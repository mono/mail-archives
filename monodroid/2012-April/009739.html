<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [mono-android] System.Linq.Dynamic
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodroid%40lists.ximian.com?Subject=Re%3A%20%5Bmono-android%5D%20System.Linq.Dynamic&In-Reply-To=%3C4F883082.3050309%40veritas-vos-liberabit.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009727.html">
   <LINK REL="Next"  HREF="009752.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mono-android] System.Linq.Dynamic</H1>
    <B>Atsushi Eno</B> 
    <A HREF="mailto:monodroid%40lists.ximian.com?Subject=Re%3A%20%5Bmono-android%5D%20System.Linq.Dynamic&In-Reply-To=%3C4F883082.3050309%40veritas-vos-liberabit.com%3E"
       TITLE="[mono-android] System.Linq.Dynamic">atsushieno at veritas-vos-liberabit.com
       </A><BR>
    <I>Fri Apr 13 13:56:18 UTC 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="009727.html">[mono-android] System.Linq.Dynamic
</A></li>
        <LI>Next message: <A HREF="009752.html">[mono-android] System.Linq.Dynamic
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9739">[ date ]</a>
              <a href="thread.html#9739">[ thread ]</a>
              <a href="subject.html#9739">[ subject ]</a>
              <a href="author.html#9739">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

I think the required libraries are excluded at the linking step in 
Release configuration. I believe we need some improvements on this 
dynamic and release mode issue.

I'm not perfectly sure if this works, but could you please try this 
workaround?
1) Microsoft.Csharp.dll, Mono.CSharp.dll has to be added like this
    <A HREF="http://docs.xamarin.com/android/advanced_topics/linking#linkskip">http://docs.xamarin.com/android/advanced_topics/linking#linkskip</A>
2a) either these additional *.Dynamic classes have to be built into 
another assembly and added to the above MSBuild property, or
2b) all those types have to be marked as 
[Android.Runtime.Preserve(AllMembers=true)] , as explained at
     
<A HREF="http://docs.xamarin.com/android/advanced_topics/linking#PreserveAttribute">http://docs.xamarin.com/android/advanced_topics/linking#PreserveAttribute</A>

Thanks,
Atsushi Eno

laurar81 wrote:
&gt;<i> I used the System.Linq.Dynamic class to set the dynamic query.
</I>&gt;<i> In debugging works correctly but in release, when I set the parameter &quot;Use
</I>&gt;<i> Shared Runtime&quot; to false, the call Expression.Call reports the error &quot;No
</I>&gt;<i> such method&quot;.
</I>&gt;<i>
</I>&gt;<i> System.Linq.Dynamic
</I>&gt;<i>
</I>&gt;<i> //Copyright (C) Microsoft Corporation.  All rights reserved.
</I>&gt;<i>
</I>&gt;<i> using System;
</I>&gt;<i> using System.Collections.Generic;
</I>&gt;<i> using System.Text;
</I>&gt;<i> using System.Linq;
</I>&gt;<i> using System.Linq.Expressions;
</I>&gt;<i> using System.Reflection;
</I>&gt;<i> using System.Reflection.Emit;
</I>&gt;<i> using System.Threading;
</I>&gt;<i>
</I>&gt;<i> namespace System.Linq.Dynamic
</I>&gt;<i> {
</I>&gt;<i>      public static class DynamicQueryable
</I>&gt;<i>      {
</I>&gt;<i>          public static IQueryable&lt;T&gt;  Where&lt;T&gt;(this IQueryable&lt;T&gt;  source,
</I>&gt;<i> string predicate, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              return (IQueryable&lt;T&gt;)Where((IQueryable)source, predicate,
</I>&gt;<i> values);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static IQueryable Where(this IQueryable source, string
</I>&gt;<i> predicate, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == null) throw new ArgumentNullException(&quot;source&quot;);
</I>&gt;<i>              if (predicate == null) throw new
</I>&gt;<i> ArgumentNullException(&quot;predicate&quot;);
</I>&gt;<i>              LambdaExpression lambda =
</I>&gt;<i> DynamicExpression.ParseLambda(source.ElementType, typeof(bool), predicate,
</I>&gt;<i> values);
</I>&gt;<i>              return source.Provider.CreateQuery(
</I>&gt;<i>                  Expression.Call(
</I>&gt;<i>                      typeof(Queryable), &quot;Where&quot;,
</I>&gt;<i>                      new Type[] { source.ElementType },
</I>&gt;<i>                      source.Expression, Expression.Quote(lambda)));
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static IQueryable Select(this IQueryable source, string
</I>&gt;<i> selector, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == null) throw new ArgumentNullException(&quot;source&quot;);
</I>&gt;<i>              if (selector == null) throw new
</I>&gt;<i> ArgumentNullException(&quot;selector&quot;);
</I>&gt;<i>              LambdaExpression lambda =
</I>&gt;<i> DynamicExpression.ParseLambda(source.ElementType, null, selector, values);
</I>&gt;<i>              return source.Provider.CreateQuery(
</I>&gt;<i>                  Expression.Call(
</I>&gt;<i>                      typeof(Queryable), &quot;Select&quot;,
</I>&gt;<i>                      new Type[] { source.ElementType, lambda.Body.Type },
</I>&gt;<i>                      source.Expression, Expression.Quote(lambda)));
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static IQueryable&lt;T&gt;  OrderBy&lt;T&gt;(this IQueryable&lt;T&gt;  source,
</I>&gt;<i> string ordering, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              return (IQueryable&lt;T&gt;)OrderBy((IQueryable)source, ordering,
</I>&gt;<i> values);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static IQueryable OrderBy(this IQueryable source, string
</I>&gt;<i> ordering, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == null) throw new ArgumentNullException(&quot;source&quot;);
</I>&gt;<i>              if (ordering == null) throw new
</I>&gt;<i> ArgumentNullException(&quot;ordering&quot;);
</I>&gt;<i>              ParameterExpression[] parameters = new ParameterExpression[] {
</I>&gt;<i>                  Expression.Parameter(source.ElementType, &quot;&quot;) };
</I>&gt;<i>              ExpressionParser parser = new ExpressionParser(parameters,
</I>&gt;<i> ordering, values);
</I>&gt;<i>              IEnumerable&lt;DynamicOrdering&gt;  orderings = parser.ParseOrdering();
</I>&gt;<i>              Expression queryExpr = source.Expression;
</I>&gt;<i>              string methodAsc = &quot;OrderBy&quot;;
</I>&gt;<i>              string methodDesc = &quot;OrderByDescending&quot;;
</I>&gt;<i>              foreach (DynamicOrdering o in orderings)
</I>&gt;<i>              {
</I>&gt;<i>                  queryExpr = Expression.Call(
</I>&gt;<i>                      typeof(Queryable), o.Ascending ? methodAsc : methodDesc,
</I>&gt;<i>                      new Type[] { source.ElementType, o.Selector.Type },
</I>&gt;<i>                      queryExpr,
</I>&gt;<i> Expression.Quote(Expression.Lambda(o.Selector, parameters)));
</I>&gt;<i>                  methodAsc = &quot;ThenBy&quot;;
</I>&gt;<i>                  methodDesc = &quot;ThenByDescending&quot;;
</I>&gt;<i>              }
</I>&gt;<i>              return source.Provider.CreateQuery(queryExpr);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static IQueryable Take(this IQueryable source, int count)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == null) throw new ArgumentNullException(&quot;source&quot;);
</I>&gt;<i>              return source.Provider.CreateQuery(
</I>&gt;<i>                  Expression.Call(
</I>&gt;<i>                      typeof(Queryable), &quot;Take&quot;,
</I>&gt;<i>                      new Type[] { source.ElementType },
</I>&gt;<i>                      source.Expression, Expression.Constant(count)));
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static IQueryable Skip(this IQueryable source, int count)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == null) throw new ArgumentNullException(&quot;source&quot;);
</I>&gt;<i>              return source.Provider.CreateQuery(
</I>&gt;<i>                  Expression.Call(
</I>&gt;<i>                      typeof(Queryable), &quot;Skip&quot;,
</I>&gt;<i>                      new Type[] { source.ElementType },
</I>&gt;<i>                      source.Expression, Expression.Constant(count)));
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static IQueryable GroupBy(this IQueryable source, string
</I>&gt;<i> keySelector, string elementSelector, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == null) throw new ArgumentNullException(&quot;source&quot;);
</I>&gt;<i>              if (keySelector == null) throw new
</I>&gt;<i> ArgumentNullException(&quot;keySelector&quot;);
</I>&gt;<i>              if (elementSelector == null) throw new
</I>&gt;<i> ArgumentNullException(&quot;elementSelector&quot;);
</I>&gt;<i>              LambdaExpression keyLambda =
</I>&gt;<i> DynamicExpression.ParseLambda(source.ElementType, null, keySelector,
</I>&gt;<i> values);
</I>&gt;<i>              LambdaExpression elementLambda =
</I>&gt;<i> DynamicExpression.ParseLambda(source.ElementType, null, elementSelector,
</I>&gt;<i> values);
</I>&gt;<i>              return source.Provider.CreateQuery(
</I>&gt;<i>                  Expression.Call(
</I>&gt;<i>                      typeof(Queryable), &quot;GroupBy&quot;,
</I>&gt;<i>                      new Type[] { source.ElementType, keyLambda.Body.Type,
</I>&gt;<i> elementLambda.Body.Type },
</I>&gt;<i>                      source.Expression, Expression.Quote(keyLambda),
</I>&gt;<i> Expression.Quote(elementLambda)));
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static bool Any(this IQueryable source)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == null) throw new ArgumentNullException(&quot;source&quot;);
</I>&gt;<i>              return (bool)source.Provider.Execute(
</I>&gt;<i>                  Expression.Call(
</I>&gt;<i>                      typeof(Queryable), &quot;Any&quot;,
</I>&gt;<i>                      new Type[] { source.ElementType }, source.Expression));
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static int Count(this IQueryable source)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == null) throw new ArgumentNullException(&quot;source&quot;);
</I>&gt;<i>              return (int)source.Provider.Execute(
</I>&gt;<i>                  Expression.Call(
</I>&gt;<i>                      typeof(Queryable), &quot;Count&quot;,
</I>&gt;<i>                      new Type[] { source.ElementType }, source.Expression));
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      public abstract class DynamicClass
</I>&gt;<i>      {
</I>&gt;<i>          public override string ToString()
</I>&gt;<i>          {
</I>&gt;<i>              PropertyInfo[] props =
</I>&gt;<i> this.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public);
</I>&gt;<i>              StringBuilder sb = new StringBuilder();
</I>&gt;<i>              sb.Append(&quot;{&quot;);
</I>&gt;<i>              for (int i = 0; i&lt;  props.Length; i++)
</I>&gt;<i>              {
</I>&gt;<i>                  if (i&gt;  0) sb.Append(&quot;, &quot;);
</I>&gt;<i>                  sb.Append(props[i].Name);
</I>&gt;<i>                  sb.Append(&quot;=&quot;);
</I>&gt;<i>                  sb.Append(props[i].GetValue(this, null));
</I>&gt;<i>              }
</I>&gt;<i>              sb.Append(&quot;}&quot;);
</I>&gt;<i>              return sb.ToString();
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      public class DynamicProperty
</I>&gt;<i>      {
</I>&gt;<i>          string name;
</I>&gt;<i>          Type type;
</I>&gt;<i>
</I>&gt;<i>          public DynamicProperty(string name, Type type)
</I>&gt;<i>          {
</I>&gt;<i>              if (name == null) throw new ArgumentNullException(&quot;name&quot;);
</I>&gt;<i>              if (type == null) throw new ArgumentNullException(&quot;type&quot;);
</I>&gt;<i>              this.name = name;
</I>&gt;<i>              this.type = type;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public string Name
</I>&gt;<i>          {
</I>&gt;<i>              get { return name; }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public Type Type
</I>&gt;<i>          {
</I>&gt;<i>              get { return type; }
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      public static class DynamicExpression
</I>&gt;<i>      {
</I>&gt;<i>          public static Expression Parse(Type resultType, string expression,
</I>&gt;<i> params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              ExpressionParser parser = new ExpressionParser(null, expression,
</I>&gt;<i> values);
</I>&gt;<i>              return parser.Parse(resultType);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static LambdaExpression ParseLambda(Type itType, Type
</I>&gt;<i> resultType, string expression, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              return ParseLambda(new ParameterExpression[] {
</I>&gt;<i> Expression.Parameter(itType, &quot;&quot;) }, resultType, expression, values);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static LambdaExpression ParseLambda(ParameterExpression[]
</I>&gt;<i> parameters, Type resultType, string expression, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              ExpressionParser parser = new ExpressionParser(parameters,
</I>&gt;<i> expression, values);
</I>&gt;<i>              return Expression.Lambda(parser.Parse(resultType), parameters);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static Expression&lt;Func&lt;T, S&gt;&gt;  ParseLambda&lt;T, S&gt;(string
</I>&gt;<i> expression, params object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              return (Expression&lt;Func&lt;T, S&gt;&gt;)ParseLambda(typeof(T),
</I>&gt;<i> typeof(S), expression, values);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static Type CreateClass(params DynamicProperty[] properties)
</I>&gt;<i>          {
</I>&gt;<i>              return ClassFactory.Instance.GetDynamicClass(properties);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public static Type CreateClass(IEnumerable&lt;DynamicProperty&gt;
</I>&gt;<i> properties)
</I>&gt;<i>          {
</I>&gt;<i>              return ClassFactory.Instance.GetDynamicClass(properties);
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      internal class DynamicOrdering
</I>&gt;<i>      {
</I>&gt;<i>          public Expression Selector;
</I>&gt;<i>          public bool Ascending;
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      internal class Signature : IEquatable&lt;Signature&gt;
</I>&gt;<i>      {
</I>&gt;<i>          public DynamicProperty[] properties;
</I>&gt;<i>          public int hashCode;
</I>&gt;<i>
</I>&gt;<i>          public Signature(IEnumerable&lt;DynamicProperty&gt;  properties)
</I>&gt;<i>          {
</I>&gt;<i>              this.properties = properties.ToArray();
</I>&gt;<i>              hashCode = 0;
</I>&gt;<i>              foreach (DynamicProperty p in properties)
</I>&gt;<i>              {
</I>&gt;<i>                  hashCode ^= p.Name.GetHashCode() ^ p.Type.GetHashCode();
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public override int GetHashCode()
</I>&gt;<i>          {
</I>&gt;<i>              return hashCode;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public override bool Equals(object obj)
</I>&gt;<i>          {
</I>&gt;<i>              return obj is Signature ? Equals((Signature)obj) : false;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public bool Equals(Signature other)
</I>&gt;<i>          {
</I>&gt;<i>              if (properties.Length != other.properties.Length) return false;
</I>&gt;<i>              for (int i = 0; i&lt;  properties.Length; i++)
</I>&gt;<i>              {
</I>&gt;<i>                  if (properties[i].Name != other.properties[i].Name ||
</I>&gt;<i>                      properties[i].Type != other.properties[i].Type) return
</I>&gt;<i> false;
</I>&gt;<i>              }
</I>&gt;<i>              return true;
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      internal class ClassFactory
</I>&gt;<i>      {
</I>&gt;<i>          public static readonly ClassFactory Instance = new ClassFactory();
</I>&gt;<i>
</I>&gt;<i>          static ClassFactory() { }  // Trigger lazy initialization of static
</I>&gt;<i> fields
</I>&gt;<i>
</I>&gt;<i>          ModuleBuilder module;
</I>&gt;<i>          Dictionary&lt;Signature, Type&gt;  classes;
</I>&gt;<i>          int classCount;
</I>&gt;<i>          ReaderWriterLock rwLock;
</I>&gt;<i>
</I>&gt;<i>          private ClassFactory()
</I>&gt;<i>          {
</I>&gt;<i>              AssemblyName name = new AssemblyName(&quot;DynamicClasses&quot;);
</I>&gt;<i>              AssemblyBuilder assembly =
</I>&gt;<i> AppDomain.CurrentDomain.DefineDynamicAssembly(name,
</I>&gt;<i> AssemblyBuilderAccess.Run);
</I>&gt;<i> #if ENABLE_LINQ_PARTIAL_TRUST
</I>&gt;<i>              new ReflectionPermission(PermissionState.Unrestricted).Assert();
</I>&gt;<i> #endif
</I>&gt;<i>              try
</I>&gt;<i>              {
</I>&gt;<i>                  module = assembly.DefineDynamicModule(&quot;Module&quot;);
</I>&gt;<i>              }
</I>&gt;<i>              finally
</I>&gt;<i>              {
</I>&gt;<i> #if ENABLE_LINQ_PARTIAL_TRUST
</I>&gt;<i>                  PermissionSet.RevertAssert();
</I>&gt;<i> #endif
</I>&gt;<i>              }
</I>&gt;<i>              classes = new Dictionary&lt;Signature, Type&gt;();
</I>&gt;<i>              rwLock = new ReaderWriterLock();
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public Type GetDynamicClass(IEnumerable&lt;DynamicProperty&gt;  properties)
</I>&gt;<i>          {
</I>&gt;<i>              rwLock.AcquireReaderLock(Timeout.Infinite);
</I>&gt;<i>              try
</I>&gt;<i>              {
</I>&gt;<i>                  Signature signature = new Signature(properties);
</I>&gt;<i>                  Type type;
</I>&gt;<i>                  if (!classes.TryGetValue(signature, out type))
</I>&gt;<i>                  {
</I>&gt;<i>                      type = CreateDynamicClass(signature.properties);
</I>&gt;<i>                      classes.Add(signature, type);
</I>&gt;<i>                  }
</I>&gt;<i>                  return type;
</I>&gt;<i>              }
</I>&gt;<i>              finally
</I>&gt;<i>              {
</I>&gt;<i>                  rwLock.ReleaseReaderLock();
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Type CreateDynamicClass(DynamicProperty[] properties)
</I>&gt;<i>          {
</I>&gt;<i>              LockCookie cookie =
</I>&gt;<i> rwLock.UpgradeToWriterLock(Timeout.Infinite);
</I>&gt;<i>              try
</I>&gt;<i>              {
</I>&gt;<i>                  string typeName = &quot;DynamicClass&quot; + (classCount + 1);
</I>&gt;<i> #if ENABLE_LINQ_PARTIAL_TRUST
</I>&gt;<i>                  new
</I>&gt;<i> ReflectionPermission(PermissionState.Unrestricted).Assert();
</I>&gt;<i> #endif
</I>&gt;<i>                  try
</I>&gt;<i>                  {
</I>&gt;<i>                      TypeBuilder tb = this.module.DefineType(typeName,
</I>&gt;<i> TypeAttributes.Class |
</I>&gt;<i>                          TypeAttributes.Public, typeof(DynamicClass));
</I>&gt;<i>                      FieldInfo[] fields = GenerateProperties(tb, properties);
</I>&gt;<i>                      GenerateEquals(tb, fields);
</I>&gt;<i>                      GenerateGetHashCode(tb, fields);
</I>&gt;<i>                      Type result = tb.CreateType();
</I>&gt;<i>                      classCount++;
</I>&gt;<i>                      return result;
</I>&gt;<i>                  }
</I>&gt;<i>                  finally
</I>&gt;<i>                  {
</I>&gt;<i> #if ENABLE_LINQ_PARTIAL_TRUST
</I>&gt;<i>                      PermissionSet.RevertAssert();
</I>&gt;<i> #endif
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              finally
</I>&gt;<i>              {
</I>&gt;<i>                  rwLock.DowngradeFromWriterLock(ref cookie);
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          FieldInfo[] GenerateProperties(TypeBuilder tb, DynamicProperty[]
</I>&gt;<i> properties)
</I>&gt;<i>          {
</I>&gt;<i>              FieldInfo[] fields = new FieldBuilder[properties.Length];
</I>&gt;<i>              for (int i = 0; i&lt;  properties.Length; i++)
</I>&gt;<i>              {
</I>&gt;<i>                  DynamicProperty dp = properties[i];
</I>&gt;<i>                  FieldBuilder fb = tb.DefineField(&quot;_&quot; + dp.Name, dp.Type,
</I>&gt;<i> FieldAttributes.Private);
</I>&gt;<i>                  PropertyBuilder pb = tb.DefineProperty(dp.Name,
</I>&gt;<i> PropertyAttributes.HasDefault, dp.Type, null);
</I>&gt;<i>                  MethodBuilder mbGet = tb.DefineMethod(&quot;get_&quot; + dp.Name,
</I>&gt;<i>                      MethodAttributes.Public | MethodAttributes.SpecialName |
</I>&gt;<i> MethodAttributes.HideBySig,
</I>&gt;<i>                      dp.Type, Type.EmptyTypes);
</I>&gt;<i>                  ILGenerator genGet = mbGet.GetILGenerator();
</I>&gt;<i>                  genGet.Emit(OpCodes.Ldarg_0);
</I>&gt;<i>                  genGet.Emit(OpCodes.Ldfld, fb);
</I>&gt;<i>                  genGet.Emit(OpCodes.Ret);
</I>&gt;<i>                  MethodBuilder mbSet = tb.DefineMethod(&quot;set_&quot; + dp.Name,
</I>&gt;<i>                      MethodAttributes.Public | MethodAttributes.SpecialName |
</I>&gt;<i> MethodAttributes.HideBySig,
</I>&gt;<i>                      null, new Type[] { dp.Type });
</I>&gt;<i>                  ILGenerator genSet = mbSet.GetILGenerator();
</I>&gt;<i>                  genSet.Emit(OpCodes.Ldarg_0);
</I>&gt;<i>                  genSet.Emit(OpCodes.Ldarg_1);
</I>&gt;<i>                  genSet.Emit(OpCodes.Stfld, fb);
</I>&gt;<i>                  genSet.Emit(OpCodes.Ret);
</I>&gt;<i>                  pb.SetGetMethod(mbGet);
</I>&gt;<i>                  pb.SetSetMethod(mbSet);
</I>&gt;<i>                  fields[i] = fb;
</I>&gt;<i>              }
</I>&gt;<i>              return fields;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void GenerateEquals(TypeBuilder tb, FieldInfo[] fields)
</I>&gt;<i>          {
</I>&gt;<i>              MethodBuilder mb = tb.DefineMethod(&quot;Equals&quot;,
</I>&gt;<i>                  MethodAttributes.Public | MethodAttributes.ReuseSlot |
</I>&gt;<i>                  MethodAttributes.Virtual | MethodAttributes.HideBySig,
</I>&gt;<i>                  typeof(bool), new Type[] { typeof(object) });
</I>&gt;<i>              ILGenerator gen = mb.GetILGenerator();
</I>&gt;<i>              LocalBuilder other = gen.DeclareLocal(tb);
</I>&gt;<i>              Label next = gen.DefineLabel();
</I>&gt;<i>              gen.Emit(OpCodes.Ldarg_1);
</I>&gt;<i>              gen.Emit(OpCodes.Isinst, tb);
</I>&gt;<i>              gen.Emit(OpCodes.Stloc, other);
</I>&gt;<i>              gen.Emit(OpCodes.Ldloc, other);
</I>&gt;<i>              gen.Emit(OpCodes.Brtrue_S, next);
</I>&gt;<i>              gen.Emit(OpCodes.Ldc_I4_0);
</I>&gt;<i>              gen.Emit(OpCodes.Ret);
</I>&gt;<i>              gen.MarkLabel(next);
</I>&gt;<i>              foreach (FieldInfo field in fields)
</I>&gt;<i>              {
</I>&gt;<i>                  Type ft = field.FieldType;
</I>&gt;<i>                  Type ct = typeof(EqualityComparer&lt;&gt;).MakeGenericType(ft);
</I>&gt;<i>                  next = gen.DefineLabel();
</I>&gt;<i>                  gen.EmitCall(OpCodes.Call, ct.GetMethod(&quot;get_Default&quot;),
</I>&gt;<i> null);
</I>&gt;<i>                  gen.Emit(OpCodes.Ldarg_0);
</I>&gt;<i>                  gen.Emit(OpCodes.Ldfld, field);
</I>&gt;<i>                  gen.Emit(OpCodes.Ldloc, other);
</I>&gt;<i>                  gen.Emit(OpCodes.Ldfld, field);
</I>&gt;<i>                  gen.EmitCall(OpCodes.Callvirt, ct.GetMethod(&quot;Equals&quot;, new
</I>&gt;<i> Type[] { ft, ft }), null);
</I>&gt;<i>                  gen.Emit(OpCodes.Brtrue_S, next);
</I>&gt;<i>                  gen.Emit(OpCodes.Ldc_I4_0);
</I>&gt;<i>                  gen.Emit(OpCodes.Ret);
</I>&gt;<i>                  gen.MarkLabel(next);
</I>&gt;<i>              }
</I>&gt;<i>              gen.Emit(OpCodes.Ldc_I4_1);
</I>&gt;<i>              gen.Emit(OpCodes.Ret);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void GenerateGetHashCode(TypeBuilder tb, FieldInfo[] fields)
</I>&gt;<i>          {
</I>&gt;<i>              MethodBuilder mb = tb.DefineMethod(&quot;GetHashCode&quot;,
</I>&gt;<i>                  MethodAttributes.Public | MethodAttributes.ReuseSlot |
</I>&gt;<i>                  MethodAttributes.Virtual | MethodAttributes.HideBySig,
</I>&gt;<i>                  typeof(int), Type.EmptyTypes);
</I>&gt;<i>              ILGenerator gen = mb.GetILGenerator();
</I>&gt;<i>              gen.Emit(OpCodes.Ldc_I4_0);
</I>&gt;<i>              foreach (FieldInfo field in fields)
</I>&gt;<i>              {
</I>&gt;<i>                  Type ft = field.FieldType;
</I>&gt;<i>                  Type ct = typeof(EqualityComparer&lt;&gt;).MakeGenericType(ft);
</I>&gt;<i>                  gen.EmitCall(OpCodes.Call, ct.GetMethod(&quot;get_Default&quot;),
</I>&gt;<i> null);
</I>&gt;<i>                  gen.Emit(OpCodes.Ldarg_0);
</I>&gt;<i>                  gen.Emit(OpCodes.Ldfld, field);
</I>&gt;<i>                  gen.EmitCall(OpCodes.Callvirt, ct.GetMethod(&quot;GetHashCode&quot;,
</I>&gt;<i> new Type[] { ft }), null);
</I>&gt;<i>                  gen.Emit(OpCodes.Xor);
</I>&gt;<i>              }
</I>&gt;<i>              gen.Emit(OpCodes.Ret);
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      public sealed class ParseException : Exception
</I>&gt;<i>      {
</I>&gt;<i>          int position;
</I>&gt;<i>
</I>&gt;<i>          public ParseException(string message, int position)
</I>&gt;<i>              : base(message)
</I>&gt;<i>          {
</I>&gt;<i>              this.position = position;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public int Position
</I>&gt;<i>          {
</I>&gt;<i>              get { return position; }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public override string ToString()
</I>&gt;<i>          {
</I>&gt;<i>              return string.Format(Res.ParseExceptionFormat, Message,
</I>&gt;<i> position);
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      internal class ExpressionParser
</I>&gt;<i>      {
</I>&gt;<i>          struct Token
</I>&gt;<i>          {
</I>&gt;<i>              public TokenId id;
</I>&gt;<i>              public string text;
</I>&gt;<i>              public int pos;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          enum TokenId
</I>&gt;<i>          {
</I>&gt;<i>              Unknown,
</I>&gt;<i>              End,
</I>&gt;<i>              Identifier,
</I>&gt;<i>              StringLiteral,
</I>&gt;<i>              IntegerLiteral,
</I>&gt;<i>              RealLiteral,
</I>&gt;<i>              Exclamation,
</I>&gt;<i>              Percent,
</I>&gt;<i>              Amphersand,
</I>&gt;<i>              OpenParen,
</I>&gt;<i>              CloseParen,
</I>&gt;<i>              Asterisk,
</I>&gt;<i>              Plus,
</I>&gt;<i>              Comma,
</I>&gt;<i>              Minus,
</I>&gt;<i>              Dot,
</I>&gt;<i>              Slash,
</I>&gt;<i>              Colon,
</I>&gt;<i>              LessThan,
</I>&gt;<i>              Equal,
</I>&gt;<i>              GreaterThan,
</I>&gt;<i>              Question,
</I>&gt;<i>              OpenBracket,
</I>&gt;<i>              CloseBracket,
</I>&gt;<i>              Bar,
</I>&gt;<i>              ExclamationEqual,
</I>&gt;<i>              DoubleAmphersand,
</I>&gt;<i>              LessThanEqual,
</I>&gt;<i>              LessGreater,
</I>&gt;<i>              DoubleEqual,
</I>&gt;<i>              GreaterThanEqual,
</I>&gt;<i>              DoubleBar
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface ILogicalSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void F(bool x, bool y);
</I>&gt;<i>              void F(bool? x, bool? y);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface IArithmeticSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void F(int x, int y);
</I>&gt;<i>              void F(uint x, uint y);
</I>&gt;<i>              void F(long x, long y);
</I>&gt;<i>              void F(ulong x, ulong y);
</I>&gt;<i>              void F(float x, float y);
</I>&gt;<i>              void F(double x, double y);
</I>&gt;<i>              void F(decimal x, decimal y);
</I>&gt;<i>              void F(int? x, int? y);
</I>&gt;<i>              void F(uint? x, uint? y);
</I>&gt;<i>              void F(long? x, long? y);
</I>&gt;<i>              void F(ulong? x, ulong? y);
</I>&gt;<i>              void F(float? x, float? y);
</I>&gt;<i>              void F(double? x, double? y);
</I>&gt;<i>              void F(decimal? x, decimal? y);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface IRelationalSignatures : IArithmeticSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void F(string x, string y);
</I>&gt;<i>              void F(char x, char y);
</I>&gt;<i>              void F(DateTime x, DateTime y);
</I>&gt;<i>              void F(TimeSpan x, TimeSpan y);
</I>&gt;<i>              void F(char? x, char? y);
</I>&gt;<i>              void F(DateTime? x, DateTime? y);
</I>&gt;<i>              void F(TimeSpan? x, TimeSpan? y);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface IEqualitySignatures : IRelationalSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void F(bool x, bool y);
</I>&gt;<i>              void F(bool? x, bool? y);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface IAddSignatures : IArithmeticSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void F(DateTime x, TimeSpan y);
</I>&gt;<i>              void F(TimeSpan x, TimeSpan y);
</I>&gt;<i>              void F(DateTime? x, TimeSpan? y);
</I>&gt;<i>              void F(TimeSpan? x, TimeSpan? y);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface ISubtractSignatures : IAddSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void F(DateTime x, DateTime y);
</I>&gt;<i>              void F(DateTime? x, DateTime? y);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface INegationSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void F(int x);
</I>&gt;<i>              void F(long x);
</I>&gt;<i>              void F(float x);
</I>&gt;<i>              void F(double x);
</I>&gt;<i>              void F(decimal x);
</I>&gt;<i>              void F(int? x);
</I>&gt;<i>              void F(long? x);
</I>&gt;<i>              void F(float? x);
</I>&gt;<i>              void F(double? x);
</I>&gt;<i>              void F(decimal? x);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface INotSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void F(bool x);
</I>&gt;<i>              void F(bool? x);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          interface IEnumerableSignatures
</I>&gt;<i>          {
</I>&gt;<i>              void Where(bool predicate);
</I>&gt;<i>              void Any();
</I>&gt;<i>              void Any(bool predicate);
</I>&gt;<i>              void All(bool predicate);
</I>&gt;<i>              void Count();
</I>&gt;<i>              void Count(bool predicate);
</I>&gt;<i>              void Min(object selector);
</I>&gt;<i>              void Max(object selector);
</I>&gt;<i>              void Sum(int selector);
</I>&gt;<i>              void Sum(int? selector);
</I>&gt;<i>              void Sum(long selector);
</I>&gt;<i>              void Sum(long? selector);
</I>&gt;<i>              void Sum(float selector);
</I>&gt;<i>              void Sum(float? selector);
</I>&gt;<i>              void Sum(double selector);
</I>&gt;<i>              void Sum(double? selector);
</I>&gt;<i>              void Sum(decimal selector);
</I>&gt;<i>              void Sum(decimal? selector);
</I>&gt;<i>              void Average(int selector);
</I>&gt;<i>              void Average(int? selector);
</I>&gt;<i>              void Average(long selector);
</I>&gt;<i>              void Average(long? selector);
</I>&gt;<i>              void Average(float selector);
</I>&gt;<i>              void Average(float? selector);
</I>&gt;<i>              void Average(double selector);
</I>&gt;<i>              void Average(double? selector);
</I>&gt;<i>              void Average(decimal selector);
</I>&gt;<i>              void Average(decimal? selector);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static readonly Type[] predefinedTypes = {
</I>&gt;<i>              typeof(Object),
</I>&gt;<i>              typeof(Boolean),
</I>&gt;<i>              typeof(Char),
</I>&gt;<i>              typeof(String),
</I>&gt;<i>              typeof(SByte),
</I>&gt;<i>              typeof(Byte),
</I>&gt;<i>              typeof(Int16),
</I>&gt;<i>              typeof(UInt16),
</I>&gt;<i>              typeof(Int32),
</I>&gt;<i>              typeof(UInt32),
</I>&gt;<i>              typeof(Int64),
</I>&gt;<i>              typeof(UInt64),
</I>&gt;<i>              typeof(Single),
</I>&gt;<i>              typeof(Double),
</I>&gt;<i>              typeof(Decimal),
</I>&gt;<i>              typeof(DateTime),
</I>&gt;<i>              typeof(TimeSpan),
</I>&gt;<i>              typeof(Guid),
</I>&gt;<i>              typeof(Math),
</I>&gt;<i>              typeof(Convert)
</I>&gt;<i>          };
</I>&gt;<i>
</I>&gt;<i>          static readonly Expression trueLiteral = Expression.Constant(true);
</I>&gt;<i>          static readonly Expression falseLiteral =
</I>&gt;<i> Expression.Constant(false);
</I>&gt;<i>          static readonly Expression nullLiteral = Expression.Constant(null);
</I>&gt;<i>
</I>&gt;<i>          static readonly string keywordIt = &quot;it&quot;;
</I>&gt;<i>          static readonly string keywordIif = &quot;iif&quot;;
</I>&gt;<i>          static readonly string keywordNew = &quot;new&quot;;
</I>&gt;<i>
</I>&gt;<i>          static Dictionary&lt;string, object&gt;  keywords;
</I>&gt;<i>
</I>&gt;<i>          Dictionary&lt;string, object&gt;  symbols;
</I>&gt;<i>          IDictionary&lt;string, object&gt;  externals;
</I>&gt;<i>          Dictionary&lt;Expression, string&gt;  literals;
</I>&gt;<i>          ParameterExpression it;
</I>&gt;<i>          string text;
</I>&gt;<i>          int textPos;
</I>&gt;<i>          int textLen;
</I>&gt;<i>          char ch;
</I>&gt;<i>          Token token;
</I>&gt;<i>
</I>&gt;<i>          public ExpressionParser(ParameterExpression[] parameters, string
</I>&gt;<i> expression, object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              if (expression == null) throw new
</I>&gt;<i> ArgumentNullException(&quot;expression&quot;);
</I>&gt;<i>              if (keywords == null) keywords = CreateKeywords();
</I>&gt;<i>              symbols = new Dictionary&lt;string,
</I>&gt;<i> object&gt;(StringComparer.OrdinalIgnoreCase);
</I>&gt;<i>              literals = new Dictionary&lt;Expression, string&gt;();
</I>&gt;<i>              if (parameters != null) ProcessParameters(parameters);
</I>&gt;<i>              if (values != null) ProcessValues(values);
</I>&gt;<i>              text = expression;
</I>&gt;<i>              textLen = text.Length;
</I>&gt;<i>              SetTextPos(0);
</I>&gt;<i>              NextToken();
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void ProcessParameters(ParameterExpression[] parameters)
</I>&gt;<i>          {
</I>&gt;<i>              foreach (ParameterExpression pe in parameters)
</I>&gt;<i>                  if (!String.IsNullOrEmpty(pe.Name))
</I>&gt;<i>                      AddSymbol(pe.Name, pe);
</I>&gt;<i>              if (parameters.Length == 1&amp;&amp;
</I>&gt;<i> String.IsNullOrEmpty(parameters[0].Name))
</I>&gt;<i>                  it = parameters[0];
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void ProcessValues(object[] values)
</I>&gt;<i>          {
</I>&gt;<i>              for (int i = 0; i&lt;  values.Length; i++)
</I>&gt;<i>              {
</I>&gt;<i>                  object value = values[i];
</I>&gt;<i>                  if (i == values.Length - 1&amp;&amp;  value is IDictionary&lt;string,
</I>&gt;<i> object&gt;)
</I>&gt;<i>                  {
</I>&gt;<i>                      externals = (IDictionary&lt;string, object&gt;)value;
</I>&gt;<i>                  }
</I>&gt;<i>                  else
</I>&gt;<i>                  {
</I>&gt;<i>                      AddSymbol(&quot;@&quot; +
</I>&gt;<i> i.ToString(System.Globalization.CultureInfo.InvariantCulture), value);
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void AddSymbol(string name, object value)
</I>&gt;<i>          {
</I>&gt;<i>              if (symbols.ContainsKey(name))
</I>&gt;<i>                  throw ParseError(Res.DuplicateIdentifier, name);
</I>&gt;<i>              symbols.Add(name, value);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          public Expression Parse(Type resultType)
</I>&gt;<i>          {
</I>&gt;<i>              int exprPos = token.pos;
</I>&gt;<i>              Expression expr = ParseExpression();
</I>&gt;<i>              if (resultType != null)
</I>&gt;<i>                  if ((expr = PromoteExpression(expr, resultType, true)) ==
</I>&gt;<i> null)
</I>&gt;<i>                      throw ParseError(exprPos, Res.ExpressionTypeMismatch,
</I>&gt;<i> GetTypeName(resultType));
</I>&gt;<i>              ValidateToken(TokenId.End, Res.SyntaxError);
</I>&gt;<i>              return expr;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i> #pragma warning disable 0219
</I>&gt;<i>          public IEnumerable&lt;DynamicOrdering&gt;  ParseOrdering()
</I>&gt;<i>          {
</I>&gt;<i>              List&lt;DynamicOrdering&gt;  orderings = new List&lt;DynamicOrdering&gt;();
</I>&gt;<i>              while (true)
</I>&gt;<i>              {
</I>&gt;<i>                  Expression expr = ParseExpression();
</I>&gt;<i>                  bool ascending = true;
</I>&gt;<i>                  if (TokenIdentifierIs(&quot;asc&quot;) ||
</I>&gt;<i> TokenIdentifierIs(&quot;ascending&quot;))
</I>&gt;<i>                  {
</I>&gt;<i>                      NextToken();
</I>&gt;<i>                  }
</I>&gt;<i>                  else if (TokenIdentifierIs(&quot;desc&quot;) ||
</I>&gt;<i> TokenIdentifierIs(&quot;descending&quot;))
</I>&gt;<i>                  {
</I>&gt;<i>                      NextToken();
</I>&gt;<i>                      ascending = false;
</I>&gt;<i>                  }
</I>&gt;<i>                  orderings.Add(new DynamicOrdering { Selector = expr,
</I>&gt;<i> Ascending = ascending });
</I>&gt;<i>                  if (token.id != TokenId.Comma) break;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>              }
</I>&gt;<i>              ValidateToken(TokenId.End, Res.SyntaxError);
</I>&gt;<i>              return orderings;
</I>&gt;<i>          }
</I>&gt;<i> #pragma warning restore 0219
</I>&gt;<i>
</I>&gt;<i>          // ?: operator
</I>&gt;<i>          Expression ParseExpression()
</I>&gt;<i>          {
</I>&gt;<i>              int errorPos = token.pos;
</I>&gt;<i>              Expression expr = ParseLogicalOr();
</I>&gt;<i>              if (token.id == TokenId.Question)
</I>&gt;<i>              {
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  Expression expr1 = ParseExpression();
</I>&gt;<i>                  ValidateToken(TokenId.Colon, Res.ColonExpected);
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  Expression expr2 = ParseExpression();
</I>&gt;<i>                  expr = GenerateConditional(expr, expr1, expr2, errorPos);
</I>&gt;<i>              }
</I>&gt;<i>              return expr;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          // ||, or operator
</I>&gt;<i>          Expression ParseLogicalOr()
</I>&gt;<i>          {
</I>&gt;<i>              Expression left = ParseLogicalAnd();
</I>&gt;<i>              while (token.id == TokenId.DoubleBar || TokenIdentifierIs(&quot;or&quot;))
</I>&gt;<i>              {
</I>&gt;<i>                  Token op = token;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  Expression right = ParseLogicalAnd();
</I>&gt;<i>                  CheckAndPromoteOperands(typeof(ILogicalSignatures), op.text,
</I>&gt;<i> ref left, ref right, op.pos);
</I>&gt;<i>                  left = Expression.OrElse(left, right);
</I>&gt;<i>              }
</I>&gt;<i>              return left;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          //&amp;&amp;, and operator
</I>&gt;<i>          Expression ParseLogicalAnd()
</I>&gt;<i>          {
</I>&gt;<i>              Expression left = ParseComparison();
</I>&gt;<i>              while (token.id == TokenId.DoubleAmphersand ||
</I>&gt;<i> TokenIdentifierIs(&quot;and&quot;))
</I>&gt;<i>              {
</I>&gt;<i>                  Token op = token;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  Expression right = ParseComparison();
</I>&gt;<i>                  CheckAndPromoteOperands(typeof(ILogicalSignatures), op.text,
</I>&gt;<i> ref left, ref right, op.pos);
</I>&gt;<i>                  left = Expression.AndAlso(left, right);
</I>&gt;<i>              }
</I>&gt;<i>              return left;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          // =, ==, !=,&lt;&gt;,&gt;,&gt;=,&lt;,&lt;= operators
</I>&gt;<i>          Expression ParseComparison()
</I>&gt;<i>          {
</I>&gt;<i>              Expression left = ParseAdditive();
</I>&gt;<i>              while (token.id == TokenId.Equal || token.id ==
</I>&gt;<i> TokenId.DoubleEqual ||
</I>&gt;<i>                  token.id == TokenId.ExclamationEqual || token.id ==
</I>&gt;<i> TokenId.LessGreater ||
</I>&gt;<i>                  token.id == TokenId.GreaterThan || token.id ==
</I>&gt;<i> TokenId.GreaterThanEqual ||
</I>&gt;<i>                  token.id == TokenId.LessThan || token.id ==
</I>&gt;<i> TokenId.LessThanEqual)
</I>&gt;<i>              {
</I>&gt;<i>                  Token op = token;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  Expression right = ParseAdditive();
</I>&gt;<i>                  bool isEquality = op.id == TokenId.Equal || op.id ==
</I>&gt;<i> TokenId.DoubleEqual ||
</I>&gt;<i>                      op.id == TokenId.ExclamationEqual || op.id ==
</I>&gt;<i> TokenId.LessGreater;
</I>&gt;<i>                  if (isEquality&amp;&amp;  !left.Type.IsValueType&amp;&amp;
</I>&gt;<i> !right.Type.IsValueType)
</I>&gt;<i>                  {
</I>&gt;<i>                      if (left.Type != right.Type)
</I>&gt;<i>                      {
</I>&gt;<i>                          if (left.Type.IsAssignableFrom(right.Type))
</I>&gt;<i>                          {
</I>&gt;<i>                              right = Expression.Convert(right, left.Type);
</I>&gt;<i>                          }
</I>&gt;<i>                          else if (right.Type.IsAssignableFrom(left.Type))
</I>&gt;<i>                          {
</I>&gt;<i>                              left = Expression.Convert(left, right.Type);
</I>&gt;<i>                          }
</I>&gt;<i>                          else
</I>&gt;<i>                          {
</I>&gt;<i>                              throw IncompatibleOperandsError(op.text, left,
</I>&gt;<i> right, op.pos);
</I>&gt;<i>                          }
</I>&gt;<i>                      }
</I>&gt;<i>                  }
</I>&gt;<i>                  else if (IsEnumType(left.Type) || IsEnumType(right.Type))
</I>&gt;<i>                  {
</I>&gt;<i>                      if (left.Type != right.Type)
</I>&gt;<i>                      {
</I>&gt;<i>                          Expression e;
</I>&gt;<i>                          if ((e = PromoteExpression(right, left.Type, true))
</I>&gt;<i> != null)
</I>&gt;<i>                          {
</I>&gt;<i>                              right = e;
</I>&gt;<i>                          }
</I>&gt;<i>                          else if ((e = PromoteExpression(left, right.Type,
</I>&gt;<i> true)) != null)
</I>&gt;<i>                          {
</I>&gt;<i>                              left = e;
</I>&gt;<i>                          }
</I>&gt;<i>                          else
</I>&gt;<i>                          {
</I>&gt;<i>                              throw IncompatibleOperandsError(op.text, left,
</I>&gt;<i> right, op.pos);
</I>&gt;<i>                          }
</I>&gt;<i>                      }
</I>&gt;<i>                  }
</I>&gt;<i>                  else
</I>&gt;<i>                  {
</I>&gt;<i>                      CheckAndPromoteOperands(isEquality ?
</I>&gt;<i> typeof(IEqualitySignatures) : typeof(IRelationalSignatures),
</I>&gt;<i>                          op.text, ref left, ref right, op.pos);
</I>&gt;<i>                  }
</I>&gt;<i>                  switch (op.id)
</I>&gt;<i>                  {
</I>&gt;<i>                      case TokenId.Equal:
</I>&gt;<i>                      case TokenId.DoubleEqual:
</I>&gt;<i>                          left = GenerateEqual(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.ExclamationEqual:
</I>&gt;<i>                      case TokenId.LessGreater:
</I>&gt;<i>                          left = GenerateNotEqual(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.GreaterThan:
</I>&gt;<i>                          left = GenerateGreaterThan(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.GreaterThanEqual:
</I>&gt;<i>                          left = GenerateGreaterThanEqual(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.LessThan:
</I>&gt;<i>                          left = GenerateLessThan(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.LessThanEqual:
</I>&gt;<i>                          left = GenerateLessThanEqual(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              return left;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          // +, -,&amp;  operators
</I>&gt;<i>          Expression ParseAdditive()
</I>&gt;<i>          {
</I>&gt;<i>              Expression left = ParseMultiplicative();
</I>&gt;<i>              while (token.id == TokenId.Plus || token.id == TokenId.Minus ||
</I>&gt;<i>                  token.id == TokenId.Amphersand)
</I>&gt;<i>              {
</I>&gt;<i>                  Token op = token;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  Expression right = ParseMultiplicative();
</I>&gt;<i>                  switch (op.id)
</I>&gt;<i>                  {
</I>&gt;<i>                      case TokenId.Plus:
</I>&gt;<i>                          if (left.Type == typeof(string) || right.Type ==
</I>&gt;<i> typeof(string))
</I>&gt;<i>                              goto case TokenId.Amphersand;
</I>&gt;<i>                          CheckAndPromoteOperands(typeof(IAddSignatures),
</I>&gt;<i> op.text, ref left, ref right, op.pos);
</I>&gt;<i>                          left = GenerateAdd(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.Minus:
</I>&gt;<i>                          CheckAndPromoteOperands(typeof(ISubtractSignatures),
</I>&gt;<i> op.text, ref left, ref right, op.pos);
</I>&gt;<i>                          left = GenerateSubtract(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.Amphersand:
</I>&gt;<i>                          left = GenerateStringConcat(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              return left;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          // *, /, %, mod operators
</I>&gt;<i>          Expression ParseMultiplicative()
</I>&gt;<i>          {
</I>&gt;<i>              Expression left = ParseUnary();
</I>&gt;<i>              while (token.id == TokenId.Asterisk || token.id == TokenId.Slash
</I>&gt;<i> ||
</I>&gt;<i>                  token.id == TokenId.Percent || TokenIdentifierIs(&quot;mod&quot;))
</I>&gt;<i>              {
</I>&gt;<i>                  Token op = token;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  Expression right = ParseUnary();
</I>&gt;<i>                  CheckAndPromoteOperands(typeof(IArithmeticSignatures),
</I>&gt;<i> op.text, ref left, ref right, op.pos);
</I>&gt;<i>                  switch (op.id)
</I>&gt;<i>                  {
</I>&gt;<i>                      case TokenId.Asterisk:
</I>&gt;<i>                          left = Expression.Multiply(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.Slash:
</I>&gt;<i>                          left = Expression.Divide(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                      case TokenId.Percent:
</I>&gt;<i>                      case TokenId.Identifier:
</I>&gt;<i>                          left = Expression.Modulo(left, right);
</I>&gt;<i>                          break;
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              return left;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          // -, !, not unary operators
</I>&gt;<i>          Expression ParseUnary()
</I>&gt;<i>          {
</I>&gt;<i>              if (token.id == TokenId.Minus || token.id == TokenId.Exclamation
</I>&gt;<i> ||
</I>&gt;<i>                  TokenIdentifierIs(&quot;not&quot;))
</I>&gt;<i>              {
</I>&gt;<i>                  Token op = token;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  if (op.id == TokenId.Minus&amp;&amp;  (token.id ==
</I>&gt;<i> TokenId.IntegerLiteral ||
</I>&gt;<i>                      token.id == TokenId.RealLiteral))
</I>&gt;<i>                  {
</I>&gt;<i>                      token.text = &quot;-&quot; + token.text;
</I>&gt;<i>                      token.pos = op.pos;
</I>&gt;<i>                      return ParsePrimary();
</I>&gt;<i>                  }
</I>&gt;<i>                  Expression expr = ParseUnary();
</I>&gt;<i>                  if (op.id == TokenId.Minus)
</I>&gt;<i>                  {
</I>&gt;<i>                      CheckAndPromoteOperand(typeof(INegationSignatures),
</I>&gt;<i> op.text, ref expr, op.pos);
</I>&gt;<i>                      expr = Expression.Negate(expr);
</I>&gt;<i>                  }
</I>&gt;<i>                  else
</I>&gt;<i>                  {
</I>&gt;<i>                      CheckAndPromoteOperand(typeof(INotSignatures), op.text,
</I>&gt;<i> ref expr, op.pos);
</I>&gt;<i>                      expr = Expression.Not(expr);
</I>&gt;<i>                  }
</I>&gt;<i>                  return expr;
</I>&gt;<i>              }
</I>&gt;<i>              return ParsePrimary();
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParsePrimary()
</I>&gt;<i>          {
</I>&gt;<i>              Expression expr = ParsePrimaryStart();
</I>&gt;<i>              while (true)
</I>&gt;<i>              {
</I>&gt;<i>                  if (token.id == TokenId.Dot)
</I>&gt;<i>                  {
</I>&gt;<i>                      NextToken();
</I>&gt;<i>                      expr = ParseMemberAccess(null, expr);
</I>&gt;<i>                  }
</I>&gt;<i>                  else if (token.id == TokenId.OpenBracket)
</I>&gt;<i>                  {
</I>&gt;<i>                      expr = ParseElementAccess(expr);
</I>&gt;<i>                  }
</I>&gt;<i>                  else
</I>&gt;<i>                  {
</I>&gt;<i>                      break;
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              return expr;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParsePrimaryStart()
</I>&gt;<i>          {
</I>&gt;<i>              switch (token.id)
</I>&gt;<i>              {
</I>&gt;<i>                  case TokenId.Identifier:
</I>&gt;<i>                      return ParseIdentifier();
</I>&gt;<i>                  case TokenId.StringLiteral:
</I>&gt;<i>                      return ParseStringLiteral();
</I>&gt;<i>                  case TokenId.IntegerLiteral:
</I>&gt;<i>                      return ParseIntegerLiteral();
</I>&gt;<i>                  case TokenId.RealLiteral:
</I>&gt;<i>                      return ParseRealLiteral();
</I>&gt;<i>                  case TokenId.OpenParen:
</I>&gt;<i>                      return ParseParenExpression();
</I>&gt;<i>                  default:
</I>&gt;<i>                      throw ParseError(Res.ExpressionExpected);
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseStringLiteral()
</I>&gt;<i>          {
</I>&gt;<i>              ValidateToken(TokenId.StringLiteral);
</I>&gt;<i>              char quote = token.text[0];
</I>&gt;<i>              string s = token.text.Substring(1, token.text.Length - 2);
</I>&gt;<i>              int start = 0;
</I>&gt;<i>              while (true)
</I>&gt;<i>              {
</I>&gt;<i>                  int i = s.IndexOf(quote, start);
</I>&gt;<i>                  if (i&lt;  0) break;
</I>&gt;<i>                  s = s.Remove(i, 1);
</I>&gt;<i>                  start = i + 1;
</I>&gt;<i>              }
</I>&gt;<i>              if (quote == '\'')
</I>&gt;<i>              {
</I>&gt;<i>                  if (s.Length != 1)
</I>&gt;<i>                      throw ParseError(Res.InvalidCharacterLiteral);
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  return CreateLiteral(s[0], s);
</I>&gt;<i>              }
</I>&gt;<i>              NextToken();
</I>&gt;<i>              return CreateLiteral(s, s);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseIntegerLiteral()
</I>&gt;<i>          {
</I>&gt;<i>              ValidateToken(TokenId.IntegerLiteral);
</I>&gt;<i>              string text = token.text;
</I>&gt;<i>              if (text[0] != '-')
</I>&gt;<i>              {
</I>&gt;<i>                  ulong value;
</I>&gt;<i>                  if (!UInt64.TryParse(text, out value))
</I>&gt;<i>                      throw ParseError(Res.InvalidIntegerLiteral, text);
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  if (value&lt;= (ulong)Int32.MaxValue) return
</I>&gt;<i> CreateLiteral((int)value, text);
</I>&gt;<i>                  if (value&lt;= (ulong)UInt32.MaxValue) return
</I>&gt;<i> CreateLiteral((uint)value, text);
</I>&gt;<i>                  if (value&lt;= (ulong)Int64.MaxValue) return
</I>&gt;<i> CreateLiteral((long)value, text);
</I>&gt;<i>                  return CreateLiteral(value, text);
</I>&gt;<i>              }
</I>&gt;<i>              else
</I>&gt;<i>              {
</I>&gt;<i>                  long value;
</I>&gt;<i>                  if (!Int64.TryParse(text, out value))
</I>&gt;<i>                      throw ParseError(Res.InvalidIntegerLiteral, text);
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  if (value&gt;= Int32.MinValue&amp;&amp;  value&lt;= Int32.MaxValue)
</I>&gt;<i>                      return CreateLiteral((int)value, text);
</I>&gt;<i>                  return CreateLiteral(value, text);
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseRealLiteral()
</I>&gt;<i>          {
</I>&gt;<i>              ValidateToken(TokenId.RealLiteral);
</I>&gt;<i>              string text = token.text;
</I>&gt;<i>              object value = null;
</I>&gt;<i>              char last = text[text.Length - 1];
</I>&gt;<i>              if (last == 'F' || last == 'f')
</I>&gt;<i>              {
</I>&gt;<i>                  float f;
</I>&gt;<i>                  if (Single.TryParse(text.Substring(0, text.Length - 1), out
</I>&gt;<i> f)) value = f;
</I>&gt;<i>              }
</I>&gt;<i>              else
</I>&gt;<i>              {
</I>&gt;<i>                  double d;
</I>&gt;<i>                  if (Double.TryParse(text, out d)) value = d;
</I>&gt;<i>              }
</I>&gt;<i>              if (value == null) throw ParseError(Res.InvalidRealLiteral,
</I>&gt;<i> text);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              return CreateLiteral(value, text);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression CreateLiteral(object value, string text)
</I>&gt;<i>          {
</I>&gt;<i>              ConstantExpression expr = Expression.Constant(value);
</I>&gt;<i>              literals.Add(expr, text);
</I>&gt;<i>              return expr;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseParenExpression()
</I>&gt;<i>          {
</I>&gt;<i>              ValidateToken(TokenId.OpenParen, Res.OpenParenExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              Expression e = ParseExpression();
</I>&gt;<i>              ValidateToken(TokenId.CloseParen,
</I>&gt;<i> Res.CloseParenOrOperatorExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              return e;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseIdentifier()
</I>&gt;<i>          {
</I>&gt;<i>              ValidateToken(TokenId.Identifier);
</I>&gt;<i>              object value;
</I>&gt;<i>              if (keywords.TryGetValue(token.text, out value))
</I>&gt;<i>              {
</I>&gt;<i>                  if (value is Type) return ParseTypeAccess((Type)value);
</I>&gt;<i>                  if (value == (object)keywordIt) return ParseIt();
</I>&gt;<i>                  if (value == (object)keywordIif) return ParseIif();
</I>&gt;<i>                  if (value == (object)keywordNew) return ParseNew();
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  return (Expression)value;
</I>&gt;<i>              }
</I>&gt;<i>              if (symbols.TryGetValue(token.text, out value) ||
</I>&gt;<i>                  externals != null&amp;&amp;  externals.TryGetValue(token.text, out
</I>&gt;<i> value))
</I>&gt;<i>              {
</I>&gt;<i>                  Expression expr = value as Expression;
</I>&gt;<i>                  if (expr == null)
</I>&gt;<i>                  {
</I>&gt;<i>                      expr = Expression.Constant(value);
</I>&gt;<i>                  }
</I>&gt;<i>                  else
</I>&gt;<i>                  {
</I>&gt;<i>                      LambdaExpression lambda = expr as LambdaExpression;
</I>&gt;<i>                      if (lambda != null) return
</I>&gt;<i> ParseLambdaInvocation(lambda);
</I>&gt;<i>                  }
</I>&gt;<i>                  NextToken();
</I>&gt;<i>                  return expr;
</I>&gt;<i>              }
</I>&gt;<i>              if (it != null) return ParseMemberAccess(null, it);
</I>&gt;<i>              throw ParseError(Res.UnknownIdentifier, token.text);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseIt()
</I>&gt;<i>          {
</I>&gt;<i>              if (it == null)
</I>&gt;<i>                  throw ParseError(Res.NoItInScope);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              return it;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseIif()
</I>&gt;<i>          {
</I>&gt;<i>              int errorPos = token.pos;
</I>&gt;<i>              NextToken();
</I>&gt;<i>              Expression[] args = ParseArgumentList();
</I>&gt;<i>              if (args.Length != 3)
</I>&gt;<i>                  throw ParseError(errorPos, Res.IifRequiresThreeArgs);
</I>&gt;<i>              return GenerateConditional(args[0], args[1], args[2], errorPos);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateConditional(Expression test, Expression expr1,
</I>&gt;<i> Expression expr2, int errorPos)
</I>&gt;<i>          {
</I>&gt;<i>              if (test.Type != typeof(bool))
</I>&gt;<i>                  throw ParseError(errorPos, Res.FirstExprMustBeBool);
</I>&gt;<i>              if (expr1.Type != expr2.Type)
</I>&gt;<i>              {
</I>&gt;<i>                  Expression expr1as2 = expr2 != nullLiteral ?
</I>&gt;<i> PromoteExpression(expr1, expr2.Type, true) : null;
</I>&gt;<i>                  Expression expr2as1 = expr1 != nullLiteral ?
</I>&gt;<i> PromoteExpression(expr2, expr1.Type, true) : null;
</I>&gt;<i>                  if (expr1as2 != null&amp;&amp;  expr2as1 == null)
</I>&gt;<i>                  {
</I>&gt;<i>                      expr1 = expr1as2;
</I>&gt;<i>                  }
</I>&gt;<i>                  else if (expr2as1 != null&amp;&amp;  expr1as2 == null)
</I>&gt;<i>                  {
</I>&gt;<i>                      expr2 = expr2as1;
</I>&gt;<i>                  }
</I>&gt;<i>                  else
</I>&gt;<i>                  {
</I>&gt;<i>                      string type1 = expr1 != nullLiteral ? expr1.Type.Name :
</I>&gt;<i> &quot;null&quot;;
</I>&gt;<i>                      string type2 = expr2 != nullLiteral ? expr2.Type.Name :
</I>&gt;<i> &quot;null&quot;;
</I>&gt;<i>                      if (expr1as2 != null&amp;&amp;  expr2as1 != null)
</I>&gt;<i>                          throw ParseError(errorPos,
</I>&gt;<i> Res.BothTypesConvertToOther, type1, type2);
</I>&gt;<i>                      throw ParseError(errorPos,
</I>&gt;<i> Res.NeitherTypeConvertsToOther, type1, type2);
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              return Expression.Condition(test, expr1, expr2);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseNew()
</I>&gt;<i>          {
</I>&gt;<i>              NextToken();
</I>&gt;<i>              ValidateToken(TokenId.OpenParen, Res.OpenParenExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              List&lt;DynamicProperty&gt;  properties = new List&lt;DynamicProperty&gt;();
</I>&gt;<i>              List&lt;Expression&gt;  expressions = new List&lt;Expression&gt;();
</I>&gt;<i>              while (true)
</I>&gt;<i>              {
</I>&gt;<i>                  int exprPos = token.pos;
</I>&gt;<i>                  Expression expr = ParseExpression();
</I>&gt;<i>                  string propName;
</I>&gt;<i>                  if (TokenIdentifierIs(&quot;as&quot;))
</I>&gt;<i>                  {
</I>&gt;<i>                      NextToken();
</I>&gt;<i>                      propName = GetIdentifier();
</I>&gt;<i>                      NextToken();
</I>&gt;<i>                  }
</I>&gt;<i>                  else
</I>&gt;<i>                  {
</I>&gt;<i>                      MemberExpression me = expr as MemberExpression;
</I>&gt;<i>                      if (me == null) throw ParseError(exprPos,
</I>&gt;<i> Res.MissingAsClause);
</I>&gt;<i>                      propName = me.Member.Name;
</I>&gt;<i>                  }
</I>&gt;<i>                  expressions.Add(expr);
</I>&gt;<i>                  properties.Add(new DynamicProperty(propName, expr.Type));
</I>&gt;<i>                  if (token.id != TokenId.Comma) break;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>              }
</I>&gt;<i>              ValidateToken(TokenId.CloseParen,
</I>&gt;<i> Res.CloseParenOrCommaExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              Type type = DynamicExpression.CreateClass(properties);
</I>&gt;<i>              MemberBinding[] bindings = new MemberBinding[properties.Count];
</I>&gt;<i>              for (int i = 0; i&lt;  bindings.Length; i++)
</I>&gt;<i>                  bindings[i] =
</I>&gt;<i> Expression.Bind(type.GetProperty(properties[i].Name), expressions[i]);
</I>&gt;<i>              return Expression.MemberInit(Expression.New(type), bindings);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseLambdaInvocation(LambdaExpression lambda)
</I>&gt;<i>          {
</I>&gt;<i>              int errorPos = token.pos;
</I>&gt;<i>              NextToken();
</I>&gt;<i>              Expression[] args = ParseArgumentList();
</I>&gt;<i>              MethodBase method;
</I>&gt;<i>              if (FindMethod(lambda.Type, &quot;Invoke&quot;, false, args, out method)
</I>&gt;<i> != 1)
</I>&gt;<i>                  throw ParseError(errorPos, Res.ArgsIncompatibleWithLambda);
</I>&gt;<i>              return Expression.Invoke(lambda, args);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseTypeAccess(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              int errorPos = token.pos;
</I>&gt;<i>              NextToken();
</I>&gt;<i>              if (token.id == TokenId.Question)
</I>&gt;<i>              {
</I>&gt;<i>                  if (!type.IsValueType || IsNullableType(type))
</I>&gt;<i>                      throw ParseError(errorPos, Res.TypeHasNoNullableForm,
</I>&gt;<i> GetTypeName(type));
</I>&gt;<i>                  type = typeof(Nullable&lt;&gt;).MakeGenericType(type);
</I>&gt;<i>                  NextToken();
</I>&gt;<i>              }
</I>&gt;<i>              if (token.id == TokenId.OpenParen)
</I>&gt;<i>              {
</I>&gt;<i>                  Expression[] args = ParseArgumentList();
</I>&gt;<i>                  MethodBase method;
</I>&gt;<i>                  switch (FindBestMethod(type.GetConstructors(), args, out
</I>&gt;<i> method))
</I>&gt;<i>                  {
</I>&gt;<i>                      case 0:
</I>&gt;<i>                          if (args.Length == 1)
</I>&gt;<i>                              return GenerateConversion(args[0], type,
</I>&gt;<i> errorPos);
</I>&gt;<i>                          throw ParseError(errorPos,
</I>&gt;<i> Res.NoMatchingConstructor, GetTypeName(type));
</I>&gt;<i>                      case 1:
</I>&gt;<i>                          return Expression.New((ConstructorInfo)method,
</I>&gt;<i> args);
</I>&gt;<i>                      default:
</I>&gt;<i>                          throw ParseError(errorPos,
</I>&gt;<i> Res.AmbiguousConstructorInvocation, GetTypeName(type));
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              ValidateToken(TokenId.Dot, Res.DotOrOpenParenExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              return ParseMemberAccess(type, null);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateConversion(Expression expr, Type type, int
</I>&gt;<i> errorPos)
</I>&gt;<i>          {
</I>&gt;<i>              Type exprType = expr.Type;
</I>&gt;<i>              if (exprType == type) return expr;
</I>&gt;<i>              if (exprType.IsValueType&amp;&amp;  type.IsValueType)
</I>&gt;<i>              {
</I>&gt;<i>                  if ((IsNullableType(exprType) || IsNullableType(type))&amp;&amp;
</I>&gt;<i>                      GetNonNullableType(exprType) ==
</I>&gt;<i> GetNonNullableType(type))
</I>&gt;<i>                      return Expression.Convert(expr, type);
</I>&gt;<i>                  if ((IsNumericType(exprType) || IsEnumType(exprType))&amp;&amp;
</I>&gt;<i>                      (IsNumericType(type)) || IsEnumType(type))
</I>&gt;<i>                      return Expression.ConvertChecked(expr, type);
</I>&gt;<i>              }
</I>&gt;<i>              if (exprType.IsAssignableFrom(type) ||
</I>&gt;<i> type.IsAssignableFrom(exprType) ||
</I>&gt;<i>                  exprType.IsInterface || type.IsInterface)
</I>&gt;<i>                  return Expression.Convert(expr, type);
</I>&gt;<i>              throw ParseError(errorPos, Res.CannotConvertValue,
</I>&gt;<i>                  GetTypeName(exprType), GetTypeName(type));
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseMemberAccess(Type type, Expression instance)
</I>&gt;<i>          {
</I>&gt;<i>              if (instance != null) type = instance.Type;
</I>&gt;<i>              int errorPos = token.pos;
</I>&gt;<i>              string id = GetIdentifier();
</I>&gt;<i>              NextToken();
</I>&gt;<i>              if (token.id == TokenId.OpenParen)
</I>&gt;<i>              {
</I>&gt;<i>                  if (instance != null&amp;&amp;  type != typeof(string))
</I>&gt;<i>                  {
</I>&gt;<i>                      Type enumerableType =
</I>&gt;<i> FindGenericType(typeof(IEnumerable&lt;&gt;), type);
</I>&gt;<i>                      if (enumerableType != null)
</I>&gt;<i>                      {
</I>&gt;<i>                          Type elementType =
</I>&gt;<i> enumerableType.GetGenericArguments()[0];
</I>&gt;<i>                          return ParseAggregate(instance, elementType, id,
</I>&gt;<i> errorPos);
</I>&gt;<i>                      }
</I>&gt;<i>                  }
</I>&gt;<i>                  Expression[] args = ParseArgumentList();
</I>&gt;<i>                  MethodBase mb;
</I>&gt;<i>                  switch (FindMethod(type, id, instance == null, args, out
</I>&gt;<i> mb))
</I>&gt;<i>                  {
</I>&gt;<i>                      case 0:
</I>&gt;<i>                          throw ParseError(errorPos, Res.NoApplicableMethod,
</I>&gt;<i>                              id, GetTypeName(type));
</I>&gt;<i>                      case 1:
</I>&gt;<i>                          MethodInfo method = (MethodInfo)mb;
</I>&gt;<i>                          if (!IsPredefinedType(method.DeclaringType))
</I>&gt;<i>                              throw ParseError(errorPos,
</I>&gt;<i> Res.MethodsAreInaccessible, GetTypeName(method.DeclaringType));
</I>&gt;<i>                          if (method.ReturnType == typeof(void))
</I>&gt;<i>                              throw ParseError(errorPos, Res.MethodIsVoid,
</I>&gt;<i>                                  id, GetTypeName(method.DeclaringType));
</I>&gt;<i>                          return Expression.Call(instance, (MethodInfo)method,
</I>&gt;<i> args);
</I>&gt;<i>                      default:
</I>&gt;<i>                          throw ParseError(errorPos,
</I>&gt;<i> Res.AmbiguousMethodInvocation,
</I>&gt;<i>                              id, GetTypeName(type));
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              else
</I>&gt;<i>              {
</I>&gt;<i>                  MemberInfo member = FindPropertyOrField(type, id, instance
</I>&gt;<i> == null);
</I>&gt;<i>                  if (member == null)
</I>&gt;<i>                      throw ParseError(errorPos, Res.UnknownPropertyOrField,
</I>&gt;<i>                          id, GetTypeName(type));
</I>&gt;<i>                  return member is PropertyInfo ?
</I>&gt;<i>                      Expression.Property(instance, (PropertyInfo)member) :
</I>&gt;<i>                      Expression.Field(instance, (FieldInfo)member);
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static Type FindGenericType(Type generic, Type type)
</I>&gt;<i>          {
</I>&gt;<i>              while (type != null&amp;&amp;  type != typeof(object))
</I>&gt;<i>              {
</I>&gt;<i>                  if (type.IsGenericType&amp;&amp;  type.GetGenericTypeDefinition() ==
</I>&gt;<i> generic) return type;
</I>&gt;<i>                  if (generic.IsInterface)
</I>&gt;<i>                  {
</I>&gt;<i>                      foreach (Type intfType in type.GetInterfaces())
</I>&gt;<i>                      {
</I>&gt;<i>                          Type found = FindGenericType(generic, intfType);
</I>&gt;<i>                          if (found != null) return found;
</I>&gt;<i>                      }
</I>&gt;<i>                  }
</I>&gt;<i>                  type = type.BaseType;
</I>&gt;<i>              }
</I>&gt;<i>              return null;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseAggregate(Expression instance, Type elementType,
</I>&gt;<i> string methodName, int errorPos)
</I>&gt;<i>          {
</I>&gt;<i>              ParameterExpression outerIt = it;
</I>&gt;<i>              ParameterExpression innerIt = Expression.Parameter(elementType,
</I>&gt;<i> &quot;&quot;);
</I>&gt;<i>              it = innerIt;
</I>&gt;<i>              Expression[] args = ParseArgumentList();
</I>&gt;<i>              it = outerIt;
</I>&gt;<i>              MethodBase signature;
</I>&gt;<i>              if (FindMethod(typeof(IEnumerableSignatures), methodName, false,
</I>&gt;<i> args, out signature) != 1)
</I>&gt;<i>                  throw ParseError(errorPos, Res.NoApplicableAggregate,
</I>&gt;<i> methodName);
</I>&gt;<i>              Type[] typeArgs;
</I>&gt;<i>              if (signature.Name == &quot;Min&quot; || signature.Name == &quot;Max&quot;)
</I>&gt;<i>              {
</I>&gt;<i>                  typeArgs = new Type[] { elementType, args[0].Type };
</I>&gt;<i>              }
</I>&gt;<i>              else
</I>&gt;<i>              {
</I>&gt;<i>                  typeArgs = new Type[] { elementType };
</I>&gt;<i>              }
</I>&gt;<i>              if (args.Length == 0)
</I>&gt;<i>              {
</I>&gt;<i>                  args = new Expression[] { instance };
</I>&gt;<i>              }
</I>&gt;<i>              else
</I>&gt;<i>              {
</I>&gt;<i>                  args = new Expression[] { instance,
</I>&gt;<i> Expression.Lambda(args[0], innerIt) };
</I>&gt;<i>              }
</I>&gt;<i>              return Expression.Call(typeof(Enumerable), signature.Name,
</I>&gt;<i> typeArgs, args);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression[] ParseArgumentList()
</I>&gt;<i>          {
</I>&gt;<i>              ValidateToken(TokenId.OpenParen, Res.OpenParenExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              Expression[] args = token.id != TokenId.CloseParen ?
</I>&gt;<i> ParseArguments() : new Expression[0];
</I>&gt;<i>              ValidateToken(TokenId.CloseParen,
</I>&gt;<i> Res.CloseParenOrCommaExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              return args;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression[] ParseArguments()
</I>&gt;<i>          {
</I>&gt;<i>              List&lt;Expression&gt;  argList = new List&lt;Expression&gt;();
</I>&gt;<i>              while (true)
</I>&gt;<i>              {
</I>&gt;<i>                  argList.Add(ParseExpression());
</I>&gt;<i>                  if (token.id != TokenId.Comma) break;
</I>&gt;<i>                  NextToken();
</I>&gt;<i>              }
</I>&gt;<i>              return argList.ToArray();
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression ParseElementAccess(Expression expr)
</I>&gt;<i>          {
</I>&gt;<i>              int errorPos = token.pos;
</I>&gt;<i>              ValidateToken(TokenId.OpenBracket, Res.OpenParenExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              Expression[] args = ParseArguments();
</I>&gt;<i>              ValidateToken(TokenId.CloseBracket,
</I>&gt;<i> Res.CloseBracketOrCommaExpected);
</I>&gt;<i>              NextToken();
</I>&gt;<i>              if (expr.Type.IsArray)
</I>&gt;<i>              {
</I>&gt;<i>                  if (expr.Type.GetArrayRank() != 1 || args.Length != 1)
</I>&gt;<i>                      throw ParseError(errorPos,
</I>&gt;<i> Res.CannotIndexMultiDimArray);
</I>&gt;<i>                  Expression index = PromoteExpression(args[0], typeof(int),
</I>&gt;<i> true);
</I>&gt;<i>                  if (index == null)
</I>&gt;<i>                      throw ParseError(errorPos, Res.InvalidIndex);
</I>&gt;<i>                  return Expression.ArrayIndex(expr, index);
</I>&gt;<i>              }
</I>&gt;<i>              else
</I>&gt;<i>              {
</I>&gt;<i>                  MethodBase mb;
</I>&gt;<i>                  switch (FindIndexer(expr.Type, args, out mb))
</I>&gt;<i>                  {
</I>&gt;<i>                      case 0:
</I>&gt;<i>                          throw ParseError(errorPos, Res.NoApplicableIndexer,
</I>&gt;<i>                              GetTypeName(expr.Type));
</I>&gt;<i>                      case 1:
</I>&gt;<i>                          return Expression.Call(expr, (MethodInfo)mb, args);
</I>&gt;<i>                      default:
</I>&gt;<i>                          throw ParseError(errorPos,
</I>&gt;<i> Res.AmbiguousIndexerInvocation,
</I>&gt;<i>                              GetTypeName(expr.Type));
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static bool IsPredefinedType(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              foreach (Type t in predefinedTypes) if (t == type) return true;
</I>&gt;<i>              return false;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static bool IsNullableType(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              return type.IsGenericType&amp;&amp;  type.GetGenericTypeDefinition() ==
</I>&gt;<i> typeof(Nullable&lt;&gt;);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static Type GetNonNullableType(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              return IsNullableType(type) ? type.GetGenericArguments()[0] :
</I>&gt;<i> type;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static string GetTypeName(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              Type baseType = GetNonNullableType(type);
</I>&gt;<i>              string s = baseType.Name;
</I>&gt;<i>              if (type != baseType) s += '?';
</I>&gt;<i>              return s;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static bool IsNumericType(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              return GetNumericTypeKind(type) != 0;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static bool IsSignedIntegralType(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              return GetNumericTypeKind(type) == 2;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static bool IsUnsignedIntegralType(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              return GetNumericTypeKind(type) == 3;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static int GetNumericTypeKind(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              type = GetNonNullableType(type);
</I>&gt;<i>              if (type.IsEnum) return 0;
</I>&gt;<i>              switch (Type.GetTypeCode(type))
</I>&gt;<i>              {
</I>&gt;<i>                  case TypeCode.Char:
</I>&gt;<i>                  case TypeCode.Single:
</I>&gt;<i>                  case TypeCode.Double:
</I>&gt;<i>                  case TypeCode.Decimal:
</I>&gt;<i>                      return 1;
</I>&gt;<i>                  case TypeCode.SByte:
</I>&gt;<i>                  case TypeCode.Int16:
</I>&gt;<i>                  case TypeCode.Int32:
</I>&gt;<i>                  case TypeCode.Int64:
</I>&gt;<i>                      return 2;
</I>&gt;<i>                  case TypeCode.Byte:
</I>&gt;<i>                  case TypeCode.UInt16:
</I>&gt;<i>                  case TypeCode.UInt32:
</I>&gt;<i>                  case TypeCode.UInt64:
</I>&gt;<i>                      return 3;
</I>&gt;<i>                  default:
</I>&gt;<i>                      return 0;
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static bool IsEnumType(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              return GetNonNullableType(type).IsEnum;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void CheckAndPromoteOperand(Type signatures, string opName, ref
</I>&gt;<i> Expression expr, int errorPos)
</I>&gt;<i>          {
</I>&gt;<i>              Expression[] args = new Expression[] { expr };
</I>&gt;<i>              MethodBase method;
</I>&gt;<i>              if (FindMethod(signatures, &quot;F&quot;, false, args, out method) != 1)
</I>&gt;<i>                  throw ParseError(errorPos, Res.IncompatibleOperand,
</I>&gt;<i>                      opName, GetTypeName(args[0].Type));
</I>&gt;<i>              expr = args[0];
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void CheckAndPromoteOperands(Type signatures, string opName, ref
</I>&gt;<i> Expression left, ref Expression right, int errorPos)
</I>&gt;<i>          {
</I>&gt;<i>              Expression[] args = new Expression[] { left, right };
</I>&gt;<i>              MethodBase method;
</I>&gt;<i>              if (FindMethod(signatures, &quot;F&quot;, false, args, out method) != 1)
</I>&gt;<i>                  throw IncompatibleOperandsError(opName, left, right,
</I>&gt;<i> errorPos);
</I>&gt;<i>              left = args[0];
</I>&gt;<i>              right = args[1];
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Exception IncompatibleOperandsError(string opName, Expression left,
</I>&gt;<i> Expression right, int pos)
</I>&gt;<i>          {
</I>&gt;<i>              return ParseError(pos, Res.IncompatibleOperands,
</I>&gt;<i>                  opName, GetTypeName(left.Type), GetTypeName(right.Type));
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          MemberInfo FindPropertyOrField(Type type, string memberName, bool
</I>&gt;<i> staticAccess)
</I>&gt;<i>          {
</I>&gt;<i>              BindingFlags flags = BindingFlags.Public |
</I>&gt;<i> BindingFlags.DeclaredOnly |
</I>&gt;<i>                  (staticAccess ? BindingFlags.Static :
</I>&gt;<i> BindingFlags.Instance);
</I>&gt;<i>              foreach (Type t in SelfAndBaseTypes(type))
</I>&gt;<i>              {
</I>&gt;<i>                  MemberInfo[] members = t.FindMembers(MemberTypes.Property |
</I>&gt;<i> MemberTypes.Field,
</I>&gt;<i>                      flags, Type.FilterNameIgnoreCase, memberName);
</I>&gt;<i>                  if (members.Length != 0) return members[0];
</I>&gt;<i>              }
</I>&gt;<i>              return null;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          int FindMethod(Type type, string methodName, bool staticAccess,
</I>&gt;<i> Expression[] args, out MethodBase method)
</I>&gt;<i>          {
</I>&gt;<i>              BindingFlags flags = BindingFlags.Public |
</I>&gt;<i> BindingFlags.DeclaredOnly |
</I>&gt;<i>                  (staticAccess ? BindingFlags.Static :
</I>&gt;<i> BindingFlags.Instance);
</I>&gt;<i>              foreach (Type t in SelfAndBaseTypes(type))
</I>&gt;<i>              {
</I>&gt;<i>                  MemberInfo[] members = t.FindMembers(MemberTypes.Method,
</I>&gt;<i>                      flags, Type.FilterNameIgnoreCase, methodName);
</I>&gt;<i>                  int count = FindBestMethod(members.Cast&lt;MethodBase&gt;(), args,
</I>&gt;<i> out method);
</I>&gt;<i>                  if (count != 0) return count;
</I>&gt;<i>              }
</I>&gt;<i>              method = null;
</I>&gt;<i>              return 0;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          int FindIndexer(Type type, Expression[] args, out MethodBase method)
</I>&gt;<i>          {
</I>&gt;<i>              foreach (Type t in SelfAndBaseTypes(type))
</I>&gt;<i>              {
</I>&gt;<i>                  MemberInfo[] members = t.GetDefaultMembers();
</I>&gt;<i>                  if (members.Length != 0)
</I>&gt;<i>                  {
</I>&gt;<i>                      IEnumerable&lt;MethodBase&gt;  methods = members.
</I>&gt;<i>                          OfType&lt;PropertyInfo&gt;().
</I>&gt;<i>                          Select(p =&gt;  (MethodBase)p.GetGetMethod()).
</I>&gt;<i>                          Where(m =&gt;  m != null);
</I>&gt;<i>                      int count = FindBestMethod(methods, args, out method);
</I>&gt;<i>                      if (count != 0) return count;
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              method = null;
</I>&gt;<i>              return 0;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static IEnumerable&lt;Type&gt;  SelfAndBaseTypes(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              if (type.IsInterface)
</I>&gt;<i>              {
</I>&gt;<i>                  List&lt;Type&gt;  types = new List&lt;Type&gt;();
</I>&gt;<i>                  AddInterface(types, type);
</I>&gt;<i>                  return types;
</I>&gt;<i>              }
</I>&gt;<i>              return SelfAndBaseClasses(type);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static IEnumerable&lt;Type&gt;  SelfAndBaseClasses(Type type)
</I>&gt;<i>          {
</I>&gt;<i>              while (type != null)
</I>&gt;<i>              {
</I>&gt;<i>                  yield return type;
</I>&gt;<i>                  type = type.BaseType;
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static void AddInterface(List&lt;Type&gt;  types, Type type)
</I>&gt;<i>          {
</I>&gt;<i>              if (!types.Contains(type))
</I>&gt;<i>              {
</I>&gt;<i>                  types.Add(type);
</I>&gt;<i>                  foreach (Type t in type.GetInterfaces()) AddInterface(types,
</I>&gt;<i> t);
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          class MethodData
</I>&gt;<i>          {
</I>&gt;<i>              public MethodBase MethodBase;
</I>&gt;<i>              public ParameterInfo[] Parameters;
</I>&gt;<i>              public Expression[] Args;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          int FindBestMethod(IEnumerable&lt;MethodBase&gt;  methods, Expression[]
</I>&gt;<i> args, out MethodBase method)
</I>&gt;<i>          {
</I>&gt;<i>              MethodData[] applicable = methods.
</I>&gt;<i>                  Select(m =&gt;  new MethodData { MethodBase = m, Parameters =
</I>&gt;<i> m.GetParameters() }).
</I>&gt;<i>                  Where(m =&gt;  IsApplicable(m, args)).
</I>&gt;<i>                  ToArray();
</I>&gt;<i>              if (applicable.Length&gt;  1)
</I>&gt;<i>              {
</I>&gt;<i>                  applicable = applicable.
</I>&gt;<i>                      Where(m =&gt;  applicable.All(n =&gt;  m == n ||
</I>&gt;<i> IsBetterThan(args, m, n))).
</I>&gt;<i>                      ToArray();
</I>&gt;<i>              }
</I>&gt;<i>              if (applicable.Length == 1)
</I>&gt;<i>              {
</I>&gt;<i>                  MethodData md = applicable[0];
</I>&gt;<i>                  for (int i = 0; i&lt;  args.Length; i++) args[i] = md.Args[i];
</I>&gt;<i>                  method = md.MethodBase;
</I>&gt;<i>              }
</I>&gt;<i>              else
</I>&gt;<i>              {
</I>&gt;<i>                  method = null;
</I>&gt;<i>              }
</I>&gt;<i>              return applicable.Length;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          bool IsApplicable(MethodData method, Expression[] args)
</I>&gt;<i>          {
</I>&gt;<i>              if (method.Parameters.Length != args.Length) return false;
</I>&gt;<i>              Expression[] promotedArgs = new Expression[args.Length];
</I>&gt;<i>              for (int i = 0; i&lt;  args.Length; i++)
</I>&gt;<i>              {
</I>&gt;<i>                  ParameterInfo pi = method.Parameters[i];
</I>&gt;<i>                  if (pi.IsOut) return false;
</I>&gt;<i>                  Expression promoted = PromoteExpression(args[i],
</I>&gt;<i> pi.ParameterType, false);
</I>&gt;<i>                  if (promoted == null) return false;
</I>&gt;<i>                  promotedArgs[i] = promoted;
</I>&gt;<i>              }
</I>&gt;<i>              method.Args = promotedArgs;
</I>&gt;<i>              return true;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression PromoteExpression(Expression expr, Type type, bool exact)
</I>&gt;<i>          {
</I>&gt;<i>              if (expr.Type == type) return expr;
</I>&gt;<i>              if (expr is ConstantExpression)
</I>&gt;<i>              {
</I>&gt;<i>                  ConstantExpression ce = (ConstantExpression)expr;
</I>&gt;<i>                  if (ce == nullLiteral)
</I>&gt;<i>                  {
</I>&gt;<i>                      if (!type.IsValueType || IsNullableType(type))
</I>&gt;<i>                          return Expression.Constant(null, type);
</I>&gt;<i>                  }
</I>&gt;<i>                  else
</I>&gt;<i>                  {
</I>&gt;<i>                      string text;
</I>&gt;<i>                      if (literals.TryGetValue(ce, out text))
</I>&gt;<i>                      {
</I>&gt;<i>                          Type target = GetNonNullableType(type);
</I>&gt;<i>                          Object value = null;
</I>&gt;<i>                          switch (Type.GetTypeCode(ce.Type))
</I>&gt;<i>                          {
</I>&gt;<i>                              case TypeCode.Int32:
</I>&gt;<i>                              case TypeCode.UInt32:
</I>&gt;<i>                              case TypeCode.Int64:
</I>&gt;<i>                              case TypeCode.UInt64:
</I>&gt;<i>                                  value = ParseNumber(text, target);
</I>&gt;<i>                                  break;
</I>&gt;<i>                              case TypeCode.Double:
</I>&gt;<i>                                  if (target == typeof(decimal)) value =
</I>&gt;<i> ParseNumber(text, target);
</I>&gt;<i>                                  break;
</I>&gt;<i>                              case TypeCode.String:
</I>&gt;<i>                                  value = ParseEnum(text, target);
</I>&gt;<i>                                  break;
</I>&gt;<i>                          }
</I>&gt;<i>                          if (value != null)
</I>&gt;<i>                              return Expression.Constant(value, type);
</I>&gt;<i>                      }
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>              if (IsCompatibleWith(expr.Type, type))
</I>&gt;<i>              {
</I>&gt;<i>                  if (type.IsValueType || exact) return
</I>&gt;<i> Expression.Convert(expr, type);
</I>&gt;<i>                  return expr;
</I>&gt;<i>              }
</I>&gt;<i>              return null;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static object ParseNumber(string text, Type type)
</I>&gt;<i>          {
</I>&gt;<i>              switch (Type.GetTypeCode(GetNonNullableType(type)))
</I>&gt;<i>              {
</I>&gt;<i>                  case TypeCode.SByte:
</I>&gt;<i>                      sbyte sb;
</I>&gt;<i>                      if (sbyte.TryParse(text, out sb)) return sb;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Byte:
</I>&gt;<i>                      byte b;
</I>&gt;<i>                      if (byte.TryParse(text, out b)) return b;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Int16:
</I>&gt;<i>                      short s;
</I>&gt;<i>                      if (short.TryParse(text, out s)) return s;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.UInt16:
</I>&gt;<i>                      ushort us;
</I>&gt;<i>                      if (ushort.TryParse(text, out us)) return us;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Int32:
</I>&gt;<i>                      int i;
</I>&gt;<i>                      if (int.TryParse(text, out i)) return i;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.UInt32:
</I>&gt;<i>                      uint ui;
</I>&gt;<i>                      if (uint.TryParse(text, out ui)) return ui;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Int64:
</I>&gt;<i>                      long l;
</I>&gt;<i>                      if (long.TryParse(text, out l)) return l;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.UInt64:
</I>&gt;<i>                      ulong ul;
</I>&gt;<i>                      if (ulong.TryParse(text, out ul)) return ul;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Single:
</I>&gt;<i>                      float f;
</I>&gt;<i>                      if (float.TryParse(text, out f)) return f;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Double:
</I>&gt;<i>                      double d;
</I>&gt;<i>                      if (double.TryParse(text, out d)) return d;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Decimal:
</I>&gt;<i>                      decimal e;
</I>&gt;<i>                      if (decimal.TryParse(text, out e)) return e;
</I>&gt;<i>                      break;
</I>&gt;<i>              }
</I>&gt;<i>              return null;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static object ParseEnum(string name, Type type)
</I>&gt;<i>          {
</I>&gt;<i>              if (type.IsEnum)
</I>&gt;<i>              {
</I>&gt;<i>                  MemberInfo[] memberInfos =
</I>&gt;<i> type.FindMembers(MemberTypes.Field,
</I>&gt;<i>                      BindingFlags.Public | BindingFlags.DeclaredOnly |
</I>&gt;<i> BindingFlags.Static,
</I>&gt;<i>                      Type.FilterNameIgnoreCase, name);
</I>&gt;<i>                  if (memberInfos.Length != 0) return
</I>&gt;<i> ((FieldInfo)memberInfos[0]).GetValue(null);
</I>&gt;<i>              }
</I>&gt;<i>              return null;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static bool IsCompatibleWith(Type source, Type target)
</I>&gt;<i>          {
</I>&gt;<i>              if (source == target) return true;
</I>&gt;<i>              if (!target.IsValueType) return target.IsAssignableFrom(source);
</I>&gt;<i>              Type st = GetNonNullableType(source);
</I>&gt;<i>              Type tt = GetNonNullableType(target);
</I>&gt;<i>              if (st != source&amp;&amp;  tt == target) return false;
</I>&gt;<i>              TypeCode sc = st.IsEnum ? TypeCode.Object :
</I>&gt;<i> Type.GetTypeCode(st);
</I>&gt;<i>              TypeCode tc = tt.IsEnum ? TypeCode.Object :
</I>&gt;<i> Type.GetTypeCode(tt);
</I>&gt;<i>              switch (sc)
</I>&gt;<i>              {
</I>&gt;<i>                  case TypeCode.SByte:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.SByte:
</I>&gt;<i>                          case TypeCode.Int16:
</I>&gt;<i>                          case TypeCode.Int32:
</I>&gt;<i>                          case TypeCode.Int64:
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                          case TypeCode.Decimal:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Byte:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.Byte:
</I>&gt;<i>                          case TypeCode.Int16:
</I>&gt;<i>                          case TypeCode.UInt16:
</I>&gt;<i>                          case TypeCode.Int32:
</I>&gt;<i>                          case TypeCode.UInt32:
</I>&gt;<i>                          case TypeCode.Int64:
</I>&gt;<i>                          case TypeCode.UInt64:
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                          case TypeCode.Decimal:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Int16:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.Int16:
</I>&gt;<i>                          case TypeCode.Int32:
</I>&gt;<i>                          case TypeCode.Int64:
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                          case TypeCode.Decimal:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.UInt16:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.UInt16:
</I>&gt;<i>                          case TypeCode.Int32:
</I>&gt;<i>                          case TypeCode.UInt32:
</I>&gt;<i>                          case TypeCode.Int64:
</I>&gt;<i>                          case TypeCode.UInt64:
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                          case TypeCode.Decimal:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Int32:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.Int32:
</I>&gt;<i>                          case TypeCode.Int64:
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                          case TypeCode.Decimal:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.UInt32:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.UInt32:
</I>&gt;<i>                          case TypeCode.Int64:
</I>&gt;<i>                          case TypeCode.UInt64:
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                          case TypeCode.Decimal:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Int64:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.Int64:
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                          case TypeCode.Decimal:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.UInt64:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.UInt64:
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                          case TypeCode.Decimal:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case TypeCode.Single:
</I>&gt;<i>                      switch (tc)
</I>&gt;<i>                      {
</I>&gt;<i>                          case TypeCode.Single:
</I>&gt;<i>                          case TypeCode.Double:
</I>&gt;<i>                              return true;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  default:
</I>&gt;<i>                      if (st == tt) return true;
</I>&gt;<i>                      break;
</I>&gt;<i>              }
</I>&gt;<i>              return false;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static bool IsBetterThan(Expression[] args, MethodData m1,
</I>&gt;<i> MethodData m2)
</I>&gt;<i>          {
</I>&gt;<i>              bool better = false;
</I>&gt;<i>              for (int i = 0; i&lt;  args.Length; i++)
</I>&gt;<i>              {
</I>&gt;<i>                  int c = CompareConversions(args[i].Type,
</I>&gt;<i>                      m1.Parameters[i].ParameterType,
</I>&gt;<i>                      m2.Parameters[i].ParameterType);
</I>&gt;<i>                  if (c&lt;  0) return false;
</I>&gt;<i>                  if (c&gt;  0) better = true;
</I>&gt;<i>              }
</I>&gt;<i>              return better;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          // Return 1 if s -&gt;  t1 is a better conversion than s -&gt;  t2
</I>&gt;<i>          // Return -1 if s -&gt;  t2 is a better conversion than s -&gt;  t1
</I>&gt;<i>          // Return 0 if neither conversion is better
</I>&gt;<i>          static int CompareConversions(Type s, Type t1, Type t2)
</I>&gt;<i>          {
</I>&gt;<i>              if (t1 == t2) return 0;
</I>&gt;<i>              if (s == t1) return 1;
</I>&gt;<i>              if (s == t2) return -1;
</I>&gt;<i>              bool t1t2 = IsCompatibleWith(t1, t2);
</I>&gt;<i>              bool t2t1 = IsCompatibleWith(t2, t1);
</I>&gt;<i>              if (t1t2&amp;&amp;  !t2t1) return 1;
</I>&gt;<i>              if (t2t1&amp;&amp;  !t1t2) return -1;
</I>&gt;<i>              if (IsSignedIntegralType(t1)&amp;&amp;  IsUnsignedIntegralType(t2))
</I>&gt;<i> return 1;
</I>&gt;<i>              if (IsSignedIntegralType(t2)&amp;&amp;  IsUnsignedIntegralType(t1))
</I>&gt;<i> return -1;
</I>&gt;<i>              return 0;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateEqual(Expression left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              return Expression.Equal(left, right);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateNotEqual(Expression left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              return Expression.NotEqual(left, right);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateGreaterThan(Expression left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              if (left.Type == typeof(string))
</I>&gt;<i>              {
</I>&gt;<i>                  return Expression.GreaterThan(
</I>&gt;<i>                      GenerateStaticMethodCall(&quot;Compare&quot;, left, right),
</I>&gt;<i>                      Expression.Constant(0)
</I>&gt;<i>                  );
</I>&gt;<i>              }
</I>&gt;<i>              return Expression.GreaterThan(left, right);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateGreaterThanEqual(Expression left, Expression
</I>&gt;<i> right)
</I>&gt;<i>          {
</I>&gt;<i>              if (left.Type == typeof(string))
</I>&gt;<i>              {
</I>&gt;<i>                  return Expression.GreaterThanOrEqual(
</I>&gt;<i>                      GenerateStaticMethodCall(&quot;Compare&quot;, left, right),
</I>&gt;<i>                      Expression.Constant(0)
</I>&gt;<i>                  );
</I>&gt;<i>              }
</I>&gt;<i>              return Expression.GreaterThanOrEqual(left, right);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateLessThan(Expression left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              if (left.Type == typeof(string))
</I>&gt;<i>              {
</I>&gt;<i>                  return Expression.LessThan(
</I>&gt;<i>                      GenerateStaticMethodCall(&quot;Compare&quot;, left, right),
</I>&gt;<i>                      Expression.Constant(0)
</I>&gt;<i>                  );
</I>&gt;<i>              }
</I>&gt;<i>              return Expression.LessThan(left, right);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateLessThanEqual(Expression left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              if (left.Type == typeof(string))
</I>&gt;<i>              {
</I>&gt;<i>                  return Expression.LessThanOrEqual(
</I>&gt;<i>                      GenerateStaticMethodCall(&quot;Compare&quot;, left, right),
</I>&gt;<i>                      Expression.Constant(0)
</I>&gt;<i>                  );
</I>&gt;<i>              }
</I>&gt;<i>              return Expression.LessThanOrEqual(left, right);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateAdd(Expression left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              if (left.Type == typeof(string)&amp;&amp;  right.Type == typeof(string))
</I>&gt;<i>              {
</I>&gt;<i>                  return GenerateStaticMethodCall(&quot;Concat&quot;, left, right);
</I>&gt;<i>              }
</I>&gt;<i>              return Expression.Add(left, right);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateSubtract(Expression left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              return Expression.Subtract(left, right);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateStringConcat(Expression left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              return Expression.Call(
</I>&gt;<i>                  null,
</I>&gt;<i>                  typeof(string).GetMethod(&quot;Concat&quot;, new[] { typeof(object),
</I>&gt;<i> typeof(object) }),
</I>&gt;<i>                  new[] { left, right });
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          MethodInfo GetStaticMethod(string methodName, Expression left,
</I>&gt;<i> Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              return left.Type.GetMethod(methodName, new[] { left.Type,
</I>&gt;<i> right.Type });
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Expression GenerateStaticMethodCall(string methodName, Expression
</I>&gt;<i> left, Expression right)
</I>&gt;<i>          {
</I>&gt;<i>              return Expression.Call(null, GetStaticMethod(methodName, left,
</I>&gt;<i> right), new[] { left, right });
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void SetTextPos(int pos)
</I>&gt;<i>          {
</I>&gt;<i>              textPos = pos;
</I>&gt;<i>              ch = textPos&lt;  textLen ? text[textPos] : '\0';
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void NextChar()
</I>&gt;<i>          {
</I>&gt;<i>              if (textPos&lt;  textLen) textPos++;
</I>&gt;<i>              ch = textPos&lt;  textLen ? text[textPos] : '\0';
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void NextToken()
</I>&gt;<i>          {
</I>&gt;<i>              while (Char.IsWhiteSpace(ch)) NextChar();
</I>&gt;<i>              TokenId t;
</I>&gt;<i>              int tokenPos = textPos;
</I>&gt;<i>              switch (ch)
</I>&gt;<i>              {
</I>&gt;<i>                  case '!':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      if (ch == '=')
</I>&gt;<i>                      {
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                          t = TokenId.ExclamationEqual;
</I>&gt;<i>                      }
</I>&gt;<i>                      else
</I>&gt;<i>                      {
</I>&gt;<i>                          t = TokenId.Exclamation;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '%':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Percent;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '&amp;':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      if (ch == '&amp;')
</I>&gt;<i>                      {
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                          t = TokenId.DoubleAmphersand;
</I>&gt;<i>                      }
</I>&gt;<i>                      else
</I>&gt;<i>                      {
</I>&gt;<i>                          t = TokenId.Amphersand;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '(':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.OpenParen;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case ')':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.CloseParen;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '*':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Asterisk;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '+':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Plus;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case ',':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Comma;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '-':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Minus;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '.':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Dot;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '/':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Slash;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case ':':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Colon;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '&lt;':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      if (ch == '=')
</I>&gt;<i>                      {
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                          t = TokenId.LessThanEqual;
</I>&gt;<i>                      }
</I>&gt;<i>                      else if (ch == '&gt;')
</I>&gt;<i>                      {
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                          t = TokenId.LessGreater;
</I>&gt;<i>                      }
</I>&gt;<i>                      else
</I>&gt;<i>                      {
</I>&gt;<i>                          t = TokenId.LessThan;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '=':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      if (ch == '=')
</I>&gt;<i>                      {
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                          t = TokenId.DoubleEqual;
</I>&gt;<i>                      }
</I>&gt;<i>                      else
</I>&gt;<i>                      {
</I>&gt;<i>                          t = TokenId.Equal;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '&gt;':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      if (ch == '=')
</I>&gt;<i>                      {
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                          t = TokenId.GreaterThanEqual;
</I>&gt;<i>                      }
</I>&gt;<i>                      else
</I>&gt;<i>                      {
</I>&gt;<i>                          t = TokenId.GreaterThan;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '?':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.Question;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '[':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.OpenBracket;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case ']':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      t = TokenId.CloseBracket;
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '|':
</I>&gt;<i>                      NextChar();
</I>&gt;<i>                      if (ch == '|')
</I>&gt;<i>                      {
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                          t = TokenId.DoubleBar;
</I>&gt;<i>                      }
</I>&gt;<i>                      else
</I>&gt;<i>                      {
</I>&gt;<i>                          t = TokenId.Bar;
</I>&gt;<i>                      }
</I>&gt;<i>                      break;
</I>&gt;<i>                  case '&quot;':
</I>&gt;<i>                  case '\'':
</I>&gt;<i>                      char quote = ch;
</I>&gt;<i>                      do
</I>&gt;<i>                      {
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                          while (textPos&lt;  textLen&amp;&amp;  ch != quote) NextChar();
</I>&gt;<i>                          if (textPos == textLen)
</I>&gt;<i>                              throw ParseError(textPos,
</I>&gt;<i> Res.UnterminatedStringLiteral);
</I>&gt;<i>                          NextChar();
</I>&gt;<i>                      } while (ch == quote);
</I>&gt;<i>                      t = TokenId.StringLiteral;
</I>&gt;<i>                      break;
</I>&gt;<i>                  default:
</I>&gt;<i>                      if (Char.IsLetter(ch) || ch == '@' || ch == '_')
</I>&gt;<i>                      {
</I>&gt;<i>                          do
</I>&gt;<i>                          {
</I>&gt;<i>                              NextChar();
</I>&gt;<i>                          } while (Char.IsLetterOrDigit(ch) || ch == '_');
</I>&gt;<i>                          t = TokenId.Identifier;
</I>&gt;<i>                          break;
</I>&gt;<i>                      }
</I>&gt;<i>                      if (Char.IsDigit(ch))
</I>&gt;<i>                      {
</I>&gt;<i>                          t = TokenId.IntegerLiteral;
</I>&gt;<i>                          do
</I>&gt;<i>                          {
</I>&gt;<i>                              NextChar();
</I>&gt;<i>                          } while (Char.IsDigit(ch));
</I>&gt;<i>                          if (ch == '.')
</I>&gt;<i>                          {
</I>&gt;<i>                              t = TokenId.RealLiteral;
</I>&gt;<i>                              NextChar();
</I>&gt;<i>                              ValidateDigit();
</I>&gt;<i>                              do
</I>&gt;<i>                              {
</I>&gt;<i>                                  NextChar();
</I>&gt;<i>                              } while (Char.IsDigit(ch));
</I>&gt;<i>                          }
</I>&gt;<i>                          if (ch == 'E' || ch == 'e')
</I>&gt;<i>                          {
</I>&gt;<i>                              t = TokenId.RealLiteral;
</I>&gt;<i>                              NextChar();
</I>&gt;<i>                              if (ch == '+' || ch == '-') NextChar();
</I>&gt;<i>                              ValidateDigit();
</I>&gt;<i>                              do
</I>&gt;<i>                              {
</I>&gt;<i>                                  NextChar();
</I>&gt;<i>                              } while (Char.IsDigit(ch));
</I>&gt;<i>                          }
</I>&gt;<i>                          if (ch == 'F' || ch == 'f') NextChar();
</I>&gt;<i>                          break;
</I>&gt;<i>                      }
</I>&gt;<i>                      if (textPos == textLen)
</I>&gt;<i>                      {
</I>&gt;<i>                          t = TokenId.End;
</I>&gt;<i>                          break;
</I>&gt;<i>                      }
</I>&gt;<i>                      throw ParseError(textPos, Res.InvalidCharacter, ch);
</I>&gt;<i>              }
</I>&gt;<i>              token.id = t;
</I>&gt;<i>              token.text = text.Substring(tokenPos, textPos - tokenPos);
</I>&gt;<i>              token.pos = tokenPos;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          bool TokenIdentifierIs(string id)
</I>&gt;<i>          {
</I>&gt;<i>              return token.id == TokenId.Identifier&amp;&amp;  String.Equals(id,
</I>&gt;<i> token.text, StringComparison.OrdinalIgnoreCase);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          string GetIdentifier()
</I>&gt;<i>          {
</I>&gt;<i>              ValidateToken(TokenId.Identifier, Res.IdentifierExpected);
</I>&gt;<i>              string id = token.text;
</I>&gt;<i>              if (id.Length&gt;  1&amp;&amp;  id[0] == '@') id = id.Substring(1);
</I>&gt;<i>              return id;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void ValidateDigit()
</I>&gt;<i>          {
</I>&gt;<i>              if (!Char.IsDigit(ch)) throw ParseError(textPos,
</I>&gt;<i> Res.DigitExpected);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void ValidateToken(TokenId t, string errorMessage)
</I>&gt;<i>          {
</I>&gt;<i>              if (token.id != t) throw ParseError(errorMessage);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          void ValidateToken(TokenId t)
</I>&gt;<i>          {
</I>&gt;<i>              if (token.id != t) throw ParseError(Res.SyntaxError);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Exception ParseError(string format, params object[] args)
</I>&gt;<i>          {
</I>&gt;<i>              return ParseError(token.pos, format, args);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          Exception ParseError(int pos, string format, params object[] args)
</I>&gt;<i>          {
</I>&gt;<i>              return new
</I>&gt;<i> ParseException(string.Format(System.Globalization.CultureInfo.CurrentCulture,
</I>&gt;<i> format, args), pos);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          static Dictionary&lt;string, object&gt;  CreateKeywords()
</I>&gt;<i>          {
</I>&gt;<i>              Dictionary&lt;string, object&gt;  d = new Dictionary&lt;string,
</I>&gt;<i> object&gt;(StringComparer.OrdinalIgnoreCase);
</I>&gt;<i>              d.Add(&quot;true&quot;, trueLiteral);
</I>&gt;<i>              d.Add(&quot;false&quot;, falseLiteral);
</I>&gt;<i>              d.Add(&quot;null&quot;, nullLiteral);
</I>&gt;<i>              d.Add(keywordIt, keywordIt);
</I>&gt;<i>              d.Add(keywordIif, keywordIif);
</I>&gt;<i>              d.Add(keywordNew, keywordNew);
</I>&gt;<i>              foreach (Type type in predefinedTypes) d.Add(type.Name, type);
</I>&gt;<i>              return d;
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>      static class Res
</I>&gt;<i>      {
</I>&gt;<i>          public const string DuplicateIdentifier = &quot;The identifier '{0}' was
</I>&gt;<i> defined more than once&quot;;
</I>&gt;<i>          public const string ExpressionTypeMismatch = &quot;Expression of type
</I>&gt;<i> '{0}' expected&quot;;
</I>&gt;<i>          public const string ExpressionExpected = &quot;Expression expected&quot;;
</I>&gt;<i>          public const string InvalidCharacterLiteral = &quot;Character literal
</I>&gt;<i> must contain exactly one character&quot;;
</I>&gt;<i>          public const string InvalidIntegerLiteral = &quot;Invalid integer literal
</I>&gt;<i> '{0}'&quot;;
</I>&gt;<i>          public const string InvalidRealLiteral = &quot;Invalid real literal
</I>&gt;<i> '{0}'&quot;;
</I>&gt;<i>          public const string UnknownIdentifier = &quot;Unknown identifier '{0}'&quot;;
</I>&gt;<i>          public const string NoItInScope = &quot;No 'it' is in scope&quot;;
</I>&gt;<i>          public const string IifRequiresThreeArgs = &quot;The 'iif' function
</I>&gt;<i> requires three arguments&quot;;
</I>&gt;<i>          public const string FirstExprMustBeBool = &quot;The first expression must
</I>&gt;<i> be of type 'Boolean'&quot;;
</I>&gt;<i>          public const string BothTypesConvertToOther = &quot;Both of the types
</I>&gt;<i> '{0}' and '{1}' convert to the other&quot;;
</I>&gt;<i>          public const string NeitherTypeConvertsToOther = &quot;Neither of the
</I>&gt;<i> types '{0}' and '{1}' converts to the other&quot;;
</I>&gt;<i>          public const string MissingAsClause = &quot;Expression is missing an 'as'
</I>&gt;<i> clause&quot;;
</I>&gt;<i>          public const string ArgsIncompatibleWithLambda = &quot;Argument list
</I>&gt;<i> incompatible with lambda expression&quot;;
</I>&gt;<i>          public const string TypeHasNoNullableForm = &quot;Type '{0}' has no
</I>&gt;<i> nullable form&quot;;
</I>&gt;<i>          public const string NoMatchingConstructor = &quot;No matching constructor
</I>&gt;<i> in type '{0}'&quot;;
</I>&gt;<i>          public const string AmbiguousConstructorInvocation = &quot;Ambiguous
</I>&gt;<i> invocation of '{0}' constructor&quot;;
</I>&gt;<i>          public const string CannotConvertValue = &quot;A value of type '{0}'
</I>&gt;<i> cannot be converted to type '{1}'&quot;;
</I>&gt;<i>          public const string NoApplicableMethod = &quot;No applicable method '{0}'
</I>&gt;<i> exists in type '{1}'&quot;;
</I>&gt;<i>          public const string MethodsAreInaccessible = &quot;Methods on type '{0}'
</I>&gt;<i> are not accessible&quot;;
</I>&gt;<i>          public const string MethodIsVoid = &quot;Method '{0}' in type '{1}' does
</I>&gt;<i> not return a value&quot;;
</I>&gt;<i>          public const string AmbiguousMethodInvocation = &quot;Ambiguous
</I>&gt;<i> invocation of method '{0}' in type '{1}'&quot;;
</I>&gt;<i>          public const string UnknownPropertyOrField = &quot;No property or field
</I>&gt;<i> '{0}' exists in type '{1}'&quot;;
</I>&gt;<i>          public const string NoApplicableAggregate = &quot;No applicable aggregate
</I>&gt;<i> method '{0}' exists&quot;;
</I>&gt;<i>          public const string CannotIndexMultiDimArray = &quot;Indexing of
</I>&gt;<i> multi-dimensional arrays is not supported&quot;;
</I>&gt;<i>          public const string InvalidIndex = &quot;Array index must be an integer
</I>&gt;<i> expression&quot;;
</I>&gt;<i>          public const string NoApplicableIndexer = &quot;No applicable indexer
</I>&gt;<i> exists in type '{0}'&quot;;
</I>&gt;<i>          public const string AmbiguousIndexerInvocation = &quot;Ambiguous
</I>&gt;<i> invocation of indexer in type '{0}'&quot;;
</I>&gt;<i>          public const string IncompatibleOperand = &quot;Operator '{0}'
</I>&gt;<i> incompatible with operand type '{1}'&quot;;
</I>&gt;<i>          public const string IncompatibleOperands = &quot;Operator '{0}'
</I>&gt;<i> incompatible with operand types '{1}' and '{2}'&quot;;
</I>&gt;<i>          public const string UnterminatedStringLiteral = &quot;Unterminated string
</I>&gt;<i> literal&quot;;
</I>&gt;<i>          public const string InvalidCharacter = &quot;Syntax error '{0}'&quot;;
</I>&gt;<i>          public const string DigitExpected = &quot;Digit expected&quot;;
</I>&gt;<i>          public const string SyntaxError = &quot;Syntax error&quot;;
</I>&gt;<i>          public const string TokenExpected = &quot;{0} expected&quot;;
</I>&gt;<i>          public const string ParseExceptionFormat = &quot;{0} (at index {1})&quot;;
</I>&gt;<i>          public const string ColonExpected = &quot;':' expected&quot;;
</I>&gt;<i>          public const string OpenParenExpected = &quot;'(' expected&quot;;
</I>&gt;<i>          public const string CloseParenOrOperatorExpected = &quot;')' or operator
</I>&gt;<i> expected&quot;;
</I>&gt;<i>          public const string CloseParenOrCommaExpected = &quot;')' or ','
</I>&gt;<i> expected&quot;;
</I>&gt;<i>          public const string DotOrOpenParenExpected = &quot;'.' or '(' expected&quot;;
</I>&gt;<i>          public const string OpenBracketExpected = &quot;'[' expected&quot;;
</I>&gt;<i>          public const string CloseBracketOrCommaExpected = &quot;']' or ','
</I>&gt;<i> expected&quot;;
</I>&gt;<i>          public const string IdentifierExpected = &quot;Identifier expected&quot;;
</I>&gt;<i>      }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> View this message in context: <A HREF="http://mono-for-android.1047100.n5.nabble.com/System-Linq-Dynamic-tp5636105p5636105.html">http://mono-for-android.1047100.n5.nabble.com/System-Linq-Dynamic-tp5636105p5636105.html</A>
</I>&gt;<i> Sent from the Mono for Android mailing list archive at Nabble.com.
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Monodroid mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monodroid">Monodroid at lists.ximian.com</A>
</I>&gt;<i>
</I>&gt;<i> UNSUBSCRIBE INFORMATION:
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monodroid">http://lists.ximian.com/mailman/listinfo/monodroid</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>



























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009727.html">[mono-android] System.Linq.Dynamic
</A></li>
	<LI>Next message: <A HREF="009752.html">[mono-android] System.Linq.Dynamic
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9739">[ date ]</a>
              <a href="thread.html#9739">[ thread ]</a>
              <a href="subject.html#9739">[ subject ]</a>
              <a href="author.html#9739">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodroid">More information about the Monodroid
mailing list</a><br>
</body></html>
