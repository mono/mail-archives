<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [mono-android] Images gets Blur while minimizing the size in height,	width
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodroid%40lists.ximian.com?Subject=Re%3A%20%5Bmono-android%5D%20Images%20gets%20Blur%20while%20minimizing%20the%20size%20in%20height%2C%0A%09width&In-Reply-To=%3C1328007208488-5444240.post%40n5.nabble.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008677.html">
   <LINK REL="Next"  HREF="008673.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mono-android] Images gets Blur while minimizing the size in height,	width</H1>
    <B>Pritish</B> 
    <A HREF="mailto:monodroid%40lists.ximian.com?Subject=Re%3A%20%5Bmono-android%5D%20Images%20gets%20Blur%20while%20minimizing%20the%20size%20in%20height%2C%0A%09width&In-Reply-To=%3C1328007208488-5444240.post%40n5.nabble.com%3E"
       TITLE="[mono-android] Images gets Blur while minimizing the size in height,	width">pritish_deshmukh at medsynaptic.com
       </A><BR>
    <I>Tue Jan 31 10:53:28 UTC 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="008677.html">[mono-android] another Java versus C# how to
</A></li>
        <LI>Next message: <A HREF="008673.html">[mono-android] Nook apps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8672">[ date ]</a>
              <a href="thread.html#8672">[ thread ]</a>
              <a href="subject.html#8672">[ subject ]</a>
              <a href="author.html#8672">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Its Uregent!!!!!!!! 
I have used the Mono.Cairo dll for Matrix class gives me an error please go
through link 

<A HREF="http://mono-for-android.1047100.n5.nabble.com/Cairo-Matrix-dll-gives-an-Error-Object-reference-not-set-to-an-instance-of-an-object-td5106920.html#a5109420">http://mono-for-android.1047100.n5.nabble.com/Cairo-Matrix-dll-gives-an-Error-Object-reference-not-set-to-an-instance-of-an-object-td5106920.html#a5109420</A>

so that i implement the CairoMatrix class for that. Now its work fine but
the problem is that while loading the image from File Explorer from Android
Device Image gets Blur and not display at center of the screen. 

Imaging1.Mathematics 
{ 
    public class CairoMatrix 
    { 
        #region Fields 
        public double Xx=1.0; 
        public double Yx=0.0; 
        public double Xy=0.0; 
        public double Yy=1.0; 
        public double X0=0.0; 
        public double Y0=0.0; 
        private readonly int _rows=3; 
        private readonly int _columns=3; 
        private readonly double[,] _CairoMatrix; 
        protected double[][] values; 
        private double[][] _matrixNew=   { 
                                         new double[]{1f,0f,0f}, 
                                         new double[]{0f,1f,0f}, 
                                         new double[]{0f,0f,1f} 
                                        }; 
       // private float[][] _matrixNew= new
float{{1f,0f,0f},{0f,1f,0f},{0f,0f,1f}};//=   {{1f,0f,0f}, {
0,1,0},{0,0,1}}; 
      
        CairoMatrix _cairoMatrixClass; 
        
        #endregion 

        #region Properties 
       
[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] 
        public int Rows 
        { 
            get 
            { 
                return _rows; 
            } 
        } 
       
[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] 
        public int Columns 
        { 
            get 
            { 
                return _columns; 
            } 
        } 
        public virtual double[,] Array 
        { 
            get 
            { 
                return _CairoMatrix; 
            } 
        } 
        public double this[int row, int column] 
        { 
            get 
            { 
                return _CairoMatrix[row, column]; 
            } 
            set 
            { 
                _CairoMatrix[row, column] = value; 
            } 
        } 
       
[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] 
        public bool IsSquare 
        { 
            get 
            { 
                return _rows == _columns; 
            } 
        } 
        #endregion 

        #region Ctor 
        public CairoMatrix(double xx, double yx, double xy, double yy, 
        double x0, double y0) 
        { 

            this.Xx = xx; 
            this.Yx = yx; 
            this.Xy = xy; 
            this.Yy = yy; 
            this.X0 = x0; 
            this.Y0 = y0;   
            
            
        } 
        public CairoMatrix() 
        { 
          _CairoMatrix = new double[Rows, Columns]; 
            for (int i = 0; i &lt; Rows; i++) 
            { 
                for (int j = 0; j &lt; Columns; j++) 
                { 
                    _CairoMatrix[i, j] = (i == j) ? 1F : 0F; 
                } 
            } 
          
        } 
      
        public CairoMatrix(int rows, int columns) 
        { 
            _rows = rows; 
            _columns = columns; 
            _CairoMatrix = new double[rows, columns]; 
            // _matrixNew = new float[rows][]; 
            //for (int i = 0; i &lt; rows; i++) 
            //{ 
            //   _matrixNew[i] = new float[columns]; 
            // } 
        } 
       
[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] 
        public CairoMatrix(int rows, int columns, double[,] matrix) 
        { 
            _CairoMatrix = matrix; 
            _rows = rows; 
            _columns = columns; 
        } 

       
[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] 
        public CairoMatrix(CairoMatrix src) 
        { 
            _rows = src._rows; 
            _columns = src._columns; 
            _CairoMatrix = (double[,])src._CairoMatrix.Clone(); 
        } 
        #endregion 

        #region Init 
        public void Init(double xx, double yx, double xy, double yy, double
x0, double y0) 
        { 
            this.Xx = xx; 
            this.Yx = yx; 
            this.Xy = xy; 
            this.Yy = yy; 
            this.X0 = x0; 
            this.Y0 = y0; 
        } 
        #endregion 

        #region Clone() 
        public CairoMatrix Clone() 
        { 
            ////return this.MemberwiseClone ();                 
            //return this.Copy();               
            CairoMatrix resultMatrix = new CairoMatrix(_rows, _columns); 
            for (int i = 0; i &lt; _rows; i++) 
            { 
                for (int j = 0; j &lt; _columns; j++) 
                { 
                    resultMatrix[i, j] = this[i, j]; 
                } 
            } 
            return resultMatrix; 
        } 
        #endregion 

        

        #region Multiply (with One Parameter) 
        public virtual CairoMatrix Multiply(CairoMatrix b) 
        { 
            //CairoMatrix a = (CairoMatrix) this.Clone (); 
            //CairoAPI.cairo_Matrix_multiply (this, a, b); 
            if (b.Rows != Columns) 
                throw new ArgumentException(&quot;Cannot multiply the two
matrices together; their sizes are incompatible.&quot;); 
            CairoMatrix _cairoMatrixP = new CairoMatrix(Rows, b.Columns); 
            double[,] C = _cairoMatrixP.Array; 
            double[] Bcolj = new double[Columns]; 
            for (int j = 0; j &lt; b.Columns; j++) 
            { 
                for (int k = 0; k &lt; Columns; k++) 
                { 
                    Bcolj[k] = b._CairoMatrix[k, j]; 
                } 
                double s = 0.0; 
                for (int i = 0; i &lt; Rows; i++) 
                { 
                    double[] Arowi = _matrixNew[i];     
                    
                    for (int k = 0; k &lt; Columns; k++) 
                    { 
                        s += Arowi[k] * Bcolj[k]; 
                    } 
                    C[i, j] = s; 
                } 

            } 

            return _cairoMatrixP; 
            
            #endregion 
        } 
        #endregion 

        

        #region Matrix Multiply(CairoMatrix leftMatrix, CairoMatrix
rightMatrix) 
        public static CairoMatrix Multiply(CairoMatrix leftMatrix,
CairoMatrix rightMatrix) 
        { 
            System.Diagnostics.Debug.Assert(leftMatrix.Columns ==
rightMatrix.Rows); 
            CairoMatrix resultMatrix = new CairoMatrix(leftMatrix.Rows,
rightMatrix.Columns); 
            for (int i = 0; i &lt; resultMatrix.Columns; i++) 
            { 
                for (int j = 0; j &lt; leftMatrix.Rows; j++) 
                { 
                    double value = 0.0; 
                    for (int k = 0; k &lt; rightMatrix.Rows; k++) 
                    { 
                        value = value + leftMatrix[j, k] * rightMatrix[k,
i]; 
                    } 
                    resultMatrix[j, i] = value; 
                } 
            } 
            return resultMatrix; 
        } 

        public static CairoMatrix operator *(CairoMatrix leftMatrix,
CairoMatrix rightMatrix) 
        { 
            return CairoMatrix.Multiply(leftMatrix, rightMatrix); 
        } 
        #endregion 

        #region Matrix Divide() 
        public static CairoMatrix Divide(CairoMatrix leftMatrix, float
right) 
        { 
            CairoMatrix resultMatrix = new CairoMatrix(leftMatrix.Rows,
leftMatrix.Columns); 
            for (int i = 0; i &lt; leftMatrix.Rows; i++) 
            { 
                for (int j = 0; j &lt; leftMatrix.Columns; j++) 
                { 
                    resultMatrix[i, j] = leftMatrix[i, j] / right; 
                } 
            } 
            return resultMatrix; 
        } 

        public static CairoMatrix operator /(CairoMatrix leftMatrix, float
right) 
        { 
            return CairoMatrix.Divide(leftMatrix, right); 
        } 
        #endregion 

      

        #region IsIdentity Property 
       
[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] 
        public bool IsIdentity 
        { 
            get 
            { 
                if (!IsSquare) 
                    return false; 

                for (int row = 0; row &lt; _rows; ++row) 
                { 
                    for (int column = 0; column &lt; _columns; ++column) 
                    { 
                        if (_CairoMatrix[row, column] != ((row == column) ?
1.0 : 0.0)) 
                            return false; 
                    } 
                } 

                return true; 
            } 
        } 
        #endregion 

        #region Invert() 
        public CairoMatrix Invert() 
        { 
            
            System.Diagnostics.Debug.Assert(_rows == _columns); 
            CairoMatrix resultMatrix = SolveFor(Identity(_rows)); 
            CairoMatrix matIdent = this * resultMatrix; 

            return SolveFor(Identity(_rows)); 
            //return Inverse(this); 
        } 
        #endregion 

        #region Identity(int size) 
        public static CairoMatrix Identity(int size) 
        { 
            CairoMatrix resultMatrix = new CairoMatrix(size, size); 
            for (int i = 0; i &lt; size; i++) 
            { 
                for (int j = 0; j &lt; size; j++) 
                { 
                    resultMatrix[i, j] = (i == j) ? 1F : 0F; 
                } 
            } 
            return resultMatrix; 
        } 
        #endregion 

        #region SolveFor() 
        public CairoMatrix SolveFor(CairoMatrix rightMatrix) 
        { 
            System.Diagnostics.Debug.Assert(rightMatrix.Rows == _columns); 
            System.Diagnostics.Debug.Assert(_columns == _rows); 

            CairoMatrix resultMatrix = new CairoMatrix(_columns,
rightMatrix.Columns); 
            LUDecompositionResults resDecomp = LUDecompose(); 
            int[] nP = resDecomp.PivotArray; 
            CairoMatrix lMatrix = resDecomp.L; 
            CairoMatrix uMatrix = resDecomp.U; 
            for (int k = 0; k &lt; rightMatrix.Columns; k++) 
            { 
                //Solve for the corresponding d Matrix from Ld=Pb 
                double sum = 0.0; 
                CairoMatrix dMatrix = new CairoMatrix(_rows, 1); 
                dMatrix[0, 0] = rightMatrix[nP[0], k] / lMatrix[0, 0]; 
                for (int i = 1; i &lt; _rows; i++) 
                { 
                    sum = 0.0; 
                    for (int j = 0; j &lt; i; j++) 
                    { 
                        sum += lMatrix[i, j] * dMatrix[j, 0]; 
                    } 
                    dMatrix[i, 0] = (rightMatrix[nP[i], k] - sum) /
lMatrix[i, i]; 
                } 
                //Solve for x using Ux = d 
                resultMatrix[_rows - 1, k] = dMatrix[_rows - 1, 0]; 
                for (int i = _rows - 2; i &gt;= 0; i--) 
                { 
                    sum = 0.0; 
                    for (int j = i + 1; j &lt; _rows; j++) 
                    { 
                        sum += uMatrix[i, j] * resultMatrix[j, k]; 
                    } 
                    resultMatrix[i, k] = dMatrix[i, 0] - sum; 
                } 
            } 
            return resultMatrix; 
        } 
        #endregion 


        public void InitIdentity()  //Instate of InitIdentity () use Reset()
Method 
            { 
                // this.Init(1,0,0,1,0,0); 
                //cairo_CairoMatrix_init_identity (this); 
                Init(this.Xx,this.Yx,this.Xy,this.Yy,this.X0,this.Y0); 
                //CairoMatrix _CairoMatrixInitIden = new CairoMatrix();                 
            } 
        public void Reset() 
        { 
            for (int i = 0; i &lt; Rows; i++) 
            { 
                for (int j = 0; j &lt; Columns; j++) 
                { 
                    _CairoMatrix[i, j] = 0; 
                } 
            } 
        } 
        #region InitTranslate() 
        public void InitTranslate(double tx, double ty) 
        { 
            //this.Init (1, 0, 0, 1, tx, ty); 
            //cairo_Matrix_init_translate (this, tx, ty); 
            this.Init(this.Xx, this.Yx, this.Xy, this.Yy, tx, ty); 
        } 
        #endregion 

        #region Translate() 
        internal  void Translate(double tx, double ty) 
        { 
            
            double[,] m = new double[3, 3] { 
                    {1.0f, 0.0f, (double)tx}, 
                    {0.0f, 1.0f, (double)ty}, 
                    {0.0f, 0.0f, 1.0f} 
                }; 
            Composite(m); 
        } 
        #endregion 

        #region InitScale() 
        public void InitScale(double sx, double sy) 
        { 
            this.Init(sx, 0, 0, sy, 0, 0); 
            //cairo_Matrix_init_scale (this, sx, sy); 
        } 
        #endregion 

       #region Scale() 
       public void Scale(double sx, double sy) 
       { 
           //cairo_Matrix_scale (this, sx, sy); 

           double[,] m = new double[3, 3] { 
                    {(double)sx, 0.0f, 0.0f}, 
                    {0.0f, (double)sy, 0.0f}, 
                    {0.0f, 0.0f, 1.0f} 
                }; 
           Composite(m); 
       } 
       #endregion 

       #region InitRotate() 
       public void InitRotate(double radians) 
       { 

           double s, c; 

           s = Math.Sin(radians); 
           c = Math.Cos(radians); 
           this.Init(c, s, -s, c, 0, 0); 

           //CairoAPI.cairo_Matrix_init_rotate (this, radians); 

       } 
       #endregion 

       #region Rotate() 
       public void Rotate(double radians) 
       { 
           //CairoAPI.cairo_Matrix_rotate (this, radians); 
           //CairoMatrix _cairo; 
           double[,] m = new double[3, 3] { 
                    {1.0f, 0.0f, 0.0f}, 
                    {0.0f, 1.0f, 0.0f}, 
                    {0.0f, 0.0f, 1.0f} 
                }; 

           m[0, 0] = (double)Math.Cos(ConvertToRadians(radians)); 
           m[0, 1] = -(double)Math.Sin(ConvertToRadians(radians)); 
           m[1, 0] = (double)Math.Sin(ConvertToRadians(radians)); 
           m[1, 1] = (double)Math.Cos(ConvertToRadians(radians)); 

           Composite(m); 

       } 

       #region ConvertToRadians() 
       private double ConvertToRadians(double angle) 
       { 
           double radians = angle * (Math.PI / 180); 
           return radians; 
       } 
       #endregion 
       #endregion 

       #region LUDecompose() 
       private LUDecompositionResults LUDecompose() 
       { 
           System.Diagnostics.Debug.Assert(_columns == _rows); 
            
           LUDecompositionResults result = new LUDecompositionResults(); 
           try 
           { 
               int[] pivotArray = new int[_rows]; //Pivot matrix. 
               CairoMatrix uMatrix = new CairoMatrix(_rows, _columns); 
               CairoMatrix lMatrix = new CairoMatrix(_rows, _columns); 
               CairoMatrix workingUMatrix = Clone(); 
               CairoMatrix workingLMatrix = new CairoMatrix(_rows,
_columns); 
               for (int i = 0; i &lt; _rows; i++) 
               { 
                   pivotArray[i] = i; 
               } 
                
               for (int i = 0; i &lt; _rows; i++) 
               { 
                    
                   double maxRowRatio = double.NegativeInfinity; 
                   int maxRow = -1; 
                   int maxPosition = -1; 
                   for (int j = i; j &lt; _rows; j++) 
                   { 
                        
                       double rowSum = 0.0; 
                        
                       for (int k = i; k &lt; _columns; k++) 
                       { 
                           rowSum += Math.Abs(workingUMatrix[pivotArray[j],
k]); 
                       } 
                        
                       if (rowSum == 0.0) 
                       { 
                           throw new SingularMatrixException(); 
                       } 
                       double dCurrentRatio =
Math.Abs(workingUMatrix[pivotArray[j], i]) / rowSum; 
                       lock (this) 
                       { 
                           if (dCurrentRatio &gt; maxRowRatio) 
                           { 
                               maxRowRatio =
Math.Abs(workingUMatrix[pivotArray[j], i] / rowSum); 
                               maxRow = pivotArray[j]; 
                               maxPosition = j; 
                           } 
                       } 
                   }                   
                   if (maxRow != pivotArray[i]) 
                   { 
                       int hold = pivotArray[i]; 
                       pivotArray[i] = maxRow; 
                       pivotArray[maxPosition] = hold; 
                   } 
                   double rowFirstElementValue =
workingUMatrix[pivotArray[i], i];                   
                   for (int j = 0; j &lt; _columns; j++) 
                   { 
                       if (j &lt; i) 
                       { 
                           //If j&lt;1, then the U matrix element value is 0. 
                           workingUMatrix[pivotArray[i], j] = 0f; 
                       } 
                       else if (j == i) 
                       { 
                           //If i == j, the L matrix value is the value of
the 
                           //element in the working U matrix. 
                           workingLMatrix[pivotArray[i], j] =
rowFirstElementValue; 
                           //The value of the U matrix for i == j is 1 
                           workingUMatrix[pivotArray[i], j] = 0F; 
                       } 
                       else // j&gt;i 
                       { 
                           //Divide each element in the current row of the U
matrix by the 
                           //value of the first element in the row 
                           workingUMatrix[pivotArray[i], j] /=
rowFirstElementValue; 
                           //The element value of the L matrix for j&gt;i is 0 
                           workingLMatrix[pivotArray[i], j] = 0.0; 
                       } 
                   } 
                   //For the working U matrix, subtract the ratioed active
row from the rows below it. 
                   //Update the columns of the rows below the working row. k
is the row index. 
                   for (int k = i + 1; k &lt; _rows; k++) 
                   { 
                       //Store the value of the first element in the working
row 
                       //of the U matrix. 
                       rowFirstElementValue = workingUMatrix[pivotArray[k],
i]; 
                       //Go accross the columns of row k. 
                       for (int j = 0; j &lt; _columns; j++) 
                       { 
                           if (j &lt; i) 
                           { 
                               //If j&lt;1, then the U matrix element value is
0. 
                               workingUMatrix[pivotArray[k], j] = 0.0; 
                           } 
                           else if (j == i) 
                           { 
                               //If i == j, the L matrix value is the value
of the 
                               //element in the working U matrix. 
                               workingLMatrix[pivotArray[k], j] =
rowFirstElementValue; 
                               //The element value of the L matrix for j&gt;i
is 0 
                               workingUMatrix[pivotArray[k], j] = 0.0; 
                           } 
                           else //j&gt;i 
                           { 
                               workingUMatrix[pivotArray[k], j] =
workingUMatrix[pivotArray[k], j] - rowFirstElementValue *
workingUMatrix[pivotArray[i], j]; 
                           } 
                       } 
                   } 
               } 
               for (int i = 0; i &lt; _rows; i++) 
               { 
                   for (int j = 0; j &lt; _rows; j++) 
                   { 
                       uMatrix[i, j] = workingUMatrix[pivotArray[i], j]; 
                       lMatrix[i, j] = workingLMatrix[pivotArray[i], j]; 
                   } 
               } 
               result.U = uMatrix; 
               result.L = lMatrix; 
               result.PivotArray = pivotArray; 
           } 
           catch (AggregateException ex2) 
           { 
               if (ex2.InnerExceptions.Count &gt; 0) 
               { 
                   throw ex2.InnerExceptions[0]; 
               } 
               else 
               { 
                   throw ex2; 
               } 
           } 
           catch (Exception ex3) 
           { 
               throw ex3; 
           } 
           return result; 
       } 
       #endregion 

       #region Transpose() 
      
[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] 
       public CairoMatrix Transpose() 
       { 
           CairoMatrix transpose = new CairoMatrix(Columns, Rows); 

           for (int row = 0; row &lt; Rows; ++row) 
           { 
               for (int column = 0; column &lt; Columns; ++column) 
                   transpose[column, row] = this[row, column]; 
           } 

           return transpose; 
       } 
       #endregion 

       #region Determinant() 
       public double Determinant() 
       { 
           #region MyRegion 
           // float[][] i = new float[3][]; 
           ////return CairoAPI.cairo_Matrix_invert (this); 
           //float det = values[0][0] * (values[1][1] * values[2][2] -
values[2][1] * values[1][2]) - values[0][1] * (values[1][0] * values[2][2] -
values[1][2] * values[2][0]) + values[0][2] * (values[1][0] * values[2][1] -
values[1][1] * values[2][0]); 
           //i[0][0] = (values[1][1] * values[2][2] - values[2][1] *
values[1][2]) / det; 
           //i[0][1] = -(values[1][0] * values[2][2] - values[1][2] *
values[2][0]) / det; 
           //i[0][2] = (values[1][0] * values[2][1] - values[2][0] *
values[1][1]) / det; 
           //i[1][0] = -(values[0][1] * values[2][2] - values[0][2] *
values[2][1]) / det; 
           //i[1][1] = (values[0][0] * values[2][2] - values[0][2] *
values[2][0]) / det; 
           //i[1][2] = -(values[0][0] * values[2][1] - values[2][0] *
values[0][1]) / det; 
           //i[2][0] = (values[0][1] * values[1][2] - values[0][2] *
values[1][1]) / det; 
           //i[2][1] = -(values[0][0] * values[1][2] - values[1][0] *
values[0][2]) / det; 
           //i[2][2] = (values[0][0] * values[1][1] - values[1][0] *
values[0][1]) / det; 
           #endregion 
           double det = ((values[0][0] * (values[1][1] * values[2][2] -
values[2][1] * values[1][2])) 
                      - (values[0][1] * (values[1][0] * values[2][2] -
values[2][0] * values[1][2])) 
                      + (values[0][2] * (values[1][0] * values[2][1] -
values[2][0] * values[1][1])) 

                      - (values[1][0] * (values[0][1] * values[2][2] -
values[0][2] * values[2][1])) 
                      + (values[1][1] * (values[0][0] * values[2][2] -
values[0][2] * values[2][0])) 
                      - (values[1][2] * (values[0][0] * values[2][1] -
values[2][0] * values[0][1])) 

                      + (values[2][0] * (values[0][1] * values[1][2] -
values[0][2] * values[1][1])) 
                      - (values[2][1] * (values[0][0] * values[1][2] -
values[1][0] * values[0][2])) 
                      + (values[2][2] * (values[0][0] * values[1][1] -
values[1][0] * values[0][1]))); 
           return det; 
       } 
       #endregion 

       #region Cofactor() 
       public CairoMatrix Cofactor() 
       { 
           CairoMatrix m = new CairoMatrix(); 
           CairoMatrix CMat = new CairoMatrix(); 
           double det; 
           for (int j = 0; j &lt;= 2; j++) 
           { 
               for (int i = 0; i &lt;= 2; i++) 
               { 

               } 
               det = m.Determinant(); 

           } 
           m = null; 
           return CMat; 
           // return this; 
       } 
       #endregion 

       #region TransformDistance(ref double dx, ref double dy) 
       public void TransformDistance(ref double dx, ref double dy)       
       { 
           double new_x, new_y; 
           CairoMatrix cm = new CairoMatrix(Xx, Yx, Xy, Yy, 0.0, 0.0); 
            
           new_x = (this.Xx * dx + this.Xy * dy); 
           new_y = (this.Yx * dx + this.Yy * dy); 
           dx = new_x; 
           dy = new_y;                     
       } 
       #endregion 

       #region TransformPoint(ref double x, ref double y) 
       public void TransformPoint(ref double x, ref double y) 
       { 
          
           //CairoAPI.cairo_Matrix_transform_point (this, ref x, ref y); 
            
           TransformDistance(ref x, ref y); 
           x = x + this.X0; 
           y = y + this.Y0; 
       }         

       #endregion 

        #region MyRegion 
        //public override String ToString () 
        //    { 
        //        String s = String.Format (&quot;xx:{0:##0.0#} yx:{1:##0.0#}
xy:{2:##0.0#} yy:{3:##0.0#} x0:{4:##0.0#} y0:{5:##0.0#}&quot;, 
        //            this.Xx, this.Yx, this.Xy, this.Yy, this.X0, this.Y0); 
        //        return s; 
        //    } 
        #endregion	

        #region ToString() 
        public override string ToString() 
        { 
            StringBuilder builder = new StringBuilder(); 

            for (int row = 0; row &lt; Rows; ++row) 
            { 
                builder.Append(&quot;( &quot;); 
                for (int column = 0; column &lt; Columns; ++column) 
                { 
                    builder.Append(_CairoMatrix[row,
column].ToString(&quot;F4&quot;)); 
                    if (column &lt; (Columns - 1)) 
                        builder.Append(&quot;  &quot;); 
                } 

                builder.Append(&quot;)&quot;); 
                if (row &lt; (Rows - 1)) 
                    builder.Append(&quot;, &quot;); 
            } 
            return builder.ToString(); 
        } 
        #endregion 

        #region Equals(object o) 
        public override bool Equals(object o) 
        { 
            if (!(o is CairoMatrix)) 
                return false; 
            else 
                return (this == (CairoMatrix)o); 
        } 
        #endregion 

        #region GetHashCode() 
        public override int GetHashCode() 
        { 
            return (int)this.Xx ^ (int)this.Xx &gt;&gt; 32 ^ 
                (int)this.Xy ^ (int)this.Xy &gt;&gt; 32 ^ 
                (int)this.Yx ^ (int)this.Yx &gt;&gt; 32 ^ 
                (int)this.Yy ^ (int)this.Yy &gt;&gt; 32 ^ 
                (int)this.X0 ^ (int)this.X0 &gt;&gt; 32 ^ 
                (int)this.Y0 ^ (int)this.Y0 &gt;&gt; 32; 
        } 
        #endregion 

        #region  Composite() 
        private void Composite(double[,] m) 
        { 
            _CairoMatrix[0, 0] = _CairoMatrix[0, 0] * m[0, 0] +
_CairoMatrix[0, 1] * m[1, 0] + _CairoMatrix[0, 2] * m[2, 0]; 
            _CairoMatrix[0, 1] = _CairoMatrix[0, 0] * m[0, 1] +
_CairoMatrix[0, 1] * m[1, 1] + _CairoMatrix[0, 2] * m[2, 1]; 
            _CairoMatrix[0, 2] = _CairoMatrix[0, 0] * m[0, 2] +
_CairoMatrix[0, 1] * m[1, 2] + _CairoMatrix[0, 2] * m[2, 2]; 

            _CairoMatrix[1, 0] = _CairoMatrix[1, 0] * m[0, 0] +
_CairoMatrix[1, 1] * m[1, 0] + _CairoMatrix[1, 2] * m[2, 0]; 
            _CairoMatrix[1, 1] = _CairoMatrix[1, 0] * m[0, 1] +
_CairoMatrix[1, 1] * m[1, 1] + _CairoMatrix[1, 2] * m[2, 1]; 
            _CairoMatrix[1, 2] = _CairoMatrix[1, 0] * m[0, 2] +
_CairoMatrix[1, 1] * m[1, 2] + _CairoMatrix[1, 2] * m[2, 2]; 

            _CairoMatrix[2, 0] = _CairoMatrix[2, 0] * m[0, 0] +
_CairoMatrix[2, 1] * m[1, 0] + _CairoMatrix[2, 2] * m[2, 0]; 
            _CairoMatrix[2, 1] = _CairoMatrix[2, 0] * m[0, 1] +
_CairoMatrix[2, 1] * m[1, 1] + _CairoMatrix[2, 2] * m[2, 1]; 
            _CairoMatrix[2, 2] = _CairoMatrix[2, 0] * m[0, 2] +
_CairoMatrix[2, 1] * m[1, 2] + _CairoMatrix[2, 2] * m[2, 2]; 
        } 
        #endregion 
        
    }     
    } 

-----
Regards
Pritish
--
View this message in context: <A HREF="http://mono-for-android.1047100.n5.nabble.com/Images-gets-Blur-while-minimizing-the-size-in-height-width-tp5444240p5444240.html">http://mono-for-android.1047100.n5.nabble.com/Images-gets-Blur-while-minimizing-the-size-in-height-width-tp5444240p5444240.html</A>
Sent from the Mono for Android mailing list archive at Nabble.com.
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008677.html">[mono-android] another Java versus C# how to
</A></li>
	<LI>Next message: <A HREF="008673.html">[mono-android] Nook apps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8672">[ date ]</a>
              <a href="thread.html#8672">[ thread ]</a>
              <a href="subject.html#8672">[ subject ]</a>
              <a href="author.html#8672">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodroid">More information about the Monodroid
mailing list</a><br>
</body></html>
