<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [mono-android] Webrequests, architecture and memory management.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodroid%40lists.ximian.com?Subject=Re%3A%20%5Bmono-android%5D%20Webrequests%2C%20architecture%20and%20memory%20management.&In-Reply-To=%3CCAGmkodseDWkcnCc3QLaMUk-1saB_y%2Bd0Q9d1b3NA8JYgMYrx6A%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011180.html">
   <LINK REL="Next"  HREF="011194.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mono-android] Webrequests, architecture and memory management.</H1>
    <B>Liam Houlahan</B> 
    <A HREF="mailto:monodroid%40lists.ximian.com?Subject=Re%3A%20%5Bmono-android%5D%20Webrequests%2C%20architecture%20and%20memory%20management.&In-Reply-To=%3CCAGmkodseDWkcnCc3QLaMUk-1saB_y%2Bd0Q9d1b3NA8JYgMYrx6A%40mail.gmail.com%3E"
       TITLE="[mono-android] Webrequests, architecture and memory management.">liamhoulahan at gmail.com
       </A><BR>
    <I>Mon Jul  2 03:16:42 UTC 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="011180.html">[mono-android] Webrequests, architecture and memory management.
</A></li>
        <LI>Next message: <A HREF="011194.html">[mono-android] Webrequests, architecture and memory management.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11187">[ date ]</a>
              <a href="thread.html#11187">[ thread ]</a>
              <a href="subject.html#11187">[ subject ]</a>
              <a href="author.html#11187">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Jonathan

Thank you for your detailed response. I have made some progress since I
posted this message and have some new questions about some of the things I
have discovered.

1. Calling the GC did help with things however because the GC takes a
millisecond or whatever to execute the UI suffers and gets a stutter
effect. Is there a way to avoid this?

In terms of memory management and making requests based on the individual
activities my biggest concern is really the user flooding the app with
network requests. Something else that has an influence on this in my app is
that I am also loading images within my activities and caching them. I
suspect that this was a cause for getting out of memory.

I have come up with a solution based on the ImageLoader in the MWC app. I
have managed to hack together a version of this ImageLoader that unifies
queuing of the image requests and the data requests. This seemed good for
managing the memory but it now has some other issues. Ideally what I think
I need is:
 - Two queues one for images and one for the data requests.
 - The worker for processing the queues should limit the number of requests
across the queues.
 - The data queue should take higher priority to the image queue. So the
data queue is always processed before the image queue.
 - If the activity is destroyed before loading all of the data/images it
should dequeue any outstanding requests. Any ideas how I might dequeue if I
am using something like the ImageLoader from the MWC app?

What are your thoughts on this design for managing the requests?

I still need to make individual requests for each activity as the data
retrieved from each request is specific to the individual activity and it
can only be retrieved on the per activity basis. I need to have realtime up
to date info for each activity.

If I initiate the all of the requests from the Application class as you
suggest and then raise the events to update the activities from the
application class when raising the event should it always be done on the UI
thread using SynchronizationContext.Post? Or is it ok to raise it on
another thread, then in the event handler in the Activity call
RunOnUIThread?

Thanks again
Liam


On Mon, Jul 2, 2012 at 8:13 AM, Jonathan Pryor &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodroid">jonp at xamarin.com</A>&gt; wrote:

&gt;<i> General questions:
</I>&gt;<i>
</I>&gt;<i> 1. Does calling GC.Collect() anywhere help with your memory use? It could
</I>&gt;<i> just be that the GC's allocation limits aren't entirely appropriate, and
</I>&gt;<i> calling GC.Collect() will help:
</I>&gt;<i>
</I>&gt;<i>         <A HREF="http://docs.xamarin.com/android/advanced_topics/garbage_collection">http://docs.xamarin.com/android/advanced_topics/garbage_collection</A>
</I>&gt;<i>
</I>&gt;<i> 2. Are there lots of peer instances that can be more quickly collected?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://docs.xamarin.com/android/advanced_topics/garbage_collection#Cross-VM_Object_Collections">http://docs.xamarin.com/android/advanced_topics/garbage_collection#Cross-VM_Object_Collections</A>
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://docs.xamarin.com/android/advanced_topics/garbage_collection#Helping_the_GC">http://docs.xamarin.com/android/advanced_topics/garbage_collection#Helping_the_GC</A>
</I>&gt;<i>         <A HREF="http://docs.xamarin.com/android/advanced_topics/diagnostics">http://docs.xamarin.com/android/advanced_topics/diagnostics</A>
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://docs.xamarin.com/android/advanced_topics/diagnostics#Global_Reference_Messages">http://docs.xamarin.com/android/advanced_topics/diagnostics#Global_Reference_Messages</A>
</I>&gt;<i>
</I>&gt;<i> 2(b): How is your gref count? You can enable gref logging with:
</I>&gt;<i>
</I>&gt;<i>         adb shell setprop debug.mono.log gref
</I>&gt;<i>
</I>&gt;<i> then every monodroid-gref message will contain the current gref count.
</I>&gt;<i>
</I>&gt;<i> On Jun 28, 2012, at 10:57 PM, Liam Houlahan wrote:
</I>&gt;<i> &gt; The scenario that I have for my app is. On first start up each day the
</I>&gt;<i> app will do an initial large download. By large I mean a couple of hundred
</I>&gt;<i> kbs.
</I>&gt;<i> &gt; After the large download when the user accesses parent activities for
</I>&gt;<i> the first time they will download all of the child data.
</I>&gt;<i>
</I>&gt;<i> How big is the child data download? How much memory does that
</I>&gt;<i> approximately take, post-download? (You can use GC.GetTotalMemory(false)
</I>&gt;<i> before your web request and after it returns to see how much memory has
</I>&gt;<i> been used, approximately.)
</I>&gt;<i>
</I>&gt;<i> &gt; To update the UI for the large download I am using event handlers in my
</I>&gt;<i> activities assigned to a static event in my service class. For the other
</I>&gt;<i> smaller requests I am using callbacks to the Activities.
</I>&gt;<i>
</I>&gt;<i> You'd need to provide more detail regarding how _exactly_ you do this;
</I>&gt;<i> done wrong, this could mean that no Activities can ever be collected (as
</I>&gt;<i> the static event is referring to them), so you'd have a steadily increasing
</I>&gt;<i> gref count and increasing memory use.
</I>&gt;<i>
</I>&gt;<i> An alternative approach is to instead use
</I>&gt;<i> Android.App.Application.SynchronizationContext.Post(...) to invoke
</I>&gt;<i> something on the UI thread.
</I>&gt;<i>
</I>&gt;<i> &gt; Some more specific things that I am wandering about are:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  - What is the best way to update the UI from async webrequest methods?
</I>&gt;<i> i.e. using action callbacks or events.
</I>&gt;<i>
</I>&gt;<i> Most direct would be Activity.RunOnUiThread(), but if that isn't available
</I>&gt;<i> then using Application.SynchronizationContext will work, and in &gt;= 4.2.3
</I>&gt;<i> then System.Threading.SynchronizationContext will actually work (wow!), but
</I>&gt;<i> note that SynchronizationContext.Current is [ThreadStatic], so you'd need
</I>&gt;<i> to either pass the SynchronizationContext to the worker thread (via a
</I>&gt;<i> closure?) or use TAP (which iirc should implicitly pass
</I>&gt;<i> SynchronizationContext.Current...on .NET, but I haven't tested on Mono;
</I>&gt;<i> test accordingly).
</I>&gt;<i>
</I>&gt;<i> &gt;  - Should database access and async webrequests be initiated from
</I>&gt;<i> threads separate to the UI thread or is it best to just call them from the
</I>&gt;<i> UI thread? If it is better to use separate threads where should these
</I>&gt;<i> threads be started? e.g. in the activity.
</I>&gt;<i>
</I>&gt;<i> Async web requests should be fine. Database access _may_ be fine; it
</I>&gt;<i> depends on the performance characteristics of SQLite and your data set. If
</I>&gt;<i> you're confident that it won't block the UI thread for long periods of
</I>&gt;<i> time, it's likely safe, but if you're not confident of that you should move
</I>&gt;<i> the writes onto another thread.
</I>&gt;<i>
</I>&gt;<i> &gt;  - For manually calling the Garbage Collector, should the GC be called
</I>&gt;<i> after each web request? If it should which part of the app should the GC be
</I>&gt;<i> called in and when? i.e in the service class after the download or in the
</I>&gt;<i> activity after displaying the updated results?
</I>&gt;<i>
</I>&gt;<i> Where (1) consistently works in reducing memory use, and (2) is
</I>&gt;<i> convenient. ;-)
</I>&gt;<i>
</I>&gt;<i> There's a bit of trial and error here...
</I>&gt;<i>
</I>&gt;<i> &gt;  - If a user opens an activity that starts a webrequest then goes back
</I>&gt;<i> opens another activity starting more requests how should the app deal with
</I>&gt;<i> this? Should the requests from the first activity be cancelled before
</I>&gt;<i> starting the next etc. If I am using a callback to the activity for an
</I>&gt;<i> async webrequest and the activity is destroyed before the webrequest
</I>&gt;<i> finishes what is the result of this?
</I>&gt;<i>
</I>&gt;<i> Again, it depends on your code structure. The most obvious way would
</I>&gt;<i> result in the Async web request referencing the launching Activity, which
</I>&gt;<i> would thus prevent the GC from collecting the Activity instance, so when
</I>&gt;<i> the web request returns it'll act on a (&quot;dead&quot;) Activity instance. This has
</I>&gt;<i> the added downside that if the user starts, &quot;exits&quot;, then starts your app,
</I>&gt;<i> you may launch the same web request twice, downloading more data than is
</I>&gt;<i> necessary.
</I>&gt;<i>
</I>&gt;<i> Instead, what I would suggest is that your web requests know ~nothing of
</I>&gt;<i> the UI. Instead, you should e.g. subclass Android.App.Application [0], and
</I>&gt;<i> have a data cache in the Application instance. The Web request would update
</I>&gt;<i> this data cache.
</I>&gt;<i>
</I>&gt;<i> Next, Activity.OnCreate() can register with an Application event, and
</I>&gt;<i> Activity.OnDestroy() can unregister the Activity with the Application.
</I>&gt;<i> (Both are important, to allow the Activity instances to be collectable!)
</I>&gt;<i> Next, updates to the Application data cache can raise the Application
</I>&gt;<i> event, allowing Activities to be notified that data is available/has
</I>&gt;<i> changed.
</I>&gt;<i>
</I>&gt;<i> The result of such an architecture is that, with some logic, you can
</I>&gt;<i> ensure that only one Web request is generated within a short time period
</I>&gt;<i> (instead of one/Activity), all data is (reasonably) up-to-date, and all
</I>&gt;<i> instances can be collected when they are no longer used.
</I>&gt;<i>
</I>&gt;<i>  - Jon
</I>&gt;<i>
</I>&gt;<i> [0]
</I>&gt;<i> <A HREF="https://github.com/xamarin/monodroid-samples/blob/master/SanityTests/Hello.cs#L92">https://github.com/xamarin/monodroid-samples/blob/master/SanityTests/Hello.cs#L92</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Monodroid mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monodroid">Monodroid at lists.ximian.com</A>
</I>&gt;<i>
</I>&gt;<i> UNSUBSCRIBE INFORMATION:
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monodroid">http://lists.ximian.com/mailman/listinfo/monodroid</A>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.ximian.com/pipermail/monodroid/attachments/20120702/e7c0b400/attachment.html">http://lists.ximian.com/pipermail/monodroid/attachments/20120702/e7c0b400/attachment.html</A>&gt;
</PRE>

















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011180.html">[mono-android] Webrequests, architecture and memory management.
</A></li>
	<LI>Next message: <A HREF="011194.html">[mono-android] Webrequests, architecture and memory management.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11187">[ date ]</a>
              <a href="thread.html#11187">[ thread ]</a>
              <a href="subject.html#11187">[ subject ]</a>
              <a href="author.html#11187">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodroid">More information about the Monodroid
mailing list</a><br>
</body></html>
