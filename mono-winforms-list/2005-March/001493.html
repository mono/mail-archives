<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-winforms-list] Matrix memory management in GDI+ bug
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:Laurent%20Debacker%20%3Cdebackerl%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001492.html">
   <LINK REL="Next"  HREF="001494.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-winforms-list] Matrix memory management in GDI+ bug
   </H1>
    <B>Laurent Debacker
    </B> 
    <A HREF="mailto:Laurent%20Debacker%20%3Cdebackerl%40gmail.com%3E"
       TITLE="[Mono-winforms-list] Matrix memory management in GDI+ bug">Laurent Debacker &lt;debackerl@gmail.com&gt;
       </A><BR>
    <I>Sat, 12 Mar 2005 11:18:22 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="001492.html">[Mono-winforms-list] Re: solaris 10
</A></li>
        <LI> Next message: <A HREF="001494.html">[Mono-winforms-list] Matrix memory management in GDI+ bug
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1493">[ date ]</a>
              <a href="thread.html#1493">[ thread ]</a>
              <a href="subject.html#1493">[ subject ]</a>
              <a href="author.html#1493">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>------=_Part_1153_22832510.1110622702641
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi,

There's is a bug in the way mono manage the unmanaged matrix in libgdiplus.

What I wanted to do is to save the transform matrix used in a Graphics
object, save it in a global variable to reuse it later in other
Graphics objects. It's just for optimization purpose.

However Mono's System.Drawing.Drawing2D.Matrix doesn't behave like
Microsoft's one.

With Microsoft I can take the transform matrix from a matrix, even
Dispose() it, then give it to another Graphics object, and it still
works. I know it's tricky to Dispose() there, but I wanted to do
futher research.

In Mono, Matrix.Dipose() (see source code
<A HREF="http://svn.myrealbox.com/viewcvs/trunk/mcs/class/System.Drawing/System.Drawing.Drawing2D/Matrix.cs?rev=31166&view=auto">http://svn.myrealbox.com/viewcvs/trunk/mcs/class/System.Drawing/System.Drawing.Drawing2D/Matrix.cs?rev=31166&amp;view=auto</A>
 just always call GdipDeleteMatrix in libgdiplus
(<A HREF="http://svn.myrealbox.com/viewcvs/trunk/libgdiplus/src/matrix.c?rev=39075&view=auto">http://svn.myrealbox.com/viewcvs/trunk/libgdiplus/src/matrix.c?rev=39075&amp;view=auto</A>),
which in turn calls cairo_matrix_destroy
(<A HREF="http://svn.myrealbox.com/viewcvs/trunk/libgdiplus/cairo/src/cairo_matrix.c?rev=39488&view=auto">http://svn.myrealbox.com/viewcvs/trunk/libgdiplus/cairo/src/cairo_matrix.c?rev=39488&amp;view=auto</A>),
which simply do a free().

So your implementation is logic, but isn't compatible with Microsoft's one.

I would recommand you to call GdipDeleteMatrix in the destructor of
System.Drawing.Drawing2D.Matrix, and leave Dipose() empty. That way as
long as the managed Matrix lives, the unmanaged one will also.

The error message I got with my code was &quot;mono in free(): error: chunk
is already free&quot; under FreeBSD 5.3-RELEASE, and libgdiplus-devel,
mono-devel (1.1.4) from the BSD# project
(<A HREF="http://forge.novell.com/modules/xfmod/project/?bsd-sharp">http://forge.novell.com/modules/xfmod/project/?bsd-sharp</A>).

Regards,
Laurent Debacker.

------=_Part_1153_22832510.1110622702641
Content-Type: text/plain; name=&quot;Map.cs&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename=&quot;Map.cs&quot;

using System;
using System.Drawing;
using System.Collections;
using System.Collections.Specialized;

namespace GUI
{
=09public class Map
=09{
=09=09private const float AI_SIZE =3D 10.0f;

=09=09private RectangleF bounds;
=09=09private Hashtable nodes;
=09=09private Hashtable segments;
=09=09private ListDictionary ais;
=09=09private ListDictionary roads;

=09=09private bool mapComplete;
=09=09private bool needRedraw;
=09=09private Image map;
=09=09private Image buffer;
=09=09private Brush grassBrush;
=09=09private Brush roadBrush;
=09=09private float ratio;
private System.Drawing.Drawing2D.Matrix transform;
=09=09public event EventHandler LayoutChanged;
=09=09public event EventHandler Update;

=09=09public RectangleF Bounds
=09=09{
=09=09=09get { return bounds; }
=09=09}

=09=09public ICollection Roads
=09=09{
=09=09=09get { return roads.Values; }
=09=09}

=09=09public ICollection AIs
=09=09{
=09=09=09get { return ais.Values; }
=09=09}

=09=09public Map()
=09=09{
=09=09=09nodes =3D new Hashtable();
=09=09=09segments =3D new Hashtable();
=09=09=09ais =3D new ListDictionary();
=09=09=09roads =3D new ListDictionary();
=09=09=09bounds =3D RectangleF.Empty;

=09=09=09mapComplete =3D false;
=09=09=09needRedraw =3D true;
=09=09=09map =3D null;

=09=09=09string path =3D this.GetType().Assembly.Location;
=09=09=09int i =3D path.LastIndexOf(&quot;/&quot;);
=09=09=09if(i =3D=3D -1) path.LastIndexOf(@&quot;\&quot;);
=09=09=09path =3D path.Substring(0, i + 1);

=09=09=09Image grassImg =3D new Bitmap(path + &quot;grass.png&quot;);
=09=09=09grassBrush =3D new TextureBrush(grassImg);
=09=09=09Image roadImg =3D new Bitmap(path + &quot;road.png&quot;);
=09=09=09roadBrush =3D new TextureBrush(roadImg);
=09=09}

=09=09public void SetSegment(SegmentInfo Si)
=09=09{
=09=09=09if(segments.Contains(Si.ID)) return;

=09=09=09Road r;
=09=09=09Segment s;
=09=09=09long key =3D Si.Source.ID &lt; Si.Destination.ID ? ((long)Si.Source.I=
D &lt;&lt; 32) + Si.Destination.ID : ((long)Si.Destination.ID &lt;&lt; 32) + Si.Source.=
ID;
=09=09=09if((r =3D (Road)roads[key]) =3D=3D null) roads[key] =3D r =3D new =
Road(Si.Source, Si.Destination);
=09=09=09segments.Add(Si.ID, s =3D new Segment(Si));
=09=09=09r.AddSegment(s);
=09=09=09if(mapComplete) OnLayoutChanged(null);
=09=09}

=09=09public void SetNode(NodeInfo Ni)
=09=09{
=09=09=09if(!nodes.Contains(Ni.ID))
=09=09=09{
=09=09=09=09//if(!bounds.IsEmpty) MONO FIX
=09=09=09=09if(nodes.Count !=3D 0)
=09=09=09=09{
=09=09=09=09=09if(Ni.X &lt; bounds.Left) bounds.X =3D Ni.X;
=09=09=09=09=09else if(Ni.X &gt; bounds.Right) bounds.Width =3D Ni.X - bounds.=
X;
=09=09=09=09=09if(Ni.Y &lt; bounds.Top) bounds.Y =3D Ni.Y;
=09=09=09=09=09else if(Ni.Y &gt; bounds.Bottom) bounds.Height =3D Ni.Y - bound=
s.Y;
=09=09=09=09}
=09=09=09=09else
=09=09=09=09=09bounds =3D new RectangleF(Ni.X, Ni.Y, 0.0f, 0.0f);

=09=09=09=09nodes.Add(Ni.ID, Ni);
=09=09=09}
=09=09=09if(mapComplete) OnLayoutChanged(null);
=09=09}

=09=09public NodeInfo GetNodeByID(int ID)
=09=09{
=09=09=09return (NodeInfo)nodes[ID];
=09=09}

=09=09public void MapComplete()
=09=09{
=09=09=09mapComplete =3D true;
=09=09=09needRedraw =3D true;
=09=09=09OnLayoutChanged(null);
=09=09}

=09=09public void MoveAI(int ID, int Segment, float Position)
=09=09{
=09=09=09AI ai =3D (AI)ais[ID];
=09=09=09if(ai =3D=3D null) ais[ID] =3D ai =3D new AI(ID);
=09=09=09ai.Segment =3D (Segment)segments[Segment];
=09=09=09if(ai.Segment =3D=3D null) throw new Exception(&quot;AI in unknown segm=
ent.&quot;);
=09=09=09ai.Position =3D Position;
=09=09=09OnUpdate(null);
=09=09}

=09=09public void RemoveAI(int ID)
=09=09{
=09=09=09ais.Remove(ID);
=09=09=09OnUpdate(null);
=09=09}

=09=09public void Render(Graphics G, Rectangle Area)
=09=09{
=09=09=09Rectangle drawingArea =3D new Rectangle(10, 10, Area.Width - 20, A=
rea.Height - 20);

=09=09=09if(map =3D=3D null || map.Width !=3D Area.Width || map.Height !=3D=
 Area.Height)
=09=09=09{
=09=09=09=09if(map !=3D null) map.Dispose();
=09=09=09=09map =3D new Bitmap(Area.Width, Area.Height);

=09=09=09=09Graphics g =3D Graphics.FromImage(map);
=09=09=09=09g.FillRectangle(grassBrush, 0, 0, Area.Width, Area.Height);

=09=09=09=09if(mapComplete)
=09=09=09=09{
=09=09=09=09=09ratio =3D drawingArea.Width / Bounds.Width;
=09=09=09=09=09float ratio2 =3D drawingArea.Height / Bounds.Height;
=09=09=09=09=09ratio =3D ratio &gt; ratio2 ? ratio2 : ratio;

=09=09=09=09=09g.TranslateTransform(drawingArea.X, drawingArea.Y);
=09=09=09=09=09g.ScaleTransform(ratio, ratio);
=09=09=09=09=09g.TranslateTransform(-Bounds.X, -Bounds.Y);
=09=09=09=09=09transform =3D g.Transform;
g.Transform.Dispose();=09/* Even with this it works under MS .NET */

=09=09=09=09=09Pen roadLinePen =3D new Pen(Color.DarkKhaki, 3.0f);
=09=09=09=09=09roadLinePen.DashStyle =3D System.Drawing.Drawing2D.DashStyle=
.Custom;
=09=09=09=09=09roadLinePen.DashPattern =3D new float[] { 16.0f, 8.0f };

=09=09=09=09=09foreach(Road r in Roads)
=09=09=09=09=09{
=09=09=09=09=09=09g.FillPolygon(roadBrush, r.Vertexes);
=09=09=09=09=09=09foreach(PointF[] pts in r.Lines)
=09=09=09=09=09=09{
=09=09=09=09=09=09=09g.DrawLine(roadLinePen, pts[0], pts[1]);
=09=09=09=09=09=09}
=09=09=09=09=09}
=09=09=09=09}

=09=09=09=09g.Dispose();
=09=09=09}

=09=09=09if(needRedraw || buffer.Width !=3D Area.Width || buffer.Height !=
=3D Area.Height)
=09=09=09{
=09=09=09=09if(buffer =3D=3D null || buffer.Width !=3D Area.Width || buffer=
.Height !=3D Area.Height)
=09=09=09=09{
=09=09=09=09=09if(buffer !=3D null) buffer.Dispose();
=09=09=09=09=09buffer =3D new Bitmap(Area.Width, Area.Height);
=09=09=09=09}

=09=09=09=09Graphics g =3D Graphics.FromImage(buffer);
=09=09=09=09g.DrawImageUnscaled(map, 0, 0);

=09=09=09=09if(mapComplete)
=09=09=09=09{
=09=09=09=09=09g.Transform =3D transform;=09/* MONO FIX &quot;mono in free(): er=
ror: chunk is already free&quot; */
=09=09=09=09=09/*g.TranslateTransform(drawingArea.X, drawingArea.Y);
=09=09=09=09=09g.ScaleTransform(ratio, ratio);
=09=09=09=09=09g.TranslateTransform(-Bounds.X, -Bounds.Y);*/

=09=09=09=09=09Brush whiteBrush =3D new SolidBrush(Color.White);
=09=09=09=09=09foreach(AI ai in AIs)
=09=09=09=09=09{
=09=09=09=09=09=09Segment s =3D ai.Segment;
=09=09=09=09=09=09float p =3D ai.Position / s.Length;
=09=09=09=09=09=09PointF center =3D new PointF(s.Source.X + (s.Destination.=
X - s.Source.X) * p, s.Source.Y + (s.Destination.Y - s.Source.Y) * p);
=09=09=09=09=09=09g.FillEllipse(whiteBrush, center.X - AI_SIZE/2, center.Y =
- AI_SIZE/2, AI_SIZE, AI_SIZE);
=09=09=09=09=09}
=09=09=09=09}

=09=09=09=09g.Dispose();
=09=09=09=09needRedraw =3D false;
=09=09=09}

=09=09=09G.DrawImageUnscaled(buffer, Area.X, Area.Y);
=09=09}

=09=09protected void OnLayoutChanged(EventArgs e)
=09=09{
=09=09=09map =3D null;
=09=09=09if(LayoutChanged !=3D null) LayoutChanged(this, e);
=09=09=09OnUpdate(e);
=09=09}

=09=09protected void OnUpdate(EventArgs e)
=09=09{
=09=09=09needRedraw =3D true;
=09=09=09if(Update !=3D null) Update(this, e);
=09=09}
=09}
}

------=_Part_1153_22832510.1110622702641--

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001492.html">[Mono-winforms-list] Re: solaris 10
</A></li>
	<LI> Next message: <A HREF="001494.html">[Mono-winforms-list] Matrix memory management in GDI+ bug
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1493">[ date ]</a>
              <a href="thread.html#1493">[ thread ]</a>
              <a href="subject.html#1493">[ subject ]</a>
              <a href="author.html#1493">[ author ]</a>
         </LI>
       </UL>
</body></html>
