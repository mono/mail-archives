<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-winforms-list] Bug in	System.Windows.Forms.Control:get_ContainsFocus ()?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-winforms-list%40lists.ximian.com?Subject=%5BMono-winforms-list%5D%20Bug%20in%0A%09System.Windows.Forms.Control%3Aget_ContainsFocus%20%28%29%3F&In-Reply-To=44992952.7050200%40paddyjoy.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002381.html">
   <LINK REL="Next"  HREF="002384.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-winforms-list] Bug in	System.Windows.Forms.Control:get_ContainsFocus ()?</H1>
    <B>Rafael Teixeira</B> 
    <A HREF="mailto:mono-winforms-list%40lists.ximian.com?Subject=%5BMono-winforms-list%5D%20Bug%20in%0A%09System.Windows.Forms.Control%3Aget_ContainsFocus%20%28%29%3F&In-Reply-To=44992952.7050200%40paddyjoy.com"
       TITLE="[Mono-winforms-list] Bug in	System.Windows.Forms.Control:get_ContainsFocus ()?">monoman at gmail.com
       </A><BR>
    <I>Wed Jun 21 08:49:31 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="002381.html">[Mono-winforms-list] Bug	in	System.Windows.Forms.Control:get_ContainsFocus ()?
</A></li>
        <LI>Next message: <A HREF="002384.html">[Mono-winforms-list] Bug in System.Windows.Forms.Control:get_ContainsFocus ()?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2382">[ date ]</a>
              <a href="thread.html#2382">[ thread ]</a>
              <a href="subject.html#2382">[ subject ]</a>
              <a href="author.html#2382">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Paddy,

Why do you return base.ContainFocus instead of base.Focused from your
overriden Focused? That way you are introducing infinite recursion as
Control.ContainsFocus calls Control.Focused, that in your case is
overriden.

In truth, unless this is just some small code to show the problem, I
don't see any need to override Focused... Even more to change its
semantics.

Anyway if that code works in MS.NET, we should not rely on Focused to
determine partially the value of ContainsFocus (ContainsFocus also
checks children if the Control per se isn't with focus). Test it in
MS.NEt and if it works OK, please fill a bug for MWF, thanks.

:|<i>
</I>
On 6/21/06, Paddy Joy &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-winforms-list">mono at paddyjoy.com</A>&gt; wrote:
&gt;<i> How about this code, I'm pretty sure that it instantiates button2
</I>&gt;<i> correctly now but still gives the segmentation error.
</I>&gt;<i>
</I>&gt;<i> I have declared the button with:
</I>&gt;<i> private testbutton button2;
</I>&gt;<i>
</I>&gt;<i> and instantiated it with:
</I>&gt;<i> this.button2 = new testbutton();
</I>&gt;<i>
</I>&gt;<i> Thanks for the help,
</I>&gt;<i> Paddy
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> using System;
</I>&gt;<i> using System.Drawing;
</I>&gt;<i> using System.Collections;
</I>&gt;<i> using System.ComponentModel;
</I>&gt;<i> using System.Windows.Forms;
</I>&gt;<i> using System.Data;
</I>&gt;<i>
</I>&gt;<i> namespace WindowsApplication4
</I>&gt;<i> {
</I>&gt;<i>     /// &lt;summary&gt;
</I>&gt;<i>     /// Summary description for Form1.
</I>&gt;<i>     /// &lt;/summary&gt;
</I>&gt;<i>     public class Form1 : System.Windows.Forms.Form
</I>&gt;<i>     {
</I>&gt;<i>         private System.Windows.Forms.Button button1;
</I>&gt;<i>         private testbutton button2;
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// Required designer variable.
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         private System.ComponentModel.Container components = null;
</I>&gt;<i>
</I>&gt;<i>         public Form1()
</I>&gt;<i>         {
</I>&gt;<i>             //
</I>&gt;<i>             // Required for Windows Form Designer support
</I>&gt;<i>             //
</I>&gt;<i>             InitializeComponent();
</I>&gt;<i>
</I>&gt;<i>             //
</I>&gt;<i>             // TODO: Add any constructor code after InitializeComponent call
</I>&gt;<i>             //
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// Clean up any resources being used.
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         protected override void Dispose( bool disposing )
</I>&gt;<i>         {
</I>&gt;<i>             if( disposing )
</I>&gt;<i>             {
</I>&gt;<i>                 if (components != null)
</I>&gt;<i>                 {
</I>&gt;<i>                     components.Dispose();
</I>&gt;<i>                 }
</I>&gt;<i>             }
</I>&gt;<i>             base.Dispose( disposing );
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         #region Windows Form Designer generated code
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// Required method for Designer support - do not modify
</I>&gt;<i>         /// the contents of this method with the code editor.
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         private void InitializeComponent()
</I>&gt;<i>         {
</I>&gt;<i>             this.button1 = new System.Windows.Forms.Button();
</I>&gt;<i>             this.button2 = new testbutton();
</I>&gt;<i>             this.SuspendLayout();
</I>&gt;<i>             //
</I>&gt;<i>             // button1
</I>&gt;<i>             //
</I>&gt;<i>             this.button1.Location = new System.Drawing.Point(96, 32);
</I>&gt;<i>             this.button1.Name = &quot;button1&quot;;
</I>&gt;<i>             this.button1.TabIndex = 0;
</I>&gt;<i>             this.button1.Text = &quot;button1&quot;;
</I>&gt;<i>             this.button1.Click += new
</I>&gt;<i> System.EventHandler(this.button1_Click);
</I>&gt;<i>             //
</I>&gt;<i>             // button2
</I>&gt;<i>             //
</I>&gt;<i>             this.button2.Location = new System.Drawing.Point(96, 80);
</I>&gt;<i>             this.button2.Name = &quot;button2&quot;;
</I>&gt;<i>             this.button2.TabIndex = 1;
</I>&gt;<i>             this.button2.Text = &quot;button2&quot;;
</I>&gt;<i>             //
</I>&gt;<i>             // Form1
</I>&gt;<i>             //
</I>&gt;<i>             this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
</I>&gt;<i>             this.ClientSize = new System.Drawing.Size(292, 262);
</I>&gt;<i>             this.Controls.Add(this.button2);
</I>&gt;<i>             this.Controls.Add(this.button1);
</I>&gt;<i>             this.Name = &quot;Form1&quot;;
</I>&gt;<i>             this.Text = &quot;Form1&quot;;
</I>&gt;<i>             this.ResumeLayout(false);
</I>&gt;<i>
</I>&gt;<i>         }
</I>&gt;<i>         #endregion
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// The main entry point for the application.
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         [STAThread]
</I>&gt;<i>         static void Main()
</I>&gt;<i>         {
</I>&gt;<i>             Application.Run(new Form1());
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         private void button1_Click(object sender, System.EventArgs e)
</I>&gt;<i>         {
</I>&gt;<i>             Console.Write(button2.Focused);
</I>&gt;<i>         }
</I>&gt;<i>     }
</I>&gt;<i>
</I>&gt;<i>     public class testbutton : System.Windows.Forms.Button
</I>&gt;<i>     {
</I>&gt;<i>
</I>&gt;<i>         public testbutton()
</I>&gt;<i>         {
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         public override bool Focused
</I>&gt;<i>         {
</I>&gt;<i>             get
</I>&gt;<i>             {
</I>&gt;<i>                 return base.ContainsFocus;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; Hi,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; So do you think it could be a bug with resolving the base class? It
</I>&gt;<i> &gt;&gt; seems from the trace that it is going into a continuous loop, like it is
</I>&gt;<i> &gt;&gt; calling ContainsFocus on itself.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; To be honest, all I saw was the segfault rather than the tonnes of
</I>&gt;<i> &gt; output. The baseclass seems to be working fine as well
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I did the following to your code and if you run it, you'll see that the
</I>&gt;<i> &gt; baseclass is fine
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; using System;
</I>&gt;<i> &gt; using System.Drawing;
</I>&gt;<i> &gt; using System.Collections;
</I>&gt;<i> &gt; using System.ComponentModel;
</I>&gt;<i> &gt; using System.Windows.Forms;
</I>&gt;<i> &gt; using System.Data;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; namespace WinApp4
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt;   public class Form1 : System.Windows.Forms.Form
</I>&gt;<i> &gt;   {
</I>&gt;<i> &gt;     private System.Windows.Forms.Button button1;
</I>&gt;<i> &gt;     private System.Windows.Forms.Button button2;
</I>&gt;<i> &gt;     private System.ComponentModel.Container components = null;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     public Form1()
</I>&gt;<i> &gt;     {
</I>&gt;<i> &gt;       InitializeComponent();
</I>&gt;<i> &gt;     }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     protected override void Dispose(bool disposing)
</I>&gt;<i> &gt;     {
</I>&gt;<i> &gt;       if (disposing)
</I>&gt;<i> &gt;       {
</I>&gt;<i> &gt;         if (components != null)
</I>&gt;<i> &gt;         {
</I>&gt;<i> &gt;           components.Dispose();
</I>&gt;<i> &gt;       }
</I>&gt;<i> &gt;       }
</I>&gt;<i> &gt;       base.Dispose(disposing);
</I>&gt;<i> &gt;     }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     private void InitializeComponent()
</I>&gt;<i> &gt;     {
</I>&gt;<i> &gt;       this.button1 = new System.Windows.Forms.Button();
</I>&gt;<i> &gt;       this.button2 = new System.Windows.Forms.Button();
</I>&gt;<i> &gt;       this.SuspendLayout();
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;       this.button1.Location = new System.Drawing.Point(96, 32);
</I>&gt;<i> &gt;       this.button1.Name = &quot;button1&quot;;
</I>&gt;<i> &gt;       this.button1.TabIndex = 0;
</I>&gt;<i> &gt;       this.button1.Text = &quot;button1&quot;;
</I>&gt;<i> &gt;       this.button1.Click += new System.EventHandler(this.button1_Click);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;       this.button2.Location = new System.Drawing.Point(96, 80);
</I>&gt;<i> &gt;       this.button2.Name = &quot;button2&quot;;
</I>&gt;<i> &gt;       this.button2.TabIndex = 1;
</I>&gt;<i> &gt;       this.button2.Text = &quot;button2&quot;;
</I>&gt;<i> &gt;       this.button2.Click += new System.EventHandler(this.button2_Click);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;       this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
</I>&gt;<i> &gt;       this.ClientSize = new System.Drawing.Size(292, 262);
</I>&gt;<i> &gt;       this.Controls.Add(this.button2);
</I>&gt;<i> &gt;       this.Controls.Add(this.button1);
</I>&gt;<i> &gt;       this.Name = &quot;Form1&quot;;
</I>&gt;<i> &gt;       this.Text = &quot;Form1&quot;;
</I>&gt;<i> &gt;       this.ResumeLayout(false);
</I>&gt;<i> &gt;     }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     [STAThread]
</I>&gt;<i> &gt;     static void Main()
</I>&gt;<i> &gt;     {
</I>&gt;<i> &gt;       Application.Run(new Form1());
</I>&gt;<i> &gt;     }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     private void button1_Click(object sender, System.EventArgs e)
</I>&gt;<i> &gt;     {
</I>&gt;<i> &gt;       Console.Write(base.ContainsFocus);
</I>&gt;<i> &gt;     }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     private void button2_Click(object sender, System.EventArgs e)
</I>&gt;<i> &gt;     {
</I>&gt;<i> &gt;       Console.WriteLine(base.ContainsFocus);
</I>&gt;<i> &gt;     }
</I>&gt;<i> &gt;   }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The output (at least on my box) is
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; True (button 1 pressed - no return feed)
</I>&gt;<i> &gt; TrueTrue (button 2 pressed)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt;From the looks of the original code, you've created the second button,
</I>&gt;<i> &gt; but never properly instantated it (it is declared as private swf.button
</I>&gt;<i> &gt; button2 at the start, but never created using this.button2 = new
</I>&gt;<i> &gt; swf.button()). That (to me) is the most likely candidate for the
</I>&gt;<i> &gt; breakage.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; TTFN
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Paul
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-winforms-list maillist  -  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-winforms-list">Mono-winforms-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-winforms-list">http://lists.ximian.com/mailman/listinfo/mono-winforms-list</A>
</I>&gt;<i>
</I>

-- 
Rafael &quot;Monoman&quot; Teixeira
---------------------------------------
&quot;The reasonable man adapts himself to the world; the unreasonable one
persists in trying to adapt the world to himself. Therefore all
progress depends on the unreasonable man.&quot; George Bernard Shaw
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002381.html">[Mono-winforms-list] Bug	in	System.Windows.Forms.Control:get_ContainsFocus ()?
</A></li>
	<LI>Next message: <A HREF="002384.html">[Mono-winforms-list] Bug in System.Windows.Forms.Control:get_ContainsFocus ()?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2382">[ date ]</a>
              <a href="thread.html#2382">[ thread ]</a>
              <a href="subject.html#2382">[ subject ]</a>
              <a href="author.html#2382">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-winforms-list">More information about the Mono-winforms-list
mailing list</a><br>
</body></html>
