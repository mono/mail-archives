Index: System.Windows.Forms/X11Keyboard.cs
===================================================================
--- System.Windows.Forms/X11Keyboard.cs	(revision 100698)
+++ System.Windows.Forms/X11Keyboard.cs	(working copy)
@@ -170,6 +170,25 @@
 			return false;
 		}
 
+		public void PreFilter (XEvent xevent)
+		{
+			// almost identical to UpdateKeyState() but does not call LookupString().
+			// The actual purpose is to handle shift state correctly.
+			int vkey = keyc2vkey [xevent.KeyEvent.keycode];
+
+			switch (xevent.type) {
+			case XEventName.KeyRelease:
+				key_state_table [vkey & 0xff] &= unchecked ((byte) ~0x80);
+				break;
+			case XEventName.KeyPress:
+				if ((key_state_table [vkey & 0xff] & 0x80) == 0) {
+					key_state_table [vkey & 0xff] ^= 0x01;
+				}
+				key_state_table [vkey & 0xff] |= 0x80;
+				break;
+			}
+		}
+
 		public void KeyEvent (IntPtr hwnd, XEvent xevent, ref MSG msg)
 		{
 			XKeySym keysym;
Index: System.Windows.Forms/XplatUIX11.cs
===================================================================
--- System.Windows.Forms/XplatUIX11.cs	(revision 100698)
+++ System.Windows.Forms/XplatUIX11.cs	(working copy)
@@ -442,6 +442,13 @@
 				// Create the foster parent
 				// it is important that border_width is kept in synch with the other XCreateWindow calls
 				FosterParent=XCreateSimpleWindow(DisplayHandle, RootWindow, 0, 0, 1, 1, 0, UIntPtr.Zero, UIntPtr.Zero);
+				/*
+				XSetWindowAttributes attributes = new XSetWindowAttributes ();
+				attributes.bit_gravity = Gravity.NorthWestGravity;
+				attributes.win_gravity = Gravity.NorthWestGravity;
+				SetWindowValuemask valueMask = SetWindowValuemask.BitGravity | SetWindowValuemask.WinGravity;
+				FosterParent=XCreateWindow(DisplayHandle, RootWindow, 0, 0, 1, 1, 0, (int)CreateWindowArgs.CopyFromParent, (int)CreateWindowArgs.InputOnly, new IntPtr ((int) CreateWindowArgs.CopyFromParent), new UIntPtr ((uint)valueMask), ref attributes);
+				*/
 				if (FosterParent==IntPtr.Zero) {
 					Console.WriteLine("XplatUIX11 Constructor failed to create FosterParent");
 				}
@@ -1561,18 +1568,16 @@
 
 					XNextEvent (DisplayHandle, ref xevent);
 
-					if (xevent.AnyEvent.type == XEventName.KeyPress) {
+					if (xevent.AnyEvent.type == XEventName.KeyPress ||
+					    xevent.AnyEvent.type == XEventName.KeyRelease) {
+						// PreFilter() handles "shift key state updates.
+						Keyboard.PreFilter (xevent);
 						if (XFilterEvent(ref xevent, FosterParent)) {
 							// probably here we could raise WM_IME_KEYDOWN and
 							// WM_IME_KEYUP, but I'm not sure it is worthy.
 							continue;
 						}
 					}
-					else if (xevent.AnyEvent.type == XEventName.KeyRelease)
-						// Allow the Input Method to process key releases but also pass them on to the
-						// keyboard event processing because certain states (Shift, Control) are not 
-						// correctly if we don't.                                                    
-						XFilterEvent(ref xevent, FosterParent);
 					else if (XFilterEvent (ref xevent, IntPtr.Zero))
 						continue;
 				}
