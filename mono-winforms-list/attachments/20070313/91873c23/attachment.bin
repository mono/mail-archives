Index: mcs/class/Managed.Windows.Forms/System.Windows.Forms/Hwnd.cs
===================================================================
--- mcs/class/Managed.Windows.Forms/System.Windows.Forms/Hwnd.cs	(revision 74173)
+++ mcs/class/Managed.Windows.Forms/System.Windows.Forms/Hwnd.cs	(working copy)
@@ -560,6 +560,13 @@
 			}
 		}
 
+		public bool Transparent {
+			get {
+				return ((initial_ex_style & WindowExStyles.WS_EX_TRANSPARENT) 
+						== WindowExStyles.WS_EX_TRANSPARENT);
+			}
+		}
+
 		public int X {
 			get {
 				return x;
Index: mcs/class/Managed.Windows.Forms/System.Windows.Forms/XplatUIX11.cs
===================================================================
--- mcs/class/Managed.Windows.Forms/System.Windows.Forms/XplatUIX11.cs	(revision 74173)
+++ mcs/class/Managed.Windows.Forms/System.Windows.Forms/XplatUIX11.cs	(working copy)
@@ -3611,7 +3611,7 @@
 					if ((xevent.CrossingEvent.mode != NotifyMode.NotifyNormal) || (xevent.CrossingEvent.window != hwnd.client_window)) {
 						goto ProcessNextMessage;
 					}
-					msg.message=Msg.WM_MOUSE_LEAVE;
+					msg.message=Msg.WM_MOUSELEAVE;
 					HoverState.Timer.Enabled = false;
 					HoverState.Window = IntPtr.Zero;
 					break;
@@ -3819,6 +3819,11 @@
 						ShowCaret();
 						Caret.Paused = false;
 					}
+
+					if (hwnd.Transparent) {
+						SimulateTransparency (hwnd);
+					}
+
 					msg.message = Msg.WM_PAINT;
 					break;
 				}
@@ -5272,10 +5277,33 @@
 				return;
 			}
 
+			if (hwnd.Transparent) {
+				SimulateTransparency (hwnd);
+			}
+
 			SendMessage(handle, Msg.WM_PAINT, IntPtr.Zero, IntPtr.Zero);
 			hwnd.Queue.Paint.Remove(hwnd);
 		}
 
+		private void SimulateTransparency (Hwnd hwnd)
+		{
+			if (hwnd.Transparent) {
+				Control parent = Control.FromHandle (GetParent (hwnd.Handle));
+				// Repaint all controls before the transparent one.
+				if (parent != null) {
+					int index = parent.Controls.IndexOf (Control.FromHandle (hwnd.Handle));
+					hwnd.expose_pending = true;
+					UpdateWindow (parent.Handle);
+					for (int i = 0; i < parent.Controls.Count; i++) {
+						if (i != index) {
+							UpdateWindow (parent.Controls[i].Handle);
+						}
+					}
+					hwnd.expose_pending = false;
+				}
+			}
+		}
+
 		internal override void CreateOffscreenDrawable (IntPtr handle,
 								int width, int height,
 								out object offscreen_drawable)