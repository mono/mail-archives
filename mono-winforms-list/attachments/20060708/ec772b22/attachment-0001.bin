Index: configure.in
===================================================================
--- configure.in	(revision 62367)
+++ configure.in	(working copy)
@@ -18,33 +18,27 @@
 	AC_MSG_ERROR("Did not find Glib >= 2.2.3");
 fi
 
-AC_CONFIG_SUBDIRS(cairo)
-CAIRO_LIBS='$(top_builddir)/cairo/src/libcairo.la'
-CAIRO_CFLAGS='-I$(top_builddir)/cairo/pixman/src -I$(top_srcdir)/cairo/pixman/src -I$(top_builddir)/cairo/src -I$(top_srcdir)/cairo/src'
-AC_DEFINE(USE_INCLUDED_CAIRO,1,[Use Cairo bundled in libgdiplus])
+default_cairo=included
+AC_ARG_WITH(cairo, [  --with-cairo=included,installed],[cairo_v=$with_cairo],[cairo_v=$default_cairo])
 
-# Activate this when we support linking to an already exiting Cairo installation
-#default_cairo=included
-#AC_ARG_WITH(cairo, [  --with-cairo=included,installed],[cairo_v=$with_cairo],[cairo_v=$default_cairo])
-#
-#if test $cairo_v = "included";
-#then
-#	#AC_CONFIG_SUBDIRS(libpixman)
-#	AC_CONFIG_SUBDIRS(cairo)
-#	CAIRO_LIBS='$(top_builddir)/cairo/src/libcairo.la'
-#	CAIRO_CFLAGS='-I$(top_builddir)/cairo/pixman/src -I$(top_srcdir)/cairo/pixman/src -I$(top_builddir)/cairo/src -I$(top_srcdir)/cairo/src'
-#	AC_DEFINE(USE_INCLUDED_CAIRO,1,[Use Cairo bundled in libgdiplus])
-#else
-#	if pkg-config --exact-version 0.3.0 cairo; then
-#		echo Cairo installation OK
-#	else
-#		AC_MSG_ERROR("Did not find Cairo == 0.3.0");
-#	fi
-#
-#	CAIRO_LIBS="`pkg-config --libs cairo`"
-#	CAIRO_CFLAGS="`pkg-config --cflags cairo`"
-#fi
+if test $cairo_v = "installed";
+then
+	AC_CONFIG_SUBDIRS(cairo)
+	CAIRO_LIBS='$(top_builddir)/cairo/src/libcairo.la'
+	CAIRO_CFLAGS='-I$(top_builddir)/cairo/pixman/src -I$(top_srcdir)/cairo/pixman/src -I$(top_builddir)/cairo/src -I$(top_srcdir)/cairo/src'
+	AC_DEFINE(USE_INCLUDED_CAIRO,1,[Use Cairo bundled in libgdiplus])
+else
+	if pkg-config --atleast-version 1.2.0 cairo; then
+		echo Cairo installation OK
+	else
+		AC_MSG_ERROR("Did not find Cairo >= 1.2.0");
+	fi
 
+	CAIRO_LIBS="`pkg-config --libs cairo`"
+	CAIRO_CFLAGS="`pkg-config --cflags cairo`"
+fi
+AM_CONDITIONAL(ENABLE_INCLUDED_CAIRO, test x$cairo_v = xinstalled)
+
 # Fall back to using fontconfig/freetype-config if their .pc is not found
 PKG_CHECK_MODULES(FONTCONFIG, fontconfig,
 	[fontconfig_pkgconfig=yes], [fontconfig_pkgconfig=no])
Index: src/bmpcodec.c
===================================================================
--- src/bmpcodec.c	(revision 62367)
+++ src/bmpcodec.c	(working copy)
@@ -879,8 +879,8 @@
 	data_read = NULL;
 
 	/* Ensure pixman_bits_t alignment */
-	result->active_bitmap->stride += (sizeof(pixman_bits_t) - 1);
-	result->active_bitmap->stride &= ~(sizeof(pixman_bits_t) - 1);
+	result->active_bitmap->stride += (3);
+	result->active_bitmap->stride &= ~(3);
  
 	if (colours) {
 		int palette_entries = colours;
@@ -1189,12 +1189,12 @@
 		memset (current_line, 0, mystride); /* Zero padding at the end if needed */
 		for (i = height - 1; i >= 0; i--) {
 			byte *ptr;
-			uint32_t *iptr;
+			guint32 *iptr;
 
-			iptr = (uint32_t *) (scan0 + i * activebmp->stride);
+			iptr = (guint32 *) (scan0 + i * activebmp->stride);
 			ptr = current_line;
 			for (k = 0; k < width; k++) {
-				uint32_t color = *iptr++;
+				guint32 color = *iptr++;
 #ifndef WORDS_BIGENDIAN
 				*ptr++ = (color & 0x000000ff);
 				*ptr++ = ((color & 0x0000ff00) >> 8);
Index: src/image.c
===================================================================
--- src/image.c	(revision 62367)
+++ src/image.c	(working copy)
@@ -130,7 +130,11 @@
 		return InvalidParameter;
 
 	surface = cairo_ps_surface_create (filename, (double) width, (double) height);
+#ifdef USE_INCLUDED_CAIRO
 	cairo_ps_surface_set_dpi (surface, dpix, dpiy);
+#else
+	cairo_surface_set_fallback_resolution (surface, dpix, dpiy);
+#endif
 
 	gfx = gdip_graphics_new (surface);
 	gfx->dpi_x = dpix;
Index: src/gifcodec.c
===================================================================
--- src/gifcodec.c	(revision 62367)
+++ src/gifcodec.c	(working copy)
@@ -513,7 +513,7 @@
 		bitmap_data->pixel_format = Format8bppIndexed;
 		bitmap_data->width = screen_width;
 		bitmap_data->height = screen_height;
-		bitmap_data->stride = (bitmap_data->width + sizeof(pixman_bits_t) - 1) & ~(sizeof(pixman_bits_t) - 1);
+		bitmap_data->stride = (bitmap_data->width + 3) & ~(3);
 		bitmap_data->left = img_desc->Left;
 		bitmap_data->top = img_desc->Top;
 
Index: src/bitmap.c
===================================================================
--- src/bitmap.c	(revision 62367)
+++ src/bitmap.c	(working copy)
@@ -851,8 +851,8 @@
 		}
 
 		/* make sure the stride aligns the next row to a pixman_bits_t boundary */
-		stride += (sizeof(pixman_bits_t)-1);
-		stride &= ~(sizeof(pixman_bits_t)-1);
+		stride += 3;
+		stride &= ~(3);
 	}
 	bitmap_data->stride = stride;
 
@@ -951,8 +951,8 @@
 	BitmapData	*bitmap_data;
 	int 		stride;
 
-	stride = width * 4 + (sizeof(pixman_bits_t)-1);
-	stride &= ~(sizeof(pixman_bits_t)-1);
+	stride = width * 4 + 3;
+	stride &= ~(3);
 	
 	result = gdip_bitmap_new ();
 	result->image_format = MEMBMP;
@@ -1106,7 +1106,7 @@
 		dest_depth = gdip_get_pixel_format_depth (srcData->pixel_format);
 		destData->pixel_format = srcData->pixel_format;
 
-		destData->stride = (((( destRect->Width * dest_components * dest_depth) /8) + (sizeof(pixman_bits_t)-1)) & ~(sizeof(pixman_bits_t)-1));
+		destData->stride = ((( destRect->Width * dest_components * dest_depth) /8) + 3) & ~(3);
 
 		destData->scan0 = GdipAlloc (destData->stride * destRect->Height);
 		if (destData== NULL) {
@@ -1264,7 +1264,7 @@
 	
 	*dest_stride = dest_components * 8;
 	*dest_stride = (*dest_stride * width) / 8;
-	*dest_stride = (*dest_stride + (sizeof(pixman_bits_t)-1)) & ~(sizeof(pixman_bits_t)-1);		
+	*dest_stride = (*dest_stride + 3) & ~(3);
 	
 	result = GdipAlloc (*dest_stride * height);
 	if (result == NULL) {
@@ -1300,7 +1300,7 @@
 	
 	*dest_stride = dest_components * 8;
 	*dest_stride = (*dest_stride * width) / 8;
-	*dest_stride = (*dest_stride + (sizeof(pixman_bits_t)-1)) & ~(sizeof(pixman_bits_t)-1);		
+	*dest_stride = (*dest_stride + 3) & ~(3);
 	
 	result = GdipAlloc (*dest_stride * height);
 	if (result == NULL) {
@@ -1688,7 +1688,7 @@
 		pixel_format = (destFormat == Format24bppRgb) ? 3 : gdip_get_pixel_format_bpp (destFormat);
 		row_bits = destRect->Width * pixel_format;
 		row_bytes = (row_bits + 7) / 8;
-		stride = (row_bytes + sizeof(pixman_bits_t) - 1) & ~(sizeof(pixman_bits_t) - 1);
+		stride = (row_bytes + 3) & ~(3);
 		dest_scan0 = GdipAlloc(stride * scans);
 
 		if (dest_scan0 == NULL) {
@@ -1898,8 +1898,8 @@
 		dest_pixel_format_bpp = gdip_get_pixel_format_bpp (format);
 	}
 	dest_stride = (srcRect->Width * dest_pixel_format_bpp + 7) / 8;
-	dest_stride += (sizeof(pixman_bits_t)-1);
-	dest_stride &= ~(sizeof(pixman_bits_t)-1);
+	dest_stride += 3;
+	dest_stride &= ~(3);
 	dest_size = srcRect->Height * dest_stride;
 
 	if ((flags & ImageLockModeUserInputBuf) == 0) {
@@ -2197,8 +2197,8 @@
 	rgb_stride = data->width * sizeof (ARGB);
 
 	/* ensure pixman_bits_t alignment */
-	rgb_stride += (sizeof(pixman_bits_t)-1);
-	rgb_stride &= ~(sizeof(pixman_bits_t)-1);
+	rgb_stride += 3;
+	rgb_stride &= ~(3);
 
 	rgb_bytes = data->height * rgb_stride;
 
Index: src/pngcodec.c
===================================================================
--- src/pngcodec.c	(revision 62367)
+++ src/pngcodec.c	(working copy)
@@ -280,13 +280,13 @@
 		bit_depth = png_get_bit_depth (png_ptr, info_ptr);
 
 		source_stride = (width * bit_depth + 7) / 8;
-		dest_stride = (source_stride + sizeof(pixman_bits_t) - 1) & ~(sizeof(pixman_bits_t) - 1);
+		dest_stride = (source_stride + 3) & ~(3);
 
 		/* Copy image data. */
 		row_pointers = png_get_rows (png_ptr, info_ptr);
 
 		if (bit_depth == 2) { /* upsample to 4bpp */
-			dest_stride = ((width + 1) / 2 + sizeof(pixman_bits_t) - 1) & ~(sizeof(pixman_bits_t) - 1);
+			dest_stride = ((width + 1) / 2 + 3) & ~(3);
 
 			rawdata = GdipAlloc(dest_stride * height);
 			for (i=0; i < height; i++) {
@@ -423,8 +423,8 @@
 			png_set_tRNS_to_alpha(png_ptr);
 		}
 
-		stride = (width * 4) + (sizeof(pixman_bits_t)-1);
-		stride &= ~(sizeof(pixman_bits_t)-1);
+		stride = (width * 4) + (3);
+		stride &= ~(3);
 
 		row_pointers = png_get_rows (png_ptr, info_ptr);
 		rawdata = GdipAlloc (stride * height);
Index: src/gdip.h
===================================================================
--- src/gdip.h	(revision 62367)
+++ src/gdip.h	(working copy)
@@ -24,8 +24,6 @@
 
 #include "config.h"
 
-#include "pixman.h"
-
 #ifdef USE_INCLUDED_CAIRO
 #include <cairo.h>
 #else
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 62367)
+++ Makefile.am	(working copy)
@@ -1,5 +1,8 @@
+if ENABLE_INCLUDED_CAIRO
 SUBDIRS = cairo src tests
-#libpixman
+else
+SUBDIRS = src tests
+endif
 
 pkgconfigdir = $(libdir)/pkgconfig
 
