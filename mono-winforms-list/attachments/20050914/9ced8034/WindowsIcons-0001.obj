Index: FileDialog.cs
===================================================================
--- FileDialog.cs	(revision 49986)
+++ FileDialog.cs	(working copy)
@@ -1635,6 +1635,15 @@
 				ListViewItem listViewItem = new ListViewItem( directoryInfoi.Name );
 				
 				int index = MimeIconEngine.GetIconIndexForMimeType( "inode/directory" );
+
+				int p = (int)Environment.OSVersion.Platform;
+				if (p != 4 && p != 128)
+				{
+					if (this.View == View.LargeIcon)
+						index = MimeIconEngine.GetIconIndexForFile( fileStruct.fullname );
+					else
+						index = MimeIconEngine.GetSmallIconIndexForFile( fileStruct.fullname );
+				}
 				
 				listViewItem.ImageIndex = index;
 				
@@ -1661,7 +1670,10 @@
 				
 				ListViewItem listViewItem = new ListViewItem( fileInfo.Name );
 				
-				listViewItem.ImageIndex = MimeIconEngine.GetIconIndexForFile( fileStruct.fullname );
+				if (this.View == View.LargeIcon)
+					listViewItem.ImageIndex = MimeIconEngine.GetIconIndexForFile( fileStruct.fullname );
+				else
+					listViewItem.ImageIndex = MimeIconEngine.GetSmallIconIndexForFile( fileStruct.fullname );
 				
 				long fileLen = 1;
 				if ( fileInfo.Length > 1024 )
Index: MimeIcon.cs
===================================================================
--- MimeIcon.cs	(revision 49986)
+++ MimeIcon.cs	(working copy)
@@ -171,7 +171,14 @@
 				platformMimeHandler = new PlatformDefaultHandler( );
 				platformMimeHandler.Start( );
 			}
-			
+
+			int p = (int)Environment.OSVersion.Platform;
+			if (p != 4 && p != 128)
+			{
+				SmallIcons.ImageSize = new Size( 16, 16 );
+				LargeIcons.ImageSize = new Size( 32, 32 );
+			}
+
 			IconNameMimeTypeNameValueCollection = null;
 			added_icons = null;
 		}
@@ -180,27 +187,52 @@
 		{
 			lock ( lock_object )
 			{
-				string mime_type = Mime.GetMimeTypeForFile( full_filename );
-				
-				if ( platform == EPlatformHandler.Default )
+				int p = (int)Environment.OSVersion.Platform;
+				if (p != 4 && p != 128)
+				{
+					return LargeIcons.GetSystemIconIndex(full_filename);
+				}
+
+				return GetIconIndexForFileInternal(full_filename);
+			}
+		}
+
+		public static int GetSmallIconIndexForFile( string full_filename )
+		{
+			lock ( lock_object )
+			{
+				int p = (int)Environment.OSVersion.Platform;
+				if (p != 4 && p != 128)
+				{
+					return SmallIcons.GetSmallSystemIconIndex(full_filename);
+				}
+
+				return GetIconIndexForFileInternal(full_filename);
+			}
+		}
+		
+		private static int GetIconIndexForFileInternal( string full_filename )
+		{
+			string mime_type = Mime.GetMimeTypeForFile( full_filename );
+			
+			if ( platform == EPlatformHandler.Default )
+			{
+				if ( mime_type == "inode/directory" )
 				{
-					if ( mime_type == "inode/directory" )
-					{
-						return (int)MimeTypeIconIndexHash[ "inode/directory" ];
-					}
-					else
-					{
-						return (int)MimeTypeIconIndexHash[ "unknown/unknown" ];
-					}
+					return (int)MimeTypeIconIndexHash[ "inode/directory" ];
 				}
-				
-				object oindex = GetIconIndex( mime_type );
-				
-				if ( oindex == null )
-					oindex = MimeTypeIconIndexHash[ "unknown/unknown" ];
-				
-				return (int)oindex;
+				else
+				{
+					return (int)MimeTypeIconIndexHash[ "unknown/unknown" ];
+				}
 			}
+			
+			object oindex = GetIconIndex( mime_type );
+			
+			if ( oindex == null )
+				oindex = MimeTypeIconIndexHash[ "unknown/unknown" ];
+			
+			return (int)oindex;
 		}
 		
 		public static int GetIconIndexForMimeType( string mime_type )
Index: ImageList.cs
===================================================================
--- ImageList.cs	(revision 49986)
+++ ImageList.cs	(working copy)
@@ -34,6 +34,7 @@
 using System.ComponentModel;
 using System.Drawing;
 using System.Drawing.Imaging;
+using System.Runtime.InteropServices;
 
 namespace System.Windows.Forms {
 	[DefaultProperty("Images")]
@@ -41,6 +42,33 @@
 	[ToolboxItemFilter("System.Windows.Forms", ToolboxItemFilterType.Allow)]
 	[TypeConverter("System.Windows.Forms.ImageListConverter, " + Consts.AssemblySystem_Windows_Forms)]
 	public sealed class ImageList : System.ComponentModel.Component {
+		private const int MAX_PATH = 260;
+		private const int SHGFI_SMALLICON = 0x000000001;
+		private const int SHGFI_SYSICONINDEX = 0x000004000;
+		private const int CLR_NONE = unchecked((int)0xFFFFFFFF);
+		private const int ILD_TRANSPARENT = 0x00000001;
+
+		[StructLayout(LayoutKind.Sequential)]
+		private struct SHFILEINFO
+		{
+			internal IntPtr hIcon;
+			internal int iIcon;
+			internal int dwAttributes;
+			[MarshalAs(UnmanagedType.ByValTStr, SizeConst=MAX_PATH)]
+			internal string szDisplayName;
+			[MarshalAs(UnmanagedType.ByValTStr, SizeConst=80)]
+			internal string szTypeName;
+		}
+
+		[DllImport("comctl32.dll")]
+		private static extern int ImageList_GetImageCount(HandleRef himl);
+
+		[DllImport("comctl32.dll")]
+		private static extern bool ImageList_DrawEx(HandleRef himl, int i, HandleRef hdcDst, int x, int y, int dx, int dy, int rgbBk, int rgbFg, int fStyle);
+
+		[DllImport("shell32.dll")]
+		private static extern IntPtr SHGetFileInfo(string pszPath, int dwFileAttributes, out SHFILEINFO psfi, int cbFileInfo, int uFlags);
+
 		#region Local Variables
 		private ColorDepth		color_depth;
 		private ImageCollection		image_collection;
@@ -49,8 +77,36 @@
 		private Delegate		handler;
 		private ImageListStreamer	image_stream;
 		private IntPtr			handle;	
+		private IntPtr			systemImageList;
 		#endregion	// Local Variables
 
+		internal int GetSystemIconIndex(string path)
+		{
+			return GetSystemIconIndexInternal(path, 0);
+		}
+
+		internal int GetSmallSystemIconIndex(string path)
+		{
+			return GetSystemIconIndexInternal(path, SHGFI_SMALLICON);
+		}
+
+		private int GetSystemIconIndexInternal(string path, int flags)
+		{
+			SHFILEINFO shellFileInfo;
+			IntPtr systemImageList;
+
+			systemImageList = SHGetFileInfo(path, 0, out shellFileInfo, Marshal.SizeOf(typeof(SHFILEINFO)), SHGFI_SYSICONINDEX | flags);
+
+			if (systemImageList == IntPtr.Zero)
+				return -1;
+			else
+			{
+				if (this.systemImageList == IntPtr.Zero)
+					this.systemImageList = systemImageList;
+				return shellFileInfo.iIcon;
+			}
+		}
+
 		#region Sub-classes
 		[Editor("System.Windows.Forms.Design.ImageCollectionEditor, " + Consts.AssemblySystem_Design, typeof(System.Drawing.Design.UITypeEditor))]
 		public sealed class ImageCollection : IList, ICollection, IEnumerable {
@@ -70,6 +126,8 @@
 			[Browsable(false)]
 			public int Count {
 				get {
+					if (owner.systemImageList != IntPtr.Zero)
+						return ImageList_GetImageCount(new HandleRef(owner, owner.systemImageList));
 					return list.Count;
 				}
 			}
@@ -471,6 +529,21 @@
 			if ((index < 0) || (index >= this.Images.Count)) {
 				throw new ArgumentOutOfRangeException("index", index, "ImageList does not contain that many images");
 			}
+
+			if (systemImageList != IntPtr.Zero)
+			{
+				IntPtr hDC = g.GetHdc();
+				try
+				{
+					ImageList_DrawEx(new HandleRef(this, systemImageList), index, new HandleRef(g, hDC), x, y, width, height, CLR_NONE, CLR_NONE, ILD_TRANSPARENT);
+				}
+				finally
+				{
+					g.ReleaseHdc(hDC);
+				}
+				return;
+			}
+
 			i = this.Images[index];
 			g.DrawImage(i, x, y, width, height);
 		}
