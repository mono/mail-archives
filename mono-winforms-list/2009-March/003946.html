<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-winforms-list] [Mono-dev] libgdiplus pango patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-winforms-list%40lists.ximian.com?Subject=%5BMono-winforms-list%5D%20%5BMono-dev%5D%20libgdiplus%20pango%20patch&In-Reply-To=1234981491.12590.47.camel%40mizar.home">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003941.html">
   <LINK REL="Next"  HREF="003961.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-winforms-list] [Mono-dev] libgdiplus pango patch</H1>
    <B>Jonathan Anderson</B> 
    <A HREF="mailto:mono-winforms-list%40lists.ximian.com?Subject=%5BMono-winforms-list%5D%20%5BMono-dev%5D%20libgdiplus%20pango%20patch&In-Reply-To=1234981491.12590.47.camel%40mizar.home"
       TITLE="[Mono-winforms-list] [Mono-dev] libgdiplus pango patch">jonathan.l.anderson at gmail.com
       </A><BR>
    <I>Fri Mar  6 08:12:01 EST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003941.html">[Mono-winforms-list] Application exits when I press right arrow key
</A></li>
        <LI>Next message: <A HREF="003961.html">[Mono-winforms-list] [Mono-dev] libgdiplus pango patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3946">[ date ]</a>
              <a href="thread.html#3946">[ thread ]</a>
              <a href="subject.html#3946">[ subject ]</a>
              <a href="author.html#3946">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Sorry for the long delay.  I don't have write access to svn, so I'll 
need someone to commit it for me, or to get access to do so.

I'm still doing work in this area - right now I'm working with the 
issues for complex scripts in the TextBox and similar edit controls.

Thanks,
Jonathan

Sebastien Pouliot wrote:
&gt;<i> Hello Jonathan,
</I>&gt;<i> 
</I>&gt;<i> On Thu, 2009-02-12 at 21:47 +0700, Jonathan Anderson wrote:
</I>&gt;&gt;<i> Sebastien Pouliot wrote:
</I>&gt;&gt;&gt;&gt;<i> There are a couple of issues that I've fixed since the patch I submitted 
</I>&gt;&gt;&gt;&gt;<i> as well (fixed a problem with vertical text and another difference with 
</I>&gt;&gt;&gt;&gt;<i> how MS GDI+ handles the NoWrap flag).  Should I do another patch with 
</I>&gt;&gt;&gt;&gt;<i> everything again, or just a patch on the patched version for those?
</I>&gt;&gt;&gt;<i> You can issue a new, complete patch.
</I>&gt;<i> 
</I>&gt;<i> Sorry for the delay, I wanted to try it (out of curiosity) but did not
</I>&gt;<i> have time yet. Anyway this should not block getting the source into SVN.
</I>&gt;<i> 
</I>&gt;<i> Besides a few spaces/tabs issues (see inline) everything looks fine and
</I>&gt;<i> since pango-support is not part of the default build please feel free*
</I>&gt;<i> to commit your changes along with the ChangeLog.
</I>&gt;<i> 
</I>&gt;<i> * as long as it does not touch the &quot;main&quot; source files and it follow the
</I>&gt;<i> mono source conventions.
</I>&gt;<i> 
</I>&gt;<i> Thanks!
</I>&gt;<i> Sebastien
</I>&gt;<i> 
</I>&gt;&gt;<i> Here's the new patch.  Fixes from the previous one:
</I>&gt;&gt;<i> * vertical latin text is now drawn with characters in the correct direction
</I>&gt;&gt;<i> * NoWrap will still wrap on newline now (MS GDI+ does this)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Jonathan Anderson
</I>&gt;&gt;<i> plain text document attachment (pangopatch2.diff)
</I>&gt;&gt;<i> Index: src/text-pango-private.h
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- src/text-pango-private.h	(revision 126715)
</I>&gt;&gt;<i> +++ src/text-pango-private.h	(working copy)
</I>&gt;&gt;<i> @@ -36,17 +36,18 @@
</I>&gt;&gt;<i>  #include &quot;graphics-private.h&quot;
</I>&gt;&gt;<i>  #include &quot;stringformat-private.h&quot;
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> +#define PANGO_MAX (G_MAXINT / PANGO_SCALE)
</I>&gt;&gt;<i> +#define MAKE_SAFE_FOR_PANGO(x)	((x) &gt; G_MAXINT/PANGO_SCALE ? G_MAXINT/PANGO_SCALE : ((x) &lt; G_MININT/PANGO_SCALE ? G_MININT/PANGO_SCALE : (x)))
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  #define	GDIP_WINDOWS_ACCELERATOR	'&amp;'
</I>&gt;&gt;<i> -#define GDIP_PANGOHACK_ACCELERATOR	((char)1)
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  #define text_DrawString			pango_DrawString
</I>&gt;&gt;<i>  #define text_MeasureString		pango_MeasureString
</I>&gt;&gt;<i>  #define text_MeasureCharacterRanges	pango_MeasureCharacterRanges
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> -PangoLayout* gdip_pango_setup_layout (cairo_t *ct, GDIPCONST WCHAR *stringUnicode, int length, GDIPCONST GpFont *font, 
</I>&gt;&gt;<i> -	GDIPCONST RectF *rc, RectF *box, GDIPCONST GpStringFormat *format);
</I>&gt;&gt;<i> +PangoLayout* gdip_pango_setup_layout (GpGraphics *graphics, GDIPCONST WCHAR *stringUnicode, int length, GDIPCONST GpFont *font, 
</I>&gt;&gt;<i> +	GDIPCONST RectF *rc, RectF *box, GDIPCONST GpStringFormat *format, int **charsRemoved);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  GpStatus pango_DrawString (GpGraphics *graphics, GDIPCONST WCHAR *stringUnicode, int length, GDIPCONST GpFont *font, 
</I>&gt;&gt;<i>  	GDIPCONST RectF *rc, GDIPCONST GpStringFormat *format, GpBrush *brush) GDIP_INTERNAL;
</I>&gt;&gt;<i> Index: src/text-pango.c
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- src/text-pango.c	(revision 126715)
</I>&gt;&gt;<i> +++ src/text-pango.c	(working copy)
</I>&gt;&gt;<i> @@ -46,45 +46,151 @@
</I>&gt;&gt;<i>  	return list;
</I>&gt;&gt;<i>  }
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -static void
</I>&gt;&gt;<i> -gdip_process_accelerators (gchar *text, int length, PangoAttrList *list)
</I>&gt;&gt;<i> +void
</I>&gt;&gt;<i> +gdip_set_array_values (int *array, int value, int num)
</I>&gt;&gt;<i>  {
</I>&gt;&gt;<i>  	int i;
</I>&gt;&gt;<i> -	for (i = 0; i &lt; length; i++) {
</I>&gt;&gt;<i> -		if (*(text + i) == GDIP_WINDOWS_ACCELERATOR) {
</I>&gt;&gt;<i> -			/* don't show the prefix character */
</I>&gt;&gt;<i> -			*(text + i) = GDIP_PANGOHACK_ACCELERATOR;
</I>&gt;&gt;<i> -			/* if the next character is an accelerator then skip over it (&amp;&amp; == &amp;) */
</I>&gt;&gt;<i> -			if ((i &lt; length - 1) &amp;&amp; (*(text + i + 1) == GDIP_WINDOWS_ACCELERATOR)) {
</I>&gt;&gt;<i> -				i++;
</I>&gt;&gt;<i> -			} else if (list) {
</I>&gt;&gt;<i> -				/* add an attribute on the next character */
</I>&gt;&gt;<i> +	for (i = 0; i &lt; num; i++)
</I>&gt;&gt;<i> +		array [i] = value;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static GString *
</I>&gt;&gt;<i> +gdip_process_string (gchar *text, int length, int removeAccelerators, int trimSpace, PangoAttrList *list, int **charsRemoved)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +	int i, j;
</I>&gt;&gt;<i> +	int nonws = 0;
</I>&gt;&gt;<i> +	gchar *iter;
</I>&gt;&gt;<i> +	gchar *iter2;
</I>&gt;&gt;<i> +	gunichar ch;
</I>&gt;&gt;<i> +    GString *res = g_string_sized_new (length);
</I>&gt;<i> 
</I>&gt;<i> ^ space/tab issue
</I>&gt;<i> 
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	/* fast version: just check for final newline and remove */
</I>&gt;&gt;<i> +	if (!removeAccelerators &amp;&amp; !trimSpace) {
</I>&gt;&gt;<i> +		j = length;
</I>&gt;&gt;<i> +		if (j &gt; 0 &amp;&amp; text [j-1] == '\n') {
</I>&gt;&gt;<i> +			j--;
</I>&gt;&gt;<i> +			if (j &gt; 0 &amp;&amp; text [j-1] == '\r')
</I>&gt;&gt;<i> +				j--;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +		g_string_append_len (res, text, j);
</I>&gt;&gt;<i> +		if (j == 0 &amp;&amp; length &gt; 0) {
</I>&gt;&gt;<i> +			g_string_append_c (res, ' ');
</I>&gt;&gt;<i> +			j++;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +		if (charsRemoved &amp;&amp; *charsRemoved) {
</I>&gt;&gt;<i> +			int prevj = (g_utf8_prev_char (res-&gt;str + j) - res-&gt;str);
</I>&gt;&gt;<i> +			gdip_set_array_values (*charsRemoved + prevj, length - j, j - prevj);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +		return res;
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	iter = text;
</I>&gt;&gt;<i> +	i = 0;
</I>&gt;&gt;<i> +	j = 0;
</I>&gt;&gt;<i> +	while (iter - text &lt; length) {
</I>&gt;&gt;<i> +		ch = g_utf8_get_char (iter);
</I>&gt;&gt;<i> +		if (ch == GDIP_WINDOWS_ACCELERATOR &amp;&amp; removeAccelerators &amp;&amp; (iter - text &lt; length - 1)) {
</I>&gt;&gt;<i> +			nonws = 1;
</I>&gt;&gt;<i> +			iter2 = g_utf8_next_char (iter);
</I>&gt;&gt;<i> +			i += iter2 - iter;
</I>&gt;&gt;<i> +			iter = iter2;
</I>&gt;&gt;<i> +			ch = g_utf8_get_char (iter);
</I>&gt;&gt;<i> +			/* add an attribute on the next character */
</I>&gt;&gt;<i> +			if (list &amp;&amp; (iter - text &lt; length) &amp;&amp; (ch != GDIP_WINDOWS_ACCELERATOR)) {
</I>&gt;&gt;<i>  				PangoAttribute *attr = pango_attr_underline_new (PANGO_UNDERLINE_LOW);
</I>&gt;&gt;<i> -				attr-&gt;start_index = i + 1;
</I>&gt;&gt;<i> -				attr-&gt;end_index = i + 2;
</I>&gt;&gt;<i> +				attr-&gt;start_index = j;
</I>&gt;&gt;<i> +				attr-&gt;end_index = j + g_utf8_next_char (iter) - iter;
</I>&gt;&gt;<i>  				pango_attr_list_insert (list, attr);
</I>&gt;&gt;<i>  			}
</I>&gt;&gt;<i> +		} else if (!g_unichar_isspace (ch)) {
</I>&gt;&gt;<i> +			nonws = 1;
</I>&gt;&gt;<i> +		} else if (trimSpace &amp;&amp; ch != '\r' &amp;&amp; ch != '\n') {
</I>&gt;&gt;<i> +			/* unless specified we don't consider the trailing spaces, unless there is just one space (#80680) */
</I>&gt;&gt;<i> +			for (iter2 = g_utf8_next_char (iter); iter2 - text &lt; length; iter2 = g_utf8_next_char (iter2)) {
</I>&gt;&gt;<i> +				ch = g_utf8_get_char (iter2);
</I>&gt;&gt;<i> +				if (ch == '\r' || ch == '\n')
</I>&gt;&gt;<i> +					break;
</I>&gt;&gt;<i> +				if (!g_unichar_isspace (ch)) {
</I>&gt;&gt;<i> +					g_string_append_len (res, iter, iter2 - iter);
</I>&gt;&gt;<i> +					if (charsRemoved &amp;&amp; *charsRemoved)
</I>&gt;&gt;<i> +						gdip_set_array_values ((*charsRemoved)+j, i - j, iter2 - iter);
</I>&gt;&gt;<i> +					j += iter2 - iter;
</I>&gt;&gt;<i> +					break;
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +			i += iter2 - iter;
</I>&gt;&gt;<i> +			iter = iter2;
</I>&gt;&gt;<i> +			continue;
</I>&gt;&gt;<i> +		} else if ((ch == '\r' &amp;&amp; (iter - text == length - 2) &amp;&amp; (*g_utf8_next_char (iter) == '\n')) || (ch == '\n' &amp;&amp; iter - text == length - 1)) {
</I>&gt;&gt;<i> +			/* in any case, ignore a final newline as pango will add an extra line to the measurement while gdi+ does not */
</I>&gt;&gt;<i> +			i = length;
</I>&gt;&gt;<i> +			break;
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i> +		iter2 = g_utf8_next_char (iter);
</I>&gt;&gt;<i> +		g_string_append_len (res, iter, iter2 - iter);
</I>&gt;&gt;<i> +		/* save these for string lengths later */
</I>&gt;&gt;<i> +		if (charsRemoved &amp;&amp; *charsRemoved)
</I>&gt;&gt;<i> +			gdip_set_array_values ((*charsRemoved)+j, i - j, iter2 - iter);
</I>&gt;&gt;<i> +		j += iter2 - iter;
</I>&gt;&gt;<i> +		i += iter2 - iter;
</I>&gt;&gt;<i> +		iter = iter2;
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i> +	/* always ensure that at least one space is measured */
</I>&gt;&gt;<i> +	if (!nonws &amp;&amp; trimSpace) {
</I>&gt;&gt;<i> +		g_string_append_c (res, ' ');
</I>&gt;&gt;<i> +		j++;
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +	if (charsRemoved &amp;&amp; *charsRemoved &amp;&amp; j &gt; 0) {
</I>&gt;&gt;<i> +		int prevj = (g_utf8_prev_char (res-&gt;str + j) - res-&gt;str);
</I>&gt;&gt;<i> +		gdip_set_array_values (*charsRemoved + prevj, i - j, j - prevj);
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +	return res;
</I>&gt;&gt;<i>  }
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  PangoLayout*
</I>&gt;&gt;<i> -gdip_pango_setup_layout (cairo_t *ct, GDIPCONST WCHAR *stringUnicode, int length, GDIPCONST GpFont *font, 
</I>&gt;&gt;<i> -	GDIPCONST RectF *rc, RectF *box, GDIPCONST GpStringFormat *format)
</I>&gt;&gt;<i> +gdip_pango_setup_layout (GpGraphics *graphics, GDIPCONST WCHAR *stringUnicode, int length, GDIPCONST GpFont *font, 
</I>&gt;&gt;<i> +	GDIPCONST RectF *rc, RectF *box, GDIPCONST GpStringFormat *format, int **charsRemoved)
</I>&gt;&gt;<i>  {
</I>&gt;&gt;<i>  	GpStringFormat *fmt;
</I>&gt;&gt;<i>  	PangoLayout *layout;
</I>&gt;&gt;<i>  	PangoContext *context;
</I>&gt;&gt;<i> -	PangoMatrix matrix = PANGO_MATRIX_INIT;
</I>&gt;&gt;<i> -	PangoRectangle logical;
</I>&gt;&gt;<i> +	PangoRectangle logical;   /* logical size of text (used for alignment) */
</I>&gt;&gt;<i> +	PangoRectangle ink;       /* ink size of text (to pixel boundaries) */
</I>&gt;&gt;<i>  	PangoAttrList *list = NULL;
</I>&gt;&gt;<i> +    GString *ftext;
</I>&gt;<i> 
</I>&gt;<i> &#65279;^ space/tab issue
</I>&gt;<i> 
</I>&gt;&gt;<i> +	PangoTabArray *tabs;
</I>&gt;&gt;<i> +	PangoLayoutIter *iter;
</I>&gt;&gt;<i> +	int i;
</I>&gt;&gt;<i> +	int FrameWidth;     /* rc-&gt;Width (or rc-&gt;Height if vertical) */
</I>&gt;&gt;<i> +	int FrameHeight;    /* rc-&gt;Height (or rc-&gt;Width if vertical) */
</I>&gt;&gt;<i> +	int FrameX;         /* rc-&gt;X (or rc-&gt;Y if vertical) */
</I>&gt;&gt;<i> +	int FrameY;         /* rc-&gt;Y (or rc-&gt;X if vertical) */
</I>&gt;&gt;<i> +	int y0;             /* y0,y1,clipNN used for checking line positions vs. clip rectangle */
</I>&gt;&gt;<i> +	int y1;
</I>&gt;&gt;<i> +	double clipx1;
</I>&gt;&gt;<i> +	double clipx2;
</I>&gt;&gt;<i> +	double clipy1;
</I>&gt;&gt;<i> +	double clipy2;
</I>&gt;&gt;<i> +	int trimSpace;      /* whether or not to trim the space */
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	gchar *text = ucs2_to_utf8 (stringUnicode, length);
</I>&gt;&gt;<i>  	if (!text)
</I>&gt;&gt;<i>  		return NULL;
</I>&gt;&gt;<i> +    length = strlen (text);
</I>&gt;<i> 
</I>&gt;<i> &#65279;^ space/tab issue
</I>&gt;<i> 
</I>&gt;&gt;<i> -//g_warning (&quot;layout &gt;%s&lt; (%d) [x %g, y %g, w %g, h %g] [font %s, %g points]&quot;, text, length, rc-&gt;X, rc-&gt;Y, rc-&gt;Width, rc-&gt;Height, font-&gt;face, font-&gt;emSize);
</I>&gt;&gt;<i> +	if (charsRemoved) {
</I>&gt;&gt;<i> +		(*charsRemoved) = GdipAlloc (sizeof (int) * length);
</I>&gt;&gt;<i> +		if (!*charsRemoved) {
</I>&gt;&gt;<i> +			GdipFree (text);
</I>&gt;&gt;<i> +			return NULL;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +		memset (*charsRemoved, 0, sizeof (int) * length);
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> +	/* TODO - Digit substitution */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +// g_warning (&quot;layout &gt;%s&lt; (%d) [x %g, y %g, w %g, h %g] [font %s, %g points]&quot;, text, length, rc-&gt;X, rc-&gt;Y, rc-&gt;Width, FrameHeight, font-&gt;face, font-&gt;emSize);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>  	/* a NULL format is valid, it means get the generic default values (and free them later) */
</I>&gt;&gt;<i>  	if (!format) {
</I>&gt;&gt;<i>  		GpStatus status = GdipStringFormatGetGenericDefault ((GpStringFormat **)&amp;fmt);
</I>&gt;&gt;<i> @@ -96,36 +202,46 @@
</I>&gt;&gt;<i>  		fmt = (GpStringFormat *)format;
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	/* unless specified we don't consider the trailing spaces, unless there is just one space (#80680) */
</I>&gt;&gt;<i> -	if ((fmt-&gt;formatFlags &amp; StringFormatFlagsMeasureTrailingSpaces) == 0) {
</I>&gt;&gt;<i> -		while ((length &gt; 0) &amp;&amp; (isspace (*(text + length - 1))))
</I>&gt;&gt;<i> -			length--;
</I>&gt;&gt;<i> -		if (length == 0)
</I>&gt;&gt;<i> -			length = 1;
</I>&gt;&gt;<i> -	}
</I>&gt;&gt;<i> +	layout = pango_cairo_create_layout (graphics-&gt;ct);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	layout = pango_cairo_create_layout (ct);
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i>  	/* context is owned by Pango (i.e. not referenced counted) do not free */
</I>&gt;&gt;<i>  	context = pango_layout_get_context (layout);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	pango_layout_set_font_description (layout, gdip_get_pango_font_description ((GpFont*) font));
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	if ((rc-&gt;Width &lt;= 0.0) || (fmt-&gt;formatFlags &amp; StringFormatFlagsNoWrap)) {
</I>&gt;&gt;<i> +	if (fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionVertical) {
</I>&gt;&gt;<i> +		FrameWidth = MAKE_SAFE_FOR_PANGO (SAFE_FLOAT_TO_UINT32 (rc-&gt;Height));
</I>&gt;&gt;<i> +		FrameHeight = MAKE_SAFE_FOR_PANGO (SAFE_FLOAT_TO_UINT32 (rc-&gt;Width));
</I>&gt;&gt;<i> +		FrameX = SAFE_FLOAT_TO_UINT32 (rc-&gt;Y);
</I>&gt;&gt;<i> +		FrameY = SAFE_FLOAT_TO_UINT32 (rc-&gt;X);
</I>&gt;&gt;<i> +	} else {
</I>&gt;&gt;<i> +		FrameWidth = MAKE_SAFE_FOR_PANGO (SAFE_FLOAT_TO_UINT32 (rc-&gt;Width));
</I>&gt;&gt;<i> +		FrameHeight = MAKE_SAFE_FOR_PANGO (SAFE_FLOAT_TO_UINT32 (rc-&gt;Height));
</I>&gt;&gt;<i> +		FrameX = SAFE_FLOAT_TO_UINT32 (rc-&gt;X);
</I>&gt;&gt;<i> +		FrameY = SAFE_FLOAT_TO_UINT32 (rc-&gt;Y);
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +	//g_warning(&quot;FW: %d\tFH: %d&quot;, FrameWidth, FrameHeight);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	if ((FrameWidth &lt;= 0) || (fmt-&gt;formatFlags &amp; StringFormatFlagsNoWrap)) {
</I>&gt;&gt;<i>  		pango_layout_set_width (layout, -1);
</I>&gt;&gt;<i> +		//g_warning (&quot;Setting width: %d&quot;, -1);
</I>&gt;&gt;<i>  	} else {
</I>&gt;&gt;<i> -		/* minus one to deal with our AA offset */
</I>&gt;&gt;<i> -		int width = rc-&gt;Width - 1;
</I>&gt;&gt;<i> -		/* TODO incomplete (missing height adjustment) */
</I>&gt;&gt;<i> -		if ((fmt-&gt;formatFlags &amp; StringFormatFlagsNoFitBlackBox) == 0)
</I>&gt;&gt;<i> -			width -= 2;
</I>&gt;&gt;<i> -		pango_layout_set_width (layout, width * PANGO_SCALE);
</I>&gt;&gt;<i> +		pango_layout_set_width (layout, FrameWidth * PANGO_SCALE);
</I>&gt;&gt;<i> +		//g_warning (&quot;Setting width: %d&quot;, FrameWidth * PANGO_SCALE);
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	if ((rc-&gt;Width != 0) &amp;&amp; (rc-&gt;Height != 0) &amp;&amp; ((fmt-&gt;formatFlags &amp; StringFormatFlagsNoClip) == 0)) {
</I>&gt;&gt;<i> +// g_warning (&quot;\tclip [%g %g %g %g]&quot;, rc-&gt;X, rc-&gt;Y, rc-&gt;Width, rc-&gt;Height);
</I>&gt;&gt;<i> +		/* We do not call cairo_reset_clip because we want to take previous clipping into account */
</I>&gt;&gt;<i> +		/* Use rc instead of frame variables because this is pre-transform */
</I>&gt;&gt;<i> +		gdip_cairo_rectangle (graphics, rc-&gt;X, rc-&gt;Y, rc-&gt;Width, rc-&gt;Height, TRUE);
</I>&gt;&gt;<i> +		cairo_clip (graphics-&gt;ct);
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i>  	
</I>&gt;&gt;<i> -	if (fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionRightToLeft) {
</I>&gt;&gt;<i> -		/* with GDI+ the API not the renderer makes the direction decision */
</I>&gt;&gt;<i> -		pango_layout_set_auto_dir (layout, FALSE);
</I>&gt;&gt;<i> -		pango_context_set_base_dir (context, PANGO_DIRECTION_RTL);
</I>&gt;&gt;<i> +	/* with GDI+ the API not the renderer makes the direction decision */
</I>&gt;&gt;<i> +	pango_layout_set_auto_dir (layout, FALSE);
</I>&gt;&gt;<i> +	if (!(fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionRightToLeft) != !(fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionVertical)) {
</I>&gt;&gt;<i> +		pango_context_set_base_dir (context, PANGO_DIRECTION_WEAK_RTL);
</I>&gt;&gt;<i>  		pango_layout_context_changed (layout);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  		/* horizontal alignment */
</I>&gt;&gt;<i> @@ -141,6 +257,8 @@
</I>&gt;&gt;<i>  			break;
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  	} else {
</I>&gt;&gt;<i> +		/* pango default base dir is WEAK_LTR, which is what we want */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>  		/* horizontal alignment */
</I>&gt;&gt;<i>  		switch (fmt-&gt;alignment) {
</I>&gt;&gt;<i>  		case StringAlignmentNear:
</I>&gt;&gt;<i> @@ -158,9 +276,18 @@
</I>&gt;&gt;<i>  #ifdef PANGO_VERSION_CHECK
</I>&gt;&gt;<i>  #if PANGO_VERSION_CHECK(1,16,0)
</I>&gt;&gt;<i>  	if (fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionVertical) {
</I>&gt;&gt;<i> +		if (fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionRightToLeft) {
</I>&gt;&gt;<i> +			cairo_rotate (graphics-&gt;ct, M_PI/2.0);
</I>&gt;&gt;<i> +			cairo_translate (graphics-&gt;ct, 0, -FrameHeight);
</I>&gt;&gt;<i> +			pango_cairo_update_context (graphics-&gt;ct, context);
</I>&gt;&gt;<i> +		} else {
</I>&gt;&gt;<i> +			cairo_rotate (graphics-&gt;ct, 3.0*M_PI/2.0);
</I>&gt;&gt;<i> +			cairo_translate (graphics-&gt;ct, -FrameWidth, 0);
</I>&gt;&gt;<i> +			pango_cairo_update_context (graphics-&gt;ct, context);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i>  		/* only since Pango 1.16 */
</I>&gt;&gt;<i> -		pango_context_set_base_gravity (context, PANGO_GRAVITY_EAST);
</I>&gt;&gt;<i> -		pango_context_set_gravity_hint (context, PANGO_GRAVITY_HINT_STRONG);
</I>&gt;&gt;<i> +		pango_context_set_base_gravity (context, PANGO_GRAVITY_AUTO);
</I>&gt;&gt;<i> +		pango_context_set_gravity_hint (context, PANGO_GRAVITY_HINT_LINE);
</I>&gt;&gt;<i>  		pango_layout_context_changed (layout);
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i>  #endif
</I>&gt;&gt;<i> @@ -169,38 +296,27 @@
</I>&gt;&gt;<i>  	/* TODO - StringFormatFlagsDisplayFormatControl
</I>&gt;&gt;<i>  		scan and replace them ??? */
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	/* TODO - StringFormatFlagsLineLimit */
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -	if ((rc-&gt;Width != 0) &amp;&amp; (rc-&gt;Height != 0) &amp;&amp; ((fmt-&gt;formatFlags &amp; StringFormatFlagsNoClip) == 0)) {
</I>&gt;&gt;<i> -//g_warning (&quot;\tclip [%g %g %g %g]&quot;, rc-&gt;X, rc-&gt;Y, rc-&gt;Width, rc-&gt;Height);
</I>&gt;&gt;<i> -		/* We do not call cairo_reset_clip because we want to take previous clipping into account */
</I>&gt;&gt;<i> -		cairo_rectangle (ct, rc-&gt;X, rc-&gt;Y, rc-&gt;Width + 0.5, rc-&gt;Height + 0.5);
</I>&gt;&gt;<i> -		cairo_clip (ct);
</I>&gt;&gt;<i> -	}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> +	/* Trimming options seem to apply only to the end of the string - gdi+ will still wrap 
</I>&gt;&gt;<i> +	 * with preference to word first, then character.  Unfortunately, pango doesn't have
</I>&gt;&gt;<i> +	 * any way to differentiate wrapping behavior from trimming behavior that I could find */
</I>&gt;&gt;<i> +	pango_layout_set_wrap (layout, PANGO_WRAP_WORD_CHAR);
</I>&gt;&gt;<i>  	switch (fmt-&gt;trimming) {
</I>&gt;&gt;<i>  	case StringTrimmingNone:
</I>&gt;&gt;<i> -		pango_layout_set_wrap (layout, PANGO_WRAP_WORD_CHAR);
</I>&gt;&gt;<i>  		pango_layout_set_ellipsize (layout, PANGO_ELLIPSIZE_NONE);
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	case StringTrimmingCharacter:
</I>&gt;&gt;<i> -		pango_layout_set_wrap (layout, PANGO_WRAP_CHAR);
</I>&gt;&gt;<i>  		pango_layout_set_ellipsize (layout, PANGO_ELLIPSIZE_NONE);
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	case StringTrimmingWord:
</I>&gt;&gt;<i> -		pango_layout_set_wrap (layout, PANGO_WRAP_WORD);
</I>&gt;&gt;<i>  		pango_layout_set_ellipsize (layout, PANGO_ELLIPSIZE_NONE);
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	case StringTrimmingEllipsisCharacter:
</I>&gt;&gt;<i> -		pango_layout_set_wrap (layout, PANGO_WRAP_CHAR);
</I>&gt;&gt;<i>  		pango_layout_set_ellipsize (layout, PANGO_ELLIPSIZE_END);
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	case StringTrimmingEllipsisWord:
</I>&gt;&gt;<i> -		pango_layout_set_wrap (layout, PANGO_WRAP_WORD);
</I>&gt;&gt;<i>  		pango_layout_set_ellipsize (layout, PANGO_ELLIPSIZE_END);
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	case StringTrimmingEllipsisPath:
</I>&gt;&gt;<i> -		pango_layout_set_wrap (layout, PANGO_WRAP_WORD_CHAR);
</I>&gt;&gt;<i>  		pango_layout_set_ellipsize (layout, PANGO_ELLIPSIZE_MIDDLE);
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i> @@ -233,59 +349,138 @@
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> +	if (fmt-&gt;numtabStops &gt; 0) {
</I>&gt;&gt;<i> +		float tabPosition;
</I>&gt;&gt;<i> +		tabs = pango_tab_array_new (fmt-&gt;numtabStops, TRUE);
</I>&gt;&gt;<i> +		tabPosition = fmt-&gt;firstTabOffset;
</I>&gt;&gt;<i> +		for (i = 0; i &lt; fmt-&gt;numtabStops; i++) {
</I>&gt;&gt;<i> +			tabPosition += fmt-&gt;tabStops[i];
</I>&gt;&gt;<i> +			pango_tab_array_set_tab (tabs, i, PANGO_TAB_LEFT, (gint)min (tabPosition, PANGO_MAX) * PANGO_SCALE);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +		pango_layout_set_tabs (layout, tabs);
</I>&gt;&gt;<i> +		pango_tab_array_free (tabs);
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	//g_warning (&quot;length before ws removal: %d&quot;, length);
</I>&gt;&gt;<i> +	trimSpace = (fmt-&gt;formatFlags &amp; StringFormatFlagsMeasureTrailingSpaces) == 0;
</I>&gt;&gt;<i>  	switch (fmt-&gt;hotkeyPrefix) {
</I>&gt;&gt;<i>  	case HotkeyPrefixHide:
</I>&gt;&gt;<i>  		/* we need to remove any accelerator from the string */
</I>&gt;&gt;<i> -		gdip_process_accelerators (text, length, NULL);
</I>&gt;&gt;<i> +		ftext = gdip_process_string (text, length, 1, trimSpace, NULL, charsRemoved);
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	case HotkeyPrefixShow:
</I>&gt;&gt;<i>  		/* optimization: is seems that we never see the hotkey when using an underline font */
</I>&gt;&gt;<i>  		if (font-&gt;style &amp; FontStyleUnderline) {
</I>&gt;&gt;<i>  			/* so don't bother drawing it (and simply add the '&amp;' character) */
</I>&gt;&gt;<i> -			gdip_process_accelerators (text, length, NULL);
</I>&gt;&gt;<i> +			ftext = gdip_process_string (text, length, 1, trimSpace, NULL, charsRemoved);
</I>&gt;&gt;<i>  		} else {
</I>&gt;&gt;<i>  			/* find accelerator and add attribute to the next character (unless it's the prefix too) */
</I>&gt;&gt;<i>  			if (!list)
</I>&gt;&gt;<i>  				list = gdip_get_layout_attributes (layout);
</I>&gt;&gt;<i> -			gdip_process_accelerators (text, length, list);
</I>&gt;&gt;<i> +			ftext = gdip_process_string (text, length, 1, trimSpace, list, charsRemoved);
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	default:
</I>&gt;&gt;<i> +		ftext = gdip_process_string (text, length, 0, trimSpace, NULL, charsRemoved);
</I>&gt;&gt;<i>  		break;
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i> +	length = ftext-&gt;len;
</I>&gt;&gt;<i> +	//g_warning (&quot;length after ws removal: %d&quot;, length);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	if (list) {
</I>&gt;&gt;<i>  		pango_layout_set_attributes (layout, list);
</I>&gt;&gt;<i>  		pango_attr_list_unref (list);
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	pango_layout_set_text (layout, text, length);
</I>&gt;&gt;<i> +// g_warning(&quot;\tftext&gt;%s&lt; (%d)&quot;, ftext-&gt;str, -1);
</I>&gt;&gt;<i> +	pango_layout_set_text (layout, ftext-&gt;str, ftext-&gt;len);
</I>&gt;&gt;<i>  	GdipFree (text);
</I>&gt;&gt;<i> +    g_string_free (ftext, TRUE);
</I>&gt;<i> 
</I>&gt;<i> ^ tab/space
</I>&gt;<i> 
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	pango_layout_get_pixel_extents (layout, NULL, &amp;logical);
</I>&gt;&gt;<i> -//g_warning (&quot;\tlogical\t[x %d, y %d, w %d, h %d]&quot;, logical.x, logical.y, logical.width, logical.height);
</I>&gt;&gt;<i> +	/* Trim the text after the last line for ease of counting lines/characters */
</I>&gt;&gt;<i> +	/* Also prevents drawing whole lines outside the boundaries if NoClip was specified */
</I>&gt;&gt;<i> +	/* In case of pre-existing clipping, use smaller of clip rectangle or our specified height */
</I>&gt;&gt;<i> +	if (FrameHeight &gt; 0) {
</I>&gt;&gt;<i> +		cairo_clip_extents (graphics-&gt;ct, &amp;clipx1, &amp;clipy1, &amp;clipx2, &amp;clipy2);
</I>&gt;&gt;<i> +		if (clipy2 &gt; 0)
</I>&gt;&gt;<i> +			clipy2 = min (clipy2, FrameHeight + FrameY);
</I>&gt;&gt;<i> +		else
</I>&gt;&gt;<i> +			clipy2 = FrameHeight + FrameY;
</I>&gt;&gt;<i> +		iter = pango_layout_get_iter (layout);
</I>&gt;&gt;<i> +		do {
</I>&gt;&gt;<i> +			if (iter == NULL)
</I>&gt;&gt;<i> +				break;
</I>&gt;&gt;<i> +			pango_layout_iter_get_line_yrange (iter, &amp;y0, &amp;y1);
</I>&gt;&gt;<i> +			//g_warning(&quot;yrange: %d  %d  clipy2: %f&quot;, y0 / PANGO_SCALE, y1 / PANGO_SCALE, clipy2);
</I>&gt;&gt;<i> +			/* StringFormatFlagsLineLimit */
</I>&gt;&gt;<i> +			if (((fmt-&gt;formatFlags &amp; StringFormatFlagsLineLimit) &amp;&amp; y1 / PANGO_SCALE &gt; clipy2) || (y0 / PANGO_SCALE &gt; clipy2)) {
</I>&gt;&gt;<i> +				PangoLayoutLine *line = pango_layout_iter_get_line_readonly (iter);
</I>&gt;&gt;<i> +				pango_layout_set_text (layout, pango_layout_get_text (layout), line-&gt;start_index);
</I>&gt;&gt;<i> +				break;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		} while (pango_layout_iter_next_line (iter));
</I>&gt;&gt;<i> +		pango_layout_iter_free (iter);
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	box-&gt;X = rc-&gt;X;
</I>&gt;&gt;<i> -	box-&gt;Y = rc-&gt;Y;
</I>&gt;&gt;<i> -	box-&gt;Height = logical.height;
</I>&gt;&gt;<i> -	/* add an extra pixel for our AA hack + 2 more if we don't draw on the box itself */
</I>&gt;&gt;<i> -	box-&gt;Width = logical.width + (fmt-&gt;formatFlags &amp; StringFormatFlagsNoFitBlackBox) ? 1 : 3;
</I>&gt;&gt;<i> -//g_warning (&quot;\tbox\t[x %g, y %g, w %g, h %g]&quot;, box-&gt;X, box-&gt;Y, box-&gt;Width, box-&gt;Height);
</I>&gt;&gt;<i> +	pango_layout_get_pixel_extents (layout, &amp;ink, &amp;logical);
</I>&gt;&gt;<i> + //g_warning (&quot;\tlogical\t[x %d, y %d, w %d, h %d][x %d, y %d, w %d, h %d]&quot;, logical.x, logical.y, logical.width, logical.height, ink.x, ink.y, ink.width, ink.height);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> +	if ((fmt-&gt;formatFlags &amp; StringFormatFlagsNoFitBlackBox) == 0) {
</I>&gt;&gt;<i> +		/* By default don't allow overhang - ink space may be larger than logical space */
</I>&gt;&gt;<i> +		if (fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionVertical) {
</I>&gt;&gt;<i> +			box-&gt;X = min (ink.y, logical.y);
</I>&gt;&gt;<i> +			box-&gt;Y = min (ink.x, logical.x);
</I>&gt;&gt;<i> +			box-&gt;Height = max (ink.width, logical.width);
</I>&gt;&gt;<i> +			box-&gt;Width = max (ink.height, logical.height);
</I>&gt;&gt;<i> +		} else {
</I>&gt;&gt;<i> +			box-&gt;X = min (ink.x, logical.x);
</I>&gt;&gt;<i> +			box-&gt;Y = min (ink.y, logical.y);
</I>&gt;&gt;<i> +			box-&gt;Height = max (ink.height, logical.height);
</I>&gt;&gt;<i> +			box-&gt;Width = max (ink.width, logical.width);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +	} else {
</I>&gt;&gt;<i> +		/* Allow overhang */
</I>&gt;&gt;<i> +		if (fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionVertical) {
</I>&gt;&gt;<i> +			box-&gt;X = logical.y;
</I>&gt;&gt;<i> +			box-&gt;Y = logical.x;
</I>&gt;&gt;<i> +			box-&gt;Height = logical.width;
</I>&gt;&gt;<i> +			box-&gt;Width = logical.height;
</I>&gt;&gt;<i> +		} else {
</I>&gt;&gt;<i> +			box-&gt;X = logical.x;
</I>&gt;&gt;<i> +			box-&gt;Y = logical.y;
</I>&gt;&gt;<i> +			box-&gt;Height = logical.height;
</I>&gt;&gt;<i> +			box-&gt;Width = logical.width;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> + //g_warning (&quot;\tbox\t[x %g, y %g, w %g, h %g]&quot;, box-&gt;X, box-&gt;Y, box-&gt;Width, box-&gt;Height);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>  	/* vertical alignment*/
</I>&gt;&gt;<i> -	switch (fmt-&gt;lineAlignment) {
</I>&gt;&gt;<i> -	case StringAlignmentNear:
</I>&gt;&gt;<i> -		break;
</I>&gt;&gt;<i> -	case StringAlignmentCenter:
</I>&gt;&gt;<i> -		box-&gt;Y += (rc-&gt;Height - logical.height) / 2;
</I>&gt;&gt;<i> -		break;
</I>&gt;&gt;<i> -	case StringAlignmentFar:
</I>&gt;&gt;<i> -		box-&gt;Y += (rc-&gt;Height - logical.height);
</I>&gt;&gt;<i> -		break;
</I>&gt;&gt;<i> +	if (fmt-&gt;formatFlags &amp; StringFormatFlagsDirectionVertical) {
</I>&gt;&gt;<i> +		switch (fmt-&gt;lineAlignment) {
</I>&gt;&gt;<i> +		case StringAlignmentNear:
</I>&gt;&gt;<i> +			break;
</I>&gt;&gt;<i> +		case StringAlignmentCenter:
</I>&gt;&gt;<i> +			box-&gt;X += (rc-&gt;Width - box-&gt;Width) / 2;
</I>&gt;&gt;<i> +			break;
</I>&gt;&gt;<i> +		case StringAlignmentFar:
</I>&gt;&gt;<i> +			box-&gt;X += (rc-&gt;Width - box-&gt;Width);
</I>&gt;&gt;<i> +			break;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +	} else {
</I>&gt;&gt;<i> +		switch (fmt-&gt;lineAlignment) {
</I>&gt;&gt;<i> +		case StringAlignmentNear:
</I>&gt;&gt;<i> +			break;
</I>&gt;&gt;<i> +		case StringAlignmentCenter:
</I>&gt;&gt;<i> +			box-&gt;Y += (rc-&gt;Height - box-&gt;Height) / 2;
</I>&gt;&gt;<i> +			break;
</I>&gt;&gt;<i> +		case StringAlignmentFar:
</I>&gt;&gt;<i> +			box-&gt;Y += (rc-&gt;Height - box-&gt;Height);
</I>&gt;&gt;<i> +			break;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i> -//g_warning (&quot;va-box\t[x %g, y %g, w %g, h %g]&quot;, box-&gt;X, box-&gt;Y, box-&gt;Width, box-&gt;Height);
</I>&gt;&gt;<i> +// g_warning (&quot;va-box\t[x %g, y %g, w %g, h %g]&quot;, box-&gt;X, box-&gt;Y, box-&gt;Width, box-&gt;Height);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	pango_cairo_update_layout (ct, layout);
</I>&gt;&gt;<i> +	pango_cairo_update_layout (graphics-&gt;ct, layout);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	return layout;
</I>&gt;&gt;<i>  }
</I>&gt;&gt;<i> @@ -297,22 +492,22 @@
</I>&gt;&gt;<i>  	PangoLayout *layout;
</I>&gt;&gt;<i>  	RectF box;
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> +	/* Setup cairo */
</I>&gt;&gt;<i> +	if (brush) {
</I>&gt;&gt;<i> +		gdip_brush_setup (graphics, brush);
</I>&gt;&gt;<i> +	} else {
</I>&gt;&gt;<i> +		cairo_set_source_rgb (graphics-&gt;ct, 0., 0., 0.);
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>  	cairo_save (graphics-&gt;ct);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	layout = gdip_pango_setup_layout (graphics-&gt;ct, stringUnicode, length, font, rc, &amp;box, format);
</I>&gt;&gt;<i> +	layout = gdip_pango_setup_layout (graphics, stringUnicode, length, font, rc, &amp;box, format, NULL);
</I>&gt;&gt;<i>  	if (!layout) {
</I>&gt;&gt;<i>  		cairo_restore (graphics-&gt;ct);
</I>&gt;&gt;<i>  		return OutOfMemory;
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	/* Setup cairo */
</I>&gt;&gt;<i> -	if (brush) {
</I>&gt;&gt;<i> -		gdip_brush_setup (graphics, brush);
</I>&gt;&gt;<i> -	} else {
</I>&gt;&gt;<i> -		cairo_set_source_rgb (graphics-&gt;ct, 0., 0., 0.);
</I>&gt;&gt;<i> -	}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -	gdip_cairo_move_to (graphics, box.X, box.Y, FALSE, TRUE);
</I>&gt;&gt;<i> +	gdip_cairo_move_to (graphics, rc-&gt;X, rc-&gt;Y, FALSE, TRUE);
</I>&gt;&gt;<i>  	pango_cairo_show_layout (graphics-&gt;ct, layout);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	g_object_unref (layout);
</I>&gt;&gt;<i> @@ -325,25 +520,96 @@
</I>&gt;&gt;<i>  	GDIPCONST GpStringFormat *format, RectF *boundingBox, int *codepointsFitted, int *linesFilled)
</I>&gt;&gt;<i>  {
</I>&gt;&gt;<i>  	PangoLayout *layout;
</I>&gt;&gt;<i> +	PangoLayoutLine *line;
</I>&gt;&gt;<i> +	PangoRectangle logical;
</I>&gt;&gt;<i> +	PangoLayoutIter *iter;
</I>&gt;&gt;<i> +	int *charsRemoved = NULL;
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	cairo_save (graphics-&gt;ct);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	layout = gdip_pango_setup_layout (graphics-&gt;ct, stringUnicode, length, font, rc, boundingBox, format);
</I>&gt;&gt;<i> +	layout = gdip_pango_setup_layout (graphics, stringUnicode, length, font, rc, boundingBox, format, &amp;charsRemoved);
</I>&gt;&gt;<i>  	if (!layout) {
</I>&gt;&gt;<i>  		cairo_restore (graphics-&gt;ct);
</I>&gt;&gt;<i>  		return OutOfMemory;
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i>  		
</I>&gt;&gt;<i>  	if (codepointsFitted) {
</I>&gt;&gt;<i> -		// TODO - dummy (total) value returned
</I>&gt;&gt;<i> -		*codepointsFitted = length;
</I>&gt;&gt;<i> +		int charsFitted;
</I>&gt;&gt;<i> +		int lastIndex;
</I>&gt;&gt;<i> +		int y0;
</I>&gt;&gt;<i> +		int y1;
</I>&gt;&gt;<i> +		double min_x;
</I>&gt;&gt;<i> +		double max_x;
</I>&gt;&gt;<i> +		double max_y;
</I>&gt;&gt;<i> +		const char *layoutText;
</I>&gt;&gt;<i> +		if (boundingBox &amp;&amp; format &amp;&amp; (format-&gt;formatFlags &amp; StringFormatFlagsDirectionVertical)) {
</I>&gt;&gt;<i> +			min_x = boundingBox-&gt;Y;
</I>&gt;&gt;<i> +			max_x = boundingBox-&gt;Y + boundingBox-&gt;Height;
</I>&gt;&gt;<i> +			max_y = boundingBox-&gt;X + boundingBox-&gt;Width;
</I>&gt;&gt;<i> +		} else if (boundingBox) {
</I>&gt;&gt;<i> +			min_x = boundingBox-&gt;X;
</I>&gt;&gt;<i> +			max_x = boundingBox-&gt;X + boundingBox-&gt;Width;
</I>&gt;&gt;<i> +			max_y = boundingBox-&gt;Y + boundingBox-&gt;Height;
</I>&gt;&gt;<i> +		} else if (format &amp;&amp; (format-&gt;formatFlags &amp; StringFormatFlagsDirectionVertical)) {
</I>&gt;&gt;<i> +			min_x = rc-&gt;Y;
</I>&gt;&gt;<i> +			max_x = rc-&gt;Y + rc-&gt;Height;
</I>&gt;&gt;<i> +			max_y = rc-&gt;X + rc-&gt;Width;
</I>&gt;&gt;<i> +		} else {
</I>&gt;&gt;<i> +			min_x = rc-&gt;X;
</I>&gt;&gt;<i> +			max_x = rc-&gt;X + rc-&gt;Width;
</I>&gt;&gt;<i> +			max_y = rc-&gt;Y + rc-&gt;Height;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +		lastIndex = 0;
</I>&gt;&gt;<i> +		iter = pango_layout_get_iter (layout);
</I>&gt;&gt;<i> +		do {
</I>&gt;&gt;<i> +			if (iter == NULL)
</I>&gt;&gt;<i> +				break;
</I>&gt;&gt;<i> +			pango_layout_iter_get_line_yrange (iter, &amp;y0, &amp;y1);
</I>&gt;&gt;<i> +			if (y0 / PANGO_SCALE &gt;= max_y)
</I>&gt;&gt;<i> +				break;
</I>&gt;&gt;<i> +			if (pango_layout_iter_at_last_line (iter)) {
</I>&gt;&gt;<i> +				do {
</I>&gt;&gt;<i> +					pango_layout_iter_get_char_extents (iter, &amp;logical);
</I>&gt;&gt;<i> +					/* check both max and min to catch right-to-left text, also width may be negative */
</I>&gt;&gt;<i> +					if ((logical.x / PANGO_SCALE &gt; max_x || (logical.x + logical.width) / PANGO_SCALE &gt; max_x) || (logical.x / PANGO_SCALE &lt; min_x || (logical.x + logical.width) / PANGO_SCALE &lt; min_x))
</I>&gt;&gt;<i> +						break;
</I>&gt;&gt;<i> +					lastIndex = pango_layout_iter_get_index (iter);
</I>&gt;&gt;<i> +				} while (pango_layout_iter_next_char (iter));
</I>&gt;&gt;<i> +				break;
</I>&gt;&gt;<i> +			} else {
</I>&gt;&gt;<i> +				line = pango_layout_iter_get_line_readonly (iter);
</I>&gt;&gt;<i> +				lastIndex = line-&gt;start_index + line-&gt;length - 1;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		} while (pango_layout_iter_next_line (iter));
</I>&gt;&gt;<i> +		pango_layout_iter_free (iter);
</I>&gt;&gt;<i> +		layoutText = pango_layout_get_text (layout);
</I>&gt;&gt;<i> +		/* this can happen when the string ends in a newline */
</I>&gt;&gt;<i> +		if (lastIndex &gt;= strlen (layoutText))
</I>&gt;&gt;<i> +			lastIndex = strlen (layoutText) - 1;
</I>&gt;&gt;<i> +		/* Add back in any &amp; characters removed and the final newline characters (if any) */
</I>&gt;&gt;<i> +		charsFitted = g_utf8_strlen (layoutText, lastIndex + 1) + charsRemoved [lastIndex];
</I>&gt;&gt;<i> +		//g_warning(&quot;lastIndex: %d\t\tcharsRemoved: %d&quot;, lastIndex, charsRemoved[lastIndex]);
</I>&gt;&gt;<i> +		/* safe because of null termination */
</I>&gt;&gt;<i> +		switch (layoutText [lastIndex + 1]) {
</I>&gt;&gt;<i> +			case '\r':
</I>&gt;&gt;<i> +				charsFitted++;
</I>&gt;&gt;<i> +				if (layoutText [lastIndex + 2] == '\n')
</I>&gt;&gt;<i> +					charsFitted++;
</I>&gt;&gt;<i> +				break;
</I>&gt;&gt;<i> +			case '\n':
</I>&gt;&gt;<i> +				charsFitted++;
</I>&gt;&gt;<i> +				break;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +		*codepointsFitted = charsFitted;
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> +	GdipFree (charsRemoved);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>  	if (linesFilled) {
</I>&gt;&gt;<i>  		*linesFilled = pango_layout_get_line_count (layout);
</I>&gt;&gt;<i> -//g_warning (&quot;linesFilled %d&quot;, *linesFilled);
</I>&gt;&gt;<i> +// g_warning (&quot;linesFilled %d&quot;, *linesFilled);
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i> -//else g_warning (&quot;linesFilled %d&quot;, pango_layout_get_line_count (layout));
</I>&gt;&gt;<i> +// else g_warning (&quot;linesFilled %d&quot;, pango_layout_get_line_count (layout));
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	g_object_unref (layout);
</I>&gt;&gt;<i>  	cairo_restore (graphics-&gt;ct);
</I>&gt;&gt;<i> @@ -361,7 +627,7 @@
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	cairo_save (graphics-&gt;ct);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> -	layout = gdip_pango_setup_layout (graphics-&gt;ct, stringUnicode, length, font, layoutRect, &amp;boundingBox, format);
</I>&gt;&gt;<i> +	layout = gdip_pango_setup_layout (graphics, stringUnicode, length, font, layoutRect, &amp;boundingBox, format, NULL);
</I>&gt;&gt;<i>  	if (!layout) {
</I>&gt;&gt;<i>  		cairo_restore (graphics-&gt;ct);
</I>&gt;&gt;<i>  		return OutOfMemory;
</I>&gt;&gt;<i> @@ -402,7 +668,16 @@
</I>&gt;&gt;<i>  			charRect.Y = (float)box.y / PANGO_SCALE;
</I>&gt;&gt;<i>  			charRect.Width = (float)box.width / PANGO_SCALE;
</I>&gt;&gt;<i>  			charRect.Height = (float)box.height / PANGO_SCALE;
</I>&gt;&gt;<i> -//g_warning (&quot;[%d] [%d : %d-%d] %c [x %g y %g w %g h %g]&quot;, i, j, start, end, (char)stringUnicode[j], charRect.X, charRect.Y, charRect.Width, charRect.Height);
</I>&gt;&gt;<i> +			/* Normalize values (width/height can be negative) */
</I>&gt;&gt;<i> +			if (charRect.Width &lt; 0) {
</I>&gt;&gt;<i> +				charRect.Width = -charRect.Width;
</I>&gt;&gt;<i> +				charRect.X -= charRect.Width;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +			if (charRect.Height &lt; 0) {
</I>&gt;&gt;<i> +				charRect.Height = -charRect.Height;
</I>&gt;&gt;<i> +				charRect.Y -= charRect.Height;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +// g_warning (&quot;[%d] [%d : %d-%d] %c [x %g y %g w %g h %g]&quot;, i, j, start, end, (char)stringUnicode[j], charRect.X, charRect.Y, charRect.Width, charRect.Height);
</I>&gt;&gt;<i>  			status = GdipCombineRegionRect (regions [i], &amp;charRect, CombineModeUnion);
</I>&gt;&gt;<i>  			if (status != Ok)
</I>&gt;&gt;<i>  				break;
</I>&gt;&gt;<i> Index: src/graphics-path.c
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- src/graphics-path.c	(revision 126715)
</I>&gt;&gt;<i> +++ src/graphics-path.c	(working copy)
</I>&gt;&gt;<i> @@ -1212,7 +1212,7 @@
</I>&gt;&gt;<i>  	PangoLayout* layout; 
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>  	cairo_save (cr);
</I>&gt;&gt;<i> -	layout = gdip_pango_setup_layout (cr, string, length, font, layoutRect, &amp;box, format);
</I>&gt;&gt;<i> +	layout = gdip_pango_setup_layout (cr, string, length, font, layoutRect, &amp;box, format, NULL);
</I>&gt;&gt;<i>  	pango_cairo_layout_path (cr, layout);
</I>&gt;&gt;<i>  	g_object_unref (layout);
</I>&gt;&gt;<i>  	cairo_restore (cr);
</I>&gt;<i> 
</I>&gt;<i> 
</I></PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003941.html">[Mono-winforms-list] Application exits when I press right arrow key
</A></li>
	<LI>Next message: <A HREF="003961.html">[Mono-winforms-list] [Mono-dev] libgdiplus pango patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3946">[ date ]</a>
              <a href="thread.html#3946">[ thread ]</a>
              <a href="subject.html#3946">[ subject ]</a>
              <a href="author.html#3946">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-winforms-list">More information about the Mono-winforms-list
mailing list</a><br>
</body></html>
