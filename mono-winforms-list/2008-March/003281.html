<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-winforms-list] patch for enabling primitive XIM text input
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-winforms-list%40lists.ximian.com?Subject=%5BMono-winforms-list%5D%20patch%20for%20enabling%20primitive%20XIM%20text%20input&In-Reply-To=47E373B0.9020608%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003280.html">
   <LINK REL="Next"  HREF="003282.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-winforms-list] patch for enabling primitive XIM text input</H1>
    <B>Doug Rintoul</B> 
    <A HREF="mailto:mono-winforms-list%40lists.ximian.com?Subject=%5BMono-winforms-list%5D%20patch%20for%20enabling%20primitive%20XIM%20text%20input&In-Reply-To=47E373B0.9020608%40ximian.com"
       TITLE="[Mono-winforms-list] patch for enabling primitive XIM text input">doug_rintoul at sil.org
       </A><BR>
    <I>Tue Mar 25 19:08:54 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="003280.html">[Mono-winforms-list] patch for enabling primitive XIM text input
</A></li>
        <LI>Next message: <A HREF="003282.html">[Mono-winforms-list] patch for enabling primitive XIM text input
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3281">[ date ]</a>
              <a href="thread.html#3281">[ thread ]</a>
              <a href="subject.html#3281">[ subject ]</a>
              <a href="author.html#3281">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Atsushi Eno wrote:
&gt;<i> Hello,
</I>&gt;<i>
</I>&gt;&gt;<i> The first problem has to do with the tracking of the control, shift, 
</I>&gt;&gt;<i> and alt key. These keys will currently get &quot;stuck&quot; because if 
</I>&gt;&gt;<i> FosterParent filters the key release event, a key release event for 
</I>&gt;&gt;<i> these keys are never put on the hwnd Queue. For example, if you press 
</I>&gt;&gt;<i> CTRL-space to enable an IM, winforms still thinks the control key is 
</I>&gt;&gt;<i> still pressed, even after you release it. Using the left and right 
</I>&gt;&gt;<i> cursor keys to move around a input field will move a word at a time, 
</I>&gt;&gt;<i> rather than a letter at a time.
</I>&gt;&gt;<i>
</I>&gt;<i> Ah, good point! It should be fixed too. But I somewhat doubt if your 
</I>&gt;<i> change
</I>&gt;<i> especially that KeyRelease event is always passed works fine.
</I>&gt;<i> It could result in inconsistent key event processing (KeyPress could be
</I>&gt;<i> filtered and KeyRelease always isn't) and such inconsistency trapped me
</I>&gt;<i> couple of days. So, IMHO there should be some condition to determine
</I>&gt;<i> whether to filter KeyRelease or not.
</I>&gt;<i>
</I>Key filtering is totaling at the whim of the IM. If the the IM processes 
a key event it will tell the calling procedure the event is filtered. I 
am assuming you mean there should be a condition on whether we should 
process a key event in winforms even when the IM has filtered the event. 
If so, then you are correct. I think my patch currently works because 
few apps use key release events and so dual processing by both the IM 
and winforms is not an issue. However keypress events for mod could be a 
problem if the IM filters event. The keypress event would never be 
processed by winforms and thus the key state would never be registered. 
In this case we cannot do dual processing of all keypress events. So 
some condition needs to be determine as to when we pass the key press 
and key release events onto winform.

Unfortunately, winforms currently relies on key press and key release 
events to track the modification key states. Perhaps it is enough to 
test if the event is a key press or a key release mod key event (alt, 
ctrl, shift, menu, etc) and then pass the event on to winforms for 
processing even if the IM filters the event. The only other alternative 
I can see is to redesign winforms so that it queries X for the current 
state of the modifier keys whenever it needs that information.
&gt;&gt;<i> The second issue has to do with the way that IME compose messages are 
</I>&gt;&gt;<i> handle. A bit of background is required here. I am one of the authors 
</I>&gt;&gt;<i> of KMFL (kmfl.sourceforge.net), which provides Tavaultesoft Keyman 
</I>&gt;&gt;<i> services to Linux. The way KMFL is designed is that KMFL can generate 
</I>&gt;&gt;<i> multiple compose messages in response to a single key stroke. The 
</I>&gt;&gt;<i> problem is that XIM does not use a FIFO to queue XIM compose 
</I>&gt;&gt;<i> messages, but a stack. So unless XIM compose events are processed 
</I>&gt;&gt;<i> immediately upon receipt, the recipient window will receive the XIM 
</I>&gt;&gt;<i> compose messages in the reverse order that they are generated. The 
</I>&gt;&gt;<i> fix is rather easy to implement. We just allow the application to 
</I>&gt;&gt;<i> process the keypress messages upon receipt rather than queuing a 
</I>&gt;&gt;<i> whole bunch and then returning. Note that the GTK XIM connector and 
</I>&gt;&gt;<i> the QT XIM interface work correctly with KMFL, so they implement a 
</I>&gt;&gt;<i> similar solution.
</I>&gt;&gt;<i>
</I>&gt;<i> I'm not sure what you meant here. Do you mean such event processing 
</I>&gt;<i> like below
</I>&gt;<i> could happen? :
</I>&gt;<i>
</I>&gt;<i>    - KeyPress for 'A' occurs, and then it is stored in X event queue 
</I>&gt;<i> ... well, &quot;stack&quot; ...
</I>&gt;<i>      as pending.
</I>&gt;<i>    - KeyPress for 'B' occurs, and then it is stored as pending.
</I>&gt;<i>    - XNextEvent() is called, and X returns KeyPress 'B' because it is 
</I>&gt;<i> not FIFO.
</I>&gt;<i>
</I>This is sort of what happens. It has been awhile since I poked around 
the XIM code in X. I just went back to familiarized myself with the 
situation. The actual problem is with the XIM commit code in X11. Here 
is an example of what actually happens:

1. The user presses 7. The input method is to generate the string 
&quot;seven&quot; in response to this. The IM will actually generate each 
character as a separate compose event. I realize that in this case the 
IM could have generated one compose event containing the string &quot;seven&quot;, 
but this is not always the case. The way the kmfl engine is designed, it 
needs to be able to generate separate compose events in response to one 
keypress.
2. The IM calls the XIM commit callback to commit the first letter &quot;s&quot;
3. The XIM commit callback pushes the commit string on the IC commit 
info stack and then fabricates a KeyPress event with a keycode of 0 and 
pushes this event onto the event queue. Control is then transfered to 
winforms.
4. winforms receives the fabricated event and puts the event onto the 
hwnd queue via UpdateMessageQueue (UpdateMessageQueue was called by 
GetMessage).
5. UpdateMessageQueue then calls XPending and XNextEvent in a loop to 
get the next event. XNextEvent passes control back to X which in turn 
passes control back to the IM.
6. The IM calls the XIM commit callback to commit the second letter &quot;e&quot;
7. Steps 3, 4 and 5 are repeated.
8. Steps 2, 3, 4 and 5 are repeated for the rest of the letters. Note 
that the IC commit info stack now has &quot;neves&quot; on it.
9. Control is now passed back to winforms GetMessage. GetMessage calls 
Keyboard.KeyEvent to process the first fabricated keypress.
10. KeyEvent calls LookupString which in turn calls Xutf8LookupString. 
Xutf8LookupString returns the first compose sequence off the C commit 
info stack, in this case &quot;n&quot; which is in turn sent to the app via 
SendImeComposition.
11. Step 10 is repeated for each of the compose character and thus neves 
is sent to the application.

&gt;<i> Gtk and Qt of course have different event processing model from 
</I>&gt;<i> winforms, so it
</I>&gt;<i> could be just that the issue with kfml does not occur. I'm not sure 
</I>&gt;<i> your change is
</I>&gt;<i> valid from our perspective (UpdateMessageQueue() may have to lookup 
</I>&gt;<i> every X
</I>&gt;<i> events; I have no idea as I'm just digging into winforms only for XIM 
</I>&gt;<i> support ;).
</I>Not sure I understand. Every event is still processed by 
UpdateMessageQueue. Just not in a loop for keypress events.
&gt;<i>
</I>&gt;<i> Besides I'm not sure why giving up processing pending event 
</I>&gt;<i> immediately in
</I>&gt;<i> UpdateMessageQueue() could fix the situation. To my understanding, events
</I>&gt;<i> are anyways retrieved as LIFO (if I believe you) and if kfml anyways 
</I>&gt;<i> regenerate
</I>&gt;<i> other messages as a result of KeyPress, they will be retrieved 
</I>&gt;<i> immediately
</I>&gt;<i> anyways, won't they?
</I>What my patch does is remove step 5. Control is passed back up the chain 
to GetMessage and thus Keyboard.KeyEvent to pop the commit string off 
the commit info stack before the IM and X can put another commit string 
onto the stack.
&gt;<i>
</I>&gt;&gt;<i> There is a third issue, the importance of which is debatable. For 
</I>&gt;&gt;<i> other frameworks (QT, GTK), each window in an application gets its 
</I>&gt;&gt;<i> own input method, independent of the other windows in an application. 
</I>&gt;&gt;<i> For example, in a text editor, even though you enable the input 
</I>&gt;&gt;<i> method, for the main editor, the IM is not enabled for the search 
</I>&gt;&gt;<i> box. This may not seem important at first, but it can be an issue for 
</I>&gt;&gt;<i> multilingual application where different fields can have different 
</I>&gt;&gt;<i> input methods associated with them. The patch I created last November 
</I>&gt;&gt;<i> did support this feature; however it does add a lot of complexity to 
</I>&gt;&gt;<i> the mix.
</I>&gt;&gt;<i>
</I>&gt;<i> Hmm, I don't think Windows Forms allow such input method switching.
</I>&gt;<i> It just controls whether IM could be enabled (default) or not. Of course
</I>&gt;<i> it is possible to have different XICs for each window but I doubt we have
</I>&gt;<i> any configuration point (other than custom configuration, environment
</I>&gt;<i> variables or whatever).
</I>&gt;<i>
</I>Winforms itself does not allow for such switching but an IM framework 
such as SCIM does. For example, I could have one field in which I want 
to type IPA characters and another field in which I want to type Greek. 
I enable the IM for the first field and switch to the IPA keyboard. I 
then switch to the second field and enable the IM and switch it to 
greek. For other frameworks such as GTK and QT, if I click on the first 
field, the input context is automatically switch back to IPA.

Stimulating stuff. Hopefully we can address these issues and come up 
with a working solution.

Doug Rintoul.
SIL Intl.
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003280.html">[Mono-winforms-list] patch for enabling primitive XIM text input
</A></li>
	<LI>Next message: <A HREF="003282.html">[Mono-winforms-list] patch for enabling primitive XIM text input
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3281">[ date ]</a>
              <a href="thread.html#3281">[ thread ]</a>
              <a href="subject.html#3281">[ subject ]</a>
              <a href="author.html#3281">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-winforms-list">More information about the Mono-winforms-list
mailing list</a><br>
</body></html>
