<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] Gnome.App.CreateMenus: take 2
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:csali%40tiscali.it">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="005105.html">
   <LINK REL="Next"  HREF="005110.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] Gnome.App.CreateMenus: take 2
   </H1>
    <B>Carlo Salinari
    </B> 
    <A HREF="mailto:csali%40tiscali.it"
       TITLE="[Gtk-sharp-list] Gnome.App.CreateMenus: take 2">csali@tiscali.it
       </A><BR>
    <I>Wed, 17 Nov 2004 13:17:44 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="005105.html">[Gtk-sharp-list] Gtk.Socket -&gt; Port communication
</A></li>
        <LI> Next message: <A HREF="005110.html">[Gtk-sharp-list] Refresh of elements in a treeview
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5106">[ date ]</a>
              <a href="thread.html#5106">[ thread ]</a>
              <a href="subject.html#5106">[ subject ]</a>
              <a href="author.html#5106">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.
--------------070105090504070808020704
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

Hello list,

I finally worked out a semi-functional example (see attachment) of
Gnome.App.CreateMenus invocation, wich I need to port the C version of
gnome-hello to C#.

compile: mcs -pkg:gnome-sharp-2.0 gnome-sharp-hello.cs
execute: mono gnome-sharp-hello.exe

Basically, I'd like to create a simple &quot;hello&quot; gnome program with no 
direct calls to gtk.

Otherwise, what's the sake of having a gnome and gnomeui library, if all 
&quot;gnome&quot;
programs go with gtk or glade as to interface building?

This confuses my quite a bit.

I had to create a new class, basically to handle the lack of any clear 
method to create
an UIInfo from the managed side. Here is the interface:

class GnomeAppHelper
{
    // byte-equivalent to UIInfo, all members accessible by CreateUIInfo
    [StructLayout(LayoutKind.Sequential)]
    protected struct DummyUIInfo; // byte-equivalent to UIInfo, all 
members accessible

    public static Gnome.UIInfo CreateUIInfo ( Gnome.UIInfoType    Type,
                                        string              Label,
                                        string              Hint,
                                        IntPtr              _moreinfo,
                                        IntPtr              _user_data,
                                        IntPtr              _unused_data,
                                        Gnome.UIPixmapType  PixmapType,
                                        IntPtr              _pixmap_info,
                                        uint                AcceleratorKey,
                                        Gdk.ModifierType    AcMods,
                                        IntPtr              _widget)

    public static Gnome.UIInfo CreateMenuConfigurableItem (string label)

    protected static HandleRef UIInfoArrayToHandleRef (Gnome.UIInfo[] arr)

    public static Gnome.UIInfo MenuMain (Gnome.UIInfo[] arr)

    public static Gnome.UIInfo CreateMenuItem (string label, string hint,
                                                
Gnome.UIInfoConfigurableTypes t)

    public static Gnome.UIInfo Endofinfo ()
    public static Gnome.UIInfo MenuFileTree (Gnome.UIInfo[] tree)

    public static Gnome.UIInfo MenuSubtree (Gnome.UIInfo[] tree)
    public static Gnome.UIInfo MenuInclude (Gnome.UIInfo[] tree)
}


This builds the menus as expected, but produces some nasty warnings
telling there's some incorrectly set C pointer somewhere.

I wasn't able to track the problem down, and at this point I really need
directions from some more experienced mono/gnome hacker.

cheers,
    Carlo



--------------070105090504070808020704
Content-Type: text/x-csharp;
 name=&quot;gnome-sharp-hello.cs&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename=&quot;gnome-sharp-hello.cs&quot;

using System;
using System.Runtime.InteropServices;

class GnomeSharpHello : Gnome.Program
{
    static public void Main (string[] args)
    {
        GnomeSharpHello hello = new GnomeSharpHello(args);
    }

    public GnomeSharpHello (string[] args)
    : base (&quot;GnomeSharpHello&quot;, &quot;0.1&quot;, Gnome.Modules.UI, args)
    {
        Gnome.App app = new Gnome.App (&quot;test&quot;, &quot;TEST&quot;);

        app.SetDefaultSize (400, 300);
        app.DeleteEvent += Window_Delete;

        Gtk.AccelGroup agrp = new Gtk.AccelGroup ();
        app.AddAccelGroup (agrp);

        app.Statusbar = new Gnome.AppBar (true, true,
                            Gnome.PreferencesType.Never);

        Gnome.UIInfo[] file_menu = {
            GnomeAppHelper.CreateMenuConfigurableItem (&quot;_New&quot;),
            GnomeAppHelper.CreateMenuConfigurableItem (&quot;_Open&quot;),
            GnomeAppHelper.CreateMenuConfigurableItem (&quot;_Save&quot;),
            GnomeAppHelper.CreateMenuConfigurableItem (&quot;Save _As...&quot;),
            GnomeAppHelper.CreateMenuConfigurableItem (&quot;_Quit&quot;),
            GnomeAppHelper.Endofinfo (),
        };

        Gnome.UIInfo[] edit_menu = {
            // we duplicate the file_menu here, just to test
            GnomeAppHelper.MenuFileTree (file_menu),
            GnomeAppHelper.MenuFileTree (file_menu),
            GnomeAppHelper.Endofinfo (),
        };

        Gnome.UIInfo[] wrapper_menu = {
            GnomeAppHelper.MenuFileTree (file_menu),
            GnomeAppHelper.MenuFileTree (edit_menu),
            GnomeAppHelper.Endofinfo (),
        };

        Gnome.UIInfo main_menu = GnomeAppHelper.MenuMain (wrapper_menu);

        app.CreateMenus (main_menu);

        app.ShowAll ();

        Run ();
    }

    private void dummy_response ()
    {
        Console.WriteLine(&quot;dummy_response&quot;);
    }

    private void Window_Delete (object o, Gtk.DeleteEventArgs args)
    {
        this.Quit ();
    }
}

class GnomeAppHelper
{
    [StructLayout(LayoutKind.Sequential)]
    protected struct DummyUIInfo {

        public Gnome.UIInfoType Type;
        public string Label;
        public string Hint;
        public IntPtr _moreinfo;
        public IntPtr _user_data;
        public IntPtr _unused_data;
        public Gnome.UIPixmapType PixmapType;
        public IntPtr _pixmap_info;
        public uint AcceleratorKey;
        public Gdk.ModifierType AcMods;
        public IntPtr _widget;
    }

    public static Gnome.UIInfo CreateUIInfo ( Gnome.UIInfoType    Type,
                                        string              Label,
                                        string              Hint,
                                        IntPtr              _moreinfo,
                                        IntPtr              _user_data,
                                        IntPtr              _unused_data,
                                        Gnome.UIPixmapType  PixmapType,
                                        IntPtr              _pixmap_info,
                                        uint                AcceleratorKey,
                                        Gdk.ModifierType    AcMods,
                                        IntPtr              _widget)
    {
        DummyUIInfo dummy   = new DummyUIInfo ();
        // let's leak!
        IntPtr ptr = Marshal.AllocHGlobal (Marshal.SizeOf (dummy));

        HandleRef handle = new HandleRef (dummy, ptr);

        dummy.Type              = Type;
        dummy.Label             = Label;
        dummy.Hint              = Hint;
        dummy._moreinfo         = _moreinfo;
        dummy._user_data        = _user_data;
        dummy._unused_data      = _unused_data;
        dummy.PixmapType        = PixmapType;
        dummy._pixmap_info      = _pixmap_info;
        dummy.AcceleratorKey    = AcceleratorKey;
        dummy.AcMods            = AcMods;
        dummy._widget           = _widget;

        Marshal.StructureToPtr (dummy, ptr, false);

        return Gnome.UIInfo.New (handle.Handle);
    }

    public static Gnome.UIInfo CreateMenuConfigurableItem (string label)
    {
        Gnome.UIInfoConfigurableTypes item_type = 0;

        switch (label) {
            case &quot;_New&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.New;
                break;
            case &quot;_Open&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.Open;
                break;
            case &quot;_Save&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.Save;
                break;
            case &quot;Save _As...&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.SaveAs;
                break;
            case &quot;_Revert&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.Revert;
                break;
            case &quot;_Print&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.Print;
                break;
            case &quot;Print Set_up&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.PrintSetup;
                break;
            case &quot;_Close&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.Close;
                break;
            case &quot;E_xit&quot;:
            case &quot;_Quit&quot;:
                item_type = Gnome.UIInfoConfigurableTypes.Quit;
                break;
        }
        return CreateUIInfo (   Gnome.UIInfoType.ItemConfigurable,
                                label,
                                null,
                                IntPtr.Zero, // cb
                                IntPtr.Zero, // data
                                IntPtr.Zero,
                                Gnome.UIPixmapType.None,
                                IntPtr.Zero,
                                (uint) item_type,
                                (Gdk.ModifierType) 0,
                                IntPtr.Zero);
    }

    protected static HandleRef UIInfoArrayToHandleRef (Gnome.UIInfo[] arr)
    {
        int     element_size        = Marshal.SizeOf (typeof (Gnome.UIInfo));
        int     buffer_size         = element_size * arr.Length;
        IntPtr  unmanaged_buffer    = Marshal.AllocHGlobal (buffer_size);

        HandleRef   href    = new HandleRef (arr, unmanaged_buffer);
        int         membase = href.Handle.ToInt32 ();

        // copy managed array of UIInfo structs to contiguous unmanaged mem regions
        foreach (Gnome.UIInfo chunk in arr) {
            Marshal.StructureToPtr (chunk, (IntPtr) membase, false);
            membase += element_size;
        }

        return href;
    }

    public static Gnome.UIInfo MenuMain (Gnome.UIInfo[] arr)
    {
        Gnome.UIInfo[] main_menu = {
            MenuInclude (arr),
            Endofinfo (),
        };

        HandleRef href = UIInfoArrayToHandleRef (main_menu);
        return Gnome.UIInfo.New (href.Handle);
    }

    public static Gnome.UIInfo CreateMenuItem (string label, string hint,
                                                Gnome.UIInfoConfigurableTypes t)
    {
         return CreateUIInfo (  Gnome.UIInfoType.ItemConfigurable,
                                label,
                                hint,
                                IntPtr.Zero, // cb
                                IntPtr.Zero, // data
                                IntPtr.Zero,
                                Gnome.UIPixmapType.None,
                                IntPtr.Zero,
                                (uint) t,
                                (Gdk.ModifierType) 0,
                                IntPtr.Zero);
    }

    public static Gnome.UIInfo Endofinfo ()
    {
         return CreateUIInfo (  Gnome.UIInfoType.Endofinfo,
                                null,
                                null,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                Gnome.UIPixmapType.None,
                                IntPtr.Zero,
                                0,
                                (Gdk.ModifierType) 0,
                                IntPtr.Zero);
    }

    public static Gnome.UIInfo MenuFileTree (Gnome.UIInfo[] tree)
    {
        HandleRef href = UIInfoArrayToHandleRef (tree);
        return CreateUIInfo (  Gnome.UIInfoType.SubtreeStock,
                                &quot;_File&quot;,
                                null,
                                href.Handle,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                Gnome.UIPixmapType.None,
                                IntPtr.Zero,
                                0,
                                (Gdk.ModifierType) 0,
                                IntPtr.Zero);
    }

    public static Gnome.UIInfo MenuSubtree (Gnome.UIInfo[] tree)
    {
        HandleRef href = UIInfoArrayToHandleRef (tree);
        return CreateUIInfo (  Gnome.UIInfoType.Subtree,
                                null,
                                null,
                                href.Handle,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                Gnome.UIPixmapType.None,
                                IntPtr.Zero,
                                0,
                                (Gdk.ModifierType) 0,
                                IntPtr.Zero);
    }

    public static Gnome.UIInfo MenuInclude (Gnome.UIInfo[] tree)
    {
        HandleRef href = UIInfoArrayToHandleRef (tree);
        return CreateUIInfo (  Gnome.UIInfoType.Include,
                                null,
                                null,
                                href.Handle,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                Gnome.UIPixmapType.None,
                                IntPtr.Zero,
                                0,
                                (Gdk.ModifierType) 0,
                                IntPtr.Zero);
    }
}

--------------070105090504070808020704--

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="005105.html">[Gtk-sharp-list] Gtk.Socket -&gt; Port communication
</A></li>
	<LI> Next message: <A HREF="005110.html">[Gtk-sharp-list] Refresh of elements in a treeview
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5106">[ date ]</a>
              <a href="thread.html#5106">[ thread ]</a>
              <a href="subject.html#5106">[ subject ]</a>
              <a href="author.html#5106">[ author ]</a>
         </LI>
       </UL>
</body></html>
