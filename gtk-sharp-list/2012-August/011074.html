<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] Rendering monogame in GTK
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:gtk-sharp-list%40lists.ximian.com?Subject=Re%3A%20%5BGtk-sharp-list%5D%20Rendering%20monogame%20in%20GTK&In-Reply-To=%3C1344935939645-4652000.post%40n4.nabble.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011087.html">
   <LINK REL="Next"  HREF="011071.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] Rendering monogame in GTK</H1>
    <B>jbg77</B> 
    <A HREF="mailto:gtk-sharp-list%40lists.ximian.com?Subject=Re%3A%20%5BGtk-sharp-list%5D%20Rendering%20monogame%20in%20GTK&In-Reply-To=%3C1344935939645-4652000.post%40n4.nabble.com%3E"
       TITLE="[Gtk-sharp-list] Rendering monogame in GTK">jbgaume at gmail.com
       </A><BR>
    <I>Tue Aug 14 09:18:59 UTC 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="011087.html">[Gtk-sharp-list] How I make a message dialog?
</A></li>
        <LI>Next message: <A HREF="011071.html">[Gtk-sharp-list] Window inside a container
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11074">[ date ]</a>
              <a href="thread.html#11074">[ thread ]</a>
              <a href="subject.html#11074">[ subject ]</a>
              <a href="author.html#11074">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I make a game engine and I would like to make a map editor. I found a very
good code. But I do not know how to display a WriteableBitmap or other in an
image or Gdk.Pixbuf.

I tried it :
Gdk.Pixbuf pixBuf = new Gdk.Pixbuf(game.m_bytes);

But I get this error :
GLib.GException: Image has zero width ---&gt; System.Exception: 
  --- End of inner exception stack trace ---
  &#224; Gdk.PixbufLoader.Write(Byte[] buf, UInt64 count)
  &#224; Gdk.PixbufLoader.Write(Byte[] bytes, UInt32 count)
  &#224; Gdk.PixbufLoader.InitFromBuffer(Byte[] buffer)
  &#224; Gdk.PixbufLoader..ctor(Byte[] buffer)
  &#224; Gdk.Pixbuf..ctor(Byte[] buffer)

Game code:
using System;
using System.Runtime.InteropServices;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameInGtk
{
    public class Game1 : Microsoft.Xna.Framework.Game
    {
        // Objet qui sera transmis au WPF
        public WriteableBitmap WriteableBitmap { get; set; }

        // A de multiple endroit nous avons besoin de savoir la taille de
l'affichage XNA
        private Point m_sizeViewport;
        // Objet qui contiendra notre sc&#232;ne apr&#232;s le rendu
        private RenderTarget2D m_renderTarget2D;
        // Servira pour faire la conversion du RenderTarget vers le
WritableBitmap
        public byte[] m_bytes;
        // Les fonctionnements interne de XNA &#233;tant bypass&#233;s, il faut un
timer
        private DispatcherTimer m_dispatcherTimer;

        private GraphicsDeviceManager m_graphics;
        private SpriteBatch m_spriteBatch;

        public Game1()
        {
            m_graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = &quot;Content&quot;;

            // On prepare la resolution du rendu, l'image de sorti, l'image
en entr&#233;, les bytes pour la conversion
            m_sizeViewport = new Point(200, 200);
            WriteableBitmap = new WriteableBitmap(m_sizeViewport.X,
m_sizeViewport.Y, 96, 96, PixelFormats.Bgra32, null);
            m_bytes = new byte[m_sizeViewport.X * m_sizeViewport.Y * 4];

            // On prepare le timer pour tourner 60 fois par seconde
            m_dispatcherTimer = new DispatcherTimer();
            m_dispatcherTimer.Interval = TimeSpan.FromSeconds(1 / 60);
            m_dispatcherTimer.Tick += new EventHandler(GameLoop);

            this.Initialize();
            this.LoadContent();
            m_dispatcherTimer.Start();
        }

        protected override void Initialize()
        {
            // Les fonctionnements interne de XNA &#233;tant bypass&#233;s , il faut
forcer la cr&#233;ation du GraphicsDevice
            IGraphicsDeviceManager graphicsDeviceManager =
this.Services.GetService(typeof(IGraphicsDeviceManager)) as
IGraphicsDeviceManager;
            if (graphicsDeviceManager != null)
graphicsDeviceManager.CreateDevice();
            else throw new Exception(&quot;Unable to retrieve
GraphicsDeviceManager&quot;);

            // Le renderTarget2D ne peut &#234;tre cr&#233;&#233; qu'apr&#232;s la cr&#233;ation du
GraphicsDevice, puisqu'il l'utilise.
            m_renderTarget2D = new RenderTarget2D(GraphicsDevice,
m_sizeViewport.X, m_sizeViewport.Y);
            IsMouseVisible = true;
            base.Initialize();
        }

        protected override void LoadContent()
        {
            m_spriteBatch = new SpriteBatch(GraphicsDevice);


            base.LoadContent();
        }

        protected override void Draw(GameTime gameTime)
        {
            // Au lieu de rendre dans une fen&#234;tre classique, XNA nous permet
de rendre la scene dans un RenderTarget2D. On le set donc.
            GraphicsDevice.SetRenderTarget(m_renderTarget2D);
           
GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.CornflowerBlue);

            m_spriteBatch.Begin();

            m_spriteBatch.End();
            base.Draw(gameTime);

            // Ne pas oublier ! Sinon une exception sera lev&#233;e
            GraphicsDevice.SetRenderTarget(null);

            // On r&#233;cup&#232;re les informations de l'image source
            m_renderTarget2D.GetData(m_bytes);

            // Parce que le seul format de pixel 32 bit pour WPF est BGRA et
que XNA est en RGBA, il faut intervertir la composante R et B pour tout les
pixels
            for (int i = 0; i &lt; m_bytes.Length - 2; i += 4)
            {
                byte r = m_bytes[i];
                m_bytes[i] = m_bytes[i + 2];
                m_bytes[i + 2] = r;
            }

            // On &#233;crit dans le WriteableBitmap les pixels r&#233;sultant de la
conversion
            WriteableBitmap.Lock();
            Marshal.Copy(m_bytes, 0, WriteableBitmap.BackBuffer,
m_bytes.Length);
            WriteableBitmap.AddDirtyRect(new System.Windows.Int32Rect(0, 0,
m_sizeViewport.X, m_sizeViewport.Y));
            WriteableBitmap.Unlock();
        }

        private void GameLoop(object sender, EventArgs e)
        {
            GameTime gameTime = new GameTime();

            this.Update(gameTime);
            this.Draw(gameTime);
        }
    }
}




--
View this message in context: <A HREF="http://mono.1490590.n4.nabble.com/Rendering-monogame-in-GTK-tp4652000.html">http://mono.1490590.n4.nabble.com/Rendering-monogame-in-GTK-tp4652000.html</A>
Sent from the Mono - Gtk# mailing list archive at Nabble.com.
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011087.html">[Gtk-sharp-list] How I make a message dialog?
</A></li>
	<LI>Next message: <A HREF="011071.html">[Gtk-sharp-list] Window inside a container
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11074">[ date ]</a>
              <a href="thread.html#11074">[ thread ]</a>
              <a href="subject.html#11074">[ subject ]</a>
              <a href="author.html#11074">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">More information about the Gtk-sharp-list
mailing list</a><br>
</body></html>
