<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] ThreadNotify
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:vladimir%40pobox.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000433.html">
   <LINK REL="Next"  HREF="000437.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] ThreadNotify
   </H1>
    <B>Vladimir Vukicevic
    </B> 
    <A HREF="mailto:vladimir%40pobox.com"
       TITLE="[Gtk-sharp-list] ThreadNotify">vladimir@pobox.com
       </A><BR>
    <I>10 Oct 2002 13:24:41 -0700</I>
    <P><UL>
        <LI> Previous message: <A HREF="000433.html">[Gtk-sharp-list] ThreadNotify
</A></li>
        <LI> Next message: <A HREF="000437.html">[Gtk-sharp-list] ThreadNotify
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#434">[ date ]</a>
              <a href="thread.html#434">[ thread ]</a>
              <a href="subject.html#434">[ subject ]</a>
              <a href="author.html#434">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 2002-10-10 at 11:40, Miguel de Icaza wrote:
&gt;<i> &gt; One way to fix this is to make sure that when you're passing data to use
</I>&gt;<i> &gt; a Queue or some other form of data structure which will ensure you get
</I>&gt;<i> &gt; each bit of data only once.  This however makes it impossible to run the
</I>&gt;<i> &gt; gtk thread and the &quot;worker&quot; thread in lock-step (and it might be
</I>&gt;<i> &gt; prohibitively expensive to make a copy of the data, etc., etc).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; So, would setting the buffer size on the pipe to 1 fix this?  Or do we
</I>&gt;<i> &gt; e
</I>&gt;<i> 
</I>&gt;<i> The issue really is that we should not be queuing more data if there is
</I>&gt;<i> already data queued in.  The reason is that it is a redundant task, and
</I>&gt;<i> also because if you queue enough information (the system buffer size),
</I>&gt;<i> you will block the calling application.
</I>&gt;<i> 
</I>&gt;<i> So what we need is a shared variable that says whether we should queue
</I>&gt;<i> or not more data.  The side effect is that it will address the problem
</I>&gt;<i> you see right now.
</I>
Hmm, will it?  If we start with the assumption that you should be using
a Queue to pass data back and forth between threads, then we're either
going to have to assume that one call of the notify handler is
equivalent to one call of NotifyMain(), in which case the GIO handler
will/should consume all available data from the pipe instead of just one
byte per invocation; or we're going to have to assume that you may have
a backlog of data for each call of the handler, and it's up to you in
your application to read as much from your private Queue as you want.

Perhaps these two could be combined in a ThreadNotifyQueue class, which
will give you one callback per notify semantics, with a piece of user
data from a queue, so that you don't have to worry about how the details
are implemented (i.e. it could just emit the event as many times as
there are items in the queue, up to some number, etc.)?

	- Vlad

-- 
Vladimir Vukicevic &lt;<A HREF="mailto:vladimir@pobox.com">vladimir@pobox.com</A>&gt;


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000433.html">[Gtk-sharp-list] ThreadNotify
</A></li>
	<LI> Next message: <A HREF="000437.html">[Gtk-sharp-list] ThreadNotify
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#434">[ date ]</a>
              <a href="thread.html#434">[ thread ]</a>
              <a href="subject.html#434">[ subject ]</a>
              <a href="author.html#434">[ author ]</a>
         </LI>
       </UL>
</body></html>
