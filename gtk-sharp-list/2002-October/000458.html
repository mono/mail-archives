<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] refcounting, GC, and glade.. (patch, need
 review)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mkestner%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000456.html">
   <LINK REL="Next"  HREF="000460.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] refcounting, GC, and glade.. (patch, need
 review)
   </H1>
    <B>Mike Kestner
    </B> 
    <A HREF="mailto:mkestner%40ximian.com"
       TITLE="[Gtk-sharp-list] refcounting, GC, and glade.. (patch, need
 review)">mkestner@ximian.com
       </A><BR>
    <I>14 Oct 2002 11:01:41 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="000456.html">[Gtk-sharp-list] refcounting, GC, and glade.. (patch, need
 review)
</A></li>
        <LI> Next message: <A HREF="000460.html">[Gtk-sharp-list] refcounting, GC, and glade.. (patch, need
 review)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#458">[ date ]</a>
              <a href="thread.html#458">[ thread ]</a>
              <a href="subject.html#458">[ subject ]</a>
              <a href="author.html#458">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sun, 2002-10-13 at 18:04, Vladimir Vukicevic wrote:

&gt;<i> - We need to either:
</I>&gt;<i>   - Ref every object we get back, and create a separate C# wrapper every
</I>&gt;<i> time, even if the underlying Handle will be the same.  This seems the
</I>&gt;<i> easiest and least error-prone thing to do.
</I>
This will only ensure that the vast majority of GObject refs get leaked,
because we own most of the refs that are returned by methods. What we
need is a deterministic way to identify owned and unowned refs from the
gtk API, which doesn't currently exist.  

&gt;<i>   - Ref only the first time we see a particular object pointer, and
</I>&gt;<i> store the C# object - return the same c# object for the same glib
</I>&gt;<i> object.  This would be doable, but tricky to get right -- by storing
</I>&gt;<i> those objects in the hashtable, they'll never get c# finalized, hence
</I>&gt;<i> never gobject unref'd.
</I>
No, it's not tricky to get right, and it's what we already do.  In the
Raw property set code, we insert a hashtable entry to track existing
wrappers.  In GetObject, we return the wrapper object for a given handle
if it's in the hash, otherwise we wrap it, which eventually calls the
GLib.Object(IntPtr) ctor, which sets Raw, which inserts it in the hash,
yadayada.

The cause of all these problems seems to be that we are getting object
refs from &quot;some&quot; gtk methods which we don't own.  We can't blindly ref
these, because we do own most of the refs, and to ref them again will
just cause them to be leaked.

There is already a bug report to rework the static object hash to store
WeakRefs so that the hashtable won't cause C# objects to be ignored by
the GC.

&gt;<i> - For Gtk.Object derivatives:
</I>&gt;<i>   - We need to ref and sink the objects in the constructors.  Right now
</I>&gt;<i> he floating object behaviour is fairly broken;
</I>
How?  We already do handle the sunken object case using glue and an
overridden dispose handler.

&gt;<i> The only solution to the sinking problem that I can think of is to
</I>&gt;<i> modify the generator so that it does the right thing in every object's
</I>&gt;<i> constructors that are a derivative of Gtk.Object -- namely,
</I>&gt;<i>    Raw = gtk_foo_new (...)
</I>&gt;<i>    Ref ();
</I>&gt;<i>    Sink ();
</I>
This is easily accomplished via the Gtk.Object(IntPtr) ctor, if needed.
However, I think the existing Dispose solution is fine. Perhaps the glue
function should sink instead of unref, though, to avoid the harmless,
but ugly, warning.

&gt;<i> instead of just assigning to Raw as they do now.  All objects that are
</I>&gt;<i> returned by get_* or whatever functions should come unreffed -- in this
</I>&gt;<i> case we need to Ref() and create a C# wrapper.
</I>
Woah.  Who says that we don't own every ref returned by a get method? If
that's true, then maybe that helps, but I doubt that is true.  The real
issue is that the Gtk api is inconsistent in its ref ownership semantics
and we need to overcome this with a solution that identifies unowned
references so that we can ref only those.  

&gt;<i> I think this should get us most of the way towards correct object
</I>&gt;<i> management; I'm going to try implementing this tonight and see where I
</I>&gt;<i> end up.
</I>
Based on what I've read so far in this mail, I think the only likely
result will be the leaking of refs, which we can accomplish by removing
the Dispose functionality until we can solve the ref ownership
identification issue.

-- 
Mike Kestner &lt;<A HREF="mailto:mkestner@ximian.com">mkestner@ximian.com</A>&gt;



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000456.html">[Gtk-sharp-list] refcounting, GC, and glade.. (patch, need
 review)
</A></li>
	<LI> Next message: <A HREF="000460.html">[Gtk-sharp-list] refcounting, GC, and glade.. (patch, need
 review)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#458">[ date ]</a>
              <a href="thread.html#458">[ thread ]</a>
              <a href="subject.html#458">[ subject ]</a>
              <a href="author.html#458">[ author ]</a>
         </LI>
       </UL>
</body></html>
