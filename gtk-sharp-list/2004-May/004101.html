<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] patch: managed TreeModel impl
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:vladimir%40pobox.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="004100.html">
   <LINK REL="Next"  HREF="004119.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] patch: managed TreeModel impl
   </H1>
    <B>Vladimir Vukicevic
    </B> 
    <A HREF="mailto:vladimir%40pobox.com"
       TITLE="[Gtk-sharp-list] patch: managed TreeModel impl">vladimir@pobox.com
       </A><BR>
    <I>Tue, 25 May 2004 14:19:55 -0700</I>
    <P><UL>
        <LI> Previous message: <A HREF="004100.html">[Gtk-sharp-list] patch: managed TreeModel impl
</A></li>
        <LI> Next message: <A HREF="004119.html">[Gtk-sharp-list] patch: managed TreeModel impl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4101">[ date ]</a>
              <a href="thread.html#4101">[ thread ]</a>
              <a href="subject.html#4101">[ subject ]</a>
              <a href="author.html#4101">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Mike Kestner wrote:
&gt;<i> On Mon, 2004-05-24 at 17:47, Vladimir Vukicevic wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>Updated patch attached; fixed a lot of the out/ref business based on 
</I>&gt;&gt;<i>feedback from Mike.  We use TreeIter.Zero to indcate invalid (i.e. NULL) 
</I>&gt;&gt;<i>passed-in TreeIters.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure how excited I am about having this in Gtk#.  I think the
</I>&gt;<i> NodeStore approach is much more C# like, and this exposes way too much
</I>&gt;<i> of the underlying nativisms of tree models.
</I>&gt;<i>
</I>&gt;<i> What exactly about NodeStore made it inappropriate for your work on the
</I>&gt;<i> DataBindings project, if you considered using it?  I'd rather finish
</I>&gt;<i> cooking that approach than put such a thin wrapper like this into Gtk#
</I>&gt;<i> if we can accomplish your goals that way.
</I>
Both the ADO.NET DataTable/DataTableView stuff and the TreeModel are 
fairly low level; having to implement an ITreeNode interface on top of 
DataRow, and then having to create one of those instances for each row 
in the data table seems rife with problems.  With NodeStore, I can't 
dynamically generate the data based on what the TreeView requests -- I 
have to generate everything beforehand and pass it to NodeStore.  With a 
lower level TreeModel interface, I only need to query the (potentially 
huge) data table only for data rows that the TreeView actually needs.

I understand that Tree Models are pretty heavy internals bits; however, 
I think that having this type of interface exported would be a good 
thing, for people that want to use it.

&gt;&gt;<i>Index: glib/Object.cs
</I>&gt;&gt;<i>===================================================================
</I>&gt;&gt;<i>RCS file: /cvs/public/gtk-sharp/glib/Object.cs,v
</I>&gt;&gt;<i>retrieving revision 1.64
</I>&gt;&gt;<i>diff -u -u -r1.64 Object.cs
</I>&gt;&gt;<i>--- glib/Object.cs	18 May 2004 05:06:10 -0000	1.64
</I>&gt;&gt;<i>+++ glib/Object.cs	24 May 2004 21:58:39 -0000
</I>&gt;&gt;<i>@@ -149,7 +149,7 @@
</I>&gt;&gt;<i> 			if (g_types.Contains (t))
</I>&gt;&gt;<i> 				return (GType) g_types [t];
</I>&gt;&gt;<i> 			
</I>&gt;&gt;<i>-			PropertyInfo pi = t.GetProperty (&quot;GType&quot;, BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public);
</I>&gt;&gt;<i>+			PropertyInfo pi = t.GetProperty (&quot;GType&quot;, BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
</I>&gt;&gt;<i> 			if (pi != null)
</I>&gt;&gt;<i> 				return (GType) pi.GetValue (null, null);
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I'd rather fix this properly by making the generator produce protected
</I>&gt;<i> GType properties so we can drop the Public flag instead of just querying
</I>&gt;<i> all protection levels.
</I>
Sounds good.

&gt;&gt;<i>Index: gtk/TreeIter.custom
</I>&gt;&gt;<i>===================================================================
</I>&gt;&gt;<i>RCS file: /cvs/public/gtk-sharp/gtk/TreeIter.custom,v
</I>&gt;&gt;<i>retrieving revision 1.3
</I>&gt;&gt;<i>diff -u -u -r1.3 TreeIter.custom
</I>&gt;&gt;<i>--- gtk/TreeIter.custom	12 Feb 2004 21:28:42 -0000	1.3
</I>&gt;&gt;<i>+++ gtk/TreeIter.custom	24 May 2004 21:58:39 -0000
</I>&gt;&gt;<i>@@ -19,3 +19,18 @@
</I>&gt;&gt;<i>                                 ti._user_data2 == _user_data2 &amp;&amp;
</I>&gt;&gt;<i>                                 ti._user_data3 == _user_data3;
</I>&gt;&gt;<i>                 }
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i>+                public IntPtr UserData1 {
</I>&gt;&gt;<i>+                        get { return _user_data; }
</I>&gt;&gt;<i>+                        set { _user_data = value; }
</I>&gt;&gt;<i>+                }
</I>&gt;&gt;<i>+                
</I>&gt;&gt;<i>+                public IntPtr UserData2 {
</I>&gt;&gt;<i>+                        get { return _user_data2; }
</I>&gt;&gt;<i>+                        set { _user_data2 = value; }
</I>&gt;&gt;<i>+                }
</I>&gt;&gt;<i>+                
</I>&gt;&gt;<i>+                public IntPtr UserData3 {
</I>&gt;&gt;<i>+                        get { return _user_data3; }
</I>&gt;&gt;<i>+                        set { _user_data3 = value; }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Ugh, ugh, ugh. ;-)  Stuff like this just makes me feel more strongly
</I>&gt;<i> that such a thin wrapper is the wrong way to go.
</I>
Yeah, I'm not really happy with this; I was thinking of another 
approach, where the iterator would essentially be &quot;object&quot;, and the 
ManagedTreeModel would map it to/from TreeIter for you.  I need to 
understand the RefNode/UnrefNode bits better first.  (I'd keep a local 
hash of Ref'd iterators, just need to know when to remove bits from the 
hash.)

&gt;&gt;<i>Index: gtk/TreeModel.custom
</I>&gt;&gt;<i>===================================================================
</I>&gt;&gt;<i>RCS file: /cvs/public/gtk-sharp/gtk/TreeModel.custom,v
</I>&gt;&gt;<i>retrieving revision 1.2
</I>&gt;&gt;<i>diff -u -u -r1.2 TreeModel.custom
</I>&gt;&gt;<i>--- gtk/TreeModel.custom	1 Nov 2003 12:00:26 -0000	1.2
</I>&gt;&gt;<i>+++ gtk/TreeModel.custom	24 May 2004 21:58:39 -0000
</I>&gt;&gt;<i>@@ -18,6 +18,7 @@
</I>&gt;&gt;<i> 	/// &lt;remarks&gt;To be completed&lt;/remarks&gt;
</I>&gt;&gt;<i> 	bool IterNthChild (out Gtk.TreeIter iter, int n);
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>+#if false
</I>&gt;&gt;<i>         void SetValue (Gtk.TreeIter iter, int column, bool value);
</I>&gt;&gt;<i>         void SetValue (Gtk.TreeIter iter, int column, double value);
</I>&gt;&gt;<i> 	void SetValue (Gtk.TreeIter iter, int column, int value);
</I>&gt;&gt;<i>@@ -25,4 +26,5 @@
</I>&gt;&gt;<i> 	void SetValue (Gtk.TreeIter iter, int column, float value);
</I>&gt;&gt;<i> 	void SetValue (Gtk.TreeIter iter, int column, uint value);
</I>&gt;&gt;<i> 	void SetValue (Gtk.TreeIter iter, int column, object value);
</I>&gt;&gt;<i>+#endif
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> If these aren't needed, then they should be deleted, not #if'd.
</I>
I agree. :)

&gt;&gt;<i>     public abstract object GetValue(Gtk.TreeIter iter, int column);
</I>&gt;&gt;<i>+    public virtual void GetValue (Gtk.TreeIter iter, int column, ref GLib.Value value) {
</I>&gt;&gt;<i>+      object o = GetValue (iter, column);
</I>&gt;&gt;<i>+      if (o == null) {
</I>&gt;&gt;<i>+	value.Init (GLib.GType.Invalid);
</I>&gt;&gt;<i>+	return;
</I>&gt;&gt;<i>+      }
</I>&gt;&gt;<i>+      GLib.GType ctype = GLibSharp.TypeConverter.LookupType (o.GetType());
</I>&gt;&gt;<i>+      value.Init (ctype);
</I>&gt;&gt;<i>+      value.Val = o;
</I>&gt;&gt;<i>+    }
</I>&gt;<i> 
</I>&gt;<i> After such a thin wrapper elsewhere, why add a bunch of code here that's
</I>&gt;<i> going to be duplicated in subclasses anyway.  I should internalize
</I>&gt;<i> GLibSharp.TypeConverter, now that you mention it.  ;-)
</I>
Well, the idea being that you can override either the GetValue that 
returns an object, or a GetValue that uses the GLib.Value (I have a 
change locally that changes the object-returning abstract GetValue to 
virtual returning null).

&gt;&gt;<i>+   
</I>&gt;&gt;<i>+    /* This is a copy of the TreeModel interface struct */
</I>&gt;&gt;<i>+    internal struct TreeModelInterface {
</I>&gt;<i> 
</I>&gt;<i> You need to use the [StructLayout (LayoutKind.Sequential)] attr on all
</I>&gt;<i> these, or you will get unpredictable layout.
</I>
LayoutKind.Sequential should be the default layout kind for structs, at 
least according to the MS docs -- but yeah, it should be added on there.

&gt;&gt;<i>+    // internal static void tree_model_iface_init (ref TreeModelInterface iface, IntPtr data) {
</I>&gt;&gt;<i>+    internal static void tree_model_iface_init (IntPtr ifaceptr, IntPtr data) {
</I>&gt;&gt;<i>+      TreeModelInterface iface = (TreeModelInterface) Marshal.PtrToStructure (ifaceptr, typeof(TreeModelInterface));
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i>+      iface.get_flags = new TreeModelGetFlagsDelegate (TreeModelGetFlagsImpl);
</I>&gt;&gt;<i>+      iface.get_n_columns = new TreeModelGetNColumnsDelegate (TreeModelGetNColumnsImpl);
</I>&gt;&gt;<i>+      iface.get_column_type = new TreeModelGetColumnTypeDelegate (TreeModelGetColumnTypeImpl);
</I>&gt;&gt;<i>+      iface.get_iter = new TreeModelGetIterDelegate (TreeModelGetIterImpl);
</I>&gt;&gt;<i>+      iface.get_path = new TreeModelGetPathDelegate (TreeModelGetPathImpl);
</I>&gt;&gt;<i>+      iface.get_value = new TreeModelGetValueDelegate (TreeModelGetValueImpl);
</I>&gt;&gt;<i>+      iface.iter_next = new TreeModelIterNextDelegate (TreeModelIterNextImpl);
</I>&gt;&gt;<i>+      iface.iter_children = new TreeModelIterChildrenDelegate (TreeModelIterChildrenImpl);
</I>&gt;&gt;<i>+      iface.iter_has_child = new TreeModelIterHasChildDelegate (TreeModelIterHasChildImpl);
</I>&gt;&gt;<i>+      iface.iter_n_children = new TreeModelIterNChildrenDelegate (TreeModelIterNChildrenImpl);
</I>&gt;&gt;<i>+      iface.iter_nth_child = new TreeModelIterNthChildDelegate (TreeModelIterNthChildImpl);
</I>&gt;&gt;<i>+      iface.iter_parent = new TreeModelIterParentDelegate (TreeModelIterParentImpl);
</I>&gt;&gt;<i>+      iface.ref_node = new TreeModelRefNodeDelegate (TreeModelRefNodeImpl);
</I>&gt;&gt;<i>+      iface.unref_node = new TreeModelUnrefNodeDelegate (TreeModelUnrefNodeImpl);
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i>+      Marshal.StructureToPtr (iface, ifaceptr, false);
</I>&gt;&gt;<i>+    }
</I>&gt;<i> 
</I>&gt;<i> Your delegates are all going to disappear as soon as the GC runs, and
</I>&gt;<i> then all those fptrs written to ifaceptr are going to be invalid. 
</I>&gt;<i> Boom.  
</I>&gt;<i> 
</I>&gt;<i> The problem is complex.  I don't think you can even just hold onto the
</I>&gt;<i> iface struct in a static variable either, because the class will get
</I>&gt;<i> GC'd as soon as the last instance &quot;wrapper&quot; is GC'd.  Any time the
</I>&gt;<i> native side is more persistent than the managed side, there has to be
</I>&gt;<i> some mechanism to hang onto the delegates that will persist as long as
</I>&gt;<i> the native side is around.  
</I>&gt;<i> 
</I>&gt;<i> This is basically why I haven't already implemented GInterfaces (or more
</I>&gt;<i> generally, structs-full-of-fptrs) already.  The static field hack will
</I>&gt;<i> work as long as the user hangs on to a ref of the ManagedTreeModel
</I>&gt;<i> subclass, but if they don't, and you know someone won't, ...
</I>
For some reason, I convinced myself that this would work -- however, to 
be fully correct, you're right; I need to keep a local reference to the 
struct, and also create a static GCHandle to it that I allocate in the 
_init and deallocate when the interface is destroyed.  Doing that should 
cause zero problems, I think.

I'll go ahead and make the changes you suggested; I still think that 
this would be a useful addition to Gtk#, as the TreeView is a pretty 
powerful widget and it would be unfortunate to not be able to fully take 
advantage of it from within C#.

Thanks,
	- Vlad


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="004100.html">[Gtk-sharp-list] patch: managed TreeModel impl
</A></li>
	<LI> Next message: <A HREF="004119.html">[Gtk-sharp-list] patch: managed TreeModel impl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4101">[ date ]</a>
              <a href="thread.html#4101">[ thread ]</a>
              <a href="subject.html#4101">[ subject ]</a>
              <a href="author.html#4101">[ author ]</a>
         </LI>
       </UL>
</body></html>
