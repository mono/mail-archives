<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] [PROPOSAL] Eliminating Application.Init ()
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="002449.html">
   <LINK REL="Next"  HREF="002432.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] [PROPOSAL] Eliminating Application.Init ()
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Gtk-sharp-list] [PROPOSAL] Eliminating Application.Init ()">jonpryor@vt.edu
       </A><BR>
    <I>Sun, 14 Sep 2003 20:53:53 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="002449.html">[Gtk-sharp-list] [PROPOSAL] Eliminating Application.Init ()
</A></li>
        <LI> Next message: <A HREF="002432.html">[Gtk-sharp-list] New Gtk# user question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2454">[ date ]</a>
              <a href="thread.html#2454">[ thread ]</a>
              <a href="subject.html#2454">[ subject ]</a>
              <a href="author.html#2454">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'm failing to see, immediately, how the Singleton pattern would work. 
Singleton just permits access to a single, well-known, instance of a
particular type.

Fortunately, after talking with a friend about this issue, I'm willing
to stand corrected. :-)

Implicit initialization is nice, when you can ensure that it won't screw
things up.  I was previously convinced that the ordering issues would be
difficult to solve.

To the contrary, it's fairly easy: have libraries invoke the
initialization code of libraries they're dependent upon.  Thus, if
Library2 is created before Library1, it's OK, since the Library2
initialization code would implicitly invoke Library1's code.  For
example:

	class Lib1.Foo {
		static Foo () { /* code ... */ }
		public static bool initialized;
	}

	// Lib2.Bar is dependent on Lib1.Foo
	class Lib2.Bar {
		static Bar () {
			// implicitly calls Lib1.Foo::.cctor, which
			// initializes Lib1.
			bool ignored = Lib1.Foo.initialized;

			/* other initialization code... */
		}

		// so other libraries can do the same thing
		public static bool initialized;
	}

Static variables don't need to be used; static functions/properties
could be used instead.  The key point is that the libraries know what
their dependencies are, so when a user creates a type anywhere in
dependency list, all dependencies will be initialized *in order*.

Wish I'd thought of this before.  It's rather useful.

There is a downside with this in Gtk#, though.  AppDomains.

Static class constructors are invoked once per AppDomain (assuming that
any instance of the type is created).  This means that GTK+
initialization code would be invoked 1 x (# AppDomains using Gtk#).  If
this is &gt; 1, you might abort the process as some of the GLib
initialization code can only be called *once* per process.  (IIRC, this
was related to threading, is very annoying to work around, and is in
bugzilla against the offending library.  I don't think this has been
fixed yet, though.)

 - Jon

On Sat, 2003-09-13 at 23:15, Michael Poole wrote:
&gt;<i> Jonathan Pryor &lt;<A HREF="mailto:jonpryor@vt.edu">jonpryor@vt.edu</A>&gt; writes:
</I>&gt;<i> 
</I>&gt;<i> &gt; So, you want to rely on the Library to handle initialization order?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sorry for being bold and/or mean, but are you insane?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The problem is that static constructors guarantee NO ORDER.  The only
</I>&gt;<i> &gt; thing you can assume is that the static constructor will be invoked
</I>&gt;<i> &gt; before any static members are accessed, or any types are created.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; You can't say &quot;this .cctor should execute before this other .cctor
</I>&gt;<i> &gt; (which could be located in a completely different assembly!).&quot;
</I>&gt;<i> 
</I>&gt;<i> You cannot specify cross-assembly ordering of .cctors, but you can
</I>&gt;<i> adapt the Singleton pattern to ensure correct ordering.  Implementing
</I>&gt;<i> that as a CLI Attribute-type class is left as an exercise for the
</I>&gt;<i> reader.  It does add a line or two of code to the library's
</I>&gt;<i> implementation, but it saves that much code from every application.
</I>&gt;<i> 
</I>&gt;<i> The significant difference between this and the apartment models is
</I>&gt;<i> that the Init()-type functions take no arguments, but more than one
</I>&gt;<i> threading model is possible.  As you pointed out later in your email,
</I>&gt;<i> automatic initialization is appropriate only for cases where the
</I>&gt;<i> argument list is trivial.
</I>&gt;<i> 
</I>&gt;<i> Michael
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Gtk-sharp-list maillist  -  <A HREF="mailto:Gtk-sharp-list@lists.ximian.com">Gtk-sharp-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">http://lists.ximian.com/mailman/listinfo/gtk-sharp-list</A>
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="002449.html">[Gtk-sharp-list] [PROPOSAL] Eliminating Application.Init ()
</A></li>
	<LI> Next message: <A HREF="002432.html">[Gtk-sharp-list] New Gtk# user question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2454">[ date ]</a>
              <a href="thread.html#2454">[ thread ]</a>
              <a href="subject.html#2454">[ subject ]</a>
              <a href="author.html#2454">[ author ]</a>
         </LI>
       </UL>
</body></html>
