<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] Some questions about clipboards and gtk-sharp
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:spamfrommailing%40freax.org">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="002021.html">
   <LINK REL="Next"  HREF="002020.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] Some questions about clipboards and gtk-sharp
   </H1>
    <B>Philip Van Hoof
    </B> 
    <A HREF="mailto:spamfrommailing%40freax.org"
       TITLE="[Gtk-sharp-list] Some questions about clipboards and gtk-sharp">spamfrommailing@freax.org
       </A><BR>
    <I>08 Jun 2003 14:00:54 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="002021.html">[Gtk-sharp-list] generator/SymbolTable.cs: Added ulong
</A></li>
        <LI> Next message: <A HREF="002020.html">[Gtk-sharp-list] Re: [Mono-list] Some questions about clipboards and gtk-sharp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2018">[ date ]</a>
              <a href="thread.html#2018">[ thread ]</a>
              <a href="subject.html#2018">[ subject ]</a>
              <a href="author.html#2018">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi there,

I want to implement a method that will collect all targets of the
current clipboard .. so far I have this (see below). I have ported it
from plain C to C# and I know that in C it &quot;does&quot; work perfectly.

The issues that I have are ..

* targets = clipboard.WaitForContents (Atom.Intern (&quot;TARGETS&quot;, false))
does not work at all.

clipboard is instantiated with Clipboard.Get(Atom.Clipboard(&quot;CLIPBOARD&quot;,
false)).

This method of clipboard will always return targets.length = -1.
Nomatter which selection I choose (PRIMARY, CLIPBOARD or SECONDARY) and
nomatter how much data is currently to be converted to the requested
target by the clipboardowner. I've tried &quot;COMPOUND_TEXT&quot;, &quot;TARGETS&quot;,
&quot;TEXT&quot;, &quot;text/html&quot;, ... as the target Atom of WaitForContents().
Short: It just does not work &quot;at all&quot;.  Nothing worked not one try ..

* I cannot know the size of a Gdk.Atom and I assume that the
targets.Data that I will receive (in case WaitForContents would work)
will not contain an array of Gdk.Atom's but in stead an array of xlib
Atom's right? I got this working in C by casting the received data to a
pointer of GdkAtom's and then I looped for i to the length of the
GtkSelectionData. I cannot do this cast in C# (it looks like it's just
impossible: getting errors about unmanaged types; invalid casts;
blabla).

In C#'s case I don't know if targets.length is the size of targets.Data
or if it's the value which X passed ? (So is this converted to the
amount of Bytes that have been received or does the C# API just copied
the value from the Gtk+ API to the SelectionData.length ?). 

And .. How do I know what the size of a Atom is :)? In C I could do
sizeof(GdkAtom) but in C# sizeof(Gdk.Atom) gives me a compiler error
explaining me that I cannot request the size of an unmanaged type. So I
made a small C application to get the size and I am now using that value
(4 bytes). I wonder if stuff like this could get in or already is
available in the gtk-sharp-glue library?

if a SelectionData.length is -1 and you want the property 
SelectionData.Data then it will throw a very wierd exception which won't
explain the programmer what the heck is wrong. I had to dig gtk-sharp
sources to get a very vague idea of what &quot;could&quot; be wrong.



So what I had to do ... to get this managed and working in C#, I guess
is ...

I have to receive the four bytes; I put those in an array of four bytes
and then I cast that array using 

raw = GtkSharp.ManagedValue.WrapObject(my_four_bytes);

and then of course I want to get the contents for that atom :

Gtk.SelectionData data = 
   this.clipboard.WaitForContents (new Atom (raw));


Ick.. I am really really not sure how much of all this will actually
work :)


So the question is .. ehm.. well.. wtf? :) I don't know how people are
going to use Gtk-Sharp if issues like this cannot and will never
work...so I hope for a clean solution (in the Gtk-Sharp API) or .. how
should I actually get this working using the current API ?


Please do not start thinking that I now hate Gtk-Sharp .. it's just that
the GtkClipboard, GtkSelection and GtkAtom wrappings really REALLY
dissapoint me a lot...I will not belive you if you tell me that one will
find it more easy to implement a Clipboard in his or hers application
using Gtk-Sharp compared to C.


Do trust me when I say that MOST applications don't want to just put
some COMPOUND_TEXT on the clipboard .. most want to put very much
targets and want to get pretty complicated when it comes down to the
clipboard -see OpenOffice.org, Evolution, GNummeric, Mozilla, Mozilla
Composer-. We/You guys are building Gtk-Sharp because large applications
in C (or C++) are difficult to maintain. so ... it should be possible to
play a lot with that clipboard, right?


So until this GtkClipboard wrapping works .. I don't belive that any
major desktop application will get working if it uses gtk-sharp.

Of course I am interested in helping with fixing the gtk-sharp
wrappings.. So is, at this moment, somebody maintaining gtk-sharp?


So.. this is what I've been trying :

public override void CollectCurrent ()
{
  // Gtk-Sharp TODO : This does not work !
  SelectionData targets = clipboard.WaitForContents
	(ClipboardManager.TARGETS);

  if (
	((targets.type == ClipboardManager.ATOM) ||
	(targets.type == ClipboardManager.TARGETS)) &amp;&amp;
	(targets.length &gt; -1)
  ) unsafe {
	ClipboardItem item = new ClipboardItem();
	item.Compressed = false;
	item.Targets = new SelectionDataCollection();

	// Gtk-Sharp TODO : This does not work !
	byte[] atoms_targets = targets.Data;

	// #include &lt;gdk/gdk.h&gt;
	// int main() { printf(&quot;%d&quot;, sizeof(GdkAtom)); }

	// Will return 4. So we will be receiving 4 bytes
	// which will contain the raw data of our Atom

	// TODO: Make a small C library-function that will return
	// sizeof(GdkAtom) or add something like that to
	// Gtk-Sharp(-glue)
	int sizeof_atom=4;

	for(int counter = 0; counter &lt; targets.length; 		counter+=sizeof_atom)
	{
		byte[] atom_target = new byte[sizeof_atom];

		for (int b=0; b&lt;sizeof_atom; b++)
			atom_target[b] = atoms_targets[counter+b];

		// TODO: I am not sure if this will work at all
		IntPtr raw = ManagedValue.WrapObject(atom_target);

		Gtk.SelectionData data = 
			this.clipboard.WaitForContents (new Atom (raw));

		item.Targets.Add(data);
	}

	this.items.Add(item);
	this.Claim(item);
  } else {
	Console.WriteLine(&quot;GCM WARNING: Not TARGETS target&quot;);
  }
}

-- 
Philip Van Hoof, Software Developer @ Cronos
home: me at freax dot org
work: Philip dot VanHoof at cronos dot be
<A HREF="http://www.freax.be,">http://www.freax.be,</A> <A HREF="http://www.freax.eu.org">http://www.freax.eu.org</A>


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="002021.html">[Gtk-sharp-list] generator/SymbolTable.cs: Added ulong
</A></li>
	<LI> Next message: <A HREF="002020.html">[Gtk-sharp-list] Re: [Mono-list] Some questions about clipboards and gtk-sharp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2018">[ date ]</a>
              <a href="thread.html#2018">[ thread ]</a>
              <a href="subject.html#2018">[ subject ]</a>
              <a href="author.html#2018">[ author ]</a>
         </LI>
       </UL>
</body></html>
