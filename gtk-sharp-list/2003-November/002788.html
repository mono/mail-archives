<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] Disposing problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="002784.html">
   <LINK REL="Next"  HREF="002789.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] Disposing problem
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Gtk-sharp-list] Disposing problem">jonpryor@vt.edu
       </A><BR>
    <I>Sun, 09 Nov 2003 11:32:41 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="002784.html">[Gtk-sharp-list] Disposing problem
</A></li>
        <LI> Next message: <A HREF="002789.html">[Gtk-sharp-list] Disposing problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2788">[ date ]</a>
              <a href="thread.html#2788">[ thread ]</a>
              <a href="subject.html#2788">[ subject ]</a>
              <a href="author.html#2788">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The problem is that you're not a GUI app. :-)

PerformQueuedUnrefs is called from the Idle handler for the GUI.  The
Idle handler is run whenever the GUI is not busy.

(Recall that GUIs are event-driven, so if the user isn't doing anything,
and the app isn't doing anything, then the app is idle, so you can do
background work during idle processing.)

Your sample app doesn't have a GUI, so there's never an &quot;idle time&quot;, so
the idle handler is never run, so PerfrmQueuedUnrefs is never called.

Some possible solutions:
  - Insert the code:
	while(GLib.MainContext.Iteration()) {
		// do nothing
	}
    This should explicitly run the idle handler.  This should be run
    after the .Dispose() call.

  - Make Object.Dispose virtual, then make Pixbuf.Dispose free memory 
    immediately.

    This probably isn't a good idea, as GTK+ requires that all objects
    be disposed from the same thread, which is what PerformQueuedUnrefs
    does (since the idle handler is only run on the GUI thread, so only
    one thread will ever do the unrefs).

    Pixbuf might not have this requirement, though.  I have no idea.

The first option is the safest and simplest option, if it works.  Please
try it and let us know.

 - Jon

On Sat, 2003-11-08 at 13:55, Bruno Fernandez-Ruiz wrote:
&gt;<i> On Sat, 2003-11-08 at 20:54, Gon√ßal Carrero Puig wrote:
</I>&gt;<i> &gt; Anyone knows why idle is never calling PerformedQueuedUnrefs?
</I>&gt;<i> 
</I>&gt;<i> I have seen similar problems in due to the GC thread never entering, and
</I>&gt;<i> the heap expanding until memory exhaustion. Try to create many dummy
</I>&gt;<i> objects that implement IDisposable, and see if they get reclaimed. When
</I>&gt;<i> running the attached sample, I freeze the system and run out of memory.
</I>&gt;<i> No collection ever happens. 
</I>&gt;<i> 
</I>&gt;<i> Is GC disabled by default in mono?
</I>&gt;<i> 
</I>&gt;<i> Bruno
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="002784.html">[Gtk-sharp-list] Disposing problem
</A></li>
	<LI> Next message: <A HREF="002789.html">[Gtk-sharp-list] Disposing problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2788">[ date ]</a>
              <a href="thread.html#2788">[ thread ]</a>
              <a href="subject.html#2788">[ subject ]</a>
              <a href="author.html#2788">[ author ]</a>
         </LI>
       </UL>
</body></html>
