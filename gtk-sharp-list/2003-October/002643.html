<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] Interface concept
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:leo%40thewoodpecker.ca">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="002642.html">
   <LINK REL="Next"  HREF="002645.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] Interface concept
   </H1>
    <B>Leo Spalteholz
    </B> 
    <A HREF="mailto:leo%40thewoodpecker.ca"
       TITLE="[Gtk-sharp-list] Interface concept">leo@thewoodpecker.ca
       </A><BR>
    <I>Wed, 22 Oct 2003 00:50:17 -0700</I>
    <P><UL>
        <LI> Previous message: <A HREF="002642.html">[Gtk-sharp-list] Interface concept
</A></li>
        <LI> Next message: <A HREF="002645.html">[Gtk-sharp-list] Interface concept
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2643">[ date ]</a>
              <a href="thread.html#2643">[ thread ]</a>
              <a href="subject.html#2643">[ subject ]</a>
              <a href="author.html#2643">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> Hey Leo,
</I>&gt;<i>
</I>&gt;<i> I am not an expert either but this is what I have found so far.
</I>&gt;<i>
</I>&gt;<i> I figured out a way to split the application into to separate areas.  I
</I>&gt;<i> used the concept of Panes.  There are widgets available for both a
</I>&gt;<i> horizontal panes and vertical panes.  I created a horizontal plane and
</I>&gt;<i> then used the left portion for my column of buttons and the right
</I>&gt;<i> portion for my scrolled window. However, I have not been able to figure
</I>&gt;<i> out how to dynamically display &quot;services&quot; in the scrolled portion.
</I>
Ah.. I haven't even looked at using panes yet...  It won't work for my 
needs but it is of course the natural solution to your problem. 
&gt;<i>
</I>&gt;<i> On your point of deleting a vertical packing box and if the deleting
</I>&gt;<i> trickles down to all the child widgets the answer is yes.  The packing
</I>&gt;<i> box is a container just like a window so any widgets within the
</I>&gt;<i> container are destroyed upon destruction of the container. 
</I>
Good.  I'm still not sure why the memory usage of mono is increasing but 
maybe I've got some references to the buttons hanging around somewhere.  I 
did some rather ugly hackish stuff with storing button references in 
ArrayLists to keep track of them... :P

&gt;<i> could possibly do instead of deleting and recreating a new vertical
</I>&gt;<i> packing box each time....maybe hide each of the widgets within the
</I>&gt;<i> packing box and then show them accordingly.  Now I figure there has to
</I>&gt;<i> be a much easier way then this.  I had thought of trying to do what you
</I>&gt;<i> are doing...but personally you are a better man than I because I would
</I>&gt;<i> not want to deal with the deletion and recreation.  
</I>
Its actually not that bad.  Looks something like this (sorry for the crappy 
10 min coding job).

using System;
using Gtk;
class switchtest {
    public static void Main() {
        new test();
    }
}

class test {
    HPaned splitter;
    public test() {
        Application.Init();
        Window winMain = new Window(&quot;Switch Test&quot;);
        winMain.SetDefaultSize(300, 200);

        splitter = new HPaned();
        Frame frame1 = new Frame(&quot;Buttons go here&quot;);
        Frame frame2 = new Frame(&quot;Service 1&quot;);

        splitter.Pack1(frame1, false, false);
        splitter.Pack2(frame2, true, false);

        Button btnSwitch = new Button(&quot;Change Service&quot;);
        btnSwitch.Clicked += new EventHandler(EvtBtnSwitchClicked);
        frame1.Add(btnSwitch);

        winMain.Add(splitter);
        winMain.ShowAll();
        Application.Run();
    }

    public void EvtBtnSwitchClicked(object obj, EventArgs e) {
        Frame frame2 = (Frame)splitter.Child2;
        Button b = new Button(&quot;Its a new service!&quot;);
        frame2.Label = &quot;New service goes here&quot;;
        frame2.Add(b);
        b.Show();
    }
}

Should run the way it is.  Nothing too complicated.  As you see you're 
basically just changing the contents of the other pane in the button 
clicked eventhandler.  So you could remove and replace the frame with 
something else or just change it like I've done..

&gt;<i> Maybe there is to
</I>&gt;<i> layer the &quot;services&quot; on the scrolled window or in your case packing box
</I>&gt;<i> like a stack where the &quot;service&quot; on the top of the stack is displayed.
</I>&gt;<i> Accordingly you can push and pop the stack of &quot;services&quot; based on the
</I>&gt;<i> actions of the user.  Like I said I am no expert these are just
</I>&gt;<i> suggestions.  Ill keep you informed if a find a way dynamically change
</I>&gt;<i> the window.  If Evolution can do then it can be done.
</I>
I suppose you could store the main container for your service in a list so 
you don't have to recreate it every time you switch to a differnet one.   
Then just swap them in the clicked eventhandler.  So you have faster 
switching between services at the expense of more memory usage I would 
think.

Let me know how it works out.

~leo
&gt;<i>
</I>&gt;<i> Joe
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="002642.html">[Gtk-sharp-list] Interface concept
</A></li>
	<LI> Next message: <A HREF="002645.html">[Gtk-sharp-list] Interface concept
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2643">[ date ]</a>
              <a href="thread.html#2643">[ thread ]</a>
              <a href="subject.html#2643">[ subject ]</a>
              <a href="author.html#2643">[ author ]</a>
         </LI>
       </UL>
</body></html>
