<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] GTK# hscale,	porting from a winforms application
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:gtk-sharp-list%40lists.ximian.com?Subject=Re%3A%20%5BGtk-sharp-list%5D%20GTK%23%20hscale%2C%0A%09porting%20from%20a%20winforms%20application&In-Reply-To=%3C1377693060494-4660700.post%40n4.nabble.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011285.html">
   <LINK REL="Next"  HREF="011287.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] GTK# hscale,	porting from a winforms application</H1>
    <B>abhaykale</B> 
    <A HREF="mailto:gtk-sharp-list%40lists.ximian.com?Subject=Re%3A%20%5BGtk-sharp-list%5D%20GTK%23%20hscale%2C%0A%09porting%20from%20a%20winforms%20application&In-Reply-To=%3C1377693060494-4660700.post%40n4.nabble.com%3E"
       TITLE="[Gtk-sharp-list] GTK# hscale,	porting from a winforms application">abhaykale at yahoo.com
       </A><BR>
    <I>Wed Aug 28 12:31:00 UTC 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="011285.html">[Gtk-sharp-list] GTK# hscale,	porting from a winforms application
</A></li>
        <LI>Next message: <A HREF="011287.html">[Gtk-sharp-list] how I can know if a DB is created?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11286">[ date ]</a>
              <a href="thread.html#11286">[ thread ]</a>
              <a href="subject.html#11286">[ subject ]</a>
              <a href="author.html#11286">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi!

I guess with minor modification, the following code should be good to go:

// Authors
//   Copyright (C) 2008 Paul Burton &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">paulburton89 at gmail.com</A>&gt;
//   Copyright (C) 2010 Andoni Morales &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">ylatuya at gmail.com</A>&gt;
using System;
using System.Runtime.InteropServices;

using Gtk;
using Gst;
using Gst.Interfaces;
using Gst.BasePlugins;
using Gst.GLib;

public partial class MainWindow : Gtk.Window {

	DrawingArea _da;
	ulong _xWindowId;
	PlayBin2 _playbin;
	HScale _scale;
	Label _lbl;
	bool _updatingScale;
	bool _pipelineOK = false;
//	Gtk.Window playWindow;
	
	public static void Main (string[] args) {
		if (System.Environment.OSVersion.Platform == PlatformID.Unix)
			XInitThreads ();
		
		Gtk.Application.Init ();
		Gst.Application.Init ();
		MainWindow window = new MainWindow ();
		window.ShowAll ();

//		Gtk.Window playWindow = new Window(WindowType.Popup);
//		playWindow.ShowAll();
		
#if HAVE_GTK_2_17_3
		if (!gdk_window_ensure_native (window._da.GdkWindow.Handle)) {
			Console.WriteLine (&quot;Can't ensure a native window for the drawing area&quot;);
		}
#endif
		switch (System.Environment.OSVersion.Platform) {
		case PlatformID.Unix:
			window._xWindowId = gdk_x11_drawable_get_xid
(window._da.GdkWindow.Handle);
			break;
		case PlatformID.Win32NT:
		case PlatformID.Win32S:
		case PlatformID.Win32Windows:
		case PlatformID.WinCE:
			window._xWindowId = (ulong) gdk_win32_drawable_get_handle
(window._da.GdkWindow.Handle).ToInt64();
			break;
		}

		window._da.AppPaintable = true;

		Gtk.Application.Run ();
	}
	
	public MainWindow ()
	: base (WindowType.Toplevel) {
		VBox vBox = new VBox ();

//		playWindow = new Window(WindowType.Popup);
//		playWindow.SetSizeRequest(400, 300);
//		playWindow.ShowAll();
		
		_da = new DrawingArea ();
		_da.ModifyBg (Gtk.StateType.Normal, new Gdk.Color (0, 0, 0));
		_da.SetSizeRequest (400, 300);
		_da.DoubleBuffered = false;
		vBox.PackStart (_da);
		
		_scale = new HScale (0, 1, 0.01);
		_scale.DrawValue = false;
		_scale.ValueChanged += ScaleValueChanged;
		vBox.PackStart (_scale, false, false, 0);
		
		HBox hBox = new HBox ();
		
		Button btnOpen = new Button ();
		btnOpen.Label = &quot;Open&quot;;
		btnOpen.Clicked += ButtonOpenClicked;
		
		hBox.PackStart (btnOpen, false, false, 0);
		
		Button btnPlay = new Button ();
		btnPlay.Label = &quot;Play&quot;;
		btnPlay.Clicked += ButtonPlayClicked;
		
		hBox.PackStart (btnPlay, false, false, 0);
		
		Button btnPause = new Button ();
		btnPause.Label = &quot;Pause&quot;;
		btnPause.Clicked += ButtonPauseClicked;
		
		hBox.PackStart (btnPause, false, false, 0);
		
		_lbl = new Label ();
		_lbl.Text = &quot;00:00 / 00:00&quot;;
		
		hBox.PackEnd (_lbl, false, false, 0);
		
		vBox.PackStart (hBox, false, false, 3);
		
		Add (vBox);
		
		WindowPosition = Gtk.WindowPosition.Center;
		DeleteEvent += OnDeleteEvent;
		
		GLib.Timeout.Add (1000, new GLib.TimeoutHandler (UpdatePos));
	}
	
	void OnDeleteEvent (object sender, DeleteEventArgs args) {
		Gtk.Application.Quit ();
		
		if (_playbin != null) {
			_playbin.SetState (Gst.State.Null);
			_playbin.Dispose ();
			_playbin = null;
		}
		
		args.RetVal = true;
	}
	
	void ButtonOpenClicked (object sender, EventArgs args) {
		FileChooserDialog dialog = new FileChooserDialog (&quot;Open&quot;, this,
FileChooserAction.Open, new object[] { &quot;Cancel&quot;, ResponseType.Cancel,
&quot;Open&quot;, ResponseType.Accept });

		if (dialog.Run () == (int) ResponseType.Accept) {
			_pipelineOK = false;
			
			if (_playbin != null) {
				_playbin.SetState (Gst.State.Null);
			} else {
				_playbin = new PlayBin2 ();
				_playbin.PlayFlags &amp;= ~((Gst.BasePlugins.PlayBin2.PlayFlagsType)(1 &lt;&lt;
2));
			}
			
			_scale.Value = 0;
			
			if (_playbin == null)
				Console.WriteLine (&quot;Unable to create element 'playbin'&quot;);
			
			_playbin.Bus.EnableSyncMessageEmission ();
			_playbin.Bus.AddSignalWatch ();
//			_playbin.AsyncHandling = true;
			
			_playbin.Bus.SyncMessage += delegate (object bus, SyncMessageArgs sargs)
{
				Gst.Message msg = sargs.Message;
				if (msg == null || msg.Type != Gst.MessageType.Element ||
				    msg.Structure == null || msg.Structure.Name == null ||
				    !msg.Structure.Name.Equals (&quot;prepare-xwindow-id&quot;))
					return;
				
				Element src = msg.Src as Element;
				if (src == null)
					return;

				if(msg.Structure != null) Console.WriteLine(&quot;msg.Structure.Name - &quot; +
msg.Structure.Name);
//				if (src.HasProperty (&quot;force-aspect-ratio&quot;))
//					src[&quot;force-aspect-ratio&quot;] = true;

				Gst.Video.VideoSink olWnd = src as Gst.Video.VideoSink;
				if(olWnd != null){
					Console.WriteLine(&quot;Got XOverlay&quot;);
					Gst.Interfaces.XOverlayAdapter overlayAdapter = new
						Gst.Interfaces.XOverlayAdapter(olWnd.Handle);
					overlayAdapter.XwindowId = (ulong)_xWindowId;
					overlayAdapter.HandleEvents(true);
				} else {
					Console.WriteLine(&quot;Did not get XOverlay&quot;);
				}
			};
			
			_playbin.Bus.Message += delegate (object bus, MessageArgs margs) {
				Message message = margs.Message;
				
				switch (message.Type) {
				case Gst.MessageType.Error:
					Enum err;
					string msg;
					
					message.ParseError (out err, out msg);
					Console.WriteLine (String.Format (&quot;Error message: {0}&quot;, msg));
					_pipelineOK = false;
					break;
				case Gst.MessageType.Eos:
					Console.WriteLine (&quot;EOS&quot;);
					break;
				}
			};

			switch (System.Environment.OSVersion.Platform) {
			case PlatformID.Unix:
				_playbin[&quot;uri&quot;] = &quot;<A HREF="file://">file://</A>&quot; + dialog.Filename;
				break;
			case PlatformID.Win32NT:
			case PlatformID.Win32S:
			case PlatformID.Win32Windows:
			case PlatformID.WinCE:
				_playbin[&quot;uri&quot;] = &quot;<A HREF="file:///">file:///</A>&quot; + dialog.Filename.Replace(&quot;\\&quot;,&quot;/&quot;);
				break;
			}
			
			StateChangeReturn sret = _playbin.SetState (Gst.State.Playing);
			
			if (sret == StateChangeReturn.Async) {
				State state, pending;
				sret = _playbin.GetState (out state, out pending, Clock.Second * 5);
			}
			
			if (sret == StateChangeReturn.Success) {
				Console.WriteLine (&quot;State change successful&quot;);
				_pipelineOK = true;
			} else {
				Console.WriteLine (&quot;State change failed for {0} ({1})\n&quot;,
dialog.Filename, sret);
			}
		}
		
		dialog.Destroy ();
	}
	
	void ButtonPlayClicked (object sender, EventArgs args) {
		if ( (_playbin != null) &amp;&amp; _pipelineOK)
			_playbin.SetState (Gst.State.Playing);
	}
	
	void ButtonPauseClicked (object sender, EventArgs args) {
		if ( (_playbin != null) &amp;&amp; _pipelineOK)
			_playbin.SetState (Gst.State.Paused);
	}
	
	void ScaleValueChanged (object sender, EventArgs args) {
		if (_updatingScale)
			return;
		
		long duration;
		Gst.Format fmt = Gst.Format.Time;
		Console.WriteLine (&quot;Trying to seek&quot;);
		
		if ( (_playbin != null) &amp;&amp; _pipelineOK &amp;&amp; _playbin.QueryDuration (ref fmt,
out duration) &amp;&amp; duration != -1) {
			long pos = (long) (duration * _scale.Value);
			Console.WriteLine (&quot;Seek to {0}/{1} ({2}%)&quot;, pos, duration,
_scale.Value);
			
			bool ret = _playbin.Seek (Gst.Format.Time, SeekFlags.Flush |
SeekFlags.KeyUnit, pos);
			
			Console.WriteLine (&quot;Seeked {0}successfully&quot;, (ret ? &quot;&quot; : &quot;not &quot;));
		}
	}
	
	bool UpdatePos () {
		Gst.Format fmt = Gst.Format.Time;
		long duration, pos;
		if ( (_playbin != null) &amp;&amp; _pipelineOK &amp;&amp;
		    _playbin.QueryDuration (ref fmt, out duration) &amp;&amp;
		    _playbin.QueryPosition (ref fmt, out pos)) {
			_lbl.Text = string.Format (&quot;{0} / {1}&quot;, TimeString (pos), TimeString
(duration));
			
			_updatingScale = true;
			_scale.Value = (double) pos / duration;
			_updatingScale = false;
		}
		
		return true;
	}
	
	string TimeString (long t) {
		long secs = t / 1000000000;
		int mins = (int) (secs / 60);
		secs = secs - (mins * 60);
		
		if (mins &gt;= 60) {
			int hours = (int) (mins / 60);
			mins = mins - (hours * 60);
			
			return string.Format (&quot;{0}:{1:d2}:{2:d2}&quot;, hours, mins, secs);
		}
		
		return string.Format (&quot;{0}:{1:d2}&quot;, mins, secs);
	}
	
	[DllImport (&quot;libgdk-x11-2.0.so.0&quot;) ]
	static extern uint gdk_x11_drawable_get_xid (IntPtr handle);
	
	[DllImport (&quot;libgdk-win32-2.0-0.dll&quot;) ]
	static extern IntPtr gdk_win32_drawable_get_handle (IntPtr handle);
	
#if HAVE_GTK_2_17_3
	[DllImport (&quot;libgdk-win32-2.0-0.dll&quot;) ]
	static extern bool gdk_window_ensure_native (IntPtr handle);
#endif
	
	[DllImport (&quot;libX11.so.6&quot;)]
	static extern int XInitThreads ();
}


Thanks and regards,
Abhay Kale




--
View this message in context: <A HREF="http://mono.1490590.n4.nabble.com/GTK-hscale-porting-from-a-winforms-application-tp4660629p4660700.html">http://mono.1490590.n4.nabble.com/GTK-hscale-porting-from-a-winforms-application-tp4660629p4660700.html</A>
Sent from the Mono - Gtk# mailing list archive at Nabble.com.
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011285.html">[Gtk-sharp-list] GTK# hscale,	porting from a winforms application
</A></li>
	<LI>Next message: <A HREF="011287.html">[Gtk-sharp-list] how I can know if a DB is created?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11286">[ date ]</a>
              <a href="thread.html#11286">[ thread ]</a>
              <a href="subject.html#11286">[ subject ]</a>
              <a href="author.html#11286">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">More information about the Gtk-sharp-list
mailing list</a><br>
</body></html>
