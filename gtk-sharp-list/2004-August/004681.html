<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] Serialization Compliance Problems
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:webmaster%40knowledgeautomation.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="004680.html">
   <LINK REL="Next"  HREF="004679.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] Serialization Compliance Problems
   </H1>
    <B>Marc Clifton
    </B> 
    <A HREF="mailto:webmaster%40knowledgeautomation.com"
       TITLE="[Gtk-sharp-list] Serialization Compliance Problems">webmaster@knowledgeautomation.com
       </A><BR>
    <I>Sun, 15 Aug 2004 18:53:34 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="004680.html">[Gtk-sharp-list] Serialization Compliance Problems
</A></li>
        <LI> Next message: <A HREF="004679.html">[Gtk-sharp-list] Window X,Y and Position on desktop.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4681">[ date ]</a>
              <a href="thread.html#4681">[ thread ]</a>
              <a href="subject.html#4681">[ subject ]</a>
              <a href="author.html#4681">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Kris,

Great discussion.  My replies follow:

&gt;<i>It looks like Xaml is just to close to a particular API: it relies on
</I>&gt;<i>the framework class structure, instead of abstracting the user
</I>&gt;<i>interface away from the API. E.g. the tags and attribute have a direct
</I>&gt;<i>mapping onto the class and properties of a particular API, which
</I>&gt;<i>doesn't help in making the approach reusable for other widget sets.
</I>&gt;<i>  
</I>&gt;<i>
</I>This is true, but I'm not sure what the you're getting at here.  In 
specific, when writing GTK# code imperatively, I'm working with the GTK# 
framework, classes, and class structure.  If I want to work the GTK# 
declaratively, I can't because it's missing certain key features that 
let me construct the necessary object graphs.  With imperative code, 
switching to another widget set is essentially a rewrite.  With 
declarative code, there is the possibility that all you need to do is 
apply an XSLT!

&gt;<i>I don't agree you need to have parameterless constructors to create a
</I>&gt;<i>&quot;declarative markup parser&quot;. If you see this as a requirement for a
</I>&gt;<i>declarative way to create a UI, than you say every widget set API
</I>&gt;<i>should have them.
</I>&gt;<i>  
</I>&gt;<i>
</I>Well, yes, I guess that is exactly what I'm saying.  I don't see that as 
an issue, and as I mentioned in the blog entry, I think supporting 
parameterless constructors (not exclusively, but inclusively) is simply 
better coding for the framework.  Any stable, predictable platform 
should essentially allow properties to be set in any order, and 
supporting parameterless constructors is a step in that direction.

&gt;<i>In my experience Gtk# was easier to support with a &quot;declarative markup
</I>&gt;<i>parser/renderer&quot; than SWF, because of its better layout management
</I>&gt;<i>system. We did the exercise with Uiml.net[1], a .Net based UIML
</I>&gt;<i>renderer that can use SWF and GTK#, SWF on compact and a tiny bit of
</I>&gt;<i>deprecated Wx.Net. It is not as powerful for Gtk# as Glade-XML is, or
</I>&gt;<i>for SWF as MyXAML is, but UIML provides a much better abstraction and
</I>&gt;<i>could be as powerful (-; . We do have a little bit of widget-set
</I>&gt;<i>specific code for each widget set, but only the absolute minimum.
</I>&gt;<i>  
</I>&gt;<i>
</I>Well, that's as I expected, that some widget specific code is required.  
With a little bit of work, I think this could be eliminated.

&gt;<i>Your second shortcoming for Xaml was a little bit confusing (&quot;how
</I>&gt;<i>collections are handled&quot;). Doesn't this indicate the close relation of
</I>&gt;<i>Xaml with a particular API?
</I>&gt;<i>  
</I>&gt;<i>
</I>Hmmm.  Perhaps, but again, why is this an issue?  While it would be easy 
enough to add support in MyXaml for a collection tag that knows how to 
invoke the Add method of the widget's Container base object, this begs 
the question, do you add to a generic parser the specific functionality 
required to support a particular toolkit, or do you enhance the toolkit 
to support generic parsing using standard .NET collection classes (or, 
as a compromise, do you expose your own container implementations if 
you're not using .NET's collection classes)?

Marc

&gt;<i>[1] <A HREF="https://sourceforge.net/projects/uimldotnet/">https://sourceforge.net/projects/uimldotnet/</A>  ,
</I>&gt;<i>research.edm.luc.ac.be/kris/projects/uiml.net/
</I>&gt;<i>
</I>&gt;<i>Regards,
</I>&gt;<i>Kris
</I>&gt;<i>_______________________________________________
</I>&gt;<i>Gtk-sharp-list maillist  -  <A HREF="mailto:Gtk-sharp-list@lists.ximian.com">Gtk-sharp-list@lists.ximian.com</A>
</I>&gt;<i><A HREF="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">http://lists.ximian.com/mailman/listinfo/gtk-sharp-list</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="004680.html">[Gtk-sharp-list] Serialization Compliance Problems
</A></li>
	<LI> Next message: <A HREF="004679.html">[Gtk-sharp-list] Window X,Y and Position on desktop.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4681">[ date ]</a>
              <a href="thread.html#4681">[ thread ]</a>
              <a href="subject.html#4681">[ subject ]</a>
              <a href="author.html#4681">[ author ]</a>
         </LI>
       </UL>
</body></html>
