<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] task list
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jeremy%40olicomp.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="003920.html">
   <LINK REL="Next"  HREF="003949.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] task list
   </H1>
    <B>Jeremy Wells
    </B> 
    <A HREF="mailto:jeremy%40olicomp.com"
       TITLE="[Gtk-sharp-list] task list">jeremy@olicomp.com
       </A><BR>
    <I>Sun, 25 Apr 2004 01:15:47 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="003920.html">[Gtk-sharp-list] task list
</A></li>
        <LI> Next message: <A HREF="003949.html">[Gtk-sharp-list] Widgets not updating
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3922">[ date ]</a>
              <a href="thread.html#3922">[ thread ]</a>
              <a href="subject.html#3922">[ subject ]</a>
              <a href="author.html#3922">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-5R8OvDuojzXePHaPOy9K
Content-Type: text/plain
Content-Transfer-Encoding: 7bit

I couldn't get the generator to work, so eventually I just wrote a
wrapper around the libwnck which does what I need it to do (attached)
but is by no means complete.

Jeremy

On Sat, 2004-04-24 at 19:52, John Luke wrote:
&gt;<i> On Sat, 2004-04-24 at 13:45 +0100, Jeremy Wells wrote:
</I>&gt;<i> &gt; ok, i found the generator readme and tried to do as it said, i created
</I>&gt;<i> &gt; an xml file for libwnck:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &lt;gapi-parser-input&gt;
</I>&gt;<i> &gt; &lt;api filename=&quot;api/wnck-api.raw&quot;&gt;
</I>&gt;<i> &gt; &lt;library name=&quot;libwnck-1.so.4&quot;&gt;
</I>&gt;<i> &gt; &lt;namespace name=&quot;Wnck&quot;&gt;
</I>&gt;<i> &gt; &lt;dir&gt;libwnck-2.4.0.1/libwnck&lt;/dir&gt;
</I>&gt;<i> &gt; &lt;/namespace&gt;
</I>&gt;<i> &gt; &lt;/library&gt;
</I>&gt;<i> &gt; &lt;/api&gt;
</I>&gt;<i> &gt; &lt;/gapi-parser-input&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; and then ran gapi-parser libwnck.xml and a lot of numbers n stuff
</I>&gt;<i> &gt; flashes past as it runs, but then it exits with the following error:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;  at /usr/local/bin/gapi2xml.pl line 852, &lt;STDIN&gt; line 1621.
</I>&gt;<i> &gt; I/O warning : failed to load external entity &quot;api/wnck-api.raw.pre&quot;
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt; ** (process:12377): WARNING **: File api/wnck-api.raw.pre empty or not
</I>&gt;<i> &gt; well-formed.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; it doesn't matter how i change the location of the api filename or
</I>&gt;<i> &gt; anything, it always comes out with the same error.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; am i doing something wrong or am i barking up the wrong tree completely
</I>&gt;<i> &gt; trying to do it like this?
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> You are doing it mostly right, except that the parser cannot parse
</I>&gt;<i> libwnck.  This is probably due to minor coding style problems for which
</I>&gt;<i> you can either patch the source of libwnck before you parse it, or add
</I>&gt;<i> support for it to the Gtk# parser.
</I>&gt;<i> 
</I>&gt;<i> A few minor things:
</I>&gt;<i> you may want to use the gnome2.2 version of libwnck
</I>&gt;<i> &lt;api filename=&quot;wnck/wnck-api.raw&quot;&gt; (wnck should be a directory at
</I>&gt;<i> gtk-sharp/wnck)
</I>&gt;<i> &lt;library name=&quot;libwnck-1.so&quot;&gt; (and then add the minor version
</I>&gt;<i> to /etc/mono/config)
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Gtk-sharp-list maillist  -  <A HREF="mailto:Gtk-sharp-list@lists.ximian.com">Gtk-sharp-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">http://lists.ximian.com/mailman/listinfo/gtk-sharp-list</A>
</I>
--=-5R8OvDuojzXePHaPOy9K
Content-Disposition: attachment; filename=Wnck.cs
Content-Type: text/x-csharp; name=Wnck.cs; charset=ANSI_X3.4-1968
Content-Transfer-Encoding: 7bit

/* C# wrapper for libwnck
 * Copyright (C) 2004 Jeremy Wells
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

namespace Wnck
{
	using GLib;
	using Gdk;
	using System;
	using System.Collections;
	using System.Runtime.InteropServices;
	
	public class WApplication
	{
		private IntPtr WnckApplication;
		
		[DllImport (&quot;libwnck-1&quot;)]
		static extern string wnck_application_get_name      (IntPtr app);
		[DllImport (&quot;libwnck-1&quot;)]
        static extern string wnck_application_get_icon_name (IntPtr app);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern int         wnck_application_get_pid       (IntPtr app);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern IntPtr  wnck_application_get_icon      (IntPtr app);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern IntPtr  wnck_application_get_mini_icon (IntPtr app);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern bool    wnck_application_get_icon_is_fallback (IntPtr app);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern string wnck_application_get_startup_id (IntPtr app);
        [DllImport (&quot;libwnck-1&quot;)]
		static extern IntPtr wnck_application_get_windows   (IntPtr app);
		
		public string Name
		{
			get { return wnck_application_get_name (Handle); }
		}
		
		public string IconName
		{
			get { return wnck_application_get_icon_name (Handle); }
		}
		
		public int PID
		{
			get { return wnck_application_get_pid (Handle); }
		}
		
		public Gdk.Pixbuf Icon
		{
			get { return new Gdk.Pixbuf (wnck_application_get_icon (Handle)); }
		}
		
		public Gdk.Pixbuf MiniIcon
		{
			get { return new Gdk.Pixbuf (wnck_application_get_mini_icon (Handle)); }
		}
		
		public WWindow[] Windows
		{
			get {
				GLib.List wlist = new GLib.List (wnck_application_get_windows (Handle));
				
				ArrayList windows = new ArrayList(wlist.Count);
				
				for(int i = 0; i &lt; wlist.Count; i++)
				{
					GLib.Object wobj = (GLib.Object)wlist[i];
        			WWindow window = new WWindow(wobj.Handle);
        			windows.Add(window);
        		}
        		
        		return (Wnck.WWindow[])windows.ToArray(System.Type.GetType(&quot;Wnck.WWindow&quot;));
			}
		}
		
		public IntPtr Handle
		{	
			get { return WnckApplication; }
		}
		
		public WApplication (IntPtr application)
		{
			WnckApplication = application;
		}
	}
    
    public class WWindow
    {
    	private IntPtr WnckWindow;
    	
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern IntPtr wnck_window_get_application(IntPtr window);
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern string wnck_application_get_name(IntPtr app);
    	
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern string wnck_window_get_name(IntPtr window);
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern IntPtr wnck_window_get_workspace(IntPtr window);
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern IntPtr wnck_window_get_screen (IntPtr window);

    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern void wnck_window_activate (IntPtr window);
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern void wnck_window_close                   (IntPtr window);
    	[DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_minimize                (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_unminimize              (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_maximize                (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_unmaximize              (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_shade                   (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_unshade                 (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_stick                   (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_unstick                 (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_keyboard_move           (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_keyboard_size           (IntPtr window);
    	
    	[DllImport (&quot;libwnck-1&quot;)]
        static extern bool wnck_window_is_minimized              (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern bool wnck_window_is_maximized_horizontally (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern bool wnck_window_is_maximized_vertically   (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern bool wnck_window_is_maximized              (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern bool wnck_window_is_shaded                 (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern bool wnck_window_is_skip_pager             (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern bool wnck_window_is_skip_tasklist          (IntPtr window);
        [DllImport (&quot;libwnck-1&quot;)]
        static extern bool wnck_window_is_sticky                 (IntPtr window);
        
        [DllImport (&quot;libwnck-1&quot;)]
		static extern bool wnck_window_is_pinned (IntPtr window);
		[DllImport (&quot;libwnck-1&quot;)]
		static extern void wnck_window_pin       (IntPtr window);
		[DllImport (&quot;libwnck-1&quot;)]
		static extern void wnck_window_unpin     (IntPtr window);
        
    	[DllImport (&quot;libwnck-1&quot;)]
        static extern void wnck_window_set_skip_pager    (IntPtr window, bool skip);
        [DllImport (&quot;libwnck-1&quot;)]
		static extern void wnck_window_set_skip_tasklist (IntPtr window, bool skip);
		
		[DllImport (&quot;libwnck-1&quot;)]
		static extern IntPtr wnck_window_get_icon      (IntPtr window);
		[DllImport (&quot;libwnck-1&quot;)]
		static extern IntPtr wnck_window_get_mini_icon (IntPtr window);
  	
    	public string Name
    	{
    		get { 
    			return wnck_window_get_name (WnckWindow);
    		}
    	}
    
    	public WApplication Application
    	{
    		get {
    			return new WApplication(wnck_window_get_application(Handle));
    		}
    	}
    	
    	public WScreen Screen
    	{
    		get {
    			return new WScreen(wnck_window_get_screen (Handle));
    		}
    	}
    	
    	public WWorkspace Workspace
    	{
    		get {
    			return new WWorkspace(this.Screen, wnck_window_get_workspace(Handle));
    		}
    	}
    	
    	public bool InTaskList
    	{
    		get {
    			return ! wnck_window_is_skip_tasklist (WnckWindow);
    		}
    		set {
    			wnck_window_set_skip_tasklist (Handle, !value);
    		}
    	}
    	
    	public bool InPager
    	{
    		get {
    			return ! wnck_window_is_skip_pager (Handle);
    		}
    		set {
    			wnck_window_set_skip_pager(Handle, !value);
    		}
    	}
    	
    	public bool Maximized
    	{
    		get {
    			return wnck_window_is_maximized (Handle);
    		}
    		set {
    			if (value) wnck_window_maximize (Handle);
    			else wnck_window_unmaximize (Handle);
    		}
    	}
    	
    	public bool Minimized
    	{
    		get {
    			return wnck_window_is_minimized (Handle);
    		}
    		set {
    			if (value) wnck_window_minimize (Handle);
    			else wnck_window_unminimize (Handle);
    		}
    	}
    	
    	public bool Shaded
    	{
    		get {
    			return wnck_window_is_shaded (Handle);
    		}
    		set {
    			if (value) wnck_window_shade (Handle);
    			else wnck_window_unshade (Handle);
    		}
    	}
    	
    	public bool Sticky
    	{
    		get {
    			return wnck_window_is_sticky (Handle);
    		}
    		set {
    			if (value) wnck_window_stick (Handle);
    			else wnck_window_unstick (Handle);
    		}
    	}
    	
    	public bool Pinned
    	{
    		get {
    			return wnck_window_is_pinned (Handle);
    		}
    		set {
    			if (value) wnck_window_pin (Handle);
    			else wnck_window_unpin (Handle);
    		}
    	}
    	
    	public Gdk.Pixbuf Icon
    	{
    		get {
    			return new Gdk.Pixbuf(wnck_window_get_icon (Handle));
    		}
    	}
    	
    	public Gdk.Pixbuf MiniIcon
    	{
    		get {
    			return new Gdk.Pixbuf(wnck_window_get_mini_icon (Handle));
    		}
    	}
    	
    	public IntPtr Handle
    	{
    		get { return WnckWindow; }
    	}
    	
    	public WWindow (IntPtr window)
    	{
    		WnckWindow = window;
    	}
    	
    	public void Activate()
    	{
    		wnck_window_activate (Handle);
    	}
    	
    	public void Close()
    	{
    		wnck_window_close (Handle);
    	}	
    }
    
    public class WWorkspace
    {
    	private IntPtr WnckWorkspace;
    	private WScreen screen;
    	
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern bool wnck_window_is_on_workspace(IntPtr window, IntPtr workspace);
    	
    	public bool Contains (WWindow window)
    	{
    		return wnck_window_is_on_workspace(window.Handle, Handle);
    	}
    	
    	public IntPtr Handle
    	{
    		get { return WnckWorkspace; }
    	}
    	
    	public WScreen Screen
    	{
    		get { return screen; }
    	}
    	
    	public WWorkspace (WScreen screen, IntPtr workspace)
    	{
    		this.screen = screen;
    		WnckWorkspace = workspace;
    	}
    	
    	public WWindow[] Tasks
    	{
    		get {
    			WWindow[] alltasks = this.Screen.Tasks;
    		
    			ArrayList windows = new ArrayList(alltasks.Length);
    			
    			foreach(WWindow w in alltasks)
    			{
    				if (Contains (w))
    					windows.Add(w);
    			}
    								
        		return (WWindow[])windows.ToArray(System.Type.GetType(&quot;Wnck.WWindow&quot;));
        	}
        }
    }
    
    public class WScreen
    {
    	private IntPtr WnckScreen;
    	
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern IntPtr wnck_screen_get_default ();
    	
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern IntPtr wnck_screen_get_windows(IntPtr screen);
    	
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern void wnck_screen_force_update(IntPtr screen);
    	
    	[DllImport (&quot;libwnck-1&quot;)]
    	static extern IntPtr wnck_screen_get_active_workspace (IntPtr window);
    	
    	public WWorkspace Active
    	{
    		get {
    			wnck_screen_force_update(Handle);
    			return new WWorkspace(this,wnck_screen_get_active_workspace (Handle));
    		}
    	}
    	
    	public WWindow[] Tasks
    	{
    		get {
        		wnck_screen_force_update(Handle);
        		IntPtr raw_list = wnck_screen_get_windows(Handle);
        		
        		GLib.List wlist = new GLib.List(raw_list);
        		ArrayList windows = new ArrayList(wlist.Count);
        		
        		for(int i = 0; i &lt; wlist.Count; i++)
        		{
        			GLib.Object wobj = (GLib.Object)wlist[i];
        			WWindow window = new WWindow(wobj.Handle); 
        			
        			if(window.InTaskList) windows.Add(window);
        		}
        		
        		return (WWindow[])windows.ToArray(System.Type.GetType(&quot;Wnck.WWindow&quot;));
        	}
        }
    	
    	public IntPtr Handle
    	{
    		get { return WnckScreen; }
    	} 
    	
    	public WScreen (IntPtr screen)
    	{
    		WnckScreen = screen;
    	}
    	public WScreen ()
    	{
    		WnckScreen = wnck_screen_get_default ();
    	}
    }
}
--=-5R8OvDuojzXePHaPOy9K--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="003920.html">[Gtk-sharp-list] task list
</A></li>
	<LI> Next message: <A HREF="003949.html">[Gtk-sharp-list] Widgets not updating
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3922">[ date ]</a>
              <a href="thread.html#3922">[ thread ]</a>
              <a href="subject.html#3922">[ subject ]</a>
              <a href="author.html#3922">[ author ]</a>
         </LI>
       </UL>
</body></html>
