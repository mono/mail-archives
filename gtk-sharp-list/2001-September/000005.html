<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] Re: Gtk# hacking
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mkestner%40speakeasy.net">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000004.html">
   <LINK REL="Next"  HREF="000006.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] Re: Gtk# hacking
   </H1>
    <B>Mike Kestner
    </B> 
    <A HREF="mailto:mkestner%40speakeasy.net"
       TITLE="[Gtk-sharp-list] Re: Gtk# hacking">mkestner@speakeasy.net
       </A><BR>
    <I>20 Sep 2001 20:57:40 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="000004.html">[Gtk-sharp-list] Re: Gtk# hacking
</A></li>
        <LI> Next message: <A HREF="000006.html">[Gtk-sharp-list] Re: FWD: [Mono-cvs-list] Mono CVS: gtk-sharp bobsmith
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5">[ date ]</a>
              <a href="thread.html#5">[ thread ]</a>
              <a href="subject.html#5">[ subject ]</a>
              <a href="author.html#5">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 2001-09-20 at 17:30, Bob Smith wrote:

&gt;<i> The proposed solution is to make a static delegate type for each type of
</I>&gt;<i> signal callback, keep a perminantly pinned instance of it laying around,
</I>&gt;<i> and have it registered when needed. So, assuming both &quot;clicked&quot; and
</I>&gt;<i> &quot;destroyed&quot; in the previous example are the same function type, the total
</I>&gt;<i> number of delegates is reduced to 1. You can have 50 buttons each with a
</I>&gt;<i> clicked method, and only one delegate gets pinned. This is MUCH easier on
</I>&gt;<i> the garbage collector and memory in general. All other delegates remain
</I>&gt;<i> managed, so nothing else needs pining.
</I>
How does the static callback know whether it is being called for a
clicked event or a destroyed event if it's being shared in this manner?
Are we going to have to connect to the raw signal with data indicating
the fully qualified event name and put another hashtable in to map that
to the real event emitter?    

&gt;<i> As to how the delegate gets access to what wrapper object it needs, there
</I>&gt;<i> is a static Object function that gets the associated wrapper of a GObject.
</I>&gt;<i> The wrapper is stored in a static hash table, the hash key is an int
</I>&gt;<i> converted to an IntPtr and stored as data in the GObject. The delegate
</I>&gt;<i> uses this function to get the wrapper, then calls the appropriate event on
</I>&gt;<i> the wrapper.
</I>
I meant to comment on this earlier.  Why do we need to store this in the
raw object?  Can't we just use the raw object IntPtr directly as a key
to the hash?  That would save some PInvoke roundtrips.

&gt;<i> I have all this already coded over here, and I can dump it into cvs if
</I>&gt;<i> you'd like. It may require a few min to make sure everything compiles, but
</I>&gt;<i> it should be pritty close.
</I>
It sounds like a good improvement.  If you already have the problem of
mapping back to the signal specific callback solved, go ahead and commit
this and I'll see if I can work out any kinks when I get back on Sunday.

Thanks,
Mike



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000004.html">[Gtk-sharp-list] Re: Gtk# hacking
</A></li>
	<LI> Next message: <A HREF="000006.html">[Gtk-sharp-list] Re: FWD: [Mono-cvs-list] Mono CVS: gtk-sharp bobsmith
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5">[ date ]</a>
              <a href="thread.html#5">[ thread ]</a>
              <a href="subject.html#5">[ subject ]</a>
              <a href="author.html#5">[ author ]</a>
         </LI>
       </UL>
</body></html>
