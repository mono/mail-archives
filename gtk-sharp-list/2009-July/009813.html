<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Gtk-sharp-list] Gtk#DataBindings v2.0 rc1 released
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:gtk-sharp-list%40lists.ximian.com?Subject=%5BGtk-sharp-list%5D%20Gtk%23DataBindings%20v2.0%20rc1%20released&In-Reply-To=1248474030.4265.133.camel%40localhost">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009810.html">
   <LINK REL="Next"  HREF="009814.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gtk-sharp-list] Gtk#DataBindings v2.0 rc1 released</H1>
    <B>Christian Hoff</B> 
    <A HREF="mailto:gtk-sharp-list%40lists.ximian.com?Subject=%5BGtk-sharp-list%5D%20Gtk%23DataBindings%20v2.0%20rc1%20released&In-Reply-To=1248474030.4265.133.camel%40localhost"
       TITLE="[Gtk-sharp-list] Gtk#DataBindings v2.0 rc1 released">christian_hoff at gmx.net
       </A><BR>
    <I>Sat Jul 25 04:25:04 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="009810.html">[Gtk-sharp-list] Gtk#DataBindings v2.0 rc1 released
</A></li>
        <LI>Next message: <A HREF="009814.html">[Gtk-sharp-list] Gtk#DataBindings v2.0 rc1 released
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9813">[ date ]</a>
              <a href="thread.html#9813">[ thread ]</a>
              <a href="subject.html#9813">[ subject ]</a>
              <a href="author.html#9813">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hey Matjaz,

first I want to apologize for the tone of my initial e-mail. Sorry, I 
really didn't mean to offend you in any way.

Some comments below.

Matja&#382; Miheli&#269; wrote:
&gt;&gt;<i> Christian has been writing an IListStore for his project and has
</I>&gt;&gt;<i> approached me about possibly adding it to gtk-sharp.  One option I'm
</I>&gt;&gt;<i> considering is adding an IList property to TreeViews which would utilize an internal treemodel implementation such as christian's to easily add
</I>&gt;&gt;<i> data to a view.  
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> yeah, I never said I'd mind that. I just think that TreeView which
</I>&gt;<i> exposes 3 different ways to introduce list would be confusing 
</I>&gt;<i> Model+gtk-sharpDataSource+assemblyDataSource
</I>&gt;<i>   
</I>I agree. However, the alternative would be to expose the IList model. We 
decided not to follow that approach since it would make the API less 
user-friendly. Instead of constructing a TreeView directly with the 
IList as argument, the user would have to create the model and an 
adapter for the model:

new TreeView (new TreeModelAdapter (new IListStore (my_list))); uggh.
&gt;<i> and lol, that would make my DataBindings (and others) really confusing.
</I>&gt;<i> Current TreeView already has Model and all external databinding
</I>&gt;<i> implementations are using at least DataSource property. I use
</I>&gt;<i> (DataSource and ItemsDataSource) for widgets with lists. DataSource for
</I>&gt;<i> storing results like for example data of the current selection and
</I>&gt;<i> ItemsDataSource as source from which items are taken.
</I>&gt;<i>   
</I>Maybe we could work together and implement something like an &quot;IList&quot; 
property for IList and other tree-model-based widgets which can not only 
deal with ILists, but also with enums and all other types you support in 
Gtk# DataBindings. The method could be declared as &quot;virtual&quot; and you can 
provide your own implementation in your TreeView. It could be something 
like:

public override IList {
       get { [....] }
       set {
             base.IList = list;
             // Do your stuff here, add columns to the tree view, ...
       }
}

That way we the light-weight models could reside in Gtk#.
&gt;<i> Meaning gtk-sharp would hit their users just to introduce this semi
</I>&gt;<i> capability. I doubt this is your wish. If you introduce DataSource into
</I>&gt;<i> treeview this will be exact result. 
</I>You're right that this approach is cannot replace a full-fledged 
databinding library. Nevertheless, I think a model for ILists would be a 
benefit for the community.
Maybe we can split devide the people needing IList support into 3 groups:

Developer A only wants to display IList data, such as an array, in a 
TreeView. He will be great if there's a need TreeModel ctor taking an 
IList. Maybe he needs to know which items have been selected, but not 
much more.

B wants to display a DataViewto the user and allow him to edit the data. 
He will probably use Gtk# DataBindings and the TreeView it provides. He 
will be happy that he does not need to write any additional code with 
everything (auto-generated columns, sorting) being implemented.

C would need the user to edit the data as well. But he wants to have 
more control over the view. That's why he decides not to use Gtk# 
databindings, but instead writes his own TreeView subclass perfectly 
uited to his needs.
&gt;<i> I for example don't even care if you
</I>&gt;<i> introduce this as long as there is clean TreeView accessible for
</I>&gt;<i> inheriting or inherited class is used for this. This way simple
</I>&gt;<i> databinding and real databinding can coexist without single problem. You
</I>&gt;<i> could do this in either way of these:
</I>&gt;<i> - Make BaseTreeView (pure gtk TreeView) for people like me and then you
</I>&gt;<i> can do with TreeView anything you like. As long as this is not
</I>&gt;<i> introduced as backport (backport would break api)
</I>&gt;<i>   
</I>I don't think something like BaseTreeView would really be necessary. It 
is something I would like to avoid.
&gt;<i> - Leave TreeView as it is in gtk and provide some ModelTreeView (or
</I>&gt;<i> whatever) and do databinding functionality there, this would pose no
</I>&gt;<i> problem even in backport
</I>&gt;<i>   
</I>No, this &quot;ModeltreeView&quot; would have nearly the same functionality as 
TreeView. We do not intend to create a 2nd GridView/DataGrid, just a 
minimal solution that can be extended by
- the application developer (type A,C);
- Maybe Gtk# DataBindings (as suggested in the comment about the IList 
property above)

And BTW, we have decided against backporting that functionality to 2.12. 
It will most likely be released with Gtk# 3.

&gt;<i> - move databinding in some other assembly like everyone else (which
</I>&gt;<i> would probably be best). Usually people tend to use the first solution
</I>&gt;<i> they find and it would be shame that semi solution would eat other
</I>&gt;<i> solutions just by having the advantage of being preinstalled. think of
</I>&gt;<i> IE and windows.
</I>&gt;<i>   
</I>As Mike said, we don't intend to provide a data binding API in Gtk#. The 
only thing we consider is implementing IList functionality as that would 
help users who don't need a full data binding solution (type A) or who 
want to write their own stuff (type C).
&gt;<i>   
</I>&gt;&gt;<i> We could also choose to expose a public TreeModel implementation in
</I>&gt;&gt;<i> gtk-dotnet.dll or an external library such as Stephane's gtk-sharp-beans project, perhaps, if he'd be willing to accept it.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Much better solution as many people are counting on gtk-sharp API
</I>&gt;<i> stability. I know I am.
</I>&gt;<i>   
</I>The IList API is not buggy and its trivial as well. I don't think that 
we should put this into a 3rd party assembly as the current approach is 
lightweight, minimal and will help a lot of people.
&gt;<i>   
</I>&gt;&gt;<i> Maybe the best way to get an IList into TreeView is to simply implement the interface on ListStore itself, though.
</I>&gt;&gt;<i>     
</I>I doubt this will be useful. The ListStore approach is much more limited 
as it won't work if the list is created by a method outside of your 
application. Besides, it would require me to rewrite the whole code for 
a feature that nobody will use.
&gt;&gt;&gt;<i> Same bad choice as it was when you corrected EmitRowsReordered api
</I>&gt;&gt;&gt;<i> correction in 2.12.9 without providing empty method as Obsolete for
</I>&gt;&gt;&gt;<i> compatibility reasons. That way compilation and execution suddenly
</I>&gt;&gt;&gt;<i> became broken.
</I>&gt;<i>
</I>&gt;<i> lol, it only was usable with Zero, where it exposed ** list completely
</I>&gt;<i> changed **. And all my applications broke because of that after update.
</I>&gt;<i> even few users of my lib also complained about the same problem.
</I>&gt;<i>   
</I>I didn't think know that the old method would work in any case. The zero 
thing isn't documented anywhere.
&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> It would be nicer if you'd provide something like 
</I>&gt;<i>
</I>&gt;<i> [Obsolete (&quot;Wrong implementation&quot;)]
</I>&gt;<i> oldResult NameOfTheBrokenMethod (... old parameters ...)
</I>&gt;<i> {
</I>&gt;<i>         Console.WriteLine (&quot;Fix this for this and that reason&quot;);
</I>&gt;<i> }
</I>&gt;<i>   
</I>We certainly would have done that if we knew that the old signature was 
usable in that case.

Christian
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009810.html">[Gtk-sharp-list] Gtk#DataBindings v2.0 rc1 released
</A></li>
	<LI>Next message: <A HREF="009814.html">[Gtk-sharp-list] Gtk#DataBindings v2.0 rc1 released
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9813">[ date ]</a>
              <a href="thread.html#9813">[ thread ]</a>
              <a href="subject.html#9813">[ subject ]</a>
              <a href="author.html#9813">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/gtk-sharp-list">More information about the Gtk-sharp-list
mailing list</a><br>
</body></html>
