<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Glade-users] Error code
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:vavaux%40ulb.ac.be">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000632.html">
   <LINK REL="Next"  HREF="000624.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Glade-users] Error code
   </H1>
    <B>Valery Avaux
    </B> 
    <A HREF="mailto:vavaux%40ulb.ac.be"
       TITLE="[Glade-users] Error code">vavaux@ulb.ac.be
       </A><BR>
    <I>Fri, 06 Apr 2001 01:55:37 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="000632.html">[Glade-users] Drawing Area
</A></li>
        <LI> Next message: <A HREF="000624.html">[Glade-users] How to create a C++ code using gladel?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#623">[ date ]</a>
              <a href="thread.html#623">[ thread ]</a>
              <a href="subject.html#623">[ subject ]</a>
              <a href="author.html#623">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>hello,

i'got trouble with an error code while running my own apps generated by
Glade. Everything worked fine until I programmed a drawing area inside
the main window. Here are the error codes:

Gdk-CRITICAL **: file gdkgc.c: line 456 (gdk_gc_set_foreground):
assertion 'gc != NULL' failed.
Gdk-CRITICAL **: file gdkdraw.c: line 89 (gdk_draw_rectangle) :
assertion 'drawable != NULL failed.
Gdk-CRITICAL **: file gdkdraw.c: line 380 (gdk_drw_pixmap) assertion
'src != NULL' failed

Here is the code I used It's this only file where the drawing area was
programmed and no compiling errors were returned. If anybody could help
me to see what wrong, it would be very nice

Thanks a lot

Valery Avaux

/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include &lt;config.h&gt;
#endif

#include &lt;gtk/gtk.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;interface.h&quot;
#include &quot;support.h&quot;
#include &quot;callbacks.h&quot; 
#include &lt;gdk/gdk.h&gt;

/* variables globales du programme */
  int matrice[102][102][102],matrice2[102][102][102];
  long int hamilt1;
  long int nbsweep = 10000;
  int nbflip = 10;
  int genre = 1;
  long int interaction = 0;
  long int champ = 0;
  int tx = 10;
  int ty = 10;
  int tz = 10;
  float temp = 50.0;
  float field =0.; 
  GtkWidget *window1;

 	GtkWidget *area;
GdkPixmap *pixmap = NULL;	/* offscreen drawable */
GdkGC *gc = NULL;
GdkColor blue;
GdkColor red;

void allocate_colors(GtkWidget *);
void repaint(GtkWidget *);
int  configure_event(GtkWidget *, GdkEventConfigure *);
int  expose_event(GtkWidget *, GdkEventExpose *);

int
main (int argc, char *argv[])
{
  GtkWidget *temper;
  GtkWidget *magnfield;
  GtkWidget *kind;


#ifdef ENABLE_NLS
  bindtextdomain (PACKAGE, PACKAGE_LOCALE_DIR);
  textdomain (PACKAGE);
#endif 

  gtk_set_locale ();
  gtk_init (&amp;argc, &amp;argv);

  add_pixmap_directory (PACKAGE_DATA_DIR &quot;/pixmaps&quot;);
  add_pixmap_directory (PACKAGE_SOURCE_DIR &quot;/pixmaps&quot;);

  initmat();

  window1 = create_window1 ();
  gtk_widget_show (window1);

  temper = lookup_widget (window1, &quot;tempsc&quot;);
  magnfield = lookup_widget (window1, &quot;hscale2&quot;);
  kind = lookup_widget (window1, &quot;combo1&quot;);
  area = lookup_widget (window1, &quot;drawingarea1&quot;);

  gtk_signal_connect (GTK_OBJECT (GTK_RANGE(temper) -&gt; adjustment),
&quot;value_changed&quot;, GTK_SIGNAL_FUNC ( on_tempsc_value_changed), temper);
  gtk_signal_connect (GTK_OBJECT (GTK_RANGE(magnfield) -&gt; adjustment),
&quot;value_changed&quot;, GTK_SIGNAL_FUNC (on_hscale2_value_changed),magnfield);
  gtk_signal_connect (GTK_OBJECT (GTK_COMBO(kind)-&gt; entry),&quot;activate&quot;,
GTK_SIGNAL_FUNC
  (on_combo_entry1_changed),NULL);
	gtk_signal_connect(GTK_OBJECT(area), &quot;expose_event&quot;,
	                   (GtkSignalFunc) expose_event, NULL);
	gtk_signal_connect(GTK_OBJECT(area), &quot;configure_event&quot;,
	                   (GtkSignalFunc) configure_event, NULL);

	repaint((GtkWidget *) area);
  gtk_main ();
  return 0;
}

/*
 *  init_colors  -  initialize the red and blue global variables
 */

void init_colors(GtkWidget *area)
{
	GdkColormap *colormap;

	colormap = gtk_widget_get_colormap(area);
	if (!colormap)
		exit(1);

	blue.red   = 0;
	blue.green = 0;
	blue.blue  = 0xff * 0x100;
	gdk_colormap_alloc_color(colormap, &amp;blue, FALSE, TRUE);

	red.red   = 0xff * 0x100;
	red.green = 0;
	red.blue  = 0;
	gdk_colormap_alloc_color(colormap, &amp;red, FALSE, TRUE);
}


/*
 *  repaint  -  redraws the contents of the matrix onto the
 *              offscreen drawable, and then copies that onto
 *              the drawing area
 */

void repaint(GtkWidget *area)
{
	int i, j;
	GdkColor *color;

	/*
	 * update the offscreen drawable
	 */

	for (i = 0; i &lt; tx; i++)
		for (j = 0; j &lt; ty; j++) {
			color = (matrice[i][j][4] == 1) ? &amp;red : &amp;blue;
			gdk_gc_set_foreground(gc, color);
			gdk_draw_rectangle(pixmap, gc, TRUE,
			                   i * 4, j * 4, 4, 4);
		}

	/*
	 * copy the offscreen drawable to the screen
	 */

	gdk_draw_pixmap( area-&gt;window,
	                 area-&gt;style-&gt;fg_gc[GTK_WIDGET_STATE(area)],
	                 pixmap, 0, 0, 0, 0,
	                 area-&gt;allocation.width, area-&gt;allocation.height );
}



/*
 *  configure_event  - called when the window is resized (and also the
 *                     when it is first created)
 *                   - creates the new backing pixmap of the appropriate
 *                     size, copies a white rectangle onto it as the
 *                     background, and calls repaint to draw the matrix
 */

int configure_event(GtkWidget *widget, GdkEventConfigure *event)
{
	if (!gc) {

		/*
		 *  This code is executed on the first configure event only,
		 *  i.e. when the window for the drawing area is created.
		 *  We create a new GC and allocate the colors we will use.
		 */
		gc = gdk_gc_new(widget-&gt;window);
		init_colors(widget);
	}

	if (pixmap)
		gdk_pixmap_unref(pixmap);

	pixmap = gdk_pixmap_new( widget-&gt;window,
	                         widget-&gt;allocation.width,
	                         widget-&gt;allocation.height,
	                         -1 );
	gdk_draw_rectangle( pixmap,
	                    widget-&gt;style-&gt;white_gc,
	                    TRUE, 0, 0,
	                    widget-&gt;allocation.width,
	                    widget-&gt;allocation.height );
	repaint(widget);
	return FALSE;
}




/*
 *  expose_event  -  called when the window is exposed to the viewer,
 *                   or the gdk_widget_draw routine is called
 *                -  copies the background pixmap to the window
 */

int expose_event(GtkWidget *widget, GdkEventExpose *event)
{
	gdk_draw_pixmap( widget-&gt;window,
	                 widget-&gt;style-&gt;fg_gc[GTK_WIDGET_STATE(widget)],
	                 pixmap,
	                 event-&gt;area.x, event-&gt;area.y,
	                 event-&gt;area.x, event-&gt;area.y,
	                 event-&gt;area.width, event-&gt;area.height );
	return FALSE;
}


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000632.html">[Glade-users] Drawing Area
</A></li>
	<LI> Next message: <A HREF="000624.html">[Glade-users] How to create a C++ code using gladel?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#623">[ date ]</a>
              <a href="thread.html#623">[ thread ]</a>
              <a href="subject.html#623">[ subject ]</a>
              <a href="author.html#623">[ author ]</a>
         </LI>
       </UL>
</body></html>
