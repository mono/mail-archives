<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Tao-list] Re: Using GLSL-Shaders with TAO
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:tao-list%40lists.ximian.com?Subject=%5BTao-list%5D%20Re%3A%20Using%20GLSL-Shaders%20with%20TAO&In-Reply-To=405468222%40web.de">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000283.html">
   <LINK REL="Next"  HREF="000285.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tao-list] Re: Using GLSL-Shaders with TAO</H1>
    <B>Dennis Wagner</B> 
    <A HREF="mailto:tao-list%40lists.ximian.com?Subject=%5BTao-list%5D%20Re%3A%20Using%20GLSL-Shaders%20with%20TAO&In-Reply-To=405468222%40web.de"
       TITLE="[Tao-list] Re: Using GLSL-Shaders with TAO">wagner at Spheron.com
       </A><BR>
    <I>Tue Dec 13 15:57:37 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000283.html">[Tao-list] Re: Using GLSL-Shaders with TAO
</A></li>
        <LI>Next message: <A HREF="000285.html">[Tao-list] whacky quaternions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#284">[ date ]</a>
              <a href="thread.html#284">[ thread ]</a>
              <a href="subject.html#284">[ subject ]</a>
              <a href="author.html#284">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Stefan!

Thanks for your code. In the meantime I was able to get my code working. 
I found that most of the OpenGL2.0-Methods seem to be quite allergic 
against all my effords to get them running. I found that at least the 
method glGetInfoLog isn't working at all. I tried all 8 overloaded 
variations and used every possible variation of 
attributes-instantiation. Every call to this methods produces an &quot;the 
handle is invalid&quot;-exception. Anyway. Switching back to the good old 
ARB-extensions helped out nearly everywhere. I came up with something 
like this (I edited it slightly to be more general, left out 
project-dependent stuff):


        /// &lt;summary&gt;
        /// This encapsulates an GLSL-Shader
        /// &lt;/summary&gt;
        public abstract class Shader {

            public const int VERTEX_SHADER = 1;
            public const int FRAGMENT_SHADER = 2;

            public Shader( string Source ) {

                this.Start();

                this.source_ = Source;

            }

            public Shader( FileInfo Source ) {

                this.Start();

                try {

                    StreamReader fr = Source.OpenText();
                    this.source_ = fr.ReadToEnd();

                }
                catch( System.Exception e ) {

                    throw new Exception( &quot;Unable to load Shader from 
File '&quot; + this.source_.Substring( 0, 15 ) + &quot;'&quot;, e );

                }

            }

            private void Start() {

                this.source_ = null;
                this.id_ = 0;
                this.inited_ = false;
                this.attached_ = false;
                this.compiled_ = false;

            }

            public virtual void InitShader() {

                try {

                    this.initShader( 0 );

                }
                catch( System.Exception e ) {

                    throw new Exception( &quot;Unable to init Shader from 
Source '&quot; + this.source_.Substring( 0, 15 ) + &quot;'&quot;, e );

                }

            }

            protected virtual void initShader( int ShaderType ) {

                try {

                    // This is left in to show how to use the function 
returning just a IntPtr, not a string at all. Maybe someone wondered... 
At least I did ;-)
                    IntPtr pVersion = Gl.glGetString( Gl.GL_VERSION );
                    string version = 
System.Runtime.InteropServices.Marshal.PtrToStringAnsi( pVersion );

                    // First create the Shader-Object (OpenGL-side) to 
hold the data
                    if( ShaderType == VERTEX_SHADER )
                        this.id_ = (uint)Gl.glCreateShaderObjectARB( 
Gl.GL_VERTEX_SHADER_ARB );
                    if( ShaderType == FRAGMENT_SHADER )
                        this.id_ = (uint)Gl.glCreateShaderObjectARB( 
Gl.GL_FRAGMENT_SHADER_ARB );

#if CHECK_GL_ERRORS
                    Shader.CheckGlError();
#endif

                    // Ok, first we clean up a bit as we found that the 
Windows- \r\n-Sequence
                    // could be quite annoying...
                    this.source_ = this.source_.Replace( &quot;\r&quot;, &quot;&quot; );

                    // Then send the source to the GL-Shader-Object
                    Gl.glShaderSourceARB( (uint)this.id_, 1, ref 
this.source_, new int[1] { this.source_.Length } );

#if CHECK_GL_ERRORS
                    Shader.CheckGlError();
#endif

                    // Now that we've added the source we might want to 
compile it
                    Gl.glCompileShader( this.id_ );

#if CHECK_GL_ERRORS
                    Shader.CheckGlError();
#endif

                    int value = 0;
                    Gl.glGetShaderiv( this.id_, Gl.GL_COMPILE_STATUS, 
out value );

                    this.compiled_ = ( value == 1 );

#if CHECK_GL_ERRORS
                    Shader.CheckGlError();
#endif

                    if( !this.compiled_ ) {

                        Gl.glGetShaderiv( (uint)this.id_, 
Gl.GL_INFO_LOG_LENGTH, out value );

#if CHECK_GL_ERRORS
                        Shader.CheckGlError();
#endif

                        int int_value = 0;
                        string string_value = new string( (char)0, value );

                        System.IntPtr pString = 
System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi( string_value );

                        Gl.glGetInfoLogARB( (int)this.id_, value, out 
int_value, pString );

                        string result = 
System.Runtime.InteropServices.Marshal.PtrToStringAnsi( pString );

                        if( result.Length &gt; 0 )
                            MessageBox.Show( result, &quot;InfoLog&quot; );

#if CHECK_GL_ERRORS
                        Shader.CheckGlError();
#endif

                        this.inited_ = true;

                    }

                }
                catch( System.Exception ex ) {

                    throw new System.Exception( &quot;Could not init Shader &quot; 
+ this.ToString(), ex );

                }

            }

            // This is only for debugging purposes (I set a breakpoint 
on the while)
            public static void CheckGlError() {

                int errorCode = Gl.GL_NO_ERROR + 1;
                string currentError = &quot;&quot;;
                while( ( errorCode = Gl.glGetError() ) != Gl.GL_NO_ERROR )
                    currentError = Glu.gluErrorString( errorCode );

            }

            public bool Inited { get{ return this.inited_; } }
            public bool Attached { get{ return this.attached_; } set{ 
this.attached_ = value; } }
            public uint Id { get{ return this.id_; } }
            public bool Compiled { get{ return this.compiled_; } }

            protected string source_;
            protected bool inited_;
            protected bool attached_;
            protected uint id_;
            protected bool compiled_;

        };

        public class VertexShader : Shader {

            public VertexShader( string Source ) : base( Source ) {}
            public VertexShader( FileInfo Source ) : base( Source ) {}

            public override void InitShader() {

                try {

                    this.initShader( Shader.VERTEX_SHADER );

                }
                catch( System.Exception e ) {

                    throw new Exception( &quot;Unable to init Vertex-Shader 
from Source '&quot; + this.source_.Substring( 0, 15 ) + &quot;'&quot;, e );

                }

            }

            public override string ToString() {

                string result = &quot;VertexShader [&quot;;
                if( this.source_ != null )
                    if( this.source_.Length &gt; 0 )
                        result += &quot;'&quot; + this.source_ + &quot;'&quot;;
                result += &quot;]&quot;;
                return result;

            }

        };

        public class FragmentShader : Shader {

            public FragmentShader( string Source ) : base( Source ) {}
            public FragmentShader( FileInfo Source ) : base( Source ) {}

            public override void InitShader() {

                try {

                    this.initShader( Shader.FRAGMENT_SHADER );

                }
                catch( System.Exception e ) {

                    throw new Exception( &quot;Unable to init Fragment-Shader 
from Source '&quot; + this.source_.Substring( 0, 15 ) + &quot;'&quot;, e );

                }

            }

            public override string ToString() {

                string result = &quot;FragmentShader [&quot;;
                if( this.source_ != null )
                    if( this.source_.Length &gt; 0 )
                        result += &quot;'&quot; + this.source_ + &quot;'&quot;;
                result += &quot;]&quot;;
                return result;

            }

        };

        public class GLSLShader {

            public GLSLShader( VertexShader vertexShader, FragmentShader 
fragmentShader ) {

                this.id_ = 0;
                this.linked_ = false;

                this.vertexShader_ = vertexShader;
                this.fragmentShader_ = fragmentShader;

                if( this.vertexShader_ != null )
                    this.vertexShader_.InitShader();
                if( this.fragmentShader_ != null )
                    this.fragmentShader_.InitShader();

                this.init();

            }

            protected virtual void init() {

                string vertexLog = &quot;&quot;;
                string fragmentLog = &quot;&quot;;
                string linkLog = &quot;&quot;;

                try {

                    this.id_ = (uint)Gl.glCreateProgram();

                    if( this.vertexShader_ != null ) {

                        if( this.vertexShader_.Compiled ) {

                            Gl.glAttachObjectARB( this.id_, 
this.vertexShader_.Id );

                        }

                    }

                    if( this.fragmentShader_ != null ) {

                        if( this.fragmentShader_.Compiled ) {

                            Gl.glAttachObjectARB( this.id_, 
this.fragmentShader_.Id );

                        }

                    }

                    int[] attachedShaders = new int[2];
                    int count = 0;
                    Gl.glGetAttachedShaders( (int)this.id_, 2, out 
count, attachedShaders );

                    for( int i = 0; i &lt; count; i++ ) {

                        if( this.vertexShader_ != null )
                            if( this.vertexShader_.Id == 
attachedShaders[i] )
                                this.vertexShader_.Attached = true;
                        if( this.fragmentShader_ != null )
                            if( this.fragmentShader_.Id == 
attachedShaders[i] )
                                this.fragmentShader_.Attached = true;

                    }

                    if( this.vertexShader_.Attached || 
this.fragmentShader_.Attached ) {

                        Gl.glLinkProgramARB( this.id_ );

#if CHECK_GL_ERRORS
                        Shader.CheckGlError();
#endif

                        int value = 0;
                        Gl.glGetObjectParameterivARB( this.id_, 
Gl.GL_OBJECT_LINK_STATUS_ARB, out value );

                        this.linked_ = ( value == 1 );

#if CHECK_GL_ERRORS
                        Shader.CheckGlError();
#endif

                        if( !this.linked_ ) {

                            Gl.glGetObjectParameterivARB( this.id_, 
Gl.GL_OBJECT_INFO_LOG_LENGTH_ARB, out value );

#if CHECK_GL_ERRORS
                            Shader.CheckGlError();
#endif

                            int int_value = 0;
                            string string_value = new string( (char)0, 
value );
                            System.IntPtr pString = 
System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi( string_value );

                            Gl.glGetInfoLogARB( (int)this.id_, value, 
out int_value, pString );

                            string result = 
System.Runtime.InteropServices.Marshal.PtrToStringAnsi( pString );

                            if( result.Length &gt; 0 )
                                MessageBox.Show( result, &quot;InfoLog&quot; );

                            throw new System.Exception( &quot;Could not link 
Shader-Program!&quot; );

                        }

                    }
                    else
                        throw new System.Exception( &quot;No attached Shaders&quot; );

                }
                catch( System.Exception ex ) {

                    string message = &quot;Could not create Shader-Program 
from Shaders&quot;;
                    if( this.vertexShader_ != null )
                        message += &quot;\n\n&quot; + this.vertexShader_.ToString();
                    if( this.fragmentShader_ != null )
                        message += &quot;\n\n&quot; + this.fragmentShader_.ToString();
                    if( vertexLog.Length &gt; 0 )
                        message += &quot;\n\n&quot; + vertexLog;
                    if( fragmentLog.Length &gt; 0 )
                        message += &quot;\n\n&quot; + fragmentLog;
                    if( linkLog.Length &gt; 0 )
                        message += &quot;\n\n&quot; + linkLog;
                    throw new Exception( message, ex );

                }

            }

            public bool Use() {

                if( this.linked_ )
                    Gl.glUseProgramObjectARB( this.id_ );

                return this.linked_;

            }

            public static void FixedFunction() {

                Gl.glUseProgramObjectARB( 0 );

            }

            private VertexShader vertexShader_;
            private FragmentShader fragmentShader_;

            private uint id_;
            private bool linked_;

        };

Ok, now, this &quot;little&quot; piece of code works for me now. As you might see 
I haven't introduced any methods to set params on the current shader. 
You might guess that this is about to come, but for my basic 
per-pixel-lighting-shaders I only use built-in state that is set the 
&quot;classical&quot; way by  glVertex, glNormal and glLightfv... You're free to 
add your own.
If you want to use this class you do the following:

                // Don't forget this or you will get some nasty 
exceptions ;-)
                Tao.OpenGl.GlExtensionLoader.LoadAllExtensions();
                try {

                    this.phong = new GLSLShader( new VertexShader( new 
FileInfo( @&quot;.\phong_vertex.glsl&quot; ) ), new FragmentShader( new FileInfo( 
@&quot;.\phong_fragment.glsl&quot; ) ) );

                }
                catch( System.Exception ex ) {

                    MessageBox.Show( ex.Message, &quot;Error...&quot;, 
MessageBoxButtons.OK, MessageBoxIcon.Error );

                }

Now, that's it. It took me way longer than I expected (especially as 
lot's of the code is a transition from C++-classes) but finally it 
works. And it produces some results like &quot;did the shader compile and if 
not why&quot;. Of course, there is much to come...

Thanks again for posting code, Stefan!

Greets...


...Dennis

Stefan Stammberger schrieb:

&gt;<i>Hi!
</I>&gt;<i>
</I>&gt;<i>this is the shader class I'm using. It works, but i didn't do any extensive testing yet.
</I>&gt;<i>I'm still in the process of writing other parts of my engine. And while looking through the code
</I>&gt;<i>I've just seen I'm not doing any testing of return values but I know it works.
</I>&gt;<i>
</I>&gt;<i>	public class Shader
</I>&gt;<i>	{
</I>&gt;<i>		int mHandleVert;
</I>&gt;<i>		int mHandleFrag;
</I>&gt;<i>		int mHandleProg;
</I>&gt;<i>
</I>&gt;<i>		public Shader()
</I>&gt;<i>		{
</I>&gt;<i>			mHandleVert = -1;
</I>&gt;<i>			mHandleFrag = -1;
</I>&gt;<i>			mHandleProg = -1;
</I>&gt;<i>		}
</I>&gt;<i>
</I>&gt;<i>		public int LoadShader(string fragFile, string vertFile)
</I>&gt;<i>		{
</I>&gt;<i>			VirtualFileSystem vfs = VirtualFileSystem.GetInstance();
</I>&gt;<i>			
</I>&gt;<i>			StreamReader vs = vfs.OpenTextFile(vertFile);
</I>&gt;<i>			string vertexsource = vs.ReadToEnd();
</I>&gt;<i>			vs.Close();
</I>&gt;<i>
</I>&gt;<i>			vs = vfs.OpenTextFile(fragFile);
</I>&gt;<i>			string fragsource = vs.ReadToEnd();
</I>&gt;<i>			vs.Close();
</I>&gt;<i>
</I>&gt;<i>			mHandleVert = Gl.glCreateShaderObjectARB(Gl.GL_VERTEX_SHADER_ARB);
</I>&gt;<i>			mHandleFrag = Gl.glCreateShaderObjectARB(Gl.GL_FRAGMENT_SHADER_ARB);
</I>&gt;<i>
</I>&gt;<i>			Gl.glShaderSourceARB(mHandleVert, 1, ref vertexsource, null);
</I>&gt;<i>			Gl.glShaderSourceARB(mHandleFrag, 1, ref fragsource, null);
</I>&gt;<i>
</I>&gt;<i>			Gl.glCompileShaderARB(mHandleVert);
</I>&gt;<i>			Gl.glCompileShaderARB(mHandleFrag);
</I>&gt;<i>
</I>&gt;<i>			mHandleProg = Gl.glCreateProgramObjectARB();
</I>&gt;<i>			Gl.glAttachObjectARB(mHandleProg, mHandleVert);
</I>&gt;<i>			Gl.glAttachObjectARB(mHandleProg, mHandleFrag);
</I>&gt;<i>
</I>&gt;<i>			Gl.glLinkProgramARB(mHandleProg);
</I>&gt;<i>
</I>&gt;<i>			return mHandleProg;
</I>&gt;<i>		}
</I>&gt;<i>	}
</I>&gt;<i>
</I>&gt;<i>And this is how I use the shader then:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Gl.glUseProgramObjectARB(shaderProgHandle); // the shader prog you want to use ( as returned by Shader.LoadShader(...) )
</I>&gt;<i>Gl.glUniform4fARB(Gl.glGetUniformLocationARB(shaderProgHandle, &quot;BaseColor&quot;), r , g , b, 1.0f); // pass the information to the shader you might want to use
</I>&gt;<i>
</I>&gt;<i>// draw your stuff  using the shader here
</I>&gt;<i>
</I>&gt;<i>Gl.glUseProgramObjectARB(0); // disable the shader usage
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>I hope this helps to solve your problems :)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Stefan
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Dennis Wagner &lt;<A HREF="http://galactus.ximian.com/mailman/listinfo/tao-list">wagner at Spheron.com</A>&gt; schrieb am 13.12.05 12:25:52:
</I>&gt;<i>
</I>&gt;<i>Hi everyone!
</I>&gt;<i>
</I>&gt;<i>I was programming OpenGL for quite a while now in C and C++ when I had 
</I>&gt;<i>the need to look into some of the &quot;newer&quot; language-bindings. First I 
</I>&gt;<i>worked quite a lot with jogl which produced quite good results (besides 
</I>&gt;<i>the lame fps). Now I focussed on .NET and C# for a new project and 
</I>&gt;<i>therefore I came across TAO. I downloaded it and started writing some 
</I>&gt;<i>basic code like a viewer for obj-files. But then again I was bored by 
</I>&gt;<i>OpenGL messing up the lighting with per-vertex-lighting all the time so 
</I>&gt;<i>I decided to include at least some basic per-pixel-lighting. I took the 
</I>&gt;<i>glsl-shaders I had in store. They work like a charm for me under C and 
</I>&gt;<i>C++. I checked them on the graphics card I'm using at the moment (ATI 
</I>&gt;<i>Mobility Radeon X600) using my own C-code and ATI's RenderMonkey. They 
</I>&gt;<i>work on the given machine. But I run into some troubles when I try to 
</I>&gt;<i>use those shaders in C#. Those troubles get even deeper the more I try 
</I>&gt;<i>to find out what's going wrong :(
</I>&gt;<i>As I have seen on the mailing-list-archives there have been some 
</I>&gt;<i>questions about different aspects of what my problem is earlier but I 
</I>&gt;<i>found none of the answers helping me out. So here's my question:
</I>&gt;<i>Has anyone every managed to get a fully working example of glsl running 
</I>&gt;<i>with TAO? I did not find anything using those functions in the source of 
</I>&gt;<i>the examples nor on the internet (using google for hours now).
</I>&gt;<i>It would be great if someone had some lines to contribute that really 
</I>&gt;<i>work. My problems start just after a call to &quot;this.id = 
</I>&gt;<i>Gl.glCreateShader( Gl.GL_VERTEX_SHADER );&quot;.
</I>&gt;<i>I store the return value in a class-member. I found that value being 
</I>&gt;<i>quite weird when I used int so I looked up glext.h again and as I 
</I>&gt;<i>expected I found GLHandle to be declared as unsigned int. So I switched 
</I>&gt;<i>the local member to uint and casted the int-return of glCreateShader 
</I>&gt;<i>apropriatly. That gave the same weird value, just being non-negative. 
</I>&gt;<i>When I tried a bit around and changed the member to type unsigned short 
</I>&gt;<i>I finally got the value &quot;1&quot; that I expected from the beginning (I know, 
</I>&gt;<i>it needn't be &quot;1&quot; always..). But then again passing that value to any 
</I>&gt;<i>function later always generates INVALID_VALUE-errors that are showing 
</I>&gt;<i>the handle to be invalid according to the documentation of the 
</I>&gt;<i>OpenGL-methods. I fiddled around a bit with different casts and stuff 
</I>&gt;<i>but it hasn't produced some good results yet.
</I>&gt;<i>While trying some different htings I came over glGetString returning a 
</I>&gt;<i>System.IntPtr. I don't have any clue how to get the string when I have 
</I>&gt;<i>just a pointer in C#. Also specifying the shader-code seems to be not 
</I>&gt;<i>that easy. I tried different versions, from using only &quot;old-style&quot; 
</I>&gt;<i>ARB-methods and constants to using completly OpenGL2.0-stuff to even 
</I>&gt;<i>mixing them (although I don't think this is wise after all). Right now I 
</I>&gt;<i>am very close to giving up but some little voice inside my head is 
</I>&gt;<i>whispering that can't be...
</I>&gt;<i>So, please help a drowning man...
</I>&gt;<i>
</I>&gt;<i>greets
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>dennis
</I>&gt;<i>
</I>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000283.html">[Tao-list] Re: Using GLSL-Shaders with TAO
</A></li>
	<LI>Next message: <A HREF="000285.html">[Tao-list] whacky quaternions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#284">[ date ]</a>
              <a href="thread.html#284">[ thread ]</a>
              <a href="subject.html#284">[ subject ]</a>
              <a href="author.html#284">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://galactus.ximian.com/mailman/listinfo/tao-list">More information about the Tao-list
mailing list</a><br>
</body></html>
