<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Tao-list] Glfw Pong Example
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:tao-list%40lists.ximian.com?Subject=%5BTao-list%5D%20Glfw%20Pong%20Example&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000263.html">
   <LINK REL="Next"  HREF="000267.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tao-list] Glfw Pong Example</H1>
    <B>Simon</B> 
    <A HREF="mailto:tao-list%40lists.ximian.com?Subject=%5BTao-list%5D%20Glfw%20Pong%20Example&In-Reply-To="
       TITLE="[Tao-list] Glfw Pong Example">the-real-sim at gmx.de
       </A><BR>
    <I>Fri Nov 25 16:34:44 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000263.html">[Tao-list] FW: Memory usage of Vertex Buffer Objects
</A></li>
        <LI>Next message: <A HREF="000267.html">[Tao-list] Glfw Pong Example
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#264">[ date ]</a>
              <a href="thread.html#264">[ thread ]</a>
              <a href="subject.html#264">[ subject ]</a>
              <a href="author.html#264">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Skipped content of type multipart/alternative-------------- next part --------------
/*
 * Created by SharpDevelop.
 * User: KarlWie
 * Date: 09.11.2005
 * Time: 19:20
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */

using System;
using Tao.Glfw;
using Tao.OpenGl;

namespace TaoPong
{
	/// &lt;summary&gt;
	/// Description of TaoPong.
	/// &lt;/summary&gt;
	public class TaoPong
	{
	
		#region fields

		// Screen resolution
		public static int width = 640;
		public static int height = 480;
		
		// Player size (units)
		public static float playerSizeX = 0.05f;
		public static float playerSizeY = 0.15f;
		
		// Ball size (units)
		public static float ballSize = 0.02f;

		// Maximum player movement speed (units / second)
		public static float maxSpeed = 1.5f;

		// Player movement acceleration (units / seconds^2)
		public static float acceleration = 4.0f;

		// Player movement deceleration (units / seconds^2)
		public static float deceleration = 2.0f;

		// Ball movement speed (units / second)
		public static float ballSpeed = 0.4f;

		// Menu options
		public enum MenuOption{
			None,Play,Quit
		}
		
		public enum GameEvent{
			NobodyWins,
			Player1Wins,
			Player2Wins
		}

		public enum Winner{
			Nobody,
			Player1,
			Player2
		}

		public static int winner;
		
		// Camera positions
		public enum CameraPosition{
			Classic,
			Above,
			Spectator
		}

		public  static CameraPosition cameraDefault = CameraPosition.Classic;


		//========================================================================
		// Textures
		//========================================================================

		public enum Textures{
			Title,
			Menu,
			Instr,
			Winner1,
			Winner2,
			Field,
			Num_textures
		}

		public static String[] TexName = {&quot;pong3d_title.tga&quot;,
										   &quot;pong3d_menu.tga&quot;,
										   &quot;pong3d_instr.tga&quot;,
										   &quot;pong3d_winner1.tga&quot;,
										   &quot;pong3d_winner2.tga&quot;,
										   &quot;pong3d_field.tga&quot;};

		//========================================================================
		// Global variables
		//========================================================================

		// Frame information
		public static double thisTime, oldTime, dt, startTime;

		// Camera information
		public static CameraPosition cameraPos;

		// Player information
		public struct Player
		{
			public int id;			// Player 1 or Player 2
			public double posY;     // -1.0 to +1.0
			public double speedY;   // -MAX_SPEED to +MAX_SPEED
		}

		public static Player Player1,Player2;

		// Ball information
		public struct Ball
		{
			public double posX, posY;
			public double speedX, speedY;
		}

		public static Ball ball;

		// Lighting configuration
		public static float[] envAmbient;
		public static float[] light1Position;
		public static float[] light1Diffuse;
		public static float[] light1Ambient;

		// Object material properties
		public static float[] Player1Diffuse;
		public static float[] Player1Ambient;
		public static float[] Player2Diffuse;
		public static float[] Player2Ambient;
		public static float[] ballDiffuse;
		public static float[] ballAmbient;
		public static float[] borderDiffuse;
		public static float[] borderAmbient;
		public static float[] floorDiffuse;
		public static float[] floorAmbient;

		// OpenGL texture object IDs
		public static int[] TexId = new int[(int)Textures.Num_textures];

		#endregion fields

        //========================================================================
        // LoadTextures() - Load textures from disk and upload to OpenGL card
        //========================================================================

		public static void LoadTextures()
		{
		    int  i;
		
		    // Generate texture objects
		    Gl.glGenTextures( (int)Textures.Num_textures, TexId );
		
		    // Load textures
		    for(i = 0; i &lt; (int)Textures.Num_textures; i++)
		    {
		        // Select texture object
		        Gl.glBindTexture( Gl.GL_TEXTURE_2D, TexId[ i ] );
		
		        // Set texture parameters
		        Gl.glTexParameteri( Gl.GL_TEXTURE_2D, Gl.GL_TEXTURE_WRAP_S, Gl.GL_REPEAT );
		        Gl.glTexParameteri( Gl.GL_TEXTURE_2D, Gl.GL_TEXTURE_WRAP_T, Gl.GL_REPEAT );
		        Gl.glTexParameteri( Gl.GL_TEXTURE_2D, Gl.GL_TEXTURE_MAG_FILTER, Gl.GL_LINEAR );
		        Gl.glTexParameteri( Gl.GL_TEXTURE_2D, Gl.GL_TEXTURE_MIN_FILTER, Gl.GL_LINEAR );
		
		        // Upload texture from file to texture memory
		        Glfw.glfwLoadTexture2D( TexName[ i ], 0 );
		    }
		}

		//========================================================================
		// DrawImage() - Draw a 2D image as a texture
		//========================================================================

		public static void DrawImage( int texnum, float x1, float x2, float y1, float y2 )
		{
			Gl.glEnable( Gl.GL_TEXTURE_2D );
			Gl.glBindTexture( Gl.GL_TEXTURE_2D, TexId[ texnum ] );
			Gl.glBegin( Gl.GL_QUADS );
			Gl.glTexCoord2f( 0.0f, 1.0f );
			Gl.glVertex2f( x1, y1 );
			Gl.glTexCoord2f( 1.0f, 1.0f );
			Gl.glVertex2f( x2, y1 );
			Gl.glTexCoord2f( 1.0f, 0.0f );
			Gl.glVertex2f( x2, y2 );
			Gl.glTexCoord2f( 0.0f, 0.0f );
			Gl.glVertex2f( x1, y2 );
			Gl.glEnd();
			Gl.glDisable( Gl.GL_TEXTURE_2D );
		}


		//========================================================================
		// GameMenu() - Game menu (returns menu option)
		//========================================================================

		public static MenuOption GameMenu( )
		{
			MenuOption option;

			// Enable sticky keys
			Glfw.glfwEnable( Glfw.GLFW_STICKY_KEYS );

			// Wait for a game menu key to be pressed
			do
			{
				// Get window size
				Glfw.glfwGetWindowSize( out width, out height );

				// Set viewport
				Gl.glViewport( 0, 0, width, height );

				// Clear display
				Gl.glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );
				Gl.glClear( Gl.GL_COLOR_BUFFER_BIT );

				// Setup projection matrix
				Gl.glMatrixMode( Gl.GL_PROJECTION );
				Gl.glLoadIdentity();
				Gl.glOrtho( 0.0f, 1.0f, 1.0f, 0.0f, -1.0f, 1.0f );

				// Setup modelview matrix
				Gl.glMatrixMode( Gl.GL_MODELVIEW );
				Gl.glLoadIdentity();

				// Display title
				Gl.glColor3f( 1.0f, 1.0f, 1.0f );
				DrawImage( (int)Textures.Title, 0.1f, 0.9f, 0.0f, 0.3f );

				// Display menu
				Gl.glColor3f( 1.0f, 1.0f, 0.0f );
				DrawImage( (int)Textures.Menu, 0.38f, 0.62f, 0.35f, 0.5f );

				// Display instructions
				Gl.glColor3f( 0.0f, 1.0f, 1.0f );
				DrawImage( (int)Textures.Instr, 0.32f, 0.68f, 0.65f, 0.85f );

				// Swap buffers
				Glfw.glfwSwapBuffers();

				// Check for keys
				if( Glfw.glfwGetKey( 'Q' ) == Gl.GL_TRUE || Glfw.glfwGetWindowParam( Glfw.GLFW_OPENED ) == Gl.GL_FALSE )
				{
					option = MenuOption.Quit;
				}
				else if( Glfw.glfwGetKey( Glfw.GLFW_KEY_F1 ) == Gl.GL_TRUE )
				{
					option = MenuOption.Play;
				}
				else
				{
					option = MenuOption.None;
				}

				// To avoid horrible busy waiting, sleep for at least 20 ms
				Glfw.glfwSleep( 0.02 );
			}
			while( option == MenuOption.None );

			// Disable sticky keys
			Glfw.glfwDisable( Glfw.GLFW_STICKY_KEYS );

			return option;
		}


		//========================================================================
		// NewGame() - Initialize a new game
		//========================================================================

		public static void NewGame()
		{
			// Frame information
			startTime = thisTime = Glfw.glfwGetTime();

			// Camera information
			cameraPos = cameraDefault;

			// Player 1 information
			Player1.posY   = 0.0;
			Player1.speedY = 0.0;

			// Player 2 information
			Player2.posY   = 0.0;
			Player2.speedY = 0.0;

			// Ball information
			ball.posX = -1.0 + playerSizeX;
			ball.posY = Player1.posY;
			ball.speedX = 1.0;
			ball.speedY = 1.0;
		}

		
		//========================================================================
		// PlayerControl() - Player control
		//========================================================================

		public static void PlayerControl( )
		{
			float[] joy1pos = new float[2];
			float[] joy2pos = new float[2];

			// Get joystick X &amp; Y axis positions
			Glfw.glfwGetJoystickPos( Glfw.GLFW_JOYSTICK_1, out joy1pos[0], 2 );
			Glfw.glfwGetJoystickPos( Glfw.GLFW_JOYSTICK_2, out joy2pos[0], 2 );

			// Player 1 control
			if( Glfw.glfwGetKey( 'A' ) == Gl.GL_TRUE || joy1pos[ 1 ] &gt; 0.2f )
			{
				Player1.speedY += dt * acceleration;
				if( Player1.speedY &gt; maxSpeed )
				{
					Player1.speedY = maxSpeed;
				}
			}
			else if( Glfw.glfwGetKey( 'Y' ) == Gl.GL_TRUE || joy1pos[ 1 ] &lt; -0.2f )
			{
				Player1.speedY -= dt * acceleration;
				if( Player1.speedY &lt; -maxSpeed )
				{
					Player1.speedY = -maxSpeed;
				}
			}
			else
			{
				Player1.speedY /= System.Math.Exp( deceleration * dt );
			}

			// Player 2 control
			if( Glfw.glfwGetKey( 'K' ) == Gl.GL_TRUE || joy2pos[ 1 ] &gt; 0.2f )
			{
				Player2.speedY += dt * acceleration;
				if( Player2.speedY &gt; maxSpeed )
				{
					Player2.speedY = maxSpeed;
				}
			}
			else if( Glfw.glfwGetKey( 'M' ) == Gl.GL_TRUE || joy2pos[ 1 ] &lt; -0.2f )
			{
				Player2.speedY -= dt * acceleration;
				if( Player2.speedY &lt; -maxSpeed )
				{
					Player2.speedY = -maxSpeed;
				}
			}
			else
			{
				Player2.speedY /= System.Math.Exp( deceleration * dt );
			}

			// Update player 1 position
			Player1.posY += dt * Player1.speedY;
			if( Player1.posY &gt; 1.0 - playerSizeY )
			{
				Player1.posY = 1.0 - playerSizeY;
				Player1.speedY = 0.0;
			}
			else if( Player1.posY &lt; -1.0 + playerSizeY )
			{
				Player1.posY = -1.0 + playerSizeY;
				Player1.speedY = 0.0;
			}

			// Update player 2 position
			Player2.posY += dt * Player2.speedY;
			if( Player2.posY &gt; 1.0 - playerSizeY )
			{
				Player2.posY = 1.0 - playerSizeY;
				Player2.speedY = 0.0;
			}
			else if( Player2.posY &lt; -1.0 + playerSizeY )
			{
				Player2.posY = -1.0 + playerSizeY;
				Player2.speedY = 0.0;
			}
		}



		//========================================================================
		// UpdateDisplay() - Draw graphics (all game related OpenGL stuff goes
		// here)
		//========================================================================

		public static void UpdateDisplay( )
		{
			// Get window size
			Glfw.glfwGetWindowSize( out width, out height );

			// Set viewport
			Gl.glViewport( 0, 0, width, height );

			// Clear display
			Gl.glClearColor( 0.02f, 0.02f, 0.02f, 0.0f );
			Gl.glClearDepth( 1.0f );
			Gl.glClear( Gl.GL_COLOR_BUFFER_BIT | Gl.GL_DEPTH_BUFFER_BIT );

			// Setup projection matrix
			Gl.glMatrixMode( Gl.GL_PROJECTION );
			Gl.glLoadIdentity();
			Glu.gluPerspective(
				55.0f,							// Angle of view
				(float)width/(float)height,		// Aspect
				1.0f,							// Near Z
				100.0f							// Far Z
				);

			// Setup modelview matrix
			Gl.glMatrixMode( Gl.GL_MODELVIEW );
			Gl.glLoadIdentity();

			switch( cameraPos )
			{
				default:
				case CameraPosition.Classic:
					Glu.gluLookAt(
						0.0f, 0.0f, 2.5f,
						0.0f, 0.0f, 0.0f,
						0.0f, 1.0f, 0.0f
						);
					break;

				case CameraPosition.Above:
					Glu.gluLookAt(
						0.0f, 0.0f, 2.5f,
						(float)ball.posX, (float)ball.posY, 0.0f,
						0.0f, 1.0f, 0.0f
						);
					break;

				case CameraPosition.Spectator:
					Glu.gluLookAt(
						0.0f, -2.0, 1.2f,
						(float)ball.posX, (float)ball.posY, 0.0f,
						0.0f, 0.0f, 1.0f
						);
					break;
			}

			// Enable depth testing
			Gl.glEnable( Gl.GL_DEPTH_TEST );
			Gl.glDepthFunc( Gl.GL_LEQUAL );

			// Enable lighting
			Gl.glEnable( Gl.GL_LIGHTING );
			Gl.glLightModelfv( Gl.GL_LIGHT_MODEL_AMBIENT, envAmbient );
			Gl.glLightModeli( Gl.GL_LIGHT_MODEL_LOCAL_VIEWER, Gl.GL_TRUE );
			Gl.glLightModeli( Gl.GL_LIGHT_MODEL_TWO_SIDE, Gl.GL_FALSE );
			Gl.glLightfv( Gl.GL_LIGHT1, Gl.GL_POSITION, light1Position );
			Gl.glLightfv( Gl.GL_LIGHT1, Gl.GL_DIFFUSE,  light1Diffuse );
			Gl.glLightfv( Gl.GL_LIGHT1, Gl.GL_AMBIENT,  light1Ambient );
			Gl.glEnable( Gl.GL_LIGHT1 );

			// Front face is counter-clock-wise
			Gl.glFrontFace( Gl.GL_CCW );

			// Enable face culling (not necessary, but speeds up rendering)
			Gl.glCullFace( Gl.GL_BACK );
			Gl.glEnable( Gl.GL_CULL_FACE );

			// Draw Player 1
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_DIFFUSE, Player1Diffuse );
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_AMBIENT, Player1Ambient );
			DrawBox( -1.0f,              (float)Player1.posY-playerSizeY, 0.0f,
				-1.0f+playerSizeX, (float)Player1.posY+playerSizeY, 0.1f );

			// Draw Player 2
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_DIFFUSE, Player2Diffuse );
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_AMBIENT, Player2Ambient );
			DrawBox( 1.0f-playerSizeX, (float)Player2.posY-playerSizeY, 0.0f,
				1.0f,              (float)Player2.posY+playerSizeY, 0.1f );

			// Draw Ball
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_DIFFUSE, ballDiffuse );
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_AMBIENT, ballAmbient );
			DrawBox( (float)ball.posX-ballSize, (float)ball.posY-ballSize, 0.0f,
				(float)ball.posX+ballSize, (float)ball.posY+ballSize, ballSize*2 );

			// Top game field border
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_DIFFUSE, borderDiffuse );
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_AMBIENT, borderAmbient );
			DrawBox( -1.1f, 1.0f, 0.0f,  1.1f, 1.1f, 0.1f );
			// Bottom game field border
			Gl.glColor3f( 0.0f, 0.0f, 0.7f );
			DrawBox( -1.1f, -1.1f, 0.0f,  1.1f, -1.0f, 0.1f );
			// Left game field border
			DrawBox( -1.1f, -1.0f, 0.0f,  -1.0f, 1.0f, 0.1f );
			// Left game field border
			DrawBox( 1.0f, -1.0f, 0.0f,  1.1f, 1.0f, 0.1f );

			// Enable texturing
			Gl.glEnable( Gl.GL_TEXTURE_2D );
			Gl.glBindTexture( Gl.GL_TEXTURE_2D, TexId[ (int)Textures.Field ] );

			// Game field floor
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_DIFFUSE, floorDiffuse );
			Gl.glMaterialfv( Gl.GL_FRONT, Gl.GL_AMBIENT, floorAmbient );
			DrawBox( -1.01f, -1.01f, -0.01f,  1.01f, 1.01f, 0.0f );

			// Disable texturing
			Gl.glDisable( Gl.GL_TEXTURE_2D );

			// Disable face culling
			Gl.glDisable( Gl.GL_CULL_FACE );

			// Disable lighting
			Gl.glDisable( Gl.GL_LIGHTING );

			// Disable depth testing
			Gl.glDisable( Gl.GL_DEPTH_TEST );
		}


		//========================================================================
		// GameOver()
		//========================================================================

		public static void GameOver( )
		{
			// Enable sticky keys
			Glfw.glfwEnable( Glfw.GLFW_STICKY_KEYS );

			// Until the user presses ESC or SPACE
			while( Glfw.glfwGetKey( Glfw.GLFW_KEY_ESC ) == Gl.GL_FALSE &amp;&amp; Glfw.glfwGetKey( ' ' ) == Gl.GL_FALSE &amp;&amp;
				Glfw.glfwGetWindowParam( Glfw.GLFW_OPENED ) == Gl.GL_TRUE)
			{
				// Draw display
				UpdateDisplay();

				// Setup projection matrix
				Gl.glMatrixMode( Gl.GL_PROJECTION );
				Gl.glLoadIdentity();
				Gl.glOrtho( 0.0f, 1.0f, 1.0f, 0.0f, -1.0f, 1.0f );

				// Setup modelview matrix
				Gl.glMatrixMode( Gl.GL_MODELVIEW );
				Gl.glLoadIdentity();

				// Enable blending
				Gl.glEnable( Gl.GL_BLEND );

				// Dim background
				Gl.glBlendFunc( Gl.GL_ONE_MINUS_SRC_ALPHA, Gl.GL_SRC_ALPHA );
				Gl.glColor4f( 0.3f, 0.3f, 0.3f, 0.3f );
				Gl.glBegin( Gl.GL_QUADS );
				Gl.glVertex2f( 0.0f, 0.0f );
				Gl.glVertex2f( 1.0f, 0.0f );
				Gl.glVertex2f( 1.0f, 1.0f );
				Gl.glVertex2f( 0.0f, 1.0f );
				Gl.glEnd();

				// Display winner text
				Gl.glBlendFunc( Gl.GL_ONE, Gl.GL_ONE_MINUS_SRC_COLOR );
				if( winner == (int)Winner.Player1 )
				{
					Gl.glColor4f( 1.0f, 0.5f, 0.5f, 1.0f );
					DrawImage( (int)Textures.Winner1, 0.35f, 0.65f, 0.46f, 0.54f );
				}
				else if( winner == (int)Winner.Player2 )
				{
					Gl.glColor4f( 0.5f, 1.0f, 0.5f, 1.0f );
					DrawImage( (int)Textures.Winner2, 0.35f, 0.65f, 0.46f, 0.54f );
				}

				// Disable blending
				Gl.glDisable( Gl.GL_BLEND );

				// Swap buffers
				Glfw.glfwSwapBuffers();
			}

			// Disable sticky keys
			Glfw.glfwDisable( Glfw.GLFW_STICKY_KEYS );
		}



		//========================================================================
		// DrawBox() - Draw a 3D box
		//========================================================================

		public static void DrawBox( float x1, float y1, float z1, float x2, float y2, float z2 )
		{
			float texScale = 4.0f;

			// Draw six sides of a cube
			Gl.glBegin( Gl.GL_QUADS );
			// Side 1 (down)
			Gl.glNormal3f( 0.0f, 0.0f, -1.0f );
			Gl.glTexCoord2f( 0.0f, 0.0f );
			Gl.glVertex3f( x1,y2,z1 );
			Gl.glTexCoord2f( texScale, 0.0f );
			Gl.glVertex3f( x2,y2,z1 );
			Gl.glTexCoord2f( texScale, texScale );
			Gl.glVertex3f( x2,y1,z1 );
			Gl.glTexCoord2f( 0.0f, texScale );
			Gl.glVertex3f( x1,y1,z1 );
			
			// Side 2 (up)
			Gl.glNormal3f( 0.0f, 0.0f, 1.0f );
			Gl.glTexCoord2f( 0.0f, 0.0f );
			Gl.glVertex3f( x1,y1,z2 );
			Gl.glTexCoord2f( texScale, 0.0f );
			Gl.glVertex3f( x2,y1,z2 );
			Gl.glTexCoord2f( texScale, texScale );
			Gl.glVertex3f( x2,y2,z2 );
			Gl.glTexCoord2f( 0.0f, texScale );
			Gl.glVertex3f( x1,y2,z2 );

			// Side 3 (backward)
			Gl.glNormal3f( 0.0f, -1.0f, 0.0f );
			Gl.glTexCoord2f( 0.0f, 0.0f );
			Gl.glVertex3f( x1,y1,z1 );
			Gl.glTexCoord2f( texScale, 0.0f );
			Gl.glVertex3f( x2,y1,z1 );
			Gl.glTexCoord2f( texScale, texScale );
			Gl.glVertex3f( x2,y1,z2 );
			Gl.glTexCoord2f( 0.0f, texScale );
			Gl.glVertex3f( x1,y1,z2 );

			// Side 4 (forward)
			Gl.glNormal3f( 0.0f, 1.0f, 0.0f );
			Gl.glTexCoord2f( 0.0f, 0.0f );
			Gl.glVertex3f( x1,y2,z2 );
			Gl.glTexCoord2f( texScale, 0.0f );
			Gl.glVertex3f( x2,y2,z2 );
			Gl.glTexCoord2f( texScale, texScale );
			Gl.glVertex3f( x2,y2,z1 );
			Gl.glTexCoord2f( 0.0f, texScale );
			Gl.glVertex3f( x1,y2,z1 );

			// Side 5 (left)
			Gl.glNormal3f( -1.0f, 0.0f, 0.0f );
			Gl.glTexCoord2f( 0.0f, 0.0f );
			Gl.glVertex3f( x1,y1,z2 );
			Gl.glTexCoord2f( texScale, 0.0f );
			Gl.glVertex3f( x1,y2,z2 );
			Gl.glTexCoord2f( texScale, texScale );
			Gl.glVertex3f( x1,y2,z1 );
			Gl.glTexCoord2f( 0.0f, texScale );
			Gl.glVertex3f( x1,y1,z1 );

			// Side 6 (right)
			Gl.glNormal3f( 1.0f, 0.0f, 0.0f );
			Gl.glTexCoord2f( 0.0f, 0.0f );
			Gl.glVertex3f( x2,y1,z1 );
			Gl.glTexCoord2f( texScale, 0.0f );
			Gl.glVertex3f( x2,y2,z1 );
			Gl.glTexCoord2f( texScale, texScale );
			Gl.glVertex3f( x2,y2,z2 );
			Gl.glTexCoord2f( 0.0f, texScale );
			Gl.glVertex3f( x2,y1,z2 );
			Gl.glEnd();
		}




		//========================================================================
		// GameLoop() - Game loop
		//========================================================================

		static void GameLoop( )
		{
			int playing;
			GameEvent gameEvent;

			// Initialize a new game
			NewGame();

			// Enable sticky keys
			Glfw.glfwEnable( Glfw.GLFW_STICKY_KEYS );

			// Loop until the game ends
			playing = Gl.GL_TRUE;
			while( playing == Gl.GL_TRUE &amp;&amp; Glfw.glfwGetWindowParam( Glfw.GLFW_OPENED ) == Gl.GL_TRUE )
			{
				// Frame timer
				oldTime = thisTime;
				thisTime = Glfw.glfwGetTime();
				dt = thisTime - oldTime;

				// Get user input and update player positions
				PlayerControl();

				// Move the ball, and check if a player hits/misses the ball
				gameEvent = BallControl();

				// Did we have a winner?
				switch( gameEvent )
				{
					case GameEvent.Player1Wins:
						winner = Player1.id;
						playing = Gl.GL_FALSE;
						break;

					case GameEvent.Player2Wins:
						winner = Player2.id;
						playing = Gl.GL_FALSE;
						break;
					default:
						break;
				}

				// Did the user press ESC?
				if( Glfw.glfwGetKey( Glfw.GLFW_KEY_ESC ) == Gl.GL_TRUE )
				{
					playing = Gl.GL_FALSE;
				}

				// Did the user change camera view?
				if( Glfw.glfwGetKey( '1' ) == Gl.GL_TRUE){
					cameraPos = CameraPosition.Classic;
				}
				else if( Glfw.glfwGetKey( '2' ) == Gl.GL_TRUE){
					cameraPos = CameraPosition.Above;
				}
				else if( Glfw.glfwGetKey( '3' ) == Gl.GL_TRUE){
					cameraPos = CameraPosition.Spectator;
				}

				// Draw display
				UpdateDisplay();

				// Swap buffers
				Glfw.glfwSwapBuffers();
			}

			// Disable sticky keys
			Glfw.glfwDisable( Glfw.GLFW_STICKY_KEYS );

			// Show winner
			GameOver();
		}



		//========================================================================
		// BallControl() - Ball control
		//========================================================================

		public static GameEvent BallControl()
		{
			GameEvent gameEvent;
			double ballspeed;

			// Calculate new ball speed
			ballspeed = ballSpeed * (1.0 + 0.02*(thisTime-startTime));
			ball.speedX = ball.speedX &gt; 0 ? ballspeed : -ballspeed;
			ball.speedY = ball.speedY &gt; 0 ? ballspeed : -ballspeed;
			ball.speedY *= 0.74321;

			// Update ball position
			ball.posX += dt * ball.speedX;
			ball.posY += dt * ball.speedY;

			// Did the ball hit a top/bottom wall?
			if( ball.posY &gt;= 1.0 )
			{
				ball.posY = 2.0 - ball.posY;
				ball.speedY = -ball.speedY;
			}
			else if( ball.posY &lt;= -1.0 ){
				ball.posY = -2.0 - ball.posY;
				ball.speedY = -ball.speedY;
			}

			// Did the ball hit/miss a player?
			gameEvent = GameEvent.NobodyWins;

			// Is the ball entering the player 1 goal?
			if( ball.posX &lt; -1.0 + playerSizeX )
			{
				// Did player 1 catch the ball?
				if( ball.posY &gt; (Player1.posY-playerSizeY) &amp;&amp;
					ball.posY &lt; (Player1.posY+playerSizeY) )
				{
					ball.posX = -2.0 + 2.0*playerSizeX - ball.posX;
					ball.speedX = -ball.speedX;
				}
				else
				{
					gameEvent = GameEvent.Player2Wins;
				}
			}

			// Is the ball entering the player 2 goal?
			if( ball.posX &gt; 1.0 - playerSizeX )
			{
				// Did player 2 catch the ball?
				if( ball.posY &gt; (Player2.posY-playerSizeY) &amp;&amp;
						ball.posY &lt; (Player2.posY+playerSizeY) )
					{
						ball.posX = 2.0 - 2.0*playerSizeX - ball.posX;
						ball.speedX = -ball.speedX;
					}
					else{
						gameEvent = GameEvent.Player1Wins;
					}
				}

				return gameEvent;
			}


		//========================================================================
		// main() - Program entry point
		//========================================================================

		public static void Main()
		{
			MenuOption menuoption;

			envAmbient     = new float[]{1.0f,1.0f,1.0f,1.0f};
			light1Position = new float[]{-3.0f,3.0f,2.0f,1.0f};
			light1Diffuse  = new float[]{1.0f,1.0f,1.0f,0.0f};
			light1Ambient  = new float[]{0.0f,0.0f,0.0f,0.0f};

			Player1Diffuse = new float[]{1.0f,0.3f,0.3f,1.0f};
			Player1Ambient = new float[]{0.3f,0.1f,0.0f,1.0f};
			Player2Diffuse = new float[]{0.3f,1.0f,0.3f,1.0f};
			Player2Ambient = new float[]{0.1f,0.3f,0.1f,1.0f};
			ballDiffuse    = new float[]{1.0f,1.0f,0.5f,1.0f};
			ballAmbient    = new float[]{0.3f,0.3f,0.1f,1.0f};
			borderDiffuse  = new float[]{0.3f,0.3f,1.0f,1.0f};
			borderAmbient  = new float[]{0.1f,0.1f,0.3f,1.0f};
			floorDiffuse   = new float[]{1.0f,1.0f,1.0f,1.0f};
			floorAmbient   = new float[]{0.3f,0.3f,0.3f,1.0f};

			Player1.id = 1;
			Player2.id = 2;

			// Initialize GLFW
			if( Glfw.glfwInit() == Gl.GL_FALSE )
			{
				System.Environment.Exit( 0 );
			}

			// Open OpenGL window
			if( Glfw.glfwOpenWindow( width, height, 0,0,0,0, 16,0, Glfw.GLFW_FULLSCREEN ) == Gl.GL_FALSE )
			{
				Glfw.glfwTerminate();
				System.Environment.Exit( 0 );
			}

			// Load all textures
			LoadTextures();

			// Main loop
			do
			{
				// Get menu option
				menuoption = GameMenu();

				// If the user wants to play, let him...
				if( menuoption == MenuOption.Play )
				{
					GameLoop();
				}
			}
			while( menuoption != MenuOption.Quit );

			// Unload all textures
			if( Glfw.glfwGetWindowParam( Glfw.GLFW_OPENED ) == Gl.GL_FALSE )
			{
				Gl.glDeleteTextures( (int)Textures.Num_textures, TexId );
			}

			// Terminate GLFW
			Glfw.glfwTerminate();

		}
	}
}
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000263.html">[Tao-list] FW: Memory usage of Vertex Buffer Objects
</A></li>
	<LI>Next message: <A HREF="000267.html">[Tao-list] Glfw Pong Example
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#264">[ date ]</a>
              <a href="thread.html#264">[ thread ]</a>
              <a href="subject.html#264">[ subject ]</a>
              <a href="author.html#264">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://galactus.ximian.com/mailman/listinfo/tao-list">More information about the Tao-list
mailing list</a><br>
</body></html>
