<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r737 - in trunk/MonoDevelop/src: AddIns/BackendBindings/CSharpBinding/FormattingStrategy AddIns/DisplayBindings/TextEditor AddIns/DisplayBindings/TextEditor/Commands Libraries/ICSharpCode.TextEditor/src/Actions Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy Libraries/ICSharpCode.TextEditor/src/Gui
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r737%20-%20in%20trunk/MonoDevelop/src%3A%20AddIns/BackendBindings/CSharpBinding/FormattingStrategy%20AddIns/DisplayBindings/TextEditor%20AddIns/DisplayBindings/TextEditor/Commands%20Libraries/ICSharpCode.TextEditor/src/Actions%20Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy%20Libraries/ICSharpCode.TextEditor/src/Gui&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000341.html">
   <LINK REL="Next"  HREF="000343.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r737 - in trunk/MonoDevelop/src: AddIns/BackendBindings/CSharpBinding/FormattingStrategy AddIns/DisplayBindings/TextEditor AddIns/DisplayBindings/TextEditor/Commands Libraries/ICSharpCode.TextEditor/src/Actions Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy Libraries/ICSharpCode.TextEditor/src/Gui</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r737%20-%20in%20trunk/MonoDevelop/src%3A%20AddIns/BackendBindings/CSharpBinding/FormattingStrategy%20AddIns/DisplayBindings/TextEditor%20AddIns/DisplayBindings/TextEditor/Commands%20Libraries/ICSharpCode.TextEditor/src/Actions%20Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy%20Libraries/ICSharpCode.TextEditor/src/Gui&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r737 - in trunk/MonoDevelop/src: AddIns/BackendBindings/CSharpBinding/FormattingStrategy AddIns/DisplayBindings/TextEditor AddIns/DisplayBindings/TextEditor/Commands Libraries/ICSharpCode.TextEditor/src/Actions Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy Libraries/ICSharpCode.TextEditor/src/Gui">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sat Jan 31 16:28:04 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000341.html">[Monodevelop-patches-list] r736 - trunk/MonoDevelop/gdldock/test
</A></li>
        <LI>Next message: <A HREF="000343.html">[Monodevelop-patches-list] r738 - in trunk/MonoDevelop/src: AddIns/BackendBindings/CSharpBinding AddIns/BackendBindings/CSharpBinding/FormattingStrategy AddIns/DisplayBindings/EditorBindings AddIns/DisplayBindings/EditorBindings/FormattingStrategy AddIns/DisplayBindings/TextEditor AddIns/DisplayBindings/TextEditor/Commands AddIns/DisplayBindings/TextEditor/Gui/Editor AddIns/DisplayBindings/TextEditor/Gui/OptionPanels Libraries/ICSharpCode.TextEditor Libraries/ICSharpCode.TextEditor/src/Actions Libraries/ICSharpCode.TextEditor/src/Document Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy Libraries/ICSharpCode.TextEditor/src/Gui Libraries/ICSharpCode.TextEditor/src/Undo
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#342">[ date ]</a>
              <a href="thread.html#342">[ thread ]</a>
              <a href="subject.html#342">[ subject ]</a>
              <a href="author.html#342">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: benm
Date: 2004-01-31 16:28:04 -0500 (Sat, 31 Jan 2004)
New Revision: 737

Modified:
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/FormattingStrategy/CSharpFormattingStrategy.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/CodeActions.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/XmlFormattingStrategy.cs
   trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/FormatActions.cs
   trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/MiscActions.cs
   trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy/DefaultFormattingStrategy.cs
   trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy/IFormattingStrategy.cs
   trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/TextArea.cs
Log:
beginning of refactoring

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/FormattingStrategy/CSharpFormattingStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/FormattingStrategy/CSharpFormattingStrategy.cs	2004-01-31 20:04:47 UTC (rev 736)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/FormattingStrategy/CSharpFormattingStrategy.cs	2004-01-31 21:28:04 UTC (rev 737)
@@ -17,122 +17,111 @@
 using ICSharpCode.Core.Services;
 using ICSharpCode.SharpDevelop.Services;
 
-namespace CSharpBinding.FormattingStrategy
-{
+namespace CSharpBinding.FormattingStrategy {
 	/// &lt;summary&gt;
 	/// This class handles the auto and smart indenting in the textbuffer while
 	/// you type.
 	/// &lt;/summary&gt;
-	public class CSharpFormattingStrategy : DefaultFormattingStrategy
-	{
-		public CSharpFormattingStrategy()
-		{
-		}
+	public class CSharpFormattingStrategy : DefaultFormattingStrategy {
 		
 		/// &lt;summary&gt;
 		/// Define CSharp specific smart indenting for a line :)
 		/// &lt;/summary&gt;
-		protected override int SmartIndentLine(TextArea textArea, int lineNr)
+		protected override int SmartIndentLine (IDocument d, int lineNr)
 		{
 			if (lineNr &gt; 0) {
-				LineSegment lineAbove = textArea.Document.GetLineSegment(lineNr - 1);
-				string  lineAboveText = textArea.Document.GetText(lineAbove.Offset, lineAbove.Length).Trim();
+				LineSegment lineAbove = d.GetLineSegment (lineNr - 1);
+				string  lineAboveText = d.GetText (lineAbove.Offset, lineAbove.Length).Trim ();
 				
-				LineSegment curLine = textArea.Document.GetLineSegment(lineNr);
-				string  curLineText = textArea.Document.GetText(curLine.Offset, curLine.Length).Trim();
+				LineSegment curLine = d.GetLineSegment (lineNr);
+				string  curLineText = d.GetText (curLine.Offset, curLine.Length).Trim ();
 				
-				if ((lineAboveText.EndsWith(&quot;)&quot;) &amp;&amp; curLineText.StartsWith(&quot;{&quot;)) ||   // after for, while, etc.
-					(lineAboveText.EndsWith(&quot;else&quot;) &amp;&amp; curLineText.StartsWith(&quot;{&quot;)))  // after else
+				if ((lineAboveText.EndsWith (&quot;)&quot;) &amp;&amp; curLineText.StartsWith (&quot;{&quot;)) ||       // after for, while, etc.
+				    (lineAboveText.EndsWith (&quot;else&quot;) &amp;&amp; curLineText.StartsWith (&quot;{&quot;)))      // after else
 				{
-					string indentation = GetIndentation(textArea, lineNr - 1);
-					textArea.Document.Replace(curLine.Offset, curLine.Length, indentation + curLineText);
+					string indentation = GetIndentation (d, lineNr - 1);
+					d.Replace (curLine.Offset, curLine.Length, indentation + curLineText);
 					return indentation.Length;
 				}
 				
-				if (curLineText.StartsWith(&quot;}&quot;)) { // indent closing bracket.
-					int closingBracketOffset = TextUtilities.SearchBracketBackward(textArea.Document, curLine.Offset + textArea.Document.GetText(curLine.Offset, curLine.Length).IndexOf('}') - 1, '{', '}');
-					if (closingBracketOffset == -1) {  // no closing bracket found -&gt; autoindent
-						return AutoIndentLine(textArea, lineNr);
-					}
+				// indent closing bracket.
+				if (curLineText.StartsWith (&quot;}&quot;)) {
+					int closingBracketOffset = TextUtilities.SearchBracketBackward (d, curLine.Offset + d.GetText (curLine.Offset, curLine.Length).IndexOf ('}') - 1, '{', '}');
 					
-					string indentation = GetIndentation(textArea, textArea.Document.GetLineNumberForOffset(closingBracketOffset));
+					// no closing bracket found -&gt; autoindent
+					if (closingBracketOffset == -1)
+						return AutoIndentLine (d, lineNr);
 					
-					textArea.Document.Replace(curLine.Offset, curLine.Length, indentation + curLineText);
+					string indentation = GetIndentation (d, d.GetLineNumberForOffset (closingBracketOffset));
+					
+					d.Replace (curLine.Offset, curLine.Length, indentation + curLineText);
 					return indentation.Length;
 				}
 				
-				if (lineAboveText.EndsWith(&quot;;&quot;)) { // expression ended, reset to valid indent.
-					int closingBracketOffset = TextUtilities.SearchBracketBackward(textArea.Document, curLine.Offset + textArea.Document.GetText(curLine.Offset, curLine.Length).IndexOf('}') - 1, '{', '}');
+				// expression ended, reset to valid indent.
+				if (lineAboveText.EndsWith (&quot;;&quot;)) {
+					int closingBracketOffset = TextUtilities.SearchBracketBackward (d, curLine.Offset + d.GetText (curLine.Offset, curLine.Length).IndexOf ('}') - 1, '{', '}');
 					
-					if (closingBracketOffset == -1) {  // no closing bracket found -&gt; autoindent
-						return AutoIndentLine(textArea, lineNr);
-					}
+					// no closing bracket found -&gt; autoindent
+					if (closingBracketOffset == -1)
+						return AutoIndentLine (d, lineNr);
 					
-					int closingBracketLineNr = textArea.Document.GetLineNumberForOffset(closingBracketOffset);
-					LineSegment closingBracketLine = textArea.Document.GetLineSegment(closingBracketLineNr);
-					string  closingBracketLineText = textArea.Document.GetText(closingBracketLine.Offset, closingBracketLine.Length).Trim();
+					int closingBracketLineNr = d.GetLineNumberForOffset (closingBracketOffset);
+					LineSegment closingBracketLine = d.GetLineSegment (closingBracketLineNr);
+					string  closingBracketLineText = d.GetText (closingBracketLine.Offset, closingBracketLine.Length).Trim ();
 					
-					string indentation = GetIndentation(textArea, closingBracketLineNr);
+					string indentation = GetIndentation (d, closingBracketLineNr);
 					
 					// special handling for switch statement formatting.
-					if (closingBracketLineText.StartsWith(&quot;switch&quot;)) {
-						if (lineAboveText.StartsWith(&quot;break;&quot;) || 
-						    lineAboveText.StartsWith(&quot;goto&quot;)   || 
-						    lineAboveText.StartsWith(&quot;return&quot;)) {
-							// nothing
-						} else {
-						indentation += ICSharpCode.TextEditor.Actions.Tab.GetIndentationString(textArea.Document);
-						}
+					if (closingBracketLineText.StartsWith (&quot;switch&quot;)) {
+						if (! (lineAboveText.StartsWith (&quot;break;&quot;) || lineAboveText.StartsWith (&quot;goto&quot;) || lineAboveText.StartsWith (&quot;return&quot;)))
+							indentation += ICSharpCode.TextEditor.Actions.Tab.GetIndentationString (d);
 					}
-					indentation += ICSharpCode.TextEditor.Actions.Tab.GetIndentationString(textArea.Document);
+					indentation += ICSharpCode.TextEditor.Actions.Tab.GetIndentationString (d);
 					
-					textArea.Document.Replace(curLine.Offset, curLine.Length, indentation + curLineText);
+					d.Replace (curLine.Offset, curLine.Length, indentation + curLineText);
 					return indentation.Length;
 				}
 				
-				if (lineAboveText.EndsWith(&quot;{&quot;) || // indent opening bracket.
-				    lineAboveText.EndsWith(&quot;:&quot;) || // indent case xyz:
-				    (lineAboveText.EndsWith(&quot;)&quot;) &amp;&amp;  // indent single line if, for ... etc
-				    (lineAboveText.StartsWith(&quot;if&quot;) ||
-				     lineAboveText.StartsWith(&quot;while&quot;) ||
-				     lineAboveText.StartsWith(&quot;for&quot;))) ||
-				     lineAboveText.EndsWith(&quot;else&quot;)) {
-						string indentation = GetIndentation(textArea, lineNr - 1) + ICSharpCode.TextEditor.Actions.Tab.GetIndentationString(textArea.Document);
-						textArea.Document.Replace(curLine.Offset, curLine.Length, indentation + curLineText);
+				if (lineAboveText.EndsWith (&quot;{&quot;) || // indent opening bracket.
+				    lineAboveText.EndsWith (&quot;:&quot;) || // indent case xyz:
+				    (lineAboveText.EndsWith (&quot;)&quot;) &amp;&amp;  // indent single line if, for ... etc
+				    (lineAboveText.StartsWith (&quot;if&quot;) ||
+				     lineAboveText.StartsWith (&quot;while&quot;) ||
+				     lineAboveText.StartsWith (&quot;for&quot;))) ||
+				     lineAboveText.EndsWith (&quot;else&quot;)) {
+						string indentation = GetIndentation (d, lineNr - 1) + ICSharpCode.TextEditor.Actions.Tab.GetIndentationString (d);
+						d.Replace (curLine.Offset, curLine.Length, indentation + curLineText);
 						return indentation.Length;
-			} else {
-				// try to indent linewrap
-				ArrayList bracketPos = new ArrayList();
-				for (int i = 0; i &lt; lineAboveText.Length; ++i) { // search for a ( bracket that isn't closed
-					switch (lineAboveText[i]) {
-						case '(':
-							bracketPos.Add(i);
-							break;
-						case ')':
-							if (bracketPos.Count &gt; 0) {
-								bracketPos.RemoveAt(bracketPos.Count - 1);
-							}
-							break;
-					}
-				}
-				
-				if (bracketPos.Count &gt; 0) {
-					int bracketIndex = (int)bracketPos[bracketPos.Count - 1];
-					string indentation = GetIndentation(textArea, lineNr - 1);
+				} else {
+					// try to indent linewrap
+					ArrayList bracketPos = new ArrayList ();
 					
-					for (int i = 0; i &lt;= bracketIndex; ++i) { // insert enough spaces to match
-					indentation += &quot; &quot;;                   // brace start in the next line
+					// search for a ( bracket that isn't closed
+					for (int i = 0; i &lt; lineAboveText.Length; ++i) {
+						if (lineAboveText [i] == '(')
+							bracketPos.Add (i);
+						else if (lineAboveText [i] == ')' &amp;&amp; bracketPos.Count &gt; 0)
+							bracketPos.RemoveAt (bracketPos.Count - 1);
 					}
 					
-					textArea.Document.Replace(curLine.Offset, curLine.Length, indentation + curLineText);
-					return indentation.Length;
+					if (bracketPos.Count &gt; 0) {
+						int bracketIndex = (int)bracketPos [bracketPos.Count - 1];
+						string indentation = GetIndentation (d, lineNr - 1);
+						
+						// insert enough spaces to match brace start in the next line
+						for (int i = 0; i &lt;= bracketIndex; ++i)
+							indentation += &quot; &quot;;
+						
+						d.Replace (curLine.Offset, curLine.Length, indentation + curLineText);
+						return indentation.Length;
+					}
 				}
 			}
-			}
-			return AutoIndentLine(textArea, lineNr);
+			return AutoIndentLine (d, lineNr);
 		}
 		
-		bool NeedCurlyBracket(string text)
+		bool NeedCurlyBracket (string text)
 		{
 			int curlyCounter = 0;
 			
@@ -143,203 +132,193 @@
 			bool blockComment = false;
 			
 			for (int i = 0; i &lt; text.Length; ++i) {
-				switch (text[i]) {
+				switch (text [i]) {
 					case '\r':
 					case '\n':
 						lineComment = false;
 						break;
 					case '/':
 						if (blockComment) {
-							Debug.Assert(i &gt; 0);
-							if (text[i - 1] == '*') {
+							Debug.Assert (i &gt; 0);
+							if (text [i - 1] == '*')
 								blockComment = false;
-							}
+								
 						}
+						
 						if (!inString &amp;&amp; !inChar &amp;&amp; i + 1 &lt; text.Length) {
-							if (!blockComment &amp;&amp; text[i + 1] == '/') {
+							if (!blockComment &amp;&amp; text [i + 1] == '/')
 								lineComment = true;
-							}
-							if (!lineComment &amp;&amp; text[i + 1] == '*') {
+							
+							if (!lineComment &amp;&amp; text [i + 1] == '*')
 								blockComment = true;
-							}
 						}
 						break;
 					case '&quot;':
-						if (!(inChar || lineComment || blockComment)) {
+						if (!(inChar || lineComment || blockComment))
 							inString = !inString;
-						}
+						
 						break;
 					case '\'':
-						if (!(inString || lineComment || blockComment)) {
+						if (!(inString || lineComment || blockComment))
 							inChar = !inChar;
-						}
+						
 						break;
 					case '{':
-						if (!(inString || inChar || lineComment || blockComment)) {
+						if (!(inString || inChar || lineComment || blockComment))
 							++curlyCounter;
-						}
+						
 						break;
 					case '}':
-						if (!(inString || inChar || lineComment || blockComment)) {
+						if (!(inString || inChar || lineComment || blockComment))
 							--curlyCounter;
-						}
+						
 						break;
 				}
 			}
 			return curlyCounter &gt; 0;
 		}
 		
-		bool IsInsideStringOrComment(TextArea textArea, LineSegment curLine, int cursorOffset)
+		bool IsInsideStringOrComment (IDocument d, LineSegment curLine, int cursorOffset)
 		{
 			// scan cur line if it is inside a string or single line comment (//)
 			bool isInsideString  = false;
-			bool isInsideComment = false;
+			
 			for (int i = curLine.Offset; i &lt; cursorOffset; ++i) {
-				char ch = textArea.Document.GetCharAt(i);
-				if (ch == '&quot;') {
+				char ch = d.GetCharAt (i);
+				if (ch == '&quot;')
 					isInsideString = !isInsideString;
-				}
-				if (ch == '/' &amp;&amp; i + 1 &lt; cursorOffset &amp;&amp; textArea.Document.GetCharAt(i + 1) == '/') {
-					isInsideComment = true;
-					break;
-				}
+				
+				if (ch == '/' &amp;&amp; i + 1 &lt; cursorOffset &amp;&amp; d.GetCharAt (i + 1) == '/')
+					return true;
 			}
 			
-			return isInsideString || isInsideComment;
+			return isInsideString;
 		}
 
-		bool IsInsideDocumentationComment(TextArea textArea, LineSegment curLine, int cursorOffset)
+		bool IsInsideDocumentationComment (IDocument d, LineSegment curLine, int cursorOffset)
 		{
 			// scan cur line if it is inside a string or single line comment (//)
 			bool isInsideString  = false;
-			bool isInsideComment = false;
+			
 			for (int i = curLine.Offset; i &lt; cursorOffset; ++i) {
-				char ch = textArea.Document.GetCharAt(i);
-				if (ch == '&quot;') {
+				char ch = d.GetCharAt (i);
+				if (ch == '&quot;')
 					isInsideString = !isInsideString;
-				}
+					
 				if (!isInsideString) {
-					if (ch == '/' &amp;&amp; i + 2 &lt; cursorOffset &amp;&amp; textArea.Document.GetCharAt(i + 1) == '/' &amp;&amp; textArea.Document.GetCharAt(i + 2) == '/') {
-						isInsideComment = true;
-						break;
-					}
+					if (ch == '/' &amp;&amp; i + 2 &lt; cursorOffset &amp;&amp; d.GetCharAt (i + 1) == '/' &amp;&amp; d.GetCharAt (i + 2) == '/')
+						return true;
 				}
 			}
 			
-			return isInsideComment;
+			return false;
 		}
 		
-		public override int FormatLine(TextArea textArea, int lineNr, int cursorOffset, char ch) // used for comment tag formater/inserter
+		// used for comment tag formater/inserter
+		public override int FormatLine (IDocument d, int lineNr, int cursorOffset, char ch)
 		{
-			LineSegment curLine   = textArea.Document.GetLineSegment(lineNr);
-			LineSegment lineAbove = lineNr &gt; 0 ? textArea.Document.GetLineSegment(lineNr - 1) : null;
+			LineSegment curLine   = d.GetLineSegment (lineNr);
+			LineSegment lineAbove = lineNr &gt; 0 ? d.GetLineSegment (lineNr - 1) : null;
 			
-			if (ch != '\n' &amp;&amp; ch != '&gt;') {
-				if (IsInsideStringOrComment(textArea, curLine, cursorOffset)) {
-					return 0;
-				}
-			}
+			if (ch != '\n' &amp;&amp; ch != '&gt;' &amp;&amp; IsInsideStringOrComment (d, curLine, cursorOffset))
+				return 0;
 			
 			switch (ch) {
 				case '&gt;':
-					if (IsInsideDocumentationComment(textArea, curLine, cursorOffset)) {
-						string curLineText  = textArea.Document.GetText(curLine.Offset, curLine.Length);
-						int column = textArea.Caret.Offset - curLine.Offset;
-						int index = Math.Min(column - 1, curLineText.Length - 1);
-						if (curLineText[index] == '/') {
+					if (IsInsideDocumentationComment (d, curLine, cursorOffset)) {
+						string curLineText  = d.GetText (curLine.Offset, curLine.Length);
+						int column = cursorOffset - curLine.Offset;
+						int index = Math.Min (column - 1, curLineText.Length - 1);
+						if (curLineText [index] == '/')
 							break;
-						}
-						while (index &gt;= 0 &amp;&amp; curLineText[index] != '&lt;') {
+						
+						while (index &gt;= 0 &amp;&amp; curLineText [index] != '&lt;')
 							--index;
-						}
 						
 						if (index &gt; 0) {
 							bool skipInsert = false;
 							for (int i = index; i &lt; curLineText.Length &amp;&amp; i &lt; column; ++i) {
-								if (i &lt; curLineText.Length &amp;&amp; curLineText[i] == '/' &amp;&amp; curLineText[i + 1] == '&gt;') {
+								if (i &lt; curLineText.Length &amp;&amp; curLineText [i] == '/' &amp;&amp; curLineText [i + 1] == '&gt;')
 									skipInsert = true;
-								}
-								if (curLineText[i] == '&gt;') {
+								
+								if (curLineText [i] == '&gt;')
 									break;
-								}
 							}
 							
-							if (!skipInsert) {
-								StringBuilder commentBuilder = new StringBuilder(&quot;&quot;);
-								for (int i = index; i &lt; curLineText.Length &amp;&amp; i &lt; column &amp;&amp; !Char.IsWhiteSpace(curLineText[i]); ++i) {
-									commentBuilder.Append(curLineText[i]);
-								}
-								string tag = commentBuilder.ToString().Trim();
-								if (!tag.EndsWith(&quot;&gt;&quot;)) {
-									tag += &quot;&gt;&quot;;
-								}
-								if (!tag.StartsWith(&quot;/&quot;)) {
-									textArea.Document.Insert(textArea.Caret.Offset, &quot;&lt;/&quot; + tag.Substring(1));
-								}
-							}
+							if (skipInsert)
+								break;
+						
+							StringBuilder commentBuilder = new StringBuilder (&quot;&quot;);
+							for (int i = index; i &lt; curLineText.Length &amp;&amp; i &lt; column &amp;&amp; !Char.IsWhiteSpace (curLineText [i]); ++i)
+								commentBuilder.Append (curLineText [i]);
+								
+							string tag = commentBuilder.ToString ().Trim ();
+							if (!tag.EndsWith (&quot;&gt;&quot;))
+								tag += &quot;&gt;&quot;;
+							
+							if (!tag.StartsWith (&quot;/&quot;))
+								d.Insert (cursorOffset, &quot;&lt;/&quot; + tag.Substring (1));
 						}
 					}
 					break;
 				case '}':
 				case '{':
-					return textArea.Document.FormattingStrategy.IndentLine(textArea, lineNr);
+					return IndentLine (d, lineNr);
 				case '\n':
-					if (lineNr &lt;= 0) {
-						return IndentLine(textArea, lineNr);
-					}
+					if (lineNr &lt;= 0)
+						return IndentLine (d, lineNr);
 					
-					if (textArea.TextEditorProperties.AutoInsertCurlyBracket) {
-						string oldLineText = TextUtilities.GetLineAsString(textArea.Document, lineNr - 1);
-						if (oldLineText.EndsWith(&quot;{&quot;)) {
-							if (NeedCurlyBracket(textArea.Document.TextContent)) {
-								textArea.Document.Insert(textArea.Caret.Offset, &quot;\n}&quot;);
-								IndentLine(textArea, lineNr + 1);
-							}
+					if (d.TextEditorProperties.AutoInsertCurlyBracket) {
+						string oldLineText = TextUtilities.GetLineAsString (d, lineNr - 1);
+						if (oldLineText.EndsWith (&quot;{&quot;) &amp;&amp; NeedCurlyBracket (d.TextContent)) {
+							d.Insert (cursorOffset, &quot;\n}&quot;);
+							IndentLine (d, lineNr + 1);
 						}
 					}
 					
-					string  lineAboveText = textArea.Document.GetText(lineAbove.Offset, lineAbove.Length);
+					string  lineAboveText = d.GetText (lineAbove.Offset, lineAbove.Length);
 					
-					LineSegment    nextLine      = lineNr + 1 &lt; textArea.Document.TotalNumberOfLines ? textArea.Document.GetLineSegment(lineNr + 1) : null;
-					string  nextLineText  = lineNr + 1 &lt; textArea.Document.TotalNumberOfLines ? textArea.Document.GetText(nextLine.Offset, nextLine.Length) : &quot;&quot;;
+					LineSegment    nextLine      = lineNr + 1 &lt; d.TotalNumberOfLines ? d.GetLineSegment (lineNr + 1) : null;
+					string  nextLineText  = lineNr + 1 &lt; d.TotalNumberOfLines ? d.GetText (nextLine.Offset, nextLine.Length) : &quot;&quot;;
 					
 					if (lineAbove.HighlightSpanStack != null &amp;&amp; lineAbove.HighlightSpanStack.Count &gt; 0) {				
-						if (!((Span)lineAbove.HighlightSpanStack.Peek()).StopEOL) {	// case for /* style comments
-							int index = lineAboveText.IndexOf(&quot;/*&quot;);
+						if (!((Span)lineAbove.HighlightSpanStack.Peek ()).StopEOL) {	// case for /* style comments
+							int index = lineAboveText.IndexOf (&quot;/*&quot;);
 							
 							if (index &gt; 0) {
-								string indentation = GetIndentation(textArea, lineNr - 1);
-								for (int i = indentation.Length; i &lt; index; ++ i) {
+								string indentation = GetIndentation (d, lineNr - 1);
+								for (int i = indentation.Length; i &lt; index; ++ i)
 									indentation += ' ';
-								}
-								textArea.Document.Replace(curLine.Offset, cursorOffset - curLine.Offset, indentation + &quot; * &quot;);
+								
+								d.Replace (curLine.Offset, cursorOffset - curLine.Offset, indentation + &quot; * &quot;);
 								return indentation.Length + 3;
 							}
 							
-							index = lineAboveText.IndexOf(&quot;*&quot;);
+							index = lineAboveText.IndexOf (&quot;*&quot;);
 							if (index &gt; 0) {
-								string indentation = GetIndentation(textArea, lineNr - 1);
-								for (int i = indentation.Length; i &lt; index; ++ i) {
+								string indentation = GetIndentation (d, lineNr - 1);
+								for (int i = indentation.Length; i &lt; index; ++ i)
 									indentation += ' ';
-								}
-								textArea.Document.Replace(curLine.Offset, cursorOffset - curLine.Offset, indentation + &quot;* &quot;);
+								
+								d.Replace (curLine.Offset, cursorOffset - curLine.Offset, indentation + &quot;* &quot;);
 								return indentation.Length + 2;
 							}
-						} else { // don't handle // lines, because they're only one lined comments
-							int indexAbove = lineAboveText.IndexOf(&quot;///&quot;);
-							int indexNext  = nextLineText.IndexOf(&quot;///&quot;);
+						} else {
+							// don't handle // lines, because they're only one lined comments
+							int indexAbove = lineAboveText.IndexOf (&quot;///&quot;);
+							int indexNext  = nextLineText.IndexOf (&quot;///&quot;);
 							
 							if (indexAbove &gt; 0 &amp;&amp; (indexNext != -1 || indexAbove + 4 &lt; lineAbove.Length)) {
-								string indentation = GetIndentation(textArea, lineNr - 1);
-								for (int i = indentation.Length; i &lt; indexAbove; ++ i) {
+								string indentation = GetIndentation (d, lineNr - 1);
+								for (int i = indentation.Length; i &lt; indexAbove; ++ i)
 									indentation += ' ';
-								}
-								textArea.Document.Replace(curLine.Offset, cursorOffset - curLine.Offset, indentation + &quot;/// &quot;);
+								
+								d.Replace (curLine.Offset, cursorOffset - curLine.Offset, indentation + &quot;/// &quot;);
 								return indentation.Length + 4;
 							}
 						}
 					}
-					return IndentLine(textArea, lineNr);
+					return IndentLine (d, lineNr);
 			}
 			return 0;
 		}

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/CodeActions.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/CodeActions.cs	2004-01-31 20:04:47 UTC (rev 736)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/CodeActions.cs	2004-01-31 21:28:04 UTC (rev 737)
@@ -342,7 +342,7 @@
 		
 		protected void IndentLine()
 		{
-			int delta = editActionHandler.Document.FormattingStrategy.IndentLine(editActionHandler, editActionHandler.Document.GetLineNumberForOffset(editActionHandler.Caret.Offset));
+			int delta = editActionHandler.Document.FormattingStrategy.IndentLine(editActionHandler.Document, editActionHandler.Document.GetLineNumberForOffset(editActionHandler.Caret.Offset));
 			if (delta != 0) {
 				++numOps;
 				LineSegment caretLine = editActionHandler.Document.GetLineSegmentForOffset(editActionHandler.Caret.Offset);

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/XmlFormattingStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/XmlFormattingStrategy.cs	2004-01-31 20:04:47 UTC (rev 736)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/XmlFormattingStrategy.cs	2004-01-31 21:28:04 UTC (rev 737)
@@ -25,24 +25,24 @@
 	/// &lt;/summary&gt;
 	public class XmlFormattingStrategy : DefaultFormattingStrategy
 	{
-		public override int FormatLine(TextArea textArea, int lineNr, int caretOffset, char charTyped) // used for comment tag formater/inserter
+		public override int FormatLine(IDocument d, int lineNr, int caretOffset, char charTyped) // used for comment tag formater/inserter
 		{
 			try {
 				if (charTyped == '&gt;') {
 					StringBuilder stringBuilder = new StringBuilder();
-					int offset = Math.Min(caretOffset - 2, textArea.Document.TextLength - 1);
+					int offset = Math.Min(caretOffset - 2, d.TextLength - 1);
 					while (true) {
 						if (offset &lt; 0) {
 							break;
 						}
-						char ch = textArea.Document.GetCharAt(offset);
+						char ch = d.GetCharAt(offset);
 						if (ch == '&lt;') {
 							string reversedTag = stringBuilder.ToString().Trim();
 							if (!reversedTag.StartsWith(&quot;/&quot;) &amp;&amp; !reversedTag.EndsWith(&quot;/&quot;)) {
 								bool validXml = true;
 								try {
 									XmlDocument doc = new XmlDocument();
-									doc.LoadXml(textArea.Document.TextContent);
+									doc.LoadXml(d.TextContent);
 								} catch (Exception) {
 									validXml = false;
 								}
@@ -54,7 +54,7 @@
 									}
 									string tagString = tag.ToString();
 									if (tagString.Length &gt; 0) {
-										textArea.Document.Insert(caretOffset, &quot;&lt;/&quot; + tagString + &quot;&gt;&quot;);
+										d.Insert(caretOffset, &quot;&lt;/&quot; + tagString + &quot;&gt;&quot;);
 									}
 								}
 							}
@@ -67,7 +67,7 @@
 			} catch (Exception e) { // Insanity check
 				Debug.Assert(false, e.ToString());
 			}
-			return charTyped == '\n' ? IndentLine(textArea, lineNr) : 0;
+			return charTyped == '\n' ? IndentLine(d, lineNr) : 0;
 		}
 	}	
 }

Modified: trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/FormatActions.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/FormatActions.cs	2004-01-31 20:04:47 UTC (rev 736)
+++ trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/FormatActions.cs	2004-01-31 21:28:04 UTC (rev 737)
@@ -14,12 +14,10 @@
 {
 	public abstract class AbstractLineFormatAction : AbstractEditAction
 	{
-		protected TextArea textArea;
 		abstract protected void Convert(IDocument document, int startLine, int endLine);
 		
 		public override void Execute(TextArea textArea)
 		{
-			this.textArea = textArea;
 			textArea.BeginUpdate();
 			if (textArea.SelectionManager.HasSomethingSelected) {
 				foreach (ISelection selection in textArea.SelectionManager.SelectionCollection) {
@@ -36,12 +34,10 @@
 	
 	public abstract class AbstractSelectionFormatAction : AbstractEditAction
 	{
-		protected TextArea textArea;
 		abstract protected void Convert(IDocument document, int offset, int length);
 		
 		public override void Execute(TextArea textArea)
 		{
-			this.textArea = textArea;
 			textArea.BeginUpdate();
 			if (textArea.SelectionManager.HasSomethingSelected) {
 				foreach (ISelection selection in textArea.SelectionManager.SelectionCollection) {
@@ -228,7 +224,7 @@
 	{
 		protected override void Convert(IDocument document, int startLine, int endLine)
 		{
-			document.FormattingStrategy.IndentLines(textArea, startLine, endLine);
+			document.FormattingStrategy.IndentLines(document, startLine, endLine);
 		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/MiscActions.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/MiscActions.cs	2004-01-31 20:04:47 UTC (rev 736)
+++ trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/MiscActions.cs	2004-01-31 21:28:04 UTC (rev 737)
@@ -339,17 +339,18 @@
 		/// &lt;param name=&quot;textArea&quot;&gt;The &lt;see cref=&quot;ItextArea&quot;/&gt; which is used for callback purposes&lt;/param&gt;
 		public override void Execute(TextArea textArea)
 		{
-			if (textArea.Document.ReadOnly) {
+			IDocument d = textArea.Document;
+			
+			if (d.ReadOnly)
 				return;
-			}
+			
 			textArea.BeginUpdate();
 			if (textArea.SelectionManager.HasSomethingSelected) {
-				foreach (ISelection selection in textArea.SelectionManager.SelectionCollection) {
-					textArea.Document.FormattingStrategy.IndentLines(textArea, selection.StartPosition.Y, selection.EndPosition.Y);
-				}
-			} else {
-				textArea.Document.FormattingStrategy.IndentLines(textArea, 0, textArea.Document.TotalNumberOfLines - 1);
-			}
+				foreach (ISelection selection in textArea.SelectionManager.SelectionCollection)
+					d.FormattingStrategy.IndentLines (d, selection.StartPosition.Y, selection.EndPosition.Y);
+			} else
+				d.FormattingStrategy.IndentLines (d, 0, textArea.Document.TotalNumberOfLines - 1);
+			
 			textArea.EndUpdate();
 			//textArea.Refresh();
 		}
@@ -484,15 +485,17 @@
 		/// &lt;param name=&quot;textArea&quot;&gt;The &lt;see cref=&quot;ItextArea&quot;/&gt; which is used for callback purposes&lt;/param&gt;
 		public override void Execute(TextArea textArea)
 		{
-			if (textArea.Document.ReadOnly) {
+			IDocument d = textArea.Document;
+			
+			if (d.ReadOnly)
 				return;
-			}
+			
 			textArea.BeginUpdate();
 			textArea.InsertChar('\n');
 			
 			++textArea.Caret.Line;
 			int curLineNr = textArea.Caret.Line;
-			textArea.Caret.Column = textArea.Document.FormattingStrategy.FormatLine(textArea, curLineNr, textArea.Caret.Offset, '\n');
+			textArea.Caret.Column = d.FormattingStrategy.FormatLine (d, curLineNr, textArea.Caret.Offset, '\n');
 			textArea.SetDesiredColumn();
 			
 			textArea.Document.UpdateQueue.Clear();

Modified: trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy/DefaultFormattingStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy/DefaultFormattingStrategy.cs	2004-01-31 20:04:47 UTC (rev 736)
+++ trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy/DefaultFormattingStrategy.cs	2004-01-31 21:28:04 UTC (rev 737)
@@ -11,64 +11,55 @@
 using System.Text;
 
 
-namespace ICSharpCode.TextEditor.Document
-{
+namespace ICSharpCode.TextEditor.Document {
 	/// &lt;summary&gt;
 	/// This class handles the auto and smart indenting in the textbuffer while
 	/// you type.
 	/// &lt;/summary&gt;
-	public class DefaultFormattingStrategy : IFormattingStrategy
-	{
+	public class DefaultFormattingStrategy : IFormattingStrategy {
 		/// &lt;summary&gt;
-		/// Creates a new instance off &lt;see cref=&quot;DefaultFormattingStrategy&quot;/&gt;
-		/// &lt;/summary&gt;
-		public DefaultFormattingStrategy()
-		{
-		}
-		
-		/// &lt;summary&gt;
 		/// returns the whitespaces which are before a non white space character in the line line
 		/// as a string.
 		/// &lt;/summary&gt;
-		protected string GetIndentation(TextArea textArea, int lineNumber)
+		protected string GetIndentation (IDocument d, int lineNumber)
 		{
-			if (lineNumber &lt; 0 || lineNumber &gt; textArea.Document.TotalNumberOfLines) {
-				throw new ArgumentOutOfRangeException(&quot;lineNumber&quot;);
-			}
+			if (lineNumber &lt; 0 || lineNumber &gt; d.TotalNumberOfLines)
+				throw new ArgumentOutOfRangeException (&quot;lineNumber&quot;);
 			
-			string lineText = TextUtilities.GetLineAsString(textArea.Document, lineNumber);
-			StringBuilder whitespaces = new StringBuilder();
+			string lineText = TextUtilities.GetLineAsString (d, lineNumber);
+			StringBuilder whitespaces = new StringBuilder ();
 			
 			foreach (char ch in lineText) {
-				if (Char.IsWhiteSpace(ch)) {
-					whitespaces.Append(ch);
-				} else {
+				if (! Char.IsWhiteSpace (ch))
 					break;
-				}
+				whitespaces.Append (ch);
 			}
-			return whitespaces.ToString();
+			
+			return whitespaces.ToString ();
 		}
 		
 		/// &lt;summary&gt;
 		/// Could be overwritten to define more complex indenting.
 		/// &lt;/summary&gt;
-		protected virtual int AutoIndentLine(TextArea textArea, int lineNumber)
+		protected virtual int AutoIndentLine (IDocument d, int lineNumber)
 		{
-			string indentation = lineNumber != 0 ? GetIndentation(textArea, lineNumber - 1) : &quot;&quot;;
-			if(indentation.Length &gt; 0) {
-				string newLineText = indentation + TextUtilities.GetLineAsString(textArea.Document, lineNumber).Trim();
-				LineSegment oldLine  = textArea.Document.GetLineSegment(lineNumber);
-				textArea.Document.Replace(oldLine.Offset, oldLine.Length, newLineText);
+			string indentation = lineNumber != 0 ? GetIndentation (d, lineNumber - 1) : &quot;&quot;;
+			
+			if (indentation.Length &gt; 0) {
+				string newLineText = indentation + TextUtilities.GetLineAsString (d, lineNumber).Trim ();
+				LineSegment oldLine = d.GetLineSegment (lineNumber);
+				d.Replace (oldLine.Offset, oldLine.Length, newLineText);
 			}
+			
 			return indentation.Length;
 		}
 		
 		/// &lt;summary&gt;
 		/// Could be overwritten to define more complex indenting.
 		/// &lt;/summary&gt;
-		protected virtual int SmartIndentLine(TextArea textArea, int line)
+		protected virtual int SmartIndentLine (IDocument d, int line)
 		{
-			return AutoIndentLine(textArea, line); // smart = autoindent in normal texts
+			return AutoIndentLine (d, line); // smart = autoindent in normal texts
 		}
 		
 		/// &lt;summary&gt;
@@ -79,11 +70,11 @@
 		/// of bytes (e.g. the number of bytes inserted before the caret, or
 		/// removed, if this number is negative)
 		/// &lt;/returns&gt;
-		public virtual int FormatLine(TextArea textArea, int line, int cursorOffset, char ch)
+		public virtual int FormatLine (IDocument d, int line, int cursorOffset, char ch)
 		{
-			if (ch == '\n') {
-				return IndentLine(textArea, line);
-			}
+			if (ch == '\n')
+				return IndentLine (d, line);
+			
 			return 0;
 		}
 		
@@ -93,33 +84,30 @@
 		/// &lt;returns&gt;
 		/// the number of inserted characters.
 		/// &lt;/returns&gt;
-		public int IndentLine(TextArea textArea, int line)
+		public int IndentLine (IDocument d, int line)
 		{
-			switch (textArea.Document.TextEditorProperties.IndentStyle) {
-				case IndentStyle.None:
-					break;
-				case IndentStyle.Auto:
-					return AutoIndentLine(textArea, line);
-				case IndentStyle.Smart:
-					return SmartIndentLine(textArea, line);
+			switch (d.TextEditorProperties.IndentStyle) {
+				case IndentStyle.Auto  : return AutoIndentLine (d, line);
+				case IndentStyle.Smart : return SmartIndentLine (d, line);
+				case IndentStyle.None  :
+				default                : return 0;
 			}
-			return 0;
 		}
 		
 		/// &lt;summary&gt;
 		/// This function sets the indentlevel in a range of lines.
 		/// &lt;/summary&gt;
-		public void IndentLines(TextArea textArea, int begin, int end)
+		public void IndentLines (IDocument d, int begin, int end)
 		{
 			int redocounter = 0;
+			
 			for (int i = begin; i &lt;= end; ++i) {
-				if (IndentLine(textArea, i) &gt; 0) {
+				if (IndentLine(d, i) &gt; 0)
 					++redocounter;
-				}
 			}
-			if (redocounter &gt; 0) {
-				textArea.Document.UndoStack.UndoLast(redocounter);
-			}
+			
+			if (redocounter &gt; 0)
+				d.UndoStack.UndoLast(redocounter);
 		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy/IFormattingStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy/IFormattingStrategy.cs	2004-01-31 20:04:47 UTC (rev 736)
+++ trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy/IFormattingStrategy.cs	2004-01-31 21:28:04 UTC (rev 737)
@@ -10,15 +10,13 @@
 using System.Drawing;
 using System.Text;
 
-namespace ICSharpCode.TextEditor.Document
-{
+namespace ICSharpCode.TextEditor.Document {
 	/// &lt;summary&gt;
 	/// This interface handles the auto and smart indenting and formating
 	/// in the document while  you type. Language bindings could overwrite this 
 	/// interface and define their own indentation/formating.
 	/// &lt;/summary&gt;
-	public interface IFormattingStrategy
-	{
+	public interface IFormattingStrategy {
 		/// &lt;summary&gt;
 		/// This function formats a specific line after &lt;code&gt;ch&lt;/code&gt; is pressed.
 		/// &lt;/summary&gt;
@@ -27,7 +25,7 @@
 		/// of bytes (e.g. the number of bytes inserted before the caret, or
 		/// removed, if this number is negative)
 		/// &lt;/returns&gt;
-		int FormatLine(TextArea textArea, int line, int caretOffset, char charTyped);
+		int FormatLine (IDocument d, int line, int caretOffset, char charTyped);
 		
 		/// &lt;summary&gt;
 		/// This function sets the indentation level in a specific line
@@ -35,11 +33,11 @@
 		/// &lt;returns&gt;
 		/// the number of inserted characters.
 		/// &lt;/returns&gt;
-		int IndentLine(TextArea textArea, int line);
+		int IndentLine (IDocument d, int line);
 		
 		/// &lt;summary&gt;
 		/// This function sets the indentlevel in a range of lines.
 		/// &lt;/summary&gt;
-		void IndentLines(TextArea textArea, int begin, int end);
+		void IndentLines (IDocument d, int begin, int end);
 	}	
 }

Modified: trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/TextArea.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/TextArea.cs	2004-01-31 20:04:47 UTC (rev 736)
+++ trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/TextArea.cs	2004-01-31 21:28:04 UTC (rev 737)
@@ -495,7 +495,7 @@
 			}
 			
 			int currentLineNr = Caret.Line;
-			int delta = Document.FormattingStrategy.FormatLine(this, currentLineNr, Document.PositionToOffset(Caret.Position), ch);
+			int delta = Document.FormattingStrategy.FormatLine(Document, currentLineNr, Document.PositionToOffset(Caret.Position), ch);
 			
 			motherTextEditorControl.EndUpdate();
 			if (delta != 0) {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000341.html">[Monodevelop-patches-list] r736 - trunk/MonoDevelop/gdldock/test
</A></li>
	<LI>Next message: <A HREF="000343.html">[Monodevelop-patches-list] r738 - in trunk/MonoDevelop/src: AddIns/BackendBindings/CSharpBinding AddIns/BackendBindings/CSharpBinding/FormattingStrategy AddIns/DisplayBindings/EditorBindings AddIns/DisplayBindings/EditorBindings/FormattingStrategy AddIns/DisplayBindings/TextEditor AddIns/DisplayBindings/TextEditor/Commands AddIns/DisplayBindings/TextEditor/Gui/Editor AddIns/DisplayBindings/TextEditor/Gui/OptionPanels Libraries/ICSharpCode.TextEditor Libraries/ICSharpCode.TextEditor/src/Actions Libraries/ICSharpCode.TextEditor/src/Document Libraries/ICSharpCode.TextEditor/src/Document/FormattingStrategy Libraries/ICSharpCode.TextEditor/src/Gui Libraries/ICSharpCode.TextEditor/src/Undo
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#342">[ date ]</a>
              <a href="thread.html#342">[ thread ]</a>
              <a href="subject.html#342">[ subject ]</a>
              <a href="author.html#342">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
