<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r711 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r711%20-%20in%20trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor%3A%20.%20CodeCompletion%20Gui&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000315.html">
   <LINK REL="Next"  HREF="000317.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r711 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r711%20-%20in%20trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor%3A%20.%20CodeCompletion%20Gui&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r711 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Thu Jan 29 10:59:07 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000315.html">[Monodevelop-patches-list] r710 - trunk/MonoDevelop
</A></li>
        <LI>Next message: <A HREF="000317.html">[Monodevelop-patches-list] r712 - trunk/MonoDevelop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#316">[ date ]</a>
              <a href="thread.html#316">[ thread ]</a>
              <a href="subject.html#316">[ subject ]</a>
              <a href="author.html#316">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tberman
Date: 2004-01-29 10:59:07 -0500 (Thu, 29 Jan 2004)
New Revision: 711

Added:
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionWindow.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs
Modified:
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorDisplayBinding.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorWidget.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Makefile
Log:
some pieces of code complete *DISPLAY* work in the new source editor.

ben, you need to look at why the parser doesnt seem to work.


Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs (from rev 704, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CodeCompletionData.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CodeCompletionData.cs	2004-01-28 17:48:17 UTC (rev 704)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,270 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#402;&#194;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Xml;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.IO;
+
+using SharpDevelop.Internal.Parser;
+using ICSharpCode.TextEditor;
+using ICSharpCode.SharpDevelop.Services;
+using ICSharpCode.Core.Services;
+using ICSharpCode.TextEditor.Gui.CompletionWindow;
+
+using MonoDevelop.SourceEditor.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	class CodeCompletionData : ICompletionDataWithMarkup
+	{
+		static ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+		static IParserService           parserService           = (IParserService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+		static AmbienceService          ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
+		
+		int      imageIndex;
+		int      overloads;
+		string   text;
+		string   description;
+		string   pango_description;
+		string   documentation;
+		string   completionString;
+		IClass   c;
+		bool     convertedDocumentation = false;
+		
+		static IAmbience PangoAmbience {
+			get {
+				IAmbience asvc = ambienceService.CurrentAmbience;
+				asvc.ConversionFlags |= ConversionFlags.IncludePangoMarkup;
+				return asvc;
+			}
+		}
+		
+		public int Overloads {
+			get {
+				return overloads;
+			}
+			set {
+				overloads = value;
+			}
+		}
+		
+		public int ImageIndex {
+			get {
+				return imageIndex;
+			}
+			set {
+				imageIndex = value;
+			}
+		}
+		
+		public string[] Text {
+			get {
+				return new string[] { text };
+			}
+			set {
+				text = value[0];
+			}
+		}
+		public string Description {
+			get {
+				// get correct delegate description (when description is requested)
+				// in the classproxies aren't methods saved, therefore delegate methods
+				// must be get through the real class instead out of the proxy
+				//
+				// Mike
+				if (c is ClassProxy &amp;&amp; c.ClassType == ClassType.Delegate) {
+					description = ambienceService.CurrentAmbience.Convert(parserService.GetClass(c.FullyQualifiedName));
+					pango_description = PangoAmbience.Convert(parserService.GetClass(c.FullyQualifiedName));
+					c = null;
+				}
+				
+				// don't give a description string, if no documentation or description is provided
+				if (description.Length + documentation.Length == 0) {
+					return null;
+				}
+				if (!convertedDocumentation) {
+					convertedDocumentation = true;
+					try {
+						documentation = GetDocumentation(documentation);
+						// new (by G.B.)
+						// XmlDocument doc = new XmlDocument();
+						// doc.LoadXml(&quot;&lt;doc&gt;&quot; + documentation + &quot;&lt;/doc&gt;&quot;);
+						// XmlNode root      = doc.DocumentElement;
+						// XmlNode paramDocu = root.SelectSingleNode(&quot;summary&quot;);
+						// documentation = paramDocu.InnerXml;
+					} catch (Exception e) {
+						Console.WriteLine(e.ToString());
+					}
+				}
+				return (description + (overloads &gt; 0 ? &quot; (+&quot; + overloads + &quot; overloads)&quot; : String.Empty) + &quot;\n&quot; + documentation).Trim ();
+			}
+			set {
+				description = value;
+			}
+		}
+		
+		public string DescriptionPango {
+			get {
+				// get correct delegate description (when description is requested)
+				// in the classproxies aren't methods saved, therefore delegate methods
+				// must be get through the real class instead out of the proxy
+				//
+				// Mike
+				if (c is ClassProxy &amp;&amp; c.ClassType == ClassType.Delegate) {
+					description = ambienceService.CurrentAmbience.Convert(parserService.GetClass(c.FullyQualifiedName));
+					pango_description = PangoAmbience.Convert(parserService.GetClass(c.FullyQualifiedName));
+					c = null;
+				}
+				
+				// don't give a description string, if no documentation or description is provided
+				if (description.Length + documentation.Length == 0) {
+					return null;
+				}
+				if (!convertedDocumentation) {
+					convertedDocumentation = true;
+					try {
+						documentation = GetDocumentation(documentation);
+						// new (by G.B.)
+						// XmlDocument doc = new XmlDocument();
+						// doc.LoadXml(&quot;&lt;doc&gt;&quot; + documentation + &quot;&lt;/doc&gt;&quot;);
+						// XmlNode root      = doc.DocumentElement;
+						// XmlNode paramDocu = root.SelectSingleNode(&quot;summary&quot;);
+						// documentation = paramDocu.InnerXml;
+					} catch (Exception e) {
+						Console.WriteLine(e.ToString());
+					}
+				}
+				return (pango_description + (overloads &gt; 0 ? &quot; (+&quot; + overloads + &quot; overloads)&quot; : String.Empty) + &quot;\n&quot; + documentation).Trim ();
+			}
+			set {
+				description = value;
+			}
+		}
+		
+		public CodeCompletionData(string s, int imageIndex)
+		{
+			description = pango_description = documentation = String.Empty;
+			text = s;
+			completionString = s;
+			this.imageIndex = imageIndex;
+		}
+		
+		public CodeCompletionData(IClass c)
+		{
+			// save class (for the delegate description shortcut
+			this.c = c;
+			imageIndex = classBrowserIconService.GetIcon(c);
+			text = c.Name;
+			completionString = c.Name;
+			description = ambienceService.CurrentAmbience.Convert(c);
+			pango_description  = PangoAmbience.Convert(c);
+			documentation = c.Documentation;
+		}
+		
+		public CodeCompletionData(IMethod method)
+		{
+			imageIndex  = classBrowserIconService.GetIcon(method);
+			text        = method.Name;
+			description = ambienceService.CurrentAmbience.Convert(method);
+			pango_description  = PangoAmbience.Convert (method);
+			completionString = method.Name;
+			documentation = method.Documentation;
+		}
+		
+		public CodeCompletionData(IField field)
+		{
+			imageIndex  = classBrowserIconService.GetIcon(field);
+			text        = field.Name;
+			description = ambienceService.CurrentAmbience.Convert(field);
+			pango_description  = PangoAmbience.Convert (field);
+			completionString = field.Name;
+			documentation = field.Documentation;
+		}
+		
+		public CodeCompletionData(IProperty property)
+		{
+			imageIndex  = classBrowserIconService.GetIcon(property);
+			text        = property.Name;
+			description = ambienceService.CurrentAmbience.Convert(property);
+			pango_description  = PangoAmbience.Convert (property);
+			completionString = property.Name;
+			documentation = property.Documentation;
+		}
+		
+		public CodeCompletionData(IEvent e)
+		{
+			imageIndex  = classBrowserIconService.GetIcon(e);
+			text        = e.Name;
+			description = ambienceService.CurrentAmbience.Convert(e);
+			pango_description  = PangoAmbience.Convert (e);
+			completionString = e.Name;
+			documentation = e.Documentation;
+		}
+		
+		public void InsertAction(SourceEditorView control)
+		{
+			//((SharpDevelopTextAreaControl)control).ActiveTextAreaControl.TextArea.InsertString(completionString);
+		}
+
+		public static string GetDocumentation(string doc)
+		{
+			System.IO.StringReader reader = new System.IO.StringReader(&quot;&lt;docroot&gt;&quot; + doc + &quot;&lt;/docroot&gt;&quot;);
+			XmlTextReader xml   = new XmlTextReader(reader);
+			StringBuilder ret   = new StringBuilder();
+			Regex whitespace    = new Regex(@&quot;\s+&quot;);
+			
+			try {
+				xml.Read();
+				do {
+					if (xml.NodeType == XmlNodeType.Element) {
+						string elname = xml.Name.ToLower();
+						if (elname == &quot;remarks&quot;) {
+							ret.Append(&quot;Remarks:\n&quot;);
+						} else if (elname == &quot;example&quot;) {
+							ret.Append(&quot;Example:\n&quot;);
+						} else if (elname == &quot;exception&quot;) {
+							ret.Append(&quot;Exception: &quot; + GetCref(xml[&quot;cref&quot;]) + &quot;:\n&quot;);
+						} else if (elname == &quot;returns&quot;) {
+							ret.Append(&quot;Returns: &quot;);
+						} else if (elname == &quot;see&quot;) {
+							ret.Append(GetCref(xml[&quot;cref&quot;]) + xml[&quot;langword&quot;]);
+						} else if (elname == &quot;seealso&quot;) {
+							ret.Append(&quot;See also: &quot; + GetCref(xml[&quot;cref&quot;]) + xml[&quot;langword&quot;]);
+						} else if (elname == &quot;paramref&quot;) {
+							ret.Append(xml[&quot;name&quot;]);
+						} else if (elname == &quot;param&quot;) {
+							ret.Append(xml[&quot;name&quot;].Trim() + &quot;: &quot;);
+						} else if (elname == &quot;value&quot;) {
+							ret.Append(&quot;Value: &quot;);
+						}
+					} else if (xml.NodeType == XmlNodeType.EndElement) {
+						string elname = xml.Name.ToLower();
+						if (elname == &quot;para&quot; || elname == &quot;param&quot;) {
+							ret.Append(&quot;\n&quot;);
+						}
+					} else if (xml.NodeType == XmlNodeType.Text) {
+						ret.Append(whitespace.Replace(xml.Value, &quot; &quot;));
+					}
+				} while(xml.Read());
+			} catch {
+				return doc;
+			}
+			return ret.ToString();
+		}
+		
+		static string GetCref(string cref)
+		{
+			if (cref == null) return &quot;&quot;;
+			if (cref.Length &lt; 2) return cref;
+			if (cref.Substring(1, 1) == &quot;:&quot;) return cref.Substring(2, cref.Length - 2);
+			return cref;
+		}
+	
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs (from rev 704, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CodeCompletionDataProvider.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CodeCompletionDataProvider.cs	2004-01-28 17:48:17 UTC (rev 704)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,156 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#402;&#194;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Diagnostics;
+using System.Reflection;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Xml;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Templates;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.TextEditor;
+using ICSharpCode.Core.Services;
+using ICSharpCode.SharpDevelop.Services;
+using SharpDevelop.Internal.Parser;
+using ICSharpCode.TextEditor.Gui.CompletionWindow;
+using ICSharpCode.SharpDevelop.Gui;
+
+using MonoDevelop.SourceEditor.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	/// &lt;summary&gt;
+	/// Data provider for code completion.
+	/// &lt;/summary&gt;
+	public class CodeCompletionDataProvider : ICompletionDataProvider
+	{
+		static ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+//		static AmbienceService          ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
+		Hashtable insertedElements           = new Hashtable();
+		Hashtable insertedPropertiesElements = new Hashtable();
+		Hashtable insertedEventElements      = new Hashtable();
+		
+		public Gdk.Pixbuf[] ImageList {
+			get {
+				PixbufList list = classBrowserIconService.ImageList;
+				return (Gdk.Pixbuf[])list.ToArray (typeof(Gdk.Pixbuf));
+			}
+		}
+		
+		int caretLineNumber;
+		int caretColumn;
+		string fileName;
+		
+		ArrayList completionData = null;
+
+		public ICompletionData[] GenerateCompletionData(string fileName, SourceEditorView textArea, char charTyped)
+		{
+			//FIXME: THIS IS A HACK
+			string lang = &quot;C#&quot;;
+			Console.WriteLine (&quot;resolve &quot; + lang);
+			Console.WriteLine (&quot;nm &quot; + fileName);
+			completionData = new ArrayList();
+			this.fileName = fileName;
+		
+			Gtk.TextIter insertIter = textArea.Buffer.GetIterAtMark (textArea.Buffer.InsertMark);
+		
+			// the parser works with 1 based coordinates
+			
+			caretLineNumber      = insertIter.Line + 1;
+			caretColumn          = insertIter.LineOffset + 1;
+			string expression    = TextUtilities.GetExpressionBeforeOffset (textArea, insertIter.Offset);
+			ResolveResult results;
+			
+			if (expression.Length == 0) {
+				return null;
+			}
+			IParserService           parserService           = (IParserService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+			if (charTyped == ' ') {
+				if (expression == &quot;using&quot; || expression.EndsWith(&quot; using&quot;) || expression.EndsWith(&quot;\tusing&quot;)|| expression.EndsWith(&quot;\nusing&quot;)|| expression.EndsWith(&quot;\rusing&quot;)) {
+					string[] namespaces = parserService.GetNamespaceList(&quot;&quot;);
+//					AddResolveResults(new ResolveResult(namespaces, ShowMembers.Public));
+					AddResolveResults(new ResolveResult(namespaces));
+//					IParseInformation info = parserService.GetParseInformation(fileName);
+//					ICompilationUnit unit = info.BestCompilationUnit as ICompilationUnit;
+//					if (unit != null) {
+//						foreach (IUsing u in unit.Usings) {
+//							if (u.Region.IsInside(caretLineNumber, caretColumn)) {
+//								foreach (string usingStr in u.Usings) {
+//									results = parserService.Resolve(usingStr, caretLineNumber, caretColumn, fileName);
+//									AddResolveResults(results);
+//								}
+//								if (u.Aliases[&quot;&quot;] != null) {
+//									results = parserService.Resolve(u.Aliases[&quot;&quot;].ToString(), caretLineNumber, caretColumn, fileName);
+//									AddResolveResults(results);
+//								}
+//							}
+//						}
+//					}
+				}
+			} else {
+				//FIXME: I added the null check, #D doesnt need it, why do we?
+				if (fileName != null) {
+					Console.WriteLine (&quot;resolve &quot; + lang);
+					results = parserService.Resolve(expression, 
+				                                caretLineNumber,
+				                                caretColumn,
+				                                fileName,
+				                                textArea.Buffer.Text,
+								lang);
+					AddResolveResults(results);
+				}
+			}
+			
+			return (ICompletionData[])completionData.ToArray(typeof(ICompletionData));
+		}
+		
+		void AddResolveResults(ResolveResult results)
+		{
+			if (results != null) {
+				completionData.Capacity += results.Namespaces.Count +
+					results.Members.Count;
+				
+				if (results.Namespaces != null &amp;&amp; results.Namespaces.Count &gt; 0) {
+					foreach (string s in results.Namespaces) {
+						completionData.Add(new CodeCompletionData(s, classBrowserIconService.NamespaceIndex));
+					}
+				}
+				if (results.Members != null &amp;&amp; results.Members.Count &gt; 0) {
+					foreach (object o in results.Members) {
+						if (o is IClass) {
+							completionData.Add(new CodeCompletionData((IClass)o));
+						} else if (o is IProperty) {
+							IProperty property = (IProperty)o;
+							if (property.Name != null &amp;&amp; insertedPropertiesElements[property.Name] == null) {
+								completionData.Add(new CodeCompletionData(property));
+								insertedPropertiesElements[property.Name] = property;
+							}
+						} else if (o is IMethod) {
+							IMethod method = (IMethod)o;
+							if (method.Name != null &amp;&amp; insertedElements[method.Name] == null &amp;&amp; !method.IsConstructor) {
+								completionData.Add(new CodeCompletionData(method));
+								insertedElements[method.Name] = method;
+							}
+						} else if (o is IField) {
+							completionData.Add(new CodeCompletionData((IField)o));
+						} else if (o is IEvent) {
+							IEvent e = (IEvent)o;
+							if (e.Name != null &amp;&amp; insertedEventElements[e.Name] == null) {
+								completionData.Add(new CodeCompletionData(e));
+								insertedEventElements[e.Name] = e;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs (from rev 704, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CommentCompletionDataProvider.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CommentCompletionDataProvider.cs	2004-01-28 17:48:17 UTC (rev 704)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,128 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Templates;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.TextEditor;
+using ICSharpCode.Core.Services;
+using ICSharpCode.SharpDevelop.Services;
+
+using SharpDevelop.Internal.Parser;
+using ICSharpCode.TextEditor.Gui.CompletionWindow;
+using ICSharpCode.SharpDevelop.Gui;
+
+using MonoDevelop.SourceEditor.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	/// &lt;summary&gt;
+	/// Data provider for code completion.
+	/// &lt;/summary&gt;
+	public class CommentCompletionDataProvider : ICompletionDataProvider
+	{
+		static ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+		static IParserService           parserService           = (IParserService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+		
+		int caretLineNumber;
+		int caretColumn;
+		
+		string[][] commentTags = new string[][] {
+			new string[] {&quot;c&quot;, &quot;marks text as code&quot;},
+			new string[] {&quot;code&quot;, &quot;marks text as code&quot;},
+			new string[] {&quot;example&quot;, &quot;A description of the code example\n(must have a &lt;code&gt; tag inside)&quot;},
+			new string[] {&quot;exception cref=\&quot;\&quot;&quot;, &quot;description to an exception thrown&quot;},
+			new string[] {&quot;list type=\&quot;\&quot;&quot;, &quot;A list&quot;},
+			new string[] {&quot;listheader&quot;, &quot;The header from the list&quot;},
+			new string[] {&quot;item&quot;, &quot;A list item&quot;},
+			new string[] {&quot;term&quot;, &quot;A term in a list&quot;},
+			new string[] {&quot;description&quot;, &quot;A description to a term in a list&quot;},
+			new string[] {&quot;param name=\&quot;\&quot;&quot;, &quot;A description for a parameter&quot;},
+			new string[] {&quot;paramref name=\&quot;\&quot;&quot;, &quot;A reference to a parameter&quot;},
+			new string[] {&quot;permission cref=\&quot;\&quot;&quot;, &quot;&quot;},
+			new string[] {&quot;remarks&quot;, &quot;Gives description for a member&quot;},
+			new string[] {&quot;include file=\&quot;\&quot; path=\&quot;\&quot;&quot;, &quot;Includes comments from other files&quot;},
+			new string[] {&quot;returns&quot;, &quot;Gives description for a return value&quot;},
+			new string[] {&quot;see cref=\&quot;\&quot;&quot;, &quot;A reference to a member&quot;},
+			new string[] {&quot;seealso cref=\&quot;\&quot;&quot;, &quot;A reference to a member in the seealso section&quot;},
+			new string[] {&quot;summary&quot;, &quot;A summary of the object&quot;},
+			new string[] {&quot;value&quot;, &quot;A description of a property&quot;}
+		};
+		
+		public Gdk.Pixbuf[] ImageList {
+			get {
+				PixbufList list = classBrowserIconService.ImageList;
+				return (Gdk.Pixbuf[])list.ToArray (typeof (Gdk.Pixbuf));
+			}
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns true, if the given coordinates (row, column) are in the region.
+		/// &lt;/remarks&gt;
+		bool IsBetween(int row, int column, IRegion region)
+		{
+			return row &gt;= region.BeginLine &amp;&amp; (row &lt;= region.EndLine || region.EndLine == -1);
+		}
+		
+		public ICompletionData[] GenerateCompletionData(string fileName, SourceEditorView textArea, char charTyped)
+		{
+			/*caretLineNumber = textArea.Caret.Line;
+			caretColumn     = textArea.Caret.Column;
+			LineSegment caretLine = textArea.Document.GetLineSegment(caretLineNumber);
+			string lineText = textArea.Document.GetText(caretLine.Offset, caretLine.Length);
+			if (!lineText.Trim().StartsWith(&quot;///&quot;)) {
+				return null;
+			}
+			*/
+			ArrayList completionData = new ArrayList();
+			/*foreach (string[] tag in commentTags) {
+				completionData.Add(new CommentCompletionData(tag[0], tag[1]));
+			}*/
+			return (ICompletionData[])completionData.ToArray(typeof(ICompletionData));
+		}
+		
+		class CommentCompletionData : ICompletionData
+		{
+			string text;
+			string description;
+			
+			public int ImageIndex {
+				get {
+					return classBrowserIconService.MethodIndex;
+				}
+			}
+			
+			public string[] Text {
+				get {
+					return new string[] { text };
+				}
+			}
+			
+			public string Description {
+				get {
+					return description;
+				}
+			}
+			
+			public void InsertAction(SourceEditorView control)
+			{
+				//((SharpDevelopTextAreaControl)control).ActiveTextAreaControl.TextArea.InsertString(text);
+			}
+			
+			public CommentCompletionData(string text, string description) 
+			{
+				this.text        = text;
+				this.description = description;
+			}
+		}
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionWindow.cs (from rev 704, trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/CompletionWindow.cs)
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/CompletionWindow.cs	2004-01-28 17:48:17 UTC (rev 704)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionWindow.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,329 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using ICSharpCode.TextEditor;
+
+using Gtk;
+using GtkSharp;
+
+using MonoDevelop.SourceEditor.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	public class CompletionWindow : Window
+	{
+		const  int  DeclarationIndent  = 1;
+		static GLib.GType type;
+		Gtk.TreeViewColumn complete_column;
+		
+		ICompletionDataProvider completionDataProvider;
+		SourceEditorView        control;
+		Gtk.TreeView            listView;
+		Gtk.TreeStore		store;
+		DeclarationViewWindow   declarationviewwindow = new DeclarationViewWindow();
+		Gdk.Pixbuf[]		imgList;		
+		int    insertLength = 0;
+		
+		string GetTypedString()
+		{
+			TextIter startIter = control.Buffer.GetIterAtMark (control.Buffer.InsertMark);
+			TextIter offsetIter = control.Buffer.GetIterAtOffset (startIter.Offset - insertLength);
+			return control.Buffer.GetText (offsetIter, startIter, true);
+		}
+		
+		void DeleteInsertion()
+		{
+			if (insertLength &gt; 0) {
+				TextIter startIter = control.Buffer.GetIterAtMark (control.Buffer.InsertMark);
+				TextIter offsetIter = control.Buffer.GetIterAtOffset (startIter.Offset - insertLength);
+				int newPos = offsetIter.Offset;
+				control.Buffer.Delete (offsetIter, startIter);
+				control.Buffer.MoveMark (control.Buffer.InsertMark, control.Buffer.GetIterAtOffset (newPos));
+			}
+		}
+		
+		// Lame fix. The backspace press event is not being caught. The release event yes, though
+		// ???
+		void ListKeyreleaseEvent(object sender, KeyReleaseEventArgs ex) {
+			if (ex.Event.Key == Gdk.Key.BackSpace) {
+				//Console.WriteLine(&quot;Got BackSpace on key release&quot;);
+				//new ICSharpCode.TextEditor.Actions.Backspace().Execute(control.ActiveTextAreaControl.TextArea);
+				if (insertLength &gt; 0) {
+					--insertLength;
+				} else {
+					// no need to delete here (insertLength &lt;= 0)
+					LostFocusListView(null, null);
+				}
+			}
+		}
+		void ListKeypressEvent(object sender, KeyPressEventArgs ex)
+		{
+			Gdk.Key key = ex.Event.Key;
+			char val = (char) key;
+			Console.WriteLine(&quot;Got Press event ({0}). Key {1}&quot;, ex, key);
+			switch (key) {
+				case Gdk.Key.Shift_L:
+				case Gdk.Key.Shift_R:
+				case Gdk.Key.Control_L:
+				case Gdk.Key.Control_R:
+					ex.RetVal = true;
+					return;
+					
+				case Gdk.Key.Escape:
+					Console.WriteLine(&quot;Got Escape&quot;);
+					LostFocusListView(null, null);
+					ex.RetVal = true;
+					return;
+					
+				case Gdk.Key.BackSpace:
+					Console.WriteLine(&quot;Got BackSpace on key press&quot;);
+					//new ICSharpCode.TextEditor.Actions.Backspace().Execute(control.ActiveTextAreaControl.TextArea);
+					if (insertLength &gt; 0) {
+						--insertLength;
+					} else {
+						// no need to delete here (insertLength &lt;= 0)
+						LostFocusListView(null, null);
+					}
+					break;
+					
+				default:
+					Console.WriteLine(&quot;Got key: {0}&quot;, key);
+					if (val != '_' &amp;&amp; !Char.IsLetterOrDigit(val)) {
+						if (listView.Selection.CountSelectedRows() &gt; 0) {
+							ActivateItem(null, null);
+						} else {
+							LostFocusListView(null, null);
+						}
+						
+						control.Buffer.InsertAtCursor (val.ToString ());
+						ex.RetVal = true;
+						return;
+					} else {
+						control.Buffer.InsertAtCursor (val.ToString ());
+						++insertLength;
+					}
+					break;
+			}
+			
+			// select the current typed word
+			int lastSelected = -1;
+			int capitalizationIndex = -1;
+			
+			string typedString = GetTypedString();
+			TreeIter iter;
+			int i = 0;
+			for (store.GetIterFirst(out iter); store.IterNext(out iter) == true; i++) {
+				string text = (string)store.GetValue(iter, 0);
+				
+				if (text.ToUpper().StartsWith(typedString.ToUpper())) {
+					int currentCapitalizationIndex = 0;
+					for (int j = 0; j &lt; typedString.Length &amp;&amp; j &lt; text.Length; ++j) {
+						if (typedString[j] == text[j]) {
+							++currentCapitalizationIndex;
+						}
+					}
+					
+					if (currentCapitalizationIndex &gt; capitalizationIndex) {
+						lastSelected = i;
+						capitalizationIndex = currentCapitalizationIndex;
+					}
+				}
+			}
+			
+			listView.Selection.UnselectAll();
+			if (lastSelected != -1) {
+				TreePath path = new TreePath(&quot;&quot; + (lastSelected + 1));
+				listView.Selection.SelectPath(path);
+				listView.SetCursor (path, complete_column, false);
+				listView.ScrollToCell(path, null, false, 0, 0);
+			}
+			
+			ex.RetVal =  true;
+		}
+		
+		void InitializeControls()
+		{
+			RequestSize = new Size (340, 210 - 85);
+			Decorated = false;
+			SkipPagerHint = true;
+			SkipTaskbarHint = true;
+			TypeHint = Gdk.WindowTypeHint.Dialog;
+			
+			store = new Gtk.TreeStore (typeof (string), typeof (Gdk.Pixbuf), typeof(ICompletionData));
+			listView = new Gtk.TreeView (store);
+
+			listView.HeadersVisible = false;
+
+			complete_column = new Gtk.TreeViewColumn ();
+			complete_column.Title = &quot;completion&quot;;
+
+			Gtk.CellRendererPixbuf pix_render = new Gtk.CellRendererPixbuf ();
+			complete_column.PackStart (pix_render, false);
+			complete_column.AddAttribute (pix_render, &quot;pixbuf&quot;, 1);
+			
+			Gtk.CellRendererText text_render = new Gtk.CellRendererText ();
+			complete_column.PackStart (text_render, true);
+			complete_column.AddAttribute (text_render, &quot;text&quot;, 0);
+	
+			listView.AppendColumn (complete_column);
+
+			Gtk.ScrolledWindow scroller = new Gtk.ScrolledWindow ();
+			scroller.Add (listView);
+
+			Gtk.Frame frame = new Gtk.Frame ();
+			frame.Add (scroller);
+			this.Add(frame);
+
+			imgList = completionDataProvider.ImageList;
+			listView.KeyPressEvent += new KeyPressEventHandler(ListKeypressEvent);
+			listView.KeyReleaseEvent += new KeyReleaseEventHandler(ListKeyreleaseEvent);
+			listView.FocusOutEvent += new FocusOutEventHandler(LostFocusListView);
+			listView.RowActivated += new RowActivatedHandler(ActivateItem);
+			listView.AddEvents ((int) (Gdk.EventMask.KeyPressMask));
+		}
+	
+		/// &lt;remarks&gt;
+		/// Shows the filled completion window, if it has no items it isn't shown.
+		/// &lt;/remarks&gt;
+		public void ShowCompletionWindow(char firstChar)
+		{
+			FillList(true, firstChar);
+
+			TreeIter iter;
+			if (store.GetIterFirst(out iter) == false) {
+				control.GrabFocus();
+				return;
+			}
+
+			//Point caretPos  = control.ActiveTextAreaControl.Caret.Position;
+			//Point visualPos = new Point(control.ActiveTextAreaControl.TextArea.TextView.GetDrawingXPos(caretPos.Y, caretPos.X) + control.ActiveTextAreaControl.TextArea.TextView.DrawingPosition.X,
+			//          (int)((1 + caretPos.Y) * control.ActiveTextAreaControl.TextArea.TextView.FontHeight) - control.ActiveTextAreaControl.TextArea.VirtualTop.Y - 1 + control.ActiveTextAreaControl.TextArea.TextView.DrawingPosition.Y);
+
+			int tx, ty;
+			//control.ActiveTextAreaControl.TextArea.GdkWindow.GetOrigin(out tx, out ty);
+			//Move(tx + visualPos.X, ty + visualPos.Y);
+			listView.Selection.Changed += new EventHandler (RowActivated);
+			ShowAll ();
+		}
+		string fileName;
+		
+		static CompletionWindow ()
+		{
+			type = RegisterGType (typeof (CompletionWindow));
+		}
+		
+		/// &lt;remarks&gt;
+		/// Creates a new Completion window and puts it location under the caret
+		/// &lt;/remarks&gt;
+		public CompletionWindow (SourceEditorView control, string fileName, ICompletionDataProvider completionDataProvider) : base (type)
+		{
+			this.fileName = fileName;
+			this.completionDataProvider = completionDataProvider;
+			this.control                = control;
+
+			InitializeControls();
+		}
+		
+		/// &lt;remarks&gt;
+		/// Creates a new Completion window at a given location
+		/// &lt;/remarks&gt;
+		CompletionWindow (SourceEditorView control, Point location, ICompletionDataProvider completionDataProvider) : base (type)
+		{
+			this.completionDataProvider = completionDataProvider;
+			this.control                = control;
+
+			InitializeControls();
+		}
+		
+		void ActivateItem(object sender, RowActivatedArgs e)
+		{
+			if (listView.Selection.CountSelectedRows() &gt; 0) {
+				TreeModel foo;
+				TreeIter iter;
+				listView.Selection.GetSelected(out foo, out iter);
+				ICompletionData data = (ICompletionData) store.GetValue(iter, 2);
+				DeleteInsertion();
+				data.InsertAction(control);
+				LostFocusListView(null, null);
+			}
+		}
+		
+		void LostFocusListView(object sender, FocusOutEventArgs e)
+		{
+			control.HasFocus = true;
+			declarationviewwindow.HideAll ();
+			Hide();
+		}
+		
+		void FillList(bool firstTime, char ch)
+		{
+			ICompletionData[] completionData = completionDataProvider.GenerateCompletionData(fileName, control, ch);
+			Console.WriteLine (&quot;testing&quot;);
+			if (completionData == null || completionData.Length == 0) {
+				return;
+			}
+
+			foreach (ICompletionData data in completionData) {
+				store.AppendValues (data.Text[0], imgList[data.ImageIndex], data);
+			}
+			// sort here
+			store.SetSortColumnId (0, SortType.Ascending);
+		}
+		
+		void RowActivated  (object sender, EventArgs a)
+		{
+			Gtk.TreeIter iter;
+			Gtk.TreeModel model;
+	
+			if (listView.Selection.GetSelected (out model, out iter)){
+				ICompletionData data = (ICompletionData) store.GetValue (iter, 2);
+				
+				//FIXME: This code is buggy, and generates a bad placement sometimes when you jump a lot. but it is better than 0,0
+				
+				Gtk.TreePath path = store.GetPath (iter);
+				Gdk.Rectangle rect;
+				rect = listView.GetCellArea (path, (Gtk.TreeViewColumn)listView.Columns[0]);
+
+				int x, y;
+				listView.TreeToWidgetCoords (rect.x, rect.y, out x, out y);
+				
+				int listpos_x, listpos_y;
+				GetPosition (out listpos_x, out listpos_y);
+				int vert = listpos_y + rect.y;
+
+				if (vert &gt; listpos_y + listView.GdkWindow.Size.Height) {
+					vert = listpos_y + listView.GdkWindow.Size.Height - rect.height;
+				} else if (vert &lt; listpos_y) {
+					vert = listpos_y;
+				}
+
+				//FIXME: This is a bad calc, its always on the right, it needs to test if thats too big, and if so, place on the left;
+				int horiz = listpos_x + listView.GdkWindow.Size.Width + 30;
+				ICompletionDataWithMarkup wMarkup = data as ICompletionDataWithMarkup;
+				declarationviewwindow.Destroy ();
+				if (wMarkup != null) {
+					declarationviewwindow = new DeclarationViewWindow ();
+					declarationviewwindow.DescriptionMarkup = wMarkup.DescriptionPango;
+				} else {
+					declarationviewwindow = new DeclarationViewWindow ();
+					declarationviewwindow.DescriptionMarkup = data.Description;
+				}
+				
+				declarationviewwindow.ShowAll ();
+				if (listView.Screen.Width &lt;= horiz + declarationviewwindow.GdkWindow.FrameExtents.Width) {
+					horiz = listpos_x - declarationviewwindow.GdkWindow.FrameExtents.Width - 10;
+				}
+				declarationviewwindow.Move (horiz, vert);
+			}
+		}
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs (from rev 704, trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/DeclarationViewWindow.cs)
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/DeclarationViewWindow.cs	2004-01-28 17:48:17 UTC (rev 704)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,44 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.TextEditor.Util;
+using ICSharpCode.TextEditor;
+
+using Gtk;
+using GtkSharp;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	public class DeclarationViewWindow : Gtk.Window
+	{
+		Label label;
+		
+		public string DescriptionMarkup {
+			get {
+				return label.Text;
+			}
+			
+			set {
+				label.Markup = value;
+				//QueueDraw ();
+			}
+		}
+		
+		public DeclarationViewWindow () : base (WindowType.Popup)
+		{
+			Gtk.Frame frame = new Gtk.Frame ();
+			frame.Add (label = new Label (&quot;&quot;));
+			Add (frame);
+		}
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs (from rev 704, trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/ICompletionData.cs)
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/ICompletionData.cs	2004-01-28 17:48:17 UTC (rev 704)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,40 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using MonoDevelop.SourceEditor.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	public interface ICompletionData
+	{
+		int ImageIndex {
+			get;
+		}
+		
+		string[] Text {
+			get;
+		}
+		
+		string Description {
+			get;
+		}
+		
+		void InsertAction(SourceEditorView control);
+	}
+	
+	public interface ICompletionDataWithMarkup : ICompletionData
+	{
+		string DescriptionPango {
+			get;
+		}
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs (from rev 704, trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/ICompletionDataProvider.cs)
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/ICompletionDataProvider.cs	2004-01-28 17:48:17 UTC (rev 704)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,29 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using ICSharpCode.TextEditor.Document;
+
+using Gdk;
+
+using MonoDevelop.SourceEditor.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	public interface ICompletionDataProvider
+	{
+		Pixbuf[] ImageList {
+			get;
+		}
+		
+		ICompletionData[] GenerateCompletionData(string fileName, SourceEditorView textArea, char charTyped);
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs (from rev 704, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/TemplateCompletionDataProvider.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/TemplateCompletionDataProvider.cs	2004-01-28 17:48:17 UTC (rev 704)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,78 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Templates;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.TextEditor;
+using ICSharpCode.TextEditor.Gui.CompletionWindow;
+
+using MonoDevelop.SourceEditor.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	public class TemplateCompletionDataProvider : ICompletionDataProvider
+	{
+		public Gdk.Pixbuf[] ImageList {
+			get {
+				return null;
+			}
+		}
+		
+		public ICompletionData[] GenerateCompletionData(string fileName, SourceEditorView textArea, char charTyped)
+		{
+			CodeTemplateGroup templateGroup = CodeTemplateLoader.GetTemplateGroupPerFilename(fileName);
+			if (templateGroup == null) {
+				return null;
+			}
+			ArrayList completionData = new ArrayList();
+			foreach (CodeTemplate template in templateGroup.Templates) {
+				completionData.Add(new TemplateCompletionData(template));
+			}
+			
+			return (ICompletionData[])completionData.ToArray(typeof(ICompletionData));
+		}
+		
+		class TemplateCompletionData : ICompletionData
+		{
+			CodeTemplate template;
+			
+			public int ImageIndex {
+				get {
+					return 0;
+				}
+			}
+			
+			public string[] Text {
+				get {
+					return new string[] { template.Shortcut, template.Description };
+				}
+			}
+			
+			public string Description {
+				get {
+					return template.Text;
+				}
+			}
+			
+			public void InsertAction(SourceEditorView control)
+			{
+				//((SharpDevelopTextAreaControl)control).InsertTemplate(template);
+			}
+			
+			public TemplateCompletionData(CodeTemplate template) 
+			{
+				this.template = template;
+			}
+		}
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs (from rev 707, trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/TextUtilities.cs)
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Document/TextUtilities.cs	2004-01-29 00:36:54 UTC (rev 707)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -0,0 +1,405 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Text;
+using System.Diagnostics;
+
+using ICSharpCode.TextEditor.Undo;
+
+using MonoDevelop.SourceEditor.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	public sealed class TextUtilities
+	{
+		
+		/// &lt;remarks&gt;
+		/// This function takes a string and converts the whitespace in front of
+		/// it to tabs. If the length of the whitespace at the start of the string
+		/// was not a whole number of tabs then there will still be some spaces just
+		/// before the text starts.
+		/// the output string will be of the form:
+		/// 1. zero or more tabs
+		/// 2. zero or more spaces (less than tabIndent)
+		/// 3. the rest of the line
+		/// &lt;/remarks&gt;
+/*		public static string LeadingWhiteSpaceToTabs(string line, int tabIndent) {
+			StringBuilder sb = new StringBuilder(line.Length);
+			int consecutiveSpaces = 0;
+			int i = 0;
+			for(i = 0; i &lt; line.Length; i++) {
+				if(line[i] == ' ') {
+					consecutiveSpaces++;
+					if(consecutiveSpaces == tabIndent) {
+						sb.Append('\t');
+						consecutiveSpaces = 0;
+					}
+				}
+				else if(line[i] == '\t') {
+					sb.Append('\t');
+					// if we had say 3 spaces then a tab and tabIndent was 4 then
+					// we would want to simply replace all of that with 1 tab
+					consecutiveSpaces = 0;					
+				}
+				else {
+					break;
+				}
+			}
+			if(i &lt; line.Length) {
+				sb.Append(line.Substring(i-consecutiveSpaces));
+			}
+			return sb.ToString();
+		}
+*/
+
+		public static bool IsLetterDigitOrUnderscore(char c)
+		{
+			if(!Char.IsLetterOrDigit(c)) {
+				return c == '_';
+			}
+			return true;
+		}
+		
+		public enum CharacterType {
+			LetterDigitOrUnderscore,
+			WhiteSpace,
+			Other
+		}
+		
+		/// &lt;remarks&gt;
+		/// This method returns the expression before a specified offset.
+		/// That method is used in code completion to determine the expression given
+		/// to the parser for type resolve.
+		/// &lt;/remarks&gt;
+		public static string GetExpressionBeforeOffset(SourceEditorView textArea, int offset)
+		{
+			while (offset - 1 &gt; 0) {
+				switch (textArea.Buffer.Text[offset - 1]) {
+					case '}':
+						goto done;
+//						offset = SearchBracketBackward(document, offset - 2, '{','}');
+//						break;
+					case ']':
+						offset = SearchBracketBackward(textArea, offset - 2, '[',']');
+						break;
+					case ')':
+						offset = SearchBracketBackward(textArea, offset - 2, '(',')');
+						break;
+					case '.':
+						--offset;
+						break;
+					case '&quot;':
+						return &quot;\&quot;\&quot;&quot;;
+					case '\'':
+						return &quot;'a'&quot;;
+					case '&gt;':
+						if (textArea.Buffer.Text[offset - 2] == '-') {
+							offset -= 2;
+							break;
+						}
+						goto done;
+					default:
+						if (Char.IsWhiteSpace(textArea.Buffer.Text[offset - 1])) {
+							--offset;
+							break;
+						}
+						int start = offset - 1;
+						if (!IsLetterDigitOrUnderscore(textArea.Buffer.Text[start])) {
+							goto done;
+						}
+						
+						while (start &gt; 0 &amp;&amp; IsLetterDigitOrUnderscore(textArea.Buffer.Text[start - 1])) {
+							--start;
+						}
+						
+						Console.WriteLine(&quot;{0} -- {1}&quot;, offset, start);
+						Gtk.TextIter startIter = textArea.Buffer.GetIterAtOffset (start);
+						Gtk.TextIter endIter = textArea.Buffer.GetIterAtOffset (offset);
+						string word = textArea.Buffer.GetText (startIter, endIter, false).Trim();
+						Console.WriteLine(&quot;word &gt;{0}&lt;&quot;, word);
+						switch (word) {
+							case &quot;ref&quot;:
+							case &quot;out&quot;:
+							case &quot;in&quot;:
+							case &quot;return&quot;:
+							case &quot;throw&quot;:
+							case &quot;case&quot;:
+								goto done;
+						}
+						
+						if (word.Length &gt; 0 &amp;&amp; !IsLetterDigitOrUnderscore(word[0])) {
+							goto done;
+						}
+						offset = start;
+						break;
+				}
+			}
+			done:
+//			Console.WriteLine(&quot;ofs : {0} cart:{1}&quot;, offset, document.Caret.Offset);
+//			Console.WriteLine(&quot;return:&quot; + document.GetText(offset, document.Caret.Offset - offset).Trim());
+			Gtk.TextIter start_Iter = textArea.Buffer.GetIterAtMark (textArea.Buffer.InsertMark);
+			Gtk.TextIter offset_Iter = textArea.Buffer.GetIterAtOffset (start_Iter.Offset - offset);
+			return textArea.Buffer.GetText (start_Iter, offset_Iter, false ).Trim();
+		}
+		
+/*		
+		public static CharacterType GetCharacterType(char c) 
+		{
+			if(IsLetterDigitOrUnderscore(c))
+				return CharacterType.LetterDigitOrUnderscore;
+			if(Char.IsWhiteSpace(c))
+				return CharacterType.WhiteSpace;
+			return CharacterType.Other;
+		}
+		
+		public static int GetFirstNonWSChar(IDocument document, int offset)
+		{
+			while (offset &lt; document.TextLength &amp;&amp; Char.IsWhiteSpace(document.GetCharAt(offset))) {
+				++offset;
+			}
+			return offset;
+		}
+		
+		public static int FindWordEnd(IDocument document, int offset)
+		{
+			LineSegment line   = document.GetLineSegmentForOffset(offset);
+			int     endPos = line.Offset + line.Length;
+			while (offset &lt; endPos &amp;&amp; IsLetterDigitOrUnderscore(document.GetCharAt(offset))) {
+				++offset;
+			}
+			
+			return offset;
+		}
+		
+		public static int FindWordStart(IDocument document, int offset)
+		{
+			LineSegment line = document.GetLineSegmentForOffset(offset);
+			
+			while (offset &gt; line.Offset &amp;&amp; !IsLetterDigitOrUnderscore(document.GetCharAt(offset - 1))) {
+				--offset;
+			}
+			
+			return offset;
+		}
+		
+		// go forward to the start of the next word
+		// if the cursor is at the start or in the middle of a word we move to the end of the word
+		// and then past any whitespace that follows it
+		// if the cursor is at the start or in the middle of some whitespace we move to the start of the
+		// next word
+		public static int FindNextWordStart(IDocument document, int offset)
+		{
+			int originalOffset = offset;
+			LineSegment line   = document.GetLineSegmentForOffset(offset);
+			int     endPos = line.Offset + line.Length;
+			// lets go to the end of the word, whitespace or operator
+			CharacterType t = GetCharacterType(document.GetCharAt(offset));
+			while (offset &lt; endPos &amp;&amp; GetCharacterType(document.GetCharAt(offset)) == t) {
+				++offset;
+			}
+			
+			// now we're at the end of the word, lets find the start of the next one by skipping whitespace
+			while (offset &lt; endPos &amp;&amp; GetCharacterType(document.GetCharAt(offset)) == CharacterType.WhiteSpace) {
+				++offset;
+			}
+
+			return offset;
+		}
+		
+		// go back to the start of the word we are on
+		// if we are already at the start of a word or if we are in whitespace, then go back
+		// to the start of the previous word
+		public static int FindPrevWordStart(IDocument document, int offset)
+		{
+			int originalOffset = offset;
+			LineSegment line = document.GetLineSegmentForOffset(offset);
+			if (offset &gt; 0) {
+				CharacterType t = GetCharacterType(document.GetCharAt(offset - 1));
+				while (offset &gt; line.Offset &amp;&amp; GetCharacterType(document.GetCharAt(offset - 1)) == t) {
+					--offset;
+				}
+				
+				// if we were in whitespace, and now we're at the end of a word or operator, go back to the beginning of it
+				if(t == CharacterType.WhiteSpace &amp;&amp; offset &gt; line.Offset) {
+					t = GetCharacterType(document.GetCharAt(offset - 1));
+					while (offset &gt; line.Offset &amp;&amp; GetCharacterType(document.GetCharAt(offset - 1)) == t) {
+						--offset;
+					}
+				}
+			}
+			
+			return offset;
+		}
+		
+		public static string GetLineAsString(IDocument document, int lineNumber)
+		{
+			LineSegment line = document.GetLineSegment(lineNumber);
+			return document.GetText(line.Offset, line.Length);
+		}
+*/
+		static bool ScanLineComment(SourceEditorView document, int offset)
+		{
+			while (offset &gt; 0 &amp;&amp; offset &lt; document.Buffer.Text.Length) {
+				char ch = document.Buffer.Text[offset];
+				switch (ch) {
+					case '\r':
+					case '\n':
+						return false;
+					case '/':
+						if (document.Buffer.Text[offset + 1] == '/') {
+							return true;
+						}
+						break;
+				}
+				--offset;
+			}
+			return false;
+		}
+		
+		public static int SearchBracketBackward(SourceEditorView document, int offset, char openBracket, char closingBracket)
+		{
+			int brackets = -1;
+			
+			bool inString = false;
+			bool inChar   = false;
+			
+			bool blockComment = false;
+			
+			while (offset &gt;= 0 &amp;&amp; offset &lt; document.Buffer.Text.Length) {
+				char ch = document.Buffer.Text[offset];
+				switch (ch) {
+					case '/':
+						if (blockComment) {
+							if (document.Buffer.Text[offset + 1]== '*') {
+								blockComment = false;
+							}
+						}
+						if (!inString &amp;&amp; !inChar &amp;&amp; offset + 1 &lt; document.Buffer.Text.Length) {
+							if (offset &gt; 0 &amp;&amp; document.Buffer.Text[offset - 1] == '*') {
+								blockComment = true;
+							}
+						}
+						break;
+					case '&quot;':
+						if (!inChar &amp;&amp; !blockComment &amp;&amp; !ScanLineComment(document, offset)) {
+							inString = !inString;
+						}
+						break;
+					case '\'':
+						if (!inString &amp;&amp; !blockComment &amp;&amp; !ScanLineComment(document, offset)) {
+							inChar = !inChar;
+						}
+						break;
+					default :
+						if (ch == closingBracket) {
+							if (!(inString || inChar || blockComment) &amp;&amp; !ScanLineComment(document, offset)) {
+								--brackets;
+							}
+						} else if (ch == openBracket) {
+							if (!(inString || inChar || blockComment) &amp;&amp; !ScanLineComment(document, offset)) {
+								++brackets;
+								if (brackets == 0) {
+									return offset;
+								}
+							}
+						}
+						break;
+				}
+				--offset;
+			}
+			return - 1;
+		}
+/*
+		public static int SearchBracketForward(IDocument document, int offset, char openBracket, char closingBracket)
+		{
+			int brackets = 1;
+			
+			bool inString = false;
+			bool inChar   = false;
+			
+			bool lineComment  = false;
+			bool blockComment = false;
+			
+			if (offset &gt;= 0) {
+				while (offset &lt; document.TextLength) {
+					char ch = document.GetCharAt(offset);
+					switch (ch) {
+						case '\r':
+						case '\n':
+							lineComment = false;
+							break;
+						case '/':
+							if (blockComment) {
+								Debug.Assert(offset &gt; 0);
+								if (document.GetCharAt(offset - 1) == '*') {
+									blockComment = false;
+								}
+							}
+							if (!inString &amp;&amp; !inChar &amp;&amp; offset + 1 &lt; document.TextLength) {
+								if (!blockComment &amp;&amp; document.GetCharAt(offset + 1) == '/') {
+									lineComment = true;
+								}
+								if (!lineComment &amp;&amp; document.GetCharAt(offset + 1) == '*') {
+									blockComment = true;
+								}
+							}
+							break;
+						case '&quot;':
+							if (!(inChar || lineComment || blockComment)) {
+								inString = !inString;
+							}
+							break;
+						case '\'':
+							if (!(inString || lineComment || blockComment)) {
+								inChar = !inChar;
+							}
+							break;
+						default :
+							if (ch == openBracket) {
+								if (!(inString || inChar || lineComment || blockComment)) {
+									++brackets;
+								}
+							} else if (ch == closingBracket) {
+								if (!(inString || inChar || lineComment || blockComment)) {
+									--brackets;
+									if (brackets == 0) {
+										return offset;
+									}
+								}
+							}
+							break;
+					}
+					++offset;
+				}
+			}
+			return -1;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns true, if the line lineNumber is empty or filled with whitespaces.
+		/// &lt;/remarks&gt;
+		public static bool IsEmptyLine(IDocument document, int lineNumber)
+		{
+			return IsEmptyLine(document, document.GetLineSegment(lineNumber));
+		}
+
+		/// &lt;remarks&gt;
+		/// Returns true, if the line lineNumber is empty or filled with whitespaces.
+		/// &lt;/remarks&gt;
+		public static bool IsEmptyLine(IDocument document, LineSegment line)
+		{
+			for (int i = line.Offset; i &lt; line.Offset + line.Length; ++i) {
+				char ch = document.GetCharAt(i);
+				if (!Char.IsWhiteSpace(ch)) {
+					return false;
+				}
+			}
+			return true;
+		}*/
+	}
+}

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorDisplayBinding.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorDisplayBinding.cs	2004-01-29 02:37:09 UTC (rev 710)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorDisplayBinding.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -82,7 +82,7 @@
 		
 		public SourceEditorDisplayBindingWrapper ()
 		{
-			se = new SourceEditor ();
+			se = new SourceEditor (this);
 			se.Buffer.ModifiedChanged += new EventHandler (OnModifiedChanged);
 			se.Buffer.MarkSet += new MarkSetHandler (OnMarkSet);
 			se.Buffer.Changed += new EventHandler (OnChanged);

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs	2004-01-29 02:37:09 UTC (rev 710)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -5,21 +5,27 @@
 using System;
 using System.IO;
 using System.Runtime.InteropServices;
+
+using MonoDevelop.SourceEditor.CodeCompletion;
 	
 namespace MonoDevelop.SourceEditor.Gui {
 	public class SourceEditorView : SourceView {
 		
 		private static GLib.GType type;
 			
-		SourceEditorBuffer buf;
+		                SourceEditorBuffer buf;
+		public readonly SourceEditor       ParentEditor;
+
+		CompletionWindow completionWindow;
 		
 		static SourceEditorView ()
 		{
 			type = RegisterGType (typeof (SourceEditorView));
 		}
 		
-		public SourceEditorView (SourceEditorBuffer buf) : base (type)
+		public SourceEditorView (SourceEditorBuffer buf, SourceEditor parent) : base (type)
 		{
+			this.ParentEditor = parent;
 			Buffer = this.buf = buf;
 			AutoIndent = true;
 			SmartHomeEnd = true;
@@ -52,6 +58,16 @@
 				}
 				break;
 			}
+
+			switch ((char)key) {
+				//FIXME: ' ' needs to do extra parsing
+				case ' ':
+				case '.':
+					Console.WriteLine (&quot;About to show completion Window&quot;);
+					completionWindow = new CompletionWindow (this, ParentEditor.DisplayBinding.ContentName, new CodeCompletionDataProvider ());
+					completionWindow.ShowCompletionWindow ((char)key);
+					break;
+			}
 			
 			base.OnKeyPressEvent (ref evnt);
 			return false;
@@ -145,4 +161,4 @@
 		}
 #endregion
 	}
-}
\ No newline at end of file
+}

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorWidget.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorWidget.cs	2004-01-29 02:37:09 UTC (rev 710)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorWidget.cs	2004-01-29 15:59:07 UTC (rev 711)
@@ -11,12 +11,14 @@
 		
 		public readonly SourceEditorBuffer Buffer;
 		public readonly SourceEditorView View;
+		public readonly SourceEditorDisplayBindingWrapper DisplayBinding;
 		
-		public SourceEditor ()
+		public SourceEditor (SourceEditorDisplayBindingWrapper bind)
 		{
+			DisplayBinding = bind;
 			Buffer = new SourceEditorBuffer ();
 			
-			View = new SourceEditorView (Buffer);
+			View = new SourceEditorView (Buffer, this);
 			
 
 			Buffer.Highlight = true;
@@ -94,4 +96,4 @@
 			&quot;....................................&quot;
 		};
 	}
-}
\ No newline at end of file
+}

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Makefile
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Makefile	2004-01-29 02:37:09 UTC (rev 710)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Makefile	2004-01-29 15:59:07 UTC (rev 711)
@@ -7,4 +7,5 @@
 		/r:../../../../build/bin/MonoDevelop.Core.dll \
 		/r:../../../../build/bin/MonoDevelop.TextEditor.dll \
 		/r:../../../../build/bin/MonoDevelop.Base.dll \
-		/r:../../../../build/bin/MonoDevelop.Gui.Utils.dll
+		/r:../../../../build/bin/MonoDevelop.Gui.Utils.dll \
+		/r:System.Drawing.dll


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000315.html">[Monodevelop-patches-list] r710 - trunk/MonoDevelop
</A></li>
	<LI>Next message: <A HREF="000317.html">[Monodevelop-patches-list] r712 - trunk/MonoDevelop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#316">[ date ]</a>
              <a href="thread.html#316">[ thread ]</a>
              <a href="subject.html#316">[ subject ]</a>
              <a href="author.html#316">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
