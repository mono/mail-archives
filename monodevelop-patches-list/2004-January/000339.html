<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r734 - in trunk/MonoDevelop: . gdldock gdldock/gdl gdldock/sources gdldock/sources/gdl gdldock/test
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r734%20-%20in%20trunk/MonoDevelop%3A%20.%20gdldock%20gdldock/gdl%20gdldock/sources%20gdldock/sources/gdl%20gdldock/test&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000338.html">
   <LINK REL="Next"  HREF="000340.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r734 - in trunk/MonoDevelop: . gdldock gdldock/gdl gdldock/sources gdldock/sources/gdl gdldock/test</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r734%20-%20in%20trunk/MonoDevelop%3A%20.%20gdldock%20gdldock/gdl%20gdldock/sources%20gdldock/sources/gdl%20gdldock/test&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r734 - in trunk/MonoDevelop: . gdldock gdldock/gdl gdldock/sources gdldock/sources/gdl gdldock/test">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sat Jan 31 14:16:44 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000338.html">[Monodevelop-patches-list] r733 - in trunk/MonoDevelop/src/Main/Base: Commands Gui/Components Internal/Codons/MenuItems Services/MenuService
</A></li>
        <LI>Next message: <A HREF="000340.html">[Monodevelop-patches-list] r735 - trunk/MonoDevelop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#339">[ date ]</a>
              <a href="thread.html#339">[ thread ]</a>
              <a href="subject.html#339">[ subject ]</a>
              <a href="author.html#339">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2004-01-31 14:16:43 -0500 (Sat, 31 Jan 2004)
New Revision: 734

Added:
   trunk/MonoDevelop/gdldock/
   trunk/MonoDevelop/gdldock/Makefile
   trunk/MonoDevelop/gdldock/gdl/
   trunk/MonoDevelop/gdldock/gdl/DockItemFlags.cs
   trunk/MonoDevelop/gdldock/gdl/DockParamFlags.cs
   trunk/MonoDevelop/gdldock/gdl/Gdl.metadata
   trunk/MonoDevelop/gdldock/gdl/Makefile
   trunk/MonoDevelop/gdldock/gdl/gdl-api.xml
   trunk/MonoDevelop/gdldock/sources/
   trunk/MonoDevelop/gdldock/sources/Makefile
   trunk/MonoDevelop/gdldock/sources/gdl-sharp-sources.xml
   trunk/MonoDevelop/gdldock/sources/gdl/
   trunk/MonoDevelop/gdldock/sources/gdl/Makefile
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-master.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-master.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-paned.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-paned.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.h
   trunk/MonoDevelop/gdldock/test/
   trunk/MonoDevelop/gdldock/test/GdlDockTest.cs
   trunk/MonoDevelop/gdldock/test/Makefile
Log:
initial gdldock wrapper


Added: trunk/MonoDevelop/gdldock/Makefile
===================================================================
--- trunk/MonoDevelop/gdldock/Makefile	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/Makefile	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,3 @@
+all:
+	cd gdl &amp;&amp; make
+	cd sources &amp;&amp; make

Added: trunk/MonoDevelop/gdldock/gdl/DockItemFlags.cs
===================================================================
--- trunk/MonoDevelop/gdldock/gdl/DockItemFlags.cs	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/gdl/DockItemFlags.cs	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,16 @@
+// This file was generated by the Gtk# code generator.
+// Any changes made will be lost if regenerated.
+
+namespace Gdl {
+
+	using System;
+
+#region Autogenerated code
+	public enum DockItemFlags {
+
+		InDrag = 1,
+		InPredrag = 2,
+		UserAction = 3,
+	}
+#endregion
+}

Added: trunk/MonoDevelop/gdldock/gdl/DockParamFlags.cs
===================================================================
--- trunk/MonoDevelop/gdldock/gdl/DockParamFlags.cs	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/gdl/DockParamFlags.cs	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,15 @@
+// This file was generated by the Gtk# code generator.
+// Any changes made will be lost if regenerated.
+
+namespace Gdl {
+
+	using System;
+
+#region Autogenerated code
+	public enum DockParamFlags {
+
+		Export = 1,
+		After = 2,
+	}
+#endregion
+}

Added: trunk/MonoDevelop/gdldock/gdl/Gdl.metadata
===================================================================
--- trunk/MonoDevelop/gdldock/gdl/Gdl.metadata	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/gdl/Gdl.metadata	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,6 @@
+&lt;metadata&gt;
+  &lt;attr path=&quot;/api/namespace/object[@cname='GdlDockObject']/signal[@name='Detach']&quot; name=&quot;name&quot;&gt;Detached&lt;/attr&gt;
+  &lt;attr path=&quot;/api/namespace/object[@cname='GdlDockObject']/signal[@name='Dock']&quot; name=&quot;name&quot;&gt;Docked&lt;/attr&gt;
+  &lt;attr path=&quot;/api/namespace/enum[@cname='GdlDockItemFlags']&quot; name=&quot;hidden&quot;&gt;1&lt;/attr&gt;
+  &lt;attr path=&quot;/api/namespace/enum[@cname='GdlDockParamFlags']&quot; name=&quot;hidden&quot;&gt;1&lt;/attr&gt;
+&lt;/metadata&gt;

Added: trunk/MonoDevelop/gdldock/gdl/Makefile
===================================================================
--- trunk/MonoDevelop/gdldock/gdl/Makefile	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/gdl/Makefile	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,26 @@
+MCS = mcs
+RUNTIME = mono
+ASSEMBLY = ../../build/bin/gdl-sharp.dll
+PREFIX ?= $(shell pkg-config --variable=prefix gapi)
+
+INCLUDE_APIS = \
+	$(PREFIX)/share/gapi/gdk-api.xml \
+	$(PREFIX)/share/gapi/gtk-api.xml \
+	$(PREFIX)/share/gapi/atk-api.xml
+			
+all: generated-stamp $(ASSEMBLY)
+
+generated-stamp: gdl-api.xml
+	gapi-fixup --api=gdl-api.xml --metadata=Gdl.metadata &amp;&amp; \
+	gapi-codegen --generate gdl-api.xml --include $(INCLUDE_APIS) --outdir=generated --customdir=. --assembly-name=gdl-sharp &amp;&amp; touch generated-stamp
+ 
+$(ASSEMBLY): generated-stamp
+	$(MCS) --unsafe --target library \
+	-r glib-sharp.dll -r gtk-sharp.dll -r gdk-sharp.dll \
+	--recurse '*.cs' -o $(ASSEMBLY)
+ 
+clean:
+	rm -f $(ASSEMBLY)
+	rm -f generated-stamp
+	rm -rf generated
+

Added: trunk/MonoDevelop/gdldock/gdl/gdl-api.xml
===================================================================
--- trunk/MonoDevelop/gdldock/gdl/gdl-api.xml	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/gdl/gdl-api.xml	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,569 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;api&gt;&lt;!--
+
+        This file was automatically generated.
+        Please DO NOT MODIFY THIS FILE, modify .metadata files instead.
+
+--&gt;
+  &lt;namespace name=&quot;Gdl&quot; library=&quot;gdl-1&quot;&gt;
+    &lt;enum name=&quot;DockItemBehavior&quot; cname=&quot;GdlDockItemBehavior&quot; type=&quot;flags&quot;&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_NORMAL&quot; name=&quot;Normal&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_NEVER_FLOATING&quot; name=&quot;NeverFloating&quot; value=&quot;1 &amp;lt;&amp;lt; 0&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_NEVER_VERTICAL&quot; name=&quot;NeverVertical&quot; value=&quot;1 &amp;lt;&amp;lt; 1&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_NEVER_HORIZONTAL&quot; name=&quot;NeverHorizontal&quot; value=&quot;1 &amp;lt;&amp;lt; 2&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_LOCKED&quot; name=&quot;Locked&quot; value=&quot;1 &amp;lt;&amp;lt; 3&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_CANT_DOCK_TOP&quot; name=&quot;CantDockTop&quot; value=&quot;1 &amp;lt;&amp;lt; 4&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_CANT_DOCK_BOTTOM&quot; name=&quot;CantDockBottom&quot; value=&quot;1 &amp;lt;&amp;lt; 5&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_CANT_DOCK_LEFT&quot; name=&quot;CantDockLeft&quot; value=&quot;1 &amp;lt;&amp;lt; 6&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_CANT_DOCK_RIGHT&quot; name=&quot;CantDockRight&quot; value=&quot;1 &amp;lt;&amp;lt; 7&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ITEM_BEH_CANT_DOCK_CENTER&quot; name=&quot;CantDockCenter&quot; value=&quot;1 &amp;lt;&amp;lt; 8&quot; /&gt;
+    &lt;/enum&gt;
+    &lt;enum name=&quot;DockItemFlags&quot; cname=&quot;GdlDockItemFlags&quot; type=&quot;enum&quot; hidden=&quot;1&quot;&gt;
+      &lt;member cname=&quot;GDL_DOCK_IN_DRAG&quot; name=&quot;InDrag&quot; value=&quot;1 &amp;lt;&amp;lt; GDL_DOCK_OBJECT_FLAGS_SHIFT&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_IN_PREDRAG&quot; name=&quot;InPredrag&quot; value=&quot;1 &amp;lt;&amp;lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 1)&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_USER_ACTION&quot; name=&quot;UserAction&quot; value=&quot;1 &amp;lt;&amp;lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 2)&quot; /&gt;
+    &lt;/enum&gt;
+    &lt;enum name=&quot;DockObjectFlags&quot; cname=&quot;GdlDockObjectFlags&quot; type=&quot;flags&quot;&gt;
+      &lt;member cname=&quot;GDL_DOCK_AUTOMATIC&quot; name=&quot;Automatic&quot; value=&quot;1 &amp;lt;&amp;lt; 0&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ATTACHED&quot; name=&quot;Attached&quot; value=&quot;1 &amp;lt;&amp;lt; 1&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_IN_REFLOW&quot; name=&quot;InReflow&quot; value=&quot;1 &amp;lt;&amp;lt; 2&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_IN_DETACH&quot; name=&quot;InDetach&quot; value=&quot;1 &amp;lt;&amp;lt; 3&quot; /&gt;
+    &lt;/enum&gt;
+    &lt;enum name=&quot;DockParamFlags&quot; cname=&quot;GdlDockParamFlags&quot; type=&quot;enum&quot; hidden=&quot;1&quot;&gt;
+      &lt;member cname=&quot;GDL_DOCK_PARAM_EXPORT&quot; name=&quot;Export&quot; value=&quot;1 &amp;lt;&amp;lt; G_PARAM_USER_SHIFT&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_PARAM_AFTER&quot; name=&quot;After&quot; value=&quot;1 &amp;lt;&amp;lt; (G_PARAM_USER_SHIFT + 1)&quot; /&gt;
+    &lt;/enum&gt;
+    &lt;enum name=&quot;DockPlacement&quot; cname=&quot;GdlDockPlacement&quot; type=&quot;enum&quot;&gt;
+      &lt;member cname=&quot;GDL_DOCK_NONE&quot; name=&quot;None&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_TOP&quot; name=&quot;Top&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_BOTTOM&quot; name=&quot;Bottom&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_RIGHT&quot; name=&quot;Right&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_LEFT&quot; name=&quot;Left&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_CENTER&quot; name=&quot;Center&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_FLOATING&quot; name=&quot;Floating&quot; /&gt;
+    &lt;/enum&gt;
+    &lt;object name=&quot;Dock&quot; cname=&quot;GdlDock&quot; parent=&quot;GdlDockObject&quot;&gt;
+      &lt;field cname=&quot;root&quot; type=&quot;GdlDockObject*&quot; /&gt;
+      &lt;field cname=&quot;_priv&quot; type=&quot;GdlDockPrivate*&quot; /&gt;
+      &lt;property name=&quot;Floating&quot; cname=&quot;floating&quot; type=&quot;gboolean&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;property name=&quot;DefaultTitle&quot; cname=&quot;default_title&quot; type=&quot;gchar*&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Width&quot; cname=&quot;width&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Height&quot; cname=&quot;height&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Floatx&quot; cname=&quot;floatx&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Floaty&quot; cname=&quot;floaty&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;signal name=&quot;LayoutChanged&quot; cname=&quot;layout_changed&quot; when=&quot;LAST&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDock*&quot; name=&quot;dock&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/signal&gt;
+      &lt;method name=&quot;AddFloatingItem&quot; cname=&quot;gdl_dock_add_floating_item&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockItem*&quot; name=&quot;item&quot; /&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;x&quot; /&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;y&quot; /&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;width&quot; /&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;height&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;AddItem&quot; cname=&quot;gdl_dock_add_item&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockItem*&quot; name=&quot;item&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockPlacement&quot; name=&quot;place&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetItemByName&quot; cname=&quot;gdl_dock_get_item_by_name&quot;&gt;
+        &lt;return-type type=&quot;GdlDockItem*&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;name&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetNamedItems&quot; cname=&quot;gdl_dock_get_named_items&quot;&gt;
+        &lt;return-type type=&quot;GList*&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetPlaceholderByName&quot; cname=&quot;gdl_dock_get_placeholder_by_name&quot;&gt;
+        &lt;return-type type=&quot;GdlDockPlaceholder*&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;name&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_new&quot; /&gt;
+      &lt;constructor cname=&quot;gdl_dock_new_from&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDock*&quot; name=&quot;original&quot; /&gt;
+          &lt;parameter type=&quot;gboolean&quot; name=&quot;floating&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
+      &lt;method name=&quot;ParamGetType&quot; cname=&quot;gdl_dock_param_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;XorRect&quot; cname=&quot;gdl_dock_xor_rect&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdkRectangle*&quot; name=&quot;rect&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockItem&quot; cname=&quot;GdlDockItem&quot; parent=&quot;GdlDockObject&quot;&gt;
+      &lt;field cname=&quot;child&quot; type=&quot;GtkWidget*&quot; /&gt;
+      &lt;field cname=&quot;behavior&quot; type=&quot;GdlDockItemBehavior&quot; /&gt;
+      &lt;field cname=&quot;orientation&quot; type=&quot;GtkOrientation&quot; /&gt;
+      &lt;field cname=&quot;resize&quot; bits=&quot;1&quot; type=&quot;guint&quot; /&gt;
+      &lt;field cname=&quot;dragoff_x&quot; type=&quot;gint&quot; /&gt;
+      &lt;field cname=&quot;dragoff_y&quot; type=&quot;gint&quot; /&gt;
+      &lt;field cname=&quot;fromoutside* /GdlDockItemPrivate* _priv&quot; type=&quot;accesible&quot; /&gt;
+      &lt;property name=&quot;Orientation&quot; cname=&quot;orientation&quot; type=&quot;GtkOrientation&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Resize&quot; cname=&quot;resize&quot; type=&quot;gboolean&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Behavior&quot; cname=&quot;behavior&quot; type=&quot;GdlDockItemBehavior&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;GripSize&quot; cname=&quot;grip_size&quot; type=&quot;guint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Locked&quot; cname=&quot;locked&quot; type=&quot;gboolean&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;PreferredWidth&quot; cname=&quot;preferred_width&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;PreferredHeight&quot; cname=&quot;preferred_height&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;signal name=&quot;DockDragBegin&quot; cname=&quot;dock_drag_begin&quot; when=&quot;FIRST&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockItem*&quot; name=&quot;item&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/signal&gt;
+      &lt;signal name=&quot;DockDragMotion&quot; cname=&quot;dock_drag_motion&quot; when=&quot;FIRST&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockItem*&quot; name=&quot;item&quot; /&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;x&quot; /&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;y&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/signal&gt;
+      &lt;signal name=&quot;DockDragEnd&quot; cname=&quot;dock_drag_end&quot; when=&quot;FIRST&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockItem*&quot; name=&quot;item&quot; /&gt;
+          &lt;parameter type=&quot;gboolean&quot; name=&quot;cancelled&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/signal&gt;
+      &lt;method name=&quot;Bind&quot; cname=&quot;gdl_dock_item_bind&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GtkWidget*&quot; name=&quot;dock&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;DockTo&quot; cname=&quot;gdl_dock_item_dock_to&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockItem*&quot; name=&quot;target&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockPlacement&quot; name=&quot;position&quot; /&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;docking_param&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetTablabel&quot; cname=&quot;gdl_dock_item_get_tablabel&quot;&gt;
+        &lt;return-type type=&quot;GtkWidget*&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_item_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;HideGrip&quot; cname=&quot;gdl_dock_item_hide_grip&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;HideItem&quot; cname=&quot;gdl_dock_item_hide_item&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Lock&quot; cname=&quot;gdl_dock_item_lock&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_item_new&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;name&quot; /&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;long_name&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockItemBehavior&quot; name=&quot;behavior&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
+      &lt;method name=&quot;PreferredSize&quot; cname=&quot;gdl_dock_item_preferred_size&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GtkRequisition*&quot; name=&quot;req&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;SetDefaultPosition&quot; cname=&quot;gdl_dock_item_set_default_position&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;reference&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;SetOrientation&quot; cname=&quot;gdl_dock_item_set_orientation&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GtkOrientation&quot; name=&quot;orientation&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;SetTablabel&quot; cname=&quot;gdl_dock_item_set_tablabel&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GtkWidget*&quot; name=&quot;tablabel&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;ShowGrip&quot; cname=&quot;gdl_dock_item_show_grip&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;ShowItem&quot; cname=&quot;gdl_dock_item_show_item&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Unbind&quot; cname=&quot;gdl_dock_item_unbind&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Unlock&quot; cname=&quot;gdl_dock_item_unlock&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockItemGrip&quot; cname=&quot;GdlDockItemGrip&quot; parent=&quot;GtkWidget&quot;&gt;
+      &lt;field cname=&quot;item&quot; type=&quot;GdlDockItem*&quot; /&gt;
+      &lt;signal name=&quot;Activate&quot; cname=&quot;activate&quot; when=&quot;LAST&quot;&gt;
+        &lt;return-type type=&quot;GCclosureMarshalVoid_Void&quot; /&gt;
+      &lt;/signal&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_item_grip_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_item_grip_new&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockItem*&quot; name=&quot;item&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockLayout&quot; cname=&quot;GdlDockLayout&quot; parent=&quot;GObject&quot;&gt;
+      &lt;field cname=&quot;dirty&quot; type=&quot;gboolean&quot; /&gt;
+      &lt;field cname=&quot;master&quot; type=&quot;GdlDockMaster*&quot; /&gt;
+      &lt;field cname=&quot;_priv&quot; type=&quot;GdlDockLayoutPrivate*&quot; /&gt;
+      &lt;property name=&quot;Master&quot; cname=&quot;master&quot; type=&quot;GdlDockMaster&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Dirty&quot; cname=&quot;dirty&quot; type=&quot;gboolean&quot; readable=&quot;true&quot; /&gt;
+      &lt;method name=&quot;Attach&quot; cname=&quot;gdl_dock_layout_attach&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockMaster*&quot; name=&quot;master&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;DeleteLayout&quot; cname=&quot;gdl_dock_layout_delete_layout&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;name&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetItemsUi&quot; cname=&quot;gdl_dock_layout_get_items_ui&quot;&gt;
+        &lt;return-type type=&quot;GtkWidget*&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetLayouts&quot; cname=&quot;gdl_dock_layout_get_layouts&quot;&gt;
+        &lt;return-type type=&quot;GList*&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;gboolean&quot; name=&quot;include_default&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetLayoutsUi&quot; cname=&quot;gdl_dock_layout_get_layouts_ui&quot;&gt;
+        &lt;return-type type=&quot;GtkWidget*&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_layout_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetUi&quot; cname=&quot;gdl_dock_layout_get_ui&quot;&gt;
+        &lt;return-type type=&quot;GtkWidget*&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;IsDirty&quot; cname=&quot;gdl_dock_layout_is_dirty&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;LoadFromFile&quot; cname=&quot;gdl_dock_layout_load_from_file&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;filename&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;LoadLayout&quot; cname=&quot;gdl_dock_layout_load_layout&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;name&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_layout_new&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDock*&quot; name=&quot;dock&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
+      &lt;method name=&quot;RunManager&quot; cname=&quot;gdl_dock_layout_run_manager&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;SaveLayout&quot; cname=&quot;gdl_dock_layout_save_layout&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;name&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;SaveToFile&quot; cname=&quot;gdl_dock_layout_save_to_file&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;filename&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockMaster&quot; cname=&quot;GdlDockMaster&quot; parent=&quot;GObject&quot;&gt;
+      &lt;field cname=&quot;dock_objects&quot; type=&quot;GHashTable*&quot; /&gt;
+      &lt;field cname=&quot;toplevel_docks&quot; type=&quot;GList*&quot; /&gt;
+      &lt;field cname=&quot;controller&quot; type=&quot;GdlDockObject*&quot; /&gt;
+      &lt;field cname=&quot;dock_number&quot; type=&quot;gint&quot; /&gt;
+      &lt;field cname=&quot;_priv&quot; type=&quot;GdlDockMasterPrivate*&quot; /&gt;
+      &lt;property name=&quot;DefaultTitle&quot; cname=&quot;default_title&quot; type=&quot;gchar*&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Locked&quot; cname=&quot;locked&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;signal name=&quot;LayoutChanged&quot; cname=&quot;layout_changed&quot; when=&quot;LAST&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockMaster*&quot; name=&quot;master&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/signal&gt;
+      &lt;method name=&quot;Add&quot; cname=&quot;gdl_dock_master_add&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;object&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Foreach&quot; cname=&quot;gdl_dock_master_foreach&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GFunc&quot; name=&quot;function&quot; /&gt;
+          &lt;parameter type=&quot;gpointer&quot; name=&quot;user_data&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;ForeachToplevel&quot; cname=&quot;gdl_dock_master_foreach_toplevel&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;gboolean&quot; name=&quot;include_controller&quot; /&gt;
+          &lt;parameter type=&quot;GFunc&quot; name=&quot;function&quot; /&gt;
+          &lt;parameter type=&quot;gpointer&quot; name=&quot;user_data&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetController&quot; cname=&quot;gdl_dock_master_get_controller&quot;&gt;
+        &lt;return-type type=&quot;GdlDockObject*&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetObject&quot; cname=&quot;gdl_dock_master_get_object&quot;&gt;
+        &lt;return-type type=&quot;GdlDockObject*&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;nick_name&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_master_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Remove&quot; cname=&quot;gdl_dock_master_remove&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;object&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;SetController&quot; cname=&quot;gdl_dock_master_set_controller&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;new_controller&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockNotebook&quot; cname=&quot;GdlDockNotebook&quot; parent=&quot;GdlDockItem&quot;&gt;
+      &lt;property name=&quot;Page&quot; cname=&quot;page&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_notebook_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_notebook_new&quot; /&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockObject&quot; cname=&quot;GdlDockObject&quot; parent=&quot;GtkContainer&quot;&gt;
+      &lt;field cname=&quot;flags&quot; type=&quot;GdlDockObjectFlags&quot; /&gt;
+      &lt;field cname=&quot;freeze_count&quot; type=&quot;gint&quot; /&gt;
+      &lt;field cname=&quot;master&quot; type=&quot;GObject*&quot; /&gt;
+      &lt;field cname=&quot;name&quot; type=&quot;gchar*&quot; /&gt;
+      &lt;field cname=&quot;long_name&quot; type=&quot;gchar*&quot; /&gt;
+      &lt;field cname=&quot;reduce_pending&quot; type=&quot;gboolean&quot; /&gt;
+      &lt;property name=&quot;Name&quot; cname=&quot;name&quot; type=&quot;gchar*&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;property name=&quot;LongName&quot; cname=&quot;long_name&quot; type=&quot;gchar*&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Master&quot; cname=&quot;master&quot; type=&quot;GdlDockMaster&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;signal cname=&quot;detach&quot; when=&quot;LAST&quot; name=&quot;Detached&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;object&quot; /&gt;
+          &lt;parameter type=&quot;gboolean&quot; name=&quot;recursive&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/signal&gt;
+      &lt;signal cname=&quot;dock&quot; when=&quot;FIRST&quot; name=&quot;Docked&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;object&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;requestor&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockPlacement&quot; name=&quot;position&quot; /&gt;
+          &lt;parameter type=&quot;GValue*&quot; name=&quot;other_data&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/signal&gt;
+      &lt;method name=&quot;Bind&quot; cname=&quot;gdl_dock_object_bind&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GObject*&quot; name=&quot;master&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;ChildPlacement&quot; cname=&quot;gdl_dock_object_child_placement&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;child&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockPlacement*&quot; name=&quot;placement&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Detach&quot; cname=&quot;gdl_dock_object_detach&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;gboolean&quot; name=&quot;recursive&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Dock&quot; cname=&quot;gdl_dock_object_dock&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;requestor&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockPlacement&quot; name=&quot;position&quot; /&gt;
+          &lt;parameter type=&quot;GValue*&quot; name=&quot;other_data&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;DockRequest&quot; cname=&quot;gdl_dock_object_dock_request&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;x&quot; /&gt;
+          &lt;parameter type=&quot;gint&quot; name=&quot;y&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockRequest*&quot; name=&quot;request&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Freeze&quot; cname=&quot;gdl_dock_object_freeze&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetParentObject&quot; cname=&quot;gdl_dock_object_get_parent_object&quot;&gt;
+        &lt;return-type type=&quot;GdlDockObject*&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetToplevel&quot; cname=&quot;gdl_dock_object_get_toplevel&quot;&gt;
+        &lt;return-type type=&quot;GdlDock*&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_object_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;IsBound&quot; cname=&quot;gdl_dock_object_is_bound&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;IsCompound&quot; cname=&quot;gdl_dock_object_is_compound&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;NickFromType&quot; cname=&quot;gdl_dock_object_nick_from_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;const-gchar*&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GType&quot; name=&quot;type&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Present&quot; cname=&quot;gdl_dock_object_present&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;child&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Reduce&quot; cname=&quot;gdl_dock_object_reduce&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Reorder&quot; cname=&quot;gdl_dock_object_reorder&quot;&gt;
+        &lt;return-type type=&quot;gboolean&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;child&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockPlacement&quot; name=&quot;new_position&quot; /&gt;
+          &lt;parameter type=&quot;GValue*&quot; name=&quot;other_data&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;SetTypeForNick&quot; cname=&quot;gdl_dock_object_set_type_for_nick&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;nick&quot; /&gt;
+          &lt;parameter type=&quot;GType&quot; name=&quot;type&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Thaw&quot; cname=&quot;gdl_dock_object_thaw&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;TypeFromNick&quot; cname=&quot;gdl_dock_object_type_from_nick&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;nick&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Unbind&quot; cname=&quot;gdl_dock_object_unbind&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockPaned&quot; cname=&quot;GdlDockPaned&quot; parent=&quot;GdlDockItem&quot;&gt;
+      &lt;field cname=&quot;position_changed&quot; type=&quot;gboolean&quot; /&gt;
+      &lt;property name=&quot;Position&quot; cname=&quot;position&quot; type=&quot;guint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_paned_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_paned_new&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GtkOrientation&quot; name=&quot;orientation&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockPlaceholder&quot; cname=&quot;GdlDockPlaceholder&quot; parent=&quot;GdlDockObject&quot;&gt;
+      &lt;field cname=&quot;_priv&quot; type=&quot;GdlDockPlaceholderPrivate*&quot; /&gt;
+      &lt;property name=&quot;Sticky&quot; cname=&quot;sticky&quot; type=&quot;gboolean&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
+      &lt;property name=&quot;Host&quot; cname=&quot;host&quot; type=&quot;GdlDockObject&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;NextPlacement&quot; cname=&quot;next_placement&quot; type=&quot;GdlDockPlacement&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;method name=&quot;Attach&quot; cname=&quot;gdl_dock_placeholder_attach&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;object&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_placeholder_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_placeholder_new&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;gchar*&quot; name=&quot;name&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockObject*&quot; name=&quot;object&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockPlacement&quot; name=&quot;position&quot; /&gt;
+          &lt;parameter type=&quot;gboolean&quot; name=&quot;sticky&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;DockTablabel&quot; cname=&quot;GdlDockTablabel&quot; parent=&quot;GtkBin&quot;&gt;
+      &lt;field cname=&quot;drag_handle_size&quot; type=&quot;guint&quot; /&gt;
+      &lt;field cname=&quot;item&quot; type=&quot;GtkWidget*&quot; /&gt;
+      &lt;field cname=&quot;event_window&quot; type=&quot;GdkWindow*&quot; /&gt;
+      &lt;field cname=&quot;active&quot; type=&quot;gboolean&quot; /&gt;
+      &lt;field cname=&quot;drag_start_event&quot; type=&quot;GdkEventButton&quot; /&gt;
+      &lt;field cname=&quot;pre_drag&quot; type=&quot;gboolean&quot; /&gt;
+      &lt;property name=&quot;Item&quot; cname=&quot;item&quot; type=&quot;GdlDockItem&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;signal name=&quot;ButtonPressedHandle&quot; cname=&quot;button_pressed_handle&quot; when=&quot;LAST&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockTablabel*&quot; name=&quot;tablabel&quot; /&gt;
+          &lt;parameter type=&quot;GdkEventButton*&quot; name=&quot;event&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/signal&gt;
+      &lt;method name=&quot;Activate&quot; cname=&quot;gdl_dock_tablabel_activate&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;Deactivate&quot; cname=&quot;gdl_dock_tablabel_deactivate&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_tablabel_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_tablabel_new&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDockItem*&quot; name=&quot;item&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
+    &lt;/object&gt;
+    &lt;struct name=&quot;DockRequest&quot; cname=&quot;GdlDockRequest&quot;&gt;
+      &lt;field cname=&quot;applicant&quot; type=&quot;GdlDockObject*&quot; /&gt;
+      &lt;field cname=&quot;target&quot; type=&quot;GdlDockObject*&quot; /&gt;
+      &lt;field cname=&quot;position&quot; type=&quot;GdlDockPlacement&quot; /&gt;
+      &lt;field cname=&quot;rect&quot; type=&quot;GdkRectangle&quot; /&gt;
+      &lt;field cname=&quot;extra&quot; type=&quot;GValue&quot; /&gt;
+    &lt;/struct&gt;
+  &lt;/namespace&gt;
+&lt;/api&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/gdldock/sources/Makefile
===================================================================
--- trunk/MonoDevelop/gdldock/sources/Makefile	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/Makefile	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,5 @@
+all:
+
+api: gdl/*.h
+	gapi-parser gdl-sharp-sources.xml
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/Makefile
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/Makefile	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/Makefile	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,38 @@
+INCLUDES = \
+	-DG_LOG_DOMAIN=\&quot;Gdl\&quot;				\
+	-I$(includedir) -I$(top_srcdir)			\
+	$(WARN_CFLAGS) $(DEPRECATED_FLAGS)		\
+	$(GDL_DEPENDENCIES_CFLAGS) $(XML_CFLAGS)
+
+lib_LTLIBRARIES = libgdl-1.la
+
+libgdl_headers = \
+	gdl.h \
+	gdl-dock-object.h \
+	gdl-dock-master.h \
+	gdl-dock.h \
+	gdl-dock-item.h \
+	gdl-dock-item-grip.h \
+	gdl-dock-notebook.h \
+	gdl-dock-paned.h \
+	gdl-dock-tablabel.h \
+	gdl-dock-layout.h \
+	gdl-dock-placeholder.h \
+
+libgdl_1_la_SOURCES = \
+	$(libgdl_headers) \
+	gdl-dock-object.c \
+	gdl-dock-master.c \
+	gdl-dock.c \
+	gdl-dock-item.c \
+	gdl-dock-item-grip.c \
+	gdl-dock-notebook.c \
+	gdl-dock-paned.c \
+	gdl-dock-tablabel.c \
+	gdl-dock-layout.c \
+	gdl-dock-placeholder.c \
+
+libgdl_1_la_LIBADD = \
+	$(GDL_DEPENDENCIES_LIBS) \
+	$(XML_LIBS)
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,362 @@
+/* -*- Mode: C; indent-tabs-mode: nil; c-basic-offset: 4; tab-width: 8 -*- */
+/**
+ * gdl-dock-item-grip.c
+ *
+ * Based on bonobo-dock-item-grip.  Original copyright notice follows.
+ *
+ * Author:
+ *    Michael Meeks
+ *
+ * Copyright (C) 2002 Sun Microsystems, Inc.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;string.h&gt;
+#include &lt;glib-object.h&gt;
+#include &lt;atk/atkstateset.h&gt;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtk/gtkaccessible.h&gt;
+#include &lt;gtk/gtkbindings.h&gt;
+#include &lt;libgnome/gnome-macros.h&gt;
+#include &quot;gdl-dock-item.h&quot;
+#include &quot;gdl-dock-item-grip.h&quot;
+#include &quot;gdl-dock.h&quot;
+#include &quot;gdl-tools.h&quot;
+
+#define A11Y_UNFINISHED
+
+enum {
+    ACTIVATE,
+    LAST_SIGNAL
+};
+static guint signals [LAST_SIGNAL];
+
+GNOME_CLASS_BOILERPLATE (GdlDockItemGrip, gdl_dock_item_grip,
+			 GtkWidget, GTK_TYPE_WIDGET);
+
+static gint
+gdl_dock_item_grip_expose (GtkWidget      *widget,
+			   GdkEventExpose *event)
+{
+    GdkRectangle *clip = &amp;event-&gt;area;
+    GdkRectangle *rect = &amp;widget-&gt;allocation;
+    GdlDockItemGrip *grip = (GdlDockItemGrip *) widget;
+    GtkShadowType shadow = GTK_SHADOW_OUT;
+
+    gtk_paint_handle (widget-&gt;style,
+                      widget-&gt;window,
+                      GTK_WIDGET_STATE (widget),
+                      shadow,
+                      clip, widget, &quot;dockitem&quot;,
+                      rect-&gt;x, rect-&gt;y, rect-&gt;width, rect-&gt;height, 
+                      grip-&gt;item-&gt;orientation);
+
+    if (GTK_WIDGET_HAS_FOCUS (widget)) {
+        gint focus_width;
+        gint focus_pad;
+        GdkRectangle focus;
+		
+        gtk_widget_style_get (GTK_WIDGET (widget),
+                              &quot;focus-line-width&quot;, &amp;focus_width,
+                              &quot;focus-padding&quot;, &amp;focus_pad,
+                              NULL); 
+		
+        focus = *rect;
+        focus.x += widget-&gt;style-&gt;xthickness + focus_pad;
+        focus.y += widget-&gt;style-&gt;ythickness + focus_pad;
+        focus.width -= 2 * (widget-&gt;style-&gt;xthickness + focus_pad);
+        focus.height -= 2 * (widget-&gt;style-&gt;xthickness + focus_pad);
+		
+        gtk_paint_focus (widget-&gt;style, widget-&gt;window,
+                         GTK_WIDGET_STATE (widget),
+                         clip, widget, &quot;dockitem&quot;,
+                         focus.x, focus.y,
+                         focus.width, focus.height);
+    }
+
+    return FALSE;
+}
+
+
+#ifndef A11Y_UNFINISHED
+
+static AtkObjectClass *a11y_parent_class = NULL;
+
+static void
+grip_item_a11y_initialize (AtkObject *accessible, gpointer widget)
+{
+    accessible-&gt;role = ATK_ROLE_SEPARATOR;
+    atk_object_set_name (accessible, &quot;grip&quot;);
+
+    a11y_parent_class-&gt;initialize (accessible, widget);
+}
+
+static AtkStateSet*
+grip_item_a11y_ref_state_set (AtkObject *accessible)
+{
+    AtkStateSet *state_set;
+    GdlDockItemGrip *grip;
+
+    state_set = a11y_parent_class-&gt;ref_state_set (accessible);
+    grip = GDL_DOCK_ITEM_GRIP (
+        GTK_ACCESSIBLE (accessible)-&gt;widget);
+
+    if (grip == NULL)
+        return state_set;
+
+    if (grip-&gt;item-&gt;orientation == GTK_ORIENTATION_VERTICAL) {
+        atk_state_set_add_state (state_set, ATK_STATE_VERTICAL);
+        atk_state_set_remove_state (state_set, ATK_STATE_HORIZONTAL);
+    } else {
+        atk_state_set_add_state (state_set, ATK_STATE_HORIZONTAL);
+        atk_state_set_remove_state (state_set, ATK_STATE_VERTICAL);
+    }
+
+    return state_set;
+}
+
+static GdlDock *
+get_dock (GtkWidget *widget)
+{
+    while (widget &amp;&amp; !GDL_IS_DOCK (widget))
+        widget = widget-&gt;parent;
+
+    return (GdlDock *) widget;
+}
+
+static void
+gdl_dock_item_grip_dock (GdlDockItemGrip *grip)
+{
+    GdlDock *dock;
+
+    g_return_if_fail (GDL_IS_DOCK_ITEM_GRIP (grip));
+
+    dock = get_dock (GTK_WIDGET (grip-&gt;item));
+    g_return_if_fail (dock != NULL);
+
+    gdl_dock_item_unfloat (grip-&gt;item);
+		
+    g_object_ref (G_OBJECT (grip-&gt;item));
+    gtk_container_remove (
+        GTK_CONTAINER (
+            GTK_WIDGET (grip-&gt;item)-&gt;parent),
+        GTK_WIDGET (grip-&gt;item));
+    gdl_dock_add_item (
+        dock, grip-&gt;item,
+        BONOBO_DOCK_TOP, 2, 0, 0, TRUE);
+    g_object_unref (G_OBJECT (grip-&gt;item));
+}
+
+static void
+gdl_dock_item_grip_undock (GdlDockItemGrip *grip)
+{
+    guint x, y;
+
+    g_return_if_fail (BONOBO_IS_DOCK_ITEM_GRIP (grip));
+
+    if (grip-&gt;item-&gt;is_floating)
+        return;
+
+    gdk_window_get_position (
+        GTK_WIDGET (grip)-&gt;window, &amp;x, &amp;y);
+
+    gdl_dock_item_detach (grip-&gt;item, x, y);
+}
+
+enum {
+    ACTION_DOCK,
+    ACTION_UNDOCK,
+    ACTION_LAST
+};
+
+static gboolean
+gdl_dock_item_grip_do_action (AtkAction *action,
+			      gint       i)
+{
+    GdlDockItemGrip *grip;
+
+    grip = GDL_DOCK_ITEM_GRIP (
+        GTK_ACCESSIBLE (action)-&gt;widget);
+
+    if (grip-&gt;item-&gt;behavior &amp; GDL_DOCK_ITEM_BEH_LOCKED)
+        return FALSE;
+
+    switch (i) {
+    case ACTION_DOCK:
+        gdl_dock_item_grip_dock (grip);
+        break;
+    case ACTION_UNDOCK:
+        gdl_dock_item_grip_undock (grip);
+        break;
+    default:
+        break;
+    }
+    return FALSE;
+}
+
+static gint
+gdl_dock_item_grip_get_n_actions (AtkAction *action)
+{
+    GdlDockItemGrip *grip;
+
+    grip = GDL_DOCK_ITEM_GRIP (
+        GTK_ACCESSIBLE (action)-&gt;widget);
+
+    if (grip-&gt;item-&gt;behavior &amp; GDL_DOCK_ITEM_BEH_LOCKED)
+        return 0;
+    else
+        return ACTION_LAST;
+}
+
+static void
+grip_item_a11y_class_init (AtkObjectClass *klass)
+{
+    a11y_parent_class = g_type_class_peek_parent (klass);
+
+    klass-&gt;initialize = grip_item_a11y_initialize;
+    klass-&gt;ref_state_set = grip_item_a11y_ref_state_set;
+}
+
+#endif /* A11Y_UNFINISHED */
+
+
+static AtkObject *
+gdl_dock_item_grip_get_accessible (GtkWidget *widget)
+{
+#ifndef A11Y_UNFINISHED
+    AtkObject *accessible;
+    static GType a11y_type = 0;
+
+    if (!a11y_type) {
+        AtkActionIface action_if;
+
+        a11y_type = bonobo_a11y_get_derived_type_for (
+            GDL_TYPE_DOCK_ITEM_GRIP,
+            NULL, grip_item_a11y_class_init);
+
+        memset (&amp;action_if, 0, sizeof (AtkActionIface));
+        action_if.do_action = gdl_dock_item_grip_do_action;
+        action_if.get_n_actions = gdl_dock_item_grip_get_n_actions;
+
+        bonobo_a11y_add_actions_interface (
+            a11y_type, &amp;action_if,
+            ACTION_DOCK,   &quot;dock&quot;,   _(&quot;Dock the toolbar&quot;),    &quot;&lt;Enter&gt;&quot;,
+            ACTION_UNDOCK, &quot;undock&quot;, _(&quot;Un dock the toolbar&quot;), &quot;&lt;Enter&gt;&quot;,
+            -1);
+    }
+
+    if ((accessible = bonobo_a11y_get_atk_object (widget)))
+        return accessible;
+
+    return bonobo_a11y_set_atk_object_ret (
+        widget, g_object_new (a11y_type, NULL));
+#else /* !A11Y_UNFINISHED */
+    return NULL;
+#endif /* A11Y_UNFINISHED */
+}
+
+static void
+gdl_dock_item_grip_activate (GdlDockItemGrip *grip)
+{
+#ifndef A11Y_UNFINISHED
+    if (grip-&gt;item-&gt;is_floating)
+        gdl_dock_item_grip_dock (grip);
+    else
+        gdl_dock_item_grip_undock (grip);
+#endif /* A11Y_UNFINISHED */
+}
+
+static void
+gdl_dock_item_grip_dispose (GObject *object)
+{
+    GNOME_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+}
+
+static void
+gdl_dock_item_grip_instance_init (GdlDockItemGrip *grip)
+{
+    GTK_WIDGET_SET_FLAGS (grip, GTK_CAN_FOCUS);
+    GTK_WIDGET_SET_FLAGS (grip, GTK_NO_WINDOW);
+}
+
+#ifndef A11Y_UNFINISHED
+static BonoboDockBand *
+get_dock_band (GtkWidget *widget)
+{
+    while (widget &amp;&amp; !BONOBO_IS_DOCK_BAND (widget))
+        widget = widget-&gt;parent;
+
+    return (BonoboDockBand *) widget;
+}
+#endif /* A11Y_UNFINISHED */
+
+static gint
+gdl_dock_item_grip_key_press_event (GtkWidget   *widget,
+                                    GdkEventKey *event)
+{
+#ifndef A11Y_UNFINISHED
+    gboolean had_focus = GTK_WIDGET_HAS_FOCUS (widget);
+    BonoboDockBand *band = get_dock_band (widget);
+    BonoboDockItemGrip *grip = (BonoboDockItemGrip *) widget;
+
+    if (!grip-&gt;item-&gt;is_floating &amp;&amp; band &amp;&amp;
+        bonobo_dock_band_handle_key_nav (band, grip-&gt;item, event))
+    {
+        if (had_focus &amp;&amp; !GTK_WIDGET_HAS_FOCUS (widget))
+            gtk_widget_grab_focus (widget);
+        return TRUE;
+    }
+#endif /* A11Y_UNFINISHED */
+
+    return GTK_WIDGET_CLASS (parent_class)-&gt;key_press_event (widget, event);
+}
+
+static void
+gdl_dock_item_grip_class_init (GdlDockItemGripClass *klass)
+{
+    GtkBindingSet  *binding_set;
+    GObjectClass   *gobject_class = (GObjectClass *) klass;
+    GtkWidgetClass *widget_class = (GtkWidgetClass *) klass;
+
+    parent_class = g_type_class_peek_parent (klass);
+
+    gobject_class-&gt;dispose = gdl_dock_item_grip_dispose;
+
+    widget_class-&gt;expose_event = gdl_dock_item_grip_expose;
+    widget_class-&gt;get_accessible = gdl_dock_item_grip_get_accessible;
+    widget_class-&gt;key_press_event = gdl_dock_item_grip_key_press_event;
+
+    klass-&gt;activate = gdl_dock_item_grip_activate;
+
+    binding_set = gtk_binding_set_by_class (klass);
+
+    signals [ACTIVATE] =
+        g_signal_new (&quot;activate&quot;,
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                      G_STRUCT_OFFSET (
+                          GdlDockItemGripClass, activate),
+                      NULL, NULL,
+                      g_cclosure_marshal_VOID__VOID,
+                      G_TYPE_NONE, 0);
+    widget_class-&gt;activate_signal = signals [ACTIVATE];
+
+    gtk_binding_entry_add_signal (binding_set, GDK_Return, 0,
+                                  &quot;activate&quot;, 0);
+    gtk_binding_entry_add_signal (binding_set, GDK_KP_Enter, 0,
+                                  &quot;activate&quot;, 0);
+}
+
+GtkWidget *
+gdl_dock_item_grip_new (GdlDockItem *item)
+{
+    GdlDockItemGrip *grip = g_object_new (GDL_TYPE_DOCK_ITEM_GRIP, NULL);
+
+    grip-&gt;item = item;
+
+    return GTK_WIDGET (grip);
+}

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,50 @@
+/* -*- Mode: C; indent-tabs-mode: nil; c-basic-offset: 4; tab-width: 8 -*- */
+/**
+ * gdl-dock-item-grip.h
+ * 
+ * Based on bonobo-dock-item-grip.  Original copyright notice follows.
+ *
+ * Author:
+ *    Michael Meeks
+ *
+ * Copyright (C) 2002 Sun Microsystems, Inc.
+ */
+
+#ifndef _GDL_DOCK_ITEM_GRIP_H_
+#define _GDL_DOCK_ITEM_GRIP_H_
+
+#include &lt;gtk/gtkwidget.h&gt;
+#include &lt;gdl/gdl-dock-item.h&gt;
+
+G_BEGIN_DECLS
+
+#define GDL_TYPE_DOCK_ITEM_GRIP            (gdl_dock_item_grip_get_type())
+#define GDL_DOCK_ITEM_GRIP(obj)            \
+    (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_ITEM_GRIP, GdlDockItemGrip))
+#define GDL_DOCK_ITEM_GRIP_CLASS(klass)    \
+    (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_ITEM_GRIP, GdlDockItemGripClass))
+#define GDL_IS_DOCK_ITEM_GRIP(obj)         \
+    (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_ITEM_GRIP))
+#define GDL_IS_DOCK_ITEM_GRIP_CLASS(klass) \
+    (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_ITEM_GRIP))
+#define GDL_DOCK_ITEM_GRIP_GET_CLASS(obj)  \
+    (GTK_CHECK_GET_CLASS ((obj), GDL_TYPE_DOCK_ITEM_GRIP, GdlDockItemGripClass))
+
+typedef struct {
+    GtkWidget parent;
+	
+    GdlDockItem *item;
+} GdlDockItemGrip;
+
+typedef struct {
+    GtkWidgetClass parent_class;
+
+    void (*activate) (GdlDockItemGrip *grip);
+} GdlDockItemGripClass;
+
+GType      gdl_dock_item_grip_get_type (void);
+GtkWidget *gdl_dock_item_grip_new      (GdlDockItem *item);
+
+G_END_DECLS
+
+#endif /* _GDL_DOCK_ITEM_GRIP_H_ */

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,1663 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * gdl-dock-item.c
+ *
+ * Author: Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * Based on GnomeDockItem/BonoboDockItem.  Original copyright notice follows.
+ *
+ * Copyright (C) 1998 Ettore Perazzoli
+ * Copyright (C) 1998 Elliot Lee
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald 
+ * All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;string.h&gt;
+#include &lt;libgnome/gnome-macros.h&gt;
+#include &lt;gdk/gdkkeysyms.h&gt;
+
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock.h&quot;
+#include &quot;gdl-dock-item.h&quot;
+#include &quot;gdl-dock-item-grip.h&quot;
+#include &quot;gdl-dock-notebook.h&quot;
+#include &quot;gdl-dock-paned.h&quot;
+#include &quot;gdl-dock-tablabel.h&quot;
+#include &quot;gdl-dock-placeholder.h&quot;
+#include &quot;libgdltypebuiltins.h&quot;
+#include &quot;libgdlmarshal.h&quot;
+
+
+/* ----- Private prototypes ----- */
+
+static void  gdl_dock_item_class_init    (GdlDockItemClass *class);
+static void  gdl_dock_item_instance_init (GdlDockItem *item);
+
+static GObject *gdl_dock_item_constructor (GType                  type,
+                                           guint                  n_construct_properties,
+                                           GObjectConstructParam *construct_param);
+
+static void  gdl_dock_item_set_property  (GObject      *object,
+                                          guint         prop_id,
+                                          const GValue *value,
+                                          GParamSpec   *pspec);
+static void  gdl_dock_item_get_property  (GObject      *object,
+                                          guint         prop_id,
+                                          GValue       *value,
+                                          GParamSpec   *pspec);
+
+static void  gdl_dock_item_destroy       (GtkObject *object);
+
+static void  gdl_dock_item_add           (GtkContainer *container,
+                                          GtkWidget    *widget);
+static void  gdl_dock_item_remove        (GtkContainer *container,
+                                          GtkWidget    *widget);
+static void  gdl_dock_item_forall        (GtkContainer *container,
+                                          gboolean      include_internals,
+                                          GtkCallback   callback,
+                                          gpointer      callback_data);
+static GtkType gdl_dock_item_child_type  (GtkContainer *container);
+
+static void  gdl_dock_item_size_request  (GtkWidget *widget,
+                                          GtkRequisition *requisition);
+static void  gdl_dock_item_size_allocate (GtkWidget *widget,
+                                          GtkAllocation *allocation);
+static void  gdl_dock_item_map           (GtkWidget *widget);
+static void  gdl_dock_item_unmap         (GtkWidget *widget);
+static void  gdl_dock_item_realize       (GtkWidget *widget);
+static void  gdl_dock_item_style_set     (GtkWidget *widget,
+                                          GtkStyle  *previous_style);
+static gint  gdl_dock_item_expose        (GtkWidget *widget,
+                                          GdkEventExpose *event);
+
+static gint  gdl_dock_item_button_changed (GtkWidget *widget,
+                                           GdkEventButton *event);
+static gint  gdl_dock_item_motion         (GtkWidget *widget,
+                                           GdkEventMotion *event);
+static gboolean  gdl_dock_item_key_press  (GtkWidget *widget,
+                                           GdkEventKey *event);
+
+static gboolean gdl_dock_item_dock_request (GdlDockObject    *object,
+                                            gint              x,
+                                            gint              y,
+                                            GdlDockRequest   *request);
+static void     gdl_dock_item_dock         (GdlDockObject    *object,
+                                            GdlDockObject    *requestor,
+                                            GdlDockPlacement  position,
+                                            GValue           *other_data);
+
+static void  gdl_dock_item_popup_menu    (GdlDockItem *item, 
+                                          guint        button,
+                                          guint32      time);
+static void  gdl_dock_item_drag_start    (GdlDockItem *item);
+static void  gdl_dock_item_drag_end      (GdlDockItem *item,
+                                          gboolean     cancel);
+
+static void  gdl_dock_item_tab_button    (GtkWidget      *widget,
+                                          GdkEventButton *event,
+                                          gpointer        data);
+                                          
+static void  gdl_dock_item_hide_cb       (GtkWidget   *widget,
+                                          GdlDockItem *item);
+
+static void  gdl_dock_item_lock_cb       (GtkWidget   *widget,
+                                          GdlDockItem *item);
+
+static void  gdl_dock_item_showhide_grip (GdlDockItem *item);
+
+static void  gdl_dock_item_real_set_orientation (GdlDockItem    *item,
+                                                 GtkOrientation  orientation);
+
+static void gdl_dock_param_export_gtk_orientation (const GValue *src,
+                                                   GValue       *dst);
+static void gdl_dock_param_import_gtk_orientation (const GValue *src,
+                                                   GValue       *dst);
+
+
+
+/* ----- Class variables and definitions ----- */
+
+enum {
+    PROP_0,
+    PROP_ORIENTATION,
+    PROP_RESIZE,
+    PROP_BEHAVIOR,
+    PROP_GRIP_SIZE,
+    PROP_LOCKED,
+    PROP_PREFERRED_WIDTH,
+    PROP_PREFERRED_HEIGHT
+};
+
+enum {
+    DOCK_DRAG_BEGIN,
+    DOCK_DRAG_MOTION,
+    DOCK_DRAG_END,
+    LAST_SIGNAL
+};
+
+static guint gdl_dock_item_signals [LAST_SIGNAL] = { 0 };
+
+#define DEFAULT_GRIP_SIZE  10
+#define GDL_DOCK_ITEM_NOT_LOCKED(item) !((item)-&gt;behavior &amp; GDL_DOCK_ITEM_BEH_LOCKED)
+#define GDL_DOCK_ITEM_GRIP_SHOWN(item) \
+    (GDL_DOCK_ITEM_HAS_GRIP (item) &amp;&amp; \
+     GDL_DOCK_ITEM_NOT_LOCKED (item) &amp;&amp; \
+     (item)-&gt;_priv-&gt;grip_shown)
+
+
+struct _GdlDockItemPrivate {
+    GtkWidget *menu;
+
+    gboolean   grip_shown;
+    GtkWidget *grip;
+    guint      grip_size;
+    
+    GtkWidget *tab_label;
+
+    gint       preferred_width;
+    gint       preferred_height;
+
+    GdlDockPlaceholder *ph;
+
+    gint       start_x, start_y;
+};
+
+/* FIXME: implement the rest of the behaviors */
+
+#define SPLIT_RATIO  0.4
+
+
+/* ----- Private functions ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDockItem, gdl_dock_item, GdlDockObject, GDL_TYPE_DOCK_OBJECT);
+
+static void
+gdl_dock_item_class_init (GdlDockItemClass *klass)
+{
+    GObjectClass       *g_object_class;
+    GtkObjectClass     *gtk_object_class;
+    GtkWidgetClass     *widget_class;
+    GtkContainerClass  *container_class;
+    GdlDockObjectClass *object_class;
+    
+    g_object_class = G_OBJECT_CLASS (klass);
+    gtk_object_class = GTK_OBJECT_CLASS (klass);
+    widget_class = GTK_WIDGET_CLASS (klass);
+    container_class = GTK_CONTAINER_CLASS (klass);
+    object_class = GDL_DOCK_OBJECT_CLASS (klass);
+
+    g_object_class-&gt;constructor = gdl_dock_item_constructor;
+    g_object_class-&gt;set_property = gdl_dock_item_set_property;
+    g_object_class-&gt;get_property = gdl_dock_item_get_property;
+
+    gtk_object_class-&gt;destroy = gdl_dock_item_destroy;
+
+    widget_class-&gt;realize = gdl_dock_item_realize;
+    widget_class-&gt;map = gdl_dock_item_map;
+    widget_class-&gt;unmap = gdl_dock_item_unmap;
+    widget_class-&gt;size_request = gdl_dock_item_size_request;
+    widget_class-&gt;size_allocate = gdl_dock_item_size_allocate;
+    widget_class-&gt;style_set = gdl_dock_item_style_set;
+    widget_class-&gt;expose_event = gdl_dock_item_expose;
+    widget_class-&gt;button_press_event = gdl_dock_item_button_changed;
+    widget_class-&gt;button_release_event = gdl_dock_item_button_changed;
+    widget_class-&gt;motion_notify_event = gdl_dock_item_motion;
+    widget_class-&gt;key_press_event = gdl_dock_item_key_press;
+    
+    container_class-&gt;add = gdl_dock_item_add;
+    container_class-&gt;remove = gdl_dock_item_remove;
+    container_class-&gt;forall = gdl_dock_item_forall;
+    container_class-&gt;child_type = gdl_dock_item_child_type;
+    
+    object_class-&gt;is_compound = FALSE;
+
+    object_class-&gt;dock_request = gdl_dock_item_dock_request;
+    object_class-&gt;dock = gdl_dock_item_dock;
+
+    /* properties */
+
+    g_object_class_install_property (
+        g_object_class, PROP_ORIENTATION,
+        g_param_spec_enum (&quot;orientation&quot;, _(&quot;Orientation&quot;),
+                           _(&quot;Orientation of the docking item&quot;),
+                           GTK_TYPE_ORIENTATION,
+                           GTK_ORIENTATION_HORIZONTAL,
+                           G_PARAM_READWRITE | G_PARAM_CONSTRUCT |
+                           GDL_DOCK_PARAM_EXPORT));
+
+    /* --- register exporter/importer for GTK_ORIENTATION */
+    g_value_register_transform_func (GTK_TYPE_ORIENTATION, GDL_TYPE_DOCK_PARAM,
+                                     gdl_dock_param_export_gtk_orientation);
+    g_value_register_transform_func (GDL_TYPE_DOCK_PARAM, GTK_TYPE_ORIENTATION,
+                                     gdl_dock_param_import_gtk_orientation);
+    /* --- end of registration */
+    
+    g_object_class_install_property (
+        g_object_class, PROP_RESIZE,
+        g_param_spec_boolean (&quot;resize&quot;, _(&quot;Resizable&quot;),
+                              _(&quot;If set, the dock item can be resized when &quot;
+                                &quot;docked in a paned&quot;),
+                              TRUE,
+                              G_PARAM_READWRITE));
+                                     
+    g_object_class_install_property (
+        g_object_class, PROP_BEHAVIOR,
+        g_param_spec_flags (&quot;behavior&quot;, _(&quot;Item behavior&quot;),
+                            _(&quot;General behavior for the dock item (i.e. &quot;
+                              &quot;whether it can float, if it's locked, etc.)&quot;),
+                            GDL_TYPE_DOCK_ITEM_BEHAVIOR,
+                            GDL_DOCK_ITEM_BEH_NORMAL,
+                            G_PARAM_READWRITE));
+                                     
+    g_object_class_install_property (
+        g_object_class, PROP_GRIP_SIZE,
+        g_param_spec_uint (&quot;grip_size&quot;, _(&quot;Grip size&quot;),
+                           _(&quot;Size in pixels of the grip to drag the dock item&quot;),
+                           0, 100, DEFAULT_GRIP_SIZE,
+                           G_PARAM_READWRITE));
+
+    g_object_class_install_property (
+        g_object_class, PROP_LOCKED,
+        g_param_spec_boolean (&quot;locked&quot;, _(&quot;Locked&quot;),
+                              _(&quot;If set, the dock item cannot be dragged around &quot;
+                                &quot;and it doesn't show a grip&quot;),
+                              FALSE,
+                              G_PARAM_READWRITE |
+                              GDL_DOCK_PARAM_EXPORT));
+
+    g_object_class_install_property (
+        g_object_class, PROP_PREFERRED_WIDTH,
+        g_param_spec_int (&quot;preferred_width&quot;, _(&quot;Preferred width&quot;),
+                          _(&quot;Preferred width for the dock item&quot;),
+                          -1, G_MAXINT, -1,
+                          G_PARAM_READWRITE));
+
+    g_object_class_install_property (
+        g_object_class, PROP_PREFERRED_HEIGHT,
+        g_param_spec_int (&quot;preferred_height&quot;, _(&quot;Preferred height&quot;),
+                          _(&quot;Preferred height for the dock item&quot;),
+                          -1, G_MAXINT, -1,
+                          G_PARAM_READWRITE));
+
+    /* signals */
+    
+    gdl_dock_item_signals [DOCK_DRAG_BEGIN] = 
+        g_signal_new (&quot;dock_drag_begin&quot;,
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_FIRST,
+                      G_STRUCT_OFFSET (GdlDockItemClass, dock_drag_begin),
+                      NULL, /* accumulator */
+                      NULL, /* accu_data */
+                      gdl_marshal_VOID__VOID,
+                      G_TYPE_NONE, 
+                      0);
+
+    gdl_dock_item_signals [DOCK_DRAG_MOTION] = 
+        g_signal_new (&quot;dock_drag_motion&quot;,
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_FIRST,
+                      G_STRUCT_OFFSET (GdlDockItemClass, dock_drag_motion),
+                      NULL, /* accumulator */
+                      NULL, /* accu_data */
+                      gdl_marshal_VOID__INT_INT,
+                      G_TYPE_NONE, 
+                      2,
+                      G_TYPE_INT,
+                      G_TYPE_INT);
+
+    gdl_dock_item_signals [DOCK_DRAG_END] = 
+        g_signal_new (&quot;dock_drag_end&quot;,
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_FIRST,
+                      G_STRUCT_OFFSET (GdlDockItemClass, dock_drag_end),
+                      NULL, /* accumulator */
+                      NULL, /* accu_data */
+                      gdl_marshal_VOID__BOOLEAN,
+                      G_TYPE_NONE, 
+                      1,
+                      G_TYPE_BOOLEAN);
+
+    klass-&gt;has_grip = TRUE;
+    klass-&gt;dock_drag_begin = NULL;
+    klass-&gt;dock_drag_motion = NULL;
+    klass-&gt;dock_drag_end = NULL;
+    klass-&gt;set_orientation = gdl_dock_item_real_set_orientation;
+}
+
+static void
+gdl_dock_item_instance_init (GdlDockItem *item)
+{
+    GTK_WIDGET_UNSET_FLAGS (GTK_WIDGET (item), GTK_NO_WINDOW);
+
+    item-&gt;child = NULL;
+    
+    item-&gt;orientation = GTK_ORIENTATION_HORIZONTAL;
+    item-&gt;behavior = GDL_DOCK_ITEM_BEH_NORMAL;
+
+    item-&gt;resize = TRUE;
+
+    item-&gt;dragoff_x = item-&gt;dragoff_y = 0;
+
+    item-&gt;_priv = g_new0 (GdlDockItemPrivate, 1);
+    item-&gt;_priv-&gt;menu = NULL;
+
+    item-&gt;_priv-&gt;preferred_width = item-&gt;_priv-&gt;preferred_height = -1;
+    item-&gt;_priv-&gt;grip_size = DEFAULT_GRIP_SIZE;
+    item-&gt;_priv-&gt;tab_label = NULL;
+
+    item-&gt;_priv-&gt;ph = NULL;
+}
+
+static GObject *
+gdl_dock_item_constructor (GType                  type,
+                           guint                  n_construct_properties,
+                           GObjectConstructParam *construct_param)
+{
+    GObject *g_object;
+    
+    g_object = GNOME_CALL_PARENT_WITH_DEFAULT (G_OBJECT_CLASS, 
+                                               constructor, 
+                                               (type,
+                                                n_construct_properties,
+                                                construct_param),
+                                               NULL);
+    if (g_object) {
+        GdlDockItem *item = GDL_DOCK_ITEM (g_object);
+
+        if (GDL_DOCK_ITEM_HAS_GRIP (item)) {
+            item-&gt;_priv-&gt;grip_shown = TRUE;
+            item-&gt;_priv-&gt;grip = gdl_dock_item_grip_new (item);
+            gtk_widget_set_parent (item-&gt;_priv-&gt;grip, GTK_WIDGET (item));
+            gtk_widget_show (item-&gt;_priv-&gt;grip);
+        }
+        else {
+            item-&gt;_priv-&gt;grip_shown = FALSE;
+        }
+    }
+
+    return g_object;
+}
+
+static void
+gdl_dock_item_set_property  (GObject      *g_object,
+                             guint         prop_id,
+                             const GValue *value,
+                             GParamSpec   *pspec)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (g_object);
+
+    switch (prop_id) {
+        case PROP_ORIENTATION:
+            gdl_dock_item_set_orientation (item, g_value_get_enum (value));
+            break;
+        case PROP_RESIZE:
+            item-&gt;resize = g_value_get_boolean (value);
+            gtk_widget_queue_resize (GTK_WIDGET (item));
+            break;
+        case PROP_BEHAVIOR:
+        {
+            GdlDockItemBehavior old_beh = item-&gt;behavior;
+            item-&gt;behavior = g_value_get_flags (value);
+
+            if ((old_beh ^ item-&gt;behavior) &amp; GDL_DOCK_ITEM_BEH_LOCKED) {
+                if (GDL_DOCK_OBJECT_GET_MASTER (item))
+                    g_signal_emit_by_name (GDL_DOCK_OBJECT_GET_MASTER (item),
+                                           &quot;layout_changed&quot;);
+                g_object_notify (g_object, &quot;locked&quot;);
+                gdl_dock_item_showhide_grip (item);
+            }
+            
+            break;
+        }
+        case PROP_GRIP_SIZE:
+            item-&gt;_priv-&gt;grip_size = g_value_get_uint (value);
+            if (GDL_DOCK_ITEM_GRIP_SHOWN (item))
+                gtk_widget_queue_resize (GTK_WIDGET (item));
+            break;
+        case PROP_LOCKED:
+        {
+            GdlDockItemBehavior old_beh = item-&gt;behavior;
+
+            if (g_value_get_boolean (value))
+                item-&gt;behavior |= GDL_DOCK_ITEM_BEH_LOCKED;
+            else
+                item-&gt;behavior &amp;= ~GDL_DOCK_ITEM_BEH_LOCKED;
+
+            if (old_beh ^ item-&gt;behavior) {
+                gdl_dock_item_showhide_grip (item);
+                g_object_notify (g_object, &quot;behavior&quot;);
+
+                if (GDL_DOCK_OBJECT_GET_MASTER (item))
+                    g_signal_emit_by_name (GDL_DOCK_OBJECT_GET_MASTER (item),
+                                           &quot;layout_changed&quot;);
+            }
+            break;
+        }
+        case PROP_PREFERRED_WIDTH:
+            item-&gt;_priv-&gt;preferred_width = g_value_get_int (value);
+            break;
+        case PROP_PREFERRED_HEIGHT:
+            item-&gt;_priv-&gt;preferred_height = g_value_get_int (value);
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (g_object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_item_get_property  (GObject      *g_object,
+                             guint         prop_id,
+                             GValue       *value,
+                             GParamSpec   *pspec)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (g_object);
+    
+    switch (prop_id) {
+        case PROP_ORIENTATION:
+            g_value_set_enum (value, item-&gt;orientation);
+            break;
+        case PROP_RESIZE:
+            g_value_set_boolean (value, item-&gt;resize);
+            break;
+        case PROP_BEHAVIOR:
+            g_value_set_flags (value, item-&gt;behavior);
+            break;
+        case PROP_GRIP_SIZE:
+            g_value_set_uint (value, item-&gt;_priv-&gt;grip_size);
+            break;
+        case PROP_LOCKED:
+            g_value_set_boolean (value, !GDL_DOCK_ITEM_NOT_LOCKED (item));
+            break;
+        case PROP_PREFERRED_WIDTH:
+            g_value_set_int (value, item-&gt;_priv-&gt;preferred_width);
+            break;
+        case PROP_PREFERRED_HEIGHT:
+            g_value_set_int (value, item-&gt;_priv-&gt;preferred_height);
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (g_object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_item_destroy (GtkObject *object)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+
+    if (item-&gt;_priv) {
+        GdlDockItemPrivate *priv = item-&gt;_priv;
+        
+        if (priv-&gt;tab_label) {
+            gdl_dock_item_set_tablabel (item, NULL);
+        };
+        if (priv-&gt;menu) {
+            gtk_menu_detach (GTK_MENU (priv-&gt;menu));
+            priv-&gt;menu = NULL;
+        };
+        if (priv-&gt;grip) {
+            gtk_container_remove (GTK_CONTAINER (item), priv-&gt;grip);
+            priv-&gt;grip = NULL;
+        }
+        if (priv-&gt;ph) {
+            g_object_unref (priv-&gt;ph);
+            priv-&gt;ph = NULL;
+        }
+        
+        item-&gt;_priv = NULL;
+        g_free (priv);
+    }
+
+    GNOME_CALL_PARENT (GTK_OBJECT_CLASS, destroy, (object));
+}
+
+static void 
+gdl_dock_item_add (GtkContainer *container,
+                   GtkWidget    *widget)
+{
+    GdlDockItem *item;
+    
+    g_return_if_fail (GDL_IS_DOCK_ITEM (container));
+
+    item = GDL_DOCK_ITEM (container);
+    if (GDL_IS_DOCK_OBJECT (widget)) {
+        g_warning (_(&quot;You can't add a dock object (%p of type %s) inside a %s. &quot;
+                     &quot;Use a GdlDock or some other compound dock object.&quot;),
+                   widget, G_OBJECT_TYPE_NAME (widget), G_OBJECT_TYPE_NAME (item));
+        return;
+    }
+
+    if (item-&gt;child != NULL) {
+        g_warning (_(&quot;Attempting to add a widget with type %s to a %s, &quot;
+                     &quot;but it can only contain one widget at a time; &quot;
+                     &quot;it already contains a widget of type %s&quot;),
+                     G_OBJECT_TYPE_NAME (widget),
+                     G_OBJECT_TYPE_NAME (item),
+                     G_OBJECT_TYPE_NAME (item-&gt;child));
+        return;
+    }
+
+    gtk_widget_set_parent (widget, GTK_WIDGET (item));
+    item-&gt;child = widget;
+}
+
+static void  
+gdl_dock_item_remove (GtkContainer *container,
+                      GtkWidget    *widget)
+{
+    GdlDockItem *item;
+    gboolean     was_visible;
+    
+    g_return_if_fail (GDL_IS_DOCK_ITEM (container));
+    
+    item = GDL_DOCK_ITEM (container);
+    if (item-&gt;_priv &amp;&amp; widget == item-&gt;_priv-&gt;grip) {
+        gboolean grip_was_visible = GTK_WIDGET_VISIBLE (widget);
+        gtk_widget_unparent (widget);
+        item-&gt;_priv-&gt;grip = NULL;
+        if (grip_was_visible)
+            gtk_widget_queue_resize (GTK_WIDGET (item));
+        return;
+    }
+    
+    if (GDL_DOCK_ITEM_IN_DRAG (item)) {
+        gdl_dock_item_drag_end (item, TRUE);
+    }
+    
+    g_return_if_fail (item-&gt;child == widget);
+    
+    was_visible = GTK_WIDGET_VISIBLE (widget);
+
+    gtk_widget_unparent (widget);
+    item-&gt;child = NULL;
+    
+    if (was_visible)
+        gtk_widget_queue_resize (GTK_WIDGET (container));
+}
+
+static void
+gdl_dock_item_forall (GtkContainer *container,
+                      gboolean      include_internals,
+                      GtkCallback   callback,
+                      gpointer      callback_data)
+{
+    GdlDockItem *item = (GdlDockItem *) container;
+    
+    g_return_if_fail (callback != NULL);
+    
+    if (include_internals &amp;&amp; item-&gt;_priv-&gt;grip)
+        (* callback) (item-&gt;_priv-&gt;grip, callback_data);
+    
+    if (item-&gt;child)
+        (* callback) (item-&gt;child, callback_data);
+}
+
+static GtkType
+gdl_dock_item_child_type (GtkContainer *container)
+{
+    g_return_val_if_fail (GDL_IS_DOCK_ITEM (container), G_TYPE_NONE);
+    
+    if (!GDL_DOCK_ITEM (container)-&gt;child)
+        return GTK_TYPE_WIDGET;
+    else
+        return G_TYPE_NONE;
+}
+
+static void
+gdl_dock_item_size_request (GtkWidget      *widget,
+                            GtkRequisition *requisition)
+{
+    GtkRequisition  child_requisition;
+    GdlDockItem    *item;
+
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+    g_return_if_fail (requisition != NULL);
+
+    item = GDL_DOCK_ITEM (widget);
+
+    /* If our child is not visible, we still request its size, since
+       we won't have any useful hint for our size otherwise.  */
+    if (item-&gt;child)
+        gtk_widget_size_request (item-&gt;child, &amp;child_requisition);
+    else {
+        child_requisition.width = 0;
+        child_requisition.height = 0;
+    }
+
+    if (item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL) {
+        requisition-&gt;width = 
+            GDL_DOCK_ITEM_GRIP_SHOWN (item) ? item-&gt;_priv-&gt;grip_size : 0;
+        if (item-&gt;child) {
+            requisition-&gt;width += child_requisition.width;
+            requisition-&gt;height = child_requisition.height;
+        } else
+            requisition-&gt;height = 0;
+    } else {
+        requisition-&gt;height = 
+            GDL_DOCK_ITEM_GRIP_SHOWN (item) ? item-&gt;_priv-&gt;grip_size : 0;
+        if (item-&gt;child) {
+            requisition-&gt;width = child_requisition.width;
+            requisition-&gt;height += child_requisition.height;
+        } else
+            requisition-&gt;width = 0;
+    }
+
+    requisition-&gt;width += GTK_CONTAINER (widget)-&gt;border_width * 2;
+    requisition-&gt;height += GTK_CONTAINER (widget)-&gt;border_width * 2;
+
+    widget-&gt;requisition = *requisition;
+}
+
+static void
+gdl_dock_item_size_allocate (GtkWidget     *widget,
+                             GtkAllocation *allocation)
+{
+    GdlDockItem *item;
+  
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+    g_return_if_fail (allocation != NULL);
+  
+    item = GDL_DOCK_ITEM (widget);
+
+    widget-&gt;allocation = *allocation;
+
+    if (GTK_WIDGET_REALIZED (widget))
+        gdk_window_move_resize (widget-&gt;window,
+                                widget-&gt;allocation.x,
+                                widget-&gt;allocation.y,
+                                widget-&gt;allocation.width,
+                                widget-&gt;allocation.height);
+
+    if (item-&gt;child &amp;&amp; GTK_WIDGET_VISIBLE (item-&gt;child)) {
+        GtkAllocation  child_allocation;
+        int            border_width;
+
+        border_width = GTK_CONTAINER (widget)-&gt;border_width;
+
+        child_allocation.x = border_width;
+        child_allocation.y = border_width;
+        child_allocation.width = allocation-&gt;width - 2 * border_width;
+        child_allocation.height = allocation-&gt;height - 2 * border_width;
+        
+        if (GDL_DOCK_ITEM_GRIP_SHOWN (item)) {
+            GtkAllocation grip_alloc = *allocation;
+            
+            grip_alloc.x = grip_alloc.y = 0;
+            
+            if (item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL) {
+                child_allocation.x += item-&gt;_priv-&gt;grip_size;
+                child_allocation.width -= item-&gt;_priv-&gt;grip_size;
+                grip_alloc.width = item-&gt;_priv-&gt;grip_size;
+            } else {
+                child_allocation.y += item-&gt;_priv-&gt;grip_size;
+                child_allocation.height -= item-&gt;_priv-&gt;grip_size;
+                grip_alloc.height = item-&gt;_priv-&gt;grip_size;
+            }
+            if (item-&gt;_priv-&gt;grip)
+                gtk_widget_size_allocate (item-&gt;_priv-&gt;grip, &amp;grip_alloc);
+        };
+        gtk_widget_size_allocate (item-&gt;child, &amp;child_allocation);
+    }
+}
+
+static void
+gdl_dock_item_map (GtkWidget *widget)
+{
+    GdlDockItem *item;
+
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+
+    GTK_WIDGET_SET_FLAGS (widget, GTK_MAPPED);
+
+    item = GDL_DOCK_ITEM (widget);
+
+    gdk_window_show (widget-&gt;window);
+
+    if (item-&gt;child
+        &amp;&amp; GTK_WIDGET_VISIBLE (item-&gt;child)
+        &amp;&amp; !GTK_WIDGET_MAPPED (item-&gt;child))
+        gtk_widget_map (item-&gt;child);
+
+    if (item-&gt;_priv-&gt;grip
+        &amp;&amp; GTK_WIDGET_VISIBLE (item-&gt;_priv-&gt;grip)
+        &amp;&amp; !GTK_WIDGET_MAPPED (item-&gt;_priv-&gt;grip))
+        gtk_widget_map (item-&gt;_priv-&gt;grip);
+}
+
+static void
+gdl_dock_item_unmap (GtkWidget *widget)
+{
+    GdlDockItem *item;
+
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+
+    GTK_WIDGET_UNSET_FLAGS (widget, GTK_MAPPED);
+    
+    item = GDL_DOCK_ITEM (widget);
+
+    gdk_window_hide (widget-&gt;window);
+
+    if (item-&gt;_priv-&gt;grip)
+        gtk_widget_unmap (item-&gt;_priv-&gt;grip);
+}
+
+static void
+gdl_dock_item_realize (GtkWidget *widget)
+{
+    GdkWindowAttr  attributes;
+    gint           attributes_mask;
+    GdlDockItem   *item;
+
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+
+    item = GDL_DOCK_ITEM (widget);
+
+    GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED);
+
+    /* widget window */
+    attributes.x = widget-&gt;allocation.x;
+    attributes.y = widget-&gt;allocation.y;
+    attributes.width = widget-&gt;allocation.width;
+    attributes.height = widget-&gt;allocation.height;
+    attributes.window_type = GDK_WINDOW_CHILD;
+    attributes.wclass = GDK_INPUT_OUTPUT;
+    attributes.visual = gtk_widget_get_visual (widget);
+    attributes.colormap = gtk_widget_get_colormap (widget);
+    attributes.event_mask = (gtk_widget_get_events (widget) |
+                             GDK_EXPOSURE_MASK |
+                             GDK_BUTTON1_MOTION_MASK |
+                             GDK_BUTTON_PRESS_MASK |
+                             GDK_BUTTON_RELEASE_MASK);
+    attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
+    widget-&gt;window = gdk_window_new (gtk_widget_get_parent_window (widget), 
+                                     &amp;attributes, attributes_mask);
+    gdk_window_set_user_data (widget-&gt;window, widget);
+  
+    widget-&gt;style = gtk_style_attach (widget-&gt;style, widget-&gt;window);
+    gtk_style_set_background (widget-&gt;style, widget-&gt;window, 
+                              GTK_WIDGET_STATE (item));
+    gdk_window_set_back_pixmap (widget-&gt;window, NULL, TRUE);
+
+    if (item-&gt;child)
+        gtk_widget_set_parent_window (item-&gt;child, widget-&gt;window);
+    
+    if (item-&gt;_priv-&gt;grip)
+        gtk_widget_set_parent_window (item-&gt;_priv-&gt;grip, widget-&gt;window);
+}
+
+static void
+gdl_dock_item_style_set (GtkWidget *widget,
+                         GtkStyle  *previous_style)
+{
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+
+    /* FIXME: maybe remove this method altogether and use the default implementation */
+    if (GTK_WIDGET_REALIZED (widget) &amp;&amp; !GTK_WIDGET_NO_WINDOW (widget)) {
+        gtk_style_set_background (widget-&gt;style, widget-&gt;window,
+                                  widget-&gt;state);
+        if (GTK_WIDGET_DRAWABLE (widget))
+            gdk_window_clear (widget-&gt;window);
+    }
+}
+
+static void
+gdl_dock_item_paint (GtkWidget      *widget,
+                     GdkEventExpose *event)
+{
+    GdlDockItem  *item;
+
+    item = GDL_DOCK_ITEM (widget);
+
+    gtk_paint_box (widget-&gt;style,
+                   widget-&gt;window,
+                   GTK_WIDGET_STATE (widget),
+                   GTK_SHADOW_NONE,
+                   &amp;event-&gt;area, widget,
+                   &quot;dockitem&quot;,
+                   0, 0, -1, -1);
+}
+
+static gint
+gdl_dock_item_expose (GtkWidget      *widget,
+                      GdkEventExpose *event)
+{
+    g_return_val_if_fail (widget != NULL, FALSE);
+    g_return_val_if_fail (GDL_IS_DOCK_ITEM (widget), FALSE);
+    g_return_val_if_fail (event != NULL, FALSE);
+
+    if (GTK_WIDGET_DRAWABLE (widget) &amp;&amp; event-&gt;window == widget-&gt;window) {
+        gdl_dock_item_paint (widget, event);
+        GNOME_CALL_PARENT (GTK_WIDGET_CLASS, expose_event, (widget, event));
+    }
+  
+    return FALSE;
+}
+
+#define EVENT_IN_TABLABEL_EVENT_WINDOW(ev,tl) \
+    ((tl) != NULL &amp;&amp; (ev)-&gt;window == GDL_DOCK_TABLABEL (tl)-&gt;event_window)
+
+static gint
+gdl_dock_item_button_changed (GtkWidget      *widget,
+                              GdkEventButton *event)
+{
+    GdlDockItem *item;
+    gboolean     event_handled;
+    gboolean     in_handle;
+  
+    g_return_val_if_fail (widget != NULL, FALSE);
+    g_return_val_if_fail (GDL_IS_DOCK_ITEM (widget), FALSE);
+    g_return_val_if_fail (event != NULL, FALSE);
+    
+    item = GDL_DOCK_ITEM (widget);
+    
+    if (!(event-&gt;window == widget-&gt;window ||
+          EVENT_IN_TABLABEL_EVENT_WINDOW (event, item-&gt;_priv-&gt;tab_label)))
+        return FALSE;
+    
+    /* Verify that the item is not locked. */
+    if (!GDL_DOCK_ITEM_NOT_LOCKED (item))
+        return FALSE;
+
+    event_handled = FALSE;
+
+    /* Check if user clicked on the drag handle. */      
+    switch (item-&gt;orientation) {
+    case GTK_ORIENTATION_HORIZONTAL:
+        in_handle = event-&gt;x &lt; item-&gt;_priv-&gt;grip_size;
+        break;
+    case GTK_ORIENTATION_VERTICAL:
+        in_handle = event-&gt;y &lt; item-&gt;_priv-&gt;grip_size;
+        break;
+    default:
+        in_handle = FALSE;
+        break;
+    }
+
+    /* Left mousebutton click on dockitem. */
+    if (event-&gt;button == 1 &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS) {
+        /* Set in_drag flag, grab pointer and call begin drag operation. */      
+        if (in_handle) {
+            item-&gt;_priv-&gt;start_x = event-&gt;x;
+            item-&gt;_priv-&gt;start_y = event-&gt;y;
+
+            GDL_DOCK_ITEM_SET_FLAGS (item, GDL_DOCK_IN_PREDRAG);
+        
+            event_handled = TRUE;
+        };
+        
+    } else if (event-&gt;type == GDK_BUTTON_RELEASE &amp;&amp; event-&gt;button == 1) {
+        if (GDL_DOCK_ITEM_IN_DRAG (item)) {
+            /* User dropped widget somewhere. */
+            gdl_dock_item_drag_end (item, FALSE);
+            event_handled = TRUE;
+        }
+        else if (GDL_DOCK_ITEM_IN_PREDRAG (item)) {
+            GDL_DOCK_ITEM_UNSET_FLAGS (item, GDL_DOCK_IN_PREDRAG);
+            event_handled = TRUE;
+        }
+             
+    } else if (event-&gt;button == 3 &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; in_handle) {
+        gdl_dock_item_popup_menu (item, event-&gt;button, event-&gt;time);
+        event_handled = TRUE;    	
+    }
+
+    return event_handled;
+}
+
+static gint
+gdl_dock_item_motion (GtkWidget      *widget,
+                      GdkEventMotion *event)
+{
+    GdlDockItem *item;
+    gint         new_x, new_y;
+
+    g_return_val_if_fail (widget != NULL, FALSE);
+    g_return_val_if_fail (GDL_IS_DOCK_ITEM (widget), FALSE);
+    g_return_val_if_fail (event != NULL, FALSE);
+
+    item = GDL_DOCK_ITEM (widget);
+
+    if (!(event-&gt;window == widget-&gt;window ||
+          EVENT_IN_TABLABEL_EVENT_WINDOW (event, item-&gt;_priv-&gt;tab_label)))
+        return FALSE;
+
+    if (GDL_DOCK_ITEM_IN_PREDRAG (item)) {
+        if (gtk_drag_check_threshold (widget,
+                                      item-&gt;_priv-&gt;start_x,
+                                      item-&gt;_priv-&gt;start_y,
+                                      event-&gt;x,
+                                      event-&gt;y)) {
+            GDL_DOCK_ITEM_UNSET_FLAGS (item, GDL_DOCK_IN_PREDRAG);
+            item-&gt;dragoff_x = item-&gt;_priv-&gt;start_x;
+            item-&gt;dragoff_y = item-&gt;_priv-&gt;start_y;
+
+            gdl_dock_item_drag_start (item);
+        }
+    }
+    
+    if (!GDL_DOCK_ITEM_IN_DRAG (item))
+        return FALSE;
+
+    new_x = event-&gt;x_root;
+    new_y = event-&gt;y_root;
+    
+    g_signal_emit (item, gdl_dock_item_signals [DOCK_DRAG_MOTION], 
+                   0, new_x, new_y);
+
+    return TRUE;
+}
+
+static gboolean
+gdl_dock_item_key_press (GtkWidget   *widget,
+                         GdkEventKey *event)
+{
+    gboolean event_handled = FALSE;
+    
+    if (GDL_DOCK_ITEM_IN_DRAG (widget)) {
+        if (event-&gt;keyval == GDK_Escape) {
+            gdl_dock_item_drag_end (GDL_DOCK_ITEM (widget), TRUE);
+            event_handled = TRUE;
+        }
+    }
+
+    if (event_handled)
+        return TRUE;
+    else
+        return GNOME_CALL_PARENT_WITH_DEFAULT (GTK_WIDGET_CLASS,
+                                               key_press_event,
+                                               (widget, event),
+                                               FALSE);
+}
+
+static gboolean
+gdl_dock_item_dock_request (GdlDockObject  *object,
+                            gint            x,
+                            gint            y,
+                            GdlDockRequest *request)
+{
+    GtkAllocation *alloc;
+    gint           rel_x, rel_y;
+
+    /* we get (x,y) in our allocation coordinates system */
+    
+    /* Get item's allocation. */
+    alloc = &amp;(GTK_WIDGET (object)-&gt;allocation);
+    
+    /* Get coordinates relative to our window. */
+    rel_x = x - alloc-&gt;x;
+    rel_y = y - alloc-&gt;y;
+
+    /* Location is inside. */
+    if (rel_x &gt; 0 &amp;&amp; rel_x &lt; alloc-&gt;width &amp;&amp;
+        rel_y &gt; 0 &amp;&amp; rel_y &lt; alloc-&gt;height) {
+        float rx, ry;
+        GtkRequisition my, other;
+        gint divider = -1;
+        
+        /* this are for calculating the extra docking parameter */
+        gdl_dock_item_preferred_size (GDL_DOCK_ITEM (request-&gt;applicant), &amp;other);
+        gdl_dock_item_preferred_size (GDL_DOCK_ITEM (object), &amp;my);
+        
+        /* Calculate location in terms of the available space (0-100%). */
+        rx = (float) rel_x / alloc-&gt;width;
+        ry = (float) rel_y / alloc-&gt;height;
+
+        /* Determine dock location. */
+        if (rx &lt; SPLIT_RATIO) {
+            request-&gt;position = GDL_DOCK_LEFT;
+            divider = other.width;
+        }
+        else if (rx &gt; (1 - SPLIT_RATIO)) {
+            request-&gt;position = GDL_DOCK_RIGHT;
+            rx = 1 - rx;
+            divider = MAX (0, my.width - other.width);
+        }
+        else if (ry &lt; SPLIT_RATIO &amp;&amp; ry &lt; rx) {
+            request-&gt;position = GDL_DOCK_TOP;
+            divider = other.height;
+        }
+        else if (ry &gt; (1 - SPLIT_RATIO) &amp;&amp; (1 - ry) &lt; rx) {
+            request-&gt;position = GDL_DOCK_BOTTOM;
+            divider = MAX (0, my.height - other.height);
+        }
+        else
+            request-&gt;position = GDL_DOCK_CENTER;
+
+        /* Reset rectangle coordinates to entire item. */
+        request-&gt;rect.x = 0;
+        request-&gt;rect.y = 0;
+        request-&gt;rect.width = alloc-&gt;width;
+        request-&gt;rect.height = alloc-&gt;height;
+
+        /* Calculate docking indicator rectangle size for new locations. Only
+           do this when we're not over the item's current location. */
+        if (request-&gt;applicant != object) {
+            switch (request-&gt;position) {
+                case GDL_DOCK_TOP:
+                    request-&gt;rect.height *= SPLIT_RATIO;
+                    break;
+                case GDL_DOCK_BOTTOM:
+                    request-&gt;rect.y += request-&gt;rect.height * (1 - SPLIT_RATIO);
+                    request-&gt;rect.height *= SPLIT_RATIO;
+                    break;
+                case GDL_DOCK_LEFT:
+                    request-&gt;rect.width *= SPLIT_RATIO;
+                    break;
+                case GDL_DOCK_RIGHT:
+                    request-&gt;rect.x += request-&gt;rect.width * (1 - SPLIT_RATIO);
+                    request-&gt;rect.width *= SPLIT_RATIO;
+                    break;
+                case GDL_DOCK_CENTER:
+                    request-&gt;rect.x = request-&gt;rect.width * SPLIT_RATIO/2;
+                    request-&gt;rect.y = request-&gt;rect.height * SPLIT_RATIO/2;
+                    request-&gt;rect.width = (request-&gt;rect.width *
+                                           (1 - SPLIT_RATIO/2)) - request-&gt;rect.x;
+                    request-&gt;rect.height = (request-&gt;rect.height *
+                                            (1 - SPLIT_RATIO/2)) - request-&gt;rect.y;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        /* adjust returned coordinates so they are have the same
+           origin as our window */
+        request-&gt;rect.x += alloc-&gt;x;
+        request-&gt;rect.y += alloc-&gt;y;
+        
+        /* Set possible target location and return TRUE. */            
+        request-&gt;target = object;
+
+        /* fill-in other dock information */
+        if (request-&gt;position != GDL_DOCK_CENTER &amp;&amp; divider &gt;= 0) {
+            if (G_IS_VALUE (&amp;request-&gt;extra))
+                g_value_unset (&amp;request-&gt;extra);
+            g_value_init (&amp;request-&gt;extra, G_TYPE_UINT);
+            g_value_set_uint (&amp;request-&gt;extra, (guint) divider);
+        }
+        
+        return TRUE;         
+    }
+    else /* No docking possible at this location. */            
+        return FALSE;
+}
+
+static void
+gdl_dock_item_dock (GdlDockObject    *object,
+                    GdlDockObject    *requestor,
+                    GdlDockPlacement  position,
+                    GValue           *other_data)
+{
+    GdlDockObject *new_parent, *parent;
+    gboolean       add_ourselves_first;
+    
+    parent = gdl_dock_object_get_parent_object (object);
+
+    switch (position) {
+        case GDL_DOCK_TOP:
+        case GDL_DOCK_BOTTOM:
+            /* get a paned style dock object */
+            new_parent = g_object_new (gdl_dock_object_type_from_nick (&quot;paned&quot;),
+                                       &quot;orientation&quot;, GTK_ORIENTATION_VERTICAL,
+                                       NULL);
+            add_ourselves_first = (position == GDL_DOCK_BOTTOM);
+            break;
+        case GDL_DOCK_LEFT:
+        case GDL_DOCK_RIGHT:
+            new_parent = g_object_new (gdl_dock_object_type_from_nick (&quot;paned&quot;),
+                                       &quot;orientation&quot;, GTK_ORIENTATION_HORIZONTAL,
+                                       NULL);
+            add_ourselves_first = (position == GDL_DOCK_RIGHT);
+            break;
+        case GDL_DOCK_CENTER:
+            new_parent = g_object_new (gdl_dock_object_type_from_nick (&quot;notebook&quot;),
+                                       NULL);
+            add_ourselves_first = TRUE;
+            break;
+        default: 
+        {
+            GEnumClass *enum_class = G_ENUM_CLASS (g_type_class_ref (GDL_TYPE_DOCK_PLACEMENT));
+            GEnumValue *enum_value = g_enum_get_value (enum_class, position);
+            gchar *name = enum_value ? enum_value-&gt;value_name : NULL;
+            
+            g_warning (_(&quot;Unsupported docking strategy %s in dock object of type %s&quot;),
+                       name,  G_OBJECT_TYPE_NAME (object));
+            g_type_class_unref (enum_class);
+            return;
+        }
+    }
+
+    /* freeze the parent so it doesn't reduce automatically */
+    if (parent)
+        gdl_dock_object_freeze (parent);
+
+    /* ref ourselves since we could be destroyed when detached */
+    g_object_ref (object);
+    GDL_DOCK_OBJECT_SET_FLAGS (object, GDL_DOCK_IN_REFLOW);
+    gdl_dock_object_detach (object, FALSE);
+
+    /* freeze the new parent, so reduce won't get called before it's
+       actually added to our parent */
+    gdl_dock_object_freeze (new_parent);
+    
+    /* bind the new parent to our master, so the following adds work */
+    gdl_dock_object_bind (new_parent, G_OBJECT (GDL_DOCK_OBJECT_GET_MASTER (object)));
+    
+    /* add the objects */
+    if (add_ourselves_first) {
+        gtk_container_add (GTK_CONTAINER (new_parent), GTK_WIDGET (object));
+        gtk_container_add (GTK_CONTAINER (new_parent), GTK_WIDGET (requestor));
+    } else {
+        gtk_container_add (GTK_CONTAINER (new_parent), GTK_WIDGET (requestor));
+        gtk_container_add (GTK_CONTAINER (new_parent), GTK_WIDGET (object));
+    }
+
+    /* add the new parent to the parent */
+    if (parent)
+        gtk_container_add (GTK_CONTAINER (parent), GTK_WIDGET (new_parent));
+
+    /* show automatic object */
+    if (GTK_WIDGET_VISIBLE (object))
+        gtk_widget_show (GTK_WIDGET (new_parent));
+    
+    /* use extra docking parameter */
+    if (position != GDL_DOCK_CENTER &amp;&amp; other_data &amp;&amp;
+        G_VALUE_HOLDS (other_data, G_TYPE_UINT)) {
+        
+        g_object_set (G_OBJECT (new_parent),
+                      &quot;position&quot;, g_value_get_uint (other_data),
+                      NULL);
+    }
+    
+    GDL_DOCK_OBJECT_UNSET_FLAGS (object, GDL_DOCK_IN_REFLOW);
+    g_object_unref (object);
+
+    gdl_dock_object_thaw (new_parent);
+    if (parent)
+        gdl_dock_object_thaw (parent);
+}
+
+static void
+gdl_dock_item_detach_menu (GtkWidget *widget,
+                           GtkMenu   *menu)
+{
+    GdlDockItem *item;
+   
+    item = GDL_DOCK_ITEM (widget);
+    item-&gt;_priv-&gt;menu = NULL;
+}
+
+static void
+gdl_dock_item_popup_menu (GdlDockItem  *item, 
+                          guint         button,
+                          guint32       time)
+{
+    GtkWidget *mitem;
+
+    if (!item-&gt;_priv-&gt;menu) {
+        /* Create popup menu and attach it to the dock item */
+        item-&gt;_priv-&gt;menu = gtk_menu_new ();
+        gtk_menu_attach_to_widget (GTK_MENU (item-&gt;_priv-&gt;menu),
+                                   GTK_WIDGET (item),
+                                   gdl_dock_item_detach_menu);
+        
+        /* Hide menuitem. */
+        mitem = gtk_menu_item_new_with_label (_(&quot;Hide&quot;));
+        gtk_menu_shell_append (GTK_MENU_SHELL (item-&gt;_priv-&gt;menu), mitem);
+        g_signal_connect (mitem, &quot;activate&quot;, 
+                          G_CALLBACK (gdl_dock_item_hide_cb), item);
+
+        /* Lock menuitem */
+        mitem = gtk_menu_item_new_with_label (_(&quot;Lock&quot;));
+        gtk_menu_shell_append (GTK_MENU_SHELL (item-&gt;_priv-&gt;menu), mitem);
+        g_signal_connect (mitem, &quot;activate&quot;,
+                          G_CALLBACK (gdl_dock_item_lock_cb), item);
+
+    }
+
+    /* Show popup menu. */
+    gtk_widget_show_all (item-&gt;_priv-&gt;menu);
+    gtk_menu_popup (GTK_MENU (item-&gt;_priv-&gt;menu), NULL, NULL, NULL, NULL, 
+                    button, time);
+}
+
+static void
+gdl_dock_item_drag_start (GdlDockItem *item)
+{
+    GdkCursor *fleur;
+
+    if (!GTK_WIDGET_REALIZED (item))
+        gtk_widget_realize (GTK_WIDGET (item));
+    
+    GDL_DOCK_ITEM_SET_FLAGS (item, GDL_DOCK_IN_DRAG);
+            
+    /* grab the pointer so we receive all mouse events */
+    fleur = gdk_cursor_new (GDK_FLEUR);
+
+    /* grab the keyboard &amp; pointer */
+    gtk_grab_add (GTK_WIDGET (item));
+    
+    gdk_cursor_unref (fleur);
+            
+    g_signal_emit (item, gdl_dock_item_signals [DOCK_DRAG_BEGIN], 0);
+}
+
+static void
+gdl_dock_item_drag_end (GdlDockItem *item,
+                        gboolean     cancel)
+{
+    /* Release pointer &amp; keyboard. */
+    gtk_grab_remove (gtk_grab_get_current ());
+    
+    g_signal_emit (item, gdl_dock_item_signals [DOCK_DRAG_END], 0, cancel);
+    
+    GDL_DOCK_ITEM_UNSET_FLAGS (item, GDL_DOCK_IN_DRAG);
+}
+
+static void 
+gdl_dock_item_tab_button (GtkWidget      *widget,
+                          GdkEventButton *event,
+                          gpointer        data)
+{
+    GdlDockItem *item;
+
+    item = GDL_DOCK_ITEM (data);
+
+    if (!GDL_DOCK_ITEM_NOT_LOCKED (item))
+        return;
+
+    switch (event-&gt;button) {
+    case 1:
+        /* set dragoff_{x,y} as we the user clicked on the middle of the 
+           drag handle */
+        switch (item-&gt;orientation) {
+        case GTK_ORIENTATION_HORIZONTAL:
+            item-&gt;dragoff_x = item-&gt;_priv-&gt;grip_size / 2;
+            item-&gt;dragoff_y = GTK_WIDGET (data)-&gt;allocation.height / 2;
+            break;
+        case GTK_ORIENTATION_VERTICAL:
+            item-&gt;dragoff_x = GTK_WIDGET (data)-&gt;allocation.width / 2;
+            item-&gt;dragoff_y = item-&gt;_priv-&gt;grip_size / 2;
+            break;
+        };
+        gdl_dock_item_drag_start (item);
+        break;
+
+    case 3:
+        gdl_dock_item_popup_menu (item, event-&gt;button, event-&gt;time);
+        break;
+
+    default:
+        break;
+    };
+}
+
+static void
+gdl_dock_item_hide_cb (GtkWidget   *widget, 
+                       GdlDockItem *item)
+{
+    GdlDockMaster *master;
+    
+    g_return_if_fail (item != NULL);
+
+    master = GDL_DOCK_OBJECT_GET_MASTER (item);
+    gdl_dock_item_hide_item (item);
+}
+
+static void
+gdl_dock_item_lock_cb (GtkWidget   *widget,
+                       GdlDockItem *item)
+{
+    g_return_if_fail (item != NULL);
+
+    gdl_dock_item_lock (item);
+}
+
+static void
+gdl_dock_item_showhide_grip (GdlDockItem *item)
+{
+    if (item-&gt;_priv-&gt;grip) {
+        if (GDL_DOCK_ITEM_GRIP_SHOWN (item)) {
+            gtk_widget_show (item-&gt;_priv-&gt;grip);
+            GTK_WIDGET_SET_FLAGS (item-&gt;_priv-&gt;grip, GTK_CAN_FOCUS);
+        } else {
+            gtk_widget_hide (item-&gt;_priv-&gt;grip);
+            GTK_WIDGET_UNSET_FLAGS (item-&gt;_priv-&gt;grip, GTK_CAN_FOCUS);
+        }
+    }
+    gtk_widget_queue_resize (GTK_WIDGET (item));
+}
+
+static void
+gdl_dock_item_real_set_orientation (GdlDockItem    *item,
+                                    GtkOrientation  orientation)
+{
+    item-&gt;orientation = orientation;
+    
+    if (GTK_WIDGET_DRAWABLE (item))
+        gtk_widget_queue_draw (GTK_WIDGET (item));
+    gtk_widget_queue_resize (GTK_WIDGET (item));
+}
+
+
+/* ----- Public interface ----- */
+
+GtkWidget *
+gdl_dock_item_new (const gchar         *name,
+                   const gchar         *long_name,
+                   GdlDockItemBehavior  behavior)
+{
+    GdlDockItem *item;
+
+    item = GDL_DOCK_ITEM (g_object_new (GDL_TYPE_DOCK_ITEM, 
+                                        &quot;name&quot;, name, 
+                                        &quot;long_name&quot;, long_name,
+                                        &quot;behavior&quot;, behavior,
+                                        NULL));
+    GDL_DOCK_OBJECT_UNSET_FLAGS (item, GDL_DOCK_AUTOMATIC);
+    gdl_dock_item_set_tablabel (item, gdl_dock_tablabel_new (item));
+
+    return GTK_WIDGET (item);
+}
+
+/* convenient function (and to preserve source compat) */
+void
+gdl_dock_item_dock_to (GdlDockItem      *item,
+                       GdlDockItem      *target,
+                       GdlDockPlacement  position,
+                       gint              docking_param)
+{
+    g_return_if_fail (item != NULL);
+    g_return_if_fail (item != target);
+    g_return_if_fail (target != NULL || position == GDL_DOCK_FLOATING);
+    
+    if (position == GDL_DOCK_FLOATING || !target) {
+        GdlDockObject *controller;
+        
+        if (!gdl_dock_object_is_bound (GDL_DOCK_OBJECT (item))) {
+            g_warning (_(&quot;Attempt to bind an unbound item %p&quot;), item);
+            return;
+        }
+
+        controller = gdl_dock_master_get_controller (GDL_DOCK_OBJECT_GET_MASTER (item));
+        
+        /* FIXME: save previous docking position for later
+           re-docking... does this make sense now? */
+
+        /* Create new floating dock for widget. */
+        item-&gt;dragoff_x = item-&gt;dragoff_y = 0;
+        gdl_dock_add_floating_item (GDL_DOCK (controller),
+                                    item, 0, 0, -1, -1);
+
+    } else
+        gdl_dock_object_dock (GDL_DOCK_OBJECT (target),
+                              GDL_DOCK_OBJECT (item),
+                              position, NULL);
+}
+
+void
+gdl_dock_item_set_orientation (GdlDockItem    *item,
+                               GtkOrientation  orientation)
+{
+    GParamSpec *pspec;
+
+    g_return_if_fail (item != NULL);
+
+    if (item-&gt;orientation != orientation) {
+        /* push the property down the hierarchy if our child supports it */
+        if (item-&gt;child != NULL) {
+            pspec = g_object_class_find_property (
+                G_OBJECT_GET_CLASS (item-&gt;child), &quot;orientation&quot;);
+            if (pspec &amp;&amp; pspec-&gt;value_type == GTK_TYPE_ORIENTATION)
+                g_object_set (G_OBJECT (item-&gt;child),
+                              &quot;orientation&quot;, orientation,
+                              NULL);
+        };
+
+        GDL_CALL_VIRTUAL (item, GDL_DOCK_ITEM_GET_CLASS, set_orientation, (item, orientation));
+        g_object_notify (G_OBJECT (item), &quot;orientation&quot;);
+    }
+}
+
+GtkWidget *
+gdl_dock_item_get_tablabel (GdlDockItem *item)
+{
+    g_return_val_if_fail (item != NULL, NULL);
+    g_return_val_if_fail (GDL_IS_DOCK_ITEM (item), NULL);
+
+    return item-&gt;_priv-&gt;tab_label;
+}
+
+void
+gdl_dock_item_set_tablabel (GdlDockItem *item,
+                            GtkWidget   *tablabel)
+{
+    g_return_if_fail (item != NULL);
+
+    if (item-&gt;_priv-&gt;tab_label) {
+        /* disconnect and unref the previous tablabel */
+        if (GDL_IS_DOCK_TABLABEL (item-&gt;_priv-&gt;tab_label)) {
+            g_signal_handlers_disconnect_matched (item-&gt;_priv-&gt;tab_label,
+                                                  G_SIGNAL_MATCH_DATA,
+                                                  0, 0, NULL,
+                                                  NULL, item);
+            g_object_set (item-&gt;_priv-&gt;tab_label, &quot;item&quot;, NULL, NULL);
+        }
+        gtk_widget_unref (item-&gt;_priv-&gt;tab_label);
+        item-&gt;_priv-&gt;tab_label = NULL;
+    }
+    
+    if (tablabel) {
+        gtk_widget_ref (tablabel);
+        gtk_object_sink (GTK_OBJECT (tablabel));
+        item-&gt;_priv-&gt;tab_label = tablabel;
+        if (GDL_IS_DOCK_TABLABEL (tablabel)) {
+            g_object_set (tablabel, &quot;item&quot;, item, NULL);
+            /* connect to tablabel signal */
+            g_signal_connect (tablabel, &quot;button_pressed_handle&quot;,
+                              G_CALLBACK (gdl_dock_item_tab_button), item);
+        }
+    }
+}
+
+void 
+gdl_dock_item_hide_grip (GdlDockItem *item)
+{
+    g_return_if_fail (item != NULL);
+    if (item-&gt;_priv-&gt;grip_shown) {
+        item-&gt;_priv-&gt;grip_shown = FALSE;
+        gdl_dock_item_showhide_grip (item);
+    };
+}
+
+void
+gdl_dock_item_show_grip (GdlDockItem *item)
+{
+    g_return_if_fail (item != NULL);
+    if (!item-&gt;_priv-&gt;grip_shown) {
+        item-&gt;_priv-&gt;grip_shown = TRUE;
+        gdl_dock_item_showhide_grip (item);
+    };
+}
+
+/* convenient function (and to preserve source compat) */
+void
+gdl_dock_item_bind (GdlDockItem *item,
+                    GtkWidget   *dock)
+{
+    g_return_if_fail (item != NULL);
+    g_return_if_fail (dock == NULL || GDL_IS_DOCK (dock));
+    
+    gdl_dock_object_bind (GDL_DOCK_OBJECT (item),
+                          G_OBJECT (GDL_DOCK_OBJECT_GET_MASTER (dock)));
+}
+
+/* convenient function (and to preserve source compat) */
+void
+gdl_dock_item_unbind (GdlDockItem *item)
+{
+    g_return_if_fail (item != NULL);
+
+    gdl_dock_object_unbind (GDL_DOCK_OBJECT (item));
+}
+
+void
+gdl_dock_item_hide_item (GdlDockItem *item)
+{
+    g_return_if_fail (item != NULL);
+
+    if (!GDL_DOCK_OBJECT_ATTACHED (item))
+        /* already hidden/detached */
+        return;
+    
+    /* if the object is manual, create a new placeholder to be able to
+       restore the position later */
+    if (!GDL_DOCK_OBJECT_AUTOMATIC (item)) {
+        if (item-&gt;_priv-&gt;ph)
+            g_object_unref (item-&gt;_priv-&gt;ph);
+        
+        item-&gt;_priv-&gt;ph = GDL_DOCK_PLACEHOLDER (
+            g_object_new (GDL_TYPE_DOCK_PLACEHOLDER,
+                          &quot;sticky&quot;, FALSE,
+                          &quot;host&quot;, item,
+                          NULL));
+        g_object_ref (item-&gt;_priv-&gt;ph);
+        gtk_object_sink (GTK_OBJECT (item-&gt;_priv-&gt;ph));
+    }
+    
+    gdl_dock_object_freeze (GDL_DOCK_OBJECT (item));
+    
+    /* hide our children first, so they can also set placeholders */
+    if (gdl_dock_object_is_compound (GDL_DOCK_OBJECT (item))) 
+        gtk_container_foreach (GTK_CONTAINER (item),
+                               (GtkCallback) gdl_dock_item_hide_item,
+                               NULL);
+    
+    /* detach the item recursively */
+    gdl_dock_object_detach (GDL_DOCK_OBJECT (item), TRUE);
+
+    gdl_dock_object_thaw (GDL_DOCK_OBJECT (item));
+}
+
+void
+gdl_dock_item_show_item (GdlDockItem *item)
+{
+    g_return_if_fail (item != NULL);
+
+    if (item-&gt;_priv-&gt;ph) {
+        gtk_container_add (GTK_CONTAINER (item-&gt;_priv-&gt;ph), GTK_WIDGET (item));
+        g_object_unref (item-&gt;_priv-&gt;ph);
+        item-&gt;_priv-&gt;ph = NULL;
+    }
+    else if (gdl_dock_object_is_bound (GDL_DOCK_OBJECT (item))) {
+        GdlDockObject *toplevel = gdl_dock_master_get_controller (
+            GDL_DOCK_OBJECT_GET_MASTER (item));
+        if (toplevel) {
+            gdl_dock_object_dock (toplevel, GDL_DOCK_OBJECT (item),
+                                  GDL_DOCK_FLOATING, NULL);
+        }
+    }
+}
+
+void
+gdl_dock_item_lock (GdlDockItem *item)
+{
+    g_object_set (item, &quot;locked&quot;, TRUE, NULL);
+}
+
+void
+gdl_dock_item_unlock (GdlDockItem *item)
+{
+    g_object_set (item, &quot;locked&quot;, FALSE, NULL);
+}
+
+void 
+gdl_dock_item_set_default_position (GdlDockItem   *item,
+                                    GdlDockObject *reference)
+{
+    g_return_if_fail (item != NULL);
+
+    if (item-&gt;_priv-&gt;ph) {
+        g_object_unref (item-&gt;_priv-&gt;ph);
+        item-&gt;_priv-&gt;ph = NULL;
+    }
+
+    if (reference &amp;&amp; GDL_DOCK_OBJECT_ATTACHED (reference)) {
+        if (GDL_IS_DOCK_PLACEHOLDER (reference)) {
+            g_object_ref (reference);
+            gtk_object_sink (GTK_OBJECT (reference));
+            item-&gt;_priv-&gt;ph = GDL_DOCK_PLACEHOLDER (reference);
+        }
+        else {
+            item-&gt;_priv-&gt;ph = GDL_DOCK_PLACEHOLDER (
+                g_object_new (GDL_TYPE_DOCK_PLACEHOLDER,
+                              &quot;sticky&quot;, TRUE,
+                              &quot;host&quot;, reference,
+                              NULL));
+            g_object_ref (item-&gt;_priv-&gt;ph);
+            gtk_object_sink (GTK_OBJECT (item-&gt;_priv-&gt;ph));
+        }
+    }
+}
+
+void 
+gdl_dock_item_preferred_size (GdlDockItem    *item,
+                              GtkRequisition *req)
+{
+    if (!req)
+        return;
+
+    req-&gt;width = MAX (item-&gt;_priv-&gt;preferred_width,
+                      GTK_WIDGET (item)-&gt;allocation.width);
+    req-&gt;height = MAX (item-&gt;_priv-&gt;preferred_height,
+                       GTK_WIDGET (item)-&gt;allocation.height);
+}
+
+
+/* ----- gtk orientation type exporter/importer ----- */
+
+static void 
+gdl_dock_param_export_gtk_orientation (const GValue *src,
+                                       GValue       *dst)
+{
+    dst-&gt;data [0].v_pointer =
+        g_strdup_printf (&quot;%s&quot;, (src-&gt;data [0].v_int == GTK_ORIENTATION_HORIZONTAL) ?
+                         &quot;horizontal&quot; : &quot;vertical&quot;);
+}
+
+static void 
+gdl_dock_param_import_gtk_orientation (const GValue *src,
+                                       GValue       *dst)
+{
+    if (!strcmp (src-&gt;data [0].v_pointer, &quot;horizontal&quot;))
+        dst-&gt;data [0].v_int = GTK_ORIENTATION_HORIZONTAL;
+    else
+        dst-&gt;data [0].v_int = GTK_ORIENTATION_VERTICAL;
+}
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,164 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * gdl-dock-item.h
+ *
+ * Author: Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * Based on GnomeDockItem/BonoboDockItem.  Original copyright notice follows.
+ *
+ * Copyright (C) 1998 Ettore Perazzoli
+ * Copyright (C) 1998 Elliot Lee
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald 
+ * All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GDL_DOCK_ITEM_H__
+#define __GDL_DOCK_ITEM_H__
+
+#include &lt;gdl/gdl-dock-object.h&gt;
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK_ITEM            (gdl_dock_item_get_type ())
+#define GDL_DOCK_ITEM(obj)            (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_ITEM, GdlDockItem))
+#define GDL_DOCK_ITEM_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_ITEM, GdlDockItemClass))
+#define GDL_IS_DOCK_ITEM(obj)         (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_ITEM))
+#define GDL_IS_DOCK_ITEM_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_ITEM))
+#define GDL_DOCK_ITEM_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), GTK_TYPE_DOCK_ITEM, GdlDockItemClass))
+
+/* data types &amp; structures */
+typedef enum {
+    GDL_DOCK_ITEM_BEH_NORMAL           = 0,
+    GDL_DOCK_ITEM_BEH_NEVER_FLOATING   = 1 &lt;&lt; 0,
+    GDL_DOCK_ITEM_BEH_NEVER_VERTICAL   = 1 &lt;&lt; 1,
+    GDL_DOCK_ITEM_BEH_NEVER_HORIZONTAL = 1 &lt;&lt; 2,
+    GDL_DOCK_ITEM_BEH_LOCKED           = 1 &lt;&lt; 3,
+    GDL_DOCK_ITEM_BEH_CANT_DOCK_TOP    = 1 &lt;&lt; 4,
+    GDL_DOCK_ITEM_BEH_CANT_DOCK_BOTTOM = 1 &lt;&lt; 5,
+    GDL_DOCK_ITEM_BEH_CANT_DOCK_LEFT   = 1 &lt;&lt; 6,
+    GDL_DOCK_ITEM_BEH_CANT_DOCK_RIGHT  = 1 &lt;&lt; 7,
+    GDL_DOCK_ITEM_BEH_CANT_DOCK_CENTER = 1 &lt;&lt; 8
+} GdlDockItemBehavior;
+
+typedef enum {
+    GDL_DOCK_IN_DRAG             = 1 &lt;&lt; GDL_DOCK_OBJECT_FLAGS_SHIFT,
+    GDL_DOCK_IN_PREDRAG          = 1 &lt;&lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 1),
+    /* for general use: indicates the user has started an action on
+       the dock item */
+    GDL_DOCK_USER_ACTION         = 1 &lt;&lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 2)
+} GdlDockItemFlags;
+
+typedef struct _GdlDockItem        GdlDockItem;
+typedef struct _GdlDockItemClass   GdlDockItemClass;
+typedef struct _GdlDockItemPrivate GdlDockItemPrivate;
+
+struct _GdlDockItem {
+    GdlDockObject        object;
+
+    GtkWidget           *child;
+    GdlDockItemBehavior  behavior;
+    GtkOrientation       orientation;
+
+    guint                resize : 1;
+
+    gint                 dragoff_x, dragoff_y;    /* these need to be
+                                                     accesible from
+                                                     outside */
+    GdlDockItemPrivate  *_priv;
+};
+
+struct _GdlDockItemClass {
+    GdlDockObjectClass  parent_class;
+
+    gboolean            has_grip;
+    
+    /* virtuals */
+    void     (* dock_drag_begin)  (GdlDockItem    *item);
+    void     (* dock_drag_motion) (GdlDockItem    *item,
+                                   gint            x,
+                                   gint            y);
+    void     (* dock_drag_end)    (GdlDockItem    *item,
+                                   gboolean        cancelled);
+                                   
+    void     (* set_orientation)  (GdlDockItem    *item,
+                                   GtkOrientation  orientation);
+};
+
+/* additional macros */
+#define GDL_DOCK_ITEM_FLAGS(item)     (GDL_DOCK_OBJECT (item)-&gt;flags)
+#define GDL_DOCK_ITEM_IN_DRAG(item) \
+    ((GDL_DOCK_ITEM_FLAGS (item) &amp; GDL_DOCK_IN_DRAG) != 0)
+#define GDL_DOCK_ITEM_IN_PREDRAG(item) \
+    ((GDL_DOCK_ITEM_FLAGS (item) &amp; GDL_DOCK_IN_PREDRAG) != 0)
+#define GDL_DOCK_ITEM_USER_ACTION(item) \
+    ((GDL_DOCK_ITEM_FLAGS (item) &amp; GDL_DOCK_USER_ACTION) != 0)
+   
+#define GDL_DOCK_ITEM_SET_FLAGS(item,flag) \
+    G_STMT_START { (GDL_DOCK_ITEM_FLAGS (item) |= (flag)); } G_STMT_END
+#define GDL_DOCK_ITEM_UNSET_FLAGS(item,flag) \
+    G_STMT_START { (GDL_DOCK_ITEM_FLAGS (item) &amp;= ~(flag)); } G_STMT_END
+
+#define GDL_DOCK_ITEM_HAS_GRIP(item) (GDL_DOCK_ITEM_GET_CLASS (item)-&gt;has_grip)
+
+/* public interface */
+ 
+GtkWidget     *gdl_dock_item_new               (const gchar         *name,
+                                                const gchar         *long_name,
+                                                GdlDockItemBehavior  behavior);
+
+GType          gdl_dock_item_get_type          (void);
+
+void           gdl_dock_item_dock_to           (GdlDockItem      *item,
+                                                GdlDockItem      *target,
+                                                GdlDockPlacement  position,
+                                                gint              docking_param);
+
+void           gdl_dock_item_set_orientation   (GdlDockItem    *item,
+                                                GtkOrientation  orientation);
+
+GtkWidget     *gdl_dock_item_get_tablabel      (GdlDockItem *item);
+void           gdl_dock_item_set_tablabel      (GdlDockItem *item,
+                                                GtkWidget   *tablabel);
+void           gdl_dock_item_hide_grip         (GdlDockItem *item);
+void           gdl_dock_item_show_grip         (GdlDockItem *item);
+
+/* bind and unbind items to a dock */
+void           gdl_dock_item_bind              (GdlDockItem *item,
+                                                GtkWidget   *dock);
+
+void           gdl_dock_item_unbind            (GdlDockItem *item);
+
+void           gdl_dock_item_hide_item         (GdlDockItem *item);
+
+void           gdl_dock_item_show_item         (GdlDockItem *item);
+
+void           gdl_dock_item_lock              (GdlDockItem *item);
+
+void           gdl_dock_item_unlock            (GdlDockItem *item);
+
+void        gdl_dock_item_set_default_position (GdlDockItem      *item,
+                                                GdlDockObject    *reference);
+
+void        gdl_dock_item_preferred_size       (GdlDockItem      *item,
+                                                GtkRequisition   *req);
+
+
+G_END_DECLS
+
+#endif

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,1413 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#195;&#161;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;string.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;libxml/parser.h&gt;
+#include &lt;gtk/gtk.h&gt;
+#include &lt;glade/glade.h&gt;
+#include &lt;libgnome/gnome-macros.h&gt;
+
+#include &quot;gdl-dock-layout.h&quot;
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock-placeholder.h&quot;
+
+
+/* ----- Private variables ----- */
+
+enum {
+    PROP_0,
+    PROP_MASTER,
+    PROP_DIRTY
+};
+
+#define ROOT_ELEMENT         &quot;dock-layout&quot;
+#define DEFAULT_LAYOUT       &quot;__default__&quot;
+#define LAYOUT_ELEMENT_NAME  &quot;layout&quot;
+#define NAME_ATTRIBUTE_NAME  &quot;name&quot;
+
+#define LAYOUT_GLADE_FILE    &quot;layout.glade&quot;
+
+enum {
+    COLUMN_NAME,
+    COLUMN_SHOW,
+    COLUMN_LOCKED,
+    COLUMN_ITEM
+};
+
+#define COLUMN_EDITABLE COLUMN_SHOW
+
+struct _GdlDockLayoutPrivate {
+    xmlDocPtr         doc;
+
+    /* layout list models */
+    GtkListStore     *items_model;
+    GtkListStore     *layouts_model;
+
+    /* idle control */
+    gboolean          idle_save_pending;
+};
+
+typedef struct _GdlDockLayoutUIData GdlDockLayoutUIData;
+
+struct _GdlDockLayoutUIData {
+    GdlDockLayout    *layout;
+    
+    GtkWidget        *locked_check;
+    GtkTreeSelection *selection;
+};
+
+
+/* ----- Private prototypes ----- */
+
+static void     gdl_dock_layout_class_init      (GdlDockLayoutClass *klass);
+
+static void     gdl_dock_layout_instance_init   (GdlDockLayout      *layout);
+
+static void     gdl_dock_layout_set_property    (GObject            *object,
+                                                 guint               prop_id,
+                                                 const GValue       *value,
+                                                 GParamSpec         *pspec);
+
+static void     gdl_dock_layout_get_property    (GObject            *object,
+                                                 guint               prop_id,
+                                                 GValue             *value,
+                                                 GParamSpec         *pspec);
+
+static void     gdl_dock_layout_dispose         (GObject            *object);
+
+static void     gdl_dock_layout_build_doc       (GdlDockLayout      *layout);
+
+static xmlNodePtr gdl_dock_layout_find_layout   (GdlDockLayout      *layout, 
+                                                 const gchar        *name);
+
+static void     gdl_dock_layout_build_models    (GdlDockLayout      *layout);
+
+
+/* ----- Private implementation ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDockLayout, gdl_dock_layout, GObject, G_TYPE_OBJECT);
+
+static void
+gdl_dock_layout_class_init (GdlDockLayoutClass *klass)
+{
+    GObjectClass *g_object_class = (GObjectClass *) klass;
+
+    g_object_class-&gt;set_property = gdl_dock_layout_set_property;
+    g_object_class-&gt;get_property = gdl_dock_layout_get_property;
+    g_object_class-&gt;dispose = gdl_dock_layout_dispose;
+
+    g_object_class_install_property (
+        g_object_class, PROP_MASTER,
+        g_param_spec_object (&quot;master&quot;, _(&quot;Master&quot;),
+                             _(&quot;GdlDockMaster object which the layout object &quot;
+                               &quot;is attached to&quot;),
+                             GDL_TYPE_DOCK_MASTER, 
+                             G_PARAM_READWRITE));
+
+    g_object_class_install_property (
+        g_object_class, PROP_DIRTY,
+        g_param_spec_boolean (&quot;dirty&quot;, _(&quot;Dirty&quot;),
+                              _(&quot;True if the layouts have changed and need to be &quot;
+                                &quot;saved to a file&quot;),
+                              FALSE,
+                              G_PARAM_READABLE));
+}
+
+static void
+gdl_dock_layout_instance_init (GdlDockLayout *layout)
+{
+    layout-&gt;master = NULL;
+    layout-&gt;dirty = FALSE;
+    layout-&gt;_priv = g_new0 (GdlDockLayoutPrivate, 1);
+    layout-&gt;_priv-&gt;idle_save_pending = FALSE;
+
+    gdl_dock_layout_build_models (layout);
+}
+
+static void
+gdl_dock_layout_set_property (GObject      *object,
+			      guint         prop_id,
+			      const GValue *value,
+			      GParamSpec   *pspec)
+{
+    GdlDockLayout *layout = GDL_DOCK_LAYOUT (object);
+
+    switch (prop_id) {
+        case PROP_MASTER:
+            gdl_dock_layout_attach (layout, g_value_get_object (value));
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    };
+}
+
+static void
+gdl_dock_layout_get_property (GObject    *object,
+			      guint       prop_id,
+			      GValue     *value,
+			      GParamSpec *pspec)
+{
+    GdlDockLayout *layout = GDL_DOCK_LAYOUT (object);
+
+    switch (prop_id) {
+        case PROP_MASTER:
+            g_value_set_object (value, layout-&gt;master);
+            break;
+        case PROP_DIRTY:
+            g_value_set_boolean (value, layout-&gt;dirty);
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    };
+}
+
+static void
+gdl_dock_layout_dispose (GObject *object)
+{
+    GdlDockLayout *layout;
+
+    g_return_if_fail (object != NULL);
+    g_return_if_fail (GDL_IS_DOCK_LAYOUT (object));
+
+    layout = GDL_DOCK_LAYOUT (object);
+    
+    if (layout-&gt;master)
+        gdl_dock_layout_attach (layout, NULL);
+
+    if (layout-&gt;_priv) {
+        if (layout-&gt;_priv-&gt;idle_save_pending) {
+            layout-&gt;_priv-&gt;idle_save_pending = FALSE;
+            g_idle_remove_by_data (layout);
+        }
+        
+        if (layout-&gt;_priv-&gt;doc) {
+            xmlFreeDoc (layout-&gt;_priv-&gt;doc);
+            layout-&gt;_priv-&gt;doc = NULL;
+        }
+
+        if (layout-&gt;_priv-&gt;items_model) {
+            g_object_unref (layout-&gt;_priv-&gt;items_model);
+            g_object_unref (layout-&gt;_priv-&gt;layouts_model);
+            layout-&gt;_priv-&gt;items_model = NULL;
+            layout-&gt;_priv-&gt;layouts_model = NULL;
+        }
+
+        g_free (layout-&gt;_priv);
+        layout-&gt;_priv = NULL;
+    }
+}
+
+static void
+gdl_dock_layout_build_doc (GdlDockLayout *layout)
+{
+    g_return_if_fail (layout-&gt;_priv-&gt;doc == NULL);
+
+    layout-&gt;_priv-&gt;doc = xmlNewDoc (&quot;1.0&quot;);
+    layout-&gt;_priv-&gt;doc-&gt;children = xmlNewDocNode (layout-&gt;_priv-&gt;doc, NULL, 
+                                                  ROOT_ELEMENT, NULL);
+}
+
+static xmlNodePtr
+gdl_dock_layout_find_layout (GdlDockLayout *layout, 
+                             const gchar   *name)
+{
+    xmlNodePtr node;
+    gboolean   found = FALSE;
+
+    g_return_val_if_fail (layout != NULL, NULL);
+    
+    if (!layout-&gt;_priv-&gt;doc)
+        return NULL;
+
+    /* get document root */
+    node = layout-&gt;_priv-&gt;doc-&gt;children;
+    for (node = node-&gt;children; node; node = node-&gt;next) {
+        gchar *layout_name;
+        
+        if (strcmp (node-&gt;name, LAYOUT_ELEMENT_NAME))
+            /* skip non-layout element */
+            continue;
+
+        /* we want the first layout */
+        if (!name)
+            break;
+
+        layout_name = xmlGetProp (node, NAME_ATTRIBUTE_NAME);
+        if (!strcmp (name, layout_name))
+            found = TRUE;
+        xmlFree (layout_name);
+
+        if (found)
+            break;
+    };
+    return node;
+}
+
+static void
+gdl_dock_layout_build_models (GdlDockLayout *layout)
+{
+    if (!layout-&gt;_priv-&gt;items_model) {
+        layout-&gt;_priv-&gt;items_model = gtk_list_store_new (4, 
+                                                         G_TYPE_STRING, 
+                                                         G_TYPE_BOOLEAN,
+                                                         G_TYPE_BOOLEAN,
+                                                         G_TYPE_POINTER);
+        gtk_tree_sortable_set_sort_column_id (
+            GTK_TREE_SORTABLE (layout-&gt;_priv-&gt;items_model), 
+            COLUMN_NAME, GTK_SORT_ASCENDING);
+    }
+
+    if (!layout-&gt;_priv-&gt;layouts_model) {
+        layout-&gt;_priv-&gt;layouts_model = gtk_list_store_new (2, G_TYPE_STRING,
+                                                           G_TYPE_BOOLEAN);
+        gtk_tree_sortable_set_sort_column_id (
+            GTK_TREE_SORTABLE (layout-&gt;_priv-&gt;layouts_model),
+            COLUMN_NAME, GTK_SORT_ASCENDING);
+    }
+}
+
+static void
+build_list (GdlDockObject *object, GList **list)
+{
+    /* add only items, not toplevels */
+    if (GDL_IS_DOCK_ITEM (object))
+        *list = g_list_prepend (*list, object);
+}
+
+static void
+update_items_model (GdlDockLayout *layout)
+{
+    GList *items, *l;
+    GtkTreeIter iter;
+    GtkListStore *store;
+    gchar *long_name;
+    gboolean locked;
+    
+    g_return_if_fail (layout != NULL);
+    g_return_if_fail (layout-&gt;_priv-&gt;items_model != NULL);
+
+    if (!layout-&gt;master)
+        return;
+    
+    /* build items list */
+    items = NULL;
+    gdl_dock_master_foreach (layout-&gt;master, (GFunc) build_list, &amp;items);
+
+    /* walk the current model */
+    store = layout-&gt;_priv-&gt;items_model;
+    
+    /* update items model data after a layout load */
+    if (gtk_tree_model_get_iter_first (GTK_TREE_MODEL (store), &amp;iter)) {
+        gboolean valid = TRUE;
+        
+        while (valid) {
+            GdlDockItem *item;
+            
+            gtk_tree_model_get (GTK_TREE_MODEL (store), &amp;iter,
+                                COLUMN_ITEM, &amp;item,
+                                -1);
+            if (item) {
+                /* look for the object in the items list */
+                for (l = items; l &amp;&amp; l-&gt;data != item; l = l-&gt;next);
+
+                if (l) {
+                    /* found, update data */
+                    g_object_get (item, 
+                                  &quot;long_name&quot;, &amp;long_name, 
+                                  &quot;locked&quot;, &amp;locked, 
+                                  NULL);
+                    gtk_list_store_set (store, &amp;iter, 
+                                        COLUMN_NAME, long_name,
+                                        COLUMN_SHOW, GDL_DOCK_OBJECT_ATTACHED (item),
+                                        COLUMN_LOCKED, locked,
+                                        -1);
+                    g_free (long_name);
+
+                    /* remove the item from the linked list and keep on walking the model */
+                    items = g_list_delete_link (items, l);
+                    valid = gtk_tree_model_iter_next (GTK_TREE_MODEL (store), &amp;iter);
+
+                } else {
+                    /* not found, which means the item has been removed */
+                    valid = gtk_list_store_remove (store, &amp;iter);
+                    
+                }
+
+            } else {
+                /* not a valid row */
+                valid = gtk_list_store_remove (store, &amp;iter);
+            }
+        }
+    }
+
+    /* add any remaining objects */
+    for (l = items; l; l = l-&gt;next) {
+        GdlDockObject *object = l-&gt;data;
+        
+        g_object_get (object, 
+                      &quot;long_name&quot;, &amp;long_name, 
+                      &quot;locked&quot;, &amp;locked, 
+                      NULL);
+        gtk_list_store_append (store, &amp;iter);
+        gtk_list_store_set (store, &amp;iter, 
+                            COLUMN_ITEM, object,
+                            COLUMN_NAME, long_name,
+                            COLUMN_SHOW, GDL_DOCK_OBJECT_ATTACHED (object),
+                            COLUMN_LOCKED, locked,
+                            -1);
+        g_free (long_name);
+    }
+    
+    g_list_free (items);
+}
+
+static void
+update_layouts_model (GdlDockLayout *layout)
+{
+    GList *items, *l;
+    GtkTreeIter iter;
+    
+    g_return_if_fail (layout != NULL);
+    g_return_if_fail (layout-&gt;_priv-&gt;layouts_model != NULL);
+
+    /* build layouts list */
+    gtk_list_store_clear (layout-&gt;_priv-&gt;layouts_model);
+    items = gdl_dock_layout_get_layouts (layout, FALSE);
+    for (l = items; l; l = l-&gt;next) {
+        gtk_list_store_append (layout-&gt;_priv-&gt;layouts_model, &amp;iter);
+        gtk_list_store_set (layout-&gt;_priv-&gt;layouts_model, &amp;iter,
+                            COLUMN_NAME, l-&gt;data, COLUMN_EDITABLE, TRUE,
+                            -1);
+        g_free (l-&gt;data);
+    };
+    g_list_free (items);
+}
+
+
+/* ------- UI functions &amp; callbacks ------ */
+
+static void 
+load_layout_cb (GtkWidget *w,
+                gpointer   data)
+{
+    GdlDockLayoutUIData *ui_data = (GdlDockLayoutUIData *) data;
+
+    GtkTreeModel  *model;
+    GtkTreeIter    iter;
+    GdlDockLayout *layout = ui_data-&gt;layout;
+    gchar         *name;
+
+    g_return_if_fail (layout != NULL);
+    
+    if (gtk_tree_selection_get_selected (ui_data-&gt;selection, &amp;model, &amp;iter)) {
+        gtk_tree_model_get (model, &amp;iter,
+                            COLUMN_NAME, &amp;name,
+                            -1);
+        gdl_dock_layout_load_layout (layout, name);
+        g_free (name);
+    }
+}
+
+static void
+delete_layout_cb (GtkWidget *w, gpointer data)
+{
+    GdlDockLayoutUIData *ui_data = (GdlDockLayoutUIData *) data;
+
+    GtkTreeModel  *model;
+    GtkTreeIter    iter;
+    GdlDockLayout *layout = ui_data-&gt;layout;
+    gchar         *name;
+
+    g_return_if_fail (layout != NULL);
+    
+    if (gtk_tree_selection_get_selected (ui_data-&gt;selection, &amp;model, &amp;iter)) {
+        gtk_tree_model_get (model, &amp;iter,
+                            COLUMN_NAME, &amp;name,
+                            -1);
+        gdl_dock_layout_delete_layout (layout, name);
+        gtk_list_store_remove (GTK_LIST_STORE (model), &amp;iter);
+        g_free (name);
+    };
+}
+
+static void
+show_toggled_cb (GtkCellRendererToggle *renderer,
+                 gchar                 *path_str,
+                 gpointer               data)
+{
+    GdlDockLayoutUIData *ui_data = (GdlDockLayoutUIData *) data;
+
+    GdlDockLayout *layout = ui_data-&gt;layout;
+    GtkTreeModel  *model;
+    GtkTreeIter    iter;
+    GtkTreePath   *path = gtk_tree_path_new_from_string (path_str);
+    gboolean       value;
+    GdlDockItem   *item;
+
+    g_return_if_fail (layout != NULL);
+    
+    model = GTK_TREE_MODEL (layout-&gt;_priv-&gt;items_model);
+    gtk_tree_model_get_iter (model, &amp;iter, path);
+    gtk_tree_model_get (model, &amp;iter, 
+                        COLUMN_SHOW, &amp;value, 
+                        COLUMN_ITEM, &amp;item, 
+                        -1);
+
+    value = !value;
+    if (value)
+        gdl_dock_item_show_item (item);
+    else
+        gdl_dock_item_hide_item (item);
+
+    gtk_tree_path_free (path);
+}
+
+static void
+all_locked_toggled_cb (GtkWidget *widget,
+                       gpointer   data)
+{
+    GdlDockLayoutUIData *ui_data = (GdlDockLayoutUIData *) data;
+    GdlDockMaster       *master;
+    gboolean             locked;
+    
+    g_return_if_fail (ui_data-&gt;layout != NULL);
+    master = ui_data-&gt;layout-&gt;master;
+    g_return_if_fail (master != NULL);
+
+    locked = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget));
+    g_object_set (master, &quot;locked&quot;, locked ? 1 : 0, NULL);
+}
+
+static void
+layout_ui_destroyed (GtkWidget *widget,
+                     gpointer   user_data)
+{
+    GdlDockLayoutUIData *ui_data;
+    
+    /* widget is the GtkContainer */
+    ui_data = g_object_get_data (G_OBJECT (widget), &quot;ui_data&quot;);
+    if (ui_data) {
+        if (ui_data-&gt;layout) {
+            if (ui_data-&gt;layout-&gt;master)
+                /* disconnet the notify handler */
+                g_signal_handlers_disconnect_matched (ui_data-&gt;layout-&gt;master,
+                                                      G_SIGNAL_MATCH_DATA,
+                                                      0, 0, NULL, NULL,
+                                                      ui_data);
+            
+            g_object_remove_weak_pointer (G_OBJECT (ui_data-&gt;layout),
+                                          (gpointer *) &amp;ui_data-&gt;layout);
+            ui_data-&gt;layout = NULL;
+        }
+        g_object_set_data (G_OBJECT (widget), &quot;ui_data&quot;, NULL);
+        g_free (ui_data);
+    }
+}
+
+static void
+master_locked_notify_cb (GdlDockMaster *master,
+                         GParamSpec    *pspec,
+                         gpointer       user_data)
+{
+    GdlDockLayoutUIData *ui_data = (GdlDockLayoutUIData *) user_data;
+    gint locked;
+
+    g_object_get (master, &quot;locked&quot;, &amp;locked, NULL);
+    if (locked == -1) {
+        gtk_toggle_button_set_inconsistent (
+            GTK_TOGGLE_BUTTON (ui_data-&gt;locked_check), TRUE);
+    }
+    else {
+        gtk_toggle_button_set_inconsistent (
+            GTK_TOGGLE_BUTTON (ui_data-&gt;locked_check), FALSE);
+        gtk_toggle_button_set_active (
+            GTK_TOGGLE_BUTTON (ui_data-&gt;locked_check), (locked == 1));
+    }
+}
+
+static GladeXML *
+load_interface (const gchar *top_widget)
+{
+    GladeXML *gui;
+    gchar    *gui_file;
+
+    /* load ui */
+    gui_file = g_build_filename (GDL_GLADEDIR, LAYOUT_GLADE_FILE, NULL);
+    gui = glade_xml_new (gui_file, top_widget, GETTEXT_PACKAGE);
+    g_free (gui_file);
+    if (!gui) {
+        /* FIXME: pop up an error dialog */
+        g_warning (_(&quot;Could not load layout user interface file '%s'&quot;), 
+                   LAYOUT_GLADE_FILE);
+        return NULL;
+    };
+    return gui;
+}
+
+static GtkWidget *
+gdl_dock_layout_construct_items_ui (GdlDockLayout *layout)
+{
+    GladeXML            *gui;
+    GtkWidget           *container;
+    GtkWidget           *items_list;
+    GtkCellRenderer     *renderer;
+    GtkTreeViewColumn   *column;
+
+    GdlDockLayoutUIData *ui_data;
+    
+    /* load the interface if it wasn't provided */
+    gui = load_interface (&quot;items_vbox&quot;);
+    
+    if (!gui)
+        return NULL;
+    
+    /* get the container */
+    container = glade_xml_get_widget (gui, &quot;items_vbox&quot;);
+
+    ui_data = g_new0 (GdlDockLayoutUIData, 1);
+    ui_data-&gt;layout = layout;
+    g_object_add_weak_pointer (G_OBJECT (layout),
+                               (gpointer *) &amp;ui_data-&gt;layout);
+    g_object_set_data (G_OBJECT (container), &quot;ui_data&quot;, ui_data);
+    
+    /* get ui widget references */
+    ui_data-&gt;locked_check = glade_xml_get_widget (gui, &quot;locked_check&quot;);
+    items_list = glade_xml_get_widget (gui, &quot;items_list&quot;);
+
+    /* locked check connections */
+    g_signal_connect (ui_data-&gt;locked_check, &quot;toggled&quot;,
+                      (GCallback) all_locked_toggled_cb, ui_data);
+    if (layout-&gt;master) {
+        g_signal_connect (layout-&gt;master, &quot;notify::locked&quot;,
+                          (GCallback) master_locked_notify_cb, ui_data);
+        /* force update now */
+        master_locked_notify_cb (layout-&gt;master, NULL, ui_data);
+    }
+    
+    /* set models */
+    gtk_tree_view_set_model (GTK_TREE_VIEW (items_list),
+                             GTK_TREE_MODEL (layout-&gt;_priv-&gt;items_model));
+
+    /* construct list views */
+    renderer = gtk_cell_renderer_toggle_new ();
+    g_signal_connect (renderer, &quot;toggled&quot;, 
+                      G_CALLBACK (show_toggled_cb), ui_data);
+    column = gtk_tree_view_column_new_with_attributes (_(&quot;Visible&quot;),
+                                                       renderer,
+                                                       &quot;active&quot;, COLUMN_SHOW,
+                                                       NULL);
+    gtk_tree_view_append_column (GTK_TREE_VIEW (items_list), column);
+
+    renderer = gtk_cell_renderer_text_new ();
+    column = gtk_tree_view_column_new_with_attributes (_(&quot;Item&quot;),
+                                                       renderer,
+                                                       &quot;text&quot;, COLUMN_NAME,
+                                                       NULL);
+    gtk_tree_view_append_column (GTK_TREE_VIEW (items_list), column);
+
+    /* connect signals */
+    g_signal_connect (container, &quot;destroy&quot;, (GCallback) layout_ui_destroyed, NULL);
+
+    g_object_unref (gui);
+
+    return container;
+}
+
+static void
+cell_edited_cb (GtkCellRendererText *cell,
+                const gchar         *path_string,
+                const gchar         *new_text,
+                gpointer             data)
+{
+    GdlDockLayoutUIData *ui_data = data;
+    GtkTreeModel *model;
+    GtkTreePath *path;
+    GtkTreeIter iter;
+    gchar *name;
+    xmlNodePtr node;
+
+    model = GTK_TREE_MODEL (ui_data-&gt;layout-&gt;_priv-&gt;layouts_model);
+    path = gtk_tree_path_new_from_string (path_string);
+
+    gtk_tree_model_get_iter (model, &amp;iter, path);
+    gtk_tree_model_get (model, &amp;iter, COLUMN_NAME, &amp;name, -1);
+
+    node = gdl_dock_layout_find_layout (ui_data-&gt;layout, name);
+    g_free (name);
+    g_return_if_fail (node != NULL);
+
+    xmlSetProp (node, NAME_ATTRIBUTE_NAME, new_text);
+    gtk_list_store_set (GTK_LIST_STORE (model), &amp;iter, COLUMN_NAME, new_text,
+                        COLUMN_EDITABLE, TRUE, -1);
+
+    gdl_dock_layout_save_layout (ui_data-&gt;layout, new_text);
+
+    gtk_tree_path_free (path);
+}
+
+static GtkWidget *
+gdl_dock_layout_construct_layouts_ui (GdlDockLayout *layout)
+{
+    GladeXML            *gui;
+    GtkWidget           *container;
+    GtkWidget           *layouts_list;
+    GtkCellRenderer     *renderer;
+    GtkTreeViewColumn   *column;
+
+    GdlDockLayoutUIData *ui_data;
+    
+    /* load the interface if it wasn't provided */
+    gui = load_interface (&quot;layouts_vbox&quot;);
+    
+    if (!gui)
+        return NULL;
+    
+    /* get the container */
+    container = glade_xml_get_widget (gui, &quot;layouts_vbox&quot;);
+
+    ui_data = g_new0 (GdlDockLayoutUIData, 1);
+    ui_data-&gt;layout = layout;
+    g_object_add_weak_pointer (G_OBJECT (layout),
+                               (gpointer *) &amp;ui_data-&gt;layout);
+    g_object_set_data (G_OBJECT (container), &quot;ui_data&quot;, ui_data);
+    
+    /* get ui widget references */
+    layouts_list = glade_xml_get_widget (gui, &quot;layouts_list&quot;);
+
+    /* set models */
+    gtk_tree_view_set_model (GTK_TREE_VIEW (layouts_list),
+                             GTK_TREE_MODEL (layout-&gt;_priv-&gt;layouts_model));
+
+    /* construct list views */
+    renderer = gtk_cell_renderer_text_new ();
+    g_signal_connect (G_OBJECT (renderer), &quot;edited&quot;,
+                      G_CALLBACK (cell_edited_cb), ui_data);
+    column = gtk_tree_view_column_new_with_attributes (_(&quot;Name&quot;), renderer,
+                                                       &quot;text&quot;, COLUMN_NAME,
+                                                       &quot;editable&quot;, COLUMN_EDITABLE,
+                                                       NULL);
+    gtk_tree_view_append_column (GTK_TREE_VIEW (layouts_list), column);
+
+    ui_data-&gt;selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (layouts_list));
+
+    /* connect signals */
+    glade_xml_signal_connect_data (gui, &quot;on_load_button_clicked&quot;,
+                                   GTK_SIGNAL_FUNC (load_layout_cb), ui_data);
+    glade_xml_signal_connect_data (gui, &quot;on_delete_button_clicked&quot;,
+                                   GTK_SIGNAL_FUNC (delete_layout_cb), ui_data);
+
+    g_signal_connect (container, &quot;destroy&quot;, (GCallback) layout_ui_destroyed, NULL);
+
+    g_object_unref (gui);
+
+    return container;
+}
+
+static GtkWidget *
+gdl_dock_layout_construct_ui (GdlDockLayout *layout)
+{
+    GtkWidget *container, *child;
+    
+    container = gtk_notebook_new ();
+    gtk_widget_show (container);
+    
+    child = gdl_dock_layout_construct_items_ui (layout);
+    if (child)
+        gtk_notebook_append_page (GTK_NOTEBOOK (container),
+                                  child,
+                                  gtk_label_new (_(&quot;Dock items&quot;)));
+    
+    child = gdl_dock_layout_construct_layouts_ui (layout);
+    if (child)
+        gtk_notebook_append_page (GTK_NOTEBOOK (container),
+                                  child,
+                                  gtk_label_new (_(&quot;Saved layouts&quot;)));
+
+    gtk_notebook_set_current_page (GTK_NOTEBOOK (container), 0);
+    
+    return container;
+}
+
+/* ----- Save &amp; Load layout functions --------- */
+
+#define GDL_DOCK_PARAM_CONSTRUCTION(p) \
+    (((p)-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY)) != 0)
+
+static GdlDockObject * 
+gdl_dock_layout_setup_object (GdlDockMaster *master,
+                              xmlNodePtr     node,
+                              gint          *n_after_params,
+                              GParameter   **after_params)
+{
+    GdlDockObject *object = NULL;
+    GType          object_type;
+    xmlChar       *object_name;
+    GObjectClass  *object_class = NULL;
+
+    GParamSpec   **props;
+    gint           n_props, i;
+    GParameter    *params = NULL;
+    gint           n_params = 0;
+    GValue         serialized = { 0, };
+    
+    object_name = xmlGetProp (node, GDL_DOCK_NAME_PROPERTY);
+    if (object_name &amp;&amp; strlen (object_name) &gt; 0) {
+        /* the object must already be bound to the master */
+        object = gdl_dock_master_get_object (master, object_name);
+
+        xmlFree (object_name);
+        object_type = object ? G_TYPE_FROM_INSTANCE (object) : G_TYPE_NONE;
+    }
+    else {
+        /* the object should be automatic, so create it by
+           retrieving the object type from the dock registry */
+        object_type = gdl_dock_object_type_from_nick (node-&gt;name);
+        if (object_type == G_TYPE_NONE) {
+            g_warning (_(&quot;While loading layout: don't know how to create &quot;
+                         &quot;a dock object whose nick is '%s'&quot;), node-&gt;name);
+        }
+    }
+    
+    if (object_type == G_TYPE_NONE || !G_TYPE_IS_CLASSED (object_type))
+        return NULL;
+
+    object_class = g_type_class_ref (object_type);
+    props = g_object_class_list_properties (object_class, &amp;n_props);
+        
+    /* create parameter slots */
+    /* extra parameter is the master */
+    params = g_new0 (GParameter, n_props + 1);
+    *after_params = g_new0 (GParameter, n_props);
+    *n_after_params = 0;
+    
+    /* initialize value used for transformations */
+    g_value_init (&amp;serialized, GDL_TYPE_DOCK_PARAM);
+    
+    for (i = 0; i &lt; n_props; i++) {
+        xmlChar *xml_prop;
+
+        /* process all exported properties, skip
+           GDL_DOCK_NAME_PROPERTY, since named items should
+           already by in the master */
+        if (!(props [i]-&gt;flags &amp; GDL_DOCK_PARAM_EXPORT) ||
+            !strcmp (props [i]-&gt;name, GDL_DOCK_NAME_PROPERTY))
+            continue;
+
+        /* get the property from xml if there is one */
+        xml_prop = xmlGetProp (node, props [i]-&gt;name);
+        if (xml_prop) {
+            g_value_set_static_string (&amp;serialized, xml_prop);
+            
+            if (!GDL_DOCK_PARAM_CONSTRUCTION (props [i]) &amp;&amp;
+                (props [i]-&gt;flags &amp; GDL_DOCK_PARAM_AFTER)) {
+                (*after_params) [*n_after_params].name = props [i]-&gt;name;
+                g_value_init (&amp;((* after_params) [*n_after_params].value),
+                              props [i]-&gt;value_type);
+                g_value_transform (&amp;serialized,
+                                   &amp;((* after_params) [*n_after_params].value));
+                (*n_after_params)++;
+            }
+            else if (!object || (!GDL_DOCK_PARAM_CONSTRUCTION (props [i]) &amp;&amp; object)) {
+                params [n_params].name = props [i]-&gt;name;
+                g_value_init (&amp;(params [n_params].value), props [i]-&gt;value_type);
+                g_value_transform (&amp;serialized, &amp;(params [n_params].value));
+                n_params++;
+            }
+            xmlFree (xml_prop);
+        }
+    }
+    g_value_unset (&amp;serialized);
+    g_free (props);
+
+    if (!object) {
+        params [n_params].name = GDL_DOCK_MASTER_PROPERTY;
+        g_value_init (&amp;params [n_params].value, GDL_TYPE_DOCK_MASTER);
+        g_value_set_object (&amp;params [n_params].value, master);
+        n_params++;
+        
+        /* construct the object if we have to */
+        /* set the master, so toplevels are created correctly and
+           other objects are bound */
+        object = g_object_newv (object_type, n_params, params);
+    }
+    else {
+        /* set the parameters to the existing object */
+        for (i = 0; i &lt; n_params; i++)
+            g_object_set_property (G_OBJECT (object),
+                                   params [i].name,
+                                   &amp;params [i].value);
+    }
+
+    /* free the parameters (names are static/const strings) */
+    for (i = 0; i &lt; n_params; i++)
+        g_value_unset (&amp;params [i].value);
+    g_free (params);
+
+    /* finally unref object class */
+    g_type_class_unref (object_class);
+
+    return object;
+}
+
+static void
+gdl_dock_layout_recursive_build (GdlDockMaster *master,
+                                 xmlNodePtr     parent_node,
+                                 GdlDockObject *parent)
+{
+    GdlDockObject *object;
+    xmlNodePtr     node;
+    
+    g_return_if_fail (master != NULL &amp;&amp; parent_node != NULL);
+
+    /* if parent is NULL we should build toplevels */
+    for (node = parent_node-&gt;children; node; node = node-&gt;next) {
+        GParameter *after_params = NULL;
+        gint        n_after_params = 0, i;
+
+        object = gdl_dock_layout_setup_object (master, node,
+                                               &amp;n_after_params,
+                                               &amp;after_params);
+        
+        if (object) {
+            gdl_dock_object_freeze (object);
+
+            /* recurse here to catch placeholders */
+            gdl_dock_layout_recursive_build (master, node, object);
+            
+            if (GDL_IS_DOCK_PLACEHOLDER (object))
+                /* placeholders are later attached to the parent */
+                gdl_dock_object_detach (object, FALSE);
+            
+            /* apply &quot;after&quot; parameters */
+            for (i = 0; i &lt; n_after_params; i++) {
+                g_object_set_property (G_OBJECT (object),
+                                       after_params [i].name,
+                                       &amp;after_params [i].value);
+                /* unset and free the value */
+                g_value_unset (&amp;after_params [i].value);
+            }
+            g_free (after_params);
+            
+            /* add the object to the parent */
+            if (parent) {
+                if (GDL_IS_DOCK_PLACEHOLDER (object))
+                    gdl_dock_placeholder_attach (GDL_DOCK_PLACEHOLDER (object),
+                                                 parent);
+                else if (gdl_dock_object_is_compound (parent)) {
+                    gtk_container_add (GTK_CONTAINER (parent), GTK_WIDGET (object));
+                    if (GTK_WIDGET_VISIBLE (parent))
+                        gtk_widget_show (GTK_WIDGET (object));
+                }
+            }
+            else {
+                GdlDockObject *controller = gdl_dock_master_get_controller (master);
+                if (controller != object &amp;&amp; GTK_WIDGET_VISIBLE (controller))
+                    gtk_widget_show (GTK_WIDGET (object));
+            }
+                
+            /* call reduce just in case any child is missing */
+            if (gdl_dock_object_is_compound (object))
+                gdl_dock_object_reduce (object);
+
+            gdl_dock_object_thaw (object);
+        }
+    }
+}
+
+static void
+_gdl_dock_layout_foreach_detach (GdlDockObject *object)
+{
+    gdl_dock_object_detach (object, TRUE);
+}
+
+static void
+gdl_dock_layout_foreach_toplevel_detach (GdlDockObject *object)
+{
+    gtk_container_foreach (GTK_CONTAINER (object),
+                           (GtkCallback) _gdl_dock_layout_foreach_detach,
+                           NULL);
+}
+
+static void
+gdl_dock_layout_load (GdlDockMaster *master, xmlNodePtr node)
+{
+    g_return_if_fail (master != NULL &amp;&amp; node != NULL);
+
+    /* start by detaching all items from the toplevels */
+    gdl_dock_master_foreach_toplevel (master, TRUE,
+                                      (GFunc) gdl_dock_layout_foreach_toplevel_detach,
+                                      NULL);
+    
+    gdl_dock_layout_recursive_build (master, node, NULL);
+}
+
+static void 
+gdl_dock_layout_foreach_object_save (GdlDockObject *object,
+                                     gpointer       user_data)
+{
+    struct {
+        xmlNodePtr  where;
+        GHashTable *placeholders;
+    } *info = user_data, info_child;
+
+    xmlNodePtr   node;
+    gint         n_props, i;
+    GParamSpec **props;
+    GValue       attr = { 0, };
+    
+    g_return_if_fail (object != NULL &amp;&amp; GDL_IS_DOCK_OBJECT (object));
+    g_return_if_fail (info-&gt;where != NULL);
+    
+    node = xmlNewChild (info-&gt;where,
+                        NULL,               /* ns */
+                        gdl_dock_object_nick_from_type (G_TYPE_FROM_INSTANCE (object)),
+                        NULL);              /* contents */
+
+    /* get object exported attributes */
+    props = g_object_class_list_properties (G_OBJECT_GET_CLASS (object),
+                                            &amp;n_props);
+    g_value_init (&amp;attr, GDL_TYPE_DOCK_PARAM);
+    for (i = 0; i &lt; n_props; i++) {
+        GParamSpec *p = props [i];
+
+        if (p-&gt;flags &amp; GDL_DOCK_PARAM_EXPORT) {
+            GValue v = { 0, };
+            
+            /* export this parameter */
+            /* get the parameter value */
+            g_value_init (&amp;v, p-&gt;value_type);
+            g_object_get_property (G_OBJECT (object),
+                                   p-&gt;name,
+                                   &amp;v);
+
+            /* only save the object &quot;name&quot; if it is set
+               (i.e. don't save the empty string) */
+            if (strcmp (p-&gt;name, GDL_DOCK_NAME_PROPERTY) ||
+                g_value_get_string (&amp;v)) {
+                if (g_value_transform (&amp;v, &amp;attr))
+                    xmlSetProp (node, p-&gt;name, g_value_get_string (&amp;attr));
+            }
+            
+            /* free the parameter value */
+            g_value_unset (&amp;v);
+        }
+    }
+    g_value_unset (&amp;attr);
+    g_free (props);
+
+    info_child = *info;
+    info_child.where = node;
+
+    /* save placeholders for the object */
+    if (info-&gt;placeholders &amp;&amp; !GDL_IS_DOCK_PLACEHOLDER (object)) {
+        GList *lph = g_hash_table_lookup (info-&gt;placeholders, object);
+        for (; lph; lph = lph-&gt;next)
+            gdl_dock_layout_foreach_object_save (GDL_DOCK_OBJECT (lph-&gt;data),
+                                                 (gpointer) &amp;info_child);
+    }
+    
+    /* recurse the object if appropiate */
+    if (gdl_dock_object_is_compound (object)) {
+        gtk_container_foreach (GTK_CONTAINER (object),
+                               (GtkCallback) gdl_dock_layout_foreach_object_save,
+                               (gpointer) &amp;info_child);
+    }
+}
+
+static void
+add_placeholder (GdlDockObject *object,
+                 GHashTable    *placeholders)
+{
+    if (GDL_IS_DOCK_PLACEHOLDER (object)) {
+        GdlDockObject *host;
+        GList *l;
+        
+        g_object_get (object, &quot;host&quot;, &amp;host, NULL);
+        if (host) {
+            l = g_hash_table_lookup (placeholders, host);
+            /* add the current placeholder to the list of placeholders
+               for that host */
+            if (l)
+                g_hash_table_steal (placeholders, host);
+            
+            l = g_list_prepend (l, object);
+            g_hash_table_insert (placeholders, host, l);
+            g_object_unref (host);
+        }
+    }
+}
+
+static void 
+gdl_dock_layout_save (GdlDockMaster *master,
+                      xmlNodePtr     where)
+{
+    struct {
+        xmlNodePtr  where;
+        GHashTable *placeholders;
+    } info;
+    
+    GHashTable *placeholders;
+    
+    g_return_if_fail (master != NULL &amp;&amp; where != NULL);
+
+    /* build the placeholder's hash: the hash keeps lists of
+     * placeholders associated to each object, so that we can save the
+     * placeholders when we are saving the object (since placeholders
+     * don't show up in the normal widget hierarchy) */
+    placeholders = g_hash_table_new_full (g_direct_hash, g_direct_equal,
+                                          NULL, (GDestroyNotify) g_list_free);
+    gdl_dock_master_foreach (master, (GFunc) add_placeholder, placeholders);
+    
+    /* save the layout recursively */
+    info.where = where;
+    info.placeholders = placeholders;
+    
+    gdl_dock_master_foreach_toplevel (master, TRUE,
+                                      (GFunc) gdl_dock_layout_foreach_object_save,
+                                      (gpointer) &amp;info);
+
+    g_hash_table_destroy (placeholders);
+}
+
+
+/* ----- Public interface ----- */
+
+GdlDockLayout *
+gdl_dock_layout_new (GdlDock *dock)
+{
+    GdlDockMaster *master = NULL;
+    
+    /* get the master of the given dock */
+    if (dock)
+        master = GDL_DOCK_OBJECT_GET_MASTER (dock);
+    
+    return g_object_new (GDL_TYPE_DOCK_LAYOUT,
+                         &quot;master&quot;, master,
+                         NULL);
+}
+
+static gboolean
+gdl_dock_layout_idle_save (GdlDockLayout *layout)
+{
+    /* save default layout */
+    gdl_dock_layout_save_layout (layout, NULL);
+    
+    layout-&gt;_priv-&gt;idle_save_pending = FALSE;
+    
+    return FALSE;
+}
+
+static void
+gdl_dock_layout_layout_changed_cb (GdlDockMaster *master,
+                                   GdlDockLayout *layout)
+{
+    /* update model */
+    update_items_model (layout);
+
+    if (!layout-&gt;_priv-&gt;idle_save_pending) {
+        g_idle_add ((GSourceFunc) gdl_dock_layout_idle_save, layout);
+        layout-&gt;_priv-&gt;idle_save_pending = TRUE;
+    }
+}
+
+void
+gdl_dock_layout_attach (GdlDockLayout *layout,
+                        GdlDockMaster *master)
+{
+    g_return_if_fail (layout != NULL);
+    g_return_if_fail (master == NULL || GDL_IS_DOCK_MASTER (master));
+    
+    if (layout-&gt;master) {
+        g_signal_handlers_disconnect_matched (layout-&gt;master, G_SIGNAL_MATCH_DATA,
+                                              0, 0, NULL, NULL, layout);
+        g_object_unref (layout-&gt;master);
+    }
+    
+    gtk_list_store_clear (layout-&gt;_priv-&gt;items_model);
+    
+    layout-&gt;master = master;
+    if (layout-&gt;master) {
+        g_object_ref (layout-&gt;master);
+        g_signal_connect (layout-&gt;master, &quot;layout_changed&quot;,
+                          (GCallback) gdl_dock_layout_layout_changed_cb,
+                          layout);
+    }
+
+    update_items_model (layout);
+}
+
+gboolean
+gdl_dock_layout_load_layout (GdlDockLayout *layout,
+                             const gchar   *name)
+{
+    xmlNodePtr  node;
+    gchar      *layout_name;
+
+    g_return_val_if_fail (layout != NULL, FALSE);
+    
+    if (!layout-&gt;_priv-&gt;doc || !layout-&gt;master)
+        return FALSE;
+
+    if (!name)
+        layout_name = DEFAULT_LAYOUT;
+    else
+        layout_name = (gchar *) name;
+
+    node = gdl_dock_layout_find_layout (layout, layout_name);
+    if (!node &amp;&amp; !name)
+        /* return the first layout if the default name failed to load */
+        node = gdl_dock_layout_find_layout (layout, NULL);
+
+    if (node) {
+        gdl_dock_layout_load (layout-&gt;master, node);
+        return TRUE;
+    } else
+        return FALSE;
+}
+
+void
+gdl_dock_layout_save_layout (GdlDockLayout *layout,
+                             const gchar   *name)
+{
+    xmlNodePtr  node;
+    gchar      *layout_name;
+
+    g_return_if_fail (layout != NULL);
+    g_return_if_fail (layout-&gt;master != NULL);
+    
+    if (!layout-&gt;_priv-&gt;doc)
+        gdl_dock_layout_build_doc (layout);
+
+    if (!name)
+        layout_name = DEFAULT_LAYOUT;
+    else
+        layout_name = (gchar *) name;
+
+    /* delete any previously node with the same name */
+    node = gdl_dock_layout_find_layout (layout, layout_name);
+    if (node) {
+        xmlUnlinkNode (node);
+        xmlFreeNode (node);
+    };
+
+    /* create the new node */
+    node = xmlNewChild (layout-&gt;_priv-&gt;doc-&gt;children, NULL, 
+                        LAYOUT_ELEMENT_NAME, NULL);
+    xmlSetProp (node, NAME_ATTRIBUTE_NAME, layout_name);
+
+    /* save the layout */
+    gdl_dock_layout_save (layout-&gt;master, node);
+    layout-&gt;dirty = TRUE;
+    g_object_notify (G_OBJECT (layout), &quot;dirty&quot;);
+}
+
+void
+gdl_dock_layout_delete_layout (GdlDockLayout *layout,
+                               const gchar   *name)
+{
+    xmlNodePtr node;
+
+    g_return_if_fail (layout != NULL);
+
+    /* don't allow the deletion of the default layout */
+    if (!name || !strcmp (DEFAULT_LAYOUT, name))
+        return;
+    
+    node = gdl_dock_layout_find_layout (layout, name);
+    if (node) {
+        xmlUnlinkNode (node);
+        xmlFreeNode (node);
+        layout-&gt;dirty = TRUE;
+        g_object_notify (G_OBJECT (layout), &quot;dirty&quot;);
+    }
+}
+
+void
+gdl_dock_layout_run_manager (GdlDockLayout *layout)
+{
+    GtkWidget *dialog, *container;
+    GtkWidget *parent = NULL;
+    
+    g_return_if_fail (layout != NULL);
+
+    if (!layout-&gt;master)
+        /* not attached to a dock yet */
+        return;
+
+    container = gdl_dock_layout_construct_ui (layout);
+    if (!container)
+        return;
+
+    parent = GTK_WIDGET (gdl_dock_master_get_controller (layout-&gt;master));
+    if (parent)
+        parent = gtk_widget_get_toplevel (parent);
+    
+    dialog = gtk_dialog_new_with_buttons (_(&quot;Layout managment&quot;),
+                                          parent ? GTK_WINDOW (parent) : NULL,
+                                          GTK_DIALOG_MODAL | GTK_DIALOG_NO_SEPARATOR,
+                                          GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE,
+                                          NULL);
+
+    gtk_window_set_default_size (GTK_WINDOW (dialog), -1, 300);
+    gtk_container_add (GTK_CONTAINER (GTK_DIALOG (dialog)-&gt;vbox), container);
+    
+    gtk_dialog_run (GTK_DIALOG (dialog));
+
+    gtk_widget_destroy (dialog);
+}
+
+gboolean
+gdl_dock_layout_load_from_file (GdlDockLayout *layout,
+                                const gchar   *filename)
+{
+    gboolean retval = FALSE;
+
+    if (layout-&gt;_priv-&gt;doc) {
+        xmlFreeDoc (layout-&gt;_priv-&gt;doc);
+        layout-&gt;_priv-&gt;doc = NULL;
+        layout-&gt;dirty = FALSE;
+        g_object_notify (G_OBJECT (layout), &quot;dirty&quot;);
+    }
+
+    /* FIXME: cannot open symlinks */
+    if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
+        layout-&gt;_priv-&gt;doc = xmlParseFile (filename);
+        if (layout-&gt;_priv-&gt;doc) {
+            xmlNodePtr root = layout-&gt;_priv-&gt;doc-&gt;children;
+            /* minimum validation: test the root element */
+            if (root &amp;&amp; !strcmp (root-&gt;name, ROOT_ELEMENT)) {
+                update_layouts_model (layout);
+                retval = TRUE;
+            } else {
+                xmlFreeDoc (layout-&gt;_priv-&gt;doc);
+                layout-&gt;_priv-&gt;doc = NULL;
+            }		
+        }
+    }
+
+    return retval;
+}
+
+gboolean
+gdl_dock_layout_save_to_file (GdlDockLayout *layout,
+                              const gchar   *filename)
+{
+    FILE     *file_handle;
+    int       bytes;
+    gboolean  retval = FALSE;
+
+    g_return_val_if_fail (layout != NULL, FALSE);
+    g_return_val_if_fail (filename != NULL, FALSE);
+
+    /* if there is still no xml doc, create an empty one */
+    if (!layout-&gt;_priv-&gt;doc)
+        gdl_dock_layout_build_doc (layout);
+
+    file_handle = fopen (filename, &quot;w&quot;);
+    if (file_handle) {
+        bytes = xmlDocDump (file_handle, layout-&gt;_priv-&gt;doc);
+        if (bytes &gt;= 0) {
+            layout-&gt;dirty = FALSE;
+            g_object_notify (G_OBJECT (layout), &quot;dirty&quot;);
+            retval = TRUE;
+        };
+        fclose (file_handle);
+    };
+
+    return retval;
+}
+
+gboolean
+gdl_dock_layout_is_dirty (GdlDockLayout *layout)
+{
+    g_return_val_if_fail (layout != NULL, FALSE);
+
+    return layout-&gt;dirty;
+};
+
+GList *
+gdl_dock_layout_get_layouts (GdlDockLayout *layout,
+                             gboolean       include_default)
+{
+    GList      *retval = NULL;
+    xmlNodePtr  node;
+
+    g_return_val_if_fail (layout != NULL, NULL);
+
+    if (!layout-&gt;_priv-&gt;doc)
+        return NULL;
+
+    node = layout-&gt;_priv-&gt;doc-&gt;children;
+    for (node = node-&gt;children; node; node = node-&gt;next) {
+        gchar *name;
+
+        if (strcmp (node-&gt;name, LAYOUT_ELEMENT_NAME))
+            continue;
+
+        name = xmlGetProp (node, NAME_ATTRIBUTE_NAME);
+        if (include_default || strcmp (name, DEFAULT_LAYOUT))
+            retval = g_list_prepend (retval, g_strdup (name));
+        xmlFree (name);
+    };
+    retval = g_list_reverse (retval);
+
+    return retval;
+}
+
+GtkWidget *
+gdl_dock_layout_get_ui (GdlDockLayout *layout)
+{
+    GtkWidget *ui;
+
+    g_return_val_if_fail (layout != NULL, NULL);
+    ui = gdl_dock_layout_construct_ui (layout);
+
+    return ui;
+}
+
+GtkWidget *
+gdl_dock_layout_get_items_ui (GdlDockLayout *layout)
+{
+    GtkWidget *ui;
+
+    g_return_val_if_fail (layout != NULL, NULL);
+    ui = gdl_dock_layout_construct_items_ui (layout);
+
+    return ui;
+}
+
+GtkWidget *
+gdl_dock_layout_get_layouts_ui (GdlDockLayout *layout)
+{
+    GtkWidget *ui;
+
+    g_return_val_if_fail (layout != NULL, NULL);
+    ui = gdl_dock_layout_construct_layouts_ui (layout);
+
+    return ui;
+}

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,99 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+
+#ifndef __GDL_DOCK_LAYOUT_H__
+#define __GDL_DOCK_LAYOUT_H__
+
+#include &lt;glib-object.h&gt;
+#include &lt;gdl/gdl-dock-master.h&gt;
+#include &lt;gdl/gdl-dock.h&gt;
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define	GDL_TYPE_DOCK_LAYOUT		  (gdl_dock_layout_get_type ())
+#define GDL_DOCK_LAYOUT(object)		  (GTK_CHECK_CAST ((object), GDL_TYPE_DOCK_LAYOUT, GdlDockLayout))
+#define GDL_DOCK_LAYOUT_CLASS(klass)	  (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_LAYOUT, GdlDockLayoutClass))
+#define GDL_IS_DOCK_LAYOUT(object)	  (GTK_CHECK_TYPE ((object), GDL_TYPE_DOCK_LAYOUT))
+#define GDL_IS_DOCK_LAYOUT_CLASS(klass)	  (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_LAYOUT))
+#define	GDL_DOCK_LAYOUT_GET_CLASS(object) (GTK_CHECK_GET_CLASS ((object), GDL_TYPE_DOCK_LAYOUT, GdlDockLayoutClass))
+
+/* data types &amp; structures */
+typedef struct _GdlDockLayout GdlDockLayout;
+typedef struct _GdlDockLayoutClass GdlDockLayoutClass;
+typedef struct _GdlDockLayoutPrivate GdlDockLayoutPrivate;
+
+struct _GdlDockLayout {
+    GObject               g_object;
+
+    gboolean              dirty;
+    GdlDockMaster        *master;
+
+    GdlDockLayoutPrivate *_priv;
+};
+
+struct _GdlDockLayoutClass {
+    GObjectClass  g_object_class;
+};
+
+
+/* public interface */
+ 
+GType            gdl_dock_layout_get_type       (void);
+
+GdlDockLayout   *gdl_dock_layout_new            (GdlDock       *dock);
+
+void             gdl_dock_layout_attach         (GdlDockLayout *layout,
+                                                 GdlDockMaster *master);
+
+gboolean         gdl_dock_layout_load_layout    (GdlDockLayout *layout,
+                                                 const gchar   *name);
+
+void             gdl_dock_layout_save_layout    (GdlDockLayout *layout,
+                                                 const gchar   *name);
+
+void             gdl_dock_layout_delete_layout  (GdlDockLayout *layout,
+                                                 const gchar   *name);
+
+GList           *gdl_dock_layout_get_layouts    (GdlDockLayout *layout,
+                                                 gboolean       include_default);
+
+void             gdl_dock_layout_run_manager    (GdlDockLayout *layout);
+
+gboolean         gdl_dock_layout_load_from_file (GdlDockLayout *layout,
+                                                 const gchar   *filename);
+
+gboolean         gdl_dock_layout_save_to_file   (GdlDockLayout *layout,
+                                                 const gchar   *filename);
+
+gboolean         gdl_dock_layout_is_dirty       (GdlDockLayout *layout);
+
+GtkWidget       *gdl_dock_layout_get_ui         (GdlDockLayout *layout);
+GtkWidget       *gdl_dock_layout_get_items_ui   (GdlDockLayout *layout);
+GtkWidget       *gdl_dock_layout_get_layouts_ui (GdlDockLayout *layout);
+
+G_END_DECLS
+
+#endif
+
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-master.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-master.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-master.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,908 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * gdl-dock-master.c - Object which manages a dock ring
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;libgnome/gnome-macros.h&gt;
+#include &lt;gdk/gdkx.h&gt;
+
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock-master.h&quot;
+#include &quot;gdl-dock.h&quot;
+#include &quot;gdl-dock-item.h&quot;
+#include &quot;libgdlmarshal.h&quot;
+
+
+/* ----- Private prototypes ----- */
+
+static void     gdl_dock_master_class_init    (GdlDockMasterClass *klass);
+static void     gdl_dock_master_instance_init (GdlDockMaster      *master);
+
+static void     gdl_dock_master_dispose       (GObject            *g_object);
+static void     gdl_dock_master_set_property  (GObject            *object,
+                                               guint               prop_id,
+                                               const GValue       *value,
+                                               GParamSpec         *pspec);
+static void     gdl_dock_master_get_property  (GObject            *object,
+                                               guint               prop_id,
+                                               GValue             *value,
+                                               GParamSpec         *pspec);
+
+static void     _gdl_dock_master_remove       (GdlDockObject      *object,
+                                               GdlDockMaster      *master);
+
+static void     gdl_dock_master_drag_begin    (GdlDockItem        *item, 
+                                               gpointer            data);
+static void     gdl_dock_master_drag_end      (GdlDockItem        *item,
+                                               gboolean            cancelled,
+                                               gpointer            data);
+static void     gdl_dock_master_drag_motion   (GdlDockItem        *item, 
+                                               gint                x, 
+                                               gint                y,
+                                               gpointer            data);
+
+static void     _gdl_dock_master_foreach      (gpointer            key,
+                                               gpointer            value,
+                                               gpointer            user_data);
+
+static void     gdl_dock_master_xor_rect      (GdlDockMaster      *master);
+
+static void     gdl_dock_master_layout_changed (GdlDockMaster     *master);
+
+/* ----- Private data types and variables ----- */
+
+enum {
+    PROP_0,
+    PROP_DEFAULT_TITLE,
+    PROP_LOCKED
+};
+
+enum {
+    LAYOUT_CHANGED,
+    LAST_SIGNAL
+};
+
+struct _GdlDockMasterPrivate {
+    gint            number;             /* for naming nameless manual objects */
+    gchar          *default_title;
+    
+    GdkGC          *root_xor_gc;
+    gboolean        rect_drawn;
+    GdlDock        *rect_owner;
+    
+    GdlDockRequest *drag_request;
+
+    /* source id for the idle handler to emit a layout_changed signal */
+    guint           idle_layout_changed_id;
+
+    /* hashes to quickly calculate the overall locked status: i.e.
+     * if size(unlocked_items) == 0 then locked = 1
+     * else if size(locked_items) == 0 then locked = 0
+     * else locked = -1
+     */
+    GHashTable     *locked_items;
+    GHashTable     *unlocked_items;
+};
+
+#define COMPUTE_LOCKED(master)                                          \
+    (g_hash_table_size ((master)-&gt;_priv-&gt;unlocked_items) == 0 ? 1 :     \
+     (g_hash_table_size ((master)-&gt;_priv-&gt;locked_items) == 0 ? 0 : -1))
+
+static guint master_signals [LAST_SIGNAL] = { 0 };
+
+
+/* ----- Private interface ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDockMaster, gdl_dock_master, GObject, G_TYPE_OBJECT);
+
+static void
+gdl_dock_master_class_init (GdlDockMasterClass *klass)
+{
+    GObjectClass      *g_object_class;
+
+    g_object_class = G_OBJECT_CLASS (klass);
+
+    g_object_class-&gt;dispose = gdl_dock_master_dispose;
+    g_object_class-&gt;set_property = gdl_dock_master_set_property;
+    g_object_class-&gt;get_property = gdl_dock_master_get_property;
+
+    g_object_class_install_property (
+        g_object_class, PROP_DEFAULT_TITLE,
+        g_param_spec_string (&quot;default_title&quot;, _(&quot;Default title&quot;),
+                             _(&quot;Default title for newly created floating docks&quot;),
+                             NULL,
+                             G_PARAM_READWRITE));
+    
+    g_object_class_install_property (
+        g_object_class, PROP_LOCKED,
+        g_param_spec_int (&quot;locked&quot;, _(&quot;Locked&quot;),
+                          _(&quot;If is set to 1, all the dock items bound to the master &quot;
+                            &quot;are locked; if it's 0, all are unlocked; -1 indicates &quot;
+                            &quot;inconsistency among the items&quot;),
+                          -1, 1, 0,
+                          G_PARAM_READWRITE));
+
+    master_signals [LAYOUT_CHANGED] = 
+        g_signal_new (&quot;layout_changed&quot;, 
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_LAST,
+                      G_STRUCT_OFFSET (GdlDockMasterClass, layout_changed),
+                      NULL, /* accumulator */
+                      NULL, /* accu_data */
+                      gdl_marshal_VOID__VOID,
+                      G_TYPE_NONE, /* return type */
+                      0);
+
+    klass-&gt;layout_changed = gdl_dock_master_layout_changed;
+}
+
+static void
+gdl_dock_master_instance_init (GdlDockMaster *master)
+{
+    master-&gt;dock_objects = g_hash_table_new_full (g_str_hash, g_str_equal,
+                                                  g_free, NULL);
+    master-&gt;toplevel_docks = NULL;
+    master-&gt;controller = NULL;
+    master-&gt;dock_number = 1;
+    
+    master-&gt;_priv = g_new0 (GdlDockMasterPrivate, 1);
+    master-&gt;_priv-&gt;number = 1;
+
+    master-&gt;_priv-&gt;locked_items = g_hash_table_new (g_direct_hash, g_direct_equal);
+    master-&gt;_priv-&gt;unlocked_items = g_hash_table_new (g_direct_hash, g_direct_equal);
+}
+
+static void
+_gdl_dock_master_remove (GdlDockObject *object,
+                         GdlDockMaster *master)
+{
+    g_return_if_fail (master != NULL &amp;&amp; object != NULL);
+
+    if (GDL_IS_DOCK (object)) {
+        GList *found_link;
+
+        found_link = g_list_find (master-&gt;toplevel_docks, object);
+        if (found_link)
+            master-&gt;toplevel_docks = g_list_delete_link (master-&gt;toplevel_docks,
+                                                         found_link);
+        if (object == master-&gt;controller) {
+            GList *last;
+            GdlDockObject *new_controller = NULL;
+            
+            /* now find some other non-automatic toplevel to use as a
+               new controller.  start from the last dock, since it's
+               probably a non-floating and manual */
+            last = g_list_last (master-&gt;toplevel_docks);
+            while (last) {
+                if (!GDL_DOCK_OBJECT_AUTOMATIC (last-&gt;data)) {
+                    new_controller = GDL_DOCK_OBJECT (last-&gt;data);
+                    break;
+                }
+                last = last-&gt;prev;
+            };
+
+            if (new_controller) {
+                /* the new controller gets the ref (implicitly of course) */
+                master-&gt;controller = new_controller;
+            } else {
+                master-&gt;controller = NULL;
+                /* no controller, no master */
+                g_object_unref (master);
+            }
+        }
+    }
+    /* disconnect dock object signals */
+    g_signal_handlers_disconnect_matched (object, G_SIGNAL_MATCH_DATA, 
+                                          0, 0, NULL, NULL, master);
+
+    /* unref the object from the hash if it's there */
+    if (object-&gt;name) {
+        GdlDockObject *found_object;
+        found_object = g_hash_table_lookup (master-&gt;dock_objects, object-&gt;name);
+        if (found_object == object) {
+            g_hash_table_remove (master-&gt;dock_objects, object-&gt;name);
+            g_object_unref (object);
+        }
+    }
+}
+
+static void
+ht_foreach_build_slist (gpointer  key,
+                        gpointer  value,
+                        GSList  **slist)
+{
+    *slist = g_slist_prepend (*slist, value);
+}
+
+static void
+gdl_dock_master_dispose (GObject *g_object)
+{
+    GdlDockMaster *master;
+    
+    g_return_if_fail (GDL_IS_DOCK_MASTER (g_object));
+
+    master = GDL_DOCK_MASTER (g_object);
+
+    if (master-&gt;toplevel_docks) {
+        g_list_foreach (master-&gt;toplevel_docks,
+                        (GFunc) gdl_dock_object_unbind, NULL);
+        g_list_free (master-&gt;toplevel_docks);
+        master-&gt;toplevel_docks = NULL;
+    }
+    
+    if (master-&gt;dock_objects) {
+        GSList *alive_docks = NULL;
+        g_hash_table_foreach (master-&gt;dock_objects,
+                              (GHFunc) ht_foreach_build_slist, &amp;alive_docks);
+        while (alive_docks) {
+            gdl_dock_object_unbind (GDL_DOCK_OBJECT (alive_docks-&gt;data));
+            alive_docks = g_slist_delete_link (alive_docks, alive_docks);
+        }
+        
+        g_hash_table_destroy (master-&gt;dock_objects);
+        master-&gt;dock_objects = NULL;
+    }
+    
+    if (master-&gt;_priv) {
+        if (master-&gt;_priv-&gt;idle_layout_changed_id)
+            g_source_remove (master-&gt;_priv-&gt;idle_layout_changed_id);
+        
+        if (master-&gt;_priv-&gt;root_xor_gc) {
+            g_object_unref (master-&gt;_priv-&gt;root_xor_gc);
+            master-&gt;_priv-&gt;root_xor_gc = NULL;
+        }
+        if (master-&gt;_priv-&gt;drag_request) {
+            if (G_IS_VALUE (&amp;master-&gt;_priv-&gt;drag_request-&gt;extra))
+                g_value_unset (&amp;master-&gt;_priv-&gt;drag_request-&gt;extra);
+            g_free (master-&gt;_priv-&gt;drag_request);
+            master-&gt;_priv-&gt;drag_request = NULL;
+        }
+        g_free (master-&gt;_priv-&gt;default_title);
+        master-&gt;_priv-&gt;default_title = NULL;
+
+        g_hash_table_destroy (master-&gt;_priv-&gt;locked_items);
+        master-&gt;_priv-&gt;locked_items = NULL;
+        g_hash_table_destroy (master-&gt;_priv-&gt;unlocked_items);
+        master-&gt;_priv-&gt;unlocked_items = NULL;
+        
+        g_free (master-&gt;_priv);
+        master-&gt;_priv = NULL;
+    }
+
+    GNOME_CALL_PARENT (G_OBJECT_CLASS, dispose, (g_object));
+}
+
+static void 
+foreach_lock_unlock (GdlDockItem *item,
+                     gboolean     locked)
+{
+    if (!GDL_IS_DOCK_ITEM (item))
+        return;
+    
+    g_object_set (item, &quot;locked&quot;, locked, NULL);
+    if (gdl_dock_object_is_compound (GDL_DOCK_OBJECT (item)))
+        gtk_container_foreach (GTK_CONTAINER (item),
+                               (GtkCallback) foreach_lock_unlock,
+                               (gpointer) locked);
+}
+
+static void
+gdl_dock_master_lock_unlock (GdlDockMaster *master,
+                             gboolean       locked)
+{
+    GList *l;
+    
+    for (l = master-&gt;toplevel_docks; l; l = l-&gt;next) {
+        GdlDock *dock = GDL_DOCK (l-&gt;data);
+        if (dock-&gt;root)
+            foreach_lock_unlock (GDL_DOCK_ITEM (dock-&gt;root), locked);
+    }
+
+    /* just to be sure hidden items are set too */
+    gdl_dock_master_foreach (master,
+                             (GFunc) foreach_lock_unlock,
+                             (gpointer) locked);
+}
+
+static void
+gdl_dock_master_set_property  (GObject      *object,
+                               guint         prop_id,
+                               const GValue *value,
+                               GParamSpec   *pspec)
+{
+    GdlDockMaster *master = GDL_DOCK_MASTER (object);
+
+    switch (prop_id) {
+        case PROP_DEFAULT_TITLE:
+            g_free (master-&gt;_priv-&gt;default_title);
+            master-&gt;_priv-&gt;default_title = g_value_dup_string (value);
+            break;
+        case PROP_LOCKED:
+            if (g_value_get_int (value) &gt;= 0)
+                gdl_dock_master_lock_unlock (master, (g_value_get_int (value) &gt; 0));
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_master_get_property  (GObject      *object,
+                               guint         prop_id,
+                               GValue       *value,
+                               GParamSpec   *pspec)
+{
+    GdlDockMaster *master = GDL_DOCK_MASTER (object);
+
+    switch (prop_id) {
+        case PROP_DEFAULT_TITLE:
+            g_value_set_string (value, master-&gt;_priv-&gt;default_title);
+            break;
+        case PROP_LOCKED:
+            g_value_set_int (value, COMPUTE_LOCKED (master));
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_master_drag_begin (GdlDockItem *item,
+                            gpointer     data)
+{
+    GdlDockMaster  *master;
+    GdlDockRequest *request;
+    
+    g_return_if_fail (data != NULL);
+    g_return_if_fail (item != NULL);
+
+    master = GDL_DOCK_MASTER (data);
+
+    if (!master-&gt;_priv-&gt;drag_request)
+        master-&gt;_priv-&gt;drag_request = g_new0 (GdlDockRequest, 1);
+
+    request = master-&gt;_priv-&gt;drag_request;
+    
+    /* Set the target to itself so it won't go floating with just a click. */
+    request-&gt;applicant = GDL_DOCK_OBJECT (item);
+    request-&gt;target = GDL_DOCK_OBJECT (item);
+    request-&gt;position = GDL_DOCK_FLOATING;
+    if (G_IS_VALUE (&amp;request-&gt;extra))
+        g_value_unset (&amp;request-&gt;extra);
+
+    master-&gt;_priv-&gt;rect_drawn = FALSE;
+    master-&gt;_priv-&gt;rect_owner = NULL;
+}
+
+static void
+gdl_dock_master_drag_end (GdlDockItem *item, 
+                          gboolean     cancelled,
+                          gpointer     data)
+{
+    GdlDockMaster  *master;
+    GdlDockRequest *request;
+    
+    g_return_if_fail (data != NULL);
+    g_return_if_fail (item != NULL);
+
+    master = GDL_DOCK_MASTER (data);
+    request = master-&gt;_priv-&gt;drag_request;
+    
+    g_return_if_fail (GDL_DOCK_OBJECT (item) == request-&gt;applicant);
+    
+    /* Erase previously drawn rectangle */
+    if (master-&gt;_priv-&gt;rect_drawn)
+        gdl_dock_master_xor_rect (master);
+    
+    /* cancel conditions */
+    if (cancelled || request-&gt;applicant == request-&gt;target)
+        return;
+    
+    /* dock object to the requested position */
+    gdl_dock_object_dock (request-&gt;target,
+                          request-&gt;applicant,
+                          request-&gt;position,
+                          &amp;request-&gt;extra);
+    
+    g_signal_emit (master, master_signals [LAYOUT_CHANGED], 0);
+}
+
+static void
+gdl_dock_master_drag_motion (GdlDockItem *item, 
+                             gint         root_x, 
+                             gint         root_y,
+                             gpointer     data)
+{
+    GdlDockMaster  *master;
+    GdlDockRequest  my_request, *request;
+    GdkWindow      *window;
+    gint            win_x, win_y;
+    gint            x, y;
+    GdlDock        *dock = NULL;
+    gboolean        may_dock = FALSE;
+    
+    g_return_if_fail (item != NULL &amp;&amp; data != NULL);
+
+    master = GDL_DOCK_MASTER (data);
+    request = master-&gt;_priv-&gt;drag_request;
+
+    g_return_if_fail (GDL_DOCK_OBJECT (item) == request-&gt;applicant);
+    
+    my_request = *request;
+
+    /* first look under the pointer */
+    window = gdk_window_at_pointer (&amp;win_x, &amp;win_y);
+    if (window) {
+        GtkWidget *widget;
+        /* ok, now get the widget who owns that window and see if we can
+           get to a GdlDock by walking up the hierarchy */
+        gdk_window_get_user_data (window, (gpointer) &amp;widget);
+        if (GTK_IS_WIDGET (widget)) {
+            while (widget &amp;&amp; !GDL_IS_DOCK (widget))
+                widget = widget-&gt;parent;
+            if (widget) {
+                gint win_w, win_h;
+                
+                /* verify that the pointer is still in that dock
+                   (the user could have moved it) */
+                gdk_window_get_geometry (widget-&gt;window,
+                                         NULL, NULL, &amp;win_w, &amp;win_h, NULL);
+                gdk_window_get_origin (widget-&gt;window, &amp;win_x, &amp;win_y);
+                if (root_x &gt;= win_x &amp;&amp; root_x &lt; win_x + win_w &amp;&amp;
+                    root_y &gt;= win_y &amp;&amp; root_y &lt; win_y + win_h)
+                    dock = GDL_DOCK (widget);
+            }
+        }
+    }
+
+    if (dock) {
+        /* translate root coordinates into dock object coordinates
+           (i.e. widget coordinates) */
+        gdk_window_get_origin (GTK_WIDGET (dock)-&gt;window, &amp;win_x, &amp;win_y);
+        x = root_x - win_x;
+        y = root_y - win_y;
+        may_dock = gdl_dock_object_dock_request (GDL_DOCK_OBJECT (dock),
+                                                 x, y, &amp;my_request);
+    }
+    else {
+        GList *l;
+        
+        /* try to dock the item in all the docks in the ring in turn */
+        for (l = master-&gt;toplevel_docks; l; l = l-&gt;next) {
+            dock = GDL_DOCK (l-&gt;data);
+            /* translate root coordinates into dock object coordinates
+               (i.e. widget coordinates) */
+            gdk_window_get_origin (GTK_WIDGET (dock)-&gt;window, &amp;win_x, &amp;win_y);
+            x = root_x - win_x;
+            y = root_y - win_y;
+            may_dock = gdl_dock_object_dock_request (GDL_DOCK_OBJECT (dock),
+                                                     x, y, &amp;my_request);
+            if (may_dock)
+                break;
+        }
+    }
+    
+    if (!may_dock) {
+        GtkRequisition req;
+        
+        dock = NULL;
+        my_request.target = GDL_DOCK_OBJECT (
+            gdl_dock_object_get_toplevel (request-&gt;applicant));
+        my_request.position = GDL_DOCK_FLOATING;
+
+        gdl_dock_item_preferred_size (GDL_DOCK_ITEM (request-&gt;applicant), &amp;req);
+        my_request.rect.width = req.width;
+        my_request.rect.height = req.height;
+
+        my_request.rect.x = root_x - GDL_DOCK_ITEM (request-&gt;applicant)-&gt;dragoff_x;
+        my_request.rect.y = root_y - GDL_DOCK_ITEM (request-&gt;applicant)-&gt;dragoff_y;
+
+        /* setup extra docking information */
+        if (G_IS_VALUE (&amp;my_request.extra))
+            g_value_unset (&amp;my_request.extra);
+
+        g_value_init (&amp;my_request.extra, GDK_TYPE_RECTANGLE);
+        g_value_set_boxed (&amp;my_request.extra, &amp;my_request.rect);
+    };
+
+    if (!(my_request.rect.x == request-&gt;rect.x &amp;&amp;
+          my_request.rect.y == request-&gt;rect.y &amp;&amp;
+          my_request.rect.width == request-&gt;rect.width &amp;&amp;
+          my_request.rect.height == request-&gt;rect.height &amp;&amp;
+          dock == master-&gt;_priv-&gt;rect_owner)) {
+
+        /* erase the previous rectangle */
+        if (master-&gt;_priv-&gt;rect_drawn)
+            gdl_dock_master_xor_rect (master);
+    }
+
+    /* set the new values */
+    *request = my_request;
+    master-&gt;_priv-&gt;rect_owner = dock;
+    
+    /* draw the previous rectangle */
+    if (~master-&gt;_priv-&gt;rect_drawn)
+        gdl_dock_master_xor_rect (master);
+}
+
+static void
+_gdl_dock_master_foreach (gpointer key,
+                          gpointer value,
+                          gpointer user_data)
+{
+    struct {
+        GFunc    function;
+        gpointer user_data;
+    } *data = user_data;
+
+    (* data-&gt;function) (GTK_WIDGET (value), data-&gt;user_data);
+}
+
+static void
+gdl_dock_master_xor_rect (GdlDockMaster *master)
+{
+    gint8         dash_list [2];
+    GdkWindow    *window;
+    GdkRectangle *rect;
+    
+    if (!master-&gt;_priv || !master-&gt;_priv-&gt;drag_request)
+        return;
+    
+    master-&gt;_priv-&gt;rect_drawn = ~master-&gt;_priv-&gt;rect_drawn;
+    
+    if (master-&gt;_priv-&gt;rect_owner) {
+        gdl_dock_xor_rect (master-&gt;_priv-&gt;rect_owner,
+                           &amp;master-&gt;_priv-&gt;drag_request-&gt;rect);
+        return;
+    }
+    
+    rect = &amp;master-&gt;_priv-&gt;drag_request-&gt;rect;
+    window = gdk_window_lookup (gdk_x11_get_default_root_xwindow ());
+
+    if (!master-&gt;_priv-&gt;root_xor_gc) {
+        GdkGCValues values;
+
+        values.function = GDK_INVERT;
+        values.subwindow_mode = GDK_INCLUDE_INFERIORS;
+        master-&gt;_priv-&gt;root_xor_gc = gdk_gc_new_with_values (
+            window, &amp;values, GDK_GC_FUNCTION | GDK_GC_SUBWINDOW);
+    };
+
+    gdk_gc_set_line_attributes (master-&gt;_priv-&gt;root_xor_gc, 1,
+                                GDK_LINE_ON_OFF_DASH,
+                                GDK_CAP_NOT_LAST,
+                                GDK_JOIN_BEVEL);
+    
+    dash_list[0] = 1;
+    dash_list[1] = 1;
+    gdk_gc_set_dashes (master-&gt;_priv-&gt;root_xor_gc, 1, dash_list, 2);
+
+    gdk_draw_rectangle (window, master-&gt;_priv-&gt;root_xor_gc, 0, 
+                        rect-&gt;x, rect-&gt;y,
+                        rect-&gt;width, rect-&gt;height);
+
+    gdk_gc_set_dashes (master-&gt;_priv-&gt;root_xor_gc, 0, dash_list, 2);
+
+    gdk_draw_rectangle (window, master-&gt;_priv-&gt;root_xor_gc, 0, 
+                        rect-&gt;x + 1, rect-&gt;y + 1,
+                        rect-&gt;width - 2, rect-&gt;height - 2);
+}
+
+static void
+gdl_dock_master_layout_changed (GdlDockMaster *master)
+{
+    g_return_if_fail (GDL_IS_DOCK_MASTER (master));
+
+    /* emit &quot;layout_changed&quot; on the controller to notify the user who
+     * normally shouldn't have access to us */
+    if (master-&gt;controller)
+        g_signal_emit_by_name (master-&gt;controller, &quot;layout_changed&quot;);
+
+    /* remove the idle handler if there is one */
+    if (master-&gt;_priv-&gt;idle_layout_changed_id) {
+        g_source_remove (master-&gt;_priv-&gt;idle_layout_changed_id);
+        master-&gt;_priv-&gt;idle_layout_changed_id = 0;
+    }
+}
+
+static gboolean
+idle_emit_layout_changed (gpointer user_data)
+{
+    GdlDockMaster *master = user_data;
+
+    g_return_val_if_fail (master &amp;&amp; GDL_IS_DOCK_MASTER (master), FALSE);
+
+    master-&gt;_priv-&gt;idle_layout_changed_id = 0;
+    g_signal_emit (master, master_signals [LAYOUT_CHANGED], 0);
+    
+    return FALSE;
+}
+
+static void 
+item_dock_cb (GdlDockObject    *object,
+              GdlDockObject    *requestor,
+              GdlDockPlacement  position,
+              GValue           *other_data,
+              gpointer          user_data)
+{
+    GdlDockMaster *master = user_data;
+    
+    g_return_if_fail (requestor &amp;&amp; GDL_IS_DOCK_OBJECT (requestor));
+    g_return_if_fail (master &amp;&amp; GDL_IS_DOCK_MASTER (master));
+
+    /* here we are in fact interested in the requestor, since it's
+     * assumed that object will not change its visibility... for the
+     * requestor, however, could mean that it's being shown */
+    if (!GDL_DOCK_OBJECT_IN_REFLOW (requestor) &amp;&amp;
+        !GDL_DOCK_OBJECT_AUTOMATIC (requestor)) {
+        if (!master-&gt;_priv-&gt;idle_layout_changed_id)
+            master-&gt;_priv-&gt;idle_layout_changed_id =
+                g_idle_add (idle_emit_layout_changed, master);
+    }
+}
+
+static void 
+item_detach_cb (GdlDockObject *object,
+                gboolean       recursive,
+                gpointer       user_data)
+{
+    GdlDockMaster *master = user_data;
+    
+    g_return_if_fail (object &amp;&amp; GDL_IS_DOCK_OBJECT (object));
+    g_return_if_fail (master &amp;&amp; GDL_IS_DOCK_MASTER (master));
+
+    if (!GDL_DOCK_OBJECT_IN_REFLOW (object) &amp;&amp;
+        !GDL_DOCK_OBJECT_AUTOMATIC (object)) {
+        if (!master-&gt;_priv-&gt;idle_layout_changed_id)
+            master-&gt;_priv-&gt;idle_layout_changed_id =
+                g_idle_add (idle_emit_layout_changed, master);
+    }
+}
+
+static void
+item_notify_cb (GdlDockObject *object,
+                GParamSpec    *pspec,
+                gpointer       user_data)
+{
+    GdlDockMaster *master = user_data;
+    gint locked = COMPUTE_LOCKED (master);
+    gboolean item_locked;
+    
+    g_object_get (object, &quot;locked&quot;, &amp;item_locked, NULL);
+
+    if (item_locked) {
+        g_hash_table_remove (master-&gt;_priv-&gt;unlocked_items, object);
+        g_hash_table_insert (master-&gt;_priv-&gt;locked_items, object, NULL);
+    } else {
+        g_hash_table_remove (master-&gt;_priv-&gt;locked_items, object);
+        g_hash_table_insert (master-&gt;_priv-&gt;unlocked_items, object, NULL);
+    }
+    
+    if (COMPUTE_LOCKED (master) != locked)
+        g_object_notify (G_OBJECT (master), &quot;locked&quot;);
+}
+
+/* ----- Public interface ----- */
+
+void
+gdl_dock_master_add (GdlDockMaster *master,
+                     GdlDockObject *object)
+{
+    g_return_if_fail (master != NULL &amp;&amp; object != NULL);
+
+    if (!GDL_DOCK_OBJECT_AUTOMATIC (object)) {
+        GdlDockObject *found_object;
+        
+        /* create a name for the object if it doesn't have one */
+        if (!object-&gt;name)
+            /* directly set the name, since it's a construction only
+               property */
+            object-&gt;name = g_strdup_printf (&quot;__dock_%u&quot;, master-&gt;_priv-&gt;number++);
+        
+        /* add the object to our hash list */
+        if ((found_object = g_hash_table_lookup (master-&gt;dock_objects, object-&gt;name))) {
+            g_warning (_(&quot;master %p: unable to add object %p[%s] to the hash.  &quot;
+                         &quot;There already is an item with that name (%p).&quot;),
+                       master, object, object-&gt;name, found_object);
+        }
+        else {
+            g_object_ref (object);
+            gtk_object_sink (GTK_OBJECT (object));
+            g_hash_table_insert (master-&gt;dock_objects, g_strdup (object-&gt;name), object);
+        }
+    }
+    
+    if (GDL_IS_DOCK (object)) {
+        gboolean floating;
+        
+        /* if this is the first toplevel we are adding, name it controller */
+        if (!master-&gt;toplevel_docks)
+            /* the dock should already have the ref */
+            master-&gt;controller = object;
+        
+        /* add dock to the toplevel list */
+        g_object_get (object, &quot;floating&quot;, &amp;floating, NULL);
+        if (floating)
+            master-&gt;toplevel_docks = g_list_prepend (master-&gt;toplevel_docks, object);
+        else
+            master-&gt;toplevel_docks = g_list_append (master-&gt;toplevel_docks, object);
+
+        /* we are interested in the dock request this toplevel
+         * receives to update the layout */
+        g_signal_connect (object, &quot;dock&quot;,
+                          G_CALLBACK (item_dock_cb), master);
+
+    }
+    else if (GDL_IS_DOCK_ITEM (object)) {
+        /* we need to connect the item's signals */
+        g_signal_connect (object, &quot;dock_drag_begin&quot;,
+                          G_CALLBACK (gdl_dock_master_drag_begin), master);
+        g_signal_connect (object, &quot;dock_drag_motion&quot;,
+                          G_CALLBACK (gdl_dock_master_drag_motion), master);
+        g_signal_connect (object, &quot;dock_drag_end&quot;,
+                          G_CALLBACK (gdl_dock_master_drag_end), master);
+        g_signal_connect (object, &quot;dock&quot;,
+                          G_CALLBACK (item_dock_cb), master);
+        g_signal_connect (object, &quot;detach&quot;,
+                          G_CALLBACK (item_detach_cb), master);
+
+        /* register to &quot;locked&quot; notification if the item has a grip,
+         * and add the item to the corresponding hash */
+        if (GDL_DOCK_ITEM_HAS_GRIP (object)) {
+            g_signal_connect (object, &quot;notify::locked&quot;,
+                              G_CALLBACK (item_notify_cb), master);
+            item_notify_cb (object, NULL, master);
+        }
+        
+        /* post a layout_changed emission if the item is not automatic
+         * (since it should be added to the items model) */
+        if (!GDL_DOCK_OBJECT_AUTOMATIC (object)) {
+            if (!master-&gt;_priv-&gt;idle_layout_changed_id)
+                master-&gt;_priv-&gt;idle_layout_changed_id =
+                    g_idle_add (idle_emit_layout_changed, master);
+        }
+    }
+}
+
+void
+gdl_dock_master_remove (GdlDockMaster *master,
+                        GdlDockObject *object)
+{
+    g_return_if_fail (master != NULL &amp;&amp; object != NULL);
+
+    /* remove from locked/unlocked hashes and property change if
+     * that's the case */
+    if (GDL_IS_DOCK_ITEM (object) &amp;&amp; GDL_DOCK_ITEM_HAS_GRIP (object)) {
+        gint locked = COMPUTE_LOCKED (master);
+        if (g_hash_table_remove (master-&gt;_priv-&gt;locked_items, object) ||
+            g_hash_table_remove (master-&gt;_priv-&gt;unlocked_items, object)) {
+            if (COMPUTE_LOCKED (master) != locked)
+                g_object_notify (G_OBJECT (master), &quot;locked&quot;);
+        }
+    }
+        
+    /* ref the master, since removing the controller could cause master disposal */
+    g_object_ref (master);
+    
+    /* all the interesting stuff happens in _gdl_dock_master_remove */
+    _gdl_dock_master_remove (object, master);
+
+    /* post a layout_changed emission if the item is not automatic
+     * (since it should be removed from the items model) */
+    if (!GDL_DOCK_OBJECT_AUTOMATIC (object)) {
+        if (!master-&gt;_priv-&gt;idle_layout_changed_id)
+            master-&gt;_priv-&gt;idle_layout_changed_id =
+                g_idle_add (idle_emit_layout_changed, master);
+    }
+    
+    /* balance ref count */
+    g_object_unref (master);
+}
+
+void
+gdl_dock_master_foreach (GdlDockMaster *master,
+                         GFunc          function,
+                         gpointer       user_data)
+{
+    struct {
+        GFunc    function;
+        gpointer user_data;
+    } data;
+
+    g_return_if_fail (master != NULL &amp;&amp; function != NULL);
+
+    data.function = function;
+    data.user_data = user_data;
+    g_hash_table_foreach (master-&gt;dock_objects, _gdl_dock_master_foreach, &amp;data);
+}
+
+void
+gdl_dock_master_foreach_toplevel (GdlDockMaster *master,
+                                  gboolean       include_controller,
+                                  GFunc          function,
+                                  gpointer       user_data)
+{
+    GList *l;
+    
+    g_return_if_fail (master != NULL &amp;&amp; function != NULL);
+
+    for (l = master-&gt;toplevel_docks; l; ) {
+        GdlDockObject *object = GDL_DOCK_OBJECT (l-&gt;data);
+        l = l-&gt;next;
+        if (object != master-&gt;controller || include_controller)
+            (* function) (GTK_WIDGET (object), user_data);
+    }
+}
+
+GdlDockObject *
+gdl_dock_master_get_object (GdlDockMaster *master,
+                            const gchar   *nick_name)
+{
+    gpointer *found;
+    
+    g_return_val_if_fail (master != NULL, NULL);
+
+    if (!nick_name)
+        return NULL;
+
+    found = g_hash_table_lookup (master-&gt;dock_objects, nick_name);
+
+    return found ? GDL_DOCK_OBJECT (found) : NULL;
+}
+
+GdlDockObject *
+gdl_dock_master_get_controller (GdlDockMaster *master)
+{
+    g_return_val_if_fail (master != NULL, NULL);
+
+    return master-&gt;controller;
+}
+
+void
+gdl_dock_master_set_controller (GdlDockMaster *master,
+                                GdlDockObject *new_controller)
+{
+    g_return_if_fail (master != NULL);
+
+    if (new_controller) {
+        if (GDL_DOCK_OBJECT_AUTOMATIC (new_controller))
+            g_warning (_(&quot;The new dock controller %p is automatic.  Only manual &quot;
+                         &quot;dock objects should be named controller.&quot;), new_controller);
+        
+        /* check that the controller is in the toplevel list */
+        if (!g_list_find (master-&gt;toplevel_docks, new_controller))
+            gdl_dock_master_add (master, new_controller);
+        master-&gt;controller = new_controller;
+
+    } else {
+        master-&gt;controller = NULL;
+        /* no controller, no master */
+        g_object_unref (master);
+    }
+}

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-master.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-master.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-master.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,98 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * gdl-dock-master.h - Object which manages a dock ring
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifndef __GDL_DOCK_MASTER_H__
+#define __GDL_DOCK_MASTER_H__
+
+#include &lt;glib-object.h&gt;
+#include &lt;gtk/gtktypeutils.h&gt;
+#include &lt;gdl/gdl-dock-object.h&gt;
+
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK_MASTER             (gdl_dock_master_get_type ())
+#define GDL_DOCK_MASTER(obj)             (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_MASTER, GdlDockMaster))
+#define GDL_DOCK_MASTER_CLASS(klass)     (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_MASTER, GdlDockMasterClass))
+#define GDL_IS_DOCK_MASTER(obj)          (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_MASTER))
+#define GDL_IS_DOCK_MASTER_CLASS(klass)  (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_MASTER))
+#define GDL_DOCK_MASTER_GET_CLASS(obj)   (GTK_CHECK_GET_CLASS ((obj), GTK_TYPE_DOCK_MASTER, GdlDockMasterClass))
+
+/* data types &amp; structures */
+typedef struct _GdlDockMaster        GdlDockMaster;
+typedef struct _GdlDockMasterClass   GdlDockMasterClass;
+typedef struct _GdlDockMasterPrivate GdlDockMasterPrivate;
+
+struct _GdlDockMaster {
+    GObject               object;
+
+    GHashTable           *dock_objects;
+    GList                *toplevel_docks;
+    GdlDockObject        *controller;      /* GUI root object */
+    
+    gint                  dock_number;     /* for toplevel dock numbering */
+    
+    GdlDockMasterPrivate *_priv;
+};
+
+struct _GdlDockMasterClass {
+    GObjectClass parent_class;
+
+    void (* layout_changed) (GdlDockMaster *master);
+};
+
+/* additional macros */
+
+#define GDL_DOCK_OBJECT_GET_MASTER(object) \
+    (GDL_DOCK_OBJECT (object)-&gt;master ? \
+        GDL_DOCK_MASTER (GDL_DOCK_OBJECT (object)-&gt;master) : NULL)
+
+/* public interface */
+ 
+GType          gdl_dock_master_get_type         (void);
+
+void           gdl_dock_master_add              (GdlDockMaster *master,
+                                                 GdlDockObject *object);
+void           gdl_dock_master_remove           (GdlDockMaster *master,
+                                                 GdlDockObject *object);
+void           gdl_dock_master_foreach          (GdlDockMaster *master,
+                                                 GFunc          function,
+                                                 gpointer       user_data);
+
+void           gdl_dock_master_foreach_toplevel (GdlDockMaster *master,
+                                                 gboolean       include_controller,
+                                                 GFunc          function,
+                                                 gpointer       user_data);
+
+GdlDockObject *gdl_dock_master_get_object       (GdlDockMaster *master,
+                                                 const gchar   *nick_name);
+
+GdlDockObject *gdl_dock_master_get_controller   (GdlDockMaster *master);
+void           gdl_dock_master_set_controller   (GdlDockMaster *master,
+                                                 GdlDockObject *new_controller);
+
+G_END_DECLS
+
+#endif /* __GDL_DOCK_MASTER_H__ */

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,502 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;gtk/gtknotebook.h&gt;
+#include &lt;libgnome/gnome-macros.h&gt;
+
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock-notebook.h&quot;
+#include &quot;gdl-dock-tablabel.h&quot;
+
+
+/* Private prototypes */
+
+static void  gdl_dock_notebook_class_init    (GdlDockNotebookClass *klass);
+static void  gdl_dock_notebook_instance_init (GdlDockNotebook      *notebook);
+static void  gdl_dock_notebook_set_property  (GObject              *object,
+                                              guint                 prop_id,
+                                              const GValue         *value,
+                                              GParamSpec           *pspec);
+static void  gdl_dock_notebook_get_property  (GObject              *object,
+                                              guint                 prop_id,
+                                              GValue               *value,
+                                              GParamSpec           *pspec);
+
+static void  gdl_dock_notebook_destroy       (GtkObject    *object);
+
+static void  gdl_dock_notebook_add           (GtkContainer *container,
+					      GtkWidget    *widget);
+static void  gdl_dock_notebook_forall        (GtkContainer *container,
+					      gboolean      include_internals,
+					      GtkCallback   callback,
+					      gpointer      callback_data);
+static GType gdl_dock_notebook_child_type    (GtkContainer *container);
+
+static void  gdl_dock_notebook_dock          (GdlDockObject    *object,
+                                              GdlDockObject    *requestor,
+                                              GdlDockPlacement  position,
+                                              GValue           *other_data);
+
+static void  gdl_dock_notebook_switch_page_cb  (GtkNotebook     *nb,
+                                                GtkNotebookPage *page,
+                                                gint             page_num,
+                                                gpointer         data);
+
+static void  gdl_dock_notebook_set_orientation (GdlDockItem     *item,
+                                                GtkOrientation   orientation);
+					       
+static gboolean gdl_dock_notebook_child_placement (GdlDockObject    *object,
+                                                   GdlDockObject    *child,
+                                                   GdlDockPlacement *placement);
+
+static void     gdl_dock_notebook_present         (GdlDockObject    *object,
+                                                   GdlDockObject    *child);
+
+static gboolean gdl_dock_notebook_reorder         (GdlDockObject    *object,
+                                                   GdlDockObject    *requestor,
+                                                   GdlDockPlacement  new_position,
+                                                   GValue           *other_data);
+
+
+/* Class variables and definitions */
+
+enum {
+    PROP_0,
+    PROP_PAGE
+};
+
+
+/* ----- Private functions ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDockNotebook, gdl_dock_notebook, GdlDockItem, GDL_TYPE_DOCK_ITEM) ;
+
+static void
+gdl_dock_notebook_class_init (GdlDockNotebookClass *klass)
+{
+    GObjectClass       *g_object_class;
+    GtkObjectClass     *gtk_object_class;
+    GtkWidgetClass     *widget_class;
+    GtkContainerClass  *container_class;
+    GdlDockObjectClass *object_class;
+    GdlDockItemClass   *item_class;
+
+    g_object_class = G_OBJECT_CLASS (klass);
+    gtk_object_class = GTK_OBJECT_CLASS (klass);
+    widget_class = GTK_WIDGET_CLASS (klass);
+    container_class = GTK_CONTAINER_CLASS (klass);
+    object_class = GDL_DOCK_OBJECT_CLASS (klass);
+    item_class = GDL_DOCK_ITEM_CLASS (klass);
+
+    g_object_class-&gt;set_property = gdl_dock_notebook_set_property;
+    g_object_class-&gt;get_property = gdl_dock_notebook_get_property;
+    
+    gtk_object_class-&gt;destroy = gdl_dock_notebook_destroy;
+
+    container_class-&gt;add = gdl_dock_notebook_add;
+    container_class-&gt;forall = gdl_dock_notebook_forall;
+    container_class-&gt;child_type = gdl_dock_notebook_child_type;
+    
+    object_class-&gt;is_compound = TRUE;
+    object_class-&gt;dock = gdl_dock_notebook_dock;
+    object_class-&gt;child_placement = gdl_dock_notebook_child_placement;
+    object_class-&gt;present = gdl_dock_notebook_present;
+    object_class-&gt;reorder = gdl_dock_notebook_reorder;
+    
+    item_class-&gt;has_grip = TRUE;
+    item_class-&gt;set_orientation = gdl_dock_notebook_set_orientation;    
+    
+    g_object_class_install_property (
+        g_object_class, PROP_PAGE,
+        g_param_spec_int (&quot;page&quot;, _(&quot;Page&quot;),
+                          _(&quot;The index of the current page&quot;),
+                          0, G_MAXINT,
+                          0,
+                          G_PARAM_READWRITE |
+                          GDL_DOCK_PARAM_EXPORT | GDL_DOCK_PARAM_AFTER));
+}
+
+static void 
+gdl_dock_notebook_notify_cb (GObject    *g_object,
+                             GParamSpec *pspec,
+                             gpointer    user_data) 
+{
+    g_return_if_fail (user_data != NULL &amp;&amp; GDL_IS_DOCK_NOTEBOOK (user_data));
+
+    /* chain the notify signal */
+    g_object_notify (G_OBJECT (user_data), pspec-&gt;name);
+}
+
+static gboolean 
+gdl_dock_notebook_button_cb (GtkWidget      *widget,
+                             GdkEventButton *event,
+                             gpointer        user_data)
+{
+    if (event-&gt;type == GDK_BUTTON_PRESS)
+        GDL_DOCK_ITEM_SET_FLAGS (user_data, GDL_DOCK_USER_ACTION);
+    else
+        GDL_DOCK_ITEM_UNSET_FLAGS (user_data, GDL_DOCK_USER_ACTION);
+
+    return FALSE;
+}
+    
+static void
+gdl_dock_notebook_instance_init (GdlDockNotebook *notebook)
+{
+    GdlDockItem *item;
+
+    item = GDL_DOCK_ITEM (notebook);
+
+    /* create the container notebook */
+    item-&gt;child = gtk_notebook_new ();
+    gtk_widget_set_parent (item-&gt;child, GTK_WIDGET (notebook));
+    if (item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL)
+        gtk_notebook_set_tab_pos (GTK_NOTEBOOK (item-&gt;child), GTK_POS_TOP);
+    else
+        gtk_notebook_set_tab_pos (GTK_NOTEBOOK (item-&gt;child), GTK_POS_LEFT);
+    g_signal_connect (item-&gt;child, &quot;switch_page&quot;,
+                      (GCallback) gdl_dock_notebook_switch_page_cb, (gpointer) item);
+    g_signal_connect (item-&gt;child, &quot;notify::page&quot;,
+                      (GCallback) gdl_dock_notebook_notify_cb, (gpointer) item);
+    g_signal_connect (item-&gt;child, &quot;button-press-event&quot;,
+                      (GCallback) gdl_dock_notebook_button_cb, (gpointer) item);
+    g_signal_connect (item-&gt;child, &quot;button-release-event&quot;,
+                      (GCallback) gdl_dock_notebook_button_cb, (gpointer) item);
+    gtk_notebook_set_scrollable (GTK_NOTEBOOK (item-&gt;child), TRUE);
+    gtk_widget_show (item-&gt;child);
+}
+
+static void 
+gdl_dock_notebook_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+
+    switch (prop_id) {
+        case PROP_PAGE:
+            if (item-&gt;child &amp;&amp; GTK_IS_NOTEBOOK (item-&gt;child)) {
+                gtk_notebook_set_current_page (GTK_NOTEBOOK (item-&gt;child),
+                                               g_value_get_int (value));
+            }
+            
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void 
+gdl_dock_notebook_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+
+    switch (prop_id) {
+        case PROP_PAGE:
+            if (item-&gt;child &amp;&amp; GTK_IS_NOTEBOOK (item-&gt;child)) {
+                g_value_set_int (value, gtk_notebook_get_current_page
+                                 (GTK_NOTEBOOK (item-&gt;child)));
+            }
+            
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+
+static void
+gdl_dock_notebook_destroy (GtkObject *object)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+
+    /* we need to call the virtual first, since in GdlDockDestroy our
+       children dock objects are detached */
+    GNOME_CALL_PARENT (GTK_OBJECT_CLASS, destroy, (object));
+
+    /* after that we can remove the GtkNotebook */
+    if (item-&gt;child) {
+        gtk_widget_unparent (item-&gt;child);
+        item-&gt;child = NULL;
+    };
+}
+
+static void
+gdl_dock_notebook_switch_page_cb (GtkNotebook     *nb,
+                                  GtkNotebookPage *page,
+                                  gint             page_num,
+                                  gpointer         data)
+{
+    GdlDockNotebook *notebook;
+    GtkWidget       *tablabel;
+
+    notebook = GDL_DOCK_NOTEBOOK (data);
+
+    /* deactivate old tablabel */
+    if (nb-&gt;cur_page) {
+        tablabel = gtk_notebook_get_tab_label (
+            nb, gtk_notebook_get_nth_page (
+                nb, gtk_notebook_get_current_page (nb)));
+        if (tablabel &amp;&amp; GDL_IS_DOCK_TABLABEL (tablabel))
+            gdl_dock_tablabel_deactivate (GDL_DOCK_TABLABEL (tablabel));
+    };
+
+    /* activate new label */
+    tablabel = gtk_notebook_get_tab_label (
+        nb, gtk_notebook_get_nth_page (nb, page_num));
+    if (tablabel &amp;&amp; GDL_IS_DOCK_TABLABEL (tablabel))
+        gdl_dock_tablabel_activate (GDL_DOCK_TABLABEL (tablabel));
+
+    if (GDL_DOCK_ITEM_USER_ACTION (notebook) &amp;&amp;
+        GDL_DOCK_OBJECT (notebook)-&gt;master)
+        g_signal_emit_by_name (GDL_DOCK_OBJECT (notebook)-&gt;master,
+                               &quot;layout_changed&quot;);
+}
+
+static void
+gdl_dock_notebook_add (GtkContainer *container,
+		       GtkWidget    *widget)
+{
+    g_return_if_fail (container != NULL &amp;&amp; widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK_NOTEBOOK (container));
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+
+    gdl_dock_object_dock (GDL_DOCK_OBJECT (container),
+                          GDL_DOCK_OBJECT (widget),
+                          GDL_DOCK_CENTER,
+                          NULL);
+}
+
+static void
+gdl_dock_notebook_forall (GtkContainer *container,
+			  gboolean      include_internals,
+			  GtkCallback   callback,
+			  gpointer      callback_data)
+{
+    GdlDockItem *item;
+
+    g_return_if_fail (container != NULL);
+    g_return_if_fail (GDL_IS_DOCK_NOTEBOOK (container));
+    g_return_if_fail (callback != NULL);
+
+    if (include_internals) {
+        /* use GdlDockItem's forall */
+        GNOME_CALL_PARENT (GTK_CONTAINER_CLASS, forall, 
+                           (container, include_internals, callback, callback_data));
+    }
+    else {
+        item = GDL_DOCK_ITEM (container);
+        if (item-&gt;child)
+            gtk_container_foreach (GTK_CONTAINER (item-&gt;child), callback, callback_data);
+    }
+}
+
+static GType
+gdl_dock_notebook_child_type (GtkContainer *container)
+{
+    return GDL_TYPE_DOCK_ITEM;
+}
+    
+static void
+gdl_dock_notebook_dock_child (GdlDockObject *requestor,
+                              gpointer       user_data)
+{
+    struct {
+        GdlDockObject    *object;
+        GdlDockPlacement  position;
+        GValue           *other_data;
+    } *data = user_data;
+
+    gdl_dock_object_dock (data-&gt;object, requestor, data-&gt;position, data-&gt;other_data);
+}
+
+static void
+gdl_dock_notebook_dock (GdlDockObject    *object,
+                        GdlDockObject    *requestor,
+                        GdlDockPlacement  position,
+                        GValue           *other_data)
+{
+    g_return_if_fail (GDL_IS_DOCK_NOTEBOOK (object));
+    g_return_if_fail (GDL_IS_DOCK_ITEM (requestor));
+
+    /* we only add support for GDL_DOCK_CENTER docking strategy here... for the rest
+       use our parent class' method */
+    if (position == GDL_DOCK_CENTER) {
+        /* we can only dock simple (not compound) items */
+        if (gdl_dock_object_is_compound (requestor)) {
+            struct {
+                GdlDockObject    *object;
+                GdlDockPlacement  position;
+                GValue           *other_data;
+            } data;
+
+            gdl_dock_object_freeze (requestor);
+            
+            data.object = object;
+            data.position = position;
+            data.other_data = other_data;
+             
+            gtk_container_foreach (GTK_CONTAINER (requestor),
+                                   (GtkCallback) gdl_dock_notebook_dock_child, &amp;data);
+
+            gdl_dock_object_thaw (requestor);
+        }
+        else {
+            GdlDockItem *item = GDL_DOCK_ITEM (object);
+            GdlDockItem *requestor_item = GDL_DOCK_ITEM (requestor);
+            GtkWidget   *label;
+            gint         position = -1;
+            
+            label = gdl_dock_item_get_tablabel (requestor_item);
+            if (!label) {
+                label = gdl_dock_tablabel_new (requestor_item);
+                gdl_dock_item_set_tablabel (requestor_item, label);
+            }
+            if (GDL_IS_DOCK_TABLABEL (label)) {
+                gdl_dock_tablabel_deactivate (GDL_DOCK_TABLABEL (label));
+                /* hide the item grip, as we will use the tablabel's */
+                gdl_dock_item_hide_grip (requestor_item);
+            }
+
+            if (other_data &amp;&amp; G_VALUE_HOLDS (other_data, G_TYPE_INT))
+                position = g_value_get_int (other_data);
+            
+            gtk_notebook_insert_page (GTK_NOTEBOOK (item-&gt;child), 
+                                      GTK_WIDGET (requestor), label,
+                                      position);
+            GDL_DOCK_OBJECT_SET_FLAGS (requestor, GDL_DOCK_ATTACHED);
+        }
+    }
+    else
+        GNOME_CALL_PARENT (GDL_DOCK_OBJECT_CLASS, dock,
+                           (object, requestor, position, other_data));
+}
+
+static void
+gdl_dock_notebook_set_orientation (GdlDockItem    *item,
+				   GtkOrientation  orientation)
+{
+    if (item-&gt;child &amp;&amp; GTK_IS_NOTEBOOK (item-&gt;child)) {
+        if (orientation == GTK_ORIENTATION_HORIZONTAL)
+            gtk_notebook_set_tab_pos (GTK_NOTEBOOK (item-&gt;child), GTK_POS_TOP);
+        else
+            gtk_notebook_set_tab_pos (GTK_NOTEBOOK (item-&gt;child), GTK_POS_LEFT);
+    }
+
+    GNOME_CALL_PARENT (GDL_DOCK_ITEM_CLASS, set_orientation, (item, orientation));
+}
+
+static gboolean 
+gdl_dock_notebook_child_placement (GdlDockObject    *object,
+                                   GdlDockObject    *child,
+                                   GdlDockPlacement *placement)
+{
+    GdlDockItem      *item = GDL_DOCK_ITEM (object);
+    GdlDockPlacement  pos = GDL_DOCK_NONE;
+    
+    if (item-&gt;child) {
+        GList *children, *l;
+
+        children = gtk_container_get_children (GTK_CONTAINER (item-&gt;child));
+        for (l = children; l; l = l-&gt;next) {
+            if (l-&gt;data == (gpointer) child) {
+                pos = GDL_DOCK_CENTER;
+                break;
+            }
+        }
+        g_list_free (children);
+    }
+
+    if (pos != GDL_DOCK_NONE) {
+        if (placement)
+            *placement = pos;
+        return TRUE;
+    }
+    else
+        return FALSE;
+}
+
+static void
+gdl_dock_notebook_present (GdlDockObject *object,
+                           GdlDockObject *child)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+    int i;
+    
+    i = gtk_notebook_page_num (GTK_NOTEBOOK (item-&gt;child),
+                               GTK_WIDGET (child));
+    if (i &gt;= 0)
+        gtk_notebook_set_current_page (GTK_NOTEBOOK (item-&gt;child), i);
+
+    GNOME_CALL_PARENT (GDL_DOCK_OBJECT_CLASS, present, (object, child));
+}
+
+static gboolean 
+gdl_dock_notebook_reorder (GdlDockObject    *object,
+                           GdlDockObject    *requestor,
+                           GdlDockPlacement  new_position,
+                           GValue           *other_data)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+    gint         current_position, new_pos = -1;
+    gboolean     handled = FALSE;
+    
+    if (item-&gt;child &amp;&amp; new_position == GDL_DOCK_CENTER) {
+        current_position = gtk_notebook_page_num (GTK_NOTEBOOK (item-&gt;child),
+                                                  GTK_WIDGET (requestor));
+        if (current_position &gt;= 0) {
+            handled = TRUE;
+    
+            if (other_data &amp;&amp; G_VALUE_HOLDS (other_data, G_TYPE_INT))
+                new_pos = g_value_get_int (other_data);
+            
+            gtk_notebook_reorder_child (GTK_NOTEBOOK (item-&gt;child), 
+                                        GTK_WIDGET (requestor),
+                                        new_pos);
+        }
+    }
+    return handled;
+}
+
+/* ----- Public interface ----- */
+
+GtkWidget *
+gdl_dock_notebook_new (void)
+{
+    GdlDockNotebook *notebook;
+
+    notebook = GDL_DOCK_NOTEBOOK (g_object_new (GDL_TYPE_DOCK_NOTEBOOK, NULL));
+    GDL_DOCK_OBJECT_UNSET_FLAGS (notebook, GDL_DOCK_AUTOMATIC);
+    
+    return GTK_WIDGET (notebook);
+}
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,60 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifndef __GDL_DOCK_NOTEBOOK_H__
+#define __GDL_DOCK_NOTEBOOK_H__
+
+#include &lt;gdl/gdl-dock-item.h&gt;
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK_NOTEBOOK            (gdl_dock_notebook_get_type ())
+#define GDL_DOCK_NOTEBOOK(obj)            (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_NOTEBOOK, GdlDockNotebook))
+#define GDL_DOCK_NOTEBOOK_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_NOTEBOOK, GdlDockNotebookClass))
+#define GDL_IS_DOCK_NOTEBOOK(obj)         (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_NOTEBOOK))
+#define GDL_IS_DOCK_NOTEBOOK_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_NOTEBOOK))
+#define GDL_DOCK_NOTEBOOK_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), GTK_TYPE_DOCK_NOTEBOOK, GdlDockNotebookClass))
+
+/* data types &amp; structures */
+typedef struct _GdlDockNotebook        GdlDockNotebook;
+typedef struct _GdlDockNotebookClass   GdlDockNotebookClass;
+
+struct _GdlDockNotebook {
+    GdlDockItem  item;
+};
+
+struct _GdlDockNotebookClass {
+    GdlDockItemClass  parent_class;
+};
+
+
+/* public interface */
+ 
+GtkWidget     *gdl_dock_notebook_new               (void);
+
+GType          gdl_dock_notebook_get_type          (void);
+
+G_END_DECLS
+
+#endif
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,913 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * gdl-dock-object.c - Abstract base class for all dock related objects
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;libgnome/gnome-macros.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock-object.h&quot;
+#include &quot;gdl-dock-master.h&quot;
+#include &quot;libgdltypebuiltins.h&quot;
+#include &quot;libgdlmarshal.h&quot;
+
+/* for later use by the registry */
+#include &quot;gdl-dock.h&quot;
+#include &quot;gdl-dock-item.h&quot;
+#include &quot;gdl-dock-paned.h&quot;
+#include &quot;gdl-dock-notebook.h&quot;
+#include &quot;gdl-dock-placeholder.h&quot;
+
+
+/* ----- Private prototypes ----- */
+
+static void     gdl_dock_object_class_init         (GdlDockObjectClass *klass);
+static void     gdl_dock_object_instance_init      (GdlDockObject      *object);
+
+static void     gdl_dock_object_set_property       (GObject            *g_object,
+                                                    guint               prop_id,
+                                                    const GValue       *value,
+                                                    GParamSpec         *pspec);
+static void     gdl_dock_object_get_property       (GObject            *g_object,
+                                                    guint               prop_id,
+                                                    GValue             *value,
+                                                    GParamSpec         *pspec);
+static void     gdl_dock_object_finalize           (GObject            *g_object);
+
+static void     gdl_dock_object_destroy            (GtkObject          *gtk_object);
+
+static void     gdl_dock_object_show               (GtkWidget          *widget);
+static void     gdl_dock_object_hide               (GtkWidget          *widget);
+
+static void     gdl_dock_object_real_detach        (GdlDockObject      *object,
+                                                    gboolean            recursive);
+static void     gdl_dock_object_real_reduce        (GdlDockObject      *object);
+static void     gdl_dock_object_dock_unimplemented (GdlDockObject     *object,
+                                                    GdlDockObject     *requestor,
+                                                    GdlDockPlacement   position,
+                                                    GValue            *other_data);
+static void     gdl_dock_object_real_present       (GdlDockObject     *object,
+                                                    GdlDockObject     *child);
+
+
+/* ----- Private data types and variables ----- */
+
+enum {
+    PROP_0,
+    PROP_NAME,
+    PROP_LONG_NAME,
+    PROP_MASTER,
+    PROP_EXPORT_PROPERTIES
+};
+
+enum {
+    DETACH,
+    DOCK,
+    LAST_SIGNAL
+};
+
+static guint gdl_dock_object_signals [LAST_SIGNAL] = { 0 };
+
+/* ----- Private interface ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDockObject, gdl_dock_object, GtkContainer, GTK_TYPE_CONTAINER);
+
+static void
+gdl_dock_object_class_init (GdlDockObjectClass *klass)
+{
+    GObjectClass      *g_object_class;
+    GtkObjectClass    *object_class;
+    GtkWidgetClass    *widget_class;
+    GtkContainerClass *container_class;
+
+    g_object_class = G_OBJECT_CLASS (klass);
+    object_class = GTK_OBJECT_CLASS (klass);
+    widget_class = GTK_WIDGET_CLASS (klass);
+    container_class = GTK_CONTAINER_CLASS (klass);
+
+    g_object_class-&gt;set_property = gdl_dock_object_set_property;
+    g_object_class-&gt;get_property = gdl_dock_object_get_property;
+    g_object_class-&gt;finalize = gdl_dock_object_finalize;
+
+    g_object_class_install_property (
+        g_object_class, PROP_NAME,
+        g_param_spec_string (GDL_DOCK_NAME_PROPERTY, _(&quot;Name&quot;),
+                             _(&quot;Unique name for identifying the dock object&quot;),
+                             NULL,
+                             G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
+                             GDL_DOCK_PARAM_EXPORT));
+
+    g_object_class_install_property (
+        g_object_class, PROP_LONG_NAME,
+        g_param_spec_string (&quot;long_name&quot;, _(&quot;Long name&quot;),
+                             _(&quot;Human readable name for the dock object&quot;),
+                             NULL,
+                             G_PARAM_READWRITE));
+
+    g_object_class_install_property (
+        g_object_class, PROP_MASTER,
+        g_param_spec_object (&quot;master&quot;, _(&quot;Dock master&quot;),
+                             _(&quot;Dock master this dock object is bound to&quot;),
+                             GDL_TYPE_DOCK_MASTER,
+                             G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+    
+    object_class-&gt;destroy = gdl_dock_object_destroy;
+    
+    widget_class-&gt;show = gdl_dock_object_show;
+    widget_class-&gt;hide = gdl_dock_object_hide;
+    
+    klass-&gt;is_compound = TRUE;
+    
+    klass-&gt;detach = gdl_dock_object_real_detach;
+    klass-&gt;reduce = gdl_dock_object_real_reduce;
+    klass-&gt;dock_request = NULL;
+    klass-&gt;dock = gdl_dock_object_dock_unimplemented;
+    klass-&gt;reorder = NULL;
+    klass-&gt;present = gdl_dock_object_real_present;
+    klass-&gt;child_placement = NULL;
+    
+    gdl_dock_object_signals [DETACH] =
+        g_signal_new (&quot;detach&quot;,
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_LAST,
+                      G_STRUCT_OFFSET (GdlDockObjectClass, detach),
+                      NULL,
+                      NULL,
+                      gdl_marshal_VOID__BOOLEAN,
+                      G_TYPE_NONE,
+                      1,
+                      G_TYPE_BOOLEAN);
+
+    gdl_dock_object_signals [DOCK] =
+        g_signal_new (&quot;dock&quot;,
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_FIRST,
+                      G_STRUCT_OFFSET (GdlDockObjectClass, dock),
+                      NULL,
+                      NULL,
+                      gdl_marshal_VOID__OBJECT_ENUM_BOXED,
+                      G_TYPE_NONE,
+                      3,
+                      GDL_TYPE_DOCK_OBJECT,
+                      GDL_TYPE_DOCK_PLACEMENT,
+                      G_TYPE_VALUE);
+}
+
+static void
+gdl_dock_object_instance_init (GdlDockObject *object)
+{
+    object-&gt;flags = GDL_DOCK_AUTOMATIC;
+    object-&gt;freeze_count = 0;
+}
+
+static void
+gdl_dock_object_set_property  (GObject      *g_object,
+                               guint         prop_id,
+                               const GValue *value,
+                               GParamSpec   *pspec)
+{
+    GdlDockObject *object = GDL_DOCK_OBJECT (g_object);
+
+    switch (prop_id) {
+    case PROP_NAME:
+        g_free (object-&gt;name);
+        object-&gt;name = g_value_dup_string (value);
+        break;
+    case PROP_LONG_NAME:
+        g_free (object-&gt;long_name);
+        object-&gt;long_name = g_value_dup_string (value);
+        break;
+    case PROP_MASTER:
+        if (g_value_get_object (value)) 
+            gdl_dock_object_bind (object, g_value_get_object (value));
+        else
+            gdl_dock_object_unbind (object);
+        break;
+    default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+        break;
+    }
+}
+
+static void
+gdl_dock_object_get_property  (GObject      *g_object,
+                               guint         prop_id,
+                               GValue       *value,
+                               GParamSpec   *pspec)
+{
+    GdlDockObject *object = GDL_DOCK_OBJECT (g_object);
+
+    switch (prop_id) {
+    case PROP_NAME:
+        g_value_set_string (value, object-&gt;name);
+        break;
+    case PROP_LONG_NAME:
+        g_value_set_string (value, object-&gt;long_name);
+        break;
+    case PROP_MASTER:
+        g_value_set_object (value, object-&gt;master);
+        break;
+    default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+        break;
+    }
+}
+
+static void
+gdl_dock_object_finalize (GObject *g_object)
+{
+    GdlDockObject *object;
+    
+    g_return_if_fail (g_object != NULL &amp;&amp; GDL_IS_DOCK_OBJECT (g_object));
+
+    object = GDL_DOCK_OBJECT (g_object);
+
+    g_free (object-&gt;name);
+    object-&gt;name = NULL;
+    g_free (object-&gt;long_name);
+    object-&gt;long_name = NULL;
+
+    GNOME_CALL_PARENT (G_OBJECT_CLASS, finalize, (g_object));
+}
+
+static void
+gdl_dock_object_foreach_detach (GdlDockObject *object,
+                                gpointer       user_data)
+{
+    gdl_dock_object_detach (object, TRUE);
+}
+
+static void
+gdl_dock_object_destroy (GtkObject *gtk_object)
+{
+    GdlDockObject *object;
+
+    g_return_if_fail (GDL_IS_DOCK_OBJECT (gtk_object));
+
+    object = GDL_DOCK_OBJECT (gtk_object);
+    if (gdl_dock_object_is_compound (object)) {
+        /* detach our dock object children if we have some, and even
+           if we are not attached, so they can get notification */
+        gdl_dock_object_freeze (object);
+        gtk_container_foreach (GTK_CONTAINER (object),
+                               (GtkCallback) gdl_dock_object_foreach_detach,
+                               NULL);
+        object-&gt;reduce_pending = FALSE;
+        gdl_dock_object_thaw (object);
+    }
+    if (GDL_DOCK_OBJECT_ATTACHED (object)) {
+        /* detach ourselves */
+        gdl_dock_object_detach (object, FALSE);
+    }
+    
+    /* finally unbind us */
+    if (object-&gt;master)
+        gdl_dock_object_unbind (object);
+        
+    GNOME_CALL_PARENT (GTK_OBJECT_CLASS, destroy, (gtk_object));
+}
+
+static void
+gdl_dock_object_foreach_automatic (GdlDockObject *object,
+                                   gpointer       user_data)
+{
+    void (* function) (GtkWidget *) = user_data;
+
+    if (GDL_DOCK_OBJECT_AUTOMATIC (object))
+        (* function) (GTK_WIDGET (object));
+}
+
+static void
+gdl_dock_object_show (GtkWidget *widget)
+{
+    if (gdl_dock_object_is_compound (GDL_DOCK_OBJECT (widget))) {
+        gtk_container_foreach (GTK_CONTAINER (widget),
+                               (GtkCallback) gdl_dock_object_foreach_automatic,
+                               gtk_widget_show);
+    }
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, show, (widget));
+}
+
+static void
+gdl_dock_object_hide (GtkWidget *widget)
+{
+    if (gdl_dock_object_is_compound (GDL_DOCK_OBJECT (widget))) {
+        gtk_container_foreach (GTK_CONTAINER (widget),
+                               (GtkCallback) gdl_dock_object_foreach_automatic,
+                               gtk_widget_hide);
+    }
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, hide, (widget));
+}
+
+static void
+gdl_dock_object_real_detach (GdlDockObject *object,
+                             gboolean       recursive)
+{
+    GdlDockObject *parent;
+    GtkWidget     *widget;
+    
+    g_return_if_fail (object != NULL);
+
+    /* detach children */
+    if (recursive &amp;&amp; gdl_dock_object_is_compound (object)) {
+        gtk_container_foreach (GTK_CONTAINER (object),
+                               (GtkCallback) gdl_dock_object_detach,
+                               (gpointer) recursive);
+    }
+    
+    /* detach the object itself */
+    GDL_DOCK_OBJECT_UNSET_FLAGS (object, GDL_DOCK_ATTACHED);
+    parent = gdl_dock_object_get_parent_object (object);
+    widget = GTK_WIDGET (object);
+    if (widget-&gt;parent)
+        gtk_container_remove (GTK_CONTAINER (widget-&gt;parent), widget);
+    if (parent)
+        gdl_dock_object_reduce (parent);
+}
+
+static void
+gdl_dock_object_real_reduce (GdlDockObject *object)
+{
+    GdlDockObject *parent;
+    GList         *children;
+    
+    g_return_if_fail (object != NULL);
+
+    if (!gdl_dock_object_is_compound (object))
+        return;
+
+    parent = gdl_dock_object_get_parent_object (object);
+    children = gtk_container_get_children (GTK_CONTAINER (object));
+    if (g_list_length (children) &lt;= 1) {
+        GList *l;
+        
+        /* detach ourselves and then re-attach our children to our
+           current parent.  if we are not currently attached, the
+           children are detached */
+        if (parent)
+            gdl_dock_object_freeze (parent);
+        gdl_dock_object_freeze (object);
+        gdl_dock_object_detach (object, FALSE);
+        for (l = children; l; l = l-&gt;next) {
+            GdlDockObject *child = GDL_DOCK_OBJECT (l-&gt;data);
+
+            g_object_ref (child);
+            GDL_DOCK_OBJECT_SET_FLAGS (child, GDL_DOCK_IN_REFLOW);
+            gdl_dock_object_detach (child, FALSE);
+            if (parent)
+                gtk_container_add (GTK_CONTAINER (parent), GTK_WIDGET (child));
+            GDL_DOCK_OBJECT_UNSET_FLAGS (child, GDL_DOCK_IN_REFLOW);
+            g_object_unref (child);
+        }
+        /* sink the widget, so any automatic floating widget is destroyed */
+        gtk_object_sink (GTK_OBJECT (object));
+        /* don't reenter */
+        object-&gt;reduce_pending = FALSE;
+        gdl_dock_object_thaw (object);
+        if (parent)
+            gdl_dock_object_thaw (parent);
+    }
+    g_list_free (children);
+}
+
+static void
+gdl_dock_object_dock_unimplemented (GdlDockObject    *object,
+                                    GdlDockObject    *requestor,
+                                    GdlDockPlacement  position,
+                                    GValue           *other_data)
+{
+    g_warning (_(&quot;Call to gdl_dock_object_dock in a dock object %p &quot;
+                 &quot;(object type is %s) which hasn't implemented this method&quot;),
+               object, G_OBJECT_TYPE_NAME (object));
+}
+
+static void 
+gdl_dock_object_real_present (GdlDockObject *object,
+                              GdlDockObject *child)
+{
+    gtk_widget_show (GTK_WIDGET (object));
+}
+
+
+/* ----- Public interface ----- */
+
+gboolean
+gdl_dock_object_is_compound (GdlDockObject *object)
+{
+    GdlDockObjectClass *klass;
+
+    g_return_val_if_fail (object != NULL, FALSE);
+    g_return_val_if_fail (GDL_IS_DOCK_OBJECT (object), FALSE);
+
+    klass = GDL_DOCK_OBJECT_GET_CLASS (object);
+    return klass-&gt;is_compound;
+}
+
+void
+gdl_dock_object_detach (GdlDockObject *object,
+                        gboolean       recursive)
+{
+    g_return_if_fail (object != NULL);
+
+    if (!GDL_DOCK_OBJECT_ATTACHED (object))
+        return;
+    
+    /* freeze the object to avoid reducing while detaching children */
+    gdl_dock_object_freeze (object);
+    GDL_DOCK_OBJECT_SET_FLAGS (object, GDL_DOCK_IN_DETACH);
+    g_signal_emit (object, gdl_dock_object_signals [DETACH], 0, recursive);
+    GDL_DOCK_OBJECT_UNSET_FLAGS (object, GDL_DOCK_IN_DETACH);
+    gdl_dock_object_thaw (object);
+}
+
+GdlDockObject *
+gdl_dock_object_get_parent_object (GdlDockObject *object)
+{
+    GtkWidget *parent;
+    
+    g_return_val_if_fail (object != NULL, NULL);
+
+    parent = GTK_WIDGET (object)-&gt;parent;
+    while (parent &amp;&amp; !GDL_IS_DOCK_OBJECT (parent)) {
+        parent = parent-&gt;parent;
+    }
+    
+    return parent ? GDL_DOCK_OBJECT (parent) : NULL;
+}
+
+void
+gdl_dock_object_freeze (GdlDockObject *object)
+{
+    g_return_if_fail (object != NULL);
+    
+    if (object-&gt;freeze_count == 0) {
+        g_object_ref (object);   /* dock objects shouldn't be
+                                    destroyed if they are frozen */
+    }
+    object-&gt;freeze_count++;
+}
+
+void
+gdl_dock_object_thaw (GdlDockObject *object)
+{
+    g_return_if_fail (object != NULL);
+    g_return_if_fail (object-&gt;freeze_count &gt; 0);
+    
+    object-&gt;freeze_count--;
+    if (object-&gt;freeze_count == 0) {
+        if (object-&gt;reduce_pending) {
+            object-&gt;reduce_pending = FALSE;
+            gdl_dock_object_reduce (object);
+        }
+        g_object_unref (object);
+    }
+}
+
+void
+gdl_dock_object_reduce (GdlDockObject *object)
+{
+    g_return_if_fail (object != NULL);
+
+    if (GDL_DOCK_OBJECT_FROZEN (object)) {
+        object-&gt;reduce_pending = TRUE;
+        return;
+    }
+
+    GDL_CALL_VIRTUAL (object, GDL_DOCK_OBJECT_GET_CLASS, reduce, (object));
+}
+
+gboolean
+gdl_dock_object_dock_request (GdlDockObject  *object,
+                              gint            x,
+                              gint            y,
+                              GdlDockRequest *request)
+{
+    g_return_val_if_fail (object != NULL &amp;&amp; request != NULL, FALSE);
+    
+    return GDL_CALL_VIRTUAL_WITH_DEFAULT (object,
+                                          GDL_DOCK_OBJECT_GET_CLASS,
+                                          dock_request,
+                                          (object, x, y, request),
+                                          FALSE);
+}
+
+void
+gdl_dock_object_dock (GdlDockObject    *object,
+                      GdlDockObject    *requestor,
+                      GdlDockPlacement  position,
+                      GValue           *other_data)
+{
+    GdlDockObject *parent;
+    
+    g_return_if_fail (object != NULL &amp;&amp; requestor != NULL);
+        
+    if (object == requestor)
+        return;
+    
+    if (!object-&gt;master)
+        g_warning (_(&quot;Dock operation requested in a non-bound object %p. &quot;
+                     &quot;The application might crash&quot;), object);
+        
+    if (!gdl_dock_object_is_bound (requestor))
+        gdl_dock_object_bind (requestor, object-&gt;master);
+
+    if (requestor-&gt;master != object-&gt;master) {
+        g_warning (_(&quot;Cannot dock %p to %p because they belong to different masters&quot;),
+                   requestor, object);
+        return;
+    }
+
+    /* first, see if we can optimize things by reordering */
+    if (position != GDL_DOCK_NONE) {
+        parent = gdl_dock_object_get_parent_object (object);
+        if (gdl_dock_object_reorder (object, requestor, position, other_data) ||
+            (parent &amp;&amp; gdl_dock_object_reorder (parent, requestor, position, other_data)))
+            return;
+    }
+    
+    /* freeze the object, since under some conditions it might be destroyed when
+       detaching the requestor */
+    gdl_dock_object_freeze (object);
+
+    /* detach the requestor before docking */
+    g_object_ref (requestor);
+    if (GDL_DOCK_OBJECT_ATTACHED (requestor))
+        gdl_dock_object_detach (requestor, FALSE);
+    
+    if (position != GDL_DOCK_NONE)
+        g_signal_emit (object, gdl_dock_object_signals [DOCK], 0,
+                       requestor, position, other_data);
+
+    g_object_unref (requestor);
+    gdl_dock_object_thaw (object);
+}
+
+void
+gdl_dock_object_bind (GdlDockObject *object,
+                      GObject       *master)
+{
+    g_return_if_fail (object != NULL &amp;&amp; master != NULL);
+    g_return_if_fail (GDL_IS_DOCK_MASTER (master));
+    
+    if (object-&gt;master == master)
+        /* nothing to do here */
+        return;
+    
+    if (object-&gt;master) {
+        g_warning (_(&quot;Attempt to bind to %p an already bound dock object %p &quot;
+                     &quot;(current master: %p)&quot;), master, object, object-&gt;master);
+        return;
+    }
+
+    gdl_dock_master_add (GDL_DOCK_MASTER (master), object);
+    object-&gt;master = master;
+    g_object_add_weak_pointer (master, (gpointer *) &amp;object-&gt;master);
+
+    g_object_notify (G_OBJECT (object), &quot;master&quot;);
+}
+
+void
+gdl_dock_object_unbind (GdlDockObject *object)
+{
+    g_return_if_fail (object != NULL);
+
+    g_object_ref (object);
+
+    /* detach the object first */
+    if (GDL_DOCK_OBJECT_ATTACHED (object))
+        gdl_dock_object_detach (object, TRUE);
+    
+    if (object-&gt;master) {
+        GObject *master = object-&gt;master;
+        g_object_remove_weak_pointer (master, (gpointer *) &amp;object-&gt;master);
+        object-&gt;master = NULL;
+        gdl_dock_master_remove (GDL_DOCK_MASTER (master), object);
+        g_object_notify (G_OBJECT (object), &quot;master&quot;);
+    }
+    g_object_unref (object);
+}
+
+gboolean
+gdl_dock_object_is_bound (GdlDockObject *object)
+{
+    g_return_val_if_fail (object != NULL, FALSE);
+    return (object-&gt;master != NULL);
+}
+
+gboolean
+gdl_dock_object_reorder (GdlDockObject    *object,
+                         GdlDockObject    *child,
+                         GdlDockPlacement  new_position,
+                         GValue           *other_data)
+{
+    g_return_val_if_fail (object != NULL &amp;&amp; child != NULL, FALSE);
+
+    return GDL_CALL_VIRTUAL_WITH_DEFAULT (object,
+                                          GDL_DOCK_OBJECT_GET_CLASS,
+                                          reorder,
+                                          (object, child, new_position, other_data),
+                                          FALSE);
+}
+
+void 
+gdl_dock_object_present (GdlDockObject *object,
+                         GdlDockObject *child)
+{
+    GdlDockObject *parent;
+    
+    g_return_if_fail (object != NULL &amp;&amp; GDL_IS_DOCK_OBJECT (object));
+
+    parent = gdl_dock_object_get_parent_object (object);
+    if (parent)
+        /* chain the call to our parent */
+        gdl_dock_object_present (parent, object);
+
+    GDL_CALL_VIRTUAL (object, GDL_DOCK_OBJECT_GET_CLASS, present, (object, child));
+}
+
+/**
+ * gdl_dock_object_child_placement:
+ * @object: the dock object we are asking for child placement
+ * @child: the child of the @object we want the placement for
+ * @placement: where to return the placement information
+ *
+ * This function returns information about placement of a child dock
+ * object inside another dock object.  The function returns %TRUE if
+ * @child is effectively a child of @object.  @placement should
+ * normally be initially setup to %GDL_DOCK_NONE.  If it's set to some
+ * other value, this function will not touch the stored value if the
+ * specified placement is &quot;compatible&quot; with the actual placement of
+ * the child.
+ *
+ * @placement can be %NULL, in which case the function simply tells if
+ * @child is attached to @object.
+ *
+ * Returns: %TRUE if @child is a child of @object.
+ */
+gboolean 
+gdl_dock_object_child_placement (GdlDockObject    *object,
+                                 GdlDockObject    *child,
+                                 GdlDockPlacement *placement)
+{
+    g_return_val_if_fail (object != NULL &amp;&amp; child != NULL, FALSE);
+
+    /* simple case */
+    if (!gdl_dock_object_is_compound (object))
+        return FALSE;
+    
+    return GDL_CALL_VIRTUAL_WITH_DEFAULT (object, GDL_DOCK_OBJECT_GET_CLASS,
+                                          child_placement,
+                                          (object, child, placement),
+                                          FALSE);
+}
+
+
+/* ----- dock param type functions start here ------ */
+
+static void 
+gdl_dock_param_export_int (const GValue *src,
+                           GValue       *dst)
+{
+    dst-&gt;data [0].v_pointer = g_strdup_printf (&quot;%d&quot;, src-&gt;data [0].v_int);
+}
+
+static void 
+gdl_dock_param_export_uint (const GValue *src,
+                            GValue       *dst)
+{
+    dst-&gt;data [0].v_pointer = g_strdup_printf (&quot;%u&quot;, src-&gt;data [0].v_uint);
+}
+
+static void 
+gdl_dock_param_export_string (const GValue *src,
+                              GValue       *dst)
+{
+    dst-&gt;data [0].v_pointer = g_strdup (src-&gt;data [0].v_pointer);
+}
+
+static void 
+gdl_dock_param_export_bool (const GValue *src,
+                            GValue       *dst)
+{
+    dst-&gt;data [0].v_pointer = g_strdup_printf (&quot;%s&quot;, src-&gt;data [0].v_int ? &quot;yes&quot; : &quot;no&quot;);
+}
+
+static void 
+gdl_dock_param_export_placement (const GValue *src,
+                                 GValue       *dst)
+{
+    switch (src-&gt;data [0].v_int) {
+        case GDL_DOCK_NONE:
+            dst-&gt;data [0].v_pointer = g_strdup (&quot;&quot;);
+            break;
+        case GDL_DOCK_TOP:
+            dst-&gt;data [0].v_pointer = g_strdup (&quot;top&quot;);
+            break;
+        case GDL_DOCK_BOTTOM:
+            dst-&gt;data [0].v_pointer = g_strdup (&quot;bottom&quot;);
+            break;
+        case GDL_DOCK_LEFT:
+            dst-&gt;data [0].v_pointer = g_strdup (&quot;left&quot;);
+            break;
+        case GDL_DOCK_RIGHT:
+            dst-&gt;data [0].v_pointer = g_strdup (&quot;right&quot;);
+            break;
+        case GDL_DOCK_CENTER:
+            dst-&gt;data [0].v_pointer = g_strdup (&quot;center&quot;);
+            break;
+        case GDL_DOCK_FLOATING:
+            dst-&gt;data [0].v_pointer = g_strdup (&quot;floating&quot;);
+            break;
+    }
+}
+
+static void 
+gdl_dock_param_import_int (const GValue *src,
+                           GValue       *dst)
+{
+    dst-&gt;data [0].v_int = atoi (src-&gt;data [0].v_pointer);
+}
+
+static void 
+gdl_dock_param_import_uint (const GValue *src,
+                            GValue       *dst)
+{
+    dst-&gt;data [0].v_uint = (guint) atoi (src-&gt;data [0].v_pointer);
+}
+
+static void 
+gdl_dock_param_import_string (const GValue *src,
+                              GValue       *dst)
+{
+    dst-&gt;data [0].v_pointer = g_strdup (src-&gt;data [0].v_pointer);
+}
+
+static void 
+gdl_dock_param_import_bool (const GValue *src,
+                            GValue       *dst)
+{
+    dst-&gt;data [0].v_int = !strcmp (src-&gt;data [0].v_pointer, &quot;yes&quot;);
+}
+
+static void 
+gdl_dock_param_import_placement (const GValue *src,
+                                 GValue       *dst)
+{
+    if (!strcmp (src-&gt;data [0].v_pointer, &quot;top&quot;))
+        dst-&gt;data [0].v_int = GDL_DOCK_TOP;
+    else if (!strcmp (src-&gt;data [0].v_pointer, &quot;bottom&quot;))
+        dst-&gt;data [0].v_int = GDL_DOCK_BOTTOM;
+    else if (!strcmp (src-&gt;data [0].v_pointer, &quot;center&quot;))
+        dst-&gt;data [0].v_int = GDL_DOCK_CENTER;
+    else if (!strcmp (src-&gt;data [0].v_pointer, &quot;left&quot;))
+        dst-&gt;data [0].v_int = GDL_DOCK_LEFT;
+    else if (!strcmp (src-&gt;data [0].v_pointer, &quot;right&quot;))
+        dst-&gt;data [0].v_int = GDL_DOCK_RIGHT;
+    else if (!strcmp (src-&gt;data [0].v_pointer, &quot;floating&quot;))
+        dst-&gt;data [0].v_int = GDL_DOCK_FLOATING;
+    else
+        dst-&gt;data [0].v_int = GDL_DOCK_NONE;
+}
+
+GType
+gdl_dock_param_get_type (void)
+{
+    static GType our_type = 0;
+
+    if (our_type == 0) {
+        GTypeInfo tinfo = { 0, };
+        our_type = g_type_register_static (G_TYPE_STRING, &quot;GdlDockParam&quot;, &amp;tinfo, 0);
+
+        /* register known transform functions */
+        /* exporters */
+        g_value_register_transform_func (G_TYPE_INT, our_type, gdl_dock_param_export_int);
+        g_value_register_transform_func (G_TYPE_UINT, our_type, gdl_dock_param_export_uint);
+        g_value_register_transform_func (G_TYPE_STRING, our_type, gdl_dock_param_export_string);
+        g_value_register_transform_func (G_TYPE_BOOLEAN, our_type, gdl_dock_param_export_bool);
+        g_value_register_transform_func (GDL_TYPE_DOCK_PLACEMENT, our_type, gdl_dock_param_export_placement);
+        /* importers */
+        g_value_register_transform_func (our_type, G_TYPE_INT, gdl_dock_param_import_int);
+        g_value_register_transform_func (our_type, G_TYPE_UINT, gdl_dock_param_import_uint);
+        g_value_register_transform_func (our_type, G_TYPE_STRING, gdl_dock_param_import_string);
+        g_value_register_transform_func (our_type, G_TYPE_BOOLEAN, gdl_dock_param_import_bool);
+        g_value_register_transform_func (our_type, GDL_TYPE_DOCK_PLACEMENT, gdl_dock_param_import_placement);
+    }
+
+    return our_type;
+}
+
+/* -------------- nick &lt;-&gt; type conversion functions --------------- */
+
+static GRelation *dock_register = NULL;
+
+enum {
+    INDEX_NICK = 0,
+    INDEX_TYPE
+};
+
+static void
+gdl_dock_object_register_init (void)
+{
+    if (dock_register)
+        return;
+    
+    /* FIXME: i don't know if GRelation is efficient */
+    dock_register = g_relation_new (2);
+    g_relation_index (dock_register, INDEX_NICK, g_str_hash, g_str_equal);
+    g_relation_index (dock_register, INDEX_TYPE, g_direct_hash, g_direct_equal);
+
+    /* add known types */
+    g_relation_insert (dock_register, &quot;dock&quot;, (gpointer) GDL_TYPE_DOCK);
+    g_relation_insert (dock_register, &quot;item&quot;, (gpointer) GDL_TYPE_DOCK_ITEM);
+    g_relation_insert (dock_register, &quot;paned&quot;, (gpointer) GDL_TYPE_DOCK_PANED);
+    g_relation_insert (dock_register, &quot;notebook&quot;, (gpointer) GDL_TYPE_DOCK_NOTEBOOK);
+    g_relation_insert (dock_register, &quot;placeholder&quot;, (gpointer) GDL_TYPE_DOCK_PLACEHOLDER);
+}
+
+G_CONST_RETURN gchar *
+gdl_dock_object_nick_from_type (GType type)
+{
+    GTuples *tuples;
+    gchar *nick = NULL;
+    
+    if (!dock_register)
+        gdl_dock_object_register_init ();
+
+    if (g_relation_count (dock_register, (gpointer) type, INDEX_TYPE) &gt; 0) {
+        tuples = g_relation_select (dock_register, (gpointer) type, INDEX_TYPE);
+        nick = (gchar *) g_tuples_index (tuples, 0, INDEX_NICK);
+        g_tuples_destroy (tuples);
+    }
+    
+    return nick ? nick : g_type_name (type);
+}
+
+GType
+gdl_dock_object_type_from_nick (const gchar *nick)
+{
+    GTuples *tuples;
+    GType type = G_TYPE_NONE;
+    
+    if (!dock_register)
+        gdl_dock_object_register_init ();
+
+    if (g_relation_count (dock_register, (gpointer) nick, INDEX_NICK) &gt; 0) {
+        tuples = g_relation_select (dock_register, (gpointer) nick, INDEX_NICK);
+        type = (GType) g_tuples_index (tuples, 0, INDEX_TYPE);
+        g_tuples_destroy (tuples);
+    }
+    else {
+        /* try searching in the glib type system */
+        type = g_type_from_name (nick);
+    }
+    
+    return type;
+}
+
+GType
+gdl_dock_object_set_type_for_nick (const gchar *nick,
+                                   GType        type)
+{
+    GType old_type = G_TYPE_NONE;
+    
+    if (!dock_register)
+        gdl_dock_object_register_init ();
+
+    g_return_val_if_fail (g_type_is_a (type, GDL_TYPE_DOCK_OBJECT), G_TYPE_NONE);
+    
+    if (g_relation_count (dock_register, (gpointer) nick, INDEX_NICK) &gt; 0) {
+        old_type = gdl_dock_object_type_from_nick (nick);
+        g_relation_delete (dock_register, (gpointer) nick, INDEX_NICK);
+    }
+    
+    g_relation_insert (dock_register, nick, type);
+
+    return old_type;
+}
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,224 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * gdl-dock-object.h - Abstract base class for all dock related objects
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifndef __GDL_DOCK_OBJECT_H__
+#define __GDL_DOCK_OBJECT_H__
+
+#include &lt;gtk/gtkcontainer.h&gt;
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK_OBJECT             (gdl_dock_object_get_type ())
+#define GDL_DOCK_OBJECT(obj)             (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_OBJECT, GdlDockObject))
+#define GDL_DOCK_OBJECT_CLASS(klass)     (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_OBJECT, GdlDockObjectClass))
+#define GDL_IS_DOCK_OBJECT(obj)          (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_OBJECT))
+#define GDL_IS_DOCK_OBJECT_CLASS(klass)  (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_OBJECT))
+#define GDL_DOCK_OBJECT_GET_CLASS(obj)   (GTK_CHECK_GET_CLASS ((obj), GTK_TYPE_DOCK_OBJECT, GdlDockObjectClass))
+
+/* data types &amp; structures */
+typedef enum {
+    /* the parameter is to be exported for later layout rebuilding */
+    GDL_DOCK_PARAM_EXPORT = 1 &lt;&lt; G_PARAM_USER_SHIFT,
+    /* the parameter must be set after adding the children objects */
+    GDL_DOCK_PARAM_AFTER  = 1 &lt;&lt; (G_PARAM_USER_SHIFT + 1)
+} GdlDockParamFlags;
+
+#define GDL_DOCK_NAME_PROPERTY    &quot;name&quot;
+#define GDL_DOCK_MASTER_PROPERTY  &quot;master&quot;
+
+typedef enum {
+    GDL_DOCK_AUTOMATIC  = 1 &lt;&lt; 0,
+    GDL_DOCK_ATTACHED   = 1 &lt;&lt; 1,
+    GDL_DOCK_IN_REFLOW  = 1 &lt;&lt; 2,
+    GDL_DOCK_IN_DETACH  = 1 &lt;&lt; 3
+} GdlDockObjectFlags;
+
+#define GDL_DOCK_OBJECT_FLAGS_SHIFT 8
+
+typedef enum {
+    GDL_DOCK_NONE = 0,
+    GDL_DOCK_TOP,
+    GDL_DOCK_BOTTOM,
+    GDL_DOCK_RIGHT,
+    GDL_DOCK_LEFT,
+    GDL_DOCK_CENTER,
+    GDL_DOCK_FLOATING
+} GdlDockPlacement;
+
+typedef struct _GdlDockObject      GdlDockObject;
+typedef struct _GdlDockObjectClass GdlDockObjectClass;
+typedef struct _GdlDockRequest     GdlDockRequest;
+
+struct _GdlDockRequest {
+    GdlDockObject    *applicant;
+    GdlDockObject    *target;
+    GdlDockPlacement  position;
+    GdkRectangle      rect;
+    GValue            extra;
+};
+
+struct _GdlDockObject {
+    GtkContainer        container;
+
+    GdlDockObjectFlags  flags;
+    gint                freeze_count;
+    
+    GObject            *master;
+    gchar              *name;
+    gchar              *long_name;
+    
+    gboolean            reduce_pending;
+};
+
+struct _GdlDockObjectClass {
+    GtkContainerClass parent_class;
+
+    gboolean          is_compound;
+    
+    void     (* detach)          (GdlDockObject    *object,
+                                  gboolean          recursive);
+    void     (* reduce)          (GdlDockObject    *object);
+
+    gboolean (* dock_request)    (GdlDockObject    *object,
+                                  gint              x,
+                                  gint              y,
+                                  GdlDockRequest   *request);
+
+    void     (* dock)            (GdlDockObject    *object,
+                                  GdlDockObject    *requestor,
+                                  GdlDockPlacement  position,
+                                  GValue           *other_data);
+    
+    gboolean (* reorder)         (GdlDockObject    *object,
+                                  GdlDockObject    *child,
+                                  GdlDockPlacement  new_position,
+                                  GValue           *other_data);
+
+    void     (* present)         (GdlDockObject    *object,
+                                  GdlDockObject    *child);
+
+    gboolean (* child_placement) (GdlDockObject    *object,
+                                  GdlDockObject    *child,
+                                  GdlDockPlacement *placement);
+};
+
+/* additional macros */
+#define GDL_DOCK_OBJECT_FLAGS(obj)  (GDL_DOCK_OBJECT (obj)-&gt;flags)
+#define GDL_DOCK_OBJECT_AUTOMATIC(obj) \
+    ((GDL_DOCK_OBJECT_FLAGS (obj) &amp; GDL_DOCK_AUTOMATIC) != 0)
+#define GDL_DOCK_OBJECT_ATTACHED(obj) \
+    ((GDL_DOCK_OBJECT_FLAGS (obj) &amp; GDL_DOCK_ATTACHED) != 0)
+#define GDL_DOCK_OBJECT_IN_REFLOW(obj) \
+    ((GDL_DOCK_OBJECT_FLAGS (obj) &amp; GDL_DOCK_IN_REFLOW) != 0)
+#define GDL_DOCK_OBJECT_IN_DETACH(obj) \
+    ((GDL_DOCK_OBJECT_FLAGS (obj) &amp; GDL_DOCK_IN_DETACH) != 0)
+
+#define GDL_DOCK_OBJECT_SET_FLAGS(obj,flag) \
+    G_STMT_START { (GDL_DOCK_OBJECT_FLAGS (obj) |= (flag)); } G_STMT_END
+#define GDL_DOCK_OBJECT_UNSET_FLAGS(obj,flag) \
+    G_STMT_START { (GDL_DOCK_OBJECT_FLAGS (obj) &amp;= ~(flag)); } G_STMT_END
+ 
+#define GDL_DOCK_OBJECT_FROZEN(obj) (GDL_DOCK_OBJECT (obj)-&gt;freeze_count &gt; 0)
+
+
+/* public interface */
+ 
+GType          gdl_dock_object_get_type          (void);
+
+gboolean       gdl_dock_object_is_compound       (GdlDockObject    *object);
+
+void           gdl_dock_object_detach            (GdlDockObject    *object,
+                                                  gboolean          recursive);
+
+GdlDockObject *gdl_dock_object_get_parent_object (GdlDockObject    *object);
+
+void           gdl_dock_object_freeze            (GdlDockObject    *object);
+void           gdl_dock_object_thaw              (GdlDockObject    *object);
+
+void           gdl_dock_object_reduce            (GdlDockObject    *object);
+
+gboolean       gdl_dock_object_dock_request      (GdlDockObject    *object,
+                                                  gint              x,
+                                                  gint              y,
+                                                  GdlDockRequest   *request);
+void           gdl_dock_object_dock              (GdlDockObject    *object,
+                                                  GdlDockObject    *requestor,
+                                                  GdlDockPlacement  position,
+                                                  GValue           *other_data);
+
+void           gdl_dock_object_bind              (GdlDockObject    *object,
+                                                  GObject          *master);
+void           gdl_dock_object_unbind            (GdlDockObject    *object);
+gboolean       gdl_dock_object_is_bound          (GdlDockObject    *object);
+
+gboolean       gdl_dock_object_reorder           (GdlDockObject    *object,
+                                                  GdlDockObject    *child,
+                                                  GdlDockPlacement  new_position,
+                                                  GValue           *other_data);
+
+void           gdl_dock_object_present           (GdlDockObject    *object,
+                                                  GdlDockObject    *child);
+
+gboolean       gdl_dock_object_child_placement   (GdlDockObject    *object,
+                                                  GdlDockObject    *child,
+                                                  GdlDockPlacement *placement);
+
+/* other types */
+
+/* this type derives from G_TYPE_STRING and is meant to be the basic
+   type for serializing object parameters which are exported
+   (i.e. those that are needed for layout rebuilding) */
+#define GDL_TYPE_DOCK_PARAM   (gdl_dock_param_get_type ())
+
+GType gdl_dock_param_get_type (void);
+
+/* functions for setting/retrieving nick names for serializing GdlDockObject types */
+G_CONST_RETURN gchar *gdl_dock_object_nick_from_type    (GType        type);
+GType                 gdl_dock_object_type_from_nick    (const gchar *nick);
+GType                 gdl_dock_object_set_type_for_nick (const gchar *nick,
+                                                         GType        type);
+
+
+/* helper macros */
+#define GDL_TRACE_OBJECT(object, format, args...) \
+    G_STMT_START {                            \
+    g_log (G_LOG_DOMAIN,                      \
+	   G_LOG_LEVEL_DEBUG,                 \
+           &quot;%s:%d (%s) %s [%p %d%s:%d]: &quot;format, \
+	   __FILE__,                          \
+	   __LINE__,                          \
+	   __PRETTY_FUNCTION__,               \
+           G_OBJECT_TYPE_NAME (object), object, \
+           G_OBJECT (object)-&gt;ref_count, \
+           (GTK_IS_OBJECT (object) &amp;&amp; GTK_OBJECT_FLOATING (object)) ? &quot;(float)&quot; : &quot;&quot;, \
+           GDL_IS_DOCK_OBJECT (object) ? GDL_DOCK_OBJECT (object)-&gt;freeze_count : -1, \
+	   ##args); } G_STMT_END                   
+    
+
+
+G_END_DECLS
+
+#endif  /* __GDL_DOCK_OBJECT_H__ */
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-paned.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-paned.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-paned.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,663 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * gdl-dock-paned.h
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;string.h&gt;
+#include &lt;gtk/gtkhpaned.h&gt;
+#include &lt;gtk/gtkvpaned.h&gt;
+#include &lt;libgnome/gnome-macros.h&gt;
+
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock-paned.h&quot;
+
+
+/* Private prototypes */
+
+static void     gdl_dock_paned_class_init     (GdlDockPanedClass *klass);
+static void     gdl_dock_paned_instance_init  (GdlDockPaned      *paned);
+static GObject *gdl_dock_paned_constructor    (GType              type,
+                                               guint              n_construct_properties,
+                                               GObjectConstructParam *construct_param);
+static void     gdl_dock_paned_set_property   (GObject           *object,
+                                               guint              prop_id,
+                                               const GValue      *value,
+                                               GParamSpec        *pspec);
+static void     gdl_dock_paned_get_property   (GObject           *object,
+                                               guint              prop_id,
+                                               GValue            *value,
+                                               GParamSpec        *pspec);
+
+static void     gdl_dock_paned_destroy        (GtkObject         *object);
+
+static void     gdl_dock_paned_add            (GtkContainer      *container,
+                                               GtkWidget         *widget);
+static void     gdl_dock_paned_forall         (GtkContainer      *container,
+                                               gboolean           include_internals,
+                                               GtkCallback        callback,
+                                               gpointer           callback_data);
+static GType    gdl_dock_paned_child_type     (GtkContainer      *container);
+
+static gboolean gdl_dock_paned_dock_request   (GdlDockObject     *object, 
+                                               gint               x,
+                                               gint               y, 
+                                               GdlDockRequest    *request);
+static void     gdl_dock_paned_dock           (GdlDockObject    *object,
+                                               GdlDockObject    *requestor,
+                                               GdlDockPlacement  position,
+                                               GValue           *other_data);
+
+static void     gdl_dock_paned_set_orientation (GdlDockItem    *item,
+                                                GtkOrientation  orientation);
+
+static gboolean gdl_dock_paned_child_placement (GdlDockObject    *object,
+                                                GdlDockObject    *child,
+                                                GdlDockPlacement *placement);
+
+
+/* ----- Class variables and definitions ----- */
+
+#define SPLIT_RATIO  0.3
+
+enum {
+    PROP_0,
+    PROP_POSITION
+};
+
+
+/* ----- Private functions ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDockPaned, gdl_dock_paned, GdlDockItem, GDL_TYPE_DOCK_ITEM);
+
+static void
+gdl_dock_paned_class_init (GdlDockPanedClass *klass)
+{
+    GObjectClass       *g_object_class;
+    GtkObjectClass     *gtk_object_class;
+    GtkWidgetClass     *widget_class;
+    GtkContainerClass  *container_class;
+    GdlDockObjectClass *object_class;
+    GdlDockItemClass   *item_class;
+
+    g_object_class = G_OBJECT_CLASS (klass);
+    gtk_object_class = GTK_OBJECT_CLASS (klass);
+    widget_class = GTK_WIDGET_CLASS (klass);
+    container_class = GTK_CONTAINER_CLASS (klass);
+    object_class = GDL_DOCK_OBJECT_CLASS (klass);
+    item_class = GDL_DOCK_ITEM_CLASS (klass);
+
+    g_object_class-&gt;set_property = gdl_dock_paned_set_property;
+    g_object_class-&gt;get_property = gdl_dock_paned_get_property;
+    g_object_class-&gt;constructor = gdl_dock_paned_constructor;
+    
+    gtk_object_class-&gt;destroy = gdl_dock_paned_destroy;
+
+    container_class-&gt;add = gdl_dock_paned_add;
+    container_class-&gt;forall = gdl_dock_paned_forall;
+    container_class-&gt;child_type = gdl_dock_paned_child_type;
+    
+    object_class-&gt;is_compound = TRUE;
+    
+    object_class-&gt;dock_request = gdl_dock_paned_dock_request;
+    object_class-&gt;dock = gdl_dock_paned_dock;
+    object_class-&gt;child_placement = gdl_dock_paned_child_placement;
+    
+    item_class-&gt;has_grip = FALSE;
+    item_class-&gt;set_orientation = gdl_dock_paned_set_orientation;    
+
+    g_object_class_install_property (
+        g_object_class, PROP_POSITION,
+        g_param_spec_uint (&quot;position&quot;, _(&quot;Position&quot;),
+                           _(&quot;Position of the divider in pixels&quot;),
+                           0, G_MAXINT, 0,
+                           G_PARAM_READWRITE |
+                           GDL_DOCK_PARAM_EXPORT | GDL_DOCK_PARAM_AFTER));
+}
+
+static void
+gdl_dock_paned_instance_init (GdlDockPaned *paned)
+{
+    paned-&gt;position_changed = FALSE;
+}
+
+static void 
+gdl_dock_paned_notify_cb (GObject    *g_object,
+                          GParamSpec *pspec,
+                          gpointer    user_data) 
+{
+    GdlDockPaned *paned;
+    
+    g_return_if_fail (user_data != NULL &amp;&amp; GDL_IS_DOCK_PANED (user_data));
+    
+    /* chain the notification to the GdlDockPaned */
+    g_object_notify (G_OBJECT (user_data), pspec-&gt;name);
+    
+    paned = GDL_DOCK_PANED (user_data);
+    
+    if (GDL_DOCK_ITEM_USER_ACTION (user_data) &amp;&amp; !strcmp (pspec-&gt;name, &quot;position&quot;))
+        paned-&gt;position_changed = TRUE;
+}
+
+static gboolean 
+gdl_dock_paned_button_cb (GtkWidget      *widget,
+                          GdkEventButton *event,
+                          gpointer        user_data)
+{
+    GdlDockPaned *paned;
+    
+    g_return_val_if_fail (user_data != NULL &amp;&amp; GDL_IS_DOCK_PANED (user_data), FALSE);
+    
+    paned = GDL_DOCK_PANED (user_data);
+    if (event-&gt;button == 1) {
+        if (event-&gt;type == GDK_BUTTON_PRESS)
+            GDL_DOCK_ITEM_SET_FLAGS (user_data, GDL_DOCK_USER_ACTION);
+        else {
+            GDL_DOCK_ITEM_UNSET_FLAGS (user_data, GDL_DOCK_USER_ACTION);
+            if (paned-&gt;position_changed) {
+                /* emit pending layout changed signal to track separator position */
+                if (GDL_DOCK_OBJECT (paned)-&gt;master)
+                    g_signal_emit_by_name (GDL_DOCK_OBJECT (paned)-&gt;master, &quot;layout_changed&quot;);
+                paned-&gt;position_changed = FALSE;
+            }
+        }
+    }
+    
+    return FALSE;
+}
+
+static void 
+gdl_dock_paned_create_child (GdlDockPaned   *paned,
+                             GtkOrientation  orientation) 
+{
+    GdlDockItem *item;
+    
+    item = GDL_DOCK_ITEM (paned);
+    
+    if (item-&gt;child)
+        gtk_widget_unparent (GTK_WIDGET (item-&gt;child));
+    
+    /* create the container paned */
+    if (orientation == GTK_ORIENTATION_HORIZONTAL)
+        item-&gt;child = gtk_hpaned_new ();
+    else
+        item-&gt;child = gtk_vpaned_new ();
+    
+    /* get notification for propagation */
+    g_signal_connect (item-&gt;child, &quot;notify::position&quot;,
+                      (GCallback) gdl_dock_paned_notify_cb, (gpointer) item);
+    g_signal_connect (item-&gt;child, &quot;button-press-event&quot;,
+                      (GCallback) gdl_dock_paned_button_cb, (gpointer) item);
+    g_signal_connect (item-&gt;child, &quot;button-release-event&quot;,
+                      (GCallback) gdl_dock_paned_button_cb, (gpointer) item);
+    
+    gtk_widget_set_parent (item-&gt;child, GTK_WIDGET (item));
+    gtk_widget_show (item-&gt;child);
+}
+
+static GObject *
+gdl_dock_paned_constructor (GType                  type,
+                            guint                  n_construct_properties,
+                            GObjectConstructParam *construct_param)
+{
+    GObject *g_object;
+    
+    g_object = GNOME_CALL_PARENT_WITH_DEFAULT (G_OBJECT_CLASS, 
+                                               constructor, 
+                                               (type,
+                                                n_construct_properties,
+                                                construct_param),
+                                               NULL);
+    if (g_object) {
+        GdlDockItem *item = GDL_DOCK_ITEM (g_object);
+        
+        if (!item-&gt;child)
+            gdl_dock_paned_create_child (GDL_DOCK_PANED (g_object),
+                                         item-&gt;orientation);
+        /* otherwise, the orientation was set as a construction
+           parameter and the child is already created */
+    }
+    
+    return g_object;
+}
+
+static void
+gdl_dock_paned_set_property (GObject        *object,
+                             guint           prop_id,
+                             const GValue   *value,
+                             GParamSpec     *pspec)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+      
+    switch (prop_id) {
+        case PROP_POSITION:
+            if (item-&gt;child &amp;&amp; GTK_IS_PANED (item-&gt;child))
+                gtk_paned_set_position (GTK_PANED (item-&gt;child),
+                                        g_value_get_uint (value));
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_paned_get_property (GObject        *object,
+                             guint           prop_id,
+                             GValue         *value,
+                             GParamSpec     *pspec)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+      
+    switch (prop_id) {
+        case PROP_POSITION:
+            if (item-&gt;child &amp;&amp; GTK_IS_PANED (item-&gt;child))
+                g_value_set_uint (value,
+                                  gtk_paned_get_position (GTK_PANED (item-&gt;child)));
+            else
+                g_value_set_uint (value, 0);
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_paned_destroy (GtkObject *object)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (object);
+
+    /* we need to call the virtual first, since in GdlDockDestroy our
+       children dock objects are detached */
+    GNOME_CALL_PARENT (GTK_OBJECT_CLASS, destroy, (object));
+
+    /* after that we can remove the GtkNotebook */
+    if (item-&gt;child) {
+        gtk_widget_unparent (item-&gt;child);
+        item-&gt;child = NULL;
+    };
+}
+
+static void
+gdl_dock_paned_add (GtkContainer *container,
+                    GtkWidget    *widget)
+{
+    GdlDockItem     *item;
+    GtkPaned        *paned;
+    GdlDockPlacement pos = GDL_DOCK_NONE;
+    
+    g_return_if_fail (container != NULL &amp;&amp; widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK_PANED (container));
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+
+    item = GDL_DOCK_ITEM (container);
+    g_return_if_fail (item-&gt;child != NULL);
+    paned = GTK_PANED (item-&gt;child);
+    g_return_if_fail (!paned-&gt;child1 || !paned-&gt;child2);
+
+    if (!paned-&gt;child1)
+        pos = item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL ?
+            GDL_DOCK_LEFT : GDL_DOCK_TOP;
+    else if (!paned-&gt;child2)
+        pos = item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL ?
+            GDL_DOCK_RIGHT : GDL_DOCK_BOTTOM;
+
+    if (pos != GDL_DOCK_NONE)
+        gdl_dock_object_dock (GDL_DOCK_OBJECT (container),
+                              GDL_DOCK_OBJECT (widget),
+                              pos, NULL);
+}
+
+static void
+gdl_dock_paned_forall (GtkContainer *container,
+                       gboolean      include_internals,
+                       GtkCallback   callback,
+                       gpointer      callback_data)
+{
+    GdlDockItem *item;
+
+    g_return_if_fail (container != NULL);
+    g_return_if_fail (GDL_IS_DOCK_PANED (container));
+    g_return_if_fail (callback != NULL);
+
+    if (include_internals) {
+        /* use GdlDockItem's forall */
+        GNOME_CALL_PARENT (GTK_CONTAINER_CLASS, forall, 
+                           (container, include_internals, callback, callback_data));
+    }
+    else {
+        item = GDL_DOCK_ITEM (container);
+        if (item-&gt;child)
+            gtk_container_foreach (GTK_CONTAINER (item-&gt;child), callback, callback_data);
+    }
+}
+
+static GType
+gdl_dock_paned_child_type (GtkContainer *container)
+{
+    GdlDockItem *item = GDL_DOCK_ITEM (container);
+
+    if (gtk_container_child_type (GTK_CONTAINER (item-&gt;child)) == G_TYPE_NONE)
+        return G_TYPE_NONE;
+    else
+        return GDL_TYPE_DOCK_ITEM;
+}
+
+static void
+gdl_dock_paned_request_foreach (GdlDockObject *object,
+                                gpointer       user_data)
+{
+    struct {
+        gint            x, y;
+        GdlDockRequest *request;
+        gboolean        may_dock;
+    } *data = user_data;
+    
+    GdlDockRequest my_request;
+    gboolean       may_dock;
+    
+    my_request = *data-&gt;request;
+    may_dock = gdl_dock_object_dock_request (object, data-&gt;x, data-&gt;y, &amp;my_request);
+    if (may_dock) {
+        data-&gt;may_dock = TRUE;
+        *data-&gt;request = my_request;
+    }
+}
+
+static gboolean
+gdl_dock_paned_dock_request (GdlDockObject  *object, 
+                             gint            x,
+                             gint            y, 
+                             GdlDockRequest *request)
+{
+    GdlDockItem        *item;
+    guint               bw;
+    gint                rel_x, rel_y;
+    GtkAllocation      *alloc;
+    gboolean            may_dock = FALSE;
+    GdlDockRequest      my_request;
+
+    g_return_val_if_fail (GDL_IS_DOCK_ITEM (object), FALSE);
+
+    /* we get (x,y) in our allocation coordinates system */
+    
+    item = GDL_DOCK_ITEM (object);
+    
+    /* Get item's allocation. */
+    alloc = &amp;(GTK_WIDGET (object)-&gt;allocation);
+    bw = GTK_CONTAINER (object)-&gt;border_width;
+
+    /* Get coordinates relative to our window. */
+    rel_x = x - alloc-&gt;x;
+    rel_y = y - alloc-&gt;y;
+
+    if (request)
+        my_request = *request;
+        
+    /* Check if coordinates are inside the widget. */
+    if (rel_x &gt; 0 &amp;&amp; rel_x &lt; alloc-&gt;width &amp;&amp;
+        rel_y &gt; 0 &amp;&amp; rel_y &lt; alloc-&gt;height) {
+        GtkRequisition my, other;
+        gint divider = -1;
+        
+        gdl_dock_item_preferred_size (GDL_DOCK_ITEM (my_request.applicant), &amp;other);
+        gdl_dock_item_preferred_size (GDL_DOCK_ITEM (object), &amp;my);
+
+        /* It's inside our area. */
+        may_dock = TRUE;
+
+	/* Set docking indicator rectangle to the widget size. */
+        my_request.rect.x = bw;
+        my_request.rect.y = bw;
+        my_request.rect.width = alloc-&gt;width - 2*bw;
+        my_request.rect.height = alloc-&gt;height - 2*bw;
+
+        my_request.target = object;
+
+        /* See if it's in the border_width band. */
+        if (rel_x &lt; bw) {
+            my_request.position = GDL_DOCK_LEFT;
+            my_request.rect.width *= SPLIT_RATIO;
+            divider = other.width;
+        } else if (rel_x &gt; alloc-&gt;width - bw) {
+            my_request.position = GDL_DOCK_RIGHT;
+            my_request.rect.x += my_request.rect.width * (1 - SPLIT_RATIO);
+            my_request.rect.width *= SPLIT_RATIO;
+            divider = MAX (0, my.width - other.width);
+        } else if (rel_y &lt; bw) {
+            my_request.position = GDL_DOCK_TOP;
+            my_request.rect.height *= SPLIT_RATIO;
+            divider = other.height;
+        } else if (rel_y &gt; alloc-&gt;height - bw) {
+            my_request.position = GDL_DOCK_BOTTOM;
+            my_request.rect.y += my_request.rect.height * (1 - SPLIT_RATIO);
+            my_request.rect.height *= SPLIT_RATIO;
+            divider = MAX (0, my.height - other.height);
+            
+        } else { /* Otherwise try our children. */
+            struct {
+                gint            x, y;
+                GdlDockRequest *request;
+                gboolean        may_dock;
+            } data;
+
+            /* give them coordinates in their allocation system... the
+               GtkPaned has no window, so our children allocation
+               coordinates are our window coordinates */
+            data.x = rel_x;
+            data.y = rel_y;
+            data.request = &amp;my_request;
+            data.may_dock = FALSE;
+            
+            gtk_container_foreach (GTK_CONTAINER (object),
+                                   (GtkCallback) gdl_dock_paned_request_foreach,
+                                   &amp;data);
+
+            may_dock = data.may_dock;
+            if (!may_dock) {
+                /* the pointer is on the handle, so snap to top/bottom
+                   or left/right */
+                may_dock = TRUE;
+                if (item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL) {
+                    if (rel_y &lt; alloc-&gt;height / 2) {
+                        my_request.position = GDL_DOCK_TOP;
+                        my_request.rect.height *= SPLIT_RATIO;
+                        divider = other.height;
+                    } else {
+                        my_request.position = GDL_DOCK_BOTTOM;
+                        my_request.rect.y += my_request.rect.height * (1 - SPLIT_RATIO);
+                        my_request.rect.height *= SPLIT_RATIO;
+                        divider = MAX (0, my.height - other.height);
+                    }
+                } else {
+                    if (rel_x &lt; alloc-&gt;width / 2) {
+                        my_request.position = GDL_DOCK_LEFT;
+                        my_request.rect.width *= SPLIT_RATIO;
+                        divider = other.width;
+                    } else {
+                        my_request.position = GDL_DOCK_RIGHT;
+                        my_request.rect.x += my_request.rect.width * (1 - SPLIT_RATIO);
+                        my_request.rect.width *= SPLIT_RATIO;
+                        divider = MAX (0, my.width - other.width);
+                    }
+                }
+            }
+        }
+
+        if (divider &gt;= 0 &amp;&amp; my_request.position != GDL_DOCK_CENTER) {
+            if (G_IS_VALUE (&amp;my_request.extra))
+                g_value_unset (&amp;my_request.extra);
+            g_value_init (&amp;my_request.extra, G_TYPE_UINT);
+            g_value_set_uint (&amp;my_request.extra, (guint) divider);
+        }
+        
+        if (may_dock) {
+            /* adjust returned coordinates so they are relative to
+               our allocation */
+            my_request.rect.x += alloc-&gt;x;
+            my_request.rect.y += alloc-&gt;y;
+        }
+    }
+
+    if (may_dock &amp;&amp; request)
+        *request = my_request;
+    
+    return may_dock;
+}
+
+static void
+gdl_dock_paned_dock (GdlDockObject    *object,
+                     GdlDockObject    *requestor,
+                     GdlDockPlacement  position,
+                     GValue           *other_data)
+{
+    GtkPaned *paned;
+    gboolean  done = FALSE;
+    
+    g_return_if_fail (GDL_IS_DOCK_PANED (object));
+    g_return_if_fail (GDL_DOCK_ITEM (object)-&gt;child != NULL);
+
+    paned = GTK_PANED (GDL_DOCK_ITEM (object)-&gt;child);
+
+    /* see if we can dock the item in our paned */
+    switch (GDL_DOCK_ITEM (object)-&gt;orientation) {
+        case GTK_ORIENTATION_HORIZONTAL:
+            if (!paned-&gt;child1 &amp;&amp; position == GDL_DOCK_LEFT) {
+                gtk_paned_pack1 (paned, GTK_WIDGET (requestor), FALSE, FALSE);
+                done = TRUE;
+            } else if (!paned-&gt;child2 &amp;&amp; position == GDL_DOCK_RIGHT) {
+                gtk_paned_pack2 (paned, GTK_WIDGET (requestor), TRUE, FALSE);
+                done = TRUE;
+            }
+            break;
+        case GTK_ORIENTATION_VERTICAL:
+            if (!paned-&gt;child1 &amp;&amp; position == GDL_DOCK_TOP) {
+                gtk_paned_pack1 (paned, GTK_WIDGET (requestor), FALSE, FALSE);
+                done = TRUE;
+            } else if (!paned-&gt;child2 &amp;&amp; position == GDL_DOCK_BOTTOM) {
+                gtk_paned_pack2 (paned, GTK_WIDGET (requestor), TRUE, FALSE);
+                done = TRUE;
+            }
+            break;
+        default:
+            break;
+    }
+
+    if (!done) {
+        /* this will create another paned and reparent us there */
+        GNOME_CALL_PARENT (GDL_DOCK_OBJECT_CLASS, dock, (object, requestor, position,
+                                                         other_data));
+    }
+    else {
+        gdl_dock_item_show_grip (GDL_DOCK_ITEM (requestor));
+        GDL_DOCK_OBJECT_SET_FLAGS (requestor, GDL_DOCK_ATTACHED);
+    }
+}
+
+static void
+gdl_dock_paned_set_orientation (GdlDockItem    *item,
+                                GtkOrientation  orientation)
+{
+    GtkPaned    *old_paned = NULL, *new_paned;
+    GtkWidget   *child1, *child2;
+    
+    g_return_if_fail (GDL_IS_DOCK_PANED (item));
+
+    if (item-&gt;child) {
+        old_paned = GTK_PANED (item-&gt;child);
+        g_object_ref (old_paned);
+        gtk_widget_unparent (GTK_WIDGET (old_paned));
+        item-&gt;child = NULL;
+    }
+    
+    gdl_dock_paned_create_child (GDL_DOCK_PANED (item), orientation);
+    
+    if (old_paned) {
+        new_paned = GTK_PANED (item-&gt;child);
+        child1 = old_paned-&gt;child1;
+        child2 = old_paned-&gt;child2;
+    
+        if (child1) {
+            g_object_ref (child1);
+            gtk_container_remove (GTK_CONTAINER (old_paned), child1);
+            gtk_paned_pack1 (new_paned, child1, TRUE, FALSE);
+            g_object_unref (child1);
+        }
+        if (child2) {
+            g_object_ref (child2);
+            gtk_container_remove (GTK_CONTAINER (old_paned), child2);
+            gtk_paned_pack1 (new_paned, child2, TRUE, FALSE);
+            g_object_unref (child2);
+        }
+    }
+    
+    GNOME_CALL_PARENT (GDL_DOCK_ITEM_CLASS, set_orientation, (item, orientation));
+}
+
+static gboolean 
+gdl_dock_paned_child_placement (GdlDockObject    *object,
+                                GdlDockObject    *child,
+                                GdlDockPlacement *placement)
+{
+    GdlDockItem      *item = GDL_DOCK_ITEM (object);
+    GtkPaned         *paned;
+    GdlDockPlacement  pos = GDL_DOCK_NONE;
+    
+    if (item-&gt;child) {
+        paned = GTK_PANED (item-&gt;child);
+        if (GTK_WIDGET (child) == paned-&gt;child1)
+            pos = item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL ?
+                GDL_DOCK_LEFT : GDL_DOCK_TOP;
+        else if (GTK_WIDGET (child) == paned-&gt;child2)
+            pos = item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL ?
+                GDL_DOCK_RIGHT : GDL_DOCK_BOTTOM;
+    }
+
+    if (pos != GDL_DOCK_NONE) {
+        if (placement)
+            *placement = pos;
+        return TRUE;
+    }
+    else
+        return FALSE;
+}
+
+
+/* ----- Public interface ----- */
+
+GtkWidget *
+gdl_dock_paned_new (GtkOrientation orientation)
+{
+    GdlDockPaned *paned;
+
+    paned = GDL_DOCK_PANED (g_object_new (GDL_TYPE_DOCK_PANED,
+                                          &quot;orientation&quot;, orientation, NULL));
+    GDL_DOCK_OBJECT_UNSET_FLAGS (paned, GDL_DOCK_AUTOMATIC);
+    
+    return GTK_WIDGET (paned);
+}
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-paned.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-paned.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-paned.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,65 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * gdl-dock-paned.h
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifndef __GDL_DOCK_PANED_H__
+#define __GDL_DOCK_PANED_H__
+
+#include &lt;gdl/gdl-dock-item.h&gt;
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK_PANED                  (gdl_dock_paned_get_type ())
+#define GDL_DOCK_PANED(obj)                  (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_PANED, GdlDockPaned))
+#define GDL_DOCK_PANED_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_PANED, GdlDockPanedClass))
+#define GDL_IS_DOCK_PANED(obj)               (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_PANED))
+#define GDL_IS_DOCK_PANED_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_PANED))
+#define GDL_DOCK_PANED_GET_CLASS(obj)        (GTK_CHECK_GET_CLASS ((obj), GDL_TYE_DOCK_PANED, GdlDockPanedClass))
+
+/* data types &amp; structures */
+typedef struct _GdlDockPaned      GdlDockPaned;
+typedef struct _GdlDockPanedClass GdlDockPanedClass;
+
+struct _GdlDockPaned {
+    GdlDockItem  dock_item;
+
+    gboolean     position_changed;
+};
+
+struct _GdlDockPanedClass {
+    GdlDockItemClass parent_class;
+};
+
+
+/* public interface */
+ 
+GType      gdl_dock_paned_get_type        (void);
+
+GtkWidget *gdl_dock_paned_new             (GtkOrientation orientation);
+
+
+G_END_DECLS
+
+#endif /* __GDL_DOCK_PANED_H__ */
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,618 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * gdl-dock-placeholder.c - Placeholders for docking items
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;libgnome/gnome-macros.h&gt;
+
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock-placeholder.h&quot;
+#include &quot;gdl-dock-item.h&quot;
+#include &quot;libgdltypebuiltins.h&quot;
+
+
+#undef PLACEHOLDER_DEBUG
+
+/* ----- Private prototypes ----- */
+
+static void     gdl_dock_placeholder_class_init     (GdlDockPlaceholderClass *klass);
+static void     gdl_dock_placeholder_instance_init  (GdlDockPlaceholder      *ph);
+
+static void     gdl_dock_placeholder_set_property   (GObject                 *g_object,
+                                                     guint                    prop_id,
+                                                     const GValue            *value,
+                                                     GParamSpec              *pspec);
+static void     gdl_dock_placeholder_get_property   (GObject                 *g_object,
+                                                     guint                    prop_id,
+                                                     GValue                  *value,
+                                                     GParamSpec              *pspec);
+
+static void     gdl_dock_placeholder_destroy        (GtkObject               *object);
+
+static void     gdl_dock_placeholder_add            (GtkContainer            *container,
+                                                     GtkWidget               *widget);
+
+static void     gdl_dock_placeholder_detach         (GdlDockObject           *object,
+                                                     gboolean                 recursive);
+static void     gdl_dock_placeholder_reduce         (GdlDockObject           *object);
+static void     gdl_dock_placeholder_dock           (GdlDockObject           *object,
+                                                     GdlDockObject           *requestor,
+                                                     GdlDockPlacement         position,
+                                                     GValue                  *other_data);
+
+static void     gdl_dock_placeholder_weak_notify    (gpointer                 data,
+                                                     GObject                 *old_object);
+
+static void     disconnect_host                     (GdlDockPlaceholder      *ph);
+static void     connect_host                        (GdlDockPlaceholder      *ph,
+                                                     GdlDockObject           *new_host);
+static void     do_excursion                        (GdlDockPlaceholder      *ph);
+
+static void     gdl_dock_placeholder_present        (GdlDockObject           *object,
+                                                     GdlDockObject           *child);
+
+
+/* ----- Private variables and data structures ----- */
+
+enum {
+    PROP_0,
+    PROP_STICKY,
+    PROP_HOST,
+    PROP_NEXT_PLACEMENT
+};
+
+struct _GdlDockPlaceholderPrivate {
+    /* current object this placeholder is pinned to */
+    GdlDockObject    *host;
+    gboolean          sticky;
+    
+    /* when the placeholder is moved up the hierarchy, this stack
+       keeps track of the necessary dock positions needed to get the
+       placeholder to the original position */
+    GSList           *placement_stack;
+
+    /* connected signal handlers */
+    guint             host_detach_handler;
+    guint             host_dock_handler;
+};
+
+
+/* ----- Private interface ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDockPlaceholder, gdl_dock_placeholder,
+			 GdlDockObject, GDL_TYPE_DOCK_OBJECT);
+
+static void 
+gdl_dock_placeholder_class_init (GdlDockPlaceholderClass *klass)
+{
+    GObjectClass       *g_object_class;
+    GtkObjectClass     *gtk_object_class;
+    GtkContainerClass  *container_class;
+    GdlDockObjectClass *object_class;
+    
+    g_object_class = G_OBJECT_CLASS (klass);
+    gtk_object_class = GTK_OBJECT_CLASS (klass);
+    container_class = GTK_CONTAINER_CLASS (klass);
+    object_class = GDL_DOCK_OBJECT_CLASS (klass);
+
+    g_object_class-&gt;get_property = gdl_dock_placeholder_get_property;
+    g_object_class-&gt;set_property = gdl_dock_placeholder_set_property;
+    
+    g_object_class_install_property (
+	g_object_class, PROP_STICKY,
+	g_param_spec_boolean (&quot;sticky&quot;, _(&quot;Sticky&quot;),
+			      _(&quot;Whether the placeholder will stick to its host or &quot;
+				&quot;move up the hierarchy when the host is redocked&quot;),
+			      FALSE,
+			      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+    
+    g_object_class_install_property (
+	g_object_class, PROP_HOST,
+	g_param_spec_object (&quot;host&quot;, _(&quot;Host&quot;),
+			     _(&quot;The dock object this placeholder is attached to&quot;),
+			     GDL_TYPE_DOCK_OBJECT,
+			     G_PARAM_READWRITE));
+    
+    /* this will return the top of the placement stack */
+    g_object_class_install_property (
+	g_object_class, PROP_NEXT_PLACEMENT,
+	g_param_spec_enum (&quot;next_placement&quot;, _(&quot;Next placement&quot;),
+			   _(&quot;The position an item will be docked to our host if a &quot;
+			     &quot;request is made to dock to us&quot;),
+			   GDL_TYPE_DOCK_PLACEMENT,
+			   GDL_DOCK_CENTER,
+			   G_PARAM_READWRITE |
+                           GDL_DOCK_PARAM_EXPORT | GDL_DOCK_PARAM_AFTER));
+    
+    gtk_object_class-&gt;destroy = gdl_dock_placeholder_destroy;
+    container_class-&gt;add = gdl_dock_placeholder_add;
+    
+    object_class-&gt;is_compound = FALSE;
+    object_class-&gt;detach = gdl_dock_placeholder_detach;
+    object_class-&gt;reduce = gdl_dock_placeholder_reduce;
+    object_class-&gt;dock = gdl_dock_placeholder_dock;
+    object_class-&gt;present = gdl_dock_placeholder_present;
+}
+
+static void 
+gdl_dock_placeholder_instance_init (GdlDockPlaceholder *ph)
+{
+    GTK_WIDGET_SET_FLAGS (ph, GTK_NO_WINDOW);
+    GTK_WIDGET_UNSET_FLAGS (ph, GTK_CAN_FOCUS);
+    
+    ph-&gt;_priv = g_new0 (GdlDockPlaceholderPrivate, 1);
+}
+
+static void 
+gdl_dock_placeholder_set_property (GObject      *g_object,
+				   guint         prop_id,
+				   const GValue *value,
+				   GParamSpec   *pspec)
+{
+    GdlDockPlaceholder *ph = GDL_DOCK_PLACEHOLDER (g_object);
+
+    switch (prop_id) {
+	case PROP_STICKY:
+            if (ph-&gt;_priv)
+                ph-&gt;_priv-&gt;sticky = g_value_get_boolean (value);
+	    break;
+	case PROP_HOST:
+            gdl_dock_placeholder_attach (ph, g_value_get_object (value));
+	    break;
+        case PROP_NEXT_PLACEMENT:
+            if (ph-&gt;_priv) {
+                ph-&gt;_priv-&gt;placement_stack =
+                    g_slist_prepend (ph-&gt;_priv-&gt;placement_stack,
+                                     (gpointer) g_value_get_enum (value));
+            }
+            break;
+	default:
+	    G_OBJECT_WARN_INVALID_PROPERTY_ID (g_object, prop_id, pspec);
+	    break;
+    }
+}
+
+static void 
+gdl_dock_placeholder_get_property (GObject    *g_object,
+				   guint       prop_id,
+				   GValue     *value,
+				   GParamSpec *pspec)
+{
+    GdlDockPlaceholder *ph = GDL_DOCK_PLACEHOLDER (g_object);
+
+    switch (prop_id) {
+	case PROP_STICKY:
+            if (ph-&gt;_priv)
+                g_value_set_boolean (value, ph-&gt;_priv-&gt;sticky);
+            else
+                g_value_set_boolean (value, FALSE);
+	    break;
+	case PROP_HOST:
+            if (ph-&gt;_priv)
+                g_value_set_object (value, ph-&gt;_priv-&gt;host);
+            else
+                g_value_set_object (value, NULL);
+	    break;
+	case PROP_NEXT_PLACEMENT:
+            if (ph-&gt;_priv &amp;&amp; ph-&gt;_priv-&gt;placement_stack)
+                g_value_set_enum (value, (GdlDockPlacement) ph-&gt;_priv-&gt;placement_stack-&gt;data);
+            else
+                g_value_set_enum (value, GDL_DOCK_CENTER);
+	    break;
+	default:
+	    G_OBJECT_WARN_INVALID_PROPERTY_ID (g_object, prop_id, pspec);
+	    break;
+    }
+}
+
+static void
+gdl_dock_placeholder_destroy (GtkObject *object)
+{
+    GdlDockPlaceholder *ph = GDL_DOCK_PLACEHOLDER (object);
+
+    if (ph-&gt;_priv) {
+        if (ph-&gt;_priv-&gt;host)
+            gdl_dock_placeholder_detach (GDL_DOCK_OBJECT (object), FALSE);
+        g_free (ph-&gt;_priv);
+        ph-&gt;_priv = NULL;
+    }
+
+    GNOME_CALL_PARENT (GTK_OBJECT_CLASS, destroy, (object));
+}
+
+static void 
+gdl_dock_placeholder_add (GtkContainer *container,
+                          GtkWidget    *widget)
+{
+    GdlDockPlaceholder *ph;
+    GdlDockPlacement    pos = GDL_DOCK_CENTER;   /* default position */
+    
+    g_return_if_fail (GDL_IS_DOCK_PLACEHOLDER (container));
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+
+    ph = GDL_DOCK_PLACEHOLDER (container);
+    if (ph-&gt;_priv-&gt;placement_stack)
+        pos = (GdlDockPlacement) ph-&gt;_priv-&gt;placement_stack-&gt;data;
+        
+    gdl_dock_object_dock (GDL_DOCK_OBJECT (ph), GDL_DOCK_OBJECT (widget),
+                          pos, NULL);
+}
+
+static void
+gdl_dock_placeholder_detach (GdlDockObject *object,
+                             gboolean       recursive)
+{
+    GdlDockPlaceholder *ph = GDL_DOCK_PLACEHOLDER (object);
+
+    /* disconnect handlers */
+    disconnect_host (ph);
+    
+    /* free the placement stack */
+    g_slist_free (ph-&gt;_priv-&gt;placement_stack);
+    ph-&gt;_priv-&gt;placement_stack = NULL;
+
+    GDL_DOCK_OBJECT_UNSET_FLAGS (object, GDL_DOCK_ATTACHED);
+}
+
+static void 
+gdl_dock_placeholder_reduce (GdlDockObject *object)
+{
+    /* placeholders are not reduced */
+    return;
+}
+
+static void 
+gdl_dock_placeholder_dock (GdlDockObject    *object,
+			   GdlDockObject    *requestor,
+			   GdlDockPlacement  position,
+			   GValue           *other_data)
+{
+    GdlDockPlaceholder *ph = GDL_DOCK_PLACEHOLDER (object);
+    
+    if (ph-&gt;_priv-&gt;host) {
+        /* we simply act as a proxy for our host */
+        gdl_dock_object_dock (ph-&gt;_priv-&gt;host, requestor,
+                              position, other_data);
+    }
+    else {
+        GdlDockObject *toplevel;
+        
+        if (!gdl_dock_object_is_bound (GDL_DOCK_OBJECT (ph))) {
+            g_warning (_(&quot;Attempt to dock a dock object to an unbound placeholder&quot;));
+            return;
+        }
+        
+        /* dock the item as a floating of the controller */
+        toplevel = gdl_dock_master_get_controller (GDL_DOCK_OBJECT_GET_MASTER (ph));
+        gdl_dock_object_dock (toplevel, requestor,
+                              GDL_DOCK_FLOATING, NULL);
+    }
+}
+
+#ifdef PLACEHOLDER_DEBUG
+static void
+print_placement_stack (GdlDockPlaceholder *ph)
+{
+    GSList *s = ph-&gt;_priv-&gt;placement_stack;
+    GEnumClass *enum_class = G_ENUM_CLASS (g_type_class_ref (GDL_TYPE_DOCK_PLACEMENT));
+    GEnumValue *enum_value;
+    gchar *name;
+    GString *message;
+
+    message = g_string_new (NULL);
+    g_string_printf (message, &quot;[%p] host: %p (%s), stack: &quot;,
+                     ph, ph-&gt;_priv-&gt;host, G_OBJECT_TYPE_NAME (ph-&gt;_priv-&gt;host));
+    for (; s; s = s-&gt;next) {
+        enum_value = g_enum_get_value (enum_class, (GdlDockPlacement) s-&gt;data);
+        name = enum_value ? enum_value-&gt;value_name : NULL;
+        g_string_append_printf (message, &quot;%s, &quot;, name);
+    }
+    g_message (&quot;%s&quot;, message-&gt;str);
+    
+    g_string_free (message, TRUE);
+    g_type_class_unref (enum_class);
+}
+#endif
+
+static void 
+gdl_dock_placeholder_present (GdlDockObject *object,
+                              GdlDockObject *child)
+{
+    /* do nothing */
+    return;
+}
+
+/* ----- Public interface ----- */
+
+GtkWidget * 
+gdl_dock_placeholder_new (gchar            *name,
+                          GdlDockObject    *object,
+                          GdlDockPlacement  position,
+                          gboolean          sticky)
+{
+    GdlDockPlaceholder *ph;
+
+    ph = GDL_DOCK_PLACEHOLDER (g_object_new (GDL_TYPE_DOCK_PLACEHOLDER,
+                                             &quot;name&quot;, name,
+                                             &quot;sticky&quot;, sticky,
+                                             NULL));
+    GDL_DOCK_OBJECT_UNSET_FLAGS (ph, GDL_DOCK_AUTOMATIC);
+
+    if (object) {
+        gdl_dock_placeholder_attach (ph, object);
+        if (position == GDL_DOCK_NONE)
+            position = GDL_DOCK_CENTER;
+        g_object_set (G_OBJECT (ph), &quot;next_placement&quot;, position, NULL);
+        if (GDL_IS_DOCK (object)) {
+            /* the top placement will be consumed by the toplevel
+               dock, so add a dummy placement */
+            g_object_set (G_OBJECT (ph), &quot;next_placement&quot;, GDL_DOCK_CENTER, NULL);
+        }
+        /* try a recursion */
+        do_excursion (ph);
+    }
+    
+    return GTK_WIDGET (ph);
+}
+
+static void 
+gdl_dock_placeholder_weak_notify (gpointer data,
+                                  GObject *old_object)
+{
+    GdlDockPlaceholder *ph;
+    
+    g_return_if_fail (data != NULL &amp;&amp; GDL_IS_DOCK_PLACEHOLDER (data));
+
+    ph = GDL_DOCK_PLACEHOLDER (data);
+
+    /* we shouldn't get here, so perform an emergency detach. instead
+       we should have gotten a detach signal from our host */
+    ph-&gt;_priv-&gt;host = NULL;
+    /* free the placement stack */
+    g_slist_free (ph-&gt;_priv-&gt;placement_stack);
+    ph-&gt;_priv-&gt;placement_stack = NULL;
+
+    GDL_DOCK_OBJECT_UNSET_FLAGS (ph, GDL_DOCK_ATTACHED);
+}
+
+static void
+detach_cb (GdlDockObject *object,
+           gboolean       recursive,
+           gpointer       user_data)
+{
+    GdlDockPlaceholder *ph;
+    GdlDockObject      *new_host, *obj;
+
+    g_return_if_fail (user_data != NULL &amp;&amp; GDL_IS_DOCK_PLACEHOLDER (user_data));
+    
+    /* we go up in the hierarchy and we store the hinted placement in
+     * the placement stack so we can rebuild the docking layout later
+     * when we get the host's dock signal.  */
+
+    ph = GDL_DOCK_PLACEHOLDER (user_data);
+    obj = ph-&gt;_priv-&gt;host;
+    if (obj != object) {
+        g_warning (_(&quot;Got a detach signal from an object (%p) who is not &quot;
+                     &quot;our host %p&quot;), object, ph-&gt;_priv-&gt;host);
+        return;
+    }
+    
+    /* skip sticky objects */
+    if (ph-&gt;_priv-&gt;sticky)
+        return;
+    
+    /* go up in the hierarchy */
+    new_host = gdl_dock_object_get_parent_object (obj);
+
+    while (new_host) {
+        GdlDockPlacement pos = GDL_DOCK_NONE;
+        
+        /* get placement hint from the new host */
+        if (gdl_dock_object_child_placement (new_host, obj, &amp;pos)) {
+            ph-&gt;_priv-&gt;placement_stack = g_slist_prepend (
+                ph-&gt;_priv-&gt;placement_stack, (gpointer) pos);
+        }
+        else {
+            g_warning (_(&quot;Something weird happened while getting the child &quot;
+                         &quot;placement for %p from parent %p&quot;), obj, new_host);
+        }
+
+        if (!GDL_DOCK_OBJECT_IN_DETACH (new_host))
+            /* we found a &quot;stable&quot; dock object */
+            break;
+        
+        obj = new_host;
+        new_host = gdl_dock_object_get_parent_object (obj);
+    }
+
+    /* disconnect host */
+    disconnect_host (ph);
+
+    if (!new_host) {
+        /* the toplevel was detached: we attach ourselves to the
+           controller with an initial placement of floating */
+        new_host = gdl_dock_master_get_controller (GDL_DOCK_OBJECT_GET_MASTER (ph));
+        ph-&gt;_priv-&gt;placement_stack = g_slist_prepend (
+            ph-&gt;_priv-&gt;placement_stack, (gpointer) GDL_DOCK_FLOATING);
+    }
+    if (new_host)
+        connect_host (ph, new_host);
+
+#ifdef PLACEHOLDER_DEBUG
+    print_placement_stack (ph);
+#endif
+}
+
+/**
+ * do_excursion:
+ * @ph: placeholder object
+ *
+ * Tries to shrink the placement stack by examining the host's
+ * children and see if any of them matches the placement which is at
+ * the top of the stack.  If this is the case, it tries again with the
+ * new host.
+ **/
+static void
+do_excursion (GdlDockPlaceholder *ph)
+{
+    if (ph-&gt;_priv-&gt;host &amp;&amp;
+        !ph-&gt;_priv-&gt;sticky &amp;&amp;
+        ph-&gt;_priv-&gt;placement_stack &amp;&amp;
+        gdl_dock_object_is_compound (ph-&gt;_priv-&gt;host)) {
+
+        GdlDockPlacement pos, stack_pos =
+            (GdlDockPlacement) ph-&gt;_priv-&gt;placement_stack-&gt;data;
+        GList           *children, *l;
+        GdlDockObject   *host = ph-&gt;_priv-&gt;host;
+        
+        children = gtk_container_get_children (GTK_CONTAINER (host));
+        for (l = children; l; l = l-&gt;next) {
+            pos = stack_pos;
+            gdl_dock_object_child_placement (GDL_DOCK_OBJECT (host),
+                                             GDL_DOCK_OBJECT (l-&gt;data),
+                                             &amp;pos);
+            if (pos == stack_pos) {
+                /* remove the stack position */
+                ph-&gt;_priv-&gt;placement_stack =
+                    g_slist_remove_link (ph-&gt;_priv-&gt;placement_stack,
+                                         ph-&gt;_priv-&gt;placement_stack);
+                
+                /* connect to the new host */
+                disconnect_host (ph);
+                connect_host (ph, GDL_DOCK_OBJECT (l-&gt;data));
+
+                /* recurse... */
+                if (!GDL_DOCK_OBJECT_IN_REFLOW (l-&gt;data))
+                    do_excursion (ph);
+                
+                break;
+            }
+        }
+        g_list_free (children);
+    }
+}
+
+static void 
+dock_cb (GdlDockObject    *object,
+         GdlDockObject    *requestor,
+         GdlDockPlacement  position,
+         GValue           *other_data,
+         gpointer          user_data)
+{
+    GdlDockPlacement    pos = GDL_DOCK_NONE;
+    GdlDockPlaceholder *ph;
+    
+    g_return_if_fail (user_data != NULL &amp;&amp; GDL_IS_DOCK_PLACEHOLDER (user_data));
+    ph = GDL_DOCK_PLACEHOLDER (user_data);
+    g_return_if_fail (ph-&gt;_priv-&gt;host == object);
+    
+    /* see if the given position is compatible for the stack's top
+       element */
+    if (!ph-&gt;_priv-&gt;sticky &amp;&amp; ph-&gt;_priv-&gt;placement_stack) {
+        pos = (GdlDockPlacement) ph-&gt;_priv-&gt;placement_stack-&gt;data;
+        if (gdl_dock_object_child_placement (object, requestor, &amp;pos)) {
+            if (pos == (GdlDockPlacement) ph-&gt;_priv-&gt;placement_stack-&gt;data) {
+                /* the position is compatible: excurse down */
+                do_excursion (ph);
+            }
+        }
+    }
+#ifdef PLACEHOLDER_DEBUG
+    print_placement_stack (ph);
+#endif
+}
+
+static void
+disconnect_host (GdlDockPlaceholder *ph)
+{
+    if (!ph-&gt;_priv-&gt;host)
+        return;
+    
+    if (ph-&gt;_priv-&gt;host_detach_handler)
+        g_signal_handler_disconnect (ph-&gt;_priv-&gt;host, ph-&gt;_priv-&gt;host_detach_handler);
+    if (ph-&gt;_priv-&gt;host_dock_handler)
+        g_signal_handler_disconnect (ph-&gt;_priv-&gt;host, ph-&gt;_priv-&gt;host_dock_handler);
+    ph-&gt;_priv-&gt;host_detach_handler = 0;
+    ph-&gt;_priv-&gt;host_dock_handler = 0;
+
+    /* remove weak ref to object */
+    g_object_weak_unref (G_OBJECT (ph-&gt;_priv-&gt;host),
+                         gdl_dock_placeholder_weak_notify, ph);
+    ph-&gt;_priv-&gt;host = NULL;
+}
+
+static void
+connect_host (GdlDockPlaceholder *ph,
+              GdlDockObject      *new_host)
+{
+    if (ph-&gt;_priv-&gt;host)
+        disconnect_host (ph);
+    
+    ph-&gt;_priv-&gt;host = new_host;
+    g_object_weak_ref (G_OBJECT (ph-&gt;_priv-&gt;host),
+                       gdl_dock_placeholder_weak_notify, ph);
+
+    ph-&gt;_priv-&gt;host_detach_handler =
+        g_signal_connect (ph-&gt;_priv-&gt;host,
+                          &quot;detach&quot;,
+                          (GCallback) detach_cb,
+                          (gpointer) ph);
+    
+    ph-&gt;_priv-&gt;host_dock_handler =
+        g_signal_connect (ph-&gt;_priv-&gt;host,
+                          &quot;dock&quot;,
+                          (GCallback) dock_cb,
+                          (gpointer) ph);
+}
+
+void
+gdl_dock_placeholder_attach (GdlDockPlaceholder *ph,
+                             GdlDockObject      *object)
+{
+    g_return_if_fail (ph != NULL &amp;&amp; GDL_IS_DOCK_PLACEHOLDER (ph));
+    g_return_if_fail (ph-&gt;_priv != NULL);
+    g_return_if_fail (object != NULL);
+    
+    /* object binding */
+    if (!gdl_dock_object_is_bound (GDL_DOCK_OBJECT (ph)))
+        gdl_dock_object_bind (GDL_DOCK_OBJECT (ph), object-&gt;master);
+
+    g_return_if_fail (GDL_DOCK_OBJECT (ph)-&gt;master == object-&gt;master);
+        
+    gdl_dock_object_freeze (GDL_DOCK_OBJECT (ph));
+    
+    /* detach from previous host first */
+    if (ph-&gt;_priv-&gt;host)
+        gdl_dock_object_detach (GDL_DOCK_OBJECT (ph), FALSE);
+
+    connect_host (ph, object);
+    
+    GDL_DOCK_OBJECT_SET_FLAGS (ph, GDL_DOCK_ATTACHED);
+    
+    gdl_dock_object_thaw (GDL_DOCK_OBJECT (ph));
+}
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,70 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * gdl-dock-placeholder.h - Placeholders for docking items
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifndef __GDL_DOCK_PLACEHOLDER_H__
+#define __GDL_DOCK_PLACEHOLDER_H__
+
+#include &lt;gdl/gdl-dock-object.h&gt;
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK_PLACEHOLDER             (gdl_dock_placeholder_get_type ())
+#define GDL_DOCK_PLACEHOLDER(obj)             (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_PLACEHOLDER, GdlDockPlaceholder))
+#define GDL_DOCK_PLACEHOLDER_CLASS(klass)     (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_PLACEHOLDER, GdlDockPlaceholderClass))
+#define GDL_IS_DOCK_PLACEHOLDER(obj)          (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_PLACEHOLDER))
+#define GDL_IS_DOCK_PLACEHOLDER_CLASS(klass)  (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_PLACEHOLDER))
+#define GDL_DOCK_PLACEHOLDER_GET_CLASS(obj)   (GTK_CHECK_GET_CLASS ((obj), GTK_TYPE_DOCK_PLACEHOLDER, GdlDockPlaceholderClass))
+
+/* data types &amp; structures */
+typedef struct _GdlDockPlaceholder        GdlDockPlaceholder;
+typedef struct _GdlDockPlaceholderClass   GdlDockPlaceholderClass;
+typedef struct _GdlDockPlaceholderPrivate GdlDockPlaceholderPrivate;
+
+struct _GdlDockPlaceholder {
+    GdlDockObject              object;
+
+    GdlDockPlaceholderPrivate *_priv;
+};
+
+struct _GdlDockPlaceholderClass {
+    GdlDockObjectClass parent_class;
+};
+
+/* public interface */
+
+GType       gdl_dock_placeholder_get_type (void);
+
+GtkWidget  *gdl_dock_placeholder_new      (gchar              *name,
+                                           GdlDockObject      *object,
+                                           GdlDockPlacement    position,
+                                           gboolean            sticky);
+
+void        gdl_dock_placeholder_attach   (GdlDockPlaceholder *ph,
+                                           GdlDockObject      *object);
+
+
+G_END_DECLS
+
+#endif /* __GDL_DOCK_PLACEHOLDER_H__ */

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,623 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * gdl-dock-tablabel.c
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;libgnome/gnome-macros.h&gt;
+#include &lt;gtk/gtk.h&gt;
+
+#include &quot;gdl-dock-tablabel.h&quot;
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock-item.h&quot;
+#include &quot;libgdlmarshal.h&quot;
+
+
+/* ----- Private prototypes ----- */
+
+static void  gdl_dock_tablabel_class_init    (GdlDockTablabelClass *klass);
+static void  gdl_dock_tablabel_instance_init (GdlDockTablabel      *tablabel);
+
+static void  gdl_dock_tablabel_set_property  (GObject              *object,
+                                              guint                 prop_id,
+                                              const GValue         *value,
+                                              GParamSpec           *pspec);
+static void  gdl_dock_tablabel_get_property  (GObject              *object,
+                                              guint                 prop_id,
+                                              GValue               *value,
+                                              GParamSpec           *pspec);
+
+static void  gdl_dock_tablabel_item_notify   (GObject            *master,
+                                              GParamSpec         *pspec,
+                                              gpointer            data);
+
+static void  gdl_dock_tablabel_size_request  (GtkWidget          *widget,
+                                              GtkRequisition     *requisition);
+static void  gdl_dock_tablabel_size_allocate (GtkWidget          *widget,
+                                              GtkAllocation      *allocation);
+                                              
+static void  gdl_dock_tablabel_paint         (GtkWidget      *widget,
+                                              GdkEventExpose *event);
+static gint  gdl_dock_tablabel_expose        (GtkWidget      *widget,
+                                              GdkEventExpose *event);
+
+static gboolean gdl_dock_tablabel_button_event  (GtkWidget      *widget,
+                                                 GdkEventButton *event);
+static gboolean gdl_dock_tablabel_motion_event  (GtkWidget      *widget,
+                                                 GdkEventMotion *event);
+
+static void  gdl_dock_tablabel_realize (GtkWidget *widget);
+static void  gdl_dock_tablabel_unrealize (GtkWidget *widget);
+static void  gdl_dock_tablabel_map (GtkWidget *widget);
+static void  gdl_dock_tablabel_unmap (GtkWidget *widget);
+
+/* ----- Private data types and variables ----- */
+
+#define DEFAULT_DRAG_HANDLE_SIZE 10
+#define HANDLE_RATIO 1.0
+
+enum {
+    BUTTON_PRESSED_HANDLE,
+    LAST_SIGNAL
+};
+
+enum {
+    PROP_0,
+    PROP_ITEM
+};
+
+
+static guint dock_tablabel_signals [LAST_SIGNAL] = { 0 };
+
+
+/* ----- Private interface ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDockTablabel, gdl_dock_tablabel,
+                         GtkBin, GTK_TYPE_BIN);
+
+static void
+gdl_dock_tablabel_class_init (GdlDockTablabelClass *klass)
+{
+    GObjectClass      *g_object_class;
+    GtkObjectClass    *object_class;
+    GtkWidgetClass    *widget_class;
+    GtkContainerClass *container_class;
+
+    g_object_class = G_OBJECT_CLASS (klass);
+    object_class = GTK_OBJECT_CLASS (klass);
+    widget_class = GTK_WIDGET_CLASS (klass);
+    container_class = GTK_CONTAINER_CLASS (klass);
+    
+    g_object_class-&gt;set_property = gdl_dock_tablabel_set_property;
+    g_object_class-&gt;get_property = gdl_dock_tablabel_get_property;
+
+    widget_class-&gt;size_request = gdl_dock_tablabel_size_request;
+    widget_class-&gt;size_allocate = gdl_dock_tablabel_size_allocate;
+    widget_class-&gt;expose_event = gdl_dock_tablabel_expose;
+    widget_class-&gt;button_press_event = gdl_dock_tablabel_button_event;
+    widget_class-&gt;button_release_event = gdl_dock_tablabel_button_event;
+    widget_class-&gt;motion_notify_event = gdl_dock_tablabel_motion_event;
+    widget_class-&gt;realize = gdl_dock_tablabel_realize;
+    widget_class-&gt;unrealize = gdl_dock_tablabel_unrealize;
+    widget_class-&gt;map = gdl_dock_tablabel_map;
+    widget_class-&gt;unmap = gdl_dock_tablabel_unmap;
+
+    g_object_class_install_property (
+        g_object_class, PROP_ITEM,
+        g_param_spec_object (&quot;item&quot;, _(&quot;Controlling dock item&quot;),
+                             _(&quot;Dockitem which 'owns' this tablabel&quot;),
+                             GDL_TYPE_DOCK_ITEM,
+                             G_PARAM_READWRITE));
+
+    dock_tablabel_signals [BUTTON_PRESSED_HANDLE] =
+        g_signal_new (&quot;button_pressed_handle&quot;,
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_LAST,
+                      G_STRUCT_OFFSET (GdlDockTablabelClass, 
+                                       button_pressed_handle),
+                      NULL, NULL,
+                      gdl_marshal_VOID__BOXED,
+                      G_TYPE_NONE,
+                      1,
+                      GDK_TYPE_EVENT | G_SIGNAL_TYPE_STATIC_SCOPE);
+
+    klass-&gt;button_pressed_handle = NULL;
+}
+
+static void
+gdl_dock_tablabel_instance_init (GdlDockTablabel *tablabel)
+{
+    GtkWidget *widget;
+    GtkWidget *label_widget;
+
+    widget = GTK_WIDGET (tablabel);
+
+    tablabel-&gt;drag_handle_size = DEFAULT_DRAG_HANDLE_SIZE;
+    tablabel-&gt;item = NULL;
+
+    label_widget = gtk_label_new (&quot;Dock item&quot;);
+    gtk_container_add (GTK_CONTAINER (tablabel), label_widget);
+    gtk_widget_show (label_widget);
+
+    tablabel-&gt;active = FALSE;
+    gtk_widget_set_state (GTK_WIDGET (tablabel), GTK_STATE_ACTIVE);
+}
+
+static void
+gdl_dock_tablabel_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+    GdlDockTablabel *tablabel;
+    GtkBin          *bin;
+
+    tablabel = GDL_DOCK_TABLABEL (object);
+
+    switch (prop_id) {
+        case PROP_ITEM:
+            if (tablabel-&gt;item) {
+                g_object_remove_weak_pointer (G_OBJECT (tablabel-&gt;item), 
+                                              (gpointer *) &amp;tablabel-&gt;item);
+                g_signal_handlers_disconnect_by_func (
+                    tablabel-&gt;item, gdl_dock_tablabel_item_notify, tablabel);
+            };
+
+            tablabel-&gt;item = g_value_get_object (value);
+            if (tablabel-&gt;item) {
+                gboolean locked;
+                gchar   *long_name;
+                
+                g_object_add_weak_pointer (G_OBJECT (tablabel-&gt;item), 
+                                           (gpointer *) &amp;tablabel-&gt;item);
+
+                g_signal_connect (tablabel-&gt;item, &quot;notify::locked&quot;,
+                                  G_CALLBACK (gdl_dock_tablabel_item_notify),
+                                  tablabel);
+                g_signal_connect (tablabel-&gt;item, &quot;notify::long_name&quot;,
+                                  G_CALLBACK (gdl_dock_tablabel_item_notify),
+                                  tablabel);
+                g_signal_connect (tablabel-&gt;item, &quot;notify::grip_size&quot;,
+                                  G_CALLBACK (gdl_dock_tablabel_item_notify),
+                                  tablabel);
+
+                g_object_get (tablabel-&gt;item,
+                              &quot;locked&quot;, &amp;locked,
+                              &quot;long_name&quot;, &amp;long_name,
+                              &quot;grip_size&quot;, &amp;tablabel-&gt;drag_handle_size,
+                              NULL);
+
+                if (locked)
+                    tablabel-&gt;drag_handle_size = 0;
+                
+                bin = GTK_BIN (tablabel);
+                if (bin-&gt;child &amp;&amp; g_object_class_find_property (
+                    G_OBJECT_GET_CLASS (bin-&gt;child), &quot;label&quot;))
+                    g_object_set (bin-&gt;child, &quot;label&quot;, long_name, NULL);
+                g_free (long_name);
+            };
+            break;
+            
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_tablabel_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+    GdlDockTablabel *tablabel;
+
+    tablabel = GDL_DOCK_TABLABEL (object);
+
+    switch (prop_id) {
+        case PROP_ITEM:
+            g_value_set_object (value, tablabel-&gt;item);
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_tablabel_item_notify (GObject    *master,
+                               GParamSpec *pspec,
+                               gpointer    data)
+{
+    GdlDockTablabel *tablabel = GDL_DOCK_TABLABEL (data);
+    gboolean         locked;
+    gchar           *label;
+    GtkBin          *bin;
+    
+    g_object_get (master,
+                  &quot;locked&quot;, &amp;locked,
+                  &quot;grip_size&quot;, &amp;tablabel-&gt;drag_handle_size,
+                  &quot;long_name&quot;, &amp;label,
+                  NULL);
+
+    if (locked)
+        tablabel-&gt;drag_handle_size = 0;
+
+    bin = GTK_BIN (tablabel);
+    if (bin-&gt;child &amp;&amp; g_object_class_find_property (
+        G_OBJECT_GET_CLASS (bin-&gt;child), &quot;label&quot;))
+        g_object_set (bin-&gt;child, &quot;label&quot;, label, NULL);
+    g_free (label);
+
+    gtk_widget_queue_resize (GTK_WIDGET (tablabel));
+}
+
+static void
+gdl_dock_tablabel_size_request (GtkWidget      *widget,
+                                GtkRequisition *requisition)
+{
+    GtkBin          *bin;
+    GtkRequisition   child_req;
+    GdlDockTablabel *tablabel;
+
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK_TABLABEL (widget));
+    g_return_if_fail (requisition != NULL);
+
+    tablabel = GDL_DOCK_TABLABEL (widget);
+    bin = GTK_BIN (widget);
+
+    requisition-&gt;width = tablabel-&gt;drag_handle_size;
+    requisition-&gt;height = 0;
+
+    if (bin-&gt;child)
+        gtk_widget_size_request (bin-&gt;child, &amp;child_req);
+    else
+        child_req.width = child_req.height = 0;
+        
+    requisition-&gt;width += child_req.width;
+    requisition-&gt;height += child_req.height;
+
+    requisition-&gt;width += GTK_CONTAINER (widget)-&gt;border_width * 2;
+    requisition-&gt;height += GTK_CONTAINER (widget)-&gt;border_width * 2;
+
+    widget-&gt;requisition = *requisition;
+}
+
+static void
+gdl_dock_tablabel_size_allocate (GtkWidget     *widget,
+                                 GtkAllocation *allocation)
+{
+    GtkBin          *bin;
+    GdlDockTablabel *tablabel;
+    gint             border_width;
+
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK_TABLABEL (widget));
+    g_return_if_fail (allocation != NULL);
+  
+    bin = GTK_BIN (widget);
+    tablabel = GDL_DOCK_TABLABEL (widget);
+
+    border_width = GTK_CONTAINER (widget)-&gt;border_width;
+  
+    widget-&gt;allocation = *allocation;
+
+    if (GTK_WIDGET_REALIZED (widget))
+        gdk_window_move_resize (tablabel-&gt;event_window, 
+                                allocation-&gt;x, 
+                                allocation-&gt;y,
+                                allocation-&gt;width, 
+                                allocation-&gt;height);
+
+    if (bin-&gt;child &amp;&amp; GTK_WIDGET_VISIBLE (bin-&gt;child)) {
+        GtkAllocation  child_allocation;
+
+        child_allocation.x = widget-&gt;allocation.x + border_width;
+        child_allocation.y = widget-&gt;allocation.y + border_width;
+
+        allocation-&gt;width = MAX (1, (int) allocation-&gt;width - 
+                                 (int) tablabel-&gt;drag_handle_size);
+        child_allocation.x += tablabel-&gt;drag_handle_size;
+
+        child_allocation.width = 
+            MAX (1, (int) allocation-&gt;width - 2 * border_width);
+        child_allocation.height = 
+            MAX (1, (int) allocation-&gt;height - 2 * border_width);
+
+        gtk_widget_size_allocate (bin-&gt;child, &amp;child_allocation);
+    }
+}
+
+static void
+gdl_dock_tablabel_paint (GtkWidget      *widget,
+                         GdkEventExpose *event)
+{
+    GdkRectangle     dest, rect;
+    GtkBin          *bin;
+    GdlDockTablabel *tablabel;
+    gint             border_width;
+
+    bin = GTK_BIN (widget);
+    tablabel = GDL_DOCK_TABLABEL (widget);
+    border_width = GTK_CONTAINER (widget)-&gt;border_width;
+
+    rect.x = widget-&gt;allocation.x + border_width;
+    rect.y = widget-&gt;allocation.y + border_width;
+    rect.width = tablabel-&gt;drag_handle_size * HANDLE_RATIO;
+    rect.height = widget-&gt;allocation.height - 2*border_width;
+
+    if (gdk_rectangle_intersect (&amp;event-&gt;area, &amp;rect, &amp;dest)) {
+        gtk_paint_handle (widget-&gt;style, widget-&gt;window, 
+                          tablabel-&gt;active ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE, 
+                          GTK_SHADOW_NONE,
+                          &amp;dest, widget, &quot;dock_tablabel&quot;,
+                          rect.x, rect.y, rect.width, rect.height,
+                          GTK_ORIENTATION_VERTICAL);
+    };
+}
+
+static gint
+gdl_dock_tablabel_expose (GtkWidget      *widget,
+                          GdkEventExpose *event)
+{
+    g_return_val_if_fail (widget != NULL, FALSE);
+    g_return_val_if_fail (GDL_IS_DOCK_TABLABEL (widget), FALSE);
+    g_return_val_if_fail (event != NULL, FALSE);
+
+    if (GTK_WIDGET_VISIBLE (widget) &amp;&amp; GTK_WIDGET_MAPPED (widget)) {
+        GNOME_CALL_PARENT (GTK_WIDGET_CLASS, expose_event, (widget, event));
+        gdl_dock_tablabel_paint (widget, event);
+    };
+  
+    return FALSE;
+}
+
+static gboolean 
+gdl_dock_tablabel_button_event (GtkWidget      *widget,
+                                GdkEventButton *event)
+{
+    GdlDockTablabel *tablabel;
+    gboolean         event_handled;
+  
+    g_return_val_if_fail (widget != NULL, FALSE);
+    g_return_val_if_fail (GDL_IS_DOCK_TABLABEL (widget), FALSE);
+    g_return_val_if_fail (event != NULL, FALSE);
+    
+    tablabel = GDL_DOCK_TABLABEL (widget);
+    
+    event_handled = FALSE;
+
+    if (event-&gt;window != tablabel-&gt;event_window)
+        return FALSE;
+    
+    switch (event-&gt;type) {
+        case GDK_BUTTON_PRESS:
+            if (tablabel-&gt;active) {
+                gboolean in_handle;
+                gint     rel_x, rel_y;
+                guint    border_width;
+                GtkBin  *bin;
+
+                bin = GTK_BIN (widget);
+                border_width = GTK_CONTAINER (widget)-&gt;border_width;
+
+                rel_x = event-&gt;x - border_width;
+                rel_y = event-&gt;y - border_width;
+
+                /* Check if user clicked on the drag handle. */      
+                in_handle = (rel_x &lt; tablabel-&gt;drag_handle_size * HANDLE_RATIO) &amp;&amp;
+                    (rel_x &gt; 0);
+
+                if (event-&gt;button == 1) {
+                    tablabel-&gt;pre_drag = TRUE;
+                    tablabel-&gt;drag_start_event = *event;
+                }
+                else {
+                    g_signal_emit (widget, 
+                                   dock_tablabel_signals [BUTTON_PRESSED_HANDLE],
+                                   0,
+                                   event);
+                }
+                
+                event_handled = TRUE;
+            }
+            break;
+
+        case GDK_BUTTON_RELEASE:
+            tablabel-&gt;pre_drag = FALSE;
+            break;
+
+        default:
+            break;
+    }
+    
+    if (!event_handled) {
+        /* propagate the event to the parent's gdkwindow */
+        GdkEventButton e;
+
+        e = *event;
+        e.window = gtk_widget_get_parent_window (widget);
+        e.x += widget-&gt;allocation.x;
+        e.y += widget-&gt;allocation.y;
+        
+        gdk_event_put ((GdkEvent *) &amp;e);
+    };
+
+    return event_handled;
+}
+
+static gboolean 
+gdl_dock_tablabel_motion_event (GtkWidget      *widget,
+                                GdkEventMotion *event)
+{
+    GdlDockTablabel *tablabel;
+    gboolean         event_handled;
+  
+    g_return_val_if_fail (widget != NULL, FALSE);
+    g_return_val_if_fail (GDL_IS_DOCK_TABLABEL (widget), FALSE);
+    g_return_val_if_fail (event != NULL, FALSE);
+    
+    tablabel = GDL_DOCK_TABLABEL (widget);
+    
+    event_handled = FALSE;
+
+    if (event-&gt;window != tablabel-&gt;event_window)
+        return FALSE;
+    
+    if (tablabel-&gt;pre_drag) {
+        if (gtk_drag_check_threshold (widget,
+                                      tablabel-&gt;drag_start_event.x,
+                                      tablabel-&gt;drag_start_event.y,
+                                      event-&gt;x,
+                                      event-&gt;y)) {
+            tablabel-&gt;pre_drag = FALSE;
+            g_signal_emit (widget, 
+                           dock_tablabel_signals [BUTTON_PRESSED_HANDLE],
+                           0,
+                           &amp;tablabel-&gt;drag_start_event);
+            event_handled = TRUE;
+        }
+    }
+    
+    if (!event_handled) {
+        /* propagate the event to the parent's gdkwindow */
+        GdkEventMotion e;
+
+        e = *event;
+        e.window = gtk_widget_get_parent_window (widget);
+        e.x += widget-&gt;allocation.x;
+        e.y += widget-&gt;allocation.y;
+        
+        gdk_event_put ((GdkEvent *) &amp;e);
+    };
+
+    return event_handled;
+}
+
+static void   
+gdl_dock_tablabel_realize (GtkWidget *widget)
+{
+    GdlDockTablabel *tablabel;
+    GdkWindowAttr attributes;
+    int attributes_mask;
+    
+    tablabel = GDL_DOCK_TABLABEL (widget);
+    
+    attributes.window_type = GDK_WINDOW_CHILD;
+    attributes.x = widget-&gt;allocation.x;
+    attributes.y = widget-&gt;allocation.y;
+    attributes.width = widget-&gt;allocation.width;
+    attributes.height = widget-&gt;allocation.height;
+    attributes.wclass = GDK_INPUT_ONLY;
+    attributes.event_mask = gtk_widget_get_events (widget);
+    attributes.event_mask |= (GDK_EXPOSURE_MASK | 
+                              GDK_BUTTON_PRESS_MASK |
+                              GDK_BUTTON_RELEASE_MASK | 
+                              GDK_ENTER_NOTIFY_MASK | 
+                              GDK_POINTER_MOTION_MASK | 
+                              GDK_LEAVE_NOTIFY_MASK);
+    attributes_mask = GDK_WA_X | GDK_WA_Y;
+    
+    widget-&gt;window = gtk_widget_get_parent_window (widget);
+    g_object_ref (widget-&gt;window);
+    
+    tablabel-&gt;event_window = 
+        gdk_window_new (gtk_widget_get_parent_window (widget),
+                        &amp;attributes, attributes_mask);
+    gdk_window_set_user_data (tablabel-&gt;event_window, widget);
+    
+    widget-&gt;style = gtk_style_attach (widget-&gt;style, widget-&gt;window);
+    
+    GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED);
+}
+
+static void   
+gdl_dock_tablabel_unrealize (GtkWidget *widget)
+{
+    GdlDockTablabel *tablabel = GDL_DOCK_TABLABEL (widget);
+    
+    if (tablabel-&gt;event_window) {
+        gdk_window_set_user_data (tablabel-&gt;event_window, NULL);
+        gdk_window_destroy (tablabel-&gt;event_window);
+        tablabel-&gt;event_window = NULL;
+    }
+    
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, unrealize, (widget));
+}
+
+static void  
+gdl_dock_tablabel_map (GtkWidget *widget)
+{
+    GdlDockTablabel *tablabel = GDL_DOCK_TABLABEL (widget);
+    
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, map, (widget));
+    
+    gdk_window_show (tablabel-&gt;event_window);
+}
+
+static void   
+gdl_dock_tablabel_unmap (GtkWidget *widget)
+{
+    GdlDockTablabel *tablabel = GDL_DOCK_TABLABEL (widget);
+
+    gdk_window_hide (tablabel-&gt;event_window);
+
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, unmap, (widget));
+}
+
+/* ----- Public interface ----- */
+
+GtkWidget *
+gdl_dock_tablabel_new (GdlDockItem *item)
+{
+    GdlDockTablabel *tablabel;
+
+    tablabel = GDL_DOCK_TABLABEL (g_object_new (GDL_TYPE_DOCK_TABLABEL,
+                                                &quot;item&quot;, item,
+                                                NULL));
+    
+    return GTK_WIDGET (tablabel);
+}
+
+void
+gdl_dock_tablabel_activate (GdlDockTablabel *tablabel)
+{
+    g_return_if_fail (tablabel != NULL);
+
+    tablabel-&gt;active = TRUE;
+    gtk_widget_set_state (GTK_WIDGET (tablabel), GTK_STATE_NORMAL);
+}
+
+void
+gdl_dock_tablabel_deactivate (GdlDockTablabel *tablabel)
+{
+    g_return_if_fail (tablabel != NULL);
+
+    tablabel-&gt;active = FALSE;
+    /* yeah, i know it contradictive */
+    gtk_widget_set_state (GTK_WIDGET (tablabel), GTK_STATE_ACTIVE);
+}

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * gdl-dock-tablabel.h
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifndef __GDL_DOCK_TABLABEL_H__
+#define __GDL_DOCK_TABLABEL_H__
+
+#include &lt;gtk/gtk.h&gt;
+#include &lt;gdl/gdl-dock-item.h&gt;
+
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK_TABLABEL            (gdl_dock_tablabel_get_type ())
+#define GDL_DOCK_TABLABEL(obj)            (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_TABLABEL, GdlDockTablabel))
+#define GDL_DOCK_TABLABEL_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_TABLABEL, GdlDockTablabelClass))
+#define GDL_IS_DOCK_TABLABEL(obj)         (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_TABLABEL))
+#define GDL_IS_DOCK_TABLABEL_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_TABLABEL))
+#define GDL_DOCK_TABLABEL_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), GTK_TYPE_DOCK_TABLABEL, GdlDockTablabelClass))
+
+/* data types &amp; structures */
+typedef struct _GdlDockTablabel      GdlDockTablabel;
+typedef struct _GdlDockTablabelClass GdlDockTablabelClass;
+
+struct _GdlDockTablabel {
+    GtkBin          parent;
+
+    guint           drag_handle_size;
+    GtkWidget      *item;
+    GdkWindow      *event_window;
+    gboolean        active;
+
+    GdkEventButton  drag_start_event;
+    gboolean        pre_drag;
+};
+
+struct _GdlDockTablabelClass {
+    GtkBinClass      parent_class;
+
+    void            (*button_pressed_handle)  (GdlDockTablabel *tablabel,
+                                               GdkEventButton  *event);
+};
+
+/* public interface */
+ 
+GtkWidget     *gdl_dock_tablabel_new           (GdlDockItem *item);
+GType          gdl_dock_tablabel_get_type      (void);
+
+void           gdl_dock_tablabel_activate      (GdlDockTablabel *tablabel);
+void           gdl_dock_tablabel_deactivate    (GdlDockTablabel *tablabel);
+
+G_END_DECLS
+
+#endif

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.c	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.c	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,1206 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;gdk/gdkx.h&gt;
+#include &lt;libgnome/gnome-macros.h&gt;
+
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock.h&quot;
+#include &quot;gdl-dock-master.h&quot;
+#include &quot;gdl-dock-paned.h&quot;
+#include &quot;gdl-dock-notebook.h&quot;
+#include &quot;gdl-dock-placeholder.h&quot;
+
+#include &quot;libgdlmarshal.h&quot;
+
+
+/* ----- Private prototypes ----- */
+
+static void  gdl_dock_class_init      (GdlDockClass *class);
+static void  gdl_dock_instance_init   (GdlDock *dock);
+
+static GObject *gdl_dock_constructor  (GType                  type,
+                                       guint                  n_construct_properties,
+                                       GObjectConstructParam *construct_param);
+static void  gdl_dock_set_property    (GObject      *object,
+                                       guint         prop_id,
+                                       const GValue *value,
+                                       GParamSpec   *pspec);
+static void  gdl_dock_get_property    (GObject      *object,
+                                       guint         prop_id,
+                                       GValue       *value,
+                                       GParamSpec   *pspec);
+static void  gdl_dock_notify_cb       (GObject      *object,
+                                       GParamSpec   *pspec,
+                                       gpointer      user_data);
+
+static void  gdl_dock_set_title       (GdlDock      *dock);
+
+static void  gdl_dock_destroy         (GtkObject    *object);
+
+static void  gdl_dock_size_request    (GtkWidget      *widget,
+                                       GtkRequisition *requisition);
+static void  gdl_dock_size_allocate   (GtkWidget      *widget,
+                                       GtkAllocation  *allocation);
+static void  gdl_dock_map             (GtkWidget      *widget);
+static void  gdl_dock_unmap           (GtkWidget      *widget);
+static void  gdl_dock_show            (GtkWidget      *widget);
+static void  gdl_dock_hide            (GtkWidget      *widget);
+
+static void  gdl_dock_add             (GtkContainer *container,
+                                       GtkWidget    *widget);
+static void  gdl_dock_remove          (GtkContainer *container,
+                                       GtkWidget    *widget);
+static void  gdl_dock_forall          (GtkContainer *container,
+                                       gboolean      include_internals,
+                                       GtkCallback   callback,
+                                       gpointer      callback_data);
+static GtkType  gdl_dock_child_type   (GtkContainer *container);
+
+static void     gdl_dock_detach       (GdlDockObject    *object,
+                                       gboolean          recursive);
+static void     gdl_dock_reduce       (GdlDockObject    *object);
+static gboolean gdl_dock_dock_request (GdlDockObject    *object,
+                                       gint              x,
+                                       gint              y,
+                                       GdlDockRequest   *request);
+static void     gdl_dock_dock         (GdlDockObject    *object,
+                                       GdlDockObject    *requestor,
+                                       GdlDockPlacement  position,
+                                       GValue           *other_data);
+static gboolean gdl_dock_reorder      (GdlDockObject    *object,
+                                       GdlDockObject    *requestor,
+                                       GdlDockPlacement  new_position,
+                                       GValue           *other_data);
+
+static gboolean gdl_dock_floating_window_delete_event_cb (GtkWidget *widget);
+
+static gboolean gdl_dock_child_placement  (GdlDockObject    *object,
+                                           GdlDockObject    *child,
+                                           GdlDockPlacement *placement);
+
+static void     gdl_dock_present          (GdlDockObject    *object,
+                                           GdlDockObject    *child);
+
+
+/* ----- Class variables and definitions ----- */
+
+struct _GdlDockPrivate
+{
+    /* for floating docks */
+    gboolean            floating;
+    GtkWidget          *window;
+    gboolean            auto_title;
+    
+    gint                float_x;
+    gint                float_y;
+    gint                width;
+    gint                height;
+    
+    /* auxiliary fields */
+    GdkGC              *xor_gc;
+};
+
+enum {
+    LAYOUT_CHANGED,
+    LAST_SIGNAL
+};
+
+enum {
+    PROP_0,
+    PROP_FLOATING,
+    PROP_DEFAULT_TITLE,
+    PROP_WIDTH,
+    PROP_HEIGHT,
+    PROP_FLOAT_X,
+    PROP_FLOAT_Y
+};
+
+static guint dock_signals [LAST_SIGNAL] = { 0 };
+
+#define SPLIT_RATIO  0.3
+
+
+/* ----- Private functions ----- */
+
+GNOME_CLASS_BOILERPLATE (GdlDock, gdl_dock, GdlDockObject, GDL_TYPE_DOCK_OBJECT);
+
+static void
+gdl_dock_class_init (GdlDockClass *klass)
+{
+    GObjectClass       *g_object_class;
+    GtkObjectClass     *gtk_object_class;
+    GtkWidgetClass     *widget_class;
+    GtkContainerClass  *container_class;
+    GdlDockObjectClass *object_class;
+    
+    g_object_class = G_OBJECT_CLASS (klass);
+    gtk_object_class = GTK_OBJECT_CLASS (klass);
+    widget_class = GTK_WIDGET_CLASS (klass);
+    container_class = GTK_CONTAINER_CLASS (klass);
+    object_class = GDL_DOCK_OBJECT_CLASS (klass);
+    
+    g_object_class-&gt;constructor = gdl_dock_constructor;
+    g_object_class-&gt;set_property = gdl_dock_set_property;
+    g_object_class-&gt;get_property = gdl_dock_get_property;
+    
+    /* properties */
+
+    g_object_class_install_property (
+        g_object_class, PROP_FLOATING,
+        g_param_spec_boolean (&quot;floating&quot;, _(&quot;Floating&quot;),
+                              _(&quot;Whether the dock is floating in its own window&quot;),
+                              FALSE,
+                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
+                              GDL_DOCK_PARAM_EXPORT));
+    
+    g_object_class_install_property (
+        g_object_class, PROP_DEFAULT_TITLE,
+        g_param_spec_string (&quot;default_title&quot;, _(&quot;Default title&quot;),
+                             _(&quot;Default title for the newly created floating docks&quot;),
+                             NULL,
+                             G_PARAM_READWRITE));
+    
+    g_object_class_install_property (
+        g_object_class, PROP_WIDTH,
+        g_param_spec_int (&quot;width&quot;, _(&quot;Width&quot;),
+                          _(&quot;Width for the dock when it's of floating type&quot;),
+                          -1, G_MAXINT, -1,
+                          G_PARAM_READWRITE | G_PARAM_CONSTRUCT |
+                          GDL_DOCK_PARAM_EXPORT));
+    
+    g_object_class_install_property (
+        g_object_class, PROP_HEIGHT,
+        g_param_spec_int (&quot;height&quot;, _(&quot;Height&quot;),
+                          _(&quot;Height for the dock when it's of floating type&quot;),
+                          -1, G_MAXINT, -1,
+                          G_PARAM_READWRITE | G_PARAM_CONSTRUCT |
+                          GDL_DOCK_PARAM_EXPORT));
+    
+    g_object_class_install_property (
+        g_object_class, PROP_FLOAT_X,
+        g_param_spec_int (&quot;floatx&quot;, _(&quot;Float X&quot;),
+                          _(&quot;X coordinate for a floating dock&quot;),
+                          G_MININT, G_MAXINT, 0,
+                          G_PARAM_READWRITE | G_PARAM_CONSTRUCT |
+                          GDL_DOCK_PARAM_EXPORT));
+    
+    g_object_class_install_property (
+        g_object_class, PROP_FLOAT_Y,
+        g_param_spec_int (&quot;floaty&quot;, _(&quot;Float Y&quot;),
+                          _(&quot;Y coordinate for a floating dock&quot;),
+                          G_MININT, G_MAXINT, 0,
+                          G_PARAM_READWRITE | G_PARAM_CONSTRUCT |
+                          GDL_DOCK_PARAM_EXPORT));
+    
+    gtk_object_class-&gt;destroy = gdl_dock_destroy;
+
+    widget_class-&gt;size_request = gdl_dock_size_request;
+    widget_class-&gt;size_allocate = gdl_dock_size_allocate;
+    widget_class-&gt;map = gdl_dock_map;
+    widget_class-&gt;unmap = gdl_dock_unmap;
+    widget_class-&gt;show = gdl_dock_show;
+    widget_class-&gt;hide = gdl_dock_hide;
+    
+    container_class-&gt;add = gdl_dock_add;
+    container_class-&gt;remove = gdl_dock_remove;
+    container_class-&gt;forall = gdl_dock_forall;
+    container_class-&gt;child_type = gdl_dock_child_type;
+    
+    object_class-&gt;is_compound = TRUE;
+    
+    object_class-&gt;detach = gdl_dock_detach;
+    object_class-&gt;reduce = gdl_dock_reduce;
+    object_class-&gt;dock_request = gdl_dock_dock_request;
+    object_class-&gt;dock = gdl_dock_dock;
+    object_class-&gt;reorder = gdl_dock_reorder;    
+    object_class-&gt;child_placement = gdl_dock_child_placement;
+    object_class-&gt;present = gdl_dock_present;
+    
+    /* signals */
+
+    dock_signals [LAYOUT_CHANGED] = 
+        g_signal_new (&quot;layout_changed&quot;, 
+                      G_TYPE_FROM_CLASS (klass),
+                      G_SIGNAL_RUN_LAST,
+                      G_STRUCT_OFFSET (GdlDockClass, layout_changed),
+                      NULL, /* accumulator */
+                      NULL, /* accu_data */
+                      gdl_marshal_VOID__VOID,
+                      G_TYPE_NONE, /* return type */
+                      0);
+
+    klass-&gt;layout_changed = NULL;
+}
+
+static void
+gdl_dock_instance_init (GdlDock *dock)
+{
+    GTK_WIDGET_SET_FLAGS (GTK_WIDGET (dock), GTK_NO_WINDOW);
+
+    dock-&gt;root = NULL;
+    dock-&gt;_priv = g_new0 (GdlDockPrivate, 1);
+    dock-&gt;_priv-&gt;width = -1;
+    dock-&gt;_priv-&gt;height = -1;
+}
+
+static gboolean 
+gdl_dock_floating_configure_event_cb (GtkWidget         *widget,
+                                      GdkEventConfigure *event,
+                                      gpointer           user_data)
+{
+    GdlDock *dock;
+    
+    g_return_val_if_fail (user_data != NULL &amp;&amp; GDL_IS_DOCK (user_data), TRUE);
+
+    dock = GDL_DOCK (user_data);
+    dock-&gt;_priv-&gt;float_x = event-&gt;x;
+    dock-&gt;_priv-&gt;float_y = event-&gt;y;
+    dock-&gt;_priv-&gt;width = event-&gt;width;
+    dock-&gt;_priv-&gt;height = event-&gt;height;
+
+    return FALSE;
+}
+
+static GObject *
+gdl_dock_constructor (GType                  type,
+                      guint                  n_construct_properties,
+                      GObjectConstructParam *construct_param)
+{
+    GObject *g_object;
+    
+    g_object = GNOME_CALL_PARENT_WITH_DEFAULT (G_OBJECT_CLASS, 
+                                               constructor, 
+                                               (type,
+                                                n_construct_properties,
+                                                construct_param),
+                                               NULL);
+    if (g_object) {
+        GdlDock *dock = GDL_DOCK (g_object);
+        GdlDockMaster *master;
+        
+        /* create a master for the dock if none was provided in the construction */
+        master = GDL_DOCK_OBJECT_GET_MASTER (GDL_DOCK_OBJECT (dock));
+        if (!master) {
+            GDL_DOCK_OBJECT_UNSET_FLAGS (dock, GDL_DOCK_AUTOMATIC);
+            master = g_object_new (GDL_TYPE_DOCK_MASTER, NULL);
+            /* the controller owns the master ref */
+            gdl_dock_object_bind (GDL_DOCK_OBJECT (dock), G_OBJECT (master));
+        }
+
+        if (dock-&gt;_priv-&gt;floating) {
+            GdlDockObject *controller;
+            
+            /* create floating window for this dock */
+            dock-&gt;_priv-&gt;window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+            g_object_set_data (G_OBJECT (dock-&gt;_priv-&gt;window), &quot;dock&quot;, dock);
+            
+            /* set position and default size */
+            gtk_window_set_position (GTK_WINDOW (dock-&gt;_priv-&gt;window),
+                                     GTK_WIN_POS_MOUSE);
+            gtk_window_set_default_size (GTK_WINDOW (dock-&gt;_priv-&gt;window),
+                                         dock-&gt;_priv-&gt;width,
+                                         dock-&gt;_priv-&gt;height);
+            gtk_window_set_type_hint (GTK_WINDOW (dock-&gt;_priv-&gt;window),
+                                      GDK_WINDOW_TYPE_HINT_NORMAL);
+            
+            /* metacity ignores this */
+            gtk_window_move (GTK_WINDOW (dock-&gt;_priv-&gt;window),
+                             dock-&gt;_priv-&gt;float_x,
+                             dock-&gt;_priv-&gt;float_y);
+            
+            /* connect to the configure event so we can track down window geometry */
+            g_signal_connect (dock-&gt;_priv-&gt;window, &quot;configure_event&quot;,
+                              (GCallback) gdl_dock_floating_configure_event_cb,
+                              dock);
+            
+            /* set the title and connect to the long_name notify queue
+               so we can reset the title when this prop changes */
+            gdl_dock_set_title (dock);
+            g_signal_connect (dock, &quot;notify::long_name&quot;,
+                              (GCallback) gdl_dock_notify_cb, NULL);
+            
+            /* set transient for the first dock if that is a non-floating dock */
+            controller = gdl_dock_master_get_controller (master);
+            if (controller &amp;&amp; GDL_IS_DOCK (controller)) {
+                gboolean first_is_floating;
+                g_object_get (controller, &quot;floating&quot;, &amp;first_is_floating, NULL);
+                if (!first_is_floating) {
+                    GtkWidget *toplevel =
+                        gtk_widget_get_toplevel (GTK_WIDGET (controller));
+
+                    if (GTK_IS_WINDOW (toplevel))
+                        gtk_window_set_transient_for (GTK_WINDOW (dock-&gt;_priv-&gt;window),
+                                                      GTK_WINDOW (toplevel));
+                }
+            }
+
+            gtk_container_add (GTK_CONTAINER (dock-&gt;_priv-&gt;window), GTK_WIDGET (dock));
+    
+            g_signal_connect (dock-&gt;_priv-&gt;window, &quot;delete_event&quot;,
+                              G_CALLBACK (gdl_dock_floating_window_delete_event_cb), 
+                              NULL);
+        }
+        GDL_DOCK_OBJECT_SET_FLAGS (dock, GDL_DOCK_ATTACHED);
+    }
+    
+    return g_object;
+}
+
+static void
+gdl_dock_set_property  (GObject      *object,
+                        guint         prop_id,
+                        const GValue *value,
+                        GParamSpec   *pspec)
+{
+    GdlDock *dock = GDL_DOCK (object);
+    
+    switch (prop_id) {
+        case PROP_FLOATING:
+            dock-&gt;_priv-&gt;floating = g_value_get_boolean (value);
+            break;
+        case PROP_DEFAULT_TITLE:
+            if (GDL_DOCK_OBJECT (object)-&gt;master)
+                g_object_set (GDL_DOCK_OBJECT (object)-&gt;master,
+                              &quot;default_title&quot;, g_value_get_string (value),
+                              NULL);
+            break;
+        case PROP_WIDTH:
+            dock-&gt;_priv-&gt;width = g_value_get_int (value);
+            break;
+        case PROP_HEIGHT:
+            dock-&gt;_priv-&gt;height = g_value_get_int (value);
+            break;
+        case PROP_FLOAT_X:
+            dock-&gt;_priv-&gt;float_x = g_value_get_int (value);
+            break;
+        case PROP_FLOAT_Y:
+            dock-&gt;_priv-&gt;float_y = g_value_get_int (value);
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+
+    switch (prop_id) {
+        case PROP_WIDTH:
+        case PROP_HEIGHT:
+        case PROP_FLOAT_X:
+        case PROP_FLOAT_Y:
+            if (dock-&gt;_priv-&gt;floating &amp;&amp; dock-&gt;_priv-&gt;window) {
+                gtk_window_resize (GTK_WINDOW (dock-&gt;_priv-&gt;window),
+                                   dock-&gt;_priv-&gt;width,
+                                   dock-&gt;_priv-&gt;height);
+            }
+            break;
+    }
+}
+
+static void
+gdl_dock_get_property  (GObject      *object,
+                        guint         prop_id,
+                        GValue       *value,
+                        GParamSpec   *pspec)
+{
+    GdlDock *dock = GDL_DOCK (object);
+
+    switch (prop_id) {
+        case PROP_FLOATING:
+            g_value_set_boolean (value, dock-&gt;_priv-&gt;floating);
+            break;
+        case PROP_DEFAULT_TITLE:
+            if (GDL_DOCK_OBJECT (object)-&gt;master) {
+                gchar *default_title;
+                g_object_get (GDL_DOCK_OBJECT (object)-&gt;master,
+                              &quot;default_title&quot;, &amp;default_title,
+                              NULL);
+                g_value_take_string (value, default_title);
+            }
+            else
+                g_value_set_string (value, NULL);
+            break;
+        case PROP_WIDTH:
+            g_value_set_int (value, dock-&gt;_priv-&gt;width);
+            break;
+        case PROP_HEIGHT:
+            g_value_set_int (value, dock-&gt;_priv-&gt;height);
+            break;
+        case PROP_FLOAT_X:
+            g_value_set_int (value, dock-&gt;_priv-&gt;float_x);
+            break;
+        case PROP_FLOAT_Y:
+            g_value_set_int (value, dock-&gt;_priv-&gt;float_y);
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_set_title (GdlDock *dock)
+{
+    GdlDockObject *object = GDL_DOCK_OBJECT (dock);
+    gchar         *title = NULL;
+    gboolean       free_title = FALSE;
+    
+    if (!dock-&gt;_priv-&gt;window)
+        return;
+    
+    if (!dock-&gt;_priv-&gt;auto_title &amp;&amp; object-&gt;long_name) {
+        title = object-&gt;long_name;
+    }
+    else if (object-&gt;master) {
+        g_object_get (object-&gt;master, &quot;default_title&quot;, &amp;title, NULL);
+        free_title = TRUE;
+    }
+
+    if (!title &amp;&amp; dock-&gt;root) {
+        g_object_get (dock-&gt;root, &quot;long_name&quot;, &amp;title, NULL);
+        free_title = TRUE;
+    }
+    
+    if (!title) {
+        /* set a default title in the long_name */
+        dock-&gt;_priv-&gt;auto_title = TRUE;
+        free_title = FALSE;
+        title = object-&gt;long_name = g_strdup_printf (
+            _(&quot;Dock #%d&quot;), GDL_DOCK_MASTER (object-&gt;master)-&gt;dock_number++);
+    }
+
+    gtk_window_set_title (GTK_WINDOW (dock-&gt;_priv-&gt;window), title);
+    if (free_title)
+        g_free (title);
+}
+
+static void
+gdl_dock_notify_cb (GObject    *object,
+                    GParamSpec *pspec,
+                    gpointer    user_data)
+{
+    GdlDock *dock;
+    
+    g_return_if_fail (object != NULL || GDL_IS_DOCK (object));
+    
+    dock = GDL_DOCK (object);
+    dock-&gt;_priv-&gt;auto_title = FALSE;
+    gdl_dock_set_title (dock);
+}
+
+static void
+gdl_dock_destroy (GtkObject *object)
+{
+    GdlDock *dock = GDL_DOCK (object);
+
+    if (dock-&gt;_priv) {
+        GdlDockPrivate *priv = dock-&gt;_priv;
+        dock-&gt;_priv = NULL;
+
+        if (priv-&gt;window) {
+            gtk_widget_destroy (priv-&gt;window);
+            priv-&gt;floating = FALSE;
+            priv-&gt;window = NULL;
+        }
+        
+        /* destroy the xor gc */
+        if (priv-&gt;xor_gc) {
+            g_object_unref (priv-&gt;xor_gc);
+            priv-&gt;xor_gc = NULL;
+        }
+
+        g_free (priv);
+    }
+    
+    GNOME_CALL_PARENT (GTK_OBJECT_CLASS, destroy, (object));
+}
+
+static void
+gdl_dock_size_request (GtkWidget      *widget,
+                       GtkRequisition *requisition)
+{
+    GdlDock      *dock;
+    GtkContainer *container;
+    guint         border_width;
+
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK (widget));
+
+    dock = GDL_DOCK (widget);
+    container = GTK_CONTAINER (widget);
+    border_width = container-&gt;border_width;
+
+    /* make request to root */
+    if (dock-&gt;root &amp;&amp; GTK_WIDGET_VISIBLE (dock-&gt;root))
+        gtk_widget_size_request (GTK_WIDGET (dock-&gt;root), requisition);
+    else {
+        requisition-&gt;width = 0;
+        requisition-&gt;height = 0;
+    };
+
+    requisition-&gt;width += 2 * border_width;
+    requisition-&gt;height += 2 * border_width;
+
+    widget-&gt;requisition = *requisition;
+}
+
+static void
+gdl_dock_size_allocate (GtkWidget     *widget,
+                        GtkAllocation *allocation)
+{
+    GdlDock      *dock;
+    GtkContainer *container;
+    guint         border_width;
+
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK (widget));
+    
+    dock = GDL_DOCK (widget);
+    container = GTK_CONTAINER (widget);
+    border_width = container-&gt;border_width;
+
+    widget-&gt;allocation = *allocation;
+
+    /* reduce allocation by border width */
+    allocation-&gt;x += border_width;
+    allocation-&gt;y += border_width;
+    allocation-&gt;width = MAX (1, allocation-&gt;width - 2 * border_width);
+    allocation-&gt;height = MAX (1, allocation-&gt;height - 2 * border_width);
+
+    if (dock-&gt;root &amp;&amp; GTK_WIDGET_VISIBLE (dock-&gt;root))
+        gtk_widget_size_allocate (GTK_WIDGET (dock-&gt;root), allocation);
+}
+
+static void
+gdl_dock_map (GtkWidget *widget)
+{
+    GtkWidget *child;
+    GdlDock   *dock;
+
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK (widget));
+
+    dock = GDL_DOCK (widget);
+
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, map, (widget));
+
+    if (dock-&gt;root) {
+        child = GTK_WIDGET (dock-&gt;root);
+        if (GTK_WIDGET_VISIBLE (child) &amp;&amp; !GTK_WIDGET_MAPPED (child))
+            gtk_widget_map (child);
+    }
+}
+
+static void
+gdl_dock_unmap (GtkWidget *widget)
+{
+    GtkWidget *child;
+    GdlDock   *dock;
+    
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK (widget));
+
+    dock = GDL_DOCK (widget);
+
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, unmap, (widget));
+
+    if (dock-&gt;root) {
+        child = GTK_WIDGET (dock-&gt;root);
+        if (GTK_WIDGET_VISIBLE (child) &amp;&amp; GTK_WIDGET_MAPPED (child))
+            gtk_widget_unmap (child);
+    }
+    
+    if (dock-&gt;_priv-&gt;window)
+        gtk_widget_unmap (dock-&gt;_priv-&gt;window);
+}
+
+static void
+gdl_dock_foreach_automatic (GdlDockObject *object,
+                            gpointer       user_data)
+{
+    void (* function) (GtkWidget *) = user_data;
+
+    if (GDL_DOCK_OBJECT_AUTOMATIC (object))
+        (* function) (GTK_WIDGET (object));
+}
+
+static void
+gdl_dock_show (GtkWidget *widget)
+{
+    GdlDock *dock;
+    
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK (widget));
+    
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, show, (widget));
+    
+    dock = GDL_DOCK (widget);
+    if (dock-&gt;_priv-&gt;floating &amp;&amp; dock-&gt;_priv-&gt;window)
+        gtk_widget_show (dock-&gt;_priv-&gt;window);
+
+    if (GDL_DOCK_IS_CONTROLLER (dock)) {
+        gdl_dock_master_foreach_toplevel (GDL_DOCK_OBJECT_GET_MASTER (dock),
+                                          FALSE, (GFunc) gdl_dock_foreach_automatic,
+                                          gtk_widget_show);
+    }
+}
+
+static void
+gdl_dock_hide (GtkWidget *widget)
+{
+    GdlDock *dock;
+    
+    g_return_if_fail (widget != NULL);
+    g_return_if_fail (GDL_IS_DOCK (widget));
+    
+    GNOME_CALL_PARENT (GTK_WIDGET_CLASS, hide, (widget));
+    
+    dock = GDL_DOCK (widget);
+    if (dock-&gt;_priv-&gt;floating &amp;&amp; dock-&gt;_priv-&gt;window)
+        gtk_widget_hide (dock-&gt;_priv-&gt;window);
+
+    if (GDL_DOCK_IS_CONTROLLER (dock)) {
+        gdl_dock_master_foreach_toplevel (GDL_DOCK_OBJECT_GET_MASTER (dock),
+                                          FALSE, (GFunc) gdl_dock_foreach_automatic,
+                                          gtk_widget_hide);
+    }
+}
+
+static void
+gdl_dock_add (GtkContainer *container,
+              GtkWidget    *widget)
+{
+    g_return_if_fail (container != NULL);
+    g_return_if_fail (GDL_IS_DOCK (container));
+    g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
+
+    gdl_dock_add_item (GDL_DOCK (container), 
+                       GDL_DOCK_ITEM (widget), 
+                       GDL_DOCK_TOP);  /* default position */
+}
+
+static void
+gdl_dock_remove (GtkContainer *container,
+                 GtkWidget    *widget)
+{
+    GdlDock  *dock;
+    gboolean  was_visible;
+
+    g_return_if_fail (container != NULL);
+    g_return_if_fail (widget != NULL);
+
+    dock = GDL_DOCK (container);
+    was_visible = GTK_WIDGET_VISIBLE (widget);
+
+    if (GTK_WIDGET (dock-&gt;root) == widget) {
+        dock-&gt;root = NULL;
+        GDL_DOCK_OBJECT_UNSET_FLAGS (widget, GDL_DOCK_ATTACHED);
+        gtk_widget_unparent (widget);
+
+        if (was_visible &amp;&amp; GTK_WIDGET_VISIBLE (GTK_WIDGET (container)))
+            gtk_widget_queue_resize (GTK_WIDGET (dock));
+    }
+}
+
+static void
+gdl_dock_forall (GtkContainer *container,
+                 gboolean      include_internals,
+                 GtkCallback   callback,
+                 gpointer      callback_data)
+{
+    GdlDock *dock;
+
+    g_return_if_fail (container != NULL);
+    g_return_if_fail (GDL_IS_DOCK (container));
+    g_return_if_fail (callback != NULL);
+
+    dock = GDL_DOCK (container);
+
+    if (dock-&gt;root)
+        (*callback) (GTK_WIDGET (dock-&gt;root), callback_data);
+}
+
+static GtkType
+gdl_dock_child_type (GtkContainer *container)
+{
+    return GDL_TYPE_DOCK_ITEM;
+}
+
+static void
+gdl_dock_detach (GdlDockObject *object,
+                 gboolean       recursive)
+{
+    GdlDock *dock = GDL_DOCK (object);
+    
+    /* detach children */
+    if (recursive &amp;&amp; dock-&gt;root) {
+        gdl_dock_object_detach (dock-&gt;root, recursive);
+    }
+    GDL_DOCK_OBJECT_UNSET_FLAGS (object, GDL_DOCK_ATTACHED);
+}
+
+static void
+gdl_dock_reduce (GdlDockObject *object)
+{
+    GdlDock *dock = GDL_DOCK (object);
+    
+    if (dock-&gt;root)
+        return;
+    
+    if (GDL_DOCK_OBJECT_AUTOMATIC (dock)) {
+        gtk_widget_destroy (GTK_WIDGET (dock));
+
+    } else if (!GDL_DOCK_OBJECT_ATTACHED (dock)) {
+        /* if the user explicitly detached the object */
+        if (dock-&gt;_priv-&gt;floating)
+            gtk_widget_hide (GTK_WIDGET (dock));
+        else {
+            GtkWidget *widget = GTK_WIDGET (object);
+            if (widget-&gt;parent) 
+                gtk_container_remove (GTK_CONTAINER (widget-&gt;parent), widget);
+        }
+    }
+}
+
+static gboolean
+gdl_dock_dock_request (GdlDockObject  *object,
+                       gint            x,
+                       gint            y,
+                       GdlDockRequest *request)
+{
+    GdlDock            *dock;
+    guint               bw;
+    gint                rel_x, rel_y;
+    GtkAllocation      *alloc;
+    gboolean            may_dock = FALSE;
+    GdlDockRequest      my_request;
+
+    g_return_val_if_fail (GDL_IS_DOCK (object), FALSE);
+
+    /* we get (x,y) in our allocation coordinates system */
+    
+    dock = GDL_DOCK (object);
+    
+    /* Get dock size. */
+    alloc = &amp;(GTK_WIDGET (dock)-&gt;allocation);
+    bw = GTK_CONTAINER (dock)-&gt;border_width;
+
+    /* Get coordinates relative to our allocation area. */
+    rel_x = x - alloc-&gt;x;
+    rel_y = y - alloc-&gt;y;
+
+    if (request)
+        my_request = *request;
+        
+    /* Check if coordinates are in GdlDock widget. */
+    if (rel_x &gt; 0 &amp;&amp; rel_x &lt; alloc-&gt;width &amp;&amp;
+        rel_y &gt; 0 &amp;&amp; rel_y &lt; alloc-&gt;height) {
+
+        /* It's inside our area. */
+        may_dock = TRUE;
+
+	/* Set docking indicator rectangle to the GdlDock size. */
+        my_request.rect.x = alloc-&gt;x + bw;
+        my_request.rect.y = alloc-&gt;y + bw;
+        my_request.rect.width = alloc-&gt;width - 2*bw;
+        my_request.rect.height = alloc-&gt;height - 2*bw;
+
+	/* If GdlDock has no root item yet, set the dock itself as 
+	   possible target. */
+        if (!dock-&gt;root) {
+            my_request.position = GDL_DOCK_TOP;
+            my_request.target = object;
+        } else {
+            my_request.target = dock-&gt;root;
+
+            /* See if it's in the border_width band. */
+            if (rel_x &lt; bw) {
+                my_request.position = GDL_DOCK_LEFT;
+                my_request.rect.width *= SPLIT_RATIO;
+            } else if (rel_x &gt; alloc-&gt;width - bw) {
+                my_request.position = GDL_DOCK_RIGHT;
+                my_request.rect.x += my_request.rect.width * (1 - SPLIT_RATIO);
+                my_request.rect.width *= SPLIT_RATIO;
+            } else if (rel_y &lt; bw) {
+                my_request.position = GDL_DOCK_TOP;
+                my_request.rect.height *= SPLIT_RATIO;
+            } else if (rel_y &gt; alloc-&gt;height - bw) {
+                my_request.position = GDL_DOCK_BOTTOM;
+                my_request.rect.y += my_request.rect.height * (1 - SPLIT_RATIO);
+                my_request.rect.height *= SPLIT_RATIO;
+            } else {
+                /* Otherwise try our children. */
+                /* give them allocation coordinates (we are a
+                   GTK_NO_WINDOW) widget */
+                may_dock = gdl_dock_object_dock_request (GDL_DOCK_OBJECT (dock-&gt;root), 
+                                                         x, y, &amp;my_request);
+            }
+        }
+    }
+
+    if (may_dock &amp;&amp; request)
+        *request = my_request;
+    
+    return may_dock;
+}
+
+static void
+gdl_dock_dock (GdlDockObject    *object,
+               GdlDockObject    *requestor,
+               GdlDockPlacement  position,
+               GValue           *user_data)
+{
+    GdlDock *dock;
+    
+    g_return_if_fail (GDL_IS_DOCK (object));
+    /* only dock items allowed at this time */
+    g_return_if_fail (GDL_IS_DOCK_ITEM (requestor));
+
+    dock = GDL_DOCK (object);
+    
+    if (position == GDL_DOCK_FLOATING) {
+        GdlDockItem *item = GDL_DOCK_ITEM (requestor);
+        gint x, y, width, height;
+
+        if (user_data &amp;&amp; G_VALUE_HOLDS (user_data, GDK_TYPE_RECTANGLE)) {
+            GdkRectangle *rect;
+
+            rect = g_value_get_boxed (user_data);
+            x = rect-&gt;x;
+            y = rect-&gt;y;
+            width = rect-&gt;width;
+            height = rect-&gt;height;
+        }
+        else {
+            x = y = 0;
+            width = height = -1;
+        }
+        
+        gdl_dock_add_floating_item (dock, item,
+                                    x, y, width, height);
+    }
+    else if (dock-&gt;root) {
+        /* This is somewhat a special case since we know which item to
+           pass the request on because we only have on child */
+        gdl_dock_object_dock (dock-&gt;root, requestor, position, NULL);
+        gdl_dock_set_title (dock);
+        
+    }
+    else { /* Item about to be added is root item. */
+        GtkWidget *widget = GTK_WIDGET (requestor);
+        
+        dock-&gt;root = requestor;
+        GDL_DOCK_OBJECT_SET_FLAGS (requestor, GDL_DOCK_ATTACHED);
+        gtk_widget_set_parent (widget, GTK_WIDGET (dock));
+        
+        gdl_dock_item_show_grip (GDL_DOCK_ITEM (requestor));
+
+        /* Realize the item (create its corresponding GdkWindow) when 
+           GdlDock has been realized. */
+        if (GTK_WIDGET_REALIZED (dock))
+            gtk_widget_realize (widget);
+        
+        /* Map the widget if it's visible and the parent is visible and has 
+           been mapped. This is done to make sure that the GdkWindow is 
+           visible. */
+        if (GTK_WIDGET_VISIBLE (dock) &amp;&amp; 
+            GTK_WIDGET_VISIBLE (widget)) {
+            if (GTK_WIDGET_MAPPED (dock))
+                gtk_widget_map (widget);
+            
+            /* Make the widget resize. */
+            gtk_widget_queue_resize (widget);
+        }
+        gdl_dock_set_title (dock);
+    }
+}
+    
+static gboolean
+gdl_dock_floating_window_delete_event_cb (GtkWidget *widget)
+{
+    GdlDock *dock;
+    
+    g_return_val_if_fail (GTK_IS_WINDOW (widget), FALSE);
+    
+    dock = GDL_DOCK (g_object_get_data (G_OBJECT (widget), &quot;dock&quot;));
+    if (dock-&gt;root) {
+        /* this will call reduce on ourselves, hiding the window if appropiate */
+        gdl_dock_item_hide_item (GDL_DOCK_ITEM (dock-&gt;root));
+    }
+
+    return TRUE;
+}
+
+static void
+_gdl_dock_foreach_build_list (GdlDockObject *object,
+                              gpointer       user_data)
+{
+    GList **l = (GList **) user_data;
+
+    if (GDL_IS_DOCK_ITEM (object))
+        *l = g_list_prepend (*l, object);
+}
+
+static gboolean
+gdl_dock_reorder (GdlDockObject    *object,
+                  GdlDockObject    *requestor,
+                  GdlDockPlacement  new_position,
+                  GValue           *other_data)
+{
+    GdlDock *dock = GDL_DOCK (object);
+    gboolean handled = FALSE;
+    
+    if (dock-&gt;_priv-&gt;floating &amp;&amp;
+        new_position == GDL_DOCK_FLOATING &amp;&amp;
+        dock-&gt;root == requestor) {
+        
+        if (other_data &amp;&amp; G_VALUE_HOLDS (other_data, GDK_TYPE_RECTANGLE)) {
+            GdkRectangle *rect;
+
+            rect = g_value_get_boxed (other_data);
+            gtk_window_move (GTK_WINDOW (dock-&gt;_priv-&gt;window),
+                             rect-&gt;x,
+                             rect-&gt;y);
+            handled = TRUE;
+        }
+    }
+    
+    return handled;
+}
+
+static gboolean 
+gdl_dock_child_placement (GdlDockObject    *object,
+                          GdlDockObject    *child,
+                          GdlDockPlacement *placement)
+{
+    GdlDock *dock = GDL_DOCK (object);
+    gboolean retval = TRUE;
+    
+    if (dock-&gt;root == child) {
+        if (placement) {
+            if (*placement == GDL_DOCK_NONE || *placement == GDL_DOCK_FLOATING)
+                *placement = GDL_DOCK_TOP;
+        }
+    } else 
+        retval = FALSE;
+
+    return retval;
+}
+
+static void 
+gdl_dock_present (GdlDockObject *object,
+                  GdlDockObject *child)
+{
+    GdlDock *dock = GDL_DOCK (object);
+
+    if (dock-&gt;_priv-&gt;floating)
+        gtk_window_present (GTK_WINDOW (dock-&gt;_priv-&gt;window));
+}
+
+
+/* ----- Public interface ----- */
+
+GtkWidget *
+gdl_dock_new (void)
+{
+    GObject *dock;
+
+    dock = g_object_new (GDL_TYPE_DOCK, NULL);
+    GDL_DOCK_OBJECT_UNSET_FLAGS (dock, GDL_DOCK_AUTOMATIC);
+    
+    return GTK_WIDGET (dock);
+}
+
+GtkWidget *
+gdl_dock_new_from (GdlDock  *original,
+                   gboolean  floating)
+{
+    GObject *new_dock;
+    
+    g_return_val_if_fail (original != NULL, NULL);
+    
+    new_dock = g_object_new (GDL_TYPE_DOCK, 
+                             &quot;master&quot;, GDL_DOCK_OBJECT_GET_MASTER (original), 
+                             &quot;floating&quot;, floating,
+                             NULL);
+    GDL_DOCK_OBJECT_UNSET_FLAGS (new_dock, GDL_DOCK_AUTOMATIC);
+    
+    return GTK_WIDGET (new_dock);
+}
+
+void
+gdl_dock_add_item (GdlDock          *dock,
+                   GdlDockItem      *item,
+                   GdlDockPlacement  placement)
+{
+    g_return_if_fail (dock != NULL);
+    g_return_if_fail (item != NULL);
+
+    if (placement == GDL_DOCK_FLOATING)
+        /* Add the item to a new floating dock */
+        gdl_dock_add_floating_item (dock, item, 0, 0, -1, -1);
+
+    else {
+        /* Non-floating item. */
+        gdl_dock_object_dock (GDL_DOCK_OBJECT (dock),
+                              GDL_DOCK_OBJECT (item),
+                              placement, NULL);
+    }
+}
+
+void
+gdl_dock_add_floating_item (GdlDock        *dock,
+                            GdlDockItem    *item,
+                            gint            x,
+                            gint            y,
+                            gint            width,
+                            gint            height)
+{
+    GdlDock *new_dock;
+    
+    g_return_if_fail (dock != NULL);
+    g_return_if_fail (item != NULL);
+    
+    new_dock = GDL_DOCK (g_object_new (GDL_TYPE_DOCK, 
+                                       &quot;master&quot;, GDL_DOCK_OBJECT_GET_MASTER (dock), 
+                                       &quot;floating&quot;, TRUE,
+                                       &quot;width&quot;, width,
+                                       &quot;height&quot;, height,
+                                       &quot;floatx&quot;, x,
+                                       &quot;floaty&quot;, y,
+                                       NULL));
+    
+    if (GTK_WIDGET_VISIBLE (dock)) {
+        gtk_widget_show (GTK_WIDGET (new_dock));
+        if (GTK_WIDGET_MAPPED (dock))
+            gtk_widget_map (GTK_WIDGET (new_dock));
+        
+        /* Make the widget resize. */
+        gtk_widget_queue_resize (GTK_WIDGET (new_dock));
+    }
+
+    gdl_dock_add_item (GDL_DOCK (new_dock), item, GDL_DOCK_TOP);
+}
+
+GdlDockItem *
+gdl_dock_get_item_by_name (GdlDock     *dock,
+                           const gchar *name)
+{
+    GdlDockObject *found;
+    
+    g_return_val_if_fail (dock != NULL &amp;&amp; name != NULL, NULL);
+    
+    /* proxy the call to our master */
+    found = gdl_dock_master_get_object (GDL_DOCK_OBJECT_GET_MASTER (dock), name);
+
+    return (found &amp;&amp; GDL_IS_DOCK_ITEM (found)) ? GDL_DOCK_ITEM (found) : NULL;
+}
+
+GdlDockPlaceholder *
+gdl_dock_get_placeholder_by_name (GdlDock     *dock,
+                                  const gchar *name)
+{
+    GdlDockObject *found;
+    
+    g_return_val_if_fail (dock != NULL &amp;&amp; name != NULL, NULL);
+    
+    /* proxy the call to our master */
+    found = gdl_dock_master_get_object (GDL_DOCK_OBJECT_GET_MASTER (dock), name);
+
+    return (found &amp;&amp; GDL_IS_DOCK_PLACEHOLDER (found)) ?
+        GDL_DOCK_PLACEHOLDER (found) : NULL;
+}
+
+GList *
+gdl_dock_get_named_items (GdlDock *dock)
+{
+    GList *list = NULL;
+    
+    g_return_val_if_fail (dock != NULL, NULL);
+
+    gdl_dock_master_foreach (GDL_DOCK_OBJECT_GET_MASTER (dock),
+                             (GFunc) _gdl_dock_foreach_build_list, &amp;list);
+
+    return list;
+}
+
+GdlDock *
+gdl_dock_object_get_toplevel (GdlDockObject *object)
+{
+    GdlDockObject *parent = object;
+    
+    g_return_val_if_fail (object != NULL, NULL);
+
+    while (parent &amp;&amp; !GDL_IS_DOCK (parent))
+        parent = gdl_dock_object_get_parent_object (parent);
+
+    return parent ? GDL_DOCK (parent) : NULL;
+}
+
+void
+gdl_dock_xor_rect (GdlDock      *dock,
+                   GdkRectangle *rect)
+{
+    GtkWidget *widget;
+    gint8      dash_list [2];
+
+    widget = GTK_WIDGET (dock);
+
+    if (!dock-&gt;_priv-&gt;xor_gc) {
+        if (GTK_WIDGET_REALIZED (widget)) {
+            GdkGCValues values;
+
+            values.function = GDK_INVERT;
+            values.subwindow_mode = GDK_INCLUDE_INFERIORS;
+            dock-&gt;_priv-&gt;xor_gc = gdk_gc_new_with_values 
+                (widget-&gt;window, &amp;values, GDK_GC_FUNCTION | GDK_GC_SUBWINDOW);
+        } else 
+            return;
+    };
+
+    gdk_gc_set_line_attributes (dock-&gt;_priv-&gt;xor_gc, 1,
+                                GDK_LINE_ON_OFF_DASH,
+                                GDK_CAP_NOT_LAST,
+                                GDK_JOIN_BEVEL);
+    
+    dash_list [0] = 1;
+    dash_list [1] = 1;
+    
+    gdk_gc_set_dashes (dock-&gt;_priv-&gt;xor_gc, 1, dash_list, 2);
+
+    gdk_draw_rectangle (widget-&gt;window, dock-&gt;_priv-&gt;xor_gc, 0, 
+                        rect-&gt;x, rect-&gt;y,
+                        rect-&gt;width, rect-&gt;height);
+
+    gdk_gc_set_dashes (dock-&gt;_priv-&gt;xor_gc, 0, dash_list, 2);
+
+    gdk_draw_rectangle (widget-&gt;window, dock-&gt;_priv-&gt;xor_gc, 0, 
+                        rect-&gt;x + 1, rect-&gt;y + 1,
+                        rect-&gt;width - 2, rect-&gt;height - 2);
+}
+

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.h	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.h	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,100 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifndef __GDL_DOCK_H__
+#define __GDL_DOCK_H__
+
+#include &lt;gtk/gtk.h&gt;
+#include &lt;gdl/gdl-dock-object.h&gt;
+#include &lt;gdl/gdl-dock-item.h&gt;
+#include &lt;gdl/gdl-dock-placeholder.h&gt;
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK            (gdl_dock_get_type ())
+#define GDL_DOCK(obj)            (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK, GdlDock))
+#define GDL_DOCK_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK, GdlDockClass))
+#define GDL_IS_DOCK(obj)         (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK))
+#define GDL_IS_DOCK_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK))
+#define GDL_DOCK_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), GTK_TYPE_DOCK, GdlDockClass))
+
+/* data types &amp; structures */
+typedef struct _GdlDock        GdlDock;
+typedef struct _GdlDockClass   GdlDockClass;
+typedef struct _GdlDockPrivate GdlDockPrivate;
+
+struct _GdlDock {
+    GdlDockObject    object;
+
+    GdlDockObject   *root;
+
+    GdlDockPrivate  *_priv;
+};
+
+struct _GdlDockClass {
+    GdlDockObjectClass parent_class;
+
+    void  (* layout_changed)  (GdlDock *dock);    /* proxy signal for the master */
+};
+
+/* additional macros */
+#define GDL_DOCK_IS_CONTROLLER(dock)  \
+    (gdl_dock_master_get_controller (GDL_DOCK_OBJECT_GET_MASTER (dock)) == \
+     GDL_DOCK_OBJECT (dock))
+
+/* public interface */
+ 
+GtkWidget     *gdl_dock_new               (void);
+
+GtkWidget     *gdl_dock_new_from          (GdlDock          *original,
+                                           gboolean          floating);
+
+GType          gdl_dock_get_type          (void);
+
+void           gdl_dock_add_item          (GdlDock          *dock,
+                                           GdlDockItem      *item,
+                                           GdlDockPlacement  place);
+
+void           gdl_dock_add_floating_item (GdlDock        *dock,
+                                           GdlDockItem    *item,
+                                           gint            x,
+                                           gint            y,
+                                           gint            width,
+                                           gint            height);
+
+GdlDockItem   *gdl_dock_get_item_by_name  (GdlDock     *dock,
+                                           const gchar *name);
+
+GdlDockPlaceholder *gdl_dock_get_placeholder_by_name (GdlDock     *dock,
+                                                      const gchar *name);
+
+GList         *gdl_dock_get_named_items   (GdlDock    *dock);
+
+GdlDock       *gdl_dock_object_get_toplevel (GdlDockObject *object);
+
+void           gdl_dock_xor_rect            (GdlDock       *dock,
+                                             GdkRectangle  *rect);
+
+G_END_DECLS
+
+#endif

Added: trunk/MonoDevelop/gdldock/sources/gdl-sharp-sources.xml
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl-sharp-sources.xml	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/sources/gdl-sharp-sources.xml	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,9 @@
+&lt;gapi-parser-input&gt;
+  &lt;api filename=&quot;../gdl/gdl-api.xml&quot;&gt;
+    &lt;library name=&quot;gdl-1&quot;&gt;
+      &lt;namespace name=&quot;Gdl&quot;&gt;
+        &lt;dir&gt;gdl&lt;/dir&gt;
+      &lt;/namespace&gt;
+    &lt;/library&gt;
+  &lt;/api&gt;
+&lt;/gapi-parser-input&gt;

Added: trunk/MonoDevelop/gdldock/test/GdlDockTest.cs
===================================================================
--- trunk/MonoDevelop/gdldock/test/GdlDockTest.cs	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/test/GdlDockTest.cs	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,53 @@
+using System;
+using Gtk;
+using GtkSharp;
+using Gnome;
+using GnomeSharp;
+using Gdl;
+using GdlSharp;
+
+class T
+{
+	Program program;
+	
+	static void Main (string[] args)
+	{
+		new T (args);
+	}
+	
+	T (string[] args)
+	{
+		program = new Program (&quot;test&quot;, &quot;0.0&quot;, Modules.UI, args);
+		App app = new App (&quot;test&quot;, &quot;Test for Gdl.Dock widget&quot;);
+		app.SetDefaultSize (600, 450);
+		app.DeleteEvent += new DeleteEventHandler (OnAppDelete);
+		
+		Dock dock = new Dock ();
+		DockLayout layout = new DockLayout (dock);
+		
+		DockItem di = new DockItem (&quot;item1&quot;, &quot;Item #1&quot;, DockItemBehavior.Locked);
+		di.Add (new Label (&quot;test&quot;));
+		dock.AddItem (di, DockPlacement.Right);
+		
+		DockItem di2 = new DockItem (&quot;item2&quot;, &quot;Item #2&quot;, DockItemBehavior.Locked);
+		di2.Add (new Label (&quot;test2&quot;));
+		dock.AddItem (di2, DockPlacement.Bottom);
+		
+		DockItem di3 = new DockItem (&quot;item3&quot;, &quot;Item #3&quot;, DockItemBehavior.Locked);
+		di3.Add (new Label (&quot;test3&quot;));
+		dock.AddItem (di3, DockPlacement.Left);
+		
+		DockItem di4 = new DockItem (&quot;item4&quot;, &quot;Item #4&quot;, DockItemBehavior.Locked);
+		di4.Add (new Label (&quot;test4&quot;));
+		dock.AddItem (di4, DockPlacement.Top);
+		
+		app.Contents = dock;
+		app.ShowAll ();
+		program.Run ();
+	}
+	
+	private void OnAppDelete (object o, DeleteEventArgs args)
+	{
+		program.Quit ();
+	}
+}

Added: trunk/MonoDevelop/gdldock/test/Makefile
===================================================================
--- trunk/MonoDevelop/gdldock/test/Makefile	2004-01-31 18:40:50 UTC (rev 733)
+++ trunk/MonoDevelop/gdldock/test/Makefile	2004-01-31 19:16:43 UTC (rev 734)
@@ -0,0 +1,8 @@
+all:
+	mcs -g GdlDockTest.cs /r:gtk-sharp.dll /r:gdl-sharp.dll /r:gnome-sharp.dll -o GdlDockTest.exe
+
+run:
+	mono --debug GdlDockTest.exe
+
+clean:
+	rm -f GdlDockTest.exe


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000338.html">[Monodevelop-patches-list] r733 - in trunk/MonoDevelop/src/Main/Base: Commands Gui/Components Internal/Codons/MenuItems Services/MenuService
</A></li>
	<LI>Next message: <A HREF="000340.html">[Monodevelop-patches-list] r735 - trunk/MonoDevelop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#339">[ date ]</a>
              <a href="thread.html#339">[ thread ]</a>
              <a href="subject.html#339">[ subject ]</a>
              <a href="author.html#339">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
