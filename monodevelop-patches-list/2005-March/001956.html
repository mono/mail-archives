<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2354 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2354%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn%3A%20.%20Gui&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001955.html">
   <LINK REL="Next"  HREF="001957.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2354 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui</H1>
    <B>Chris Toshok</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2354%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn%3A%20.%20Gui&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2354 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui">toshok at mono-cvs.ximian.com
       </A><BR>
    <I>Tue Mar 15 14:47:28 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001955.html">[Monodevelop-patches-list] r2353 - in trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets: . FileBrowser
</A></li>
        <LI>Next message: <A HREF="001957.html">[Monodevelop-patches-list] r2355 - trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1956">[ date ]</a>
              <a href="thread.html#1956">[ thread ]</a>
              <a href="subject.html#1956">[ subject ]</a>
              <a href="author.html#1956">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: toshok
Date: 2005-03-15 14:47:28 -0500 (Tue, 15 Mar 2005)
New Revision: 2354

Added:
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/DebuggerASTVisitor.cs
Removed:
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpExpressionParser.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpExpressionParser.jay
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpTokenizer.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/MyTextReader.cs
Modified:
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Expression.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am
Log:
2005-03-15  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;

        * Makefile.am (DLLS): add ICSharpCode.SharpRefactory.dll
        (FILES): remove CSharpTokenizer.cs, CSharpExpressionParser.cs, and
        MyTextReader.cs.  Add DebuggerASTVisitor.cs

        * Gui/DebuggerVariablePad.cs
        (DebuggerVariablePad.EvaluateDebuggerDisplay): use MD's AST stuff
        instead of mdb's parser c&amp;p here.  
        
        * CSharpTokenizer.cs, CSharpExpressionParser.jay,
        CSharpExpressionParser.cs, MyTextReader.cs: nuke.
        
        * DebuggerASTVisitor.cs: new class used to convert from MD's AST
        to trees that the debugger can evaluate.
        
        * Expression.cs: add ConditionalExpression and BoolExpression.



Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpExpressionParser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpExpressionParser.cs	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpExpressionParser.cs	2005-03-15 19:47:28 UTC (rev 2354)
@@ -1,753 +0,0 @@
-// created by jay 0.7 (c) 1998 <A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">Axel.Schreiner at informatik.uni-osnabrueck.de</A>
-
-#line 2 &quot;CSharpExpressionParser.jay&quot;
-using System.Text;
-using System.IO;
-using System.Collections;
-using System;
-
-namespace Debugger.Frontend
-{
-#if NET_2_0
-	public class CSharpExpressionParser
-	{
-		EvaluationContext current_context;
-		MyTextReader reader;
-		Tokenizer lexer;
-
-		protected bool yacc_verbose_flag = false;
-
-		public bool Verbose {
-			set {
-				yacc_verbose_flag = value;
-			}
-
-			get {
-				return yacc_verbose_flag;
-			}
-		}
-
-#line default
-
-  /** simplified error message.
-      @see &lt;a href=&quot;#yyerror(java.lang.String, java.lang.String[])&quot;&gt;yyerror&lt;/a&gt;
-    */
-  public void yyerror (string message) {
-    yyerror(message, null);
-  }
-
-  /** (syntax) error message.
-      Can be overwritten to control message format.
-      @param message text to be displayed.
-      @param expected vector of acceptable tokens, if available.
-    */
-  public void yyerror (string message, string[] expected) {
-    if ((expected != null) &amp;&amp; (expected.Length  &gt; 0)) {
-      System.Console.Write (message+&quot;, expecting&quot;);
-      for (int n = 0; n &lt; expected.Length; ++ n)
-        System.Console.Write (&quot; &quot;+expected[n]);
-        System.Console.WriteLine ();
-    } else
-      System.Console.WriteLine (message);
-  }
-
-  /** debugging support, requires the package jay.yydebug.
-      Set to null to suppress debugging messages.
-    */
-  internal yydebug.yyDebug debug;
-
-  protected static  int yyFinal = 13;
-  public static  string [] yyRule = {
-    &quot;$accept : parse_expression&quot;,
-    &quot;parse_expression : primary_expression&quot;,
-    &quot;primary_expression : expression&quot;,
-    &quot;primary_expression : expression ASSIGN expression&quot;,
-    &quot;expression : NUMBER&quot;,
-    &quot;expression : INTEGER&quot;,
-    &quot;expression : STRING&quot;,
-    &quot;expression : THIS&quot;,
-    &quot;expression : CATCH&quot;,
-    &quot;expression : BASE DOTDOT IDENTIFIER&quot;,
-    &quot;expression : BASE DOT IDENTIFIER&quot;,
-    &quot;expression : variable_or_type_name&quot;,
-    &quot;expression : PERCENT IDENTIFIER&quot;,
-    &quot;expression : STAR expression&quot;,
-    &quot;expression : AMPERSAND expression&quot;,
-    &quot;expression : expression OPEN_BRACKET expression CLOSE_BRACKET&quot;,
-    &quot;expression : expression OPEN_PARENS argument_list CLOSE_PARENS&quot;,
-    &quot;expression : NEW variable_or_type_name OPEN_PARENS argument_list CLOSE_PARENS&quot;,
-    &quot;expression : OPEN_PARENS variable_or_type_name CLOSE_PARENS expression&quot;,
-    &quot;expression : OPEN_PARENS expression CLOSE_PARENS&quot;,
-    &quot;argument_list :&quot;,
-    &quot;argument_list : argument_list_0&quot;,
-    &quot;argument_list_0 : expression&quot;,
-    &quot;argument_list_0 : argument_list_0 COMMA expression&quot;,
-    &quot;variable_or_type_name : IDENTIFIER&quot;,
-    &quot;variable_or_type_name : expression DOT IDENTIFIER&quot;,
-    &quot;variable_or_type_name : expression DOTDOT IDENTIFIER&quot;,
-    &quot;variable_or_type_name : expression MINUS OP_GT IDENTIFIER&quot;,
-  };
-  protected static  string [] yyNames = {    
-    &quot;end-of-file&quot;,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
-    null,null,null,null,null,null,null,&quot;QUIT&quot;,&quot;EOF&quot;,&quot;NONE&quot;,&quot;ERROR&quot;,
-    &quot;IDENTIFIER&quot;,&quot;INTEGER&quot;,&quot;NUMBER&quot;,&quot;STRING&quot;,&quot;HASH&quot;,&quot;AT&quot;,&quot;PERCENT&quot;,
-    &quot;DOLLAR&quot;,&quot;DOT&quot;,&quot;DOTDOT&quot;,&quot;BANG&quot;,&quot;COMMA&quot;,&quot;ASSIGN&quot;,&quot;STAR&quot;,&quot;PLUS&quot;,&quot;MINUS&quot;,
-    &quot;DIV&quot;,&quot;OPEN_PARENS&quot;,&quot;CLOSE_PARENS&quot;,&quot;OPEN_BRACKET&quot;,&quot;CLOSE_BRACKET&quot;,
-    &quot;OP_LT&quot;,&quot;OP_GT&quot;,&quot;COLON&quot;,&quot;AMPERSAND&quot;,&quot;LENGTH&quot;,&quot;LOWER&quot;,&quot;UPPER&quot;,&quot;NEW&quot;,
-    &quot;THIS&quot;,&quot;BASE&quot;,&quot;CATCH&quot;,
-  };
-
-  /** index-checked interface to yyNames[].
-      @param token single character or %token value.
-      @return token name or [illegal] or [unknown].
-    */
-  public static string yyname (int token) {
-    if ((token &lt; 0) || (token &gt; yyNames.Length)) return &quot;[illegal]&quot;;
-    string name;
-    if ((name = yyNames[token]) != null) return name;
-    return &quot;[unknown]&quot;;
-  }
-
-  /** computes list of expected tokens on error by tracing the tables.
-      @param state for which to compute the list.
-      @return list of token names.
-    */
-  protected string[] yyExpecting (int state) {
-    int token, n, len = 0;
-    bool[] ok = new bool[yyNames.Length];
-
-    if ((n = yySindex[state]) != 0)
-      for (token = n &lt; 0 ? -n : 0;
-           (token &lt; yyNames.Length) &amp;&amp; (n+token &lt; yyTable.Length); ++ token)
-        if (yyCheck[n+token] == token &amp;&amp; !ok[token] &amp;&amp; yyNames[token] != null) {
-          ++ len;
-          ok[token] = true;
-        }
-    if ((n = yyRindex[state]) != 0)
-      for (token = n &lt; 0 ? -n : 0;
-           (token &lt; yyNames.Length) &amp;&amp; (n+token &lt; yyTable.Length); ++ token)
-        if (yyCheck[n+token] == token &amp;&amp; !ok[token] &amp;&amp; yyNames[token] != null) {
-          ++ len;
-          ok[token] = true;
-        }
-
-    string [] result = new string[len];
-    for (n = token = 0; n &lt; len;  ++ token)
-      if (ok[token]) result[n++] = yyNames[token];
-    return result;
-  }
-
-  /** the generated parser, with debugging messages.
-      Maintains a state and a value stack, currently with fixed maximum size.
-      @param yyLex scanner.
-      @param yydebug debug message writer implementing yyDebug, or null.
-      @return result of the last reduction, if any.
-      @throws yyException on irrecoverable parse error.
-    */
- internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
-				 {
-    this.debug = (yydebug.yyDebug)yyd;
-    return yyparse(yyLex);
-  }
-
-  /** initial size and increment of the state/value stack [default 256].
-      This is not final so that it can be overwritten outside of invocations
-      of yyparse().
-    */
-  protected int yyMax;
-
-  /** executed at the beginning of a reduce action.
-      Used as $$ = yyDefault($1), prior to the user-specified action, if any.
-      Can be overwritten to provide deep copy, etc.
-      @param first value for $1, or null.
-      @return first.
-    */
-  protected Object yyDefault (Object first) {
-    return first;
-  }
-
-  /** the generated parser.
-      Maintains a state and a value stack, currently with fixed maximum size.
-      @param yyLex scanner.
-      @return result of the last reduction, if any.
-      @throws yyException on irrecoverable parse error.
-    */
-  internal Object yyparse (yyParser.yyInput yyLex)
-				{
-    if (yyMax &lt;= 0) yyMax = 256;			// initial size
-    int yyState = 0;                                   // state stack ptr
-    int [] yyStates = new int[yyMax];	                // state stack 
-    Object yyVal = null;                               // value stack ptr
-    Object [] yyVals = new Object[yyMax];	        // value stack
-    int yyToken = -1;					// current input
-    int yyErrorFlag = 0;				// #tks to shift
-
-    int yyTop = 0;
-    goto skip;
-    yyLoop:
-    yyTop++;
-    skip:
-    for (;; ++ yyTop) {
-      if (yyTop &gt;= yyStates.Length) {			// dynamically increase
-        int[] i = new int[yyStates.Length+yyMax];
-        yyStates.CopyTo (i, 0);
-        yyStates = i;
-        Object[] o = new Object[yyVals.Length+yyMax];
-        yyVals.CopyTo (o, 0);
-        yyVals = o;
-      }
-      yyStates[yyTop] = yyState;
-      yyVals[yyTop] = yyVal;
-      if (debug != null) debug.push(yyState, yyVal);
-
-      yyDiscarded: for (;;) {	// discarding a token does not change stack
-        int yyN;
-        if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
-          if (yyToken &lt; 0) {
-            yyToken = yyLex.advance() ? yyLex.token() : 0;
-            if (debug != null)
-              debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
-          }
-          if ((yyN = yySindex[yyState]) != 0 &amp;&amp; ((yyN += yyToken) &gt;= 0)
-              &amp;&amp; (yyN &lt; yyTable.Length) &amp;&amp; (yyCheck[yyN] == yyToken)) {
-            if (debug != null)
-              debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
-            yyState = yyTable[yyN];		// shift to yyN
-            yyVal = yyLex.value();
-            yyToken = -1;
-            if (yyErrorFlag &gt; 0) -- yyErrorFlag;
-            goto yyLoop;
-          }
-          if ((yyN = yyRindex[yyState]) != 0 &amp;&amp; (yyN += yyToken) &gt;= 0
-              &amp;&amp; yyN &lt; yyTable.Length &amp;&amp; yyCheck[yyN] == yyToken)
-            yyN = yyTable[yyN];			// reduce (yyN)
-          else
-            switch (yyErrorFlag) {
-  
-            case 0:
-              yyerror(&quot;syntax error&quot;, yyExpecting(yyState));
-              if (debug != null) debug.error(&quot;syntax error&quot;);
-              goto case 1;
-            case 1: case 2:
-              yyErrorFlag = 3;
-              do {
-                if ((yyN = yySindex[yyStates[yyTop]]) != 0
-                    &amp;&amp; (yyN += Token.yyErrorCode) &gt;= 0 &amp;&amp; yyN &lt; yyTable.Length
-                    &amp;&amp; yyCheck[yyN] == Token.yyErrorCode) {
-                  if (debug != null)
-                    debug.shift(yyStates[yyTop], yyTable[yyN], 3);
-                  yyState = yyTable[yyN];
-                  yyVal = yyLex.value();
-                  goto yyLoop;
-                }
-                if (debug != null) debug.pop(yyStates[yyTop]);
-              } while (-- yyTop &gt;= 0);
-              if (debug != null) debug.reject();
-              throw new yyParser.yyException(&quot;irrecoverable syntax error&quot;);
-  
-            case 3:
-              if (yyToken == 0) {
-                if (debug != null) debug.reject();
-                throw new yyParser.yyException(&quot;irrecoverable syntax error at end-of-file&quot;);
-              }
-              if (debug != null)
-                debug.discard(yyState, yyToken, yyname(yyToken),
-  							yyLex.value());
-              yyToken = -1;
-              goto yyDiscarded;		// leave stack alone
-            }
-        }
-        int yyV = yyTop + 1-yyLen[yyN];
-        if (debug != null)
-          debug.reduce(yyState, yyStates[yyV-1], yyN, yyRule[yyN], yyLen[yyN]);
-        yyVal = yyDefault(yyV &gt; yyTop ? null : yyVals[yyV]);
-        switch (yyN) {
-case 1:
-#line 75 &quot;CSharpExpressionParser.jay&quot;
-  {
-		return yyVals[0+yyTop];
-	  }
-  break;
-case 3:
-#line 83 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new AssignmentExpression ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
-	  }
-  break;
-case 4:
-#line 90 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new NumberExpression ((long) yyVals[0+yyTop]);
-	  }
-  break;
-case 5:
-#line 94 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new NumberExpression ((int) yyVals[0+yyTop]);
-	  }
-  break;
-case 6:
-#line 98 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new StringExpression ((string) yyVals[0+yyTop]);
-	  }
-  break;
-case 7:
-#line 102 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new ThisExpression ();
-	  }
-  break;
-case 8:
-#line 106 &quot;CSharpExpressionParser.jay&quot;
-  {
-    //		yyVal = new CatchExpression ();
-	  }
-  break;
-case 9:
-#line 110 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new MemberAccessExpression (new BaseExpression (), &quot;.&quot; + ((string) yyVals[0+yyTop]));
-	  }
-  break;
-case 10:
-#line 114 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new MemberAccessExpression (new BaseExpression (), (string) yyVals[0+yyTop]);
-	  }
-  break;
-case 12:
-#line 119 &quot;CSharpExpressionParser.jay&quot;
-  {
-    //		yyVal = new RegisterExpression ((string) yyVals[0+yyTop], 0);
-	  }
-  break;
-case 13:
-#line 123 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new PointerDereferenceExpression ((Expression) yyVals[0+yyTop], false);
-	  }
-  break;
-case 14:
-#line 127 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new AddressOfExpression ((Expression) yyVals[0+yyTop]);
-	  }
-  break;
-case 15:
-#line 131 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new ArrayAccessExpression ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop]);
-	  }
-  break;
-case 16:
-#line 135 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new InvocationExpression ((Expression) yyVals[-3+yyTop], ((Expression []) yyVals[-1+yyTop]));
-	  }
-  break;
-case 17:
-#line 139 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new NewExpression ((Expression) yyVals[-3+yyTop], ((Expression []) yyVals[-1+yyTop]));
-	  }
-  break;
-case 18:
-#line 143 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new CastExpression ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
-	  }
-  break;
-case 19:
-#line 147 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = yyVals[-1+yyTop];
-	  }
-  break;
-case 20:
-#line 154 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new Expression [0];
-	  }
-  break;
-case 21:
-#line 158 &quot;CSharpExpressionParser.jay&quot;
-  {
-		Expression[] args = new Expression [((ArrayList) yyVals[0+yyTop]).Count];
-		((ArrayList) yyVals[0+yyTop]).CopyTo (args, 0);
-
-		yyVal = args;
-	  }
-  break;
-case 22:
-#line 168 &quot;CSharpExpressionParser.jay&quot;
-  {
-		ArrayList args = new ArrayList ();
-		args.Add (yyVals[0+yyTop]);
-
-		yyVal = args;
-	  }
-  break;
-case 23:
-#line 175 &quot;CSharpExpressionParser.jay&quot;
-  {
-		ArrayList args = (ArrayList) yyVals[-2+yyTop];
-		args.Add (yyVals[0+yyTop]);
-
-		yyVal = args;
-	  }
-  break;
-case 24:
-#line 185 &quot;CSharpExpressionParser.jay&quot;
-  {
-		yyVal = new SimpleNameExpression ((string) yyVals[0+yyTop]);
-	  }
-  break;
-case 25:
-#line 189 &quot;CSharpExpressionParser.jay&quot;
-  { 
-		yyVal = new MemberAccessExpression ((Expression) yyVals[-2+yyTop], (string) yyVals[0+yyTop]);
-	  }
-  break;
-case 26:
-#line 193 &quot;CSharpExpressionParser.jay&quot;
-  { 
-		yyVal = new MemberAccessExpression ((Expression) yyVals[-2+yyTop], &quot;.&quot; + (string) yyVals[0+yyTop]);
-	  }
-  break;
-case 27:
-#line 197 &quot;CSharpExpressionParser.jay&quot;
-  {
-		Expression expr = new PointerDereferenceExpression ((Expression) yyVals[-3+yyTop], true);
-		yyVal = new MemberAccessExpression (expr, (string) yyVals[0+yyTop]);
-	  }
-  break;
-#line default
-        }
-        yyTop -= yyLen[yyN];
-        yyState = yyStates[yyTop];
-        int yyM = yyLhs[yyN];
-        if (yyState == 0 &amp;&amp; yyM == 0) {
-          if (debug != null) debug.shift(0, yyFinal);
-          yyState = yyFinal;
-          if (yyToken &lt; 0) {
-            yyToken = yyLex.advance() ? yyLex.token() : 0;
-            if (debug != null)
-               debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
-          }
-          if (yyToken == 0) {
-            if (debug != null) debug.accept(yyVal);
-            return yyVal;
-          }
-          goto yyLoop;
-        }
-        if (((yyN = yyGindex[yyM]) != 0) &amp;&amp; ((yyN += yyState) &gt;= 0)
-            &amp;&amp; (yyN &lt; yyTable.Length) &amp;&amp; (yyCheck[yyN] == yyState))
-          yyState = yyTable[yyN];
-        else
-          yyState = yyDgoto[yyM];
-        if (debug != null) debug.shift(yyStates[yyTop], yyState);
-	 goto yyLoop;
-      }
-    }
-  }
-
-   static  short [] yyLhs  = {              -1,
-    0,    1,    1,    2,    2,    2,    2,    2,    2,    2,
-    2,    2,    2,    2,    2,    2,    2,    2,    2,    4,
-    4,    5,    5,    3,    3,    3,    3,
-  };
-   static  short [] yyLen = {           2,
-    1,    1,    3,    1,    1,    1,    1,    1,    3,    3,
-    1,    2,    2,    2,    4,    4,    5,    4,    3,    0,
-    1,    1,    3,    1,    3,    3,    4,
-  };
-   static  short [] yyDefRed = {            0,
-   24,    5,    4,    6,    0,    0,    0,    0,    0,    7,
-    0,    8,    0,    1,    0,   11,   12,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,   19,    0,    0,   10,    9,   25,   26,    0,    0,
-    0,    0,    0,    0,    0,    0,   27,   16,    0,   15,
-   17,    0,
-  };
-  protected static  short [] yyDgoto  = {            13,
-   14,   41,   16,   42,   43,
-  };
-  protected static  short [] yySindex = {         -246,
-    0,    0,    0,    0, -255, -246, -246, -246, -246,    0,
- -245,    0,    0,    0, -215,    0,    0, -198, -210, -253,
- -198, -198, -256, -232, -230, -227, -225, -246, -243, -246,
- -246,    0, -246, -246,    0,    0,    0,    0, -198, -224,
- -198, -241, -223, -228, -198, -222,    0,    0, -246,    0,
-    0, -198,
-  };
-  protected static  short [] yyRindex = {            0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,   47,    0,    0,    1,    0, -195,
-    4,    0, -257,    0,    0,    0,    0,    0,    0, -217,
-    0,    0,    0, -217,    0,    0,    0,    0,   56,    0,
- -272,    0, -212,    0,   14,    0,    0,    0,    0,    0,
-    0, -252,
-  };
-  protected static  short [] yyGindex = {            0,
-    0,    2,   -4,   30,    0,
-  };
-  protected static  short [] yyTable = {            22,
-   13,   15,   20,   14,   23,   17,   22,   18,   19,   21,
-   22,   11,   11,   18,    1,    2,    3,    4,   11,   23,
-    5,   34,   11,   24,   25,   33,   23,    6,   35,   39,
-   36,    7,   44,   37,   45,   38,   47,   48,    8,   40,
-   26,   27,    9,   10,   11,   12,    2,   29,   49,   30,
-   52,   31,   50,   26,   27,    3,   51,   28,   26,   27,
-   29,   20,   30,   46,   31,   29,   21,   30,   32,   31,
-   26,   27,    0,   11,   11,    0,    0,   29,    0,   30,
-   11,   31,   11,    0,   11,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,   13,   13,    0,   14,   14,    0,    0,   13,
-    0,   13,   14,    0,   14,   18,   18,    0,    0,    0,
-    0,    0,   18,    0,   18,
-  };
-  protected static  short [] yyCheck = {           272,
-    0,    0,    7,    0,    9,  261,  279,    6,    7,    8,
-    9,  269,  270,    0,  261,  262,  263,  264,  276,  272,
-  267,  278,  280,  269,  270,  279,  279,  274,  261,   28,
-  261,  278,   31,  261,   33,  261,  261,  279,  285,  283,
-  269,  270,  289,  290,  291,  292,    0,  276,  272,  278,
-   49,  280,  281,  269,  270,    0,  279,  273,  269,  270,
-  276,  279,  278,   34,  280,  276,  279,  278,  279,  280,
-  269,  270,   -1,  269,  270,   -1,   -1,  276,   -1,  278,
-  276,  280,  278,   -1,  280,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,  272,  273,   -1,  272,  273,   -1,   -1,  279,
-   -1,  281,  279,   -1,  281,  272,  273,   -1,   -1,   -1,
-   -1,   -1,  279,   -1,  281,
-  };
-
-#line 204 &quot;CSharpExpressionParser.jay&quot;
-
-public CSharpExpressionParser (EvaluationContext context, string name)
-{
-	this.reader = new MyTextReader ();
-	this.current_context = context;
-
-	lexer = new Tokenizer (context, reader, name);
-}
-
-public Expression Parse (string text)
-{
-	try {
-		reader.Text = text;
-		lexer.restart ();
-		if (yacc_verbose_flag)
-			return (Expression) yyparse (lexer, new yydebug.yyDebugSimple ());
-		else
-			return (Expression) yyparse (lexer);
-	} catch (Exception e){
-		// Please do not remove this, it is used during debugging
-		// of the grammar
-		//
-// 		current_context.Error (lexer.location + &quot;  : Parsing error &quot;);
-// 		current_context.Error (e.ToString ());
-		return null;
-	}
-}
-
-/* end end end */
-}
-#line default
-namespace yydebug {
-        using System;
-	 internal interface yyDebug {
-		 void push (int state, Object value);
-		 void lex (int state, int token, string name, Object value);
-		 void shift (int from, int to, int errorFlag);
-		 void pop (int state);
-		 void discard (int state, int token, string name, Object value);
-		 void reduce (int from, int to, int rule, string text, int len);
-		 void shift (int from, int to);
-		 void accept (Object value);
-		 void error (string message);
-		 void reject ();
-	 }
-	 
-	 class yyDebugSimple : yyDebug {
-		 void println (string s){
-			 Console.WriteLine (s);
-		 }
-		 
-		 public void push (int state, Object value) {
-			 println (&quot;push\tstate &quot;+state+&quot;\tvalue &quot;+value);
-		 }
-		 
-		 public void lex (int state, int token, string name, Object value) {
-			 println(&quot;lex\tstate &quot;+state+&quot;\treading &quot;+name+&quot;\tvalue &quot;+value);
-		 }
-		 
-		 public void shift (int from, int to, int errorFlag) {
-			 switch (errorFlag) {
-			 default:				// normally
-				 println(&quot;shift\tfrom state &quot;+from+&quot; to &quot;+to);
-				 break;
-			 case 0: case 1: case 2:		// in error recovery
-				 println(&quot;shift\tfrom state &quot;+from+&quot; to &quot;+to
-					     +&quot;\t&quot;+errorFlag+&quot; left to recover&quot;);
-				 break;
-			 case 3:				// normally
-				 println(&quot;shift\tfrom state &quot;+from+&quot; to &quot;+to+&quot;\ton error&quot;);
-				 break;
-			 }
-		 }
-		 
-		 public void pop (int state) {
-			 println(&quot;pop\tstate &quot;+state+&quot;\ton error&quot;);
-		 }
-		 
-		 public void discard (int state, int token, string name, Object value) {
-			 println(&quot;discard\tstate &quot;+state+&quot;\ttoken &quot;+name+&quot;\tvalue &quot;+value);
-		 }
-		 
-		 public void reduce (int from, int to, int rule, string text, int len) {
-			 println(&quot;reduce\tstate &quot;+from+&quot;\tuncover &quot;+to
-				     +&quot;\trule (&quot;+rule+&quot;) &quot;+text);
-		 }
-		 
-		 public void shift (int from, int to) {
-			 println(&quot;goto\tfrom state &quot;+from+&quot; to &quot;+to);
-		 }
-		 
-		 public void accept (Object value) {
-			 println(&quot;accept\tvalue &quot;+value);
-		 }
-		 
-		 public void error (string message) {
-			 println(&quot;error\t&quot;+message);
-		 }
-		 
-		 public void reject () {
-			 println(&quot;reject&quot;);
-		 }
-		 
-	 }
-}
-// %token constants
- class Token {
-  public const int QUIT = 257;
-  public const int EOF = 258;
-  public const int NONE = 259;
-  public const int ERROR = 260;
-  public const int IDENTIFIER = 261;
-  public const int INTEGER = 262;
-  public const int NUMBER = 263;
-  public const int STRING = 264;
-  public const int HASH = 265;
-  public const int AT = 266;
-  public const int PERCENT = 267;
-  public const int DOLLAR = 268;
-  public const int DOT = 269;
-  public const int DOTDOT = 270;
-  public const int BANG = 271;
-  public const int COMMA = 272;
-  public const int ASSIGN = 273;
-  public const int STAR = 274;
-  public const int PLUS = 275;
-  public const int MINUS = 276;
-  public const int DIV = 277;
-  public const int OPEN_PARENS = 278;
-  public const int CLOSE_PARENS = 279;
-  public const int OPEN_BRACKET = 280;
-  public const int CLOSE_BRACKET = 281;
-  public const int OP_LT = 282;
-  public const int OP_GT = 283;
-  public const int COLON = 284;
-  public const int AMPERSAND = 285;
-  public const int LENGTH = 286;
-  public const int LOWER = 287;
-  public const int UPPER = 288;
-  public const int NEW = 289;
-  public const int THIS = 290;
-  public const int BASE = 291;
-  public const int CATCH = 292;
-  public const int yyErrorCode = 256;
- }
- namespace yyParser {
-  using System;
-  /** thrown for irrecoverable syntax errors and stack overflow.
-    */
-  internal class yyException : System.Exception {
-    public yyException (string message) : base (message) {
-    }
-  }
-
-  /** must be implemented by a scanner object to supply input to the parser.
-    */
-  internal interface yyInput {
-    /** move on to next token.
-        @return false if positioned beyond tokens.
-        @throws IOException on input error.
-      */
-    bool advance (); // throws java.io.IOException;
-    /** classifies current token.
-        Should not be called if advance() returned false.
-        @return current %token or single character.
-      */
-    int token ();
-    /** associated with current token.
-        Should not be called if advance() returned false.
-        @return value for token().
-      */
-    Object value ();
-  }
- }
-#endif
-} // close outermost namespace, that MUST HAVE BEEN opened in the prolog

Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpExpressionParser.jay
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpExpressionParser.jay	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpExpressionParser.jay	2005-03-15 19:47:28 UTC (rev 2354)
@@ -1,235 +0,0 @@
-%{
-using System.Text;
-using System.IO;
-using System.Collections;
-using System;
-
-namespace Debugger.Frontend
-{
-#if NET_2_0
-	public class CSharpExpressionParser
-	{
-		EvaluationContext current_context;
-		MyTextReader reader;
-		Tokenizer lexer;
-
-		protected bool yacc_verbose_flag = false;
-
-		public bool Verbose {
-			set {
-				yacc_verbose_flag = value;
-			}
-
-			get {
-				return yacc_verbose_flag;
-			}
-		}
-
-%}
-
-%token QUIT
-%token EOF
-%token NONE	// This token is never returned by our lexer
-%token ERROR	// This is used not by the parser, but by the tokenizer.
-		// do not remove.
-
-%token IDENTIFIER
-%token INTEGER
-%token NUMBER
-%token STRING
-%token HASH
-%token AT
-%token PERCENT
-%token DOLLAR
-%token DOT
-%token DOTDOT
-%token BANG
-%token COMMA
-%token ASSIGN
-%token STAR
-%token PLUS
-%token MINUS
-%token DIV
-%token OPEN_PARENS
-%token CLOSE_PARENS
-%token OPEN_BRACKET
-%token CLOSE_BRACKET
-%token OP_LT
-%token OP_GT
-%token COLON
-%token AMPERSAND
-
-%token LENGTH
-%token LOWER
-%token UPPER
-
-%token NEW
-%token THIS
-%token BASE
-%token CATCH
-
-%start parse_expression
-%%
-
-parse_expression
-	: primary_expression
-	  {
-		return $1;
-	  }
-	;
-
-primary_expression
-	: expression
-	| expression ASSIGN expression
-	  {
-		$$ = new AssignmentExpression ((Expression) $1, (Expression) $3);
-	  }
-	;	
-
-expression
-	: NUMBER
-	  {
-		$$ = new NumberExpression ((long) $1);
-	  }
-	| INTEGER
-	  {
-		$$ = new NumberExpression ((int) $1);
-	  }
-	| STRING
-	  {
-		$$ = new StringExpression ((string) $1);
-	  }
-	| THIS
-	  {
-		$$ = new ThisExpression ();
-	  }
-	| CATCH
-	  {
-//		$$ = new CatchExpression ();
-	  }
-	| BASE DOTDOT IDENTIFIER
-	  {
-		$$ = new MemberAccessExpression (new BaseExpression (), &quot;.&quot; + ((string) $3));
-	  }
-	| BASE DOT IDENTIFIER
-	  {
-		$$ = new MemberAccessExpression (new BaseExpression (), (string) $3);
-	  }
-	| variable_or_type_name
-	| PERCENT IDENTIFIER
-	  {
-//		$$ = new RegisterExpression ((string) $2, 0);
-	  }
-	| STAR expression
-	  {
-		$$ = new PointerDereferenceExpression ((Expression) $2, false);
-	  }
-	| AMPERSAND expression
-	  {
-		$$ = new AddressOfExpression ((Expression) $2);
-	  }
-	| expression OPEN_BRACKET expression CLOSE_BRACKET
-	  {
-		$$ = new ArrayAccessExpression ((Expression) $1, (Expression) $3);
-	  }
-	| expression OPEN_PARENS argument_list CLOSE_PARENS
-	  {
-		$$ = new InvocationExpression ((Expression) $1, ((Expression []) $3));
-	  }
-	| NEW variable_or_type_name OPEN_PARENS argument_list CLOSE_PARENS
-	  {
-		$$ = new NewExpression ((Expression) $2, ((Expression []) $4));
-	  }
-	| OPEN_PARENS variable_or_type_name CLOSE_PARENS expression
-	  {
-		$$ = new CastExpression ((Expression) $2, (Expression) $4);
-	  }
-	| OPEN_PARENS expression CLOSE_PARENS
-	  {
-		$$ = $2;
-	  }
-	;
-
-argument_list
-	: /* empty */
-	  {
-		$$ = new Expression [0];
-	  }
-	| argument_list_0
-	  {
-		Expression[] args = new Expression [((ArrayList) $1).Count];
-		((ArrayList) $1).CopyTo (args, 0);
-
-		$$ = args;
-	  }
-	;
-
-argument_list_0
-	: expression
-	  {
-		ArrayList args = new ArrayList ();
-		args.Add ($1);
-
-		$$ = args;
-	  }
-	| argument_list_0 COMMA expression
-	  {
-		ArrayList args = (ArrayList) $1;
-		args.Add ($3);
-
-		$$ = args;
-	  }
-	;
-
-variable_or_type_name
-	: IDENTIFIER
-	  {
-		$$ = new SimpleNameExpression ((string) $1);
-	  }
-	| expression DOT IDENTIFIER
-	  { 
-		$$ = new MemberAccessExpression ((Expression) $1, (string) $3);
-	  }
-	| expression DOTDOT IDENTIFIER
-	  { 
-		$$ = new MemberAccessExpression ((Expression) $1, &quot;.&quot; + (string) $3);
-	  }
-	| expression MINUS OP_GT IDENTIFIER
-	  {
-		Expression expr = new PointerDereferenceExpression ((Expression) $1, true);
-		$$ = new MemberAccessExpression (expr, (string) $4);
-	  }
-	;
-
-%%
-
-public CSharpExpressionParser (EvaluationContext context, string name)
-{
-	this.reader = new MyTextReader ();
-	this.current_context = context;
-
-	lexer = new Tokenizer (context, reader, name);
-}
-
-public Expression Parse (string text)
-{
-	try {
-		reader.Text = text;
-		lexer.restart ();
-		if (yacc_verbose_flag)
-			return (Expression) yyparse (lexer, new yydebug.yyDebugSimple ());
-		else
-			return (Expression) yyparse (lexer);
-	} catch (Exception e){
-		// Please do not remove this, it is used during debugging
-		// of the grammar
-		//
-//		current_context.Error (lexer.location + &quot;  : Parsing error &quot;);
-//		current_context.Error (e.ToString ());
-		return null;
-	}
-}
-
-/* end end end */
-#endif
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpTokenizer.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpTokenizer.cs	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/CSharpTokenizer.cs	2005-03-15 19:47:28 UTC (rev 2354)
@@ -1,570 +0,0 @@
-#if NET_2_0
-using System;
-using System.Text;
-using System.IO;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
-using Mono.Debugger;
-
-namespace Debugger.Frontend
-{
-	public class SyntaxError : Exception
-	{
-		public SyntaxError (string message)
-			: base (&quot;syntax error: &quot; + message)
-		{ }
-	}
-
-	public class Tokenizer : yyParser.yyInput
-	{
-		//
-		// Class variables
-		// 
-		static Hashtable keywords;
-		static Hashtable short_keywords;
-		static System.Text.StringBuilder id_builder;
-		static System.Text.StringBuilder string_builder;
-		static System.Text.StringBuilder number_builder;
-
-		//
-		// Values for the associated token returned
-		//
-		int putback_char;
-		Object val;
-
-		//
-		// Class initializer
-		// 
-		static Tokenizer ()
-		{
-			InitTokens ();
-			id_builder = new System.Text.StringBuilder ();
-			string_builder = new System.Text.StringBuilder ();
-			number_builder = new System.Text.StringBuilder ();
-		}
-
-		static void InitTokens ()
-		{
-			keywords = new Hashtable ();
-			short_keywords = new Hashtable ();
-
-			keywords.Add (&quot;new&quot;, Token.NEW);
-			keywords.Add (&quot;this&quot;, Token.THIS);
-			keywords.Add (&quot;base&quot;, Token.BASE);
-			keywords.Add (&quot;catch&quot;, Token.CATCH);
-		}
-
-		EvaluationContext context;
-		TextReader reader;
-		string ref_name;
-		int current_token;
-		int col = 1;
-
-		//
-		// Whether tokens have been seen on this line
-		//
-		bool tokens_seen = false;
-
-		//
-		// Details about the error encoutered by the tokenizer
-		//
-		string error_details;
-		
-		public string error {
-			get {
-				return error_details;
-			}
-		}
-
-		public Tokenizer (EvaluationContext context, TextReader reader, string name)
-		{
-			this.context = context;
-			this.reader = reader;
-			this.ref_name = name;
-		}
-
-		public void restart ()
-		{
-			tokens_seen = false;
-			col = 1;
-		}
-
-		//
-		// Accepts exactly count (4 or 8) hex, no more no less
-		//
-		int getHex (int count, out bool error)
-		{
-			int i;
-			int total = 0;
-			int c;
-			int top = count != -1 ? count : 4;
-			
-			getChar ();
-			error = false;
-			for (i = 0; i &lt; top; i++){
-				c = getChar ();
-				
-				if (c &gt;= '0' &amp;&amp; c &lt;= '9')
-					c = (int) c - (int) '0';
-				else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F')
-					c = (int) c - (int) 'A' + 10;
-				else if (c &gt;= 'a' &amp;&amp; c &lt;= 'f')
-					c = (int) c - (int) 'a' + 10;
-				else {
-					error = true;
-					return 0;
-				}
-				
-				total = (total * 16) + c;
-				if (count == -1){
-					int p = peekChar ();
-					if (p == -1)
-						break;
-					if (!is_hex ((char)p))
-						break;
-				}
-			}
-			return total;
-		}
-
-		int escape (int c)
-		{
-			bool error;
-			int d;
-			int v;
-
-			d = peekChar ();
-			if (c != '\\')
-				return c;
-			
-			switch (d){
-			case 'a':
-				v = '\a'; break;
-			case 'b':
-				v = '\b'; break;
-			case 'n':
-				v = '\n'; break;
-			case 't':
-				v = '\t'; break;
-			case 'v':
-				v = '\v'; break;
-			case 'r':
-				v = '\r'; break;
-			case '\\':
-				v = '\\'; break;
-			case 'f':
-				v = '\f'; break;
-			case '0':
-				v = 0; break;
-			case '&quot;':
-				v = '&quot;'; break;
-			case '\'':
-				v = '\''; break;
-			case 'x':
-				v = getHex (-1, out error);
-				if (error)
-					goto default;
-				return v;
-			case 'u':
-				v = getHex (4, out error);
-				if (error)
-					goto default;
-				return v;
-			case 'U':
-				v = getHex (8, out error);
-				if (error)
-					goto default;
-				return v;
-			default:
-// 				context.Error (&quot;Unrecognized escape sequence in &quot; + (char)d);
-				return d;
-			}
-			getChar ();
-			return v;
-		}
-
-		int getChar ()
-		{
-			if (putback_char != -1){
-				int x = putback_char;
-				putback_char = -1;
-
-				return x;
-			}
-			return reader.Read ();
-		}
-
-		int peekChar ()
-		{
-			if (putback_char != -1)
-				return putback_char;
-			return reader.Peek ();
-		}
-
-		void putback (int c)
-		{
-			if (putback_char != -1)
-				throw new Exception (&quot;This should not happen putback on putback&quot;);
-			putback_char = c;
-		}
-
-		public bool advance ()
-		{
-			return peekChar () &gt;= 0;
-		}
-
-		bool is_identifier_start_character (char c)
-		{
-			return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || c == '_' || Char.IsLetter (c);
-		}
-
-		bool is_identifier_part_character (char c)
-		{
-			return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || c == '_' || (c &gt;= '0' &amp;&amp; c &lt;= '9') || Char.IsLetter (c);
-		}
-
-		int GetKeyword (string name, bool tokens_seen)
-		{
-			object o = keywords [name];
-
-			if (o != null)
-				return (int) o;
-
-			if (tokens_seen)
-				return -1;
-
-			o = short_keywords [name];
-			if (o != null)
-				return (int) o;
-
-			return -1;
-		}
-
-		//
-		// Invoked if we know we have .digits or digits
-		//
-		int is_number (int c)
-		{
-			number_builder.Length = 0;
-
-			if (c &gt;= '0' &amp;&amp; c &lt;= '9'){
-				if (c == '0' &amp;&amp; peekChar () == 'x' || peekChar () == 'X'){
-					getChar ();
-					hex_digits (-1);
-
-					string s = number_builder.ToString ();
-
-					val = (long) System.UInt64.Parse (s, NumberStyles.HexNumber);
-					return Token.NUMBER;
-				}
-				decimal_digits (c);
-
-				val = (int) System.UInt32.Parse (number_builder.ToString ());
-				return Token.INTEGER;
-			}
-
-			throw new Exception (&quot;Is Number should never reach this point&quot;);
-		}
-
-		bool decimal_digits (int c)
-		{
-			int d;
-			bool seen_digits = false;
-			
-			if (c != -1)
-				number_builder.Append ((char) c);
-			
-			while ((d = peekChar ()) != -1){
-				if (d &gt;= '0' &amp;&amp; d &lt;= '9'){
-					number_builder.Append ((char) d);
-					getChar ();
-					seen_digits = true;
-				} else
-					break;
-			}
-			
-			return seen_digits;
-		}
-
-		bool is_hex (int e)
-		{
-			return (e &gt;= '0' &amp;&amp; e &lt;= '9') || (e &gt;= 'A' &amp;&amp; e &lt;= 'F') || (e &gt;= 'a' &amp;&amp; e &lt;= 'f');
-		}
-		
-		void hex_digits (int c)
-		{
-			int d;
-
-			if (c != -1)
-				number_builder.Append ((char) c);
-			while ((d = peekChar ()) != -1){
-				if (is_hex (d)){
-					number_builder.Append ((char) d);
-					getChar ();
-				} else
-					break;
-			}
-		}
-
-		private int consume_identifier (int c, bool quoted) 
-		{
-			bool old_tokens_seen = tokens_seen;
-			tokens_seen = true;
-
-			id_builder.Length = 0;
-
-			id_builder.Append ((char) c);
-					
-			while ((c = peekChar ()) != -1) {
-				if (is_identifier_part_character ((char) c)){
-					id_builder.Append ((char)getChar ());
-					col++;
-				} else 
-					break;
-			}
-
-			string ids = id_builder.ToString ();
-			int keyword = GetKeyword (ids, old_tokens_seen);
-
-			if (keyword == -1 || quoted){
-				val = ids;
-				if (ids.Length &gt; 512){
-// 					context.Error (&quot;Identifier too long (limit is 512 chars)&quot;);
-				}
-				return Token.IDENTIFIER;
-			}
-
-			return keyword;
-		}
-
-		private int consume_string (bool quoted) 
-		{
-			int c;
-			string_builder.Length = 0;
-								
-			while ((c = getChar ()) != -1){
-				if (c == '&quot;'){
-					if (quoted &amp;&amp; peekChar () == '&quot;'){
-						string_builder.Append ((char) c);
-						getChar ();
-						continue;
-					} else {
-						val = string_builder.ToString ();
-						return Token.STRING;
-					}
-				}
-
-				if (c == '\n'){
-// 					if (!quoted)
-// 						context.Error (&quot;Newline in constant&quot;);
-					col = 0;
-				} else
-					col++;
-
-				if (!quoted){
-					c = escape (c);
-					if (c == -1)
-						return Token.ERROR;
-				}
-				string_builder.Append ((char) c);
-			}
-
-// 			context.Error (&quot;Unterminated string literal&quot;);
-			return Token.EOF;
-		}
-
-		private int consume_quoted_identifier ()
-		{
-			int c;
-
-			id_builder.Length = 0;
-								
-			while ((c = getChar ()) != -1){
-				if (c == '\''){
-					val = id_builder.ToString ();
-					return Token.IDENTIFIER;
-				}
-
-				if (c == '\n')
-					col = 0;
-				else
-					col++;
-
-				id_builder.Append ((char) c);
-			}
-
-// 			context.Error (&quot;Unterminated quoted identifier&quot;);
-			return Token.EOF;
-		}
-
-		private string consume_help ()
-		{
-			int c;
-			StringBuilder sb = new StringBuilder ();
-								
-			while ((c = getChar ()) != -1){
-				if (c == '\n') {
-					col = 0;
-					return sb.ToString ();
-				}
-
-				col++;
-				sb.Append ((char) c);
-			}
-
-			return sb.ToString ();
-		}
-
-		public int xtoken ()
-		{
-			int c;
-
-			val = null;
-			// optimization: eliminate col and implement #directive semantic correctly.
-			for (;(c = getChar ()) != -1; col++) {
-				if (is_identifier_start_character ((char)c))
-					return consume_identifier (c, false);
-
-				if (c == 0)
-					continue;
-				else if (c == '#')
-					return Token.HASH;
-				else if (c == '@')
-					return Token.AT;
-				else if (c == '%')
-					return Token.PERCENT;
-				else if (c == '$')
-					return Token.DOLLAR;
-				else if (c == '.')
-					if ((c = peekChar ()) == '.') {
-						getChar ();
-						return Token.DOTDOT;
-					}
-					else {
-						return Token.DOT;
-					}
-				else if (c == '!')
-					return Token.BANG;
-				else if (c == '=')
-					return Token.ASSIGN;
-				else if (c == '*')
-					return Token.STAR;
-				else if (c == '+')
-					return Token.PLUS;
-				else if (c == '-') // FIXME: negative numbers...
-					return Token.MINUS;
-				else if (c == '/')
-					return Token.DIV;
-				else if (c == '(')
-					return Token.OPEN_PARENS;
-				else if (c == ')')
-					return Token.CLOSE_PARENS;
-				else if (c == '[')
-					return Token.OPEN_BRACKET;
-				else if (c == ']')
-					return Token.CLOSE_BRACKET;
-				else if (c == ',')
-					return Token.COMMA;
-				else if (c == '&lt;')
-					return Token.OP_LT;
-				else if (c == '&gt;')
-					return Token.OP_GT;
-				else if (c == ':')
-					return Token.COLON;
-				else if (c == '&amp;')
-					return Token.AMPERSAND;
-
-				if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
-					tokens_seen = true;
-					return is_number (c);
-				}
-
-				if (c == '&quot;')
-					return consume_string (false);
-
-				if (c == ' ' || c == '\t' || c == '\f' || c == '\v' || c == '\r' || c == '\n'){
-					if (current_token == Token.HASH) {
- 						error_details = &quot;No whitespace allowed after `#'&quot;;
-						return Token.ERROR;
-					} else if (current_token == Token.AT) {
-						error_details = &quot;No whitespace allowed after `@'&quot;;
-						return Token.ERROR;
-					}
-
-					if (c == '\t')
-						col = (((col + 8) / 8) * 8) - 1;
-					continue;
-				}
-
-				if (c == '\'')
-					return consume_quoted_identifier ();
-
-				error_details = &quot;Unknown character `&quot; + (char) c + &quot;'&quot;;
-				return Token.ERROR;
-			}
-
-			return Token.EOF;
-		}
-
-		public int token ()
-		{
-			current_token = xtoken ();
-			return current_token;
-		}
-
-		public Object value ()
-		{
-			return val;
-		}
-
-		static Hashtable tokenValues;
-		
-		private static Hashtable TokenValueName
-		{
-			get {
-				if (tokenValues == null)
-					tokenValues = GetTokenValueNameHash ();
-
-				return tokenValues;
-			}
-		}
-
-		private static Hashtable GetTokenValueNameHash ()
-		{
-			Type t = typeof (Token);
-			FieldInfo [] fields = t.GetFields ();
-			Hashtable hash = new Hashtable ();
-			foreach (FieldInfo field in fields) {
-				if (field.IsLiteral &amp;&amp; field.IsStatic &amp;&amp; field.FieldType == typeof (int))
-					hash.Add (field.GetValue (null), field.Name);
-			}
-			return hash;
-		}
-
-		//
-		// Returns a verbose representation of the current location
-		//
-		public string location {
-			get {
-				string det;
-
-				if (current_token == Token.ERROR)
-					det = &quot;detail: &quot; + error_details;
-				else
-					det = &quot;&quot;;
-				
-				// return &quot;Line:     &quot;+line+&quot; Col: &quot;+col + &quot;\n&quot; +
-				//       &quot;VirtLine: &quot;+ref_line +
-				//       &quot; Token: &quot;+current_token + &quot; &quot; + det;
-				string current_token_name = TokenValueName [current_token] as string;
-				if (current_token_name == null)
-					current_token_name = current_token.ToString ();
-
-				return String.Format (&quot;{0}, Token: {1} {2}&quot;, ref_name,
-						      current_token_name, det);
-			}
-		}
-	}
-}
-#endif

Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog	2005-03-15 19:47:28 UTC (rev 2354)
@@ -1,3 +1,21 @@
+2005-03-15  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;
+
+	* Makefile.am (DLLS): add ICSharpCode.SharpRefactory.dll
+	(FILES): remove CSharpTokenizer.cs, CSharpExpressionParser.cs, and
+	MyTextReader.cs.  Add DebuggerASTVisitor.cs
+
+	* Gui/DebuggerVariablePad.cs
+	(DebuggerVariablePad.EvaluateDebuggerDisplay): use MD's AST stuff
+	instead of mdb's parser c&amp;p here.  
+	
+	* CSharpTokenizer.cs, CSharpExpressionParser.jay,
+	CSharpExpressionParser.cs, MyTextReader.cs: nuke.
+	
+	* DebuggerASTVisitor.cs: new class used to convert from MD's AST
+	to trees that the debugger can evaluate.
+	
+	* Expression.cs: add ConditionalExpression and BoolExpression.
+	
 2005-03-14  Lluis Sanchez Gual &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;
 
 	* MonoDevelopDebugger.addin.xml: Use the new syntax for defining pads.

Added: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/DebuggerASTVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/DebuggerASTVisitor.cs	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/DebuggerASTVisitor.cs	2005-03-15 19:47:28 UTC (rev 2354)
@@ -0,0 +1,135 @@
+using System;
+using System.Text;
+using System.Collections;
+using System.Diagnostics;
+
+using RefParser = ICSharpCode.SharpRefactory.Parser;
+using AST = ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace Debugger.Frontend
+{
+	public class DebuggerASTVisitor : RefParser.AbstractASTVisitor
+	{
+                public override object Visit (AST.PrimitiveExpression primitiveExpression, object data)  {
+			object v = primitiveExpression.Value;
+			Type t = v.GetType();
+
+			if (t == typeof (bool))
+				return new BoolExpression ((bool)v);
+			else if (t == typeof (long))
+				return new NumberExpression ((long)v);
+			else if (t == typeof (int))
+				return new NumberExpression ((int)v);
+			else
+				throw new EvaluationException (String.Format (&quot;unhandled primitive expression: `{0}'&quot;, primitiveExpression.ToString()));
+		}
+
+                public override object Visit (AST.BinaryOperatorExpression binaryOperatorExpression, object data) {
+			throw new EvaluationException (&quot;AST.TypeReferenceExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.ParenthesizedExpression parenthesizedExpression, object data) {
+			return parenthesizedExpression.Expression.AcceptVisitor (this, data);
+		}
+
+                public override object Visit (AST.FieldReferenceExpression fieldReferenceExpression, object data) {
+			return new MemberAccessExpression ((Expression)fieldReferenceExpression.TargetObject.AcceptVisitor (this, data),
+							   fieldReferenceExpression.FieldName);
+		}
+
+                public override object Visit (AST.InvocationExpression invocationExpression, object data) {
+			Expression[] arg_expr = new Expression[invocationExpression.Parameters.Count];
+			int i = 0;
+			foreach (AST.Expression pexpr in invocationExpression.Parameters)
+				arg_expr[i++] = (Expression)pexpr.AcceptVisitor (this, data);
+
+			return new InvocationExpression ((Expression)invocationExpression.TargetObject.AcceptVisitor (this, data),
+							 arg_expr);
+		}
+
+                public override object Visit (AST.IdentifierExpression identifierExpression, object data) {
+			return new SimpleNameExpression (identifierExpression.Identifier);
+		}
+
+                public override object Visit (AST.TypeReferenceExpression typeReferenceExpression, object data) {
+			throw new EvaluationException (&quot;AST.TypeReferenceExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.UnaryOperatorExpression unaryOperatorExpression, object data) {
+			throw new EvaluationException (&quot;AST.UnaryOperatorExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.AssignmentExpression assignmentExpression, object data) {
+			throw new EvaluationException (&quot;AST.AssignmentExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.SizeOfExpression sizeOfExpression, object data) {
+			throw new EvaluationException (&quot;AST.SizeOfExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.TypeOfExpression typeOfExpression, object data) {
+			throw new EvaluationException (&quot;AST.TypeOfExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.CheckedExpression checkedExpression, object data) {
+			throw new EvaluationException (&quot;AST.CheckedExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.UncheckedExpression uncheckedExpression, object data) {
+			throw new EvaluationException (&quot;AST.UncheckedExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.PointerReferenceExpression pointerReferenceExpression, object data) {
+			throw new EvaluationException (&quot;AST.PointerReferenceExpression not yet implemented&quot;);
+		}
+
+
+                public override object Visit (AST.CastExpression castExpression, object data) {
+			throw new EvaluationException (&quot;AST.CastExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.StackAllocExpression stackAllocExpression, object data) {
+			throw new EvaluationException (&quot;AST.StackAllocExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.IndexerExpression indexerExpression, object data) {
+			throw new EvaluationException (&quot;AST.IndexerExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.ThisReferenceExpression thisReferenceExpression, object data) {
+		  return new ThisExpression ();
+		}
+
+                public override object Visit (AST.BaseReferenceExpression baseReferenceExpression, object data) {
+		  return new BaseExpression ();
+		}
+
+                public override object Visit (AST.ObjectCreateExpression objectCreateExpression, object data) {
+			throw new EvaluationException (&quot;AST.ObjectCreateExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.ArrayCreationParameter arrayCreationParameter, object data) {
+			throw new EvaluationException (&quot;AST.ArrayCreationParameter not yet implemented&quot;);
+		}
+
+		public override object Visit (AST.ArrayCreateExpression arrayCreateExpression, object data) {
+			throw new EvaluationException (&quot;AST.ArrayCreateExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.ArrayInitializerExpression arrayInitializerExpression, object data) {
+			throw new EvaluationException (&quot;AST.ArrayInitializerExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.DirectionExpression directionExpression, object data) {
+			throw new EvaluationException (&quot;AST.DirectionExpression not yet implemented&quot;);
+		}
+
+                public override object Visit (AST.ConditionalExpression conditionalExpression, object data) {
+			Expression test_expr = (Expression)conditionalExpression.TestCondition.AcceptVisitor (this, data);
+			Expression true_expr = (Expression)conditionalExpression.TrueExpression.AcceptVisitor (this, data);
+			Expression false_expr = (Expression)conditionalExpression.FalseExpression.AcceptVisitor (this, data);
+			return new ConditionalExpression (test_expr, true_expr, false_expr);
+		}
+
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Expression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Expression.cs	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Expression.cs	2005-03-15 19:47:28 UTC (rev 2354)
@@ -301,6 +301,86 @@
 		}
 	}
 
+	public class ConditionalExpression : Expression
+	{
+		Expression test;
+		Expression true_expr;
+		Expression false_expr;
+
+		public override string Name {
+			get {
+				return &quot;conditional&quot;;
+			}
+		}
+		public ConditionalExpression (Expression test, Expression true_expr, Expression false_expr)
+		{
+			this.test = test;
+			this.true_expr = true_expr;
+			this.false_expr = false_expr;
+		}
+
+		protected override Expression DoResolve (EvaluationContext context)
+		{
+			test = test.Resolve (context);
+			true_expr = true_expr.Resolve (context);
+			false_expr = false_expr.Resolve (context);
+
+			resolved = true;
+			return this;
+		}
+
+		protected override ITargetObject DoEvaluateVariable (EvaluationContext context)
+		{
+		  bool cond = false;
+
+		  try {
+		    cond = (bool) this.test.Evaluate (context);
+		  }
+		  catch (Exception e) {
+		    throw new EvaluationException (
+			   &quot;Cannot convert {0} to a boolean for conditional: {1}&quot;,
+			   this.test, e);
+		  }
+
+		  return cond ? true_expr.EvaluateVariable (context) : false_expr.EvaluateVariable (context);
+		}
+	}
+
+	public class BoolExpression : Expression
+	{
+		bool val;
+
+		public BoolExpression (bool val)
+		{
+			this.val = val;
+		}
+
+		public override string Name {
+			get { return val.ToString(); }
+		}
+
+		protected override Expression DoResolve (EvaluationContext context)
+		{
+			resolved = true;
+			return this;
+		}
+
+		protected override object DoEvaluate (EvaluationContext context)
+		{
+			return val;
+		}
+
+		protected override ITargetObject DoEvaluateVariable (EvaluationContext context)
+		{
+			StackFrame frame = context.CurrentFrame.Frame;
+			if ((frame.Language == null) ||
+			    !frame.Language.CanCreateInstance (typeof (bool)))
+				return null;
+
+			return frame.Language.CreateInstance (frame, val);
+		}
+	}
+
 	public class ThisExpression : Expression
 	{
 		public override string Name {

Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs	2005-03-15 19:47:28 UTC (rev 2354)
@@ -12,8 +12,12 @@
 using Mono.Debugger.Languages;
 
 using MonoDevelop.Core.Services;
+using MonoDevelop.Internal.Parser;
 using MonoDevelop.Services;
 
+using RefParse = ICSharpCode.SharpRefactory.Parser;
+using AST = ICSharpCode.SharpRefactory.Parser.AST;
+
 using Debugger.Frontend;
 
 namespace MonoDevelop.SourceEditor.Gui
@@ -418,18 +422,31 @@
 				}
 
 				if (right_idx - left_idx &gt; 1) {
-					// there's enough space for an
-					// expression.  parse it and see
-					// what we get.
+					/* there's enough space for an
+					 * expression.  parse it and see
+					 * what we get. */
+					RefParse.Parser parser;
+					AST.Expression ast_expr;
+					Expression dbgr_expr;
+					DebuggerASTVisitor visitor;
+					string snippet;
+					object retval;
 
-					string snippet = display.Substring (left_idx + 1, right_idx - left_idx - 1);
+					/* parse the snippet to build up MD's AST */
+					parser = new RefParse.Parser();
 
-					CSharpExpressionParser parser = new CSharpExpressionParser (ctx, snippet);
-					Expression expr = parser.Parse (snippet);
+					snippet = display.Substring (left_idx + 1, right_idx - left_idx - 1);
+					ast_expr = parser.ParseExpression (new RefParse.Lexer (new RefParse.StringReader (snippet)));
 
-					expr = expr.Resolve (ctx);
-					object retval = expr.Evaluate (ctx);
+					/* use our visitor to convert from MD's AST to types that
+					 * facilitate evaluation by the debugger */
+					visitor = new DebuggerASTVisitor ();
+					dbgr_expr = (Expression)e.AcceptVisitor (visitor, null);
 
+					/* finally, resolve and evaluate the expression */
+					dbgr_expr = dbgr_expr.Resolve (ctx);
+					retval = dbgr_expr.Evaluate (ctx);
+
 #region &quot;c&amp;p'ed from debugger/frontend/Style.cs&quot;
 					if (retval is long) {
 						sb.Append (String.Format (&quot;0x{0:x}&quot;, (long) retval));
@@ -446,7 +463,6 @@
 					}
 #endregion
 				}
-				
 
 				start_idx = right_idx + 1;
 			}

Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am	2005-03-15 19:47:28 UTC (rev 2354)
@@ -6,16 +6,16 @@
 DLLS = $(GTK_SHARP_LIBS) \
 	$(MONO_DEBUGGER_LIBS) \
 	/r:$(top_builddir)/build/bin/MonoDevelop.Base.dll \
-	/r:$(top_builddir)/build/bin/MonoDevelop.Core.dll
+	/r:$(top_builddir)/build/bin/MonoDevelop.Core.dll \
+        /r:$(top_builddir)/build/bin/ICSharpCode.SharpRefactory.dll
 
+
 FILES = \
 DebuggerCommands.cs \
 DebuggingService.cs \
 EvaluationContext.cs \
 Expression.cs \
-CSharpTokenizer.cs \
-CSharpExpressionParser.cs \
-MyTextReader.cs \
+DebuggerASTVisitor.cs \
 Gui/DebuggerLocalsPad.cs \
 Gui/DebuggerVariablePad.cs \
 Gui/DebuggerStackTracePad.cs \
@@ -36,7 +36,7 @@
 
 $(ASSEMBLY): $(build_sources)
 	mkdir -p $(ADDIN_BUILD)
-	$(CSC) -out:$@ -target:library \
+	$(CSC) -define:NET_2_0 -out:$@ -target:library \
 	$(build_sources) $(DLLS)
 
 assemblydir = $(libdir)/monodevelop/AddIns/DebuggerAddIn

Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/MyTextReader.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/MyTextReader.cs	2005-03-15 17:39:27 UTC (rev 2353)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/MyTextReader.cs	2005-03-15 19:47:28 UTC (rev 2354)
@@ -1,76 +0,0 @@
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace Debugger.Frontend
-{
-	internal class MyTextReader : TextReader
-	{
-		bool closed = false;
-		string current_line = null;
-		int pos = 0;
-
-		public string Text {
-			set {
-				if (closed)
-					throw new InvalidOperationException (&quot;Reader is closed.&quot;);
-
-				pos = 0;
-				current_line = value;
-			}
-		}
-
-		bool check_line ()
-		{
-			if (closed || (current_line == null))
-				return false;
-
-			if (pos &gt;= current_line.Length) {
-				current_line = null;
-				return false;
-			}
-
-			return true;
-		}
-
-		public override int Peek ()
-		{
-			if (!check_line ())
-				return -1;
-
-			return current_line [pos];
-		}
-
-		public override int Read ()
-		{
-			if (!check_line ())
-				return -1;
-
-			return current_line [pos++];
-		}
-
-		public override string ReadLine ()
-		{
-			string retval;
-
-			if (!check_line ())
-				return String.Empty;
-
-			retval = current_line;
-			current_line = null;
-			return retval;
-		}
-
-		public override string ReadToEnd ()
-		{
-			return ReadLine ();
-		}
-
-		public override void Close ()
-		{
-			current_line = null;
-			closed = true;
-			base.Close ();
-		}
-	}
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001955.html">[Monodevelop-patches-list] r2353 - in trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets: . FileBrowser
</A></li>
	<LI>Next message: <A HREF="001957.html">[Monodevelop-patches-list] r2355 - trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1956">[ date ]</a>
              <a href="thread.html#1956">[ thread ]</a>
              <a href="subject.html#1956">[ subject ]</a>
              <a href="author.html#1956">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
