<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2391 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Parser/generated
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2391%20-%20in%20trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory%3A%20.%20src/Parser/generated&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001992.html">
   <LINK REL="Next"  HREF="001994.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2391 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Parser/generated</H1>
    <B>John Luke &lt;jluke@cfl.rr.com&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2391%20-%20in%20trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory%3A%20.%20src/Parser/generated&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2391 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Parser/generated">jluke at mono-cvs.ximian.com
       </A><BR>
    <I>Fri Mar 25 22:12:10 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001992.html">[Monodevelop-patches-list] r2390 - in trunk/MonoDevelop/Core/src: AddIns/BackendBindings/CSharpBinding ICSharpCode.SharpRefactory ICSharpCode.SharpRefactory/src/Lexer
</A></li>
        <LI>Next message: <A HREF="001994.html">[Monodevelop-patches-list] r2392 - trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1993">[ date ]</a>
              <a href="thread.html#1993">[ thread ]</a>
              <a href="subject.html#1993">[ subject ]</a>
              <a href="author.html#1993">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2005-03-25 22:12:10 -0500 (Fri, 25 Mar 2005)
New Revision: 2391

Modified:
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/TODO
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG
Log:
flush


Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/TODO
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/TODO	2005-03-25 18:23:18 UTC (rev 2390)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/TODO	2005-03-26 03:12:10 UTC (rev 2391)
@@ -1,4 +1,3 @@
-- fix double.TryParse bug
 - add C# 2.0 features
 	option 1 - wait to see if SD writes 2.0 stuff
 	option 2 - write it ourselves based on current one

Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG	2005-03-25 18:23:18 UTC (rev 2390)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG	2005-03-26 03:12:10 UTC (rev 2391)
@@ -1,1976 +1,1976 @@
-using System.Drawing;
-using System.Collections;
-using System.Collections.Specialized;
-using System.Text;
-using ICSharpCode.SharpRefactory.Parser;
-using ICSharpCode.SharpRefactory.Parser.AST;
-
-COMPILER CS    /* AW 2002-12-30 renamed from CompilationUnit to CS */
-
-string assemblyName = null;
-
-public CompilationUnit compilationUnit;
-
-public string ContainingAssembly {
-	set {
-		assemblyName = value;
-	}
-}
-
-Token t {
-	get {
-		return lexer.Token;
-	}
-}
-Token la {
-	get {
-		return lexer.LookAhead;
-	}
-}
-
-Hashtable typeStrings     = null;
-ArrayList usingNamespaces = null;
-
-public void Error(string s)
-{
-	if (errDist &gt;= minErrDist) {
-		errors.Error(la.line, la.col, s);
-	}
-	errDist = 0;
-}
-
-public Expression ParseExpression(Lexer lexer)
-{
-	this.errors = lexer.Errors;
-	this.lexer = lexer;
-	errors.SynErr = new ErrorCodeProc(SynErr);
-	lexer.NextToken();
-	Expression expr;
-	Expr(out expr);
-	return expr;
-}
-
-bool IsTypeCast()
-{
-	if (IsSimpleTypeCast()) {
-		return true;
-	}
-	
-	if (assemblyName != null) {
-		return CheckTypeCast();
-	}
-	
-	return GuessTypeCast();
-}
-
-bool IsSimpleTypeCast()
-{
-	// check: &quot;(&quot; pointer or array of keyword type &quot;)&quot;
-	
-	if (la.kind != Tokens.OpenParenthesis) {
-		return false;
-	}
-
-	StartPeek();
-	Token pt1 = Peek();
-	Token pt  = Peek();
-	
-	return ParserUtil.IsTypeKW(pt1) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp;
-	       pt.kind == Tokens.CloseParenthesis;
-}
-
-bool CheckTypeCast()
-{
-	// check: leading &quot;(&quot; pointer or array of some type &quot;)&quot;
-
-	if (la.kind != Tokens.OpenParenthesis) {
-		return false;
-	}
-	
-	string qualident;
-	
-	StartPeek();
-	Token pt = Peek();
-	
-	return IsQualident(ref pt, out qualident) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
-	       pt.kind == Tokens.CloseParenthesis &amp;&amp; IsType(qualident);		
-}
-
-bool IsType(string qualident)
-{
-	if (typeStrings == null) {
-		CreateTypeStrings();
-	}
-	
-	if (typeStrings.ContainsValue(qualident)) {
-		return true;
-	}
-	
-	foreach (string ns in usingNamespaces) {
-		if (typeStrings.ContainsValue(ns + &quot;.&quot; + qualident)) {
-			return true;
-		}
-	}
-	return false;
-}
-
-bool GuessTypeCast()
-{
-	// check: &quot;(&quot; pointer or array of some type &quot;)&quot; possible type cast successor
-	
-	if (la.kind != Tokens.OpenParenthesis) return false;
-	
-	string qualident;
-	
-	StartPeek();
-	Token pt = Peek();
-	
-	if (IsQualident(ref pt, out qualident) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
-	    pt.kind == Tokens.CloseParenthesis) {
-		// check successor
-		pt = Peek();
-		return pt.kind == Tokens.Identifier || pt.kind == Tokens.Literal   ||
-		       pt.kind == Tokens.OpenParenthesis   || ParserUtil.IsUnaryOperator(pt)         ||
-		       pt.kind == Tokens.New        || pt.kind == Tokens.This      ||
-		       pt.kind == Tokens.Base       || pt.kind == Tokens.Null      ||
-		       pt.kind == Tokens.Checked    || pt.kind == Tokens.Unchecked ||
-		       pt.kind == Tokens.Typeof     || pt.kind == Tokens.Sizeof    ||
-		       (ParserUtil.IsTypeKW(pt) &amp;&amp; Peek().kind == Tokens.Dot);
-	} else return false;
-}
-
-void CreateTypeStrings()
-{
-	Assembly a;
-	Type[] types;
-	AssemblyName [] aNames;
-	
-	if (assemblyName != null &amp;&amp; assemblyName.Length &gt; 0) {    /* AW 2002-12-30 add check for length &gt; 0 */
-		typeStrings = new Hashtable();
-		a = Assembly.LoadFrom(assemblyName);
-		types = a.GetTypes();
-		foreach (Type t in types) 
-			typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
-		aNames = a.GetReferencedAssemblies();
-		
-		for (int i = 0; i &lt; aNames.Length; i++) {
-			a = Assembly.LoadFrom(aNames[i].Name);
-			types = a.GetExportedTypes();
-			
-			foreach(Type t in types)
-				if (usingNamespaces.Contains(t.FullName.Substring(0, t.FullName.LastIndexOf('.'))))
-					typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
-		}
-	}
-}
-
-/* Checks whether the next sequences of tokens is a qualident *
- * and returns the qualident string                           */
-/* !!! Proceeds from current peek position !!! */
-bool IsQualident (ref Token pt, out string qualident)
-{
-	qualident = &quot;&quot;;
-	if (pt.kind == Tokens.Identifier) {
-		qualident = pt.val;
-		pt = Peek();
-		while (pt.kind == Tokens.Dot) {
-			pt = Peek();
-			if (pt.kind != Tokens.Identifier) return false;
-			qualident += &quot;.&quot; + pt.val;
-			pt = Peek();
-		}
-		return true;
-	} else return false;
-}
-
-/* skip: { &quot;*&quot; | &quot;[&quot; { &quot;,&quot; } &quot;]&quot; } */
-/* !!! Proceeds from current peek position !!! */
-bool IsPointerOrDims (ref Token pt)
-{
-	for (;;) {
-		if (pt.kind == Tokens.OpenSquareBracket) {
-			do pt = Peek();
-			while (pt.kind == Tokens.Comma);
-			if (pt.kind != Tokens.CloseSquareBracket) return false;
-		} else if (pt.kind != Tokens.Times) break;
-		pt = Peek();
-	}
-	return true;
-}
-
-/* Return the n-th token after the current lookahead token */
-void StartPeek()
-{
-	lexer.StartPeek();
-}
-
-Token Peek()
-{
-	return lexer.Peek();
-}
-
-Token Peek (int n)
-{
-	lexer.StartPeek();
-	Token x = la;
-	while (n &gt; 0) {
-		x = lexer.Peek();
-		n--;
-	}
-	return x;
-}
-
-/*-----------------------------------------------------------------*
- * Resolver routines to resolve LL(1) conflicts:                   *                                                  *
- * These resolution routine return a boolean value that indicates  *
- * whether the alternative at hand shall be choosen or not.        *
- * They are used in IF ( ... ) expressions.                        *       
- *-----------------------------------------------------------------*/
-
-/* True, if ident is followed by &quot;=&quot; */
-bool IdentAndAsgn ()
-{
-	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.Assign;
-}
-
-bool IsAssignment () { return IdentAndAsgn(); }
-
-/* True, if ident is followed by &quot;,&quot;, &quot;=&quot;, or &quot;;&quot; */
-bool IdentAndCommaOrAsgnOrSColon () {
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.Identifier &amp;&amp; 
-	       (peek == Tokens.Comma || peek == Tokens.Assign || peek == Tokens.Semicolon);
-}
-bool IsVarDecl () { return IdentAndCommaOrAsgnOrSColon(); }
-
-/* True, if the comma is not a trailing one, *
- * like the last one in: a, b, c,            */
-bool NotFinalComma () {
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.Comma &amp;&amp;
-	       peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
-}
-
-/* True, if &quot;void&quot; is followed by &quot;*&quot; */
-bool NotVoidPointer () {
-	return la.kind == Tokens.Void &amp;&amp; Peek(1).kind != Tokens.Times;
-}
-
-/* True, if &quot;checked&quot; or &quot;unchecked&quot; are followed by &quot;{&quot; */
-bool UnCheckedAndLBrace () {
-	return la.kind == Tokens.Checked || la.kind == Tokens.Unchecked &amp;&amp;
-	       Peek(1).kind == Tokens.OpenCurlyBrace;
-}
-
-/* True, if &quot;.&quot; is followed by an ident */
-bool DotAndIdent () {
-	return la.kind == Tokens.Dot &amp;&amp; Peek(1).kind == Tokens.Identifier;
-}
-
-/* True, if ident is followed by &quot;:&quot; */
-bool IdentAndColon () {
-	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.Colon;
-}
-
-bool IsLabel () { return IdentAndColon(); }
-
-/* True, if ident is followed by &quot;(&quot; */
-bool IdentAndLPar () {
-	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.OpenParenthesis;
-}
-
-/* True, if &quot;catch&quot; is followed by &quot;(&quot; */
-bool CatchAndLPar () {
-	return la.kind == Tokens.Catch &amp;&amp; Peek(1).kind == Tokens.OpenParenthesis;
-}
-bool IsTypedCatch () { return CatchAndLPar(); }
-
-/* True, if &quot;[&quot; is followed by the ident &quot;assembly&quot; */
-bool IsGlobalAttrTarget () {
-	Token pt = Peek(1);
-	return la.kind == Tokens.OpenSquareBracket &amp;&amp; 
-	       pt.kind == Tokens.Identifier &amp;&amp; pt.val == &quot;assembly&quot;;
-}
-
-/* True, if &quot;[&quot; is followed by &quot;,&quot; or &quot;]&quot; */
-bool LBrackAndCommaOrRBrack () {
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.OpenSquareBracket &amp;&amp;
-	       (peek == Tokens.Comma || peek == Tokens.CloseSquareBracket);
-}
-
-bool IsDims () { return LBrackAndCommaOrRBrack(); }
-
-/* True, if &quot;[&quot; is followed by &quot;,&quot; or &quot;]&quot; *
- * or if the current token is &quot;*&quot;         */
-bool TimesOrLBrackAndCommaOrRBrack () {
-	return la.kind == Tokens.Times || LBrackAndCommaOrRBrack();
-}
-bool IsPointerOrDims () { return TimesOrLBrackAndCommaOrRBrack(); }
-bool IsPointer () { return la.kind == Tokens.Times; }
-
-/* True, if lookahead is a primitive type keyword, or *
- * if it is a type declaration followed by an ident   */
-bool IsLocalVarDecl () {
-	if ((ParserUtil.IsTypeKW(la) &amp;&amp; Peek(1).kind != Tokens.Dot) || la.kind == Tokens.Void) return true;
-	
-	StartPeek();
-	Token pt = la ;  // peek token
-	string ignore;
-	
-	return IsQualident(ref pt, out ignore) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
-	       pt.kind == Tokens.Identifier;
-}
-
-/* True, if lookahead ident is &quot;get&quot; */
-bool IdentIsGet () {
-	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;get&quot;;
-}
-
-/* True, if lookahead ident is &quot;set&quot; */
-bool IdentIsSet () {
-	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;set&quot;;
-}
-
-/* True, if lookahead ident is &quot;add&quot; */
-bool IdentIsAdd () {
-	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;add&quot;;
-}
-
-/* True, if lookahead ident is &quot;remove&quot; */
-bool IdentIsRemove () {
-	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;remove&quot;;
-}
-
-/* True, if lookahead is a local attribute target specifier, *
- * i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,         *
- *             &quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;      */
-bool IsLocalAttrTarget () {
-	int cur = la.kind;
-	string val = la.val;
-
-	return (cur == Tokens.Event || cur == Tokens.Return ||
-	        (cur == Tokens.Identifier &amp;&amp;
-	         (val == &quot;field&quot; || val == &quot;method&quot;   || val == &quot;module&quot; ||
-	          val == &quot;param&quot; || val == &quot;property&quot; || val == &quot;type&quot;))) &amp;&amp;
-	       Peek(1).kind == Tokens.Colon;
-}
-
-
-/*------------------------------------------------------------------------*
- *----- LEXER TOKEN LIST  ------------------------------------------------*
- *------------------------------------------------------------------------*/
-TOKENS
-	/*----- terminal classes -----*/
-	/* EOF is 0 */
-	ident
-	literal
-	
-	/*----- special character -----*/
-	&quot;=&quot; /* 3 */
-	
-	&quot;+&quot;
-	&quot;-&quot;
-	&quot;*&quot;
-	&quot;/&quot;
-	&quot;%&quot;
-	
-	&quot;:&quot;
-	&quot;;&quot;
-	&quot;?&quot;
-	&quot;,&quot;
-	&quot;.&quot;
-	
-	&quot;{&quot;
-	&quot;}&quot;
-	
-	&quot;[&quot;
-	&quot;]&quot;
-	
-	&quot;(&quot;
-	&quot;)&quot;
-	
-	&quot;&gt;&quot;
-	&quot;&lt;&quot;
-	
-	&quot;!&quot;
-	&quot;&amp;&amp;&quot;
-	&quot;||&quot;
-	
-	&quot;~&quot;
-	&quot;&amp;&quot;
-	&quot;|&quot;
-	&quot;^&quot;
-
-	/*----- special character sequences -----*/
-	&quot;++&quot; /* 29 */
-	&quot;--&quot;
-	&quot;==&quot;
-	&quot;!=&quot;
-	&quot;&gt;=&quot;
-	&quot;&lt;=&quot;
-	
-	&quot;&lt;&lt;&quot;
-	&quot;&gt;&gt;&quot;
-	
-	&quot;+=&quot;
-	&quot;-=&quot;
-	&quot;*=&quot;
-	&quot;/=&quot;
-	&quot;%=&quot;
-	&quot;&amp;=&quot;
-	&quot;|=&quot;
-	&quot;^=&quot;
-	&quot;&lt;&lt;=&quot;
-	&quot;&gt;&gt;=&quot;
-	
-	&quot;-&gt;&quot;
-	
-	/*----- C# keywords -----*/
-	&quot;abstract&quot; /* 48 */
-	&quot;as&quot;
-	&quot;base&quot;
-	&quot;bool&quot;
-	&quot;break&quot;
-	&quot;byte&quot;
-	&quot;case&quot;
-	&quot;catch&quot;
-	&quot;char&quot;
-	&quot;checked&quot;
-	&quot;class&quot;
-	&quot;const&quot;
-	&quot;continue&quot;
-	&quot;decimal&quot;
-	&quot;default&quot;
-	&quot;delegate&quot;
-	&quot;do&quot;
-	&quot;double&quot;
-	&quot;else&quot;
-	&quot;enum&quot;
-	&quot;event&quot;
-	&quot;explicit&quot;
-	&quot;extern&quot;
-	&quot;false&quot;
-	&quot;finally&quot;
-	&quot;fixed&quot;
-	&quot;float&quot;
-	&quot;for&quot;
-	&quot;foreach&quot;
-	&quot;goto&quot;
-	&quot;if&quot;
-	&quot;implicit&quot;
-	&quot;in&quot;
-	&quot;int&quot;
-	&quot;interface&quot;
-	&quot;internal&quot;
-	&quot;is&quot;
-	&quot;lock&quot;
-	&quot;long&quot;
-	&quot;namespace&quot;
-	&quot;new&quot;
-	&quot;null&quot;
-	&quot;object&quot;
-	&quot;operator&quot;
-	&quot;out&quot;
-	&quot;override&quot;
-	&quot;params&quot;
-	&quot;private&quot;
-	&quot;protected&quot;
-	&quot;public&quot;
-	&quot;readonly&quot;
-	&quot;ref&quot;
-	&quot;return&quot;
-	&quot;sbyte&quot;
-	&quot;sealed&quot;
-	&quot;short&quot;
-	&quot;sizeof&quot;
-	&quot;stackalloc&quot;
-	&quot;static&quot;
-	&quot;string&quot;
-	&quot;struct&quot;
-	&quot;switch&quot;
-	&quot;this&quot;
-	&quot;throw&quot;
-	&quot;true&quot;
-	&quot;try&quot;
-	&quot;typeof&quot;
-	&quot;uint&quot;
-	&quot;ulong&quot;
-	&quot;unchecked&quot;
-	&quot;unsafe&quot;
-	&quot;ushort&quot;
-	&quot;using&quot;
-	&quot;virtual&quot;
-	&quot;void&quot;
-	&quot;volatile&quot;
-	&quot;while&quot;
-
-/*------------------------------------------------------------------------*
- *----- PARSER -----------------------------------------------------------*
- *------------------------------------------------------------------------*/
-
-PRODUCTIONS
-
-/*--- compilation unit: */
-CS
-(. compilationUnit = new CompilationUnit(); .)
-=
-	{ UsingDirective }
-	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
-	{ NamespaceMemberDecl }
-	EOF
-.
-
-UsingDirective
-(.
-	usingNamespaces = new ArrayList();
-	string qualident = null, aliasident = null;
-.)
-=
-	&quot;using&quot;                     (. Point startPos = t.Location;
-	                               INode node     = null; 
-	                            .)
-	[ IF (IsAssignment()) ident (. aliasident = t.val; .) &quot;=&quot;  ]  /*--- using alias directive */
-	Qualident&lt;out qualident&gt;    (. if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
-	                                 if (aliasident != null) {
-	                                   node = new UsingAliasDeclaration(aliasident, qualident);
-	                                 } else {
-	                                     usingNamespaces.Add(qualident);
-	                                     node = new UsingDeclaration(qualident);
-	                                 }
-	                               }
-	                            .)
-	&quot;;&quot;                         (. node.StartLocation = startPos;
-	                               node.EndLocation   = t.EndLocation;
-	                               compilationUnit.AddChild(node);
-	                            .)
-.
-
-GlobalAttributeSection
-=
-	
-	&quot;[&quot; (. Point startPos = t.Location; .) ident                   (. if (t.val != &quot;assembly&quot;) Error(&quot;global attribute target specifier (\&quot;assembly\&quot;) expected&quot;);
-	                               string attributeTarget = t.val;
-	                               ArrayList attributes = new ArrayList();
-	                               ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
-	                            .)
-	&quot;:&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)
-	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
-	[ &quot;,&quot; ]
-	&quot;]&quot;                         (. AttributeSection section = new AttributeSection(attributeTarget, attributes);
-	                               section.StartLocation = startPos;
-	                               section.EndLocation = t.EndLocation;
-	                               compilationUnit.AddChild(section);
-	                            .)
-.
-
-Attribute&lt;out ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute&gt;
-(. string qualident; .)
-=
-	Qualident&lt;out qualident&gt;           (. ArrayList positional = new ArrayList();
-	                                      ArrayList named      = new ArrayList();
-	                                      string name = qualident;
-	                                   .)
-	[ AttributeArguments&lt;ref positional, ref named&gt; ] (. attribute  = new ICSharpCode.SharpRefactory.Parser.AST.Attribute(name, positional, named);.)
-.
-
-AttributeArguments&lt;ref ArrayList positional, ref ArrayList named&gt;
-(.
-	bool nameFound = false;
-	string name = &quot;&quot;;
-	Expression expr;
-.)
-=
-	&quot;(&quot;
-	[
-		[
-			IF (IsAssignment())          (. nameFound = true; .)
-			ident                        (. name = t.val; .)
-			&quot;=&quot;
-		] Expr&lt;out expr&gt;                 (. if(name == &quot;&quot;) positional.Add(expr);
-		                                    else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
-		                                 .)
-		
-		{
-			&quot;,&quot;
-				(
-					IF (IsAssignment())    (. nameFound = true; .)
-					ident                      (. name = t.val; .)
-					&quot;=&quot;
-					| /*Empty*/                (. if (nameFound) Error(&quot;no positional argument after named argument&quot;); .)
-				) Expr&lt;out expr&gt;           (. if(name == &quot;&quot;) positional.Add(expr);
-				                              else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
-				                           .)
-		}
-	]
-	&quot;)&quot;
-.
-
-AttributeSection&lt;out AttributeSection section&gt;
-(.
-	string attributeTarget = &quot;&quot;;
-	ArrayList attributes = new ArrayList();
-	ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
-	
-.)
-=
-	&quot;[&quot; (. Point startPos = t.Location; .) /*--- attribute target specifier: */
-	[ IF (IsLocalAttrTarget())
-		( &quot;event&quot;                       (. attributeTarget = &quot;event&quot;;.)
-		| &quot;return&quot;                      (. attributeTarget = &quot;return&quot;;.)
-		| ident                         (. if (t.val != &quot;field&quot;    || t.val != &quot;method&quot; ||
-		                                      t.val != &quot;module&quot;   || t.val != &quot;param&quot;  ||
-		                                      t.val != &quot;property&quot; || t.val != &quot;type&quot;)
-		                                    Error(&quot;attribute target specifier (event, return, field,&quot; +
-		                                          &quot;method, module, param, property, or type) expected&quot;);
-		                                   attributeTarget = t.val;
-		                                .)
-		) &quot;:&quot; 
-	]
-	/*--- attribute list: */
-	Attribute&lt;out attribute&gt;            (. attributes.Add(attribute); .)
-	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
-	[ &quot;,&quot; ]
-	&quot;]&quot;                         (. section = new AttributeSection(attributeTarget, attributes);
-	                               section.StartLocation = startPos;
-	                               section.EndLocation = t.EndLocation;
-	                            .)
-.
-
-NamespaceMemberDecl
-(.
-	AttributeSection section;
-	ArrayList attributes = new ArrayList();
-	Modifiers m = new Modifiers(this);
-	string qualident;
-.)
-= /*--- namespace declaration: */
-	&quot;namespace&quot;                  (. Point startPos = t.Location; .)
-	Qualident&lt;out qualident&gt;     (. INode node =  new NamespaceDeclaration(qualident);
-	                                node.StartLocation = startPos;
-	                                compilationUnit.AddChild(node);
-	                                compilationUnit.BlockStart(node);
-	                              .)
-	&quot;{&quot;
-	{ UsingDirective }
-	{ NamespaceMemberDecl }
-	&quot;}&quot;
-	[ &quot;;&quot; ]                       (. node.EndLocation   = t.EndLocation;
-	                                 compilationUnit.BlockEnd();
-	                              .)
-	/*--- type declaration: */
-	| { AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-	{ TypeModifier&lt;m&gt; }
-	TypeDecl&lt;m, attributes&gt;
-.
-
-TypeDecl&lt;Modifiers m, ArrayList attributes&gt;
-(.
-	TypeReference type;
-	StringCollection names;
-	ArrayList p; string name;
-.)
-= /*--- class declaration: */      (. m.Check(Modifier.Classes); .)
-	&quot;class&quot;                        (. TypeDeclaration newType = new TypeDeclaration();
-	                                  compilationUnit.AddChild(newType);
-	                                  compilationUnit.BlockStart(newType);
-	                                  
-	                                  newType.Type = Types.Class;
-	                                  newType.Modifier = m.Modifier;
-	                                  newType.Attributes = attributes;
-	                                .)
-	ident                           (. newType.Name = t.val; .)
-	[ ClassBase&lt;out names&gt;          (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
-	ClassBody
-	[ &quot;;&quot; ]                         (. newType.EndLocation = t.Location; 
-	                                   compilationUnit.BlockEnd();
-	                                .)
-	| /*--- struct declaration: */  (. m.Check(Modifier.StructsInterfacesEnumsDelegates); .)
-	( &quot;struct&quot;                      (. TypeDeclaration newType = new TypeDeclaration();
-	                                   compilationUnit.AddChild(newType);
-	                                   compilationUnit.BlockStart(newType);
-	                                   newType.Type = Types.Struct; 
-	                                   newType.Modifier = m.Modifier;
-	                                   newType.Attributes = attributes;
-	                                 .)
-	ident                            (. newType.Name = t.val; .)
-	[ StructInterfaces&lt;out names&gt;    (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
-	StructBody
-	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
-	                                    compilationUnit.BlockEnd();
-	                                 .)
-	| /*--- interface declaration: */ 
-	&quot;interface&quot;                      (. TypeDeclaration newType = new TypeDeclaration();
-	                                    compilationUnit.AddChild(newType);
-	                                    compilationUnit.BlockStart(newType);
-	                                    newType.Type = Types.Interface;
-	                                    newType.Attributes = attributes;
-	                                    newType.Modifier = m.Modifier;.)
-	ident                            (. newType.Name = t.val; .)
-	[ InterfaceBase&lt;out names&gt;       (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
-	InterfaceBody
-	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
-	                                    compilationUnit.BlockEnd();
-	                                 .)
-	| /*--- enumeration declaration: */
-	&quot;enum&quot;                           (. TypeDeclaration newType = new TypeDeclaration();
-	                                    compilationUnit.AddChild(newType);
-	                                    compilationUnit.BlockStart(newType);
-	                                    newType.Type = Types.Enum;
-	                                    newType.Attributes = attributes;
-	                                    newType.Modifier = m.Modifier;.)
-	ident                            (. newType.Name = t.val; .)
-	[ &quot;:&quot; IntegralType&lt;out name&gt;     (. newType.BaseTypes = new StringCollection(); 
-	                                    newType.BaseTypes.Add(name);
-	                                 .)
-	]                                (. newType.StartLocation = t.EndLocation; .)
-	EnumBody 
-	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
-	                                    compilationUnit.BlockEnd();
-	                                 .)
-	| /*--- delegate declaration: */
-	&quot;delegate&quot;                       (. DelegateDeclaration delegateDeclr = new DelegateDeclaration();
-	                                    delegateDeclr.StartLocation = t.Location;
-	                                    delegateDeclr.Modifier = m.Modifier;
-	                                    delegateDeclr.Attributes = attributes;
-	                                 .)
-	( IF (NotVoidPointer()) &quot;void&quot;   (. delegateDeclr.ReturnType = new TypeReference(&quot;void&quot;, 0, null); .)
-		| Type&lt;out type&gt;             (. delegateDeclr.ReturnType = type; .)
-	)
-	ident                            (. delegateDeclr.Name = t.val; .)
-	&quot;(&quot; [ FormalParameterList&lt;out p&gt; (. delegateDeclr.Parameters = p; .)
-	] &quot;)&quot;
-	&quot;;&quot;                              (. delegateDeclr.EndLocation = t.Location;
-	                                    compilationUnit.AddChild(delegateDeclr);
-	                                 .)
-	)
-.
-
-Qualident&lt;out string qualident&gt;
-=
-	ident                              (. StringBuilder qualidentBuilder = new StringBuilder(t.val); .)
-	{ IF (DotAndIdent()) &quot;.&quot; ident     (. qualidentBuilder.Append('.');
-	                                      qualidentBuilder.Append(t.val); 
-	                                    .)
-	} (. qualident = qualidentBuilder.ToString(); .)
-.
-
-ClassBase&lt;out StringCollection names&gt;
-(.
-	string qualident;
-	names = new StringCollection(); 
-.)
-=
-	&quot;:&quot; ClassType&lt;out qualident&gt;       (. names.Add(qualident); .)
-	{ &quot;,&quot; Qualident&lt;out qualident&gt;     (. names.Add(qualident); .) }
-.
-
-ClassBody
-(. AttributeSection section; .)
-=
-	&quot;{&quot;
-	{                                  (.ArrayList attributes = new ArrayList();
-		                                 Modifiers m = new Modifiers(this);
-		                               .)
-		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-		{ MemberModifier&lt;m&gt; } 
-		ClassMemberDecl&lt;m, attributes&gt; 
-	}
-	&quot;}&quot;
-.
-
-StructInterfaces&lt;out StringCollection names&gt;
-(.
-	string qualident; 
-	names = new StringCollection();
-.)
-=
-	&quot;:&quot; Qualident&lt;out qualident&gt;        (. names.Add(qualident); .)
-	{ &quot;,&quot; Qualident&lt;out qualident&gt;      (. names.Add(qualident); .) }
-.
-
-StructBody
-(. AttributeSection section; .)
-=
-	&quot;{&quot; 
-	{                                    (.ArrayList attributes = new ArrayList();
-		                                   Modifiers m = new Modifiers(this);
-		                                 .)
-		{ AttributeSection&lt;out section&gt;  (. attributes.Add(section); .) }
-		{ MemberModifier&lt;m&gt; } 
-		StructMemberDecl&lt;m, attributes&gt; 
-	}
-	&quot;}&quot; 
-.
-
-InterfaceBase&lt;out StringCollection names&gt;
-(.
-	string qualident;
-	names = new StringCollection();
-.)
-=
-	&quot;:&quot; Qualident&lt;out qualident&gt;    (. names.Add(qualident); .)
-	{ &quot;,&quot; Qualident&lt;out qualident&gt;  (. names.Add(qualident); .) }
-.
-
-InterfaceBody
-= &quot;{&quot; { InterfaceMemberDecl } &quot;}&quot; .
-
-EnumBody                                 (. FieldDeclaration f; .)
-=
-	&quot;{&quot; [ EnumMemberDecl&lt;out f&gt;          (. compilationUnit.AddChild(f); .)
-	{ IF (NotFinalComma()) &quot;,&quot; EnumMemberDecl&lt;out f&gt; (. compilationUnit.AddChild(f); .)
-	}
-	[&quot;,&quot;] ] &quot;}&quot;
-.
-
-Type&lt;out TypeReference type&gt;
-(.
-	string name = &quot;&quot;;
-	int pointer = 0;
-.)
-=
-	( ClassType&lt;out name&gt;
-	| SimpleType&lt;out name&gt;
-	| &quot;void&quot; &quot;*&quot;                         (. pointer = 1; name = &quot;void&quot;; .)
-	)                                    (. ArrayList r = new ArrayList(); .)
-	{ IF (IsPointerOrDims())             (. int i = 1; .)
-		( &quot;*&quot;                            (. ++pointer; .)
-		| &quot;[&quot; { &quot;,&quot; (. ++i; .) } &quot;]&quot;     (. r.Add(i); .)
-		) 
-	}                                    (. int[] rank = new int[r.Count]; r.CopyTo(rank); 
-	                                        type = new TypeReference(name, pointer, rank);
-	                                     .)
-.
-
-NonArrayType&lt;out TypeReference type&gt;
-(.
-	string name = &quot;&quot;;
-	int pointer = 0;
-.)
-=
-	( ClassType&lt;out name&gt;
-	| SimpleType&lt;out name&gt;
-	| &quot;void&quot; &quot;*&quot;                         (. pointer = 1; name = &quot;void&quot;; .)
-	)                                    
-	{ IF (IsPointer())                   
-		( &quot;*&quot;                            (. ++pointer; .)
-		) 
-	}                                    (. 
-	                                        type = new TypeReference(name, pointer, null);
-	                                     .)
-.
-
-SimpleType&lt;out string name&gt;
-(. name = String.Empty; .)
-=
-	IntegralType&lt;out name&gt; 
-	| &quot;float&quot;   (. name = t.val; .)
-	| &quot;double&quot;  (. name = t.val; .)
-	| &quot;decimal&quot; (. name = t.val; .)
-	| &quot;bool&quot;    (. name = t.val; .)
-.
-
-
-FormalParameterList&lt;out ArrayList parameter&gt;
-(.
-	parameter = new ArrayList();
-	ParameterDeclarationExpression p;
-	AttributeSection section;
-	ArrayList attributes = new ArrayList();
-.)
-=
-	{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
-	(
-		FixedParameter&lt;out p&gt; (. bool paramsFound = false;
-		                         p.Attributes = attributes;
-		                         parameter.Add(p);
-		                      .)
-		{
-			&quot;,&quot;                              (. attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); .)
-			{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
-			(
-				FixedParameter&lt;out p&gt;        (. p.Attributes = attributes; parameter.Add(p); .)
-				| ParameterArray&lt;out p&gt;      (. paramsFound = true; p.Attributes = attributes; parameter.Add(p); .)
-			)
-		}
-		| ParameterArray&lt;out p&gt;              (. p.Attributes = attributes; parameter.Add(p); .)
-	)
-.
-
-FixedParameter&lt;out ParameterDeclarationExpression p&gt;
-(.
-	TypeReference type;
-	ParamModifiers mod = ParamModifiers.In;
-.)
-=
-	[
-		&quot;ref&quot;    (. mod = ParamModifiers.Ref; .)
-		| &quot;out&quot;  (. mod = ParamModifiers.Out; .)
-	]
-	Type&lt;out type&gt; ident (. p = new ParameterDeclarationExpression(type, t.val, mod); .)
-.
-
-ParameterArray&lt;out ParameterDeclarationExpression p&gt;
-(. TypeReference type; .)
-=
-	&quot;params&quot; Type&lt;out type&gt; ident (. p = new ParameterDeclarationExpression(type, t.val, ParamModifiers.Params); .)
-. 
-
-TypeModifier&lt;Modifiers m&gt;
-=
-	&quot;new&quot;                              (. m.Add(Modifier.New); .)
-	| &quot;public&quot;                         (. m.Add(Modifier.Public); .)
-	| &quot;protected&quot;                      (. m.Add(Modifier.Protected); .)
-	| &quot;internal&quot;                       (. m.Add(Modifier.Internal); .)
-	| &quot;private&quot;                        (. m.Add(Modifier.Private); .)
-	| &quot;unsafe&quot;                         (. m.Add(Modifier.Unsafe); .)
-	| &quot;abstract&quot;                       (. m.Add(Modifier.Abstract); .)
-	| &quot;sealed&quot;                         (. m.Add(Modifier.Sealed); .)
-	| &quot;static&quot;                         (. m.Add(Modifier.Static); .)
-.
-
-ClassType&lt;out string name&gt;             (. string qualident; name = &quot;&quot;;.)
-=
-	Qualident&lt;out qualident&gt;           (. name = qualident; .)
-	| &quot;object&quot;                         (. name = &quot;object&quot;; .)
-	| &quot;string&quot;                         (. name = &quot;string&quot;; .)
-.
-
-IntegralType&lt;out string name&gt;          (. name = &quot;&quot;; .)
-=
-	&quot;sbyte&quot;                            (. name = &quot;sbyte&quot;; .)
-	| &quot;byte&quot;                           (. name = &quot;byte&quot;; .)
-	| &quot;short&quot;                          (. name = &quot;short&quot;; .)
-	| &quot;ushort&quot;                         (. name = &quot;ushort&quot;; .)
-	| &quot;int&quot;                            (. name = &quot;int&quot;; .)
-	| &quot;uint&quot;                           (. name = &quot;uint&quot;; .)
-	| &quot;long&quot;                           (. name = &quot;long&quot;; .)
-	| &quot;ulong&quot;                          (. name = &quot;ulong&quot;; .)
-	| &quot;char&quot;                           (. name = &quot;char&quot;; .)
-.
-
-MemberModifier&lt;Modifiers m&gt;
-=
-	&quot;abstract&quot;                         (. m.Add(Modifier.Abstract); .)
-	| &quot;extern&quot;                         (. m.Add(Modifier.Extern); .)
-	| &quot;internal&quot;                       (. m.Add(Modifier.Internal); .)
-	| &quot;new&quot;                            (. m.Add(Modifier.New); .)
-	| &quot;override&quot;                       (. m.Add(Modifier.Override); .)
-	| &quot;private&quot;                        (. m.Add(Modifier.Private); .)
-	| &quot;protected&quot;                      (. m.Add(Modifier.Protected); .)
-	| &quot;public&quot;                         (. m.Add(Modifier.Public); .)
-	| &quot;readonly&quot;                       (. m.Add(Modifier.Readonly); .)
-	| &quot;sealed&quot;                         (. m.Add(Modifier.Sealed); .)
-	| &quot;static&quot;                         (. m.Add(Modifier.Static); .)
-	| &quot;unsafe&quot;                         (. m.Add(Modifier.Unsafe); .)
-	| &quot;virtual&quot;                        (. m.Add(Modifier.Virtual); .)
-	| &quot;volatile&quot;                       (. m.Add(Modifier.Volatile); .)
-.
-
-StructMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
-(.
-	string qualident = null;
-	TypeReference type;
-	Expression expr;
-	ArrayList p = new ArrayList();
-	Statement stmt = null;
-	ArrayList variableDeclarators = new ArrayList();
-.)
-=
-	/*--- constant declaration: */         (. m.Check(Modifier.Constants); .)
-	&quot;const&quot;
-	Type&lt;out type&gt; ident                   (. FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier | Modifier.Const);
-	                                          VariableDeclaration f = new VariableDeclaration(t.val);
-	                                          fd.Fields.Add(f);
-	                                       .)
-	&quot;=&quot; Expr&lt;out expr&gt;                     (. f.Initializer = expr; .)
-	{ &quot;,&quot; ident                            (. f = new VariableDeclaration(t.val);
-	                                          fd.Fields.Add(f);
-	                                       .)
-		&quot;=&quot; Expr&lt;out expr&gt;                 (. f.Initializer = expr; .)
-	} &quot;;&quot;                                  (. fd.EndLocation = t.EndLocation; compilationUnit.AddChild(fd); .)
-	
-	/*--- void method (procedure) declaration: */
-	| IF (NotVoidPointer())                (. m.Check(Modifier.PropertysEventsMethods); .)
-	&quot;void&quot;                                 (. Point startPos = t.Location; .)
-	Qualident&lt;out qualident&gt; &quot;(&quot; 
-	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot;     (. MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
-	                                                                                                      m.Modifier, 
-	                                                                                                      new TypeReference(&quot;void&quot;), 
-	                                                                                                      p, 
-	                                                                                                      attributes);
-	                                          methodDeclaration.StartLocation = startPos;
-	                                          methodDeclaration.EndLocation   = t.EndLocation;
-	                                          compilationUnit.AddChild(methodDeclaration);
-	                                          compilationUnit.BlockStart(methodDeclaration);
-	                                       .)
-	( Block&lt;out stmt&gt; | &quot;;&quot; )              (. compilationUnit.BlockEnd();
-	                                          methodDeclaration.Body  = (BlockStatement)stmt;
-	                                       .)
-	
-	| /*--- event declaration: */          (. m.Check(Modifier.PropertysEventsMethods); .)
-	&quot;event&quot;                                (. EventDeclaration eventDecl = new EventDeclaration(m.Modifier, attributes);
-	                                          eventDecl.StartLocation = t.Location;
-	                                          compilationUnit.AddChild(eventDecl);
-	                                          compilationUnit.BlockStart(eventDecl);
-	                                          EventAddRegion addBlock = null;
-	                                          EventRemoveRegion removeBlock = null;
-	                                       .)
-	Type&lt;out type&gt;                         (. eventDecl.TypeReference = type; .)
-	(
-		IF (IsVarDecl()) VariableDeclarator&lt;variableDeclarators&gt;
-		{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; } &quot;;&quot;      (. eventDecl.VariableDeclarators = variableDeclarators; eventDecl.EndLocation = t.EndLocation;  .)
-		| Qualident&lt;out qualident&gt;         (. eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation;  .)
-		&quot;{&quot; (. eventDecl.BodyStart = t.Location; .)
-		EventAccessorDecls&lt;out addBlock, out removeBlock&gt; 
-		&quot;}&quot; (. eventDecl.BodyEnd   = t.EndLocation; .)
-	)                                       (. compilationUnit.BlockEnd();
-	                                           
-	                                           eventDecl.AddRegion = addBlock;
-	                                           eventDecl.RemoveRegion = removeBlock;
-	                                       .)
-	
-	/*--- constructor or static contructor declaration: */
-	| IF (IdentAndLPar())                  (. m.Check(Modifier.Constructors | Modifier.StaticConstructors); .)
-	ident (. string name = t.val; Point startPos = t.Location; .) &quot;(&quot; [  (. m.Check(Modifier.Constructors); .)
-	FormalParameterList&lt;out p&gt;
-	]
-	&quot;)&quot; (.ConstructorInitializer init = null;  .)
-	[                                      (. m.Check(Modifier.Constructors); .)
-		ConstructorInitializer&lt;out init&gt;
-	] (. 
-	     ConstructorDeclaration cd = new ConstructorDeclaration(name, m.Modifier, p, init, attributes); 
-	     cd.StartLocation = startPos;
-	     cd.EndLocation   = t.EndLocation;
-	  .)
-	
-	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. cd.Body = (BlockStatement)stmt; compilationUnit.AddChild(cd); .)
-	
-	/*--- conversion operator declaration: */
-	|                                      (. m.Check(Modifier.Operators);
-	                                          if (m.isNone) Error(&quot;at least one modifier must be set&quot;); 
-	                                          bool isImplicit = true;
-	                                       .)
-	( &quot;implicit&quot; | &quot;explicit&quot; (. isImplicit = false; .) ) 
-	&quot;operator&quot; Type&lt;out type&gt; (. TypeReference operatorType = type; .) 
-	&quot;(&quot; Type&lt;out type&gt; ident (. string varName = t.val; .) &quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; (. stmt = null; .) )
-	(.
-		
-		OperatorDeclarator operatorDeclarator = new OperatorDeclarator(isImplicit ? OperatorType.Implicit : OperatorType.Explicit,
-		                                                               operatorType,
-		                                                               type,
-		                                                               varName);
-		OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
-		operatorDeclaration.Body = stmt;
-		compilationUnit.AddChild(operatorDeclaration);
-	.)
-	
-	/*--- inner type declaration: */
-	| TypeDecl&lt;m, attributes&gt;
-	| Type&lt;out type&gt;                       (. Point startPos = t.Location; .)
-	(
-		/*--- operator declaration: */     (. Token op;
-		                                      m.Check(Modifier.Operators);
-		                                      if (m.isNone) Error(&quot;at least one modifier must be set&quot;);
-		                                   .)
-		&quot;operator&quot; OverloadableOperator&lt;out op&gt; (. TypeReference firstType, secondType = null; string secondName = null; .)
-		&quot;(&quot; Type&lt;out firstType&gt; ident (. string firstName = t.val; .)
-		( &quot;,&quot; Type&lt;out secondType&gt; ident (. secondName = t.val; .)        (. if (ParserUtil.IsUnaryOperator(op) &amp;&amp; !ParserUtil.IsBinaryOperator(op))
-		                                      Error(&quot;too many operands for unary operator&quot;); 
-		                                   .)
-		| /* empty */                      (. if (ParserUtil.IsBinaryOperator(op))
-		                                      Error(&quot;too few operands for binary operator&quot;);
-		                                   .)
-		)
-		&quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; )
-		(.
-			OperatorDeclarator operatorDeclarator = new OperatorDeclarator(secondType != null ? OperatorType.Binary : OperatorType.Unary, 
-			                                                               type,
-			                                                               op.kind,
-			                                                               firstType,
-			                                                               firstName,
-			                                                               secondType,
-			                                                               secondName);
-			OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
-			operatorDeclaration.Body = stmt;
-			compilationUnit.AddChild(operatorDeclaration);
-		.)
-		
-		/*--- field declaration: */
-		| IF (IsVarDecl())                 (. m.Check(Modifier.Fields); 
-		                                      FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
-		                                      fd.StartLocation = startPos; 
-		                                   .)
-		VariableDeclarator&lt;variableDeclarators&gt;
-		{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; }
-		&quot;;&quot;                                (. fd.EndLocation = t.EndLocation; fd.Fields = variableDeclarators; compilationUnit.AddChild(fd); .)
-		
-		/*--- unqualified indexer declaration (without interface name): */
-		|                                  (. m.Check(Modifier.Indexers); .)
-		&quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (. Point endLocation = t.EndLocation; .) &quot;{&quot; (.
-			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
-			         indexer.StartLocation = startPos;
-			         indexer.EndLocation   = endLocation;
-			         indexer.BodyStart     = t.Location;
-			         PropertyGetRegion getRegion;
-			         PropertySetRegion setRegion;
-			       .) 
-		AccessorDecls&lt;out getRegion, out setRegion&gt; &quot;}&quot; (. 
-			          indexer.BodyEnd    = t.EndLocation;
-			          indexer.GetRegion = getRegion;
-			          indexer.SetRegion = setRegion;
-			          compilationUnit.AddChild(indexer);
-			       .)
-		| Qualident&lt;out qualident&gt; (. Point qualIdentEndLocation = t.EndLocation; .)
-		(
-			/*--- &quot;not void&quot; method (function) declaration: */
-			(                              (. m.Check(Modifier.PropertysEventsMethods); .)
-			    &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
-	                                                                                                      m.Modifier, 
-	                                                                                                      type, 
-	                                                                                                      p, 
-	                                                                                                      attributes);
-	                                                      methodDeclaration.StartLocation = startPos;
-	                                                      methodDeclaration.EndLocation   = t.EndLocation;
-	                                                      compilationUnit.AddChild(methodDeclaration);
-	                                                   .)
-			     ( Block&lt;out stmt&gt; | &quot;;&quot; ) (. methodDeclaration.Body  = (BlockStatement)stmt; .)
-			
-			/*--- property declaration: */  
-			| &quot;{&quot; (. PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
-			         pDecl.StartLocation = startPos;
-			         pDecl.EndLocation   = qualIdentEndLocation;
-			         pDecl.BodyStart   = t.Location;
-			         PropertyGetRegion getRegion;
-			         PropertySetRegion setRegion;
-			      .)
-			   AccessorDecls&lt;out getRegion, out setRegion&gt; 
-			   &quot;}&quot; (. 
-			          pDecl.GetRegion = getRegion;
-			          pDecl.SetRegion = setRegion;
-			          pDecl.BodyEnd = t.EndLocation;
-			          compilationUnit.AddChild(pDecl);
-			       .)
-			)
-			
-			/*--- qualified indexer declaration (with interface name): */
-			|                              (. m.Check(Modifier.Indexers); .)
-			&quot;.&quot; &quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (.
-			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
-			         indexer.StartLocation = startPos;
-			         indexer.EndLocation   = t.EndLocation;
-			         indexer.NamespaceName = qualident;
-			         PropertyGetRegion getRegion;
-			         PropertySetRegion setRegion;
-			       .) 
-			  &quot;{&quot; (. Point bodyStart = t.Location; .)
-			  AccessorDecls&lt;out getRegion, out setRegion&gt; 
-			  &quot;}&quot;  (. indexer.BodyStart = bodyStart;
-			          indexer.BodyEnd   = t.EndLocation;
-			          indexer.GetRegion = getRegion;
-			          indexer.SetRegion = setRegion;
-			          compilationUnit.AddChild(indexer);
-			       .)
-		)
-	)
-.
-
-ClassMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
-(. Statement stmt = null; .)
-=
-	StructMemberDecl&lt;m, attributes&gt;
-	| /*--- destructor declaration: */ (. m.Check(Modifier.Destructors); Point startPos = t.Location; .)
-	&quot;~&quot; ident                          (. DestructorDeclaration d = new DestructorDeclaration(t.val, attributes); 
-	                                      d.Modifier = m.Modifier;
-	                                      d.StartLocation = startPos;
-	                                   .)
-	&quot;(&quot; &quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; )  (. d.EndLocation = t.EndLocation; 
-	                                      d.Body = (BlockStatement)stmt;
-	                                      compilationUnit.AddChild(d);
-	                                   .)
-.
-
-InterfaceMemberDecl
-(.
-	TypeReference type;
-	ArrayList p;
-	AttributeSection section;
-	Modifier mod = Modifier.None;
-	ArrayList attributes = new ArrayList();
-	ArrayList parameters = new ArrayList();
-	string name;
-	PropertyGetRegion getBlock;
-	PropertySetRegion setBlock;
-	Point startLocation = new Point(-1, -1);
-.)
-=
-	{ AttributeSection&lt;out section&gt;     (. attributes.Add(section); .)}
-	[ &quot;new&quot; (. mod = Modifier.New; startLocation = t.Location; .) ]
-	(
-		/*--- interface void method (procedure) declaration: */
-		IF (NotVoidPointer()) &quot;void&quot; (. if (startLocation.X == -1) startLocation = t.Location; .) ident (. name = t.val; .)
-		&quot;(&quot; [ FormalParameterList&lt;out parameters&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference(&quot;void&quot;), parameters, attributes);
-		                                              md.StartLocation = startLocation;
-		                                              md.EndLocation = t.EndLocation;
-		                                              compilationUnit.AddChild(md);
-		                                           .)
-		| (
-			Type&lt;out type&gt; (. if (startLocation.X == -1) startLocation = t.Location; .)
-			(
-				ident                  (. name = t.val; Point qualIdentEndLocation = t.EndLocation; .)
-				(
-					/*--- interface &quot;not void&quot; method (function) declaration: */
-					&quot;(&quot; [ FormalParameterList&lt;out parameters&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, type, parameters, attributes);
-					                                              md.StartLocation = startLocation;
-					                                              md.EndLocation = t.EndLocation;
-					                                              compilationUnit.AddChild(md);
-					                                           .)
-					/*--- interface property declaration: */
-					|                   (. PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); .)
-					&quot;{&quot; (. Point bodyStart = t.Location;.) InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; .)
-				)
-				/*--- interface indexer declaration: */
-				| &quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (.Point bracketEndLocation = t.EndLocation; .)  (. IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); .)
-				&quot;{&quot; (. Point bodyStart = t.Location;.) InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;.)
-			)
-			/*--- interface event declaration: */
-			| &quot;event&quot; (. if (startLocation.X == -1) startLocation = t.Location; .) Type&lt;out type&gt; ident (. EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
-			                                  compilationUnit.AddChild(ed);
-			                               .)
-			&quot;;&quot;                            (. ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; .)
-		)
-	)
-.
-
-EnumMemberDecl&lt;out FieldDeclaration f&gt;
-(.
-	Expression expr = null;
-	ArrayList attributes = new ArrayList();
-	AttributeSection section = null;
-	VariableDeclaration varDecl = null;
-.)
-=
-	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-	ident                           (. f = new FieldDeclaration(attributes);
-	                                   varDecl         = new VariableDeclaration(t.val);
-	                                   f.Fields.Add(varDecl);
-	                                   f.StartLocation = t.Location;
-	                                .)
-	[ &quot;=&quot; Expr&lt;out expr&gt; (. varDecl.Initializer = expr; .) ]
-.
-
-
-AccessorDecls&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
-(.
-	ArrayList attributes = new ArrayList(); 
-	AttributeSection section;
-	getBlock = null;
-	setBlock = null; 
-.)
-=
-	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-	(
-		IF (IdentIsGet())
-			GetAccessorDecl&lt;out getBlock, attributes&gt;
-			[                       (. attributes = new ArrayList(); .)
-				{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-				SetAccessorDecl&lt;out setBlock, attributes&gt;
-			]
-		| IF (IdentIsSet())
-			SetAccessorDecl&lt;out setBlock, attributes&gt;
-			[                        (. attributes = new ArrayList(); .)
-				{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-				GetAccessorDecl&lt;out getBlock, attributes&gt;
-			]
-		| ident (. Error(&quot;get or set accessor declaration expected&quot;); .)
-	)
-.
-
-GetAccessorDecl&lt;out PropertyGetRegion getBlock, ArrayList attributes&gt;
-(. Statement stmt = null; .)
-=
-	ident /* &quot;get&quot; is not a keyword!? */
-	(. if (t.val != &quot;get&quot;) Error(&quot;get expected&quot;); .)
-	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes); .)
-.
-
-SetAccessorDecl&lt;out PropertySetRegion setBlock, ArrayList attributes&gt;
-(. Statement stmt = null; .)
-=
-	ident /* &quot;set&quot; is not a keyword!? */
-	(. if (t.val != &quot;set&quot;) Error(&quot;set expected&quot;); .)
-	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. setBlock = new PropertySetRegion((BlockStatement)stmt, attributes); .)
-.
-
-EventAccessorDecls&lt;out EventAddRegion addBlock, out EventRemoveRegion removeBlock&gt;
-(. AttributeSection section;
-   ArrayList attributes = new ArrayList();
-   Statement stmt;
-   addBlock = null;
-   removeBlock = null;
-.)
-=
-	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-	(
-		IF (IdentIsAdd())            (. addBlock = new EventAddRegion(attributes); .)
-			AddAccessorDecl&lt;out stmt&gt;       (. attributes = new ArrayList(); addBlock.Block = (BlockStatement)stmt; .)
-			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .)}
-			RemoveAccessorDecl&lt;out stmt&gt;    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; .)
-		| IF (IdentIsRemove())
-			RemoveAccessorDecl &lt;out stmt&gt;    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new ArrayList(); .)
-			{ AttributeSection&lt;out section&gt;  (. attributes.Add(section); .) }
-			AddAccessorDecl&lt;out stmt&gt;        (. addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; .)
-		| ident (. Error(&quot;add or remove accessor declaration expected&quot;); .)
-	)
-.
-
-InterfaceAccessors&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
-(.
-	AttributeSection section;
-	ArrayList attributes = new ArrayList();
-	getBlock = null; setBlock = null;
-.)
-=
-	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-	(
-		IF (IdentIsGet()) ident   (. getBlock = new PropertyGetRegion(null, attributes); .)
-		| IF (IdentIsSet()) ident (. setBlock = new PropertySetRegion(null, attributes); .)
-		| ident                   (. Error(&quot;set or get expected&quot;); .)
-	)
-	&quot;;&quot;                           (. attributes = new ArrayList(); .)
-	[
-		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-		(
-			IF (IdentIsGet()) ident   (. if (getBlock != null) Error(&quot;get already declared&quot;);
-			                             else getBlock = new PropertyGetRegion(null, attributes);
-			                          .)
-			| IF (IdentIsSet()) ident (. if (setBlock != null) Error(&quot;set already declared&quot;);
-			                             else setBlock = new PropertySetRegion(null, attributes);
-			                          .)
-			| ident                   (. Error(&quot;set or get expected&quot;); .)
-		)
-		&quot;;&quot;
-	]
-.
-
-VariableDeclarator&lt;ArrayList fieldDeclaration&gt;
-(. Expression expr = null; .)
-=
-	ident                                 (. VariableDeclaration f = new VariableDeclaration(t.val); .)
-	[ &quot;=&quot; VariableInitializer&lt;out expr&gt;   (. f.Initializer = expr; .) ] (. fieldDeclaration.Add(f); .)
-.
-
-Block&lt;out Statement stmt&gt; /* not BlockStatement because of EmbeddedStatement */
-=
-	&quot;{&quot; (. BlockStatement blockStmt = new BlockStatement();
-	       blockStmt.StartLocation = t.Location;
-	       compilationUnit.BlockStart(blockStmt);
-	    .)
-	{ Statement }
-	&quot;}&quot; (. stmt = blockStmt;
-	       blockStmt.EndLocation = t.EndLocation;
-	       compilationUnit.BlockEnd();
-	    .)
-.
-
-AddAccessorDecl&lt;out Statement stmt&gt;
-(.stmt = null;.) 
-=
-	/* &quot;add&quot; is not a keyword!? */
-	ident (. if (t.val != &quot;add&quot;) Error(&quot;add expected&quot;); .)
-	Block&lt;out stmt&gt;
-.
-
-RemoveAccessorDecl&lt;out Statement stmt&gt;
-(.stmt = null;.) 
-=
-	/* &quot;remove&quot; is not a keyword!? */
-	ident (. if (t.val != &quot;remove&quot;) Error(&quot;remove expected&quot;); .)
-	Block&lt;out stmt&gt;
-.
-
-ConstructorInitializer&lt;out ConstructorInitializer ci&gt;
-(. Expression expr; ci = new ConstructorInitializer(); .)
-=
-	&quot;:&quot;
-	(
-		&quot;base&quot; (. ci.ConstructorInitializerType = ConstructorInitializerType.Base; .)
-		| &quot;this&quot;  (. ci.ConstructorInitializerType = ConstructorInitializerType.This; .)
-	) 
-	&quot;(&quot;
-	[ Argument&lt;out expr&gt; (. ci.Arguments.Add(expr); .) { &quot;,&quot; Argument&lt;out expr&gt; (. ci.Arguments.Add(expr); .) } ]
-	&quot;)&quot;
-.
-
-VariableInitializer&lt;out Expression initializerExpression&gt;
-(. TypeReference type = null; Expression expr = null; initializerExpression = null; .)
-=
-	Expr&lt;out initializerExpression&gt;
-	| ArrayInitializer&lt;out initializerExpression&gt;
-	| &quot;stackalloc&quot; Type&lt;out type&gt; &quot;[&quot; Expr&lt;out expr&gt; &quot;]&quot; (. initializerExpression = new StackAllocExpression(type, expr); .)
-.
-
-OverloadableOperator&lt;out Token op&gt;
-=
-	(
-		&quot;+&quot;  | &quot;-&quot;  | &quot;!&quot;    | &quot;~&quot;
-		| &quot;++&quot; | &quot;--&quot; | &quot;true&quot; | &quot;false&quot;
-		| &quot;*&quot;  | &quot;/&quot;  | &quot;%&quot;    | &quot;&amp;&quot;
-		| &quot;|&quot;  | &quot;^&quot;  | &quot;&lt;&lt;&quot;   | &quot;&gt;&gt;&quot;
-		| &quot;==&quot; | &quot;!=&quot; | &quot;&gt;&quot;    | &quot;&lt;&quot;
-		| &quot;&gt;=&quot; | &quot;&lt;=&quot;
-	) (. op = t; .)
-.
-
-Argument&lt;out Expression argumentexpr&gt;
-(.
-	Expression expr;
-	FieldDirection fd = FieldDirection.None;
-.)
-=
-	[
-		&quot;ref&quot; (. fd = FieldDirection.Ref; .)
-		| &quot;out&quot; (. fd = FieldDirection.Out; .)
-	]
-	Expr&lt;out expr&gt; (. argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; .)
-.
-
-AssignmentOperator&lt;out AssignmentOperatorType op&gt;
-(. op = AssignmentOperatorType.None; .)
-=
-	&quot;=&quot;     (. op = AssignmentOperatorType.Assign; .)
-	| &quot;+=&quot;  (. op = AssignmentOperatorType.Add; .)
-	| &quot;-=&quot;  (. op = AssignmentOperatorType.Subtract; .)
-	| &quot;*=&quot;  (. op = AssignmentOperatorType.Multiply; .)
-	| &quot;/=&quot;  (. op = AssignmentOperatorType.Divide; .)
-	| &quot;%=&quot;  (. op = AssignmentOperatorType.Modulus; .)
-	| &quot;&amp;=&quot;  (. op = AssignmentOperatorType.BitwiseAnd; .)
-	| &quot;|=&quot;  (. op = AssignmentOperatorType.BitwiseOr; .)
-	| &quot;^=&quot;  (. op = AssignmentOperatorType.ExclusiveOr; .)
-	| &quot;&lt;&lt;=&quot; (. op = AssignmentOperatorType.ShiftLeft; .)
-	| &quot;&gt;&gt;=&quot; (. op = AssignmentOperatorType.ShiftRight; .)
-.
-
-ArrayInitializer&lt;out Expression outExpr&gt;
-(.
-	Expression expr = null;
-	ArrayInitializerExpression initializer = new ArrayInitializerExpression();
-.)
-=
-	&quot;{&quot;
-	[ VariableInitializer&lt;out expr&gt; (. initializer.CreateExpressions.Add(expr); .) { IF (NotFinalComma()) &quot;,&quot; VariableInitializer&lt;out expr&gt; (. initializer.CreateExpressions.Add(expr); .) } [ &quot;,&quot; ] ]
-	&quot;}&quot; (. outExpr = initializer; .)
-.
-
-LocalVariableDecl&lt;out Statement stmt&gt;
-(.
-	TypeReference type;
-	VariableDeclaration      var = null;
-	LocalVariableDeclaration localVariableDeclaration; 
-.)
-=
-	Type&lt;out type&gt; (. localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; .)
-	LocalVariableDeclarator&lt;out var&gt; (. localVariableDeclaration.Variables.Add(var); .)
-	{ &quot;,&quot; LocalVariableDeclarator&lt;out var&gt; (. localVariableDeclaration.Variables.Add(var); .) }
-	(. stmt = localVariableDeclaration; .)
-.
-
-LocalVariableDeclarator&lt;out VariableDeclaration var&gt;
-(. Expression expr = null; .)
-=
-	ident (. var = new VariableDeclaration(t.val); .) [ &quot;=&quot; LocalVariableInitializer&lt;out expr&gt; (. var.Initializer = expr; .) ]
-.
-
-LocalVariableInitializer&lt;out Expression expr&gt;
-(. expr = null; .)
-=
-	Expr&lt;out expr&gt;
-	| ArrayInitializer&lt;out expr&gt;
-.
-
-Statement
-(.
-	TypeReference type;
-	Expression expr;
-	Statement stmt;
-.)
-=
-	/*--- labeled statement: */
-	IF (IsLabel()) ident (. compilationUnit.AddChild(new LabelStatement(t.val)); .)
-	&quot;:&quot; Statement
-	/*--- local constant declaration: */
-	| &quot;const&quot; Type&lt;out type&gt; (. LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifier.Const); string ident = null; var.StartLocation = t.Location; .) 
-	  ident (. ident = t.val; .)
-	  &quot;=&quot; Expr&lt;out expr&gt; (. var.Variables.Add(new VariableDeclaration(ident, expr)); .)
-	  { &quot;,&quot; ident (. ident = t.val; .) &quot;=&quot; Expr&lt;out expr&gt; (. var.Variables.Add(new VariableDeclaration(ident, expr)); .) }
-	  &quot;;&quot; (. compilationUnit.AddChild(var); .)
-	/*--- local variable declaration: */
-	| IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt; &quot;;&quot; (. compilationUnit.AddChild(stmt); .)
-	| EmbeddedStatement&lt;out stmt&gt; (. compilationUnit.AddChild(stmt); .)
-	/* LL(1) confict: LocalVariableDecl *
-	 *            &lt;-&gt; StatementExpr     *
-	 * ident {&quot;.&quot; ident} { &quot;[&quot; Expr ... */
-.
-
-EmbeddedStatement&lt;out Statement statement&gt;
-(.
-	TypeReference type = null;
-	Expression expr = null;
-	Statement embeddedStatement = null;
-	statement = null;
-.)
-=
-	Block&lt;out statement&gt;
-	/*--- empty statement: */
-	| &quot;;&quot;                       (. statement = new EmptyStatement(); .)
-	/*--- checked / unchecked statement: */
-	| IF (UnCheckedAndLBrace()) (. Statement block; bool isChecked = true; .)
-	(&quot;checked&quot; | &quot;unchecked&quot;    (. isChecked = false;.) )
-	Block&lt;out block&gt;            (. statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); .)
-	/*--- expression statement: */
-	| StatementExpr&lt;out statement&gt; &quot;;&quot;
-	/*--- selection statements (if, switch): */
-	| &quot;if&quot;                      (. Statement elseStatement = null; .)
-	&quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
-	EmbeddedStatement&lt;out embeddedStatement&gt;
-	[ &quot;else&quot; EmbeddedStatement&lt;out elseStatement&gt; ]
-	                            (. statement = elseStatement != null ? (Statement)new IfElseStatement(expr, embeddedStatement, elseStatement) :  (Statement)new IfStatement(expr, embeddedStatement); .)
-	| &quot;switch&quot; (. ArrayList switchSections = new ArrayList(); .)
-	  &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
-	  &quot;{&quot; { SwitchSection&lt;out statement&gt; (. switchSections.Add(statement); .) } 
-	  &quot;}&quot;  (. statement = new SwitchStatement(expr, switchSections); .)
-	/*--- iteration statements (while, do, for, foreach): */
-	| &quot;while&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
-	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new WhileStatement(expr, embeddedStatement); .)
-	| &quot;do&quot; EmbeddedStatement&lt;out embeddedStatement&gt; &quot;while&quot;
-	&quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; &quot;;&quot;  (. statement = new DoWhileStatement(expr, embeddedStatement); .)
-	| &quot;for&quot; (. ArrayList initializer = null, iterator = null; .)
-	  &quot;(&quot; [ ForInitializer&lt;out initializer&gt; ] &quot;;&quot;
-	  [ Expr&lt;out expr&gt; ] &quot;;&quot;
-	  [ ForIterator&lt;out iterator&gt; ] &quot;)&quot;
-	  EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new ForStatement(initializer, expr, iterator, embeddedStatement); .)
-	| &quot;foreach&quot; &quot;(&quot; Type&lt;out type&gt; ident     (. string varName = t.val; .)
-	&quot;in&quot; Expr&lt;out expr&gt; &quot;)&quot;
-	EmbeddedStatement&lt;out embeddedStatement&gt; (.  statement = new ForeachStatement(type, varName , expr, embeddedStatement); 
-	                                             statement.EndLocation = t.EndLocation;
-	                                         .)
-	/*--- jump statements (break, contine, goto, return, throw): */
-	| &quot;break&quot; &quot;;&quot;               (. statement = new BreakStatement(); .)
-	| &quot;continue&quot; &quot;;&quot;            (. statement = new ContinueStatement(); .)
-	| GotoStatement&lt;out statement&gt;
-	| &quot;return&quot; [ Expr&lt;out expr&gt; ] &quot;;&quot;    (. statement = new ReturnStatement(expr); .)
-	| &quot;throw&quot; [ Expr&lt;out expr&gt; ] &quot;;&quot;     (. statement = new ThrowStatement(expr); .)
-	/*--- try statement: */
-	| TryStatement&lt;out statement&gt;
-	/*--- lock satement: */
-	| &quot;lock&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
-	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new LockStatement(expr, embeddedStatement); .)
-	/*--- using statement: */
-	| (.Statement resourceAcquisitionStmt = null; .)
-	&quot;using&quot; &quot;(&quot;
-	ResourceAcquisition&lt;out resourceAcquisitionStmt&gt; &quot;)&quot;
-	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); .)
-	/*--- unsafe statement: */
-	| &quot;unsafe&quot; Block&lt;out embeddedStatement&gt;  (. statement = new UnsafeStatement(embeddedStatement); .)
-	/*--- fixed statement: */
-	| &quot;fixed&quot;
-	&quot;(&quot; Type&lt;out type&gt;     (. if (type.PointerNestingLevel == 0) Error(&quot;can only fix pointer types&quot;);
-	                          FixedStatement fxStmt = new FixedStatement(type);
-	                          string identifier = null;
-	                       .)
-	ident                  (. identifier = t.val; .)
-	&quot;=&quot; Expr&lt;out expr&gt;     (. fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
-	{
-		&quot;,&quot; ident          (. identifier = t.val; .)
-		&quot;=&quot; Expr&lt;out expr&gt; (. fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
-	}
-	&quot;)&quot; EmbeddedStatement&lt;out embeddedStatement&gt;  (. fxStmt.EmbeddedStatement = embeddedStatement; statement = fxStmt;.)
-.
-
-ForInitializer&lt;out ArrayList initializer&gt;
-(.
-	Statement stmt; 
-	initializer = new ArrayList();
-.)
-=
-	IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt; (. initializer.Add(stmt);.)
-	| StatementExpr&lt;out stmt&gt; (.initializer.Add(stmt);.) { &quot;,&quot; StatementExpr&lt;out stmt&gt; (. initializer.Add(stmt);.) } (. initializer.Add(stmt);.)
-.
-
-ForIterator&lt;out ArrayList iterator&gt;
-(.
-	Statement stmt; 
-	iterator = new ArrayList();
-.)
-=
-	StatementExpr&lt;out stmt&gt; (. iterator.Add(stmt);.) { &quot;,&quot; StatementExpr&lt;out stmt&gt; (. iterator.Add(stmt); .) }
-.
-
-SwitchSection&lt;out Statement stmt&gt;
-(.
-	SwitchSection switchSection = new SwitchSection();
-	Expression expr;
-.)
-=
-	SwitchLabel&lt;out expr&gt; (. switchSection.SwitchLabels.Add(expr); .) { SwitchLabel&lt;out expr&gt; (. switchSection.SwitchLabels.Add(expr); .) } 
-	(. compilationUnit.BlockStart(switchSection); .)
-	Statement { Statement }
-	(.
-		compilationUnit.BlockEnd();
-		stmt = switchSection;
-	.)
-.
-
-SwitchLabel&lt;out Expression expr&gt;
- (. expr = null; .)
-=
-	&quot;case&quot; Expr&lt;out expr&gt; &quot;:&quot; 
-	| &quot;default&quot; &quot;:&quot;
-.
-
-TryStatement&lt;out Statement tryStatement&gt;
-(.
-	Statement blockStmt = null, finallyStmt = null;
-	ArrayList catchClauses = null;
-.)
-=
-	&quot;try&quot;  Block&lt;out blockStmt&gt;
-	(
-		CatchClauses&lt;out catchClauses&gt; [ &quot;finally&quot; Block&lt;out finallyStmt&gt; ]
-		| &quot;finally&quot; Block&lt;out finallyStmt&gt;
-	)
-	(.
-		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
-	
-	.)
-.
-
-CatchClauses&lt;out ArrayList catchClauses&gt;
-(.
-	catchClauses = new ArrayList();
-.)
-=
-	&quot;catch&quot; (. string name;
-	           string identifier;
-	           Statement stmt; 
-	        .)
-	/*--- general catch clause (as only catch clause) */
-	(
-		Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(stmt)); .)
-		/*--- specific catch clause */
-		| &quot;(&quot; ClassType&lt;out name&gt; (. identifier = null; .) [ ident (. identifier = t.val; .) ] &quot;)&quot; Block&lt;out stmt&gt;  (. catchClauses.Add(new CatchClause(name, identifier, stmt)); .)
-		{ IF (IsTypedCatch()) &quot;catch&quot; &quot;(&quot; ClassType&lt;out name&gt; (. identifier = null; .) [ ident (. identifier = t.val; .) ] &quot;)&quot; Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(name, identifier, stmt)); .) }
-		/*--- general catch clause (after specific catch clauses, optional) */
-		[ &quot;catch&quot; Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(stmt)); .) ]
-	)
-.
-
-GotoStatement&lt;out Statement stmt&gt;
-(. Expression expr; stmt = null; .)
-=
-	&quot;goto&quot;
-	(
-		ident (. stmt = new GotoStatement(t.val); .) &quot;;&quot;
-		| &quot;case&quot; Expr&lt;out expr&gt;  &quot;;&quot; (. stmt = new GotoCaseStatement(expr); .)
-		| &quot;default&quot; &quot;;&quot; (. stmt = new GotoCaseStatement(null); .)
-	)
-.
-
-ResourceAcquisition&lt;out Statement stmt&gt;
-(.
-	stmt = null;
-	Expression expr;
-.)
-=
-	(
-		IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt;
-		| Expr&lt;out expr&gt; /* LL(1) conflict resoltion:                             *
-		                  * check if next is Qualident followed by ident          *
-		                  * ==&gt; LocalVariableDecl                                 *
-		                  * new problem: first set of ResourceAcquisition changes */
-		(. stmt = new StatementExpression(expr); .)
-	)
-.
-
-StatementExpr&lt;out Statement stmt&gt;
-=
-	/* We don't know why, but it's in the grammar. */
-	/* (see internal document: assignment.txt) */
-	(.
-		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
-		                        la.kind == Tokens.Not   || la.kind == Tokens.BitwiseComplement ||
-		                        la.kind == Tokens.Times || la.kind == Tokens.BitwiseAnd   || IsTypeCast();
-		Expression expr = null;
-	.)
-	
-	UnaryExpr&lt;out expr&gt;
-	/*--- assignment */
-	(
-		(. AssignmentOperatorType op; Expression val; .) AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
-		| (. if (mustBeAssignment) Error(&quot;error in assignment.&quot;); .)
-	) (. stmt = new StatementExpression(expr); .)
-.
-
-Expr&lt;out Expression expr&gt;
-(. expr = null; Expression expr1 = null, expr2 = null; .)
-=
-	UnaryExpr&lt;out expr&gt;
-	/*--- conditional expression: */
-	(
-		ConditionalOrExpr&lt;ref expr&gt; [ &quot;?&quot; Expr&lt;out expr1&gt; &quot;:&quot; Expr&lt;out expr2&gt; (. expr = new ConditionalExpression(expr, expr1, expr2);  .) ] 
-		/*--- assignment: */
-		| (. AssignmentOperatorType op; Expression val; .) AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
-	)
-.
-
-
-UnaryExpr&lt;out Expression uExpr&gt;
-(.
-	TypeReference type = null;
-	Expression expr;
-	ArrayList  expressions = new ArrayList();
-	uExpr = null;
-.)
-=
-	{
-		  &quot;+&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); .)
-		| &quot;-&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); .)
-		| &quot;!&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); .)
-		| &quot;~&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); .)
-		| &quot;*&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); .)
-		| &quot;++&quot; (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); .)
-		| &quot;--&quot; (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); .)
-		| &quot;&amp;&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); .)
-		
-		/*--- cast expression: */
-		/* Problem:  &quot;(&quot; Type &quot;)&quot; from here and                     *
-		 *           &quot;(&quot; Expr &quot;)&quot; from PrimaryExpr                  *
-		 *           are not distinguishable                        *
-		 * Solution: (in IsTypeCast())                              *
-		 * use external information from compiled assembly or guess */
-		| IF (IsTypeCast()) &quot;(&quot; Type&lt;out type&gt; &quot;)&quot;  (.  expressions.Add(new CastExpression(type)); .)
-	}
-	
-	PrimaryExpr&lt;out expr&gt; (. for (int i = 0; i &lt; expressions.Count; ++i) {
-	                         	Expression nextExpression = i + 1 &lt; expressions.Count ? (Expression)expressions[i + 1] : expr;
-	                         	if (expressions[i] is CastExpression) {
-	                         		((CastExpression)expressions[i]).Expression = nextExpression;
-	                         	} else {
-	                         		((UnaryOperatorExpression)expressions[i]).Expression = nextExpression;
-	                         	}
-	                         }
-	                         if (expressions.Count &gt; 0) {
-	                         	uExpr = (Expression)expressions[0];
-	                         } else {
-	                         	uExpr = expr;
-	                         }
-	                      .)
-.
-
-
-PrimaryExpr&lt;out Expression pexpr&gt;
-(.
-	TypeReference type = null;
-	bool isArrayCreation = false;
-	Expression expr;
-	pexpr = null;
-.)
-=
-	(
-		&quot;true&quot;                              (.pexpr = new PrimitiveExpression(true, &quot;true&quot;);  .)
-		| &quot;false&quot;                           (.pexpr = new PrimitiveExpression(false, &quot;false&quot;); .)
-		| &quot;null&quot;                            (.pexpr = new PrimitiveExpression(null, &quot;null&quot;);  .)          /* from literal token */
-		| literal                           (.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
-		/*--- simple name: */
-		| ident (. pexpr = new IdentifierExpression(t.val); .)
-		/*--- parenthesized expression: */
-		| &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new ParenthesizedExpression(expr); .)
-		| /*--- predefined type member access: */
-		(
-			&quot;bool&quot;   | &quot;byte&quot;   | &quot;char&quot; | &quot;decimal&quot; | &quot;double&quot;
-			| &quot;float&quot;  | &quot;int&quot;    | &quot;long&quot; | &quot;object&quot;  | &quot;sbyte&quot;
-			| &quot;short&quot;  | &quot;string&quot; | &quot;uint&quot; | &quot;ulong&quot;   | &quot;ushort&quot;
-		) (. string val = t.val; t.val = &quot;&quot;; .) &quot;.&quot; ident (. pexpr = new FieldReferenceExpression(new TypeReferenceExpression(val), t.val); .)
-		/*--- this access: */
-		| &quot;this&quot;                              (. pexpr = new ThisReferenceExpression(); .)
-		/*--- base access: */
-		| &quot;base&quot;                              (. Expression retExpr = new BaseReferenceExpression(); .)
-		(
-			&quot;.&quot; ident                         (. retExpr = new FieldReferenceExpression(retExpr, t.val); .)
-			| &quot;[&quot; Expr&lt;out expr&gt;              (.ArrayList indices = new ArrayList(); indices.Add(expr); .)
-			{ &quot;,&quot; Expr&lt;out expr&gt;              (. indices.Add(expr); .) }
-			&quot;]&quot;                               (. retExpr = new IndexerExpression(retExpr, indices); .)
-		)                                     (. pexpr = retExpr; .)
-		| &quot;new&quot; NonArrayType&lt;out type&gt;                (. ArrayList parameters = new ArrayList(); .)
-		/*--- delegate / object creation expression: */
-		/* Note: a delegate creation expression allow only a single Expr  *
-		 *       not an argument list, but this is not distinguished here */
-		(
-			&quot;(&quot; (. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .) [ Argument&lt;out expr&gt;          (. parameters.Add(expr); .)
-			{ &quot;,&quot; Argument&lt;out expr&gt;          (. parameters.Add(expr); .) } ] &quot;)&quot; (. pexpr = oce; .)
-			/*--- array creation expression: */
-			| (. isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type); pexpr = ace; .)
-			&quot;[&quot; (. int dims = 0; ArrayList rank = new ArrayList(); ArrayList parameterExpression = new ArrayList(); .)
-			(
-				Expr&lt;out expr&gt; (. parameterExpression.Add(expr); .) { &quot;,&quot; Expr&lt;out expr&gt; (. parameterExpression.Add(expr); .) } &quot;]&quot; (. parameters.Add(new ArrayCreationParameter(parameterExpression)); ace.Parameters = parameters; .)
-				{ IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.rank.Add(dims); parameters.Add(new ArrayCreationParameter(dims)); .) &quot;]&quot; } 
-				(. if (rank.Count &gt; 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } .)
-				[ ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; .) ]
-				
-				| { &quot;,&quot; (.dims++;.) } (.parameters.Add(new ArrayCreationParameter(dims)); .)  &quot;]&quot; { IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.parameters.Add(new ArrayCreationParameter(dims)); .) &quot;]&quot; } ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; ace.Parameters = parameters; .)
-			)
-/*			| ArrayInitializer&lt;out expr&gt; (. if (!type.IsArrayType) { Error(&quot;() or [] expected&quot;); }  pexpr =  new ArrayCreateExpression(type, (ArrayInitializerExpression)expr); .)*/
-		)
-		| &quot;typeof&quot; &quot;(&quot;
-		(
-			IF (NotVoidPointer()) &quot;void&quot; (. type = new TypeReference(&quot;void&quot;); .)
-			| Type&lt;out type&gt;
-		) &quot;)&quot;                            (. pexpr = new TypeOfExpression(type); .)
-		| &quot;sizeof&quot; &quot;(&quot; Type&lt;out type&gt; &quot;)&quot; (. pexpr = new SizeOfExpression(type); .)
-		| &quot;checked&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new CheckedExpression(expr); .)
-		| &quot;unchecked&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new CheckedExpression(expr); .)
-	)
-	{
-		(
-			&quot;++&quot;   (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); .)
-			| &quot;--&quot; (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); .)
-		)
-		/*--- member access */
-		| &quot;-&gt;&quot; ident (. pexpr = new PointerReferenceExpression(pexpr, t.val); .)
-		| &quot;.&quot; ident (. pexpr = new FieldReferenceExpression(pexpr, t.val);.)
-		/*--- invocation expression: */
-		| &quot;(&quot;                        (. ArrayList parameters = new ArrayList(); .)
-			[ Argument&lt;out expr&gt;     (. parameters.Add(expr); .)
-			{ &quot;,&quot; Argument&lt;out expr&gt; (. parameters.Add(expr); .)
-			} ] &quot;)&quot;                  (. pexpr = new InvocationExpression(pexpr, parameters); .)
-		/*--- element access */
-		|  (. if (isArrayCreation) Error(&quot;element access not allow on array creation&quot;);
-		      ArrayList indices = new ArrayList();
-		   .)
-		&quot;[&quot; Expr&lt;out expr&gt; (.indices.Add(expr); .)
-		{ &quot;,&quot; Expr&lt;out expr&gt; (. indices.Add(expr); .)
-		} &quot;]&quot; (. pexpr = new IndexerExpression(pexpr, indices); .)
-	}
-.
-
-ConditionalOrExpr&lt;ref Expression outExpr&gt;
-(. Expression expr;   .)
-=
-	ConditionalAndExpr&lt;ref outExpr&gt;  { &quot;||&quot; UnaryExpr&lt;out expr&gt; ConditionalAndExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  .) }
-.
-
-ConditionalAndExpr&lt;ref Expression outExpr&gt;
-(. Expression expr; .)
-=
-	InclusiveOrExpr&lt;ref outExpr&gt;  { &quot;&amp;&amp;&quot; UnaryExpr&lt;out expr&gt; InclusiveOrExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  .) }
-.
-
-InclusiveOrExpr&lt;ref Expression outExpr&gt;
-(. Expression expr; .)
-=
-	ExclusiveOrExpr&lt;ref outExpr&gt;  { &quot;|&quot; UnaryExpr&lt;out expr&gt; ExclusiveOrExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  .) }
-.
-
-ExclusiveOrExpr&lt;ref Expression outExpr&gt;
-(. Expression expr; .)
-=
-	AndExpr&lt;ref outExpr&gt;  { &quot;^&quot; UnaryExpr&lt;out expr&gt; AndExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  .) }
-.
-
-AndExpr&lt;ref Expression outExpr&gt;
-(. Expression expr; .)
-=
-	EqualityExpr&lt;ref outExpr&gt; { &quot;&amp;&quot; UnaryExpr&lt;out expr&gt; EqualityExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  .) }
-.
-
-EqualityExpr&lt;ref Expression outExpr&gt;
-(.
-	Expression expr;
-	BinaryOperatorType op = BinaryOperatorType.None;
-.)
-=
-	RelationalExpr&lt;ref outExpr&gt;
-	{
-		(
-			&quot;!=&quot;   (. op = BinaryOperatorType.InEquality; .)
-			| &quot;==&quot; (. op = BinaryOperatorType.Equality; .)
-		)
-		UnaryExpr&lt;out expr&gt; RelationalExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
-	}
-.
-
-RelationalExpr&lt;ref Expression outExpr&gt;
-(.
-	TypeReference type;
-	Expression expr;
-	BinaryOperatorType op = BinaryOperatorType.None;
-.)
-=
-	ShiftExpr&lt;ref outExpr&gt;
-	{
-		(
-			&quot;&lt;&quot;    (. op = BinaryOperatorType.LessThan; .)
-			| &quot;&gt;&quot;  (. op = BinaryOperatorType.GreaterThan; .)
-			| &quot;&lt;=&quot; (. op = BinaryOperatorType.LessThanOrEqual; .)
-			| &quot;&gt;=&quot; (. op = BinaryOperatorType.GreaterThanOrEqual; .)
-		)
-		UnaryExpr&lt;out expr&gt; ShiftExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
-		|
-		(
-			&quot;is&quot; (. op = BinaryOperatorType.IS; .)
-			| &quot;as&quot; (. op = BinaryOperatorType.AS; .)
-		)
-		Type&lt;out type&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, new TypeReferenceExpression(type)); .)
-	}
-.
-
-ShiftExpr&lt;ref Expression outExpr&gt;
-(.
-	Expression expr;
-	BinaryOperatorType op = BinaryOperatorType.None;
-.)
-=
-	AdditiveExpr&lt;ref outExpr&gt; 
-	{
-		(
-			&quot;&lt;&lt;&quot;   (. op = BinaryOperatorType.ShiftLeft; .)
-			| &quot;&gt;&gt;&quot; (. op = BinaryOperatorType.ShiftRight; .)
-		)
-		UnaryExpr&lt;out expr&gt; AdditiveExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
-	}
-.
-
-AdditiveExpr&lt;ref Expression outExpr&gt;
-(.
-	Expression expr;
-	BinaryOperatorType op = BinaryOperatorType.None;
-.)
-=
-	MultiplicativeExpr&lt;ref outExpr&gt;
-	{
-		(
-			&quot;+&quot;   (. op = BinaryOperatorType.Add; .)
-			| &quot;-&quot; (. op = BinaryOperatorType.Subtract; .)
-		)
-		UnaryExpr&lt;out expr&gt; MultiplicativeExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
-	}
-.
-
-MultiplicativeExpr&lt;ref Expression outExpr&gt;
-(.
-	Expression expr;
-	BinaryOperatorType op = BinaryOperatorType.None;
-.)
-=
-	{
-		(
-			&quot;*&quot;   (. op = BinaryOperatorType.Multiply; .)
-			| &quot;/&quot; (. op = BinaryOperatorType.Divide; .)
-			| &quot;%&quot; (. op = BinaryOperatorType.Modulus; .)
-		) 
-		UnaryExpr&lt;out expr&gt; (. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .) 
-	}
-.
-	
-END CS.
+using System.Drawing;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+COMPILER CS    /* AW 2002-12-30 renamed from CompilationUnit to CS */
+
+string assemblyName = null;
+
+public CompilationUnit compilationUnit;
+
+public string ContainingAssembly {
+	set {
+		assemblyName = value;
+	}
+}
+
+Token t {
+	get {
+		return lexer.Token;
+	}
+}
+Token la {
+	get {
+		return lexer.LookAhead;
+	}
+}
+
+Hashtable typeStrings     = null;
+ArrayList usingNamespaces = null;
+
+public void Error(string s)
+{
+	if (errDist &gt;= minErrDist) {
+		errors.Error(la.line, la.col, s);
+	}
+	errDist = 0;
+}
+
+public Expression ParseExpression(Lexer lexer)
+{
+	this.errors = lexer.Errors;
+	this.lexer = lexer;
+	errors.SynErr = new ErrorCodeProc(SynErr);
+	lexer.NextToken();
+	Expression expr;
+	Expr(out expr);
+	return expr;
+}
+
+bool IsTypeCast()
+{
+	if (IsSimpleTypeCast()) {
+		return true;
+	}
+	
+	if (assemblyName != null) {
+		return CheckTypeCast();
+	}
+	
+	return GuessTypeCast();
+}
+
+bool IsSimpleTypeCast()
+{
+	// check: &quot;(&quot; pointer or array of keyword type &quot;)&quot;
+	
+	if (la.kind != Tokens.OpenParenthesis) {
+		return false;
+	}
+
+	StartPeek();
+	Token pt1 = Peek();
+	Token pt  = Peek();
+	
+	return ParserUtil.IsTypeKW(pt1) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp;
+	       pt.kind == Tokens.CloseParenthesis;
+}
+
+bool CheckTypeCast()
+{
+	// check: leading &quot;(&quot; pointer or array of some type &quot;)&quot;
+
+	if (la.kind != Tokens.OpenParenthesis) {
+		return false;
+	}
+	
+	string qualident;
+	
+	StartPeek();
+	Token pt = Peek();
+	
+	return IsQualident(ref pt, out qualident) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	       pt.kind == Tokens.CloseParenthesis &amp;&amp; IsType(qualident);		
+}
+
+bool IsType(string qualident)
+{
+	if (typeStrings == null) {
+		CreateTypeStrings();
+	}
+	
+	if (typeStrings.ContainsValue(qualident)) {
+		return true;
+	}
+	
+	foreach (string ns in usingNamespaces) {
+		if (typeStrings.ContainsValue(ns + &quot;.&quot; + qualident)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+bool GuessTypeCast()
+{
+	// check: &quot;(&quot; pointer or array of some type &quot;)&quot; possible type cast successor
+	
+	if (la.kind != Tokens.OpenParenthesis) return false;
+	
+	string qualident;
+	
+	StartPeek();
+	Token pt = Peek();
+	
+	if (IsQualident(ref pt, out qualident) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	    pt.kind == Tokens.CloseParenthesis) {
+		// check successor
+		pt = Peek();
+		return pt.kind == Tokens.Identifier || pt.kind == Tokens.Literal   ||
+		       pt.kind == Tokens.OpenParenthesis   || ParserUtil.IsUnaryOperator(pt)         ||
+		       pt.kind == Tokens.New        || pt.kind == Tokens.This      ||
+		       pt.kind == Tokens.Base       || pt.kind == Tokens.Null      ||
+		       pt.kind == Tokens.Checked    || pt.kind == Tokens.Unchecked ||
+		       pt.kind == Tokens.Typeof     || pt.kind == Tokens.Sizeof    ||
+		       (ParserUtil.IsTypeKW(pt) &amp;&amp; Peek().kind == Tokens.Dot);
+	} else return false;
+}
+
+void CreateTypeStrings()
+{
+	Assembly a;
+	Type[] types;
+	AssemblyName [] aNames;
+	
+	if (assemblyName != null &amp;&amp; assemblyName.Length &gt; 0) {    /* AW 2002-12-30 add check for length &gt; 0 */
+		typeStrings = new Hashtable();
+		a = Assembly.LoadFrom(assemblyName);
+		types = a.GetTypes();
+		foreach (Type t in types) 
+			typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
+		aNames = a.GetReferencedAssemblies();
+		
+		for (int i = 0; i &lt; aNames.Length; i++) {
+			a = Assembly.LoadFrom(aNames[i].Name);
+			types = a.GetExportedTypes();
+			
+			foreach(Type t in types)
+				if (usingNamespaces.Contains(t.FullName.Substring(0, t.FullName.LastIndexOf('.'))))
+					typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
+		}
+	}
+}
+
+/* Checks whether the next sequences of tokens is a qualident *
+ * and returns the qualident string                           */
+/* !!! Proceeds from current peek position !!! */
+bool IsQualident (ref Token pt, out string qualident)
+{
+	qualident = &quot;&quot;;
+	if (pt.kind == Tokens.Identifier) {
+		qualident = pt.val;
+		pt = Peek();
+		while (pt.kind == Tokens.Dot) {
+			pt = Peek();
+			if (pt.kind != Tokens.Identifier) return false;
+			qualident += &quot;.&quot; + pt.val;
+			pt = Peek();
+		}
+		return true;
+	} else return false;
+}
+
+/* skip: { &quot;*&quot; | &quot;[&quot; { &quot;,&quot; } &quot;]&quot; } */
+/* !!! Proceeds from current peek position !!! */
+bool IsPointerOrDims (ref Token pt)
+{
+	for (;;) {
+		if (pt.kind == Tokens.OpenSquareBracket) {
+			do pt = Peek();
+			while (pt.kind == Tokens.Comma);
+			if (pt.kind != Tokens.CloseSquareBracket) return false;
+		} else if (pt.kind != Tokens.Times) break;
+		pt = Peek();
+	}
+	return true;
+}
+
+/* Return the n-th token after the current lookahead token */
+void StartPeek()
+{
+	lexer.StartPeek();
+}
+
+Token Peek()
+{
+	return lexer.Peek();
+}
+
+Token Peek (int n)
+{
+	lexer.StartPeek();
+	Token x = la;
+	while (n &gt; 0) {
+		x = lexer.Peek();
+		n--;
+	}
+	return x;
+}
+
+/*-----------------------------------------------------------------*
+ * Resolver routines to resolve LL(1) conflicts:                   *                                                  *
+ * These resolution routine return a boolean value that indicates  *
+ * whether the alternative at hand shall be choosen or not.        *
+ * They are used in IF ( ... ) expressions.                        *       
+ *-----------------------------------------------------------------*/
+
+/* True, if ident is followed by &quot;=&quot; */
+bool IdentAndAsgn ()
+{
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.Assign;
+}
+
+bool IsAssignment () { return IdentAndAsgn(); }
+
+/* True, if ident is followed by &quot;,&quot;, &quot;=&quot;, or &quot;;&quot; */
+bool IdentAndCommaOrAsgnOrSColon () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Identifier &amp;&amp; 
+	       (peek == Tokens.Comma || peek == Tokens.Assign || peek == Tokens.Semicolon);
+}
+bool IsVarDecl () { return IdentAndCommaOrAsgnOrSColon(); }
+
+/* True, if the comma is not a trailing one, *
+ * like the last one in: a, b, c,            */
+bool NotFinalComma () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Comma &amp;&amp;
+	       peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
+}
+
+/* True, if &quot;void&quot; is followed by &quot;*&quot; */
+bool NotVoidPointer () {
+	return la.kind == Tokens.Void &amp;&amp; Peek(1).kind != Tokens.Times;
+}
+
+/* True, if &quot;checked&quot; or &quot;unchecked&quot; are followed by &quot;{&quot; */
+bool UnCheckedAndLBrace () {
+	return la.kind == Tokens.Checked || la.kind == Tokens.Unchecked &amp;&amp;
+	       Peek(1).kind == Tokens.OpenCurlyBrace;
+}
+
+/* True, if &quot;.&quot; is followed by an ident */
+bool DotAndIdent () {
+	return la.kind == Tokens.Dot &amp;&amp; Peek(1).kind == Tokens.Identifier;
+}
+
+/* True, if ident is followed by &quot;:&quot; */
+bool IdentAndColon () {
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.Colon;
+}
+
+bool IsLabel () { return IdentAndColon(); }
+
+/* True, if ident is followed by &quot;(&quot; */
+bool IdentAndLPar () {
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.OpenParenthesis;
+}
+
+/* True, if &quot;catch&quot; is followed by &quot;(&quot; */
+bool CatchAndLPar () {
+	return la.kind == Tokens.Catch &amp;&amp; Peek(1).kind == Tokens.OpenParenthesis;
+}
+bool IsTypedCatch () { return CatchAndLPar(); }
+
+/* True, if &quot;[&quot; is followed by the ident &quot;assembly&quot; */
+bool IsGlobalAttrTarget () {
+	Token pt = Peek(1);
+	return la.kind == Tokens.OpenSquareBracket &amp;&amp; 
+	       pt.kind == Tokens.Identifier &amp;&amp; pt.val == &quot;assembly&quot;;
+}
+
+/* True, if &quot;[&quot; is followed by &quot;,&quot; or &quot;]&quot; */
+bool LBrackAndCommaOrRBrack () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.OpenSquareBracket &amp;&amp;
+	       (peek == Tokens.Comma || peek == Tokens.CloseSquareBracket);
+}
+
+bool IsDims () { return LBrackAndCommaOrRBrack(); }
+
+/* True, if &quot;[&quot; is followed by &quot;,&quot; or &quot;]&quot; *
+ * or if the current token is &quot;*&quot;         */
+bool TimesOrLBrackAndCommaOrRBrack () {
+	return la.kind == Tokens.Times || LBrackAndCommaOrRBrack();
+}
+bool IsPointerOrDims () { return TimesOrLBrackAndCommaOrRBrack(); }
+bool IsPointer () { return la.kind == Tokens.Times; }
+
+/* True, if lookahead is a primitive type keyword, or *
+ * if it is a type declaration followed by an ident   */
+bool IsLocalVarDecl () {
+	if ((ParserUtil.IsTypeKW(la) &amp;&amp; Peek(1).kind != Tokens.Dot) || la.kind == Tokens.Void) return true;
+	
+	StartPeek();
+	Token pt = la ;  // peek token
+	string ignore;
+	
+	return IsQualident(ref pt, out ignore) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	       pt.kind == Tokens.Identifier;
+}
+
+/* True, if lookahead ident is &quot;get&quot; */
+bool IdentIsGet () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;get&quot;;
+}
+
+/* True, if lookahead ident is &quot;set&quot; */
+bool IdentIsSet () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;set&quot;;
+}
+
+/* True, if lookahead ident is &quot;add&quot; */
+bool IdentIsAdd () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;add&quot;;
+}
+
+/* True, if lookahead ident is &quot;remove&quot; */
+bool IdentIsRemove () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;remove&quot;;
+}
+
+/* True, if lookahead is a local attribute target specifier, *
+ * i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,         *
+ *             &quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;      */
+bool IsLocalAttrTarget () {
+	int cur = la.kind;
+	string val = la.val;
+
+	return (cur == Tokens.Event || cur == Tokens.Return ||
+	        (cur == Tokens.Identifier &amp;&amp;
+	         (val == &quot;field&quot; || val == &quot;method&quot;   || val == &quot;module&quot; ||
+	          val == &quot;param&quot; || val == &quot;property&quot; || val == &quot;type&quot;))) &amp;&amp;
+	       Peek(1).kind == Tokens.Colon;
+}
+
+
+/*------------------------------------------------------------------------*
+ *----- LEXER TOKEN LIST  ------------------------------------------------*
+ *------------------------------------------------------------------------*/
+TOKENS
+	/*----- terminal classes -----*/
+	/* EOF is 0 */
+	ident
+	literal
+	
+	/*----- special character -----*/
+	&quot;=&quot; /* 3 */
+	
+	&quot;+&quot;
+	&quot;-&quot;
+	&quot;*&quot;
+	&quot;/&quot;
+	&quot;%&quot;
+	
+	&quot;:&quot;
+	&quot;;&quot;
+	&quot;?&quot;
+	&quot;,&quot;
+	&quot;.&quot;
+	
+	&quot;{&quot;
+	&quot;}&quot;
+	
+	&quot;[&quot;
+	&quot;]&quot;
+	
+	&quot;(&quot;
+	&quot;)&quot;
+	
+	&quot;&gt;&quot;
+	&quot;&lt;&quot;
+	
+	&quot;!&quot;
+	&quot;&amp;&amp;&quot;
+	&quot;||&quot;
+	
+	&quot;~&quot;
+	&quot;&amp;&quot;
+	&quot;|&quot;
+	&quot;^&quot;
+
+	/*----- special character sequences -----*/
+	&quot;++&quot; /* 29 */
+	&quot;--&quot;
+	&quot;==&quot;
+	&quot;!=&quot;
+	&quot;&gt;=&quot;
+	&quot;&lt;=&quot;
+	
+	&quot;&lt;&lt;&quot;
+	&quot;&gt;&gt;&quot;
+	
+	&quot;+=&quot;
+	&quot;-=&quot;
+	&quot;*=&quot;
+	&quot;/=&quot;
+	&quot;%=&quot;
+	&quot;&amp;=&quot;
+	&quot;|=&quot;
+	&quot;^=&quot;
+	&quot;&lt;&lt;=&quot;
+	&quot;&gt;&gt;=&quot;
+	
+	&quot;-&gt;&quot;
+	
+	/*----- C# keywords -----*/
+	&quot;abstract&quot; /* 48 */
+	&quot;as&quot;
+	&quot;base&quot;
+	&quot;bool&quot;
+	&quot;break&quot;
+	&quot;byte&quot;
+	&quot;case&quot;
+	&quot;catch&quot;
+	&quot;char&quot;
+	&quot;checked&quot;
+	&quot;class&quot;
+	&quot;const&quot;
+	&quot;continue&quot;
+	&quot;decimal&quot;
+	&quot;default&quot;
+	&quot;delegate&quot;
+	&quot;do&quot;
+	&quot;double&quot;
+	&quot;else&quot;
+	&quot;enum&quot;
+	&quot;event&quot;
+	&quot;explicit&quot;
+	&quot;extern&quot;
+	&quot;false&quot;
+	&quot;finally&quot;
+	&quot;fixed&quot;
+	&quot;float&quot;
+	&quot;for&quot;
+	&quot;foreach&quot;
+	&quot;goto&quot;
+	&quot;if&quot;
+	&quot;implicit&quot;
+	&quot;in&quot;
+	&quot;int&quot;
+	&quot;interface&quot;
+	&quot;internal&quot;
+	&quot;is&quot;
+	&quot;lock&quot;
+	&quot;long&quot;
+	&quot;namespace&quot;
+	&quot;new&quot;
+	&quot;null&quot;
+	&quot;object&quot;
+	&quot;operator&quot;
+	&quot;out&quot;
+	&quot;override&quot;
+	&quot;params&quot;
+	&quot;private&quot;
+	&quot;protected&quot;
+	&quot;public&quot;
+	&quot;readonly&quot;
+	&quot;ref&quot;
+	&quot;return&quot;
+	&quot;sbyte&quot;
+	&quot;sealed&quot;
+	&quot;short&quot;
+	&quot;sizeof&quot;
+	&quot;stackalloc&quot;
+	&quot;static&quot;
+	&quot;string&quot;
+	&quot;struct&quot;
+	&quot;switch&quot;
+	&quot;this&quot;
+	&quot;throw&quot;
+	&quot;true&quot;
+	&quot;try&quot;
+	&quot;typeof&quot;
+	&quot;uint&quot;
+	&quot;ulong&quot;
+	&quot;unchecked&quot;
+	&quot;unsafe&quot;
+	&quot;ushort&quot;
+	&quot;using&quot;
+	&quot;virtual&quot;
+	&quot;void&quot;
+	&quot;volatile&quot;
+	&quot;while&quot;
+
+/*------------------------------------------------------------------------*
+ *----- PARSER -----------------------------------------------------------*
+ *------------------------------------------------------------------------*/
+
+PRODUCTIONS
+
+/*--- compilation unit: */
+CS
+(. compilationUnit = new CompilationUnit(); .)
+=
+	{ UsingDirective }
+	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
+	{ NamespaceMemberDecl }
+	EOF
+.
+
+UsingDirective
+(.
+	usingNamespaces = new ArrayList();
+	string qualident = null, aliasident = null;
+.)
+=
+	&quot;using&quot;                     (. Point startPos = t.Location;
+	                               INode node     = null; 
+	                            .)
+	[ IF (IsAssignment()) ident (. aliasident = t.val; .) &quot;=&quot;  ]  /*--- using alias directive */
+	Qualident&lt;out qualident&gt;    (. if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
+	                                 if (aliasident != null) {
+	                                   node = new UsingAliasDeclaration(aliasident, qualident);
+	                                 } else {
+	                                     usingNamespaces.Add(qualident);
+	                                     node = new UsingDeclaration(qualident);
+	                                 }
+	                               }
+	                            .)
+	&quot;;&quot;                         (. node.StartLocation = startPos;
+	                               node.EndLocation   = t.EndLocation;
+	                               compilationUnit.AddChild(node);
+	                            .)
+.
+
+GlobalAttributeSection
+=
+	
+	&quot;[&quot; (. Point startPos = t.Location; .) ident                   (. if (t.val != &quot;assembly&quot;) Error(&quot;global attribute target specifier (\&quot;assembly\&quot;) expected&quot;);
+	                               string attributeTarget = t.val;
+	                               ArrayList attributes = new ArrayList();
+	                               ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
+	                            .)
+	&quot;:&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)
+	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
+	[ &quot;,&quot; ]
+	&quot;]&quot;                         (. AttributeSection section = new AttributeSection(attributeTarget, attributes);
+	                               section.StartLocation = startPos;
+	                               section.EndLocation = t.EndLocation;
+	                               compilationUnit.AddChild(section);
+	                            .)
+.
+
+Attribute&lt;out ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute&gt;
+(. string qualident; .)
+=
+	Qualident&lt;out qualident&gt;           (. ArrayList positional = new ArrayList();
+	                                      ArrayList named      = new ArrayList();
+	                                      string name = qualident;
+	                                   .)
+	[ AttributeArguments&lt;ref positional, ref named&gt; ] (. attribute  = new ICSharpCode.SharpRefactory.Parser.AST.Attribute(name, positional, named);.)
+.
+
+AttributeArguments&lt;ref ArrayList positional, ref ArrayList named&gt;
+(.
+	bool nameFound = false;
+	string name = &quot;&quot;;
+	Expression expr;
+.)
+=
+	&quot;(&quot;
+	[
+		[
+			IF (IsAssignment())          (. nameFound = true; .)
+			ident                        (. name = t.val; .)
+			&quot;=&quot;
+		] Expr&lt;out expr&gt;                 (. if(name == &quot;&quot;) positional.Add(expr);
+		                                    else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
+		                                 .)
+		
+		{
+			&quot;,&quot;
+				(
+					IF (IsAssignment())    (. nameFound = true; .)
+					ident                      (. name = t.val; .)
+					&quot;=&quot;
+					| /*Empty*/                (. if (nameFound) Error(&quot;no positional argument after named argument&quot;); .)
+				) Expr&lt;out expr&gt;           (. if(name == &quot;&quot;) positional.Add(expr);
+				                              else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
+				                           .)
+		}
+	]
+	&quot;)&quot;
+.
+
+AttributeSection&lt;out AttributeSection section&gt;
+(.
+	string attributeTarget = &quot;&quot;;
+	ArrayList attributes = new ArrayList();
+	ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
+	
+.)
+=
+	&quot;[&quot; (. Point startPos = t.Location; .) /*--- attribute target specifier: */
+	[ IF (IsLocalAttrTarget())
+		( &quot;event&quot;                       (. attributeTarget = &quot;event&quot;;.)
+		| &quot;return&quot;                      (. attributeTarget = &quot;return&quot;;.)
+		| ident                         (. if (t.val != &quot;field&quot;    || t.val != &quot;method&quot; ||
+		                                      t.val != &quot;module&quot;   || t.val != &quot;param&quot;  ||
+		                                      t.val != &quot;property&quot; || t.val != &quot;type&quot;)
+		                                    Error(&quot;attribute target specifier (event, return, field,&quot; +
+		                                          &quot;method, module, param, property, or type) expected&quot;);
+		                                   attributeTarget = t.val;
+		                                .)
+		) &quot;:&quot; 
+	]
+	/*--- attribute list: */
+	Attribute&lt;out attribute&gt;            (. attributes.Add(attribute); .)
+	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
+	[ &quot;,&quot; ]
+	&quot;]&quot;                         (. section = new AttributeSection(attributeTarget, attributes);
+	                               section.StartLocation = startPos;
+	                               section.EndLocation = t.EndLocation;
+	                            .)
+.
+
+NamespaceMemberDecl
+(.
+	AttributeSection section;
+	ArrayList attributes = new ArrayList();
+	Modifiers m = new Modifiers(this);
+	string qualident;
+.)
+= /*--- namespace declaration: */
+	&quot;namespace&quot;                  (. Point startPos = t.Location; .)
+	Qualident&lt;out qualident&gt;     (. INode node =  new NamespaceDeclaration(qualident);
+	                                node.StartLocation = startPos;
+	                                compilationUnit.AddChild(node);
+	                                compilationUnit.BlockStart(node);
+	                              .)
+	&quot;{&quot;
+	{ UsingDirective }
+	{ NamespaceMemberDecl }
+	&quot;}&quot;
+	[ &quot;;&quot; ]                       (. node.EndLocation   = t.EndLocation;
+	                                 compilationUnit.BlockEnd();
+	                              .)
+	/*--- type declaration: */
+	| { AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	{ TypeModifier&lt;m&gt; }
+	TypeDecl&lt;m, attributes&gt;
+.
+
+TypeDecl&lt;Modifiers m, ArrayList attributes&gt;
+(.
+	TypeReference type;
+	StringCollection names;
+	ArrayList p; string name;
+.)
+= /*--- class declaration: */      (. m.Check(Modifier.Classes); .)
+	&quot;class&quot;                        (. TypeDeclaration newType = new TypeDeclaration();
+	                                  compilationUnit.AddChild(newType);
+	                                  compilationUnit.BlockStart(newType);
+	                                  
+	                                  newType.Type = Types.Class;
+	                                  newType.Modifier = m.Modifier;
+	                                  newType.Attributes = attributes;
+	                                .)
+	ident                           (. newType.Name = t.val; .)
+	[ ClassBase&lt;out names&gt;          (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
+	ClassBody
+	[ &quot;;&quot; ]                         (. newType.EndLocation = t.Location; 
+	                                   compilationUnit.BlockEnd();
+	                                .)
+	| /*--- struct declaration: */  (. m.Check(Modifier.StructsInterfacesEnumsDelegates); .)
+	( &quot;struct&quot;                      (. TypeDeclaration newType = new TypeDeclaration();
+	                                   compilationUnit.AddChild(newType);
+	                                   compilationUnit.BlockStart(newType);
+	                                   newType.Type = Types.Struct; 
+	                                   newType.Modifier = m.Modifier;
+	                                   newType.Attributes = attributes;
+	                                 .)
+	ident                            (. newType.Name = t.val; .)
+	[ StructInterfaces&lt;out names&gt;    (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
+	StructBody
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
+	                                    compilationUnit.BlockEnd();
+	                                 .)
+	| /*--- interface declaration: */ 
+	&quot;interface&quot;                      (. TypeDeclaration newType = new TypeDeclaration();
+	                                    compilationUnit.AddChild(newType);
+	                                    compilationUnit.BlockStart(newType);
+	                                    newType.Type = Types.Interface;
+	                                    newType.Attributes = attributes;
+	                                    newType.Modifier = m.Modifier;.)
+	ident                            (. newType.Name = t.val; .)
+	[ InterfaceBase&lt;out names&gt;       (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
+	InterfaceBody
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
+	                                    compilationUnit.BlockEnd();
+	                                 .)
+	| /*--- enumeration declaration: */
+	&quot;enum&quot;                           (. TypeDeclaration newType = new TypeDeclaration();
+	                                    compilationUnit.AddChild(newType);
+	                                    compilationUnit.BlockStart(newType);
+	                                    newType.Type = Types.Enum;
+	                                    newType.Attributes = attributes;
+	                                    newType.Modifier = m.Modifier;.)
+	ident                            (. newType.Name = t.val; .)
+	[ &quot;:&quot; IntegralType&lt;out name&gt;     (. newType.BaseTypes = new StringCollection(); 
+	                                    newType.BaseTypes.Add(name);
+	                                 .)
+	]                                (. newType.StartLocation = t.EndLocation; .)
+	EnumBody 
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
+	                                    compilationUnit.BlockEnd();
+	                                 .)
+	| /*--- delegate declaration: */
+	&quot;delegate&quot;                       (. DelegateDeclaration delegateDeclr = new DelegateDeclaration();
+	                                    delegateDeclr.StartLocation = t.Location;
+	                                    delegateDeclr.Modifier = m.Modifier;
+	                                    delegateDeclr.Attributes = attributes;
+	                                 .)
+	( IF (NotVoidPointer()) &quot;void&quot;   (. delegateDeclr.ReturnType = new TypeReference(&quot;void&quot;, 0, null); .)
+		| Type&lt;out type&gt;             (. delegateDeclr.ReturnType = type; .)
+	)
+	ident                            (. delegateDeclr.Name = t.val; .)
+	&quot;(&quot; [ FormalParameterList&lt;out p&gt; (. delegateDeclr.Parameters = p; .)
+	] &quot;)&quot;
+	&quot;;&quot;                              (. delegateDeclr.EndLocation = t.Location;
+	                                    compilationUnit.AddChild(delegateDeclr);
+	                                 .)
+	)
+.
+
+Qualident&lt;out string qualident&gt;
+=
+	ident                              (. StringBuilder qualidentBuilder = new StringBuilder(t.val); .)
+	{ IF (DotAndIdent()) &quot;.&quot; ident     (. qualidentBuilder.Append('.');
+	                                      qualidentBuilder.Append(t.val); 
+	                                    .)
+	} (. qualident = qualidentBuilder.ToString(); .)
+.
+
+ClassBase&lt;out StringCollection names&gt;
+(.
+	string qualident;
+	names = new StringCollection(); 
+.)
+=
+	&quot;:&quot; ClassType&lt;out qualident&gt;       (. names.Add(qualident); .)
+	{ &quot;,&quot; Qualident&lt;out qualident&gt;     (. names.Add(qualident); .) }
+.
+
+ClassBody
+(. AttributeSection section; .)
+=
+	&quot;{&quot;
+	{                                  (.ArrayList attributes = new ArrayList();
+		                                 Modifiers m = new Modifiers(this);
+		                               .)
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; } 
+		ClassMemberDecl&lt;m, attributes&gt; 
+	}
+	&quot;}&quot;
+.
+
+StructInterfaces&lt;out StringCollection names&gt;
+(.
+	string qualident; 
+	names = new StringCollection();
+.)
+=
+	&quot;:&quot; Qualident&lt;out qualident&gt;        (. names.Add(qualident); .)
+	{ &quot;,&quot; Qualident&lt;out qualident&gt;      (. names.Add(qualident); .) }
+.
+
+StructBody
+(. AttributeSection section; .)
+=
+	&quot;{&quot; 
+	{                                    (.ArrayList attributes = new ArrayList();
+		                                   Modifiers m = new Modifiers(this);
+		                                 .)
+		{ AttributeSection&lt;out section&gt;  (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; } 
+		StructMemberDecl&lt;m, attributes&gt; 
+	}
+	&quot;}&quot; 
+.
+
+InterfaceBase&lt;out StringCollection names&gt;
+(.
+	string qualident;
+	names = new StringCollection();
+.)
+=
+	&quot;:&quot; Qualident&lt;out qualident&gt;    (. names.Add(qualident); .)
+	{ &quot;,&quot; Qualident&lt;out qualident&gt;  (. names.Add(qualident); .) }
+.
+
+InterfaceBody
+= &quot;{&quot; { InterfaceMemberDecl } &quot;}&quot; .
+
+EnumBody                                 (. FieldDeclaration f; .)
+=
+	&quot;{&quot; [ EnumMemberDecl&lt;out f&gt;          (. compilationUnit.AddChild(f); .)
+	{ IF (NotFinalComma()) &quot;,&quot; EnumMemberDecl&lt;out f&gt; (. compilationUnit.AddChild(f); .)
+	}
+	[&quot;,&quot;] ] &quot;}&quot;
+.
+
+Type&lt;out TypeReference type&gt;
+(.
+	string name = &quot;&quot;;
+	int pointer = 0;
+.)
+=
+	( ClassType&lt;out name&gt;
+	| SimpleType&lt;out name&gt;
+	| &quot;void&quot; &quot;*&quot;                         (. pointer = 1; name = &quot;void&quot;; .)
+	)                                    (. ArrayList r = new ArrayList(); .)
+	{ IF (IsPointerOrDims())             (. int i = 1; .)
+		( &quot;*&quot;                            (. ++pointer; .)
+		| &quot;[&quot; { &quot;,&quot; (. ++i; .) } &quot;]&quot;     (. r.Add(i); .)
+		) 
+	}                                    (. int[] rank = new int[r.Count]; r.CopyTo(rank); 
+	                                        type = new TypeReference(name, pointer, rank);
+	                                     .)
+.
+
+NonArrayType&lt;out TypeReference type&gt;
+(.
+	string name = &quot;&quot;;
+	int pointer = 0;
+.)
+=
+	( ClassType&lt;out name&gt;
+	| SimpleType&lt;out name&gt;
+	| &quot;void&quot; &quot;*&quot;                         (. pointer = 1; name = &quot;void&quot;; .)
+	)                                    
+	{ IF (IsPointer())                   
+		( &quot;*&quot;                            (. ++pointer; .)
+		) 
+	}                                    (. 
+	                                        type = new TypeReference(name, pointer, null);
+	                                     .)
+.
+
+SimpleType&lt;out string name&gt;
+(. name = String.Empty; .)
+=
+	IntegralType&lt;out name&gt; 
+	| &quot;float&quot;   (. name = t.val; .)
+	| &quot;double&quot;  (. name = t.val; .)
+	| &quot;decimal&quot; (. name = t.val; .)
+	| &quot;bool&quot;    (. name = t.val; .)
+.
+
+
+FormalParameterList&lt;out ArrayList parameter&gt;
+(.
+	parameter = new ArrayList();
+	ParameterDeclarationExpression p;
+	AttributeSection section;
+	ArrayList attributes = new ArrayList();
+.)
+=
+	{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
+	(
+		FixedParameter&lt;out p&gt; (. bool paramsFound = false;
+		                         p.Attributes = attributes;
+		                         parameter.Add(p);
+		                      .)
+		{
+			&quot;,&quot;                              (. attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); .)
+			{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
+			(
+				FixedParameter&lt;out p&gt;        (. p.Attributes = attributes; parameter.Add(p); .)
+				| ParameterArray&lt;out p&gt;      (. paramsFound = true; p.Attributes = attributes; parameter.Add(p); .)
+			)
+		}
+		| ParameterArray&lt;out p&gt;              (. p.Attributes = attributes; parameter.Add(p); .)
+	)
+.
+
+FixedParameter&lt;out ParameterDeclarationExpression p&gt;
+(.
+	TypeReference type;
+	ParamModifiers mod = ParamModifiers.In;
+.)
+=
+	[
+		&quot;ref&quot;    (. mod = ParamModifiers.Ref; .)
+		| &quot;out&quot;  (. mod = ParamModifiers.Out; .)
+	]
+	Type&lt;out type&gt; ident (. p = new ParameterDeclarationExpression(type, t.val, mod); .)
+.
+
+ParameterArray&lt;out ParameterDeclarationExpression p&gt;
+(. TypeReference type; .)
+=
+	&quot;params&quot; Type&lt;out type&gt; ident (. p = new ParameterDeclarationExpression(type, t.val, ParamModifiers.Params); .)
+. 
+
+TypeModifier&lt;Modifiers m&gt;
+=
+	&quot;new&quot;                              (. m.Add(Modifier.New); .)
+	| &quot;public&quot;                         (. m.Add(Modifier.Public); .)
+	| &quot;protected&quot;                      (. m.Add(Modifier.Protected); .)
+	| &quot;internal&quot;                       (. m.Add(Modifier.Internal); .)
+	| &quot;private&quot;                        (. m.Add(Modifier.Private); .)
+	| &quot;unsafe&quot;                         (. m.Add(Modifier.Unsafe); .)
+	| &quot;abstract&quot;                       (. m.Add(Modifier.Abstract); .)
+	| &quot;sealed&quot;                         (. m.Add(Modifier.Sealed); .)
+	| &quot;static&quot;                         (. m.Add(Modifier.Static); .)
+.
+
+ClassType&lt;out string name&gt;             (. string qualident; name = &quot;&quot;;.)
+=
+	Qualident&lt;out qualident&gt;           (. name = qualident; .)
+	| &quot;object&quot;                         (. name = &quot;object&quot;; .)
+	| &quot;string&quot;                         (. name = &quot;string&quot;; .)
+.
+
+IntegralType&lt;out string name&gt;          (. name = &quot;&quot;; .)
+=
+	&quot;sbyte&quot;                            (. name = &quot;sbyte&quot;; .)
+	| &quot;byte&quot;                           (. name = &quot;byte&quot;; .)
+	| &quot;short&quot;                          (. name = &quot;short&quot;; .)
+	| &quot;ushort&quot;                         (. name = &quot;ushort&quot;; .)
+	| &quot;int&quot;                            (. name = &quot;int&quot;; .)
+	| &quot;uint&quot;                           (. name = &quot;uint&quot;; .)
+	| &quot;long&quot;                           (. name = &quot;long&quot;; .)
+	| &quot;ulong&quot;                          (. name = &quot;ulong&quot;; .)
+	| &quot;char&quot;                           (. name = &quot;char&quot;; .)
+.
+
+MemberModifier&lt;Modifiers m&gt;
+=
+	&quot;abstract&quot;                         (. m.Add(Modifier.Abstract); .)
+	| &quot;extern&quot;                         (. m.Add(Modifier.Extern); .)
+	| &quot;internal&quot;                       (. m.Add(Modifier.Internal); .)
+	| &quot;new&quot;                            (. m.Add(Modifier.New); .)
+	| &quot;override&quot;                       (. m.Add(Modifier.Override); .)
+	| &quot;private&quot;                        (. m.Add(Modifier.Private); .)
+	| &quot;protected&quot;                      (. m.Add(Modifier.Protected); .)
+	| &quot;public&quot;                         (. m.Add(Modifier.Public); .)
+	| &quot;readonly&quot;                       (. m.Add(Modifier.Readonly); .)
+	| &quot;sealed&quot;                         (. m.Add(Modifier.Sealed); .)
+	| &quot;static&quot;                         (. m.Add(Modifier.Static); .)
+	| &quot;unsafe&quot;                         (. m.Add(Modifier.Unsafe); .)
+	| &quot;virtual&quot;                        (. m.Add(Modifier.Virtual); .)
+	| &quot;volatile&quot;                       (. m.Add(Modifier.Volatile); .)
+.
+
+StructMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
+(.
+	string qualident = null;
+	TypeReference type;
+	Expression expr;
+	ArrayList p = new ArrayList();
+	Statement stmt = null;
+	ArrayList variableDeclarators = new ArrayList();
+.)
+=
+	/*--- constant declaration: */         (. m.Check(Modifier.Constants); .)
+	&quot;const&quot;
+	Type&lt;out type&gt; ident                   (. FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier | Modifier.Const);
+	                                          VariableDeclaration f = new VariableDeclaration(t.val);
+	                                          fd.Fields.Add(f);
+	                                       .)
+	&quot;=&quot; Expr&lt;out expr&gt;                     (. f.Initializer = expr; .)
+	{ &quot;,&quot; ident                            (. f = new VariableDeclaration(t.val);
+	                                          fd.Fields.Add(f);
+	                                       .)
+		&quot;=&quot; Expr&lt;out expr&gt;                 (. f.Initializer = expr; .)
+	} &quot;;&quot;                                  (. fd.EndLocation = t.EndLocation; compilationUnit.AddChild(fd); .)
+	
+	/*--- void method (procedure) declaration: */
+	| IF (NotVoidPointer())                (. m.Check(Modifier.PropertysEventsMethods); .)
+	&quot;void&quot;                                 (. Point startPos = t.Location; .)
+	Qualident&lt;out qualident&gt; &quot;(&quot; 
+	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot;     (. MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
+	                                                                                                      m.Modifier, 
+	                                                                                                      new TypeReference(&quot;void&quot;), 
+	                                                                                                      p, 
+	                                                                                                      attributes);
+	                                          methodDeclaration.StartLocation = startPos;
+	                                          methodDeclaration.EndLocation   = t.EndLocation;
+	                                          compilationUnit.AddChild(methodDeclaration);
+	                                          compilationUnit.BlockStart(methodDeclaration);
+	                                       .)
+	( Block&lt;out stmt&gt; | &quot;;&quot; )              (. compilationUnit.BlockEnd();
+	                                          methodDeclaration.Body  = (BlockStatement)stmt;
+	                                       .)
+	
+	| /*--- event declaration: */          (. m.Check(Modifier.PropertysEventsMethods); .)
+	&quot;event&quot;                                (. EventDeclaration eventDecl = new EventDeclaration(m.Modifier, attributes);
+	                                          eventDecl.StartLocation = t.Location;
+	                                          compilationUnit.AddChild(eventDecl);
+	                                          compilationUnit.BlockStart(eventDecl);
+	                                          EventAddRegion addBlock = null;
+	                                          EventRemoveRegion removeBlock = null;
+	                                       .)
+	Type&lt;out type&gt;                         (. eventDecl.TypeReference = type; .)
+	(
+		IF (IsVarDecl()) VariableDeclarator&lt;variableDeclarators&gt;
+		{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; } &quot;;&quot;      (. eventDecl.VariableDeclarators = variableDeclarators; eventDecl.EndLocation = t.EndLocation;  .)
+		| Qualident&lt;out qualident&gt;         (. eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation;  .)
+		&quot;{&quot; (. eventDecl.BodyStart = t.Location; .)
+		EventAccessorDecls&lt;out addBlock, out removeBlock&gt; 
+		&quot;}&quot; (. eventDecl.BodyEnd   = t.EndLocation; .)
+	)                                       (. compilationUnit.BlockEnd();
+	                                           
+	                                           eventDecl.AddRegion = addBlock;
+	                                           eventDecl.RemoveRegion = removeBlock;
+	                                       .)
+	
+	/*--- constructor or static contructor declaration: */
+	| IF (IdentAndLPar())                  (. m.Check(Modifier.Constructors | Modifier.StaticConstructors); .)
+	ident (. string name = t.val; Point startPos = t.Location; .) &quot;(&quot; [  (. m.Check(Modifier.Constructors); .)
+	FormalParameterList&lt;out p&gt;
+	]
+	&quot;)&quot; (.ConstructorInitializer init = null;  .)
+	[                                      (. m.Check(Modifier.Constructors); .)
+		ConstructorInitializer&lt;out init&gt;
+	] (. 
+	     ConstructorDeclaration cd = new ConstructorDeclaration(name, m.Modifier, p, init, attributes); 
+	     cd.StartLocation = startPos;
+	     cd.EndLocation   = t.EndLocation;
+	  .)
+	
+	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. cd.Body = (BlockStatement)stmt; compilationUnit.AddChild(cd); .)
+	
+	/*--- conversion operator declaration: */
+	|                                      (. m.Check(Modifier.Operators);
+	                                          if (m.isNone) Error(&quot;at least one modifier must be set&quot;); 
+	                                          bool isImplicit = true;
+	                                       .)
+	( &quot;implicit&quot; | &quot;explicit&quot; (. isImplicit = false; .) ) 
+	&quot;operator&quot; Type&lt;out type&gt; (. TypeReference operatorType = type; .) 
+	&quot;(&quot; Type&lt;out type&gt; ident (. string varName = t.val; .) &quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; (. stmt = null; .) )
+	(.
+		
+		OperatorDeclarator operatorDeclarator = new OperatorDeclarator(isImplicit ? OperatorType.Implicit : OperatorType.Explicit,
+		                                                               operatorType,
+		                                                               type,
+		                                                               varName);
+		OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+		operatorDeclaration.Body = stmt;
+		compilationUnit.AddChild(operatorDeclaration);
+	.)
+	
+	/*--- inner type declaration: */
+	| TypeDecl&lt;m, attributes&gt;
+	| Type&lt;out type&gt;                       (. Point startPos = t.Location; .)
+	(
+		/*--- operator declaration: */     (. Token op;
+		                                      m.Check(Modifier.Operators);
+		                                      if (m.isNone) Error(&quot;at least one modifier must be set&quot;);
+		                                   .)
+		&quot;operator&quot; OverloadableOperator&lt;out op&gt; (. TypeReference firstType, secondType = null; string secondName = null; .)
+		&quot;(&quot; Type&lt;out firstType&gt; ident (. string firstName = t.val; .)
+		( &quot;,&quot; Type&lt;out secondType&gt; ident (. secondName = t.val; .)        (. if (ParserUtil.IsUnaryOperator(op) &amp;&amp; !ParserUtil.IsBinaryOperator(op))
+		                                      Error(&quot;too many operands for unary operator&quot;); 
+		                                   .)
+		| /* empty */                      (. if (ParserUtil.IsBinaryOperator(op))
+		                                      Error(&quot;too few operands for binary operator&quot;);
+		                                   .)
+		)
+		&quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; )
+		(.
+			OperatorDeclarator operatorDeclarator = new OperatorDeclarator(secondType != null ? OperatorType.Binary : OperatorType.Unary, 
+			                                                               type,
+			                                                               op.kind,
+			                                                               firstType,
+			                                                               firstName,
+			                                                               secondType,
+			                                                               secondName);
+			OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+			operatorDeclaration.Body = stmt;
+			compilationUnit.AddChild(operatorDeclaration);
+		.)
+		
+		/*--- field declaration: */
+		| IF (IsVarDecl())                 (. m.Check(Modifier.Fields); 
+		                                      FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+		                                      fd.StartLocation = startPos; 
+		                                   .)
+		VariableDeclarator&lt;variableDeclarators&gt;
+		{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; }
+		&quot;;&quot;                                (. fd.EndLocation = t.EndLocation; fd.Fields = variableDeclarators; compilationUnit.AddChild(fd); .)
+		
+		/*--- unqualified indexer declaration (without interface name): */
+		|                                  (. m.Check(Modifier.Indexers); .)
+		&quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (. Point endLocation = t.EndLocation; .) &quot;{&quot; (.
+			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
+			         indexer.StartLocation = startPos;
+			         indexer.EndLocation   = endLocation;
+			         indexer.BodyStart     = t.Location;
+			         PropertyGetRegion getRegion;
+			         PropertySetRegion setRegion;
+			       .) 
+		AccessorDecls&lt;out getRegion, out setRegion&gt; &quot;}&quot; (. 
+			          indexer.BodyEnd    = t.EndLocation;
+			          indexer.GetRegion = getRegion;
+			          indexer.SetRegion = setRegion;
+			          compilationUnit.AddChild(indexer);
+			       .)
+		| Qualident&lt;out qualident&gt; (. Point qualIdentEndLocation = t.EndLocation; .)
+		(
+			/*--- &quot;not void&quot; method (function) declaration: */
+			(                              (. m.Check(Modifier.PropertysEventsMethods); .)
+			    &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
+	                                                                                                      m.Modifier, 
+	                                                                                                      type, 
+	                                                                                                      p, 
+	                                                                                                      attributes);
+	                                                      methodDeclaration.StartLocation = startPos;
+	                                                      methodDeclaration.EndLocation   = t.EndLocation;
+	                                                      compilationUnit.AddChild(methodDeclaration);
+	                                                   .)
+			     ( Block&lt;out stmt&gt; | &quot;;&quot; ) (. methodDeclaration.Body  = (BlockStatement)stmt; .)
+			
+			/*--- property declaration: */  
+			| &quot;{&quot; (. PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
+			         pDecl.StartLocation = startPos;
+			         pDecl.EndLocation   = qualIdentEndLocation;
+			         pDecl.BodyStart   = t.Location;
+			         PropertyGetRegion getRegion;
+			         PropertySetRegion setRegion;
+			      .)
+			   AccessorDecls&lt;out getRegion, out setRegion&gt; 
+			   &quot;}&quot; (. 
+			          pDecl.GetRegion = getRegion;
+			          pDecl.SetRegion = setRegion;
+			          pDecl.BodyEnd = t.EndLocation;
+			          compilationUnit.AddChild(pDecl);
+			       .)
+			)
+			
+			/*--- qualified indexer declaration (with interface name): */
+			|                              (. m.Check(Modifier.Indexers); .)
+			&quot;.&quot; &quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (.
+			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
+			         indexer.StartLocation = startPos;
+			         indexer.EndLocation   = t.EndLocation;
+			         indexer.NamespaceName = qualident;
+			         PropertyGetRegion getRegion;
+			         PropertySetRegion setRegion;
+			       .) 
+			  &quot;{&quot; (. Point bodyStart = t.Location; .)
+			  AccessorDecls&lt;out getRegion, out setRegion&gt; 
+			  &quot;}&quot;  (. indexer.BodyStart = bodyStart;
+			          indexer.BodyEnd   = t.EndLocation;
+			          indexer.GetRegion = getRegion;
+			          indexer.SetRegion = setRegion;
+			          compilationUnit.AddChild(indexer);
+			       .)
+		)
+	)
+.
+
+ClassMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
+(. Statement stmt = null; .)
+=
+	StructMemberDecl&lt;m, attributes&gt;
+	| /*--- destructor declaration: */ (. m.Check(Modifier.Destructors); Point startPos = t.Location; .)
+	&quot;~&quot; ident                          (. DestructorDeclaration d = new DestructorDeclaration(t.val, attributes); 
+	                                      d.Modifier = m.Modifier;
+	                                      d.StartLocation = startPos;
+	                                   .)
+	&quot;(&quot; &quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; )  (. d.EndLocation = t.EndLocation; 
+	                                      d.Body = (BlockStatement)stmt;
+	                                      compilationUnit.AddChild(d);
+	                                   .)
+.
+
+InterfaceMemberDecl
+(.
+	TypeReference type;
+	ArrayList p;
+	AttributeSection section;
+	Modifier mod = Modifier.None;
+	ArrayList attributes = new ArrayList();
+	ArrayList parameters = new ArrayList();
+	string name;
+	PropertyGetRegion getBlock;
+	PropertySetRegion setBlock;
+	Point startLocation = new Point(-1, -1);
+.)
+=
+	{ AttributeSection&lt;out section&gt;     (. attributes.Add(section); .)}
+	[ &quot;new&quot; (. mod = Modifier.New; startLocation = t.Location; .) ]
+	(
+		/*--- interface void method (procedure) declaration: */
+		IF (NotVoidPointer()) &quot;void&quot; (. if (startLocation.X == -1) startLocation = t.Location; .) ident (. name = t.val; .)
+		&quot;(&quot; [ FormalParameterList&lt;out parameters&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference(&quot;void&quot;), parameters, attributes);
+		                                              md.StartLocation = startLocation;
+		                                              md.EndLocation = t.EndLocation;
+		                                              compilationUnit.AddChild(md);
+		                                           .)
+		| (
+			Type&lt;out type&gt; (. if (startLocation.X == -1) startLocation = t.Location; .)
+			(
+				ident                  (. name = t.val; Point qualIdentEndLocation = t.EndLocation; .)
+				(
+					/*--- interface &quot;not void&quot; method (function) declaration: */
+					&quot;(&quot; [ FormalParameterList&lt;out parameters&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, type, parameters, attributes);
+					                                              md.StartLocation = startLocation;
+					                                              md.EndLocation = t.EndLocation;
+					                                              compilationUnit.AddChild(md);
+					                                           .)
+					/*--- interface property declaration: */
+					|                   (. PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); .)
+					&quot;{&quot; (. Point bodyStart = t.Location;.) InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; .)
+				)
+				/*--- interface indexer declaration: */
+				| &quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (.Point bracketEndLocation = t.EndLocation; .)  (. IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); .)
+				&quot;{&quot; (. Point bodyStart = t.Location;.) InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;.)
+			)
+			/*--- interface event declaration: */
+			| &quot;event&quot; (. if (startLocation.X == -1) startLocation = t.Location; .) Type&lt;out type&gt; ident (. EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
+			                                  compilationUnit.AddChild(ed);
+			                               .)
+			&quot;;&quot;                            (. ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; .)
+		)
+	)
+.
+
+EnumMemberDecl&lt;out FieldDeclaration f&gt;
+(.
+	Expression expr = null;
+	ArrayList attributes = new ArrayList();
+	AttributeSection section = null;
+	VariableDeclaration varDecl = null;
+.)
+=
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	ident                           (. f = new FieldDeclaration(attributes);
+	                                   varDecl         = new VariableDeclaration(t.val);
+	                                   f.Fields.Add(varDecl);
+	                                   f.StartLocation = t.Location;
+	                                .)
+	[ &quot;=&quot; Expr&lt;out expr&gt; (. varDecl.Initializer = expr; .) ]
+.
+
+
+AccessorDecls&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
+(.
+	ArrayList attributes = new ArrayList(); 
+	AttributeSection section;
+	getBlock = null;
+	setBlock = null; 
+.)
+=
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	(
+		IF (IdentIsGet())
+			GetAccessorDecl&lt;out getBlock, attributes&gt;
+			[                       (. attributes = new ArrayList(); .)
+				{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+				SetAccessorDecl&lt;out setBlock, attributes&gt;
+			]
+		| IF (IdentIsSet())
+			SetAccessorDecl&lt;out setBlock, attributes&gt;
+			[                        (. attributes = new ArrayList(); .)
+				{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+				GetAccessorDecl&lt;out getBlock, attributes&gt;
+			]
+		| ident (. Error(&quot;get or set accessor declaration expected&quot;); .)
+	)
+.
+
+GetAccessorDecl&lt;out PropertyGetRegion getBlock, ArrayList attributes&gt;
+(. Statement stmt = null; .)
+=
+	ident /* &quot;get&quot; is not a keyword!? */
+	(. if (t.val != &quot;get&quot;) Error(&quot;get expected&quot;); .)
+	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes); .)
+.
+
+SetAccessorDecl&lt;out PropertySetRegion setBlock, ArrayList attributes&gt;
+(. Statement stmt = null; .)
+=
+	ident /* &quot;set&quot; is not a keyword!? */
+	(. if (t.val != &quot;set&quot;) Error(&quot;set expected&quot;); .)
+	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. setBlock = new PropertySetRegion((BlockStatement)stmt, attributes); .)
+.
+
+EventAccessorDecls&lt;out EventAddRegion addBlock, out EventRemoveRegion removeBlock&gt;
+(. AttributeSection section;
+   ArrayList attributes = new ArrayList();
+   Statement stmt;
+   addBlock = null;
+   removeBlock = null;
+.)
+=
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	(
+		IF (IdentIsAdd())            (. addBlock = new EventAddRegion(attributes); .)
+			AddAccessorDecl&lt;out stmt&gt;       (. attributes = new ArrayList(); addBlock.Block = (BlockStatement)stmt; .)
+			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .)}
+			RemoveAccessorDecl&lt;out stmt&gt;    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; .)
+		| IF (IdentIsRemove())
+			RemoveAccessorDecl &lt;out stmt&gt;    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new ArrayList(); .)
+			{ AttributeSection&lt;out section&gt;  (. attributes.Add(section); .) }
+			AddAccessorDecl&lt;out stmt&gt;        (. addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; .)
+		| ident (. Error(&quot;add or remove accessor declaration expected&quot;); .)
+	)
+.
+
+InterfaceAccessors&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
+(.
+	AttributeSection section;
+	ArrayList attributes = new ArrayList();
+	getBlock = null; setBlock = null;
+.)
+=
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	(
+		IF (IdentIsGet()) ident   (. getBlock = new PropertyGetRegion(null, attributes); .)
+		| IF (IdentIsSet()) ident (. setBlock = new PropertySetRegion(null, attributes); .)
+		| ident                   (. Error(&quot;set or get expected&quot;); .)
+	)
+	&quot;;&quot;                           (. attributes = new ArrayList(); .)
+	[
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		(
+			IF (IdentIsGet()) ident   (. if (getBlock != null) Error(&quot;get already declared&quot;);
+			                             else getBlock = new PropertyGetRegion(null, attributes);
+			                          .)
+			| IF (IdentIsSet()) ident (. if (setBlock != null) Error(&quot;set already declared&quot;);
+			                             else setBlock = new PropertySetRegion(null, attributes);
+			                          .)
+			| ident                   (. Error(&quot;set or get expected&quot;); .)
+		)
+		&quot;;&quot;
+	]
+.
+
+VariableDeclarator&lt;ArrayList fieldDeclaration&gt;
+(. Expression expr = null; .)
+=
+	ident                                 (. VariableDeclaration f = new VariableDeclaration(t.val); .)
+	[ &quot;=&quot; VariableInitializer&lt;out expr&gt;   (. f.Initializer = expr; .) ] (. fieldDeclaration.Add(f); .)
+.
+
+Block&lt;out Statement stmt&gt; /* not BlockStatement because of EmbeddedStatement */
+=
+	&quot;{&quot; (. BlockStatement blockStmt = new BlockStatement();
+	       blockStmt.StartLocation = t.Location;
+	       compilationUnit.BlockStart(blockStmt);
+	    .)
+	{ Statement }
+	&quot;}&quot; (. stmt = blockStmt;
+	       blockStmt.EndLocation = t.EndLocation;
+	       compilationUnit.BlockEnd();
+	    .)
+.
+
+AddAccessorDecl&lt;out Statement stmt&gt;
+(.stmt = null;.) 
+=
+	/* &quot;add&quot; is not a keyword!? */
+	ident (. if (t.val != &quot;add&quot;) Error(&quot;add expected&quot;); .)
+	Block&lt;out stmt&gt;
+.
+
+RemoveAccessorDecl&lt;out Statement stmt&gt;
+(.stmt = null;.) 
+=
+	/* &quot;remove&quot; is not a keyword!? */
+	ident (. if (t.val != &quot;remove&quot;) Error(&quot;remove expected&quot;); .)
+	Block&lt;out stmt&gt;
+.
+
+ConstructorInitializer&lt;out ConstructorInitializer ci&gt;
+(. Expression expr; ci = new ConstructorInitializer(); .)
+=
+	&quot;:&quot;
+	(
+		&quot;base&quot; (. ci.ConstructorInitializerType = ConstructorInitializerType.Base; .)
+		| &quot;this&quot;  (. ci.ConstructorInitializerType = ConstructorInitializerType.This; .)
+	) 
+	&quot;(&quot;
+	[ Argument&lt;out expr&gt; (. ci.Arguments.Add(expr); .) { &quot;,&quot; Argument&lt;out expr&gt; (. ci.Arguments.Add(expr); .) } ]
+	&quot;)&quot;
+.
+
+VariableInitializer&lt;out Expression initializerExpression&gt;
+(. TypeReference type = null; Expression expr = null; initializerExpression = null; .)
+=
+	Expr&lt;out initializerExpression&gt;
+	| ArrayInitializer&lt;out initializerExpression&gt;
+	| &quot;stackalloc&quot; Type&lt;out type&gt; &quot;[&quot; Expr&lt;out expr&gt; &quot;]&quot; (. initializerExpression = new StackAllocExpression(type, expr); .)
+.
+
+OverloadableOperator&lt;out Token op&gt;
+=
+	(
+		&quot;+&quot;  | &quot;-&quot;  | &quot;!&quot;    | &quot;~&quot;
+		| &quot;++&quot; | &quot;--&quot; | &quot;true&quot; | &quot;false&quot;
+		| &quot;*&quot;  | &quot;/&quot;  | &quot;%&quot;    | &quot;&amp;&quot;
+		| &quot;|&quot;  | &quot;^&quot;  | &quot;&lt;&lt;&quot;   | &quot;&gt;&gt;&quot;
+		| &quot;==&quot; | &quot;!=&quot; | &quot;&gt;&quot;    | &quot;&lt;&quot;
+		| &quot;&gt;=&quot; | &quot;&lt;=&quot;
+	) (. op = t; .)
+.
+
+Argument&lt;out Expression argumentexpr&gt;
+(.
+	Expression expr;
+	FieldDirection fd = FieldDirection.None;
+.)
+=
+	[
+		&quot;ref&quot; (. fd = FieldDirection.Ref; .)
+		| &quot;out&quot; (. fd = FieldDirection.Out; .)
+	]
+	Expr&lt;out expr&gt; (. argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; .)
+.
+
+AssignmentOperator&lt;out AssignmentOperatorType op&gt;
+(. op = AssignmentOperatorType.None; .)
+=
+	&quot;=&quot;     (. op = AssignmentOperatorType.Assign; .)
+	| &quot;+=&quot;  (. op = AssignmentOperatorType.Add; .)
+	| &quot;-=&quot;  (. op = AssignmentOperatorType.Subtract; .)
+	| &quot;*=&quot;  (. op = AssignmentOperatorType.Multiply; .)
+	| &quot;/=&quot;  (. op = AssignmentOperatorType.Divide; .)
+	| &quot;%=&quot;  (. op = AssignmentOperatorType.Modulus; .)
+	| &quot;&amp;=&quot;  (. op = AssignmentOperatorType.BitwiseAnd; .)
+	| &quot;|=&quot;  (. op = AssignmentOperatorType.BitwiseOr; .)
+	| &quot;^=&quot;  (. op = AssignmentOperatorType.ExclusiveOr; .)
+	| &quot;&lt;&lt;=&quot; (. op = AssignmentOperatorType.ShiftLeft; .)
+	| &quot;&gt;&gt;=&quot; (. op = AssignmentOperatorType.ShiftRight; .)
+.
+
+ArrayInitializer&lt;out Expression outExpr&gt;
+(.
+	Expression expr = null;
+	ArrayInitializerExpression initializer = new ArrayInitializerExpression();
+.)
+=
+	&quot;{&quot;
+	[ VariableInitializer&lt;out expr&gt; (. initializer.CreateExpressions.Add(expr); .) { IF (NotFinalComma()) &quot;,&quot; VariableInitializer&lt;out expr&gt; (. initializer.CreateExpressions.Add(expr); .) } [ &quot;,&quot; ] ]
+	&quot;}&quot; (. outExpr = initializer; .)
+.
+
+LocalVariableDecl&lt;out Statement stmt&gt;
+(.
+	TypeReference type;
+	VariableDeclaration      var = null;
+	LocalVariableDeclaration localVariableDeclaration; 
+.)
+=
+	Type&lt;out type&gt; (. localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; .)
+	LocalVariableDeclarator&lt;out var&gt; (. localVariableDeclaration.Variables.Add(var); .)
+	{ &quot;,&quot; LocalVariableDeclarator&lt;out var&gt; (. localVariableDeclaration.Variables.Add(var); .) }
+	(. stmt = localVariableDeclaration; .)
+.
+
+LocalVariableDeclarator&lt;out VariableDeclaration var&gt;
+(. Expression expr = null; .)
+=
+	ident (. var = new VariableDeclaration(t.val); .) [ &quot;=&quot; LocalVariableInitializer&lt;out expr&gt; (. var.Initializer = expr; .) ]
+.
+
+LocalVariableInitializer&lt;out Expression expr&gt;
+(. expr = null; .)
+=
+	Expr&lt;out expr&gt;
+	| ArrayInitializer&lt;out expr&gt;
+.
+
+Statement
+(.
+	TypeReference type;
+	Expression expr;
+	Statement stmt;
+.)
+=
+	/*--- labeled statement: */
+	IF (IsLabel()) ident (. compilationUnit.AddChild(new LabelStatement(t.val)); .)
+	&quot;:&quot; Statement
+	/*--- local constant declaration: */
+	| &quot;const&quot; Type&lt;out type&gt; (. LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifier.Const); string ident = null; var.StartLocation = t.Location; .) 
+	  ident (. ident = t.val; .)
+	  &quot;=&quot; Expr&lt;out expr&gt; (. var.Variables.Add(new VariableDeclaration(ident, expr)); .)
+	  { &quot;,&quot; ident (. ident = t.val; .) &quot;=&quot; Expr&lt;out expr&gt; (. var.Variables.Add(new VariableDeclaration(ident, expr)); .) }
+	  &quot;;&quot; (. compilationUnit.AddChild(var); .)
+	/*--- local variable declaration: */
+	| IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt; &quot;;&quot; (. compilationUnit.AddChild(stmt); .)
+	| EmbeddedStatement&lt;out stmt&gt; (. compilationUnit.AddChild(stmt); .)
+	/* LL(1) confict: LocalVariableDecl *
+	 *            &lt;-&gt; StatementExpr     *
+	 * ident {&quot;.&quot; ident} { &quot;[&quot; Expr ... */
+.
+
+EmbeddedStatement&lt;out Statement statement&gt;
+(.
+	TypeReference type = null;
+	Expression expr = null;
+	Statement embeddedStatement = null;
+	statement = null;
+.)
+=
+	Block&lt;out statement&gt;
+	/*--- empty statement: */
+	| &quot;;&quot;                       (. statement = new EmptyStatement(); .)
+	/*--- checked / unchecked statement: */
+	| IF (UnCheckedAndLBrace()) (. Statement block; bool isChecked = true; .)
+	(&quot;checked&quot; | &quot;unchecked&quot;    (. isChecked = false;.) )
+	Block&lt;out block&gt;            (. statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); .)
+	/*--- expression statement: */
+	| StatementExpr&lt;out statement&gt; &quot;;&quot;
+	/*--- selection statements (if, switch): */
+	| &quot;if&quot;                      (. Statement elseStatement = null; .)
+	&quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt;
+	[ &quot;else&quot; EmbeddedStatement&lt;out elseStatement&gt; ]
+	                            (. statement = elseStatement != null ? (Statement)new IfElseStatement(expr, embeddedStatement, elseStatement) :  (Statement)new IfStatement(expr, embeddedStatement); .)
+	| &quot;switch&quot; (. ArrayList switchSections = new ArrayList(); .)
+	  &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	  &quot;{&quot; { SwitchSection&lt;out statement&gt; (. switchSections.Add(statement); .) } 
+	  &quot;}&quot;  (. statement = new SwitchStatement(expr, switchSections); .)
+	/*--- iteration statements (while, do, for, foreach): */
+	| &quot;while&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new WhileStatement(expr, embeddedStatement); .)
+	| &quot;do&quot; EmbeddedStatement&lt;out embeddedStatement&gt; &quot;while&quot;
+	&quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; &quot;;&quot;  (. statement = new DoWhileStatement(expr, embeddedStatement); .)
+	| &quot;for&quot; (. ArrayList initializer = null, iterator = null; .)
+	  &quot;(&quot; [ ForInitializer&lt;out initializer&gt; ] &quot;;&quot;
+	  [ Expr&lt;out expr&gt; ] &quot;;&quot;
+	  [ ForIterator&lt;out iterator&gt; ] &quot;)&quot;
+	  EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new ForStatement(initializer, expr, iterator, embeddedStatement); .)
+	| &quot;foreach&quot; &quot;(&quot; Type&lt;out type&gt; ident     (. string varName = t.val; .)
+	&quot;in&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt; (.  statement = new ForeachStatement(type, varName , expr, embeddedStatement); 
+	                                             statement.EndLocation = t.EndLocation;
+	                                         .)
+	/*--- jump statements (break, contine, goto, return, throw): */
+	| &quot;break&quot; &quot;;&quot;               (. statement = new BreakStatement(); .)
+	| &quot;continue&quot; &quot;;&quot;            (. statement = new ContinueStatement(); .)
+	| GotoStatement&lt;out statement&gt;
+	| &quot;return&quot; [ Expr&lt;out expr&gt; ] &quot;;&quot;    (. statement = new ReturnStatement(expr); .)
+	| &quot;throw&quot; [ Expr&lt;out expr&gt; ] &quot;;&quot;     (. statement = new ThrowStatement(expr); .)
+	/*--- try statement: */
+	| TryStatement&lt;out statement&gt;
+	/*--- lock satement: */
+	| &quot;lock&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new LockStatement(expr, embeddedStatement); .)
+	/*--- using statement: */
+	| (.Statement resourceAcquisitionStmt = null; .)
+	&quot;using&quot; &quot;(&quot;
+	ResourceAcquisition&lt;out resourceAcquisitionStmt&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); .)
+	/*--- unsafe statement: */
+	| &quot;unsafe&quot; Block&lt;out embeddedStatement&gt;  (. statement = new UnsafeStatement(embeddedStatement); .)
+	/*--- fixed statement: */
+	| &quot;fixed&quot;
+	&quot;(&quot; Type&lt;out type&gt;     (. if (type.PointerNestingLevel == 0) Error(&quot;can only fix pointer types&quot;);
+	                          FixedStatement fxStmt = new FixedStatement(type);
+	                          string identifier = null;
+	                       .)
+	ident                  (. identifier = t.val; .)
+	&quot;=&quot; Expr&lt;out expr&gt;     (. fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
+	{
+		&quot;,&quot; ident          (. identifier = t.val; .)
+		&quot;=&quot; Expr&lt;out expr&gt; (. fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
+	}
+	&quot;)&quot; EmbeddedStatement&lt;out embeddedStatement&gt;  (. fxStmt.EmbeddedStatement = embeddedStatement; statement = fxStmt;.)
+.
+
+ForInitializer&lt;out ArrayList initializer&gt;
+(.
+	Statement stmt; 
+	initializer = new ArrayList();
+.)
+=
+	IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt; (. initializer.Add(stmt);.)
+	| StatementExpr&lt;out stmt&gt; (.initializer.Add(stmt);.) { &quot;,&quot; StatementExpr&lt;out stmt&gt; (. initializer.Add(stmt);.) } (. initializer.Add(stmt);.)
+.
+
+ForIterator&lt;out ArrayList iterator&gt;
+(.
+	Statement stmt; 
+	iterator = new ArrayList();
+.)
+=
+	StatementExpr&lt;out stmt&gt; (. iterator.Add(stmt);.) { &quot;,&quot; StatementExpr&lt;out stmt&gt; (. iterator.Add(stmt); .) }
+.
+
+SwitchSection&lt;out Statement stmt&gt;
+(.
+	SwitchSection switchSection = new SwitchSection();
+	Expression expr;
+.)
+=
+	SwitchLabel&lt;out expr&gt; (. switchSection.SwitchLabels.Add(expr); .) { SwitchLabel&lt;out expr&gt; (. switchSection.SwitchLabels.Add(expr); .) } 
+	(. compilationUnit.BlockStart(switchSection); .)
+	Statement { Statement }
+	(.
+		compilationUnit.BlockEnd();
+		stmt = switchSection;
+	.)
+.
+
+SwitchLabel&lt;out Expression expr&gt;
+ (. expr = null; .)
+=
+	&quot;case&quot; Expr&lt;out expr&gt; &quot;:&quot; 
+	| &quot;default&quot; &quot;:&quot;
+.
+
+TryStatement&lt;out Statement tryStatement&gt;
+(.
+	Statement blockStmt = null, finallyStmt = null;
+	ArrayList catchClauses = null;
+.)
+=
+	&quot;try&quot;  Block&lt;out blockStmt&gt;
+	(
+		CatchClauses&lt;out catchClauses&gt; [ &quot;finally&quot; Block&lt;out finallyStmt&gt; ]
+		| &quot;finally&quot; Block&lt;out finallyStmt&gt;
+	)
+	(.
+		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
+	
+	.)
+.
+
+CatchClauses&lt;out ArrayList catchClauses&gt;
+(.
+	catchClauses = new ArrayList();
+.)
+=
+	&quot;catch&quot; (. string name;
+	           string identifier;
+	           Statement stmt; 
+	        .)
+	/*--- general catch clause (as only catch clause) */
+	(
+		Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(stmt)); .)
+		/*--- specific catch clause */
+		| &quot;(&quot; ClassType&lt;out name&gt; (. identifier = null; .) [ ident (. identifier = t.val; .) ] &quot;)&quot; Block&lt;out stmt&gt;  (. catchClauses.Add(new CatchClause(name, identifier, stmt)); .)
+		{ IF (IsTypedCatch()) &quot;catch&quot; &quot;(&quot; ClassType&lt;out name&gt; (. identifier = null; .) [ ident (. identifier = t.val; .) ] &quot;)&quot; Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(name, identifier, stmt)); .) }
+		/*--- general catch clause (after specific catch clauses, optional) */
+		[ &quot;catch&quot; Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(stmt)); .) ]
+	)
+.
+
+GotoStatement&lt;out Statement stmt&gt;
+(. Expression expr; stmt = null; .)
+=
+	&quot;goto&quot;
+	(
+		ident (. stmt = new GotoStatement(t.val); .) &quot;;&quot;
+		| &quot;case&quot; Expr&lt;out expr&gt;  &quot;;&quot; (. stmt = new GotoCaseStatement(expr); .)
+		| &quot;default&quot; &quot;;&quot; (. stmt = new GotoCaseStatement(null); .)
+	)
+.
+
+ResourceAcquisition&lt;out Statement stmt&gt;
+(.
+	stmt = null;
+	Expression expr;
+.)
+=
+	(
+		IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt;
+		| Expr&lt;out expr&gt; /* LL(1) conflict resoltion:                             *
+		                  * check if next is Qualident followed by ident          *
+		                  * ==&gt; LocalVariableDecl                                 *
+		                  * new problem: first set of ResourceAcquisition changes */
+		(. stmt = new StatementExpression(expr); .)
+	)
+.
+
+StatementExpr&lt;out Statement stmt&gt;
+=
+	/* We don't know why, but it's in the grammar. */
+	/* (see internal document: assignment.txt) */
+	(.
+		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
+		                        la.kind == Tokens.Not   || la.kind == Tokens.BitwiseComplement ||
+		                        la.kind == Tokens.Times || la.kind == Tokens.BitwiseAnd   || IsTypeCast();
+		Expression expr = null;
+	.)
+	
+	UnaryExpr&lt;out expr&gt;
+	/*--- assignment */
+	(
+		(. AssignmentOperatorType op; Expression val; .) AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
+		| (. if (mustBeAssignment) Error(&quot;error in assignment.&quot;); .)
+	) (. stmt = new StatementExpression(expr); .)
+.
+
+Expr&lt;out Expression expr&gt;
+(. expr = null; Expression expr1 = null, expr2 = null; .)
+=
+	UnaryExpr&lt;out expr&gt;
+	/*--- conditional expression: */
+	(
+		ConditionalOrExpr&lt;ref expr&gt; [ &quot;?&quot; Expr&lt;out expr1&gt; &quot;:&quot; Expr&lt;out expr2&gt; (. expr = new ConditionalExpression(expr, expr1, expr2);  .) ] 
+		/*--- assignment: */
+		| (. AssignmentOperatorType op; Expression val; .) AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
+	)
+.
+
+
+UnaryExpr&lt;out Expression uExpr&gt;
+(.
+	TypeReference type = null;
+	Expression expr;
+	ArrayList  expressions = new ArrayList();
+	uExpr = null;
+.)
+=
+	{
+		  &quot;+&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); .)
+		| &quot;-&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); .)
+		| &quot;!&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); .)
+		| &quot;~&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); .)
+		| &quot;*&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); .)
+		| &quot;++&quot; (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); .)
+		| &quot;--&quot; (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); .)
+		| &quot;&amp;&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); .)
+		
+		/*--- cast expression: */
+		/* Problem:  &quot;(&quot; Type &quot;)&quot; from here and                     *
+		 *           &quot;(&quot; Expr &quot;)&quot; from PrimaryExpr                  *
+		 *           are not distinguishable                        *
+		 * Solution: (in IsTypeCast())                              *
+		 * use external information from compiled assembly or guess */
+		| IF (IsTypeCast()) &quot;(&quot; Type&lt;out type&gt; &quot;)&quot;  (.  expressions.Add(new CastExpression(type)); .)
+	}
+	
+	PrimaryExpr&lt;out expr&gt; (. for (int i = 0; i &lt; expressions.Count; ++i) {
+	                         	Expression nextExpression = i + 1 &lt; expressions.Count ? (Expression)expressions[i + 1] : expr;
+	                         	if (expressions[i] is CastExpression) {
+	                         		((CastExpression)expressions[i]).Expression = nextExpression;
+	                         	} else {
+	                         		((UnaryOperatorExpression)expressions[i]).Expression = nextExpression;
+	                         	}
+	                         }
+	                         if (expressions.Count &gt; 0) {
+	                         	uExpr = (Expression)expressions[0];
+	                         } else {
+	                         	uExpr = expr;
+	                         }
+	                      .)
+.
+
+
+PrimaryExpr&lt;out Expression pexpr&gt;
+(.
+	TypeReference type = null;
+	bool isArrayCreation = false;
+	Expression expr;
+	pexpr = null;
+.)
+=
+	(
+		&quot;true&quot;                              (.pexpr = new PrimitiveExpression(true, &quot;true&quot;);  .)
+		| &quot;false&quot;                           (.pexpr = new PrimitiveExpression(false, &quot;false&quot;); .)
+		| &quot;null&quot;                            (.pexpr = new PrimitiveExpression(null, &quot;null&quot;);  .)          /* from literal token */
+		| literal                           (.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+		/*--- simple name: */
+		| ident (. pexpr = new IdentifierExpression(t.val); .)
+		/*--- parenthesized expression: */
+		| &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new ParenthesizedExpression(expr); .)
+		| /*--- predefined type member access: */
+		(
+			&quot;bool&quot;   | &quot;byte&quot;   | &quot;char&quot; | &quot;decimal&quot; | &quot;double&quot;
+			| &quot;float&quot;  | &quot;int&quot;    | &quot;long&quot; | &quot;object&quot;  | &quot;sbyte&quot;
+			| &quot;short&quot;  | &quot;string&quot; | &quot;uint&quot; | &quot;ulong&quot;   | &quot;ushort&quot;
+		) (. string val = t.val; t.val = &quot;&quot;; .) &quot;.&quot; ident (. pexpr = new FieldReferenceExpression(new TypeReferenceExpression(val), t.val); .)
+		/*--- this access: */
+		| &quot;this&quot;                              (. pexpr = new ThisReferenceExpression(); .)
+		/*--- base access: */
+		| &quot;base&quot;                              (. Expression retExpr = new BaseReferenceExpression(); .)
+		(
+			&quot;.&quot; ident                         (. retExpr = new FieldReferenceExpression(retExpr, t.val); .)
+			| &quot;[&quot; Expr&lt;out expr&gt;              (.ArrayList indices = new ArrayList(); indices.Add(expr); .)
+			{ &quot;,&quot; Expr&lt;out expr&gt;              (. indices.Add(expr); .) }
+			&quot;]&quot;                               (. retExpr = new IndexerExpression(retExpr, indices); .)
+		)                                     (. pexpr = retExpr; .)
+		| &quot;new&quot; NonArrayType&lt;out type&gt;                (. ArrayList parameters = new ArrayList(); .)
+		/*--- delegate / object creation expression: */
+		/* Note: a delegate creation expression allow only a single Expr  *
+		 *       not an argument list, but this is not distinguished here */
+		(
+			&quot;(&quot; (. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .) [ Argument&lt;out expr&gt;          (. parameters.Add(expr); .)
+			{ &quot;,&quot; Argument&lt;out expr&gt;          (. parameters.Add(expr); .) } ] &quot;)&quot; (. pexpr = oce; .)
+			/*--- array creation expression: */
+			| (. isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type); pexpr = ace; .)
+			&quot;[&quot; (. int dims = 0; ArrayList rank = new ArrayList(); ArrayList parameterExpression = new ArrayList(); .)
+			(
+				Expr&lt;out expr&gt; (. parameterExpression.Add(expr); .) { &quot;,&quot; Expr&lt;out expr&gt; (. parameterExpression.Add(expr); .) } &quot;]&quot; (. parameters.Add(new ArrayCreationParameter(parameterExpression)); ace.Parameters = parameters; .)
+				{ IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.rank.Add(dims); parameters.Add(new ArrayCreationParameter(dims)); .) &quot;]&quot; } 
+				(. if (rank.Count &gt; 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } .)
+				[ ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; .) ]
+				
+				| { &quot;,&quot; (.dims++;.) } (.parameters.Add(new ArrayCreationParameter(dims)); .)  &quot;]&quot; { IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.parameters.Add(new ArrayCreationParameter(dims)); .) &quot;]&quot; } ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; ace.Parameters = parameters; .)
+			)
+/*			| ArrayInitializer&lt;out expr&gt; (. if (!type.IsArrayType) { Error(&quot;() or [] expected&quot;); }  pexpr =  new ArrayCreateExpression(type, (ArrayInitializerExpression)expr); .)*/
+		)
+		| &quot;typeof&quot; &quot;(&quot;
+		(
+			IF (NotVoidPointer()) &quot;void&quot; (. type = new TypeReference(&quot;void&quot;); .)
+			| Type&lt;out type&gt;
+		) &quot;)&quot;                            (. pexpr = new TypeOfExpression(type); .)
+		| &quot;sizeof&quot; &quot;(&quot; Type&lt;out type&gt; &quot;)&quot; (. pexpr = new SizeOfExpression(type); .)
+		| &quot;checked&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new CheckedExpression(expr); .)
+		| &quot;unchecked&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new CheckedExpression(expr); .)
+	)
+	{
+		(
+			&quot;++&quot;   (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); .)
+			| &quot;--&quot; (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); .)
+		)
+		/*--- member access */
+		| &quot;-&gt;&quot; ident (. pexpr = new PointerReferenceExpression(pexpr, t.val); .)
+		| &quot;.&quot; ident (. pexpr = new FieldReferenceExpression(pexpr, t.val);.)
+		/*--- invocation expression: */
+		| &quot;(&quot;                        (. ArrayList parameters = new ArrayList(); .)
+			[ Argument&lt;out expr&gt;     (. parameters.Add(expr); .)
+			{ &quot;,&quot; Argument&lt;out expr&gt; (. parameters.Add(expr); .)
+			} ] &quot;)&quot;                  (. pexpr = new InvocationExpression(pexpr, parameters); .)
+		/*--- element access */
+		|  (. if (isArrayCreation) Error(&quot;element access not allow on array creation&quot;);
+		      ArrayList indices = new ArrayList();
+		   .)
+		&quot;[&quot; Expr&lt;out expr&gt; (.indices.Add(expr); .)
+		{ &quot;,&quot; Expr&lt;out expr&gt; (. indices.Add(expr); .)
+		} &quot;]&quot; (. pexpr = new IndexerExpression(pexpr, indices); .)
+	}
+.
+
+ConditionalOrExpr&lt;ref Expression outExpr&gt;
+(. Expression expr;   .)
+=
+	ConditionalAndExpr&lt;ref outExpr&gt;  { &quot;||&quot; UnaryExpr&lt;out expr&gt; ConditionalAndExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  .) }
+.
+
+ConditionalAndExpr&lt;ref Expression outExpr&gt;
+(. Expression expr; .)
+=
+	InclusiveOrExpr&lt;ref outExpr&gt;  { &quot;&amp;&amp;&quot; UnaryExpr&lt;out expr&gt; InclusiveOrExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  .) }
+.
+
+InclusiveOrExpr&lt;ref Expression outExpr&gt;
+(. Expression expr; .)
+=
+	ExclusiveOrExpr&lt;ref outExpr&gt;  { &quot;|&quot; UnaryExpr&lt;out expr&gt; ExclusiveOrExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  .) }
+.
+
+ExclusiveOrExpr&lt;ref Expression outExpr&gt;
+(. Expression expr; .)
+=
+	AndExpr&lt;ref outExpr&gt;  { &quot;^&quot; UnaryExpr&lt;out expr&gt; AndExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  .) }
+.
+
+AndExpr&lt;ref Expression outExpr&gt;
+(. Expression expr; .)
+=
+	EqualityExpr&lt;ref outExpr&gt; { &quot;&amp;&quot; UnaryExpr&lt;out expr&gt; EqualityExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  .) }
+.
+
+EqualityExpr&lt;ref Expression outExpr&gt;
+(.
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	RelationalExpr&lt;ref outExpr&gt;
+	{
+		(
+			&quot;!=&quot;   (. op = BinaryOperatorType.InEquality; .)
+			| &quot;==&quot; (. op = BinaryOperatorType.Equality; .)
+		)
+		UnaryExpr&lt;out expr&gt; RelationalExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
+	}
+.
+
+RelationalExpr&lt;ref Expression outExpr&gt;
+(.
+	TypeReference type;
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	ShiftExpr&lt;ref outExpr&gt;
+	{
+		(
+			&quot;&lt;&quot;    (. op = BinaryOperatorType.LessThan; .)
+			| &quot;&gt;&quot;  (. op = BinaryOperatorType.GreaterThan; .)
+			| &quot;&lt;=&quot; (. op = BinaryOperatorType.LessThanOrEqual; .)
+			| &quot;&gt;=&quot; (. op = BinaryOperatorType.GreaterThanOrEqual; .)
+		)
+		UnaryExpr&lt;out expr&gt; ShiftExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
+		|
+		(
+			&quot;is&quot; (. op = BinaryOperatorType.IS; .)
+			| &quot;as&quot; (. op = BinaryOperatorType.AS; .)
+		)
+		Type&lt;out type&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, new TypeReferenceExpression(type)); .)
+	}
+.
+
+ShiftExpr&lt;ref Expression outExpr&gt;
+(.
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	AdditiveExpr&lt;ref outExpr&gt; 
+	{
+		(
+			&quot;&lt;&lt;&quot;   (. op = BinaryOperatorType.ShiftLeft; .)
+			| &quot;&gt;&gt;&quot; (. op = BinaryOperatorType.ShiftRight; .)
+		)
+		UnaryExpr&lt;out expr&gt; AdditiveExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
+	}
+.
+
+AdditiveExpr&lt;ref Expression outExpr&gt;
+(.
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	MultiplicativeExpr&lt;ref outExpr&gt;
+	{
+		(
+			&quot;+&quot;   (. op = BinaryOperatorType.Add; .)
+			| &quot;-&quot; (. op = BinaryOperatorType.Subtract; .)
+		)
+		UnaryExpr&lt;out expr&gt; MultiplicativeExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
+	}
+.
+
+MultiplicativeExpr&lt;ref Expression outExpr&gt;
+(.
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	{
+		(
+			&quot;*&quot;   (. op = BinaryOperatorType.Multiply; .)
+			| &quot;/&quot; (. op = BinaryOperatorType.Divide; .)
+			| &quot;%&quot; (. op = BinaryOperatorType.Modulus; .)
+		) 
+		UnaryExpr&lt;out expr&gt; (. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .) 
+	}
+.
+	
+END CS.


Property changes on: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG
___________________________________________________________________
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001992.html">[Monodevelop-patches-list] r2390 - in trunk/MonoDevelop/Core/src: AddIns/BackendBindings/CSharpBinding ICSharpCode.SharpRefactory ICSharpCode.SharpRefactory/src/Lexer
</A></li>
	<LI>Next message: <A HREF="001994.html">[Monodevelop-patches-list] r2392 - trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1993">[ date ]</a>
              <a href="thread.html#1993">[ thread ]</a>
              <a href="subject.html#1993">[ subject ]</a>
              <a href="author.html#1993">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
