<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2403 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Parser/AST/Statements src/Parser/generated
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2403%20-%20in%20trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory%3A%20.%20src/Parser/AST/Statements%20src/Parser/generated&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002004.html">
   <LINK REL="Next"  HREF="002006.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2403 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Parser/AST/Statements src/Parser/generated</H1>
    <B>John Luke &lt;jluke@cfl.rr.com&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2403%20-%20in%20trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory%3A%20.%20src/Parser/AST/Statements%20src/Parser/generated&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2403 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Parser/AST/Statements src/Parser/generated">jluke at mono-cvs.ximian.com
       </A><BR>
    <I>Wed Mar 30 19:23:03 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002004.html">[Monodevelop-patches-list] r2402 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Parser/AST/TypeLevel src/Parser/generated src/PrettyPrinter
</A></li>
        <LI>Next message: <A HREF="002006.html">[Monodevelop-patches-list] r2404 - trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2005">[ date ]</a>
              <a href="thread.html#2005">[ thread ]</a>
              <a href="subject.html#2005">[ subject ]</a>
              <a href="author.html#2005">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2005-03-30 19:23:02 -0500 (Wed, 30 Mar 2005)
New Revision: 2403

Added:
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/AST/Statements/YieldStatement.cs
Modified:
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/ChangeLog
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/Makefile.am
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/Parser.cs
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG
Log:
allow yield return and yield break;


Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/ChangeLog	2005-03-30 23:08:24 UTC (rev 2402)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/ChangeLog	2005-03-31 00:23:02 UTC (rev 2403)
@@ -1,5 +1,12 @@
 2005-03-30  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
 
+	* src/Parser/AST/Statements/YieldStatement.cs:
+	* src/Parser/generated/cs.ATG
+	* src/Parser/generated/Parser.cs
+	* Makefile.am: allow yield return and yield break;
+
+2005-03-30  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
+
 	* src/PrettyPrinter/PrettyPrintVisitor.cs:
 	* src/Parser/AST/TypeLevel/PropertyGetRegion.cs:
 	* src/Parser/AST/TypeLevel/PropertySetRegion.cs:

Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/Makefile.am	2005-03-30 23:08:24 UTC (rev 2402)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/Makefile.am	2005-03-31 00:23:02 UTC (rev 2403)
@@ -72,6 +72,7 @@
 src/Parser/AST/Statements/WhileStatement.cs \
 src/Parser/AST/Statements/UsingStatement.cs \
 src/Parser/AST/Statements/DoWhileStatement.cs \
+src/Parser/AST/Statements/YieldStatement.cs \
 src/Parser/AST/GlobalScope/UsingAliasDeclaration.cs \
 src/Parser/AST/GlobalScope/UsingDeclaration.cs \
 src/Parser/AST/GlobalScope/NamespaceDeclaration.cs \

Added: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/AST/Statements/YieldStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/AST/Statements/YieldStatement.cs	2005-03-30 23:08:24 UTC (rev 2402)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/AST/Statements/YieldStatement.cs	2005-03-31 00:23:02 UTC (rev 2403)
@@ -0,0 +1,31 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class YieldStatement : Statement
+	{
+		Expression yieldExpression;
+		
+		public Expression YieldExpression {
+			get { return yieldExpression; }
+			set { yieldExpression = value; }
+		}
+		
+		public YieldStatement (Expression yieldExpression)
+		{
+			this.yieldExpression = yieldExpression;
+		}
+		
+		public override object AcceptVisitor (IASTVisitor visitor, object data)
+		{
+			return visitor.Visit (this, data);
+		}
+		
+		public override string ToString ()
+		{
+			return String.Format (&quot;[YieldStatement: YieldExpression={0}]&quot;, yieldExpression);
+		}
+	}
+}
+

Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/Parser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/Parser.cs	2005-03-30 23:08:24 UTC (rev 2402)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/Parser.cs	2005-03-31 00:23:02 UTC (rev 2403)
@@ -348,6 +348,16 @@
 	       pt.kind == Tokens.Identifier;
 }
 
+/* True, if lookahead ident is &quot;partial&quot; */
+bool IdentIsPartial () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;partial&quot;;
+}
+
+/* True, if lookahead ident is &quot;yield&quot; */
+bool IdentIsYield () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;yield&quot;;
+}
+
 /* True, if lookahead ident is &quot;get&quot; */
 bool IdentIsGet () {
 	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;get&quot;;
@@ -456,13 +466,13 @@
 	
 	void CS() {
 
-#line  516 &quot;cs.ATG&quot; 
+#line  526 &quot;cs.ATG&quot; 
 		compilationUnit = new CompilationUnit(); 
 		while (la.kind == 120) {
 			UsingDirective();
 		}
 		while (
-#line  519 &quot;cs.ATG&quot; 
+#line  529 &quot;cs.ATG&quot; 
 IsGlobalAttrTarget()) {
 			GlobalAttributeSection();
 		}
@@ -474,30 +484,30 @@
 
 	void UsingDirective() {
 
-#line  526 &quot;cs.ATG&quot; 
+#line  536 &quot;cs.ATG&quot; 
 		usingNamespaces = new ArrayList();
 		string qualident = null, aliasident = null;
 		
 		Expect(120);
 
-#line  530 &quot;cs.ATG&quot; 
+#line  540 &quot;cs.ATG&quot; 
 		Point startPos = t.Location;
 		INode node     = null; 
 		
 		if (
-#line  533 &quot;cs.ATG&quot; 
+#line  543 &quot;cs.ATG&quot; 
 IsAssignment()) {
 			lexer.NextToken();
 
-#line  533 &quot;cs.ATG&quot; 
+#line  543 &quot;cs.ATG&quot; 
 			aliasident = t.val; 
 			Expect(3);
 		}
 		Qualident(
-#line  534 &quot;cs.ATG&quot; 
+#line  544 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  534 &quot;cs.ATG&quot; 
+#line  544 &quot;cs.ATG&quot; 
 		if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
 		 if (aliasident != null) {
 		   node = new UsingAliasDeclaration(aliasident, qualident);
@@ -509,7 +519,7 @@
 		
 		Expect(10);
 
-#line  543 &quot;cs.ATG&quot; 
+#line  553 &quot;cs.ATG&quot; 
 		node.StartLocation = startPos;
 		node.EndLocation   = t.EndLocation;
 		compilationUnit.AddChild(node);
@@ -519,11 +529,11 @@
 	void GlobalAttributeSection() {
 		Expect(16);
 
-#line  552 &quot;cs.ATG&quot; 
+#line  562 &quot;cs.ATG&quot; 
 		Point startPos = t.Location; 
 		Expect(1);
 
-#line  552 &quot;cs.ATG&quot; 
+#line  562 &quot;cs.ATG&quot; 
 		if (t.val != &quot;assembly&quot;) Error(&quot;global attribute target specifier (\&quot;assembly\&quot;) expected&quot;);
 		string attributeTarget = t.val;
 		ArrayList attributes = new ArrayList();
@@ -531,20 +541,20 @@
 		
 		Expect(9);
 		Attribute(
-#line  557 &quot;cs.ATG&quot; 
+#line  567 &quot;cs.ATG&quot; 
 out attribute);
 
-#line  557 &quot;cs.ATG&quot; 
+#line  567 &quot;cs.ATG&quot; 
 		attributes.Add(attribute); 
 		while (
-#line  558 &quot;cs.ATG&quot; 
+#line  568 &quot;cs.ATG&quot; 
 NotFinalComma()) {
 			Expect(12);
 			Attribute(
-#line  558 &quot;cs.ATG&quot; 
+#line  568 &quot;cs.ATG&quot; 
 out attribute);
 
-#line  558 &quot;cs.ATG&quot; 
+#line  568 &quot;cs.ATG&quot; 
 			attributes.Add(attribute); 
 		}
 		if (la.kind == 12) {
@@ -552,7 +562,7 @@
 		}
 		Expect(17);
 
-#line  560 &quot;cs.ATG&quot; 
+#line  570 &quot;cs.ATG&quot; 
 		AttributeSection section = new AttributeSection(attributeTarget, attributes);
 		section.StartLocation = startPos;
 		section.EndLocation = t.EndLocation;
@@ -562,7 +572,7 @@
 
 	void NamespaceMemberDecl() {
 
-#line  642 &quot;cs.ATG&quot; 
+#line  652 &quot;cs.ATG&quot; 
 		AttributeSection section;
 		ArrayList attributes = new ArrayList();
 		Modifiers m = new Modifiers(this);
@@ -571,13 +581,13 @@
 		if (la.kind == 87) {
 			lexer.NextToken();
 
-#line  648 &quot;cs.ATG&quot; 
+#line  658 &quot;cs.ATG&quot; 
 			Point startPos = t.Location; 
 			Qualident(
-#line  649 &quot;cs.ATG&quot; 
+#line  659 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  649 &quot;cs.ATG&quot; 
+#line  659 &quot;cs.ATG&quot; 
 			INode node =  new NamespaceDeclaration(qualident);
 			node.StartLocation = startPos;
 			compilationUnit.AddChild(node);
@@ -595,83 +605,83 @@
 				lexer.NextToken();
 			}
 
-#line  658 &quot;cs.ATG&quot; 
+#line  668 &quot;cs.ATG&quot; 
 			node.EndLocation   = t.EndLocation;
 			compilationUnit.BlockEnd();
 			
 		} else if (StartOf(2)) {
 			while (la.kind == 16) {
 				AttributeSection(
-#line  662 &quot;cs.ATG&quot; 
+#line  672 &quot;cs.ATG&quot; 
 out section);
 
-#line  662 &quot;cs.ATG&quot; 
+#line  672 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			while (StartOf(3)) {
 				TypeModifier(
-#line  663 &quot;cs.ATG&quot; 
+#line  673 &quot;cs.ATG&quot; 
 m);
 			}
 			TypeDecl(
-#line  664 &quot;cs.ATG&quot; 
+#line  674 &quot;cs.ATG&quot; 
 m, attributes);
 		} else SynErr(126);
 	}
 
 	void Qualident(
-#line  749 &quot;cs.ATG&quot; 
+#line  769 &quot;cs.ATG&quot; 
 out string qualident) {
 		Expect(1);
 
-#line  751 &quot;cs.ATG&quot; 
+#line  771 &quot;cs.ATG&quot; 
 		StringBuilder qualidentBuilder = new StringBuilder(t.val); 
 		while (
-#line  752 &quot;cs.ATG&quot; 
+#line  772 &quot;cs.ATG&quot; 
 DotAndIdent()) {
 			Expect(13);
 			Expect(1);
 
-#line  752 &quot;cs.ATG&quot; 
+#line  772 &quot;cs.ATG&quot; 
 			qualidentBuilder.Append('.');
 			qualidentBuilder.Append(t.val); 
 			
 		}
 
-#line  755 &quot;cs.ATG&quot; 
+#line  775 &quot;cs.ATG&quot; 
 		qualident = qualidentBuilder.ToString(); 
 	}
 
 	void Attribute(
-#line  567 &quot;cs.ATG&quot; 
+#line  577 &quot;cs.ATG&quot; 
 out ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute) {
 
-#line  568 &quot;cs.ATG&quot; 
+#line  578 &quot;cs.ATG&quot; 
 		string qualident; 
 		Qualident(
-#line  570 &quot;cs.ATG&quot; 
+#line  580 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  570 &quot;cs.ATG&quot; 
+#line  580 &quot;cs.ATG&quot; 
 		ArrayList positional = new ArrayList();
 		ArrayList named      = new ArrayList();
 		string name = qualident;
 		
 		if (la.kind == 18) {
 			AttributeArguments(
-#line  574 &quot;cs.ATG&quot; 
+#line  584 &quot;cs.ATG&quot; 
 ref positional, ref named);
 		}
 
-#line  574 &quot;cs.ATG&quot; 
+#line  584 &quot;cs.ATG&quot; 
 		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.Attribute(name, positional, named);
 	}
 
 	void AttributeArguments(
-#line  577 &quot;cs.ATG&quot; 
+#line  587 &quot;cs.ATG&quot; 
 ref ArrayList positional, ref ArrayList named) {
 
-#line  579 &quot;cs.ATG&quot; 
+#line  589 &quot;cs.ATG&quot; 
 		bool nameFound = false;
 		string name = &quot;&quot;;
 		Expression expr;
@@ -679,48 +689,48 @@
 		Expect(18);
 		if (StartOf(4)) {
 			if (
-#line  587 &quot;cs.ATG&quot; 
+#line  597 &quot;cs.ATG&quot; 
 IsAssignment()) {
 
-#line  587 &quot;cs.ATG&quot; 
+#line  597 &quot;cs.ATG&quot; 
 				nameFound = true; 
 				lexer.NextToken();
 
-#line  588 &quot;cs.ATG&quot; 
+#line  598 &quot;cs.ATG&quot; 
 				name = t.val; 
 				Expect(3);
 			}
 			Expr(
-#line  590 &quot;cs.ATG&quot; 
+#line  600 &quot;cs.ATG&quot; 
 out expr);
 
-#line  590 &quot;cs.ATG&quot; 
+#line  600 &quot;cs.ATG&quot; 
 			if(name == &quot;&quot;) positional.Add(expr);
 			else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
 			
 			while (la.kind == 12) {
 				lexer.NextToken();
 				if (
-#line  597 &quot;cs.ATG&quot; 
+#line  607 &quot;cs.ATG&quot; 
 IsAssignment()) {
 
-#line  597 &quot;cs.ATG&quot; 
+#line  607 &quot;cs.ATG&quot; 
 					nameFound = true; 
 					Expect(1);
 
-#line  598 &quot;cs.ATG&quot; 
+#line  608 &quot;cs.ATG&quot; 
 					name = t.val; 
 					Expect(3);
 				} else if (StartOf(4)) {
 
-#line  600 &quot;cs.ATG&quot; 
+#line  610 &quot;cs.ATG&quot; 
 					if (nameFound) Error(&quot;no positional argument after named argument&quot;); 
 				} else SynErr(127);
 				Expr(
-#line  601 &quot;cs.ATG&quot; 
+#line  611 &quot;cs.ATG&quot; 
 out expr);
 
-#line  601 &quot;cs.ATG&quot; 
+#line  611 &quot;cs.ATG&quot; 
 				if(name == &quot;&quot;) positional.Add(expr);
 				else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
 				
@@ -730,52 +740,52 @@
 	}
 
 	void Expr(
-#line  1727 &quot;cs.ATG&quot; 
+#line  1751 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1728 &quot;cs.ATG&quot; 
+#line  1752 &quot;cs.ATG&quot; 
 		expr = null; Expression expr1 = null, expr2 = null; 
 		UnaryExpr(
-#line  1730 &quot;cs.ATG&quot; 
+#line  1754 &quot;cs.ATG&quot; 
 out expr);
 		if (StartOf(5)) {
 			ConditionalOrExpr(
-#line  1733 &quot;cs.ATG&quot; 
+#line  1757 &quot;cs.ATG&quot; 
 ref expr);
 			if (la.kind == 11) {
 				lexer.NextToken();
 				Expr(
-#line  1733 &quot;cs.ATG&quot; 
+#line  1757 &quot;cs.ATG&quot; 
 out expr1);
 				Expect(9);
 				Expr(
-#line  1733 &quot;cs.ATG&quot; 
+#line  1757 &quot;cs.ATG&quot; 
 out expr2);
 
-#line  1733 &quot;cs.ATG&quot; 
+#line  1757 &quot;cs.ATG&quot; 
 				expr = new ConditionalExpression(expr, expr1, expr2);  
 			}
 		} else if (StartOf(6)) {
 
-#line  1735 &quot;cs.ATG&quot; 
+#line  1759 &quot;cs.ATG&quot; 
 			AssignmentOperatorType op; Expression val; 
 			AssignmentOperator(
-#line  1735 &quot;cs.ATG&quot; 
+#line  1759 &quot;cs.ATG&quot; 
 out op);
 			Expr(
-#line  1735 &quot;cs.ATG&quot; 
+#line  1759 &quot;cs.ATG&quot; 
 out val);
 
-#line  1735 &quot;cs.ATG&quot; 
+#line  1759 &quot;cs.ATG&quot; 
 			expr = new AssignmentExpression(expr, op, val); 
 		} else SynErr(128);
 	}
 
 	void AttributeSection(
-#line  609 &quot;cs.ATG&quot; 
+#line  619 &quot;cs.ATG&quot; 
 out AttributeSection section) {
 
-#line  611 &quot;cs.ATG&quot; 
+#line  621 &quot;cs.ATG&quot; 
 		string attributeTarget = &quot;&quot;;
 		ArrayList attributes = new ArrayList();
 		ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
@@ -783,25 +793,25 @@
 		
 		Expect(16);
 
-#line  617 &quot;cs.ATG&quot; 
+#line  627 &quot;cs.ATG&quot; 
 		Point startPos = t.Location; 
 		if (
-#line  618 &quot;cs.ATG&quot; 
+#line  628 &quot;cs.ATG&quot; 
 IsLocalAttrTarget()) {
 			if (la.kind == 68) {
 				lexer.NextToken();
 
-#line  619 &quot;cs.ATG&quot; 
+#line  629 &quot;cs.ATG&quot; 
 				attributeTarget = &quot;event&quot;;
 			} else if (la.kind == 100) {
 				lexer.NextToken();
 
-#line  620 &quot;cs.ATG&quot; 
+#line  630 &quot;cs.ATG&quot; 
 				attributeTarget = &quot;return&quot;;
 			} else {
 				lexer.NextToken();
 
-#line  621 &quot;cs.ATG&quot; 
+#line  631 &quot;cs.ATG&quot; 
 				if (t.val != &quot;field&quot;    || t.val != &quot;method&quot; ||
 				  t.val != &quot;module&quot;   || t.val != &quot;param&quot;  ||
 				  t.val != &quot;property&quot; || t.val != &quot;type&quot;)
@@ -813,20 +823,20 @@
 			Expect(9);
 		}
 		Attribute(
-#line  631 &quot;cs.ATG&quot; 
+#line  641 &quot;cs.ATG&quot; 
 out attribute);
 
-#line  631 &quot;cs.ATG&quot; 
+#line  641 &quot;cs.ATG&quot; 
 		attributes.Add(attribute); 
 		while (
-#line  632 &quot;cs.ATG&quot; 
+#line  642 &quot;cs.ATG&quot; 
 NotFinalComma()) {
 			Expect(12);
 			Attribute(
-#line  632 &quot;cs.ATG&quot; 
+#line  642 &quot;cs.ATG&quot; 
 out attribute);
 
-#line  632 &quot;cs.ATG&quot; 
+#line  642 &quot;cs.ATG&quot; 
 			attributes.Add(attribute); 
 		}
 		if (la.kind == 12) {
@@ -834,7 +844,7 @@
 		}
 		Expect(17);
 
-#line  634 &quot;cs.ATG&quot; 
+#line  644 &quot;cs.ATG&quot; 
 		section = new AttributeSection(attributeTarget, attributes);
 		section.StartLocation = startPos;
 		section.EndLocation = t.EndLocation;
@@ -842,69 +852,69 @@
 	}
 
 	void TypeModifier(
-#line  920 &quot;cs.ATG&quot; 
+#line  940 &quot;cs.ATG&quot; 
 Modifiers m) {
 		switch (la.kind) {
 		case 88: {
 			lexer.NextToken();
 
-#line  922 &quot;cs.ATG&quot; 
+#line  942 &quot;cs.ATG&quot; 
 			m.Add(Modifier.New); 
 			break;
 		}
 		case 97: {
 			lexer.NextToken();
 
-#line  923 &quot;cs.ATG&quot; 
+#line  943 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Public); 
 			break;
 		}
 		case 96: {
 			lexer.NextToken();
 
-#line  924 &quot;cs.ATG&quot; 
+#line  944 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Protected); 
 			break;
 		}
 		case 83: {
 			lexer.NextToken();
 
-#line  925 &quot;cs.ATG&quot; 
+#line  945 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Internal); 
 			break;
 		}
 		case 95: {
 			lexer.NextToken();
 
-#line  926 &quot;cs.ATG&quot; 
+#line  946 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Private); 
 			break;
 		}
 		case 118: {
 			lexer.NextToken();
 
-#line  927 &quot;cs.ATG&quot; 
+#line  947 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Unsafe); 
 			break;
 		}
 		case 48: {
 			lexer.NextToken();
 
-#line  928 &quot;cs.ATG&quot; 
+#line  948 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Abstract); 
 			break;
 		}
 		case 102: {
 			lexer.NextToken();
 
-#line  929 &quot;cs.ATG&quot; 
+#line  949 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Sealed); 
 			break;
 		}
 		case 106: {
 			lexer.NextToken();
 
-#line  930 &quot;cs.ATG&quot; 
+#line  950 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Static); 
 			break;
 		}
@@ -913,21 +923,25 @@
 	}
 
 	void TypeDecl(
-#line  667 &quot;cs.ATG&quot; 
+#line  685 &quot;cs.ATG&quot; 
 Modifiers m, ArrayList attributes) {
 
-#line  669 &quot;cs.ATG&quot; 
+#line  687 &quot;cs.ATG&quot; 
 		TypeReference type;
 		StringCollection names;
 		ArrayList p; string name;
+		bool partial;
 		
-		if (la.kind == 58) {
+		if (la.kind == 1 || la.kind == 58) {
 
-#line  673 &quot;cs.ATG&quot; 
+#line  692 &quot;cs.ATG&quot; 
 			m.Check(Modifier.Classes); 
-			lexer.NextToken();
+			PartialDecl(
+#line  693 &quot;cs.ATG&quot; 
+out partial);
+			Expect(58);
 
-#line  674 &quot;cs.ATG&quot; 
+#line  694 &quot;cs.ATG&quot; 
 			TypeDeclaration newType = new TypeDeclaration();
 			compilationUnit.AddChild(newType);
 			compilationUnit.BlockStart(newType);
@@ -938,36 +952,36 @@
 			
 			Expect(1);
 
-#line  682 &quot;cs.ATG&quot; 
+#line  702 &quot;cs.ATG&quot; 
 			newType.Name = t.val; 
 			if (la.kind == 9) {
 				ClassBase(
-#line  683 &quot;cs.ATG&quot; 
+#line  703 &quot;cs.ATG&quot; 
 out names);
 
-#line  683 &quot;cs.ATG&quot; 
+#line  703 &quot;cs.ATG&quot; 
 				newType.BaseTypes = names; 
 			}
 
-#line  683 &quot;cs.ATG&quot; 
+#line  703 &quot;cs.ATG&quot; 
 			newType.StartLocation = t.EndLocation; 
 			ClassBody();
 			if (la.kind == 10) {
 				lexer.NextToken();
 			}
 
-#line  685 &quot;cs.ATG&quot; 
+#line  705 &quot;cs.ATG&quot; 
 			newType.EndLocation = t.Location; 
 			compilationUnit.BlockEnd();
 			
 		} else if (StartOf(7)) {
 
-#line  688 &quot;cs.ATG&quot; 
+#line  708 &quot;cs.ATG&quot; 
 			m.Check(Modifier.StructsInterfacesEnumsDelegates); 
 			if (la.kind == 108) {
 				lexer.NextToken();
 
-#line  689 &quot;cs.ATG&quot; 
+#line  709 &quot;cs.ATG&quot; 
 				TypeDeclaration newType = new TypeDeclaration();
 				compilationUnit.AddChild(newType);
 				compilationUnit.BlockStart(newType);
@@ -977,32 +991,32 @@
 				
 				Expect(1);
 
-#line  696 &quot;cs.ATG&quot; 
+#line  716 &quot;cs.ATG&quot; 
 				newType.Name = t.val; 
 				if (la.kind == 9) {
 					StructInterfaces(
-#line  697 &quot;cs.ATG&quot; 
+#line  717 &quot;cs.ATG&quot; 
 out names);
 
-#line  697 &quot;cs.ATG&quot; 
+#line  717 &quot;cs.ATG&quot; 
 					newType.BaseTypes = names; 
 				}
 
-#line  697 &quot;cs.ATG&quot; 
+#line  717 &quot;cs.ATG&quot; 
 				newType.StartLocation = t.EndLocation; 
 				StructBody();
 				if (la.kind == 10) {
 					lexer.NextToken();
 				}
 
-#line  699 &quot;cs.ATG&quot; 
+#line  719 &quot;cs.ATG&quot; 
 				newType.EndLocation = t.Location; 
 				compilationUnit.BlockEnd();
 				
 			} else if (la.kind == 82) {
 				lexer.NextToken();
 
-#line  703 &quot;cs.ATG&quot; 
+#line  723 &quot;cs.ATG&quot; 
 				TypeDeclaration newType = new TypeDeclaration();
 				compilationUnit.AddChild(newType);
 				compilationUnit.BlockStart(newType);
@@ -1011,32 +1025,32 @@
 				newType.Modifier = m.Modifier;
 				Expect(1);
 
-#line  709 &quot;cs.ATG&quot; 
+#line  729 &quot;cs.ATG&quot; 
 				newType.Name = t.val; 
 				if (la.kind == 9) {
 					InterfaceBase(
-#line  710 &quot;cs.ATG&quot; 
+#line  730 &quot;cs.ATG&quot; 
 out names);
 
-#line  710 &quot;cs.ATG&quot; 
+#line  730 &quot;cs.ATG&quot; 
 					newType.BaseTypes = names; 
 				}
 
-#line  710 &quot;cs.ATG&quot; 
+#line  730 &quot;cs.ATG&quot; 
 				newType.StartLocation = t.EndLocation; 
 				InterfaceBody();
 				if (la.kind == 10) {
 					lexer.NextToken();
 				}
 
-#line  712 &quot;cs.ATG&quot; 
+#line  732 &quot;cs.ATG&quot; 
 				newType.EndLocation = t.Location; 
 				compilationUnit.BlockEnd();
 				
 			} else if (la.kind == 67) {
 				lexer.NextToken();
 
-#line  716 &quot;cs.ATG&quot; 
+#line  736 &quot;cs.ATG&quot; 
 				TypeDeclaration newType = new TypeDeclaration();
 				compilationUnit.AddChild(newType);
 				compilationUnit.BlockStart(newType);
@@ -1045,72 +1059,72 @@
 				newType.Modifier = m.Modifier;
 				Expect(1);
 
-#line  722 &quot;cs.ATG&quot; 
+#line  742 &quot;cs.ATG&quot; 
 				newType.Name = t.val; 
 				if (la.kind == 9) {
 					lexer.NextToken();
 					IntegralType(
-#line  723 &quot;cs.ATG&quot; 
+#line  743 &quot;cs.ATG&quot; 
 out name);
 
-#line  723 &quot;cs.ATG&quot; 
+#line  743 &quot;cs.ATG&quot; 
 					newType.BaseTypes = new StringCollection(); 
 					newType.BaseTypes.Add(name);
 					
 				}
 
-#line  726 &quot;cs.ATG&quot; 
+#line  746 &quot;cs.ATG&quot; 
 				newType.StartLocation = t.EndLocation; 
 				EnumBody();
 				if (la.kind == 10) {
 					lexer.NextToken();
 				}
 
-#line  728 &quot;cs.ATG&quot; 
+#line  748 &quot;cs.ATG&quot; 
 				newType.EndLocation = t.Location; 
 				compilationUnit.BlockEnd();
 				
 			} else {
 				lexer.NextToken();
 
-#line  732 &quot;cs.ATG&quot; 
+#line  752 &quot;cs.ATG&quot; 
 				DelegateDeclaration delegateDeclr = new DelegateDeclaration();
 				delegateDeclr.StartLocation = t.Location;
 				delegateDeclr.Modifier = m.Modifier;
 				delegateDeclr.Attributes = attributes;
 				
 				if (
-#line  737 &quot;cs.ATG&quot; 
+#line  757 &quot;cs.ATG&quot; 
 NotVoidPointer()) {
 					Expect(122);
 
-#line  737 &quot;cs.ATG&quot; 
+#line  757 &quot;cs.ATG&quot; 
 					delegateDeclr.ReturnType = new TypeReference(&quot;void&quot;, 0, null); 
 				} else if (StartOf(8)) {
 					Type(
-#line  738 &quot;cs.ATG&quot; 
+#line  758 &quot;cs.ATG&quot; 
 out type);
 
-#line  738 &quot;cs.ATG&quot; 
+#line  758 &quot;cs.ATG&quot; 
 					delegateDeclr.ReturnType = type; 
 				} else SynErr(130);
 				Expect(1);
 
-#line  740 &quot;cs.ATG&quot; 
+#line  760 &quot;cs.ATG&quot; 
 				delegateDeclr.Name = t.val; 
 				Expect(18);
 				if (StartOf(9)) {
 					FormalParameterList(
-#line  741 &quot;cs.ATG&quot; 
+#line  761 &quot;cs.ATG&quot; 
 out p);
 
-#line  741 &quot;cs.ATG&quot; 
+#line  761 &quot;cs.ATG&quot; 
 					delegateDeclr.Parameters = p; 
 				}
 				Expect(19);
 				Expect(10);
 
-#line  743 &quot;cs.ATG&quot; 
+#line  763 &quot;cs.ATG&quot; 
 				delegateDeclr.EndLocation = t.Location;
 				compilationUnit.AddChild(delegateDeclr);
 				
@@ -1118,142 +1132,157 @@
 		} else SynErr(131);
 	}
 
+	void PartialDecl(
+#line  677 &quot;cs.ATG&quot; 
+out bool partial) {
+
+#line  679 &quot;cs.ATG&quot; 
+		partial = false;
+		
+		if (la.kind == 1) {
+			lexer.NextToken();
+
+#line  682 &quot;cs.ATG&quot; 
+			if (t.val == &quot;partial&quot;) partial = true; 
+		}
+	}
+
 	void ClassBase(
-#line  758 &quot;cs.ATG&quot; 
+#line  778 &quot;cs.ATG&quot; 
 out StringCollection names) {
 
-#line  760 &quot;cs.ATG&quot; 
+#line  780 &quot;cs.ATG&quot; 
 		string qualident;
 		names = new StringCollection(); 
 		
 		Expect(9);
 		ClassType(
-#line  764 &quot;cs.ATG&quot; 
+#line  784 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  764 &quot;cs.ATG&quot; 
+#line  784 &quot;cs.ATG&quot; 
 		names.Add(qualident); 
 		while (la.kind == 12) {
 			lexer.NextToken();
 			Qualident(
-#line  765 &quot;cs.ATG&quot; 
+#line  785 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  765 &quot;cs.ATG&quot; 
+#line  785 &quot;cs.ATG&quot; 
 			names.Add(qualident); 
 		}
 	}
 
 	void ClassBody() {
 
-#line  769 &quot;cs.ATG&quot; 
+#line  789 &quot;cs.ATG&quot; 
 		AttributeSection section; 
 		Expect(14);
 		while (StartOf(10)) {
 
-#line  772 &quot;cs.ATG&quot; 
+#line  792 &quot;cs.ATG&quot; 
 			ArrayList attributes = new ArrayList();
 			Modifiers m = new Modifiers(this);
 			
 			while (la.kind == 16) {
 				AttributeSection(
-#line  775 &quot;cs.ATG&quot; 
+#line  795 &quot;cs.ATG&quot; 
 out section);
 
-#line  775 &quot;cs.ATG&quot; 
+#line  795 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			while (StartOf(11)) {
 				MemberModifier(
-#line  776 &quot;cs.ATG&quot; 
+#line  796 &quot;cs.ATG&quot; 
 m);
 			}
 			ClassMemberDecl(
-#line  777 &quot;cs.ATG&quot; 
+#line  797 &quot;cs.ATG&quot; 
 m, attributes);
 		}
 		Expect(15);
 	}
 
 	void StructInterfaces(
-#line  782 &quot;cs.ATG&quot; 
+#line  802 &quot;cs.ATG&quot; 
 out StringCollection names) {
 
-#line  784 &quot;cs.ATG&quot; 
+#line  804 &quot;cs.ATG&quot; 
 		string qualident; 
 		names = new StringCollection();
 		
 		Expect(9);
 		Qualident(
-#line  788 &quot;cs.ATG&quot; 
+#line  808 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  788 &quot;cs.ATG&quot; 
+#line  808 &quot;cs.ATG&quot; 
 		names.Add(qualident); 
 		while (la.kind == 12) {
 			lexer.NextToken();
 			Qualident(
-#line  789 &quot;cs.ATG&quot; 
+#line  809 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  789 &quot;cs.ATG&quot; 
+#line  809 &quot;cs.ATG&quot; 
 			names.Add(qualident); 
 		}
 	}
 
 	void StructBody() {
 
-#line  793 &quot;cs.ATG&quot; 
+#line  813 &quot;cs.ATG&quot; 
 		AttributeSection section; 
 		Expect(14);
 		while (StartOf(12)) {
 
-#line  796 &quot;cs.ATG&quot; 
+#line  816 &quot;cs.ATG&quot; 
 			ArrayList attributes = new ArrayList();
 			Modifiers m = new Modifiers(this);
 			
 			while (la.kind == 16) {
 				AttributeSection(
-#line  799 &quot;cs.ATG&quot; 
+#line  819 &quot;cs.ATG&quot; 
 out section);
 
-#line  799 &quot;cs.ATG&quot; 
+#line  819 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			while (StartOf(11)) {
 				MemberModifier(
-#line  800 &quot;cs.ATG&quot; 
+#line  820 &quot;cs.ATG&quot; 
 m);
 			}
 			StructMemberDecl(
-#line  801 &quot;cs.ATG&quot; 
+#line  821 &quot;cs.ATG&quot; 
 m, attributes);
 		}
 		Expect(15);
 	}
 
 	void InterfaceBase(
-#line  806 &quot;cs.ATG&quot; 
+#line  826 &quot;cs.ATG&quot; 
 out StringCollection names) {
 
-#line  808 &quot;cs.ATG&quot; 
+#line  828 &quot;cs.ATG&quot; 
 		string qualident;
 		names = new StringCollection();
 		
 		Expect(9);
 		Qualident(
-#line  812 &quot;cs.ATG&quot; 
+#line  832 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  812 &quot;cs.ATG&quot; 
+#line  832 &quot;cs.ATG&quot; 
 		names.Add(qualident); 
 		while (la.kind == 12) {
 			lexer.NextToken();
 			Qualident(
-#line  813 &quot;cs.ATG&quot; 
+#line  833 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  813 &quot;cs.ATG&quot; 
+#line  833 &quot;cs.ATG&quot; 
 			names.Add(qualident); 
 		}
 	}
@@ -1267,72 +1296,72 @@
 	}
 
 	void IntegralType(
-#line  940 &quot;cs.ATG&quot; 
+#line  960 &quot;cs.ATG&quot; 
 out string name) {
 
-#line  940 &quot;cs.ATG&quot; 
+#line  960 &quot;cs.ATG&quot; 
 		name = &quot;&quot;; 
 		switch (la.kind) {
 		case 101: {
 			lexer.NextToken();
 
-#line  942 &quot;cs.ATG&quot; 
+#line  962 &quot;cs.ATG&quot; 
 			name = &quot;sbyte&quot;; 
 			break;
 		}
 		case 53: {
 			lexer.NextToken();
 
-#line  943 &quot;cs.ATG&quot; 
+#line  963 &quot;cs.ATG&quot; 
 			name = &quot;byte&quot;; 
 			break;
 		}
 		case 103: {
 			lexer.NextToken();
 
-#line  944 &quot;cs.ATG&quot; 
+#line  964 &quot;cs.ATG&quot; 
 			name = &quot;short&quot;; 
 			break;
 		}
 		case 119: {
 			lexer.NextToken();
 
-#line  945 &quot;cs.ATG&quot; 
+#line  965 &quot;cs.ATG&quot; 
 			name = &quot;ushort&quot;; 
 			break;
 		}
 		case 81: {
 			lexer.NextToken();
 
-#line  946 &quot;cs.ATG&quot; 
+#line  966 &quot;cs.ATG&quot; 
 			name = &quot;int&quot;; 
 			break;
 		}
 		case 115: {
 			lexer.NextToken();
 
-#line  947 &quot;cs.ATG&quot; 
+#line  967 &quot;cs.ATG&quot; 
 			name = &quot;uint&quot;; 
 			break;
 		}
 		case 86: {
 			lexer.NextToken();
 
-#line  948 &quot;cs.ATG&quot; 
+#line  968 &quot;cs.ATG&quot; 
 			name = &quot;long&quot;; 
 			break;
 		}
 		case 116: {
 			lexer.NextToken();
 
-#line  949 &quot;cs.ATG&quot; 
+#line  969 &quot;cs.ATG&quot; 
 			name = &quot;ulong&quot;; 
 			break;
 		}
 		case 56: {
 			lexer.NextToken();
 
-#line  950 &quot;cs.ATG&quot; 
+#line  970 &quot;cs.ATG&quot; 
 			name = &quot;char&quot;; 
 			break;
 		}
@@ -1342,25 +1371,25 @@
 
 	void EnumBody() {
 
-#line  819 &quot;cs.ATG&quot; 
+#line  839 &quot;cs.ATG&quot; 
 		FieldDeclaration f; 
 		Expect(14);
 		if (la.kind == 1 || la.kind == 16) {
 			EnumMemberDecl(
-#line  821 &quot;cs.ATG&quot; 
+#line  841 &quot;cs.ATG&quot; 
 out f);
 
-#line  821 &quot;cs.ATG&quot; 
+#line  841 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(f); 
 			while (
-#line  822 &quot;cs.ATG&quot; 
+#line  842 &quot;cs.ATG&quot; 
 NotFinalComma()) {
 				Expect(12);
 				EnumMemberDecl(
-#line  822 &quot;cs.ATG&quot; 
+#line  842 &quot;cs.ATG&quot; 
 out f);
 
-#line  822 &quot;cs.ATG&quot; 
+#line  842 &quot;cs.ATG&quot; 
 				compilationUnit.AddChild(f); 
 			}
 			if (la.kind == 12) {
@@ -1371,68 +1400,68 @@
 	}
 
 	void Type(
-#line  827 &quot;cs.ATG&quot; 
+#line  847 &quot;cs.ATG&quot; 
 out TypeReference type) {
 
-#line  829 &quot;cs.ATG&quot; 
+#line  849 &quot;cs.ATG&quot; 
 		string name = &quot;&quot;;
 		int pointer = 0;
 		
 		if (la.kind == 1 || la.kind == 90 || la.kind == 107) {
 			ClassType(
-#line  833 &quot;cs.ATG&quot; 
+#line  853 &quot;cs.ATG&quot; 
 out name);
 		} else if (StartOf(14)) {
 			SimpleType(
-#line  834 &quot;cs.ATG&quot; 
+#line  854 &quot;cs.ATG&quot; 
 out name);
 		} else if (la.kind == 122) {
 			lexer.NextToken();
 			Expect(6);
 
-#line  835 &quot;cs.ATG&quot; 
+#line  855 &quot;cs.ATG&quot; 
 			pointer = 1; name = &quot;void&quot;; 
 		} else SynErr(133);
 
-#line  836 &quot;cs.ATG&quot; 
+#line  856 &quot;cs.ATG&quot; 
 		ArrayList r = new ArrayList(); 
 		while (
-#line  837 &quot;cs.ATG&quot; 
+#line  857 &quot;cs.ATG&quot; 
 IsPointerOrDims()) {
 
-#line  837 &quot;cs.ATG&quot; 
+#line  857 &quot;cs.ATG&quot; 
 			int i = 1; 
 			if (la.kind == 6) {
 				lexer.NextToken();
 
-#line  838 &quot;cs.ATG&quot; 
+#line  858 &quot;cs.ATG&quot; 
 				++pointer; 
 			} else if (la.kind == 16) {
 				lexer.NextToken();
 				while (la.kind == 12) {
 					lexer.NextToken();
 
-#line  839 &quot;cs.ATG&quot; 
+#line  859 &quot;cs.ATG&quot; 
 					++i; 
 				}
 				Expect(17);
 
-#line  839 &quot;cs.ATG&quot; 
+#line  859 &quot;cs.ATG&quot; 
 				r.Add(i); 
 			} else SynErr(134);
 		}
 
-#line  841 &quot;cs.ATG&quot; 
+#line  861 &quot;cs.ATG&quot; 
 		int[] rank = new int[r.Count]; r.CopyTo(rank); 
 		type = new TypeReference(name, pointer, rank);
 		
 	}
 
 	void FormalParameterList(
-#line  875 &quot;cs.ATG&quot; 
+#line  895 &quot;cs.ATG&quot; 
 out ArrayList parameter) {
 
-#line  877 &quot;cs.ATG&quot; 
+#line  897 &quot;cs.ATG&quot; 
 		parameter = new ArrayList();
 		ParameterDeclarationExpression p;
 		AttributeSection section;
@@ -1440,18 +1469,18 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  883 &quot;cs.ATG&quot; 
+#line  903 &quot;cs.ATG&quot; 
 out section);
 
-#line  883 &quot;cs.ATG&quot; 
+#line  903 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (StartOf(15)) {
 			FixedParameter(
-#line  885 &quot;cs.ATG&quot; 
+#line  905 &quot;cs.ATG&quot; 
 out p);
 
-#line  885 &quot;cs.ATG&quot; 
+#line  905 &quot;cs.ATG&quot; 
 			bool paramsFound = false;
 			p.Attributes = attributes;
 			parameter.Add(p);
@@ -1459,167 +1488,167 @@
 			while (la.kind == 12) {
 				lexer.NextToken();
 
-#line  890 &quot;cs.ATG&quot; 
+#line  910 &quot;cs.ATG&quot; 
 				attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); 
 				while (la.kind == 16) {
 					AttributeSection(
-#line  891 &quot;cs.ATG&quot; 
+#line  911 &quot;cs.ATG&quot; 
 out section);
 
-#line  891 &quot;cs.ATG&quot; 
+#line  911 &quot;cs.ATG&quot; 
 					attributes.Add(section); 
 				}
 				if (StartOf(15)) {
 					FixedParameter(
-#line  893 &quot;cs.ATG&quot; 
+#line  913 &quot;cs.ATG&quot; 
 out p);
 
-#line  893 &quot;cs.ATG&quot; 
+#line  913 &quot;cs.ATG&quot; 
 					p.Attributes = attributes; parameter.Add(p); 
 				} else if (la.kind == 94) {
 					ParameterArray(
-#line  894 &quot;cs.ATG&quot; 
+#line  914 &quot;cs.ATG&quot; 
 out p);
 
-#line  894 &quot;cs.ATG&quot; 
+#line  914 &quot;cs.ATG&quot; 
 					paramsFound = true; p.Attributes = attributes; parameter.Add(p); 
 				} else SynErr(135);
 			}
 		} else if (la.kind == 94) {
 			ParameterArray(
-#line  897 &quot;cs.ATG&quot; 
+#line  917 &quot;cs.ATG&quot; 
 out p);
 
-#line  897 &quot;cs.ATG&quot; 
+#line  917 &quot;cs.ATG&quot; 
 			p.Attributes = attributes; parameter.Add(p); 
 		} else SynErr(136);
 	}
 
 	void ClassType(
-#line  933 &quot;cs.ATG&quot; 
+#line  953 &quot;cs.ATG&quot; 
 out string name) {
 
-#line  933 &quot;cs.ATG&quot; 
+#line  953 &quot;cs.ATG&quot; 
 		string qualident; name = &quot;&quot;;
 		if (la.kind == 1) {
 			Qualident(
-#line  935 &quot;cs.ATG&quot; 
+#line  955 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  935 &quot;cs.ATG&quot; 
+#line  955 &quot;cs.ATG&quot; 
 			name = qualident; 
 		} else if (la.kind == 90) {
 			lexer.NextToken();
 
-#line  936 &quot;cs.ATG&quot; 
+#line  956 &quot;cs.ATG&quot; 
 			name = &quot;object&quot;; 
 		} else if (la.kind == 107) {
 			lexer.NextToken();
 
-#line  937 &quot;cs.ATG&quot; 
+#line  957 &quot;cs.ATG&quot; 
 			name = &quot;string&quot;; 
 		} else SynErr(137);
 	}
 
 	void MemberModifier(
-#line  953 &quot;cs.ATG&quot; 
+#line  973 &quot;cs.ATG&quot; 
 Modifiers m) {
 		switch (la.kind) {
 		case 48: {
 			lexer.NextToken();
 
-#line  955 &quot;cs.ATG&quot; 
+#line  975 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Abstract); 
 			break;
 		}
 		case 70: {
 			lexer.NextToken();
 
-#line  956 &quot;cs.ATG&quot; 
+#line  976 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Extern); 
 			break;
 		}
 		case 83: {
 			lexer.NextToken();
 
-#line  957 &quot;cs.ATG&quot; 
+#line  977 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Internal); 
 			break;
 		}
 		case 88: {
 			lexer.NextToken();
 
-#line  958 &quot;cs.ATG&quot; 
+#line  978 &quot;cs.ATG&quot; 
 			m.Add(Modifier.New); 
 			break;
 		}
 		case 93: {
 			lexer.NextToken();
 
-#line  959 &quot;cs.ATG&quot; 
+#line  979 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Override); 
 			break;
 		}
 		case 95: {
 			lexer.NextToken();
 
-#line  960 &quot;cs.ATG&quot; 
+#line  980 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Private); 
 			break;
 		}
 		case 96: {
 			lexer.NextToken();
 
-#line  961 &quot;cs.ATG&quot; 
+#line  981 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Protected); 
 			break;
 		}
 		case 97: {
 			lexer.NextToken();
 
-#line  962 &quot;cs.ATG&quot; 
+#line  982 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Public); 
 			break;
 		}
 		case 98: {
 			lexer.NextToken();
 
-#line  963 &quot;cs.ATG&quot; 
+#line  983 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Readonly); 
 			break;
 		}
 		case 102: {
 			lexer.NextToken();
 
-#line  964 &quot;cs.ATG&quot; 
+#line  984 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Sealed); 
 			break;
 		}
 		case 106: {
 			lexer.NextToken();
 
-#line  965 &quot;cs.ATG&quot; 
+#line  985 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Static); 
 			break;
 		}
 		case 118: {
 			lexer.NextToken();
 
-#line  966 &quot;cs.ATG&quot; 
+#line  986 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Unsafe); 
 			break;
 		}
 		case 121: {
 			lexer.NextToken();
 
-#line  967 &quot;cs.ATG&quot; 
+#line  987 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Virtual); 
 			break;
 		}
 		case 123: {
 			lexer.NextToken();
 
-#line  968 &quot;cs.ATG&quot; 
+#line  988 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Volatile); 
 			break;
 		}
@@ -1628,23 +1657,23 @@
 	}
 
 	void ClassMemberDecl(
-#line  1187 &quot;cs.ATG&quot; 
+#line  1207 &quot;cs.ATG&quot; 
 Modifiers m, ArrayList attributes) {
 
-#line  1188 &quot;cs.ATG&quot; 
+#line  1208 &quot;cs.ATG&quot; 
 		Statement stmt = null; 
 		if (StartOf(16)) {
 			StructMemberDecl(
-#line  1190 &quot;cs.ATG&quot; 
+#line  1210 &quot;cs.ATG&quot; 
 m, attributes);
 		} else if (la.kind == 25) {
 
-#line  1191 &quot;cs.ATG&quot; 
+#line  1211 &quot;cs.ATG&quot; 
 			m.Check(Modifier.Destructors); Point startPos = t.Location; 
 			lexer.NextToken();
 			Expect(1);
 
-#line  1192 &quot;cs.ATG&quot; 
+#line  1212 &quot;cs.ATG&quot; 
 			DestructorDeclaration d = new DestructorDeclaration(t.val, attributes); 
 			d.Modifier = m.Modifier;
 			d.StartLocation = startPos;
@@ -1653,13 +1682,13 @@
 			Expect(19);
 			if (la.kind == 14) {
 				Block(
-#line  1196 &quot;cs.ATG&quot; 
+#line  1216 &quot;cs.ATG&quot; 
 out stmt);
 			} else if (la.kind == 10) {
 				lexer.NextToken();
 			} else SynErr(139);
 
-#line  1196 &quot;cs.ATG&quot; 
+#line  1216 &quot;cs.ATG&quot; 
 			d.EndLocation = t.EndLocation; 
 			d.Body = (BlockStatement)stmt;
 			compilationUnit.AddChild(d);
@@ -1668,10 +1697,10 @@
 	}
 
 	void StructMemberDecl(
-#line  979 &quot;cs.ATG&quot; 
+#line  999 &quot;cs.ATG&quot; 
 Modifiers m, ArrayList attributes) {
 
-#line  981 &quot;cs.ATG&quot; 
+#line  1001 &quot;cs.ATG&quot; 
 		string qualident = null;
 		TypeReference type;
 		Expression expr;
@@ -1681,68 +1710,68 @@
 		
 		if (la.kind == 59) {
 
-#line  989 &quot;cs.ATG&quot; 
+#line  1009 &quot;cs.ATG&quot; 
 			m.Check(Modifier.Constants); 
 			lexer.NextToken();
 			Type(
-#line  991 &quot;cs.ATG&quot; 
+#line  1011 &quot;cs.ATG&quot; 
 out type);
 			Expect(1);
 
-#line  991 &quot;cs.ATG&quot; 
+#line  1011 &quot;cs.ATG&quot; 
 			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier | Modifier.Const);
 			VariableDeclaration f = new VariableDeclaration(t.val);
 			fd.Fields.Add(f);
 			
 			Expect(3);
 			Expr(
-#line  995 &quot;cs.ATG&quot; 
+#line  1015 &quot;cs.ATG&quot; 
 out expr);
 
-#line  995 &quot;cs.ATG&quot; 
+#line  1015 &quot;cs.ATG&quot; 
 			f.Initializer = expr; 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  996 &quot;cs.ATG&quot; 
+#line  1016 &quot;cs.ATG&quot; 
 				f = new VariableDeclaration(t.val);
 				fd.Fields.Add(f);
 				
 				Expect(3);
 				Expr(
-#line  999 &quot;cs.ATG&quot; 
+#line  1019 &quot;cs.ATG&quot; 
 out expr);
 
-#line  999 &quot;cs.ATG&quot; 
+#line  1019 &quot;cs.ATG&quot; 
 				f.Initializer = expr; 
 			}
 			Expect(10);
 
-#line  1000 &quot;cs.ATG&quot; 
+#line  1020 &quot;cs.ATG&quot; 
 			fd.EndLocation = t.EndLocation; compilationUnit.AddChild(fd); 
 		} else if (
-#line  1003 &quot;cs.ATG&quot; 
+#line  1023 &quot;cs.ATG&quot; 
 NotVoidPointer()) {
 
-#line  1003 &quot;cs.ATG&quot; 
+#line  1023 &quot;cs.ATG&quot; 
 			m.Check(Modifier.PropertysEventsMethods); 
 			Expect(122);
 
-#line  1004 &quot;cs.ATG&quot; 
+#line  1024 &quot;cs.ATG&quot; 
 			Point startPos = t.Location; 
 			Qualident(
-#line  1005 &quot;cs.ATG&quot; 
+#line  1025 &quot;cs.ATG&quot; 
 out qualident);
 			Expect(18);
 			if (StartOf(9)) {
 				FormalParameterList(
-#line  1006 &quot;cs.ATG&quot; 
+#line  1026 &quot;cs.ATG&quot; 
 out p);
 			}
 			Expect(19);
 
-#line  1006 &quot;cs.ATG&quot; 
+#line  1026 &quot;cs.ATG&quot; 
 			MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
 			                                                           m.Modifier, 
 			                                                           new TypeReference(&quot;void&quot;), 
@@ -1755,23 +1784,23 @@
 			
 			if (la.kind == 14) {
 				Block(
-#line  1016 &quot;cs.ATG&quot; 
+#line  1036 &quot;cs.ATG&quot; 
 out stmt);
 			} else if (la.kind == 10) {
 				lexer.NextToken();
 			} else SynErr(141);
 
-#line  1016 &quot;cs.ATG&quot; 
+#line  1036 &quot;cs.ATG&quot; 
 			compilationUnit.BlockEnd();
 			methodDeclaration.Body  = (BlockStatement)stmt;
 			
 		} else if (la.kind == 68) {
 
-#line  1020 &quot;cs.ATG&quot; 
+#line  1040 &quot;cs.ATG&quot; 
 			m.Check(Modifier.PropertysEventsMethods); 
 			lexer.NextToken();
 
-#line  1021 &quot;cs.ATG&quot; 
+#line  1041 &quot;cs.ATG&quot; 
 			EventDeclaration eventDecl = new EventDeclaration(m.Modifier, attributes);
 			eventDecl.StartLocation = t.Location;
 			compilationUnit.AddChild(eventDecl);
@@ -1780,102 +1809,102 @@
 			EventRemoveRegion removeBlock = null;
 			
 			Type(
-#line  1028 &quot;cs.ATG&quot; 
+#line  1048 &quot;cs.ATG&quot; 
 out type);
 
-#line  1028 &quot;cs.ATG&quot; 
+#line  1048 &quot;cs.ATG&quot; 
 			eventDecl.TypeReference = type; 
 			if (
-#line  1030 &quot;cs.ATG&quot; 
+#line  1050 &quot;cs.ATG&quot; 
 IsVarDecl()) {
 				VariableDeclarator(
-#line  1030 &quot;cs.ATG&quot; 
+#line  1050 &quot;cs.ATG&quot; 
 variableDeclarators);
 				while (la.kind == 12) {
 					lexer.NextToken();
 					VariableDeclarator(
-#line  1031 &quot;cs.ATG&quot; 
+#line  1051 &quot;cs.ATG&quot; 
 variableDeclarators);
 				}
 				Expect(10);
 
-#line  1031 &quot;cs.ATG&quot; 
+#line  1051 &quot;cs.ATG&quot; 
 				eventDecl.VariableDeclarators = variableDeclarators; eventDecl.EndLocation = t.EndLocation;  
 			} else if (la.kind == 1) {
 				Qualident(
-#line  1032 &quot;cs.ATG&quot; 
+#line  1052 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  1032 &quot;cs.ATG&quot; 
+#line  1052 &quot;cs.ATG&quot; 
 				eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation;  
 				Expect(14);
 
-#line  1033 &quot;cs.ATG&quot; 
+#line  1053 &quot;cs.ATG&quot; 
 				eventDecl.BodyStart = t.Location; 
 				EventAccessorDecls(
-#line  1034 &quot;cs.ATG&quot; 
+#line  1054 &quot;cs.ATG&quot; 
 out addBlock, out removeBlock);
 				Expect(15);
 
-#line  1035 &quot;cs.ATG&quot; 
+#line  1055 &quot;cs.ATG&quot; 
 				eventDecl.BodyEnd   = t.EndLocation; 
 			} else SynErr(142);
 
-#line  1036 &quot;cs.ATG&quot; 
+#line  1056 &quot;cs.ATG&quot; 
 			compilationUnit.BlockEnd();
 				                                           eventDecl.AddRegion = addBlock;
 			eventDecl.RemoveRegion = removeBlock;
 			
 		} else if (
-#line  1043 &quot;cs.ATG&quot; 
+#line  1063 &quot;cs.ATG&quot; 
 IdentAndLPar()) {
 
-#line  1043 &quot;cs.ATG&quot; 
+#line  1063 &quot;cs.ATG&quot; 
 			m.Check(Modifier.Constructors | Modifier.StaticConstructors); 
 			Expect(1);
 
-#line  1044 &quot;cs.ATG&quot; 
+#line  1064 &quot;cs.ATG&quot; 
 			string name = t.val; Point startPos = t.Location; 
 			Expect(18);
 			if (StartOf(9)) {
 
-#line  1044 &quot;cs.ATG&quot; 
+#line  1064 &quot;cs.ATG&quot; 
 				m.Check(Modifier.Constructors); 
 				FormalParameterList(
-#line  1045 &quot;cs.ATG&quot; 
+#line  1065 &quot;cs.ATG&quot; 
 out p);
 			}
 			Expect(19);
 
-#line  1047 &quot;cs.ATG&quot; 
+#line  1067 &quot;cs.ATG&quot; 
 			ConstructorInitializer init = null;  
 			if (la.kind == 9) {
 
-#line  1048 &quot;cs.ATG&quot; 
+#line  1068 &quot;cs.ATG&quot; 
 				m.Check(Modifier.Constructors); 
 				ConstructorInitializer(
-#line  1049 &quot;cs.ATG&quot; 
+#line  1069 &quot;cs.ATG&quot; 
 out init);
 			}
 
-#line  1051 &quot;cs.ATG&quot; 
+#line  1071 &quot;cs.ATG&quot; 
 			ConstructorDeclaration cd = new ConstructorDeclaration(name, m.Modifier, p, init, attributes); 
 			cd.StartLocation = startPos;
 			cd.EndLocation   = t.EndLocation;
 			
 			if (la.kind == 14) {
 				Block(
-#line  1056 &quot;cs.ATG&quot; 
+#line  1076 &quot;cs.ATG&quot; 
 out stmt);
 			} else if (la.kind == 10) {
 				lexer.NextToken();
 			} else SynErr(143);
 
-#line  1056 &quot;cs.ATG&quot; 
+#line  1076 &quot;cs.ATG&quot; 
 			cd.Body = (BlockStatement)stmt; compilationUnit.AddChild(cd); 
 		} else if (la.kind == 69 || la.kind == 79) {
 
-#line  1059 &quot;cs.ATG&quot; 
+#line  1079 &quot;cs.ATG&quot; 
 			m.Check(Modifier.Operators);
 			if (m.isNone) Error(&quot;at least one modifier must be set&quot;); 
 			bool isImplicit = true;
@@ -1885,37 +1914,37 @@
 			} else {
 				lexer.NextToken();
 
-#line  1063 &quot;cs.ATG&quot; 
+#line  1083 &quot;cs.ATG&quot; 
 				isImplicit = false; 
 			}
 			Expect(91);
 			Type(
-#line  1064 &quot;cs.ATG&quot; 
+#line  1084 &quot;cs.ATG&quot; 
 out type);
 
-#line  1064 &quot;cs.ATG&quot; 
+#line  1084 &quot;cs.ATG&quot; 
 			TypeReference operatorType = type; 
 			Expect(18);
 			Type(
-#line  1065 &quot;cs.ATG&quot; 
+#line  1085 &quot;cs.ATG&quot; 
 out type);
 			Expect(1);
 
-#line  1065 &quot;cs.ATG&quot; 
+#line  1085 &quot;cs.ATG&quot; 
 			string varName = t.val; 
 			Expect(19);
 			if (la.kind == 14) {
 				Block(
-#line  1065 &quot;cs.ATG&quot; 
+#line  1085 &quot;cs.ATG&quot; 
 out stmt);
 			} else if (la.kind == 10) {
 				lexer.NextToken();
 
-#line  1065 &quot;cs.ATG&quot; 
+#line  1085 &quot;cs.ATG&quot; 
 				stmt = null; 
 			} else SynErr(144);
 
-#line  1068 &quot;cs.ATG&quot; 
+#line  1088 &quot;cs.ATG&quot; 
 			OperatorDeclarator operatorDeclarator = new OperatorDeclarator(isImplicit ? OperatorType.Implicit : OperatorType.Explicit,
 			                                                              operatorType,
 			                                                              type,
@@ -1926,54 +1955,54 @@
 			
 		} else if (StartOf(17)) {
 			TypeDecl(
-#line  1078 &quot;cs.ATG&quot; 
+#line  1098 &quot;cs.ATG&quot; 
 m, attributes);
 		} else if (StartOf(8)) {
 			Type(
-#line  1079 &quot;cs.ATG&quot; 
+#line  1099 &quot;cs.ATG&quot; 
 out type);
 
-#line  1079 &quot;cs.ATG&quot; 
+#line  1099 &quot;cs.ATG&quot; 
 			Point startPos = t.Location; 
 			if (la.kind == 91) {
 
-#line  1081 &quot;cs.ATG&quot; 
+#line  1101 &quot;cs.ATG&quot; 
 				Token op;
 				m.Check(Modifier.Operators);
 				if (m.isNone) Error(&quot;at least one modifier must be set&quot;);
 				
 				lexer.NextToken();
 				OverloadableOperator(
-#line  1085 &quot;cs.ATG&quot; 
+#line  1105 &quot;cs.ATG&quot; 
 out op);
 
-#line  1085 &quot;cs.ATG&quot; 
+#line  1105 &quot;cs.ATG&quot; 
 				TypeReference firstType, secondType = null; string secondName = null; 
 				Expect(18);
 				Type(
-#line  1086 &quot;cs.ATG&quot; 
+#line  1106 &quot;cs.ATG&quot; 
 out firstType);
 				Expect(1);
 
-#line  1086 &quot;cs.ATG&quot; 
+#line  1106 &quot;cs.ATG&quot; 
 				string firstName = t.val; 
 				if (la.kind == 12) {
 					lexer.NextToken();
 					Type(
-#line  1087 &quot;cs.ATG&quot; 
+#line  1107 &quot;cs.ATG&quot; 
 out secondType);
 					Expect(1);
 
-#line  1087 &quot;cs.ATG&quot; 
+#line  1107 &quot;cs.ATG&quot; 
 					secondName = t.val; 
 
-#line  1087 &quot;cs.ATG&quot; 
+#line  1107 &quot;cs.ATG&quot; 
 					if (ParserUtil.IsUnaryOperator(op) &amp;&amp; !ParserUtil.IsBinaryOperator(op))
 					Error(&quot;too many operands for unary operator&quot;); 
 					
 				} else if (la.kind == 19) {
 
-#line  1090 &quot;cs.ATG&quot; 
+#line  1110 &quot;cs.ATG&quot; 
 					if (ParserUtil.IsBinaryOperator(op))
 					Error(&quot;too few operands for binary operator&quot;);
 					
@@ -1981,13 +2010,13 @@
 				Expect(19);
 				if (la.kind == 14) {
 					Block(
-#line  1094 &quot;cs.ATG&quot; 
+#line  1114 &quot;cs.ATG&quot; 
 out stmt);
 				} else if (la.kind == 10) {
 					lexer.NextToken();
 				} else SynErr(146);
 
-#line  1096 &quot;cs.ATG&quot; 
+#line  1116 &quot;cs.ATG&quot; 
 				OperatorDeclarator operatorDeclarator = new OperatorDeclarator(secondType != null ? OperatorType.Binary : OperatorType.Unary, 
 				                                                              type,
 				                                                              op.kind,
@@ -2000,43 +2029,43 @@
 				compilationUnit.AddChild(operatorDeclaration);
 				
 			} else if (
-#line  1109 &quot;cs.ATG&quot; 
+#line  1129 &quot;cs.ATG&quot; 
 IsVarDecl()) {
 
-#line  1109 &quot;cs.ATG&quot; 
+#line  1129 &quot;cs.ATG&quot; 
 				m.Check(Modifier.Fields); 
 				FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
 				fd.StartLocation = startPos; 
 				
 				VariableDeclarator(
-#line  1113 &quot;cs.ATG&quot; 
+#line  1133 &quot;cs.ATG&quot; 
 variableDeclarators);
 				while (la.kind == 12) {
 					lexer.NextToken();
 					VariableDeclarator(
-#line  1114 &quot;cs.ATG&quot; 
+#line  1134 &quot;cs.ATG&quot; 
 variableDeclarators);
 				}
 				Expect(10);
 
-#line  1115 &quot;cs.ATG&quot; 
+#line  1135 &quot;cs.ATG&quot; 
 				fd.EndLocation = t.EndLocation; fd.Fields = variableDeclarators; compilationUnit.AddChild(fd); 
 			} else if (la.kind == 110) {
 
-#line  1118 &quot;cs.ATG&quot; 
+#line  1138 &quot;cs.ATG&quot; 
 				m.Check(Modifier.Indexers); 
 				lexer.NextToken();
 				Expect(16);
 				FormalParameterList(
-#line  1119 &quot;cs.ATG&quot; 
+#line  1139 &quot;cs.ATG&quot; 
 out p);
 				Expect(17);
 
-#line  1119 &quot;cs.ATG&quot; 
+#line  1139 &quot;cs.ATG&quot; 
 				Point endLocation = t.EndLocation; 
 				Expect(14);
 
-#line  1120 &quot;cs.ATG&quot; 
+#line  1140 &quot;cs.ATG&quot; 
 				IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
 				indexer.StartLocation = startPos;
 				indexer.EndLocation   = endLocation;
@@ -2045,11 +2074,11 @@
 				PropertySetRegion setRegion;
 				
 				AccessorDecls(
-#line  1127 &quot;cs.ATG&quot; 
+#line  1147 &quot;cs.ATG&quot; 
 out getRegion, out setRegion);
 				Expect(15);
 
-#line  1128 &quot;cs.ATG&quot; 
+#line  1148 &quot;cs.ATG&quot; 
 				indexer.BodyEnd    = t.EndLocation;
 				indexer.GetRegion = getRegion;
 				indexer.SetRegion = setRegion;
@@ -2057,25 +2086,25 @@
 				
 			} else if (la.kind == 1) {
 				Qualident(
-#line  1133 &quot;cs.ATG&quot; 
+#line  1153 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  1133 &quot;cs.ATG&quot; 
+#line  1153 &quot;cs.ATG&quot; 
 				Point qualIdentEndLocation = t.EndLocation; 
 				if (la.kind == 14 || la.kind == 18) {
 					if (la.kind == 18) {
 
-#line  1136 &quot;cs.ATG&quot; 
+#line  1156 &quot;cs.ATG&quot; 
 						m.Check(Modifier.PropertysEventsMethods); 
 						lexer.NextToken();
 						if (StartOf(9)) {
 							FormalParameterList(
-#line  1137 &quot;cs.ATG&quot; 
+#line  1157 &quot;cs.ATG&quot; 
 out p);
 						}
 						Expect(19);
 
-#line  1137 &quot;cs.ATG&quot; 
+#line  1157 &quot;cs.ATG&quot; 
 						MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
 						                                                     m.Modifier, 
 						                                                     type, 
@@ -2087,18 +2116,18 @@
 						  
 						if (la.kind == 14) {
 							Block(
-#line  1146 &quot;cs.ATG&quot; 
+#line  1166 &quot;cs.ATG&quot; 
 out stmt);
 						} else if (la.kind == 10) {
 							lexer.NextToken();
 						} else SynErr(147);
 
-#line  1146 &quot;cs.ATG&quot; 
+#line  1166 &quot;cs.ATG&quot; 
 						methodDeclaration.Body  = (BlockStatement)stmt; 
 					} else {
 						lexer.NextToken();
 
-#line  1149 &quot;cs.ATG&quot; 
+#line  1169 &quot;cs.ATG&quot; 
 						PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
 						pDecl.StartLocation = startPos;
 						pDecl.EndLocation   = qualIdentEndLocation;
@@ -2107,11 +2136,11 @@
 						PropertySetRegion setRegion;
 						
 						AccessorDecls(
-#line  1156 &quot;cs.ATG&quot; 
+#line  1176 &quot;cs.ATG&quot; 
 out getRegion, out setRegion);
 						Expect(15);
 
-#line  1158 &quot;cs.ATG&quot; 
+#line  1178 &quot;cs.ATG&quot; 
 						pDecl.GetRegion = getRegion;
 						pDecl.SetRegion = setRegion;
 						pDecl.BodyEnd = t.EndLocation;
@@ -2120,17 +2149,17 @@
 					}
 				} else if (la.kind == 13) {
 
-#line  1166 &quot;cs.ATG&quot; 
+#line  1186 &quot;cs.ATG&quot; 
 					m.Check(Modifier.Indexers); 
 					lexer.NextToken();
 					Expect(110);
 					Expect(16);
 					FormalParameterList(
-#line  1167 &quot;cs.ATG&quot; 
+#line  1187 &quot;cs.ATG&quot; 
 out p);
 					Expect(17);
 
-#line  1168 &quot;cs.ATG&quot; 
+#line  1188 &quot;cs.ATG&quot; 
 					IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
 					indexer.StartLocation = startPos;
 					indexer.EndLocation   = t.EndLocation;
@@ -2140,14 +2169,14 @@
 					
 					Expect(14);
 
-#line  1175 &quot;cs.ATG&quot; 
+#line  1195 &quot;cs.ATG&quot; 
 					Point bodyStart = t.Location; 
 					AccessorDecls(
-#line  1176 &quot;cs.ATG&quot; 
+#line  1196 &quot;cs.ATG&quot; 
 out getRegion, out setRegion);
 					Expect(15);
 
-#line  1177 &quot;cs.ATG&quot; 
+#line  1197 &quot;cs.ATG&quot; 
 					indexer.BodyStart = bodyStart;
 					indexer.BodyEnd   = t.EndLocation;
 					indexer.GetRegion = getRegion;
@@ -2161,7 +2190,7 @@
 
 	void InterfaceMemberDecl() {
 
-#line  1204 &quot;cs.ATG&quot; 
+#line  1224 &quot;cs.ATG&quot; 
 		TypeReference type;
 		ArrayList p;
 		AttributeSection section;
@@ -2175,39 +2204,39 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1216 &quot;cs.ATG&quot; 
+#line  1236 &quot;cs.ATG&quot; 
 out section);
 
-#line  1216 &quot;cs.ATG&quot; 
+#line  1236 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (la.kind == 88) {
 			lexer.NextToken();
 
-#line  1217 &quot;cs.ATG&quot; 
+#line  1237 &quot;cs.ATG&quot; 
 			mod = Modifier.New; startLocation = t.Location; 
 		}
 		if (
-#line  1220 &quot;cs.ATG&quot; 
+#line  1240 &quot;cs.ATG&quot; 
 NotVoidPointer()) {
 			Expect(122);
 
-#line  1220 &quot;cs.ATG&quot; 
+#line  1240 &quot;cs.ATG&quot; 
 			if (startLocation.X == -1) startLocation = t.Location; 
 			Expect(1);
 
-#line  1220 &quot;cs.ATG&quot; 
+#line  1240 &quot;cs.ATG&quot; 
 			name = t.val; 
 			Expect(18);
 			if (StartOf(9)) {
 				FormalParameterList(
-#line  1221 &quot;cs.ATG&quot; 
+#line  1241 &quot;cs.ATG&quot; 
 out parameters);
 			}
 			Expect(19);
 			Expect(10);
 
-#line  1221 &quot;cs.ATG&quot; 
+#line  1241 &quot;cs.ATG&quot; 
 			MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference(&quot;void&quot;), parameters, attributes);
 			md.StartLocation = startLocation;
 			md.EndLocation = t.EndLocation;
@@ -2216,27 +2245,27 @@
 		} else if (StartOf(18)) {
 			if (StartOf(8)) {
 				Type(
-#line  1227 &quot;cs.ATG&quot; 
+#line  1247 &quot;cs.ATG&quot; 
 out type);
 
-#line  1227 &quot;cs.ATG&quot; 
+#line  1247 &quot;cs.ATG&quot; 
 				if (startLocation.X == -1) startLocation = t.Location; 
 				if (la.kind == 1) {
 					lexer.NextToken();
 
-#line  1229 &quot;cs.ATG&quot; 
+#line  1249 &quot;cs.ATG&quot; 
 					name = t.val; Point qualIdentEndLocation = t.EndLocation; 
 					if (la.kind == 18) {
 						lexer.NextToken();
 						if (StartOf(9)) {
 							FormalParameterList(
-#line  1232 &quot;cs.ATG&quot; 
+#line  1252 &quot;cs.ATG&quot; 
 out parameters);
 						}
 						Expect(19);
 						Expect(10);
 
-#line  1232 &quot;cs.ATG&quot; 
+#line  1252 &quot;cs.ATG&quot; 
 						MethodDeclaration md = new MethodDeclaration(name, mod, type, parameters, attributes);
 						md.StartLocation = startLocation;
 						md.EndLocation = t.EndLocation;
@@ -2244,72 +2273,72 @@
 						
 					} else if (la.kind == 14) {
 
-#line  1238 &quot;cs.ATG&quot; 
+#line  1258 &quot;cs.ATG&quot; 
 						PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); 
 						lexer.NextToken();
 
-#line  1239 &quot;cs.ATG&quot; 
+#line  1259 &quot;cs.ATG&quot; 
 						Point bodyStart = t.Location;
 						InterfaceAccessors(
-#line  1239 &quot;cs.ATG&quot; 
+#line  1259 &quot;cs.ATG&quot; 
 out getBlock, out setBlock);
 						Expect(15);
 
-#line  1239 &quot;cs.ATG&quot; 
+#line  1259 &quot;cs.ATG&quot; 
 						pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; 
 					} else SynErr(151);
 				} else if (la.kind == 110) {
 					lexer.NextToken();
 					Expect(16);
 					FormalParameterList(
-#line  1242 &quot;cs.ATG&quot; 
+#line  1262 &quot;cs.ATG&quot; 
 out p);
 					Expect(17);
 
-#line  1242 &quot;cs.ATG&quot; 
+#line  1262 &quot;cs.ATG&quot; 
 					Point bracketEndLocation = t.EndLocation; 
 
-#line  1242 &quot;cs.ATG&quot; 
+#line  1262 &quot;cs.ATG&quot; 
 					IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); 
 					Expect(14);
 
-#line  1243 &quot;cs.ATG&quot; 
+#line  1263 &quot;cs.ATG&quot; 
 					Point bodyStart = t.Location;
 					InterfaceAccessors(
-#line  1243 &quot;cs.ATG&quot; 
+#line  1263 &quot;cs.ATG&quot; 
 out getBlock, out setBlock);
 					Expect(15);
 
-#line  1243 &quot;cs.ATG&quot; 
+#line  1263 &quot;cs.ATG&quot; 
 					id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;
 				} else SynErr(152);
 			} else {
 				lexer.NextToken();
 
-#line  1246 &quot;cs.ATG&quot; 
+#line  1266 &quot;cs.ATG&quot; 
 				if (startLocation.X == -1) startLocation = t.Location; 
 				Type(
-#line  1246 &quot;cs.ATG&quot; 
+#line  1266 &quot;cs.ATG&quot; 
 out type);
 				Expect(1);
 
-#line  1246 &quot;cs.ATG&quot; 
+#line  1266 &quot;cs.ATG&quot; 
 				EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
 				compilationUnit.AddChild(ed);
 				
 				Expect(10);
 
-#line  1249 &quot;cs.ATG&quot; 
+#line  1269 &quot;cs.ATG&quot; 
 				ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; 
 			}
 		} else SynErr(153);
 	}
 
 	void EnumMemberDecl(
-#line  1254 &quot;cs.ATG&quot; 
+#line  1274 &quot;cs.ATG&quot; 
 out FieldDeclaration f) {
 
-#line  1256 &quot;cs.ATG&quot; 
+#line  1276 &quot;cs.ATG&quot; 
 		Expression expr = null;
 		ArrayList attributes = new ArrayList();
 		AttributeSection section = null;
@@ -2317,15 +2346,15 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1262 &quot;cs.ATG&quot; 
+#line  1282 &quot;cs.ATG&quot; 
 out section);
 
-#line  1262 &quot;cs.ATG&quot; 
+#line  1282 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		Expect(1);
 
-#line  1263 &quot;cs.ATG&quot; 
+#line  1283 &quot;cs.ATG&quot; 
 		f = new FieldDeclaration(attributes);
 		varDecl         = new VariableDeclaration(t.val);
 		f.Fields.Add(varDecl);
@@ -2334,89 +2363,89 @@
 		if (la.kind == 3) {
 			lexer.NextToken();
 			Expr(
-#line  1268 &quot;cs.ATG&quot; 
+#line  1288 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1268 &quot;cs.ATG&quot; 
+#line  1288 &quot;cs.ATG&quot; 
 			varDecl.Initializer = expr; 
 		}
 	}
 
 	void SimpleType(
-#line  864 &quot;cs.ATG&quot; 
+#line  884 &quot;cs.ATG&quot; 
 out string name) {
 
-#line  865 &quot;cs.ATG&quot; 
+#line  885 &quot;cs.ATG&quot; 
 		name = String.Empty; 
 		if (StartOf(19)) {
 			IntegralType(
-#line  867 &quot;cs.ATG&quot; 
+#line  887 &quot;cs.ATG&quot; 
 out name);
 		} else if (la.kind == 74) {
 			lexer.NextToken();
 
-#line  868 &quot;cs.ATG&quot; 
+#line  888 &quot;cs.ATG&quot; 
 			name = t.val; 
 		} else if (la.kind == 65) {
 			lexer.NextToken();
 
-#line  869 &quot;cs.ATG&quot; 
+#line  889 &quot;cs.ATG&quot; 
 			name = t.val; 
 		} else if (la.kind == 61) {
 			lexer.NextToken();
 
-#line  870 &quot;cs.ATG&quot; 
+#line  890 &quot;cs.ATG&quot; 
 			name = t.val; 
 		} else if (la.kind == 51) {
 			lexer.NextToken();
 
-#line  871 &quot;cs.ATG&quot; 
+#line  891 &quot;cs.ATG&quot; 
 			name = t.val; 
 		} else SynErr(154);
 	}
 
 	void NonArrayType(
-#line  846 &quot;cs.ATG&quot; 
+#line  866 &quot;cs.ATG&quot; 
 out TypeReference type) {
 
-#line  848 &quot;cs.ATG&quot; 
+#line  868 &quot;cs.ATG&quot; 
 		string name = &quot;&quot;;
 		int pointer = 0;
 		
 		if (la.kind == 1 || la.kind == 90 || la.kind == 107) {
 			ClassType(
-#line  852 &quot;cs.ATG&quot; 
+#line  872 &quot;cs.ATG&quot; 
 out name);
 		} else if (StartOf(14)) {
 			SimpleType(
-#line  853 &quot;cs.ATG&quot; 
+#line  873 &quot;cs.ATG&quot; 
 out name);
 		} else if (la.kind == 122) {
 			lexer.NextToken();
 			Expect(6);
 
-#line  854 &quot;cs.ATG&quot; 
+#line  874 &quot;cs.ATG&quot; 
 			pointer = 1; name = &quot;void&quot;; 
 		} else SynErr(155);
 		while (
-#line  856 &quot;cs.ATG&quot; 
+#line  876 &quot;cs.ATG&quot; 
 IsPointer()) {
 			Expect(6);
 
-#line  857 &quot;cs.ATG&quot; 
+#line  877 &quot;cs.ATG&quot; 
 			++pointer; 
 		}
 
-#line  860 &quot;cs.ATG&quot; 
+#line  880 &quot;cs.ATG&quot; 
 		type = new TypeReference(name, pointer, null);
 		
 	}
 
 	void FixedParameter(
-#line  901 &quot;cs.ATG&quot; 
+#line  921 &quot;cs.ATG&quot; 
 out ParameterDeclarationExpression p) {
 
-#line  903 &quot;cs.ATG&quot; 
+#line  923 &quot;cs.ATG&quot; 
 		TypeReference type;
 		ParamModifiers mod = ParamModifiers.In;
 		
@@ -2424,72 +2453,72 @@
 			if (la.kind == 99) {
 				lexer.NextToken();
 
-#line  908 &quot;cs.ATG&quot; 
+#line  928 &quot;cs.ATG&quot; 
 				mod = ParamModifiers.Ref; 
 			} else {
 				lexer.NextToken();
 
-#line  909 &quot;cs.ATG&quot; 
+#line  929 &quot;cs.ATG&quot; 
 				mod = ParamModifiers.Out; 
 			}
 		}
 		Type(
-#line  911 &quot;cs.ATG&quot; 
+#line  931 &quot;cs.ATG&quot; 
 out type);
 		Expect(1);
 
-#line  911 &quot;cs.ATG&quot; 
+#line  931 &quot;cs.ATG&quot; 
 		p = new ParameterDeclarationExpression(type, t.val, mod); 
 	}
 
 	void ParameterArray(
-#line  914 &quot;cs.ATG&quot; 
+#line  934 &quot;cs.ATG&quot; 
 out ParameterDeclarationExpression p) {
 
-#line  915 &quot;cs.ATG&quot; 
+#line  935 &quot;cs.ATG&quot; 
 		TypeReference type; 
 		Expect(94);
 		Type(
-#line  917 &quot;cs.ATG&quot; 
+#line  937 &quot;cs.ATG&quot; 
 out type);
 		Expect(1);
 
-#line  917 &quot;cs.ATG&quot; 
+#line  937 &quot;cs.ATG&quot; 
 		p = new ParameterDeclarationExpression(type, t.val, ParamModifiers.Params); 
 	}
 
 	void AccessorModifier(
-#line  971 &quot;cs.ATG&quot; 
+#line  991 &quot;cs.ATG&quot; 
 Modifiers m) {
 		if (la.kind == 83) {
 			lexer.NextToken();
 
-#line  973 &quot;cs.ATG&quot; 
+#line  993 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Internal); 
 		} else if (la.kind == 97) {
 			lexer.NextToken();
 
-#line  974 &quot;cs.ATG&quot; 
+#line  994 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Public); 
 		} else if (la.kind == 96) {
 			lexer.NextToken();
 
-#line  975 &quot;cs.ATG&quot; 
+#line  995 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Protected); 
 		} else if (la.kind == 95) {
 			lexer.NextToken();
 
-#line  976 &quot;cs.ATG&quot; 
+#line  996 &quot;cs.ATG&quot; 
 			m.Add(Modifier.Private); 
 		} else SynErr(156);
 	}
 
 	void Block(
-#line  1376 &quot;cs.ATG&quot; 
+#line  1396 &quot;cs.ATG&quot; 
 out Statement stmt) {
 		Expect(14);
 
-#line  1378 &quot;cs.ATG&quot; 
+#line  1398 &quot;cs.ATG&quot; 
 		BlockStatement blockStmt = new BlockStatement();
 		blockStmt.StartLocation = t.Location;
 		compilationUnit.BlockStart(blockStmt);
@@ -2499,7 +2528,7 @@
 		}
 		Expect(15);
 
-#line  1383 &quot;cs.ATG&quot; 
+#line  1403 &quot;cs.ATG&quot; 
 		stmt = blockStmt;
 		blockStmt.EndLocation = t.EndLocation;
 		compilationUnit.BlockEnd();
@@ -2507,34 +2536,34 @@
 	}
 
 	void VariableDeclarator(
-#line  1369 &quot;cs.ATG&quot; 
+#line  1389 &quot;cs.ATG&quot; 
 ArrayList fieldDeclaration) {
 
-#line  1370 &quot;cs.ATG&quot; 
+#line  1390 &quot;cs.ATG&quot; 
 		Expression expr = null; 
 		Expect(1);
 
-#line  1372 &quot;cs.ATG&quot; 
+#line  1392 &quot;cs.ATG&quot; 
 		VariableDeclaration f = new VariableDeclaration(t.val); 
 		if (la.kind == 3) {
 			lexer.NextToken();
 			VariableInitializer(
-#line  1373 &quot;cs.ATG&quot; 
+#line  1393 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1373 &quot;cs.ATG&quot; 
+#line  1393 &quot;cs.ATG&quot; 
 			f.Initializer = expr; 
 		}
 
-#line  1373 &quot;cs.ATG&quot; 
+#line  1393 &quot;cs.ATG&quot; 
 		fieldDeclaration.Add(f); 
 	}
 
 	void EventAccessorDecls(
-#line  1318 &quot;cs.ATG&quot; 
+#line  1338 &quot;cs.ATG&quot; 
 out EventAddRegion addBlock, out EventRemoveRegion removeBlock) {
 
-#line  1319 &quot;cs.ATG&quot; 
+#line  1339 &quot;cs.ATG&quot; 
 		AttributeSection section;
 		ArrayList attributes = new ArrayList();
 		Statement stmt;
@@ -2543,102 +2572,102 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1326 &quot;cs.ATG&quot; 
+#line  1346 &quot;cs.ATG&quot; 
 out section);
 
-#line  1326 &quot;cs.ATG&quot; 
+#line  1346 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (
-#line  1328 &quot;cs.ATG&quot; 
+#line  1348 &quot;cs.ATG&quot; 
 IdentIsAdd()) {
 
-#line  1328 &quot;cs.ATG&quot; 
+#line  1348 &quot;cs.ATG&quot; 
 			addBlock = new EventAddRegion(attributes); 
 			AddAccessorDecl(
-#line  1329 &quot;cs.ATG&quot; 
+#line  1349 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1329 &quot;cs.ATG&quot; 
+#line  1349 &quot;cs.ATG&quot; 
 			attributes = new ArrayList(); addBlock.Block = (BlockStatement)stmt; 
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1330 &quot;cs.ATG&quot; 
+#line  1350 &quot;cs.ATG&quot; 
 out section);
 
-#line  1330 &quot;cs.ATG&quot; 
+#line  1350 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			RemoveAccessorDecl(
-#line  1331 &quot;cs.ATG&quot; 
+#line  1351 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1331 &quot;cs.ATG&quot; 
+#line  1351 &quot;cs.ATG&quot; 
 			removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; 
 		} else if (
-#line  1332 &quot;cs.ATG&quot; 
+#line  1352 &quot;cs.ATG&quot; 
 IdentIsRemove()) {
 			RemoveAccessorDecl(
-#line  1333 &quot;cs.ATG&quot; 
+#line  1353 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1333 &quot;cs.ATG&quot; 
+#line  1353 &quot;cs.ATG&quot; 
 			removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new ArrayList(); 
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1334 &quot;cs.ATG&quot; 
+#line  1354 &quot;cs.ATG&quot; 
 out section);
 
-#line  1334 &quot;cs.ATG&quot; 
+#line  1354 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			AddAccessorDecl(
-#line  1335 &quot;cs.ATG&quot; 
+#line  1355 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1335 &quot;cs.ATG&quot; 
+#line  1355 &quot;cs.ATG&quot; 
 			addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; 
 		} else if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1336 &quot;cs.ATG&quot; 
+#line  1356 &quot;cs.ATG&quot; 
 			Error(&quot;add or remove accessor declaration expected&quot;); 
 		} else SynErr(157);
 	}
 
 	void ConstructorInitializer(
-#line  1405 &quot;cs.ATG&quot; 
+#line  1425 &quot;cs.ATG&quot; 
 out ConstructorInitializer ci) {
 
-#line  1406 &quot;cs.ATG&quot; 
+#line  1426 &quot;cs.ATG&quot; 
 		Expression expr; ci = new ConstructorInitializer(); 
 		Expect(9);
 		if (la.kind == 50) {
 			lexer.NextToken();
 
-#line  1410 &quot;cs.ATG&quot; 
+#line  1430 &quot;cs.ATG&quot; 
 			ci.ConstructorInitializerType = ConstructorInitializerType.Base; 
 		} else if (la.kind == 110) {
 			lexer.NextToken();
 
-#line  1411 &quot;cs.ATG&quot; 
+#line  1431 &quot;cs.ATG&quot; 
 			ci.ConstructorInitializerType = ConstructorInitializerType.This; 
 		} else SynErr(158);
 		Expect(18);
 		if (StartOf(21)) {
 			Argument(
-#line  1414 &quot;cs.ATG&quot; 
+#line  1434 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1414 &quot;cs.ATG&quot; 
+#line  1434 &quot;cs.ATG&quot; 
 			ci.Arguments.Add(expr); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Argument(
-#line  1414 &quot;cs.ATG&quot; 
+#line  1434 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1414 &quot;cs.ATG&quot; 
+#line  1434 &quot;cs.ATG&quot; 
 				ci.Arguments.Add(expr); 
 			}
 		}
@@ -2646,7 +2675,7 @@
 	}
 
 	void OverloadableOperator(
-#line  1426 &quot;cs.ATG&quot; 
+#line  1446 &quot;cs.ATG&quot; 
 out Token op) {
 		switch (la.kind) {
 		case 4: {
@@ -2740,15 +2769,15 @@
 		default: SynErr(159); break;
 		}
 
-#line  1435 &quot;cs.ATG&quot; 
+#line  1455 &quot;cs.ATG&quot; 
 		op = t; 
 	}
 
 	void AccessorDecls(
-#line  1272 &quot;cs.ATG&quot; 
+#line  1292 &quot;cs.ATG&quot; 
 out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
 
-#line  1274 &quot;cs.ATG&quot; 
+#line  1294 &quot;cs.ATG&quot; 
 		ArrayList attributes = new ArrayList(); 
 		Modifiers m = new Modifiers (this);
 		AttributeSection section;
@@ -2757,151 +2786,151 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1281 &quot;cs.ATG&quot; 
+#line  1301 &quot;cs.ATG&quot; 
 out section);
 
-#line  1281 &quot;cs.ATG&quot; 
+#line  1301 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		while (StartOf(22)) {
 			AccessorModifier(
-#line  1282 &quot;cs.ATG&quot; 
+#line  1302 &quot;cs.ATG&quot; 
 m);
 		}
 		if (
-#line  1284 &quot;cs.ATG&quot; 
+#line  1304 &quot;cs.ATG&quot; 
 IdentIsGet()) {
 			GetAccessorDecl(
-#line  1285 &quot;cs.ATG&quot; 
+#line  1305 &quot;cs.ATG&quot; 
 out getBlock, attributes, m.Modifier);
 			if (StartOf(23)) {
 
-#line  1286 &quot;cs.ATG&quot; 
+#line  1306 &quot;cs.ATG&quot; 
 				attributes = new ArrayList(); m = new Modifiers (this); 
 				while (la.kind == 16) {
 					AttributeSection(
-#line  1287 &quot;cs.ATG&quot; 
+#line  1307 &quot;cs.ATG&quot; 
 out section);
 
-#line  1287 &quot;cs.ATG&quot; 
+#line  1307 &quot;cs.ATG&quot; 
 					attributes.Add(section); 
 				}
 				while (StartOf(22)) {
 					AccessorModifier(
-#line  1288 &quot;cs.ATG&quot; 
+#line  1308 &quot;cs.ATG&quot; 
 m);
 				}
 				SetAccessorDecl(
-#line  1289 &quot;cs.ATG&quot; 
+#line  1309 &quot;cs.ATG&quot; 
 out setBlock, attributes, m.Modifier);
 			}
 		} else if (
-#line  1291 &quot;cs.ATG&quot; 
+#line  1311 &quot;cs.ATG&quot; 
 IdentIsSet()) {
 			SetAccessorDecl(
-#line  1292 &quot;cs.ATG&quot; 
+#line  1312 &quot;cs.ATG&quot; 
 out setBlock, attributes, m.Modifier);
 			if (StartOf(23)) {
 
-#line  1293 &quot;cs.ATG&quot; 
+#line  1313 &quot;cs.ATG&quot; 
 				attributes = new ArrayList(); m = new Modifiers (this); 
 				while (la.kind == 16) {
 					AttributeSection(
-#line  1294 &quot;cs.ATG&quot; 
+#line  1314 &quot;cs.ATG&quot; 
 out section);
 
-#line  1294 &quot;cs.ATG&quot; 
+#line  1314 &quot;cs.ATG&quot; 
 					attributes.Add(section); 
 				}
 				while (StartOf(22)) {
 					AccessorModifier(
-#line  1295 &quot;cs.ATG&quot; 
+#line  1315 &quot;cs.ATG&quot; 
 m);
 				}
 				GetAccessorDecl(
-#line  1296 &quot;cs.ATG&quot; 
+#line  1316 &quot;cs.ATG&quot; 
 out getBlock, attributes, m.Modifier);
 			}
 		} else if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1298 &quot;cs.ATG&quot; 
+#line  1318 &quot;cs.ATG&quot; 
 			Error(&quot;get or set accessor declaration expected&quot;); 
 		} else SynErr(160);
 	}
 
 	void InterfaceAccessors(
-#line  1340 &quot;cs.ATG&quot; 
+#line  1360 &quot;cs.ATG&quot; 
 out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
 
-#line  1342 &quot;cs.ATG&quot; 
+#line  1362 &quot;cs.ATG&quot; 
 		AttributeSection section;
 		ArrayList attributes = new ArrayList();
 		getBlock = null; setBlock = null;
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1347 &quot;cs.ATG&quot; 
+#line  1367 &quot;cs.ATG&quot; 
 out section);
 
-#line  1347 &quot;cs.ATG&quot; 
+#line  1367 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (
-#line  1349 &quot;cs.ATG&quot; 
+#line  1369 &quot;cs.ATG&quot; 
 IdentIsGet()) {
 			Expect(1);
 
-#line  1349 &quot;cs.ATG&quot; 
+#line  1369 &quot;cs.ATG&quot; 
 			getBlock = new PropertyGetRegion(null, attributes); 
 		} else if (
-#line  1350 &quot;cs.ATG&quot; 
+#line  1370 &quot;cs.ATG&quot; 
 IdentIsSet()) {
 			Expect(1);
 
-#line  1350 &quot;cs.ATG&quot; 
+#line  1370 &quot;cs.ATG&quot; 
 			setBlock = new PropertySetRegion(null, attributes); 
 		} else if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1351 &quot;cs.ATG&quot; 
+#line  1371 &quot;cs.ATG&quot; 
 			Error(&quot;set or get expected&quot;); 
 		} else SynErr(161);
 		Expect(10);
 
-#line  1353 &quot;cs.ATG&quot; 
+#line  1373 &quot;cs.ATG&quot; 
 		attributes = new ArrayList(); 
 		if (la.kind == 1 || la.kind == 16) {
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1355 &quot;cs.ATG&quot; 
+#line  1375 &quot;cs.ATG&quot; 
 out section);
 
-#line  1355 &quot;cs.ATG&quot; 
+#line  1375 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			if (
-#line  1357 &quot;cs.ATG&quot; 
+#line  1377 &quot;cs.ATG&quot; 
 IdentIsGet()) {
 				Expect(1);
 
-#line  1357 &quot;cs.ATG&quot; 
+#line  1377 &quot;cs.ATG&quot; 
 				if (getBlock != null) Error(&quot;get already declared&quot;);
 				else getBlock = new PropertyGetRegion(null, attributes);
 				
 			} else if (
-#line  1360 &quot;cs.ATG&quot; 
+#line  1380 &quot;cs.ATG&quot; 
 IdentIsSet()) {
 				Expect(1);
 
-#line  1360 &quot;cs.ATG&quot; 
+#line  1380 &quot;cs.ATG&quot; 
 				if (setBlock != null) Error(&quot;set already declared&quot;);
 				else setBlock = new PropertySetRegion(null, attributes);
 				
 			} else if (la.kind == 1) {
 				lexer.NextToken();
 
-#line  1363 &quot;cs.ATG&quot; 
+#line  1383 &quot;cs.ATG&quot; 
 				Error(&quot;set or get expected&quot;); 
 			} else SynErr(162);
 			Expect(10);
@@ -2909,187 +2938,187 @@
 	}
 
 	void GetAccessorDecl(
-#line  1302 &quot;cs.ATG&quot; 
+#line  1322 &quot;cs.ATG&quot; 
 out PropertyGetRegion getBlock, ArrayList attributes, Modifier m) {
 
-#line  1303 &quot;cs.ATG&quot; 
+#line  1323 &quot;cs.ATG&quot; 
 		Statement stmt = null; 
 		Expect(1);
 
-#line  1306 &quot;cs.ATG&quot; 
+#line  1326 &quot;cs.ATG&quot; 
 		if (t.val != &quot;get&quot;) Error(&quot;get expected&quot;); 
 		if (la.kind == 14) {
 			Block(
-#line  1307 &quot;cs.ATG&quot; 
+#line  1327 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 		} else SynErr(163);
 
-#line  1307 &quot;cs.ATG&quot; 
+#line  1327 &quot;cs.ATG&quot; 
 		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes, m); 
 	}
 
 	void SetAccessorDecl(
-#line  1310 &quot;cs.ATG&quot; 
+#line  1330 &quot;cs.ATG&quot; 
 out PropertySetRegion setBlock, ArrayList attributes, Modifier m) {
 
-#line  1311 &quot;cs.ATG&quot; 
+#line  1331 &quot;cs.ATG&quot; 
 		Statement stmt = null; 
 		Expect(1);
 
-#line  1314 &quot;cs.ATG&quot; 
+#line  1334 &quot;cs.ATG&quot; 
 		if (t.val != &quot;set&quot;) Error(&quot;set expected&quot;); 
 		if (la.kind == 14) {
 			Block(
-#line  1315 &quot;cs.ATG&quot; 
+#line  1335 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 		} else SynErr(164);
 
-#line  1315 &quot;cs.ATG&quot; 
+#line  1335 &quot;cs.ATG&quot; 
 		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes, m); 
 	}
 
 	void AddAccessorDecl(
-#line  1389 &quot;cs.ATG&quot; 
+#line  1409 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1390 &quot;cs.ATG&quot; 
+#line  1410 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expect(1);
 
-#line  1393 &quot;cs.ATG&quot; 
+#line  1413 &quot;cs.ATG&quot; 
 		if (t.val != &quot;add&quot;) Error(&quot;add expected&quot;); 
 		Block(
-#line  1394 &quot;cs.ATG&quot; 
+#line  1414 &quot;cs.ATG&quot; 
 out stmt);
 	}
 
 	void RemoveAccessorDecl(
-#line  1397 &quot;cs.ATG&quot; 
+#line  1417 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1398 &quot;cs.ATG&quot; 
+#line  1418 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expect(1);
 
-#line  1401 &quot;cs.ATG&quot; 
+#line  1421 &quot;cs.ATG&quot; 
 		if (t.val != &quot;remove&quot;) Error(&quot;remove expected&quot;); 
 		Block(
-#line  1402 &quot;cs.ATG&quot; 
+#line  1422 &quot;cs.ATG&quot; 
 out stmt);
 	}
 
 	void VariableInitializer(
-#line  1418 &quot;cs.ATG&quot; 
+#line  1438 &quot;cs.ATG&quot; 
 out Expression initializerExpression) {
 
-#line  1419 &quot;cs.ATG&quot; 
+#line  1439 &quot;cs.ATG&quot; 
 		TypeReference type = null; Expression expr = null; initializerExpression = null; 
 		if (StartOf(4)) {
 			Expr(
-#line  1421 &quot;cs.ATG&quot; 
+#line  1441 &quot;cs.ATG&quot; 
 out initializerExpression);
 		} else if (la.kind == 14) {
 			ArrayInitializer(
-#line  1422 &quot;cs.ATG&quot; 
+#line  1442 &quot;cs.ATG&quot; 
 out initializerExpression);
 		} else if (la.kind == 105) {
 			lexer.NextToken();
 			Type(
-#line  1423 &quot;cs.ATG&quot; 
+#line  1443 &quot;cs.ATG&quot; 
 out type);
 			Expect(16);
 			Expr(
-#line  1423 &quot;cs.ATG&quot; 
+#line  1443 &quot;cs.ATG&quot; 
 out expr);
 			Expect(17);
 
-#line  1423 &quot;cs.ATG&quot; 
+#line  1443 &quot;cs.ATG&quot; 
 			initializerExpression = new StackAllocExpression(type, expr); 
 		} else SynErr(165);
 	}
 
 	void Statement() {
 
-#line  1506 &quot;cs.ATG&quot; 
+#line  1526 &quot;cs.ATG&quot; 
 		TypeReference type;
 		Expression expr;
 		Statement stmt;
 		
 		if (
-#line  1512 &quot;cs.ATG&quot; 
+#line  1532 &quot;cs.ATG&quot; 
 IsLabel()) {
 			Expect(1);
 
-#line  1512 &quot;cs.ATG&quot; 
+#line  1532 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(new LabelStatement(t.val)); 
 			Expect(9);
 			Statement();
 		} else if (la.kind == 59) {
 			lexer.NextToken();
 			Type(
-#line  1515 &quot;cs.ATG&quot; 
+#line  1535 &quot;cs.ATG&quot; 
 out type);
 
-#line  1515 &quot;cs.ATG&quot; 
+#line  1535 &quot;cs.ATG&quot; 
 			LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifier.Const); string ident = null; var.StartLocation = t.Location; 
 			Expect(1);
 
-#line  1516 &quot;cs.ATG&quot; 
+#line  1536 &quot;cs.ATG&quot; 
 			ident = t.val; 
 			Expect(3);
 			Expr(
-#line  1517 &quot;cs.ATG&quot; 
+#line  1537 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1517 &quot;cs.ATG&quot; 
+#line  1537 &quot;cs.ATG&quot; 
 			var.Variables.Add(new VariableDeclaration(ident, expr)); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1518 &quot;cs.ATG&quot; 
+#line  1538 &quot;cs.ATG&quot; 
 				ident = t.val; 
 				Expect(3);
 				Expr(
-#line  1518 &quot;cs.ATG&quot; 
+#line  1538 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1518 &quot;cs.ATG&quot; 
+#line  1538 &quot;cs.ATG&quot; 
 				var.Variables.Add(new VariableDeclaration(ident, expr)); 
 			}
 			Expect(10);
 
-#line  1519 &quot;cs.ATG&quot; 
+#line  1539 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(var); 
 		} else if (
-#line  1521 &quot;cs.ATG&quot; 
+#line  1541 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1521 &quot;cs.ATG&quot; 
+#line  1541 &quot;cs.ATG&quot; 
 out stmt);
 			Expect(10);
 
-#line  1521 &quot;cs.ATG&quot; 
+#line  1541 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(stmt); 
 		} else if (StartOf(24)) {
 			EmbeddedStatement(
-#line  1522 &quot;cs.ATG&quot; 
+#line  1542 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1522 &quot;cs.ATG&quot; 
+#line  1542 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(stmt); 
 		} else SynErr(166);
 	}
 
 	void Argument(
-#line  1438 &quot;cs.ATG&quot; 
+#line  1458 &quot;cs.ATG&quot; 
 out Expression argumentexpr) {
 
-#line  1440 &quot;cs.ATG&quot; 
+#line  1460 &quot;cs.ATG&quot; 
 		Expression expr;
 		FieldDirection fd = FieldDirection.None;
 		
@@ -3097,48 +3126,48 @@
 			if (la.kind == 99) {
 				lexer.NextToken();
 
-#line  1445 &quot;cs.ATG&quot; 
+#line  1465 &quot;cs.ATG&quot; 
 				fd = FieldDirection.Ref; 
 			} else {
 				lexer.NextToken();
 
-#line  1446 &quot;cs.ATG&quot; 
+#line  1466 &quot;cs.ATG&quot; 
 				fd = FieldDirection.Out; 
 			}
 		}
 		Expr(
-#line  1448 &quot;cs.ATG&quot; 
+#line  1468 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1448 &quot;cs.ATG&quot; 
+#line  1468 &quot;cs.ATG&quot; 
 		argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; 
 	}
 
 	void ArrayInitializer(
-#line  1467 &quot;cs.ATG&quot; 
+#line  1487 &quot;cs.ATG&quot; 
 out Expression outExpr) {
 
-#line  1469 &quot;cs.ATG&quot; 
+#line  1489 &quot;cs.ATG&quot; 
 		Expression expr = null;
 		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
 		
 		Expect(14);
 		if (StartOf(25)) {
 			VariableInitializer(
-#line  1474 &quot;cs.ATG&quot; 
+#line  1494 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1474 &quot;cs.ATG&quot; 
+#line  1494 &quot;cs.ATG&quot; 
 			initializer.CreateExpressions.Add(expr); 
 			while (
-#line  1474 &quot;cs.ATG&quot; 
+#line  1494 &quot;cs.ATG&quot; 
 NotFinalComma()) {
 				Expect(12);
 				VariableInitializer(
-#line  1474 &quot;cs.ATG&quot; 
+#line  1494 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1474 &quot;cs.ATG&quot; 
+#line  1494 &quot;cs.ATG&quot; 
 				initializer.CreateExpressions.Add(expr); 
 			}
 			if (la.kind == 12) {
@@ -3147,91 +3176,91 @@
 		}
 		Expect(15);
 
-#line  1475 &quot;cs.ATG&quot; 
+#line  1495 &quot;cs.ATG&quot; 
 		outExpr = initializer; 
 	}
 
 	void AssignmentOperator(
-#line  1451 &quot;cs.ATG&quot; 
+#line  1471 &quot;cs.ATG&quot; 
 out AssignmentOperatorType op) {
 
-#line  1452 &quot;cs.ATG&quot; 
+#line  1472 &quot;cs.ATG&quot; 
 		op = AssignmentOperatorType.None; 
 		switch (la.kind) {
 		case 3: {
 			lexer.NextToken();
 
-#line  1454 &quot;cs.ATG&quot; 
+#line  1474 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Assign; 
 			break;
 		}
 		case 37: {
 			lexer.NextToken();
 
-#line  1455 &quot;cs.ATG&quot; 
+#line  1475 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Add; 
 			break;
 		}
 		case 38: {
 			lexer.NextToken();
 
-#line  1456 &quot;cs.ATG&quot; 
+#line  1476 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Subtract; 
 			break;
 		}
 		case 39: {
 			lexer.NextToken();
 
-#line  1457 &quot;cs.ATG&quot; 
+#line  1477 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Multiply; 
 			break;
 		}
 		case 40: {
 			lexer.NextToken();
 
-#line  1458 &quot;cs.ATG&quot; 
+#line  1478 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Divide; 
 			break;
 		}
 		case 41: {
 			lexer.NextToken();
 
-#line  1459 &quot;cs.ATG&quot; 
+#line  1479 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Modulus; 
 			break;
 		}
 		case 42: {
 			lexer.NextToken();
 
-#line  1460 &quot;cs.ATG&quot; 
+#line  1480 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.BitwiseAnd; 
 			break;
 		}
 		case 43: {
 			lexer.NextToken();
 
-#line  1461 &quot;cs.ATG&quot; 
+#line  1481 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.BitwiseOr; 
 			break;
 		}
 		case 44: {
 			lexer.NextToken();
 
-#line  1462 &quot;cs.ATG&quot; 
+#line  1482 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ExclusiveOr; 
 			break;
 		}
 		case 45: {
 			lexer.NextToken();
 
-#line  1463 &quot;cs.ATG&quot; 
+#line  1483 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ShiftLeft; 
 			break;
 		}
 		case 46: {
 			lexer.NextToken();
 
-#line  1464 &quot;cs.ATG&quot; 
+#line  1484 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ShiftRight; 
 			break;
 		}
@@ -3240,83 +3269,83 @@
 	}
 
 	void LocalVariableDecl(
-#line  1478 &quot;cs.ATG&quot; 
+#line  1498 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1480 &quot;cs.ATG&quot; 
+#line  1500 &quot;cs.ATG&quot; 
 		TypeReference type;
 		VariableDeclaration      var = null;
 		LocalVariableDeclaration localVariableDeclaration; 
 		
 		Type(
-#line  1485 &quot;cs.ATG&quot; 
+#line  1505 &quot;cs.ATG&quot; 
 out type);
 
-#line  1485 &quot;cs.ATG&quot; 
+#line  1505 &quot;cs.ATG&quot; 
 		localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; 
 		LocalVariableDeclarator(
-#line  1486 &quot;cs.ATG&quot; 
+#line  1506 &quot;cs.ATG&quot; 
 out var);
 
-#line  1486 &quot;cs.ATG&quot; 
+#line  1506 &quot;cs.ATG&quot; 
 		localVariableDeclaration.Variables.Add(var); 
 		while (la.kind == 12) {
 			lexer.NextToken();
 			LocalVariableDeclarator(
-#line  1487 &quot;cs.ATG&quot; 
+#line  1507 &quot;cs.ATG&quot; 
 out var);
 
-#line  1487 &quot;cs.ATG&quot; 
+#line  1507 &quot;cs.ATG&quot; 
 			localVariableDeclaration.Variables.Add(var); 
 		}
 
-#line  1488 &quot;cs.ATG&quot; 
+#line  1508 &quot;cs.ATG&quot; 
 		stmt = localVariableDeclaration; 
 	}
 
 	void LocalVariableDeclarator(
-#line  1491 &quot;cs.ATG&quot; 
+#line  1511 &quot;cs.ATG&quot; 
 out VariableDeclaration var) {
 
-#line  1492 &quot;cs.ATG&quot; 
+#line  1512 &quot;cs.ATG&quot; 
 		Expression expr = null; 
 		Expect(1);
 
-#line  1494 &quot;cs.ATG&quot; 
+#line  1514 &quot;cs.ATG&quot; 
 		var = new VariableDeclaration(t.val); 
 		if (la.kind == 3) {
 			lexer.NextToken();
 			LocalVariableInitializer(
-#line  1494 &quot;cs.ATG&quot; 
+#line  1514 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1494 &quot;cs.ATG&quot; 
+#line  1514 &quot;cs.ATG&quot; 
 			var.Initializer = expr; 
 		}
 	}
 
 	void LocalVariableInitializer(
-#line  1497 &quot;cs.ATG&quot; 
+#line  1517 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1498 &quot;cs.ATG&quot; 
+#line  1518 &quot;cs.ATG&quot; 
 		expr = null; 
 		if (StartOf(4)) {
 			Expr(
-#line  1500 &quot;cs.ATG&quot; 
+#line  1520 &quot;cs.ATG&quot; 
 out expr);
 		} else if (la.kind == 14) {
 			ArrayInitializer(
-#line  1501 &quot;cs.ATG&quot; 
+#line  1521 &quot;cs.ATG&quot; 
 out expr);
 		} else SynErr(168);
 	}
 
 	void EmbeddedStatement(
-#line  1528 &quot;cs.ATG&quot; 
+#line  1548 &quot;cs.ATG&quot; 
 out Statement statement) {
 
-#line  1530 &quot;cs.ATG&quot; 
+#line  1550 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		Expression expr = null;
 		Statement embeddedStatement = null;
@@ -3324,161 +3353,177 @@
 		
 		if (la.kind == 14) {
 			Block(
-#line  1536 &quot;cs.ATG&quot; 
+#line  1556 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 
-#line  1538 &quot;cs.ATG&quot; 
+#line  1558 &quot;cs.ATG&quot; 
 			statement = new EmptyStatement(); 
 		} else if (
-#line  1540 &quot;cs.ATG&quot; 
+#line  1560 &quot;cs.ATG&quot; 
+IdentIsYield ()) {
+			Expect(1);
+			if (la.kind == 100) {
+				lexer.NextToken();
+				Expr(
+#line  1561 &quot;cs.ATG&quot; 
+out expr);
+			} else if (la.kind == 52) {
+				lexer.NextToken();
+			} else SynErr(169);
+			Expect(10);
+
+#line  1561 &quot;cs.ATG&quot; 
+			statement = new YieldStatement(expr); 
+		} else if (
+#line  1563 &quot;cs.ATG&quot; 
 UnCheckedAndLBrace()) {
 
-#line  1540 &quot;cs.ATG&quot; 
+#line  1563 &quot;cs.ATG&quot; 
 			Statement block; bool isChecked = true; 
 			if (la.kind == 57) {
 				lexer.NextToken();
 			} else if (la.kind == 117) {
 				lexer.NextToken();
 
-#line  1541 &quot;cs.ATG&quot; 
+#line  1564 &quot;cs.ATG&quot; 
 				isChecked = false;
-			} else SynErr(169);
+			} else SynErr(170);
 			Block(
-#line  1542 &quot;cs.ATG&quot; 
+#line  1565 &quot;cs.ATG&quot; 
 out block);
 
-#line  1542 &quot;cs.ATG&quot; 
+#line  1565 &quot;cs.ATG&quot; 
 			statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); 
 		} else if (StartOf(4)) {
 			StatementExpr(
-#line  1544 &quot;cs.ATG&quot; 
+#line  1567 &quot;cs.ATG&quot; 
 out statement);
 			Expect(10);
 		} else if (la.kind == 78) {
 			lexer.NextToken();
 
-#line  1546 &quot;cs.ATG&quot; 
+#line  1569 &quot;cs.ATG&quot; 
 			Statement elseStatement = null; 
 			Expect(18);
 			Expr(
-#line  1547 &quot;cs.ATG&quot; 
+#line  1570 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1548 &quot;cs.ATG&quot; 
+#line  1571 &quot;cs.ATG&quot; 
 out embeddedStatement);
 			if (la.kind == 66) {
 				lexer.NextToken();
 				EmbeddedStatement(
-#line  1549 &quot;cs.ATG&quot; 
+#line  1572 &quot;cs.ATG&quot; 
 out elseStatement);
 			}
 
-#line  1550 &quot;cs.ATG&quot; 
+#line  1573 &quot;cs.ATG&quot; 
 			statement = elseStatement != null ? (Statement)new IfElseStatement(expr, embeddedStatement, elseStatement) :  (Statement)new IfStatement(expr, embeddedStatement); 
 		} else if (la.kind == 109) {
 			lexer.NextToken();
 
-#line  1551 &quot;cs.ATG&quot; 
+#line  1574 &quot;cs.ATG&quot; 
 			ArrayList switchSections = new ArrayList(); 
 			Expect(18);
 			Expr(
-#line  1552 &quot;cs.ATG&quot; 
+#line  1575 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			Expect(14);
 			while (la.kind == 54 || la.kind == 62) {
 				SwitchSection(
-#line  1553 &quot;cs.ATG&quot; 
+#line  1576 &quot;cs.ATG&quot; 
 out statement);
 
-#line  1553 &quot;cs.ATG&quot; 
+#line  1576 &quot;cs.ATG&quot; 
 				switchSections.Add(statement); 
 			}
 			Expect(15);
 
-#line  1554 &quot;cs.ATG&quot; 
+#line  1577 &quot;cs.ATG&quot; 
 			statement = new SwitchStatement(expr, switchSections); 
 		} else if (la.kind == 124) {
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1556 &quot;cs.ATG&quot; 
+#line  1579 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1557 &quot;cs.ATG&quot; 
+#line  1580 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1557 &quot;cs.ATG&quot; 
+#line  1580 &quot;cs.ATG&quot; 
 			statement = new WhileStatement(expr, embeddedStatement); 
 		} else if (la.kind == 64) {
 			lexer.NextToken();
 			EmbeddedStatement(
-#line  1558 &quot;cs.ATG&quot; 
+#line  1581 &quot;cs.ATG&quot; 
 out embeddedStatement);
 			Expect(124);
 			Expect(18);
 			Expr(
-#line  1559 &quot;cs.ATG&quot; 
+#line  1582 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			Expect(10);
 
-#line  1559 &quot;cs.ATG&quot; 
+#line  1582 &quot;cs.ATG&quot; 
 			statement = new DoWhileStatement(expr, embeddedStatement); 
 		} else if (la.kind == 75) {
 			lexer.NextToken();
 
-#line  1560 &quot;cs.ATG&quot; 
+#line  1583 &quot;cs.ATG&quot; 
 			ArrayList initializer = null, iterator = null; 
 			Expect(18);
 			if (StartOf(4)) {
 				ForInitializer(
-#line  1561 &quot;cs.ATG&quot; 
+#line  1584 &quot;cs.ATG&quot; 
 out initializer);
 			}
 			Expect(10);
 			if (StartOf(4)) {
 				Expr(
-#line  1562 &quot;cs.ATG&quot; 
+#line  1585 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 			if (StartOf(4)) {
 				ForIterator(
-#line  1563 &quot;cs.ATG&quot; 
+#line  1586 &quot;cs.ATG&quot; 
 out iterator);
 			}
 			Expect(19);
 			EmbeddedStatement(
-#line  1564 &quot;cs.ATG&quot; 
+#line  1587 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1564 &quot;cs.ATG&quot; 
+#line  1587 &quot;cs.ATG&quot; 
 			statement = new ForStatement(initializer, expr, iterator, embeddedStatement); 
 		} else if (la.kind == 76) {
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1565 &quot;cs.ATG&quot; 
+#line  1588 &quot;cs.ATG&quot; 
 out type);
 			Expect(1);
 
-#line  1565 &quot;cs.ATG&quot; 
+#line  1588 &quot;cs.ATG&quot; 
 			string varName = t.val; 
 			Expect(80);
 			Expr(
-#line  1566 &quot;cs.ATG&quot; 
+#line  1589 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1567 &quot;cs.ATG&quot; 
+#line  1590 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1567 &quot;cs.ATG&quot; 
+#line  1590 &quot;cs.ATG&quot; 
 			statement = new ForeachStatement(type, varName , expr, embeddedStatement); 
 			statement.EndLocation = t.EndLocation;
 			
@@ -3486,519 +3531,519 @@
 			lexer.NextToken();
 			Expect(10);
 
-#line  1571 &quot;cs.ATG&quot; 
+#line  1594 &quot;cs.ATG&quot; 
 			statement = new BreakStatement(); 
 		} else if (la.kind == 60) {
 			lexer.NextToken();
 			Expect(10);
 
-#line  1572 &quot;cs.ATG&quot; 
+#line  1595 &quot;cs.ATG&quot; 
 			statement = new ContinueStatement(); 
 		} else if (la.kind == 77) {
 			GotoStatement(
-#line  1573 &quot;cs.ATG&quot; 
+#line  1596 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 100) {
 			lexer.NextToken();
 			if (StartOf(4)) {
 				Expr(
-#line  1574 &quot;cs.ATG&quot; 
+#line  1597 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 
-#line  1574 &quot;cs.ATG&quot; 
+#line  1597 &quot;cs.ATG&quot; 
 			statement = new ReturnStatement(expr); 
 		} else if (la.kind == 111) {
 			lexer.NextToken();
 			if (StartOf(4)) {
 				Expr(
-#line  1575 &quot;cs.ATG&quot; 
+#line  1598 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 
-#line  1575 &quot;cs.ATG&quot; 
+#line  1598 &quot;cs.ATG&quot; 
 			statement = new ThrowStatement(expr); 
 		} else if (la.kind == 113) {
 			TryStatement(
-#line  1577 &quot;cs.ATG&quot; 
+#line  1601 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 85) {
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1579 &quot;cs.ATG&quot; 
+#line  1603 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1580 &quot;cs.ATG&quot; 
+#line  1604 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1580 &quot;cs.ATG&quot; 
+#line  1604 &quot;cs.ATG&quot; 
 			statement = new LockStatement(expr, embeddedStatement); 
 		} else if (la.kind == 120) {
 
-#line  1582 &quot;cs.ATG&quot; 
+#line  1606 &quot;cs.ATG&quot; 
 			Statement resourceAcquisitionStmt = null; 
 			lexer.NextToken();
 			Expect(18);
 			ResourceAcquisition(
-#line  1584 &quot;cs.ATG&quot; 
+#line  1608 &quot;cs.ATG&quot; 
 out resourceAcquisitionStmt);
 			Expect(19);
 			EmbeddedStatement(
-#line  1585 &quot;cs.ATG&quot; 
+#line  1609 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1585 &quot;cs.ATG&quot; 
+#line  1609 &quot;cs.ATG&quot; 
 			statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); 
 		} else if (la.kind == 118) {
 			lexer.NextToken();
 			Block(
-#line  1587 &quot;cs.ATG&quot; 
+#line  1611 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1587 &quot;cs.ATG&quot; 
+#line  1611 &quot;cs.ATG&quot; 
 			statement = new UnsafeStatement(embeddedStatement); 
 		} else if (la.kind == 73) {
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1590 &quot;cs.ATG&quot; 
+#line  1614 &quot;cs.ATG&quot; 
 out type);
 
-#line  1590 &quot;cs.ATG&quot; 
+#line  1614 &quot;cs.ATG&quot; 
 			if (type.PointerNestingLevel == 0) Error(&quot;can only fix pointer types&quot;);
 			FixedStatement fxStmt = new FixedStatement(type);
 			string identifier = null;
 			
 			Expect(1);
 
-#line  1594 &quot;cs.ATG&quot; 
+#line  1618 &quot;cs.ATG&quot; 
 			identifier = t.val; 
 			Expect(3);
 			Expr(
-#line  1595 &quot;cs.ATG&quot; 
+#line  1619 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1595 &quot;cs.ATG&quot; 
+#line  1619 &quot;cs.ATG&quot; 
 			fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1597 &quot;cs.ATG&quot; 
+#line  1621 &quot;cs.ATG&quot; 
 				identifier = t.val; 
 				Expect(3);
 				Expr(
-#line  1598 &quot;cs.ATG&quot; 
+#line  1622 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1598 &quot;cs.ATG&quot; 
+#line  1622 &quot;cs.ATG&quot; 
 				fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); 
 			}
 			Expect(19);
 			EmbeddedStatement(
-#line  1600 &quot;cs.ATG&quot; 
+#line  1624 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1600 &quot;cs.ATG&quot; 
+#line  1624 &quot;cs.ATG&quot; 
 			fxStmt.EmbeddedStatement = embeddedStatement; statement = fxStmt;
-		} else SynErr(170);
+		} else SynErr(171);
 	}
 
 	void StatementExpr(
-#line  1708 &quot;cs.ATG&quot; 
+#line  1732 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1713 &quot;cs.ATG&quot; 
+#line  1737 &quot;cs.ATG&quot; 
 		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
 		                       la.kind == Tokens.Not   || la.kind == Tokens.BitwiseComplement ||
 		                       la.kind == Tokens.Times || la.kind == Tokens.BitwiseAnd   || IsTypeCast();
 		Expression expr = null;
 		
 		UnaryExpr(
-#line  1719 &quot;cs.ATG&quot; 
+#line  1743 &quot;cs.ATG&quot; 
 out expr);
 		if (StartOf(6)) {
 
-#line  1722 &quot;cs.ATG&quot; 
+#line  1746 &quot;cs.ATG&quot; 
 			AssignmentOperatorType op; Expression val; 
 			AssignmentOperator(
-#line  1722 &quot;cs.ATG&quot; 
+#line  1746 &quot;cs.ATG&quot; 
 out op);
 			Expr(
-#line  1722 &quot;cs.ATG&quot; 
+#line  1746 &quot;cs.ATG&quot; 
 out val);
 
-#line  1722 &quot;cs.ATG&quot; 
+#line  1746 &quot;cs.ATG&quot; 
 			expr = new AssignmentExpression(expr, op, val); 
 		} else if (la.kind == 10 || la.kind == 12 || la.kind == 19) {
 
-#line  1723 &quot;cs.ATG&quot; 
+#line  1747 &quot;cs.ATG&quot; 
 			if (mustBeAssignment) Error(&quot;error in assignment.&quot;); 
-		} else SynErr(171);
+		} else SynErr(172);
 
-#line  1724 &quot;cs.ATG&quot; 
+#line  1748 &quot;cs.ATG&quot; 
 		stmt = new StatementExpression(expr); 
 	}
 
 	void SwitchSection(
-#line  1622 &quot;cs.ATG&quot; 
+#line  1646 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1624 &quot;cs.ATG&quot; 
+#line  1648 &quot;cs.ATG&quot; 
 		SwitchSection switchSection = new SwitchSection();
 		Expression expr;
 		
 		SwitchLabel(
-#line  1628 &quot;cs.ATG&quot; 
+#line  1652 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1628 &quot;cs.ATG&quot; 
+#line  1652 &quot;cs.ATG&quot; 
 		switchSection.SwitchLabels.Add(expr); 
 		while (la.kind == 54 || la.kind == 62) {
 			SwitchLabel(
-#line  1628 &quot;cs.ATG&quot; 
+#line  1652 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1628 &quot;cs.ATG&quot; 
+#line  1652 &quot;cs.ATG&quot; 
 			switchSection.SwitchLabels.Add(expr); 
 		}
 
-#line  1629 &quot;cs.ATG&quot; 
+#line  1653 &quot;cs.ATG&quot; 
 		compilationUnit.BlockStart(switchSection); 
 		Statement();
 		while (StartOf(20)) {
 			Statement();
 		}
 
-#line  1632 &quot;cs.ATG&quot; 
+#line  1656 &quot;cs.ATG&quot; 
 		compilationUnit.BlockEnd();
 		stmt = switchSection;
 		
 	}
 
 	void ForInitializer(
-#line  1603 &quot;cs.ATG&quot; 
+#line  1627 &quot;cs.ATG&quot; 
 out ArrayList initializer) {
 
-#line  1605 &quot;cs.ATG&quot; 
+#line  1629 &quot;cs.ATG&quot; 
 		Statement stmt; 
 		initializer = new ArrayList();
 		
 		if (
-#line  1609 &quot;cs.ATG&quot; 
+#line  1633 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1609 &quot;cs.ATG&quot; 
+#line  1633 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1609 &quot;cs.ATG&quot; 
+#line  1633 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
 		} else if (StartOf(4)) {
 			StatementExpr(
-#line  1610 &quot;cs.ATG&quot; 
+#line  1634 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1610 &quot;cs.ATG&quot; 
+#line  1634 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
 			while (la.kind == 12) {
 				lexer.NextToken();
 				StatementExpr(
-#line  1610 &quot;cs.ATG&quot; 
+#line  1634 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1610 &quot;cs.ATG&quot; 
+#line  1634 &quot;cs.ATG&quot; 
 				initializer.Add(stmt);
 			}
 
-#line  1610 &quot;cs.ATG&quot; 
+#line  1634 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
-		} else SynErr(172);
+		} else SynErr(173);
 	}
 
 	void ForIterator(
-#line  1613 &quot;cs.ATG&quot; 
+#line  1637 &quot;cs.ATG&quot; 
 out ArrayList iterator) {
 
-#line  1615 &quot;cs.ATG&quot; 
+#line  1639 &quot;cs.ATG&quot; 
 		Statement stmt; 
 		iterator = new ArrayList();
 		
 		StatementExpr(
-#line  1619 &quot;cs.ATG&quot; 
+#line  1643 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1619 &quot;cs.ATG&quot; 
+#line  1643 &quot;cs.ATG&quot; 
 		iterator.Add(stmt);
 		while (la.kind == 12) {
 			lexer.NextToken();
 			StatementExpr(
-#line  1619 &quot;cs.ATG&quot; 
+#line  1643 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1619 &quot;cs.ATG&quot; 
+#line  1643 &quot;cs.ATG&quot; 
 			iterator.Add(stmt); 
 		}
 	}
 
 	void GotoStatement(
-#line  1681 &quot;cs.ATG&quot; 
+#line  1705 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1682 &quot;cs.ATG&quot; 
+#line  1706 &quot;cs.ATG&quot; 
 		Expression expr; stmt = null; 
 		Expect(77);
 		if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1686 &quot;cs.ATG&quot; 
+#line  1710 &quot;cs.ATG&quot; 
 			stmt = new GotoStatement(t.val); 
 			Expect(10);
 		} else if (la.kind == 54) {
 			lexer.NextToken();
 			Expr(
-#line  1687 &quot;cs.ATG&quot; 
+#line  1711 &quot;cs.ATG&quot; 
 out expr);
 			Expect(10);
 
-#line  1687 &quot;cs.ATG&quot; 
+#line  1711 &quot;cs.ATG&quot; 
 			stmt = new GotoCaseStatement(expr); 
 		} else if (la.kind == 62) {
 			lexer.NextToken();
 			Expect(10);
 
-#line  1688 &quot;cs.ATG&quot; 
+#line  1712 &quot;cs.ATG&quot; 
 			stmt = new GotoCaseStatement(null); 
-		} else SynErr(173);
+		} else SynErr(174);
 	}
 
 	void TryStatement(
-#line  1644 &quot;cs.ATG&quot; 
+#line  1668 &quot;cs.ATG&quot; 
 out Statement tryStatement) {
 
-#line  1646 &quot;cs.ATG&quot; 
+#line  1670 &quot;cs.ATG&quot; 
 		Statement blockStmt = null, finallyStmt = null;
 		ArrayList catchClauses = null;
 		
 		Expect(113);
 		Block(
-#line  1650 &quot;cs.ATG&quot; 
+#line  1674 &quot;cs.ATG&quot; 
 out blockStmt);
 		if (la.kind == 55) {
 			CatchClauses(
-#line  1652 &quot;cs.ATG&quot; 
+#line  1676 &quot;cs.ATG&quot; 
 out catchClauses);
 			if (la.kind == 72) {
 				lexer.NextToken();
 				Block(
-#line  1652 &quot;cs.ATG&quot; 
+#line  1676 &quot;cs.ATG&quot; 
 out finallyStmt);
 			}
 		} else if (la.kind == 72) {
 			lexer.NextToken();
 			Block(
-#line  1653 &quot;cs.ATG&quot; 
+#line  1677 &quot;cs.ATG&quot; 
 out finallyStmt);
-		} else SynErr(174);
+		} else SynErr(175);
 
-#line  1656 &quot;cs.ATG&quot; 
+#line  1680 &quot;cs.ATG&quot; 
 		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
 		
 	}
 
 	void ResourceAcquisition(
-#line  1692 &quot;cs.ATG&quot; 
+#line  1716 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1694 &quot;cs.ATG&quot; 
+#line  1718 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expression expr;
 		
 		if (
-#line  1699 &quot;cs.ATG&quot; 
+#line  1723 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1699 &quot;cs.ATG&quot; 
+#line  1723 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (StartOf(4)) {
 			Expr(
-#line  1700 &quot;cs.ATG&quot; 
+#line  1724 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1704 &quot;cs.ATG&quot; 
+#line  1728 &quot;cs.ATG&quot; 
 			stmt = new StatementExpression(expr); 
-		} else SynErr(175);
+		} else SynErr(176);
 	}
 
 	void SwitchLabel(
-#line  1637 &quot;cs.ATG&quot; 
+#line  1661 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1638 &quot;cs.ATG&quot; 
+#line  1662 &quot;cs.ATG&quot; 
 		expr = null; 
 		if (la.kind == 54) {
 			lexer.NextToken();
 			Expr(
-#line  1640 &quot;cs.ATG&quot; 
+#line  1664 &quot;cs.ATG&quot; 
 out expr);
 			Expect(9);
 		} else if (la.kind == 62) {
 			lexer.NextToken();
 			Expect(9);
-		} else SynErr(176);
+		} else SynErr(177);
 	}
 
 	void CatchClauses(
-#line  1661 &quot;cs.ATG&quot; 
+#line  1685 &quot;cs.ATG&quot; 
 out ArrayList catchClauses) {
 
-#line  1663 &quot;cs.ATG&quot; 
+#line  1687 &quot;cs.ATG&quot; 
 		catchClauses = new ArrayList();
 		
 		Expect(55);
 
-#line  1666 &quot;cs.ATG&quot; 
+#line  1690 &quot;cs.ATG&quot; 
 		string name;
 		string identifier;
 		Statement stmt; 
 		
 		if (la.kind == 14) {
 			Block(
-#line  1672 &quot;cs.ATG&quot; 
+#line  1696 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1672 &quot;cs.ATG&quot; 
+#line  1696 &quot;cs.ATG&quot; 
 			catchClauses.Add(new CatchClause(stmt)); 
 		} else if (la.kind == 18) {
 			lexer.NextToken();
 			ClassType(
-#line  1674 &quot;cs.ATG&quot; 
+#line  1698 &quot;cs.ATG&quot; 
 out name);
 
-#line  1674 &quot;cs.ATG&quot; 
+#line  1698 &quot;cs.ATG&quot; 
 			identifier = null; 
 			if (la.kind == 1) {
 				lexer.NextToken();
 
-#line  1674 &quot;cs.ATG&quot; 
+#line  1698 &quot;cs.ATG&quot; 
 				identifier = t.val; 
 			}
 			Expect(19);
 			Block(
-#line  1674 &quot;cs.ATG&quot; 
+#line  1698 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1674 &quot;cs.ATG&quot; 
+#line  1698 &quot;cs.ATG&quot; 
 			catchClauses.Add(new CatchClause(name, identifier, stmt)); 
 			while (
-#line  1675 &quot;cs.ATG&quot; 
+#line  1699 &quot;cs.ATG&quot; 
 IsTypedCatch()) {
 				Expect(55);
 				Expect(18);
 				ClassType(
-#line  1675 &quot;cs.ATG&quot; 
+#line  1699 &quot;cs.ATG&quot; 
 out name);
 
-#line  1675 &quot;cs.ATG&quot; 
+#line  1699 &quot;cs.ATG&quot; 
 				identifier = null; 
 				if (la.kind == 1) {
 					lexer.NextToken();
 
-#line  1675 &quot;cs.ATG&quot; 
+#line  1699 &quot;cs.ATG&quot; 
 					identifier = t.val; 
 				}
 				Expect(19);
 				Block(
-#line  1675 &quot;cs.ATG&quot; 
+#line  1699 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1675 &quot;cs.ATG&quot; 
+#line  1699 &quot;cs.ATG&quot; 
 				catchClauses.Add(new CatchClause(name, identifier, stmt)); 
 			}
 			if (la.kind == 55) {
 				lexer.NextToken();
 				Block(
-#line  1677 &quot;cs.ATG&quot; 
+#line  1701 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1677 &quot;cs.ATG&quot; 
+#line  1701 &quot;cs.ATG&quot; 
 				catchClauses.Add(new CatchClause(stmt)); 
 			}
-		} else SynErr(177);
+		} else SynErr(178);
 	}
 
 	void UnaryExpr(
-#line  1740 &quot;cs.ATG&quot; 
+#line  1764 &quot;cs.ATG&quot; 
 out Expression uExpr) {
 
-#line  1742 &quot;cs.ATG&quot; 
+#line  1766 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		Expression expr;
 		ArrayList  expressions = new ArrayList();
 		uExpr = null;
 		
 		while (StartOf(26) || 
-#line  1764 &quot;cs.ATG&quot; 
+#line  1788 &quot;cs.ATG&quot; 
 IsTypeCast()) {
 			if (la.kind == 4) {
 				lexer.NextToken();
 
-#line  1749 &quot;cs.ATG&quot; 
+#line  1773 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); 
 			} else if (la.kind == 5) {
 				lexer.NextToken();
 
-#line  1750 &quot;cs.ATG&quot; 
+#line  1774 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); 
 			} else if (la.kind == 22) {
 				lexer.NextToken();
 
-#line  1751 &quot;cs.ATG&quot; 
+#line  1775 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); 
 			} else if (la.kind == 25) {
 				lexer.NextToken();
 
-#line  1752 &quot;cs.ATG&quot; 
+#line  1776 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); 
 			} else if (la.kind == 6) {
 				lexer.NextToken();
 
-#line  1753 &quot;cs.ATG&quot; 
+#line  1777 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); 
 			} else if (la.kind == 29) {
 				lexer.NextToken();
 
-#line  1754 &quot;cs.ATG&quot; 
+#line  1778 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); 
 			} else if (la.kind == 30) {
 				lexer.NextToken();
 
-#line  1755 &quot;cs.ATG&quot; 
+#line  1779 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); 
 			} else if (la.kind == 26) {
 				lexer.NextToken();
 
-#line  1756 &quot;cs.ATG&quot; 
+#line  1780 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); 
 			} else {
 				Expect(18);
 				Type(
-#line  1764 &quot;cs.ATG&quot; 
+#line  1788 &quot;cs.ATG&quot; 
 out type);
 				Expect(19);
 
-#line  1764 &quot;cs.ATG&quot; 
+#line  1788 &quot;cs.ATG&quot; 
 				expressions.Add(new CastExpression(type)); 
 			}
 		}
 		PrimaryExpr(
-#line  1767 &quot;cs.ATG&quot; 
+#line  1791 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1767 &quot;cs.ATG&quot; 
+#line  1791 &quot;cs.ATG&quot; 
 		for (int i = 0; i &lt; expressions.Count; ++i) {
 		Expression nextExpression = i + 1 &lt; expressions.Count ? (Expression)expressions[i + 1] : expr;
 		if (expressions[i] is CastExpression) {
@@ -4016,33 +4061,33 @@
 	}
 
 	void ConditionalOrExpr(
-#line  1869 &quot;cs.ATG&quot; 
+#line  1893 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1870 &quot;cs.ATG&quot; 
+#line  1894 &quot;cs.ATG&quot; 
 		Expression expr;   
 		ConditionalAndExpr(
-#line  1872 &quot;cs.ATG&quot; 
+#line  1896 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 24) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1872 &quot;cs.ATG&quot; 
+#line  1896 &quot;cs.ATG&quot; 
 out expr);
 			ConditionalAndExpr(
-#line  1872 &quot;cs.ATG&quot; 
+#line  1896 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1872 &quot;cs.ATG&quot; 
+#line  1896 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  
 		}
 	}
 
 	void PrimaryExpr(
-#line  1784 &quot;cs.ATG&quot; 
+#line  1808 &quot;cs.ATG&quot; 
 out Expression pexpr) {
 
-#line  1786 &quot;cs.ATG&quot; 
+#line  1810 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		bool isArrayCreation = false;
 		Expression expr;
@@ -4052,46 +4097,46 @@
 		case 112: {
 			lexer.NextToken();
 
-#line  1793 &quot;cs.ATG&quot; 
+#line  1817 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(true, &quot;true&quot;);  
 			break;
 		}
 		case 71: {
 			lexer.NextToken();
 
-#line  1794 &quot;cs.ATG&quot; 
+#line  1818 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(false, &quot;false&quot;); 
 			break;
 		}
 		case 89: {
 			lexer.NextToken();
 
-#line  1795 &quot;cs.ATG&quot; 
+#line  1819 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(null, &quot;null&quot;);  
 			break;
 		}
 		case 2: {
 			lexer.NextToken();
 
-#line  1796 &quot;cs.ATG&quot; 
+#line  1820 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(t.literalValue, t.val);  
 			break;
 		}
 		case 1: {
 			lexer.NextToken();
 
-#line  1798 &quot;cs.ATG&quot; 
+#line  1822 &quot;cs.ATG&quot; 
 			pexpr = new IdentifierExpression(t.val); 
 			break;
 		}
 		case 18: {
 			lexer.NextToken();
 			Expr(
-#line  1800 &quot;cs.ATG&quot; 
+#line  1824 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1800 &quot;cs.ATG&quot; 
+#line  1824 &quot;cs.ATG&quot; 
 			pexpr = new ParenthesizedExpression(expr); 
 			break;
 		}
@@ -4159,208 +4204,208 @@
 			}
 			}
 
-#line  1806 &quot;cs.ATG&quot; 
+#line  1830 &quot;cs.ATG&quot; 
 			string val = t.val; t.val = &quot;&quot;; 
 			Expect(13);
 			Expect(1);
 
-#line  1806 &quot;cs.ATG&quot; 
+#line  1830 &quot;cs.ATG&quot; 
 			pexpr = new FieldReferenceExpression(new TypeReferenceExpression(val), t.val); 
 			break;
 		}
 		case 110: {
 			lexer.NextToken();
 
-#line  1808 &quot;cs.ATG&quot; 
+#line  1832 &quot;cs.ATG&quot; 
 			pexpr = new ThisReferenceExpression(); 
 			break;
 		}
 		case 50: {
 			lexer.NextToken();
 
-#line  1810 &quot;cs.ATG&quot; 
+#line  1834 &quot;cs.ATG&quot; 
 			Expression retExpr = new BaseReferenceExpression(); 
 			if (la.kind == 13) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1812 &quot;cs.ATG&quot; 
+#line  1836 &quot;cs.ATG&quot; 
 				retExpr = new FieldReferenceExpression(retExpr, t.val); 
 			} else if (la.kind == 16) {
 				lexer.NextToken();
 				Expr(
-#line  1813 &quot;cs.ATG&quot; 
+#line  1837 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1813 &quot;cs.ATG&quot; 
+#line  1837 &quot;cs.ATG&quot; 
 				ArrayList indices = new ArrayList(); indices.Add(expr); 
 				while (la.kind == 12) {
 					lexer.NextToken();
 					Expr(
-#line  1814 &quot;cs.ATG&quot; 
+#line  1838 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1814 &quot;cs.ATG&quot; 
+#line  1838 &quot;cs.ATG&quot; 
 					indices.Add(expr); 
 				}
 				Expect(17);
 
-#line  1815 &quot;cs.ATG&quot; 
+#line  1839 &quot;cs.ATG&quot; 
 				retExpr = new IndexerExpression(retExpr, indices); 
-			} else SynErr(178);
+			} else SynErr(179);
 
-#line  1816 &quot;cs.ATG&quot; 
+#line  1840 &quot;cs.ATG&quot; 
 			pexpr = retExpr; 
 			break;
 		}
 		case 88: {
 			lexer.NextToken();
 			NonArrayType(
-#line  1817 &quot;cs.ATG&quot; 
+#line  1841 &quot;cs.ATG&quot; 
 out type);
 
-#line  1817 &quot;cs.ATG&quot; 
+#line  1841 &quot;cs.ATG&quot; 
 			ArrayList parameters = new ArrayList(); 
 			if (la.kind == 18) {
 				lexer.NextToken();
 
-#line  1822 &quot;cs.ATG&quot; 
+#line  1846 &quot;cs.ATG&quot; 
 				ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); 
 				if (StartOf(21)) {
 					Argument(
-#line  1822 &quot;cs.ATG&quot; 
+#line  1846 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1822 &quot;cs.ATG&quot; 
+#line  1846 &quot;cs.ATG&quot; 
 					parameters.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Argument(
-#line  1823 &quot;cs.ATG&quot; 
+#line  1847 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1823 &quot;cs.ATG&quot; 
+#line  1847 &quot;cs.ATG&quot; 
 						parameters.Add(expr); 
 					}
 				}
 				Expect(19);
 
-#line  1823 &quot;cs.ATG&quot; 
+#line  1847 &quot;cs.ATG&quot; 
 				pexpr = oce; 
 			} else if (la.kind == 16) {
 
-#line  1825 &quot;cs.ATG&quot; 
+#line  1849 &quot;cs.ATG&quot; 
 				isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type); pexpr = ace; 
 				lexer.NextToken();
 
-#line  1826 &quot;cs.ATG&quot; 
+#line  1850 &quot;cs.ATG&quot; 
 				int dims = 0; ArrayList rank = new ArrayList(); ArrayList parameterExpression = new ArrayList(); 
 				if (StartOf(4)) {
 					Expr(
-#line  1828 &quot;cs.ATG&quot; 
+#line  1852 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1828 &quot;cs.ATG&quot; 
+#line  1852 &quot;cs.ATG&quot; 
 					parameterExpression.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Expr(
-#line  1828 &quot;cs.ATG&quot; 
+#line  1852 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1828 &quot;cs.ATG&quot; 
+#line  1852 &quot;cs.ATG&quot; 
 						parameterExpression.Add(expr); 
 					}
 					Expect(17);
 
-#line  1828 &quot;cs.ATG&quot; 
+#line  1852 &quot;cs.ATG&quot; 
 					parameters.Add(new ArrayCreationParameter(parameterExpression)); ace.Parameters = parameters; 
 					while (
-#line  1829 &quot;cs.ATG&quot; 
+#line  1853 &quot;cs.ATG&quot; 
 IsDims()) {
 						Expect(16);
 
-#line  1829 &quot;cs.ATG&quot; 
+#line  1853 &quot;cs.ATG&quot; 
 						dims =0;
 						while (la.kind == 12) {
 							lexer.NextToken();
 
-#line  1829 &quot;cs.ATG&quot; 
+#line  1853 &quot;cs.ATG&quot; 
 							dims++;
 						}
 
-#line  1829 &quot;cs.ATG&quot; 
+#line  1853 &quot;cs.ATG&quot; 
 						rank.Add(dims); parameters.Add(new ArrayCreationParameter(dims)); 
 						Expect(17);
 					}
 
-#line  1830 &quot;cs.ATG&quot; 
+#line  1854 &quot;cs.ATG&quot; 
 					if (rank.Count &gt; 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } 
 					if (la.kind == 14) {
 						ArrayInitializer(
-#line  1831 &quot;cs.ATG&quot; 
+#line  1855 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1831 &quot;cs.ATG&quot; 
+#line  1855 &quot;cs.ATG&quot; 
 						ace.ArrayInitializer = (ArrayInitializerExpression)expr; 
 					}
 				} else if (la.kind == 12 || la.kind == 17) {
 					while (la.kind == 12) {
 						lexer.NextToken();
 
-#line  1833 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 						dims++;
 					}
 
-#line  1833 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 					parameters.Add(new ArrayCreationParameter(dims)); 
 					Expect(17);
 					while (
-#line  1833 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 IsDims()) {
 						Expect(16);
 
-#line  1833 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 						dims =0;
 						while (la.kind == 12) {
 							lexer.NextToken();
 
-#line  1833 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 							dims++;
 						}
 
-#line  1833 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 						parameters.Add(new ArrayCreationParameter(dims)); 
 						Expect(17);
 					}
 					ArrayInitializer(
-#line  1833 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1833 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 					ace.ArrayInitializer = (ArrayInitializerExpression)expr; ace.Parameters = parameters; 
-				} else SynErr(179);
-			} else SynErr(180);
+				} else SynErr(180);
+			} else SynErr(181);
 			break;
 		}
 		case 114: {
 			lexer.NextToken();
 			Expect(18);
 			if (
-#line  1839 &quot;cs.ATG&quot; 
+#line  1863 &quot;cs.ATG&quot; 
 NotVoidPointer()) {
 				Expect(122);
 
-#line  1839 &quot;cs.ATG&quot; 
+#line  1863 &quot;cs.ATG&quot; 
 				type = new TypeReference(&quot;void&quot;); 
 			} else if (StartOf(8)) {
 				Type(
-#line  1840 &quot;cs.ATG&quot; 
+#line  1864 &quot;cs.ATG&quot; 
 out type);
-			} else SynErr(181);
+			} else SynErr(182);
 			Expect(19);
 
-#line  1841 &quot;cs.ATG&quot; 
+#line  1865 &quot;cs.ATG&quot; 
 			pexpr = new TypeOfExpression(type); 
 			break;
 		}
@@ -4368,11 +4413,11 @@
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1842 &quot;cs.ATG&quot; 
+#line  1866 &quot;cs.ATG&quot; 
 out type);
 			Expect(19);
 
-#line  1842 &quot;cs.ATG&quot; 
+#line  1866 &quot;cs.ATG&quot; 
 			pexpr = new SizeOfExpression(type); 
 			break;
 		}
@@ -4380,11 +4425,11 @@
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1843 &quot;cs.ATG&quot; 
+#line  1867 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1843 &quot;cs.ATG&quot; 
+#line  1867 &quot;cs.ATG&quot; 
 			pexpr = new CheckedExpression(expr); 
 			break;
 		}
@@ -4392,365 +4437,365 @@
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1844 &quot;cs.ATG&quot; 
+#line  1868 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1844 &quot;cs.ATG&quot; 
+#line  1868 &quot;cs.ATG&quot; 
 			pexpr = new CheckedExpression(expr); 
 			break;
 		}
-		default: SynErr(182); break;
+		default: SynErr(183); break;
 		}
 		while (StartOf(27)) {
 			if (la.kind == 29 || la.kind == 30) {
 				if (la.kind == 29) {
 					lexer.NextToken();
 
-#line  1848 &quot;cs.ATG&quot; 
+#line  1872 &quot;cs.ATG&quot; 
 					pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); 
 				} else if (la.kind == 30) {
 					lexer.NextToken();
 
-#line  1849 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 					pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); 
-				} else SynErr(183);
+				} else SynErr(184);
 			} else if (la.kind == 47) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1852 &quot;cs.ATG&quot; 
+#line  1876 &quot;cs.ATG&quot; 
 				pexpr = new PointerReferenceExpression(pexpr, t.val); 
 			} else if (la.kind == 13) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1853 &quot;cs.ATG&quot; 
+#line  1877 &quot;cs.ATG&quot; 
 				pexpr = new FieldReferenceExpression(pexpr, t.val);
 			} else if (la.kind == 18) {
 				lexer.NextToken();
 
-#line  1855 &quot;cs.ATG&quot; 
+#line  1879 &quot;cs.ATG&quot; 
 				ArrayList parameters = new ArrayList(); 
 				if (StartOf(21)) {
 					Argument(
-#line  1856 &quot;cs.ATG&quot; 
+#line  1880 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1856 &quot;cs.ATG&quot; 
+#line  1880 &quot;cs.ATG&quot; 
 					parameters.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Argument(
-#line  1857 &quot;cs.ATG&quot; 
+#line  1881 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1857 &quot;cs.ATG&quot; 
+#line  1881 &quot;cs.ATG&quot; 
 						parameters.Add(expr); 
 					}
 				}
 				Expect(19);
 
-#line  1858 &quot;cs.ATG&quot; 
+#line  1882 &quot;cs.ATG&quot; 
 				pexpr = new InvocationExpression(pexpr, parameters); 
 			} else {
 
-#line  1860 &quot;cs.ATG&quot; 
+#line  1884 &quot;cs.ATG&quot; 
 				if (isArrayCreation) Error(&quot;element access not allow on array creation&quot;);
 				ArrayList indices = new ArrayList();
 				
 				lexer.NextToken();
 				Expr(
-#line  1863 &quot;cs.ATG&quot; 
+#line  1887 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1863 &quot;cs.ATG&quot; 
+#line  1887 &quot;cs.ATG&quot; 
 				indices.Add(expr); 
 				while (la.kind == 12) {
 					lexer.NextToken();
 					Expr(
-#line  1864 &quot;cs.ATG&quot; 
+#line  1888 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1864 &quot;cs.ATG&quot; 
+#line  1888 &quot;cs.ATG&quot; 
 					indices.Add(expr); 
 				}
 				Expect(17);
 
-#line  1865 &quot;cs.ATG&quot; 
+#line  1889 &quot;cs.ATG&quot; 
 				pexpr = new IndexerExpression(pexpr, indices); 
 			}
 		}
 	}
 
 	void ConditionalAndExpr(
-#line  1875 &quot;cs.ATG&quot; 
+#line  1899 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1876 &quot;cs.ATG&quot; 
+#line  1900 &quot;cs.ATG&quot; 
 		Expression expr; 
 		InclusiveOrExpr(
-#line  1878 &quot;cs.ATG&quot; 
+#line  1902 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 23) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1878 &quot;cs.ATG&quot; 
+#line  1902 &quot;cs.ATG&quot; 
 out expr);
 			InclusiveOrExpr(
-#line  1878 &quot;cs.ATG&quot; 
+#line  1902 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1878 &quot;cs.ATG&quot; 
+#line  1902 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  
 		}
 	}
 
 	void InclusiveOrExpr(
-#line  1881 &quot;cs.ATG&quot; 
+#line  1905 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1882 &quot;cs.ATG&quot; 
+#line  1906 &quot;cs.ATG&quot; 
 		Expression expr; 
 		ExclusiveOrExpr(
-#line  1884 &quot;cs.ATG&quot; 
+#line  1908 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 27) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1884 &quot;cs.ATG&quot; 
+#line  1908 &quot;cs.ATG&quot; 
 out expr);
 			ExclusiveOrExpr(
-#line  1884 &quot;cs.ATG&quot; 
+#line  1908 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1884 &quot;cs.ATG&quot; 
+#line  1908 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  
 		}
 	}
 
 	void ExclusiveOrExpr(
-#line  1887 &quot;cs.ATG&quot; 
+#line  1911 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1888 &quot;cs.ATG&quot; 
+#line  1912 &quot;cs.ATG&quot; 
 		Expression expr; 
 		AndExpr(
-#line  1890 &quot;cs.ATG&quot; 
+#line  1914 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 28) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1890 &quot;cs.ATG&quot; 
+#line  1914 &quot;cs.ATG&quot; 
 out expr);
 			AndExpr(
-#line  1890 &quot;cs.ATG&quot; 
+#line  1914 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1890 &quot;cs.ATG&quot; 
+#line  1914 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  
 		}
 	}
 
 	void AndExpr(
-#line  1893 &quot;cs.ATG&quot; 
+#line  1917 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1894 &quot;cs.ATG&quot; 
+#line  1918 &quot;cs.ATG&quot; 
 		Expression expr; 
 		EqualityExpr(
-#line  1896 &quot;cs.ATG&quot; 
+#line  1920 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 26) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1896 &quot;cs.ATG&quot; 
+#line  1920 &quot;cs.ATG&quot; 
 out expr);
 			EqualityExpr(
-#line  1896 &quot;cs.ATG&quot; 
+#line  1920 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1896 &quot;cs.ATG&quot; 
+#line  1920 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  
 		}
 	}
 
 	void EqualityExpr(
-#line  1899 &quot;cs.ATG&quot; 
+#line  1923 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1901 &quot;cs.ATG&quot; 
+#line  1925 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		RelationalExpr(
-#line  1905 &quot;cs.ATG&quot; 
+#line  1929 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 31 || la.kind == 32) {
 			if (la.kind == 32) {
 				lexer.NextToken();
 
-#line  1908 &quot;cs.ATG&quot; 
+#line  1932 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.InEquality; 
 			} else {
 				lexer.NextToken();
 
-#line  1909 &quot;cs.ATG&quot; 
+#line  1933 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Equality; 
 			}
 			UnaryExpr(
-#line  1911 &quot;cs.ATG&quot; 
+#line  1935 &quot;cs.ATG&quot; 
 out expr);
 			RelationalExpr(
-#line  1911 &quot;cs.ATG&quot; 
+#line  1935 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1911 &quot;cs.ATG&quot; 
+#line  1935 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void RelationalExpr(
-#line  1915 &quot;cs.ATG&quot; 
+#line  1939 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1917 &quot;cs.ATG&quot; 
+#line  1941 &quot;cs.ATG&quot; 
 		TypeReference type;
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		ShiftExpr(
-#line  1922 &quot;cs.ATG&quot; 
+#line  1946 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (StartOf(28)) {
 			if (StartOf(29)) {
 				if (la.kind == 21) {
 					lexer.NextToken();
 
-#line  1925 &quot;cs.ATG&quot; 
+#line  1949 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.LessThan; 
 				} else if (la.kind == 20) {
 					lexer.NextToken();
 
-#line  1926 &quot;cs.ATG&quot; 
+#line  1950 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.GreaterThan; 
 				} else if (la.kind == 34) {
 					lexer.NextToken();
 
-#line  1927 &quot;cs.ATG&quot; 
+#line  1951 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.LessThanOrEqual; 
 				} else if (la.kind == 33) {
 					lexer.NextToken();
 
-#line  1928 &quot;cs.ATG&quot; 
+#line  1952 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.GreaterThanOrEqual; 
-				} else SynErr(184);
+				} else SynErr(185);
 				UnaryExpr(
-#line  1930 &quot;cs.ATG&quot; 
+#line  1954 &quot;cs.ATG&quot; 
 out expr);
 				ShiftExpr(
-#line  1930 &quot;cs.ATG&quot; 
+#line  1954 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1930 &quot;cs.ATG&quot; 
+#line  1954 &quot;cs.ATG&quot; 
 				outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 			} else {
 				if (la.kind == 84) {
 					lexer.NextToken();
 
-#line  1933 &quot;cs.ATG&quot; 
+#line  1957 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.IS; 
 				} else if (la.kind == 49) {
 					lexer.NextToken();
 
-#line  1934 &quot;cs.ATG&quot; 
+#line  1958 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.AS; 
-				} else SynErr(185);
+				} else SynErr(186);
 				Type(
-#line  1936 &quot;cs.ATG&quot; 
+#line  1960 &quot;cs.ATG&quot; 
 out type);
 
-#line  1936 &quot;cs.ATG&quot; 
+#line  1960 &quot;cs.ATG&quot; 
 				outExpr = new BinaryOperatorExpression(outExpr, op, new TypeReferenceExpression(type)); 
 			}
 		}
 	}
 
 	void ShiftExpr(
-#line  1940 &quot;cs.ATG&quot; 
+#line  1964 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1942 &quot;cs.ATG&quot; 
+#line  1966 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		AdditiveExpr(
-#line  1946 &quot;cs.ATG&quot; 
+#line  1970 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 35 || la.kind == 36) {
 			if (la.kind == 35) {
 				lexer.NextToken();
 
-#line  1949 &quot;cs.ATG&quot; 
+#line  1973 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.ShiftLeft; 
 			} else {
 				lexer.NextToken();
 
-#line  1950 &quot;cs.ATG&quot; 
+#line  1974 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.ShiftRight; 
 			}
 			UnaryExpr(
-#line  1952 &quot;cs.ATG&quot; 
+#line  1976 &quot;cs.ATG&quot; 
 out expr);
 			AdditiveExpr(
-#line  1952 &quot;cs.ATG&quot; 
+#line  1976 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1952 &quot;cs.ATG&quot; 
+#line  1976 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void AdditiveExpr(
-#line  1956 &quot;cs.ATG&quot; 
+#line  1980 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1958 &quot;cs.ATG&quot; 
+#line  1982 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		MultiplicativeExpr(
-#line  1962 &quot;cs.ATG&quot; 
+#line  1986 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 4 || la.kind == 5) {
 			if (la.kind == 4) {
 				lexer.NextToken();
 
-#line  1965 &quot;cs.ATG&quot; 
+#line  1989 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Add; 
 			} else {
 				lexer.NextToken();
 
-#line  1966 &quot;cs.ATG&quot; 
+#line  1990 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Subtract; 
 			}
 			UnaryExpr(
-#line  1968 &quot;cs.ATG&quot; 
+#line  1992 &quot;cs.ATG&quot; 
 out expr);
 			MultiplicativeExpr(
-#line  1968 &quot;cs.ATG&quot; 
+#line  1992 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1968 &quot;cs.ATG&quot; 
+#line  1992 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void MultiplicativeExpr(
-#line  1972 &quot;cs.ATG&quot; 
+#line  1996 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1974 &quot;cs.ATG&quot; 
+#line  1998 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
@@ -4758,24 +4803,24 @@
 			if (la.kind == 6) {
 				lexer.NextToken();
 
-#line  1980 &quot;cs.ATG&quot; 
+#line  2004 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Multiply; 
 			} else if (la.kind == 7) {
 				lexer.NextToken();
 
-#line  1981 &quot;cs.ATG&quot; 
+#line  2005 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Divide; 
 			} else {
 				lexer.NextToken();
 
-#line  1982 &quot;cs.ATG&quot; 
+#line  2006 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Modulus; 
 			}
 			UnaryExpr(
-#line  1984 &quot;cs.ATG&quot; 
+#line  2008 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1984 &quot;cs.ATG&quot; 
+#line  2008 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
 		}
 	}
@@ -4968,21 +5013,22 @@
 			case 168: s = &quot;invalid LocalVariableInitializer&quot;; break;
 			case 169: s = &quot;invalid EmbeddedStatement&quot;; break;
 			case 170: s = &quot;invalid EmbeddedStatement&quot;; break;
-			case 171: s = &quot;invalid StatementExpr&quot;; break;
-			case 172: s = &quot;invalid ForInitializer&quot;; break;
-			case 173: s = &quot;invalid GotoStatement&quot;; break;
-			case 174: s = &quot;invalid TryStatement&quot;; break;
-			case 175: s = &quot;invalid ResourceAcquisition&quot;; break;
-			case 176: s = &quot;invalid SwitchLabel&quot;; break;
-			case 177: s = &quot;invalid CatchClauses&quot;; break;
-			case 178: s = &quot;invalid PrimaryExpr&quot;; break;
+			case 171: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 172: s = &quot;invalid StatementExpr&quot;; break;
+			case 173: s = &quot;invalid ForInitializer&quot;; break;
+			case 174: s = &quot;invalid GotoStatement&quot;; break;
+			case 175: s = &quot;invalid TryStatement&quot;; break;
+			case 176: s = &quot;invalid ResourceAcquisition&quot;; break;
+			case 177: s = &quot;invalid SwitchLabel&quot;; break;
+			case 178: s = &quot;invalid CatchClauses&quot;; break;
 			case 179: s = &quot;invalid PrimaryExpr&quot;; break;
 			case 180: s = &quot;invalid PrimaryExpr&quot;; break;
 			case 181: s = &quot;invalid PrimaryExpr&quot;; break;
 			case 182: s = &quot;invalid PrimaryExpr&quot;; break;
 			case 183: s = &quot;invalid PrimaryExpr&quot;; break;
-			case 184: s = &quot;invalid RelationalExpr&quot;; break;
+			case 184: s = &quot;invalid PrimaryExpr&quot;; break;
 			case 185: s = &quot;invalid RelationalExpr&quot;; break;
+			case 186: s = &quot;invalid RelationalExpr&quot;; break;
 
 			default: s = &quot;error &quot; + errorNumber; break;
 		}
@@ -4991,8 +5037,8 @@
 
 	static bool[,] set = {
 	{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x},
 	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x},
 	{x,T,T,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,T,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,T,x,x, T,T,x,x, x,T,x,x, x,T,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, T,T,T,x, x,x,x,x, x,x,x,x, x,T,x,T, T,x,x,T, x,x,T,x, T,x,T,T, T,T,x,T, x,x,x,x, x,x,x},
 	{x,x,x,x, T,T,T,T, T,T,T,T, T,x,x,T, x,T,x,T, T,T,x,T, T,x,T,T, T,x,x,T, T,T,T,T, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
@@ -5007,7 +5053,7 @@
 	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,T, x,x,x,x, x,x,x},
 	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, x,T,x,T, x,x,x,T, x,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
 	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,T,T, x,T,x,T, x,T,x,T, T,T,x,x, x,x,T,x, x,x,x,T, x,T,T,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,T, T,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,T, x,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
 	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,T, x,x,x,x, x,x,x},
 	{x,T,T,x, T,T,T,x, x,x,T,x, x,x,T,x, x,x,T,x, x,x,T,x, x,T,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, T,T,x,T, T,T,x,x, T,T,x,x, x,x,x,T, x,T,T,T, T,T,T,x, x,T,x,x, x,T,T,x, T,T,T,x, x,x,x,x, x,x,x,x, T,T,x,T, T,x,x,T, x,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, T,x,x},

Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG	2005-03-30 23:08:24 UTC (rev 2402)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG	2005-03-31 00:23:02 UTC (rev 2403)
@@ -322,6 +322,11 @@
 	       pt.kind == Tokens.Identifier;
 }
 
+/* True, if lookahead ident is &quot;yield&quot; */
+bool IdentIsYield () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;yield&quot;;
+}
+
 /* True, if lookahead ident is &quot;get&quot; */
 bool IdentIsGet () {
 	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;get&quot;;
@@ -1536,6 +1541,9 @@
 	Block&lt;out statement&gt;
 	/*--- empty statement: */
 	| &quot;;&quot;                       (. statement = new EmptyStatement(); .)
+	/* yield statements */
+	| IF (IdentIsYield ()) ident
+		(&quot;return&quot; Expr&lt;out expr&gt; | &quot;break&quot;) &quot;;&quot;			(. statement = new YieldStatement(expr); .)
 	/*--- checked / unchecked statement: */
 	| IF (UnCheckedAndLBrace()) (. Statement block; bool isChecked = true; .)
 	(&quot;checked&quot; | &quot;unchecked&quot;    (. isChecked = false;.) )
@@ -1573,6 +1581,7 @@
 	| GotoStatement&lt;out statement&gt;
 	| &quot;return&quot; [ Expr&lt;out expr&gt; ] &quot;;&quot;    (. statement = new ReturnStatement(expr); .)
 	| &quot;throw&quot; [ Expr&lt;out expr&gt; ] &quot;;&quot;     (. statement = new ThrowStatement(expr); .)
+
 	/*--- try statement: */
 	| TryStatement&lt;out statement&gt;
 	/*--- lock satement: */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002004.html">[Monodevelop-patches-list] r2402 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Parser/AST/TypeLevel src/Parser/generated src/PrettyPrinter
</A></li>
	<LI>Next message: <A HREF="002006.html">[Monodevelop-patches-list] r2404 - trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2005">[ date ]</a>
              <a href="thread.html#2005">[ thread ]</a>
              <a href="subject.html#2005">[ subject ]</a>
              <a href="author.html#2005">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
