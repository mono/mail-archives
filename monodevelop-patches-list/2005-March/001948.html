<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2346 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Commands Commands/ProjectBrowserCommands Gui Gui/Components Gui/Dialogs/ReferenceDialog Gui/Pads Gui/Pads/ClassPad Gui/Pads/ClassScout Gui/Pads/FileScout Gui/Pads/ProjectBrowser Gui/Pads/ProjectPad Gui/Pads/SolutionPad Gui/Workbench Gui/Workbench/Layouts Internal/Codons Internal/Codons/Pads Internal/Project/Combine Internal/Project/Project Services Services/ParserService Services/Project options
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2346%20-%20in%20trunk/MonoDevelop/Core/src/MonoDevelop.Base%3A%20.%20Commands%20Commands/ProjectBrowserCommands%20Gui%20Gui/Components%20Gui/Dialogs/ReferenceDialog%20Gui/Pads%20Gui/Pads/ClassPad%20Gui/Pads/ClassScout%20Gui/Pads/FileScout%20Gui/Pads/ProjectBrowser%20Gui/Pads/ProjectPad%20Gui/Pads/SolutionPad%20Gui/Workbench%20Gui/Workbench/Layouts%20Internal/Codons%20Internal/Codons/Pads%20Internal/Project/Combine%20Internal/Project/Project%20Services%20Services/ParserService%20Services/Project%20options&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001947.html">
   <LINK REL="Next"  HREF="001949.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2346 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Commands Commands/ProjectBrowserCommands Gui Gui/Components Gui/Dialogs/ReferenceDialog Gui/Pads Gui/Pads/ClassPad Gui/Pads/ClassScout Gui/Pads/FileScout Gui/Pads/ProjectBrowser Gui/Pads/ProjectPad Gui/Pads/SolutionPad Gui/Workbench Gui/Workbench/Layouts Internal/Codons Internal/Codons/Pads Internal/Project/Combine Internal/Project/Project Services Services/ParserService Services/Project options</H1>
    <B>Lluis Sanchez &lt;lluis@ximian.com&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2346%20-%20in%20trunk/MonoDevelop/Core/src/MonoDevelop.Base%3A%20.%20Commands%20Commands/ProjectBrowserCommands%20Gui%20Gui/Components%20Gui/Dialogs/ReferenceDialog%20Gui/Pads%20Gui/Pads/ClassPad%20Gui/Pads/ClassScout%20Gui/Pads/FileScout%20Gui/Pads/ProjectBrowser%20Gui/Pads/ProjectPad%20Gui/Pads/SolutionPad%20Gui/Workbench%20Gui/Workbench/Layouts%20Internal/Codons%20Internal/Codons/Pads%20Internal/Project/Combine%20Internal/Project/Project%20Services%20Services/ParserService%20Services/Project%20options&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2346 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Commands Commands/ProjectBrowserCommands Gui Gui/Components Gui/Dialogs/ReferenceDialog Gui/Pads Gui/Pads/ClassPad Gui/Pads/ClassScout Gui/Pads/FileScout Gui/Pads/ProjectBrowser Gui/Pads/ProjectPad Gui/Pads/SolutionPad Gui/Workbench Gui/Workbench/Layouts Internal/Codons Internal/Codons/Pads Internal/Project/Combine Internal/Project/Project Services Services/ParserService Services/Project options">lluis at mono-cvs.ximian.com
       </A><BR>
    <I>Mon Mar 14 18:32:08 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001947.html">[Monodevelop-patches-list] r2345 - trunk/MonoDevelop/Core/src/MonoDevelop.Dock
</A></li>
        <LI>Next message: <A HREF="001949.html">[Monodevelop-patches-list] r2347 - in trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor: . Gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1948">[ date ]</a>
              <a href="thread.html#1948">[ thread ]</a>
              <a href="subject.html#1948">[ subject ]</a>
              <a href="author.html#1948">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lluis
Date: 2005-03-14 18:32:08 -0500 (Mon, 14 Mar 2005)
New Revision: 2346

Added:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ClassData.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ClassNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/CombineNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/EventNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/FieldNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MemberNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MemberNodeCommandHandler.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MethodNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/NamespaceData.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/NamespaceNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ProjectNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/PropertyNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/CombineNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/FolderNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFileNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFolder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFolderNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectReferenceFolderNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ResourceFolder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ResourceFolderNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/DragOperation.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeBuilderContext.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeNavigator.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeOptions.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeAttributes.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeBuilderExtension.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeCommandHandler.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/SolutionPad.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TreePadOption.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TreeViewPad.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TypeNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ContextPadCodon.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/NodeBuilderCodon.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/PadCodon.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/PadOptionCodon.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/SolutionPadCodon.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/WorkbenchContextCodon.cs
Modified:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/MenuItemBuilders.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/CombineNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/FolderNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/GeneralNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ProjectNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/AbstractPadContent.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/SdMenuCheckBox.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/SdMenuCommand.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/SelectReferenceDialog.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IPadContent.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IWorkbench.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/PadContentCollection.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/ClassScout.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/DefaultMonitorPad.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/FileScout/FileScout.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/OpenTaskView.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/ProjectBrowserView.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/TerminalPad.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/DefaultWorkbench.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceWindow.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/Combine.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IncludeFilesDialog.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Project.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReference.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/IconService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/CodeCompletionDatabase.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/IParserService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/options/DefaultEditingLayout.xml
Log:
2005-03-14  Lluis Sanchez Gual &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;

	* Commands/MenuItemBuilders.cs
	* Gui/Components/SdMenuCheckBox.cs
	* Gui/Components/SdMenuCommand.cs:
	  Avoid subscribing self events since it can be a source of memory leaks.
	
	* Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs,
	  Commands/ProjectBrowserCommands/ProjectNodeCommands.cs,
	  Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs,
	  Commands/ProjectBrowserCommands/FolderNodeCommands.cs,
	  Commands/ProjectBrowserCommands/CombineNodeCommands.cs,
	  Commands/ProjectBrowserCommands/GeneralNodeCommands.cs:
	  Modified to use the new tree navigation api.
	  
	* Services/Project/ProjectService.cs: call RestoreCombinePreferences
	  in the gui thread.
	* IconService.cs: Added helper method for changing the alpha of a pixbuf.
	* PadContentCollection.cs: Pads now have an Id. Use it.
	* SelectReferenceDialog.cs: Use a ProjectReferenceCollection instead
	  of an array list to return the results.
	* Gui/Workbench/Layouts/SdiWorkspaceLayout.cs: Name dock items after
	  pad's ids. Read the list of pads for the context from the addin xm
	  file. Use the new IPadContent.DefaultPlacement property to put pads
	  in the right place.
	* Gui/Workbench/Layouts/SdiWorkspaceWindow.cs: Properly dispose the
	  window.
	* Gui/Workbench/DefaultWorkbench.cs: Read pads declarations from the
	  new addin tree path, and using the new codons.
	* Gui/AbstractPadContent.cs: Added Id and DefaultPlacement properties.
	
	* Gui/Pads/SolutionPad/*: The new generic solution pad.
	* Gui/Pads/ClassPad/*: Node builders for the new class pad.
	* Gui/Pads/ProjectPad/*: Node builders for the new project pad.
	
	* Gui/Pads/ClassScout/ClassScout.cs:
	* Gui/Pads/OpenTaskView.cs:
	* Gui/Pads/TerminalPad.cs:
	* Gui/Pads/DefaultMonitorPad.cs:
	* Gui/Pads/ProjectBrowser/ProjectBrowserView.cs:
	* Gui/Pads/FileScout/FileScout.cs:
	  Track API changes.
	  
	* Gui/IWorkbench.cs: WorkbenchContext is now a class instad of an
	  enum. New context can be dynamically created.
	* Gui/IPadContent.cs: Added Id and DefaultPlacement properties.
	* options/DefaultEditingLayout.xml: Use new pad Ids.
	
	* Internal/Codons/ContextPadCodon.cs: New codon for defining pads
	  in a workbench context.
	* Internal/Codons/Pads/NodeBuilderCodon.cs: New codon for defining
	  node builders.
	* Internal/Codons/Pads/PadOptionCodon.cs: New codon for defining
	  pad options.
	* Internal/Codons/Pads/SolutionPadCodon.cs: New codon for defining
	  solution pads.
	* Internal/Codons/Pads/PadCodon.cs: New codon for defining
	  pads.
	* Internal/Codons/WorkbenchContextCodon.cs: New codon for defining
	  workbench contexts.
	  
	* Internal/Project/Project/ProjectReference.cs: Implemented Equals().
	* Internal/Project/Project/IncludeFilesDialog.cs: Doesn't need to be modal.
	* Internal/Project/Project/Project.cs: Enable include files dialog.
	* Internal/Project/Combine/Combine.cs: Fixed some wrong events.
	
	* MonoDevelopCore.addin.xml: Use the new codons for defining pads and
	  contexts.



Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-03-14 23:32:08 UTC (rev 2346)
@@ -1,3 +1,72 @@
+2005-03-14  Lluis Sanchez Gual &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;
+
+	* Commands/MenuItemBuilders.cs
+	* Gui/Components/SdMenuCheckBox.cs
+	* Gui/Components/SdMenuCommand.cs:
+	  Avoid subscribing self events since it can be a source of memory leaks.
+	
+	* Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs,
+	  Commands/ProjectBrowserCommands/ProjectNodeCommands.cs,
+	  Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs,
+	  Commands/ProjectBrowserCommands/FolderNodeCommands.cs,
+	  Commands/ProjectBrowserCommands/CombineNodeCommands.cs,
+	  Commands/ProjectBrowserCommands/GeneralNodeCommands.cs:
+	  Modified to use the new tree navigation api.
+	  
+	* Services/Project/ProjectService.cs: call RestoreCombinePreferences
+	  in the gui thread.
+	* IconService.cs: Added helper method for changing the alpha of a pixbuf.
+	* PadContentCollection.cs: Pads now have an Id. Use it.
+	* SelectReferenceDialog.cs: Use a ProjectReferenceCollection instead
+	  of an array list to return the results.
+	* Gui/Workbench/Layouts/SdiWorkspaceLayout.cs: Name dock items after
+	  pad's ids. Read the list of pads for the context from the addin xm
+	  file. Use the new IPadContent.DefaultPlacement property to put pads
+	  in the right place.
+	* Gui/Workbench/Layouts/SdiWorkspaceWindow.cs: Properly dispose the
+	  window.
+	* Gui/Workbench/DefaultWorkbench.cs: Read pads declarations from the
+	  new addin tree path, and using the new codons.
+	* Gui/AbstractPadContent.cs: Added Id and DefaultPlacement properties.
+	
+	* Gui/Pads/SolutionPad/*: The new generic solution pad.
+	* Gui/Pads/ClassPad/*: Node builders for the new class pad.
+	* Gui/Pads/ProjectPad/*: Node builders for the new project pad.
+	
+	* Gui/Pads/ClassScout/ClassScout.cs:
+	* Gui/Pads/OpenTaskView.cs:
+	* Gui/Pads/TerminalPad.cs:
+	* Gui/Pads/DefaultMonitorPad.cs:
+	* Gui/Pads/ProjectBrowser/ProjectBrowserView.cs:
+	* Gui/Pads/FileScout/FileScout.cs:
+	  Track API changes.
+	  
+	* Gui/IWorkbench.cs: WorkbenchContext is now a class instad of an
+	  enum. New context can be dynamically created.
+	* Gui/IPadContent.cs: Added Id and DefaultPlacement properties.
+	* options/DefaultEditingLayout.xml: Use new pad Ids.
+	
+	* Internal/Codons/ContextPadCodon.cs: New codon for defining pads
+	  in a workbench context.
+	* Internal/Codons/Pads/NodeBuilderCodon.cs: New codon for defining
+	  node builders.
+	* Internal/Codons/Pads/PadOptionCodon.cs: New codon for defining
+	  pad options.
+	* Internal/Codons/Pads/SolutionPadCodon.cs: New codon for defining
+	  solution pads.
+	* Internal/Codons/Pads/PadCodon.cs: New codon for defining
+	  pads.
+	* Internal/Codons/WorkbenchContextCodon.cs: New codon for defining
+	  workbench contexts.
+	  
+	* Internal/Project/Project/ProjectReference.cs: Implemented Equals().
+	* Internal/Project/Project/IncludeFilesDialog.cs: Doesn't need to be modal.
+	* Internal/Project/Project/Project.cs: Enable include files dialog.
+	* Internal/Project/Combine/Combine.cs: Fixed some wrong events.
+	
+	* MonoDevelopCore.addin.xml: Use the new codons for defining pads and
+	  contexts.
+
 2005-03-13  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at off.net</A>&gt;
 
 	* Gui/Workbench/Layouts/SdiWorkspaceWindow.cs: Don't use a dock, this

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/MenuItemBuilders.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/MenuItemBuilders.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/MenuItemBuilders.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -214,11 +214,11 @@
 		{
 			public MyMenuItem(string name) : base(null, null, name)
 			{
-				Toggled += new EventHandler (OnClick);
 			}
 			
-			protected new void OnClick(object o, EventArgs e)
+			protected override void OnToggled ()
 			{
+				base.OnToggled ();
 				((IWorkbenchWindow)Tag).SelectWindow();
 				Active = true;
 			}
@@ -370,13 +370,15 @@
 			
 			public MyMenuItem(IPadContent padContent) : base(null, null, padContent.Title)
 			{
+				Active = WorkbenchSingleton.Workbench.WorkbenchLayout.IsVisible (padContent);
 				this.padContent = padContent;
-				Active = IsPadVisible;
-				Toggled += new EventHandler (OnClick);
 			}
 			
-			protected new void OnClick(object o, EventArgs e)
+			protected override void OnToggled ()
 			{
+				base.OnToggled ();
+				if (padContent == null) return;
+				
 				if (IsPadVisible) {
 					WorkbenchSingleton.Workbench.WorkbenchLayout.HidePad(padContent);
 				} else {
@@ -421,14 +423,15 @@
 			
 			public MyMenuItem (string name) : base (null, null, name)
 			{
+				Active = WorkbenchSingleton.Workbench.WorkbenchLayout.CurrentLayout == layoutName;
 				this.layoutName = name;
-				Active = IsCurrentLayout;
-				Toggled += new EventHandler (OnClick);
 			}
 			
-			protected new void OnClick(object o, EventArgs e)
+			protected override void OnToggled ()
 			{
-				WorkbenchSingleton.Workbench.WorkbenchLayout.CurrentLayout = layoutName;
+				base.OnToggled ();
+				if (layoutName != null)
+					WorkbenchSingleton.Workbench.WorkbenchLayout.CurrentLayout = layoutName;
 			}
 			
 			public override  void UpdateStatus()

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/CombineNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/CombineNodeCommands.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/CombineNodeCommands.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -24,22 +24,24 @@
 using MonoDevelop.Gui.Widgets;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Gui.Pads.ProjectBrowser;
+using MonoDevelop.Gui.Pads;
 
 namespace MonoDevelop.Commands.ProjectBrowser
 {
 	public class AddNewProjectToCombine : AbstractMenuCommand
 	{
 		NewProjectDialog npdlg;
-		ProjectBrowserView browser;
-		CombineBrowserNode node;
+		Combine combine;
+		NodePosition position;
+		SolutionPad browser;
 
 		public override void Run()
 		{
-			browser     = (ProjectBrowserView)Owner;
-			node        = browser.SelectedNode as CombineBrowserNode;
-			
-			if (node != null) {
+			browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			combine = nav.GetParentDataItem (typeof(Combine), true) as Combine;
+			if (combine != null) {
+				position = nav.CurrentPosition;
 				npdlg = new NewProjectDialog(false);
 				npdlg.OnOked += new EventHandler (Oked);
 			}
@@ -47,36 +49,46 @@
 
 		void Oked (object o, EventArgs e)
 		{
+			ITreeNavigator nav = browser.GetNodeAtPosition (position);
+			nav.Expanded = true;
+			
+			IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ();
 			try 
 			{
-				int newNodeIndex;
-				using (IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ()) {
-					newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((Project)node.Combine.AddEntry(npdlg.NewProjectLocation, monitor)));
-				}
+				object ob = combine.AddEntry (npdlg.NewProjectLocation, monitor);
 				Runtime.ProjectService.SaveCombine ();
-			// expand to the new node
-				node.Nodes[newNodeIndex].Expand();
+				browser.AddNodeInsertCallback (ob, new TreeNodeCallback (OnEntryInserted));
 			}
 			catch {
 				Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Invalid Project File&quot;));
 			}
-			
-			npdlg = null;
-		}	
+			finally {
+				monitor.Dispose ();
+				npdlg = null;
+			}
+		}
+		
+		void OnEntryInserted (ITreeNavigator nav)
+		{
+			nav.Selected = true;
+			nav.Expanded = true;
+		}
 	}
 		
 	public class AddNewCombineToCombine : AbstractMenuCommand
 	{
-		ProjectBrowserView browser;
-		CombineBrowserNode node;
+		Combine combine;
 		NewProjectDialog npdlg;
+		SolutionPad browser;
+		NodePosition position;
 
 		public override void Run()
 		{
-			browser = (ProjectBrowserView)Owner;
-			node    = browser.SelectedNode as CombineBrowserNode;
-			
-			if (node != null) {
+			browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			combine = nav.GetParentDataItem (typeof(Combine), true) as Combine;
+			if (combine != null) {
+				position = nav.CurrentPosition;
 				npdlg = new NewProjectDialog(false);
 				npdlg.OnOked += new EventHandler (Oked);
 			}
@@ -84,127 +96,129 @@
 
 		void Oked (object o, EventArgs e)
 		{
+			ITreeNavigator nav = browser.GetNodeAtPosition (position);
+			nav.Expanded = true;
+			
+			IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ();
 			try 
 			{
-				int newNodeIndex;
-				using (IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ()) {
-					newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildCombineTreeNode((Combine)node.Combine.AddEntry(npdlg.NewCombineLocation, monitor)));
-				}
+				object ob = combine.AddEntry (npdlg.NewCombineLocation, monitor);
 				Runtime.ProjectService.SaveCombine ();
-				
-				// expand to the new node
-				node.Nodes[newNodeIndex].Expand();
+				browser.AddNodeInsertCallback (ob, new TreeNodeCallback (OnEntryInserted));
 			}
-			catch
-			{
+			catch {
 				Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Invalid Solution File&quot;));
 			}
-			npdlg = null;
+			finally {
+				monitor.Dispose ();
+				npdlg = null;
+			}
 		}
+		
+		void OnEntryInserted (ITreeNavigator nav)
+		{
+			nav.Selected = true;
+			nav.Expanded = true;
+		}
 	}
 	
 	public class AddProjectToCombine : AbstractMenuCommand
 	{
 		public override void Run()
 		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
-			CombineBrowserNode node    = browser.SelectedNode as CombineBrowserNode;
+			SolutionPad browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			Combine combine = nav.GetParentDataItem (typeof(Combine), true) as Combine;
+			if (combine == null) return;
 			
-			if (node != null) {
-				using (FileSelector fdiag = new FileSelector (GettextCatalog.GetString (&quot;Add a Project&quot;))) {
-					fdiag.SelectMultiple = false;
-					if (fdiag.Run () == (int) Gtk.ResponseType.Ok) {
-						try {
-							object obj;
-							using (IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ()) {
-								obj = node.Combine.AddEntry (fdiag.Filename, monitor);
-							}
-							int newNodeIndex = -1;
-							if (obj is Project) {
-								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((Project)obj));
-							} else {
-								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildCombineTreeNode((Combine)obj));
-							}
+			using (FileSelector fdiag = new FileSelector (GettextCatalog.GetString (&quot;Add a Project&quot;))) {
+				fdiag.SelectMultiple = false;
+				if (fdiag.Run () == (int) Gtk.ResponseType.Ok) {
+					try
+					{
+						nav.Expanded = true;
+						using (IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ()) {
+							object ob = combine.AddEntry (fdiag.Filename, monitor);
 							Runtime.ProjectService.SaveCombine ();
-						
-							if (newNodeIndex &gt; -1) {
-								// expand to the new node
-								node.Nodes[newNodeIndex].Expand();
-							}
+							browser.AddNodeInsertCallback (ob, new TreeNodeCallback (OnEntryInserted));
 						}
-						catch 
-						{
-							Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Invalid Project File&quot;));
-						}
 					}
+					catch 
+					{
+						Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Invalid Project File&quot;));
+					}
+				}
 
-					fdiag.Hide ();
-				}
+				fdiag.Hide ();
 			}
 		}
+		
+		void OnEntryInserted (ITreeNavigator nav)
+		{
+			nav.Selected = true;
+			nav.Expanded = true;
+		}
 	}
 		
 	public class AddCombineToCombine : AbstractMenuCommand
 	{
 		public override void Run()
 		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
-			CombineBrowserNode node    = browser.SelectedNode as CombineBrowserNode;
+			SolutionPad browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			Combine combine = nav.GetParentDataItem (typeof(Combine), true) as Combine;
+			if (combine == null) return;
 			
-			if (node != null) {
-				using (FileSelector fdiag = new FileSelector (GettextCatalog.GetString (&quot;Add a Combine&quot;))) {
-					fdiag.SelectMultiple = false;
-					if (fdiag.Run () == (int) Gtk.ResponseType.Ok) {
-						try {
-							object obj;
-							using (IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ()) {
-								obj = node.Combine.AddEntry (fdiag.Filename, monitor);
-							}
-							int newNodeIndex = -1;
-							if (obj is Project) {
-								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((Project)obj));
-							} else {
-								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildCombineTreeNode((Combine)obj));
-							}
+			using (FileSelector fdiag = new FileSelector (GettextCatalog.GetString (&quot;Add a Combine&quot;))) {
+				fdiag.SelectMultiple = false;
+				if (fdiag.Run () == (int) Gtk.ResponseType.Ok)
+				{
+					try
+					{
+						nav.Expanded = true;
+						using (IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ()) {
+							object ob = combine.AddEntry (fdiag.Filename, monitor);
 							Runtime.ProjectService.SaveCombine ();
-							
-							if (newNodeIndex &gt; -1) {
-								// expand to the new node
-								node.Nodes[newNodeIndex].Expand();
-							}
+							browser.AddNodeInsertCallback (ob, new TreeNodeCallback (OnEntryInserted));
 						}
-						catch 
-						{
-							Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Invalid Solution File&quot;));
-						}
 					}
+					catch 
+					{
+						Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Invalid Solution File&quot;));
+					}
+				}
 
-					fdiag.Hide ();
-				}
+				fdiag.Hide ();
 			}
 		}
+		
+		void OnEntryInserted (ITreeNavigator nav)
+		{
+			nav.Selected = true;
+			nav.Expanded = true;
+		}
 	}
 	
 	public class CombineOptions : AbstractMenuCommand
 	{
 		public override void Run()
 		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
-			CombineBrowserNode node    = browser.SelectedNode as CombineBrowserNode;
+			SolutionPad browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			Combine combine = nav.GetParentDataItem (typeof(Combine), true) as Combine;
+			if (combine == null) return;
 			
-			if (node != null) {
-				DefaultProperties defaultProperties = new DefaultProperties();
-				defaultProperties.SetProperty(&quot;Combine&quot;, node.Combine);
-				TreeViewOptions optionsDialog = new TreeViewOptions(defaultProperties,
-				                                                           AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/CombineOptions&quot;));
-			//		optionsDialog.SetDefaultSize = new Size(700, 450);
-			//		optionsDialog.FormBorderStyle = FormBorderStyle.FixedDialog;
-			//				
-			//		optionsDialog.TransientFor = (Gtk.Window)WorkbenchSingleton.Workbench;
-					optionsDialog.Run ();
-			//		optionsDialog.Hide ();
-					Runtime.ProjectService.SaveCombine ();
-				}
-			}
+			DefaultProperties defaultProperties = new DefaultProperties();
+			defaultProperties.SetProperty (&quot;Combine&quot;, combine);
+			TreeViewOptions optionsDialog = new TreeViewOptions (defaultProperties,
+																	   AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/CombineOptions&quot;));
+		//		optionsDialog.SetDefaultSize = new Size(700, 450);
+		//		optionsDialog.FormBorderStyle = FormBorderStyle.FixedDialog;
+		//				
+		//		optionsDialog.TransientFor = (Gtk.Window)WorkbenchSingleton.Workbench;
+				optionsDialog.Run ();
+		//		optionsDialog.Hide ();
+				Runtime.ProjectService.SaveCombine ();
+		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/FolderNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/FolderNodeCommands.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/FolderNodeCommands.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -23,7 +23,8 @@
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Gui.Pads.ProjectBrowser;
+using MonoDevelop.Gui.Pads;
+using MonoDevelop.Gui.Pads.ProjectPad;
 
 using Gtk;
 
@@ -31,17 +32,14 @@
 {
 	public class AddFilesToProject : AbstractMenuCommand
 	{
-		
 		public override void Run()
 		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
+			SolutionPad browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			if (nav == null) return;
 			
-			if (browser == null || browser.SelectedNode == null) {
-				return;
-			}
+			Project project = nav.GetParentDataItem (typeof(Project), true) as Project;
 			
-			AbstractBrowserNode node = (AbstractBrowserNode)browser.SelectedNode;
-			
 			using (FileSelector fdiag  = new FileSelector (GettextCatalog.GetString (&quot;Add files&quot;))) {
 				fdiag.SelectMultiple = true;
 				
@@ -51,8 +49,8 @@
 						return;
 					
 					foreach (string file in fdiag.Filenames) {
-						if (file.StartsWith(node.Project.BaseDirectory)) {
-							ProjectBrowserView.MoveCopyFile (file, node, true, true);
+						if (file.StartsWith (project.BaseDirectory)) {
+							MoveCopyFile (project, nav, file, true, true);
 						} else {
 							using (MessageDialog md = new MessageDialog (
 																		 (Window) WorkbenchSingleton.Workbench,
@@ -69,12 +67,10 @@
 								if (ret &lt; 0)
 									return;
 
-								try 
-								{
-									ProjectBrowserView.MoveCopyFile (file, node, ret == 2, false);
+								try {
+									MoveCopyFile (project, nav, file, ret == 2, false);
 								}
-								catch 
-								{
+								catch {
 									Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;An error occurred while attempt to move/copy that file. Please check your permissions.&quot;));
 								}
 							}
@@ -85,29 +81,50 @@
 				}
 			}
 		}
+		
+		public static void MoveCopyFile (Project project, ITreeNavigator nav, string filename, bool move, bool alreadyInPlace)
+		{
+			if (Runtime.FileUtilityService.IsDirectory (filename))
+			    return;
+
+			ProjectFolder folder = nav.GetParentDataItem (typeof(ProjectFolder), true) as ProjectFolder;
+			
+			string name = System.IO.Path.GetFileName (filename);
+			string baseDirectory = folder != null ? folder.Path : project.BaseDirectory;
+			string newfilename = alreadyInPlace ? filename : Path.Combine (baseDirectory, name);
+
+			if (filename != newfilename) {
+				File.Copy (filename, newfilename);
+				if (move)
+					Runtime.FileService.RemoveFile (filename);
+			}
+			
+			if (project.IsCompileable (newfilename)) {
+				project.AddFile (newfilename, BuildAction.Compile);
+			} else {
+				project.AddFile (newfilename, BuildAction.Nothing);
+			}
+
+			Runtime.ProjectService.SaveCombine();
+		}
 	}
 	
 	public class AddNewFileEvent : AbstractMenuCommand
 	{
 		string baseFolderPath;
-		AbstractBrowserNode node;
-		ProjectBrowserView browser;
+		SolutionPad browser;
+		Project project;
 
 		public override void Run()
 		{
-			browser = (ProjectBrowserView)Owner;
+			browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			project = nav.GetParentDataItem (typeof(Project), true) as Project;
+			if (project == null) return;
 			
-			if (browser == null || browser.SelectedNode == null) {
-				return;
-			}
+			ProjectFolder folder = nav.GetParentDataItem (typeof(ProjectFolder), true) as ProjectFolder;
+			baseFolderPath = folder != null ? folder.Path : project.BaseDirectory;
 			
-			node = (AbstractBrowserNode)browser.SelectedNode;
-			baseFolderPath = NewFolderEvent.SearchBasePath(node);
-			
-			if (baseFolderPath == null || baseFolderPath.Length == 0) {
-				return;
-			}
-			
 			NewFileDialog nfd = new NewFileDialog ();
 			nfd.OnOked += new EventHandler (newfileOked);
 		}
@@ -121,102 +138,74 @@
 			string extension = Path.GetExtension(window.ViewContent.UntitledName);
 				
 			// first try the default untitled name of the viewcontent filename
-			string fileName = Runtime.FileUtilityService.GetDirectoryNameWithSeparator(baseFolderPath) + baseName +  extension;
+			string fileName = Path.Combine (baseFolderPath, baseName +  extension);
 				
 			// if it is already in the project, or it does exists we try to get a name that is
 			// untitledName + Numer + extension
-			while (node.Project.IsFileInProject(fileName) || System.IO.File.Exists(fileName)) {
-				fileName = Runtime.FileUtilityService.GetDirectoryNameWithSeparator(baseFolderPath) + baseName + count.ToString() + extension;
+			while (project.IsFileInProject (fileName) || System.IO.File.Exists (fileName)) {
+				fileName = Path.Combine (baseFolderPath, baseName + count.ToString() + extension);
 				++count;
 			}
-				
+
 			// now we have a valid filename which we could use
-			window.ViewContent.Save(fileName);
+			window.ViewContent.Save (fileName);
 				
 			ProjectFile newFileInformation = new ProjectFile(fileName, BuildAction.Compile);
-				
-			AbstractBrowserNode newNode = new FileNode(newFileInformation);
-			newNode.ContextmenuAddinTreePath = FileNode.ProjectFileContextMenuPath;
-				
-			// Assume that the parent node of a 'leaf' (e.g. file) is
-			// a folder or project
-			AbstractBrowserNode parentNode = node;
-			if (!(parentNode is ProjectBrowserNode || parentNode is DirectoryNode)) {
-				parentNode = (AbstractBrowserNode)node.Parent;
-			}
-				
-			parentNode.Nodes.Add(newNode);
-			parentNode.Project.ProjectFiles.Add(newFileInformation);
-			window.ViewContent.Project = parentNode.Project;
-				
-			newNode.EnsureVisible();
-			browser.StealFocus ();
-			browser.SelectedNode = newNode;
-			browser.StartLabelEdit();
-				
+			project.ProjectFiles.Add (newFileInformation);
 			Runtime.ProjectService.SaveCombine();
-			
+
+			browser.AddNodeInsertCallback (newFileInformation, new TreeNodeCallback (OnFileInserted));
 		}
+		
+		void OnFileInserted (ITreeNavigator nav)
+		{
+			browser.StealFocus ();
+			nav.Selected = true;
+			browser.StartLabelEdit ();
+		}
 	}
 	
 	public class NewFolderEvent : AbstractMenuCommand
 	{
-		public static string SearchBasePath(AbstractBrowserNode node)
-		{
-			while (node != null) {
-				if (node is ProjectBrowserNode) {
-					return node.Project.BaseDirectory;
-				} else if (node is DirectoryNode) {
-					return ((DirectoryNode)node).FolderName;
-				}
-				node = (AbstractBrowserNode)node.Parent;
-			}
-			return null;
-		}
+		SolutionPad browser;
 		
 		public override void Run()
 		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
+			browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			if (nav == null) return;
 			
-			if (browser == null || browser.SelectedNode == null) {
-				return;
+			Project project = nav.GetParentDataItem (typeof(Project), true) as Project;
+			if (project == null) return;
+
+			ProjectFolder folder = nav.GetParentDataItem (typeof(ProjectFolder), true) as ProjectFolder;
+			string baseFolderPath = folder != null ? folder.Path : project.BaseDirectory;
+
+			string directoryName = Path.Combine (baseFolderPath, GettextCatalog.GetString(&quot;New Folder&quot;));
+			int index = -1;
+
+			if (Directory.Exists(directoryName)) {
+				while (Directory.Exists(directoryName + (++index + 1))) ;
 			}
-			AbstractBrowserNode selectedNode = (AbstractBrowserNode)browser.SelectedNode;
 			
-			string baseFolderPath = SearchBasePath(selectedNode);
-			
-			if (baseFolderPath != null &amp;&amp; baseFolderPath.Length &gt; 0) {
-				string directoryName = Runtime.FileUtilityService.GetDirectoryNameWithSeparator(baseFolderPath) + GettextCatalog.GetString(&quot;New Folder&quot;);
-				int    index         = -1;
-				
-				if (Directory.Exists(directoryName)) {
-					while (Directory.Exists(directoryName + (++index + 1))) ;
-				}
-				
-				if (index &gt;= 0) {
-					directoryName += index + 1;
-				}
-				
-				DirectoryNode newDirectoryNode = new DirectoryNode(directoryName);
-				Directory.CreateDirectory(newDirectoryNode.FolderName);
-						
-				// Assume that the parent node of a 'leaf' (e.g. file) is
-				// a folder or project
-				AbstractBrowserNode parentNode = selectedNode;
-				if (!(parentNode is ProjectBrowserNode || parentNode is DirectoryNode)) {
-					parentNode = (AbstractBrowserNode)selectedNode.Parent;
-				}
-				
-				parentNode.Nodes.Add(newDirectoryNode);
-				
-				ProjectFile newFolder = new ProjectFile(newDirectoryNode.FolderName);
-				newFolder.Subtype = Subtype.Directory;
-				parentNode.Project.ProjectFiles.Add(newFolder);
-				
-				newDirectoryNode.EnsureVisible();
-				browser.SelectedNode = newDirectoryNode;
-				browser.StartLabelEdit();
+			if (index &gt;= 0) {
+				directoryName += index + 1;
 			}
+			
+			Directory.CreateDirectory (directoryName);
+			
+			ProjectFile newFolder = new ProjectFile (directoryName);
+			newFolder.Subtype = Subtype.Directory;
+			project.ProjectFiles.Add (newFolder);
+
+			browser.AddNodeInsertCallback (newFolder, new TreeNodeCallback (OnFolderInserted));
 		}
+		
+		void OnFolderInserted (ITreeNavigator nav)
+		{
+			browser.StealFocus ();
+			nav.Selected = true;
+			browser.StartLabelEdit();
+		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/GeneralNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/GeneralNodeCommands.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/GeneralNodeCommands.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -23,7 +23,7 @@
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Gui.Pads.ProjectBrowser;
+using MonoDevelop.Gui.Pads;
 
 namespace MonoDevelop.Commands.ProjectBrowser
 {
@@ -31,19 +31,8 @@
 	{
 		public override void Run()
 		{
-			ProjectBrowserView  browser = (ProjectBrowserView)Owner;
-			AbstractBrowserNode node    = browser.SelectedNode as AbstractBrowserNode;
-			
-			if (node.IsEditing) { // TODO : throw remove key to the browser component.
-				return;
-			}
-			
-			if (node != null &amp;&amp; node.Parent != null) {
-				if (node.RemoveNode()) {
-					node.Parent.Nodes.Remove(node);
-					Runtime.ProjectService.SaveCombine();
-				}
-			}
+			SolutionPad pad = (SolutionPad) Owner;
+			pad.RemoveCurrentItem ();
 		}
 	}
 	
@@ -51,7 +40,7 @@
 	{
 		public override void Run()
 		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
+			SolutionPad browser = (SolutionPad) Owner;
 			browser.StartLabelEdit();
 		}
 	}
@@ -60,12 +49,8 @@
 	{
 		public override void Run()
 		{
-			ProjectBrowserView  browser = (ProjectBrowserView)Owner;
-			AbstractBrowserNode node    = browser.SelectedNode as AbstractBrowserNode;
-			
-			if (node != null) {
-				node.ActivateItem();
-			}
+			SolutionPad browser = (SolutionPad)Owner;
+			browser.ActivateCurrentItem ();
 		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ProjectNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ProjectNodeCommands.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ProjectNodeCommands.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -22,7 +22,7 @@
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Gui.Pads.ProjectBrowser;
+using MonoDevelop.Gui.Pads;
 
 namespace MonoDevelop.Commands.ProjectBrowser
 {
@@ -30,15 +30,17 @@
 	{
 		public override void Run()
 		{
-			ProjectBrowserView  browser = (ProjectBrowserView)Owner;
-			ProjectBrowserNode  node    = browser.SelectedNode as ProjectBrowserNode;
+			SolutionPad browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			if (nav == null) return;
 			
-			if (node != null) {
-				Combine combine                = node.Combine;
-				combine.SingleStartProjectName = node.Project.Name;
-				combine.SingleStartupProject   = true;
-				Runtime.ProjectService.SaveCombine();
-			}
+			Project project = nav.DataItem as Project;
+			if (project == null) return;
+			
+			Combine combine = nav.GetParentDataItem (typeof(Combine), false) as Combine;
+			combine.SingleStartProjectName = project.Name;
+			combine.SingleStartupProject = true;
+			Runtime.ProjectService.SaveCombine ();
 		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -24,7 +24,7 @@
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Gui.Pads.ProjectBrowser;
+using MonoDevelop.Gui.Pads;
 
 namespace MonoDevelop.Commands.ProjectBrowser
 {
@@ -32,98 +32,32 @@
 	{
 		public override void Run()
 		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
-			FolderNode         node    = browser.SelectedNode as FolderNode;
+			SolutionPad browser = (SolutionPad) Owner;
+			ITreeNavigator tnav = browser.GetSelectedNode ();
+			Project project = tnav.GetParentDataItem (typeof(Project), true) as Project;
 			
-			if (node != null) {
-				Project project = ((ProjectBrowserNode)node.Parent).Project;
-				
+			if (project != null) {
 				SelectReferenceDialog selDialog = new SelectReferenceDialog(project);
 				if (selDialog.Run() == (int)Gtk.ResponseType.Ok) {
+					ProjectReferenceCollection newRefs = selDialog.ReferenceInformations;
 					
-					project.ProjectReferences.Clear ();
-					foreach (ProjectReference refInfo in selDialog.ReferenceInformations) {
-						project.ProjectReferences.Add(refInfo);
-					}
+					ArrayList toDelete = new ArrayList ();
+					foreach (ProjectReference refInfo in project.ProjectReferences)
+						if (!newRefs.Contains (refInfo))
+							toDelete.Add (refInfo);
 					
-					DefaultDotNetNodeBuilder.InitializeReferences(node, project);
+					foreach (ProjectReference refInfo in toDelete)
+							project.ProjectReferences.Remove (refInfo);
+
+					foreach (ProjectReference refInfo in selDialog.ReferenceInformations)
+						if (!project.ProjectReferences.Contains (refInfo))
+							project.ProjectReferences.Add(refInfo);
+					
 					Runtime.ProjectService.SaveCombine();
+					tnav.Expanded = true;
 				}
 				selDialog.Hide ();
 			}
-			node.Expand();
 		}
-	}
-	
-	/*
-	public class RefreshWebReference : AbstractMenuCommand
-	{
-		public override void Run()
-		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
-			ReferenceNode   node    = browser.SelectedNode as ReferenceNode;
-			if (node != null) {				
-				Project project = node.Project;  //((ProjectBrowserNode)node.Parent.Parent).Project;
-				IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
-				
-				ProjectReference refInfo = (ProjectWebReference)node.UserData;
-				WebReference.GenerateWebProxy(project, refInfo.HRef);				
-				parserService.AddReferenceToCompletionLookup(project, refInfo);							
-			}
-		}
-	}*/
-	
-	public class AddWebReferenceToProject : AbstractMenuCommand
-	{
-		public override void Run()
-		{
-/*			ProjectBrowserView browser = (ProjectBrowserView)Owner;
-			AbstractBrowserNode node   = browser.SelectedNode as AbstractBrowserNode;
-			AbstractBrowserNode projectNode = DefaultDotNetNodeBuilder.GetProjectNode(node);
-			bool bInitReferences = false;
-			
-			if (node != null) {
-				Project project = ((ProjectBrowserNode)node.Parent).Project;
-			
-				using (AddWebReferenceDialog refDialog = new AddWebReferenceDialog(project)) {
-					if (refDialog.ShowDialog() == DialogResult.OK) {						
-						foreach(object objReference in refDialog.ReferenceInformations) {
-							if(objReference is ProjectReference) {
-								ProjectReference refInfo = (ProjectReference)objReference;
-								project.ProjectReferences.Add(refInfo);
-								if(refInfo.ReferenceType == ReferenceType.Assembly) {
-									parserService.AddReferenceToCompletionLookup(project, refInfo);
-									bInitReferences = true;
-								}
-							} else if(objReference is ProjectFile) {
-								ProjectFile projectFile = (ProjectFile) objReference;
-								//HACK: fix later
-								if(projectFile.Subtype == Subtype.WebReferences || projectFile.Subtype == Subtype.Directory) {																		
-									AbstractBrowserNode checkNode = DefaultDotNetNodeBuilder.GetPath(fileUtilityService.AbsoluteToRelativePath(project.BaseDirectory,projectFile.Name + Path.DirectorySeparatorChar), projectNode, false);
-									if(checkNode != null) {
-										continue;
-									}
-								}																																	
-								// add to the project browser
-								DefaultDotNetNodeBuilder.AddProjectFileNode(project, projectNode, projectFile);
-									
-								// add to the project
-								projectService.AddFileToProject(project, projectFile);
-								
-								// add to code completion
-								if(projectFile.Subtype == Subtype.Code ) {
-									parserService.ParseFile(projectFile.Name);
-								}
-								
-							}							
-						}
-						if(bInitReferences) {
-							DefaultDotNetNodeBuilder.InitializeReferences(node, project);						
-						}
-						projectService.SaveCombine();						
-					}
-				}
-			}*/
-		}
-	}
+	}	
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -25,7 +25,7 @@
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Gui.Pads.ProjectBrowser;
+using MonoDevelop.Gui.Pads;
 using MonoDevelop.Gui.Widgets;
 
 using Gtk;
@@ -37,43 +37,52 @@
 	{
 		public override void Run()
 		{
-			ProjectBrowserView browser = (ProjectBrowserView)Owner;
-			FolderNode         node    = browser.SelectedNode as FolderNode;
+			SolutionPad browser = (SolutionPad) Owner;
+			ITreeNavigator nav = browser.GetSelectedNode ();
+			if (nav == null) return;
 			
-			if (node != null) {
-				Project project = ((ProjectBrowserNode) node.Parent).Project;
-				
-				show_dialog:
-									
-				using (FileSelector fs = new FileSelector (GettextCatalog.GetString (&quot;File to Open&quot;))) {
-					fs.SelectMultiple = true;
-					fs.SetFilename (project.BaseDirectory);
-					int response = fs.Run ();
-					string [] files = fs.Filenames;
-					fs.Hide ();
+			Project project = nav.GetParentDataItem (typeof(Project), true) as Project;
+			if (project == null) return;
+			
+			string [] files;
+			do {
+				files = AskFiles (project);
+				if (files == null) return;
+			}
+			while (!CheckFiles (files));
+			
+			nav.Expanded = true;
+		
+			foreach (string fileName in files)
+				project.AddFile (fileName, BuildAction.EmbedAsResource);
+			Runtime.ProjectService.SaveCombine ();
+		}
+		
+		string[] AskFiles (Project project)
+		{
+			using (FileSelector fs = new FileSelector (GettextCatalog.GetString (&quot;File to Open&quot;))) {
+				fs.SelectMultiple = true;
+				fs.SetFilename (project.BaseDirectory);
+				int response = fs.Run ();
+				string [] files = fs.Filenames;
+				fs.Hide ();
 
-					if (response != (int)Gtk.ResponseType.Ok)
-						return;
-				
-					foreach (string file in files) {
-						if (!System.IO.File.Exists (file)) {
-							Runtime.MessageService.ShowError (String.Format (GettextCatalog.GetString (&quot;Resource file '{0}' does not exist&quot;), file));
-							goto show_dialog;
-						}
-					}
-				
-					foreach (string fileName in files) {
-						ProjectFile fileInformation = project.AddFile (fileName, BuildAction.EmbedAsResource);
-					
-						AbstractBrowserNode newResNode = new FileNode(fileInformation);
-						newResNode.Image = Stock.ResourceFileIcon;
-						node.Nodes.Add (newResNode);
-					}
-
-					node.Expand();
-					Runtime.ProjectService.SaveCombine ();
+				if (response != (int)Gtk.ResponseType.Ok)
+					return null;
+				else
+					return files;
+			}
+		}
+		
+		bool CheckFiles (string[] files)
+		{
+			foreach (string file in files) {
+				if (!System.IO.File.Exists (file)) {
+					Runtime.MessageService.ShowError (String.Format (GettextCatalog.GetString (&quot;Resource file '{0}' does not exist&quot;), file));
+					return false;
 				}
 			}
+			return true;
 		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/AbstractPadContent.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/AbstractPadContent.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/AbstractPadContent.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -16,6 +16,8 @@
 	{
 		string title;
 		string icon;
+		string id;
+		string defaultPosition = &quot;left&quot;;
 		
 		public abstract Gtk.Widget Control {
 			get;
@@ -32,15 +34,27 @@
 				return icon;
 			}
 		}
+
+		public string Id {
+			get { return id; }
+			set { id = value; }
+		}
 		
+		public string DefaultPlacement {
+			get { return defaultPosition; }
+			set { defaultPosition = value; }
+		}
+		
 		public AbstractPadContent(string title) : this(title, null)
 		{
+			id = GetType ().FullName;
 		}
 		
 		public AbstractPadContent(string title, string iconResoureName)
 		{
 			this.title = title;
 			this.icon  = iconResoureName;
+			id = GetType ().FullName;
 		}
 		
 		public virtual void RedrawContent()

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/SdMenuCheckBox.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/SdMenuCheckBox.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/SdMenuCheckBox.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -45,7 +45,6 @@
 	
 		public SdMenuCheckBox (string label) : base ()
 		{
-			Toggled += new EventHandler (OnClick);
 			Gtk.AccelLabel child = new Gtk.AccelLabel (label);
 			child.Xalign = 0;
 			child.UseUnderline = true;
@@ -72,8 +71,9 @@
 			UpdateStatus();
 		}
 		
-		protected void OnClick(object o, EventArgs e)
+		protected override void OnToggled ()
 		{
+			base.OnToggled ();
 			if (menuCommand != null) {
 				menuCommand.IsChecked = Active;
 			}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/SdMenuCommand.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/SdMenuCommand.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/SdMenuCommand.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -28,6 +28,7 @@
 		string description   = String.Empty;
 		string localizedText = String.Empty;
 		ICommand menuCommand = null;
+		bool internalActivate;
 		
 		string tag;
 		
@@ -70,7 +71,7 @@
 		{
 			this.caller              = caller;
 			this.conditionCollection = conditionCollection;
-			this.Activated += new EventHandler (OnClick);
+			internalActivate = true;
 			UpdateStatus();
 		}
 		
@@ -79,7 +80,7 @@
 			this.caller = caller;
 			this.conditionCollection = conditionCollection;
 			this.menuCommand = menuCommand;
-			this.Activated += new EventHandler (OnClick);
+			internalActivate = true;
 			UpdateStatus();
 		}
 		
@@ -120,9 +121,10 @@
 			}
 		}
 		
-		protected void OnClick(object o, EventArgs e)
+		protected override void OnActivated ()
 		{
-			if (menuCommand != null) {
+			base.OnActivated ();
+			if (internalActivate &amp;&amp; menuCommand != null) {
 				menuCommand.Run();
 			}
 		}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/SelectReferenceDialog.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/SelectReferenceDialog.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/SelectReferenceDialog.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -37,16 +37,16 @@
 
 		Project configureProject;
 		
-		public ArrayList ReferenceInformations {
+		public ProjectReferenceCollection ReferenceInformations {
 			get {
-				ArrayList referenceInformations = new ArrayList();
+				ProjectReferenceCollection referenceInformations = new ProjectReferenceCollection();
 				Gtk.TreeIter looping_iter;
 				if (refTreeStore.GetIterFirst (out looping_iter) == false) {
 					return referenceInformations;
 				}
 				do {
 					//Debug.Assert(item.Tag != null);
-					referenceInformations.Add(refTreeStore.GetValue(looping_iter, 3));
+					referenceInformations.Add ((ProjectReference) refTreeStore.GetValue(looping_iter, 3));
 				} while (refTreeStore.IterNext (ref looping_iter));
 				return referenceInformations;
 			}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IPadContent.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IPadContent.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IPadContent.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -17,6 +17,25 @@
 	public interface IPadContent : IDisposable
 	{
 		/// &lt;summary&gt;
+		/// Id of the pad
+		/// &lt;/summary&gt;
+		string Id {
+			get;
+		}
+		
+		/// &lt;summary&gt;
+		/// Returns the default placement of the pad: left, right, top, bottom.
+		/// Relative positions can be used, for example: &quot;ProjectPad/left&quot;
+		/// would show the pad at the left of the project pad. When using
+		/// relative placements several positions can be provided. If the
+		/// pad can be placed in the first position, the next one will be
+		/// tried. For example &quot;ProjectPad/left; bottom&quot;.
+		/// &lt;/summary&gt;
+		string DefaultPlacement {
+			get;
+		}
+		
+		/// &lt;summary&gt;
 		/// Returns the title of the pad.
 		/// &lt;/summary&gt;
 		string Title {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IWorkbench.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IWorkbench.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IWorkbench.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -10,10 +10,37 @@
 
 namespace MonoDevelop.Gui
 {
-	public enum WorkbenchContext
+	public class WorkbenchContext
 	{
-		Edit,
-		Debug
+		string id;
+		static Hashtable contexts = new Hashtable ();
+		
+		WorkbenchContext (string id)
+		{
+			this.id = id;
+		}
+		
+		public static WorkbenchContext GetContext (string id)
+		{
+			WorkbenchContext ctx = (WorkbenchContext) contexts [id];
+			if (ctx == null) {
+				ctx = new WorkbenchContext (id);
+				contexts [id] = ctx;
+			}
+			return ctx;
+		}
+		
+		public static WorkbenchContext Edit {
+			get { return GetContext (&quot;Edit&quot;); }
+		}
+		
+		public static WorkbenchContext Debug {
+			get { return GetContext (&quot;Debug&quot;); }
+		}
+		
+		public string Id {
+			get { return id; }
+		}
 	}
 	
 	/// &lt;summary&gt;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/PadContentCollection.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/PadContentCollection.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/PadContentCollection.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -67,10 +67,10 @@
 			}
 		}
 		
-		public IPadContent this[string typeName] {
+		public IPadContent this [string id] {
 			get {
 				foreach (IPadContent padContent in this) {
-					if (padContent.GetType().FullName == typeName) {
+					if (padContent.Id == id) {
 						return padContent;
 					}
 				}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ClassData.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ClassData.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ClassData.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,75 @@
+//
+// ClassData.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class ClassData
+	{
+		IClass cls;
+		Project project;
+		
+		public ClassData (Project p, IClass c)
+		{
+			cls = c;
+			project = p;
+		}
+		
+		public IClass Class {
+			get { return cls; }
+		}
+		
+		public Project Project {
+			get { return project; }
+		}
+		
+		public override bool Equals (object ob)
+		{
+			ClassData other = ob as ClassData;
+			return (cls.FullyQualifiedName == other.cls.FullyQualifiedName &amp;&amp;
+					project == other.project);
+		}
+		
+		public override int GetHashCode ()
+		{
+			return (cls.FullyQualifiedName + project.Name).GetHashCode ();
+		}
+		
+		public override string ToString ()
+		{
+			return base.ToString () + &quot; [&quot; + cls.FullyQualifiedName + &quot;, &quot; + project.Name + &quot;]&quot;;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ClassNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ClassNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ClassNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,129 @@
+//
+// ClassNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class ClassNodeBuilder: TypeNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof(ClassData); }
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof(ClassNodeCommandHandler); }
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return ((ClassData)dataObject).Class.Name;
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			ClassData classData = dataObject as ClassData;
+			label = classData.Class.Name;
+			icon = Context.GetIcon (Runtime.Gui.Icons.GetIcon (classData.Class));
+		}
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			ClassData classData = dataObject as ClassData;
+
+			foreach (IClass innerClass in classData.Class.InnerClasses)
+				builder.AddChild (innerClass);
+
+			foreach (IMethod method in classData.Class.Methods)
+				builder.AddChild (method);
+			
+			foreach (IProperty property in classData.Class.Properties)
+				builder.AddChild (property);
+			
+			foreach (IField field in classData.Class.Fields)
+				builder.AddChild (field);
+			
+			foreach (IEvent e in classData.Class.Events)
+				builder.AddChild (e);
+		}
+
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			ClassData classData = dataObject as ClassData;
+			return 	classData.Class.InnerClasses.Count &gt; 0 ||
+					classData.Class.Methods.Count &gt; 0 ||
+					classData.Class.Properties.Count &gt; 0 ||
+					classData.Class.Fields.Count &gt; 0 ||
+					classData.Class.Events.Count &gt; 0;
+		}
+		
+		public override int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			if (otherDataObject is ClassData)
+				return DefaultSort;
+			else
+				return 1;
+		}
+	}
+	
+	public class ClassNodeCommandHandler: NodeCommandHandler
+	{
+		public override void ActivateItem ()
+		{
+			string file = GetFileName ();
+			Runtime.FileService.OpenFile (file, new FileOpeningFinished (OnFileOpened));
+		}
+		
+		private void OnFileOpened()
+		{
+			ClassData cls = CurrentNode.DataItem as ClassData;
+			int line = cls.Class.Region.BeginLine;
+			string file = GetFileName ();
+			
+			IWorkbenchWindow window = Runtime.FileService.GetOpenFile (file);
+			if (window == null) return;
+			
+			IViewContent content = window.ViewContent;
+			if (content is IPositionable) {
+				((IPositionable)content).JumpTo (Math.Max (0, line), 0);
+			}
+		}
+		
+		string GetFileName ()
+		{
+			ClassData cls = (ClassData) CurrentNode.GetParentDataItem (typeof(ClassData), true);
+			if (cls != null &amp;&amp; cls.Class.Region.FileName != null) return cls.Class.Region.FileName;
+			return null;
+		}
+	}	
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/CombineNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/CombineNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/CombineNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,137 @@
+//
+// CombineNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class CombineNodeBuilder: TypeNodeBuilder
+	{
+		CombineEntryEventHandler combineEntryAdded;
+		CombineEntryEventHandler combineEntryRemoved;
+		CombineEntryRenamedEventHandler combineNameChanged;
+		
+		public CombineNodeBuilder ()
+		{
+			combineEntryAdded = (CombineEntryEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEntryEventHandler (OnEntryAdded));
+			combineEntryRemoved = (CombineEntryEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEntryEventHandler (OnEntryRemoved));
+			combineNameChanged = (CombineEntryRenamedEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEntryRenamedEventHandler (OnCombineRenamed));
+		}
+			
+		public override Type NodeDataType {
+			get { return typeof(Combine); }
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return ((Combine)dataObject).Name;
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			Combine combine = dataObject as Combine;
+			label = String.Format (GettextCatalog.GetString (&quot;Solution {0}&quot;), combine.Name);
+			icon = Context.GetIcon (Stock.CombineIcon);
+		}
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			Combine combine = (Combine) dataObject;
+			if (builder.Options [&quot;ShowProjects&quot;]) {
+				foreach (CombineEntry entry in combine.Entries)
+					builder.AddChild (entry);
+			} else {
+				AddClasses (builder, combine);
+			}
+		}
+
+		void AddClasses (ITreeBuilder builder, CombineEntry entry)
+		{
+			if (entry is Combine) {
+				foreach (CombineEntry e in ((Combine)entry).Entries)
+					AddClasses (builder, e);
+			} else if (entry is Project) {
+				ProjectNodeBuilder.BuildChildNodes (builder, entry as Project);
+			}
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return ((Combine) dataObject).Entries.Count &gt; 0;
+		}
+		
+		public override int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			if (otherDataObject is Combine)
+				return DefaultSort;
+			else
+				return -1;
+		}
+
+		public override void OnNodeAdded (object dataObject)
+		{
+			Combine combine = (Combine) dataObject;
+			combine.EntryAdded += combineEntryAdded;
+			combine.EntryRemoved += combineEntryRemoved;
+			combine.NameChanged += combineNameChanged;
+		}
+		
+		public override void OnNodeRemoved (object dataObject)
+		{
+			Combine combine = (Combine) dataObject;
+			combine.EntryAdded -= combineEntryAdded;
+			combine.EntryRemoved -= combineEntryRemoved;
+			combine.NameChanged -= combineNameChanged;
+		}
+		
+		void OnEntryAdded (object sender, CombineEntryEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (sender);
+			if (tb != null) {
+				tb.AddChild (e.CombineEntry, true);
+				tb.Expanded = true;
+			}
+		}
+
+		void OnEntryRemoved (object sender, CombineEntryEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.CombineEntry);
+			if (tb != null) tb.Remove ();
+		}
+		
+		void OnCombineRenamed (object sender, CombineEntryRenamedEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.CombineEntry);
+			if (tb != null) tb.Update ();
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/EventNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/EventNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/EventNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,60 @@
+//
+// EventNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class EventNodeBuilder: MemberNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof(IEvent); }
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			IEvent data = dataObject as IEvent;
+			label = data.Name;
+			icon = Context.GetIcon (Runtime.Gui.Icons.GetIcon (data));
+		}
+
+		public override int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			ITreeOptions options = Context.GetOptions (thisDataObject);
+			if (options [&quot;GroupByType&quot;]) {
+			
+			}
+			return DefaultSort;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/FieldNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/FieldNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/FieldNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,51 @@
+//
+// FieldNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class FieldNodeBuilder: MemberNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof(IField); }
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			IField data = dataObject as IField;
+			label = data.Name;
+			icon = Context.GetIcon (Runtime.Gui.Icons.GetIcon (data));
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MemberNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MemberNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MemberNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,87 @@
+//
+// MemberNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public abstract class MemberNodeBuilder: TypeNodeBuilder
+	{
+		public override string GetNodeName (object dataObject)
+		{
+			return ((IMember)dataObject).Name;
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof(MemberNodeCommandHandler); }
+		}
+		
+		public override int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			if (!(otherDataObject is IMember)) return 1;
+
+			ITreeOptions options = Context.GetOptions (thisDataObject);
+			if (options [&quot;GroupByType&quot;]) {
+				int v1 = GetTypeSortValue (thisDataObject);
+				int v2 = GetTypeSortValue (otherDataObject);
+				if (v1 &lt; v2) return -1;
+				else if (v1 &gt; v2) return 1;
+			}
+			if (options [&quot;GroupByAccess&quot;]) {
+				int v1 = GetAccessSortValue (((IMember)thisDataObject).Modifiers);
+				int v2 = GetAccessSortValue (((IMember)otherDataObject).Modifiers);
+				if (v1 &lt; v2) return -1;
+				else if (v1 &gt; v2) return 1;
+			}
+			return DefaultSort;
+		}
+		
+		int GetTypeSortValue (object member)
+		{
+			if (member is IField) return 0;
+			if (member is IEvent) return 1;
+			if (member is IProperty) return 2;
+			if (member is IMethod) return 3;
+			return 4;
+		}
+		
+		int GetAccessSortValue (ModifierEnum mods)
+		{
+			if ((mods &amp; ModifierEnum.Private) != 0) return 0;
+			if ((mods &amp; ModifierEnum.Internal) != 0) return 1;
+			if ((mods &amp; ModifierEnum.Protected) != 0) return 2;
+			if ((mods &amp; ModifierEnum.Public) != 0) return 3;
+			return 4;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MemberNodeCommandHandler.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MemberNodeCommandHandler.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MemberNodeCommandHandler.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,73 @@
+//
+// MemberNodeCommandHandler.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class MemberNodeCommandHandler: NodeCommandHandler
+	{
+		public override void ActivateItem ()
+		{
+			string file = GetFileName ();
+			Runtime.FileService.OpenFile (file, new FileOpeningFinished (OnFileOpened));
+		}
+		
+		private void OnFileOpened()
+		{
+			IMember member = CurrentNode.DataItem as IMember;
+			int line = member.Region.BeginLine;
+			string file = GetFileName ();
+			
+			IWorkbenchWindow window = Runtime.FileService.GetOpenFile (file);
+			if (window == null) {
+				return;
+			}
+			
+			IViewContent content = window.ViewContent;
+			if (content is IPositionable) {
+				((IPositionable)content).JumpTo (Math.Max (0, line), 0);
+			}
+		}
+		
+		string GetFileName ()
+		{
+			IMember member = (IMember) CurrentNode.GetParentDataItem (typeof(IMember), true);
+			if (member != null &amp;&amp; member.Region.FileName != null) return member.Region.FileName;
+			
+			ClassData cls = (ClassData) CurrentNode.GetParentDataItem (typeof(ClassData), true);
+			if (cls != null &amp;&amp; cls.Class.Region.FileName != null) return cls.Class.Region.FileName;
+			
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MethodNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MethodNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/MethodNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,51 @@
+//
+// MethodNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class MethodNodeBuilder: MemberNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof(IMethod); }
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			IMethod data = dataObject as IMethod;
+			label = data.Name;
+			icon = Context.GetIcon (Runtime.Gui.Icons.GetIcon (data));
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/NamespaceData.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/NamespaceData.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/NamespaceData.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,84 @@
+//
+// NamespaceData.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class NamespaceData
+	{
+		string namesp;
+		Project project;
+		
+		public NamespaceData (Project p, string fullNamespace)
+		{
+			project = p;
+			namesp = fullNamespace;
+		}
+		
+		public string Name {
+			get {
+				int i = namesp.LastIndexOf (&quot;.&quot;);
+				if (i != -1) return namesp.Substring (i+1);
+				else return namesp;
+			}
+		}
+		
+		public string FullName {
+			get { return namesp; }
+		}
+		
+		public Project Project {
+			get { return project; }
+		}
+		
+		public override bool Equals (object ob)
+		{
+			NamespaceData other = ob as NamespaceData;
+			return (namesp == other.namesp &amp;&amp;
+					project == other.project);
+		}
+		
+		public override int GetHashCode ()
+		{
+			if (project != null) return (namesp + project.Name).GetHashCode ();
+			else return namesp.GetHashCode ();
+		}
+		
+		public override string ToString ()
+		{
+			return base.ToString () + &quot; [&quot; + namesp + &quot;, &quot; + (project != null ? project.Name : &quot;no project&quot;) + &quot;]&quot;;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/NamespaceNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/NamespaceNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/NamespaceNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,198 @@
+//
+// NamespaceNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class NamespaceNodeBuilder: TypeNodeBuilder
+	{
+		ClassInformationEventHandler changeClassInformationHandler;
+		
+		public override Type NodeDataType {
+			get { return typeof(NamespaceData); }
+		}
+		
+		protected override void Initialize ()
+		{
+			changeClassInformationHandler = (ClassInformationEventHandler) Runtime.DispatchService.GuiDispatch (new ClassInformationEventHandler (OnClassInformationChanged));
+			Runtime.ParserService.ClassInformationChanged += changeClassInformationHandler;
+		}
+		
+		public override void Dispose ()
+		{
+			Runtime.ParserService.ClassInformationChanged -= changeClassInformationHandler;
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return Context.GetOptions (dataObject) [&quot;NestedNamespaces&quot;] ? ((NamespaceData)dataObject).Name : ((NamespaceData)dataObject).FullName;
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			NamespaceData nsData = dataObject as NamespaceData;
+			label = treeBuilder.Options [&quot;NestedNamespaces&quot;] ? nsData.Name : nsData.FullName;
+			icon = Context.GetIcon (Stock.NameSpace);
+		}
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			NamespaceData nsData = dataObject as NamespaceData;
+			
+			if (nsData.Project != null) {
+				ArrayList list = Runtime.ParserService.GetNamespaceContents (nsData.Project, nsData.FullName, false);
+				AddProjectContent (builder, nsData.Project, nsData, list);
+			}
+			else {
+				foreach (Project p in Runtime.ProjectService.CurrentOpenCombine.GetAllProjects ()) {
+					ArrayList list = Runtime.ParserService.GetNamespaceContents (p, nsData.FullName, false);
+					AddProjectContent (builder, p, nsData, list);
+				}
+			}
+			
+		}
+		
+		void AddProjectContent (ITreeBuilder builder, Project project, NamespaceData nsData, ArrayList list)
+		{
+			bool nestedNs = builder.Options [&quot;NestedNamespaces&quot;];
+
+			foreach (object ob in list) {
+				if (ob is string &amp;&amp; nestedNs) {
+					string ns = nsData.FullName + &quot;.&quot; + ob;
+					if (!builder.HasChild (ob as string, typeof(NamespaceData)))
+						builder.AddChild (new NamespaceData (project, ns));
+				}
+				else if (ob is IClass)
+					builder.AddChild (new ClassData (project, ob as IClass));
+			}
+		}
+		
+		void OnClassInformationChanged (object sender, ClassInformationEventArgs e)
+		{
+			Hashtable oldStatus = new Hashtable ();
+			ArrayList namespacesToClean = new ArrayList ();
+			ITreeBuilder tb = Context.GetTreeBuilder ();
+			
+			foreach (IClass cls in e.ClassInformation.Removed) {
+				if (tb.MoveToObject (new ClassData (e.Project, cls))) {
+					oldStatus [tb.DataItem] = tb.Expanded;
+					
+					ITreeNavigator np = tb.Clone ();
+					np.MoveToParent ();
+					oldStatus [np.DataItem] = np.Expanded;
+					
+					tb.Remove (true);
+				}
+				namespacesToClean.Add (cls.Namespace);
+			}
+			
+			foreach (IClass cls in e.ClassInformation.Modified) {
+				if (tb.MoveToObject (new ClassData (e.Project, cls))) {
+					oldStatus [tb.DataItem] = tb.Expanded;
+					
+					ITreeNavigator np = tb.Clone ();
+					np.MoveToParent ();
+					oldStatus [np.DataItem] = np.Expanded;
+					
+					tb.Remove (true);
+					tb.AddChild (new ClassData (e.Project, cls));
+				}
+			}
+			
+			foreach (IClass cls in e.ClassInformation.Added) {
+				AddClass (e.Project, cls);
+			}
+			
+			// Clean empty namespaces
+			
+			foreach (string ns in namespacesToClean) {
+				string subns = ns;
+				while (subns != null) {
+					bool found = tb.MoveToObject (new NamespaceData (e.Project, subns));
+					if (!found) found = tb.MoveToObject (new NamespaceData (null, subns));
+					if (found) {
+						while (tb.DataItem is NamespaceData &amp;&amp; !tb.HasChildren())
+							tb.Remove (true);
+						break;
+					}
+					int i = subns.LastIndexOf ('.');
+					if (i != -1) subns = subns.Substring (0,i);
+					else subns = null;
+				}
+			}
+			
+			// Restore expand status
+			
+			foreach (DictionaryEntry de in oldStatus) {
+				if ((bool)de.Value &amp;&amp; tb.MoveToObject (de.Key)) {
+					tb.ExpandToNode ();
+					tb.Expanded = true;
+				}
+			}
+		}
+		
+		void AddClass (Project project, IClass cls)
+		{
+			ITreeBuilder builder = Context.GetTreeBuilder ();
+			if (!builder.MoveToObject (project))
+				builder.MoveToRoot ();
+			
+			if (cls.Namespace == &quot;&quot;) {
+				builder.AddChild (new ClassData (project, cls));
+			} else {
+				if (builder.Options [&quot;NestedNamespaces&quot;]) {
+					string[] nsparts = cls.Namespace.Split ('.');
+					string ns = &quot;&quot;;
+					foreach (string nsp in nsparts) {
+						if (ns.Length &gt; 0) ns += &quot;.&quot;;
+						ns += nsp;
+						if (!builder.MoveToChild (nsp, typeof(NamespaceData)))
+							builder.AddChild (new NamespaceData (project, ns), true);
+					}
+					builder.AddChild (new ClassData (project, cls));
+				} else {
+					if (builder.MoveToChild (cls.Namespace, typeof(NamespaceData)))
+						builder.AddChild (new ClassData (project, cls));
+					else
+						builder.AddChild (new NamespaceData (project, cls.Namespace));
+				}
+			}
+		}
+
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return true;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ProjectNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ProjectNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/ProjectNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,133 @@
+//
+// ProjectNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Text;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class ProjectNodeBuilder: TypeNodeBuilder
+	{
+		CombineEntryRenamedEventHandler projectNameChanged;
+
+		public ProjectNodeBuilder ()
+		{
+			projectNameChanged = (CombineEntryRenamedEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEntryRenamedEventHandler (OnProjectRenamed));
+		}
+		
+		public override Type NodeDataType {
+			get { return typeof(Project); }
+		}
+		
+		public override void OnNodeAdded (object dataObject)
+		{
+			Project project = (Project) dataObject;
+			project.NameChanged += projectNameChanged;
+		}
+		
+		public override void OnNodeRemoved (object dataObject)
+		{
+			Project project = (Project) dataObject;
+			project.NameChanged -= projectNameChanged;
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return ((Project)dataObject).Name;
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			Project p = dataObject as Project;
+			label = p.Name;
+			string iconName = Runtime.Gui.Icons.GetImageForProjectType (p.ProjectType);
+			icon = Context.GetIcon (iconName);
+		}
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			Project project = (Project) dataObject;
+			BuildChildNodes (builder, project);
+		}
+		
+		public static void BuildChildNodes (ITreeBuilder builder, Project project)
+		{
+			ArrayList list = Runtime.ParserService.GetNamespaceContents (project, &quot;&quot;, false);
+			foreach (object ob in list) {
+				if (ob is string) {
+					if (builder.Options [&quot;NestedNamespaces&quot;])
+						builder.AddChild (new NamespaceData (project, ob as string));
+					else {
+						FillNamespaces (builder, project, ob as string);
+					}
+				}
+				else
+					builder.AddChild (new ClassData (project, ob as IClass));
+			}
+		}
+		
+		public static void FillNamespaces (ITreeBuilder builder, Project project, string ns)
+		{
+			if (Runtime.ParserService.GetClassList (project, ns, false, true).Length &gt; 0) {
+				if (builder.Options [&quot;ShowProjects&quot;])
+					builder.AddChild (new NamespaceData (project, ns));
+				else {
+					if (!builder.HasChild (ns, typeof (NamespaceData)))
+						builder.AddChild (new NamespaceData (null, ns));
+				}
+			}
+				
+			string[] list = Runtime.ParserService.GetNamespaceList (project, ns, false, true);
+			foreach (string subns in list)
+				FillNamespaces (builder, project, ns + &quot;.&quot; + subns);
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return true;
+		}
+		
+		void OnRenameFile (object sender, ProjectFileRenamedEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.ProjectFile);
+			if (tb != null) tb.Update ();
+		}
+		
+		void OnProjectRenamed (object sender, CombineEntryRenamedEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.CombineEntry);
+			if (tb != null) tb.Update ();
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/PropertyNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/PropertyNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassPad/PropertyNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,51 @@
+//
+// PropertyNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Gui.Pads.ClassPad
+{
+	public class PropertyNodeBuilder: MemberNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof(IProperty); }
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			IProperty data = dataObject as IProperty;
+			label = data.Name;
+			icon = Context.GetIcon (Runtime.Gui.Icons.GetIcon (data));
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/ClassScout.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/ClassScout.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/ClassScout.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -73,6 +73,14 @@
 			new DefaultDotNetClassScoutNodeBuilder()
 		};
 
+		public string Id {
+			get { return &quot;ClassScout&quot;; }
+		}
+		
+		public string DefaultPlacement {
+			get { return &quot;Left&quot;; }
+		}
+
 		public string Title {
 			get {
 				return GettextCatalog.GetString(&quot;Classes&quot;);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/DefaultMonitorPad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/DefaultMonitorPad.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/DefaultMonitorPad.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -151,9 +151,8 @@
 			set { id = value; }
 		}
 		
-		public override string ToString ()
-		{
-			return base.ToString () + id;
+		public string DefaultPlacement {
+			get { return &quot;Bottom&quot;; }
 		}
 		
 		public void EndProgress ()

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/FileScout/FileScout.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/FileScout/FileScout.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/FileScout/FileScout.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -8,6 +8,14 @@
 {
 	public class FileScout : Gtk.VPaned, IPadContent
 	{
+		public string Id {
+			get { return &quot;MonoDevelop.Gui.Pads.FileScout&quot;; }
+		}
+		
+		public string DefaultPlacement {
+			get { return &quot;Left&quot;; }
+		}
+
 		public Gtk.Widget Control {
 			get {
 				return this;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/OpenTaskView.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/OpenTaskView.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/OpenTaskView.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -34,7 +34,15 @@
 				return sw;
 			}
 		}
+
+		public string Id {
+			get { return &quot;MonoDevelop.Gui.Pads.OpenTaskView&quot;; }
+		}
 		
+		public string DefaultPlacement {
+			get { return &quot;Bottom&quot;; }
+		}
+		
 		public string Title {
 			get {
 				return GettextCatalog.GetString (&quot;Task List&quot;);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/ProjectBrowserView.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/ProjectBrowserView.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/ProjectBrowserView.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -46,6 +46,14 @@
 			}
 		}
 
+		public string Id {
+			get { return &quot;ProjectScout&quot;; }
+		}
+		
+		public string DefaultPlacement {
+			get { return &quot;Left&quot;; }
+		}
+		
 		public void BringToFront() {
 			// TODO FIXME
 		}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/CombineNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/CombineNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/CombineNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,190 @@
+//
+// CombineNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class CombineNodeBuilder: TypeNodeBuilder
+	{
+		CombineEntryEventHandler combineEntryAdded;
+		CombineEntryEventHandler combineEntryRemoved;
+		CombineEntryRenamedEventHandler combineNameChanged;
+		
+		public CombineNodeBuilder ()
+		{
+			combineEntryAdded = (CombineEntryEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEntryEventHandler (OnEntryAdded));
+			combineEntryRemoved = (CombineEntryEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEntryEventHandler (OnEntryRemoved));
+			combineNameChanged = (CombineEntryRenamedEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEntryRenamedEventHandler (OnCombineRenamed));
+		}
+
+		public override Type NodeDataType {
+			get { return typeof(Combine); }
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof(CombineNodeCommandHandler); }
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return ((Combine)dataObject).Name;
+		}
+		
+		public override void GetNodeAttributes (ITreeNavigator treeNavigator, object dataObject, ref NodeAttributes attributes)
+		{
+			attributes |= NodeAttributes.AllowRename;
+		}
+		
+		public override string ContextMenuAddinPath {
+			get { return &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/CombineBrowserNode&quot;; }
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			Combine combine = dataObject as Combine;
+			
+			switch (combine.Entries.Count) {
+				case 0:
+					label = String.Format (GettextCatalog.GetString (&quot;Solution {0}&quot;), combine.Name);
+					break;
+				case 1:
+					label = String.Format (GettextCatalog.GetString (&quot;Solution {0} (1 entry)&quot;), combine.Name);
+					break;
+				default:
+					label = String.Format (GettextCatalog.GetString (&quot;Solution {0} ({1} entries)&quot;), combine.Name, combine.Entries.Count);
+					break;
+			}
+
+			icon = Context.GetIcon (Stock.CombineIcon);
+		}
+
+		public override void BuildChildNodes (ITreeBuilder ctx, object dataObject)
+		{
+			Combine combine = (Combine) dataObject;
+			foreach (CombineEntry entry in combine.Entries)
+				ctx.AddChild (entry);
+		}
+
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return ((Combine) dataObject).Entries.Count &gt; 0;
+		}
+		
+		public override int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			if (otherDataObject is Combine)
+				return DefaultSort;
+			else
+				return -1;
+		}
+
+		public override void OnNodeAdded (object dataObject)
+		{
+			Combine combine = (Combine) dataObject;
+			combine.EntryAdded += combineEntryAdded;
+			combine.EntryRemoved += combineEntryRemoved;
+			combine.NameChanged += combineNameChanged;
+		}
+		
+		public override void OnNodeRemoved (object dataObject)
+		{
+			Combine combine = (Combine) dataObject;
+			combine.EntryAdded -= combineEntryAdded;
+			combine.EntryRemoved -= combineEntryRemoved;
+			combine.NameChanged -= combineNameChanged;
+		}
+		
+		void OnEntryAdded (object sender, CombineEntryEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (sender);
+			if (tb != null) {
+				tb.AddChild (e.CombineEntry, true);
+				tb.Expanded = true;
+			}
+		}
+
+		void OnEntryRemoved (object sender, CombineEntryEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.CombineEntry);
+			if (tb != null) tb.Remove ();
+		}
+		
+		void OnCombineRenamed (object sender, CombineEntryRenamedEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.CombineEntry);
+			if (tb != null) tb.Update ();
+		}
+	}
+	
+	public class CombineNodeCommandHandler: NodeCommandHandler
+	{
+		public override void RenameItem (string newName)
+		{
+			if (newName.IndexOfAny (new char [] { '\'', '(', ')', '&quot;', '{', '}', '|' } ) != -1) {
+				Runtime.MessageService.ShowError (String.Format (GettextCatalog.GetString (&quot;Solution name may not contain any of the following characters: {0}&quot;), &quot;', (, ), \&quot;, {, }, |&quot;));
+				return;
+			}
+			
+			Combine combine = (Combine) CurrentNode.DataItem;
+			combine.Name = newName;
+			Runtime.ProjectService.SaveCombine();
+		}
+		
+		public override void RemoveItem ()
+		{
+			Combine combine = CurrentNode.DataItem as Combine;
+			Combine parent = CurrentNode.GetParentDataItem (typeof(Combine), false) as Combine;
+			if (parent == null) return;
+			
+			bool yes = Runtime.MessageService.AskQuestion (String.Format (GettextCatalog.GetString (&quot;Do you really want to remove solution {0} from solution {1}?&quot;), combine.Name, parent.Name));
+			if (yes) {
+				parent.Entries.Remove (combine);
+				Runtime.ProjectService.SaveCombine();
+			}
+		}
+		
+		public override DragOperation CanDragNode ()
+		{
+			return DragOperation.Move;
+		}
+		
+		public override bool CanDropNode (object dataObject, DragOperation operation)
+		{
+			return dataObject is CombineEntry;
+		}
+		
+		public override void OnNodeDrop (object dataObject, DragOperation operation)
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/FolderNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/FolderNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/FolderNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,152 @@
+//
+// FolderNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Text;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public abstract class FolderNodeBuilder: TypeNodeBuilder
+	{
+		public override void GetNodeAttributes (ITreeNavigator treeNavigator, object dataObject, ref NodeAttributes attributes)
+		{
+			attributes |= NodeAttributes.AllowRename;
+		}
+		
+		public abstract string GetFolderPath (object dataObject);
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			string path = GetFolderPath (dataObject);
+			
+			Project project = builder.GetParentDataItem (typeof(Project), true) as Project;
+			ProjectFileCollection files;
+			ArrayList folders;
+			GetFolderContent (project, path, out files, out folders);
+			
+			foreach (ProjectFile file in files)
+				builder.AddChild (file);
+			
+			foreach (string folder in folders)
+				builder.AddChild (new ProjectFolder (folder, project));
+			
+			if (builder.Options [&quot;ShowAllFiles&quot;])
+			{
+				foreach (string file in Directory.GetFiles (path)) {
+					if (files.GetFile (file) == null)
+						builder.AddChild (new ProjectFile (file));
+				}
+					
+				foreach (string folder in Directory.GetDirectories (path))
+					if (!folders.Contains (folder))
+						builder.AddChild (new ProjectFolder (folder, null));
+			}
+		}
+		
+		protected void AddFile (ITreeBuilder builder, Project project, ProjectFile file)
+		{
+			if (file.BuildAction == BuildAction.EmbedAsResource)
+				return;
+				
+			string[] path = file.RelativePath.Split (Path.DirectorySeparatorChar);
+			StringBuilder sb = new StringBuilder (project.BaseDirectory);
+			for (int n=0; n&lt;path.Length - 1; n++) {
+				string dir = path [n];
+				if (dir == &quot;.&quot;) continue;
+				if (sb.Length &gt; 0) sb.Append (Path.DirectorySeparatorChar);
+				sb.Append (dir);
+				if (!builder.MoveToChild (dir, typeof(ProjectFolder)))
+					builder.AddChild (new ProjectFolder (sb.ToString (), project), true);
+			}
+			if (file.Subtype == Subtype.Directory)
+				builder.AddChild (new ProjectFolder (file.FilePath, project));
+			else
+				builder.AddChild (file);
+		}
+
+		void GetFolderContent (Project project, string folder, out ProjectFileCollection files, out ArrayList folders)
+		{
+			files = new ProjectFileCollection ();
+			folders = new ArrayList ();
+			string folderPrefix = folder + Path.DirectorySeparatorChar;
+			
+			foreach (ProjectFile file in project.ProjectFiles)
+			{
+				string dir;
+				
+				// Resource files are shown in a special resource folder (?!?!).
+				if (file.BuildAction == BuildAction.EmbedAsResource)
+					continue;
+
+				if (file.Subtype != Subtype.Directory) {
+					dir = Path.GetDirectoryName (file.Name);
+					if (dir == folder) {
+						files.Add (file);
+						continue;
+					}
+				} else
+					dir = file.Name;
+				
+				if (dir.StartsWith (folderPrefix)) {
+					int i = dir.IndexOf (Path.DirectorySeparatorChar, folderPrefix.Length);
+					if (i != -1) dir = dir.Substring (0,i);
+					if (!folders.Contains (dir))
+						folders.Add (dir);
+				}
+			}
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			Project project = builder.GetParentDataItem (typeof(Project), true) as Project;
+			
+			// For big projects, a real HasChildNodes value is too slow to get
+			if (project.ProjectFiles.Count &gt; 500)
+				return true;
+
+			ProjectFileCollection files;
+			ArrayList folders;
+			
+			string path = GetFolderPath (dataObject);
+			
+			GetFolderContent (project, path, out files, out folders);
+
+			if (files.Count &gt; 0 || folders.Count &gt; 0) return true;
+			
+			if (builder.Options [&quot;ShowAllFiles&quot;])
+				return Directory.GetFiles (path).Length &gt; 0 || Directory.GetDirectories (path).Length &gt; 0;
+
+			return false;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFileNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFileNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFileNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,185 @@
+//
+// ProjectFileNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class ProjectFileNodeBuilder: TypeNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof(ProjectFile); }
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof(ProjectFileNodeCommandHandler); }
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return Path.GetFileName (((ProjectFile)dataObject).Name);
+		}
+		
+		public override string ContextMenuAddinPath {
+			get { return &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/DefaultFileNode&quot;; }
+		}
+		
+		public override void GetNodeAttributes (ITreeNavigator treeNavigator, object dataObject, ref NodeAttributes attributes)
+		{
+			attributes |= NodeAttributes.AllowRename;
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			ProjectFile file = (ProjectFile) dataObject;
+			label = Path.GetFileName (file.FilePath);
+			icon = Context.GetIcon (Runtime.Gui.Icons.GetImageForFile (file.FilePath));
+			if (file.Project == null) {
+				Gdk.Pixbuf gicon = Context.GetComposedIcon (icon, &quot;fade&quot;);
+				if (gicon == null) {
+					gicon = Runtime.Gui.Icons.MakeTransparent (icon, 0.5);
+					Context.CacheComposedIcon (icon, &quot;fade&quot;, gicon);
+				}
+				icon = gicon;
+			}
+		}
+	}
+	
+	public class ProjectFileNodeCommandHandler: NodeCommandHandler
+	{
+		public override void RenameItem (string newName)
+		{
+			ProjectFile file = CurrentNode.DataItem as ProjectFile;
+			string oldname = file.Name;
+
+			string newname = Path.Combine (Path.GetDirectoryName (oldname), newName);
+			if (oldname != newname) {
+				try {
+					if (Runtime.FileUtilityService.IsValidFileName (newname)) {
+						Runtime.FileService.RenameFile (oldname, newname);
+						Runtime.ProjectService.SaveCombine();
+					}
+				} catch (System.IO.IOException) {   // assume duplicate file
+					Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;File or directory name is already in use, choose a different one.&quot;));
+				} catch (System.ArgumentException) { // new file name with wildcard (*, ?) characters in it
+					Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;The file name you have chosen contains illegal characters. Please choose a different file name.&quot;));
+				}
+			}
+		}
+		
+		public override void ActivateItem ()
+		{
+			ProjectFile file = CurrentNode.DataItem as ProjectFile;
+			Runtime.FileService.OpenFile (file.FilePath);
+		}
+		
+		public override void RemoveItem ()
+		{
+			ProjectFile file = CurrentNode.DataItem as ProjectFile;
+			Project project = CurrentNode.GetParentDataItem (typeof(Project), false) as Project;
+			
+			bool yes = Runtime.MessageService.AskQuestion (String.Format (GettextCatalog.GetString (&quot;Are you sure you want to remove file {0} from project {1}?&quot;), Path.GetFileName (file.Name), project.Name));
+			if (!yes) return;
+
+			Runtime.ProjectService.RemoveFileFromProject (file.Name);
+			Runtime.ProjectService.SaveCombine();
+		}
+		
+		public override DragOperation CanDragNode ()
+		{
+			return DragOperation.Copy | DragOperation.Move;
+		}
+		
+		public override bool CanDropNode (object dataObject, DragOperation operation)
+		{
+			return dataObject is CombineEntry;
+		}
+		
+		public override void OnNodeDrop (object dataObject, DragOperation operation)
+		{
+		}
+	}
+
+
+	public class ExNodeBuilder: NodeBuilderExtension
+	{
+		public override bool CanBuildNode (Type dataType)
+		{
+			return typeof(ProjectFile).IsAssignableFrom (dataType);
+		}
+		
+		public override void GetNodeAttributes (ITreeNavigator treeNavigator, object dataObject, ref NodeAttributes attributes)
+		{
+			ProjectFile file = (ProjectFile) dataObject;
+			if (GetParentFile (file) != null &amp;&amp; treeNavigator.GetParentDataItem (typeof(ProjectFile), true) == null)
+				attributes |= NodeAttributes.Hidden;
+		}
+		
+		public override void BuildChildNodes (ITreeBuilder treeBuilder, object dataObject)
+		{
+			ProjectFile file = (ProjectFile) dataObject;
+			ProjectFile depFile = GetDependentFile (file);
+			if (depFile != null)
+				treeBuilder.AddChild (depFile);
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			ProjectFile file = (ProjectFile) dataObject;
+			return GetDependentFile (file) != null;
+		}
+		
+		ProjectFile GetDependentFile (ProjectFile file)
+		{
+			Project p = file.Project;
+			if (p == null) return null;
+			
+			if (file.Name.EndsWith (&quot;.cs&quot;))
+				return p.GetProjectFile (file.Name.Substring (0, file.Name.Length - 2) + &quot;ex.cs&quot;);
+			else
+				return null;
+		}
+		
+		ProjectFile GetParentFile (ProjectFile file)
+		{
+			Project p = file.Project;
+			if (p == null) return null;
+			
+			if (file.Name.EndsWith (&quot;.ex.cs&quot;))
+				return p.GetProjectFile (file.Name.Substring (0, file.Name.Length - 5) + &quot;cs&quot;);
+			else
+				return null;
+		}
+	}	
+	
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFolder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFolder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFolder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,91 @@
+//
+// ProjectFolder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class ProjectFolder: IDisposable
+	{
+		string absolutePath;
+		Project project;
+		
+		public ProjectFolder (string absolutePath, Project project)
+		{
+			this.project = project;
+			this.absolutePath = absolutePath;
+			Runtime.FileService.FileRenamed += new FileEventHandler (OnFileRenamed);
+			Runtime.FileService.FileRemoved += new FileEventHandler (OnFileRemoved);
+		}
+		
+		public string Path {
+			get { return absolutePath; }
+		}
+		
+		public string Name {
+			get { return System.IO.Path.GetFileName (absolutePath); }
+		}
+		
+		public Project Project {
+			get { return project; }
+		}
+		
+		public void Dispose ()
+		{
+			Runtime.FileService.FileRenamed -= new FileEventHandler (OnFileRenamed);
+			Runtime.FileService.FileRemoved -= new FileEventHandler (OnFileRemoved);
+		}
+		
+		void OnFileRemoved (object sender, FileEventArgs e)
+		{
+			if (!e.IsDirectory || e.TargetFile != absolutePath) return;
+			
+			if (FolderRemoved != null) {
+				FolderRemoved(this, e);
+			}
+		}
+
+		void OnFileRenamed (object sender, FileEventArgs e)
+		{
+			if (!e.IsDirectory || e.SourceFile != absolutePath) return;
+
+			absolutePath = e.TargetFile;
+			if (FolderRenamed != null) {
+				FolderRenamed(this, e);
+			}
+		}
+
+		public event FileEventHandler FolderRenamed;
+		public event FileEventHandler FolderRemoved;
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFolderNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFolderNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectFolderNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,189 @@
+//
+// ProjectFolderNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class ProjectFolderNodeBuilder: FolderNodeBuilder
+	{
+		Gdk.Pixbuf folderOpenIcon;
+		Gdk.Pixbuf folderClosedIcon;
+		
+		FileEventHandler fileRenamedHandler;
+		FileEventHandler fileRemovedHandler;
+		
+		public override Type NodeDataType {
+			get { return typeof(ProjectFolder); }
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof(ProjectFolderCommandHandler); }
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return ((ProjectFolder)dataObject).Name;
+		}
+		
+		public override string GetFolderPath (object dataObject)
+		{
+			return ((ProjectFolder)dataObject).Path;
+		}
+		
+		public override string ContextMenuAddinPath {
+			get { return &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/DefaultDirectoryNode&quot;; }
+		}
+		
+		protected override void Initialize ()
+		{
+			base.Initialize ();
+
+			folderOpenIcon = Context.GetIcon (Stock.OpenFolderBitmap);
+			folderClosedIcon = Context.GetIcon (Stock.ClosedFolderBitmap);
+			
+			fileRenamedHandler = (FileEventHandler) Runtime.DispatchService.GuiDispatch (new FileEventHandler (OnFolderRenamed));
+			fileRemovedHandler = (FileEventHandler) Runtime.DispatchService.GuiDispatch (new FileEventHandler (OnFolderRemoved));
+		}
+		
+		public override void OnNodeAdded (object dataObject)
+		{
+			ProjectFolder folder = (ProjectFolder) dataObject;
+			folder.FolderRenamed += fileRenamedHandler;
+			folder.FolderRemoved += fileRemovedHandler;
+		}
+		
+		public override void OnNodeRemoved (object dataObject)
+		{
+			ProjectFolder folder = (ProjectFolder) dataObject;
+			folder.FolderRenamed -= fileRenamedHandler;
+			folder.FolderRemoved -= fileRemovedHandler;
+			folder.Dispose ();
+		}
+		
+		void OnFolderRenamed (object sender, FileEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (sender);
+			if (tb != null) tb.Update ();
+		}
+		
+		void OnFolderRemoved (object sender, FileEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (sender);
+			if (tb != null) tb.Remove ();
+		}
+	
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			ProjectFolder folder = (ProjectFolder) dataObject;
+			label = folder.Name;
+			icon = folderOpenIcon;
+			closedIcon = folderClosedIcon;
+			
+			if (folder.Project == null)
+			{
+				Gdk.Pixbuf gicon = Context.GetComposedIcon (icon, &quot;fade&quot;);
+				if (gicon == null) {
+					gicon = Runtime.Gui.Icons.MakeTransparent (icon, 0.5);
+					Context.CacheComposedIcon (icon, &quot;fade&quot;, gicon);
+				}
+				icon = gicon;
+				
+				gicon = Context.GetComposedIcon (closedIcon, &quot;fade&quot;);
+				if (gicon == null) {
+					gicon = Runtime.Gui.Icons.MakeTransparent (closedIcon, 0.5);
+					Context.CacheComposedIcon (closedIcon, &quot;fade&quot;, gicon);
+				}
+				closedIcon = gicon;
+			}
+		}
+		
+		public override int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			if (otherDataObject is ProjectFolder)
+				return DefaultSort;
+			else if (otherDataObject is ProjectFile)
+				return -1;
+			else
+				return 1;
+		}
+	}
+	
+	public class ProjectFolderCommandHandler: NodeCommandHandler
+	{
+		public override void RenameItem (string newName)
+		{
+			ProjectFolder folder = (ProjectFolder) CurrentNode.DataItem as ProjectFolder;
+			string oldFoldername = folder.Path;
+			string newFoldername = Path.Combine (Path.GetDirectoryName(oldFoldername), newName);
+			
+			if (oldFoldername != newFoldername) {
+				try {
+					
+					if (Runtime.FileUtilityService.IsValidFileName (newFoldername)) {
+						Runtime.FileService.RenameFile (oldFoldername, newFoldername);
+						Runtime.ProjectService.SaveCombine();
+					}
+				} catch (System.IO.IOException) {   // assume duplicate file
+					Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;File or directory name is already in use, choose a different one.&quot;));
+				} catch (System.ArgumentException) { // new file name with wildcard (*, ?) characters in it
+					Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;The file name you have chosen contains illegal characters. Please choose a different file name.&quot;));
+				}
+			}
+		}
+		
+		public override void RemoveItem ()
+		{
+			ProjectFolder folder = (ProjectFolder) CurrentNode.DataItem as ProjectFolder;
+			
+			bool yes = Runtime.MessageService.AskQuestion (String.Format (GettextCatalog.GetString (&quot;Do you want to remove folder {0}?&quot;), folder.Name));
+			if (!yes) return;
+			
+			Runtime.ProjectService.RemoveFileFromProject (folder.Path);
+		}
+		
+		public override DragOperation CanDragNode ()
+		{
+			return DragOperation.Move | DragOperation.Copy;
+		}
+		
+		public override bool CanDropNode (object dataObject, DragOperation operation)
+		{
+			return (dataObject is ProjectFile) || (dataObject is ProjectFolder);
+		}
+		
+		public override void OnNodeDrop (object dataObject, DragOperation operation)
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,196 @@
+//
+// ProjectNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class ProjectNodeBuilder: FolderNodeBuilder
+	{
+		ProjectFileEventHandler fileAddedHandler;
+		ProjectFileEventHandler fileRemovedHandler;
+		ProjectFileRenamedEventHandler fileRenamedHandler;
+		CombineEntryRenamedEventHandler projectNameChanged;
+		
+		public override Type NodeDataType {
+			get { return typeof(Project); }
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof(ProjectNodeCommandHandler); }
+		}
+		
+		protected override void Initialize ()
+		{
+			fileAddedHandler = (ProjectFileEventHandler) Runtime.DispatchService.GuiDispatch (new ProjectFileEventHandler (OnAddFile));
+			fileRemovedHandler = (ProjectFileEventHandler) Runtime.DispatchService.GuiDispatch (new ProjectFileEventHandler (OnRemoveFile));
+			fileRenamedHandler = (ProjectFileRenamedEventHandler) Runtime.DispatchService.GuiDispatch (new ProjectFileRenamedEventHandler (OnRenameFile));
+			projectNameChanged = (CombineEntryRenamedEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEntryRenamedEventHandler (OnProjectRenamed));
+			
+			Runtime.ProjectService.FileAddedToProject += fileAddedHandler;
+			Runtime.ProjectService.FileRemovedFromProject += fileRemovedHandler;
+			Runtime.ProjectService.FileRenamedInProject += fileRenamedHandler;
+		}
+		
+		public override void Dispose ()
+		{
+			Runtime.ProjectService.FileAddedToProject -= fileAddedHandler;
+			Runtime.ProjectService.FileRemovedFromProject -= fileRemovedHandler;
+			Runtime.ProjectService.FileRenamedInProject -= fileRenamedHandler;
+		}
+
+		public override void OnNodeAdded (object dataObject)
+		{
+			Project project = (Project) dataObject;
+			project.NameChanged += projectNameChanged;
+		}
+		
+		public override void OnNodeRemoved (object dataObject)
+		{
+			Project project = (Project) dataObject;
+			project.NameChanged -= projectNameChanged;
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return ((Project)dataObject).Name;
+		}
+		
+		public override string GetFolderPath (object dataObject)
+		{
+			return ((Project)dataObject).BaseDirectory;
+		}
+		
+		public override string ContextMenuAddinPath {
+			get { return &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/ProjectBrowserNode&quot;; }
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			Project p = dataObject as Project;
+			label = p.Name;
+			string iconName = Runtime.Gui.Icons.GetImageForProjectType (p.ProjectType);
+			icon = Context.GetIcon (iconName);
+		}
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			Project project = (Project) dataObject;
+			builder.AddChild (project.ProjectReferences);
+			builder.AddChild (new ResourceFolder (project));
+			
+			base.BuildChildNodes (builder, dataObject);
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return true;
+		}
+		
+		void OnAddFile (object sender, ProjectFileEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.Project);
+			if (tb != null) {
+				if (e.ProjectFile.BuildAction != BuildAction.EmbedAsResource)
+					AddFile (tb, e.Project, e.ProjectFile);
+				else {
+					tb.MoveToChild (&quot;Resources&quot;, typeof(ResourceFolder));
+					tb.AddChild (e.ProjectFile);
+				}
+			}
+		}
+		
+		void OnRemoveFile (object sender, ProjectFileEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.ProjectFile);
+			if (tb != null) tb.Remove ();
+		}
+		
+		void OnRenameFile (object sender, ProjectFileRenamedEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.ProjectFile);
+			if (tb != null) tb.Update ();
+		}
+		
+		void OnProjectRenamed (object sender, CombineEntryRenamedEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.CombineEntry);
+			if (tb != null) tb.Update ();
+		}
+	}
+	
+	public class ProjectNodeCommandHandler: NodeCommandHandler
+	{
+		public override void RenameItem (string newName)
+		{
+			if (newName.IndexOfAny (new char [] { '\'', '(', ')', '&quot;', '{', '}', '|' } ) != -1) {
+				Runtime.MessageService.ShowError (String.Format (GettextCatalog.GetString (&quot;Project name may not contain any of the following characters: {0}&quot;), &quot;', (, ), \&quot;, {, }, |&quot;));
+				return;
+			}
+			
+			Project project = (Project) CurrentNode.DataItem;
+			project.Name = newName;
+			Runtime.ProjectService.SaveCombine();
+		}
+		
+		public override void ActivateItem ()
+		{
+		}
+		
+		public override void RemoveItem ()
+		{
+			Combine cmb = CurrentNode.GetParentDataItem (typeof(Combine), false) as Combine;;
+			Project prj = CurrentNode.DataItem as Project;
+			
+			bool yes = Runtime.MessageService.AskQuestion (String.Format (GettextCatalog.GetString (&quot;Do you really want to remove project {0} from solution {1}&quot;), prj.Name, cmb.Name));
+			if (yes) {
+				cmb.RemoveEntry (prj);
+				Runtime.ProjectService.SaveCombine();
+			}
+		}
+		
+		public override DragOperation CanDragNode ()
+		{
+			return DragOperation.Copy | DragOperation.Move;
+		}
+		
+		public override bool CanDropNode (object dataObject, DragOperation operation)
+		{
+			return (dataObject is ProjectFile) || (dataObject is ProjectFolder);
+		}
+		
+		public override void OnNodeDrop (object dataObject, DragOperation operation)
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectReferenceFolderNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectReferenceFolderNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectReferenceFolderNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,147 @@
+//
+// ProjectReferenceFolderNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class ProjectReferenceFolderNodeBuilder: TypeNodeBuilder
+	{
+		ProjectReferenceEventHandler addedHandler;
+		ProjectReferenceEventHandler removedHandler;
+
+		public override Type NodeDataType {
+			get { return typeof(ProjectReferenceCollection); }
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof(ProjectReferenceFolderNodeCommandHandler); }
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return &quot;References&quot;;
+		}
+		
+		public override string ContextMenuAddinPath {
+			get { return &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/ReferenceFolderNode&quot;; }
+		}
+		
+		protected override void Initialize ()
+		{
+			addedHandler = (ProjectReferenceEventHandler) Runtime.DispatchService.GuiDispatch (new ProjectReferenceEventHandler (OnAddReference));
+			removedHandler = (ProjectReferenceEventHandler) Runtime.DispatchService.GuiDispatch (new ProjectReferenceEventHandler (OnRemoveReference));
+
+			Runtime.ProjectService.ReferenceAddedToProject += addedHandler;
+			Runtime.ProjectService.ReferenceRemovedFromProject += removedHandler;
+		}
+		
+		public override void Dispose ()
+		{
+			Runtime.ProjectService.ReferenceAddedToProject -= addedHandler;
+			Runtime.ProjectService.ReferenceRemovedFromProject -= removedHandler;
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			label = GettextCatalog.GetString (&quot;References&quot;);
+			icon = Context.GetIcon (Stock.OpenReferenceFolder);
+			closedIcon = Context.GetIcon (Stock.ClosedReferenceFolder);
+		}
+
+		public override void BuildChildNodes (ITreeBuilder ctx, object dataObject)
+		{
+			ProjectReferenceCollection refs = (ProjectReferenceCollection) dataObject;
+			foreach (ProjectReference pref in refs)
+				ctx.AddChild (pref);
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return ((ProjectReferenceCollection) dataObject).Count &gt; 0;
+		}
+		
+		public override int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			return -1;
+		}
+
+		void OnRemoveReference (object sender, ProjectReferenceEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.ProjectReference);
+			if (tb != null) tb.Remove ();
+		}
+		
+		void OnAddReference (object sender, ProjectReferenceEventArgs e)
+		{
+			ITreeBuilder tb = Context.GetTreeBuilder (e.Project.ProjectReferences);
+			if (tb != null) tb.AddChild (e.ProjectReference);
+		}
+	}
+	
+	public class ProjectReferenceFolderNodeCommandHandler: NodeCommandHandler
+	{
+		public override DragOperation CanDragNode ()
+		{
+			return DragOperation.Copy | DragOperation.Move;
+		}
+		
+		public override bool CanDropNode (object dataObject, DragOperation operation)
+		{
+			return dataObject is ProjectReference;
+		}
+		
+		public override void OnNodeDrop (object dataObject, DragOperation operation)
+		{
+			ProjectReference pref = dataObject as ProjectReference;
+			ITreeNavigator nav = CurrentNode;
+
+			if (operation == DragOperation.Move) {
+				NodePosition pos = nav.CurrentPosition;
+				nav.MoveToObject (dataObject);
+				nav.MoveToParent (typeof(Project));
+				Project p = nav.DataItem as Project;
+				p.ProjectReferences.Remove (pref);
+				
+				nav.MoveToPosition (pos);
+				nav.MoveToParent (typeof(Project));
+				p = nav.DataItem as Project;
+				p.ProjectReferences.Add (pref);
+			} else {
+				nav.MoveToParent (typeof(Project));
+				Project p = nav.DataItem as Project;
+				p.ProjectReferences.Add ((ProjectReference) pref.Clone ());
+			}
+			Runtime.ProjectService.SaveCombine();
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,102 @@
+//
+// ProjectReferenceNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class ProjectReferenceNodeBuilder: TypeNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof(ProjectReference); }
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof(ProjectReferenceNodeCommandHandler); }
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			return ((ProjectReference)dataObject).Reference;
+		}
+		
+		public override string ContextMenuAddinPath {
+			get { return &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/ReferenceNode&quot;; }
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			ProjectReference pref = (ProjectReference) dataObject;
+			
+			switch (pref.ReferenceType) {
+				case ReferenceType.Typelib:
+					int index = pref.Reference.IndexOf(&quot;|&quot;);
+					if (index &gt; 0) {
+						label = pref.Reference.Substring(0, index);
+					} else {
+						label = pref.Reference;
+					}
+					break;
+				case ReferenceType.Project:
+					label = pref.Reference;
+					break;
+				case ReferenceType.Assembly:
+					label = Path.GetFileName(pref.Reference);
+					break;
+				case ReferenceType.Gac:
+					label = pref.Reference.Split(',')[0];
+					break;
+				default:
+					throw new NotImplementedException(&quot;reference type : &quot; + pref.ReferenceType);
+			}
+			
+			icon = Context.GetIcon (Stock.Reference);
+		}
+	}
+	
+	public class ProjectReferenceNodeCommandHandler: NodeCommandHandler
+	{
+		public override void RemoveItem ()
+		{
+			ProjectReference pref = (ProjectReference) CurrentNode.DataItem;
+			Project project = CurrentNode.GetParentDataItem (typeof(Project), false) as Project;
+			project.ProjectReferences.Remove (pref);
+			Runtime.ProjectService.SaveCombine ();
+		}
+		
+		public override DragOperation CanDragNode ()
+		{
+			return DragOperation.Copy;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ResourceFolder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ResourceFolder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ResourceFolder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,47 @@
+//
+// ResourceFolder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class ResourceFolder
+	{
+		Project project;
+		
+		public ResourceFolder (Project project)
+		{
+			this.project = project;
+		}
+		
+		public Project Project {
+			get { return project; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ResourceFolderNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ResourceFolderNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectPad/ResourceFolderNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,86 @@
+//
+// ResourceFolderNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Gui.Pads.ProjectPad
+{
+	public class ResourceFolderNodeBuilder: TypeNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof(ResourceFolder); }
+		}
+		
+		public override string GetNodeName (object dataObject)
+		{
+			// Don't localize this string.
+			return &quot;Resources&quot;;
+		}
+		
+		public override string ContextMenuAddinPath {
+			get { return &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/ResourceFolderNode&quot;; }
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			label = GettextCatalog.GetString (&quot;Resources&quot;);
+			icon = Context.GetIcon (Stock.OpenResourceFolder);
+			closedIcon = Context.GetIcon (Stock.ClosedResourceFolder);
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			Project project = ((ResourceFolder)dataObject).Project;
+			foreach (ProjectFile file in project.ProjectFiles)
+				if (file.BuildAction == BuildAction.EmbedAsResource)
+					return true;
+			return false;
+		}
+
+		public override int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			if (otherDataObject is ProjectReferenceCollection)
+				return 1;
+			else
+				return -1;
+		}
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			Project project = ((ResourceFolder)dataObject).Project;
+			foreach (ProjectFile file in project.ProjectFiles)
+				if (file.BuildAction == BuildAction.EmbedAsResource)
+					builder.AddChild (file);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/DragOperation.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/DragOperation.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/DragOperation.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,38 @@
+//
+// DragOperation.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public enum DragOperation {
+		None = 0,
+		Copy = 1,
+		Move = 2
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,42 @@
+//
+// ITreeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public interface ITreeBuilder: ITreeNavigator
+	{
+		void Update ();
+		void UpdateChildren ();
+		void Remove ();
+		void Remove (bool moveToParent);
+		void AddChild (object dataObject);
+		void AddChild (object dataObject, bool moveToChild);
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeBuilderContext.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeBuilderContext.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeBuilderContext.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,44 @@
+//
+// ITreeBuilderContext.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public interface ITreeBuilderContext
+	{
+		ITreeBuilder GetTreeBuilder ();
+		ITreeBuilder GetTreeBuilder (object dataObject);
+		ITreeNavigator GetTreeNavigator (object dataObject);
+		ITreeOptions GetOptions (object dataObject);
+		
+		Gdk.Pixbuf GetIcon (string iconId);
+		Gdk.Pixbuf GetComposedIcon (Gdk.Pixbuf baseIcon, string compositionId);
+		void CacheComposedIcon (Gdk.Pixbuf baseIcon, string compositionId, Gdk.Pixbuf composedIcon);
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeNavigator.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeNavigator.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeNavigator.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,64 @@
+//
+// ITreeNavigator.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public interface ITreeNavigator
+	{
+		object DataItem { get; }
+		string NodeName { get; }
+
+		object GetParentDataItem (Type type, bool includeCurrent);
+		bool Selected { get; set; }
+		bool Expanded { get; set; }
+		void ExpandToNode ();
+		ITreeOptions Options { get; }
+		
+		NodePosition CurrentPosition { get; }
+		bool MoveToPosition (NodePosition position);
+		
+		bool MoveToObject (object dataObject);
+		bool MoveToParent ();
+		bool MoveToParent (Type type);
+		bool MoveToRoot ();
+		bool MoveToFirstChild ();
+		bool MoveToChild (string name, Type dataType);
+		bool HasChild (string name, Type dataType);
+		bool HasChildren ();
+		bool MoveNext ();
+		
+		ITreeNavigator Clone ();
+	}
+	
+	public struct NodePosition {
+		internal Gtk.TreeIter _iter;
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeOptions.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeOptions.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/ITreeOptions.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,37 @@
+//
+// ITreeOptions.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public interface ITreeOptions
+	{
+		bool this [string name] { get; set; }
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeAttributes.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeAttributes.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeAttributes.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,40 @@
+//
+// NodeAttributes.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	[Flags]
+	public enum NodeAttributes
+	{
+		None = 0,
+		Hidden = 1,
+		AllowRename = 2
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,117 @@
+//
+// NodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public abstract class NodeBuilder: IDisposable
+	{
+		ITreeBuilderContext context;
+		NodeCommandHandler commandHandler;
+		
+		internal NodeBuilder ()
+		{
+		}
+		
+		internal void SetContext (ITreeBuilderContext context)
+		{
+			this.context = context;
+			Initialize ();
+		}
+		
+		internal NodeCommandHandler CommandHandler {
+			get {
+				if (commandHandler == null)
+					commandHandler = (NodeCommandHandler) Activator.CreateInstance (CommandHandlerType);
+				return commandHandler;
+			}
+		}
+		
+		protected virtual void Initialize ()
+		{
+		}
+		
+		protected ITreeBuilderContext Context {
+			get { return context; }
+		}
+		
+		public virtual Type CommandHandlerType {
+			get { return typeof(NodeCommandHandler); }
+		}
+		
+		public virtual void GetNodeAttributes (ITreeNavigator parentNode, object dataObject, ref NodeAttributes attributes)
+		{
+		}
+		
+		public virtual void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+		}
+		
+		public virtual void BuildChildNodes (ITreeBuilder treeBuilder, object dataObject)
+		{
+		}
+		
+		public virtual bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return false;
+		}
+		
+		public virtual void OnNodeAdded (object dataObject)
+		{
+		}
+		
+		public virtual void OnNodeRemoved (object dataObject)
+		{
+		}
+
+		public virtual void OnNodeSelect (object dataObject)
+		{
+		}
+		
+		public virtual void Dispose ()
+		{
+		}
+		
+
+		// Helper methods
+		
+		internal static bool HasAttribute (ITreeNavigator treeNavigator, NodeAttributes attr, NodeBuilder[] chain, object dataObject)
+		{
+			NodeAttributes nodeAttr = NodeAttributes.None;
+			NodePosition pos = treeNavigator.CurrentPosition;
+			
+			foreach (NodeBuilder nb in chain) {
+				nb.GetNodeAttributes (treeNavigator, dataObject, ref nodeAttr);
+				treeNavigator.MoveToPosition (pos);
+			}
+			
+			return (nodeAttr &amp; attr) != 0;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeBuilderExtension.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeBuilderExtension.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeBuilderExtension.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,37 @@
+//
+// NodeBuilderExtension.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public abstract class NodeBuilderExtension: NodeBuilder
+	{
+		public abstract bool CanBuildNode (Type dataType);
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeCommandHandler.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeCommandHandler.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/NodeCommandHandler.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,72 @@
+//
+// NodeCommandHandler.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public class NodeCommandHandler
+	{
+		ITreeNavigator currentNode;
+		
+		internal void SetCurrentNode (ITreeNavigator currentNode)
+		{
+			this.currentNode = currentNode;
+		}
+		
+		protected ITreeNavigator CurrentNode {
+			get { return currentNode; }
+		}
+		
+		public virtual void RenameItem (string newName)
+		{
+		}
+		
+		public virtual void ActivateItem ()
+		{
+		}
+		
+		public virtual void RemoveItem ()
+		{
+		}
+		
+		public virtual DragOperation CanDragNode ()
+		{
+			return DragOperation.None;
+		}
+		
+		public virtual bool CanDropNode (object dataObject, DragOperation operation)
+		{
+			return false;
+		}
+		
+		public virtual void OnNodeDrop (object dataObject, DragOperation operation)
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/SolutionPad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/SolutionPad.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/SolutionPad.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,73 @@
+//
+// SolutionPad.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Resources;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Services;
+using MonoDevelop.Core.Properties;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public class SolutionPad : TreeViewPad
+	{
+		public SolutionPad (string label, string icon, NodeBuilder[] builders, TreePadOption[] options): base (label, icon, builders, options)
+		{
+			Runtime.ProjectService.CombineOpened += (CombineEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEventHandler (OpenCombine));
+			Runtime.ProjectService.CombineClosed += (CombineEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEventHandler (CloseCombine));
+			WorkbenchSingleton.Workbench.ActiveWorkbenchWindowChanged += new EventHandler(ActiveWindowChanged);
+			Runtime.Properties.PropertyChanged += (PropertyEventHandler) Runtime.DispatchService.GuiDispatch (new PropertyEventHandler (TrackPropertyChange));
+		}
+		
+		void TrackPropertyChange (object o, MonoDevelop.Core.Properties.PropertyEventArgs e)
+		{
+			if (e.OldValue != e.NewValue &amp;&amp; e.Key == &quot;MonoDevelop.Gui.ProjectBrowser.ShowExtensions&quot;) {
+				RedrawContent ();
+			}
+		}
+		
+		void ActiveWindowChanged(object sender, EventArgs e)
+		{
+			if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null) {
+//				string fileName = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName;
+				// TODO
+			}
+		}
+
+		void OpenCombine(object sender, CombineEventArgs e)
+		{
+			LoadTree (e.Combine);
+		}
+
+		void CloseCombine(object sender, CombineEventArgs e)
+		{
+			Clear ();
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TreePadOption.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TreePadOption.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TreePadOption.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,59 @@
+//
+// TreePadOption.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public class TreePadOption
+	{
+		string label;
+		bool defaultValue;
+		string id;
+		
+		public TreePadOption (string id, string label, bool defaultValue)
+		{
+			this.label = label;
+			this.id = id;
+			this.defaultValue = defaultValue;
+		}
+		
+		public string Id {
+			get { return id; }
+		}
+
+		public bool DefaultValue {
+			get { return defaultValue; }
+		}
+		
+		public string Label {
+			get { return label; }
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TreeViewPad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TreeViewPad.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TreeViewPad.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,1499 @@
+//
+// TreeViewPad.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.ComponentModel;
+using System.Drawing;
+using System.Diagnostics;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Collections.Utility;
+using System.Xml;
+using System.Resources;
+using System.Text;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Services;
+using MonoDevelop.Gui.Widgets;
+
+namespace MonoDevelop.Gui.Pads
+{
+	/// &lt;summary&gt;
+	/// This class implements a project browser.
+	/// &lt;/summary&gt;
+	public class TreeViewPad : IPadContent, IMementoCapable
+	{
+		string title;
+		string icon;
+		string id;
+		string defaultPosition = &quot;left&quot;;
+		
+		internal const int TextColumn = 0;
+		internal const int OpenIconColumn = 1;
+		internal const int ClosedIconColumn = 2;
+		internal const int DataItemColumn = 3;
+		internal const int BuilderChainColumn = 4;
+		internal const int WeightColumn = 5;
+		internal const int FilledColumn = 6;
+		
+		NodeBuilder[] builders;
+		Hashtable builderChains = new Hashtable ();
+		Hashtable nodeHash = new Hashtable ();
+		Gtk.TreeView tree;
+		Gtk.TreeStore store;
+		internal Gtk.TreeViewColumn complete_column;
+		internal Gtk.CellRendererText text_render;
+		TreeBuilderContext builderContext;
+		Hashtable callbacks = new Hashtable ();
+		
+		TreePadOption[] options;
+		TreeOptions globalOptions;
+		Hashtable nodeOptions = new Hashtable ();
+		
+		object dragObject;
+
+		Gtk.Frame contentPanel = new Gtk.Frame();
+
+		private static Gtk.TargetEntry [] target_table = new Gtk.TargetEntry [] {
+			new Gtk.TargetEntry (&quot;text/uri-list&quot;, 0, 11 ),
+			new Gtk.TargetEntry (&quot;text/plain&quot;, 0, 22),
+			new Gtk.TargetEntry (&quot;application/x-rootwindow-drop&quot;, 0, 33)
+		};
+	
+		public string Id {
+			get { return id; }
+			set { id = value; }
+		}
+		
+		public string DefaultPlacement {
+			get { return defaultPosition; }
+			set { defaultPosition = value; }
+		}
+
+		public Gtk.Widget Control {
+			get {
+				return contentPanel;
+			}
+		}
+
+		public void BringToFront() {
+			// TODO FIXME
+		}
+		
+		public string Title {
+			get { return title; }
+			set { title = value; }
+		}
+
+		public string Icon {
+			get { return icon; }
+			set { icon = value; }
+		}
+
+		public void RedrawContent()
+		{
+		}
+		
+		public TreeViewPad (string label, string icon, NodeBuilder[] builders, TreePadOption[] options)
+		{
+			// Create default options
+			
+			this.options = options;
+			globalOptions = new TreeOptions ();
+			foreach (TreePadOption op in options)
+				globalOptions [op.Id] = op.DefaultValue;
+				
+			globalOptions.Pad = this;
+			
+			// Check that there is only one node builder per type
+			
+			Hashtable bc = new Hashtable ();
+			foreach (NodeBuilder nb in builders) {
+				TypeNodeBuilder tnb = nb as TypeNodeBuilder;
+				if (tnb != null) {
+					TypeNodeBuilder other = (TypeNodeBuilder) bc [tnb.NodeDataType];
+					if (other != null)
+						throw new ApplicationException (string.Format (&quot;The type node builder {0} can't be used in this context because the type {1} is already handled by {2}&quot;, nb.GetType(), tnb.NodeDataType, other.GetType()));
+					bc [tnb.NodeDataType] = tnb;
+				}
+				else if (!(nb is NodeBuilderExtension))
+					throw new InvalidOperationException (string.Format (&quot;Invalid NodeBuilder type: {0}. NodeBuilders must inherit either from TypeNodeBuilder or NodeBuilderExtension&quot;, nb.GetType()));
+			}
+			
+			NodeBuilders = builders;
+			Title = label;
+			Icon = icon;
+
+			builderContext = new TreeBuilderContext (this);
+			
+			tree = new Gtk.TreeView ();
+			
+			/*
+			0 -- Text
+			1 -- Icon (Open)
+			2 -- Icon (Closed)
+			3 -- Node Data
+			4 -- Builder chain
+			5 -- Pango weight
+			6 -- Expanded
+			*/
+			store = new Gtk.TreeStore (typeof (string), typeof (Gdk.Pixbuf), typeof (Gdk.Pixbuf), typeof (object), typeof (object), typeof(int), typeof(bool));
+			tree.Model = store;
+
+/*
+			tree.EnableModelDragSource (Gdk.ModifierType.Button1Mask, target_table, Gdk.DragAction.Copy | Gdk.DragAction.Move);
+			tree.EnableModelDragDest (target_table, Gdk.DragAction.Copy | Gdk.DragAction.Move);
+*/
+
+			store.SetDefaultSortFunc (new Gtk.TreeIterCompareFunc (CompareNodes), IntPtr.Zero, null);
+			store.SetSortColumnId (/* GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID */ -1, Gtk.SortType.Ascending);
+			
+			tree.HeadersVisible = false;
+			tree.SearchColumn = 0;
+			tree.EnableSearch = true;
+			complete_column = new Gtk.TreeViewColumn ();
+			complete_column.Title = &quot;column&quot;;
+
+			Gtk.CellRendererPixbuf pix_render = new Gtk.CellRendererPixbuf ();
+			complete_column.PackStart (pix_render, false);
+			complete_column.AddAttribute (pix_render, &quot;pixbuf&quot;, OpenIconColumn);
+			complete_column.AddAttribute (pix_render, &quot;pixbuf-expander-open&quot;, OpenIconColumn);
+			complete_column.AddAttribute (pix_render, &quot;pixbuf-expander-closed&quot;, ClosedIconColumn);
+
+			text_render = new Gtk.CellRendererText ();
+			text_render.Edited += new Gtk.EditedHandler (HandleOnEdit);
+			
+			complete_column.PackStart (text_render, true);
+			complete_column.AddAttribute (text_render, &quot;text&quot;, TextColumn);
+			complete_column.AddAttribute (text_render, &quot;weight&quot;, WeightColumn);
+	
+			tree.AppendColumn (complete_column);
+			
+			Gtk.ScrolledWindow sw = new Gtk.ScrolledWindow ();
+			sw.Add(tree);
+			contentPanel = new Gtk.Frame();
+			contentPanel.Add(sw);
+			
+			tree.TestExpandRow += new Gtk.TestExpandRowHandler (OnTestExpandRow);
+			tree.RowActivated += new Gtk.RowActivatedHandler(OnNodeActivated);
+			
+			contentPanel.ButtonReleaseEvent += new Gtk.ButtonReleaseEventHandler(OnButtonRelease);
+			contentPanel.PopupMenu += OnPopupMenu;
+			
+			foreach (NodeBuilder nb in builders)
+				nb.SetContext (builderContext);
+			
+/*			tree.DragBegin += new Gtk.DragBeginHandler (OnDragBegin);
+			tree.DragDataGet += new Gtk.DragDataGetHandler (OnDragDataGet);
+			tree.DragDataReceived += new Gtk.DragDataReceivedHandler (OnDragDataReceived);
+			tree.DragDrop += new Gtk.DragDropHandler (OnDragDrop);
+			tree.DragEnd += new Gtk.DragEndHandler (OnDragEnd);
+			tree.DragLeave += new Gtk.DragLeaveHandler (OnDragLeave);
+			tree.DragMotion += new Gtk.DragMotionHandler (OnDragMotion);
+*/
+		}
+
+/*
+		void OnDragBegin (object o, Gtk.DragBeginArgs arg)
+		{
+			ITreeNavigator nav = GetSelectedNode ();
+			dragObject = nav.DataItem;
+			Console.WriteLine (&quot;OnDragBegin&quot;);
+		}
+		
+		void OnDragDataGet (object o, Gtk.DragDataGetArgs args)
+		{
+			Console.WriteLine (&quot;OnDragDataGet&quot;);
+			args.SelectionData.Set (args.Context.Targets[0], 0, new byte[0]);
+		}
+		
+		void OnDragDataReceived (object o, Gtk.DragDataReceivedArgs args)
+		{
+			Console.WriteLine (&quot;OnDragDataReceived &quot; + args.X + &quot; &quot; + args.Y + &quot; &quot; + args.SelectionData.Length);
+			
+			if (dragObject != null) {
+				bool res = CheckAndDrop (args.X, args.Y, true);
+				Gtk.Drag.Finish (args.Context, res, true, args.Time);
+			} else {
+				if (args.SelectionData.Data.Length &gt; 0) {
+					string fullData = System.Text.Encoding.UTF8.GetString (args.SelectionData.Data);
+					Console.WriteLine (&quot;file:&quot; + fullData);
+				}
+				Gtk.Drag.Finish (args.Context, false, true, args.Time);
+			}
+		}
+		
+		void OnDragDrop (object o, Gtk.DragDropArgs args)
+		{
+			Console.WriteLine (&quot;OnDragDrop &quot; + args.X + &quot; &quot; + args.Y);
+		}
+		
+		void OnDragEnd (object o, Gtk.DragEndArgs args)
+		{
+			dragObject = null;
+			Console.WriteLine (&quot;OnDragEnd&quot;);
+		}
+		
+		void OnDragLeave (object sender, Gtk.DragLeaveArgs args)
+		{
+			Console.WriteLine (&quot;OnDragLeave&quot;);
+		}
+		
+		[GLib.ConnectBefore]
+		void OnDragMotion (object o, Gtk.DragMotionArgs args)
+		{
+			if (dragObject != null) {
+				if (!CheckAndDrop (args.X, args.Y, false)) {
+					Gdk.Drag.Status (args.Context, (Gdk.DragAction)0, args.Time);
+					args.RetVal = true;
+				}
+			}
+		}
+		
+		bool CheckAndDrop (int x, int y, bool drop)
+		{
+			Gtk.TreePath path;
+			Gtk.TreeViewDropPosition pos;
+			if (!tree.GetDestRowAtPos (x, y, out path, out pos)) return false;
+			
+			Gtk.TreeIter iter;
+			if (!store.GetIter (out iter, path)) return false;
+			
+			TreeNodeNavigator nav = new TreeNodeNavigator (this, iter);
+			Console.WriteLine (&quot;Trying drop to &quot; + nav.NodeName);
+			NodeBuilder[] chain = nav.BuilderChain;
+			bool foundHandler = false;
+			
+			foreach (NodeBuilder nb in chain) {
+				nb.CommandHandler.SetCurrentNode (nav);
+				if (nb.CommandHandler.CanDropNode (dragObject, DragOperation.Copy)) {
+					foundHandler = true;
+					if (drop) {
+						Console.WriteLine (&quot;Droping to &quot; + nb);
+						nb.CommandHandler.OnNodeDrop (dragObject, DragOperation.Copy);
+					}
+				}
+			}
+			return foundHandler;
+		}
+*/
+
+		public virtual void Dispose ()
+		{
+			Clear ();
+			foreach (NodeBuilder nb in builders)
+				nb.Dispose ();
+		}
+		
+		protected NodeBuilder[] NodeBuilders {
+			get { return builders; }
+			set { builders = value; }
+		}
+		
+		protected void LoadTree (object nodeObject)
+		{
+			Clear ();
+			TreeBuilder builder = new TreeBuilder (this);
+			builder.AddChild (nodeObject, true);
+			builder.Expanded = true;
+		}
+		
+		protected void Clear ()
+		{
+			object[] obs = new object [nodeHash.Count];
+			nodeHash.Keys.CopyTo (obs, 0);
+			
+			foreach (object dataObject in obs)
+				UnregisterNode (dataObject, null);
+
+			nodeHash = new Hashtable ();
+			store.Clear ();
+		}
+		
+		public ITreeNavigator GetSelectedNode ()
+		{
+			Gtk.TreeModel foo;
+			Gtk.TreeIter iter;
+			if (!tree.Selection.GetSelected (out foo, out iter))
+				return null;
+			
+			return new TreeNodeNavigator (this, iter);
+		}
+		
+		public ITreeNavigator GetNodeAtPosition (NodePosition position)
+		{
+			return new TreeNodeNavigator (this, position._iter);
+		}
+		
+		public ITreeNavigator GetNodeAtObject (object dataObject)
+		{
+			object it = nodeHash [dataObject];
+			if (it == null) return null;
+			return new TreeNodeNavigator (this, (Gtk.TreeIter)it);
+		}
+		
+		public ITreeNavigator GetRootNode ()
+		{
+			Gtk.TreeIter iter;
+			if (!store.GetIterFirst (out iter)) return null;
+			return new TreeNodeNavigator (this, iter);
+		}
+		
+		public void AddNodeInsertCallback (object dataObject, TreeNodeCallback callback)
+		{
+			if (IsRegistered (dataObject)) {
+				callback (GetNodeAtObject (dataObject));
+				return;
+			}
+				
+			ArrayList list = callbacks [dataObject] as ArrayList;
+			if (list != null)
+				list.Add (callback);
+			else {
+				list = new ArrayList ();
+				list.Add (callback);
+				callbacks [dataObject] = list;
+			}
+		}
+		
+		public void ActivateCurrentItem ()
+		{
+			ITreeNavigator node = GetSelectedNode ();
+			if (node != null) {
+				object data = node.DataItem;
+				NodeBuilder[] chain = GetBuilderChain (data.GetType ());
+				NodePosition pos = node.CurrentPosition;
+				foreach (NodeBuilder b in chain) {
+					b.CommandHandler.SetCurrentNode (node);
+					b.CommandHandler.ActivateItem ();
+					node.MoveToPosition (pos);
+				}
+			}
+		}
+
+		public void RemoveCurrentItem ()
+		{
+			ITreeNavigator node = GetSelectedNode ();
+			if (node != null) {
+				object data = node.DataItem;
+				NodeBuilder[] chain = GetBuilderChain (data.GetType ());
+				NodePosition pos = node.CurrentPosition;
+				foreach (NodeBuilder b in chain) {
+					b.CommandHandler.SetCurrentNode (node);
+					b.CommandHandler.RemoveItem ();
+					node.MoveToPosition (pos);
+				}
+			}
+		}
+
+		/// &lt;summary&gt;
+		/// If you want to edit a node label. Select the node you want to edit and then
+		/// call this method, instead of using the LabelEdit Property and the BeginEdit
+		/// Method directly.
+		/// &lt;/summary&gt;
+		public void StartLabelEdit()
+		{
+			Gtk.TreeModel foo;
+			Gtk.TreeIter iter;
+			if (!tree.Selection.GetSelected (out foo, out iter))
+				return;
+			
+			object data = store.GetValue (iter, TreeViewPad.DataItemColumn);
+			
+			TypeNodeBuilder nb = GetTypeNodeBuilder (data.GetType ());
+			store.SetValue (iter, TreeViewPad.TextColumn, nb.GetNodeName (data));
+			
+			text_render.Editable = true;
+			tree.SetCursor (store.GetPath (iter), complete_column, true);
+		}
+
+		void HandleOnEdit (object o, Gtk.EditedArgs e)
+		{
+			text_render.Editable = false;
+			Gtk.TreeIter iter;
+			if (!store.GetIterFromString (out iter, e.Path))
+				throw new Exception(&quot;Error calculating iter for path &quot; + e.Path);
+
+			if (e.NewText == null || e.NewText.Length == 0) {
+				return;
+			}
+
+			ITreeNavigator nav = new TreeNodeNavigator (this, iter);
+			NodePosition pos = nav.CurrentPosition;
+
+			NodeBuilder[] chain = (NodeBuilder[]) store.GetValue (iter, BuilderChainColumn);
+			foreach (NodeBuilder b in chain) {
+				b.CommandHandler.SetCurrentNode (nav);
+				b.CommandHandler.RenameItem (e.NewText);
+				nav.MoveToPosition (pos);
+			}
+		}
+		
+		public void SaveTreeState (XmlElement el)
+		{
+			Gtk.TreeIter iter;
+			if (!store.GetIterFirst (out iter)) return;
+			XmlElement child = SaveTree (el.OwnerDocument, globalOptions, new TreeNodeNavigator (this, iter));
+			if (child != null) el.AppendChild (child);
+		}
+		
+		XmlElement SaveTree (XmlDocument doc, ITreeOptions parentOptions, TreeNodeNavigator nav)
+		{
+			XmlElement el = null;
+			ITreeOptions ops = nodeOptions [nav.DataItem] as ITreeOptions;
+			
+			if (nav.Expanded || ops != null) {
+				el = doc.CreateElement (&quot;Node&quot;);
+				if (ops != null) {
+					foreach (TreePadOption op in options) {
+						if (parentOptions [op.Id] != ops [op.Id]) {
+							XmlElement eop = doc.CreateElement (&quot;Option&quot;);
+							eop.SetAttribute (&quot;id&quot;, op.Id);
+							eop.SetAttribute (&quot;value&quot;, ops [op.Id].ToString ());
+							el.AppendChild (eop);
+						}
+					}
+				}
+			}
+			
+			if (!nav.Filled || !nav.MoveToFirstChild ())
+				return el;
+
+			do {
+				XmlElement child = SaveTree (doc, ops != null ? ops : parentOptions, nav);
+				if (child != null) {
+					if (el == null) el = doc.CreateElement (&quot;Node&quot;);
+					el.AppendChild (child);
+				}
+			} while (nav.MoveNext ());
+			
+			nav.MoveToParent ();
+			
+			if (el != null) {
+				el.SetAttribute (&quot;name&quot;, nav.NodeName);
+				el.SetAttribute (&quot;expanded&quot;, nav.Expanded.ToString ());
+			}
+			return el;
+		}
+		
+		public void RestoreTreeState (XmlElement parent)
+		{
+			ITreeNavigator nav = GetRootNode ();
+			if (nav != null)
+				RestoreTree (parent, nav);
+		}
+		
+		void RestoreTree (XmlElement parent, ITreeNavigator nav)
+		{
+			XmlNodeList nodelist = parent.ChildNodes;
+			foreach (XmlNode nod in nodelist) {
+				XmlElement el = nod as XmlElement;
+				if (el == null) continue;
+				if (el.LocalName == &quot;Option&quot;) {
+					nav.Options [el.GetAttribute (&quot;id&quot;)] = bool.Parse (el.GetAttribute (&quot;value&quot;));
+				}
+			}
+
+			string expanded = parent.GetAttribute (&quot;expanded&quot;);
+			if (expanded == &quot;&quot; || bool.Parse (expanded))
+				nav.Expanded = true;
+				
+			foreach (XmlNode nod in nodelist) {
+				XmlElement el = nod as XmlElement;
+				if (el == null) continue;
+				if (el.LocalName == &quot;Node&quot;) {
+					string name = el.GetAttribute (&quot;name&quot;);
+					if (nav.MoveToChild (name, null)) {
+						RestoreTree (el, nav);
+						nav.MoveToParent ();
+					}
+				}
+			}
+		}
+		
+		NodeBuilder[] GetBuilderChain (Type type)
+		{
+			NodeBuilder[] chain = builderChains [type] as NodeBuilder[];
+			if (chain == null)
+			{
+				ArrayList list = new ArrayList ();
+				foreach (NodeBuilder nb in builders) {
+					if (nb is TypeNodeBuilder) {
+						if (((TypeNodeBuilder)nb).NodeDataType.IsAssignableFrom (type))
+							list.Insert (0, nb);
+					}
+					else if (((NodeBuilderExtension)nb).CanBuildNode (type))
+						list.Add (nb);
+				}
+				
+				chain = (NodeBuilder[]) list.ToArray (typeof(NodeBuilder));
+				
+				if (chain.Length == 0 || !(chain[0] is TypeNodeBuilder))
+					chain = null;
+
+				builderChains [type] = chain;
+			}
+			return chain;
+		}
+		
+		TypeNodeBuilder GetTypeNodeBuilder (Type type)
+		{
+			NodeBuilder[] chain = GetBuilderChain (type);
+			if (chain != null &amp;&amp; chain.Length &gt; 0)
+				return chain[0] as TypeNodeBuilder;
+			return null;
+		}
+		
+		int CompareNodes (Gtk.TreeModel model, Gtk.TreeIter a, Gtk.TreeIter b)
+		{
+			object o1 = store.GetValue (a, DataItemColumn);
+			object o2 = store.GetValue (b, DataItemColumn);
+			
+			NodeBuilder[] chain1 = (NodeBuilder[]) store.GetValue (a, BuilderChainColumn);
+			if (chain1 == null) return 0;
+			
+			TypeNodeBuilder tb1 = (TypeNodeBuilder) chain1[0];
+			int sort = tb1.CompareObjects (o1, o2);
+			if (sort != TypeNodeBuilder.DefaultSort) return sort;
+			
+			NodeBuilder[] chain2 = (NodeBuilder[]) store.GetValue (b, BuilderChainColumn);
+			if (chain2 == null) return 0;
+			
+			if (chain1 == chain2)
+				return string.Compare (tb1.GetNodeName (o1), tb1.GetNodeName (o2), true);
+				
+			TypeNodeBuilder tb2 = (TypeNodeBuilder) chain2[0];
+			sort = tb2.CompareObjects (o2, o1);
+			if (sort != TypeNodeBuilder.DefaultSort) return sort * -1;
+
+			return string.Compare (tb1.GetNodeName (o1), tb2.GetNodeName (o2), true);
+		}
+		
+		internal void RegisterNode (Gtk.TreeIter it, object dataObject, NodeBuilder[] chain)
+		{
+			nodeHash [dataObject] = it;
+
+			if (chain == null) chain = GetBuilderChain (dataObject.GetType());
+			foreach (NodeBuilder nb in chain)
+				nb.OnNodeAdded (dataObject);
+		}
+		
+		internal void UnregisterNode (object dataObject, NodeBuilder[] chain)
+		{
+			nodeOptions.Remove (dataObject);
+			nodeHash.Remove (dataObject);
+			if (chain == null) chain = GetBuilderChain (dataObject.GetType());
+			foreach (NodeBuilder nb in chain)
+				nb.OnNodeRemoved (dataObject);
+		}
+		
+		internal bool IsRegistered (object dataObject)
+		{
+			return nodeHash.Contains (dataObject);
+		}
+		
+		internal void NotifyInserted (Gtk.TreeIter it, object dataObject)
+		{
+			if (callbacks.Count &gt; 0) {
+				ArrayList list = callbacks [dataObject] as ArrayList;
+				if (list != null) {
+					ITreeNavigator nav = new TreeNodeNavigator (this, it);
+					NodePosition pos = nav.CurrentPosition;
+					foreach (TreeNodeCallback callback in list) {
+						callback (nav);
+						nav.MoveToPosition (pos);
+					}
+					callbacks.Remove (dataObject);
+				}
+			}
+		}
+		
+		TreeOptions GetOptions (Gtk.TreeIter iter, bool createSpecificOptions)
+		{
+			if (nodeOptions.Count == 0) {
+				if (createSpecificOptions) {
+					object dataObject = store.GetValue (iter, DataItemColumn);
+					TreeOptions ops = globalOptions.CloneOptions (dataObject);
+					nodeOptions [dataObject] = ops;
+					return ops;
+				}
+				else
+					return globalOptions;
+			}
+			
+			TreeOptions result = null;
+			Gtk.TreeIter it = iter;
+			do {
+				if (store.GetValue (it, BuilderChainColumn) != null) {
+					object ob = store.GetValue (it, DataItemColumn);
+					result = nodeOptions [ob] as TreeOptions;
+				}
+			} while (result == null &amp;&amp; store.IterParent (out it, it));
+
+			if (result == null)
+				result = globalOptions;
+			
+			if (createSpecificOptions &amp;&amp; !it.Equals (iter)) {
+				object dataObject = store.GetValue (iter, DataItemColumn);
+				TreeOptions ops = result.CloneOptions (dataObject);
+				nodeOptions [dataObject] = ops;
+				return ops;
+			} else
+				return result;
+		}
+		
+		internal void ClearOptions (Gtk.TreeIter iter)
+		{
+			if (nodeOptions.Count == 0)
+				return;
+				
+			ArrayList toDelete = new ArrayList ();
+			string path = store.GetPath (iter).ToString () + &quot;:&quot;;
+			
+			foreach (object ob in nodeOptions.Keys) {
+				Gtk.TreeIter nit = (Gtk.TreeIter) nodeHash [ob];
+				string npath = store.GetPath (nit).ToString () + &quot;:&quot;;
+				if (npath.StartsWith (path))
+					toDelete.Add (ob);
+			}
+
+			foreach (object ob in toDelete)
+				nodeOptions.Remove (ob);
+		}
+
+		internal string GetNamePathFromIter (Gtk.TreeIter iter)
+		{
+			StringBuilder sb = new StringBuilder ();
+			do {
+				NodeBuilder[] chain = (NodeBuilder[]) store.GetValue (iter, BuilderChainColumn);
+				string name;
+				if (chain == null)
+					name = (string) store.GetValue (iter, TextColumn);
+				else {
+					object ob = store.GetValue (iter, DataItemColumn);
+					name = ((TypeNodeBuilder)chain[0]).GetNodeName (ob);
+				}
+				if (sb.Length &gt; 0) sb.Insert (0, '/');
+				name = name.Replace (&quot;%&quot;,&quot;%%&quot;);
+				name = name.Replace (&quot;/&quot;,&quot;_%_&quot;);
+				sb.Insert (0, name);
+			} while (store.IterParent (out iter, iter));
+
+			return sb.ToString ();
+		}
+		
+		internal void RefreshNode (object dataObject)
+		{
+			ITreeBuilder builder = new TreeBuilder (this);
+			bool found;
+			
+			if (dataObject != null) found = builder.MoveToObject (dataObject);
+			else found = builder.MoveToRoot ();
+			
+			if (found) {
+				builder.Update ();
+				builder.UpdateChildren ();
+			}
+		}
+		
+		internal bool GetIterFromNamePath (string path, out Gtk.TreeIter iter)
+		{
+			if (!store.GetIterFirst (out iter))
+				return false;
+				
+			TreeNodeNavigator nav = new TreeNodeNavigator (this, iter);
+			string[] names = path.Split ('/');
+
+			int n = 0;
+			bool more;
+			do {
+				string name = names [n].Replace (&quot;_%_&quot;,&quot;/&quot;);
+				name = name.Replace (&quot;%%&quot;,&quot;%&quot;);
+				
+				if (nav.NodeName == name) {
+					iter = nav.CurrentPosition._iter;
+					if (++n == names.Length) return true;
+					more = nav.MoveToFirstChild ();
+				} else
+					more = nav.MoveNext ();
+			} while (more);
+
+			return false;
+		}
+
+		public void StealFocus ()
+		{
+			GLib.Timeout.Add (20, new GLib.TimeoutHandler (wantFocus));
+		}
+		bool wantFocus ()
+		{
+			tree.GrabFocus ();
+			StartLabelEdit ();
+			return false;
+		}
+
+		private void OnTestExpandRow (object sender, Gtk.TestExpandRowArgs args)
+		{
+			bool filled = (bool) store.GetValue (args.Iter, FilledColumn);
+			if (!filled) {
+				TreeBuilder nb = new TreeBuilder (this, args.Iter);
+				args.RetVal = !nb.FillNode ();
+			} else
+				args.RetVal = false;
+		}
+
+		void ShowPopup ()
+		{
+			ITreeNavigator tnav = GetSelectedNode ();
+			Runtime.ProjectService.CurrentSelectedProject = tnav.GetParentDataItem (typeof(Project), true) as Project;
+			Runtime.ProjectService.CurrentSelectedCombine = tnav.GetParentDataItem (typeof(Combine), true) as Combine;
+			
+			TypeNodeBuilder nb = GetTypeNodeBuilder (tnav.DataItem.GetType ());
+			if (nb == null || nb.ContextMenuAddinPath == null) {
+				if (options.Length &gt; 0)
+					Runtime.Gui.Menus.ShowContextMenu (BuildTreeOptionsMenu (tnav.DataItem));
+			} else {
+				Gtk.Menu menu = Runtime.Gui.Menus.CreateContextMenu (this, nb.ContextMenuAddinPath);
+				if (options.Length &gt; 0) {
+					Gtk.MenuItem mi = new Gtk.SeparatorMenuItem ();
+					mi.Show ();
+					menu.Append (mi);
+					
+					mi = new Gtk.MenuItem (GettextCatalog.GetString (&quot;Display Options&quot;));
+					menu.Append (mi);
+					mi.Submenu = BuildTreeOptionsMenu (tnav.DataItem);
+					mi.Show ();
+				}
+				Runtime.Gui.Menus.ShowContextMenu (menu);
+			}
+		}
+		
+		Gtk.Menu BuildTreeOptionsMenu (object dataObject)
+		{
+			ITreeOptions currentOptions = builderContext.GetOptions (dataObject);
+			Gtk.Menu omenu = new Gtk.Menu ();
+
+			foreach (TreePadOption op in options) {
+				PadCheckMenuItem cmi = new PadCheckMenuItem (op.Label, op.Id);
+				cmi.Active = currentOptions [op.Id];
+				omenu.Append (cmi);
+				cmi.Toggled += new EventHandler (OptionToggled);
+			}
+			
+			omenu.Append (new Gtk.SeparatorMenuItem ());
+			
+			Gtk.MenuItem mi = new Gtk.MenuItem (GettextCatalog.GetString (&quot;Reset Options&quot;));
+			mi.Activated += new EventHandler (ResetOptions);
+			omenu.Append (mi);
+			omenu.ShowAll ();
+			
+			return omenu;
+		}
+		
+		void OptionToggled (object sender, EventArgs args)
+		{
+			Gtk.TreeModel foo;
+			Gtk.TreeIter iter;
+			if (!tree.Selection.GetSelected (out foo, out iter))
+				return;
+
+			PadCheckMenuItem mi = (PadCheckMenuItem) sender;
+			GetOptions (iter, true) [mi.Id] = mi.Active;
+		}
+		
+		void ResetOptions (object sender, EventArgs args)
+		{
+			Gtk.TreeModel foo;
+			Gtk.TreeIter iter;
+			if (!tree.Selection.GetSelected (out foo, out iter))
+				return;
+
+			ClearOptions (iter);
+			TreeBuilder tb = new TreeBuilder (this, iter);
+			tb.Update ();
+			tb.UpdateChildren ();
+		}
+
+		void OnPopupMenu (object o, Gtk.PopupMenuArgs args)
+		{
+			if (GetSelectedNode () != null)
+				ShowPopup ();
+		}
+
+		private void OnButtonRelease(object sender, Gtk.ButtonReleaseEventArgs args)
+		{
+			if (args.Event.Button == 3 &amp;&amp; GetSelectedNode() != null) {
+				ShowPopup ();
+			}
+		}
+
+		private void OnNodeActivated (object sender, Gtk.RowActivatedArgs args)
+		{
+			ActivateCurrentItem ();
+		}
+		
+		public IXmlConvertable CreateMemento ()
+		{
+			return new TreeViewPadMemento (this);
+		}
+
+		public void SetMemento (IXmlConvertable memento)
+		{
+			((TreeViewPadMemento)memento).Restore (this);
+		}
+
+		// ********* Own events
+		protected virtual void OnTitleChanged(EventArgs e)
+		{
+			if (TitleChanged != null) {
+				TitleChanged(this, e);
+			}
+		}
+
+		protected virtual void OnIconChanged(EventArgs e)
+		{
+			if (IconChanged != null) {
+				IconChanged(this, e);
+			}
+		}
+
+		public event EventHandler TitleChanged;
+		public event EventHandler IconChanged;
+
+		class PadCheckMenuItem: Gtk.CheckMenuItem
+		{
+			internal string Id;
+			
+			public PadCheckMenuItem (string label, string id): base (label) {
+				Id = id;
+			}
+		}
+
+		class TreeBuilderContext: ITreeBuilderContext
+		{
+			TreeViewPad pad;
+			Hashtable icons = new Hashtable ();
+			Hashtable composedIcons = new Hashtable ();
+			
+			internal TreeBuilderContext (TreeViewPad pad)
+			{
+				this.pad = pad;
+			}
+			
+			public ITreeBuilder GetTreeBuilder ()
+			{
+				Gtk.TreeIter iter;
+				if (!pad.store.GetIterFirst (out iter)) return null;
+				return new TreeBuilder (pad, iter);
+			}
+			
+			public ITreeBuilder GetTreeBuilder (object dataObject)
+			{
+				object pos = pad.nodeHash [dataObject];
+				if (pos == null) return null;
+				return new TreeBuilder (pad, (Gtk.TreeIter) pos);
+			}
+			
+			public Gdk.Pixbuf GetIcon (string id)
+			{
+				Gdk.Pixbuf icon = icons [id] as Gdk.Pixbuf;
+				if (icon == null) {
+					icon = pad.tree.RenderIcon (id, Gtk.IconSize.Menu, &quot;&quot;);
+					icons [id] = icon;
+				}
+				return icon;
+			}
+			
+			public Gdk.Pixbuf GetComposedIcon (Gdk.Pixbuf baseIcon, string compositionId)
+			{
+				Hashtable itable = composedIcons [baseIcon] as Hashtable;
+				if (itable == null) return null;
+				return itable [compositionId] as Gdk.Pixbuf;
+			}
+			
+			public void CacheComposedIcon (Gdk.Pixbuf baseIcon, string compositionId, Gdk.Pixbuf composedIcon)
+			{
+				Hashtable itable = composedIcons [baseIcon] as Hashtable;
+				if (itable == null) {
+					itable = new Hashtable ();
+					composedIcons [baseIcon] = itable;
+				}
+				itable [compositionId] = composedIcon;
+			}
+			
+			public ITreeNavigator GetTreeNavigator (object dataObject)
+			{
+				object pos = pad.nodeHash [dataObject];
+				if (pos == null) return null;
+				return new TreeNodeNavigator (pad, (Gtk.TreeIter) pos);
+			}
+			
+			public ITreeOptions GetOptions (object dataObject)
+			{
+				if (dataObject == null) return pad.globalOptions;
+				object pos = pad.nodeHash [dataObject];
+				if (pos == null) return pad.globalOptions;
+				return new TreeNodeNavigator (pad, (Gtk.TreeIter) pos);
+			}
+		}
+		
+		class TreeNodeNavigator: ITreeNavigator, ITreeOptions
+		{
+			protected TreeViewPad pad;
+			protected Gtk.TreeView tree;
+			protected Gtk.TreeStore store;
+			protected Gtk.TreeIter currentIter;
+			
+			public TreeNodeNavigator (TreeViewPad pad): this (pad, Gtk.TreeIter.Zero)
+			{
+			}
+			
+			public TreeNodeNavigator (TreeViewPad pad, Gtk.TreeIter iter)
+			{
+				this.pad = pad;
+				tree = pad.tree;
+				store = pad.store;
+				currentIter = iter;
+			}
+			
+			public ITreeNavigator Clone ()
+			{
+				return new TreeNodeNavigator (pad, currentIter);
+			}
+
+			
+			public object DataItem {
+				get { return store.GetValue (currentIter, TreeViewPad.DataItemColumn); }
+			}
+			
+			public bool Selected {
+				get {
+					return tree.Selection.IterIsSelected (currentIter);
+				}
+				set {
+					if (value) {
+						Gtk.TreeIter parent = currentIter;
+						while (store.IterParent (out parent, parent)) {
+							Gtk.TreePath path = store.GetPath (parent);
+							tree.ExpandRow (path, false);
+						}
+				
+						tree.Selection.SelectIter (currentIter);
+						tree.ScrollToCell (store.GetPath (currentIter), null, false, 0, 0);
+					}
+				}
+			}
+			
+			public NodePosition CurrentPosition {
+				get {
+					NodePosition pos = new NodePosition ();
+					pos._iter = currentIter;
+					return pos;
+				}
+			}
+		
+			bool ITreeOptions.this [string name] {
+				get { return pad.GetOptions (currentIter, false) [name]; }
+				set { pad.GetOptions (currentIter, true) [name] = value; }
+			}
+			
+			public bool MoveToPosition (NodePosition position)
+			{
+				currentIter = (Gtk.TreeIter) position._iter;
+				return true;
+			}
+			
+			public bool MoveToRoot ()
+			{
+				return store.GetIterFirst (out currentIter);
+			}
+		
+			public bool MoveToObject (object dataObject)
+			{
+				object pos = pad.nodeHash [dataObject];
+				if (pos != null) {
+					currentIter = (Gtk.TreeIter) pos;
+					return true;
+				} else
+					return false;
+			}
+		
+			public bool MoveToParent ()
+			{
+				return store.IterParent (out currentIter, currentIter);
+			}
+			
+			public bool MoveToParent (Type dataType)
+			{
+				Gtk.TreeIter newIter = currentIter;
+				while (store.IterParent (out newIter, newIter)) {
+					object data = store.GetValue (newIter, TreeViewPad.DataItemColumn);
+					if (dataType.IsInstanceOfType (data)) {
+						currentIter = newIter;
+						return true;
+					}
+				}
+				return false;
+			}
+			
+			public bool MoveToFirstChild ()
+			{
+				EnsureFilled ();
+				Gtk.TreeIter it;
+				if (!store.IterChildren (out it, currentIter))
+					return false;
+				
+				currentIter = it;
+				return true;
+			}
+			
+			public bool MoveNext ()
+			{
+				return store.IterNext (ref currentIter);
+			}
+			
+			public bool HasChild (string name, Type dataType)
+			{
+				if (MoveToChild (name, dataType)) {
+					MoveToParent ();
+					return true;
+				} else
+					return false;
+			}
+			
+			public bool HasChildren ()
+			{
+				EnsureFilled ();
+				Gtk.TreeIter it;
+				return store.IterChildren (out it, currentIter);
+			}
+		
+			public bool MoveToChild (string name, Type dataType)
+			{
+				EnsureFilled ();
+				Gtk.TreeIter oldIter = currentIter;
+
+				if (!MoveToFirstChild ()) {
+					currentIter = oldIter;
+					return false;
+				}
+
+				do {
+					if (name == NodeName) return true;
+				} while (MoveNext ());
+
+				currentIter = oldIter;
+				return false;
+			}
+			
+			public bool Expanded {
+				get { return tree.GetRowExpanded (store.GetPath (currentIter)); }
+				set {
+					if (value &amp;&amp; !Expanded) {
+						Gtk.TreePath path = store.GetPath (currentIter);
+						tree.ExpandRow (path, false);
+					}
+					else if (!value &amp;&amp; Expanded) {
+						Gtk.TreePath path = store.GetPath (currentIter);
+						tree.CollapseRow (path);
+					}
+				}
+			}
+
+			public ITreeOptions Options {
+				get { return this; }
+			}
+		
+			public void ExpandToNode ()
+			{
+				Gtk.TreePath path = store.GetPath (currentIter);
+				tree.ExpandToPath (path);
+			}
+			
+			public string NodeName {
+				get {
+					object data = DataItem;
+					NodeBuilder[] chain = BuilderChain;
+					if (chain != null &amp;&amp; chain.Length &gt; 0) return ((TypeNodeBuilder)chain[0]).GetNodeName (data);
+					else return store.GetValue (currentIter, TreeViewPad.TextColumn) as string;;
+				}
+			}
+			
+			public NodeBuilder[] BuilderChain {
+				get { return (NodeBuilder[]) store.GetValue (currentIter, TreeViewPad.BuilderChainColumn); }
+			}
+			
+			public object GetParentDataItem (Type type, bool includeCurrent)
+			{
+				if (includeCurrent &amp;&amp; type.IsInstanceOfType (DataItem))
+					return DataItem;
+
+				Gtk.TreeIter it = currentIter;
+				while (store.IterParent (out it, it)) {
+					object data = store.GetValue (it, TreeViewPad.DataItemColumn);
+					if (type.IsInstanceOfType (data))
+						return data;
+				}
+				return null;
+			}
+		
+			void EnsureFilled ()
+			{
+				if (!(bool) store.GetValue (currentIter, TreeViewPad.FilledColumn))
+					new TreeBuilder (pad, currentIter).FillNode ();
+			}
+			
+			public bool Filled {
+				get { return (bool) store.GetValue (currentIter, TreeViewPad.FilledColumn); }
+			}
+		}
+		
+		
+		class TreeBuilder: TreeNodeNavigator, ITreeBuilder
+		{
+			public TreeBuilder (TreeViewPad pad): base (pad)
+			{
+			}
+
+			public TreeBuilder (TreeViewPad pad, Gtk.TreeIter iter): base (pad, iter)
+			{
+			}
+			
+			void EnsureFilled ()
+			{
+				if (!(bool) store.GetValue (currentIter, TreeViewPad.FilledColumn))
+					FillNode ();
+			}
+			
+			public bool FillNode ()
+			{
+				store.SetValue (currentIter, TreeViewPad.FilledColumn, true);
+				
+				Gtk.TreeIter child;
+				if (store.IterChildren (out child, currentIter))
+					store.Remove (ref child);
+				
+				NodeBuilder[] chain = (NodeBuilder[]) store.GetValue (currentIter, TreeViewPad.BuilderChainColumn);
+				object dataObject = store.GetValue (currentIter, TreeViewPad.DataItemColumn);
+				CreateChildren (chain, dataObject);
+				return store.IterHasChild (currentIter);
+			}
+			
+			public void Update ()
+			{
+				object data = store.GetValue (currentIter, TreeViewPad.DataItemColumn);
+				NodeBuilder[] chain = (NodeBuilder[]) store.GetValue (currentIter, TreeViewPad.BuilderChainColumn);
+				UpdateNode (chain, data);
+			}
+			
+			public void UpdateChildren ()
+			{
+				object data = store.GetValue (currentIter, TreeViewPad.DataItemColumn);
+				NodeBuilder[] chain = (NodeBuilder[]) store.GetValue (currentIter, TreeViewPad.BuilderChainColumn);
+				
+				if (!(bool) store.GetValue (currentIter, TreeViewPad.FilledColumn)) {
+					if (!HasChildNodes (chain, data))
+						FillNode ();
+					return;
+				}
+				
+				if (!tree.GetRowExpanded (store.GetPath (currentIter))) {
+					if (!HasChildNodes (chain, data))
+						FillNode ();
+					else {
+						RemoveChildren (currentIter);
+						store.Append (currentIter);	// Dummy node
+						store.SetValue (currentIter, TreeViewPad.FilledColumn, false);
+					}
+					return;
+				}
+
+				ArrayList state = new ArrayList ();
+				SaveExpandState (currentIter, state);
+				RemoveChildren (currentIter);
+				CreateChildren (chain, data);
+				RestoreExpandState (state);
+			}
+			
+			void RemoveChildren (Gtk.TreeIter it)
+			{
+				Gtk.TreeIter child;
+				while (store.IterChildren (out child, it)) {
+					RemoveChildren (child);
+					object childData = store.GetValue (child, TreeViewPad.DataItemColumn);
+					if (childData != null)
+						pad.UnregisterNode (childData, null);
+					store.Remove (ref child);
+				}
+			}
+			
+			void SaveExpandState (Gtk.TreeIter it, ArrayList state)
+			{
+				if (tree.GetRowExpanded (store.GetPath (it)))
+					state.Add (store.GetValue (it, TreeViewPad.DataItemColumn));
+				if (store.IterChildren (out it, it)) {
+					do {
+						SaveExpandState (it, state);
+					} while (store.IterNext (ref it));
+				}
+			}
+			
+			void RestoreExpandState (ArrayList state)
+			{
+				foreach (object ob in state) {
+					object pos = pad.nodeHash [ob];
+					if (pos == null) continue;
+					
+					Gtk.TreeIter it = (Gtk.TreeIter) pos;
+					Gtk.TreePath p = store.GetPath (it);
+					tree.ExpandRow (p, false);
+				}
+			}
+			
+			public void Remove ()
+			{
+				RemoveChildren (currentIter);
+				object data = store.GetValue (currentIter, TreeViewPad.DataItemColumn);
+				pad.UnregisterNode (data, null);
+				store.Remove (ref currentIter);
+			}
+			
+			public void Remove (bool moveToParent)
+			{
+				Gtk.TreeIter parent;
+				store.IterParent (out parent, currentIter);
+
+				Remove ();
+
+				if (moveToParent)
+					currentIter = parent;
+			}
+			
+			public void AddChild (object dataObject)
+			{
+				AddChild (dataObject, false);
+			}
+			
+			public void AddChild (object dataObject, bool moveToChild)
+			{
+				if (dataObject == null) throw new ArgumentNullException (&quot;dataObject&quot;);
+				
+				if (!currentIter.Equals (Gtk.TreeIter.Zero))
+					EnsureFilled ();
+					
+				if (pad.IsRegistered (dataObject)) return;
+
+				NodeBuilder[] chain = pad.GetBuilderChain (dataObject.GetType ());
+				if (chain == null) return;
+				
+				Gtk.TreeIter oldIter = currentIter;
+				NodeAttributes ats = NodeAttributes.None;
+				
+				foreach (NodeBuilder nb in chain) {
+					nb.GetNodeAttributes (this, dataObject, ref ats);
+					currentIter = oldIter;
+				}
+				
+				if ((ats &amp; NodeAttributes.Hidden) != 0)
+					return;
+					
+				Gtk.TreeIter it;
+				if (!currentIter.Equals (Gtk.TreeIter.Zero))
+					it = store.Append (currentIter);
+				else
+					store.Append (out it);
+				
+				pad.RegisterNode (it, dataObject, chain);
+				
+				BuildNode (it, chain, dataObject);
+				if (moveToChild)
+					currentIter = it;
+				else
+					currentIter = oldIter;
+
+				pad.NotifyInserted (it, dataObject);
+			}
+			
+			void BuildNode (Gtk.TreeIter it, NodeBuilder[] chain, object dataObject)
+			{
+				Gtk.TreeIter oldIter = currentIter;
+				currentIter = it;
+				
+				// It is *critical* that we set this first. We will
+				// sort after this call, so we must give as much info
+				// to the sort function as possible.
+				store.SetValue (it, TreeViewPad.DataItemColumn, dataObject);
+				store.SetValue (it, TreeViewPad.BuilderChainColumn, chain);
+				
+				UpdateNode (chain, dataObject);
+				
+				bool hasChildren = HasChildNodes (chain, dataObject);
+				store.SetValue (currentIter, TreeViewPad.FilledColumn, !hasChildren);
+
+				if (hasChildren)
+					store.Append (currentIter);	// Dummy node
+
+				currentIter = oldIter;
+			}
+			
+			bool HasChildNodes (NodeBuilder[] chain, object dataObject)
+			{
+				Gtk.TreeIter citer = currentIter;
+				foreach (NodeBuilder nb in chain) {
+					bool res = nb.HasChildNodes (this, dataObject);
+					currentIter = citer;
+					if (res) return true;
+				}
+				return false;
+			}
+			
+			void UpdateNode (NodeBuilder[] chain, object dataObject)
+			{
+				Gdk.Pixbuf icon = null;
+				Gdk.Pixbuf closedIcon = null;
+				string text = string.Empty;
+				Gtk.TreeIter citer = currentIter;
+				
+				foreach (NodeBuilder builder in chain) {
+					builder.BuildNode (this, dataObject, ref text, ref icon, ref closedIcon);
+					currentIter = citer;
+				}
+					
+				if (closedIcon == null) closedIcon = icon;
+				
+				SetNodeInfo (currentIter, text, icon, closedIcon);
+			}
+			
+			void SetNodeInfo (Gtk.TreeIter it, string text, Gdk.Pixbuf icon, Gdk.Pixbuf closedIcon)
+			{
+				store.SetValue (it, TreeViewPad.TextColumn, text);
+				if (icon != null) store.SetValue (it, TreeViewPad.OpenIconColumn, icon);
+				if (closedIcon != null) store.SetValue (it, TreeViewPad.ClosedIconColumn, closedIcon);
+			}
+
+			void CreateChildren (NodeBuilder[] chain, object dataObject)
+			{
+				Gtk.TreeIter it = currentIter;
+				foreach (NodeBuilder builder in chain) {
+					builder.BuildChildNodes (this, dataObject);
+					currentIter = it;
+				}
+			}
+		}
+		
+		class TreeOptions: Hashtable, ITreeOptions
+		{
+			TreeViewPad pad;
+			object dataObject;
+			
+			public TreeOptions ()
+			{
+			}
+			
+			public TreeOptions (TreeViewPad pad, object dataObject)
+			{
+				this.pad = pad;
+				this.dataObject = dataObject;
+			}
+			
+			public TreeViewPad Pad {
+				get { return pad; }
+				set { pad = value; }
+			}
+
+			public bool this [string name] {
+				get {
+					object op = base [name];
+					if (op == null) return false;
+					return (bool) op;
+				}
+				set {
+					base [name] = value;
+					if (pad != null)
+						pad.RefreshNode (dataObject);
+				}
+			}
+			
+			public TreeOptions CloneOptions (object newDataObject)
+			{
+				TreeOptions ops = new TreeOptions (pad, null);
+				ops.pad = pad;
+				ops.dataObject = newDataObject;
+				foreach (DictionaryEntry de in this)
+					ops [de.Key] = de.Value;
+				return ops;
+			}
+		}
+	}
+	
+	public class TreeViewPadMemento : IXmlConvertable
+	{
+		TreeViewPad treeView = null;
+		XmlElement parent = null;
+		
+		public TreeViewPadMemento()
+		{
+		}
+		
+		public TreeViewPadMemento (TreeViewPad treeView)
+		{
+			this.treeView = treeView;
+		}
+		
+		public void Restore (TreeViewPad view)
+		{
+			XmlElement rootNode = parent [&quot;Node&quot;];
+			if (rootNode != null) {
+				view.RestoreTreeState (rootNode);
+			}
+		}
+		
+		public object FromXmlElement (XmlElement element)
+		{
+			this.parent = element;
+			return this;
+		}
+		
+		public XmlElement ToXmlElement (XmlDocument doc)
+		{
+			Debug.Assert(treeView != null);
+			
+			XmlElement treenode  = doc.CreateElement (&quot;TreeView&quot;);
+			treeView.SaveTreeState (treenode);
+			return treenode;
+		}
+	}
+	
+	public delegate void TreeNodeCallback (ITreeNavigator nav);
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TypeNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TypeNodeBuilder.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad/TypeNodeBuilder.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,57 @@
+//
+// TypeNodeBuilder.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public abstract class TypeNodeBuilder: NodeBuilder
+	{
+		// Return this const in CompareToObject to instruct the tree view to
+		// use the default sorting rules for the compared objects.
+		public const int DefaultSort = int.MinValue;
+		
+		public abstract Type NodeDataType { get; }
+		
+		public abstract string GetNodeName (object dataObject);
+		
+		// Return -1 if thisDataObject is less than otherDataObject, 0 if equal, 1 if greater
+		// Return DefaultSort is sort is undefined or you want to use default sorting rules
+		// (by default, it compares the node name).
+		// The thisDataObject parameter is an instance valid for this node builder.
+		// otherDataObject may not be an instance valid for this builder.
+		public virtual int CompareObjects (object thisDataObject, object otherDataObject)
+		{
+			return DefaultSort;
+		}
+		
+		public virtual string ContextMenuAddinPath {
+			get { return null; }
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/TerminalPad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/TerminalPad.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/TerminalPad.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -18,7 +18,15 @@
 
 		IProjectService projectService = (IProjectService) ServiceManager.Services.GetService (typeof (IProjectService));
 		PropertyService propertyService = (PropertyService) ServiceManager.Services.GetService (typeof (PropertyService));
+
+		public string Id {
+			get { return &quot;TerminalPad&quot;; }
+		}
 		
+		public string DefaultPlacement {
+			get { return &quot;Bottom&quot;; }
+		}
+		
 		public Widget Control {
 			get {
 				return frame;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/DefaultWorkbench.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/DefaultWorkbench.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/DefaultWorkbench.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -21,6 +21,7 @@
 using MonoDevelop.Core.Services;
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.AddIns.Codons;
 
 using MonoDevelop.Services;
 
@@ -34,7 +35,7 @@
 	public class DefaultWorkbench : Gtk.Window, IWorkbench
 	{
 		readonly static string mainMenuPath    = &quot;/SharpDevelop/Workbench/MainMenu&quot;;
-		readonly static string viewContentPath = &quot;/SharpDevelop/Workbench/Views&quot;;
+		readonly static string viewContentPath = &quot;/SharpDevelop/Workbench/Pads&quot;;
 		
 		PadContentCollection viewContentCollection       = new PadContentCollection();
 		ViewContentCollection workbenchContentCollection = new ViewContentCollection();
@@ -52,7 +53,7 @@
 		static GType gtype;
 		
 		public Gtk.MenuBar TopMenu = null;
-
+		
 		enum TargetList {
 			UriList = 100
 		}
@@ -291,13 +292,12 @@
 			RedrawAllComponents ();
 		}
 		
-		public virtual void ShowPad(IPadContent content)
+		public virtual void ShowPad (IPadContent content)
 		{
 			PadContentCollection.Add(content);
 			
-			if (layout != null) {
-				layout.ShowPad(content);
-			}
+			if (layout != null)
+				layout.ShowPad (content);
 		}
 		
 		public void RedrawAllComponents()
@@ -583,12 +583,12 @@
 		
 		public void UpdateViews(object sender, EventArgs e)
 		{
-			IPadContent[] contents = (IPadContent[])(AddInTreeSingleton.AddInTree.GetTreeNode(viewContentPath).BuildChildItems(this)).ToArray(typeof(IPadContent));
-			foreach (IPadContent content in contents) {
-				ShowPad(content);
-			}
+			PadCodon[] padCodons = (PadCodon[])(AddInTreeSingleton.AddInTree.GetTreeNode(viewContentPath).BuildChildItems(this)).ToArray(typeof(PadCodon));
+			foreach (PadCodon codon in padCodons)
+				ShowPad (codon.Pad);
 		}
-			// Handle keyboard shortcuts
+		
+		// Handle keyboard shortcuts
 
 
 		public event EventHandler ActiveWorkbenchWindowChanged;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -18,6 +18,8 @@
 using Gdl;
 using MonoDevelop.Gui.Widgets;
 using MonoDevelop.Gui.Utils;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Core.AddIns;
 
 namespace MonoDevelop.Gui
 {	
@@ -44,6 +46,8 @@
 		DockLayout dockLayout;
 		DragNotebook tabControl;
 		EventHandler contextChangedHandler;
+		
+		WorkbenchContextCodon[] contextCodons;
 
 		public SdiWorkbenchLayout () {
 			contextChangedHandler = new EventHandler (OnContextChanged);
@@ -113,7 +117,7 @@
 			// create DockItems for all the pads
 			foreach (IPadContent content in workbench.PadContentCollection)
 			{
-				AddPad (content, DockPlacement.Left, false);
+				AddPad (content, content.DefaultPlacement);
 			}
 			
 			// FIXME: GTKize
@@ -176,7 +180,7 @@
 			{
 				if (!activePadCollection.Contains (content))
 				{
-					DockItem item = dock.GetItemByName (content.ToString ());
+					DockItem item = dock.GetItemByName (content.Id);
 					if (item != null)
 						item.HideItem ();
 				}
@@ -219,7 +223,7 @@
 
 				// persist the selected layout for the current context
 				Runtime.Properties.SetProperty (&quot;MonoDevelop.Gui.SdiWorkbenchLayout.&quot; +
-				                             workbenchContext.ToString (), value);
+				                             workbenchContext.Id, value);
 			}
 		}
 
@@ -247,7 +251,7 @@
 		{
 			if (activePadCollection.Contains (content))
 			{
-				DockItem item = dock.GetItemByName (content.ToString ());
+				DockItem item = dock.GetItemByName (content.Id);
 				return item;
 			}
 			return null;
@@ -255,59 +259,23 @@
 		
 		void CreateDefaultLayout()
 		{
-			string[] commonPads = new string[] {
-				&quot;MonoDevelop.Gui.Pads.ProjectBrowser.ProjectBrowserView&quot;,
-				&quot;MonoDevelop.Gui.Pads.ClassScout&quot;,
-				&quot;MonoDevelop.Gui.Pads.FileScout&quot;,
-				&quot;MonoDevelop.Gui.Pads.SideBarView&quot;,
-				&quot;MonoDevelop.Gui.Pads.PropertyPad&quot;,
-				&quot;MonoDevelop.Gui.Pads.OpenTaskView&quot;,
-				&quot;MonoDevelop.Gui.Pads.HelpTree&quot;,
-//				&quot;MonoDevelop.EditorBindings.Gui.Pads.CompilerMessageView&quot;,
-				//&quot;MonoDevelop.Gui.Pads.TerminalPad&quot;,
-				&quot;MonoDevelop.Gui.Pads.HelpBrowser&quot;,
-				&quot;MonoQuery.Pads.MonoQueryView&quot;
-			};
-
-			string[] debugPads = new string[] {
-				&quot;MonoDevelop.SourceEditor.Gui.DebuggerLocalsPad&quot;,
-				&quot;MonoDevelop.SourceEditor.Gui.DebuggerStackTracePad&quot;,
-				&quot;MonoDevelop.SourceEditor.Gui.DebuggerThreadPad&quot;
-			};
-
-			string[] editPads = new string[] {
-			};
-
+			contextCodons = (WorkbenchContextCodon[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/Contexts&quot;).BuildChildItems(this)).ToArray(typeof(WorkbenchContextCodon));
 			PadContentCollection collection;
 			
-			foreach (WorkbenchContext ctxt in Enum.GetValues (typeof (WorkbenchContext)))
+			// Set the pads specific of each context
+			foreach (WorkbenchContextCodon codon in contextCodons)
 			{
 				collection = new PadContentCollection ();
-				padCollections [ctxt] = collection;
-				foreach (string padTypeName in commonPads)
-				{
-					IPadContent pad = workbench.PadContentCollection [padTypeName];
+				WorkbenchContext ctx = WorkbenchContext.GetContext (codon.ID);
+				padCollections [ctx] = collection;
+
+				foreach (ContextPadCodon padCodon in codon.Pads) {
+					IPadContent pad = workbench.PadContentCollection [padCodon.ID];
 					if (pad != null)
 						collection.Add (pad);
 				}
 			}
 			
-			collection = (PadContentCollection) padCollections [WorkbenchContext.Edit];
-			foreach (string padTypeName in editPads)
-			{
-				IPadContent pad = workbench.PadContentCollection [padTypeName];
-				if (pad != null)
-					collection.Add (pad);
-			}
-				
-			collection = (PadContentCollection) padCollections [WorkbenchContext.Debug];
-			foreach (string padTypeName in debugPads)
-			{
-				IPadContent pad = workbench.PadContentCollection [padTypeName];
-				if (pad != null)
-					collection.Add (pad);
-			}
-				
 			//Console.WriteLine(&quot; Default Layout created.&quot;);
 			dockLayout = new DockLayout (dock);
 			if (System.IO.File.Exists (configFile)) {
@@ -331,9 +299,54 @@
 			activePadCollection = null;
 		}
 		
-		void AddPad (IPadContent content, DockPlacement placement, bool extraPad)
+		void GetPlacement (string placementString, out DockPlacement dockPlacement, out DockItem originItem)
 		{
-			DockItem item = new DockItem (content.ToString (),
+			// placementString can be: left, right, top, bottom, or a relative
+			// position, for example: &quot;ProjectPad/left&quot; would show the pad at
+			// the left of the project pad. When using
+			// relative placements several positions can be provided. If the
+			// pad can be placed in the first position, the next one will be
+			// tried. For example &quot;ProjectPad/left; bottom&quot;.
+			
+			dockPlacement = DockPlacement.None;
+			string[] placementOptions = placementString.Split (';');
+			foreach (string placementOption in placementOptions) {
+				int i = placementOption.IndexOf ('/');
+				if (i == -1) {
+					dockPlacement = (DockPlacement) Enum.Parse (typeof(DockPlacement), placementOption, true);
+					break;
+				} else {
+					string id = placementOption.Substring (0, i);
+					originItem = dock.GetItemByName (id); 
+					if (originItem != null &amp;&amp; originItem.IsAttached) {
+						dockPlacement = (DockPlacement) Enum.Parse (typeof(DockPlacement), placementOption.Substring (i+1), true);
+						return;
+					}
+				}
+			}
+
+			if (dockPlacement != DockPlacement.None) {
+				// If there is a pad in the same position, place the new one
+				// over the existing one with a new tab.
+				foreach (IPadContent pad in activePadCollection) {
+					string[] places = pad.DefaultPlacement.Split (';');
+					foreach (string p in places)
+						if (string.Compare (p.Trim(), dockPlacement.ToString(), true) == 0) {
+							originItem = GetDockItem (pad);
+							if (originItem != null &amp;&amp; originItem.IsAttached) {
+								dockPlacement = DockPlacement.Center;
+								return;
+							}
+						}
+				}
+			}
+			
+			originItem = null;
+		}
+		
+		void AddPad (IPadContent content, string placement)
+		{
+			DockItem item = new DockItem (content.Id,
 								 content.Title,
 								 content.Icon,
 								 DockItemBehavior.Normal);
@@ -343,24 +356,36 @@
 
 			item.Add (content.Control);
 			item.ShowAll ();
+			item.HideItem ();
+
 			content.TitleChanged += new EventHandler (UpdatePad);
 			content.IconChanged += new EventHandler (UpdatePad);
 			
-			if (extraPad) {
-				DockItem ot = dock.GetItemByName (&quot;MonoDevelop.Gui.Pads.OpenTaskView&quot;); 
-				if (ot != null &amp;&amp; ot.IsAttached) {
-					item.DockTo (ot, DockPlacement.Center);
+			DockPad (item, placement);
+
+			if (!activePadCollection.Contains (content))
+				activePadCollection.Add (content);
+		}
+		
+		void DockPad (DockItem item, string placement)
+		{
+			DockPlacement dockPlacement = DockPlacement.None;
+			DockItem ot = null;
+			
+			if (placement != null)
+				GetPlacement (placement, out dockPlacement, out ot);
+				
+			if (dockPlacement != DockPlacement.None &amp;&amp; dockPlacement != DockPlacement.Floating) {
+				if (ot != null) {
+					item.DockTo (ot, dockPlacement);
 				}
 				else {
 					ot = dock.GetItemByName (&quot;Documents&quot;); 
-					item.DockTo (ot, DockPlacement.Bottom);
+					item.DockTo (ot, dockPlacement);
 				}
 			}
 			else
-				dock.AddItem (item, placement);
-
-			if (!activePadCollection.Contains (content))
-				activePadCollection.Add (content);
+				dock.AddItem (item, dockPlacement);
 		}
 		
 		void UpdatePad (object source, EventArgs args)
@@ -378,11 +403,14 @@
 		public void ShowPad (IPadContent content)
 		{
 			DockItem item = GetDockItem (content);
-			if (item != null)
-				item.ShowItem();
-			else {
-				AddPad (content, DockPlacement.Bottom, true);
+			if (item != null) {
+				if (item.DefaultPosition != null)
+					item.ShowItem();
+				else
+					DockPad (item, content.DefaultPlacement);
 			}
+			else
+				AddPad (content, content.DefaultPlacement);
 		}
 		
 		public bool IsVisible (IPadContent padContent)
@@ -410,7 +438,7 @@
 		public void RedrawAllComponents()
 		{
 			foreach (IPadContent content in ((IWorkbench)workbench).PadContentCollection) {
-				DockItem item = dock.GetItemByName (content.ToString ());
+				DockItem item = dock.GetItemByName (content.Id);
 				if (item != null)
 					item.LongName = content.Title;
 			}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceWindow.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceWindow.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -201,14 +201,6 @@
 			WorkbenchSingleton.Workbench.WorkbenchLayout.ActiveMdiChanged (null, null);
 		}
 		
-		public void DetachContent()
-		{
-			content.ContentNameChanged -= new EventHandler(SetTitleEvent);
-			content.DirtyChanged       -= new EventHandler(SetTitleEvent);
-			content.BeforeSave         -= new EventHandler(BeforeSave);
-			content.ContentChanged     -= new EventHandler (OnContentChanged);
-		}
-
 		public void OnContentChanged (object o, EventArgs e)
 		{
 			if (subViewContents != null) {
@@ -249,9 +241,21 @@
 				WorkbenchSingleton.Workbench.WorkbenchLayout.RemoveTab (pageNum);
 			}
 			OnWindowDeselected(EventArgs.Empty);
+			
+			content.ContentNameChanged -= new EventHandler(SetTitleEvent);
+			content.DirtyChanged       -= new EventHandler(SetTitleEvent);
+			content.BeforeSave         -= new EventHandler(BeforeSave);
+			content.ContentChanged     -= new EventHandler (OnContentChanged);
+			content.WorkbenchWindow = null;
+			
+			Remove (content.Control);
 			content.Dispose ();
 			OnCloseEvent(null);
-			content = null;
+			
+			this.content = null;
+			this.tabControl = null;
+			this.tabLabel = null;
+			this.tabPage = null;
 		}
 		
 		public void AttachSecondaryViewContent(ISecondaryViewContent subViewContent)

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ContextPadCodon.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ContextPadCodon.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ContextPadCodon.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,49 @@
+//
+// ContextPadCodon.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+using System.Collections;
+using MonoDevelop.Core.AddIns.Conditions;
+
+namespace MonoDevelop.Core.AddIns.Codons
+{
+	[CodonNameAttribute (&quot;ContextPad&quot;)]
+	public class ContextPadCodon : AbstractCodon
+	{
+		[XmlMemberAttribute (&quot;defaultVisible&quot;)]
+		bool visible = true;
+		
+		public override object BuildItem (object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			return this;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/NodeBuilderCodon.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/NodeBuilderCodon.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/NodeBuilderCodon.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,55 @@
+//
+// NodeBuilderCodon.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+using System.Collections;
+using MonoDevelop.Core.AddIns.Conditions;
+using MonoDevelop.Gui.Pads;
+
+namespace MonoDevelop.Core.AddIns.Codons
+{
+	[CodonNameAttribute (&quot;NodeBuilder&quot;)]
+	public class NodeBuilderCodon : AbstractCodon
+	{
+		NodeBuilder builder;
+		
+		public NodeBuilder NodeBuilder {
+			get { return builder; }
+		}
+		
+		public override object BuildItem (object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			builder = (NodeBuilder) AddIn.CreateObject (Class);
+			if (builder == null) throw new ApplicationException (&quot;Could not create object of type: &quot; + Class);
+			return this;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/PadCodon.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/PadCodon.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/PadCodon.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,73 @@
+//
+// PadCodon.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+using System.Collections;
+using MonoDevelop.Core.AddIns.Conditions;
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Core.AddIns.Codons
+{
+	[CodonNameAttribute (&quot;Pad&quot;)]
+	public class PadCodon : AbstractCodon
+	{
+		IPadContent content;
+		
+		[XmlMemberAttribute(&quot;context&quot;)]
+		string context = null;
+		
+		string[] contexts;
+		
+		public IPadContent Pad {
+			get { return content; }
+		}
+		
+		public string[] Contexts {
+			get { return contexts; }
+		}
+		
+		public override object BuildItem (object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			content = CreatePad ();
+			return this;
+		}
+		
+		protected virtual IPadContent CreatePad ()
+		{
+			if (context != null)
+				contexts = context.Split (',');
+
+			IPadContent pad = (IPadContent) AddIn.CreateObject (Class);
+			if (pad == null) throw new ApplicationException (&quot;Could not create pad of type: &quot; + Class);
+			return pad;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/PadOptionCodon.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/PadOptionCodon.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/PadOptionCodon.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,60 @@
+//
+// PadOptionCodon.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+using System.Collections;
+using MonoDevelop.Core.AddIns.Conditions;
+using MonoDevelop.Gui.Pads;
+
+namespace MonoDevelop.Core.AddIns.Codons
+{
+	[CodonNameAttribute (&quot;PadOption&quot;)]
+	public class PadOptionCodon : AbstractCodon
+	{
+		[XmlMemberAttribute(&quot;_label&quot;, IsRequired=true)]
+		string label = null;
+		
+		[XmlMemberAttribute(&quot;defaultValue&quot;)]
+		bool defaultValue;
+		
+		TreePadOption option;
+		
+		public TreePadOption Option {
+			get { return option; }
+		}
+		
+		public override object BuildItem (object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			option = new TreePadOption (ID, label, defaultValue);
+			return this;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/SolutionPadCodon.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/SolutionPadCodon.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/Pads/SolutionPadCodon.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,99 @@
+//
+// SolutionPadCodon.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+using System.Collections;
+using MonoDevelop.Core.AddIns.Conditions;
+using MonoDevelop.Gui;
+using MonoDevelop.Gui.Pads;
+
+namespace MonoDevelop.Core.AddIns.Codons
+{
+	[CodonNameAttribute (&quot;SolutionPad&quot;)]
+	public class SolutionPadCodon : PadCodon
+	{
+		NodeBuilder[] builders;
+		TreePadOption[] options;
+		
+		[XmlMemberAttribute(&quot;_label&quot;, IsRequired=true)]
+		string label = null;
+		
+		[XmlMemberAttribute(&quot;icon&quot;)]
+		string icon = null;
+
+		[XmlMemberAttribute(&quot;defaultPlacement&quot;)]
+		string placement = null;
+
+		public NodeBuilder[] NodeBuilders {
+			get { return builders; }
+		}
+		
+		public string Label {
+			get { return label; }
+		}
+		
+		public string Icon {
+			get { return icon; }
+		}
+		
+		public string DefaultPlacement {
+			get { return placement; }
+		}
+		
+		public override object BuildItem (object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			ArrayList bs = new ArrayList ();
+			ArrayList ops = new ArrayList ();
+			
+			foreach (object ob in subItems) {
+				NodeBuilderCodon nbc = ob as NodeBuilderCodon;
+				if (nbc != null)
+					bs.Add (nbc.NodeBuilder);
+				else {
+					PadOptionCodon poc = ob as PadOptionCodon;
+					if (poc != null)
+						ops.Add (poc.Option);
+				}
+			}
+			builders = (NodeBuilder[]) bs.ToArray (typeof(NodeBuilder));
+			options = (TreePadOption[]) ops.ToArray (typeof(TreePadOption));
+			return base.BuildItem (owner, subItems, conditions);
+		}
+		
+		protected override IPadContent CreatePad ()
+		{
+			SolutionPad pad = new SolutionPad (label, icon, builders, options);
+			pad.DefaultPlacement = placement;
+			pad.Id = ID;
+			return pad;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/WorkbenchContextCodon.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/WorkbenchContextCodon.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/WorkbenchContextCodon.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -0,0 +1,59 @@
+//
+// WorkbenchContextCodon .cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+using System.Collections;
+using MonoDevelop.Core.AddIns.Conditions;
+
+namespace MonoDevelop.Core.AddIns.Codons
+{
+	[CodonNameAttribute (&quot;WorkbenchContext&quot;)]
+	public class WorkbenchContextCodon : AbstractCodon
+	{
+		ContextPadCodon[] pads;
+		
+		public ContextPadCodon[] Pads {
+			get { return pads; }
+		}
+		
+		public override object BuildItem (object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			ArrayList bs = new ArrayList ();
+			foreach (object ob in subItems) {
+				ContextPadCodon spad = ob as ContextPadCodon;
+				if (spad != null)
+					bs.Add (spad);
+			}
+			pads = (ContextPadCodon[]) bs.ToArray (typeof(ContextPadCodon));
+			return this;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/Combine.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/Combine.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/Combine.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -235,8 +235,8 @@
 		{
 			Project pce = entry as Project;
 			if (pce != null) {
-				pce.FileRemovedFromProject -= fileAddedToProjectHandler;
-				pce.FileAddedToProject -= fileRemovedFromProjectHandler;
+				pce.FileRemovedFromProject -= fileRemovedFromProjectHandler;
+				pce.FileAddedToProject -= fileAddedToProjectHandler;
 				pce.FileChangedInProject -= fileChangedInProjectHandler;
 				pce.FileRenamedInProject -= fileRenamedInProjectHandler;
 				pce.ReferenceRemovedFromProject -= referenceRemovedFromProjectHandler;
@@ -245,8 +245,8 @@
 			else {
 				Combine cce = entry as Combine;
 				if (cce != null) {
-					cce.FileRemovedFromProject -= fileAddedToProjectHandler;
-					cce.FileAddedToProject -= fileRemovedFromProjectHandler;
+					cce.FileRemovedFromProject -= fileRemovedFromProjectHandler;
+					cce.FileAddedToProject -= fileAddedToProjectHandler;
 					cce.FileChangedInProject -= fileChangedInProjectHandler;
 					cce.FileRenamedInProject -= fileRenamedInProjectHandler;
 					cce.ReferenceRemovedFromProject -= referenceRemovedFromProjectHandler;
@@ -267,12 +267,13 @@
 			// remove configuration
 			foreach (CombineConfiguration dentry in Configurations)
 				dentry.RemoveEntry (entry);
+
+			OnEntryRemoved (new CombineEntryEventArgs (entry));
 		}
 		
 		public void RemoveEntry (CombineEntry entry)
 		{
 			Entries.Remove (entry);
-			OnEntryRemoved (new CombineEntryEventArgs (entry));
 		}
 		
 		public override void Debug (IProgressMonitor monitor)

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IncludeFilesDialog.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IncludeFilesDialog.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IncludeFilesDialog.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -126,6 +126,8 @@
 				store.IterNext(ref current);
 			}
 			
+			Runtime.ProjectService.SaveCombine ();
+			
 			IncludeFilesDialogWidget.Destroy();
 		}
 		
@@ -158,7 +160,7 @@
 		
 		public void ShowDialog()
 		{
-			this.IncludeFilesDialogWidget.Run();
+			this.IncludeFilesDialogWidget.Show ();
 		}
 
 	}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Project.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Project.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Project.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -192,16 +192,16 @@
 			}
 			
 			if (newFiles.Count &gt; 0) {
-//				if (newFileSearch == NewFileSearch.OnLoadAutoInsert) {
+				if (newFileSearch == NewFileSearch.OnLoadAutoInsert) {
 					foreach (string file in newFiles) {
 						ProjectFile newFile = new ProjectFile(file);
 						newFile.BuildAction = IsCompileable(file) ? BuildAction.Compile : BuildAction.Nothing;
 						ProjectFiles.Add(newFile);
 					}
-/*				} else {
-					Runtime.DispatchService.GuiSyncDispatch (new MessageHandler (new IncludeFilesDialog (BaseDirectory, this, newFiles).ShowDialog));
+				} else {
+					Runtime.DispatchService.GuiDispatch (new MessageHandler (new IncludeFilesDialog (this, newFiles).ShowDialog));
 				}
-*/			}
+			}
 		}
 		
 		public static Project LoadProject (string filename, IProgressMonitor monitor)

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReference.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReference.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReference.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -184,6 +184,19 @@
 			return MemberwiseClone();
 		}
 		
+		public override bool Equals (object other)
+		{
+			ProjectReference oref = other as ProjectReference;
+			if (oref == null) return false;
+			
+			return reference == oref.reference &amp;&amp; referenceType == oref.referenceType;
+		}
+		
+		public override int GetHashCode ()
+		{
+			return reference.GetHashCode ();
+		}
+		
 		protected virtual void OnReferenceChanged(EventArgs e) 
 		{
 			if (ReferenceChanged != null) {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-03-14 23:32:08 UTC (rev 2346)
@@ -40,8 +40,43 @@
 Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs \
 Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs \
 Gui/Pads/ClassScout/BrowserNode/AbstractClassScoutNode.cs \
+Gui/Pads/ClassPad/ClassData.cs \
+Gui/Pads/ClassPad/ClassNodeBuilder.cs \
+Gui/Pads/ClassPad/CombineNodeBuilder.cs \
+Gui/Pads/ClassPad/EventNodeBuilder.cs \
+Gui/Pads/ClassPad/FieldNodeBuilder.cs \
+Gui/Pads/ClassPad/MemberNodeBuilder.cs \
+Gui/Pads/ClassPad/MemberNodeCommandHandler.cs \
+Gui/Pads/ClassPad/MethodNodeBuilder.cs \
+Gui/Pads/ClassPad/NamespaceData.cs \
+Gui/Pads/ClassPad/NamespaceNodeBuilder.cs \
+Gui/Pads/ClassPad/ProjectNodeBuilder.cs \
+Gui/Pads/ClassPad/PropertyNodeBuilder.cs \
 Gui/Pads/HelpBrowser/MonodocTreePad.cs \
 Gui/Pads/HelpBrowser/HelpViewer.cs \
+Gui/Pads/ProjectPad/CombineNodeBuilder.cs \
+Gui/Pads/ProjectPad/FolderNodeBuilder.cs \
+Gui/Pads/ProjectPad/ProjectFileNodeBuilder.cs \
+Gui/Pads/ProjectPad/ProjectFolder.cs \
+Gui/Pads/ProjectPad/ProjectFolderNodeBuilder.cs \
+Gui/Pads/ProjectPad/ProjectNodeBuilder.cs \
+Gui/Pads/ProjectPad/ProjectReferenceFolderNodeBuilder.cs \
+Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs \
+Gui/Pads/ProjectPad/ResourceFolder.cs \
+Gui/Pads/ProjectPad/ResourceFolderNodeBuilder.cs \
+Gui/Pads/SolutionPad/DragOperation.cs \
+Gui/Pads/SolutionPad/ITreeBuilder.cs \
+Gui/Pads/SolutionPad/ITreeBuilderContext.cs \
+Gui/Pads/SolutionPad/ITreeNavigator.cs \
+Gui/Pads/SolutionPad/ITreeOptions.cs \
+Gui/Pads/SolutionPad/NodeAttributes.cs \
+Gui/Pads/SolutionPad/NodeBuilder.cs \
+Gui/Pads/SolutionPad/NodeBuilderExtension.cs \
+Gui/Pads/SolutionPad/NodeCommandHandler.cs \
+Gui/Pads/SolutionPad/SolutionPad.cs \
+Gui/Pads/SolutionPad/TreePadOption.cs \
+Gui/Pads/SolutionPad/TreeViewPad.cs \
+Gui/Pads/SolutionPad/TypeNodeBuilder.cs \
 Gui/Pads/DefaultMonitorPad.cs \
 Gui/AbstractPadContent.cs \
 Gui/ISecondaryViewContent.cs \
@@ -254,8 +289,14 @@
 Internal/Codons/MenuItems/AbstractMenuCommand.cs \
 Internal/Codons/MenuItems/ICheckableMenuCommand.cs \
 Internal/Codons/MenuItems/MenuItemCodon.cs \
+Internal/Codons/Pads/NodeBuilderCodon.cs \
+Internal/Codons/Pads/PadCodon.cs \
+Internal/Codons/Pads/PadOptionCodon.cs \
+Internal/Codons/Pads/SolutionPadCodon.cs \
 Internal/Codons/Templates/FileTemplateCodon.cs \
 Internal/Codons/Templates/ProjectTemplateCodon.cs \
+Internal/Codons/ContextPadCodon.cs \
+Internal/Codons/WorkbenchContextCodon.cs \
 Internal/DataStructures/PriorityQueue.cs \
 Internal/Parser/IRegion.cs \
 Internal/Parser/ICompilationUnitBase.cs \

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml	2005-03-14 23:32:08 UTC (rev 2346)
@@ -403,27 +403,60 @@
 		            extensions = &quot;*.*&quot;/&gt;
 	&lt;/Extension&gt;
 	
-	&lt;Extension path = &quot;/SharpDevelop/Workbench/Views&quot;&gt;
-		&lt;Class id    = &quot;ProjectScout&quot; 
-		       class = &quot;MonoDevelop.Gui.Pads.ProjectBrowser.ProjectBrowserView&quot;/&gt;
-		&lt;Class id    = &quot;ClassScout&quot;
-		       class = &quot;MonoDevelop.Gui.Pads.ClassScout&quot;/&gt;
-		&lt;Class id    = &quot;FileScout&quot; 
-		       class = &quot;MonoDevelop.Gui.Pads.FileScout&quot;/&gt;
-		&lt;Class id    = &quot;OpenTaskView&quot; 
-		       class = &quot;MonoDevelop.Gui.Pads.OpenTaskView&quot;/&gt;
-		&lt;Class id    = &quot;HelpBrowser&quot;
-		       class = &quot;MonoDevelop.Gui.Pads.HelpTree&quot;/&gt;
+	&lt;Extension path = &quot;/SharpDevelop/Workbench/Pads&quot;&gt;
+		&lt;Pad id = &quot;MonoDevelop.Gui.Pads.FileScout&quot; class = &quot;MonoDevelop.Gui.Pads.FileScout&quot;/&gt;
+		&lt;Pad id = &quot;MonoDevelop.Gui.Pads.OpenTaskView&quot; class = &quot;MonoDevelop.Gui.Pads.OpenTaskView&quot;/&gt;
+		&lt;Pad id = &quot;MonoDevelop.Gui.Pads.HelpTree&quot; class = &quot;MonoDevelop.Gui.Pads.HelpTree&quot;/&gt;
+
+		&lt;SolutionPad id = &quot;MonoDevelop.Gui.Pads.ProjectPad&quot; defaultPlacement = &quot;Left&quot; _label = &quot;Solution&quot; icon = &quot;Icons.16x16.CombineIcon&quot;&gt;
+			&lt;PadOption id = &quot;ShowAllFiles&quot; _label = &quot;Show All Files&quot; defaultValue = &quot;False&quot; /&gt;
+			&lt;NodeBuilder id = &quot;Combine&quot; class = &quot;MonoDevelop.Gui.Pads.ProjectPad.CombineNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Project&quot; class = &quot;MonoDevelop.Gui.Pads.ProjectPad.ProjectNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;ProjectReferenceFolder&quot; class = &quot;MonoDevelop.Gui.Pads.ProjectPad.ProjectReferenceFolderNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;ProjectReference&quot; class = &quot;MonoDevelop.Gui.Pads.ProjectPad.ProjectReferenceNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;ProjectFile&quot; class = &quot;MonoDevelop.Gui.Pads.ProjectPad.ProjectFileNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Folder&quot; class = &quot;MonoDevelop.Gui.Pads.ProjectPad.ProjectFolderNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;ResourceFolder&quot; class = &quot;MonoDevelop.Gui.Pads.ProjectPad.ResourceFolderNodeBuilder&quot;/&gt;
+		&lt;/SolutionPad&gt;
+
+		&lt;SolutionPad id = &quot;MonoDevelop.Gui.Pads.ClassPad&quot; defaultPlacement = &quot;Left&quot; _label = &quot;Classes&quot; icon = &quot;Icons.16x16.Class&quot;&gt;
+			&lt;PadOption id = &quot;NestedNamespaces&quot; _label = &quot;Nested namespaces&quot; defaultValue = &quot;True&quot; /&gt;
+			&lt;PadOption id = &quot;ShowProjects&quot; _label = &quot;Show project structure&quot; defaultValue = &quot;True&quot; /&gt;
+			&lt;PadOption id = &quot;GroupByAccess&quot; _label = &quot;Group members by access&quot; defaultValue = &quot;False&quot; /&gt;
+			&lt;PadOption id = &quot;GroupByType&quot; _label = &quot;Group members by member type&quot; defaultValue = &quot;True&quot; /&gt;
+			&lt;NodeBuilder id = &quot;Combine&quot; class = &quot;MonoDevelop.Gui.Pads.ClassPad.CombineNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Project&quot; class = &quot;MonoDevelop.Gui.Pads.ClassPad.ProjectNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Namespace&quot; class = &quot;MonoDevelop.Gui.Pads.ClassPad.NamespaceNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Class&quot; class = &quot;MonoDevelop.Gui.Pads.ClassPad.ClassNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Event&quot; class = &quot;MonoDevelop.Gui.Pads.ClassPad.EventNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Field&quot; class = &quot;MonoDevelop.Gui.Pads.ClassPad.FieldNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Method&quot; class = &quot;MonoDevelop.Gui.Pads.ClassPad.MethodNodeBuilder&quot;/&gt;
+			&lt;NodeBuilder id = &quot;Property&quot; class = &quot;MonoDevelop.Gui.Pads.ClassPad.PropertyNodeBuilder&quot;/&gt;
+		&lt;/SolutionPad&gt;
+
 &lt;!--			   
-		&lt;Class id    = &quot;SideBar&quot; 
-		       class = &quot;MonoDevelop.Gui.Pads.SideBarView&quot;/&gt;
-		&lt;Class id    = &quot;PropertyPad&quot; 
-		       class = &quot;MonoDevelop.Gui.Pads.PropertyPad&quot;/&gt;
-		&lt;Class id    = &quot;TerminalPad&quot; 
-		       class = &quot;MonoDevelop.Gui.Pads.TerminalPad&quot;/&gt;
+		&lt;Pad id = &quot;SideBar&quot; class = &quot;MonoDevelop.Gui.Pads.SideBarView&quot;/&gt;
+		&lt;Pad id = &quot;PropertyPad&quot; class = &quot;MonoDevelop.Gui.Pads.PropertyPad&quot;/&gt;
+		&lt;Pad id = &quot;TerminalPad&quot; class = &quot;MonoDevelop.Gui.Pads.TerminalPad&quot;/&gt;
 --&gt;			 
 	&lt;/Extension&gt;
 	
+	&lt;Extension path = &quot;/SharpDevelop/Workbench/Contexts&quot;&gt;
+		&lt;WorkbenchContext id = &quot;Edit&quot;&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.ProjectPad&quot; /&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.ClassPad&quot; /&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.FileScout&quot; /&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.HelpTree&quot; /&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.OpenTaskView&quot;/&gt;
+		&lt;/WorkbenchContext&gt;
+		&lt;WorkbenchContext id = &quot;Debug&quot;&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.ProjectPad&quot;/&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.ClassPad&quot; defaultVisible = &quot;False&quot;/&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.FileScout&quot; defaultVisible = &quot;False&quot;/&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.HelpTree&quot; defaultVisible = &quot;False&quot;/&gt;
+			&lt;ContextPad id = &quot;MonoDevelop.Gui.Pads.OpenTaskView&quot;/&gt;
+		&lt;/WorkbenchContext&gt;
+	&lt;/Extension&gt;
 	
 	&lt;Extension path = &quot;/SharpDevelop/Dialogs/OptionsDialog&quot;&gt;
 		&lt;DialogPanel id    = &quot;UIOptions&quot;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/IconService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/IconService.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/IconService.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -217,5 +217,15 @@
 			
 			return GetWithModifiers (mod, Stock.Class, Stock.ProtectedClass, Stock.InternalClass, Stock.PrivateClass);
 		}
+		
+		public Gdk.Pixbuf MakeTransparent (Gdk.Pixbuf icon, double opacity)
+		{
+			// If somebody knows a better way of doing this, please redo.
+			Gdk.Pixbuf gicon = icon.Copy ();
+			gicon.Fill (0);
+			gicon = gicon.AddAlpha (true,0,0,0);
+			icon.Composite (gicon, 0, 0, icon.Width, icon.Height, 0, 0, 1, 1, Gdk.InterpType.Bilinear, (int)(256 * opacity));
+			return gicon;
+		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/CodeCompletionDatabase.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/CodeCompletionDatabase.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/CodeCompletionDatabase.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -624,6 +624,20 @@
 			get { return references; }
 		}
 		
+		public IClass[] GetFileContents (string fileName)
+		{
+			FileEntry fe = GetFile (fileName);
+			if (fe == null) return new IClass [0];
+
+			ArrayList classes = new ArrayList ();
+			ClassEntry ce = fe.FirstClass;
+			while (ce != null) {
+				classes.Add (GetClass (ce));
+				ce = ce.NextInFile;
+			}
+			return (IClass[]) classes.ToArray (typeof(IClass));
+		}
+		
 		IClass CopyClass (IClass cls)
 		{
 			MemoryStream ms = new MemoryStream ();

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -1062,6 +1062,12 @@
 			return new ClassInheritanceEnumerator (this, project, cls);
 		}
 		
+		public IClass[] GetFileContents (Project project, string fileName)
+		{
+			CodeCompletionDatabase db = (project != null) ? GetProjectDatabase (project) : GetActiveFileDatabase ();
+			return db.GetFileContents (fileName);
+		}
+		
 #endregion
 		
 		public IParseInformation ParseFile(string fileName)

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/IParserService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/IParserService.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/IParserService.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -67,6 +67,8 @@
 		
 		IEnumerable GetClassInheritanceTree (Project project, IClass cls);
 		
+		IClass[] GetFileContents (Project project, string fileName);
+		
 		////////////////////////////////////////////
 
 		/// &lt;summary&gt;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs	2005-03-14 23:32:08 UTC (rev 2346)
@@ -266,12 +266,13 @@
 				openCombine.FileChangedInProject += new ProjectFileEventHandler (NotifyFileChangedInProject);
 				openCombine.ReferenceAddedToProject += new ProjectReferenceEventHandler (NotifyReferenceAddedToProject);
 				openCombine.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (NotifyReferenceRemovedFromProject);
-		
+				
 				SearchForNewFiles ();
 		
 				OnCombineOpened(new CombineEventArgs(openCombine));
+
+				Runtime.DispatchService.GuiDispatch (new StatefulMessageHandler (RestoreCombinePreferences), CurrentOpenCombine);
 				
-				RestoreCombinePreferences (CurrentOpenCombine);
 				SaveCombine ();
 				monitor.ReportSuccess (GettextCatalog.GetString (&quot;Combine loaded.&quot;));
 			} catch (Exception ex) {
@@ -672,8 +673,9 @@
 			return tmp;
 		}
 		
-		void RestoreCombinePreferences (Combine combine)
+		void RestoreCombinePreferences (object data)
 		{
+			Combine combine = (Combine) data;
 			string combinefilename = combine.FileName;
 			string directory = Runtime.Properties.ConfigDirectory + &quot;CombinePreferences&quot;;
 
@@ -704,7 +706,7 @@
 				if (root[&quot;Views&quot;] != null) {
 					foreach (XmlElement el in root[&quot;Views&quot;].ChildNodes) {
 						foreach (IPadContent view in WorkbenchSingleton.Workbench.PadContentCollection) {
-							if (el.Attributes[&quot;class&quot;].InnerText == view.GetType().ToString() &amp;&amp; view is IMementoCapable &amp;&amp; el.ChildNodes.Count &gt; 0) {
+							if (el.GetAttribute (&quot;Id&quot;) == view.Id &amp;&amp; view is IMementoCapable &amp;&amp; el.ChildNodes.Count &gt; 0) {
 								IMementoCapable m = (IMementoCapable)view; 
 								m.SetMemento((IXmlConvertable)m.CreateMemento().FromXmlElement((XmlElement)el.ChildNodes[0]));
 							}
@@ -763,13 +765,8 @@
 			foreach (IPadContent view in WorkbenchSingleton.Workbench.PadContentCollection) {
 				if (view is IMementoCapable) {
 					XmlElement el = doc.CreateElement(&quot;ViewMemento&quot;);
-					
-					XmlAttribute attr = doc.CreateAttribute(&quot;class&quot;);
-					attr.InnerText = view.GetType().ToString();
-					el.Attributes.Append(attr);
-					
+					el.SetAttribute (&quot;Id&quot;, view.Id);
 					el.AppendChild(((IMementoCapable)view).CreateMemento().ToXmlElement(doc));
-					
 					viewsnode.AppendChild(el);
 				}
 			}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/options/DefaultEditingLayout.xml
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/options/DefaultEditingLayout.xml	2005-03-14 01:50:54 UTC (rev 2345)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/options/DefaultEditingLayout.xml	2005-03-14 23:32:08 UTC (rev 2346)
@@ -5,8 +5,8 @@
       &lt;paned orientation=&quot;horizontal&quot; locked=&quot;no&quot; position=&quot;226&quot;&gt;
         &lt;notebook orientation=&quot;vertical&quot; locked=&quot;no&quot; page=&quot;3&quot;&gt;
           &lt;item name=&quot;MonoDevelop.Gui.Pads.FileScout&quot; orientation=&quot;vertical&quot; locked=&quot;no&quot;/&gt;
-          &lt;item name=&quot;MonoDevelop.Gui.Pads.ClassScout&quot; orientation=&quot;vertical&quot; locked=&quot;no&quot;/&gt;
-          &lt;item name=&quot;MonoDevelop.Gui.Pads.ProjectBrowser.ProjectBrowserView&quot; orientation=&quot;vertical&quot; locked=&quot;no&quot;/&gt;
+          &lt;item name=&quot;MonoDevelop.Gui.Pads.ClassPad&quot; orientation=&quot;vertical&quot; locked=&quot;no&quot;/&gt;
+          &lt;item name=&quot;MonoDevelop.Gui.Pads.ProjectPad&quot; orientation=&quot;vertical&quot; locked=&quot;no&quot;/&gt;
           &lt;item name=&quot;MonoDevelop.Gui.Pads.HelpTree&quot; orientation=&quot;vertical&quot; locked=&quot;no&quot;/&gt;
         &lt;/notebook&gt;
         &lt;paned orientation=&quot;vertical&quot; locked=&quot;no&quot; position=&quot;319&quot;&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001947.html">[Monodevelop-patches-list] r2345 - trunk/MonoDevelop/Core/src/MonoDevelop.Dock
</A></li>
	<LI>Next message: <A HREF="001949.html">[Monodevelop-patches-list] r2347 - in trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor: . Gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1948">[ date ]</a>
              <a href="thread.html#1948">[ thread ]</a>
              <a href="subject.html#1948">[ subject ]</a>
              <a href="author.html#1948">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
