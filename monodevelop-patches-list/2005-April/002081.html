<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2480 - in trunk/MonoDevelop: . Extras Extras/BooBinding Extras/BooBinding/Gui Extras/BooBinding/Gui/OptionPanels Extras/BooBinding/Parser Extras/BooBinding/Project Extras/BooBinding/Properties Extras/BooBinding/templates build/data/resources/icons
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2480%20-%20in%20trunk/MonoDevelop%3A%20.%20Extras%20Extras/BooBinding%20Extras/BooBinding/Gui%20Extras/BooBinding/Gui/OptionPanels%20Extras/BooBinding/Parser%20Extras/BooBinding/Project%20Extras/BooBinding/Properties%20Extras/BooBinding/templates%20build/data/resources/icons&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002080.html">
   <LINK REL="Next"  HREF="002082.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2480 - in trunk/MonoDevelop: . Extras Extras/BooBinding Extras/BooBinding/Gui Extras/BooBinding/Gui/OptionPanels Extras/BooBinding/Parser Extras/BooBinding/Project Extras/BooBinding/Properties Extras/BooBinding/templates build/data/resources/icons</H1>
    <B>Peter Johanson &lt;latexer@gentoo.org&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2480%20-%20in%20trunk/MonoDevelop%3A%20.%20Extras%20Extras/BooBinding%20Extras/BooBinding/Gui%20Extras/BooBinding/Gui/OptionPanels%20Extras/BooBinding/Parser%20Extras/BooBinding/Project%20Extras/BooBinding/Properties%20Extras/BooBinding/templates%20build/data/resources/icons&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2480 - in trunk/MonoDevelop: . Extras Extras/BooBinding Extras/BooBinding/Gui Extras/BooBinding/Gui/OptionPanels Extras/BooBinding/Parser Extras/BooBinding/Project Extras/BooBinding/Properties Extras/BooBinding/templates build/data/resources/icons">pjohanson at mono-cvs.ximian.com
       </A><BR>
    <I>Mon Apr 25 21:27:11 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002080.html">[Monodevelop-patches-list] r2479 - trunk/MonoDevelop/Extras/MonoDeveloperExtensions
</A></li>
        <LI>Next message: <A HREF="002082.html">[Monodevelop-patches-list] r2482 - trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2081">[ date ]</a>
              <a href="thread.html#2081">[ thread ]</a>
              <a href="subject.html#2081">[ subject ]</a>
              <a href="author.html#2081">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pjohanson
Date: 2005-04-25 21:27:10 -0400 (Mon, 25 Apr 2005)
New Revision: 2480

Added:
   trunk/MonoDevelop/Extras/BooBinding/
   trunk/MonoDevelop/Extras/BooBinding/BooAmbience.boo
   trunk/MonoDevelop/Extras/BooBinding/BooBinding.addin.xml
   trunk/MonoDevelop/Extras/BooBinding/BooBindingCompilerServices.boo
   trunk/MonoDevelop/Extras/BooBinding/BooCompiler.boo
   trunk/MonoDevelop/Extras/BooBinding/BooLanguageBinding.boo
   trunk/MonoDevelop/Extras/BooBinding/BooShellPadContent.boo
   trunk/MonoDevelop/Extras/BooBinding/ChangeLog
   trunk/MonoDevelop/Extras/BooBinding/Gui/
   trunk/MonoDevelop/Extras/BooBinding/Gui/BooShellModel.boo
   trunk/MonoDevelop/Extras/BooBinding/Gui/IShellModel.boo
   trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/
   trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/CodeCompilationPanel.boo
   trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/GeneralBooShellPanel.boo
   trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/GeneralShellPanel.boo
   trunk/MonoDevelop/Extras/BooBinding/Gui/ShellTextView.boo
   trunk/MonoDevelop/Extras/BooBinding/Makefile.am
   trunk/MonoDevelop/Extras/BooBinding/Parser/
   trunk/MonoDevelop/Extras/BooBinding/Parser/BooParser.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/ExpressionFinder.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/ExpressionTypeVisitor.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/Resolver.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/ReturnType.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/Tree.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/TypeMembers.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/VariableLookupVisitor.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/Visitor.boo
   trunk/MonoDevelop/Extras/BooBinding/Project/
   trunk/MonoDevelop/Extras/BooBinding/Project/BooCompilerParameters.boo
   trunk/MonoDevelop/Extras/BooBinding/Properties/
   trunk/MonoDevelop/Extras/BooBinding/Properties/BooShellProperties.boo
   trunk/MonoDevelop/Extras/BooBinding/Properties/ShellProperties.boo
   trunk/MonoDevelop/Extras/BooBinding/templates/
   trunk/MonoDevelop/Extras/BooBinding/templates/BooGtkSharpProject.xpt.xml
   trunk/MonoDevelop/Extras/BooBinding/templates/BooGtkSharpWindow.xft.xml
   trunk/MonoDevelop/Extras/BooBinding/templates/EmptyBooFile.xft.xml
   trunk/MonoDevelop/Extras/BooBinding/templates/EmptyBooProject.xpt.xml
   trunk/MonoDevelop/build/data/resources/icons/Boo.File.EmptyFile
   trunk/MonoDevelop/build/data/resources/icons/Boo.File.Form
   trunk/MonoDevelop/build/data/resources/icons/Boo.FileIcon
   trunk/MonoDevelop/build/data/resources/icons/Boo.Project.EmptyProject
   trunk/MonoDevelop/build/data/resources/icons/Boo.Project.Form
   trunk/MonoDevelop/build/data/resources/icons/Boo.ProjectIcon
   trunk/MonoDevelop/build/data/resources/icons/BooBinding.Base
Modified:
   trunk/MonoDevelop/ChangeLog
   trunk/MonoDevelop/Extras/Makefile.am
   trunk/MonoDevelop/build/data/resources/icons/Makefile.am
   trunk/MonoDevelop/configure.in
Log:
Say hello to a Boo addin.


Modified: trunk/MonoDevelop/ChangeLog
===================================================================
--- trunk/MonoDevelop/ChangeLog	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/ChangeLog	2005-04-26 01:27:10 UTC (rev 2480)
@@ -1,5 +1,9 @@
 2005-04-18  Peter Johanson &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>&gt;
 
+	* configure.in: Add Boo addin logic
+
+2005-04-18  Peter Johanson &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>&gt;
+
 	* configure.in: Add monodevelop.pc generation
 	* Makefile.am: Add monodevelop.pc installation/cleanup
 	* monodevelop.pc.in: New monodevelop.pc file for external addins to

Added: trunk/MonoDevelop/Extras/BooBinding/BooAmbience.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/BooAmbience.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/BooAmbience.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,478 @@
+#region license
+// Copyright (c) 2004, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding
+
+import System
+import System.Collections
+import System.Text
+import MonoDevelop.Internal.Parser
+import MonoDevelop.Services
+import MonoDevelop.Core.Properties
+
+class BooAmbience(AbstractAmbience):
+	[Getter(TypeConversionTable)]
+	static _typeConversionTable = {
+		'System.Void'    : 'void',
+		'System.Object'  : 'object',
+		'System.Boolean' : 'bool',
+		'System.Byte'    : 'byte',
+		'System.SByte'   : 'sbyte',
+		//'System.Char'   : 'char',
+		//'System.Enum'   : 'enum',
+		'System.Int16'  : 'short',
+		'System.Int32'  : 'int',
+		'System.Int64'  : 'long',
+		'System.UInt16' : 'ushort',
+		'System.UInt32' : 'uint',
+		'System.UInt64' : 'ulong',
+		'System.Single' : 'single',
+		'System.Double' : 'double',
+		'System.Decimal' : 'decimal',
+		'System.String' : 'string',
+		'System.DateTime' : 'date',
+		'System.TimeSpan' : 'timespan',
+		'System.Type'  : 'type',
+		'System.Array' : 'array',
+		'System.Text.RegularExpressions.Regex' : 'regex'
+		}
+	
+	static _reverseTypeConversionTable as Hashtable
+	
+	static ReverseTypeConversionTable:
+		get:
+			if _reverseTypeConversionTable == null:
+				_reverseTypeConversionTable = Hashtable()
+				for e as DictionaryEntry in _typeConversionTable:
+					_reverseTypeConversionTable.Add(e.Value, e.Key)
+			return _reverseTypeConversionTable
+	
+	
+	private def ModifierIsSet(modifier as ModifierEnum, query as ModifierEnum) as bool:
+		return (modifier &amp; query) == query
+	
+	override def Convert(modifier as ModifierEnum) as string:
+		if ShowAccessibility:
+			if ModifierIsSet(modifier, ModifierEnum.Public):
+				return 'public '
+			elif ModifierIsSet(modifier, ModifierEnum.Private):
+				return 'private '
+			elif ModifierIsSet(modifier, ModifierEnum.ProtectedAndInternal):
+				return 'protected internal '
+			elif ModifierIsSet(modifier, ModifierEnum.ProtectedOrInternal):
+				return 'internal protected '
+			elif ModifierIsSet(modifier, ModifierEnum.Internal):
+				return 'internal '
+			elif ModifierIsSet(modifier, ModifierEnum.Protected):
+				return 'protected '
+		return ''
+	
+	private def GetModifier(decoration as IDecoration) as string:
+		ret as string = ''
+		if IncludeHTMLMarkup:
+			ret += '&lt;i&gt;'
+		
+		if decoration.IsStatic:
+			ret += 'static '
+		elif decoration.IsFinal:
+			ret += 'final '
+		elif decoration.IsVirtual:
+			ret += 'virtual '
+		elif decoration.IsOverride:
+			ret += 'override '
+		elif decoration.IsNew:
+			ret += 'new '
+		
+		if IncludeHTMLMarkup:
+			ret += '&lt;/i&gt;'
+		
+		return ret
+	
+	override def Convert(c as IClass) as string:
+		builder as StringBuilder = StringBuilder()
+		builder.Append(Convert(c.Modifiers))
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;i&gt;')
+		
+		cType = c.ClassType
+		
+		if ShowModifiers:
+			if c.IsSealed:
+				if cType == ClassType.Delegate or cType == ClassType.Enum:
+					pass
+				else:
+					builder.Append('final ')
+			elif c.IsAbstract and cType != ClassType.Interface:
+				builder.Append('abstract ')
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/i&gt;')
+		
+		if ShowModifiers:
+			if cType == ClassType.Delegate:
+				builder.Append('callable ')
+			elif cType == ClassType.Class:
+				builder.Append('class ')
+			elif cType == ClassType.Struct:
+				builder.Append('struct ')
+			elif cType == ClassType.Interface:
+				builder.Append('interface ')
+			elif cType == ClassType.Enum:
+				builder.Append('enum ')
+		
+		if cType == ClassType.Delegate and c.Methods.Count &gt; 0:
+			for m as IMethod in c.Methods:
+				if m.Name == 'Invoke':
+					builder.Append(Convert(m.ReturnType))
+					builder.Append(' ')
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;b&gt;')
+		
+		if UseFullyQualifiedMemberNames:
+			builder.Append(c.FullyQualifiedName)
+		else:
+			builder.Append(c.Name)
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/b&gt;')
+		
+		if c.ClassType == ClassType.Delegate:
+			builder.Append(' (')
+			if IncludeHTMLMarkup:
+				builder.Append('&lt;br&gt;')
+			
+			for m as IMethod in c.Methods:
+				if m.Name == 'Invoke':
+					for i in range(m.Parameters.Count):
+						if IncludeHTMLMarkup:
+							builder.Append('&amp;nbsp;&amp;nbsp;&amp;nbsp;')
+						
+						builder.Append(Convert(m.Parameters[i]))
+						if i + 1 &lt; m.Parameters.Count:
+							builder.Append(', ')
+						
+						if IncludeHTMLMarkup:
+							builder.Append('&lt;br&gt;')
+			
+			builder.Append(Char.Parse(')'))
+		elif ShowInheritanceList:
+			if c.BaseTypes.Count &gt; 0:
+				builder.Append('(')
+				for i in range(c.BaseTypes.Count):
+					builder.Append(c.BaseTypes[i])
+					if i + 1 &lt; c.BaseTypes.Count:
+						builder.Append(', ')
+				builder.Append(')')
+		
+		if IncludeBodies:
+			builder.Append(':\n')
+		
+		return builder.ToString()
+	
+	override def ConvertEnd(c as IClass) as string:
+		return ''
+	
+	override def Convert(field as IField) as string:
+		builder as StringBuilder = StringBuilder()
+		builder.Append(Convert(field.Modifiers))
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;i&gt;')
+		
+		if ShowModifiers:
+			if field.IsStatic and field.IsLiteral:
+				builder.Append('const ')
+			elif field.IsStatic:
+				builder.Append('static ')
+			
+			if field.IsReadonly:
+				builder.Append('readonly ')
+			
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/i&gt;')
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;b&gt;')
+		
+		if UseFullyQualifiedMemberNames:
+			builder.Append(field.FullyQualifiedName)
+		else:
+			builder.Append(field.Name)
+		
+		if field.ReturnType != null:
+			builder.Append(' as ')
+			builder.Append(Convert(field.ReturnType))
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/b&gt;')
+		
+		return builder.ToString()
+	
+	override def Convert(property as IProperty) as string:
+		builder as StringBuilder = StringBuilder()
+		builder.Append(Convert(property.Modifiers))
+		if ShowModifiers:
+			builder.Append(GetModifier(property))
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;b&gt;')
+		
+		if UseFullyQualifiedMemberNames:
+			builder.Append(property.FullyQualifiedName)
+		else:
+			builder.Append(property.Name)
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/b&gt;')
+		
+		if property.Parameters.Count &gt; 0:
+			builder.Append('(')
+			if IncludeHTMLMarkup:
+				builder.Append('&lt;br&gt;')
+			
+			for i in range(property.Parameters.Count):
+				if IncludeHTMLMarkup:
+					builder.Append('&amp;nbsp;&amp;nbsp;&amp;nbsp;')
+				
+				builder.Append(Convert(property.Parameters[i]))
+				if i + 1 &lt; property.Parameters.Count:
+					builder.Append(', ')
+				
+				if IncludeHTMLMarkup:
+					builder.Append('&lt;br&gt;')
+			
+			builder.Append(')')
+		
+		if property.ReturnType != null:
+			builder.Append(' as ')
+			builder.Append(Convert(property.ReturnType))
+		
+		if IncludeBodies:
+			builder.Append(': ')
+			if property.CanGet:
+				builder.Append('get ')
+			
+			if property.CanSet:
+				builder.Append('set ')
+		
+		return builder.ToString()
+	
+	override def Convert(e as IEvent) as string:
+		builder as StringBuilder = StringBuilder()
+		builder.Append(Convert(e.Modifiers))
+		if ShowModifiers:
+			builder.Append(GetModifier(e))
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;b&gt;')
+		
+		if UseFullyQualifiedMemberNames:
+			builder.Append(e.FullyQualifiedName)
+		else:
+			builder.Append(e.Name)
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/b&gt;')
+		
+		if e.ReturnType != null:
+			builder.Append(' as ')
+			builder.Append(Convert(e.ReturnType))
+		
+		return builder.ToString()
+	
+	override def Convert(m as IIndexer) as string:
+		builder as StringBuilder = StringBuilder()
+		builder.Append(Convert(m.Modifiers))
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;i&gt;')
+		
+		if ShowModifiers and m.IsStatic:
+			builder.Append('static ')
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/i&gt;')
+		
+		if m.ReturnType != null:
+			builder.Append(Convert(m.ReturnType))
+			builder.Append(' ')
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;b&gt;')
+		
+		if UseFullyQualifiedMemberNames:
+			builder.Append(m.FullyQualifiedName)
+		else:
+			builder.Append(m.Name)
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/b&gt;')
+		
+		builder.Append('Indexer(')
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;br&gt;')
+		
+		for i in range(m.Parameters.Count):
+			if IncludeHTMLMarkup:
+				builder.Append('&amp;nbsp;&amp;nbsp;&amp;nbsp;')
+			
+			builder.Append(Convert(m.Parameters[i]))
+			if i + 1 &lt; m.Parameters.Count:
+				builder.Append(', ')
+			
+			if IncludeHTMLMarkup:
+				builder.Append('&lt;br&gt;')
+		
+		builder.Append(')')
+		
+		return builder.ToString()
+	
+	override def Convert(m as IMethod) as string:
+		builder as StringBuilder = StringBuilder()
+		builder.Append(Convert(m.Modifiers))
+		if ShowModifiers:
+			builder.Append(GetModifier(m))
+		
+		//builder.Append('def ') if ShowReturnType
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;b&gt;')
+		
+		if m.IsConstructor:
+			builder.Append('constructor')
+		else:
+			if UseFullyQualifiedMemberNames:
+				builder.Append(m.FullyQualifiedName)
+			else:
+				builder.Append(m.Name)
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/b&gt;')
+		
+		builder.Append('(')
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;br&gt;')
+		
+		for i in range(m.Parameters.Count):
+			if IncludeHTMLMarkup:
+				builder.Append('&amp;nbsp;&amp;nbsp;&amp;nbsp;')
+			
+			builder.Append(Convert(m.Parameters[i]))
+			if i + 1 &lt; m.Parameters.Count:
+				builder.Append(', ')
+			
+			if IncludeHTMLMarkup:
+				builder.Append('&lt;br&gt;')
+		
+		builder.Append(')')
+		
+		//if m.ReturnType != null and ShowReturnType and not m.IsConstructor:
+		if m.ReturnType != null and not m.IsConstructor:
+			builder.Append(' as ')
+			builder.Append(Convert(m.ReturnType))
+		
+		if IncludeBodies:
+			if m.DeclaringType != null:
+				if m.DeclaringType.ClassType != ClassType.Interface:
+					builder.Append(': ')
+			else:
+				builder.Append(': ')
+			
+		
+		return builder.ToString()
+	
+	override def ConvertEnd(m as IMethod) as string:
+		return ''
+	
+	override def Convert(returnType as IReturnType) as string:
+		if returnType == null:
+			return ''
+		
+		builder as StringBuilder = StringBuilder()
+		/*
+		linkSet as bool = false
+		if UseLinkArrayList:
+			ret as SharpAssemblyReturnType = returnType as SharpAssemblyReturnType
+			if ret != null:
+				if ret.UnderlyingClass != null:
+					builder.Append('&lt;a href=\'<A HREF="as://'">as://'</A> + linkArrayList.Add(ret.UnderlyingClass) + '\'&gt;')
+					linkSet = true
+		*/
+		
+		for i in range(returnType.ArrayCount):
+			builder.Append('(')
+		
+		if returnType.FullyQualifiedName != null and _typeConversionTable[returnType.FullyQualifiedName] != null:
+			builder.Append(_typeConversionTable[returnType.FullyQualifiedName])
+		else:
+			if UseFullyQualifiedNames:
+				builder.Append(returnType.FullyQualifiedName)
+			else:
+				builder.Append(returnType.Name)
+			
+		
+		//if linkSet:
+		//	builder.Append('&lt;/a&gt;')
+		
+		if returnType.PointerNestingLevel &gt; 0:
+			// Sometimes there are negative pointer nesting levels
+			// (especially in exception constructors in the BCL
+			for i in range(returnType.PointerNestingLevel):
+				builder.Append('*')
+		
+		for i in range(returnType.ArrayCount):
+			if returnType.ArrayDimensions[i] &gt; 1:
+				builder.Append(',')
+				builder.Append(returnType.ArrayDimensions[i])
+			builder.Append(')')
+		
+		return builder.ToString()
+	
+	override def Convert(param as IParameter) as string:
+		builder as StringBuilder = StringBuilder()
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;i&gt;')
+		
+		if param.IsRef:
+			builder.Append('ref ')
+		elif param.IsOut:
+			builder.Append('out ')
+		elif param.IsParams:
+			builder.Append('params ')
+		
+		if IncludeHTMLMarkup:
+			builder.Append('&lt;/i&gt;')
+		
+		if ShowParameterNames:
+			builder.Append(param.Name)
+			builder.Append(' as ')
+		builder.Append(Convert(param.ReturnType))
+		
+		return builder.ToString()
+	
+	override def WrapAttribute(attribute as string) as string:
+		return '[' + attribute + ']'
+	
+	override def WrapComment(comment as string) as string:
+		return '// ' + comment
+	
+	override def GetIntrinsicTypeName(dotNetTypeName as string) as string:
+		if _typeConversionTable[dotNetTypeName] != null:
+			return _typeConversionTable[dotNetTypeName]
+		return dotNetTypeName

Added: trunk/MonoDevelop/Extras/BooBinding/BooBinding.addin.xml
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/BooBinding.addin.xml	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/BooBinding.addin.xml	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,89 @@
+&lt;AddIn name        = &quot;Boo Language Binding&quot;
+       author      = &quot;Peter Johanson&quot;
+       copyright   = &quot;GPL&quot;
+       url         = &quot;<A HREF="http://boo.codehaus.org&quot;">http://boo.codehaus.org&quot;</A>
+       description = &quot;Boo Language Binding&quot;
+       version     = &quot;0.1&quot;&gt;
+
+  &lt;Runtime&gt;
+    &lt;Import assembly = &quot;BooBinding.dll&quot;/&gt;
+  &lt;/Runtime&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/FileFilter&quot;&gt;
+    &lt;FileFilter id = &quot;Boo&quot;
+                insertbefore = &quot;AllFiles&quot;
+                name = &quot;Boo Files (*.boo)&quot;
+                extensions = &quot;*.boo&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/MonoDevelop/FileTemplates&quot;&gt;
+    &lt;FileTemplate id = &quot;EmptyBooFile&quot;
+                  location = &quot;templates/EmptyBooFile.xft.xml&quot;/&gt;
+    &lt;FileTemplate id = &quot;BooGtkSharpWindow&quot;
+                  location = &quot;templates/BooGtkSharpWindow.xft.xml&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/MonoDevelop/ProjectTemplates&quot;&gt;
+    &lt;ProjectTemplate id = &quot;EmptyBooProject&quot;
+                     location = &quot;templates/EmptyBooProject.xpt.xml&quot;/&gt;
+    &lt;ProjectTemplate id = &quot;BooGtkSharpProject&quot;
+                     location = &quot;templates/BooGtkSharpProject.xpt.xml&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/ProjectOptions/ConfigurationProperties&quot;&gt;
+    &lt;Conditional activelanguage = &quot;Boo&quot;&gt;
+      &lt;DialogPanel id = &quot;BooCodeGenerationPanel&quot;
+                   _label = &quot;Code Generation&quot;
+                   class = &quot;BooBinding.Gui.OptionPanels.CodeGenerationPanel&quot;/&gt;
+    &lt;/Conditional&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/Workspace/Icons&quot;&gt;
+    &lt;Icon id = &quot;BooPrj&quot;
+          language = &quot;Boo&quot;
+          resource = &quot;Boo.ProjectIcon&quot;/&gt;
+    &lt;Icon id = &quot;BooFile&quot;
+          extensions = &quot;.boo&quot;
+          resource = &quot;Boo.FileIcon&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/LanguageBindings&quot;&gt;
+    &lt;LanguageBinding id = &quot;Boo&quot;
+                     supportedextensions = &quot;.boo&quot;
+                     class = &quot;BooBinding.BooLanguageBinding&quot; /&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/Workspace/Parser&quot;&gt;
+	&lt;Class id    = &quot;BooParser&quot;
+	       class = &quot;BooBinding.Parser.BooParser&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/Ambiences&quot;&gt;
+	  &lt;Class id    = &quot;Boo&quot;
+		 class = &quot;BooBinding.BooAmbience&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/Views&quot;&gt;
+	&lt;Class    id    = &quot;BooShell&quot; 
+		  insertafter = &quot;TaskList&quot;
+		  class               = &quot;BooBinding.Pads.BooShellPadContent&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/Pads&quot;&gt;
+	&lt;Pad id = &quot;BooBinding.Pads.BooShellPadContent&quot; class = &quot;BooBinding.Pads.BooShellPadContent&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/Contexts/Edit&quot;&gt;
+ 	&lt;ContextPad id = &quot;BooBinding.Pads.BooShellPadContent&quot; /&gt;
+  &lt;/Extension&gt;
+  &lt;Extension path = &quot;/SharpDevelop/Dialogs/OptionsDialog&quot;&gt;
+	&lt;DialogPanel id    = &quot;BooShellOptions&quot;
+		     insertafter = &quot;ToolsOptions&quot;
+		     _label = &quot;Boo Shell&quot;&gt;
+		&lt;DialogPanel    id = &quot;General&quot;
+				_label = &quot;General&quot;
+				class = &quot;BooBinding.Gui.OptionPanels.GeneralBooShellPanel&quot; /&gt;
+	&lt;/DialogPanel&gt;
+  &lt;/Extension&gt;
+
+&lt;/AddIn&gt;

Added: trunk/MonoDevelop/Extras/BooBinding/BooBindingCompilerServices.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/BooBindingCompilerServices.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/BooBindingCompilerServices.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,179 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding
+
+import System
+import System.Diagnostics
+import System.IO
+import System.CodeDom.Compiler
+import System.Text
+
+import MonoDevelop.Gui.Components
+import MonoDevelop.Services
+import MonoDevelop.Core.Services
+import MonoDevelop.Internal.Project
+
+public class BooBindingCompilerServices:
+	public def CanCompile (fileName as string):
+		return Path.GetExtension(fileName) == &quot;.boo&quot;
+	
+	public def GetCompilerName (cp as BooCompilerParameters):
+		if (cp.Compiler == BooCompiler.Boo):
+			return &quot;boo&quot;
+
+		return &quot;booc&quot;
+	
+	def Compile (projectFiles as ProjectFileCollection, references as ProjectReferenceCollection, configuration as DotNetProjectConfiguration, monitor as IProgressMonitor) as ICompilerResult:
+		compilerparameters = cast(BooCompilerParameters, configuration.CompilationParameters)
+		if compilerparameters is null:
+			compilerparameters = BooCompilerParameters()
+		
+		// FIXME: Use outdir
+		//outdir = configuration.OutputDirectory
+		options = &quot;&quot;
+
+		compiler = GetCompilerName (compilerparameters)
+		
+		if configuration.DebugMode:
+			options += &quot; -debug &quot;
+
+		options += &quot; -o:&quot; + configuration.CompiledOutputName
+
+		if references is not null:
+			for lib as ProjectReference in references:
+				fileName = lib.GetReferencedFileName()
+				// FIXME: DO we need all these tests?
+				if lib.ReferenceType == ReferenceType.Gac:
+					options += &quot; -r:&quot; + fileName + &quot; &quot;
+				elif lib.ReferenceType == ReferenceType.Assembly:
+					options += &quot; -r:&quot; + fileName + &quot; &quot;
+				elif lib.ReferenceType == ReferenceType.Project:
+					options += &quot; -r:&quot; + fileName + &quot; &quot;
+
+		files  = &quot;&quot;
+		
+		for finfo as ProjectFile in projectFiles:
+			if finfo.Subtype != Subtype.Directory:
+				if finfo.BuildAction == BuildAction.Compile:
+					files = files + &quot; \&quot;&quot; + finfo.Name + &quot;\&quot;&quot;
+
+		
+		// FIXME: Add selection of output assembly types (library, exe, etc)
+		if configuration.CompileTarget == CompileTarget.Exe:
+			options += &quot; -t:exe &quot;
+		elif configuration.CompileTarget == CompileTarget.Library:
+			options += &quot; -t:library &quot;
+		elif configuration.CompileTarget == CompileTarget.WinExe:
+			options += &quot; -t:winexe &quot;
+
+		if compilerparameters.Culture != String.Empty:
+			options += &quot; -c:${compilerparameters.Culture} &quot;
+
+		if compilerparameters.Ducky:
+			options += &quot; -ducky &quot;
+
+		options += files
+
+		tf = TempFileCollection ()
+		output, error = DoCompilation (monitor, compiler, options, tf, configuration, compilerparameters)
+		cr = ParseOutput (tf, output, error)
+		File.Delete (output)
+		File.Delete (error)
+		return cr
+
+	private def DoCompilation (monitor as IProgressMonitor , compiler as string , args as string , tf as TempFileCollection , configuration as DotNetProjectConfiguration , compilerparameters as BooCompilerParameters):
+		output = Path.GetTempFileName ()
+		error = Path.GetTempFileName ()
+
+		try:
+			monitor.BeginTask (null, 2)
+			monitor.Log.WriteLine (&quot;Compiling Boo source code ...&quot;)
+			arguments = String.Format (&quot;-c \&quot;{0} {1} &gt; {2} 2&gt; {3}\&quot;&quot;, (compiler, args, output, error))
+			si = ProcessStartInfo (&quot;/bin/sh&quot;, arguments)
+			// print &quot;${si.FileName}, ${si.Arguments}&quot;
+			si.RedirectStandardOutput = true
+			si.RedirectStandardError = true
+			si.UseShellExecute = false
+			p = Process ()
+			p.StartInfo = si
+			p.Start ()
+			p.WaitForExit ()
+
+			monitor.Step (1)
+
+			return output, error;
+		ensure:
+			monitor.EndTask ()
+
+	
+	def ParseOutput (tf as TempFileCollection , stdout as string, stderr as string) as ICompilerResult:
+		compilerOutput = StringBuilder ()
+		cr = CompilerResults (tf)
+		
+		for s as string in ( stdout, stderr ):
+			sr = File.OpenText (s);
+			while true:
+				next = sr.ReadLine ()
+				if next is null:
+					break
+
+				error = CreateErrorFromString (next)
+
+				if error is not null:
+					cr.Errors.Add (error)
+
+			sr.Close ()
+
+		return DefaultCompilerResult (cr, compilerOutput.ToString ())
+
+	private static def CreateErrorFromString (error as string) as CompilerError:
+		//print &quot;${error}&quot;
+		// FIXME: Better checking to make sure we have an error we can parse
+
+		err_pieces = /:/.Split(error)
+
+		// FIXME: i18n of &quot;Fatal Error&quot; check
+		if err_pieces.Length == 2 and err_pieces[0] == &quot;Fatal error&quot;:
+			cerror = CompilerError()
+			cerror.ErrorText = error
+			return cerror
+
+		if (err_pieces.Length &lt; 3):
+			return null
+
+		// Uses extensive LastIndexOf to avoid problems with filenames
+		// and directories with &quot;(&quot; or &quot;)&quot; in their names
+		last_open_bracket = err_pieces[0].LastIndexOf(&quot;(&quot;)
+		last_close_bracket = err_pieces[0].LastIndexOf(&quot;)&quot;)
+
+		file = err_pieces[0].Substring(0,last_open_bracket)
+		line, column = /,/.Split (err_pieces[0].Substring (last_open_bracket + 1, last_close_bracket - last_open_bracket - 1))
+
+		cerror = CompilerError ()
+
+		// Rejoin the split error back the way it originally was
+		cerror.ErrorText = join(err_pieces[1:], &quot;:&quot;)
+		cerror.FileName = file
+		cerror.Column = Int32.Parse(column)
+		cerror.Line = Int32.Parse(line)
+		if (err_pieces[2].Trim() == &quot;WARNING&quot;):
+			cerror.IsWarning = true
+
+		return cerror

Added: trunk/MonoDevelop/Extras/BooBinding/BooCompiler.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/BooCompiler.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/BooCompiler.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,26 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding
+
+import System
+
+public enum BooCompiler:
+	Booc
+	Boo

Added: trunk/MonoDevelop/Extras/BooBinding/BooLanguageBinding.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/BooLanguageBinding.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/BooLanguageBinding.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,65 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding
+
+import System
+import System.IO
+import System.Diagnostics
+import System.Collections
+import System.Reflection
+import System.Resources
+import System.Xml
+
+import MonoDevelop.Internal.Project
+import MonoDevelop.Internal.Templates
+import MonoDevelop.Gui
+import MonoDevelop.Services
+
+public class BooLanguageBinding(ILanguageBinding):
+	internal static LanguageName = &quot;Boo&quot;
+	compilerServices = BooBindingCompilerServices ()
+	
+	public def constructor():
+		MonoDevelop.Services.Runtime.ProjectService.DataContext.IncludeType (typeof(BooCompilerParameters));
+	
+	public Language as string:
+		get:
+			return LanguageName
+	
+	public def CanCompile(fileName as string) as bool:
+		Debug.Assert(compilerServices is not null)
+		return compilerServices.CanCompile(fileName)
+	
+	public def Compile (projectFiles as ProjectFileCollection , references as ProjectReferenceCollection , configuration as DotNetProjectConfiguration , monitor as IProgressMonitor ) as ICompilerResult:
+		Debug.Assert(compilerServices is not null)
+		return compilerServices.Compile (projectFiles, references, configuration, monitor)
+	
+	public def GenerateMakefile (project as Project, parentCombine as Combine) as void:
+		// FIXME: dont abort for now
+		// throw NotImplementedException ()
+		return
+	
+	public def CreateCompilationParameters (projectOptions as XmlElement) as object:
+		parameters = BooCompilerParameters ()
+		return parameters
+	
+	public CommentTag as string:
+		get:
+			return &quot;//&quot;;

Added: trunk/MonoDevelop/Extras/BooBinding/BooShellPadContent.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/BooShellPadContent.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/BooShellPadContent.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,55 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+
+namespace BooBinding.Pads
+
+import System
+
+import MonoDevelop.Core.AddIns
+import MonoDevelop.Services
+import MonoDevelop.Core.Services
+import MonoDevelop.Gui
+import BooBinding.Gui
+
+
+public class BooShellPadContent (AbstractPadContent):
+	private static _scroller as Gtk.ScrolledWindow
+	private static _shellView as ShellTextView
+
+	override Control:
+		get:
+			return _scroller
+	
+	def constructor():
+		super( &quot;Boo Shell&quot;, &quot;md-boo-binding-base&quot; )
+		CreateBooShell()
+	
+	def CreateBooShell():
+		_scroller = Gtk.ScrolledWindow()
+		_shellView = ShellTextView (BooShellModel())
+		_scroller.Add(_shellView)
+
+	override def RedrawContent():
+		OnTitleChanged(null);
+		OnIconChanged(null);
+
+	override def Dispose():
+		_shellView.Dispose()
+		

Added: trunk/MonoDevelop/Extras/BooBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/ChangeLog	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/ChangeLog	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,4 @@
+2005-04-25  Peter Johanson &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>&gt;
+
+	* Initial import of the Boo addin.
+

Added: trunk/MonoDevelop/Extras/BooBinding/Gui/BooShellModel.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/BooShellModel.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/BooShellModel.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,89 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Gui
+
+import System
+import System.Collections
+import System.IO
+import Boo.Lang.Interpreter
+import Boo.Lang.Compiler
+import BooBinding.Properties
+
+class BooShellModel(IShellModel):
+	
+	private _interpreter = InteractiveInterpreter(RememberLastValue: true, Print: print)
+
+	private _outSink as StreamWriter
+	private _outSource as StreamReader
+
+	private props = BooShellProperties()
+
+	MimeType as string:
+		get:
+			return &quot;text/x-boo&quot;
+
+	def constructor():
+		_stream = MemoryStream()
+		_outSink = StreamWriter(_stream)
+		_outSource = StreamReader (_stream)
+	
+	Properties as ShellProperties:
+		get:
+			return props
+	
+	def Reset() as bool:
+		_interpreter.Reset()
+		return true
+		
+	def ProcessInput (line as String) as (string):
+		// Make sure our fake stdout is at the beginning
+		_outSink.BaseStream.SetLength(0)
+		_outSink.BaseStream.Seek(0, SeekOrigin.Begin)
+
+		// Save tradition stdout, and redirect Console
+		// to local StreamWriter. Catches any print, etc calls
+		// to be output to the local shell
+		_stdout = Console.Out
+		Console.SetOut(_outSink)
+
+		_interpreter.LoopEval(line)
+
+		// Restore stdout, and prep our fake stdout for reading
+		Console.SetOut(_stdout)
+		_outSink.Flush()
+		_outSink.BaseStream.Seek(0, SeekOrigin.Begin)
+
+		retList = ArrayList()
+		_outputLine as string = _outSource.ReadLine()
+
+		while _outputLine is not null:
+			retList.Add(_outputLine)
+			_outputLine = _outSource.ReadLine()
+
+		ret = cast ((string), retList.ToArray(typeof(string)))
+
+		_ = _interpreter.LastValue
+		if _ is not null:
+			_interpreter.SetValue(&quot;_&quot;, _)
+
+		return ret
+	
+	def print(obj):
+		print &quot;${obj}&quot;

Added: trunk/MonoDevelop/Extras/BooBinding/Gui/IShellModel.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/IShellModel.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/IShellModel.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,39 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Gui
+
+import System
+import BooBinding.Properties
+
+interface IShellModel:
+	def Reset() as bool:
+		pass
+
+	def ProcessInput (line as String) as (string):
+		pass
+	
+
+	Properties as ShellProperties:
+		get:
+			pass
+
+	MimeType as string:
+		get:
+			pass

Added: trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/CodeCompilationPanel.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/CodeCompilationPanel.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/CodeCompilationPanel.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,180 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Gui.OptionPanels
+
+import BooBinding
+
+import System
+import Gtk
+
+import MonoDevelop.Internal.Project
+import MonoDevelop.Internal.ExternalTool
+import MonoDevelop.Gui.Dialogs
+import MonoDevelop.Gui.Widgets
+import MonoDevelop.Services
+import MonoDevelop.Core.Services
+import MonoDevelop.Core.Properties
+import MonoDevelop.Core.AddIns.Codons
+
+public class CodeGenerationPanel(AbstractOptionPanel):
+	private codeGenerationLabel as Gtk.Label = Gtk.Label ()
+	private labelWarnings as Gtk.Label = Gtk.Label ()
+	private labelOutputDir as Gtk.Label = Gtk.Label ()
+	private outputLabel as Gtk.Label = Gtk.Label ()
+	private labelCompiler as Gtk.Label = Gtk.Label ()
+	private labelCulture as Gtk.Label = Gtk.Label ()
+
+	private labelCompileTarget as Gtk.Label = Gtk.Label ()
+	private compileTargetCombo as Gtk.ComboBox = Gtk.ComboBox ()
+	
+	private checkDebug = CheckButton (GettextCatalog.GetString (&quot;Enable debug&quot;))
+	private checkDucky = CheckButton (GettextCatalog.GetString (&quot;Enable ducky mode&quot;))
+
+	// compiler chooser
+	private booc = RadioButton (&quot;booc&quot;)
+	private boo as RadioButton
+
+	private outputAssembly = Entry ()
+	private outputDirectory = Entry()
+	// Waiting on resolution of a boo bug before we can use this
+	//private outputDirectory as FolderEntry = FolderEntry (&quot;Output Directory&quot;)
+	private compilerPath = Entry ()
+	private culture = Entry ()
+	
+	compilerParameters as BooCompilerParameters = null
+	configuration as DotNetProjectConfiguration  = null
+	
+	public def constructor():
+
+		InitializeComponent ()
+		vbox = VBox ()
+		hboxTmp = HBox ()
+		hboxTmp.PackStart (codeGenerationLabel, false, false, 0)
+		vbox.PackStart (hboxTmp, false, false, 12)
+		
+		hboxTmp = HBox()
+		tableOutputOptions = Table (4, 2, false)
+		tableOutputOptions.Attach (outputLabel, 0, 1, 0, 1, AttachOptions.Shrink, AttachOptions.Shrink, 0, 0)
+		tableOutputOptions.Attach (outputAssembly, 1, 2, 0, 1, AttachOptions.Fill | AttachOptions.Expand, AttachOptions.Fill, 0, 3)
+		tableOutputOptions.Attach (labelOutputDir, 0, 1, 1, 2, AttachOptions.Shrink, AttachOptions.Shrink, 0, 0)
+		tableOutputOptions.Attach (outputDirectory, 1, 2, 1, 2, AttachOptions.Fill | AttachOptions.Expand , AttachOptions.Fill, 0, 3)
+		tableOutputOptions.Attach (labelCompileTarget, 0, 1, 2, 3, AttachOptions.Shrink, AttachOptions.Shrink, 0, 0)
+		tableOutputOptions.Attach (compileTargetCombo, 1, 2, 2, 3, AttachOptions.Fill | AttachOptions.Expand, AttachOptions.Fill, 0, 3)
+		tableOutputOptions.Attach (labelCulture, 0, 1, 3, 4, AttachOptions.Shrink, AttachOptions.Shrink, 0, 0)
+		tableOutputOptions.Attach (culture, 1, 2, 3, 4, AttachOptions.Fill | AttachOptions.Expand, AttachOptions.Fill, 0, 3)
+		hboxTmp.PackStart (tableOutputOptions, true, true, 6)
+		vbox.PackStart (hboxTmp, false, false, 0)
+		
+		hboxTmp = HBox ()
+		hboxTmp.PackStart (labelWarnings, false, false, 0)
+		vbox.PackStart (hboxTmp, false, false, 12)
+		hboxTmp = HBox()
+		hboxTmp.PackStart (checkDebug, false, false, 6)
+		vbox.PackStart (hboxTmp, false, false, 0)
+		hboxTmp = HBox()
+		hboxTmp.PackStart (checkDucky, false, false, 6)
+		vbox.PackStart (hboxTmp, false, false, 0)
+		Add (vbox)
+
+	def OnCompilerToggled (o as object, args as EventArgs) as void:
+		if booc.Active:
+			compilerPath.Text = &quot;booc&quot;
+		else:
+			compilerPath.Text = &quot;boo&quot;
+	
+	private def InitializeComponent() as void:
+		boo = RadioButton (booc, &quot;boo&quot;)
+		boo.Toggled += OnCompilerToggled
+		booc.Toggled += OnCompilerToggled
+
+		codeGenerationLabel.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Code Generation&quot;))
+		labelOutputDir.Markup = String.Format (&quot;{0} :&quot;, GettextCatalog.GetString (&quot;Output Path&quot;))
+		labelOutputDir.Layout.Alignment = Pango.Alignment.Right
+		outputAssembly = Entry ()
+		
+		outputLabel.Markup = String.Format (&quot;{0} :&quot;, GettextCatalog.GetString (&quot;Output Assembly&quot;))
+		outputLabel.Layout.Alignment = Pango.Alignment.Right
+		labelWarnings.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Warnings and Compiler Options&quot;))
+		
+		labelCompiler.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Compiler&quot;))
+		labelCulture.Markup = String.Format (&quot;{0} :&quot;, GettextCatalog.GetString (&quot;Culture&quot;))
+		labelCulture.Layout.Alignment = Pango.Alignment.Right
+		labelCompileTarget.Markup = String.Format (&quot;{0} :&quot;, GettextCatalog.GetString (&quot;Output Assembly&quot;))
+		
+
+		typeArray = array(System.Type, 1)
+		typeArray[0] = typeof(string)
+		store = ListStore (typeArray)
+
+		stringArray = array(System.String, 1)
+		stringArray[0] = GettextCatalog.GetString (&quot;Executable&quot;)
+		store.AppendValues (stringArray)
+
+		stringArray = array(System.String, 1)
+		stringArray[0] = GettextCatalog.GetString (&quot;Library&quot;)
+		store.AppendValues (stringArray)
+
+		/*
+		stringArray = array(System.String, 1)
+		stringArray[0] = GettextCatalog.GetString (&quot;Windows Executable&quot;)
+		store.AppendValues (stringArray)
+		*/
+
+		compileTargetCombo.Model = store
+		cr = CellRendererText()
+		compileTargetCombo.PackStart(cr, true)
+		compileTargetCombo.AddAttribute(cr, &quot;text&quot;, 0)
+
+	
+	public override def LoadPanelContents() as void:
+		configuration = cast(DotNetProjectConfiguration,(cast(IProperties,CustomizationObject)).GetProperty(&quot;Config&quot;))
+		compilerParameters = cast (BooCompilerParameters, configuration.CompilationParameters)
+
+		if (compilerParameters.Compiler == BooCompiler.Booc):
+			booc.Active = true
+		else:
+			boo.Active = true
+
+		checkDebug.Active = configuration.DebugMode
+		checkDucky.Active = compilerParameters.Ducky
+		outputAssembly.Text = configuration.OutputAssembly
+		//outputDirectory.DefaultPath = configuration.OutputDirectory
+		outputDirectory.Text = configuration.OutputDirectory
+		
+		compilerPath.Text = compilerParameters.CompilerPath
+		culture.Text = compilerParameters.Culture
+		compileTargetCombo.Active = cast (int, configuration.CompileTarget)
+
+	public override def StorePanelContents() as bool:
+		if (compilerParameters is null):
+			return true
+
+
+		configuration.DebugMode = checkDebug.Active
+		configuration.CompileTarget = cast (CompileTarget, compileTargetCombo.Active)
+		configuration.OutputAssembly = outputAssembly.Text
+		configuration.OutputDirectory = outputDirectory.Text
+		//configuration.OutputDirectory = outputDirectory.Path
+
+		compilerParameters.Ducky = checkDucky.Active
+		compilerParameters.CompilerPath = compilerPath.Text
+		compilerParameters.Culture = culture.Text
+
+		return true

Added: trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/GeneralBooShellPanel.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/GeneralBooShellPanel.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/GeneralBooShellPanel.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,47 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Gui.OptionPanels
+
+import System
+import Gtk
+import Pango
+
+import MonoDevelop.Internal.Project
+import MonoDevelop.Internal.ExternalTool
+import MonoDevelop.Gui.Dialogs
+import MonoDevelop.Gui.Widgets
+import MonoDevelop.Services
+import MonoDevelop.Core.Services
+import MonoDevelop.Core.Properties
+import MonoDevelop.Core.AddIns.Codons
+
+import BooBinding.Properties
+
+public class GeneralBooShellPanel(GeneralShellPanel):
+
+	public Properties as ShellProperties:
+		get:
+			return BooShellProperties()
+
+	public override def LoadPanelContents() as void:
+		super()
+
+	public override def StorePanelContents() as bool:
+		return super()

Added: trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/GeneralShellPanel.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/GeneralShellPanel.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/GeneralShellPanel.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,124 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Gui.OptionPanels
+
+import System
+import Gtk
+import Pango
+
+import MonoDevelop.Internal.Project
+import MonoDevelop.Internal.ExternalTool
+import MonoDevelop.Gui.Dialogs
+import MonoDevelop.Gui.Widgets
+import MonoDevelop.Services
+import MonoDevelop.Core.Services
+import MonoDevelop.Core.Properties
+import MonoDevelop.Core.AddIns.Codons
+
+import BooBinding.Properties
+
+public class GeneralShellPanel(AbstractOptionPanel):
+	private generalOptionsLabel = Gtk.Label ()
+	private autoIndentCheckButton = Gtk.CheckButton ()
+	private resetClearsScrollbackCheckButton = Gtk.CheckButton ()
+	private resetClearsHistoryCheckButton = Gtk.CheckButton ()
+
+	private fontOptionsLabel = Gtk.Label ()
+	private fontButton = FontButton ()
+	private defaultMonoRadio as RadioButton
+	private customFontRadio as RadioButton
+
+	protected virtual Properties as ShellProperties:
+		get:
+			pass
+
+	private def InitializeComponent() as void:
+		generalOptionsLabel.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;General Options&quot;))
+
+		autoIndentCheckButton.Label = GettextCatalog.GetString (&quot;Automatically indent new lines in code blocks&quot;)
+		resetClearsScrollbackCheckButton.Label = GettextCatalog.GetString (&quot;Shell reset clears scollback&quot;)
+		resetClearsHistoryCheckButton.Label = GettextCatalog.GetString (&quot;Shell reset clears command history&quot;)
+		fontOptionsLabel.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Font&quot;))
+		defaultMonoRadio = RadioButton (GettextCatalog.GetString (&quot;Use default monospace font&quot;))
+		customFontRadio = RadioButton (defaultMonoRadio, GettextCatalog.GetString (&quot;Use custom font:&quot;))
+
+		defaultMonoRadio.Toggled += ItemToggled
+		customFontRadio.Toggled += ItemToggled
+
+
+	
+	public override def LoadPanelContents() as void:
+		InitializeComponent ()
+		vbox = VBox ()
+		hboxTmp = HBox()
+		hboxTmp.PackStart (generalOptionsLabel, false, false, 0)
+		vbox.PackStart (hboxTmp, false, false, 12)
+		hboxTmp = HBox()
+		hboxTmp.PackStart (autoIndentCheckButton, false, false, 6)
+		vbox.PackStart (hboxTmp, false, false, 0)
+		hboxTmp = HBox()
+		hboxTmp.PackStart (resetClearsScrollbackCheckButton, false, false, 6)
+		vbox.PackStart (hboxTmp, false, false, 0)
+		hboxTmp = HBox()
+		hboxTmp.PackStart (resetClearsHistoryCheckButton, false, false, 6)
+		vbox.PackStart (hboxTmp, false, false, 0)
+		hboxTmp = HBox()
+		hboxTmp.PackStart (fontOptionsLabel, false, false, 0)
+		vbox.PackStart (hboxTmp, false, false, 12)
+		hboxTmp = HBox()
+		hboxTmp.PackStart(defaultMonoRadio, false, false, 6)
+		vbox.PackStart (hboxTmp, false, false, 0)
+		hboxTmp = HBox()
+		hboxTmp.PackStart (customFontRadio, false, false, 6)
+		hboxTmp.PackStart (fontButton, false, false, 0)
+		vbox.PackStart (hboxTmp, false, false, 0)
+		Add (vbox)
+
+		s = Properties.FontName
+
+		if s == &quot;__default_monospace&quot;:
+			defaultMonoRadio.Active = true
+		else:
+			fontButton.FontName = s
+			customFontRadio.Active = true
+
+		fontButton.Sensitive = customFontRadio.Active
+		autoIndentCheckButton.Active = Properties.AutoIndentBlocks
+		resetClearsScrollbackCheckButton.Active = Properties.ResetClearsScrollback
+		resetClearsHistoryCheckButton.Active = Properties.ResetClearsHistory
+
+
+	public override def StorePanelContents() as bool:
+		if customFontRadio.Active:
+			Properties.FontName =  fontButton.FontName
+		elif defaultMonoRadio.Active:
+			Properties.FontName = &quot;__default_monospace&quot;
+
+		if Properties.AutoIndentBlocks != autoIndentCheckButton.Active:
+			Properties.AutoIndentBlocks = autoIndentCheckButton.Active
+
+		if Properties.ResetClearsScrollback != resetClearsScrollbackCheckButton.Active:
+			Properties.ResetClearsScrollback = resetClearsScrollbackCheckButton.Active
+		if Properties.ResetClearsHistory != resetClearsHistoryCheckButton.Active:
+			Properties.ResetClearsHistory = resetClearsHistoryCheckButton.Active
+		return true
+	
+	private def ItemToggled (o, args as EventArgs):
+		fontButton.Sensitive = customFontRadio.Active

Added: trunk/MonoDevelop/Extras/BooBinding/Gui/ShellTextView.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/ShellTextView.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/ShellTextView.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,315 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Gui
+
+import System
+import System.Collections
+import System.Runtime.InteropServices
+
+import Gtk
+import Gdk
+import Pango
+import GtkSourceView
+
+import MonoDevelop.Gui.Widgets
+import MonoDevelop.Core.Services
+import MonoDevelop.Services
+import MonoDevelop.Core.Properties
+import Boo.IO
+
+
+/*
+ * TODO
+ * 
+ * 1) Code Completion - Nice way to handle code competion for arbitrary shell?
+ * 2) Don't record lines with errors in the _scriptLines buffer
+ */
+
+class ShellTextView (SourceView):
+	private static _promptRegular = &quot;&gt;&gt;&gt; &quot;
+	private static _promptMultiline = &quot;... &quot;
+	
+	[Getter(Model)]
+	model as IShellModel
+
+	private _scriptLines = &quot;&quot;
+	
+	private _commandHistoryPast as Stack = Stack()
+	private _commandHistoryFuture as Stack = Stack()
+	
+	private _inBlock as bool = false
+	private _blockText = &quot;&quot;
+
+	private _reset_clears_history as bool
+	private _reset_clears_scrollback as bool
+	private _auto_indent as bool
+	
+	def constructor(model as IShellModel):
+		service = cast(SourceViewService,ServiceManager.GetService(typeof(SourceViewService)))
+		buf = SourceBuffer(service.GetLanguageFromMimeType(model.MimeType))
+
+		// This freaks out booc for some reason.
+		//super(buf, Highlight: true)
+		super(buf)
+		buf.Highlight = true
+
+		self.model = model
+		self.WrapMode = Gtk.WrapMode.Word
+		self.ModifyFont(Model.Properties.Font)
+
+		Model.Properties.InternalProperties.PropertyChanged += OnPropertyChanged
+
+		_auto_indent = Model.Properties.AutoIndentBlocks
+		_reset_clears_scrollback = Model.Properties.ResetClearsScrollback
+		_reset_clears_history = Model.Properties.ResetClearsHistory
+
+
+		// The 'Freezer' tag is used to keep everything except
+		// the input line from being editable
+		tag = TextTag (&quot;Freezer&quot;)
+		tag.Editable = false
+		Buffer.TagTable.Add (tag)
+		prompt(false)
+	
+	#region Overrides of the standard methods for event handling
+	override def OnPopulatePopup (menu as Gtk.Menu):
+		_copyScriptInput = ImageMenuItem (GettextCatalog.GetString (&quot;Copy Script&quot;))
+		_copyScriptInput.Activated += { Gtk.Clipboard.Get (Gdk.Atom.Intern (&quot;PRIMARY&quot;, true)).SetText(_scriptLines) }
+		_copyScriptInput.Image = Gtk.Image (Stock.Copy, Gtk.IconSize.Menu)
+		
+		_saveScriptToFile = ImageMenuItem (GettextCatalog.GetString (&quot;Save Script As ...&quot;))
+		_saveScriptToFile.Image = Gtk.Image (Stock.SaveAs, Gtk.IconSize.Menu)
+		_saveScriptToFile.Activated += OnSaveScript
+		
+		_reset = ImageMenuItem (GettextCatalog.GetString (&quot;Reset Shell&quot;))
+		_reset.Image = Gtk.Image (Stock.Clear, Gtk.IconSize.Menu)
+		_reset.Activated += def():
+			if Model.Reset():
+				resetGui()
+		
+		if _scriptLines.Length &lt;= 0:
+			_copyScriptInput.Sensitive = false
+			_saveScriptToFile.Sensitive = false
+			_reset.Sensitive = false
+
+		_sep = Gtk.SeparatorMenuItem()
+		menu.Prepend(_sep)
+		menu.Prepend(_copyScriptInput)
+		menu.Prepend(_saveScriptToFile)
+		menu.Prepend(_reset)
+		
+		_sep.Show()
+		_copyScriptInput.Show()
+		_saveScriptToFile.Show()
+		_reset.Show()
+	
+	override def OnKeyPressEvent (ev as Gdk.EventKey):
+		// Short circuit to avoid getting moved back to the input line
+		// when paging up and down in the shell output
+		if ev.Key in Gdk.Key.Page_Up, Gdk.Key.Page_Down:
+			return super (ev)
+		
+		// Needed so people can copy and paste, but always end up
+		// typing in the prompt.
+		if Cursor.Compare (InputLineBegin) &lt; 0:
+			Buffer.MoveMark (Buffer.SelectionBound, InputLineEnd)
+			Buffer.MoveMark (Buffer.InsertMark, InputLineEnd)
+		
+		if ev.Key == Gdk.Key.Return:
+			if _inBlock:
+				if InputLine == &quot;&quot;:
+					processInput (_blockText)
+					_blockText = &quot;&quot;
+					_inBlock = false
+				else:
+					_blockText += &quot;\n${InputLine}&quot;
+					if _auto_indent:
+						_whiteSpace = /^(\s+).*/.Replace(InputLine, &quot;$1&quot;)
+						if InputLine.Trim()[-1:] == &quot;:&quot;:
+							_whiteSpace += &quot;\t&quot;
+					prompt (true, true)
+					if _auto_indent:
+						InputLine += &quot;${_whiteSpace}&quot;
+			else:
+				// Special case for start of new code block
+				if InputLine.Trim()[-1:] == &quot;:&quot;:
+					_inBlock = true;
+					_blockText = InputLine
+					prompt (true, true)
+					if _auto_indent:
+						InputLine += &quot;\t&quot;
+					return true
+
+				// Bookkeeping
+				if InputLine != &quot;&quot;:
+					// Everything but the last item (which was input),
+					//in the future stack needs to get put back into the
+					// past stack
+					while _commandHistoryFuture.Count &gt; 1:
+						_commandHistoryPast.Push(cast(string,_commandHistoryFuture.Pop()))
+					// Clear the pesky junk input line
+					_commandHistoryFuture.Clear()
+
+					// Record our input line
+					_commandHistoryPast.Push(InputLine)
+					if _scriptLines == &quot;&quot;:
+						_scriptLines += &quot;${InputLine}&quot;
+					else:
+						_scriptLines += &quot;\n${InputLine}&quot;
+				
+				processInput (InputLine)
+			return true
+
+		// The next two cases handle command history	
+		elif ev.Key == Gdk.Key.Up:
+			if (not _inBlock) and _commandHistoryPast.Count &gt; 0:
+				if _commandHistoryFuture.Count == 0:
+					_commandHistoryFuture.Push(InputLine);
+				else:
+					if _commandHistoryPast.Count == 1:
+						return true
+					_commandHistoryFuture.Push(cast(string,_commandHistoryPast.Pop()))
+				InputLine = cast (string, _commandHistoryPast.Peek())
+			return true
+			
+		elif ev.Key == Gdk.Key.Down:
+			if (not _inBlock) and _commandHistoryFuture.Count &gt; 0:
+				if _commandHistoryFuture.Count == 1:
+					InputLine = cast(string, _commandHistoryFuture.Pop())
+				else:
+					_commandHistoryPast.Push (cast(string,_commandHistoryFuture.Pop()))
+					InputLine = cast (string, _commandHistoryPast.Peek())
+			return true
+			
+		elif ev.Key == Gdk.Key.Left:
+			// Keep our cursor inside the prompt area
+			if Cursor.Compare (InputLineBegin) &lt;= 0:
+				return true
+
+		elif ev.Key == Gdk.Key.Home:
+			Buffer.MoveMark (Buffer.InsertMark, InputLineBegin)
+			// Move the selection mark too, if shift isn't held
+			if (ev.State &amp; Gdk.ModifierType.ShiftMask) == ev.State:
+				Buffer.MoveMark (Buffer.SelectionBound, InputLineBegin)
+			return true
+
+		// Short circuit to avoid getting moved back to the input line
+		// when paging up and down in the shell output
+		elif ev.Key in Gdk.Key.Page_Up, Gdk.Key.Page_Down:
+			return super (ev)
+		
+		return super (ev)
+	
+	#endregion
+
+	#region Public getters for useful values
+	public InputLineBegin as TextIter:
+		get:
+			iter = Buffer.GetIterAtLine(Buffer.LineCount)
+			// Really should be either _promptRegular or Multiline, but
+			// those are the same length
+			iter.ForwardChars(_promptRegular.Length)
+			return iter
+	
+	public InputLineEnd as TextIter:
+		get:
+			return Buffer.EndIter
+	
+	private Cursor as TextIter:
+		get:
+			return Buffer.GetIterAtMark (Buffer.InsertMark)
+	#endregion
+	
+	// The current input line
+	public InputLine as string:
+		get:
+			return Buffer.GetText (InputLineBegin, InputLineEnd, false)
+		set:
+			start = InputLineBegin
+			end = InputLineEnd
+			Buffer.Delete (start, end)
+			start = InputLineBegin
+			Buffer.Insert (start, value)
+	
+	#region local private methods
+	private def processInput (line as string):
+		// Send our input out to be processed by the model
+		// and handle any output received in return
+		_results = self.Model.ProcessInput (line)
+		if _results:
+			for line as string in _results:
+				processOutput (line)
+		prompt(true)
+	
+	private def processOutput (line as string):
+		end = Buffer.EndIter
+		Buffer.Insert (end , &quot;\n${line}&quot;)
+
+	private def prompt (newLine as bool):
+		prompt (newLine, false)
+
+	private def prompt (newLine as bool, multiline as bool):
+		end = Buffer.EndIter
+		if newLine:
+			Buffer.Insert (end , &quot;\n&quot;)
+		if multiline:
+			Buffer.Insert (end , &quot;${_promptMultiline}&quot;)
+		else:
+			Buffer.Insert (end , &quot;${_promptRegular}&quot;)
+
+		Buffer.PlaceCursor (Buffer.EndIter)
+		ScrollMarkOnscreen(Buffer.InsertMark)
+		// Freeze all the text except our input line
+		Buffer.ApplyTag(Buffer.TagTable.Lookup(&quot;Freezer&quot;), Buffer.StartIter, InputLineBegin)
+		
+	private def resetGui():
+		if _reset_clears_scrollback:
+			Buffer.Text = &quot;&quot;
+		if _reset_clears_history:
+			_commandHistoryFuture.Clear()
+			_commandHistoryPast.Clear()
+
+		_scriptLines = &quot;&quot;
+		prompt(not _reset_clears_scrollback)
+		
+	// FIXME: Make my FileChooser use suck less
+	private def OnSaveScript():
+		_sel = FileSelector(&quot;Save Script ...&quot;, FileChooserAction.Save)
+		_sel.Run()
+		if _sel.Filename:
+			_sel.Hide()
+			_path = _sel.Filename
+			TextFile.WriteFile (_path, _scriptLines)
+		else:
+			_sel.Hide()
+	
+	def OnPropertyChanged (obj as object, e as PropertyEventArgs):
+		if e.Key == &quot;Font&quot;:
+			self.ModifyFont(Model.Properties.Font)
+		elif e.Key == &quot;AutoIndentBlocks&quot;:
+			_auto_indent = Model.Properties.AutoIndentBlocks
+		elif e.Key == &quot;ResetClearsScrollback&quot;:
+			_reset_clears_scrollback = Model.Properties.ResetClearsScrollback
+		elif e.Key == &quot;ResetClearsHistory&quot;:
+			_reset_clears_history = Model.Properties.ResetClearsHistory
+
+		return
+
+	#endregion

Added: trunk/MonoDevelop/Extras/BooBinding/Makefile.am
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Makefile.am	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Makefile.am	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,91 @@
+
+ADDIN_BUILD = $(top_builddir)/build/AddIns/BackendBindings
+ASSEMBLY = $(ADDIN_BUILD)/BooBinding.dll
+
+DLLS = -r:System.Drawing \
+	-r:System.Xml \
+	-r:$(top_builddir)/build/bin/MonoDevelop.Core.dll \
+	-r:$(top_builddir)/build/bin/MonoDevelop.SourceEditor.dll \
+	-r:$(top_builddir)/build/bin/MonoDevelop.Base.dll \
+	-r:$(top_builddir)/build/bin/ICSharpCode.SharpRefactory.dll \
+	-r:$(top_builddir)/build/bin/MonoDevelop.Gui.Widgets.dll \
+	$(BOO_LIBS) \
+	$(GTK_SHARP_LIBS) \
+	$(GCONF_SHARP_LIBS) \
+	$(GTKSOURCEVIEW_SHARP_LIBS)
+
+FILES = \
+Gui/ShellTextView.boo \
+Gui/IShellModel.boo \
+Gui/BooShellModel.boo \
+Gui/OptionPanels/CodeCompilationPanel.boo \
+Gui/OptionPanels/GeneralShellPanel.boo \
+Gui/OptionPanels/GeneralBooShellPanel.boo \
+Project/BooCompilerParameters.boo \
+Properties/ShellProperties.boo \
+Properties/BooShellProperties.boo \
+BooBindingCompilerServices.boo \
+BooAmbience.boo \
+BooShellPadContent.boo \
+BooCompiler.boo \
+BooLanguageBinding.boo \
+Parser/BooParser.boo \
+Parser/Resolver.boo \
+Parser/TypeMembers.boo \
+Parser/ExpressionFinder.boo \
+Parser/ReturnType.boo \
+Parser/VariableLookupVisitor.boo \
+Parser/ExpressionTypeVisitor.boo \
+Parser/Tree.boo \
+Parser/Visitor.boo
+
+TEMPLATES = \
+templates/BooGtkSharpProject.xpt.xml \
+templates/BooGtkSharpWindow.xft.xml \
+templates/EmptyBooFile.xft.xml \
+templates/EmptyBooProject.xpt.xml
+
+build_sources = $(addprefix $(srcdir)/, $(FILES))
+
+ADDIN = BooBinding.addin.xml
+
+
+TEMPLATES_DIR = $(ADDIN_BUILD)/templates
+
+build_TEMPLATES = $(addprefix $(TEMPLATES_DIR)/, $(notdir $(TEMPLATES)))
+
+src_TEMPLATES = $(addprefix $(srcdir)/, $(TEMPLATES))
+
+if ENABLE_BOO
+all: $(ASSEMBLY) $(ADDIN_BUILD)/$(ADDIN) $(build_TEMPLATES)
+else
+all:
+endif
+
+$(filter %.xft.xml, $(build_TEMPLATES)): $(TEMPLATES_DIR)/%.xft.xml: $(srcdir)/templates/%.xft.xml
+	mkdir -p $(TEMPLATES_DIR)
+	cp $(srcdir)/templates/$(notdir $@) $@
+
+$(filter %.xpt.xml, $(build_TEMPLATES)): $(TEMPLATES_DIR)/%.xpt.xml: $(srcdir)/templates/%.xpt.xml
+	mkdir -p $(TEMPLATES_DIR)
+	cp $(srcdir)/templates/$(notdir $@) $@
+
+$(ADDIN_BUILD)/$(ADDIN): $(srcdir)/$(ADDIN)
+	mkdir -p $(ADDIN_BUILD)
+	cp $(srcdir)/$(ADDIN) $(ADDIN_BUILD)/.
+
+$(ASSEMBLY): $(FILES)
+	mkdir -p $(ADDIN_BUILD)
+	$(BOOC) $(DLLS) $(build_sources) -o:$@ -t:library
+
+if ENABLE_BOO
+assemblydir = $(libdir)/monodevelop/AddIns/BackendBindings
+assembly_DATA = $(ASSEMBLY) $(ADDIN)
+
+templatedir = $(assemblydir)/templates
+template_DATA = $(TEMPLATES)
+endif
+
+CLEANFILES = $(ASSEMBLY) $(ASSEMBLY).mdb
+EXTRA_DIST = $(FILES) $(ADDIN) $(TEMPLATES)
+

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/BooParser.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/BooParser.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/BooParser.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,166 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import System
+import System.Collections
+import System.Diagnostics
+import System.IO
+import MonoDevelop.Services
+import MonoDevelop.Internal.Project
+import MonoDevelop.Internal.Parser
+import Boo.Lang.Compiler
+import Boo.Lang.Compiler.IO
+import Boo.Lang.Compiler.Pipelines
+import Boo.Lang.Compiler.Steps
+
+class BooParser(IParser):
+	private _lexerTags as (string)
+	
+	LexerTags as (string):
+		get:
+			return _lexerTags
+		set:
+			_lexerTags = value
+	
+	ExpressionFinder as IExpressionFinder:
+		get:
+			return BooBinding.Parser.ExpressionFinder()
+	
+	def CanParse(fileName as string):
+		return Path.GetExtension(fileName).ToLower() == &quot;.boo&quot;
+	
+	def CanParse(project as Project):
+		return project.ProjectType == BooBinding.BooLanguageBinding.LanguageName
+	
+	def Parse(fileName as string) as ICompilationUnitBase:
+		/*
+		compiler = BooCompiler()
+		compiler.Parameters.Input.Add(FileInput(fileName))
+		return Parse(fileName, compiler)
+		*/
+		content as string
+		using r = StreamReader(fileName):
+			content = r.ReadToEnd()
+		return Parse(fileName, content)
+	
+	def Parse(fileName as string, fileContent as string) as ICompilationUnitBase:
+		//print &quot;Parse ${fileName} with content&quot;
+		
+		cr = '\r'[0]
+		ln = '\n'[0]
+		linecount = 1
+		for c as Char in fileContent:
+			linecount += 1 if c == ln
+		lineLength = array(int, linecount)
+		length = 0
+		i = 0
+		for c as Char in fileContent:
+			if c == ln:
+				lineLength[i] = length
+				i += 1
+				length = 0
+			elif c != cr:
+				length += 1
+		lineLength[i] = length
+		
+		compiler = BooCompiler()
+		compiler.Parameters.Input.Add(StringInput(fileName, fileContent))
+		return Parse(fileName, lineLength, compiler)
+	
+	private def Parse(fileName as string, lineLength as (int), compiler as BooCompiler):
+		compiler.Parameters.OutputWriter = StringWriter()
+		compiler.Parameters.TraceSwitch.Level = TraceLevel.Warning;
+		
+		compilePipe = Compile()
+		parsingStep as Boo.Lang.Parser.BooParsingStep = compilePipe[0]
+		parsingStep.TabSize = 1
+		num = compilePipe.Find(typeof(StricterErrorChecking))
+		// Original cut out from this place onward, but this caused
+		// problems with [Property(A)]\na\n type properties
+		// and trying to figure out the types.
+		// What did we break by doing this extra Step?
+		//num = compilePipe.Find(typeof(ProcessMethodBodiesWithDuckTyping))
+		visitor = Visitor(LineLength:lineLength)
+		for c as IClass in visitor.Cu.Classes:
+			c.Region.FileName = fileName
+		compilePipe[num] = visitor
+		// Remove unneccessary compiler steps
+		while compilePipe.Count &gt; num + 1:
+			compilePipe.RemoveAt(compilePipe.Count - 1)
+		num = compilePipe.Find(typeof(TransformCallableDefinitions))
+		compilePipe.RemoveAt(num)
+		
+		//for i in range(compilePipe.Count):
+		//	print compilePipe[i].ToString()
+		
+		compilePipe.BreakOnErrors = false
+		compiler.Parameters.Pipeline = compilePipe
+		
+		try:
+			compiler.Run()
+			// somehow the SD parser thread goes into an endless loop if this flag is not set
+			visitor.Cu.ErrorsDuringCompile = true //context.Errors.Count &gt; 0
+		except e:
+			//ShowException(e)
+			print &quot;ShowException ${e}&quot;
+		return visitor.Cu
+	
+	def CtrlSpace(parserService as IParserService, project as Project, caretLine as int, caretColumn as int, fileName as string) as ArrayList:
+		//print &quot;Ctrl-Space (${caretLine}/${caretColumn})&quot;
+		try:
+			return Resolver(project).CtrlSpace(parserService, caretLine, caretColumn, fileName)
+		except e:
+			//ShowException(e)
+			return null
+	
+	def IsAsResolve (parserService as IParserService , project as Project , expression as string , caretLineNumber as int , caretColumn as int , fileName as string , fileContent as string ) as ArrayList:
+		return Resolver (project).IsAsResolve (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent)
+
+	def Resolve(parserService as IParserService, project as Project, expression as string, caretLineNumber as int, caretColumn as int, fileName as string, fileContent as string) as ResolveResult:
+		//print &quot;Resolve ${expression} (${caretLineNumber}/${caretColumn})&quot;
+		try:
+			return Resolver(project).Resolve(parserService, expression, caretLineNumber, caretColumn, fileName, fileContent)
+		except e:
+			//ShowException(e)
+			return null
+
+	def MonodocResolver(parserService as IParserService, project as Project, expression as string, caretLineNumber as int, caretColumn as int, fileName as string, fileContent as string) as string:
+		//print &quot;MonodocResolver ${expression} (${caretLineNumber}/${caretColumn})&quot;
+		try:
+			return Resolver(project).MonodocResolver(parserService, expression, caretLineNumber, caretColumn, fileName, fileContent)
+		except e:
+			//ShowException(e)
+			return null
+	
+	/*
+	static def ShowException(e as Exception):
+		//messageService as IMessageService = ServiceManager.Services.GetService(typeof(IMessageService))
+		//messageService.ShowError(e.ToString())
+		retur
+	*/
+
+

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/ExpressionFinder.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/ExpressionFinder.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/ExpressionFinder.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,214 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import System
+import System.Text
+import MonoDevelop.Internal.Parser
+
+class ExpressionFinder(IExpressionFinder):
+	// The expression finder can find an expression in a text
+	// inText is the full source code, offset the cursor position
+	
+	// example: &quot;_var = 'bla'\n_var^\nprint _var&quot;
+	// where ^ is the cursor position
+	// in that simple case the expression finder should return 'n_var'.
+	
+	// but also complex expressions like
+	// 'filename.Substring(filename.IndexOf(&quot;var=&quot;))'
+	// should be returned if the cursor is after the last ).
+	
+	// implementation note: the text after offset is irrelevant, so
+	// every operation on the string aborts after reaching offset
+	
+	static _closingBrackets = '}])'
+	static _openingBrackets = '{[('
+	
+	def FindExpression(inText as string, offset as int) as string:
+		return null if inText == null
+		print &quot;Trying quickfind for ${offset}&quot;
+		// OK, first try a kind of &quot;quick find&quot;
+		i = offset + 1
+		forbidden = '&quot;\'/#)]}'
+		finish = '([{=+*&lt;,:'
+		start = -1
+		while i &gt; 0:
+			i -= 1
+			c = inText[i]
+			if finish.IndexOf(c) &gt;= 0:
+				start = i + 1
+				break
+			if forbidden.IndexOf(c) &gt;= 0:
+				print &quot;Quickfind failed: got ${c}&quot;
+				break
+			if Char.IsWhiteSpace(c):
+				if i &gt; 6 and inText.Substring(i - 6, 6) == &quot;import&quot;:
+					i -= 7 // include 'import' in the expression
+				start = i + 1
+				break
+		if start &gt;= 0:
+			if CheckString(inText, start, '/#&quot;\'', '\r\n'):
+				return GetExpression(inText, start, offset + 1)
+		
+		inText = SimplifyCode(inText, offset)
+		if inText == null:
+			print 'SimplifyCode returned null (cursor is in comment/string???)'
+			return null
+		// inText now has no comments or string literals, but the same meaning in
+		// terms of the type system
+		// Now go back until a finish-character or a whitespace character
+		bracketStack = StringBuilder() // use Stack&lt;char&gt; instead in .NET 2.0
+		i = inText.Length
+		while i &gt; 0:
+			i -= 1
+			c = inText[i]
+			if bracketStack.Length == 0 and (finish.IndexOf(c) &gt;= 0 or Char.IsWhiteSpace(c)):
+				return GetExpression(inText, i + 1, inText.Length)
+			if _closingBrackets.IndexOf(c) &gt;= 0:
+				bracketStack.Append(c)
+			bracket = _openingBrackets.IndexOf(c)
+			if bracket &gt;= 0:
+				while Pop(bracketStack) &gt; bracket:
+					pass
+		
+		return null
+	
+	private def CheckString(text as string, offset as int, forbidden as string, finish as string):
+		i = offset
+		while i &gt; 0:
+			i -= 1
+			c = text[i]
+			return false if forbidden.IndexOf(c) &gt;= 0
+			return true if finish.IndexOf(c) &gt;= 0
+		return true
+	
+	private def Pop(bracketStack as StringBuilder):
+		return -1 if bracketStack.Length == 0
+		c = bracketStack[bracketStack.Length - 1]
+		bracketStack.Length -= 1
+		return _closingBrackets.IndexOf(c)
+	
+	private def GetExpression(inText as string, start as int, end as int):
+		b = StringBuilder()
+		wasSpace = true
+		i = start
+		while i &lt; end:
+			c = inText[i]
+			if Char.IsWhiteSpace(c):
+				b.Append(' ') unless wasSpace
+				wasSpace = true
+			else:
+				wasSpace = false
+				b.Append(c)
+			i += 1
+		print &quot;Expression is '${b}'&quot;
+		return b.ToString().Trim()
+	
+	// this method makes boo source code &quot;simpler&quot; by removing all comments
+	// and replacing all types of strings through string.Empty.
+	
+	// TODO: We could need some unit tests for this.
+	
+	static _elseIndex = 10
+	
+	static _stateTable = ( // &quot;    '    \    \n   $    {    }    #    /    *   else
+	/* 0: in Code       */  ( 1  , 7  , 0  , 0  , 0  , 0  , 0  , 13 , 12 , 0  , 0  ),
+	/* 1: after &quot;       */  ( 2  , 6  , 10 , 0  , 8  , 6  , 6  , 6  , 6  , 6  , 6  ),
+	/* 2: after &quot;&quot;      */  ( 3  , 7  , 0  , 0  , 0  , 0  , 0  , 13 , 12 , 0  , 0  ),
+	/* 3: in &quot;&quot;&quot;        */  ( 4  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  ),
+	/* 4: in &quot;&quot;&quot;, &quot;     */  ( 5  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  ),
+	/* 5: in &quot;&quot;&quot;, &quot;&quot;    */  ( 0  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  , 3  ),
+	/* 6: in &quot;-string   */  ( 0  , 6  , 10 , 0  , 8  , 6  , 6  , 6  , 6  , 6  , 6  ),
+	/* 7: in '-string   */  ( 7  , 0  , 11 , 0  , 7  , 7  , 7  , 7  , 7  , 7  , 7  ),
+	/* 8: after $ in &quot;  */  ( 0  , 6  , 10 , 0  , 8  , 9  , 6  , 6  , 6  , 6  , 6  ),
+	/* 9: in &quot;{         */  ( 9  , 9  , 9  , 9  , 9  , 9  , 6  , 9  , 9  , 9  , 9  ),
+	/* 10: after \ in &quot; */  ( 6  , 6  , 6  , 0  , 6  , 6  , 6  , 6  , 6  , 6  , 6  ),
+	/* 11: after \ in ' */  ( 7  , 7  , 7  , 0  , 7  , 7  , 7  , 7  , 7  , 7  , 7  ),
+	/* 12: after /      */  ( 1  , 7  , 0  , 0  , 0  , 0  , 0  , 0  , 13 ,-14 , 0  ),
+	/* 13: line comment */  ( 13 , 13 , 13 , 0  , 13 , 13 , 13 , 13 , 13 , 13 , 13 ),
+	/* 14: block comment*/  ( 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 15 , 14 ),
+	/* 15: after * in bc*/  ( 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 ,-15 , 15 , 14 )
+	                     )
+	
+	def SimplifyCode(inText as string, offset as int):
+		result = StringBuilder()
+		inStringResult = StringBuilder(' ')
+		state = 0
+		commentblocks = 0
+		inputTable = array(int, 128)
+		for i in range(128):
+			inputTable[i] = _elseIndex
+		inputTable[ 34] = 0 // &quot;
+		inputTable[ 39] = 1 // '
+		inputTable[ 92] = 2 // \
+		inputTable[ 10] = 3 // \n
+		inputTable[ 13] = 3 // \r
+		inputTable[ 36] = 4 // $
+		inputTable[123] = 5 // {
+		inputTable[125] = 6 // }
+		inputTable[ 35] = 7 // #
+		inputTable[ 47] = 8 // /
+		inputTable[ 42] = 9 // *
+		for i in range(offset + 1):
+			c as Char = inText[i]
+			// TODO: Direct char-&gt;int conversion
+			charNum as int = Encoding.ASCII.GetBytes((c,))[0]
+			if charNum &gt; 127:
+				input = _elseIndex
+			else:
+				input = inputTable[charNum]
+			action = _stateTable[state][input]
+			if action == -14:
+				// enter block comment
+				commentblocks += 1
+				state = 14
+			elif action == -15:
+				// leave block comment
+				commentblocks -= 1
+				if commentblocks == 0:
+					state = 0
+				else:
+					state = 14
+			elif action == 9:
+				if state == 9:
+					inStringResult.Append(c)
+				else:
+					inStringResult.Length = 1
+				state = action
+			elif action == 0 or action == 12:
+				if state == 2 or (state &gt;= 6 and state &lt;= 11):
+					result.Append(&quot;string.Empty&quot;)
+				if state == 0 or state == 2 or state == 12:
+					result.Append(c)
+				state = action
+			else:
+				state = action
+		if state == 0 or state == 2 or state == 12:
+			return result.ToString()
+		elif state == 9:
+			return inStringResult.ToString()
+		else:
+			return null

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/ExpressionTypeVisitor.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/ExpressionTypeVisitor.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/ExpressionTypeVisitor.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,268 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import System
+import System.Collections
+import MonoDevelop.Internal.Parser
+import Boo.Lang.Compiler.Ast
+
+class ExpressionTypeVisitor(DepthFirstVisitor):
+	protected override def OnError(node as Node, error as Exception):
+		//BooParser.ShowException(error)
+		super(node, error)
+	
+	[Property(ReturnType)]
+	_returnType as IReturnType
+	
+	[Property(ReturnClass)]
+	_returnClass as IClass
+	
+	[Property(Resolver)]
+	_resolver as Resolver
+	
+	private def CreateReturnType(fullClassName as string):
+		_returnClass = null
+		if fullClassName == null:
+			_returnType = null
+		else:
+			print &quot;CreateReturnType: type set to ${fullClassName}&quot;
+			_returnType = BooBinding.Parser.ReturnType(fullClassName)
+	
+	private def CreateReturnType(reference as TypeReference):
+		_returnClass = null
+		if reference == null:
+			_returnType = null
+		else:
+			_returnType = BooBinding.Parser.ReturnType(reference)
+	
+	private def CreateReturnType(c as IClass):
+		_returnClass = c
+		if c == null:
+			_returnType = null
+		else:
+			_returnType = BooBinding.Parser.ReturnType(c)
+	
+	private def SetReturnType(r as IReturnType):
+		_returnClass = null
+		_returnType = r
+	
+	private def Debug(node):
+		if node == null:
+			print &quot;-- null --&quot;
+		else:
+			print &quot;${node.ToString()} - ${node.GetType().FullName}&quot;
+	
+	override def OnCallableBlockExpression(node as CallableBlockExpression):
+		Debug(node)
+		CreateReturnType(&quot;System.Delegate&quot;)
+	
+	override def OnMethodInvocationExpression(node as MethodInvocationExpression):
+		Debug(node)
+		Debug(node.Target)
+		if node.Target isa MemberReferenceExpression:
+			// call a method on another object
+			mre as MemberReferenceExpression = node.Target
+			Visit(mre.Target)
+			if _returnClass == null and _returnType != null:
+				_returnClass = _resolver.SearchType(_returnType.FullyQualifiedName)
+			return if ProcessMethod(node, mre.Name, _returnClass)
+			// try if the MemberReferenceExpression is a fully qualified class name (constructor call)
+			ProcessMemberReferenceExpression(mre.Name)
+			CreateReturnType(_returnClass)
+		elif node.Target isa ReferenceExpression:
+			re as ReferenceExpression = node.Target
+			// try if it is a method on the current object
+			return if ProcessMethod(node, re.Name, _resolver.CallingClass)
+			// try if it is a builtin method
+			return if ProcessMethod(node, re.Name, _resolver.BuiltinClass)
+			// try if it is a class name -&gt; constructor
+			CreateReturnType(_resolver.SearchType(re.Name))
+		else:
+			SetReturnType(null)
+	
+	private def ProcessMethod(node as MethodInvocationExpression, name as string, c as IClass) as bool:
+		return false if c == null
+		possibleOverloads = FindMethods(c, name, node.Arguments.Count)
+		print &quot;found ${possibleOverloads.Count} overloads (multiple overloads not supported yet)&quot;
+		if possibleOverloads.Count &gt;= 1:
+			SetReturnType(cast(IMethod, possibleOverloads[0]).ReturnType)
+			return true
+		/*// find best overload
+		argumentTypes = array(IReturnType, node.Arguments.Count)
+		for i as int in range(argumentTypes.Length):
+			Visit(node.Arguments[i])
+			argumentTypes[i] = _returnType
+		...
+		*/
+		return false
+	
+	private def FindMethods(c as IClass, name as string, arguments as int):
+		possibleOverloads = ArrayList()
+		//for cl as IClass in c.ClassInheritanceTree:
+		for cl as IClass in _resolver.ParserService.GetClassInheritanceTree(_resolver.Project, c):
+			for m as IMethod in cl.Methods:
+				if m.Parameters.Count == arguments and name == m.Name:
+					possibleOverloads.Add(m)
+		return possibleOverloads
+	
+	override def OnSlicingExpression(node as SlicingExpression):
+		Debug(node)
+		Visit(node.Target)
+		slice as Slice = node.Indices[0]
+		if (slice.End != null):
+			// Boo slice, returns a part of the source -&gt; same type as source
+			return
+		if _returnType != null and _returnType.ArrayDimensions != null and _returnType.ArrayDimensions.Length &gt; 0:
+			SetReturnType(BooBinding.Parser.ReturnType(_returnType.FullyQualifiedName, _returnType.ArrayDimensions[0 : _returnType.ArrayDimensions.Length - 1], 0))
+			return
+		if _returnClass == null and _returnType != null:
+			_returnClass = _resolver.SearchType(_returnType.FullyQualifiedName)
+		if _returnClass != null:
+			indexers = FindIndexer(_returnClass, 1)
+			if indexers.Count &gt; 0:
+				SetReturnType(cast(IIndexer, indexers[0]).ReturnType)
+				return
+		SetReturnType(null)
+	
+	private def FindIndexer(c as IClass, arguments as int):
+		possibleOverloads = ArrayList()
+		//for cl as IClass in c.ClassInheritanceTree:
+		for cl as IClass in _resolver.ParserService.GetClassInheritanceTree(_resolver.Project, c):
+			for m as IIndexer in cl.Indexer:
+				if m.Parameters.Count == arguments:
+					possibleOverloads.Add(m)
+		return possibleOverloads
+	
+	override def OnBinaryExpression(node as BinaryExpression):
+		Debug(node)
+		CombineTypes(node.Left, node.Right)
+	
+	override def OnTernaryExpression(node as TernaryExpression):
+		Debug(node)
+		CombineTypes(node.TrueValue, node.FalseValue)
+	
+	private def CombineTypes(a as Expression, b as Expression):
+		Visit(a)
+	
+	override def OnReferenceExpression(node as ReferenceExpression):
+		// Resolve reference (to a variable, field, parameter or type)
+		rt = _resolver.GetTypeFromLocal(node.Name)
+		if rt != null:
+			SetReturnType(rt)
+
+		return if ProcessMember(node.Name, _resolver.CallingClass)
+		if _resolver.IsNamespace(node.Name):
+			SetReturnType(NamespaceReturnType(node.Name))
+		else:
+			CreateReturnType(_resolver.SearchType(node.Name))
+	
+	override def OnMemberReferenceExpression(node as MemberReferenceExpression):
+		Debug(node)
+		Visit(node.Target)
+		ProcessMemberReferenceExpression(node.Name)
+	
+	private def ProcessMemberReferenceExpression(name as string):
+	&quot;&quot;&quot;Gets the return type of the MemberReferenceExpression with the specified name
+	on the current return type.&quot;&quot;&quot;
+		if _returnType isa NamespaceReturnType:
+			name = _returnType.FullyQualifiedName + '.' + name
+			if _resolver.IsNamespace(name):
+				SetReturnType(NamespaceReturnType(name))
+			else:
+				CreateReturnType(_resolver.SearchType(name))
+			return
+		if _returnClass == null and _returnType != null:
+			_returnClass = _resolver.SearchType(_returnType.FullyQualifiedName)
+		return if ProcessMember(name, _returnClass)
+		SetReturnType(null)
+	
+	private def ProcessMember(name as string, parentClass as IClass):
+		return false if parentClass == null
+		for cl as IClass in _resolver.ParserService.GetClassInheritanceTree(_resolver.Project, parentClass):
+			for c as IClass in cl.InnerClasses:
+				if c.Name == name:
+					CreateReturnType(c)
+					return true
+			for f as IField in cl.Fields:
+				if f.Name == name:
+					SetReturnType(f.ReturnType)
+					return true
+			for p as IProperty in cl.Properties:
+				if p.Name == name:
+					print &quot;ProcessMember: Set property return type to ${p.ReturnType}&quot;
+					SetReturnType(p.ReturnType)
+					return true
+			for m as IMethod in cl.Methods:
+				if m.Name == name:
+					CreateReturnType(&quot;System.Delegate&quot;)
+					return true
+		return false
+	
+	override def OnTimeSpanLiteralExpression(node as TimeSpanLiteralExpression):
+		CreateReturnType(&quot;System.TimeSpan&quot;)
+	
+	override def OnIntegerLiteralExpression(node as IntegerLiteralExpression):
+		CreateReturnType(&quot;System.Int32&quot;)
+	
+	override def OnDoubleLiteralExpression(node as DoubleLiteralExpression):
+		CreateReturnType(&quot;System.Double&quot;)
+	
+	override def OnNullLiteralExpression(node as NullLiteralExpression):
+		CreateReturnType(&quot;System.Object&quot;)
+	
+	override def OnStringLiteralExpression(node as StringLiteralExpression):
+		CreateReturnType(&quot;System.String&quot;)
+	
+	override def OnSelfLiteralExpression(node as SelfLiteralExpression):
+		CreateReturnType(_resolver.CallingClass)
+	
+	override def OnSuperLiteralExpression(node as SuperLiteralExpression):
+		CreateReturnType(_resolver.ParentClass)
+	
+	override def OnBoolLiteralExpression(node as BoolLiteralExpression):
+		CreateReturnType(&quot;System.Boolean&quot;)
+	
+	override def OnRELiteralExpression(node as RELiteralExpression):
+		CreateReturnType(&quot;System.Text.RegularExpressions.Regex&quot;)
+	
+	override def OnHashLiteralExpression(node as HashLiteralExpression):
+		CreateReturnType(&quot;System.Collections.Hashtable&quot;)
+	
+	override def OnListLiteralExpression(node as ListLiteralExpression):
+		CreateReturnType(&quot;System.Collections.ArrayList&quot;)
+	
+	override def OnArrayLiteralExpression(node as ArrayLiteralExpression):
+		CreateReturnType(&quot;System.Array&quot;)
+	
+	override def OnAsExpression(node as AsExpression):
+		CreateReturnType(node.Type)
+	
+	override def OnCastExpression(node as CastExpression):
+		CreateReturnType(node.Type)
+	
+	override def OnTypeofExpression(node as TypeofExpression):
+		CreateReturnType(&quot;System.Type&quot;)

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/Resolver.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/Resolver.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/Resolver.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,467 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import BooBinding
+import System
+import System.Collections
+import System.Diagnostics
+import System.IO
+import MonoDevelop.Services
+import MonoDevelop.Internal.Parser
+import MonoDevelop.Internal.Project
+import Boo.Lang.Compiler
+import Boo.Lang.Compiler.Ast as AST
+import Boo.Lang.Compiler.IO
+import Boo.Lang.Compiler.Steps
+
+class Resolver:
+	[Getter(ParserService)]
+	_parserService as IParserService
+
+	_caretLine as int
+	_caretColumn as int
+
+	[Getter(Project)]
+	_project as Project
+	
+	[Getter(CallingClass)]
+	_callingClass as IClass
+	_compilationUnit as ICompilationUnit
+
+	[Property(ShowStatic)]
+	_showStatic as bool
+	
+	_parentClass as IClass
+	ParentClass as IClass:
+		get:
+			curClass = GetInnermostClass(_compilationUnit) as IClass
+			return BaseClass(curClass)
+	
+	_resolvedMember = false
+	_currentMember as IMember
+	
+	CurrentMember as IMember:
+		get:
+			if not _resolvedMember:
+				_resolvedMember = true
+				_currentMember = ResolveCurrentMember()
+			return _currentMember
+	
+
+	def constructor ():
+		pass
+
+	def constructor (project as Project):
+		_project = project
+
+	#region Helper methods
+	private def ResolveCurrentMember() as IMember:
+		print &quot;Getting current method... caretLine = ${_caretLine}, caretColumn = ${_caretColumn}&quot;
+		return null if _callingClass == null
+		best as IMember = null
+		line = 0
+		for m as IMember in _callingClass.Methods:
+			if m.Region != null:
+				if m.Region.BeginLine &lt;= _caretLine and m.Region.BeginLine &gt; line:
+					line = m.Region.BeginLine
+					best = m
+		for m as IMember in _callingClass.Properties:
+			if m.Region != null:
+				if m.Region.BeginLine &lt;= _caretLine and m.Region.BeginLine &gt; line:
+					line = m.Region.BeginLine
+					best = m
+		if _callingClass.Region == null:
+			for m as IMember in _callingClass.Methods:
+				if m.Region == null:
+					if best == null or best.Region.EndLine &lt; _caretLine:
+						return m
+		return best
+	
+	_localTypes as Hashtable = {}
+	
+	def GetTypeFromLocal(name as string) as IReturnType:
+		// gets the type of a local variable or method parameter
+		print &quot;Trying to get local variable ${name}...&quot;
+		return _localTypes[name] if _localTypes.ContainsKey(name)
+		_localTypes[name] = null // prevent stack overflow by caching null first
+		rt = InnerGetTypeFromLocal(name)
+		_localTypes[name] = rt
+		return rt
+	
+	def InnerGetTypeFromLocal(name as string) as IReturnType:
+		member = self.CurrentMember
+		Print(&quot;member&quot;, member)
+		if member isa BooAbstractMethod:
+			method as BooAbstractMethod = member
+			for para as IParameter in method.Parameters:
+				return para.ReturnType if para.Name == name
+			if method.Node != null and method.Node.Body != null:
+				varLookup = VariableLookupVisitor(Resolver: self, LookFor: name)
+				print &quot;Visiting method body...&quot;
+				varLookup.Visit(method.Node.Body)
+				print &quot;Finished visiting method body!&quot;
+				return varLookup.ReturnType
+		elif member isa Property:
+			print &quot;name: ${name}&quot;
+			property as Property = member
+			/*
+			if property.ReturnType isa BooBinding.Parser.InferredReturnType:
+				print &quot;Return type is an inferred, zapping it!&quot;
+				return ReturnType(&quot;System.Object&quot;)
+				*/
+			return property.ReturnType if name == &quot;value&quot;
+			for para as IParameter in property.Parameters:
+				return para.ReturnType if para.Name == name
+			if property.Node != null:
+				varLookup = VariableLookupVisitor(Resolver: self, LookFor: name)
+				// TODO: visit only the correct body
+				print &quot;Visiting property body...&quot;
+				varLookup.Visit(property.Node.Getter) unless property.Node.Getter == null
+				varLookup.Visit(property.Node.Setter) unless property.Node.Setter == null
+				print &quot;Finished visiting property body!&quot;
+				/*
+				if varLookup.ReturnType is null:
+					print &quot;null return type!&quot;
+					return ReturnType(&quot;System.Object&quot;);
+					*/
+				print &quot;ReturnType: ${varLookup.ReturnType}&quot;
+				return varLookup.ReturnType
+		return null
+	
+	def SearchType(name as string) as IClass:
+		expandedName = BooAmbience.ReverseTypeConversionTable[name]
+		return _parserService.GetClass(_project, expandedName) if expandedName != null
+		//return _parserService.SearchType(_project, name, _callingClass, _caretLine, _caretColumn)
+		return _parserService.SearchType(_project, name, _callingClass, null)
+	
+	builtinClass as IClass
+	
+	BuiltinClass as IClass:
+		get:
+			builtinClass = _parserService.GetClass(_project, &quot;Boo.Lang.Builtins&quot;) if builtinClass == null
+			return builtinClass
+	
+	def IsNamespace(name as string) as bool:
+		return _parserService.NamespaceExists(_project, name)
+	
+	#endregion
+	
+	#region CtrlSpace-Completion
+	def CtrlSpace(parserService as IParserService, caretLine as int, caretColumn as int, fileName as string) as ArrayList:
+		_parserService = parserService
+		_caretLine = caretLine
+		_caretColumn = caretColumn
+		result = ArrayList(BooAmbience.TypeConversionTable.Values)
+		result.Add(&quot;System&quot;) // system namespace can be used everywhere
+		
+		builtinClass = self.BuiltinClass
+		if builtinClass != null:
+			for method as IMethod in builtinClass.Methods:
+				result.Add(method)
+		
+		parseInfo = parserService.GetParseInformation(fileName)
+		cu = parseInfo.MostRecentCompilationUnit as CompilationUnit
+		_compilationUnit = cu
+		if cu != null:
+			curClass = GetInnermostClass(cu) as IClass
+			_callingClass = curClass
+			if curClass != null:
+				result = AddCurrentClassMembers(result, curClass)
+				result.AddRange(parserService.GetNamespaceContents(_project, curClass.Namespace, true, true))
+			for u as IUsing in cu.Usings:
+				if u != null and (u.Region == null or u.Region.IsInside(caretLine, caretColumn)):
+					for name as string in u.Usings:
+						result.AddRange(parserService.GetNamespaceContents(_project, name, true, true))
+					for alias as string in u.Aliases.Keys:
+						result.Add(alias)
+			member = self.CurrentMember
+			Print(&quot;member&quot;, member)
+			if member != null:
+				varList as Hashtable = null
+				if member isa BooAbstractMethod:
+					method as BooAbstractMethod = member
+					for para as IParameter in method.Parameters:
+						result.Add(Field(para.ReturnType, para.Name, ModifierEnum.Private, null))
+					if method.Node != null:
+						varLookup = VariableListLookupVisitor(Resolver: self)
+						print &quot;Visiting method body...&quot;
+						varLookup.Visit(cast(BooAbstractMethod, member).Node.Body)
+						print &quot;Finished visiting method body!&quot;
+						varList = varLookup.Results
+				elif member isa Property:
+					property as Property = member
+					if property.Node != null:
+						varLookup = VariableListLookupVisitor(Resolver: self)
+						// TODO: visit only the correct body
+						print &quot;Visiting property body...&quot;
+						varLookup.Visit(property.Node.Getter) unless property.Node.Getter == null
+						varLookup.Visit(property.Node.Setter) unless property.Node.Setter == null
+						print &quot;Finished visiting property body!&quot;
+						varList = varLookup.Results
+				if varList != null:
+					for e as DictionaryEntry in varList:
+						result.Add(Field(e.Value, e.Key, ModifierEnum.Private, null))
+		result.AddRange(parserService.GetNamespaceContents(_project, &quot;&quot;, true, true))
+		return result
+	
+	def AddCurrentClassMembers(result as ArrayList, curClass as IClass) as ArrayList:
+		if self.CurrentMember != null and self.CurrentMember.IsStatic == false:
+			//result = ListMembers(result, curClass, curClass, false)
+			result = ListMembers(result, curClass)
+		// Add static members, but only from this class (not from base classes)
+		for method as IMethod in curClass.Methods:
+			result.Add(method) if (method.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static
+		for field as IField in curClass.Fields:
+			result.Add(field) if (field.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static
+		for property as IProperty in curClass.Properties:
+			result.Add(property) if (property.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static
+		for e as Event in curClass.Events:
+			result.Add(e) if (e.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static
+		return result
+	#endregion
+	
+	#region IsAsResolve
+
+	def IsAsResolve(parserService as IParserService, expression as string, caretLine as int, caretColumn as int, fileName as string, fileContent as string) as ArrayList: 
+		return null
+
+	def MonodocResolver(parserService as IParserService, expression as string, caretLine as int, caretColumn as int, fileName as string, fileContent as string) as string: 
+		return null
+
+	#region Resolve CC
+	def Initialize(parserService as IParserService, caretLine as int, caretColumn as int, fileName as string):
+		_parserService = parserService
+		_caretLine = caretLine
+		_caretColumn = caretColumn
+		
+		parseInfo = parserService.GetParseInformation(fileName)
+		cu = parseInfo.MostRecentCompilationUnit as CompilationUnit
+		_compilationUnit = cu
+		if _compilationUnit == null:
+			print &quot;BooResolver: No parse information!&quot;
+			return false
+		_callingClass = GetInnermostClass(cu)
+		if _callingClass == null:
+			return false if cu.Classes.Count == 0
+			_callingClass = cu.Classes[cu.Classes.Count - 1]
+			if _callingClass.Region != null:
+				return false if _callingClass.Region.BeginLine &gt; caretLine
+		return true
+	
+	def Resolve(parserService as IParserService, expression as string, caretLine as int, caretColumn as int, fileName as string, fileContent as string) as ResolveResult:
+		if expression == null or expression == '':
+			return null
+		
+		if expression.StartsWith(&quot;import &quot;):
+			expression = expression.Substring(7).Trim()
+			if parserService.NamespaceExists(_project, expression):
+				return ResolveResult(parserService.GetNamespaceList(_project, expression, true, true))
+			return null
+		
+		if not Initialize(parserService, caretLine, caretColumn, fileName):
+			return null
+		callingClass = _callingClass
+		returnClass as IClass = null
+		if expression == &quot;self&quot;:
+			returnClass = callingClass
+		elif expression == &quot;this&quot;:
+			// SharpDevelop uses &quot;this&quot; as expression when requesting method insight information
+			// for a method on the current class
+			returnClass = callingClass
+		elif expression == &quot;super&quot;:
+			returnClass = self.ParentClass
+		else:
+			// try looking if the expression is the name of a class
+			expressionClass = self.SearchType(expression)
+			if expressionClass != null:
+				//return ResolveResult(expressionClass, ListMembers(ArrayList(), expressionClass, callingClass, true))
+				return ResolveResult(expressionClass, ListMembers(ArrayList(), expressionClass))
+			
+			// try if it is the name of a namespace
+			if parserService.NamespaceExists(_project, expression):
+				return ResolveResult(array(string, 0), parserService.GetNamespaceContents(_project, expression, true, true))
+			
+			expr = Boo.Lang.Parser.BooParser.ParseExpression(&quot;expression&quot;, expression)
+			return null if expr isa AST.IntegerLiteralExpression
+			visitor = ExpressionTypeVisitor(Resolver : self)
+			visitor.Visit(expr)
+			retType = visitor.ReturnType
+			Print (&quot;result&quot;, retType)
+			if visitor.ReturnClass != null:
+				returnClass = visitor.ReturnClass
+			elif retType != null:
+				if retType.ArrayDimensions != null and retType.ArrayDimensions.Length &gt; 0:
+					returnClass = self.SearchType(&quot;System.Array&quot;)
+				else:
+					returnClass = self.SearchType(retType.FullyQualifiedName)
+		
+		return null if returnClass == null
+		//return ResolveResult(returnClass, ListMembers(ArrayList(), returnClass, callingClass, false))
+		return ResolveResult(returnClass, ListMembers(ArrayList(), returnClass))
+	
+	private def Print(name as string, obj):
+		Console.Write(name)
+		Console.Write(' = ')
+		if obj == null:
+			print('null')
+		else:
+			print(&quot;${obj} (${obj.GetType().FullName})&quot;)
+	#endregion
+
+	#region Code converted from CSharpBinding/Parser/Resolver.cs
+	def MustBeShowen(c as IClass, member as IDecoration) as bool:
+		// FIXME: _showStatic should be coming from elsewhere... but where? (See CSharpBinding)
+		_showStatic = false
+//		print(&quot;member:&quot; + member.Modifiers);
+		if (((not _showStatic) and  ((member.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static)) or
+		    ( _showStatic and not ((member.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static))):
+			//// enum type fields are not shown here - there is no info in member about enum field
+			return false
+		
+//		print(&quot;Testing Accessibility&quot;);
+		return IsAccessible(c, member)
+	
+	def IsAccessible(c as IClass, member as IDecoration) as bool:
+//		print(&quot;member.Modifiers = &quot; + member.Modifiers);
+		if ((member.Modifiers &amp; ModifierEnum.Internal) == ModifierEnum.Internal):
+			return true
+
+		if ((member.Modifiers &amp; ModifierEnum.Public) == ModifierEnum.Public):
+//			print(&quot;IsAccessible&quot;)
+			return true
+
+		if ((member.Modifiers &amp; ModifierEnum.Protected) == ModifierEnum.Protected and IsClassInInheritanceTree(c, _callingClass)):
+//			print(&quot;IsAccessible&quot;)
+			return true
+
+		return c.FullyQualifiedName == _callingClass.FullyQualifiedName
+
+	/// &lt;remarks&gt;
+	/// Returns true, if class possibleBaseClass is in the inheritance tree from c
+	/// &lt;/remarks&gt;
+	def IsClassInInheritanceTree(possibleBaseClass as IClass , c as IClass) as bool:
+		if (possibleBaseClass == null or c == null):
+			return false
+
+		if (possibleBaseClass.FullyQualifiedName == c.FullyQualifiedName):
+			return true
+
+		for baseClass as string in c.BaseTypes:
+			bc = _parserService.GetClass (_project, baseClass, true, true)
+			if (IsClassInInheritanceTree(possibleBaseClass, bc)):
+				return true
+
+		return false
+
+	def BaseClass(curClass as IClass) as IClass:
+		for s as string in curClass.BaseTypes:
+			baseClass = _parserService.GetClass (_project, s, true, true)
+			if ((baseClass != null) and (baseClass.ClassType != ClassType.Interface)):
+				return baseClass
+		return null
+	
+	def ListMembers(members as ArrayList, curType as IClass) as ArrayList:
+		// FIXME: _showStatic should be coming from elsewhere... but where? (See CSharpBinding)
+		_showStatic = false
+//		print(&quot;LIST MEMBERS!!!&quot;);
+//		print(&quot;_showStatic = &quot; + _showStatic);
+//		print(curType.InnerClasses.Count + &quot; classes&quot;);
+//		print(curType.Properties.Count + &quot; properties&quot;);
+//		print(curType.Methods.Count + &quot; methods&quot;);
+//		print(curType.Events.Count + &quot; events&quot;);
+//		print(curType.Fields.Count + &quot; fields&quot;);
+		if _showStatic:
+			for c as IClass in curType.InnerClasses:
+				if IsAccessible(curType, c):
+					members.Add(c)
+//					print(&quot;Member added&quot;)
+
+		for p as IProperty in curType.Properties:
+			if (MustBeShowen(curType, p)):
+				members.Add(p)
+//				print(&quot;Member added&quot;)
+
+//		print(&quot;ADDING METHODS!!!&quot;);
+		for m as IMethod in curType.Methods:
+//			print(&quot;Method : &quot; + m)
+			if (MustBeShowen(curType, m)):
+				members.Add(m)
+//				print(&quot;Member added&quot;);
+
+		for e as IEvent in curType.Events:
+			if (MustBeShowen(curType, e)):
+				members.Add(e)
+//				print(&quot;Member added&quot;);
+
+		for f as IField in curType.Fields:
+			if (MustBeShowen(curType, f)):
+				members.Add(f)
+//				print(&quot;Member added&quot;)
+			else:
+				//// enum fields must be shown here if present
+				if (curType.ClassType == ClassType.Enum):
+					members.Add(f) if (IsAccessible(curType,f))
+//					print(&quot;Member {0} added&quot;, f.FullyQualifiedName);
+
+//		print(&quot;ClassType = &quot; + curType.ClassType);
+		if (curType.ClassType == ClassType.Interface and not _showStatic):
+			for s as string in curType.BaseTypes:
+				baseClass = _parserService.GetClass (_project, s, true, true)
+				if (baseClass != null and baseClass.ClassType == ClassType.Interface):
+					ListMembers(members, baseClass)
+		else:
+			baseClass = BaseClass(curType)
+			if (baseClass != null):
+//				print(&quot;Base Class = &quot; + baseClass.FullyQualifiedName)
+				ListMembers(members, baseClass)
+
+//		print(&quot;listing finished&quot;);
+		return members;
+
+	def GetResolvedClass (cls as IClass) as IClass:
+		// Returns an IClass in which all type names have been properly resolved
+		return _parserService.GetClass (_project, cls.FullyQualifiedName);
+
+	def GetInnermostClass(cu as ICompilationUnit) as IClass:
+		if (cu != null):
+			for c as IClass in cu.Classes:
+				if (c != null and c.Region != null and c.Region.IsInside(_caretLine, _caretColumn)):
+					return GetInnermostClass(c)
+		return null;
+	
+	def GetInnermostClass(curClass as IClass) as IClass:
+		if (curClass == null):
+			return null
+
+		if (curClass.InnerClasses == null):
+			return GetResolvedClass (curClass)
+
+		for c as IClass in curClass.InnerClasses:
+			if (c != null and c.Region != null and c.Region.IsInside(_caretLine, _caretColumn)):
+				return GetInnermostClass(c)
+
+		return GetResolvedClass (curClass)

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/ReturnType.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/ReturnType.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/ReturnType.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,198 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import System
+import System.Collections
+import System.Diagnostics
+import MonoDevelop.Internal.Parser
+import MonoDevelop.Services
+import Boo.Lang.Compiler.Ast as AST
+
+/////////////////////////////////////
+///          Return Type          ///
+/////////////////////////////////////
+class ReturnType(AbstractReturnType):
+	def constructor(fullyQualifiedName as string):
+		self(fullyQualifiedName, array(int, 0), 0)
+	
+	def constructor(fullyQualifiedName as string, arrayDimensions as (int), pointerNestingLevel as int):
+		self.FullyQualifiedName = fullyQualifiedName
+		self.arrayDimensions = arrayDimensions
+		self.pointerNestingLevel = pointerNestingLevel
+	
+	def constructor(t as AST.TypeReference):
+		super.pointerNestingLevel = 0
+		if t isa AST.SimpleTypeReference:
+			super.arrayDimensions = array(int, 0)
+			name = cast(AST.SimpleTypeReference, t).Name
+			expandedName = BooBinding.BooAmbience.ReverseTypeConversionTable[name]
+			name = expandedName if expandedName != null
+			super.FullyQualifiedName = name
+		elif t isa AST.ArrayTypeReference:
+			ar as AST.ArrayTypeReference = t
+			depth = 1
+			while ar.ElementType isa AST.ArrayTypeReference:
+				depth += 1
+				ar = ar.ElementType
+			dimensions = array(int, depth)
+			for i as int in range(depth):
+				dimensions[i] = 1
+			self.arrayDimensions = dimensions
+			if ar.ElementType isa AST.SimpleTypeReference:
+				super.FullyQualifiedName = cast(AST.SimpleTypeReference, ar.ElementType).Name
+			else:
+				print (&quot;Got unknown TypeReference in Array: ${t}&quot;)
+				super.FullyQualifiedName = &quot;&lt;Error&gt;&quot;
+		else:
+			super.arrayDimensions = array(int, 0)
+			super.FullyQualifiedName = &quot;&lt;Error&gt;&quot;
+			print (&quot;Got unknown TypeReference ${t}&quot;)
+	
+	static def CreateReturnType(node as AST.Node) as IReturnType:
+		if node isa AST.Field:
+			t = (node as AST.Field).Type
+		elif node isa AST.Property:
+			t = (node as AST.Property).Type
+		elif node isa AST.Method:
+			t = (node as AST.Method).ReturnType
+		else:
+			raise &quot;Unknown node ${node.GetType().FullName}&quot;
+		str = t as AST.SimpleTypeReference
+		if (str != null and str.Name != &quot;unknown&quot;) or t isa AST.ArrayTypeReference:
+			return ReturnType(t)
+		else:
+			if node isa AST.Field:
+				return InferredReturnType((node as AST.Field).Initializer, node.LexicalInfo)
+			elif node isa AST.Property:
+				prop as AST.Property = node
+				return InferredReturnType(GetReturnExpression(prop.Getter), node.LexicalInfo)
+			elif node isa AST.Method:
+				return InferredReturnType(GetReturnExpression(node), node.LexicalInfo)
+	
+	private static def GetReturnExpression(method as AST.Method):
+		return null if method == null
+		return null if method.Body == null
+		visitor = FindReturnExpressionVisitor()
+		method.Body.Accept(visitor)
+		return visitor.Expression
+	
+	private class FindReturnExpressionVisitor(AST.DepthFirstVisitor):
+		[Getter(Expression)]
+		_expression as AST.Expression
+		
+		override def OnReturnStatement(node as AST.ReturnStatement):
+			if _expression isa AST.NullLiteralExpression or not (node.Expression isa AST.NullLiteralExpression):
+				_expression = node.Expression
+	
+	def constructor(t as AST.TypeDefinition):
+		self(t.FullName)
+	
+	def constructor(c as IClass):
+		self(c.FullyQualifiedName)
+	
+	def Clone() as ReturnType:
+		return ReturnType(FullyQualifiedName, arrayDimensions, pointerNestingLevel)
+	
+	override def ToString():
+		return &quot;[${GetType().Name} Name=${FullyQualifiedName}]&quot;
+
+/////////////////////////////////////
+///     Namespace Return Type     ///
+/////////////////////////////////////
+class NamespaceReturnType(AbstractReturnType):
+	def constructor(fullyQualifiedName as string):
+		self.FullyQualifiedName = fullyQualifiedName
+		self.arrayDimensions = array(int, 0)
+		self.pointerNestingLevel = 0
+	
+	override def ToString():
+		return &quot;[${GetType().Name} Name=${FullyQualifiedName}]&quot;
+
+/////////////////////////////////////
+///      Inferred Return Type     ///
+/////////////////////////////////////
+class InferredReturnType(AbstractReturnType):
+	_expression as AST.Expression
+	
+	_filename as string
+	_caretLine as int
+	_caretColumn as int
+	
+	def constructor(expression as AST.Expression, info as AST.LexicalInfo):
+		_expression = expression
+		if info == null or expression == null:
+			_resolved = true // don't resolve but return error
+		else:
+			_filename = info.FileName
+			_caretLine = info.Line
+			_caretColumn = info.Column
+	
+	_baseType as IReturnType
+	_resolved as bool = false
+	
+	override FullyQualifiedName as string:
+		get:
+			r = self.BaseType
+			if r == null:
+				return &quot;&lt;Error&gt;&quot;
+			else:
+				return r.FullyQualifiedName
+		set:
+			raise NotSupportedException()
+	
+	override PointerNestingLevel as int:
+		get:
+			r = self.BaseType
+			if r == null:
+				return 0
+			else:
+				return r.PointerNestingLevel
+	
+	override ArrayDimensions as (int):
+		get:
+			r = self.BaseType
+			if r == null:
+				return array(int, 0)
+			else:
+				return r.ArrayDimensions
+	
+	BaseType as IReturnType:
+		get:
+			if not _resolved:
+				_resolved = true
+				_baseType = Resolve()
+			return _baseType
+	
+	def Resolve() as IReturnType:
+		resolver = Resolver()
+		parserService = MonoDevelop.Core.Services.ServiceManager.GetService(typeof(IParserService))
+		if resolver.Initialize(parserService, _caretLine, _caretColumn, _filename):
+			visitor = ExpressionTypeVisitor(Resolver : resolver)
+			visitor.Visit(_expression)
+			return visitor.ReturnType
+		else:
+			return null

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/Tree.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/Tree.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/Tree.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,127 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import System
+import System.Collections
+import System.Diagnostics
+import MonoDevelop.Internal.Parser
+import Boo.Lang.Compiler.Ast as AST
+
+/////////////////////////////////////
+///       Compilation Unit        ///
+/////////////////////////////////////
+class CompilationUnit(AbstractCompilationUnit):
+	override MiscComments as CommentCollection:
+		get:
+			return null
+	
+	override DokuComments as CommentCollection:
+		get:
+			return null
+	
+	override TagComments as TagCollection:
+		get:
+			return null
+
+/////////////////////////////////////
+///             Class             ///
+/////////////////////////////////////
+class Class(AbstractClass):
+	_cu as ICompilationUnit
+	
+	override CompilationUnit as ICompilationUnit:
+		get:
+			return _cu
+	
+	def constructor(cu as CompilationUnit, t as ClassType, m as ModifierEnum, region as IRegion):
+		_cu = cu
+		classType = t
+		self.region = region
+		modifiers = m
+	
+	def UpdateModifier():
+		if classType == ClassType.Enum:
+			for f as Field in Fields:
+				f.AddModifier(ModifierEnum.Public)
+			
+			return
+		
+		for f as Field in Fields:
+			if f.Modifiers == ModifierEnum.None:
+				f.AddModifier(ModifierEnum.Protected)
+		
+		if classType != ClassType.Interface:
+			return
+		
+		for c as Class in InnerClasses:
+			c.modifiers = c.modifiers | ModifierEnum.Public
+		
+		for m as IMethod in Methods:
+			if m isa BooAbstractMethod:
+				cast(BooAbstractMethod, m).AddModifier(ModifierEnum.Public)
+			else:
+				Debug.Assert(false, 'Unexpected type in method of interface. Can not set modifier to public!')
+		
+		for e as Event in Events:
+			e.AddModifier(ModifierEnum.Public)
+		
+		for f as Field in Fields:
+			f.AddModifier(ModifierEnum.Public)
+		
+		for i as Indexer in Indexer:
+			i.AddModifier(ModifierEnum.Public)
+		
+		for p as Property in Properties:
+			p.AddModifier(ModifierEnum.Public)
+		
+	
+
+
+/////////////////////////////////////
+///           Parameter           ///
+/////////////////////////////////////
+class Parameter(AbstractParameter):
+	def constructor(name as string, rtype as ReturnType):
+		Name = name
+		returnType = rtype
+
+/////////////////////////////////////
+///          Attributes           ///
+/////////////////////////////////////
+class AttributeSection(AbstractAttributeSection):
+	def constructor(attributeTarget as AttributeTarget, attributes as AttributeCollection):
+		self.attributeTarget = attributeTarget
+		self.attributes = attributes
+
+class ASTAttribute(AbstractAttribute):
+	def constructor(name as string, positionalArguments as ArrayList, namedArguments as SortedList):
+		self.name = name
+		self.positionalArguments = positionalArguments
+		self.namedArguments = namedArguments
+	
+
+

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/TypeMembers.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/TypeMembers.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/TypeMembers.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,134 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import System
+import MonoDevelop.Internal.Parser
+import Boo.Lang.Compiler.Ast as AST
+
+/////////////////////////////////////
+///          Constructor          ///
+/////////////////////////////////////
+class Constructor(BooAbstractMethod):
+	def constructor(m as ModifierEnum, region as IRegion, bodyRegion as IRegion):
+		FullyQualifiedName = '#ctor'
+		self.region = region
+		self.bodyRegion = bodyRegion
+		modifiers = m
+
+
+/////////////////////////////////////
+///           Destructor          ///
+/////////////////////////////////////
+class Destructor(BooAbstractMethod):
+	def constructor(className as string, m as ModifierEnum, region as IRegion, bodyRegion as IRegion):
+		FullyQualifiedName = '~' + className
+		self.region = region
+		self.bodyRegion = bodyRegion
+		modifiers = m
+
+class BooAbstractMethod(AbstractMethod):
+	[Property(Node)]
+	_node as AST.Method
+	
+	def AddModifier(m as ModifierEnum):
+		modifiers = modifiers | m
+
+/////////////////////////////////////
+///             Event             ///
+/////////////////////////////////////
+class Event(AbstractEvent):
+	def AddModifier(m as ModifierEnum):
+		modifiers = modifiers | m
+	
+	def constructor(name as string, rtype as IReturnType, m as ModifierEnum, region as IRegion, bodyRegion as IRegion):
+		FullyQualifiedName = name
+		returnType = rtype
+		self.region = region
+		self.bodyRegion = bodyRegion
+		modifiers = m
+
+
+/////////////////////////////////////
+///             Field             ///
+/////////////////////////////////////
+class Field(AbstractField):
+	def AddModifier(m as ModifierEnum):
+		modifiers = modifiers | m
+	
+	def constructor(rtype as IReturnType, fullyQualifiedName as string, m as ModifierEnum, region as IRegion):
+		self.returnType = rtype
+		self.FullyQualifiedName = fullyQualifiedName
+		self.region = region
+		modifiers = m
+	
+	def SetModifiers(m as ModifierEnum):
+		modifiers = m
+
+
+/////////////////////////////////////
+///            Indexer            ///
+/////////////////////////////////////
+class Indexer(AbstractIndexer):
+	def AddModifier(m as ModifierEnum):
+		modifiers = modifiers | m
+	
+	def constructor(rtype as IReturnType, parameters as ParameterCollection, m as ModifierEnum, region as IRegion, bodyRegion as IRegion):
+		returnType = rtype
+		self.parameters = parameters
+		self.region = region
+		self.bodyRegion = bodyRegion
+		modifiers = m
+
+
+/////////////////////////////////////
+///            Method             ///
+/////////////////////////////////////
+class Method(BooAbstractMethod):
+	def constructor(name as string, rtype as IReturnType, m as ModifierEnum, region as IRegion, bodyRegion as IRegion):
+		FullyQualifiedName = name
+		self.returnType = rtype
+		self.region = region
+		self.bodyRegion = bodyRegion
+		modifiers = m
+
+
+/////////////////////////////////////
+///           Property            ///
+/////////////////////////////////////
+class Property(AbstractProperty):
+	[Property(Node)]
+	_node as AST.Property
+	
+	def AddModifier(m as ModifierEnum):
+		modifiers = modifiers | m
+	
+	def constructor(fullyQualifiedName as string, rtype as IReturnType, m as ModifierEnum, region as IRegion, bodyRegion as IRegion):
+		self.FullyQualifiedName = fullyQualifiedName
+		self.returnType = rtype
+		self.region = region
+		self.bodyRegion = bodyRegion
+		modifiers = m

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/VariableLookupVisitor.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/VariableLookupVisitor.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/VariableLookupVisitor.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,101 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import System
+import System.Collections
+import MonoDevelop.Internal.Parser
+import Boo.Lang.Compiler.Ast
+
+class VariableLookupVisitor(DepthFirstVisitor):
+	[Property(Resolver)]
+	_resolver as Resolver
+	
+	[Property(LookFor)]
+	_lookFor as string
+	
+	[Getter(ReturnType)]
+	_returnType as IReturnType
+	
+	private def Finish(expr as Expression):
+		return if expr == null
+		return if _returnType != null
+		visitor = ExpressionTypeVisitor(Resolver: _resolver)
+		visitor.Visit(expr)
+		_returnType = visitor.ReturnType
+	
+	private def Finish(reference as TypeReference):
+		return if _returnType != null
+		return if reference == null
+		_returnType = BooBinding.Parser.ReturnType(reference)
+	
+	override def OnDeclaration(node as Declaration):
+		return if node.Name != _lookFor
+		Finish(node.Type)
+	
+	override def OnDeclarationStatement(node as DeclarationStatement):
+		return if node.Declaration.Name != _lookFor
+		Visit(node.Declaration)
+		Finish(node.Initializer)
+	
+	override def OnBinaryExpression(node as BinaryExpression):
+		if node.Operator == BinaryOperatorType.Assign and node.Left isa ReferenceExpression:
+			reference as ReferenceExpression = node.Left
+			if reference.Name == _lookFor:
+				Finish(node.Right) unless reference isa MemberReferenceExpression
+		super(node)
+
+class VariableListLookupVisitor(DepthFirstVisitor):
+	[Property(Resolver)]
+	_resolver as Resolver
+	
+	[Getter(Results)]
+	_results as Hashtable = {}
+	
+	private def Add(name as string, expr as Expression):
+		return if name == null or expr == null
+		return if _results.ContainsKey(name)
+		visitor = ExpressionTypeVisitor(Resolver: _resolver)
+		visitor.Visit(expr)
+		_results.Add(name, visitor.ReturnType)
+	
+	private def Add(name as string, reference as TypeReference):
+		return if reference == null or name == null
+		return if _results.ContainsKey(name)
+		_results.Add(name, BooBinding.Parser.ReturnType(reference))
+	
+	override def OnDeclaration(node as Declaration):
+		Add(node.Name, node.Type)
+	
+	override def OnDeclarationStatement(node as DeclarationStatement):
+		Visit(node.Declaration)
+		Add(node.Declaration.Name, node.Initializer)
+	
+	override def OnBinaryExpression(node as BinaryExpression):
+		if node.Operator == BinaryOperatorType.Assign and node.Left isa ReferenceExpression:
+			reference as ReferenceExpression = node.Left
+			Add(reference.Name, node.Right) unless reference isa MemberReferenceExpression
+		super(node)

Added: trunk/MonoDevelop/Extras/BooBinding/Parser/Visitor.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/Visitor.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/Visitor.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,287 @@
+#region license
+// Copyright (c) 2004-2005, Daniel Grunwald (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>)
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// The BooBinding.Parser code is originally that of Daniel Grunwald
+// (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">daniel at danielgrunwald.de</A>) from the SharpDevelop BooBinding. The code has
+// been imported here, and modified, including, but not limited to, changes
+// to function with MonoDevelop, additions, refactorings, etc.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding.Parser
+
+import System
+import System.Collections
+import MonoDevelop.Services
+import MonoDevelop.Internal.Parser
+import Boo.Lang.Compiler
+import Boo.Lang.Compiler.Ast as AST
+import Boo.Lang.Compiler.IO
+import Boo.Lang.Compiler.Steps
+
+class Using(AbstractUsing):
+	pass
+
+class Visitor(AbstractVisitorCompilerStep):
+	[Getter(Cu)]
+	_cu as CompilationUnit = CompilationUnit()
+	
+	_currentClass as Stack = Stack()
+	_firstModule = true
+	
+	override def Run():
+		//print &quot;RUN&quot;
+		try:
+			Visit(CompileUnit)
+		except e:
+			print e.ToString()
+			//msg as IMessageService = ServiceManager.Services.GetService(typeof(IMessageService))
+			//msg.ShowError(e)
+	
+	private def GetModifier(m as AST.TypeMember) as ModifierEnum:
+		r = ModifierEnum.None
+		r = r | ModifierEnum.Public    if m.IsPublic
+		r = r | ModifierEnum.Protected if m.IsProtected
+		r = r | ModifierEnum.Private   if m.IsPrivate
+		r = r | ModifierEnum.Internal  if m.IsInternal
+		
+		r = r | ModifierEnum.Static   if m.IsStatic
+		r = r | ModifierEnum.Virtual  if m.IsModifierSet(AST.TypeMemberModifiers.Virtual)
+		r = r | ModifierEnum.Abstract if m.IsModifierSet(AST.TypeMemberModifiers.Abstract)
+		r = r | ModifierEnum.Override if m.IsModifierSet(AST.TypeMemberModifiers.Override)
+		
+		r = r | ModifierEnum.Final if m.IsFinal
+		return r
+	
+	[Property(LineLength)]
+	_lineLength as (int)
+	
+	private def GetLineEnd(line as int) as int:
+		return 0 if _lineLength == null or line &lt; 1 or line &gt; _lineLength.Length
+		return _lineLength[line - 1] + 1
+	
+	private def GetRegion(m as AST.Node):
+		l = m.LexicalInfo
+		return null if (l.Line &lt; 0)
+		return DefaultRegion(l.Line, 0 /*l.Column*/, l.Line, GetLineEnd(l.Line))
+	
+	private def GetClientRegion(m as AST.Node) as DefaultRegion:
+		l = m.LexicalInfo
+		return null if l.Line &lt; 0
+		l2 as AST.SourceLocation = null
+		if m isa AST.Method:
+			l2 = cast(AST.Method, m).Body.EndSourceLocation
+		elif m isa AST.Property:
+			p as AST.Property = m
+			if p.Getter != null and p.Getter.Body != null:
+				l2 = cast(AST.Property, m).Getter.Body.EndSourceLocation
+				if p.Setter != null and p.Setter.Body != null:
+					l3 = cast(AST.Property, m).Setter.Body.EndSourceLocation
+					l2 = l3 if l3.Line &gt; l2.Line
+			elif p.Setter != null and p.Setter.Body != null:
+				l2 = cast(AST.Property, m).Setter.Body.EndSourceLocation
+		else:
+			l2 = m.EndSourceLocation
+		return null if l2 == null or l2.Line &lt; 0 or l.Line == l2.Line
+		// TODO: use l.Column / l2.Column when the tab-bug has been fixed
+		return DefaultRegion(l.Line, GetLineEnd(l.Line), l2.Line, GetLineEnd(l2.Line))
+	
+	override def OnImport(p as AST.Import):
+		u = Using()
+		if p.Alias == null:
+			u.Usings.Add(p.Namespace)
+		else:
+			u.Aliases[p.Alias.Name] = p.Namespace
+		_cu.Usings.Add(u)
+	
+	override def OnCallableDefinition(node as AST.CallableDefinition):
+		//print &quot;OnCallableDefinition: ${node.FullName}&quot;
+		region = GetRegion(node)
+		modifier = GetModifier(node)
+		c = Class(_cu, ClassType.Delegate, modifier, region)
+		c.BaseTypes.Add('System.Delegate')
+		c.FullyQualifiedName = node.FullName
+		if _currentClass.Count &gt; 0:
+			cast(Class, _currentClass.Peek()).InnerClasses.Add(c)
+		else:
+			_cu.Classes.Add(c)
+		invokeMethod = Method('Invoke', ReturnType(node.ReturnType), modifier, region, region)
+		invokeMethod.Parameters = GetParameters(node.Parameters)
+		c.Methods.Add(invokeMethod)
+	
+	override def EnterClassDefinition(node as AST.ClassDefinition):
+		EnterTypeDefinition(node, ClassType.Class)
+		return super(node)
+	
+	override def EnterInterfaceDefinition(node as AST.InterfaceDefinition):
+		EnterTypeDefinition(node, ClassType.Interface)
+		return super(node)
+	
+	override def EnterEnumDefinition(node as AST.EnumDefinition):
+		EnterTypeDefinition(node, ClassType.Enum)
+		return super(node)
+	
+	override def EnterModule(node as AST.Module):
+		EnterTypeDefinition(node, ClassType.Class) unless _firstModule
+		_firstModule = false
+		return super(node)
+	
+	private def EnterTypeDefinition(node as AST.TypeDefinition, classType as ClassType):
+		try:
+			//print &quot;Enter ${node.GetType().Name} (${node.FullName})&quot;
+			region = GetClientRegion(node)
+			modifier = GetModifier(node)
+			c = Class(_cu, classType, modifier, region)
+			c.FullyQualifiedName = node.FullName
+			c.Documentation = node.Documentation
+			if _currentClass.Count &gt; 0:
+				cast(Class, _currentClass.Peek()).InnerClasses.Add(c)
+			else:
+				_cu.Classes.Add(c)
+			if node.BaseTypes != null:
+				for r as AST.SimpleTypeReference in node.BaseTypes:
+					c.BaseTypes.Add(r.Name)
+			_currentClass.Push(c)
+		except ex:
+			print ex.ToString()
+			raise
+	
+	override def LeaveClassDefinition(node as AST.ClassDefinition):
+		LeaveTypeDefinition(node)
+		super(node)
+	
+	override def LeaveInterfaceDefinition(node as AST.InterfaceDefinition):
+		LeaveTypeDefinition(node)
+		super(node)
+	
+	override def LeaveEnumDefinition(node as AST.EnumDefinition):
+		LeaveTypeDefinition(node)
+		super(node)
+	
+	override def LeaveModule(node as AST.Module):
+		LeaveTypeDefinition(node) unless _currentClass.Count == 0
+		super(node)
+	
+	private def LeaveTypeDefinition(node as AST.TypeDefinition):
+		c as Class = _currentClass.Pop()
+		//print &quot;Leave ${node.GetType().Name} ${node.FullName} (Class = ${c.FullyQualifiedName})&quot;
+		c.UpdateModifier()
+	
+	override def OnMethod(node as AST.Method):
+		try:
+			// Since we visit after ProcessMethodBodies, we may have
+			// some compiler generated methods (prefixed with ___)
+			if node.Name.StartsWith(&quot;___&quot;):
+				return
+
+			print &quot;Method: ${node.FullName}&quot;
+			method = Method(node.Name, ReturnType.CreateReturnType(node), GetModifier(node), GetRegion(node), GetClientRegion(node))
+			method.Parameters = GetParameters(node.Parameters)
+			method.Node = node
+			method.Documentation = node.Documentation
+			cast(Class, _currentClass.Peek()).Methods.Add(method)
+		except ex:
+			print ex.ToString()
+			raise
+	
+	private def GetParameters(params as AST.ParameterDeclarationCollection):
+		parameters = ParameterCollection()
+		return parameters if params == null
+		for par as AST.ParameterDeclaration in params:
+			parameters.Add(Parameter(par.Name, ReturnType(par.Type)))
+		return parameters
+	
+	override def OnConstructor(node as AST.Constructor):
+		return if node.Body.Statements.Count == 0
+		ctor = Constructor(GetModifier(node), GetRegion(node), GetClientRegion(node))
+		ctor.Parameters = GetParameters(node.Parameters)
+		ctor.Node = node
+		ctor.Documentation = node.Documentation
+		cast(Class, _currentClass.Peek()).Methods.Add(ctor)
+		
+	override def OnEnumMember(node as AST.EnumMember):
+		try:
+			c as Class = _currentClass.Peek()
+			field = Field(ReturnType(c), node.Name, GetModifier(node), GetRegion(node))
+			field.Documentation = node.Documentation
+			field.SetModifiers(ModifierEnum.Const | ModifierEnum.SpecialName)
+			c.Fields.Add(field)
+		except x:
+			print x
+			raise
+	
+	override def OnField(node as AST.Field):
+		try:
+			//print &quot;Field ${node.Name}&quot;
+			c as Class = _currentClass.Peek()
+			field = Field(ReturnType.CreateReturnType(node), node.Name, GetModifier(node), GetRegion(node))
+			field.Documentation = node.Documentation
+			c.Fields.Add(field)
+		except ex:
+			print ex.ToString()
+			raise
+	
+	override def OnProperty(node as AST.Property):
+		try:
+			property = Property(node.Name, ReturnType.CreateReturnType(node), GetModifier(node), GetRegion(node), GetClientRegion(node))
+			property.Documentation = node.Documentation
+			property.Node = node
+			cast(Class, _currentClass.Peek()).Properties.Add(property)
+		except ex:
+			print ex.ToString()
+			raise
+	
+	/*
+	// TODO: Event Declaration
+	override def Visit(eventDeclaration as AST.EventDeclaration, data as object) as object:
+		region as DefaultRegion = GetRegion(eventDeclaration.StartLocation, eventDeclaration.EndLocation)
+		bodyRegion as DefaultRegion = GetRegion(eventDeclaration.BodyStart, eventDeclaration.BodyEnd)
+		type as ReturnType = ReturnType(eventDeclaration.TypeReference)
+		c as Class = _currentClass.Peek()
+		e as Event = null
+		if eventDeclaration.VariableDeclarators != null:
+			for varDecl as ICSharpCode.SharpRefactory.Parser.AST.VariableDeclaration in eventDeclaration.VariableDeclarators:
+				e = Event(varDecl.Name, type, eventDeclaration.Modifier, region, bodyRegion)
+				c.Events.Add(e)
+			
+		else:
+			e = Event(eventDeclaration.Name, type, eventDeclaration.Modifier, region, bodyRegion)
+			c.Events.Add(e)
+		
+		return null
+	
+	// TODO: Detect indexer method and add it as Indexer
+	override def Visit(indexerDeclaration as AST.IndexerDeclaration, data as object) as object:
+		region as DefaultRegion = GetRegion(indexerDeclaration.StartLocation, indexerDeclaration.EndLocation)
+		bodyRegion as DefaultRegion = GetRegion(indexerDeclaration.BodyStart, indexerDeclaration.BodyEnd)
+		parameters as ParameterCollection = ParameterCollection()
+		i as Indexer = Indexer(ReturnType(indexerDeclaration.TypeReference), parameters, indexerDeclaration.Modifier, region, bodyRegion)
+		if indexerDeclaration.Parameters != null:
+			for par as AST.ParameterDeclarationExpression in indexerDeclaration.Parameters:
+				parType as ReturnType = ReturnType(par.TypeReference)
+				p as Parameter = Parameter(par.ParameterName, parType)
+				parameters.Add(p)
+			
+		
+		c as Class = _currentClass.Peek()
+		c.Indexer.Add(i)
+		return null
+	*/
+	
+
+

Added: trunk/MonoDevelop/Extras/BooBinding/Project/BooCompilerParameters.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Project/BooCompilerParameters.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Project/BooCompilerParameters.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,73 @@
+#region license
+// Copyright (c) 2005, Peter Johanson (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>)
+// All rights reserved.
+//
+// BooBinding is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// BooBinding is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with BooBinding; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#endregion
+
+namespace BooBinding
+
+import System
+import System.Xml
+import System.Diagnostics
+
+import MonoDevelop.Internal.Project
+import MonoDevelop.Internal.Serialization
+
+public class BooCompilerParameters:
+	[ItemProperty (&quot;compiler&quot;)]
+	compiler = BooCompiler.Booc
+
+	[ItemProperty(&quot;compilerpath&quot;)]
+	compilerpath = &quot;booc&quot;
+	
+	[ItemProperty(&quot;genwarnings&quot;)]
+	genwarnings = false
+	
+	[ItemProperty(&quot;ducky&quot;)]
+	ducky = false 
+
+	[ItemProperty(&quot;culture&quot;)]
+	culture = &quot;&quot; 
+
+	public GenWarnings as bool:
+		get:
+			return genwarnings
+		set:
+			genwarnings = value
+
+	public Compiler as BooCompiler:
+		get:
+			return compiler
+		set:
+			compiler = value
+	
+	public CompilerPath as string:
+		get:
+			return compilerpath
+		set:
+			compilerpath = value
+	
+	public Ducky as bool:
+		get:
+			return ducky
+		set:
+			ducky = value
+
+	public Culture as string:
+		get:
+			return culture
+		set:
+			culture = value

Added: trunk/MonoDevelop/Extras/BooBinding/Properties/BooShellProperties.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Properties/BooShellProperties.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Properties/BooShellProperties.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,18 @@
+
+
+namespace BooBinding.Properties
+
+import System
+
+import Gtk
+import Gdk
+
+import MonoDevelop.Gui.Widgets
+import MonoDevelop.Core.Services
+import MonoDevelop.Core.Properties
+import MonoDevelop.Services
+
+class BooShellProperties (ShellProperties):
+	override PropertyName as string:
+		get:
+			return &quot;BooBinding.BooShell.ShellProps&quot;

Added: trunk/MonoDevelop/Extras/BooBinding/Properties/ShellProperties.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Properties/ShellProperties.boo	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/Properties/ShellProperties.boo	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,58 @@
+
+
+namespace BooBinding.Properties
+
+import System
+
+import Gtk
+import Gdk
+import Pango
+
+import MonoDevelop.Gui.Widgets
+import MonoDevelop.Core.Services
+import MonoDevelop.Core.Properties
+import MonoDevelop.Services
+
+class ShellProperties:
+	private propertyService = cast (PropertyService, ServiceManager.GetService (typeof(PropertyService)))
+	private properties = cast (IProperties, propertyService.GetProperty (PropertyName, DefaultProperties()))
+
+	public virtual PropertyName as string:
+		get:
+			pass
+
+	public InternalProperties as IProperties:
+		get:
+			return properties
+	
+	FontName as string:
+		get:
+			return properties.GetProperty (&quot;Font&quot;, &quot;__default_monospace&quot;)
+		set:
+			properties.SetProperty (&quot;Font&quot;, value)
+	
+	Font as FontDescription:
+		get:
+			if FontName == &quot;__default_monospace&quot;:
+				return FontDescription.FromString (GConf.Client ().Get (&quot;/desktop/gnome/interface/monospace_font_name&quot;))
+			else:
+				return FontDescription.FromString (FontName)
+
+	
+	AutoIndentBlocks as bool:
+		get:
+			return properties.GetProperty (&quot;AutoIndentBlocks&quot;, true)
+		set:
+			properties.SetProperty (&quot;AutoIndentBlocks&quot;, value)
+	
+	ResetClearsScrollback as bool:
+		get:
+			return properties.GetProperty (&quot;ResetClearsScrollback&quot;, true)
+		set:
+			properties.SetProperty (&quot;ResetClearsScrollback&quot;, value)
+
+	ResetClearsHistory as bool:
+		get:
+			return properties.GetProperty (&quot;ResetClearsHistory&quot;, true)
+		set:
+			properties.SetProperty (&quot;ResetClearsHistory&quot;, value)

Added: trunk/MonoDevelop/Extras/BooBinding/templates/BooGtkSharpProject.xpt.xml
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/templates/BooGtkSharpProject.xpt.xml	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/templates/BooGtkSharpProject.xpt.xml	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,49 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;Template originator   = &quot;Peter Johanson&quot;
+          created      = &quot;10/13/2004&quot;
+          lastModified = &quot;10/13/2004&quot;&gt;
+
+	&lt;!-- Template Header --&gt;
+	&lt;TemplateConfiguration&gt;
+		&lt;_Name&gt;Gtk# Project&lt;/_Name&gt;
+		&lt;Category&gt;Boo&lt;/Category&gt;
+		&lt;Icon&gt;Boo.Project.Form&lt;/Icon&gt;
+		&lt;LanguageName&gt;Boo&lt;/LanguageName&gt;
+		&lt;_Description&gt;Creates a Boo/Gtk# project&lt;/_Description&gt;
+	&lt;/TemplateConfiguration&gt;
+	
+	&lt;Actions&gt;
+		&lt;Open filename = &quot;Main.boo&quot;/&gt;
+	&lt;/Actions&gt;	
+	
+	&lt;Combine name = &quot;${ProjectName}&quot; directory = &quot;.&quot;&gt;
+		&lt;Options&gt;
+			&lt;StartupProject&gt;${ProjectName}&lt;/StartupProject&gt;
+		&lt;/Options&gt;
+		
+		&lt;Project name = &quot;${ProjectName}&quot; directory = &quot;.&quot;&gt;
+			&lt;References&gt;
+				&lt;Reference type=&quot;Gac&quot; refto=&quot;gtk-sharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; /&gt;
+			&lt;/References&gt;
+			&lt;Files&gt;
+				&lt;File name=&quot;Main.boo&quot;&gt;&lt;![CDATA[// project created on ${Date} at ${Time}
+import Gtk
+
+Application.Init()
+w = MyWindow(&quot;Window&quot;)
+w.ShowAll()
+Application.Run()]]&gt;&lt;/File&gt;
+				&lt;File name=&quot;MyWindow.boo&quot;&gt;&lt;![CDATA[import System
+import Gtk
+
+class MyWindow(Window):
+	def constructor(title as string):
+		super(title)
+		SetDefaultSize(400, 300)
+		DeleteEvent += { Application.Quit() }]]&gt;&lt;/File&gt;
+			&lt;/Files&gt;
+
+		&lt;/Project&gt;
+	&lt;/Combine&gt;
+&lt;/Template&gt;
+

Added: trunk/MonoDevelop/Extras/BooBinding/templates/BooGtkSharpWindow.xft.xml
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/templates/BooGtkSharpWindow.xft.xml	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/templates/BooGtkSharpWindow.xft.xml	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,29 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;Template Originator   = &quot;Peter Johanson&quot;
+	  Language     = &quot;Boo&quot;
+	  Created      = &quot;04/04/2005&quot;
+	  LastModified = &quot;04/04/2005&quot;&gt;
+	  
+	&lt;TemplateConfiguration&gt;
+		&lt;_Name&gt;Gtk# Window&lt;/_Name&gt;
+		&lt;Icon&gt;Boo.File.Form&lt;/Icon&gt;
+		&lt;Category&gt;Boo&lt;/Category&gt;
+		&lt;LanguageName&gt;Boo&lt;/LanguageName&gt;
+		&lt;_Description&gt;Creates a top-level Gtk# window&lt;/_Description&gt;
+	&lt;/TemplateConfiguration&gt;
+	
+	&lt;TemplateFiles&gt;
+		&lt;File DefaultExtension=&quot;.boo&quot; DefaultName=&quot;CreatedWindow&quot;&gt;
+&lt;![CDATA[// created on ${Date} at ${Time}
+import System
+import Gtk
+
+class CreatedWindow(Window):
+	constructor():
+		super(&quot;CreatedWindow&quot;)
+]]&gt;&lt;/File&gt;
+	&lt;/TemplateFiles&gt;
+	
+	&lt;FileOptions/&gt;
+	
+&lt;/Template&gt;

Added: trunk/MonoDevelop/Extras/BooBinding/templates/EmptyBooFile.xft.xml
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/templates/EmptyBooFile.xft.xml	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/templates/EmptyBooFile.xft.xml	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,20 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;Template Originator=&quot;Peter Johanson&quot; Language=&quot;Boo&quot; Created=&quot;04/03/2005&quot; LastModified=&quot;04/03/2005&quot;&gt;
+	
+	&lt;TemplateConfiguration&gt;
+                &lt;_Name&gt;Empty File&lt;/_Name&gt;
+                &lt;Icon&gt;Boo.File.EmptyFile&lt;/Icon&gt;
+                &lt;Category&gt;Boo&lt;/Category&gt;
+                &lt;LanguageName&gt;Boo&lt;/LanguageName&gt;
+                &lt;_Description&gt;Creates an empty Boo file.&lt;/_Description&gt;
+	&lt;/TemplateConfiguration&gt;
+	
+	&lt;TemplateFiles&gt;
+                &lt;File DefaultExtension=&quot;.boo&quot; DefaultName=&quot;EmptyBoofile&quot;&gt;
+			&lt;![CDATA[// created on ${Date} at ${Time}]]&gt;
+		&lt;/File&gt;
+	&lt;/TemplateFiles&gt;
+	
+	&lt;FileOptions/&gt;
+	
+&lt;/Template&gt;

Added: trunk/MonoDevelop/Extras/BooBinding/templates/EmptyBooProject.xpt.xml
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/templates/EmptyBooProject.xpt.xml	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/BooBinding/templates/EmptyBooProject.xpt.xml	2005-04-26 01:27:10 UTC (rev 2480)
@@ -0,0 +1,19 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;Template originator   = &quot;Peter Johanson&quot; 
+	  created      = &quot;04/03/2005&quot;
+	  lastModified = &quot;04/03/2005&quot;&gt;
+	
+	&lt;!-- Template Header --&gt;
+	&lt;TemplateConfiguration&gt;
+                &lt;_Name&gt;Empty Project&lt;/_Name&gt;
+                &lt;Category&gt;Boo&lt;/Category&gt;
+                &lt;Icon&gt;Boo.Project.EmptyProject&lt;/Icon&gt;
+                &lt;LanguageName&gt;Boo&lt;/LanguageName&gt;
+                &lt;_Description&gt;Creates an empty Boo solution.&lt;/_Description&gt;
+	&lt;/TemplateConfiguration&gt;
+	
+	&lt;!-- Template Content --&gt;
+	&lt;Combine name = &quot;${ProjectName}&quot; directory = &quot;.&quot;&gt;
+		&lt;Project name = &quot;${ProjectName}&quot; directory = &quot;.&quot;/&gt;
+	&lt;/Combine&gt;
+&lt;/Template&gt;

Modified: trunk/MonoDevelop/Extras/Makefile.am
===================================================================
--- trunk/MonoDevelop/Extras/Makefile.am	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/Extras/Makefile.am	2005-04-26 01:27:10 UTC (rev 2480)
@@ -1,3 +1,3 @@
 
 #SUBDIRS = PythonBinding MonoQuery
-SUBDIRS = MonoQuery MonoDeveloperExtensions JavaBinding
+SUBDIRS = MonoQuery MonoDeveloperExtensions JavaBinding BooBinding 

Added: trunk/MonoDevelop/build/data/resources/icons/Boo.File.EmptyFile
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/build/data/resources/icons/Boo.File.EmptyFile
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/build/data/resources/icons/Boo.File.Form
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/build/data/resources/icons/Boo.File.Form
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/build/data/resources/icons/Boo.FileIcon
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/build/data/resources/icons/Boo.FileIcon
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/build/data/resources/icons/Boo.Project.EmptyProject
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/build/data/resources/icons/Boo.Project.EmptyProject
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/build/data/resources/icons/Boo.Project.Form
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/build/data/resources/icons/Boo.Project.Form
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/build/data/resources/icons/Boo.ProjectIcon
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/build/data/resources/icons/Boo.ProjectIcon
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/build/data/resources/icons/BooBinding.Base
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/build/data/resources/icons/BooBinding.Base
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/MonoDevelop/build/data/resources/icons/Makefile.am
===================================================================
--- trunk/MonoDevelop/build/data/resources/icons/Makefile.am	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/build/data/resources/icons/Makefile.am	2005-04-26 01:27:10 UTC (rev 2480)
@@ -2,7 +2,14 @@
 monodevelopdir = $(libdir)/monodevelop
 iconsdir = $(monodevelopdir)/data/resources/icons
 
-icons_DATA = C\#.File.EmptyFile \
+icons_DATA = BooBinding.Base \
+Boo.File.EmptyFile \
+Boo.File.Form \
+Boo.FileIcon \
+Boo.Project.EmptyProject \
+Boo.Project.Form \
+Boo.ProjectIcon \
+C\#.File.EmptyFile \
 C++.File.EmptyFile \
 C\#.File.Form \
 C++.File.Form \

Modified: trunk/MonoDevelop/configure.in
===================================================================
--- trunk/MonoDevelop/configure.in	2005-04-25 20:37:23 UTC (rev 2479)
+++ trunk/MonoDevelop/configure.in	2005-04-26 01:27:10 UTC (rev 2480)
@@ -113,6 +113,20 @@
 		enable_java=no)
 AM_CONDITIONAL(ENABLE_JAVA, test x$enable_java = xyes)
 
+BOO_REQUIRED_VERSION=0.5.2.99
+AC_ARG_ENABLE(boo,
+	AC_HELP_STRING([--enable-boo],
+		[enable support for boo [default=no]]),
+		[PKG_CHECK_MODULES(BOO, boo &gt;= $BOO_REQUIRED_VERSION, enable_boo=yes, enable_boo=no)],
+		enable_boo=no)
+
+AM_CONDITIONAL(ENABLE_BOO, test x$enable_boo = xyes)
+AC_SUBST(BOO_LIBS)
+
+if test &quot;x$enable_boo&quot; = &quot;xyes&quot; ; then
+	AC_PATH_PROG(BOOC, booc)
+fi
+
 MOZILLA_HOME=&quot;`$PKG_CONFIG --variable=libdir mozilla-gtkmozembed`&quot;
 AC_SUBST(MOZILLA_HOME)
 
@@ -216,6 +230,7 @@
 Extras/MonoQuery/MonoQuery.addin.xml
 Extras/MonoDeveloperExtensions/Makefile
 Extras/JavaBinding/Makefile
+Extras/BooBinding/Makefile
 contrib/Makefile
 ])
 
@@ -231,4 +246,5 @@
 echo &quot;   *   MySQL:        yes&quot;
 echo &quot;   *   SQLite:       $enable_monoquery_sqlite&quot;
 echo &quot;   * java support: $enable_java&quot;
+echo &quot;   * boo support: $enable_boo&quot;
 echo &quot;&quot;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002080.html">[Monodevelop-patches-list] r2479 - trunk/MonoDevelop/Extras/MonoDeveloperExtensions
</A></li>
	<LI>Next message: <A HREF="002082.html">[Monodevelop-patches-list] r2482 - trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2081">[ date ]</a>
              <a href="thread.html#2081">[ thread ]</a>
              <a href="subject.html#2081">[ subject ]</a>
              <a href="author.html#2081">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
