<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2413 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2413%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn%3A%20.%20Gui&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002014.html">
   <LINK REL="Next"  HREF="002016.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2413 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui</H1>
    <B>Chris Toshok</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2413%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn%3A%20.%20Gui&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2413 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui">toshok at mono-cvs.ximian.com
       </A><BR>
    <I>Fri Apr  1 18:21:10 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002014.html">[Monodevelop-patches-list] r2412 - trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/tests
</A></li>
        <LI>Next message: <A HREF="002016.html">[Monodevelop-patches-list] r2414 - in trunk/MonoDevelop: . Core/src/MonoDevelop.Base Core/src/MonoDevelop.Base/Commands Core/src/MonoDevelop.Base/Commands/VBConverter Core/src/MonoDevelop.Base/Gui/BrowserDisplayBinding Core/src/MonoDevelop.Base/Gui/Dialogs Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog Core/src/MonoDevelop.Base/Gui/Dialogs/Wizard Core/src/MonoDevelop.Base/Gui/HtmlControl Core/src/MonoDevelop.Base/Gui/Pads/FileScout Core/src/MonoDevelop.Base/Gui/Pads/HelpBrowser Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder Core/src/MonoDevelop.Base/Gui/Pads/PropertyPad Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad Core/src/MonoDevelop.Base/Gui/Workbench Core/src/MonoDevelop.Base/Gui/Workbench/Layouts Core/src/MonoDevelop.Base/Internal/ExternalTool Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer Core/src/MonoDevelop.Base/Internal/ProgressMonitoring Core/src/MonoDevelop.Base/Internal/Project/Combin e Core/src/MonoDevelop.Base/Internal/Project/Project Core/src/MonoDevelop.Base/Internal/Templates Core/src/MonoDevelop.Base/Services Core/src/MonoDevelop.Base/Services/DispatchService Core/src/MonoDevelop.Base/Services/DisplayBinding Core/src/MonoDevelop.Base/Services/ParserService Core/src/MonoDevelop.Startup contrib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2015">[ date ]</a>
              <a href="thread.html#2015">[ thread ]</a>
              <a href="subject.html#2015">[ subject ]</a>
              <a href="author.html#2015">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: toshok
Date: 2005-04-01 18:21:09 -0500 (Fri, 01 Apr 2005)
New Revision: 2413

Added:
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/LocalsPad.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/StackTracePad.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/ThreadPad.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/VariablePad.cs
Removed:
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerLocalsPad.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerStackTracePad.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerThreadPad.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs
Modified:
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/MonoDevelopDebugger.addin.xml
Log:
2005-04-01  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;

        * Gui/Debugger*Pad.cs: rename to Gui/*Pad.cs (drop the
        &quot;Debugger&quot;).
        
        * Makefile.am (FILES): track Pad filename changes.

        * MonoDevelopDebugger.addin.xml: same.

2005-03-31  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;



Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog	2005-04-01 23:00:27 UTC (rev 2412)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog	2005-04-01 23:21:09 UTC (rev 2413)
@@ -1,3 +1,12 @@
+2005-04-01  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;
+
+	* Gui/Debugger*Pad.cs: rename to Gui/*Pad.cs (drop the
+	&quot;Debugger&quot;).
+	
+	* Makefile.am (FILES): track Pad filename changes.
+
+	* MonoDevelopDebugger.addin.xml: same.
+
 2005-03-31  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;
 
 	* Gui/DebuggerVariablePad.cs: use Runtime.Gui.Icons and

Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerLocalsPad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerLocalsPad.cs	2005-04-01 23:00:27 UTC (rev 2412)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerLocalsPad.cs	2005-04-01 23:21:09 UTC (rev 2413)
@@ -1,65 +0,0 @@
-using System;
-using MonoDevelop.Gui;
-
-namespace MonoDevelop.Debugger
-{
-	public class DebuggerLocalsPad : DebuggerVariablePad, IPadContent
-	{
-
-		public DebuggerLocalsPad () : base (true)
-		{
-		}
-
-		public Gtk.Widget Control {
-			get {
-				return this;
-			}
-		}
-
-		public string Id {
-			get { return &quot;MonoDevelop.Debugger.DebuggerLocalsPad&quot;; }
-		}
-
-		public string DefaultPlacement {
-			get { return &quot;Bottom&quot;; }
-		}
-
-		public string Title {
-			get {
-				return &quot;Locals&quot;;
-			}
-		}
-
-		public string Icon {
-			get {
-				return MonoDevelop.Gui.Stock.OutputIcon;
-			}
-		}
-
-		public void RedrawContent ()
-		{
-			UpdateDisplay ();
-		}
-
-		public void BringToFront ()
-		{
-		}
-
-                protected virtual void OnTitleChanged(EventArgs e)
-                {
-                        if (TitleChanged != null) {
-                                TitleChanged(this, e);
-                        }
-                }
-                protected virtual void OnIconChanged(EventArgs e)
-                {
-                        if (IconChanged != null) {
-                                IconChanged(this, e);
-                        }
-                }
-                public event EventHandler TitleChanged;
-                public event EventHandler IconChanged;
-
-
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerStackTracePad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerStackTracePad.cs	2005-04-01 23:00:27 UTC (rev 2412)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerStackTracePad.cs	2005-04-01 23:21:09 UTC (rev 2413)
@@ -1,145 +0,0 @@
-using GLib;
-using Gtk;
-using GtkSharp;
-using System;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.InteropServices;
-using Mono.Debugger;
-using Mono.Debugger.Languages;
-
-using MonoDevelop.Core.Services;
-using MonoDevelop.Services;
-using MonoDevelop.Gui;
-
-namespace MonoDevelop.Debugger
-{
-	public class DebuggerStackTracePad : Gtk.ScrolledWindow, IPadContent
-	{
-		StackFrame current_frame;
-
-		Gtk.TreeView tree;
-		Gtk.TreeStore store;
-
-		public DebuggerStackTracePad ()
-		{
-			this.ShadowType = ShadowType.In;
-
-			store = new TreeStore (typeof (string));
-
-			tree = new TreeView (store);
-			tree.RulesHint = true;
-			tree.HeadersVisible = true;
-
-			TreeViewColumn FrameCol = new TreeViewColumn ();
-			CellRenderer FrameRenderer = new CellRendererText ();
-			FrameCol.Title = &quot;Frame&quot;;
-			FrameCol.PackStart (FrameRenderer, true);
-			FrameCol.AddAttribute (FrameRenderer, &quot;text&quot;, 0);
-			FrameCol.Resizable = true;
-			FrameCol.Alignment = 0.0f;
-			tree.AppendColumn (FrameCol);
-
-			Add (tree);
-			ShowAll ();
-
-			Runtime.DebuggingService.PausedEvent += new EventHandler (OnPausedEvent);
-			Runtime.DebuggingService.ResumedEvent += new EventHandler (OnResumedEvent);
-			Runtime.DebuggingService.StoppedEvent += new EventHandler (OnStoppedEvent);
-		}
-
-		public void UpdateDisplay ()
-		{
-			if ((current_frame == null) || (current_frame.Method == null))
-				return;
-
-			string[] trace = Runtime.DebuggingService.Backtrace;
-
-			TreeIter it;
-			if (!store.GetIterFirst (out it)) {
-				foreach (string frame in trace) {
-					store.Append (out it);
-					store.SetValue (it, 0, frame);
-				}
-			}
-			else {
-				for (int i = 0; i &lt; trace.Length; i ++) {
-					store.SetValue (it, 0, trace[i]);
-					if (i &lt; trace.Length - 1 &amp;&amp; !store.IterNext (ref it))
-						store.Append (out it);
-				}
-				/* clear any remaining rows */
-				if (store.IterNext (ref it))
-					do { } while (store.Remove (ref it));
-			}
-		}
-
-		protected void OnStoppedEvent (object o, EventArgs args)
-		{
-			UpdateDisplay ();
-		}
-
-		protected void OnResumedEvent (object o, EventArgs args)
-		{
-			UpdateDisplay ();
-		}
-
-		protected void OnPausedEvent (object o, EventArgs args)
-		{
-			current_frame = (StackFrame)Runtime.DebuggingService.CurrentFrame;
-			UpdateDisplay ();
-		}
-
-		public Gtk.Widget Control {
-			get {
-				return this;
-			}
-		}
-
-		public string Id {
-			get { return &quot;MonoDevelop.Debugger.DebuggerStackTracePad&quot;; }
-		}
-
-		public string DefaultPlacement {
-			get { return &quot;Bottom&quot;; }
-		}
-
-		public string Title {
-			get {
-				return &quot;Call Stack&quot;;
-			}
-		}
-
-		public string Icon {
-			get {
-				return MonoDevelop.Gui.Stock.OutputIcon;
-			}
-		}
-
-		public void RedrawContent ()
-		{
-			UpdateDisplay ();
-		}
-
-		public void BringToFront ()
-		{
-		}
-
-                protected virtual void OnTitleChanged(EventArgs e)
-                {
-                        if (TitleChanged != null) {
-                                TitleChanged(this, e);
-                        }
-                }
-                protected virtual void OnIconChanged(EventArgs e)
-                {
-                        if (IconChanged != null) {
-                                IconChanged(this, e);
-                        }
-                }
-                public event EventHandler TitleChanged;
-                public event EventHandler IconChanged;
-	  
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerThreadPad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerThreadPad.cs	2005-04-01 23:00:27 UTC (rev 2412)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerThreadPad.cs	2005-04-01 23:21:09 UTC (rev 2413)
@@ -1,217 +0,0 @@
-using GLib;
-using Gtk;
-using GtkSharp;
-using System;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.InteropServices;
-using Mono.Debugger;
-using Mono.Debugger.Languages;
-
-using MonoDevelop.Core.Services;
-using MonoDevelop.Services;
-using MonoDevelop.Gui;
-
-namespace MonoDevelop.Debugger
-{
-	public class DebuggerThreadPad : Gtk.ScrolledWindow, IPadContent
-	{
-		Gtk.TreeView tree;
-		Gtk.TreeStore store;
-		Hashtable thread_rows;
-
-		public DebuggerThreadPad ()
-		{
-			thread_rows = new Hashtable ();
-
-			this.ShadowType = ShadowType.In;
-
-			store = new TreeStore (typeof (int),
-					       typeof (int),
-					       typeof (string),
-					       typeof (string));
-
-			tree = new TreeView (store);
-			tree.RulesHint = true;
-			tree.HeadersVisible = true;
-
-			TreeViewColumn Col;
-			CellRenderer ThreadRenderer;
-
-			Col = new TreeViewColumn ();
-			ThreadRenderer = new CellRendererText ();
-			Col.Title = &quot;Id&quot;;
-			Col.PackStart (ThreadRenderer, true);
-			Col.AddAttribute (ThreadRenderer, &quot;text&quot;, 0);
-			Col.Resizable = true;
-			Col.Alignment = 0.0f;
-			tree.AppendColumn (Col);
-
-			Col = new TreeViewColumn ();
-			ThreadRenderer = new CellRendererText ();
-			Col.Title = &quot;PID&quot;;
-			Col.PackStart (ThreadRenderer, true);
-			Col.AddAttribute (ThreadRenderer, &quot;text&quot;, 1);
-			Col.Resizable = true;
-			Col.Alignment = 0.0f;
-			tree.AppendColumn (Col);
-
-			Col = new TreeViewColumn ();
-			ThreadRenderer = new CellRendererText ();
-			Col.Title = &quot;State&quot;;
-			Col.PackStart (ThreadRenderer, true);
-			Col.AddAttribute (ThreadRenderer, &quot;text&quot;, 2);
-			Col.Resizable = true;
-			Col.Alignment = 0.0f;
-			tree.AppendColumn (Col);
-
-			Col = new TreeViewColumn ();
-			ThreadRenderer = new CellRendererText ();
-			Col.Title = &quot;Current Location&quot;;
-			Col.PackStart (ThreadRenderer, true);
-			Col.AddAttribute (ThreadRenderer, &quot;text&quot;, 3);
-			Col.Resizable = true;
-			Col.Alignment = 0.0f;
-			tree.AppendColumn (Col);
-
-			Add (tree);
-			ShowAll ();
-
-			((DebuggingService)Runtime.DebuggingService).ThreadStateEvent += new EventHandler (OnThreadEvent);
-		}
-
-		void AddThread (Process thread)
-		{
-			TreeIter iter;
-			store.Append (out iter);
-			store.SetValue (iter, 0, new GLib.Value (thread.ID));
-			store.SetValue (iter, 1, new GLib.Value (thread.PID));
-			store.SetValue (iter, 2, new GLib.Value (thread.State.ToString()));
-			if (thread.IsStopped)
-				store.SetValue (iter, 3, new GLib.Value (thread.GetBacktrace().Frames[0].SourceAddress.Name));
-			else
-				store.SetValue (iter, 3, new GLib.Value (&quot;&quot;));
-			thread_rows.Add (thread, new TreeRowReference (store, store.GetPath (iter)));
-		}
-
-		void UpdateThread (Process thread)
-		{
-			TreeRowReference row = (TreeRowReference)thread_rows[thread];
-			TreeIter iter;
-
-			if (row != null &amp;&amp; store.GetIter (out iter, row.Path)) {
-				if (thread.ID != (int)store.GetValue (iter, 0))
-					store.SetValue (iter, 0, thread.ID);
-				if (thread.PID != (int)store.GetValue (iter, 1))
-					store.SetValue (iter, 1, thread.PID);
-				if (thread.State.ToString() != (string)store.GetValue (iter, 2))
-					store.SetValue (iter, 2, thread.State.ToString());
-
-				string location;
-				if (thread.IsStopped)
-					location = thread.GetBacktrace().Frames[0].SourceAddress.Name;
-				else
-					location = &quot;&quot;;
-
-				if (location != (string)store.GetValue (iter, 3))
-					store.SetValue (iter, 3, location);
-			}
-			else {
-				AddThread (thread);
-			}
-		}
-
-		void RemoveThread (Process thread)
-		{
-			TreeRowReference row = (TreeRowReference)thread_rows[thread];
-			TreeIter iter;
-
-			if (row != null &amp;&amp; store.GetIter (out iter, row.Path))
-				store.Remove (ref iter);
-
-			thread_rows.Remove (thread);
-		}
-
-		public void UpdateDisplay ()
-		{
-			Hashtable threads_to_remove = new Hashtable();
-
-			foreach (Process thread in thread_rows.Keys) {
-				threads_to_remove.Add (thread, thread);
-			}
-
-			foreach (Process t in ((DebuggingService)Runtime.DebuggingService).Threads) {
-				if (!t.IsDaemon) {
-					UpdateThread (t);
-					threads_to_remove.Remove (t);
-				}
-			}
-
-			foreach (Process t in threads_to_remove.Keys) {
-				RemoveThread (t);
-			}
-		}
-
-		public void CleanDisplay ()
-		{
-			UpdateDisplay ();
-		}
-
-		public void RedrawContent ()
-		{
-			UpdateDisplay ();
-		}
-
-		public void BringToFront ()
-		{
-		}
-
-		protected void OnThreadEvent (object o, EventArgs args)
-		{
-			UpdateDisplay ();
-		}
-
-		public Gtk.Widget Control {
-			get {
-				return this;
-			}
-		}
-
-		public string Id {
-			get { return &quot;MonoDevelop.Debugger.DebuggerThreadPad&quot;; }
-		}
-
-		public string DefaultPlacement {
-			get { return &quot;Bottom&quot;; }
-		}
-
-		public string Title {
-			get {
-				return &quot;Threads&quot;;
-			}
-		}
-
-		public string Icon {
-			get {
-				return MonoDevelop.Gui.Stock.OutputIcon;
-			}
-		}
-
-                protected virtual void OnTitleChanged(EventArgs e)
-                {
-                        if (TitleChanged != null) {
-                                TitleChanged(this, e);
-                        }
-                }
-                protected virtual void OnIconChanged(EventArgs e)
-                {
-                        if (IconChanged != null) {
-                                IconChanged(this, e);
-                        }
-                }
-                public event EventHandler TitleChanged;
-                public event EventHandler IconChanged;
-	  
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs	2005-04-01 23:00:27 UTC (rev 2412)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs	2005-04-01 23:21:09 UTC (rev 2413)
@@ -1,660 +0,0 @@
-using GLib;
-using Gtk;
-using GtkSharp;
-using System;
-using System.Diagnostics;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Text;
-using System.Reflection;
-using System.Runtime.InteropServices;
-using Mono.Debugger;
-using Mono.Debugger.Languages;
-
-using Stock = MonoDevelop.Gui.Stock;
-using MonoDevelop.Core.Services;
-using MonoDevelop.Internal.Parser;
-using MonoDevelop.Services;
-
-namespace MonoDevelop.Debugger
-{
-	public class DebuggerVariablePad : Gtk.ScrolledWindow
-	{
-		Mono.Debugger.StackFrame current_frame;
-
-		Hashtable variable_rows;
-		Hashtable iters;
-
-		Gtk.TreeView tree;
-		Gtk.TreeStore store;
-		bool is_locals_display;
-
-		internal const int NAME_COL = 0;
-		internal const int VALUE_COL = 1;
-		internal const int TYPE_COL = 2;
-		internal const int RAW_VIEW_COL = 3;
-		internal const int PIXBUF_COL = 4;
-
-		public DebuggerVariablePad (bool is_locals_display)
-		{
-			this.ShadowType = ShadowType.In;
-
-			this.is_locals_display = is_locals_display;
-
-			variable_rows = new Hashtable();
-			iters = new Hashtable();
-
-			store = new TreeStore (typeof (string),
-					       typeof (string),
-			                       typeof (string),
-					       typeof (bool),
-					       typeof (Gdk.Pixbuf));
-
-			tree = new TreeView (store);
-			tree.RulesHint = true;
-			tree.HeadersVisible = true;
-
-			TreeViewColumn NameCol = new TreeViewColumn ();
-			CellRenderer NameRenderer = new CellRendererText ();
-			CellRenderer IconRenderer = new CellRendererPixbuf ();
-			NameCol.Title = &quot;Name&quot;;
-			NameCol.PackStart (IconRenderer, false);
-			NameCol.PackStart (NameRenderer, true);
-			NameCol.AddAttribute (IconRenderer, &quot;pixbuf&quot;, PIXBUF_COL);
-			NameCol.AddAttribute (NameRenderer, &quot;text&quot;, NAME_COL);
-			NameCol.Resizable = true;
-			NameCol.Alignment = 0.0f;
-			tree.AppendColumn (NameCol);
-
-			TreeViewColumn ValueCol = new TreeViewColumn ();
-			CellRenderer ValueRenderer = new CellRendererText ();
-			ValueCol.Title = &quot;Value&quot;;
-			ValueCol.PackStart (ValueRenderer, true);
-			ValueCol.AddAttribute (ValueRenderer, &quot;text&quot;, VALUE_COL);
-			ValueCol.Resizable = true;
-			NameCol.Alignment = 0.0f;
-			tree.AppendColumn (ValueCol);
-
-			TreeViewColumn TypeCol = new TreeViewColumn ();
-			CellRenderer TypeRenderer = new CellRendererText ();
-			TypeCol.Title = &quot;Type&quot;;
-			TypeCol.PackStart (TypeRenderer, true);
-			TypeCol.AddAttribute (TypeRenderer, &quot;text&quot;, TYPE_COL);
-			TypeCol.Resizable = true;
-			NameCol.Alignment = 0.0f;
-			tree.AppendColumn (TypeCol);
-
-			tree.TestExpandRow += new TestExpandRowHandler (TestExpandRow);
-
-			Add (tree);
-			ShowAll ();
-
-			Runtime.DebuggingService.PausedEvent += new EventHandler (OnPausedEvent);
-			Runtime.DebuggingService.StoppedEvent += new EventHandler (OnStoppedEvent);
-		}
-
-		bool InsertArrayChildren (TreeIter parent, ITargetArrayObject array)
-		{
-			bool inserted = false;
-
-			for (int i = array.LowerBound; i &lt; array.UpperBound; i++) {
-
-				inserted = true;
-
-				ITargetObject elt = array [i];
-				if (elt == null)
-					continue;
-
-				TreeIter iter = store.Append (parent);
-				AddObject (i.ToString (), &quot;&quot; /* XXX */, elt, iter);
-			}
-
-			return inserted;
-		}
-
-		bool InsertStructMember (TreeIter parent, ITargetStructObject sobj, ITargetMemberInfo member, bool is_field)
-		{
-			bool inserted = false;
-
-			string icon_name = GetIcon (member);
-
-#if NET_2_0
-			DebuggerBrowsableAttribute battr = GetDebuggerBrowsableAttribute (member);
-			if (battr != null) {
-				TreeIter iter;
-
-				switch (battr.State) {
-				case DebuggerBrowsableState.Never:
-					// don't display it at all
-					continue;
-				case DebuggerBrowsableState.Collapsed:
-					// the default behavior for the debugger (c&amp;p from above)
-					iter = store.Append (parent);
-					AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
-						   iter);
-					inserted = true;
-					break;
-				case DebuggerBrowsableState.Expanded:
-					// add it as in the Collapsed case...
-					iter = store.Append (parent);
-					AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
-						   iter);
-					inserted = true;
-					// then expand the row
-					tree.ExpandRow (store.GetPath (iter), false);
-					break;
-				case DebuggerBrowsableState.RootHidden:
-					ITargetObject member_obj = is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index);
-
-					if (member_obj != null) {
-						switch (member_obj.TypeInfo.Type.Kind) {
-						case TargetObjectKind.Array:
-							iter = store.Append (parent);
-							// handle arrays normally, should check how vs2005 does this.
-							AddObject (member.Name, icon_name, member_obj, iter);
-							inserted = true;
-							break;
-						case TargetObjectKind.Class:
-							try {
-								inserted = InsertClassChildren (parent, (ITargetClassObject)member_obj, false);
-							}
-							catch {
-								// what about this case?  where the member is possibly
-								// uninitialized, do we try to add it later?
-							}
-							break;
-						case TargetObjectKind.Struct:
-							try {
-								inserted = InsertStructChildren (parent, (ITargetStructObject)member_obj, false);
-							}
-							catch {
-								// what about this case?  where the member is possibly
-								// uninitialized, do we try to add it later?
-							}
-							break;
-						default:
-							// nothing
-							break;
-						}
-					}
-					break;
-				}
-			}
-			else {
-#endif
-				TreeIter iter = store.Append (parent);
-				AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
-					   iter);
-				inserted = true;
-#if NET_2_0
-			}
-#endif
-
-			return inserted;
-		}
-
-#if NET_2_0
-		bool InsertProxyChildren (DebuggingService dbgr, DebuggerTypeProxyAttribute pattr, TreeIter parent, ITargetStructObject sobj)
-		{
-			Mono.Debugger.StackFrame frame = dbgr.MainThread.CurrentFrame;
-	 		ITargetStructType proxy_type = frame.Language.LookupType (frame, pattr.ProxyTypeName) as ITargetStructType;
-			if (proxy_type == null)
-				proxy_type = frame.Language.LookupType (frame,
-									sobj.Type.Name + &quot;+&quot; + pattr.ProxyTypeName) as ITargetStructType;
-			if (proxy_type != null) {
-				string name = String.Format (&quot;.ctor({0})&quot;, sobj.Type.Name);
-				ITargetMethodInfo method = null;
-
-				foreach (ITargetMethodInfo m in proxy_type.Constructors) {
-					if (m.FullName == name)
-						method = m;
-				}
-
-				if (method != null) {
-					ITargetFunctionObject ctor = proxy_type.GetConstructor (frame, method.Index);
-					ITargetObject[] args = new ITargetObject[1];
-					args[0] = sobj;
-
-					ITargetStructObject proxy_obj = ctor.Type.InvokeStatic (frame, args, false) as ITargetStructObject;
-
-					if (proxy_obj != null) {
-						foreach (ITargetPropertyInfo prop in proxy_obj.Type.Properties) {
-							InsertStructMember (parent, proxy_obj, prop, false);
-						}
-
-						TreeIter iter = store.Append (parent);
-						store.SetValue (iter, NAME_COL, &quot;Raw View&quot;);
-						store.SetValue (iter, RAW_VIEW_COL, true);
-
-						Gdk.Pixbuf icon = Runtime.Gui.Resources.GetIcon (Stock.Class, Gtk.IconSize.Menu);
-						if (icon != null)
-							store.SetValue (iter, PIXBUF_COL, icon);
-
-						iters.Remove (iter);
-						AddPlaceholder (sobj, iter);
-
-						return true;
-					}
-				}
-			}
-
-			return false;
-		}
-#endif
-
-		bool InsertStructChildren (TreeIter parent, ITargetStructObject sobj, bool raw_view)
-		{
-			bool inserted = false;
-
-#if NET_2_0
-			if (!raw_view) {
-				DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
-				DebuggerTypeProxyAttribute pattr = GetDebuggerTypeProxyAttribute (dbgr, sobj);
-
-				if (pattr != null) {
-					if (InsertProxyChildren (dbgr, pattr, parent, sobj))
-						inserted = true;
-				}
-			}
-#endif
-
-			foreach (ITargetFieldInfo field in sobj.Type.Fields) {
-				if (InsertStructMember (parent, sobj, field, true))
-					inserted = true;
-			}
-
-			foreach (ITargetPropertyInfo prop in sobj.Type.Properties) {
-				if (InsertStructMember (parent, sobj, prop, false))
-					inserted = true;
-			}
-
-			return inserted;
-		}
-
-		bool InsertClassChildren (TreeIter parent, ITargetClassObject sobj, bool raw_view)
-		{
-			bool inserted = false;
-
-			if (sobj.Type.HasParent) {
-				TreeIter iter = store.Append (parent);
-				AddObject (&quot;&lt;parent&gt;&quot;, Stock.Class, sobj.Parent, iter);
-				inserted = true;
-			}
-
-			if (InsertStructChildren (parent, sobj, raw_view))
-				inserted = true;
-
-			return inserted;
-		}
-
-		void InsertMessage (TreeIter parent, string message)
-		{
-			TreeIter child;
-			if (store.IterChildren (out child, parent)) {
-				while (!(child.Equals (Gtk.TreeIter.Zero)) &amp;&amp; (child.Stamp != 0))
-					store.Remove (ref child);
-			}
-
-			TreeIter iter = store.Append (parent);
-			store.SetValue (iter, VALUE_COL, message);
-		}
-
-		void TestExpandRow (object o, TestExpandRowArgs args)
-		{
-			bool inserted = false;
-
-			ITargetObject obj = (ITargetObject) iters [args.Iter];
-
-			TreeIter child;
-			if (store.IterChildren (out child, args.Iter)) {
-				while (!(child.Equals (Gtk.TreeIter.Zero)) &amp;&amp; (child.Stamp != 0))
-					store.Remove (ref child);
-			}
-
-			if (obj == null) {
-				child = store.Append (args.Iter);
-				return;
-			}
-
-			switch (obj.TypeInfo.Type.Kind) {
-			case TargetObjectKind.Array:
-				ITargetArrayObject array = (ITargetArrayObject) obj;
-				try {
-					inserted = InsertArrayChildren (args.Iter, array);
-				} catch {
-					InsertMessage (args.Iter, &quot;&lt;can't display array&gt;&quot;);
-					inserted = true;
-				}
-				if (!inserted)
-					InsertMessage (args.Iter, &quot;&lt;empty array&gt;&quot;);
-				break;
-
-			case TargetObjectKind.Class:
-				ITargetClassObject cobj = (ITargetClassObject) obj;
-				try {
-					bool raw_view = (bool)store.GetValue (args.Iter, RAW_VIEW_COL);
-					inserted = InsertClassChildren (args.Iter, cobj, raw_view);
-				} catch (Exception e) {
-				  Console.WriteLine (e);
-					InsertMessage (args.Iter, &quot;&lt;can't display class&gt;&quot;);
-					inserted = true;
-				}
-				if (!inserted)
-					InsertMessage (args.Iter, &quot;&lt;empty class&gt;&quot;);
-				break;
-
-			case TargetObjectKind.Struct:
-				ITargetStructObject sobj = (ITargetStructObject) obj;
-				try {
-					bool raw_view = (bool)store.GetValue (args.Iter, RAW_VIEW_COL);
-					inserted = InsertStructChildren (args.Iter, sobj, raw_view);
-				} catch {
-					InsertMessage (args.Iter, &quot;&lt;can't display struct&gt;&quot;);
-					inserted = true;
-				}
-				if (!inserted)
-					InsertMessage (args.Iter, &quot;&lt;empty struct&gt;&quot;);
-				break;
-
-			default:
-				InsertMessage (args.Iter, &quot;&lt;unknown object&gt;&quot;);
-				break;
-			}
-		}
-
-		void AddPlaceholder (ITargetObject obj, TreeIter parent)
-		{
-			if (obj.TypeInfo.Type.Kind == TargetObjectKind.Array) {
-				ITargetArrayObject array = (ITargetArrayObject) obj;
-				if (array.LowerBound == array.UpperBound)
-					return;
-			}
-
-			store.Append (parent);
-			iters.Add (parent, obj);
-		}
-
-		string GetObjectValueString (ITargetObject obj)
-		{
-			if (obj == null) {
-				return &quot;null&quot;;
-			}
-
-			switch (obj.TypeInfo.Type.Kind) {
-			case TargetObjectKind.Fundamental:
-				object contents = ((ITargetFundamentalObject) obj).Object;
-				return contents.ToString ();
-
-			case TargetObjectKind.Array:
-				ITargetArrayObject array = (ITargetArrayObject) obj;
-				if (array.LowerBound == array.UpperBound &amp;&amp; array.LowerBound == 0)
-					return &quot;[]&quot;;
-				else
-					return &quot;&quot;;
-
-			case TargetObjectKind.Struct:
-			case TargetObjectKind.Class:
-				try {
-#if NET_2_0
-					DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
-					DebuggerDisplayAttribute dattr = GetDebuggerDisplayAttribute (dbgr, obj);
-					if (dattr != null) {
-						return dbgr.AttributeHandler.EvaluateDebuggerDisplay (obj, dattr.Value);
-					}
-					else {
-#endif
-						// call the object's ToString() method.
-						return ((ITargetStructObject)obj).PrintObject();
-#if NET_2_0
-					}
-#endif
-				}
-				catch (Exception e) {
-				  //Console.WriteLine (&quot;getting object value failed: {0}&quot;, e);
-					return &quot;&quot;;
-				}
-			default:
-				return &quot;&quot;;
-			}
-		}
-
-		void AddObject (string name, string icon_name, ITargetObject obj, TreeIter iter)
-		{
-			store.SetValue (iter, NAME_COL, name);
-			store.SetValue (iter, VALUE_COL, GetObjectValueString (obj));
-			store.SetValue (iter, TYPE_COL,
-					obj == null ? &quot;&quot; : Runtime.Ambience.CurrentAmbience.GetIntrinsicTypeName (obj.TypeInfo.Type.Name));
-			Gdk.Pixbuf icon = Runtime.Gui.Resources.GetIcon (icon_name, Gtk.IconSize.Menu);
-			if (icon != null)
-				store.SetValue (iter, PIXBUF_COL, icon);
-			if (obj != null)
-				AddPlaceholder (obj, iter);
-		}
-
-		string GetIcon (ITargetObject obj)
-		{
-			string icon = &quot;&quot;;
-
-			if (obj.TypeInfo.Type.TypeHandle is Type)
-				icon = Runtime.Gui.Icons.GetIcon ((Type)obj.TypeInfo.Type.TypeHandle);
-
-			return icon;
-		}
-
-		string GetIcon (ITargetMemberInfo member)
-		{
-			string icon = &quot;&quot;;
-
-			if (member.Handle is PropertyInfo)
-				icon = Runtime.Gui.Icons.GetIcon ((PropertyInfo)member.Handle);
-			else if (member.Handle is FieldInfo)
-				icon = Runtime.Gui.Icons.GetIcon ((FieldInfo)member.Handle);
-
-			return icon;
-		}
-
-		void UpdateVariableChildren (IVariable variable, ITargetObject obj, TreePath path, TreeIter iter)
-		{
-			bool expanded = tree.GetRowExpanded (path);
-			TreeIter citer;
-
-			if (!expanded) {
-
-				/* we aren't expanded, just remove all
-				 * children and add the object back
-				 * (since it might be a different
-				 * object now) */
-
-				if (store.IterChildren (out citer, iter))
-					while (store.Remove (ref citer)) ;
-				iters.Remove (iter);
-
-				AddPlaceholder (obj, iter);
-			}
-			else {
-				/* in a perfect world, we'd just iterate
-				 * over the stuff we're showing and update
-				 * it.  for now, just remove all rows and
-				 * re-add them. */
-
-				if (store.IterChildren (out citer, iter))
-					while (store.Remove (ref citer)) ;
-
-				iters.Remove (iter);
-
-				AddObject (variable.Name, GetIcon (obj), obj, iter);
-
-				tree.ExpandRow (path, false);
-			}
-		}
-
-		void UpdateVariable (IVariable variable)
-		{
-			TreeRowReference row = (TreeRowReference)variable_rows[variable];
-
-			if (row == null) {
-				/* the variable isn't presently displayed */
-
-				if (!variable.IsAlive (current_frame.TargetAddress))
-					/* it's not displayed and not alive, just return */
-					return;
-
-				AddVariable (variable);
-			}
-			else {
-				/* the variable is presently displayed */
-
-				// XXX we need a obj.IsValid check in this branch
-
-				if (!variable.IsAlive (current_frame.TargetAddress)) {
-					/* it's in the display but no longer alive.  remove it */
-					RemoveVariable (variable);
-					return;
-				}
-
-				/* it's still alive - make sure the display is up to date */
-				TreeIter iter;
-				if (store.GetIter (out iter, row.Path)) {
-					try {
-						ITargetObject obj = variable.GetObject (current_frame);
-
-						/* make sure the Value column is correct */
-						string current_value = (string)store.GetValue (iter, VALUE_COL);
-						string new_value = GetObjectValueString (obj);
-						if (current_value != new_value)
-							store.SetValue (iter, VALUE_COL, new_value);
-
-						/* update the children */
-						UpdateVariableChildren (variable, obj, row.Path, iter);
-
-					} catch (Exception e) {
-						Console.WriteLine (&quot;can't update variable: {0} {1}&quot;, variable, e);
-						store.SetValue (iter, VALUE_COL, &quot;&quot;);
-					}
-				}
-			}
-		}
-
-		void AddVariable (IVariable variable)
-		{
-			try {
-				/* it's alive, add it to the display */
-
-				ITargetObject obj = variable.GetObject (current_frame);
-				TreeIter iter;
-
-				if (!obj.IsValid)
-					return;
-
-				store.Append (out iter);
-
-				variable_rows.Add (variable, new TreeRowReference (store, store.GetPath (iter)));
-
-				AddObject (variable.Name, GetIcon (obj), obj, iter);
-			} catch (LocationInvalidException) {
-				// Do nothing
-			} catch (Exception e) {
-				Console.WriteLine (&quot;can't add variable: {0} {1}&quot;, variable, e);
-			}
-		}
-
-		void RemoveVariable (IVariable variable)
-		{
-			TreeRowReference row = (TreeRowReference)variable_rows[variable];
-			TreeIter iter;
-
-			if (row != null &amp;&amp; store.GetIter (out iter, row.Path)) {
-				iters.Remove (iter);
-				store.Remove (ref iter);
-			}
-
-			variable_rows.Remove (variable);
-		}
-
-		public void UpdateDisplay ()
-		{
-			if ((current_frame == null) || (current_frame.Method == null))
-				return;
-
-			try {
-				Hashtable vars_to_remove = new Hashtable();
-
-				foreach (IVariable var in variable_rows.Keys) {
-					vars_to_remove.Add (var, var);
-				}
-
-				if (is_locals_display) {
-					if (current_frame.Method.HasThis) {
-						UpdateVariable (current_frame.Method.This);
-						vars_to_remove.Remove (current_frame.Method.This);
-					}
-					IVariable[] local_vars = current_frame.Method.Locals;
-					foreach (IVariable var in local_vars) {
-						UpdateVariable (var);
-						vars_to_remove.Remove (var);
-					}
-				} else {
-					IVariable[] param_vars = current_frame.Method.Parameters;
-					foreach (IVariable var in param_vars) {
-						UpdateVariable (var);
-						vars_to_remove.Remove (var);
-					}
-				}
-
-				foreach (IVariable var in vars_to_remove.Keys) {
-					RemoveVariable (var);
-				}
-
-			} catch (Exception e) {
-				Console.WriteLine (&quot;CAN'T GET VARIABLES: {0}&quot;, e);
-				store.Clear ();
-				iters = new Hashtable ();
-			}
-		}
-
-		protected void OnStoppedEvent (object o, EventArgs args)
-		{
-			current_frame = (Mono.Debugger.StackFrame)Runtime.DebuggingService.CurrentFrame;
-			UpdateDisplay ();
-		}
-
-		protected void OnPausedEvent (object o, EventArgs args)
-		{
-			current_frame = (Mono.Debugger.StackFrame)Runtime.DebuggingService.CurrentFrame;
-			UpdateDisplay ();
-		}
-
-#if NET_2_0
-		DebuggerBrowsableAttribute GetDebuggerBrowsableAttribute (ITargetMemberInfo info)
-		{
-	  		if (info.Handle != null &amp;&amp; info.Handle is System.Reflection.MemberInfo) {
-				System.Reflection.MemberInfo mi = (System.Reflection.MemberInfo)info.Handle;
-				object[] attrs = mi.GetCustomAttributes (typeof (DebuggerBrowsableAttribute), false);
-
-				if (attrs != null &amp;&amp; attrs.Length &gt; 0)
-					return (DebuggerBrowsableAttribute)attrs[0];
-			}
-
-			return null;
-		}
-
-		DebuggerTypeProxyAttribute GetDebuggerTypeProxyAttribute (DebuggingService dbgr, ITargetObject obj)
-		{
-			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
-				return dbgr.AttributeHandler.GetDebuggerTypeProxyAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
-
-			return null;
-		}
-
-		DebuggerDisplayAttribute GetDebuggerDisplayAttribute (DebuggingService dbgr, ITargetObject obj)
-		{
-			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
-			  return dbgr.AttributeHandler.GetDebuggerDisplayAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
-
-			return null;
-		}
-#endif
-
-	}
-}

Copied: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/LocalsPad.cs (from rev 2407, trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerLocalsPad.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerLocalsPad.cs	2005-03-31 17:22:50 UTC (rev 2407)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/LocalsPad.cs	2005-04-01 23:21:09 UTC (rev 2413)
@@ -0,0 +1,66 @@
+using System;
+using MonoDevelop.Gui;
+using Stock = MonoDevelop.Gui.Stock;
+
+namespace MonoDevelop.Debugger
+{
+	public class LocalsPad : VariablePad, IPadContent
+	{
+
+		public LocalsPad () : base (true)
+		{
+		}
+
+		public Gtk.Widget Control {
+			get {
+				return this;
+			}
+		}
+
+		public string Id {
+			get { return &quot;MonoDevelop.Debugger.LocalsPad&quot;; }
+		}
+
+		public string DefaultPlacement {
+			get { return &quot;Bottom&quot;; }
+		}
+
+		public string Title {
+			get {
+				return &quot;Locals&quot;;
+			}
+		}
+
+		public string Icon {
+			get {
+				return Stock.OutputIcon;
+			}
+		}
+
+		public void RedrawContent ()
+		{
+			UpdateDisplay ();
+		}
+
+		public void BringToFront ()
+		{
+		}
+
+                protected virtual void OnTitleChanged(EventArgs e)
+                {
+                        if (TitleChanged != null) {
+                                TitleChanged(this, e);
+                        }
+                }
+                protected virtual void OnIconChanged(EventArgs e)
+                {
+                        if (IconChanged != null) {
+                                IconChanged(this, e);
+                        }
+                }
+                public event EventHandler TitleChanged;
+                public event EventHandler IconChanged;
+
+
+	}
+}

Copied: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/StackTracePad.cs (from rev 2410, trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerStackTracePad.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerStackTracePad.cs	2005-04-01 03:57:44 UTC (rev 2410)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/StackTracePad.cs	2005-04-01 23:21:09 UTC (rev 2413)
@@ -0,0 +1,146 @@
+using GLib;
+using Gtk;
+using GtkSharp;
+using System;
+using System.IO;
+using System.Collections;
+using System.Globalization;
+using System.Runtime.InteropServices;
+using Mono.Debugger;
+using Mono.Debugger.Languages;
+
+using Stock = MonoDevelop.Gui.Stock;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Debugger
+{
+	public class StackTracePad : Gtk.ScrolledWindow, IPadContent
+	{
+		StackFrame current_frame;
+
+		Gtk.TreeView tree;
+		Gtk.TreeStore store;
+
+		public StackTracePad ()
+		{
+			this.ShadowType = ShadowType.In;
+
+			store = new TreeStore (typeof (string));
+
+			tree = new TreeView (store);
+			tree.RulesHint = true;
+			tree.HeadersVisible = true;
+
+			TreeViewColumn FrameCol = new TreeViewColumn ();
+			CellRenderer FrameRenderer = new CellRendererText ();
+			FrameCol.Title = &quot;Frame&quot;;
+			FrameCol.PackStart (FrameRenderer, true);
+			FrameCol.AddAttribute (FrameRenderer, &quot;text&quot;, 0);
+			FrameCol.Resizable = true;
+			FrameCol.Alignment = 0.0f;
+			tree.AppendColumn (FrameCol);
+
+			Add (tree);
+			ShowAll ();
+
+			Runtime.DebuggingService.PausedEvent += new EventHandler (OnPausedEvent);
+			Runtime.DebuggingService.ResumedEvent += new EventHandler (OnResumedEvent);
+			Runtime.DebuggingService.StoppedEvent += new EventHandler (OnStoppedEvent);
+		}
+
+		public void UpdateDisplay ()
+		{
+			if ((current_frame == null) || (current_frame.Method == null))
+				return;
+
+			string[] trace = Runtime.DebuggingService.Backtrace;
+
+			TreeIter it;
+			if (!store.GetIterFirst (out it)) {
+				foreach (string frame in trace) {
+					store.Append (out it);
+					store.SetValue (it, 0, frame);
+				}
+			}
+			else {
+				for (int i = 0; i &lt; trace.Length; i ++) {
+					store.SetValue (it, 0, trace[i]);
+					if (i &lt; trace.Length - 1 &amp;&amp; !store.IterNext (ref it))
+						store.Append (out it);
+				}
+				/* clear any remaining rows */
+				if (store.IterNext (ref it))
+					do { } while (store.Remove (ref it));
+			}
+		}
+
+		protected void OnStoppedEvent (object o, EventArgs args)
+		{
+			UpdateDisplay ();
+		}
+
+		protected void OnResumedEvent (object o, EventArgs args)
+		{
+			UpdateDisplay ();
+		}
+
+		protected void OnPausedEvent (object o, EventArgs args)
+		{
+			current_frame = (StackFrame)Runtime.DebuggingService.CurrentFrame;
+			UpdateDisplay ();
+		}
+
+		public Gtk.Widget Control {
+			get {
+				return this;
+			}
+		}
+
+		public string Id {
+			get { return &quot;MonoDevelop.Debugger.StackTracePad&quot;; }
+		}
+
+		public string DefaultPlacement {
+			get { return &quot;Bottom&quot;; }
+		}
+
+		public string Title {
+			get {
+				return &quot;Call Stack&quot;;
+			}
+		}
+
+		public string Icon {
+			get {
+				return Stock.OutputIcon;
+			}
+		}
+
+		public void RedrawContent ()
+		{
+			UpdateDisplay ();
+		}
+
+		public void BringToFront ()
+		{
+		}
+
+                protected virtual void OnTitleChanged(EventArgs e)
+                {
+                        if (TitleChanged != null) {
+                                TitleChanged(this, e);
+                        }
+                }
+                protected virtual void OnIconChanged(EventArgs e)
+                {
+                        if (IconChanged != null) {
+                                IconChanged(this, e);
+                        }
+                }
+                public event EventHandler TitleChanged;
+                public event EventHandler IconChanged;
+	  
+	}
+}

Copied: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/ThreadPad.cs (from rev 2410, trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerThreadPad.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerThreadPad.cs	2005-04-01 03:57:44 UTC (rev 2410)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/ThreadPad.cs	2005-04-01 23:21:09 UTC (rev 2413)
@@ -0,0 +1,218 @@
+using GLib;
+using Gtk;
+using GtkSharp;
+using System;
+using System.IO;
+using System.Collections;
+using System.Globalization;
+using System.Runtime.InteropServices;
+using Mono.Debugger;
+using Mono.Debugger.Languages;
+
+using Stock = MonoDevelop.Gui.Stock;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Debugger
+{
+	public class ThreadPad : Gtk.ScrolledWindow, IPadContent
+	{
+		Gtk.TreeView tree;
+		Gtk.TreeStore store;
+		Hashtable thread_rows;
+
+		public ThreadPad ()
+		{
+			thread_rows = new Hashtable ();
+
+			this.ShadowType = ShadowType.In;
+
+			store = new TreeStore (typeof (int),
+					       typeof (int),
+					       typeof (string),
+					       typeof (string));
+
+			tree = new TreeView (store);
+			tree.RulesHint = true;
+			tree.HeadersVisible = true;
+
+			TreeViewColumn Col;
+			CellRenderer ThreadRenderer;
+
+			Col = new TreeViewColumn ();
+			ThreadRenderer = new CellRendererText ();
+			Col.Title = &quot;Id&quot;;
+			Col.PackStart (ThreadRenderer, true);
+			Col.AddAttribute (ThreadRenderer, &quot;text&quot;, 0);
+			Col.Resizable = true;
+			Col.Alignment = 0.0f;
+			tree.AppendColumn (Col);
+
+			Col = new TreeViewColumn ();
+			ThreadRenderer = new CellRendererText ();
+			Col.Title = &quot;PID&quot;;
+			Col.PackStart (ThreadRenderer, true);
+			Col.AddAttribute (ThreadRenderer, &quot;text&quot;, 1);
+			Col.Resizable = true;
+			Col.Alignment = 0.0f;
+			tree.AppendColumn (Col);
+
+			Col = new TreeViewColumn ();
+			ThreadRenderer = new CellRendererText ();
+			Col.Title = &quot;State&quot;;
+			Col.PackStart (ThreadRenderer, true);
+			Col.AddAttribute (ThreadRenderer, &quot;text&quot;, 2);
+			Col.Resizable = true;
+			Col.Alignment = 0.0f;
+			tree.AppendColumn (Col);
+
+			Col = new TreeViewColumn ();
+			ThreadRenderer = new CellRendererText ();
+			Col.Title = &quot;Current Location&quot;;
+			Col.PackStart (ThreadRenderer, true);
+			Col.AddAttribute (ThreadRenderer, &quot;text&quot;, 3);
+			Col.Resizable = true;
+			Col.Alignment = 0.0f;
+			tree.AppendColumn (Col);
+
+			Add (tree);
+			ShowAll ();
+
+			((DebuggingService)Runtime.DebuggingService).ThreadStateEvent += new EventHandler (OnThreadEvent);
+		}
+
+		void AddThread (Process thread)
+		{
+			TreeIter iter;
+			store.Append (out iter);
+			store.SetValue (iter, 0, new GLib.Value (thread.ID));
+			store.SetValue (iter, 1, new GLib.Value (thread.PID));
+			store.SetValue (iter, 2, new GLib.Value (thread.State.ToString()));
+			if (thread.IsStopped)
+				store.SetValue (iter, 3, new GLib.Value (thread.GetBacktrace().Frames[0].SourceAddress.Name));
+			else
+				store.SetValue (iter, 3, new GLib.Value (&quot;&quot;));
+			thread_rows.Add (thread, new TreeRowReference (store, store.GetPath (iter)));
+		}
+
+		void UpdateThread (Process thread)
+		{
+			TreeRowReference row = (TreeRowReference)thread_rows[thread];
+			TreeIter iter;
+
+			if (row != null &amp;&amp; store.GetIter (out iter, row.Path)) {
+				if (thread.ID != (int)store.GetValue (iter, 0))
+					store.SetValue (iter, 0, thread.ID);
+				if (thread.PID != (int)store.GetValue (iter, 1))
+					store.SetValue (iter, 1, thread.PID);
+				if (thread.State.ToString() != (string)store.GetValue (iter, 2))
+					store.SetValue (iter, 2, thread.State.ToString());
+
+				string location;
+				if (thread.IsStopped)
+					location = thread.GetBacktrace().Frames[0].SourceAddress.Name;
+				else
+					location = &quot;&quot;;
+
+				if (location != (string)store.GetValue (iter, 3))
+					store.SetValue (iter, 3, location);
+			}
+			else {
+				AddThread (thread);
+			}
+		}
+
+		void RemoveThread (Process thread)
+		{
+			TreeRowReference row = (TreeRowReference)thread_rows[thread];
+			TreeIter iter;
+
+			if (row != null &amp;&amp; store.GetIter (out iter, row.Path))
+				store.Remove (ref iter);
+
+			thread_rows.Remove (thread);
+		}
+
+		public void UpdateDisplay ()
+		{
+			Hashtable threads_to_remove = new Hashtable();
+
+			foreach (Process thread in thread_rows.Keys) {
+				threads_to_remove.Add (thread, thread);
+			}
+
+			foreach (Process t in ((DebuggingService)Runtime.DebuggingService).Threads) {
+				if (!t.IsDaemon) {
+					UpdateThread (t);
+					threads_to_remove.Remove (t);
+				}
+			}
+
+			foreach (Process t in threads_to_remove.Keys) {
+				RemoveThread (t);
+			}
+		}
+
+		public void CleanDisplay ()
+		{
+			UpdateDisplay ();
+		}
+
+		public void RedrawContent ()
+		{
+			UpdateDisplay ();
+		}
+
+		public void BringToFront ()
+		{
+		}
+
+		protected void OnThreadEvent (object o, EventArgs args)
+		{
+			UpdateDisplay ();
+		}
+
+		public Gtk.Widget Control {
+			get {
+				return this;
+			}
+		}
+
+		public string Id {
+			get { return &quot;MonoDevelop.Debugger.ThreadPad&quot;; }
+		}
+
+		public string DefaultPlacement {
+			get { return &quot;Bottom&quot;; }
+		}
+
+		public string Title {
+			get {
+				return &quot;Threads&quot;;
+			}
+		}
+
+		public string Icon {
+			get {
+				return Stock.OutputIcon;
+			}
+		}
+
+                protected virtual void OnTitleChanged(EventArgs e)
+                {
+                        if (TitleChanged != null) {
+                                TitleChanged(this, e);
+                        }
+                }
+                protected virtual void OnIconChanged(EventArgs e)
+                {
+                        if (IconChanged != null) {
+                                IconChanged(this, e);
+                        }
+                }
+                public event EventHandler TitleChanged;
+                public event EventHandler IconChanged;
+	  
+	}
+}

Copied: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/VariablePad.cs (from rev 2411, trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/DebuggerVariablePad.cs	2005-04-01 05:46:29 UTC (rev 2411)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/VariablePad.cs	2005-04-01 23:21:09 UTC (rev 2413)
@@ -0,0 +1,660 @@
+using GLib;
+using Gtk;
+using GtkSharp;
+using System;
+using System.Diagnostics;
+using System.IO;
+using System.Collections;
+using System.Globalization;
+using System.Text;
+using System.Reflection;
+using System.Runtime.InteropServices;
+using Mono.Debugger;
+using Mono.Debugger.Languages;
+
+using Stock = MonoDevelop.Gui.Stock;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Debugger
+{
+	public class VariablePad : Gtk.ScrolledWindow
+	{
+		Mono.Debugger.StackFrame current_frame;
+
+		Hashtable variable_rows;
+		Hashtable iters;
+
+		Gtk.TreeView tree;
+		Gtk.TreeStore store;
+		bool is_locals_display;
+
+		internal const int NAME_COL = 0;
+		internal const int VALUE_COL = 1;
+		internal const int TYPE_COL = 2;
+		internal const int RAW_VIEW_COL = 3;
+		internal const int PIXBUF_COL = 4;
+
+		public VariablePad (bool is_locals_display)
+		{
+			this.ShadowType = ShadowType.In;
+
+			this.is_locals_display = is_locals_display;
+
+			variable_rows = new Hashtable();
+			iters = new Hashtable();
+
+			store = new TreeStore (typeof (string),
+					       typeof (string),
+			                       typeof (string),
+					       typeof (bool),
+					       typeof (Gdk.Pixbuf));
+
+			tree = new TreeView (store);
+			tree.RulesHint = true;
+			tree.HeadersVisible = true;
+
+			TreeViewColumn NameCol = new TreeViewColumn ();
+			CellRenderer NameRenderer = new CellRendererText ();
+			CellRenderer IconRenderer = new CellRendererPixbuf ();
+			NameCol.Title = &quot;Name&quot;;
+			NameCol.PackStart (IconRenderer, false);
+			NameCol.PackStart (NameRenderer, true);
+			NameCol.AddAttribute (IconRenderer, &quot;pixbuf&quot;, PIXBUF_COL);
+			NameCol.AddAttribute (NameRenderer, &quot;text&quot;, NAME_COL);
+			NameCol.Resizable = true;
+			NameCol.Alignment = 0.0f;
+			tree.AppendColumn (NameCol);
+
+			TreeViewColumn ValueCol = new TreeViewColumn ();
+			CellRenderer ValueRenderer = new CellRendererText ();
+			ValueCol.Title = &quot;Value&quot;;
+			ValueCol.PackStart (ValueRenderer, true);
+			ValueCol.AddAttribute (ValueRenderer, &quot;text&quot;, VALUE_COL);
+			ValueCol.Resizable = true;
+			NameCol.Alignment = 0.0f;
+			tree.AppendColumn (ValueCol);
+
+			TreeViewColumn TypeCol = new TreeViewColumn ();
+			CellRenderer TypeRenderer = new CellRendererText ();
+			TypeCol.Title = &quot;Type&quot;;
+			TypeCol.PackStart (TypeRenderer, true);
+			TypeCol.AddAttribute (TypeRenderer, &quot;text&quot;, TYPE_COL);
+			TypeCol.Resizable = true;
+			NameCol.Alignment = 0.0f;
+			tree.AppendColumn (TypeCol);
+
+			tree.TestExpandRow += new TestExpandRowHandler (TestExpandRow);
+
+			Add (tree);
+			ShowAll ();
+
+			Runtime.DebuggingService.PausedEvent += new EventHandler (OnPausedEvent);
+			Runtime.DebuggingService.StoppedEvent += new EventHandler (OnStoppedEvent);
+		}
+
+		bool InsertArrayChildren (TreeIter parent, ITargetArrayObject array)
+		{
+			bool inserted = false;
+
+			for (int i = array.LowerBound; i &lt; array.UpperBound; i++) {
+
+				inserted = true;
+
+				ITargetObject elt = array [i];
+				if (elt == null)
+					continue;
+
+				TreeIter iter = store.Append (parent);
+				AddObject (i.ToString (), &quot;&quot; /* XXX */, elt, iter);
+			}
+
+			return inserted;
+		}
+
+		bool InsertStructMember (TreeIter parent, ITargetStructObject sobj, ITargetMemberInfo member, bool is_field)
+		{
+			bool inserted = false;
+
+			string icon_name = GetIcon (member);
+
+#if NET_2_0
+			DebuggerBrowsableAttribute battr = GetDebuggerBrowsableAttribute (member);
+			if (battr != null) {
+				TreeIter iter;
+
+				switch (battr.State) {
+				case DebuggerBrowsableState.Never:
+					// don't display it at all
+					continue;
+				case DebuggerBrowsableState.Collapsed:
+					// the default behavior for the debugger (c&amp;p from above)
+					iter = store.Append (parent);
+					AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
+						   iter);
+					inserted = true;
+					break;
+				case DebuggerBrowsableState.Expanded:
+					// add it as in the Collapsed case...
+					iter = store.Append (parent);
+					AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
+						   iter);
+					inserted = true;
+					// then expand the row
+					tree.ExpandRow (store.GetPath (iter), false);
+					break;
+				case DebuggerBrowsableState.RootHidden:
+					ITargetObject member_obj = is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index);
+
+					if (member_obj != null) {
+						switch (member_obj.TypeInfo.Type.Kind) {
+						case TargetObjectKind.Array:
+							iter = store.Append (parent);
+							// handle arrays normally, should check how vs2005 does this.
+							AddObject (member.Name, icon_name, member_obj, iter);
+							inserted = true;
+							break;
+						case TargetObjectKind.Class:
+							try {
+								inserted = InsertClassChildren (parent, (ITargetClassObject)member_obj, false);
+							}
+							catch {
+								// what about this case?  where the member is possibly
+								// uninitialized, do we try to add it later?
+							}
+							break;
+						case TargetObjectKind.Struct:
+							try {
+								inserted = InsertStructChildren (parent, (ITargetStructObject)member_obj, false);
+							}
+							catch {
+								// what about this case?  where the member is possibly
+								// uninitialized, do we try to add it later?
+							}
+							break;
+						default:
+							// nothing
+							break;
+						}
+					}
+					break;
+				}
+			}
+			else {
+#endif
+				TreeIter iter = store.Append (parent);
+				AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
+					   iter);
+				inserted = true;
+#if NET_2_0
+			}
+#endif
+
+			return inserted;
+		}
+
+#if NET_2_0
+		bool InsertProxyChildren (DebuggingService dbgr, DebuggerTypeProxyAttribute pattr, TreeIter parent, ITargetStructObject sobj)
+		{
+			Mono.Debugger.StackFrame frame = dbgr.MainThread.CurrentFrame;
+	 		ITargetStructType proxy_type = frame.Language.LookupType (frame, pattr.ProxyTypeName) as ITargetStructType;
+			if (proxy_type == null)
+				proxy_type = frame.Language.LookupType (frame,
+									sobj.Type.Name + &quot;+&quot; + pattr.ProxyTypeName) as ITargetStructType;
+			if (proxy_type != null) {
+				string name = String.Format (&quot;.ctor({0})&quot;, sobj.Type.Name);
+				ITargetMethodInfo method = null;
+
+				foreach (ITargetMethodInfo m in proxy_type.Constructors) {
+					if (m.FullName == name)
+						method = m;
+				}
+
+				if (method != null) {
+					ITargetFunctionObject ctor = proxy_type.GetConstructor (frame, method.Index);
+					ITargetObject[] args = new ITargetObject[1];
+					args[0] = sobj;
+
+					ITargetStructObject proxy_obj = ctor.Type.InvokeStatic (frame, args, false) as ITargetStructObject;
+
+					if (proxy_obj != null) {
+						foreach (ITargetPropertyInfo prop in proxy_obj.Type.Properties) {
+							InsertStructMember (parent, proxy_obj, prop, false);
+						}
+
+						TreeIter iter = store.Append (parent);
+						store.SetValue (iter, NAME_COL, &quot;Raw View&quot;);
+						store.SetValue (iter, RAW_VIEW_COL, true);
+
+						Gdk.Pixbuf icon = Runtime.Gui.Resources.GetIcon (Stock.Class, Gtk.IconSize.Menu);
+						if (icon != null)
+							store.SetValue (iter, PIXBUF_COL, icon);
+
+						iters.Remove (iter);
+						AddPlaceholder (sobj, iter);
+
+						return true;
+					}
+				}
+			}
+
+			return false;
+		}
+#endif
+
+		bool InsertStructChildren (TreeIter parent, ITargetStructObject sobj, bool raw_view)
+		{
+			bool inserted = false;
+
+#if NET_2_0
+			if (!raw_view) {
+				DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
+				DebuggerTypeProxyAttribute pattr = GetDebuggerTypeProxyAttribute (dbgr, sobj);
+
+				if (pattr != null) {
+					if (InsertProxyChildren (dbgr, pattr, parent, sobj))
+						inserted = true;
+				}
+			}
+#endif
+
+			foreach (ITargetFieldInfo field in sobj.Type.Fields) {
+				if (InsertStructMember (parent, sobj, field, true))
+					inserted = true;
+			}
+
+			foreach (ITargetPropertyInfo prop in sobj.Type.Properties) {
+				if (InsertStructMember (parent, sobj, prop, false))
+					inserted = true;
+			}
+
+			return inserted;
+		}
+
+		bool InsertClassChildren (TreeIter parent, ITargetClassObject sobj, bool raw_view)
+		{
+			bool inserted = false;
+
+			if (sobj.Type.HasParent) {
+				TreeIter iter = store.Append (parent);
+				AddObject (&quot;&lt;parent&gt;&quot;, Stock.Class, sobj.Parent, iter);
+				inserted = true;
+			}
+
+			if (InsertStructChildren (parent, sobj, raw_view))
+				inserted = true;
+
+			return inserted;
+		}
+
+		void InsertMessage (TreeIter parent, string message)
+		{
+			TreeIter child;
+			if (store.IterChildren (out child, parent)) {
+				while (!(child.Equals (Gtk.TreeIter.Zero)) &amp;&amp; (child.Stamp != 0))
+					store.Remove (ref child);
+			}
+
+			TreeIter iter = store.Append (parent);
+			store.SetValue (iter, VALUE_COL, message);
+		}
+
+		void TestExpandRow (object o, TestExpandRowArgs args)
+		{
+			bool inserted = false;
+
+			ITargetObject obj = (ITargetObject) iters [args.Iter];
+
+			TreeIter child;
+			if (store.IterChildren (out child, args.Iter)) {
+				while (!(child.Equals (Gtk.TreeIter.Zero)) &amp;&amp; (child.Stamp != 0))
+					store.Remove (ref child);
+			}
+
+			if (obj == null) {
+				child = store.Append (args.Iter);
+				return;
+			}
+
+			switch (obj.TypeInfo.Type.Kind) {
+			case TargetObjectKind.Array:
+				ITargetArrayObject array = (ITargetArrayObject) obj;
+				try {
+					inserted = InsertArrayChildren (args.Iter, array);
+				} catch {
+					InsertMessage (args.Iter, &quot;&lt;can't display array&gt;&quot;);
+					inserted = true;
+				}
+				if (!inserted)
+					InsertMessage (args.Iter, &quot;&lt;empty array&gt;&quot;);
+				break;
+
+			case TargetObjectKind.Class:
+				ITargetClassObject cobj = (ITargetClassObject) obj;
+				try {
+					bool raw_view = (bool)store.GetValue (args.Iter, RAW_VIEW_COL);
+					inserted = InsertClassChildren (args.Iter, cobj, raw_view);
+				} catch (Exception e) {
+				  Console.WriteLine (e);
+					InsertMessage (args.Iter, &quot;&lt;can't display class&gt;&quot;);
+					inserted = true;
+				}
+				if (!inserted)
+					InsertMessage (args.Iter, &quot;&lt;empty class&gt;&quot;);
+				break;
+
+			case TargetObjectKind.Struct:
+				ITargetStructObject sobj = (ITargetStructObject) obj;
+				try {
+					bool raw_view = (bool)store.GetValue (args.Iter, RAW_VIEW_COL);
+					inserted = InsertStructChildren (args.Iter, sobj, raw_view);
+				} catch {
+					InsertMessage (args.Iter, &quot;&lt;can't display struct&gt;&quot;);
+					inserted = true;
+				}
+				if (!inserted)
+					InsertMessage (args.Iter, &quot;&lt;empty struct&gt;&quot;);
+				break;
+
+			default:
+				InsertMessage (args.Iter, &quot;&lt;unknown object&gt;&quot;);
+				break;
+			}
+		}
+
+		void AddPlaceholder (ITargetObject obj, TreeIter parent)
+		{
+			if (obj.TypeInfo.Type.Kind == TargetObjectKind.Array) {
+				ITargetArrayObject array = (ITargetArrayObject) obj;
+				if (array.LowerBound == array.UpperBound)
+					return;
+			}
+
+			store.Append (parent);
+			iters.Add (parent, obj);
+		}
+
+		string GetObjectValueString (ITargetObject obj)
+		{
+			if (obj == null) {
+				return &quot;null&quot;;
+			}
+
+			switch (obj.TypeInfo.Type.Kind) {
+			case TargetObjectKind.Fundamental:
+				object contents = ((ITargetFundamentalObject) obj).Object;
+				return contents.ToString ();
+
+			case TargetObjectKind.Array:
+				ITargetArrayObject array = (ITargetArrayObject) obj;
+				if (array.LowerBound == array.UpperBound &amp;&amp; array.LowerBound == 0)
+					return &quot;[]&quot;;
+				else
+					return &quot;&quot;;
+
+			case TargetObjectKind.Struct:
+			case TargetObjectKind.Class:
+				try {
+#if NET_2_0
+					DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
+					DebuggerDisplayAttribute dattr = GetDebuggerDisplayAttribute (dbgr, obj);
+					if (dattr != null) {
+						return dbgr.AttributeHandler.EvaluateDebuggerDisplay (obj, dattr.Value);
+					}
+					else {
+#endif
+						// call the object's ToString() method.
+						return ((ITargetStructObject)obj).PrintObject();
+#if NET_2_0
+					}
+#endif
+				}
+				catch (Exception e) {
+				  //Console.WriteLine (&quot;getting object value failed: {0}&quot;, e);
+					return &quot;&quot;;
+				}
+			default:
+				return &quot;&quot;;
+			}
+		}
+
+		void AddObject (string name, string icon_name, ITargetObject obj, TreeIter iter)
+		{
+			store.SetValue (iter, NAME_COL, name);
+			store.SetValue (iter, VALUE_COL, GetObjectValueString (obj));
+			store.SetValue (iter, TYPE_COL,
+					obj == null ? &quot;&quot; : Runtime.Ambience.CurrentAmbience.GetIntrinsicTypeName (obj.TypeInfo.Type.Name));
+			Gdk.Pixbuf icon = Runtime.Gui.Resources.GetIcon (icon_name, Gtk.IconSize.Menu);
+			if (icon != null)
+				store.SetValue (iter, PIXBUF_COL, icon);
+			if (obj != null)
+				AddPlaceholder (obj, iter);
+		}
+
+		string GetIcon (ITargetObject obj)
+		{
+			string icon = &quot;&quot;;
+
+			if (obj.TypeInfo.Type.TypeHandle is Type)
+				icon = Runtime.Gui.Icons.GetIcon ((Type)obj.TypeInfo.Type.TypeHandle);
+
+			return icon;
+		}
+
+		string GetIcon (ITargetMemberInfo member)
+		{
+			string icon = &quot;&quot;;
+
+			if (member.Handle is PropertyInfo)
+				icon = Runtime.Gui.Icons.GetIcon ((PropertyInfo)member.Handle);
+			else if (member.Handle is FieldInfo)
+				icon = Runtime.Gui.Icons.GetIcon ((FieldInfo)member.Handle);
+
+			return icon;
+		}
+
+		void UpdateVariableChildren (IVariable variable, ITargetObject obj, TreePath path, TreeIter iter)
+		{
+			bool expanded = tree.GetRowExpanded (path);
+			TreeIter citer;
+
+			if (!expanded) {
+
+				/* we aren't expanded, just remove all
+				 * children and add the object back
+				 * (since it might be a different
+				 * object now) */
+
+				if (store.IterChildren (out citer, iter))
+					while (store.Remove (ref citer)) ;
+				iters.Remove (iter);
+
+				AddPlaceholder (obj, iter);
+			}
+			else {
+				/* in a perfect world, we'd just iterate
+				 * over the stuff we're showing and update
+				 * it.  for now, just remove all rows and
+				 * re-add them. */
+
+				if (store.IterChildren (out citer, iter))
+					while (store.Remove (ref citer)) ;
+
+				iters.Remove (iter);
+
+				AddObject (variable.Name, GetIcon (obj), obj, iter);
+
+				tree.ExpandRow (path, false);
+			}
+		}
+
+		void UpdateVariable (IVariable variable)
+		{
+			TreeRowReference row = (TreeRowReference)variable_rows[variable];
+
+			if (row == null) {
+				/* the variable isn't presently displayed */
+
+				if (!variable.IsAlive (current_frame.TargetAddress))
+					/* it's not displayed and not alive, just return */
+					return;
+
+				AddVariable (variable);
+			}
+			else {
+				/* the variable is presently displayed */
+
+				// XXX we need a obj.IsValid check in this branch
+
+				if (!variable.IsAlive (current_frame.TargetAddress)) {
+					/* it's in the display but no longer alive.  remove it */
+					RemoveVariable (variable);
+					return;
+				}
+
+				/* it's still alive - make sure the display is up to date */
+				TreeIter iter;
+				if (store.GetIter (out iter, row.Path)) {
+					try {
+						ITargetObject obj = variable.GetObject (current_frame);
+
+						/* make sure the Value column is correct */
+						string current_value = (string)store.GetValue (iter, VALUE_COL);
+						string new_value = GetObjectValueString (obj);
+						if (current_value != new_value)
+							store.SetValue (iter, VALUE_COL, new_value);
+
+						/* update the children */
+						UpdateVariableChildren (variable, obj, row.Path, iter);
+
+					} catch (Exception e) {
+						Console.WriteLine (&quot;can't update variable: {0} {1}&quot;, variable, e);
+						store.SetValue (iter, VALUE_COL, &quot;&quot;);
+					}
+				}
+			}
+		}
+
+		void AddVariable (IVariable variable)
+		{
+			try {
+				/* it's alive, add it to the display */
+
+				ITargetObject obj = variable.GetObject (current_frame);
+				TreeIter iter;
+
+				if (!obj.IsValid)
+					return;
+
+				store.Append (out iter);
+
+				variable_rows.Add (variable, new TreeRowReference (store, store.GetPath (iter)));
+
+				AddObject (variable.Name, GetIcon (obj), obj, iter);
+			} catch (LocationInvalidException) {
+				// Do nothing
+			} catch (Exception e) {
+				Console.WriteLine (&quot;can't add variable: {0} {1}&quot;, variable, e);
+			}
+		}
+
+		void RemoveVariable (IVariable variable)
+		{
+			TreeRowReference row = (TreeRowReference)variable_rows[variable];
+			TreeIter iter;
+
+			if (row != null &amp;&amp; store.GetIter (out iter, row.Path)) {
+				iters.Remove (iter);
+				store.Remove (ref iter);
+			}
+
+			variable_rows.Remove (variable);
+		}
+
+		public void UpdateDisplay ()
+		{
+			if ((current_frame == null) || (current_frame.Method == null))
+				return;
+
+			try {
+				Hashtable vars_to_remove = new Hashtable();
+
+				foreach (IVariable var in variable_rows.Keys) {
+					vars_to_remove.Add (var, var);
+				}
+
+				if (is_locals_display) {
+					if (current_frame.Method.HasThis) {
+						UpdateVariable (current_frame.Method.This);
+						vars_to_remove.Remove (current_frame.Method.This);
+					}
+					IVariable[] local_vars = current_frame.Method.Locals;
+					foreach (IVariable var in local_vars) {
+						UpdateVariable (var);
+						vars_to_remove.Remove (var);
+					}
+				} else {
+					IVariable[] param_vars = current_frame.Method.Parameters;
+					foreach (IVariable var in param_vars) {
+						UpdateVariable (var);
+						vars_to_remove.Remove (var);
+					}
+				}
+
+				foreach (IVariable var in vars_to_remove.Keys) {
+					RemoveVariable (var);
+				}
+
+			} catch (Exception e) {
+				Console.WriteLine (&quot;CAN'T GET VARIABLES: {0}&quot;, e);
+				store.Clear ();
+				iters = new Hashtable ();
+			}
+		}
+
+		protected void OnStoppedEvent (object o, EventArgs args)
+		{
+			current_frame = (Mono.Debugger.StackFrame)Runtime.DebuggingService.CurrentFrame;
+			UpdateDisplay ();
+		}
+
+		protected void OnPausedEvent (object o, EventArgs args)
+		{
+			current_frame = (Mono.Debugger.StackFrame)Runtime.DebuggingService.CurrentFrame;
+			UpdateDisplay ();
+		}
+
+#if NET_2_0
+		DebuggerBrowsableAttribute GetDebuggerBrowsableAttribute (ITargetMemberInfo info)
+		{
+	  		if (info.Handle != null &amp;&amp; info.Handle is System.Reflection.MemberInfo) {
+				System.Reflection.MemberInfo mi = (System.Reflection.MemberInfo)info.Handle;
+				object[] attrs = mi.GetCustomAttributes (typeof (DebuggerBrowsableAttribute), false);
+
+				if (attrs != null &amp;&amp; attrs.Length &gt; 0)
+					return (DebuggerBrowsableAttribute)attrs[0];
+			}
+
+			return null;
+		}
+
+		DebuggerTypeProxyAttribute GetDebuggerTypeProxyAttribute (DebuggingService dbgr, ITargetObject obj)
+		{
+			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
+				return dbgr.AttributeHandler.GetDebuggerTypeProxyAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
+
+			return null;
+		}
+
+		DebuggerDisplayAttribute GetDebuggerDisplayAttribute (DebuggingService dbgr, ITargetObject obj)
+		{
+			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
+			  return dbgr.AttributeHandler.GetDebuggerDisplayAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
+
+			return null;
+		}
+#endif
+
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am	2005-04-01 23:00:27 UTC (rev 2412)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am	2005-04-01 23:21:09 UTC (rev 2413)
@@ -17,10 +17,10 @@
 Expression.cs \
 DebuggerASTVisitor.cs \
 DebugAttributeHandler.cs \
-Gui/DebuggerLocalsPad.cs \
-Gui/DebuggerVariablePad.cs \
-Gui/DebuggerStackTracePad.cs \
-Gui/DebuggerThreadPad.cs
+Gui/LocalsPad.cs \
+Gui/VariablePad.cs \
+Gui/StackTracePad.cs \
+Gui/ThreadPad.cs
 
 
 EXTRA_DIST = $(FILES) $(ADDIN)

Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/MonoDevelopDebugger.addin.xml
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/MonoDevelopDebugger.addin.xml	2005-04-01 23:00:27 UTC (rev 2412)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/MonoDevelopDebugger.addin.xml	2005-04-01 23:21:09 UTC (rev 2413)
@@ -15,15 +15,15 @@
 	&lt;/Extension&gt;
 
 	&lt;Extension path = &quot;/SharpDevelop/Workbench/Pads&quot;&gt;
-		&lt;Pad id = &quot;MonoDevelop.Debugger.DebuggerLocalsPad&quot;     class = &quot;MonoDevelop.Debugger.DebuggerLocalsPad&quot;/&gt;
-		&lt;Pad id = &quot;MonoDevelop.Debugger.DebuggerStackTracePad&quot; class = &quot;MonoDevelop.Debugger.DebuggerStackTracePad&quot;/&gt;
-		&lt;Pad id = &quot;MonoDevelop.Debugger.DebuggerThreadPad&quot;     class = &quot;MonoDevelop.Debugger.DebuggerThreadPad&quot;/&gt;
+		&lt;Pad id = &quot;MonoDevelop.Debugger.LocalsPad&quot;     class = &quot;MonoDevelop.Debugger.LocalsPad&quot;/&gt;
+		&lt;Pad id = &quot;MonoDevelop.Debugger.StackTracePad&quot; class = &quot;MonoDevelop.Debugger.StackTracePad&quot;/&gt;
+		&lt;Pad id = &quot;MonoDevelop.Debugger.ThreadPad&quot;     class = &quot;MonoDevelop.Debugger.ThreadPad&quot;/&gt;
 	&lt;/Extension&gt;
 
 	&lt;Extension path = &quot;/SharpDevelop/Workbench/Contexts/Debug&quot;&gt;
-		&lt;ContextPad id = &quot;MonoDevelop.Debugger.DebuggerLocalsPad&quot; /&gt;
-		&lt;ContextPad id = &quot;MonoDevelop.Debugger.DebuggerStackTracePad&quot; /&gt;
-		&lt;ContextPad id = &quot;MonoDevelop.Debugger.DebuggerThreadPad&quot; /&gt;
+		&lt;ContextPad id = &quot;MonoDevelop.Debugger.LocalsPad&quot; /&gt;
+		&lt;ContextPad id = &quot;MonoDevelop.Debugger.StackTracePad&quot; /&gt;
+		&lt;ContextPad id = &quot;MonoDevelop.Debugger.ThreadPad&quot; /&gt;
 	&lt;/Extension&gt;
 
 	&lt;Extension path=&quot;/SharpDevelop/Workbench/MainMenu/Run&quot;&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002014.html">[Monodevelop-patches-list] r2412 - trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/tests
</A></li>
	<LI>Next message: <A HREF="002016.html">[Monodevelop-patches-list] r2414 - in trunk/MonoDevelop: . Core/src/MonoDevelop.Base Core/src/MonoDevelop.Base/Commands Core/src/MonoDevelop.Base/Commands/VBConverter Core/src/MonoDevelop.Base/Gui/BrowserDisplayBinding Core/src/MonoDevelop.Base/Gui/Dialogs Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog Core/src/MonoDevelop.Base/Gui/Dialogs/Wizard Core/src/MonoDevelop.Base/Gui/HtmlControl Core/src/MonoDevelop.Base/Gui/Pads/FileScout Core/src/MonoDevelop.Base/Gui/Pads/HelpBrowser Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder Core/src/MonoDevelop.Base/Gui/Pads/PropertyPad Core/src/MonoDevelop.Base/Gui/Pads/SolutionPad Core/src/MonoDevelop.Base/Gui/Workbench Core/src/MonoDevelop.Base/Gui/Workbench/Layouts Core/src/MonoDevelop.Base/Internal/ExternalTool Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer Core/src/MonoDevelop.Base/Internal/ProgressMonitoring Core/src/MonoDevelop.Base/Internal/Project/Combin e Core/src/MonoDevelop.Base/Internal/Project/Project Core/src/MonoDevelop.Base/Internal/Templates Core/src/MonoDevelop.Base/Services Core/src/MonoDevelop.Base/Services/DispatchService Core/src/MonoDevelop.Base/Services/DisplayBinding Core/src/MonoDevelop.Base/Services/ParserService Core/src/MonoDevelop.Startup contrib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2015">[ date ]</a>
              <a href="thread.html#2015">[ thread ]</a>
              <a href="subject.html#2015">[ subject ]</a>
              <a href="author.html#2015">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
