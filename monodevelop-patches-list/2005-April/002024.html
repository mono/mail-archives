<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2422 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2422%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn%3A%20.%20Gui&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002023.html">
   <LINK REL="Next"  HREF="002025.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2422 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui</H1>
    <B>Chris Toshok</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2422%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn%3A%20.%20Gui&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2422 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui">toshok at mono-cvs.ximian.com
       </A><BR>
    <I>Tue Apr  5 16:06:23 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002023.html">[Monodevelop-patches-list] r2421 - trunk/MonoDevelop
</A></li>
        <LI>Next message: <A HREF="002025.html">[Monodevelop-patches-list] r2423 - in trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor: . Gui/OptionPanels Services
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2024">[ date ]</a>
              <a href="thread.html#2024">[ thread ]</a>
              <a href="subject.html#2024">[ subject ]</a>
              <a href="author.html#2024">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: toshok
Date: 2005-04-05 16:06:23 -0400 (Tue, 05 Apr 2005)
New Revision: 2422

Removed:
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/VariablePad.cs
Modified:
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/LocalsPad.cs
   trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am
Log:
2005-04-05  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;

        * Makefile.am (FILES): remove VariablePad.cs

        * Gui/LocalsPad.cs: roll VariablePad.cs into here.  we'll display
        both args and locals in the same pad.

        * Gui/VariablePad.cs: nuke.



Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog	2005-04-03 20:30:46 UTC (rev 2421)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/ChangeLog	2005-04-05 20:06:23 UTC (rev 2422)
@@ -1,3 +1,12 @@
+2005-04-05  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;
+
+	* Makefile.am (FILES): remove VariablePad.cs
+
+	* Gui/LocalsPad.cs: roll VariablePad.cs into here.  we'll display
+	both args and locals in the same pad.
+
+	* Gui/VariablePad.cs: nuke.
+
 2005-04-01  Chris Toshok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">toshok at ximian.com</A>&gt;
 
 	* Visualizers/*: Start of debug visualizer support.

Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/LocalsPad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/LocalsPad.cs	2005-04-03 20:30:46 UTC (rev 2421)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/LocalsPad.cs	2005-04-05 20:06:23 UTC (rev 2422)
@@ -1,16 +1,760 @@
 using System;
+using System.Collections;
+using System.Diagnostics;
+using System.Reflection;
+using Gtk;
+
 using MonoDevelop.Gui;
+using MonoDevelop.Services;
 using Stock = MonoDevelop.Gui.Stock;
+using MonoDevelop.DebuggerVisualizers;
 
+using Mono.Debugger;
+using Mono.Debugger.Languages;
+
 namespace MonoDevelop.Debugger
 {
-	public class LocalsPad : VariablePad, IPadContent
+	public class LocalsPad : Gtk.ScrolledWindow, IPadContent
 	{
+		Mono.Debugger.StackFrame current_frame;
 
-		public LocalsPad () : base (true)
+		Hashtable variable_rows;
+		Hashtable iters;
+
+		Hashtable visualizers_by_item;
+
+		Gtk.TreeView tree;
+		Gtk.TreeStore store;
+
+		internal const int NAME_COL = 0;
+		internal const int VALUE_COL = 1;
+		internal const int TYPE_COL = 2;
+		internal const int RAW_VIEW_COL = 3;
+		internal const int PIXBUF_COL = 4;
+
+
+		public LocalsPad ()
 		{
+			this.ShadowType = ShadowType.In;
+
+			variable_rows = new Hashtable();
+			iters = new Hashtable();
+
+			store = new TreeStore (typeof (string),
+						    typeof (string),
+						    typeof (string),
+						    typeof (bool),
+						    typeof (Gdk.Pixbuf));
+
+			tree = new TreeView (store);
+			tree.RulesHint = true;
+			tree.HeadersVisible = true;
+
+			TreeViewColumn NameCol = new TreeViewColumn ();
+			CellRenderer NameRenderer = new CellRendererText ();
+			CellRenderer IconRenderer = new CellRendererPixbuf ();
+			NameCol.Title = &quot;Name&quot;;
+			NameCol.PackStart (IconRenderer, false);
+			NameCol.PackStart (NameRenderer, true);
+			NameCol.AddAttribute (IconRenderer, &quot;pixbuf&quot;, PIXBUF_COL);
+			NameCol.AddAttribute (NameRenderer, &quot;text&quot;, NAME_COL);
+			NameCol.Resizable = true;
+			NameCol.Alignment = 0.0f;
+			tree.AppendColumn (NameCol);
+
+			TreeViewColumn ValueCol = new TreeViewColumn ();
+			CellRenderer ValueRenderer = new CellRendererText ();
+			ValueCol.Title = &quot;Value&quot;;
+			ValueCol.PackStart (ValueRenderer, true);
+			ValueCol.AddAttribute (ValueRenderer, &quot;text&quot;, VALUE_COL);
+			ValueCol.Resizable = true;
+			NameCol.Alignment = 0.0f;
+			tree.AppendColumn (ValueCol);
+
+			TreeViewColumn TypeCol = new TreeViewColumn ();
+			CellRenderer TypeRenderer = new CellRendererText ();
+			TypeCol.Title = &quot;Type&quot;;
+			TypeCol.PackStart (TypeRenderer, true);
+			TypeCol.AddAttribute (TypeRenderer, &quot;text&quot;, TYPE_COL);
+			TypeCol.Resizable = true;
+			NameCol.Alignment = 0.0f;
+			tree.AppendColumn (TypeCol);
+
+			tree.TestExpandRow += new TestExpandRowHandler (TestExpandRow);
+
+#if NET_2_0
+			tree.PopupMenu += new PopupMenuHandler (TreePopup);
+                        tree.ButtonReleaseEvent += new Gtk.ButtonReleaseEventHandler(OnButtonRelease);
+#endif
+
+			Add (tree);
+			ShowAll ();
+
+			Runtime.DebuggingService.PausedEvent += new EventHandler (OnPausedEvent);
+			Runtime.DebuggingService.StoppedEvent += new EventHandler (OnStoppedEvent);
 		}
 
+		bool InsertArrayChildren (TreeIter parent, ITargetArrayObject array)
+		{
+			bool inserted = false;
+
+			for (int i = array.LowerBound; i &lt; array.UpperBound; i++) {
+
+				inserted = true;
+
+				ITargetObject elt = array [i];
+				if (elt == null)
+					continue;
+
+				TreeIter iter = store.Append (parent);
+				AddObject (i.ToString (), &quot;&quot; /* XXX */, elt, iter);
+			}
+
+			return inserted;
+		}
+
+		bool InsertStructMember (TreeIter parent, ITargetStructObject sobj, ITargetMemberInfo member, bool is_field)
+		{
+			bool inserted = false;
+
+			string icon_name = GetIcon (member);
+
+#if NET_2_0
+			DebuggerBrowsableAttribute battr = GetDebuggerBrowsableAttribute (member);
+			if (battr != null) {
+				TreeIter iter;
+
+				switch (battr.State) {
+				case DebuggerBrowsableState.Never:
+					// don't display it at all
+					continue;
+				case DebuggerBrowsableState.Collapsed:
+					// the default behavior for the debugger (c&amp;p from above)
+					iter = store.Append (parent);
+					AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
+						   iter);
+					inserted = true;
+					break;
+				case DebuggerBrowsableState.Expanded:
+					// add it as in the Collapsed case...
+					iter = store.Append (parent);
+					AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
+						   iter);
+					inserted = true;
+					// then expand the row
+					tree.ExpandRow (store.GetPath (iter), false);
+					break;
+				case DebuggerBrowsableState.RootHidden:
+					ITargetObject member_obj = is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index);
+
+					if (member_obj != null) {
+						switch (member_obj.TypeInfo.Type.Kind) {
+						case TargetObjectKind.Array:
+							iter = store.Append (parent);
+							// handle arrays normally, should check how vs2005 does this.
+							AddObject (member.Name, icon_name, member_obj, iter);
+							inserted = true;
+							break;
+						case TargetObjectKind.Class:
+							try {
+								inserted = InsertClassChildren (parent, (ITargetClassObject)member_obj, false);
+							}
+							catch {
+								// what about this case?  where the member is possibly
+								// uninitialized, do we try to add it later?
+							}
+							break;
+						case TargetObjectKind.Struct:
+							try {
+								inserted = InsertStructChildren (parent, (ITargetStructObject)member_obj, false);
+							}
+							catch {
+								// what about this case?  where the member is possibly
+								// uninitialized, do we try to add it later?
+							}
+							break;
+						default:
+							// nothing
+							break;
+						}
+					}
+					break;
+				}
+			}
+			else {
+#endif
+				TreeIter iter = store.Append (parent);
+				AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
+					   iter);
+				inserted = true;
+#if NET_2_0
+			}
+#endif
+
+			return inserted;
+		}
+
+#if NET_2_0
+		bool InsertProxyChildren (DebuggingService dbgr, DebuggerTypeProxyAttribute pattr, TreeIter parent, ITargetStructObject sobj)
+		{
+			Mono.Debugger.StackFrame frame = dbgr.MainThread.CurrentFrame;
+	 		ITargetStructType proxy_type = frame.Language.LookupType (frame, pattr.ProxyTypeName) as ITargetStructType;
+			if (proxy_type == null)
+				proxy_type = frame.Language.LookupType (frame,
+									sobj.Type.Name + &quot;+&quot; + pattr.ProxyTypeName) as ITargetStructType;
+			if (proxy_type != null) {
+				string name = String.Format (&quot;.ctor({0})&quot;, sobj.Type.Name);
+				ITargetMethodInfo method = null;
+
+				foreach (ITargetMethodInfo m in proxy_type.Constructors) {
+					if (m.FullName == name)
+						method = m;
+				}
+
+				if (method != null) {
+					ITargetFunctionObject ctor = proxy_type.GetConstructor (frame, method.Index);
+					ITargetObject[] args = new ITargetObject[1];
+					args[0] = sobj;
+
+					ITargetStructObject proxy_obj = ctor.Type.InvokeStatic (frame, args, false) as ITargetStructObject;
+
+					if (proxy_obj != null) {
+						foreach (ITargetPropertyInfo prop in proxy_obj.Type.Properties) {
+							InsertStructMember (parent, proxy_obj, prop, false);
+						}
+
+						TreeIter iter = store.Append (parent);
+						store.SetValue (iter, NAME_COL, &quot;Raw View&quot;);
+						store.SetValue (iter, RAW_VIEW_COL, true);
+
+						Gdk.Pixbuf icon = Runtime.Gui.Resources.GetIcon (Stock.Class, Gtk.IconSize.Menu);
+						if (icon != null)
+							store.SetValue (iter, PIXBUF_COL, icon);
+
+						iters.Remove (iter);
+						AddPlaceholder (sobj, iter);
+
+						return true;
+					}
+				}
+			}
+
+			return false;
+		}
+#endif
+
+		bool InsertStructChildren (TreeIter parent, ITargetStructObject sobj, bool raw_view)
+		{
+			bool inserted = false;
+
+#if NET_2_0
+			if (!raw_view) {
+				DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
+				DebuggerTypeProxyAttribute pattr = GetDebuggerTypeProxyAttribute (dbgr, sobj);
+
+				if (pattr != null) {
+					if (InsertProxyChildren (dbgr, pattr, parent, sobj))
+						inserted = true;
+				}
+			}
+#endif
+
+			foreach (ITargetFieldInfo field in sobj.Type.Fields) {
+				if (InsertStructMember (parent, sobj, field, true))
+					inserted = true;
+			}
+
+			foreach (ITargetPropertyInfo prop in sobj.Type.Properties) {
+				if (InsertStructMember (parent, sobj, prop, false))
+					inserted = true;
+			}
+
+			return inserted;
+		}
+
+		bool InsertClassChildren (TreeIter parent, ITargetClassObject sobj, bool raw_view)
+		{
+			bool inserted = false;
+
+			if (sobj.Type.HasParent) {
+				TreeIter iter = store.Append (parent);
+				AddObject (&quot;&lt;parent&gt;&quot;, Stock.Class, sobj.Parent, iter);
+				inserted = true;
+			}
+
+			if (InsertStructChildren (parent, sobj, raw_view))
+				inserted = true;
+
+			return inserted;
+		}
+
+		void InsertMessage (TreeIter parent, string message)
+		{
+			TreeIter child;
+			if (store.IterChildren (out child, parent)) {
+				while (!(child.Equals (Gtk.TreeIter.Zero)) &amp;&amp; (child.Stamp != 0))
+					store.Remove (ref child);
+			}
+
+			TreeIter iter = store.Append (parent);
+			store.SetValue (iter, VALUE_COL, message);
+		}
+
+#if NET_2_0
+		void OnButtonRelease(object sender, Gtk.ButtonReleaseEventArgs args)
+		{
+	  		if (args.Event.Button == 3)
+				TreePopup (null, new PopupMenuArgs ());
+		}
+
+		void VisualizerActivate (object sender, EventArgs args)
+		{
+			DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
+	  		DebuggerVisualizerAttribute va_attr = (DebuggerVisualizerAttribute)visualizers_by_item [sender];
+			TreeModel model;
+			TreeIter selected_iter;
+
+			Console.WriteLine (&quot;Activating visualizer: {0}&quot;, va_attr.VisualizerTypeName);
+
+			if (va_attr == null) {
+				Console.WriteLine (&quot;blarg&quot;);
+				return;
+			}
+
+			if (!tree.Selection.GetSelected (out model, out selected_iter)) {
+				Console.WriteLine (&quot;blarg&quot;);
+				return;
+			}
+
+			Type visualizerType = Type.GetType (va_attr.VisualizerTypeName);
+			DialogDebuggerVisualizer visualizer = (DialogDebuggerVisualizer)Activator.CreateInstance (visualizerType);
+
+			// make sure the assembly defining the
+			// VisualizerObjectSource used by this
+			// visualizer is loaded into the debuggee.
+			Type sourceType = Type.GetType (va_attr.VisualizerObjectSourceTypeName);
+			dbgr.LoadLibrary (dbgr.MainThread, sourceType.Assembly.Location);
+
+			ITargetObject tobj = (ITargetObject)iters [selected_iter];
+			visualizer.Show (null, new TargetObjectProvider (tobj, sourceType.FullName));
+		}
+
+		void TreePopup (object o, PopupMenuArgs args)
+		{
+			DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
+			TreeModel model;
+			TreeIter selected_iter;
+			ITargetObject obj;
+			DebuggerVisualizerAttribute va;
+			Gtk.Menu popup_menu;
+
+			Console.WriteLine (&quot;TreePopup&quot;);
+
+			if (!tree.Selection.GetSelected (out model, out selected_iter))
+				return;
+
+			popup_menu = new Gtk.Menu ();
+
+			obj = (ITargetObject)iters [selected_iter];
+			va = GetDebuggerVisualizerAttribute (dbgr, obj);
+	    
+			if (va == null) {
+				Gtk.MenuItem item = new Gtk.MenuItem (&quot;No Visualizers Defined&quot;);
+				item.Show();
+				popup_menu.Append (item);
+			}
+			else {
+				visualizers_by_item = new Hashtable ();
+
+				Gtk.MenuItem item = new Gtk.MenuItem (&quot;Visualizers&quot;);
+				Gtk.Menu visualizer_submenu = new Gtk.Menu ();
+				Gtk.MenuItem va_item;
+
+				item.Submenu = visualizer_submenu;
+
+				va_item = new Gtk.MenuItem (va.Description != null ? va.Description : va.VisualizerTypeName);
+
+				va_item.Activated += new EventHandler (VisualizerActivate);
+
+				item.Show();
+				va_item.Show();
+
+				popup_menu.Append(item);
+				visualizer_submenu.Append (va_item);
+
+				visualizers_by_item.Add (va_item, va);
+			}
+
+			popup_menu.Popup ();
+		}
+#endif
+
+		void TestExpandRow (object o, TestExpandRowArgs args)
+		{
+			bool inserted = false;
+
+			ITargetObject obj = (ITargetObject) iters [args.Iter];
+
+			TreeIter child;
+			if (store.IterChildren (out child, args.Iter)) {
+				while (!(child.Equals (Gtk.TreeIter.Zero)) &amp;&amp; (child.Stamp != 0))
+					store.Remove (ref child);
+			}
+
+			if (obj == null) {
+				child = store.Append (args.Iter);
+				return;
+			}
+
+			switch (obj.TypeInfo.Type.Kind) {
+			case TargetObjectKind.Array:
+				ITargetArrayObject array = (ITargetArrayObject) obj;
+				try {
+					inserted = InsertArrayChildren (args.Iter, array);
+				} catch {
+					InsertMessage (args.Iter, &quot;&lt;can't display array&gt;&quot;);
+					inserted = true;
+				}
+				if (!inserted)
+					InsertMessage (args.Iter, &quot;&lt;empty array&gt;&quot;);
+				break;
+
+			case TargetObjectKind.Class:
+				ITargetClassObject cobj = (ITargetClassObject) obj;
+				try {
+					bool raw_view = (bool)store.GetValue (args.Iter, RAW_VIEW_COL);
+					inserted = InsertClassChildren (args.Iter, cobj, raw_view);
+				} catch (Exception e) {
+				  Console.WriteLine (e);
+					InsertMessage (args.Iter, &quot;&lt;can't display class&gt;&quot;);
+					inserted = true;
+				}
+				if (!inserted)
+					InsertMessage (args.Iter, &quot;&lt;empty class&gt;&quot;);
+				break;
+
+			case TargetObjectKind.Struct:
+				ITargetStructObject sobj = (ITargetStructObject) obj;
+				try {
+					bool raw_view = (bool)store.GetValue (args.Iter, RAW_VIEW_COL);
+					inserted = InsertStructChildren (args.Iter, sobj, raw_view);
+				} catch {
+					InsertMessage (args.Iter, &quot;&lt;can't display struct&gt;&quot;);
+					inserted = true;
+				}
+				if (!inserted)
+					InsertMessage (args.Iter, &quot;&lt;empty struct&gt;&quot;);
+				break;
+
+			default:
+				InsertMessage (args.Iter, &quot;&lt;unknown object&gt;&quot;);
+				break;
+			}
+		}
+
+		void AddPlaceholder (ITargetObject obj, TreeIter parent)
+		{
+			if (obj.TypeInfo.Type.Kind == TargetObjectKind.Array) {
+				ITargetArrayObject array = (ITargetArrayObject) obj;
+				if (array.LowerBound == array.UpperBound)
+					return;
+			}
+
+			store.Append (parent);
+			iters.Add (parent, obj);
+		}
+
+		string GetObjectValueString (ITargetObject obj)
+		{
+			if (obj == null) {
+				return &quot;null&quot;;
+			}
+
+			switch (obj.TypeInfo.Type.Kind) {
+			case TargetObjectKind.Fundamental:
+				object contents = ((ITargetFundamentalObject) obj).Object;
+				return contents.ToString ();
+
+			case TargetObjectKind.Array:
+				ITargetArrayObject array = (ITargetArrayObject) obj;
+				if (array.LowerBound == array.UpperBound &amp;&amp; array.LowerBound == 0)
+					return &quot;[]&quot;;
+				else
+					return &quot;&quot;;
+
+			case TargetObjectKind.Struct:
+			case TargetObjectKind.Class:
+				try {
+#if NET_2_0
+					DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
+					DebuggerDisplayAttribute dattr = GetDebuggerDisplayAttribute (dbgr, obj);
+					if (dattr != null) {
+						return dbgr.AttributeHandler.EvaluateDebuggerDisplay (obj, dattr.Value);
+					}
+					else {
+#endif
+						// call the object's ToString() method.
+						return ((ITargetStructObject)obj).PrintObject();
+#if NET_2_0
+					}
+#endif
+				}
+				catch (Exception e) {
+				  //Console.WriteLine (&quot;getting object value failed: {0}&quot;, e);
+					return &quot;&quot;;
+				}
+			default:
+				return &quot;&quot;;
+			}
+		}
+
+		void AddObject (string name, string icon_name, ITargetObject obj, TreeIter iter)
+		{
+			store.SetValue (iter, NAME_COL, name);
+			store.SetValue (iter, VALUE_COL, GetObjectValueString (obj));
+			store.SetValue (iter, TYPE_COL,
+					obj == null ? &quot;&quot; : Runtime.Ambience.CurrentAmbience.GetIntrinsicTypeName (obj.TypeInfo.Type.Name));
+			Gdk.Pixbuf icon = Runtime.Gui.Resources.GetIcon (icon_name, Gtk.IconSize.Menu);
+			if (icon != null)
+				store.SetValue (iter, PIXBUF_COL, icon);
+			if (obj != null)
+				AddPlaceholder (obj, iter);
+		}
+
+		string GetIcon (ITargetObject obj)
+		{
+			string icon = &quot;&quot;;
+
+			if (obj.TypeInfo.Type.TypeHandle is Type)
+				icon = Runtime.Gui.Icons.GetIcon ((Type)obj.TypeInfo.Type.TypeHandle);
+
+			return icon;
+		}
+
+		string GetIcon (ITargetMemberInfo member)
+		{
+			string icon = &quot;&quot;;
+
+			if (member.Handle is PropertyInfo)
+				icon = Runtime.Gui.Icons.GetIcon ((PropertyInfo)member.Handle);
+			else if (member.Handle is FieldInfo)
+				icon = Runtime.Gui.Icons.GetIcon ((FieldInfo)member.Handle);
+
+			return icon;
+		}
+
+		void UpdateVariableChildren (IVariable variable, ITargetObject obj, TreePath path, TreeIter iter)
+		{
+			bool expanded = tree.GetRowExpanded (path);
+			TreeIter citer;
+
+			if (!expanded) {
+
+				/* we aren't expanded, just remove all
+				 * children and add the object back
+				 * (since it might be a different
+				 * object now) */
+
+				if (store.IterChildren (out citer, iter))
+					while (store.Remove (ref citer)) ;
+				iters.Remove (iter);
+
+				AddPlaceholder (obj, iter);
+			}
+			else {
+				/* in a perfect world, we'd just iterate
+				 * over the stuff we're showing and update
+				 * it.  for now, just remove all rows and
+				 * re-add them. */
+
+				if (store.IterChildren (out citer, iter))
+					while (store.Remove (ref citer)) ;
+
+				iters.Remove (iter);
+
+				AddObject (variable.Name, GetIcon (obj), obj, iter);
+
+				tree.ExpandRow (path, false);
+			}
+		}
+
+		void UpdateVariable (IVariable variable)
+		{
+			TreeRowReference row = (TreeRowReference)variable_rows[variable];
+
+			if (row == null) {
+				/* the variable isn't presently displayed */
+
+				if (!variable.IsAlive (current_frame.TargetAddress))
+					/* it's not displayed and not alive, just return */
+					return;
+
+				AddVariable (variable);
+			}
+			else {
+				/* the variable is presently displayed */
+
+				// XXX we need a obj.IsValid check in this branch
+
+				if (!variable.IsAlive (current_frame.TargetAddress)) {
+					/* it's in the display but no longer alive.  remove it */
+					RemoveVariable (variable);
+					return;
+				}
+
+				/* it's still alive - make sure the display is up to date */
+				TreeIter iter;
+				if (store.GetIter (out iter, row.Path)) {
+					try {
+						ITargetObject obj = variable.GetObject (current_frame);
+
+						/* make sure the Value column is correct */
+						string current_value = (string)store.GetValue (iter, VALUE_COL);
+						string new_value = GetObjectValueString (obj);
+						if (current_value != new_value)
+							store.SetValue (iter, VALUE_COL, new_value);
+
+						/* update the children */
+						UpdateVariableChildren (variable, obj, row.Path, iter);
+
+					} catch (Exception e) {
+						Console.WriteLine (&quot;can't update variable: {0} {1}&quot;, variable, e);
+						store.SetValue (iter, VALUE_COL, &quot;&quot;);
+					}
+				}
+			}
+		}
+
+		void AddVariable (IVariable variable)
+		{
+			try {
+				/* it's alive, add it to the display */
+
+				ITargetObject obj = variable.GetObject (current_frame);
+				TreeIter iter;
+
+				if (!obj.IsValid)
+					return;
+
+				store.Append (out iter);
+
+				variable_rows.Add (variable, new TreeRowReference (store, store.GetPath (iter)));
+
+				AddObject (variable.Name, GetIcon (obj), obj, iter);
+			} catch (LocationInvalidException) {
+				// Do nothing
+			} catch (Exception e) {
+				Console.WriteLine (&quot;can't add variable: {0} {1}&quot;, variable, e);
+			}
+		}
+
+		void RemoveVariable (IVariable variable)
+		{
+			TreeRowReference row = (TreeRowReference)variable_rows[variable];
+			TreeIter iter;
+
+			if (row != null &amp;&amp; store.GetIter (out iter, row.Path)) {
+				iters.Remove (iter);
+				store.Remove (ref iter);
+			}
+
+			variable_rows.Remove (variable);
+		}
+
+		public void UpdateDisplay ()
+		{
+			if ((current_frame == null) || (current_frame.Method == null))
+				return;
+
+			try {
+				Hashtable vars_to_remove = new Hashtable();
+
+				foreach (IVariable var in variable_rows.Keys) {
+					vars_to_remove.Add (var, var);
+				}
+
+				// this
+				if (current_frame.Method.HasThis) {
+					UpdateVariable (current_frame.Method.This);
+					vars_to_remove.Remove (current_frame.Method.This);
+				}
+
+				// locals
+				IVariable[] local_vars = current_frame.Method.Locals;
+				foreach (IVariable var in local_vars) {
+					UpdateVariable (var);
+					vars_to_remove.Remove (var);
+				}
+
+				// parameters
+				IVariable[] param_vars = current_frame.Method.Parameters;
+				foreach (IVariable var in param_vars) {
+					UpdateVariable (var);
+					vars_to_remove.Remove (var);
+				}
+
+				foreach (IVariable var in vars_to_remove.Keys) {
+					RemoveVariable (var);
+				}
+
+			} catch (Exception e) {
+				Console.WriteLine (&quot;error getting variables for current stack frame: {0}&quot;, e);
+				store.Clear ();
+				iters = new Hashtable ();
+			}
+		}
+
+		protected void OnStoppedEvent (object o, EventArgs args)
+		{
+			current_frame = (Mono.Debugger.StackFrame)Runtime.DebuggingService.CurrentFrame;
+			UpdateDisplay ();
+		}
+
+		protected void OnPausedEvent (object o, EventArgs args)
+		{
+			current_frame = (Mono.Debugger.StackFrame)Runtime.DebuggingService.CurrentFrame;
+			UpdateDisplay ();
+		}
+
+#if NET_2_0
+		DebuggerBrowsableAttribute GetDebuggerBrowsableAttribute (ITargetMemberInfo info)
+		{
+	  		if (info.Handle != null &amp;&amp; info.Handle is System.Reflection.MemberInfo) {
+				System.Reflection.MemberInfo mi = (System.Reflection.MemberInfo)info.Handle;
+				object[] attrs = mi.GetCustomAttributes (typeof (DebuggerBrowsableAttribute), false);
+
+				if (attrs != null &amp;&amp; attrs.Length &gt; 0)
+					return (DebuggerBrowsableAttribute)attrs[0];
+			}
+
+			return null;
+		}
+
+		DebuggerTypeProxyAttribute GetDebuggerTypeProxyAttribute (DebuggingService dbgr, ITargetObject obj)
+		{
+			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
+				return dbgr.AttributeHandler.GetDebuggerTypeProxyAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
+
+			return null;
+		}
+
+		DebuggerDisplayAttribute GetDebuggerDisplayAttribute (DebuggingService dbgr, ITargetObject obj)
+		{
+			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
+			  return dbgr.AttributeHandler.GetDebuggerDisplayAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
+
+			return null;
+		}
+
+		DebuggerVisualizerAttribute GetDebuggerVisualizerAttribute (DebuggingService dbgr, ITargetObject obj)
+		{
+			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
+			  return dbgr.AttributeHandler.GetDebuggerVisualizerAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
+
+			return null;
+		}
+#endif
+
 		public Gtk.Widget Control {
 			get {
 				return this;

Deleted: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/VariablePad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/VariablePad.cs	2005-04-03 20:30:46 UTC (rev 2421)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Gui/VariablePad.cs	2005-04-05 20:06:23 UTC (rev 2422)
@@ -1,660 +0,0 @@
-using GLib;
-using Gtk;
-using GtkSharp;
-using System;
-using System.Diagnostics;
-using System.IO;
-using System.Collections;
-using System.Globalization;
-using System.Text;
-using System.Reflection;
-using System.Runtime.InteropServices;
-using Mono.Debugger;
-using Mono.Debugger.Languages;
-
-using Stock = MonoDevelop.Gui.Stock;
-using MonoDevelop.Core.Services;
-using MonoDevelop.Internal.Parser;
-using MonoDevelop.Services;
-
-namespace MonoDevelop.Debugger
-{
-	public class VariablePad : Gtk.ScrolledWindow
-	{
-		Mono.Debugger.StackFrame current_frame;
-
-		Hashtable variable_rows;
-		Hashtable iters;
-
-		Gtk.TreeView tree;
-		Gtk.TreeStore store;
-		bool is_locals_display;
-
-		internal const int NAME_COL = 0;
-		internal const int VALUE_COL = 1;
-		internal const int TYPE_COL = 2;
-		internal const int RAW_VIEW_COL = 3;
-		internal const int PIXBUF_COL = 4;
-
-		public VariablePad (bool is_locals_display)
-		{
-			this.ShadowType = ShadowType.In;
-
-			this.is_locals_display = is_locals_display;
-
-			variable_rows = new Hashtable();
-			iters = new Hashtable();
-
-			store = new TreeStore (typeof (string),
-					       typeof (string),
-			                       typeof (string),
-					       typeof (bool),
-					       typeof (Gdk.Pixbuf));
-
-			tree = new TreeView (store);
-			tree.RulesHint = true;
-			tree.HeadersVisible = true;
-
-			TreeViewColumn NameCol = new TreeViewColumn ();
-			CellRenderer NameRenderer = new CellRendererText ();
-			CellRenderer IconRenderer = new CellRendererPixbuf ();
-			NameCol.Title = &quot;Name&quot;;
-			NameCol.PackStart (IconRenderer, false);
-			NameCol.PackStart (NameRenderer, true);
-			NameCol.AddAttribute (IconRenderer, &quot;pixbuf&quot;, PIXBUF_COL);
-			NameCol.AddAttribute (NameRenderer, &quot;text&quot;, NAME_COL);
-			NameCol.Resizable = true;
-			NameCol.Alignment = 0.0f;
-			tree.AppendColumn (NameCol);
-
-			TreeViewColumn ValueCol = new TreeViewColumn ();
-			CellRenderer ValueRenderer = new CellRendererText ();
-			ValueCol.Title = &quot;Value&quot;;
-			ValueCol.PackStart (ValueRenderer, true);
-			ValueCol.AddAttribute (ValueRenderer, &quot;text&quot;, VALUE_COL);
-			ValueCol.Resizable = true;
-			NameCol.Alignment = 0.0f;
-			tree.AppendColumn (ValueCol);
-
-			TreeViewColumn TypeCol = new TreeViewColumn ();
-			CellRenderer TypeRenderer = new CellRendererText ();
-			TypeCol.Title = &quot;Type&quot;;
-			TypeCol.PackStart (TypeRenderer, true);
-			TypeCol.AddAttribute (TypeRenderer, &quot;text&quot;, TYPE_COL);
-			TypeCol.Resizable = true;
-			NameCol.Alignment = 0.0f;
-			tree.AppendColumn (TypeCol);
-
-			tree.TestExpandRow += new TestExpandRowHandler (TestExpandRow);
-
-			Add (tree);
-			ShowAll ();
-
-			Runtime.DebuggingService.PausedEvent += new EventHandler (OnPausedEvent);
-			Runtime.DebuggingService.StoppedEvent += new EventHandler (OnStoppedEvent);
-		}
-
-		bool InsertArrayChildren (TreeIter parent, ITargetArrayObject array)
-		{
-			bool inserted = false;
-
-			for (int i = array.LowerBound; i &lt; array.UpperBound; i++) {
-
-				inserted = true;
-
-				ITargetObject elt = array [i];
-				if (elt == null)
-					continue;
-
-				TreeIter iter = store.Append (parent);
-				AddObject (i.ToString (), &quot;&quot; /* XXX */, elt, iter);
-			}
-
-			return inserted;
-		}
-
-		bool InsertStructMember (TreeIter parent, ITargetStructObject sobj, ITargetMemberInfo member, bool is_field)
-		{
-			bool inserted = false;
-
-			string icon_name = GetIcon (member);
-
-#if NET_2_0
-			DebuggerBrowsableAttribute battr = GetDebuggerBrowsableAttribute (member);
-			if (battr != null) {
-				TreeIter iter;
-
-				switch (battr.State) {
-				case DebuggerBrowsableState.Never:
-					// don't display it at all
-					continue;
-				case DebuggerBrowsableState.Collapsed:
-					// the default behavior for the debugger (c&amp;p from above)
-					iter = store.Append (parent);
-					AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
-						   iter);
-					inserted = true;
-					break;
-				case DebuggerBrowsableState.Expanded:
-					// add it as in the Collapsed case...
-					iter = store.Append (parent);
-					AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
-						   iter);
-					inserted = true;
-					// then expand the row
-					tree.ExpandRow (store.GetPath (iter), false);
-					break;
-				case DebuggerBrowsableState.RootHidden:
-					ITargetObject member_obj = is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index);
-
-					if (member_obj != null) {
-						switch (member_obj.TypeInfo.Type.Kind) {
-						case TargetObjectKind.Array:
-							iter = store.Append (parent);
-							// handle arrays normally, should check how vs2005 does this.
-							AddObject (member.Name, icon_name, member_obj, iter);
-							inserted = true;
-							break;
-						case TargetObjectKind.Class:
-							try {
-								inserted = InsertClassChildren (parent, (ITargetClassObject)member_obj, false);
-							}
-							catch {
-								// what about this case?  where the member is possibly
-								// uninitialized, do we try to add it later?
-							}
-							break;
-						case TargetObjectKind.Struct:
-							try {
-								inserted = InsertStructChildren (parent, (ITargetStructObject)member_obj, false);
-							}
-							catch {
-								// what about this case?  where the member is possibly
-								// uninitialized, do we try to add it later?
-							}
-							break;
-						default:
-							// nothing
-							break;
-						}
-					}
-					break;
-				}
-			}
-			else {
-#endif
-				TreeIter iter = store.Append (parent);
-				AddObject (member.Name, icon_name, is_field ? sobj.GetField (member.Index) : sobj.GetProperty (member.Index),
-					   iter);
-				inserted = true;
-#if NET_2_0
-			}
-#endif
-
-			return inserted;
-		}
-
-#if NET_2_0
-		bool InsertProxyChildren (DebuggingService dbgr, DebuggerTypeProxyAttribute pattr, TreeIter parent, ITargetStructObject sobj)
-		{
-			Mono.Debugger.StackFrame frame = dbgr.MainThread.CurrentFrame;
-	 		ITargetStructType proxy_type = frame.Language.LookupType (frame, pattr.ProxyTypeName) as ITargetStructType;
-			if (proxy_type == null)
-				proxy_type = frame.Language.LookupType (frame,
-									sobj.Type.Name + &quot;+&quot; + pattr.ProxyTypeName) as ITargetStructType;
-			if (proxy_type != null) {
-				string name = String.Format (&quot;.ctor({0})&quot;, sobj.Type.Name);
-				ITargetMethodInfo method = null;
-
-				foreach (ITargetMethodInfo m in proxy_type.Constructors) {
-					if (m.FullName == name)
-						method = m;
-				}
-
-				if (method != null) {
-					ITargetFunctionObject ctor = proxy_type.GetConstructor (frame, method.Index);
-					ITargetObject[] args = new ITargetObject[1];
-					args[0] = sobj;
-
-					ITargetStructObject proxy_obj = ctor.Type.InvokeStatic (frame, args, false) as ITargetStructObject;
-
-					if (proxy_obj != null) {
-						foreach (ITargetPropertyInfo prop in proxy_obj.Type.Properties) {
-							InsertStructMember (parent, proxy_obj, prop, false);
-						}
-
-						TreeIter iter = store.Append (parent);
-						store.SetValue (iter, NAME_COL, &quot;Raw View&quot;);
-						store.SetValue (iter, RAW_VIEW_COL, true);
-
-						Gdk.Pixbuf icon = Runtime.Gui.Resources.GetIcon (Stock.Class, Gtk.IconSize.Menu);
-						if (icon != null)
-							store.SetValue (iter, PIXBUF_COL, icon);
-
-						iters.Remove (iter);
-						AddPlaceholder (sobj, iter);
-
-						return true;
-					}
-				}
-			}
-
-			return false;
-		}
-#endif
-
-		bool InsertStructChildren (TreeIter parent, ITargetStructObject sobj, bool raw_view)
-		{
-			bool inserted = false;
-
-#if NET_2_0
-			if (!raw_view) {
-				DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
-				DebuggerTypeProxyAttribute pattr = GetDebuggerTypeProxyAttribute (dbgr, sobj);
-
-				if (pattr != null) {
-					if (InsertProxyChildren (dbgr, pattr, parent, sobj))
-						inserted = true;
-				}
-			}
-#endif
-
-			foreach (ITargetFieldInfo field in sobj.Type.Fields) {
-				if (InsertStructMember (parent, sobj, field, true))
-					inserted = true;
-			}
-
-			foreach (ITargetPropertyInfo prop in sobj.Type.Properties) {
-				if (InsertStructMember (parent, sobj, prop, false))
-					inserted = true;
-			}
-
-			return inserted;
-		}
-
-		bool InsertClassChildren (TreeIter parent, ITargetClassObject sobj, bool raw_view)
-		{
-			bool inserted = false;
-
-			if (sobj.Type.HasParent) {
-				TreeIter iter = store.Append (parent);
-				AddObject (&quot;&lt;parent&gt;&quot;, Stock.Class, sobj.Parent, iter);
-				inserted = true;
-			}
-
-			if (InsertStructChildren (parent, sobj, raw_view))
-				inserted = true;
-
-			return inserted;
-		}
-
-		void InsertMessage (TreeIter parent, string message)
-		{
-			TreeIter child;
-			if (store.IterChildren (out child, parent)) {
-				while (!(child.Equals (Gtk.TreeIter.Zero)) &amp;&amp; (child.Stamp != 0))
-					store.Remove (ref child);
-			}
-
-			TreeIter iter = store.Append (parent);
-			store.SetValue (iter, VALUE_COL, message);
-		}
-
-		void TestExpandRow (object o, TestExpandRowArgs args)
-		{
-			bool inserted = false;
-
-			ITargetObject obj = (ITargetObject) iters [args.Iter];
-
-			TreeIter child;
-			if (store.IterChildren (out child, args.Iter)) {
-				while (!(child.Equals (Gtk.TreeIter.Zero)) &amp;&amp; (child.Stamp != 0))
-					store.Remove (ref child);
-			}
-
-			if (obj == null) {
-				child = store.Append (args.Iter);
-				return;
-			}
-
-			switch (obj.TypeInfo.Type.Kind) {
-			case TargetObjectKind.Array:
-				ITargetArrayObject array = (ITargetArrayObject) obj;
-				try {
-					inserted = InsertArrayChildren (args.Iter, array);
-				} catch {
-					InsertMessage (args.Iter, &quot;&lt;can't display array&gt;&quot;);
-					inserted = true;
-				}
-				if (!inserted)
-					InsertMessage (args.Iter, &quot;&lt;empty array&gt;&quot;);
-				break;
-
-			case TargetObjectKind.Class:
-				ITargetClassObject cobj = (ITargetClassObject) obj;
-				try {
-					bool raw_view = (bool)store.GetValue (args.Iter, RAW_VIEW_COL);
-					inserted = InsertClassChildren (args.Iter, cobj, raw_view);
-				} catch (Exception e) {
-				  Console.WriteLine (e);
-					InsertMessage (args.Iter, &quot;&lt;can't display class&gt;&quot;);
-					inserted = true;
-				}
-				if (!inserted)
-					InsertMessage (args.Iter, &quot;&lt;empty class&gt;&quot;);
-				break;
-
-			case TargetObjectKind.Struct:
-				ITargetStructObject sobj = (ITargetStructObject) obj;
-				try {
-					bool raw_view = (bool)store.GetValue (args.Iter, RAW_VIEW_COL);
-					inserted = InsertStructChildren (args.Iter, sobj, raw_view);
-				} catch {
-					InsertMessage (args.Iter, &quot;&lt;can't display struct&gt;&quot;);
-					inserted = true;
-				}
-				if (!inserted)
-					InsertMessage (args.Iter, &quot;&lt;empty struct&gt;&quot;);
-				break;
-
-			default:
-				InsertMessage (args.Iter, &quot;&lt;unknown object&gt;&quot;);
-				break;
-			}
-		}
-
-		void AddPlaceholder (ITargetObject obj, TreeIter parent)
-		{
-			if (obj.TypeInfo.Type.Kind == TargetObjectKind.Array) {
-				ITargetArrayObject array = (ITargetArrayObject) obj;
-				if (array.LowerBound == array.UpperBound)
-					return;
-			}
-
-			store.Append (parent);
-			iters.Add (parent, obj);
-		}
-
-		string GetObjectValueString (ITargetObject obj)
-		{
-			if (obj == null) {
-				return &quot;null&quot;;
-			}
-
-			switch (obj.TypeInfo.Type.Kind) {
-			case TargetObjectKind.Fundamental:
-				object contents = ((ITargetFundamentalObject) obj).Object;
-				return contents.ToString ();
-
-			case TargetObjectKind.Array:
-				ITargetArrayObject array = (ITargetArrayObject) obj;
-				if (array.LowerBound == array.UpperBound &amp;&amp; array.LowerBound == 0)
-					return &quot;[]&quot;;
-				else
-					return &quot;&quot;;
-
-			case TargetObjectKind.Struct:
-			case TargetObjectKind.Class:
-				try {
-#if NET_2_0
-					DebuggingService dbgr = (DebuggingService)Runtime.DebuggingService;
-					DebuggerDisplayAttribute dattr = GetDebuggerDisplayAttribute (dbgr, obj);
-					if (dattr != null) {
-						return dbgr.AttributeHandler.EvaluateDebuggerDisplay (obj, dattr.Value);
-					}
-					else {
-#endif
-						// call the object's ToString() method.
-						return ((ITargetStructObject)obj).PrintObject();
-#if NET_2_0
-					}
-#endif
-				}
-				catch (Exception e) {
-				  //Console.WriteLine (&quot;getting object value failed: {0}&quot;, e);
-					return &quot;&quot;;
-				}
-			default:
-				return &quot;&quot;;
-			}
-		}
-
-		void AddObject (string name, string icon_name, ITargetObject obj, TreeIter iter)
-		{
-			store.SetValue (iter, NAME_COL, name);
-			store.SetValue (iter, VALUE_COL, GetObjectValueString (obj));
-			store.SetValue (iter, TYPE_COL,
-					obj == null ? &quot;&quot; : Runtime.Ambience.CurrentAmbience.GetIntrinsicTypeName (obj.TypeInfo.Type.Name));
-			Gdk.Pixbuf icon = Runtime.Gui.Resources.GetIcon (icon_name, Gtk.IconSize.Menu);
-			if (icon != null)
-				store.SetValue (iter, PIXBUF_COL, icon);
-			if (obj != null)
-				AddPlaceholder (obj, iter);
-		}
-
-		string GetIcon (ITargetObject obj)
-		{
-			string icon = &quot;&quot;;
-
-			if (obj.TypeInfo.Type.TypeHandle is Type)
-				icon = Runtime.Gui.Icons.GetIcon ((Type)obj.TypeInfo.Type.TypeHandle);
-
-			return icon;
-		}
-
-		string GetIcon (ITargetMemberInfo member)
-		{
-			string icon = &quot;&quot;;
-
-			if (member.Handle is PropertyInfo)
-				icon = Runtime.Gui.Icons.GetIcon ((PropertyInfo)member.Handle);
-			else if (member.Handle is FieldInfo)
-				icon = Runtime.Gui.Icons.GetIcon ((FieldInfo)member.Handle);
-
-			return icon;
-		}
-
-		void UpdateVariableChildren (IVariable variable, ITargetObject obj, TreePath path, TreeIter iter)
-		{
-			bool expanded = tree.GetRowExpanded (path);
-			TreeIter citer;
-
-			if (!expanded) {
-
-				/* we aren't expanded, just remove all
-				 * children and add the object back
-				 * (since it might be a different
-				 * object now) */
-
-				if (store.IterChildren (out citer, iter))
-					while (store.Remove (ref citer)) ;
-				iters.Remove (iter);
-
-				AddPlaceholder (obj, iter);
-			}
-			else {
-				/* in a perfect world, we'd just iterate
-				 * over the stuff we're showing and update
-				 * it.  for now, just remove all rows and
-				 * re-add them. */
-
-				if (store.IterChildren (out citer, iter))
-					while (store.Remove (ref citer)) ;
-
-				iters.Remove (iter);
-
-				AddObject (variable.Name, GetIcon (obj), obj, iter);
-
-				tree.ExpandRow (path, false);
-			}
-		}
-
-		void UpdateVariable (IVariable variable)
-		{
-			TreeRowReference row = (TreeRowReference)variable_rows[variable];
-
-			if (row == null) {
-				/* the variable isn't presently displayed */
-
-				if (!variable.IsAlive (current_frame.TargetAddress))
-					/* it's not displayed and not alive, just return */
-					return;
-
-				AddVariable (variable);
-			}
-			else {
-				/* the variable is presently displayed */
-
-				// XXX we need a obj.IsValid check in this branch
-
-				if (!variable.IsAlive (current_frame.TargetAddress)) {
-					/* it's in the display but no longer alive.  remove it */
-					RemoveVariable (variable);
-					return;
-				}
-
-				/* it's still alive - make sure the display is up to date */
-				TreeIter iter;
-				if (store.GetIter (out iter, row.Path)) {
-					try {
-						ITargetObject obj = variable.GetObject (current_frame);
-
-						/* make sure the Value column is correct */
-						string current_value = (string)store.GetValue (iter, VALUE_COL);
-						string new_value = GetObjectValueString (obj);
-						if (current_value != new_value)
-							store.SetValue (iter, VALUE_COL, new_value);
-
-						/* update the children */
-						UpdateVariableChildren (variable, obj, row.Path, iter);
-
-					} catch (Exception e) {
-						Console.WriteLine (&quot;can't update variable: {0} {1}&quot;, variable, e);
-						store.SetValue (iter, VALUE_COL, &quot;&quot;);
-					}
-				}
-			}
-		}
-
-		void AddVariable (IVariable variable)
-		{
-			try {
-				/* it's alive, add it to the display */
-
-				ITargetObject obj = variable.GetObject (current_frame);
-				TreeIter iter;
-
-				if (!obj.IsValid)
-					return;
-
-				store.Append (out iter);
-
-				variable_rows.Add (variable, new TreeRowReference (store, store.GetPath (iter)));
-
-				AddObject (variable.Name, GetIcon (obj), obj, iter);
-			} catch (LocationInvalidException) {
-				// Do nothing
-			} catch (Exception e) {
-				Console.WriteLine (&quot;can't add variable: {0} {1}&quot;, variable, e);
-			}
-		}
-
-		void RemoveVariable (IVariable variable)
-		{
-			TreeRowReference row = (TreeRowReference)variable_rows[variable];
-			TreeIter iter;
-
-			if (row != null &amp;&amp; store.GetIter (out iter, row.Path)) {
-				iters.Remove (iter);
-				store.Remove (ref iter);
-			}
-
-			variable_rows.Remove (variable);
-		}
-
-		public void UpdateDisplay ()
-		{
-			if ((current_frame == null) || (current_frame.Method == null))
-				return;
-
-			try {
-				Hashtable vars_to_remove = new Hashtable();
-
-				foreach (IVariable var in variable_rows.Keys) {
-					vars_to_remove.Add (var, var);
-				}
-
-				if (is_locals_display) {
-					if (current_frame.Method.HasThis) {
-						UpdateVariable (current_frame.Method.This);
-						vars_to_remove.Remove (current_frame.Method.This);
-					}
-					IVariable[] local_vars = current_frame.Method.Locals;
-					foreach (IVariable var in local_vars) {
-						UpdateVariable (var);
-						vars_to_remove.Remove (var);
-					}
-				} else {
-					IVariable[] param_vars = current_frame.Method.Parameters;
-					foreach (IVariable var in param_vars) {
-						UpdateVariable (var);
-						vars_to_remove.Remove (var);
-					}
-				}
-
-				foreach (IVariable var in vars_to_remove.Keys) {
-					RemoveVariable (var);
-				}
-
-			} catch (Exception e) {
-				Console.WriteLine (&quot;CAN'T GET VARIABLES: {0}&quot;, e);
-				store.Clear ();
-				iters = new Hashtable ();
-			}
-		}
-
-		protected void OnStoppedEvent (object o, EventArgs args)
-		{
-			current_frame = (Mono.Debugger.StackFrame)Runtime.DebuggingService.CurrentFrame;
-			UpdateDisplay ();
-		}
-
-		protected void OnPausedEvent (object o, EventArgs args)
-		{
-			current_frame = (Mono.Debugger.StackFrame)Runtime.DebuggingService.CurrentFrame;
-			UpdateDisplay ();
-		}
-
-#if NET_2_0
-		DebuggerBrowsableAttribute GetDebuggerBrowsableAttribute (ITargetMemberInfo info)
-		{
-	  		if (info.Handle != null &amp;&amp; info.Handle is System.Reflection.MemberInfo) {
-				System.Reflection.MemberInfo mi = (System.Reflection.MemberInfo)info.Handle;
-				object[] attrs = mi.GetCustomAttributes (typeof (DebuggerBrowsableAttribute), false);
-
-				if (attrs != null &amp;&amp; attrs.Length &gt; 0)
-					return (DebuggerBrowsableAttribute)attrs[0];
-			}
-
-			return null;
-		}
-
-		DebuggerTypeProxyAttribute GetDebuggerTypeProxyAttribute (DebuggingService dbgr, ITargetObject obj)
-		{
-			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
-				return dbgr.AttributeHandler.GetDebuggerTypeProxyAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
-
-			return null;
-		}
-
-		DebuggerDisplayAttribute GetDebuggerDisplayAttribute (DebuggingService dbgr, ITargetObject obj)
-		{
-			if (obj.TypeInfo.Type.TypeHandle != null &amp;&amp; obj.TypeInfo.Type.TypeHandle is Type)
-			  return dbgr.AttributeHandler.GetDebuggerDisplayAttribute ((Type)obj.TypeInfo.Type.TypeHandle);
-
-			return null;
-		}
-#endif
-
-	}
-}

Modified: trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am	2005-04-03 20:30:46 UTC (rev 2421)
+++ trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn/Makefile.am	2005-04-05 20:06:23 UTC (rev 2422)
@@ -18,7 +18,6 @@
 DebuggerASTVisitor.cs \
 DebugAttributeHandler.cs \
 Gui/LocalsPad.cs \
-Gui/VariablePad.cs \
 Gui/StackTracePad.cs \
 Gui/ThreadPad.cs
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002023.html">[Monodevelop-patches-list] r2421 - trunk/MonoDevelop
</A></li>
	<LI>Next message: <A HREF="002025.html">[Monodevelop-patches-list] r2423 - in trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor: . Gui/OptionPanels Services
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2024">[ date ]</a>
              <a href="thread.html#2024">[ thread ]</a>
              <a href="subject.html#2024">[ subject ]</a>
              <a href="author.html#2024">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
