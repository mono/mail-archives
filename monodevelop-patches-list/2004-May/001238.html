<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1631 - in trunk/MonoDevelop: . src src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow src/Libraries/SharpRefactory src/Libraries/SharpRefactory/src/Parser/AST src/Main/Base src/Main/Base/Commands src/Main/Base/Commands/ProjectBrowserCommands src/Main/Base/Gui src/Main/Base/Gui/Pads/ClassScout src/Main/Base/Gui/Pads/ClassScout/NodeBuilder src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode src/Main/Base/Gui/Workbench/Layouts src/Main/Base/Internal/Parser src/Main/Base/Internal/Parser/Implementations src/Main/Base/Internal/Parser/PersistenceLayer src/Main/Base/Internal/Parser/ReflectionLayer src/Main/Base/Internal/Project/Combine src/Main/Base/Internal/Project/Project src/Main/Base/Internal/Project/Project/Collections src/Main/Base/Services/File src/Main/Base/Services/ParserService src/Main/Base/Services/Pr oject src/Tools src/Tools/dbgen src/Tools/dbgen/src
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1631%20-%20in%20trunk/MonoDevelop%3A%20.%20src%20src/AddIns/BackendBindings/CSharpBinding%20src/AddIns/BackendBindings/CSharpBinding/Parser%20src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow%20src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow%20src/Libraries/SharpRefactory%20src/Libraries/SharpRefactory/src/Parser/AST%20src/Main/Base%20src/Main/Base/Commands%20src/Main/Base/Commands/ProjectBrowserCommands%20src/Main/Base/Gui%20src/Main/Base/Gui/Pads/ClassScout%20src/Main/Base/Gui/Pads/ClassScout/NodeBuilder%20src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode%20src/Main/Base/Gui/Workbench/Layouts%20src/Main/Base/Internal/Parser%20src/Main/Base/Internal/Parser/Implementations%20src/Main/Base/Internal/Parser/PersistenceLayer%20src/Main/Base/Internal/Parser/ReflectionLayer%20src/Main/Base/Internal/Project/Combine%20src/Main/Base/Internal/Project/Project%20src/Main/Base/Internal/Project/Project/Collections%20src/Main/Base/Services/File%20src/Main/Base/Services/ParserService%20src/Main/Base/Services/Pr%0A%20oject%20src/Tools%20src/Tools/dbgen%20src/Tools/dbgen/src&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001237.html">
   <LINK REL="Next"  HREF="001239.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1631 - in trunk/MonoDevelop: . src src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow src/Libraries/SharpRefactory src/Libraries/SharpRefactory/src/Parser/AST src/Main/Base src/Main/Base/Commands src/Main/Base/Commands/ProjectBrowserCommands src/Main/Base/Gui src/Main/Base/Gui/Pads/ClassScout src/Main/Base/Gui/Pads/ClassScout/NodeBuilder src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode src/Main/Base/Gui/Workbench/Layouts src/Main/Base/Internal/Parser src/Main/Base/Internal/Parser/Implementations src/Main/Base/Internal/Parser/PersistenceLayer src/Main/Base/Internal/Parser/ReflectionLayer src/Main/Base/Internal/Project/Combine src/Main/Base/Internal/Project/Project src/Main/Base/Internal/Project/Project/Collections src/Main/Base/Services/File src/Main/Base/Services/ParserService src/Main/Base/Services/Pr oject src/Tools src/Tools/dbgen src/Tools/dbgen/src</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1631%20-%20in%20trunk/MonoDevelop%3A%20.%20src%20src/AddIns/BackendBindings/CSharpBinding%20src/AddIns/BackendBindings/CSharpBinding/Parser%20src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow%20src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow%20src/Libraries/SharpRefactory%20src/Libraries/SharpRefactory/src/Parser/AST%20src/Main/Base%20src/Main/Base/Commands%20src/Main/Base/Commands/ProjectBrowserCommands%20src/Main/Base/Gui%20src/Main/Base/Gui/Pads/ClassScout%20src/Main/Base/Gui/Pads/ClassScout/NodeBuilder%20src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode%20src/Main/Base/Gui/Workbench/Layouts%20src/Main/Base/Internal/Parser%20src/Main/Base/Internal/Parser/Implementations%20src/Main/Base/Internal/Parser/PersistenceLayer%20src/Main/Base/Internal/Parser/ReflectionLayer%20src/Main/Base/Internal/Project/Combine%20src/Main/Base/Internal/Project/Project%20src/Main/Base/Internal/Project/Project/Collections%20src/Main/Base/Services/File%20src/Main/Base/Services/ParserService%20src/Main/Base/Services/Pr%0A%20oject%20src/Tools%20src/Tools/dbgen%20src/Tools/dbgen/src&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1631 - in trunk/MonoDevelop: . src src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow src/Libraries/SharpRefactory src/Libraries/SharpRefactory/src/Parser/AST src/Main/Base src/Main/Base/Commands src/Main/Base/Commands/ProjectBrowserCommands src/Main/Base/Gui src/Main/Base/Gui/Pads/ClassScout src/Main/Base/Gui/Pads/ClassScout/NodeBuilder src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode src/Main/Base/Gui/Workbench/Layouts src/Main/Base/Internal/Parser src/Main/Base/Internal/Parser/Implementations src/Main/Base/Internal/Parser/PersistenceLayer src/Main/Base/Internal/Parser/ReflectionLayer src/Main/Base/Internal/Project/Combine src/Main/Base/Internal/Project/Project src/Main/Base/Internal/Project/Project/Collections src/Main/Base/Services/File src/Main/Base/Services/ParserService src/Main/Base/Services/Pr oject src/Tools src/Tools/dbgen src/Tools/dbgen/src">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Tue May 25 15:32:09 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001237.html">[Monodevelop-patches-list] r1630 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui InsightWindow
</A></li>
        <LI>Next message: <A HREF="001239.html">[Monodevelop-patches-list] r1632 - in trunk/MonoDevelop: . po src/Main/Base src/Main/Base/Services/ParserService src/Tools/dbgen
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1238">[ date ]</a>
              <a href="thread.html#1238">[ thread ]</a>
              <a href="subject.html#1238">[ subject ]</a>
              <a href="author.html#1238">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lluis
Date: 2004-05-25 15:32:09 -0400 (Tue, 25 May 2004)
New Revision: 1631

Added:
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/CombineEntryEventArgs.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/ProjectFileEventArgs.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/ProjectReferenceEventArgs.cs
   trunk/MonoDevelop/src/Main/Base/Services/ParserService/ClassInformationEventHandler.cs
   trunk/MonoDevelop/src/Main/Base/Services/ParserService/CodeCompletionDatabase.cs
   trunk/MonoDevelop/src/Tools/dbgen/
   trunk/MonoDevelop/src/Tools/dbgen/Makefile.am
   trunk/MonoDevelop/src/Tools/dbgen/src/
   trunk/MonoDevelop/src/Tools/dbgen/src/AssemblyInfo.cs
   trunk/MonoDevelop/src/Tools/dbgen/src/dbgen.cs
Modified:
   trunk/MonoDevelop/configure.in
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/ChangeLog
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CodeCompletionDataProvider.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CommentCompletionDataProvider.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/TemplateCompletionDataProvider.cs
   trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/ICompletionDataProvider.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/ChangeLog
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractNode.cs
   trunk/MonoDevelop/src/Main/Base/ChangeLog
   trunk/MonoDevelop/src/Main/Base/Commands/AutostartCommands.cs
   trunk/MonoDevelop/src/Main/Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs
   trunk/MonoDevelop/src/Main/Base/Gui/AbstractViewContent.cs
   trunk/MonoDevelop/src/Main/Base/Gui/IViewContent.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/ClassScout.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/IClass.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/IParser.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/IRegion.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/IUsing.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractClass.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractDecoration.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractNamedEntity.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractParameter.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractReturnType.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractUsing.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/DefaultRegion.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentClass.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentEvent.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentField.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentIndexer.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentMethod.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentParameter.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentProperty.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentReturnType.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Parser/ReflectionLayer/ReflectionClass.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/Combine.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/CombineEntry.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/AbstractProject.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/Collections/ProjectFileCollection.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/Collections/ProjectReferenceCollection.cs
   trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/IProject.cs
   trunk/MonoDevelop/src/Main/Base/Makefile.am
   trunk/MonoDevelop/src/Main/Base/Services/File/DefaultFileService.cs
   trunk/MonoDevelop/src/Main/Base/Services/ParserService/AssemblyInformation.cs
   trunk/MonoDevelop/src/Main/Base/Services/ParserService/DefaultParserService.cs
   trunk/MonoDevelop/src/Main/Base/Services/ParserService/IParserService.cs
   trunk/MonoDevelop/src/Main/Base/Services/Project/DefaultProjectService.cs
   trunk/MonoDevelop/src/Main/Base/Services/Project/IProjectService.cs
   trunk/MonoDevelop/src/Makefile.am
   trunk/MonoDevelop/src/Tools/Makefile.am
Log:
Implemented a new version of the code completion service.


Modified: trunk/MonoDevelop/configure.in
===================================================================
--- trunk/MonoDevelop/configure.in	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/configure.in	2004-05-25 19:32:09 UTC (rev 1631)
@@ -133,6 +133,7 @@
 src/Libraries/SharpRefactory/Makefile
 src/Tools/Makefile
 src/Tools/SharpCoco/Makefile
+src/Tools/dbgen/Makefile
 build/Makefile
 build/data/Makefile
 build/data/resources/Makefile

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/ChangeLog	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/ChangeLog	2004-05-25 19:32:09 UTC (rev 1631)
@@ -1,3 +1,10 @@
+2004-05-25  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&gt;
+
+	* Parser/Parser.cs: Set the file name to the region of each parsed class.
+	  Added IProject parameter in CtrlSpace and Resolve.
+	* Parser/Resolver.cs: Added IProject parameter where needed. Use new 
+	  methods in IParserService.
+
 2004-05-25  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
 
 	* CSharpLanguageBinding.cs: signature change for GenerateMakefile

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -9,6 +9,7 @@
 using System.Collections;
 using MonoDevelop.Services;
 using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
 using CSharpBinding.Parser.SharpDevelopTree;
 using ICSharpCode.SharpRefactory.Parser;
 
@@ -70,6 +71,8 @@
 			visitor.Visit(p.compilationUnit, null);
 			visitor.Cu.ErrorsDuringCompile = p.Errors.count &gt; 0;
 			RetrieveRegions(visitor.Cu, lexer.SpecialTracker);
+			foreach (IClass c in visitor.Cu.Classes)
+				c.Region.FileName = fileName;
 			return visitor.Cu;
 		}
 		
@@ -86,27 +89,29 @@
 			visitor.Cu.Tag = p.compilationUnit;
 			visitor.Cu.ErrorOutput = p.Errors.ErrorOutput;
 			RetrieveRegions(visitor.Cu, lexer.SpecialTracker);
+			foreach (IClass c in visitor.Cu.Classes)
+				c.Region.FileName = fileName;
 			return visitor.Cu;
 		}
 		
-		public ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName)
+		public ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName)
 		{
-			return new Resolver().CtrlSpace(parserService, caretLine, caretColumn, fileName);
+			return new Resolver(project).CtrlSpace(parserService, caretLine, caretColumn, fileName);
 		}
 
 		public ArrayList IsAsResolve (IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
-			return new Resolver ().IsAsResolve (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+			return new Resolver (null).IsAsResolve (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 		}
 		
-		public ResolveResult Resolve(IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		public ResolveResult Resolve(IParserService parserService, IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
-			return new Resolver().Resolve(parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+			return new Resolver(project).Resolve(parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 		}
 
 		public string MonodocResolver (IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
-			return new Resolver ().MonodocResolver (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+			return new Resolver (null).MonodocResolver (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 		}
 		
 		///////// IParser Interface END

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -11,6 +11,7 @@
 
 using MonoDevelop.Services;
 using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
 using CSharpBinding.Parser.SharpDevelopTree;
 using ICSharpCode.SharpRefactory.Parser.AST;
 using ICSharpCode.SharpRefactory.Parser;
@@ -23,7 +24,13 @@
 		ICompilationUnit cu;
 		IClass callingClass;
 		LookupTableVisitor lookupTableVisitor;
+		IProject project;
 		
+		public Resolver (IProject project)
+		{
+			this.project = project;
+		}
+		
 		public IParserService ParserService {
 			get {
 				return parserService;
@@ -195,7 +202,7 @@
 				}
 				string t = expression.Substring(i + 1);
 //				Console.WriteLine(&quot;in Using Statement&quot;);
-				string[] namespaces = parserService.GetNamespaceList(t);
+				string[] namespaces = parserService.GetNamespaceList(project, t);
 				if (namespaces == null || namespaces.Length &lt;= 0) {
 					return null;
 				}
@@ -211,14 +218,14 @@
 				if (n == null) {
 					return null;
 				}
-				ArrayList content = parserService.GetNamespaceContents(n);
+				ArrayList content = parserService.GetNamespaceContents(project,n,true);
 				ArrayList classes = new ArrayList();
 				for (int i = 0; i &lt; content.Count; ++i) {
 					if (content[i] is IClass) {
 						classes.Add((IClass)content[i]);
 					}
 				}
-				string[] namespaces = parserService.GetNamespaceList(n);
+				string[] namespaces = parserService.GetNamespaceList(project, n, true);
 				return new ResolveResult(namespaces, classes);
 			}
 			Console.WriteLine(&quot;Returning Result!&quot;);
@@ -674,7 +681,7 @@
 		/// &lt;/remarks&gt;
 		public string SearchNamespace(string name, ICompilationUnit unit)
 		{
-			if (parserService.NamespaceExists(name)) {
+			if (parserService.NamespaceExists(project, name)) {
 				return name;
 			}
 			if (unit == null) {
@@ -683,7 +690,7 @@
 			}
 			foreach (IUsing u in unit.Usings) {
 				if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
-					string nameSpace = u.SearchNamespace(name);
+					string nameSpace = parserService.SearchNamespace (project, u, name);
 					if (nameSpace != null) {
 						return nameSpace;
 					}
@@ -704,7 +711,7 @@
 				return null;
 			}
 			IClass c;
-			c = parserService.GetClass(name);
+			c = parserService.GetClass(project, name);
 			if (c != null) {
 //				Console.WriteLine(&quot;Found!&quot;);
 				return c;
@@ -715,7 +722,7 @@
 				foreach (IUsing u in unit.Usings) {
 					if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
 //						Console.WriteLine(&quot;In UsingRegion&quot;);
-						c = u.SearchType(name);
+						c = parserService.SearchType(project, u, name);
 						if (c != null) {
 //							Console.WriteLine(&quot;SearchType Successfull!!!&quot;);
 							return c;
@@ -730,7 +737,7 @@
 			string[] namespaces = fullname.Split(new char[] {'.'});
 			string curnamespace = namespaces[0] + '.';
 			for (int i = 1; i &lt; namespaces.Length; ++i) {
-				c = parserService.GetClass(curnamespace + name);
+				c = parserService.GetClass(project, curnamespace + name);
 				if (c != null) {
 					return c;
 				}
@@ -877,7 +884,7 @@
 			if (returnClass == null)
 				return null;
 
-			foreach (IClass iclass in returnClass.ClassInheritanceTree) {
+			foreach (IClass iclass in parserService.GetClassInheritanceTree (project, returnClass)) {
 				if (!result.Contains (iclass))
 					result.Add (iclass);
 			}
@@ -917,11 +924,11 @@
 				result = ListMembers(result, callingClass);
 			}
 			string n = &quot;&quot;;
-			result.AddRange(parserService.GetNamespaceContents(n));
+			result.AddRange(parserService.GetNamespaceContents(project, n, true));
 			foreach (IUsing u in cu.Usings) {
 				if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
 					foreach (string name in u.Usings) {
-						result.AddRange(parserService.GetNamespaceContents(name));
+						result.AddRange(parserService.GetNamespaceContents(project, name, true));
 					}
 					foreach (string alias in u.Aliases.Keys) {
 						result.Add(alias);

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CodeCompletionDataProvider.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CodeCompletionDataProvider.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CodeCompletionDataProvider.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -49,7 +49,7 @@
 		
 		ArrayList completionData = null;
 			
-		public ICompletionData[] GenerateCompletionData(string fileName, TextArea textArea, char charTyped)
+		public ICompletionData[] GenerateCompletionData(IProject project, string fileName, TextArea textArea, char charTyped)
 		{
 			IDocument document =  textArea.Document;
 			Console.WriteLine (&quot;resolve &quot; + document.Language);

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CommentCompletionDataProvider.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CommentCompletionDataProvider.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/CommentCompletionDataProvider.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -71,7 +71,7 @@
 			return row &gt;= region.BeginLine &amp;&amp; (row &lt;= region.EndLine || region.EndLine == -1);
 		}
 		
-		public ICompletionData[] GenerateCompletionData(string fileName, TextArea textArea, char charTyped)
+		public ICompletionData[] GenerateCompletionData(IProject project, string fileName, TextArea textArea, char charTyped)
 		{
 			caretLineNumber = textArea.Caret.Line;
 			caretColumn     = textArea.Caret.Column;

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/TemplateCompletionDataProvider.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/TemplateCompletionDataProvider.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Editor/CompletionWindow/TemplateCompletionDataProvider.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -12,6 +12,7 @@
 
 using MonoDevelop.Core.Properties;
 using MonoDevelop.Internal.Templates;
+using MonoDevelop.Internal.Project;
 using MonoDevelop.TextEditor.Document;
 using MonoDevelop.TextEditor;
 using MonoDevelop.TextEditor.Gui.CompletionWindow;
@@ -26,7 +27,7 @@
 			}
 		}
 		
-		public ICompletionData[] GenerateCompletionData(string fileName, TextArea textArea, char charTyped)
+		public ICompletionData[] GenerateCompletionData(IProject project, string fileName, TextArea textArea, char charTyped)
 		{
 			CodeTemplateGroup templateGroup = CodeTemplateLoader.GetTemplateGroupPerFilename(fileName);
 			if (templateGroup == null) {

Modified: trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/ICompletionDataProvider.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/ICompletionDataProvider.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Gui/CompletionWindow/ICompletionDataProvider.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -22,6 +22,6 @@
 			get;
 		}
 		
-		ICompletionData[] GenerateCompletionData(string fileName, TextArea textArea, char charTyped);
+		ICompletionData[] GenerateCompletionData(IProject project, string fileName, TextArea textArea, char charTyped);
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/ChangeLog
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/ChangeLog	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/ChangeLog	2004-05-25 19:32:09 UTC (rev 1631)
@@ -1,3 +1,7 @@
+2004-05-24  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&gt;
+
+	* src/Parser/AST/AbstractNode.cs: Lazily create children arraylist.
+
 2004-03-29  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
 
 	* src/Parser/Expressions/PrimitiveExpression.cs: stop requiring ICU 

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractNode.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractNode.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractNode.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -26,7 +26,7 @@
 	public abstract class AbstractNode : INode
 	{
 		INode     parent;
-		ArrayList children = new ArrayList();
+		ArrayList children;
 		Hashtable specials;
 		Point     startLocation;
 		Point     endLocation;
@@ -69,6 +69,7 @@
 		
 		public ArrayList Children {
 			get {
+				if (children == null) children = new ArrayList();
 				return children;
 			}
 		}
@@ -85,6 +86,7 @@
 		
 		public object AcceptChildren(IASTVisitor visitor, object data)
 		{
+			if (children == null) return data;
 			foreach (INode child in children) {
 				if (child != null) {
 					child.AcceptVisitor(visitor, data);

Modified: trunk/MonoDevelop/src/Main/Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/src/Main/Base/ChangeLog	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/ChangeLog	2004-05-25 19:32:09 UTC (rev 1631)
@@ -1,3 +1,114 @@
+2004-05-25  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&gt;
+
+	* Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs:
+	  Removed call to IParserService.AddReferenceToCompletionLookup. The parser
+	  service now receives an event when a reference is added.
+	  
+	* Commands/AutostartCommands.cs: Disabled generation of initial code
+	  completion database.
+	  
+	* Services/File/DefaultFileService.cs: In LoadFileWrapper, use IProject
+	  reference instead of project name.
+	
+	* Services/Project/DefaultProjectService.cs: Added ReferenceAddedToProject
+	  and ReferenceRemovedFromProject events. Changed how event are handled.
+	  Now the service just forwards the events received from the open combine.
+	  The file events now use a new ProjectFileEventHandler delegate, which
+	  provide information about the source project in the args.
+	  
+	* Services/Project/IProjectService.cs: Added new reference events.
+	
+	* ParserService/DefaultParserService.cs: Mostly reimplemented. The new
+	  implementation uses a unified data structure for storing information
+	  from projects and assemblies.
+	  
+	* Services/ParserService/AssemblyInformation.cs: Added FileName property.
+	
+	* Services/ParserService/IParserService.cs: Added IProject parameter to
+	  most of methods. Added SearchNamespace, SearchType methods (moved
+	  from AbstractUnit), and GetClassInheritanceTree (moved from 
+	  AbstractClass).
+	  Removed ParseInformationAdded and ParseInformationRemoved, and added a
+	  new ClassInformationChanged event that provides all change information
+	  at once.
+	  
+	* Gui/Workbench/Layouts/SdiWorkspaceLayout.cs: Take the name of the project
+	  from view's IProject property.
+	  
+	* Gui/IViewContent.cs: Changed ProjectName property to IProject Project
+	  property.
+	  
+	* Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs
+	* Gui/Pads/ClassScout/ClassScout.cs: Use the new events and data structures
+	  from of parser service. Now, class data is not fully loaded when opening
+	  the project, but it is loaded under demand as project nodes are expanded.
+	  
+	* Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs: Use a single
+	  method to update the tree from parse event args.
+	  
+	* Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs,
+	  Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs:
+	  Use Combine.RemoveEntry to remove projects from a combine.
+	  
+	* Gui/AbstractViewContent.cs: Implement new Project property.
+	
+	* Makefile.am: Added new files: 
+	  Services/ParserService/CodeCompletionDatabase.cs,
+	  Services/ParserService/ClassInformationEventHandler.cs,
+	  Internal/Project/Project/ProjectReferenceEventArgs.cs,
+	  Internal/Project/Project/ProjectFileEventArgs.cs,
+	  Internal/Project/Combine/CombineEntryEventArgs.cs.
+	  
+	* Internal/Project/Project/IProject.cs: Added new events for changes in
+	  files and references.
+	  
+	* Internal/Project/Project/Collections/ProjectReferenceCollection.cs
+	  Internal/Project/Project/Collections/ProjectFileCollection.cs,
+	  AbstractProject.cs,
+	  Internal/Project/Combine/Combine.cs:
+	  Added support for new events.
+	  
+	* Internal/Project/Combine/CombineEntry.cs: Created CombineEntryCollection.
+	
+	* Internal/Parser/PersistenceLayer/PersistentIndexer.cs,
+	  Internal/Parser/PersistenceLayer/PersistentParameter.cs,
+	  Internal/Parser/PersistenceLayer/PersistentMethod.cs,
+	  Internal/Parser/PersistenceLayer/PersistentReturnType.cs,
+	  Internal/Parser/PersistenceLayer/PersistentEvent.cs,
+	  Internal/Parser/PersistenceLayer/PersistentField.cs,
+	  Internal/Parser/PersistenceLayer/PersistentProperty.cs,
+	  Internal/Parser/PersistenceLayer/PersistentClass.cs,
+	  New implementation of read and write methods based on static methods. In
+	  this way it can be used to write instances of any IClass and not only
+	  PersistentClass. Also use new helper methods for writing strings and
+	  object references.
+	  
+	* Internal/Parser/IClass.cs: Moved ClassInheritanceTree to IParserService.
+	
+	* Internal/Parser/ReflectionLayer/ReflectionClass.cs: Added Null check for
+	  MonodocService.
+	  
+	* Internal/Parser/IRegion.cs: Added FileName property.
+	
+	* Internal/Parser/Implementations/AbstractUsing.cs,
+	  Internal/Parser/IUsing.cs: Moved SearchType and SearchNamespace to
+	  IParserService.
+	  
+	* Internal/Parser/Implementations/AbstractDecoration.cs,
+	  Internal/Parser/Implementations/AbstractNamedEntity.cs,
+	  Internal/Parser/Implementations/AbstractReturnType.cs: Fixed usage of
+	  documentation hashtable. GetHashCode() do not return unique values!
+	  
+	* Internal/Parser/Implementations/DefaultRegion.cs: Implemented FileName
+	  property.
+	  
+	* Internal/Parser/Implementations/AbstractClass.cs: 
+	  Moved ClassInheritanceTree to IParserService.
+	  
+	* Internal/Parser/Implementations/AbstractParameter.cs: Added null check.
+	
+	* Internal/Parser/IParser.cs: Added Project parameter to some methods.
+	
 2004-05-25  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
 
 	* Internal/Project/Combine/Combine.cs: more makefile magic for

Modified: trunk/MonoDevelop/src/Main/Base/Commands/AutostartCommands.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Commands/AutostartCommands.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Commands/AutostartCommands.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -54,16 +54,14 @@
 		{
 			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
 			string path = propertyService.GetProperty (&quot;SharpDevelop.CodeCompletion.DataDirectory&quot;, null);
-			string codeCompletionProxyFile = Path.Combine (path, &quot;CodeCompletionProxyDataV02.bin&quot;);
+			string codeCompletionProxyFile = Path.Combine (path, &quot;mscorlib.pidb&quot;);
 			//Console.WriteLine(&quot;checking for existence of {0}&quot;, codeCompletionProxyFile);
 
-			if (!File.Exists (codeCompletionProxyFile)) {
+/*			if (!File.Exists (codeCompletionProxyFile)) {
 				generatingCompletionData = true;
 				RunWizard();
-				DefaultParserService parserService = (DefaultParserService)ServiceManager.Services.GetService(typeof(IParserService));
-				parserService.LoadProxyDataFile();
 			}
-		}
+*/		}
 		
 		void RunWizard()
 		{

Modified: trunk/MonoDevelop/src/Main/Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -37,7 +37,6 @@
 			
 			if (node != null) {
 				IProject project = ((ProjectBrowserNode)node.Parent).Project;
-				IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
 				
 				SelectReferenceDialog selDialog = new SelectReferenceDialog(project);
 				if (selDialog.Run() == (int)Gtk.ResponseType.Ok) {
@@ -45,7 +44,6 @@
 					project.ProjectReferences.Clear ();
 					foreach (ProjectReference refInfo in selDialog.ReferenceInformations) {
 						project.ProjectReferences.Add(refInfo);
-						parserService.AddReferenceToCompletionLookup(project, refInfo);
 					}
 					
 					DefaultDotNetNodeBuilder.InitializeReferences(node, project);

Modified: trunk/MonoDevelop/src/Main/Base/Gui/AbstractViewContent.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/AbstractViewContent.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Gui/AbstractViewContent.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -8,6 +8,7 @@
 using System;
 
 using MonoDevelop.Services;
+using MonoDevelop.Internal.Project;
 
 namespace MonoDevelop.Gui
 {
@@ -15,7 +16,7 @@
 	{
 		string untitledName = &quot;&quot;;
 		string contentName  = null;
-		string projectname = null;
+		IProject project = null;
 		string pathrelativetoproject = null;
 		
 		bool   isDirty  = false;
@@ -101,19 +102,19 @@
 		
 		public abstract void Load(string fileName);
 
-		public string ProjectName
+		public IProject Project
 		{
 			get
 			{
-				return projectname;
+				return project;
 			}
 			set
 			{
-				if (!HasProject &amp;&amp; value != null &amp;&amp; value != &quot;&quot;)
+				if (!HasProject &amp;&amp; value != null)
 				{
 					HasProject = true;
 				}
-				projectname = value;
+				project = value;
 			}
 		}
 		
@@ -131,10 +132,6 @@
 					{
 						HasProject = true;
 					}
-					if (ProjectName == null)
-					{
-						ProjectName = &quot;&quot;;
-					}
 				}
 				pathrelativetoproject = value;
 			}

Modified: trunk/MonoDevelop/src/Main/Base/Gui/IViewContent.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/IViewContent.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Gui/IViewContent.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -6,6 +6,7 @@
 // &lt;/file&gt;
 
 using System;
+using MonoDevelop.Internal.Project;
 
 namespace MonoDevelop.Gui
 {
@@ -94,11 +95,11 @@
 		/// &lt;summary&gt;
 		/// The name of the project the content is attached to
 		/// &lt;/summary&gt;
-		string ProjectName {
+		IProject Project {
 			get;
 			set;
 		}
-		
+	
 		/// &lt;summary&gt;
 		/// The path relative to the project
 		/// &lt;/summary&gt;

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/ClassScout.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/ClassScout.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/ClassScout.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -60,8 +60,7 @@
 		Gtk.Frame contentPanel;
 
 		ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
-		ParseInformationEventHandler addParseInformationHandler = null;
-		ParseInformationEventHandler removeParseInformationHandler = null;
+		ClassInformationEventHandler changeClassInformationHandler = null;
 		Combine parseCombine;
 		ArrayList ImageList;
 		
@@ -99,8 +98,7 @@
 		
 		public ClassScout() : base (false, TreeNodeComparer.GtkDefault)
 		{
-			addParseInformationHandler = new ParseInformationEventHandler(OnParseInformationAdded);
-			removeParseInformationHandler = new ParseInformationEventHandler(OnParseInformationRemoved);
+			changeClassInformationHandler = new ClassInformationEventHandler(OnClassInformationChanged);
 			
 			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
 
@@ -110,8 +108,6 @@
 
 			projectService.CombineOpened += new CombineEventHandler(OnCombineOpen);
 			projectService.CombineClosed += new CombineEventHandler(OnCombineClosed);
-			projectService.FileAddedToProject += new FileEventHandler (OnProjectFilesChanged);
-			projectService.FileRemovedFromProject += new FileEventHandler (OnProjectFilesChanged);
 
 			Gtk.ScrolledWindow sw = new Gtk.ScrolledWindow ();
 			sw.Add(this);
@@ -133,12 +129,6 @@
 			}
 		}
 
-		void OnProjectFilesChanged (object sender, FileEventArgs e)
-		{
-			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
-			OnCombineOpen (sender, new CombineEventArgs (projectService.CurrentOpenCombine));
-		}
-
 		public void RedrawContent()
 		{
 		}
@@ -153,44 +143,24 @@
 		void OnCombineClosed(object sender, CombineEventArgs e)
 		{
 			IParserService parserService  = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
-			parserService.ParseInformationAdded -= addParseInformationHandler;
-			parserService.ParseInformationRemoved -= removeParseInformationHandler;
+			parserService.ClassInformationChanged -= changeClassInformationHandler;
 			Nodes.Clear();
 		}
-
-		ParseInformationEventArgs add_e = null;
-		void OnParseInformationAdded(object sender, ParseInformationEventArgs e)
+		
+		void AddIdle (IdleStateHandler cb, object data)
 		{
-			add_e = e;
-			GLib.Idle.Add (new GLib.IdleHandler (addParseInfo));
+			GLib.Idle.Add (new GLib.IdleHandler (new IdleWork (cb, data).Run));
 		}
 
-		bool addParseInfo ()
+		void OnClassInformationChanged(object sender, ClassInformationEventArgs e)
 		{
-			if (add_e != null) {
-				lock (add_e) {
-					AddParseInformation (Nodes, add_e);
-				}
-				add_e = null;
-			}
-			return false;
+			AddIdle (new IdleStateHandler(ChangeClassInfo), e);
 		}
 		
-		ParseInformationEventArgs remove_e;
-		void OnParseInformationRemoved(object sender, ParseInformationEventArgs e)
+		bool ChangeClassInfo (object e)
 		{
-			remove_e = e;
-			GLib.Idle.Add (new GLib.IdleHandler (removeParseInfo));
-		}
-
-		bool removeParseInfo ()
-		{
-			if (remove_e != null) {
-				lock (remove_e) {
-					RemoveParseInformation (Nodes, remove_e);
-				}
-				remove_e = null;
-			}
+			ClassInformationEventArgs ce = (ClassInformationEventArgs) e;
+			ChangeClassInformation (Nodes, ce);
 			return false;
 		}
 
@@ -213,6 +183,29 @@
 				}
 			}
 		}
+		
+		protected override void OnBeforeExpand (TreeViewCancelEventArgs e)
+		{
+			TreeNode nod = e.Node;
+			if (nod.Tag == null || nod.Tag is IProject)
+			{
+				while (nod != null &amp;&amp; nod.Tag == null)
+					nod = nod.Parent;
+					
+				if (nod == null) return;
+				
+				IProject p = (IProject)nod.Tag;
+				foreach (IClassScoutNodeBuilder classBrowserNodeBuilder in classBrowserNodeBuilders) {
+					if (classBrowserNodeBuilder.CanBuildClassTree(p)) {
+						classBrowserNodeBuilder.ExpandNode (e.Node);
+						break;
+					}
+				}
+				
+			}
+		}
+		
+		
 /*
 		protected override void OnMouseDown(MouseEventArgs e)
 		{
@@ -272,14 +265,13 @@
 		
 		void StartPopulating()
 		{
-			ParseCombine(parseCombine);
+			//ParseCombine(parseCombine);
 			//Invoke(new MyD(DoPopulate));
 			Gdk.Threads.Enter();
 			DoPopulate();
 			Gdk.Threads.Leave();
 			IParserService parserService  = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
-			parserService.ParseInformationAdded += addParseInformationHandler;
-			parserService.ParseInformationRemoved += removeParseInformationHandler;
+			parserService.ClassInformationChanged += changeClassInformationHandler;
 		}
 
 		public void ParseCombine(Combine combine)
@@ -369,7 +361,7 @@
 			}
 		}
 
-		void AddParseInformation(TreeNodeCollection nodes, ParseInformationEventArgs e)
+		void ChangeClassInformation(TreeNodeCollection nodes, ClassInformationEventArgs e)
 		{
 			BeginUpdate();
 			foreach (TreeNode node in nodes) {
@@ -377,35 +369,35 @@
 					IProject p = (IProject)node.Tag;
 					if (p.IsFileInProject(e.FileName)) {
 						foreach (IClassScoutNodeBuilder classBrowserNodeBuilder in classBrowserNodeBuilders) {
-							classBrowserNodeBuilder.AddToClassTree(node, e);
+							classBrowserNodeBuilder.UpdateClassTree(node, e);
 							break;
 						}
 					}
 				} else {
-					AddParseInformation(node.Nodes, e);
+					ChangeClassInformation(node.Nodes, e);
 				}
 			}
 			EndUpdate();
 		}
+	}
+	
+	public delegate bool IdleStateHandler (object state);
+	
+	class IdleWork
+	{
+		object _data;
+		IdleStateHandler _cb;
 		
-		void RemoveParseInformation(TreeNodeCollection nodes, ParseInformationEventArgs e)
+		public IdleWork (IdleStateHandler cb, object data)
 		{
-			BeginUpdate();
-			foreach (TreeNode node in nodes) {
-				if (node.Tag is IProject) {
-					IProject p = (IProject)node.Tag;
-					if (p.IsFileInProject(e.FileName)) {
-						foreach (IClassScoutNodeBuilder classBrowserNodeBuilder in classBrowserNodeBuilders) {
-							classBrowserNodeBuilder.RemoveFromClassTree(node, e);
-							break;
-						}
-					}
-				} else {
-					RemoveParseInformation(node.Nodes, e);
-				}
-			}
-			EndUpdate();
+			_data = data;
+			_cb = cb;
 		}
+		
+		public bool Run ()
+		{
+			return _cb (_data);
+		}
 	}
 }
 

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -49,30 +49,32 @@
 		}
 
 		private object locker = new object ();
-		public void AddToClassTree(TreeNode parentNode, ParseInformationEventArgs e)
+		
+		public void UpdateClassTree (TreeNode parentNode, ClassInformationEventArgs e)
 		{
 			lock (locker) {
-				AddToClassTree(parentNode, e.FileName, (ICompilationUnit)e.ParseInformation.MostRecentCompilationUnit);
+				RemoveFromClassTree (parentNode, e.ClassInformation.Removed);
+				AddToClassTree (parentNode, e.FileName, e.ClassInformation.Added);
+				AddToClassTree (parentNode, e.FileName, e.ClassInformation.Modified);
 			}
 		}
 		
-		public void RemoveFromClassTree(TreeNode parentNode, ParseInformationEventArgs e) {
+		public void RemoveFromClassTree (TreeNode parentNode, ClassCollection removed) {
 			ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
 			
 			TreeNode classNode = new TreeNode();
 			
-			ICompilationUnit unit = (ICompilationUnit)e.ParseInformation.MostRecentCompilationUnit;
-			foreach (IClass c in unit.Classes) {
+			foreach (IClass c in removed) {
 				classNode.Text = c.Name;
 				classNode.Image = classBrowserIconService.GetIcon (c);
 				// TODO: Perf check
-				TreeNode node = GetNodeByPath(c.Namespace, parentNode.Nodes, false);
-				if (node != null) {
-					int oldIndex = SortUtility.BinarySearch (classNode, node.Nodes, TreeNodeComparer.Default);
+				TreeNode node = GetNodeByPath (c.Namespace, parentNode, false);
+				if (node != null &amp;&amp; !NeedsExpansion (node)) {
+					int oldIndex = FindNodeByName (node.Nodes, c.Name);
 					if (oldIndex &gt;= 0) {
 						node.Nodes[oldIndex].Remove ();
 					}
-					DropPhantomNamespaces (c.Namespace, parentNode.Nodes);
+					DropPhantomNamespaces (c.Namespace, parentNode);
 				}
 			}
 		}
@@ -84,6 +86,11 @@
 			foreach (TreeNode node in newNode.Nodes)
 				projectNode.Nodes.Add(node);
 		}
+		
+		static bool NeedsExpansion (TreeNode nod)
+		{
+			return (nod.Nodes.Count == 1 &amp;&amp; nod.Nodes[0].Text == &quot;&quot;);
+		}
 
 		public TreeNode BuildClassTreeNode(IProject p)
 		{
@@ -96,41 +103,65 @@
 
 			TreeNode prjNode = new AbstractClassScoutNode(p.Name);
 			prjNode.Image = iconService.GetImageForProjectType(p.ProjectType);
- 			foreach (ProjectFile finfo in p.ProjectFiles) {
-				if (finfo.BuildAction == BuildAction.Compile) {
-					int i = 0;
-					IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
-					if (parserService.GetParser(finfo.Name) == null) {
-						continue;
-					}
+			prjNode.Nodes.Add (new TreeNode (&quot;&quot;));
+			prjNode.Tag = p;
+			return prjNode;
+		}
+		
+		public void ExpandNode (TreeNode node)
+		{
+			if (node.Tag == null)
+			{
+				// Build the namespace
+				string ns = node.Text;
+				TreeNode nod = node.Parent;
+				while (nod.Tag == null) {
+					ns = nod.Text + &quot;.&quot; + ns;
+					nod = nod.Parent;
+				}
 
-					for(i=0; i &lt; 5 &amp;&amp; parserService.GetParseInformation(finfo.Name) == null; i++) {
-						Thread.Sleep(100);
-					}
-
-					if (parserService.GetParseInformation(finfo.Name) == null) {
-						continue;
-					}
-
-					IParseInformation parseInformation = parserService.GetParseInformation(finfo.Name);
-					if (parseInformation != null) {
-						ICompilationUnit unit = parseInformation.BestCompilationUnit as ICompilationUnit;
-						if (unit != null) {
-						   AddToClassTree(prjNode, finfo.Name, unit);
-						}
-					}
+				IProject p = (IProject)nod.Tag;
+				ExpandNamespaceTree (p, ns, node);
+			}
+			else if (node.Tag is IProject)
+			{
+				IProject p = (IProject)node.Tag;
+				ExpandNamespaceTree (p, &quot;&quot;, node);
+			}
+		}
+		
+		void ExpandNamespaceTree (IProject project, string ns, TreeNode node)
+		{
+			if (!NeedsExpansion (node)) return;
+			node.Nodes.Clear ();
+			
+			IParserService parserService  = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+			ArrayList contents = parserService.GetNamespaceContents (project, ns, false);
+			foreach (object item in contents)
+			{
+				if (item is string)
+				{
+					TreeNode newnode = new AbstractClassScoutNode ((string)item);
+					newnode.Image = Stock.NameSpace;
+					node.Nodes.Add (newnode);
+					newnode.Nodes.Add (new TreeNode (&quot;&quot;));
 				}
+				else if (item is IClass)
+				{
+					node.Nodes.Add (BuildClassNode ((IClass)item));
+				}
 			}
-			return prjNode;
 		}
 		
-		public void AddToClassTree(TreeNode parentNode, string filename, ICompilationUnit unit)
+		public void AddToClassTree(TreeNode parentNode, string filename, ClassCollection classes)
 		{
-			foreach (IClass c in unit.Classes) {
-				TreeNode node = GetNodeByPath(c.Namespace, parentNode.Nodes, true);
-				if (node == null) {
-					node = parentNode;
-				}
+			if (NeedsExpansion (parentNode)) return;
+			
+			foreach (IClass c in classes) {
+			
+				TreeNode node = GetNodeByPath (c.Namespace, parentNode, true);
+				if (node == null || NeedsExpansion (node))
+					continue;
 				
 				TreeNode oldClassNode = GetNodeByName(node.Nodes, c.Name);
 				bool wasExpanded = false;
@@ -139,7 +170,7 @@
 					oldClassNode.Remove();
 				}
 				
-				TreeNode classNode = BuildClassNode(filename, c);
+				TreeNode classNode = BuildClassNode(c);
 				if(classNode != null) {
 					node.Nodes.Add (classNode);
 					
@@ -150,15 +181,16 @@
 			}
 		}
 		
-		TreeNode BuildClassNode(string filename, IClass c)
+		TreeNode BuildClassNode (IClass c)
 		{
 			ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
 
 			AbstractClassScoutNode classNode = new AbstractClassScoutNode(c.Name);
+			string file = c.Region.FileName;
 			
 			classNode.Image = classBrowserIconService.GetIcon (c);
 			classNode.ContextmenuAddinTreePath = &quot;/SharpDevelop/Views/ClassScout/ContextMenu/ClassNode&quot;;
-			classNode.Tag = new ClassScoutTag(c.Region.BeginLine, filename);
+			classNode.Tag = new ClassScoutTag(c.Region.BeginLine, file);
 
 			// don't insert delegate 'members'
 			if (c.ClassType == ClassType.Delegate) {
@@ -168,12 +200,12 @@
 			foreach (IClass innerClass in c.InnerClasses) {
 				if (innerClass.ClassType == ClassType.Delegate) {
 					TreeNode innerClassNode = new AbstractClassScoutNode(languageConversion.Convert(innerClass));
-					innerClassNode.Tag = new ClassScoutTag(innerClass.Region.BeginLine, filename);
+					innerClassNode.Tag = new ClassScoutTag(innerClass.Region.BeginLine, innerClass.Region.FileName == null ? file : innerClass.Region.FileName);
 					//innerClassNode.SelectedImageIndex = innerClassNode.ImageIndex = classBrowserIconService.GetIcon(innerClass);
 					innerClassNode.Image = classBrowserIconService.GetIcon(innerClass);
 					classNode.Nodes.Add(innerClassNode);
 				} else {
-					TreeNode n = BuildClassNode(filename, innerClass);
+					TreeNode n = BuildClassNode(innerClass);
 					if(classNode != null) {
 						classNode.Nodes.Add(n);
 					}
@@ -182,7 +214,7 @@
 
 			foreach (IMethod method in c.Methods) {
 				TreeNode methodNode = new AbstractClassScoutNode(languageConversion.Convert(method));
-				methodNode.Tag = new ClassScoutTag(method.Region.BeginLine, filename);
+				methodNode.Tag = new ClassScoutTag(method.Region.BeginLine, method.Region.FileName == null ? file : method.Region.FileName);
 				//methodNode.SelectedImageIndex = methodNode.ImageIndex = classBrowserIconService.GetIcon(method);
 				methodNode.Image = classBrowserIconService.GetIcon(method);
 				classNode.Nodes.Add(methodNode);
@@ -190,7 +222,7 @@
 			
 			foreach (IProperty property in c.Properties) {
 				TreeNode propertyNode = new AbstractClassScoutNode(languageConversion.Convert(property));
-				propertyNode.Tag = new ClassScoutTag(property.Region.BeginLine, filename);
+				propertyNode.Tag = new ClassScoutTag(property.Region.BeginLine, property.Region.FileName == null ? file : property.Region.FileName);
 				//propertyNode.SelectedImageIndex = propertyNode.ImageIndex = classBrowserIconService.GetIcon(property);
 				propertyNode.Image = classBrowserIconService.GetIcon(property);
 				classNode.Nodes.Add(propertyNode);
@@ -198,7 +230,7 @@
 			
 			foreach (IField field in c.Fields) {
 				TreeNode fieldNode = new AbstractClassScoutNode(languageConversion.Convert(field));
-				fieldNode.Tag = new ClassScoutTag(field.Region.BeginLine, filename);
+				fieldNode.Tag = new ClassScoutTag(field.Region.BeginLine, field.Region.FileName == null ? file : field.Region.FileName);
 				//fieldNode.SelectedImageIndex = fieldNode.ImageIndex = classBrowserIconService.GetIcon(field);
 				fieldNode.Image = classBrowserIconService.GetIcon(field);
 				classNode.Nodes.Add(fieldNode);
@@ -206,7 +238,7 @@
 			
 			foreach (IEvent e in c.Events) {
 				TreeNode eventNode = new AbstractClassScoutNode(languageConversion.Convert(e));
-				eventNode.Tag = new ClassScoutTag(e.Region.BeginLine, filename);
+				eventNode.Tag = new ClassScoutTag(e.Region.BeginLine, e.Region.FileName == null ? file : e.Region.FileName);
 				//eventNode.SelectedImageIndex = eventNode.ImageIndex = classBrowserIconService.GetIcon(e);
 				eventNode.Image = classBrowserIconService.GetIcon(e);
 				classNode.Nodes.Add(eventNode);
@@ -215,51 +247,51 @@
 			return classNode;
 		}
 
-		public void DropPhantomNamespaces (string dir, TreeNodeCollection root)
+		public void DropPhantomNamespaces (string dir, TreeNode parentNode)
 		{
 			string[] full_path = dir.Split (new char[] { '.' });
 			for (int i = full_path.Length - 1; i != -1; i--)
 			{
-				TreeNode node = GetNodeByPath (String.Join (&quot;.&quot;, full_path, 0, i + 1), root, false);
-				if (node != null &amp;&amp; node.Nodes.Count == 0)
+				TreeNode node = GetNodeByPath (String.Join (&quot;.&quot;, full_path, 0, i + 1), parentNode, false);
+				if (node != null &amp;&amp; node.Nodes.Count == 0 &amp;&amp; node != parentNode)
 					node.Remove ();
 			}
 		}
 		
-		static public TreeNode GetNodeByPath(string directory, TreeNodeCollection root, bool create)
+		static public TreeNode GetNodeByPath(string directory, TreeNode parentNode, bool create)
 		{
 			ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
 
 			string[] treepath   = directory.Split(new char[] { '.' });
-			TreeNodeCollection curcollection = root;
-			TreeNode           curnode       = null;
-			if (treepath.Length == 1 &amp;&amp; treepath[0].Length == 0) {
-				if (root.Count == 0)
-					return null;
-				return root[0].Parent;
-			}
+			TreeNode curnode = parentNode;
+			
+			if (NeedsExpansion (parentNode)) return null;
+			
+			if (treepath.Length == 1 &amp;&amp; treepath[0].Length == 0)
+				return parentNode;
+			
 			foreach (string path in treepath) {
 				if (path.Length == 0 || path[0] == '.') {
 					continue;
 				}
 
-				TreeNode node = GetNodeByName(curcollection, path);
-				if (node == null) {
+				curnode = GetNodeByName (curnode.Nodes, path);
+				
+				if (curnode == null) {
 					if (create) {
-						TreeNode newnode = new AbstractClassScoutNode(path);
-						//newnode.ImageIndex = newnode.SelectedImageIndex = classBrowserIconService.NamespaceIndex;
-						newnode.Image = Stock.NameSpace;
-
-						curcollection.Add (newnode);
-						curnode = newnode;
-						curcollection = curnode.Nodes;
-						continue;
+						curnode = new AbstractClassScoutNode(path);
+						curnode.Image = Stock.NameSpace;
+						curnode.Nodes.Add (new TreeNode (&quot;&quot;));
+						parentNode.Nodes.Add (curnode);
+						return null;	// Delay expansion
 					} else {
 						return null;
 					}
 				}
-				curnode = node;
-				curcollection = curnode.Nodes;
+				else if (NeedsExpansion (curnode))
+					return null;
+				
+				parentNode = curnode;
 			}
 			return curnode;
 		}
@@ -273,5 +305,14 @@
 			}
 			return null;
 		}
+
+		static int FindNodeByName(TreeNodeCollection collection, string name)
+		{
+			for (int n=0; n&lt;collection.Count; n++)
+				if (collection[n].Text == name)
+					return n;
+
+			return -1;
+		}
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -23,8 +23,8 @@
 	{
 		bool     CanBuildClassTree(IProject project);
 		TreeNode BuildClassTreeNode(IProject project);
+		void     ExpandNode (TreeNode node);
 
-		void     AddToClassTree(TreeNode projectNode, ParseInformationEventArgs e);
-		void     RemoveFromClassTree(TreeNode parentNode, ParseInformationEventArgs e);
+		void     UpdateClassTree (TreeNode projectNode, ClassInformationEventArgs e);
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -118,7 +118,7 @@
 			}
 			
 			Debug.Assert(removeEntry != null);
-			cmbNode.Combine.Entries.Remove(removeEntry);
+			cmbNode.Combine.RemoveEntry (removeEntry);
 			
 			// remove execute definition
 			CombineExecuteDefinition removeExDef = null;

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -125,7 +125,7 @@
 			}
 			
 			Debug.Assert(removeEntry != null);
-			cmb.Entries.Remove(removeEntry);
+			cmb.RemoveEntry (removeEntry);
 			
 			// remove execute definition
 			CombineExecuteDefinition removeExDef = null;

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -458,7 +458,7 @@
 					}
 					if (ActiveWorkbenchwindow.ViewContent.HasProject)
 					{
-						((Gtk.Window)WorkbenchSingleton.Workbench).Title = ActiveWorkbenchwindow.ViewContent.ProjectName + &quot; - &quot; + ActiveWorkbenchwindow.ViewContent.PathRelativeToProject + post + &quot; - MonoDevelop&quot;;
+						((Gtk.Window)WorkbenchSingleton.Workbench).Title = ActiveWorkbenchwindow.ViewContent.Project.Name + &quot; - &quot; + ActiveWorkbenchwindow.ViewContent.PathRelativeToProject + post + &quot; - MonoDevelop&quot;;
 					}
 					else
 					{

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/IClass.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/IClass.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/IClass.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -70,10 +70,6 @@
 			get;
 		}
 
-		IEnumerable ClassInheritanceTree {
-			get;
-		}
-		
 		object DeclaredIn {
 			get;
 		}

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/IParser.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/IParser.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/IParser.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -10,6 +10,7 @@
 using System.Collections.Specialized;
 
 using MonoDevelop.Services;
+using MonoDevelop.Internal.Project;
 
 namespace MonoDevelop.Internal.Parser
 {
@@ -131,6 +132,7 @@
 		/// The caretLineNumber and caretColumn is 1 based.
 		/// &lt;/summary&gt;
 		ResolveResult Resolve(IParserService parserService, 
+							  IProject project,
 		                      string expression, 
 		                      int caretLineNumber, 
 		                      int caretColumn, 
@@ -141,6 +143,6 @@
 
 		ArrayList IsAsResolve (IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
 		
-		ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName);
+		ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName);
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/IRegion.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/IRegion.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/IRegion.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -27,6 +27,11 @@
 			get;
 			set;
 		}
+		
+		string FileName {
+			get;
+			set;
+		}
 
 		bool IsInside(int row, int column);
 	}

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/IUsing.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/IUsing.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/IUsing.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -24,11 +24,5 @@
 		SortedList Aliases {
 			get;
 		}
-
-		IClass SearchType(string partitialTypeName);
-		string SearchNamespace(string partitialNamespaceName);
-		
-		IClass SearchType(string partitialTypeName, bool caseSensitive);
-		string SearchNamespace(string partitialNamespaceName, bool caseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitivecaseSensitive);
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractClass.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractClass.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractClass.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -155,91 +155,10 @@
 			return CompareTo((IClass)o);
 		}
 		
-		public IEnumerable ClassInheritanceTree {
-			get {
-				return new ClassInheritanceEnumerator(this);
-			}
-		}
-		
 		protected override bool CanBeSubclass {
 			get {
 				return true;
 			}
 		}
-
-		public class ClassInheritanceEnumerator : IEnumerator, IEnumerable
-		{
-			static IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
-			IClass topLevelClass;
-			IClass currentClass  = null;
-			Queue  baseTypeQueue = new Queue();
-
-			public ClassInheritanceEnumerator(IClass topLevelClass)
-			{
-				this.topLevelClass = topLevelClass;
-				baseTypeQueue.Enqueue(topLevelClass.FullyQualifiedName);
-				PutBaseClassesOnStack(topLevelClass);
-				baseTypeQueue.Enqueue(&quot;System.Object&quot;);
-			}
-			public IEnumerator GetEnumerator()
-			{
-				return this;
-			}
-
-			void PutBaseClassesOnStack(IClass c)
-			{
-				foreach (string baseTypeName in c.BaseTypes) {
-					baseTypeQueue.Enqueue(baseTypeName);
-				}
-			}
-
-			public IClass Current {
-				get {
-					return currentClass;
-				}
-			}
-
-			object IEnumerator.Current {
-				get {
-					return currentClass;
-				}
-			}
-
-			public bool MoveNext()
-			{
-				if (baseTypeQueue.Count == 0) {
-					return false;
-				}
-				string baseTypeName = baseTypeQueue.Dequeue().ToString();
-
-				IClass baseType = parserService.GetClass(baseTypeName);
-				if (baseType == null) {
-					ICompilationUnit unit = currentClass == null ? null : currentClass.CompilationUnit;
-					if (unit != null) {
-						foreach (IUsing u in unit.Usings) {
-							baseType = u.SearchType(baseTypeName);
-							if (baseType != null) {
-								break;
-							}
-						}
-					}
-				}
-
-				if (baseType != null) {
-					currentClass = baseType;
-					PutBaseClassesOnStack(currentClass);
-				}
-
-				return baseType != null;
-			}
-
-			public void Reset()
-			{
-				baseTypeQueue.Clear();
-				baseTypeQueue.Enqueue(topLevelClass.FullyQualifiedName);
-				PutBaseClassesOnStack(topLevelClass);
-				baseTypeQueue.Enqueue(&quot;System.Object&quot;);
-			}
-		}
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractDecoration.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractDecoration.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractDecoration.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -16,7 +16,7 @@
 	{
 		protected ModifierEnum               modifiers     = ModifierEnum.None;
 		protected AttributeSectionCollection attributes    = null;
-		int    documentationHash = -1;
+		string documentation;
 		static Hashtable documentationHashtable = new Hashtable();
 		
 		
@@ -37,15 +37,19 @@
 
 		public string Documentation {
 			get {
-				if (documentationHash == -1) {
-					return String.Empty;
-				}
-				return (string)documentationHashtable[documentationHash];
+				return documentation == null ? &quot;&quot; : documentation;
 			}
 			set {
-				documentationHash = value.GetHashCode();
-				if (documentationHashtable[documentationHash] == null) {
-					documentationHashtable[documentationHash] = value;
+				if (value == null)
+					documentation = null;
+				else {
+					string sharedVal = documentationHashtable [value] as string;
+					if (sharedVal == null) {
+						documentationHashtable [value] = value;
+						documentation = value;
+					}
+					else
+						documentation = sharedVal;
 				}
 			}
 		}

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractNamedEntity.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractNamedEntity.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractNamedEntity.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -14,16 +14,23 @@
 	public abstract class AbstractNamedEntity : AbstractDecoration
 	{
 		public static Hashtable fullyQualifiedNames = new Hashtable();
-		int nameHashCode = -1;
+		string fqname;
 		
 		public virtual string FullyQualifiedName {
 			get {
-				return (string)fullyQualifiedNames[nameHashCode];
+				return fqname;
 			}
 			set {
-				nameHashCode = value.GetHashCode();
-				if (fullyQualifiedNames[nameHashCode] == null) {
-					fullyQualifiedNames[nameHashCode] = value;
+				if (value == null)
+					fqname = null;
+				else {
+					string sharedVal = fullyQualifiedNames[value] as string;
+					if (sharedVal != null)
+						fqname = sharedVal;
+					else {
+						fullyQualifiedNames[value] = value;
+						fqname = value;
+					}
 				}
 			}
 		}

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractParameter.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractParameter.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractParameter.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -72,7 +72,7 @@
 
 		public string Documentation {
 			get {
-				return documentation;
+				return documentation == null ? &quot;&quot; : documentation;
 			}
 		}
 		

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractReturnType.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractReturnType.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractReturnType.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -15,16 +15,23 @@
 		protected int    pointerNestingLevel;
 		protected int[]  arrayDimensions;
 		protected object declaredin = null;
-		int nameHashCode = -1;
+		string fname;
 		
 		public virtual string FullyQualifiedName {
 			get {
-				return (string)AbstractNamedEntity.fullyQualifiedNames[nameHashCode];
+				return fname;
 			}
 			set {
-				nameHashCode = value.GetHashCode();
-				if (AbstractNamedEntity.fullyQualifiedNames[nameHashCode] == null) {
-					AbstractNamedEntity.fullyQualifiedNames[nameHashCode] = value;
+				if (value == null)
+					fname = value;
+				else {
+					string sharedName = (string) AbstractNamedEntity.fullyQualifiedNames [value];
+					if (sharedName == null) {
+						AbstractNamedEntity.fullyQualifiedNames [value] = value;
+						fname = value;
+					}
+					else
+						fname = sharedName;
 				}
 			}
 		}

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractUsing.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractUsing.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/AbstractUsing.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -38,114 +38,6 @@
 			}
 		}
 		
-		static IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
-		public string SearchNamespace(string partitialNamespaceName)
-		{
-			return SearchNamespace(partitialNamespaceName, true);
-		}
-		
-		public string SearchNamespace(string partitialNamespaceName, bool caseSensitive)
-		{
-//			Console.WriteLine(&quot;SearchNamespace : &gt;{0}&lt;&quot;, partitialNamespaceName);
-			if (parserService.NamespaceExists(partitialNamespaceName, caseSensitive)) {
-				return partitialNamespaceName;
-			}
-			
-			// search for partitial namespaces
-			string declaringNamespace = (string)aliases[&quot;&quot;];
-			if (declaringNamespace != null) {
-				while (declaringNamespace.Length &gt; 0) {
-					if ((caseSensitive ? declaringNamespace.EndsWith(partitialNamespaceName) : declaringNamespace.ToLower().EndsWith(partitialNamespaceName.ToLower()) ) &amp;&amp; parserService.NamespaceExists(declaringNamespace, caseSensitive)) {
-						return declaringNamespace;
-					}
-					int index = declaringNamespace.IndexOf('.');
-					if (index &gt; 0) {
-						declaringNamespace = declaringNamespace.Substring(0, index);
-					} else {
-						break;
-					}
-				}
-			}
-			
-			// Remember:
-			//     Each namespace has an own using object
-			//     The namespace name is an alias which has the key &quot;&quot;
-			foreach (DictionaryEntry entry in aliases) {
-				string aliasString = entry.Key.ToString();
-				if (caseSensitive ? partitialNamespaceName.StartsWith(aliasString) : partitialNamespaceName.ToLower().StartsWith(aliasString.ToLower())) {
-					if (aliasString.Length &gt;= 0) {
-						string nsName = nsName = String.Concat(entry.Value.ToString(), partitialNamespaceName.Remove(0, aliasString.Length));
-						if (parserService.NamespaceExists(nsName, caseSensitive)) {
-							return nsName;
-						}
-					}
-				}
-			}
-			return null;
-		}
-
-		public IClass SearchType(string partitialTypeName)
-		{
-			return SearchType(partitialTypeName, true);
-		}
-		
-		public IClass SearchType(string partitialTypeName, bool caseSensitive)
-		{
-//			Console.WriteLine(&quot;Search type : &gt;{0}&lt;&quot;, partitialTypeName);
-			IClass c = parserService.GetClass(partitialTypeName, caseSensitive);
-			if (c != null) {
-				return c;
-			}
-			
-			foreach (string str in usings) {
-				string possibleType = String.Concat(str, &quot;.&quot;, partitialTypeName);
-//				Console.WriteLine(&quot;looking for &quot; + possibleType);
-				c = parserService.GetClass(possibleType, caseSensitive);
-				if (c != null) {
-//					Console.WriteLine(&quot;Found!&quot;);
-					return c;
-				}
-			}
-			
-			// search class in partitial namespaces
-			string declaringNamespace = (string)aliases[&quot;&quot;];
-			if (declaringNamespace != null) {
-				while (declaringNamespace.Length &gt; 0) {
-					string className = String.Concat(declaringNamespace, &quot;.&quot;, partitialTypeName);
-//					Console.WriteLine(&quot;looking for &quot; + className);
-					c = parserService.GetClass(className, caseSensitive);
-					if (c != null) {
-//						Console.WriteLine(&quot;Found!&quot;);
-						return c;
-					}
-					int index = declaringNamespace.IndexOf('.');
-					if (index &gt; 0) {
-						declaringNamespace = declaringNamespace.Substring(0, index);
-					} else {
-						break;
-					}
-				}
-			}
-			
-			foreach (DictionaryEntry entry in aliases) {
-				string aliasString = entry.Key.ToString();
-				if (caseSensitive ? partitialTypeName.StartsWith(aliasString) : partitialTypeName.ToLower().StartsWith(aliasString.ToLower())) {
-					string className = null;
-					if (aliasString.Length &gt; 0) {
-						className = String.Concat(entry.Value.ToString(), partitialTypeName.Remove(0, aliasString.Length));
-//						Console.WriteLine(&quot;looking for &quot; + className);
-						c = parserService.GetClass(className, caseSensitive);
-						if (c != null) {
-//							Console.WriteLine(&quot;Found!&quot;);
-							return c;
-						}
-					}
-				}
-			}
-			
-			return null;
-		}
-		
 		public override string ToString()
 		{
 			StringBuilder builder = new StringBuilder(&quot;[AbstractUsing: using list=&quot;);

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/DefaultRegion.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/DefaultRegion.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/Implementations/DefaultRegion.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -18,6 +18,7 @@
 		protected int endLine = -1;
 		protected int beginColumn = -1;
 		protected int endColumn = -1;
+		protected string fileName;
 
 		public virtual int BeginLine {
 			get {
@@ -57,6 +58,15 @@
 			}
 		}
 
+		public string FileName {
+			get { 
+				return fileName; 
+			}
+			set {
+				fileName = value;
+			}
+		}
+		
 		public DefaultRegion(Point start, Point end) : this(start.Y, start.X, end.Y, end.X)
 		{
 		}

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentClass.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentClass.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentClass.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -15,424 +15,176 @@
 
 namespace MonoDevelop.Internal.Parser
 {
-	public sealed class PersistentClass : IClass
+	[Serializable]
+	public sealed class PersistentClass : AbstractClass
 	{
-		int                  classProxyIndex;
-		ClassProxyCollection classProxyCollection;
-
-		// an int arraylist of base types.
-		ArrayList          baseTypes         = new ArrayList();
-
-		/// &lt;remarks&gt;
-		/// This collection is only used during creation, if for a basetype no
-		/// proxy index could be determined. It contains all those names as real name.
-		/// They should be read to &lt;code&gt;baseTypesStringCollection&lt;/code&gt; when the persistant
-		/// class is read.
-		/// &lt;/remarks&gt;
-		StringCollection   notFoundBaseTypes = new StringCollection();
-
-		StringCollection   baseTypesStringCollection = new StringCollection();
-
-		ClassCollection    innerClasses = new ClassCollection();
-		FieldCollection    fields       = new FieldCollection();
-		PropertyCollection properties   = new PropertyCollection();
-		MethodCollection   methods      = new MethodCollection();
-		EventCollection    events       = new EventCollection();
-		IndexerCollection  indexer      = new IndexerCollection();
-
-
-		string       fullyQualifiedName;
-		string       documentation;
-		ClassType    classType;
-		ModifierEnum modifiers;
-
-		public ICompilationUnit CompilationUnit {
+		public override ICompilationUnit CompilationUnit {
 			get {
 				return null;
 			}
 		}
 
-		public PersistentClass(BinaryReader reader, ClassProxyCollection classProxyCollection)
+		public static PersistentClass Read (BinaryReader reader, INameDecoder nameTable)
 		{
-			this.classProxyCollection = classProxyCollection;
-			classProxyIndex = reader.ReadInt32();
+			PersistentClass cls = new PersistentClass ();
+			
+			cls.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			cls.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			
+			cls.modifiers          = (ModifierEnum)reader.ReadUInt32();
+			cls.classType          = (ClassType)reader.ReadInt16();
 
-			if (classProxyIndex &lt; 0) {
-				fullyQualifiedName = reader.ReadString();
-				documentation      = reader.ReadString();
-				modifiers          = (ModifierEnum)reader.ReadUInt32();
-				classType          = (ClassType)reader.ReadInt16();
-			}
-
 			uint count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				int baseTypeIndex = reader.ReadInt32();
-				if (baseTypeIndex &lt; 0) {
-					baseTypesStringCollection.Add(reader.ReadString());
-				} else {
-					baseTypes.Add(baseTypeIndex);
-				}
+				cls.baseTypes.Add (PersistentHelper.ReadString (reader, nameTable));
 			}
-
+			
 			count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				innerClasses.Add(new PersistentClass(reader, classProxyCollection));
+				cls.innerClasses.Add(PersistentClass.Read (reader, nameTable));
 			}
 
 			count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				fields.Add(new PersistentField(reader, classProxyCollection));
+				cls.fields.Add(PersistentField.Read (reader, nameTable));
 			}
 
 			count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				properties.Add(new PersistentProperty(reader, classProxyCollection));
+				cls.properties.Add(PersistentProperty.Read (reader, nameTable));
 			}
 
 			count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				IMethod m = new PersistentMethod(reader, classProxyCollection);
-				methods.Add(m);
+				IMethod m = PersistentMethod.Read (reader, nameTable);
+				cls.methods.Add(m);
 			}
 
 			count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				events.Add(new PersistentEvent(reader, classProxyCollection));
+				cls.events.Add(PersistentEvent.Read (reader, nameTable));
 			}
 
 			count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				indexer.Add(new PersistentIndexer(reader, classProxyCollection));
+				cls.indexer.Add(PersistentIndexer.Read (reader, nameTable));
 			}
+			
+			cls.region = PersistentRegion.Read (reader, nameTable);
+			return cls;
 		}
 
-		public void WriteTo(BinaryWriter writer)
+		public static void WriteTo (IClass cls, BinaryWriter writer, INameEncoder nameTable)
 		{
-			writer.Write(classProxyIndex);
+			PersistentHelper.WriteString (cls.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (cls.Documentation, writer, nameTable);
+				
+			writer.Write((uint)cls.Modifiers);
+			writer.Write((short)cls.ClassType);
 
-			if (classProxyIndex &lt; 0) {
-				writer.Write(fullyQualifiedName);
-				writer.Write(documentation);
-				writer.Write((uint)modifiers);
-				writer.Write((short)classType);
-			}
+			writer.Write((uint)(cls.BaseTypes.Count));
+			foreach (string baseType in cls.BaseTypes)
+				PersistentHelper.WriteString (baseType, writer, nameTable);
 
-			writer.Write((uint)(baseTypes.Count + notFoundBaseTypes.Count));
-			foreach (int baseTypeIdx in baseTypes) {
-				writer.Write(baseTypeIdx);
+			writer.Write((uint)cls.InnerClasses.Count);
+			foreach (IClass innerClass in cls.InnerClasses) {
+				PersistentClass.WriteTo (innerClass, writer, nameTable);
 			}
 
-			foreach (string baseType in notFoundBaseTypes) {
-				writer.Write((int)-1);
-				writer.Write(baseType);
+			writer.Write((uint)cls.Fields.Count);
+			foreach (IField field in cls.Fields) {
+				PersistentField.WriteTo (field, writer, nameTable);
 			}
 
-
-			writer.Write((uint)innerClasses.Count);
-			foreach (PersistentClass innerClass in innerClasses) {
-				innerClass.WriteTo(writer);
+			writer.Write((uint)cls.Properties.Count);
+			foreach (IProperty property in cls.Properties) {
+				PersistentProperty.WriteTo (property, writer, nameTable);
 			}
 
-			writer.Write((uint)fields.Count);
-			foreach (PersistentField field in fields) {
-				field.WriteTo(writer);
+			writer.Write((uint)cls.Methods.Count);
+			foreach (IMethod method in cls.Methods) {
+				PersistentMethod.WriteTo (method, writer, nameTable);
 			}
 
-			writer.Write((uint)properties.Count);
-			foreach (PersistentProperty property in properties) {
-				property.WriteTo(writer);
+			writer.Write((uint)cls.Events.Count);
+			foreach (IEvent e in cls.Events) {
+				PersistentEvent.WriteTo (e, writer, nameTable);
 			}
 
-			writer.Write((uint)methods.Count);
-			foreach (PersistentMethod method in methods) {
-				method.WriteTo(writer);
+			writer.Write((uint)cls.Indexer.Count);
+			foreach (IIndexer ind in cls.Indexer) {
+				PersistentIndexer.WriteTo (ind, writer, nameTable);
 			}
-
-			writer.Write((uint)events.Count);
-			foreach (PersistentEvent e in events) {
-				e.WriteTo(writer);
-			}
-
-			writer.Write((uint)indexer.Count);
-			foreach (PersistentIndexer ind in indexer) {
-				ind.WriteTo(writer);
-			}
+			
+			PersistentRegion.WriteTo (cls.Region, writer, nameTable);
 		}
-
-		public PersistentClass(ClassProxyCollection classProxyCollection, IClass c)
+	}
+	
+	public class PersistentRegion: DefaultRegion
+	{
+		public PersistentRegion (): base (-1,-1)
 		{
-			this.classProxyCollection = classProxyCollection;
-			classProxyIndex           = classProxyCollection.IndexOf(c.FullyQualifiedName, true);
-			if (classProxyIndex &lt; 0) {
-				fullyQualifiedName = c.FullyQualifiedName;
-				documentation      = c.Documentation;
-				modifiers          = c.Modifiers;
-				classType          = c.ClassType;
-			}
-
-			foreach (string baseType in c.BaseTypes) {
-				int idx = classProxyCollection.IndexOf(baseType, true);
-				if (idx &lt; 0) {
-					notFoundBaseTypes.Add(baseType);
-				} else {
-					baseTypes.Add(idx);
-				}
-			}
-
-			foreach (IClass innerClass in c.InnerClasses) {
-				innerClasses.Add(new PersistentClass(classProxyCollection, innerClass));
-			}
-
-			foreach (IField field in c.Fields) {
-				fields.Add(new PersistentField(classProxyCollection, field));
-			}
-
-			foreach (IProperty property in c.Properties) {
-				properties.Add(new PersistentProperty(classProxyCollection, property));
-			}
-
-			foreach (IMethod method in c.Methods) {
-				methods.Add(new PersistentMethod(classProxyCollection, method));
-			}
-
-			foreach (IEvent e in c.Events) {
-				events.Add(new PersistentEvent(classProxyCollection, e));
-			}
-
-			foreach (IIndexer ind in c.Indexer) {
-				indexer.Add(new PersistentIndexer(classProxyCollection, ind));
-			}
 		}
-
-		public ClassType ClassType {
-			get {
-				if (classProxyIndex &lt; 0) {
-					return classType;
-				}
-				return classProxyCollection[classProxyIndex].ClassType;
-			}
+		
+		public static PersistentRegion Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			if (PersistentHelper.ReadNull (reader)) return null;
+			
+			PersistentRegion reg = new PersistentRegion ();
+			reg.FileName = PersistentHelper.ReadString (reader, nameTable);
+			reg.beginLine = reader.ReadInt32 ();
+			reg.endLine = reader.ReadInt32 ();
+			reg.beginColumn = reader.ReadInt32 ();
+			reg.endColumn = reader.ReadInt32 ();
+			return reg;
 		}
-
-		public string FullyQualifiedName {
-			get {
-				if (classProxyIndex &lt; 0) {
-					return fullyQualifiedName;
-				}
-				return classProxyCollection[classProxyIndex].FullyQualifiedName;
-			}
-		}
-
-		public string Name {
-			get {
-				string[] name = FullyQualifiedName.Split(new char[] {'.'});
-				return name[name.Length - 1];
-			}
-		}
-
-		public string Namespace {
-			get {
-				int index = FullyQualifiedName.LastIndexOf('.');
-				return index &lt; 0 ? String.Empty : FullyQualifiedName.Substring(0, index);
-			}
-		}
-
-		// regions are currently useless (only assembly classes are
-		// made persistant)
-		public IRegion Region {
-			get {
-				return null;
-			}
-		}
-		public IRegion BodyRegion {
-			get {
-				return null;
-			}
-		}
-
-		public StringCollection BaseTypes {
-			get {
-				// convert base types first time they're requested
-				if (baseTypes.Count &gt; 0) {
-					foreach (int index in baseTypes) {
-						baseTypesStringCollection.Add(classProxyCollection[index].FullyQualifiedName);
-					}
-					baseTypes.Clear();
-				}
-				return baseTypesStringCollection;
-			}
-		}
 		
-		public ClassCollection InnerClasses {
-			get {
-				return innerClasses;
-			}
+		public static void WriteTo (IRegion reg, BinaryWriter writer, INameEncoder nameTable)
+		{
+			if (PersistentHelper.WriteNull (reg, writer)) return;
+			
+			PersistentHelper.WriteString (reg.FileName, writer, nameTable);
+			writer.Write (reg.BeginLine);
+			writer.Write (reg.BeginColumn);
+			writer.Write (reg.EndColumn);
+			writer.Write (reg.EndLine);
 		}
-
-		public FieldCollection Fields {
-			get {
-				return fields;
+	}
+	
+	public class PersistentHelper
+	{
+		public static void WriteString (string s, BinaryWriter writer, INameEncoder nameTable)
+		{
+			if (s == null)
+				writer.Write (-2);
+			else {
+				int id = nameTable.GetStringId (s);
+				writer.Write (id);
+				if (id == -1)
+					writer.Write (s);
 			}
 		}
-
-		public PropertyCollection Properties {
-			get {
-				return properties;
-			}
-		}
-
-		public IndexerCollection Indexer {
-			get {
-				return indexer;
-			}
-		}
-
-		public MethodCollection Methods {
-			get {
-				return methods;
-			}
-		}
-
-		public EventCollection Events {
-			get {
-				return events;
-			}
-		}
-
-		// IDecoration implementation
-		public ModifierEnum Modifiers {
-			get {
-				if (classProxyIndex &lt; 0) {
-					return modifiers;
-				}
-				return classProxyCollection[classProxyIndex].Modifiers;
-			}
-		}
-
-		public AttributeSectionCollection Attributes {
-			get {
+		
+		public static string ReadString (BinaryReader reader, INameDecoder nameTable)
+		{
+			int id = reader.ReadInt32 ();
+			if (id == -1)
+				return reader.ReadString ();
+			else if (id == -2)
 				return null;
-			}
+			else
+				return nameTable.GetStringValue (id);
 		}
-
-		public string Documentation {
-			get {
-				if (classProxyIndex &lt; 0) {
-					return documentation;
-				}
-				return classProxyCollection[classProxyIndex].Documentation;
-			}
-		}
-
-		public bool IsStatic {
-			get {
-				return (Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static;
-			}
-		}
-
-		public bool IsVirtual {
-			get {
-				return (Modifiers &amp; ModifierEnum.Virtual) == ModifierEnum.Virtual;
-			}
-		}
-
-		public bool IsPublic {
-			get {
-				return (Modifiers &amp; ModifierEnum.Public) == ModifierEnum.Public;
-			}
-		}
-
-		public bool IsFinal {
-			get {
-				return (Modifiers &amp; ModifierEnum.Final) == ModifierEnum.Final;
-			}
-		}
-
-		public bool IsSpecialName {
-			get {
-				return (Modifiers &amp; ModifierEnum.SpecialName) == ModifierEnum.SpecialName;
-			}
-		}
-
-		public bool IsProtected {
-			get {
-				return (Modifiers &amp; ModifierEnum.Protected) == ModifierEnum.Protected;
-			}
-		}
-
-		public bool IsPrivate {
-			get {
-				return (Modifiers &amp; ModifierEnum.Private) == ModifierEnum.Private;
-			}
-		}
-
-		public bool IsInternal {
-			get {
-				return (Modifiers &amp; ModifierEnum.Internal) == ModifierEnum.Internal;
-			}
-		}
-
-		public bool IsProtectedAndInternal {
-			get {
-				return (Modifiers &amp; (ModifierEnum.Internal | ModifierEnum.Protected)) == (ModifierEnum.Internal | ModifierEnum.Protected);
-			}
-		}
-
-		public bool IsProtectedOrInternal {
-			get {
-				return (Modifiers &amp; ModifierEnum.ProtectedOrInternal) == ModifierEnum.ProtectedOrInternal;
-			}
-		}
-
-		public bool IsAbstract {
-			get {
-				return (Modifiers &amp; ModifierEnum.Abstract) == ModifierEnum.Abstract;
-			}
-		}
-
-		public bool IsSealed {
-			get {
-				return (Modifiers &amp; ModifierEnum.Sealed) == ModifierEnum.Sealed;
-			}
-		}
-
-		public bool IsLiteral {
-			get {
-				return (Modifiers &amp; ModifierEnum.Const) == ModifierEnum.Const;
-			}
-		}
-
-		public bool IsReadonly {
-			get {
-				return (Modifiers &amp; ModifierEnum.Readonly) == ModifierEnum.Readonly;
-			}
-		}
-		public bool IsOverride {
-			get {
-				return (Modifiers &amp; ModifierEnum.Override) == ModifierEnum.Override;
-			}
-		}
-
-		public bool IsNew {
-			get {
-				return (Modifiers &amp; ModifierEnum.New) == ModifierEnum.New;
-			}
-		}
-
-		public IEnumerable ClassInheritanceTree {
-			get {
-				return new AbstractClass.ClassInheritanceEnumerator(this);
-			}
-		}
 		
-		int IComparable.CompareTo(object value) {
-			return 0;
+		public static bool WriteNull (object ob, BinaryWriter writer)
+		{
+			writer.Write (ob==null);
+			return ob==null;
 		}
 		
-		// stub
-		public object DeclaredIn {
-			get {
-				return null;
-			}
+		public static bool ReadNull (BinaryReader reader)
+		{
+			return reader.ReadBoolean ();
 		}
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentEvent.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentEvent.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentEvent.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -11,39 +11,27 @@
 
 namespace MonoDevelop.Internal.Parser
 {
+	[Serializable]
 	public sealed class PersistentEvent : AbstractEvent
 	{
-		public PersistentEvent(BinaryReader reader, ClassProxyCollection classProxyCollection)
+		public static PersistentEvent Read (BinaryReader reader, INameDecoder nameTable)
 		{
-			FullyQualifiedName = reader.ReadString();
-			Documentation      = reader.ReadString();
-			modifiers          = (ModifierEnum)reader.ReadUInt32();
-
-			returnType         = new PersistentReturnType(reader, classProxyCollection);
-			if (returnType.Name == null) {
-				returnType = null;
-			}
+			PersistentEvent ev = new PersistentEvent();
+			ev.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			ev.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			ev.modifiers = (ModifierEnum)reader.ReadUInt32();
+			ev.returnType = PersistentReturnType.Read (reader, nameTable);
+			ev.region = PersistentRegion.Read (reader, nameTable);
+			return ev;
 		}
 
-		public void WriteTo(BinaryWriter writer)
+		public static void WriteTo (IEvent ev, BinaryWriter writer, INameEncoder nameTable)
 		{
-			writer.Write(FullyQualifiedName);
-			writer.Write(Documentation);
-			writer.Write((uint)modifiers);
-			((PersistentReturnType)returnType).WriteTo(writer);
+			PersistentHelper.WriteString (ev.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (ev.Documentation, writer, nameTable);
+			writer.Write ((uint)ev.Modifiers);
+			PersistentReturnType.WriteTo (ev.ReturnType, writer, nameTable);
+			PersistentRegion.WriteTo (ev.Region, writer, nameTable);
 		}
-
-		public PersistentEvent(ClassProxyCollection classProxyCollection, IEvent e)
-		{
-			modifiers          = e.Modifiers;
-			FullyQualifiedName = e.Name;
-			if (e.Documentation != null) {
-				Documentation = e.Documentation;
-			} else {
-				Documentation = String.Empty;
-			}
-
-			returnType         = new PersistentReturnType(classProxyCollection, e.ReturnType);
-		}
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentField.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentField.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentField.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -11,39 +11,27 @@
 
 namespace MonoDevelop.Internal.Parser
 {
+	[Serializable]
 	public sealed class PersistentField : AbstractField
 	{
-		public PersistentField(BinaryReader reader, ClassProxyCollection classProxyCollection)
+		public static PersistentField Read (BinaryReader reader, INameDecoder nameTable)
 		{
-			FullyQualifiedName = reader.ReadString();
-			Documentation      = reader.ReadString();
-			modifiers          = (ModifierEnum)reader.ReadUInt32();
-			
-			returnType         = new PersistentReturnType(reader, classProxyCollection);
-			if (returnType.Name == null) {
-				returnType = null;
-			}
+			PersistentField field = new PersistentField ();
+			field.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			field.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			field.modifiers = (ModifierEnum)reader.ReadUInt32();
+			field.returnType = PersistentReturnType.Read (reader, nameTable);
+			field.region = PersistentRegion.Read (reader, nameTable);
+			return field;
 		}
 		
-		public void WriteTo(BinaryWriter writer)
+		public static void WriteTo (IField field, BinaryWriter writer, INameEncoder nameTable)
 		{
-			writer.Write(FullyQualifiedName);
-			writer.Write(Documentation);
-			writer.Write((uint)modifiers);
-			((PersistentReturnType)returnType).WriteTo(writer);
+			PersistentHelper.WriteString (field.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (field.Documentation, writer, nameTable);
+			writer.Write ((uint)field.Modifiers);
+			PersistentReturnType.WriteTo (field.ReturnType, writer, nameTable);
+			PersistentRegion.WriteTo (field.Region, writer, nameTable);
 		}
-		
-		public PersistentField(ClassProxyCollection classProxyCollection, IField field)
-		{
-			modifiers          = field.Modifiers;
-			FullyQualifiedName = field.Name;
-			
-			if (field.Documentation != null) {
-				Documentation = field.Documentation;
-			}  else {
-				Documentation = String.Empty;
-			}
-			returnType         = new PersistentReturnType(classProxyCollection, field.ReturnType);
-		}
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentIndexer.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentIndexer.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentIndexer.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -11,56 +11,38 @@
 
 namespace MonoDevelop.Internal.Parser
 {
+	[Serializable]
 	public sealed class PersistentIndexer : AbstractIndexer
 	{
-		public PersistentIndexer(BinaryReader reader, ClassProxyCollection classProxyCollection)
+		public static PersistentIndexer Read (BinaryReader reader, INameDecoder nameTable)
 		{
-			FullyQualifiedName = reader.ReadString();
-			Documentation      = reader.ReadString();
-			modifiers          = (ModifierEnum)reader.ReadUInt32();
+			PersistentIndexer ind = new PersistentIndexer();
+			ind.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			ind.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			ind.modifiers = (ModifierEnum)reader.ReadUInt32();
+			ind.returnType = PersistentReturnType.Read (reader, nameTable);
 			
-			returnType         = new PersistentReturnType(reader, classProxyCollection);
-			if (returnType.Name == null) {
-				returnType = null;
-			}
-			
 			uint count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				parameters.Add(new PersistentParameter(reader, classProxyCollection));
+				ind.parameters.Add (PersistentParameter.Read (reader, nameTable));
 			}
+			ind.region = PersistentRegion.Read (reader, nameTable);
+			return ind;
 		}
 		
-		public void WriteTo(BinaryWriter writer)
+		public static void WriteTo (IIndexer ind, BinaryWriter writer, INameEncoder nameTable)
 		{
-			writer.Write(FullyQualifiedName);
-			writer.Write(Documentation);
+			PersistentHelper.WriteString (ind.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (ind.Documentation, writer, nameTable);
 			
-			writer.Write((uint)modifiers);
-			((PersistentReturnType)returnType).WriteTo(writer);
+			writer.Write((uint)ind.Modifiers);
+			PersistentReturnType.WriteTo (ind.ReturnType, writer, nameTable);
 			
-			writer.Write((uint)parameters.Count);
-			foreach (PersistentParameter p in parameters) {
-				p.WriteTo(writer);
+			writer.Write ((uint)ind.Parameters.Count);
+			foreach (IParameter p in ind.Parameters) {
+				PersistentParameter.WriteTo (p, writer, nameTable);
 			}
+			PersistentRegion.WriteTo (ind.Region, writer, nameTable);
 		}
-		
-		public PersistentIndexer(ClassProxyCollection classProxyCollection, IIndexer indexer)
-		{
-			FullyQualifiedName = indexer.Name;
-			if (indexer.Documentation != null) {
-				Documentation = indexer.Documentation;
-			} else {
-				Documentation = String.Empty;
-			}
-			modifiers = indexer.Modifiers;
-			returnType         = new PersistentReturnType(classProxyCollection, indexer.ReturnType);
-			
-			foreach (IParameter param in indexer.Parameters) {
-				parameters.Add(new PersistentParameter(classProxyCollection, param));
-			}
-			
-			region = getterRegion = setterRegion = null;
-		}
-		
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentMethod.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentMethod.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentMethod.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -12,56 +12,39 @@
 
 namespace MonoDevelop.Internal.Parser
 {
+	[Serializable]
 	public sealed class PersistentMethod : AbstractMethod
 	{
-		public PersistentMethod(BinaryReader reader, ClassProxyCollection classProxyCollection)
+		public static PersistentMethod Read (BinaryReader reader, INameDecoder nameTable)
 		{
-			FullyQualifiedName = reader.ReadString();
-			Documentation      = reader.ReadString();
+			PersistentMethod met = new PersistentMethod ();
+			met.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			met.Documentation = PersistentHelper.ReadString (reader, nameTable);
 			
-			modifiers          = (ModifierEnum)reader.ReadUInt32();
-			returnType         = new PersistentReturnType(reader, classProxyCollection);
-			if (returnType.Name == null) {
-				returnType = null;
-			}
+			met.modifiers = (ModifierEnum)reader.ReadUInt32();
+			met.returnType = PersistentReturnType.Read (reader, nameTable);
 			
 			uint count = reader.ReadUInt32();
 			for (uint i = 0; i &lt; count; ++i) {
-				parameters.Add(new PersistentParameter(reader, classProxyCollection));
+				met.parameters.Add (PersistentParameter.Read (reader, nameTable));
 			}
+			met.region = PersistentRegion.Read (reader, nameTable);
+			return met;
 		}
 		
-		public void WriteTo(BinaryWriter writer)
+		public static void WriteTo (IMethod met, BinaryWriter writer, INameEncoder nameTable)
 		{
-			writer.Write(FullyQualifiedName);
-			writer.Write(Documentation);
-			writer.Write((uint)modifiers);
-			((PersistentReturnType)returnType).WriteTo(writer);
+			PersistentHelper.WriteString (met.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (met.Documentation, writer, nameTable);
 			
-			writer.Write((uint)parameters.Count);
-			foreach (PersistentParameter p in parameters) {
-				p.WriteTo(writer);
-			}
-		}
-		
-		public PersistentMethod(ClassProxyCollection classProxyCollection, IMethod method)
-		{
-			FullyQualifiedName = method.Name;
-			if (method.Documentation != null) {
-				Documentation = method.Documentation;
-			} else {
-				Documentation = String.Empty;
-			}
+			writer.Write ((uint)met.Modifiers);
+			PersistentReturnType.WriteTo (met.ReturnType, writer, nameTable);
 			
-			modifiers  = method.Modifiers;
-			returnType = new PersistentReturnType(classProxyCollection, method.ReturnType);
-			
-			foreach (IParameter param in method.Parameters) {
-				parameters.Add(new PersistentParameter(classProxyCollection, param));
+			writer.Write (met.Parameters != null ? (uint)met.Parameters.Count : (uint)0);
+			foreach (IParameter p in met.Parameters) {
+				PersistentParameter.WriteTo (p, writer, nameTable);
 			}
-			
-			region = null;
+			PersistentRegion.WriteTo (met.Region, writer, nameTable);
 		}
-		
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentParameter.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentParameter.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentParameter.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -11,39 +11,25 @@
 
 namespace MonoDevelop.Internal.Parser
 {
+	[Serializable]
 	public sealed class PersistentParameter : AbstractParameter
 	{
-		public PersistentParameter(BinaryReader reader, ClassProxyCollection classProxyCollection)
+		public static PersistentParameter Read (BinaryReader reader, INameDecoder nameTable)
 		{
-			name     = reader.ReadString();
-			documentation      = reader.ReadString();
-
-			modifier = (ParameterModifier)reader.ReadByte();
-						
-			returnType = new PersistentReturnType(reader, classProxyCollection);
-			if (returnType.Name == null) {
-				returnType = null;
-			}
+			PersistentParameter par = new PersistentParameter ();
+			par.name = PersistentHelper.ReadString (reader, nameTable);
+			par.documentation = PersistentHelper.ReadString (reader, nameTable);
+			par.modifier = (ParameterModifier)reader.ReadByte();
+			par.returnType = PersistentReturnType.Read (reader, nameTable);
+			return par;
 		}
 		
-		public void WriteTo(BinaryWriter writer)
+		public static void WriteTo (IParameter p, BinaryWriter writer, INameEncoder nameTable)
 		{
-			writer.Write(name);
-			writer.Write(documentation);
-			writer.Write((byte)modifier);
-			((PersistentReturnType)returnType).WriteTo(writer);
+			PersistentHelper.WriteString (p.Name, writer, nameTable);
+			PersistentHelper.WriteString (p.Documentation, writer, nameTable);
+			writer.Write((byte)p.Modifier);
+			PersistentReturnType.WriteTo (p.ReturnType, writer, nameTable);
 		}
-		
-		public PersistentParameter(ClassProxyCollection classProxyCollection, IParameter param)
-		{
-			name          = param.Name;
-			documentation = param.Documentation;
-			if (documentation == null) {
-				documentation = String.Empty;
-			}
-			
-			returnType = new PersistentReturnType(classProxyCollection, param.ReturnType);
-			modifier   = param.Modifier;
-		}
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentProperty.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentProperty.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentProperty.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -11,6 +11,7 @@
 
 namespace MonoDevelop.Internal.Parser
 {
+	[Serializable]
 	public sealed class PersistentProperty : AbstractProperty
 	{
 		const uint canGetFlag = (uint)(1 &lt;&lt; 29);
@@ -31,45 +32,27 @@
 			}
 		}
 		
-		public PersistentProperty(BinaryReader reader, ClassProxyCollection classProxyCollection)
+		public static PersistentProperty Read (BinaryReader reader, INameDecoder nameTable)
 		{
-			FullyQualifiedName = reader.ReadString();
-			Documentation      = reader.ReadString();
+			PersistentProperty pro = new PersistentProperty ();
+			pro.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			pro.Documentation = PersistentHelper.ReadString (reader, nameTable);
 			uint m = reader.ReadUInt32();
-			modifiers          = (ModifierEnum)(m &amp; (canGetFlag - 1));
-			canGet             = (m &amp; canGetFlag) == canGetFlag;
-			canSet             = (m &amp; canSetFlag) == canSetFlag;
-			
-			returnType         = new PersistentReturnType(reader, classProxyCollection);
-			if (returnType.Name == null) {
-				returnType = null;
-			}
+			pro.modifiers = (ModifierEnum)(m &amp; (canGetFlag - 1));
+			pro.canGet = (m &amp; canGetFlag) == canGetFlag;
+			pro.canSet = (m &amp; canSetFlag) == canSetFlag;
+			pro.returnType = PersistentReturnType.Read (reader, nameTable);
+			pro.region = PersistentRegion.Read (reader, nameTable);
+			return pro;
 		}
 		
-		public void WriteTo(BinaryWriter writer)
+		public static void WriteTo (IProperty p, BinaryWriter writer, INameEncoder nameTable)
 		{
-			writer.Write(FullyQualifiedName);
-			writer.Write(Documentation);
-			writer.Write((uint)modifiers + (CanGet ? canGetFlag : 0) + (CanSet ? canSetFlag : 0));
-			((PersistentReturnType)returnType).WriteTo(writer);
+			PersistentHelper.WriteString (p.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (p.Documentation, writer, nameTable);
+			writer.Write((uint)p.Modifiers + (p.CanGet ? canGetFlag : 0) + (p.CanSet ? canSetFlag : 0));
+			PersistentReturnType.WriteTo (p.ReturnType, writer, nameTable);
+			PersistentRegion.WriteTo (p.Region, writer, nameTable);
 		}
-		
-		public PersistentProperty(ClassProxyCollection classProxyCollection, IProperty property)
-		{
-			FullyQualifiedName = property.Name;
-			modifiers          = property.Modifiers;
-			if (property.Documentation != null) {
-				Documentation = property.Documentation;
-			} else {
-				Documentation = String.Empty;
-			}
-			
-			if (property.ReturnType != null) {
-				returnType     = new PersistentReturnType(classProxyCollection, property.ReturnType);
-			}
-			region = getterRegion = setterRegion = null;
-			canGet = property.CanGet;
-			canSet = property.CanSet;
-		}
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentReturnType.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentReturnType.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/PersistenceLayer/PersistentReturnType.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -10,115 +10,41 @@
 
 namespace MonoDevelop.Internal.Parser
 {
-	public sealed class PersistentReturnType : IReturnType
+	[Serializable]
+	public sealed class PersistentReturnType : AbstractReturnType
 	{
-		string               fullyQualifiedName;
-
-		int                  classProxyIndex;
-		ClassProxyCollection classProxyCollection;
-
-		int   pointerNestingLevel = -1;
-		int[] arrayDimensions     = new int[] {};
-
-		public PersistentReturnType(BinaryReader reader, ClassProxyCollection classProxyCollection)
+		public static PersistentReturnType Read (BinaryReader reader, INameDecoder nameTable)
 		{
-			this.classProxyCollection = classProxyCollection;
-			classProxyIndex      = reader.ReadInt32();
+			if (PersistentHelper.ReadNull (reader)) return null;
+			
+			PersistentReturnType rt = new PersistentReturnType ();
+			rt.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
 
-			if (classProxyIndex &lt; 0) {
-				fullyQualifiedName = reader.ReadString();
-			}
+			rt.pointerNestingLevel = reader.ReadInt32();
 
-			pointerNestingLevel = reader.ReadInt32();
-
 			uint count = reader.ReadUInt32();
-			arrayDimensions = new int[count];
-			for (uint i = 0; i &lt; arrayDimensions.Length; ++i) {
-				arrayDimensions[i] = reader.ReadInt32();
+			rt.arrayDimensions = new int[count];
+			for (uint i = 0; i &lt; rt.arrayDimensions.Length; ++i) {
+				rt.arrayDimensions[i] = reader.ReadInt32();
 			}
+			return rt;
 		}
 
-		public void WriteTo(BinaryWriter writer)
+		public static void WriteTo (IReturnType rt, BinaryWriter writer, INameEncoder nameTable)
 		{
-			writer.Write(classProxyIndex);
-			if (classProxyIndex &lt; 0) {
-				writer.Write(fullyQualifiedName);
-			}
-			writer.Write(pointerNestingLevel);
-			if (arrayDimensions == null) {
+			if (PersistentHelper.WriteNull (rt, writer)) return;
+			
+			PersistentHelper.WriteString (rt.FullyQualifiedName, writer, nameTable);
+
+			writer.Write (rt.PointerNestingLevel);
+			if (rt.ArrayDimensions == null) {
 				writer.Write((uint)0);
 			} else {
-				writer.Write((uint)arrayDimensions.Length);
-				for (uint i = 0; i &lt; arrayDimensions.Length; ++i) {
-					writer.Write(arrayDimensions[i]);
+				writer.Write((uint)rt.ArrayDimensions.Length);
+				for (uint i = 0; i &lt; rt.ArrayDimensions.Length; ++i) {
+					writer.Write (rt.ArrayDimensions[i]);
 				}
 			}
 		}
-
-		public PersistentReturnType(ClassProxyCollection classProxyCollection, IReturnType returnType)
-		{
-			if (returnType == null) {
-				classProxyIndex    = - 1;
-				fullyQualifiedName = String.Empty;
-			} else {
-				this.classProxyCollection = classProxyCollection;
-				this.pointerNestingLevel  = returnType.PointerNestingLevel;
-				this.arrayDimensions      = returnType.ArrayDimensions;
-				classProxyIndex           = classProxyCollection.IndexOf(returnType.FullyQualifiedName, true);
-				fullyQualifiedName        = returnType.FullyQualifiedName;
-			}
-		}
-
-		public string FullyQualifiedName {
-			get {
-				if (classProxyIndex &lt; 0) {
-					return fullyQualifiedName;
-				}
-				return classProxyCollection[classProxyIndex].FullyQualifiedName;
-			}
-		}
-
-		public string Name {
- 			get {
-				string[] name = FullyQualifiedName.Split(new char[] {'.'});
-				return name[name.Length - 1];
-			}
-		}
-
-		public string Namespace {
-			get {
-				int index = FullyQualifiedName.LastIndexOf('.');
-				return index &lt; 0 ? String.Empty : FullyQualifiedName.Substring(0, index);
-			}
-		}
-
-		public int PointerNestingLevel {
-			get {
-				return pointerNestingLevel;
-			}
-		}
-
-		public int ArrayCount {
-			get {
-				return ArrayDimensions.Length;
-			}
-		}
-
-		public int[] ArrayDimensions {
-			get {
-				return arrayDimensions;
-			}
-		}
-
-       int IComparable.CompareTo(object value) {
-          return 0;
-       }
-
-		// stub
-       	public object DeclaredIn {
-       		get {
-       			return null;
-       		}
-       	}
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Parser/ReflectionLayer/ReflectionClass.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Parser/ReflectionLayer/ReflectionClass.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Parser/ReflectionLayer/ReflectionClass.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -52,7 +52,8 @@
 			
 			FullyQualifiedName = type.FullName;
 
-			XmlDocument docs = ((MonodocService)ServiceManager.Services.GetService (typeof (MonodocService))).GetHelpXml (FullyQualifiedName);
+			MonodocService docservice = ((MonodocService)ServiceManager.Services.GetService (typeof (MonodocService)));
+			XmlDocument docs = docservice != null ? docservice.GetHelpXml (FullyQualifiedName) : null;
 			if (docs != null) {
 				XmlNode node = docs.SelectSingleNode (&quot;/Type/Docs/summary&quot;);
 				if (node != null) {

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/Combine.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/Combine.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/Combine.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -37,11 +37,17 @@
 		/// &lt;/summary&gt;
 		string startProject  = null;
 		bool   singleStartup = true;
+		bool   eventsAllowed = true;
 		string path          = null;
 		string outputdir     = null;
 		
-		ArrayList entries       = new ArrayList();
+		ProjectFileEventHandler fileAddedToProjectHandler;
+		ProjectFileEventHandler fileRemovedFromProjectHandler;
+		ProjectReferenceEventHandler referenceAddedToProjectHandler;
+		ProjectReferenceEventHandler referenceRemovedFromProjectHandler;
 		
+		CombineEntryCollection entries = new CombineEntryCollection();
+		
 		CombineConfiguration activeConfiguration;
 		
 		Hashtable configurations            = new Hashtable();
@@ -74,7 +80,7 @@
 			}
 		}
 		[Browsable(false)]
-		public ArrayList Entries {
+		public ICombineEntryCollection Entries {
 			get {
 				return entries;
 			}
@@ -165,6 +171,10 @@
 		
 		public Combine()
 		{
+			fileAddedToProjectHandler = new ProjectFileEventHandler (NotifyFileAddedToProject);
+			fileRemovedFromProjectHandler = new ProjectFileEventHandler (NotifyFileRemovedFromProject);
+			referenceAddedToProjectHandler = new ProjectReferenceEventHandler (NotifyReferenceAddedToProject);
+			referenceRemovedFromProjectHandler = new ProjectReferenceEventHandler (NotifyReferenceRemovedFromProject);
 		}
 		
 		public Combine(string filename)
@@ -195,7 +205,6 @@
 			doc.Load(filename);
 			path = Path.GetDirectoryName(filename);
 			
-			
 			XmlElement root = doc.DocumentElement;
 			
 			name          = root.Attributes[&quot;name&quot;].InnerText;
@@ -207,10 +216,16 @@
 			XmlNodeList nodes = root[&quot;Entries&quot;].ChildNodes;
 			entries.Clear();
 			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-			foreach (XmlElement el in nodes) {
-				string abs_path = fileUtilityService.RelativeToAbsolutePath(path, el.Attributes[&quot;filename&quot;].InnerText);
-				AddEntry(abs_path);
+			eventsAllowed = false;
+			try {
+				foreach (XmlElement el in nodes) {
+					string abs_path = fileUtilityService.RelativeToAbsolutePath(path, el.Attributes[&quot;filename&quot;].InnerText);
+					AddEntry(abs_path);
+				}
 			}
+			finally {
+				eventsAllowed = true;
+			}
 			
 			nodes = root[&quot;StartMode&quot;].ChildNodes;
 			combineExecuteDefinitions.Clear();
@@ -382,7 +397,15 @@
 				foreach (DictionaryEntry entry in configurations) {
 					CombineConfiguration conf = (CombineConfiguration)entry.Value;
 					conf.AddEntry(project);
-				}				
+				}
+				if (eventsAllowed)
+					OnEntryAdded (new CombineEntryEventArgs (this, newEntry));
+				
+				newEntry.Project.FileRemovedFromProject += fileAddedToProjectHandler;
+				newEntry.Project.FileAddedToProject += fileRemovedFromProjectHandler;
+				newEntry.Project.ReferenceRemovedFromProject += referenceAddedToProjectHandler;
+				newEntry.Project.ReferenceAddedToProject += referenceRemovedFromProjectHandler;
+				
 				return project;
 			} else {
 				Combine combine = new Combine(filename);
@@ -405,10 +428,41 @@
 					CombineConfiguration conf = (CombineConfiguration)entry.Value;
 					conf.AddEntry(combine);
 				}
+				if (eventsAllowed)
+					OnEntryAdded (new CombineEntryEventArgs (this, newEntry));
+					
+				newEntry.Combine.FileRemovedFromProject += fileAddedToProjectHandler;
+				newEntry.Combine.FileAddedToProject += fileRemovedFromProjectHandler;
+				newEntry.Combine.ReferenceRemovedFromProject += referenceAddedToProjectHandler;
+				newEntry.Combine.ReferenceAddedToProject += referenceRemovedFromProjectHandler;
+				
 				return combine;
 			}
 		}
 		
+		public void RemoveEntry (CombineEntry entry)
+		{
+			ProjectCombineEntry pce = entry as ProjectCombineEntry;
+			if (pce != null) {
+				pce.Project.FileRemovedFromProject -= fileAddedToProjectHandler;
+				pce.Project.FileAddedToProject -= fileRemovedFromProjectHandler;
+				pce.Project.ReferenceRemovedFromProject -= referenceAddedToProjectHandler;
+				pce.Project.ReferenceAddedToProject -= referenceRemovedFromProjectHandler;
+			}
+			else {
+				CombineCombineEntry cce = entry as CombineCombineEntry;
+				if (cce != null) {
+					cce.Combine.FileRemovedFromProject -= fileAddedToProjectHandler;
+					cce.Combine.FileAddedToProject -= fileRemovedFromProjectHandler;
+					cce.Combine.ReferenceRemovedFromProject -= referenceAddedToProjectHandler;
+					cce.Combine.ReferenceAddedToProject -= referenceRemovedFromProjectHandler;
+				}
+			}
+				
+			entries.Remove (entry);
+			OnEntryRemoved (new CombineEntryEventArgs (this, entry));
+		}
+		
 		public void SaveAllProjects()
 		{
 			foreach (CombineEntry entry in entries) {
@@ -464,7 +518,7 @@
 			} else {
 				foreach (CombineExecuteDefinition ced in combineExecuteDefinitions) {
 					if (ced.Type == EntryExecuteType.Execute) {
-						StartProject(Entries.IndexOf(ced.Entry));
+						StartProject(entries.IndexOf(ced.Entry));
 					}
 				}
 			}
@@ -640,6 +694,26 @@
 			stream.Close ();
 		}
 		
+		internal void NotifyFileRemovedFromProject (object sender, ProjectFileEventArgs e)
+		{
+			OnFileRemovedFromProject (e);
+		}
+		
+		internal void NotifyFileAddedToProject (object sender, ProjectFileEventArgs e)
+		{
+			OnFileAddedToProject (e);
+		}
+		
+		internal void NotifyReferenceRemovedFromProject (object sender, ProjectReferenceEventArgs e)
+		{
+			OnReferenceRemovedFromProject (e);
+		}
+		
+		internal void NotifyReferenceAddedToProject (object sender, ProjectReferenceEventArgs e)
+		{
+			OnReferenceAddedToProject (e);
+		}
+		
 		protected virtual void OnStartupPropertyChanged(EventArgs e)
 		{
 			if (StartupPropertyChanged != null) {
@@ -655,8 +729,56 @@
 			}
 		}
 		
+		protected virtual void OnEntryAdded(CombineEntryEventArgs e)
+		{
+			if (EntryAdded != null) {
+				EntryAdded (this, e);
+			}
+		}
+		
+		protected virtual void OnEntryRemoved(CombineEntryEventArgs e)
+		{
+			if (EntryRemoved != null) {
+				EntryRemoved (this, e);
+			}
+		}
+		
+		protected virtual void OnFileRemovedFromProject (ProjectFileEventArgs e)
+		{
+			if (FileRemovedFromProject != null) {
+				FileRemovedFromProject (this, e);
+			}
+		}
+		
+		protected virtual void OnFileAddedToProject (ProjectFileEventArgs e)
+		{
+			if (FileAddedToProject != null) {
+				FileAddedToProject (this, e);
+			}
+		}
+		
+		protected virtual void OnReferenceRemovedFromProject (ProjectReferenceEventArgs e)
+		{
+			if (ReferenceRemovedFromProject != null) {
+				ReferenceRemovedFromProject (this, e);
+			}
+		}
+		
+		protected virtual void OnReferenceAddedToProject (ProjectReferenceEventArgs e)
+		{
+			if (ReferenceAddedToProject != null) {
+				ReferenceAddedToProject (this, e);
+			}
+		}
+
 		public event EventHandler NameChanged;
 		public event EventHandler StartupPropertyChanged;
+		public event CombineEntryEventHandler EntryAdded;
+		public event CombineEntryEventHandler EntryRemoved;
+		public event ProjectFileEventHandler FileAddedToProject;
+		public event ProjectFileEventHandler FileRemovedFromProject;
+		public event ProjectReferenceEventHandler ReferenceAddedToProject;
+		public event ProjectReferenceEventHandler ReferenceRemovedFromProject;
 	}
 	
 	public class CombineActiveConfigurationTypeConverter : TypeConverter

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/CombineEntry.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/CombineEntry.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/CombineEntry.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -279,4 +279,52 @@
 			return String.Empty;
 		}
 	}
+
+	
+	public interface ICombineEntryCollection: IEnumerable
+	{
+		int Count { get; }
+		CombineEntry this [int n] { get; }
+		IEnumerator GetEnumerator ();
+	}
+	
+	public class CombineEntryCollection: ICombineEntryCollection
+	{
+		ArrayList list = new ArrayList ();
+		
+		public int Count
+		{
+			get { return list.Count; }
+		}
+		
+		public CombineEntry this [int n]
+		{
+			get { return (CombineEntry) list[n]; }
+		}
+		
+		public IEnumerator GetEnumerator ()
+		{
+			return list.GetEnumerator ();
+		}
+		
+		public void Add (CombineEntry entry)
+		{
+			list.Add (entry);
+		}
+		
+		public void Remove (CombineEntry entry)
+		{
+			list.Remove (entry);
+		}
+		
+		public int IndexOf (CombineEntry entry)
+		{
+			return list.IndexOf (entry);
+		}
+		
+		public void Clear ()
+		{
+			list.Clear ();
+		}
+	}
 }

Added: trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/CombineEntryEventArgs.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/CombineEntryEventArgs.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Combine/CombineEntryEventArgs.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -0,0 +1,38 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.Internal.Project
+{
+	public delegate void CombineEntryEventHandler(object sender, CombineEntryEventArgs e);
+	
+	public class CombineEntryEventArgs : EventArgs
+	{
+		Combine combine;
+		CombineEntry entry;
+		
+		public Combine Combine {
+			get {
+				return combine;
+			}
+		}
+		
+		public CombineEntry CombineEntry {
+			get {
+				return entry;
+			}
+		}
+		
+		public CombineEntryEventArgs (Combine combine, CombineEntry entry)
+		{
+			this.combine = combine;
+			this.entry = entry;
+		}
+	}
+}

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/AbstractProject.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/AbstractProject.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/AbstractProject.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -52,7 +52,7 @@
 		protected ProjectFileCollection      projectFiles       = new ProjectFileCollection();
 
 		[XmlSetAttribute(typeof(ProjectReference), &quot;References&quot;)]
-		protected ProjectReferenceCollection projectReferencess = new ProjectReferenceCollection();
+		protected ProjectReferenceCollection projectReferences = new ProjectReferenceCollection();
 		
 		protected DeployInformation deployInformation = new DeployInformation();
 		FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
@@ -105,7 +105,7 @@
 		[Browsable(false)]
 		public ProjectReferenceCollection ProjectReferences {
 			get {
-				return projectReferencess;
+				return projectReferences;
 			}
 		}
 		
@@ -172,6 +172,8 @@
 
 		public AbstractProject()
 		{
+			projectFiles.SetProject (this);
+			projectReferences.SetProject (this);
 		}
 
 		public bool IsFileInProject(string filename)
@@ -301,6 +303,9 @@
 			}
 			
 			SearchNewFiles();
+
+			projectFiles.SetProject (this);
+			projectReferences.SetProject (this);
 		}
 
 		void GetXmlAttributes(XmlDocument doc, XmlElement element, object o)
@@ -355,11 +360,13 @@
 							setElement = (XmlElement)element.SelectSingleNode(&quot;descendant::&quot; + xmlSetAttributes[0].Name);
 						}
 						
-						IList collection = (IList)fieldInfo.GetValue(o);
-						foreach (XmlNode childNode in setElement.ChildNodes) {
-							object instance = xmlSetAttributes[0].Type.Assembly.CreateInstance(xmlSetAttributes[0].Type.FullName);
-							GetXmlAttributes(doc, (XmlElement)childNode, instance);
-							collection.Add(instance);
+						if (setElement != null) {
+							IList collection = (IList)fieldInfo.GetValue(o);
+							foreach (XmlNode childNode in setElement.ChildNodes) {
+								object instance = xmlSetAttributes[0].Type.Assembly.CreateInstance(xmlSetAttributes[0].Type.FullName);
+								GetXmlAttributes(doc, (XmlElement)childNode, instance);
+								collection.Add(instance);
+							}
 						}
 					} else { // finally try, if the field is from a type which has a XmlNodeName attribute attached
 						
@@ -561,6 +568,26 @@
 			return config;
 		}
 		
+		internal void NotifyFileRemovedFromProject (ProjectFile file)
+		{
+			OnFileRemovedFromProject (new ProjectFileEventArgs (this, file));
+		}
+		
+		internal void NotifyFileAddedToProject (ProjectFile file)
+		{
+			OnFileAddedToProject (new ProjectFileEventArgs (this, file));
+		}
+		
+		internal void NotifyReferenceRemovedFromProject (ProjectReference reference)
+		{
+			OnReferenceRemovedFromProject (new ProjectReferenceEventArgs (this, reference));
+		}
+		
+		internal void NotifyReferenceAddedToProject (ProjectReference reference)
+		{
+			OnReferenceAddedToProject (new ProjectReferenceEventArgs (this, reference));
+		}
+		
 		protected virtual void OnNameChanged(EventArgs e)
 		{
 			if (NameChanged != null) {
@@ -568,7 +595,39 @@
 			}
 		}
 		
+		protected virtual void OnFileRemovedFromProject (ProjectFileEventArgs e)
+		{
+			if (FileRemovedFromProject != null) {
+				FileRemovedFromProject (this, e);
+			}
+		}
+		
+		protected virtual void OnFileAddedToProject (ProjectFileEventArgs e)
+		{
+			if (FileAddedToProject != null) {
+				FileAddedToProject (this, e);
+			}
+		}
+		
+		protected virtual void OnReferenceRemovedFromProject (ProjectReferenceEventArgs e)
+		{
+			if (ReferenceRemovedFromProject != null) {
+				ReferenceRemovedFromProject (this, e);
+			}
+		}
+		
+		protected virtual void OnReferenceAddedToProject (ProjectReferenceEventArgs e)
+		{
+			if (ReferenceAddedToProject != null) {
+				ReferenceAddedToProject (this, e);
+			}
+		}
+		
 		public event EventHandler NameChanged;
+		public event ProjectFileEventHandler FileRemovedFromProject;
+		public event ProjectFileEventHandler FileAddedToProject;
+		public event ProjectReferenceEventHandler ReferenceRemovedFromProject;
+		public event ProjectReferenceEventHandler ReferenceAddedToProject;
 	}
 	
 	public class ProjectActiveConfigurationTypeConverter : TypeConverter

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/Collections/ProjectFileCollection.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/Collections/ProjectFileCollection.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/Collections/ProjectFileCollection.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -17,40 +17,23 @@
 	/// &lt;seealso cref='.ProjectFileCollection'/&gt;
 	[Serializable()]
 	public class ProjectFileCollection : CollectionBase {
+	
+		AbstractProject project;
 		
 		/// &lt;summary&gt;
 		///     &lt;para&gt;
 		///       Initializes a new instance of &lt;see cref='.ProjectFileCollection'/&gt;.
 		///    &lt;/para&gt;
 		/// &lt;/summary&gt;
-		public ProjectFileCollection() {
+		public ProjectFileCollection () {
 		}
 		
-		/// &lt;summary&gt;
-		///     &lt;para&gt;
-		///       Initializes a new instance of &lt;see cref='.ProjectFileCollection'/&gt; based on another &lt;see cref='.ProjectFileCollection'/&gt;.
-		///    &lt;/para&gt;
-		/// &lt;/summary&gt;
-		/// &lt;param name='value'&gt;
-		///       A &lt;see cref='.ProjectFileCollection'/&gt; from which the contents are copied
-		/// &lt;/param&gt;
-		public ProjectFileCollection(ProjectFileCollection value) {
-			this.AddRange(value);
+		internal void SetProject (AbstractProject project)
+		{
+			this.project = project;
 		}
 		
 		/// &lt;summary&gt;
-		///     &lt;para&gt;
-		///       Initializes a new instance of &lt;see cref='.ProjectFileCollection'/&gt; containing any array of &lt;see cref='.ProjectFile'/&gt; objects.
-		///    &lt;/para&gt;
-		/// &lt;/summary&gt;
-		/// &lt;param name='value'&gt;
-		///       A array of &lt;see cref='.ProjectFile'/&gt; objects with which to intialize the collection
-		/// &lt;/param&gt;
-		public ProjectFileCollection(ProjectFile[] value) {
-			this.AddRange(value);
-		}
-		
-		/// &lt;summary&gt;
 		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.ProjectFile'/&gt;.&lt;/para&gt;
 		/// &lt;/summary&gt;
 		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
@@ -63,7 +46,9 @@
 				return ((ProjectFile)(List[index]));
 			}
 			set {
+				project.NotifyFileRemovedFromProject ((ProjectFile)List[index]);
 				List[index] = value;
+				project.NotifyFileAddedToProject (value);
 			}
 		}
 		
@@ -77,7 +62,9 @@
 		/// &lt;/returns&gt;
 		/// &lt;seealso cref='.ProjectFileCollection.AddRange'/&gt;
 		public int Add(ProjectFile value) {
-			return List.Add(value);
+			int i = List.Add(value);
+			project.NotifyFileAddedToProject (value);
+			return i;
 		}
 		
 		/// &lt;summary&gt;
@@ -168,6 +155,7 @@
 		/// &lt;seealso cref='.ProjectFileCollection.Add'/&gt;
 		public void Insert(int index, ProjectFile value) {
 			List.Insert(index, value);
+			project.NotifyFileAddedToProject (value);
 		}
 		
 		/// &lt;summary&gt;

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/Collections/ProjectReferenceCollection.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/Collections/ProjectReferenceCollection.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/Collections/ProjectReferenceCollection.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -18,39 +18,22 @@
 	[Serializable()]
 	public class ProjectReferenceCollection : CollectionBase {
 		
+		AbstractProject project;
+		
 		/// &lt;summary&gt;
 		///     &lt;para&gt;
 		///       Initializes a new instance of &lt;see cref='.ProjectReferenceCollection'/&gt;.
 		///    &lt;/para&gt;
 		/// &lt;/summary&gt;
-		public ProjectReferenceCollection() {
+		internal ProjectReferenceCollection() {
 		}
 		
-		/// &lt;summary&gt;
-		///     &lt;para&gt;
-		///       Initializes a new instance of &lt;see cref='.ProjectReferenceCollection'/&gt; based on another &lt;see cref='.ProjectReferenceCollection'/&gt;.
-		///    &lt;/para&gt;
-		/// &lt;/summary&gt;
-		/// &lt;param name='value'&gt;
-		///       A &lt;see cref='.ProjectReferenceCollection'/&gt; from which the contents are copied
-		/// &lt;/param&gt;
-		public ProjectReferenceCollection(ProjectReferenceCollection value) {
-			this.AddRange(value);
+		internal void SetProject (AbstractProject project)
+		{
+			this.project = project;
 		}
 		
 		/// &lt;summary&gt;
-		///     &lt;para&gt;
-		///       Initializes a new instance of &lt;see cref='.ProjectReferenceCollection'/&gt; containing any array of &lt;see cref='.ProjectReference'/&gt; objects.
-		///    &lt;/para&gt;
-		/// &lt;/summary&gt;
-		/// &lt;param name='value'&gt;
-		///       A array of &lt;see cref='.ProjectReference'/&gt; objects with which to intialize the collection
-		/// &lt;/param&gt;
-		public ProjectReferenceCollection(ProjectReference[] value) {
-			this.AddRange(value);
-		}
-		
-		/// &lt;summary&gt;
 		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.ProjectReference'/&gt;.&lt;/para&gt;
 		/// &lt;/summary&gt;
 		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
@@ -63,7 +46,9 @@
 				return ((ProjectReference)(List[index]));
 			}
 			set {
+				project.NotifyReferenceRemovedFromProject ((ProjectReference)List[index]);
 				List[index] = value;
+				project.NotifyReferenceAddedToProject (value);
 			}
 		}
 		
@@ -77,7 +62,9 @@
 		/// &lt;/returns&gt;
 		/// &lt;seealso cref='.ProjectReferenceCollection.AddRange'/&gt;
 		public int Add(ProjectReference value) {
-			return List.Add(value);
+			int i = List.Add(value);
+			project.NotifyReferenceAddedToProject (value);
+			return i;
 		}
 		
 		/// &lt;summary&gt;
@@ -168,6 +155,7 @@
 		/// &lt;seealso cref='.ProjectReferenceCollection.Add'/&gt;
 		public void Insert(int index, ProjectReference value) {
 			List.Insert(index, value);
+			project.NotifyReferenceAddedToProject (value);
 		}
 		
 		/// &lt;summary&gt;
@@ -189,6 +177,7 @@
 		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
 		public void Remove(ProjectReference value) {
 			List.Remove(value);
+			project.NotifyReferenceRemovedFromProject (value);
 		}
 		
 		public class ProjectReferenceEnumerator : object, IEnumerator {

Modified: trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/IProject.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/IProject.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/IProject.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -156,5 +156,9 @@
 		IConfiguration CreateConfiguration();
 		
 		event EventHandler NameChanged;
+		event ProjectFileEventHandler FileRemovedFromProject;
+		event ProjectFileEventHandler FileAddedToProject;
+		event ProjectReferenceEventHandler ReferenceRemovedFromProject;
+		event ProjectReferenceEventHandler ReferenceAddedToProject;
 	}
 }

Added: trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/ProjectFileEventArgs.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/ProjectFileEventArgs.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/ProjectFileEventArgs.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -0,0 +1,38 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.Internal.Project
+{
+	public delegate void ProjectFileEventHandler(object sender, ProjectFileEventArgs e);
+	
+	public class ProjectFileEventArgs : EventArgs
+	{
+		IProject project;
+		ProjectFile file;
+		
+		public IProject Project {
+			get {
+				return project;
+			}
+		}
+		
+		public ProjectFile ProjectFile {
+			get {
+				return file;
+			}
+		}
+		
+		public ProjectFileEventArgs (IProject project, ProjectFile file)
+		{
+			this.project = project;
+			this.file = file;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/ProjectReferenceEventArgs.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/ProjectReferenceEventArgs.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Internal/Project/Project/ProjectReferenceEventArgs.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -0,0 +1,38 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.Internal.Project
+{
+	public delegate void ProjectReferenceEventHandler(object sender, ProjectReferenceEventArgs e);
+	
+	public class ProjectReferenceEventArgs : EventArgs
+	{
+		IProject project;
+		ProjectReference reference;
+		
+		public IProject Project {
+			get {
+				return project;
+			}
+		}
+		
+		public ProjectReference ProjectReference {
+			get {
+				return reference;
+			}
+		}
+		
+		public ProjectReferenceEventArgs (IProject project, ProjectReference reference)
+		{
+			this.project = project;
+			this.reference = reference;
+		}
+	}
+}

Modified: trunk/MonoDevelop/src/Main/Base/Makefile.am
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Makefile.am	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Makefile.am	2004-05-25 19:32:09 UTC (rev 1631)
@@ -205,11 +205,13 @@
 ./Services/ClassBrowserIcons/ClassBrowserIconsService.cs \
 ./Services/ResourceNotFoundException.cs \
 ./Services/ParserService/DefaultParserService.cs \
+./Services/ParserService/CodeCompletionDatabase.cs \
 ./Services/ParserService/ClassProxyCollection.cs \
 ./Services/ParserService/IParserService.cs \
 ./Services/ParserService/ClassProxy.cs \
 ./Services/ParserService/AssemblyInformation.cs \
 ./Services/ParserService/ParseInformation.cs \
+./Services/ParserService/ClassInformationEventHandler.cs \
 ./Services/ResourceService.cs \
 ./Services/StockIcons.cs \
 ./Services/MessageService.cs \
@@ -339,10 +341,12 @@
 ./Internal/Project/Project/AbstractProjectConfiguration.cs \
 ./Internal/Project/Project/AbstractProject.cs \
 ./Internal/Project/Project/ProjectReference.cs \
+./Internal/Project/Project/ProjectReferenceEventArgs.cs \
 ./Internal/Project/Project/ConvertXml.cs \
 ./Internal/Project/Project/IncludeFilesDialog.cs \
 ./Internal/Project/Project/IConfiguration.cs \
 ./Internal/Project/Project/ProjectFile.cs \
+./Internal/Project/Project/ProjectFileEventArgs.cs \
 ./Internal/Project/Project/AbstractConfiguration.cs \
 ./Internal/Project/Project/IProject.cs \
 ./Internal/Project/Combine/Combine.cs \
@@ -351,6 +355,7 @@
 ./Internal/Project/Combine/CombineConfiguration.cs \
 ./Internal/Project/Combine/NoStartupCombineDefinedException.cs \
 ./Internal/Project/Combine/CombineEntry.cs \
+./Internal/Project/Combine/CombineEntryEventArgs.cs \
 ./Internal/Templates/FileDescriptionTemplate.cs \
 ./Internal/Templates/CodeTemplate.cs \
 ./Internal/Templates/CodeTemplateGroup.cs \

Modified: trunk/MonoDevelop/src/Main/Base/Services/File/DefaultFileService.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/File/DefaultFileService.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Services/File/DefaultFileService.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -51,27 +51,28 @@
 		class LoadFileWrapper
 		{
 			IDisplayBinding binding;
-			string projectname, pathrelativetoproject;
+			IProject project;
+			string pathrelativetoproject;
 			
 			public LoadFileWrapper(IDisplayBinding binding)
 			{
 				this.binding = binding;
 			}
 			
-			public LoadFileWrapper(IDisplayBinding binding, string projectname, string pathrelativetoproject)
+			public LoadFileWrapper(IDisplayBinding binding, IProject project, string pathrelativetoproject)
 			{
 				this.binding = binding;
-				this.projectname = projectname;
+				this.project = project;
 				this.pathrelativetoproject = pathrelativetoproject;
 			}
 			
 			public void Invoke(string fileName)
 			{
 				IViewContent newContent = binding.CreateContentForFile(fileName);
-				if (projectname != null &amp;&amp; projectname != &quot;&quot; &amp;&amp;  pathrelativetoproject != null &amp;&amp; pathrelativetoproject != &quot;&quot;)
-				{ 
+				if (project != null &amp;&amp;  pathrelativetoproject != null &amp;&amp; pathrelativetoproject != &quot;&quot;)
+				{
 					newContent.HasProject = true;
-					newContent.ProjectName = projectname;
+					newContent.Project = project;
 					newContent.PathRelativeToProject = pathrelativetoproject;
 				}
 				WorkbenchSingleton.Workbench.ShowView(newContent);
@@ -126,7 +127,7 @@
 				
 				if (combine != null &amp;&amp; project != null)
 				{
-					if (fileUtilityService.ObservedLoad(new NamedFileOperationDelegate(new LoadFileWrapper(binding, project.Name, pathrelativetoproject).Invoke), fileName) == FileOperationResult.OK) {
+					if (fileUtilityService.ObservedLoad(new NamedFileOperationDelegate(new LoadFileWrapper(binding, project, pathrelativetoproject).Invoke), fileName) == FileOperationResult.OK) {
 						fileService.RecentOpen.AddLastFile(fileName);
 					}
 				}

Modified: trunk/MonoDevelop/src/Main/Base/Services/ParserService/AssemblyInformation.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/ParserService/AssemblyInformation.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Services/ParserService/AssemblyInformation.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -31,6 +31,7 @@
 	public class AssemblyInformation : MarshalByRefObject
 	{
 		ClassCollection classes = new ClassCollection();
+		string fileName;
 		
 		/// &lt;value&gt;
 		/// A &lt;code&gt;ClassColection&lt;/code&gt; that contains all loaded classes.
@@ -41,6 +42,11 @@
 			}
 		}
 		
+		public string FileName
+		{
+			get { return fileName; }
+		}
+		
 		public AssemblyInformation()
 		{
 		}
@@ -97,6 +103,9 @@
 			//FIXME: Re-enable this code when the mono bug goes away, 0.32
 			//hopefully
 			//System.Reflection.Assembly asm = nonLocking ? Assembly.Load(GetBytes(fileName)) : Assembly.LoadFrom(fileName);
+			
+			this.fileName = fileName;
+			
 			Assembly asm = null;		
 			try {
 				asm = Assembly.LoadFrom (fileName);

Added: trunk/MonoDevelop/src/Main/Base/Services/ParserService/ClassInformationEventHandler.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/ParserService/ClassInformationEventHandler.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Services/ParserService/ClassInformationEventHandler.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -0,0 +1,47 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+using System.IO;
+
+using MonoDevelop.Core.AddIns;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Services
+{
+	public delegate void ClassInformationEventHandler(object sender, ClassInformationEventArgs e);
+	
+	public class ClassInformationEventArgs : EventArgs
+	{
+		string fileName;
+		ClassUpdateInformation classInformation;
+				
+		public string FileName {
+			get {
+				return fileName;
+			}
+		}
+		
+		public ClassUpdateInformation ClassInformation {
+			get {
+				return classInformation;
+			}
+		}
+		
+		public ClassInformationEventArgs(string fileName, ClassUpdateInformation classInformation)
+		{
+			this.fileName         = fileName;
+			this.classInformation = classInformation;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/Main/Base/Services/ParserService/CodeCompletionDatabase.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/ParserService/CodeCompletionDatabase.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Services/ParserService/CodeCompletionDatabase.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -0,0 +1,1011 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Diagnostics;
+using System.Threading;
+using System.IO;
+using System.Collections;
+using System.Runtime.Serialization;
+using System.Runtime.Serialization.Formatters.Binary;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Parser;
+using System.Reflection;
+
+namespace MonoDevelop.Services
+{
+	internal class CodeCompletionDatabase
+	{
+		static readonly int MAX_ACTIVE_COUNT = 100;
+		static readonly int MIN_ACTIVE_COUNT = 50;
+		static readonly int FORMAT_VERSION = 2;
+		
+		NamespaceEntry rootNamespace;
+		protected ArrayList references;
+		protected Hashtable files;
+		protected DefaultParserService parserService;
+		protected Hashtable headers;
+		
+		BinaryReader datareader;
+		FileStream datafile;
+		int currentGetTime = 0;
+		bool modified;
+		
+		string basePath;
+		string dataFile;
+		
+		protected Object rwlock = new Object ();
+		
+		public CodeCompletionDatabase (DefaultParserService parserService)
+		{
+			this.parserService = parserService;
+			rootNamespace = new NamespaceEntry ();
+			files = new Hashtable ();
+			references = new ArrayList ();
+			headers = new Hashtable ();
+		}
+		
+		protected void SetLocation (string basePath, string name)
+		{
+			dataFile = Path.Combine (basePath, name + &quot;.pidb&quot;);
+			this.basePath = basePath;
+		}
+		
+		public void Rename (string name)
+		{
+			lock (rwlock)
+			{
+				Flush ();
+				string oldDataFile = dataFile;
+				dataFile = Path.Combine (basePath, name + &quot;.pidb&quot;);
+
+				CloseReader ();
+				
+				if (File.Exists (oldDataFile))
+					File.Move (oldDataFile, dataFile);
+			}
+		}
+		
+		public virtual void Read ()
+		{
+			if (basePath == null)
+				throw new InvalidOperationException (&quot;Location not set&quot;);
+				
+			if (!File.Exists (dataFile)) return;
+			
+			lock (rwlock)
+			{
+				FileStream ifile = null;
+				try 
+				{
+					modified = false;
+					currentGetTime = 0;
+					CloseReader ();
+					
+					Console.WriteLine (&quot;Reading &quot; + dataFile);
+					ifile = new FileStream (dataFile, FileMode.Open, FileAccess.Read, FileShare.Read);
+					BinaryFormatter bf = new BinaryFormatter ();
+					
+					// Read the headers
+					headers = (Hashtable) bf.Deserialize (ifile);
+					int ver = (int) headers[&quot;Version&quot;];
+					if (ver != FORMAT_VERSION)
+						throw new Exception (&quot;Expected version &quot; + FORMAT_VERSION + &quot;, found version &quot; + ver);
+					
+					// Move to the index offset and read the index
+					BinaryReader br = new BinaryReader (ifile);
+					long indexOffset = br.ReadInt64 ();
+					ifile.Position = indexOffset;
+					
+					object[] data = (object[]) bf.Deserialize (ifile);
+					ifile.Close ();
+					
+					references = (ArrayList) data[0];
+					rootNamespace = (NamespaceEntry) data[1];
+					files = (Hashtable) data[2];
+				}
+				catch (Exception ex)
+				{
+					if (ifile != null) ifile.Close ();
+					Console.WriteLine (&quot;PIDB file '&quot; + dataFile + &quot;' couldn not be loaded: '&quot; + ex.Message + &quot;'. The file will be recreated&quot;);
+					rootNamespace = new NamespaceEntry ();
+					files = new Hashtable ();
+					references = new ArrayList ();
+					headers = new Hashtable ();
+				}
+			}
+		}
+		
+		public static Hashtable ReadHeaders (string baseDir, string name)
+		{
+			string file = Path.Combine (baseDir, name + &quot;.pidb&quot;);
+			FileStream ifile = new FileStream (file, FileMode.Open, FileAccess.Read, FileShare.Read);
+			BinaryFormatter bf = new BinaryFormatter ();
+			Hashtable headers = (Hashtable) bf.Deserialize (ifile);
+			ifile.Close ();
+			return headers;
+		}
+		
+		public void Write ()
+		{
+			lock (rwlock)
+			{
+				if (!modified) return;
+				modified = false;
+				headers[&quot;Version&quot;] = FORMAT_VERSION;
+							
+				Console.WriteLine (&quot;Writing &quot; + dataFile);
+				
+				string tmpDataFile = dataFile + &quot;.tmp&quot;;
+				FileStream dfile = new FileStream (tmpDataFile, FileMode.Create, FileAccess.Write, FileShare.Write);
+				
+				BinaryFormatter bf = new BinaryFormatter ();
+				BinaryWriter bw = new BinaryWriter (dfile);
+				
+				// The headers are the first thing to write, so they can be read
+				// without deserializing the whole file.
+				bf.Serialize (dfile, headers);
+				
+				// The position of the index will be written here
+				long indexOffsetPos = dfile.Position;
+				bw.Write ((long)0);
+				
+				// Write all class data
+				foreach (FileEntry fe in files.Values) 
+				{
+					ClassEntry ce = fe.FirstClass;
+					while (ce != null)
+					{
+						IClass c = ce.Class;
+						if (c == null)
+							c = ReadClass (ce);
+							
+						ce.Position = dfile.Position;
+						PersistentClass.WriteTo (c, bw, parserService.DefaultNameEncoder);
+						ce = ce.NextInFile;
+					}
+				}
+				
+				// Write the index
+				long indexOffset = dfile.Position;
+				object[] data = new object[] { references, rootNamespace, files };
+				bf.Serialize (dfile, data);
+				
+				dfile.Position = indexOffsetPos;
+				bw.Write (indexOffset);
+				
+				bw.Close ();
+				dfile.Close ();
+				
+				CloseReader ();
+				
+				if (File.Exists (dataFile))
+					File.Delete (dataFile);
+					
+				File.Move (tmpDataFile, dataFile);
+				
+				Console.WriteLine (&quot;Done Writing &quot; + tmpDataFile);
+			}
+		}
+		
+		void Flush ()
+		{
+			int activeCount = 0;
+			
+			foreach (FileEntry fe in files.Values) {
+				ClassEntry ce = fe.FirstClass;
+				while (ce != null) { 
+					if (ce.Class != null) activeCount++;
+					ce = ce.NextInFile;
+				}
+			}
+			
+			if (activeCount &lt;= MAX_ACTIVE_COUNT) return;
+			
+			Write ();
+			
+			foreach (FileEntry fe in files.Values) {
+				ClassEntry ce = fe.FirstClass;
+				while (ce != null) { 
+					if (ce.LastGetTime &lt; currentGetTime - MIN_ACTIVE_COUNT)
+						ce.Class = null;
+					ce = ce.NextInFile;
+				}
+			}
+		}
+		
+		IClass ReadClass (ClassEntry ce)
+		{
+			if (datareader == null) {
+				datafile = new FileStream (dataFile, FileMode.Open, FileAccess.Read, FileShare.Read);
+				datareader = new BinaryReader (datafile);
+			}
+			datafile.Position = ce.Position;
+			return PersistentClass.Read (datareader, parserService.DefaultNameDecoder);
+		}
+		
+		void CloseReader ()
+		{
+			if (datareader != null) {
+				datareader.Close ();
+				datareader = null;
+			}
+		}
+		
+		public IClass GetClass (string typeName, bool caseSensitive)
+		{
+			lock (rwlock)
+			{
+				string[] path = typeName.Split ('.');
+				int len = path.Length - 1;
+				NamespaceEntry nst = GetNamespaceEntry (path, len, false, caseSensitive);
+				if (nst == null) return null;
+	
+				ClassEntry ce = nst.GetClass (path[len], caseSensitive);
+				if (ce == null) return null;
+				return GetClass (ce);
+			}
+		}
+		
+		IClass GetClass (ClassEntry ce)
+		{
+			ce.LastGetTime = currentGetTime++;
+			if (ce.Class != null) return ce.Class;
+			
+			// Read the class from the file
+			
+			ce.Class = ReadClass (ce);
+			return ce.Class;
+		}		
+		
+		public void CheckModifiedFiles ()
+		{
+			lock (rwlock)
+			{
+				foreach (FileEntry file in files.Values)
+				{
+					if (!File.Exists (file.FileName)) continue;
+					FileInfo fi = new FileInfo (file.FileName);
+					if (fi.LastWriteTime &gt; file.LastParseTime) 
+					{
+						// Change date now, to avoid reparsing if CheckModifiedFiles is called again
+						// before the parse job is executed
+						
+						file.LastParseTime = fi.LastWriteTime;
+						parserService.QueueParseJob (new WaitCallback (ParseCallback), file.FileName);
+					}
+				}
+			}
+		}
+		
+		void ParseCallback (object ob)
+		{
+			lock (rwlock)
+			{
+				ParseFile ((string)ob);
+			}
+		}
+		
+		protected virtual void ParseFile (string fileName)
+		{
+		}
+		
+		public void ParseAll ()
+		{
+			lock (rwlock)
+			{
+				foreach (FileEntry fe in files.Values) 
+					ParseFile (fe.FileName);
+			}
+		}
+		
+		protected void AddReference (string uri)
+		{
+			Console.WriteLine (&quot;AddReference &quot; + uri);
+			lock (rwlock)
+			{
+				ReferenceEntry re = new ReferenceEntry (uri);
+				references.Add (re);
+				modified = true;
+			}
+		}
+		
+		protected void RemoveReference (string uri)
+		{
+			Console.WriteLine (&quot;RemoveReference &quot; + uri);
+			lock (rwlock)
+			{
+				for (int n=0; n&lt;references.Count; n++)
+				{
+					if (((ReferenceEntry)references[n]).Uri == uri) {
+						references.RemoveAt (n);
+						modified = true;
+						return;
+					}
+				}
+			}
+		}
+		
+		public void AddFile (string fileName)
+		{
+			lock (rwlock)
+			{
+				FileEntry fe = new FileEntry (fileName);
+				files [fileName] = fe;
+				modified = true;
+			}
+		}
+		
+		public void RemoveFile (string fileName)
+		{
+			lock (rwlock)
+			{
+				FileEntry fe = files [fileName] as FileEntry;
+				if (fe == null) return;
+				
+				ClassEntry ce = fe.FirstClass;
+				while (ce != null) {
+					ce.NamespaceRef.Remove (ce.Name);
+					ce = ce.NextInFile;
+				}
+				
+				files.Remove (fileName);
+				modified = true;
+			}
+		}
+		
+		protected void AddClass (IClass c, FileEntry fe)
+		{
+			lock (rwlock)
+			{
+				string[] path = c.Namespace.Split ('.');
+				NamespaceEntry nst = GetNamespaceEntry (path, path.Length, true, true);
+				ClassEntry ce = nst.GetClass (c.Name, true);
+				if (ce == null) {
+					ce = new ClassEntry (c, fe, nst);
+					nst.Add (c.Name, ce);
+				}
+				else {
+					ce.Class = CopyClass (c);
+				}
+				
+				if (ce.FileEntry != fe)
+					fe.AddClass (ce);
+	
+				ce.LastGetTime = currentGetTime++;
+				modified = true;
+			}
+		}
+			
+		public ClassUpdateInformation UpdateClassInformation (ClassCollection newClasses, string fileName)
+		{
+			lock (rwlock)
+			{
+				ClassUpdateInformation res = new ClassUpdateInformation ();
+				
+				FileEntry fe = files [fileName] as FileEntry;
+				if (fe == null) return null;
+				
+				bool[] added = new bool [newClasses.Count];
+				NamespaceEntry[] newNss = new NamespaceEntry [newClasses.Count];
+				for (int n=0; n&lt;newClasses.Count; n++) {
+					string[] path = newClasses[n].Namespace.Split ('.');
+					newNss[n] = GetNamespaceEntry (path, path.Length, true, true);
+				}
+				
+				ArrayList newFileClasses = new ArrayList ();
+				
+				if (fe != null)
+				{
+					ClassEntry ce = fe.FirstClass;
+					while (ce != null)
+					{
+						IClass newClass = null;
+						for (int n=0; n&lt;newClasses.Count &amp;&amp; newClass == null; n++) {
+							IClass uc = newClasses [n];
+							if (uc.Name == ce.Name &amp;&amp; newNss[n] == ce.NamespaceRef) {
+								newClass = uc;
+								added[n] = true;
+							}
+						}
+						
+						if (newClass != null) {
+							// Class found, replace it
+							ce.Class = CopyClass (newClass);
+							ce.LastGetTime = currentGetTime++;
+							newFileClasses.Add (ce);
+							res.Modified.Add (ce.Class);
+						}
+						else {
+							// Class not found, it has to be deleted, unless it has
+							// been added in another file
+							if (ce.FileEntry == fe) {
+								IClass c = ce.Class;
+								if (c == null) c = ReadClass (ce);
+								res.Removed.Add (c);
+								ce.NamespaceRef.Remove (ce.Name);
+							}
+						}
+						ce = ce.NextInFile;
+					}
+				}
+				
+				if (fe == null) {
+					fe = new FileEntry (fileName);
+					files [fileName] = fe;
+				}
+				
+				for (int n=0; n&lt;newClasses.Count; n++) {
+					if (!added[n]) {
+						IClass c = CopyClass (newClasses[n]);
+						ClassEntry ce = new ClassEntry (c, fe, newNss[n]);
+						ce.LastGetTime = currentGetTime++;
+						newNss[n].Add (c.Name, ce);
+						newFileClasses.Add (ce);
+						res.Added.Add (c);
+					}
+				}
+				
+				fe.SetClasses (newFileClasses);
+				rootNamespace.Clean ();
+				fe.LastParseTime = DateTime.Now;
+				modified = true;
+				Flush ();
+				
+				return res;
+			}
+		}
+		
+		public void GetNamespaceContents (ArrayList list, string subNameSpace, bool caseSensitive)
+		{
+			lock (rwlock)
+			{
+				string[] path = subNameSpace.Split ('.');
+				NamespaceEntry tns = GetNamespaceEntry (path, path.Length, false, caseSensitive);
+				if (tns == null) return;
+				
+				foreach (DictionaryEntry en in tns.Contents) {
+					if (en.Value is NamespaceEntry)
+						list.Add (en.Key);
+					else
+						list.Add (GetClass ((ClassEntry)en.Value));
+				}
+			}
+		}
+		
+		public void GetNamespaceList (ArrayList list, string subNameSpace, bool caseSensitive)
+		{
+			lock (rwlock)
+			{
+				string[] path = subNameSpace.Split ('.');
+				NamespaceEntry tns = GetNamespaceEntry (path, path.Length, false, caseSensitive);
+				if (tns == null) return;
+				
+				foreach (DictionaryEntry en in tns.Contents) {
+					if (en.Value is NamespaceEntry)
+						list.Add (en.Key);
+				}
+			}
+		}
+		
+		public bool NamespaceExists (string name, bool caseSensitive)
+		{
+			lock (rwlock)
+			{
+				string[] path = name.Split ('.');
+				NamespaceEntry tns = GetNamespaceEntry (path, path.Length, false, caseSensitive);
+				return tns != null;
+			}
+		}
+		
+		public ICollection References
+		{
+			get { return references; }
+		}
+		
+		IClass CopyClass (IClass cls)
+		{
+			MemoryStream ms = new MemoryStream ();
+			BinaryWriter bw = new BinaryWriter (ms);
+			PersistentClass.WriteTo (cls, bw, parserService.DefaultNameEncoder);
+			bw.Flush ();
+			ms.Position = 0;
+			BinaryReader br = new BinaryReader (ms);
+			return PersistentClass.Read (br, parserService.DefaultNameDecoder);
+		}
+		
+		NamespaceEntry GetNamespaceEntry (string[] path, int length, bool createPath, bool caseSensitive)
+		{
+			NamespaceEntry nst = rootNamespace;
+
+			if (length == 0 || (length == 1 &amp;&amp; path[0] == &quot;&quot;)) {
+				return nst;
+			}
+			else
+			{
+				for (int n=0; n&lt;length; n++) {
+					NamespaceEntry nh = nst.GetNamespace (path[n], caseSensitive);
+					if (nh == null) {
+						if (!createPath) return null;
+						nh = new NamespaceEntry ();
+						nst.Add (path[n], nh);
+					}
+					nst = nh;
+				}
+				return nst;
+			}
+		}
+	}
+	
+	internal class ProjectCodeCompletionDatabase: CodeCompletionDatabase
+	{
+		IProject project;
+		
+		public ProjectCodeCompletionDatabase (IProject project, DefaultParserService parserService)
+		: base (parserService)
+		{
+			SetLocation (project.BaseDirectory, project.Name);
+			
+			this.project = project;
+			Read ();
+			
+			UpdateFromProject ();
+		}
+		
+		public void UpdateFromProject ()
+		{
+			Hashtable fs = new Hashtable ();
+			foreach (ProjectFile file in project.ProjectFiles)
+			{
+				if (file.BuildAction != BuildAction.Compile) continue;
+				FileEntry fe = files[file.Name] as FileEntry;
+				if (fe == null) AddFile (file.Name);
+				fs [file.Name] = null;
+			}
+			
+			ArrayList keys = new ArrayList ();
+			keys.AddRange (files.Keys);
+			foreach (string file in keys)
+			{
+				if (!fs.Contains (file))
+					RemoveFile (file);
+			}
+			
+			fs.Clear ();
+			foreach (ProjectReference pr in project.ProjectReferences)
+			{
+				string refId = pr.ReferenceType + &quot;:&quot; + pr.Reference;
+				if (pr.ReferenceType == ReferenceType.Gac &amp;&amp; refId.ToLower().EndsWith (&quot;.dll&quot;))
+					refId = refId.Substring (0, refId.Length - 4);
+
+				fs[refId] = null;
+				bool found = false;
+				for (int n=0; n&lt;references.Count &amp;&amp; !found; n++) {
+					ReferenceEntry re = (ReferenceEntry) references[n];
+					found = ((ReferenceEntry) references[n]).Uri == refId;
+				}
+				if (!found)
+					AddReference (refId);
+			}
+			
+			keys.Clear();
+			keys.AddRange (references);
+			foreach (ReferenceEntry re in keys)
+			{
+				if (!fs.Contains (re.Uri))
+					RemoveReference (re.Uri);
+			}
+		}
+		
+		protected override void ParseFile (string fileName)
+		{
+			IParseInformation parserInfo = parserService.DoParseFile ((string)fileName, null);
+			ICompilationUnit cu = (ICompilationUnit)parserInfo.BestCompilationUnit;
+			ClassUpdateInformation res = UpdateClassInformation (cu.Classes, fileName);
+			parserService.NotifyParseInfoChange (fileName, res);
+		}
+	}
+	
+	internal class AssemblyCodeCompletionDatabase: CodeCompletionDatabase
+	{
+		bool useExternalProcess = true;
+		string baseDir;
+		string assemblyName;
+		
+		public AssemblyCodeCompletionDatabase (string baseDir, string assemblyName, DefaultParserService parserService)
+		: base (parserService)
+		{
+			string assemblyFile;
+			string name;
+			
+			this.assemblyName = assemblyName;
+			
+			if (assemblyName == &quot;mscorlib&quot;) {
+				name = assemblyName;
+				assemblyFile = typeof(object).Assembly.Location;
+			}
+			else if (assemblyName.ToLower().EndsWith (&quot;.dll&quot;)) {
+				name = assemblyName.Substring (0, assemblyName.Length - 4);
+				name = name.Replace(',','_').Replace(&quot; &quot;,&quot;&quot;).Replace('/','_');
+				assemblyFile = assemblyName;
+			}
+			else {
+				assemblyName = GetAssemblyFullName (assemblyName);
+				name = EncodeGacAssemblyName (assemblyName);
+				assemblyFile = GetGacAssemblyLocation (assemblyName);
+			}
+			
+			this.baseDir = baseDir;
+			SetLocation (baseDir, name);
+
+			Read ();
+			
+			if (files [assemblyFile] == null) {
+				AddFile (assemblyFile);
+				headers [&quot;CheckFile&quot;] = assemblyFile;
+			}
+		}
+		
+		string EncodeGacAssemblyName (string assemblyName)
+		{
+			string[] assemblyPieces = assemblyName.Split(',');
+			string res = &quot;&quot;;
+			foreach (string item in assemblyPieces) {
+				string[] pieces = item.Trim ().Split (new char[] { '=' }, 2);
+				if(pieces.Length == 1)
+					res += pieces[0];
+				else if (!(pieces[0] == &quot;Culture&quot; &amp;&amp; pieces[1] != &quot;Neutral&quot;))
+					res += &quot;_&quot; + pieces[1];
+			}
+			return res;
+		}
+		
+		string GetGacAssemblyLocation (string assemblyName)
+		{
+			Assembly asm;
+			try {
+				asm = Assembly.Load (assemblyName);
+			}
+			catch {
+				asm = Assembly.LoadWithPartialName (assemblyName);
+			}
+			
+			if (asm == null)
+				throw new InvalidOperationException (&quot;Could not find: &quot; + assemblyName);
+
+			return asm.Location;
+		}
+		
+		public string GetAssemblyFullName (string assemblyName)
+		{
+			if (assemblyName.IndexOf (',') == -1) return assemblyName;
+			Assembly asm = Assembly.LoadWithPartialName (assemblyName);
+			return asm.GetName().FullName;
+		}
+		
+		protected override void ParseFile (string fileName)
+		{
+			if (useExternalProcess)
+			{
+				string dbgen = Path.Combine (AppDomain.CurrentDomain.BaseDirectory, &quot;dbgen.exe&quot;);
+				Console.WriteLine (&quot;Starting &quot; + dbgen);
+				Process proc = Process.Start (&quot;mono &quot; + dbgen, &quot;\&quot;&quot; + baseDir + &quot;\&quot; \&quot;&quot; + assemblyName + &quot;\&quot;&quot;);
+				proc.WaitForExit ();
+				Console.WriteLine (&quot;Done &quot; + proc.ExitCode);
+				Read ();
+			}
+			else
+			{
+				Console.WriteLine (&quot;Parsing assembly: &quot; + fileName);
+				AssemblyInformation ainfo = new AssemblyInformation();
+				ainfo.Load (fileName, false);
+				UpdateClassInformation (ainfo.Classes, fileName);
+			}
+		}
+		
+		public bool ParseInExternalProcess
+		{
+			get { return useExternalProcess; }
+			set { useExternalProcess = value; }
+		}
+		
+		public static void CleanDatabase (string baseDir, string name)
+		{
+			// Read the headers of the file without fully loading the database
+			Hashtable headers = ReadHeaders (baseDir, name);
+			string checkFile = (string) headers [&quot;CheckFile&quot;];
+			if (!File.Exists (checkFile)) {
+				string dataFile = Path.Combine (baseDir, name + &quot;.pidb&quot;);
+				File.Delete (dataFile);
+				Console.WriteLine (&quot;File not exists: &quot; + checkFile);
+				Console.WriteLine (&quot;Deleted &quot; + dataFile);
+			}
+		}
+	}
+	
+
+	public interface INameEncoder
+	{
+		int GetStringId (string text);
+	}
+	
+	public interface INameDecoder
+	{
+		string GetStringValue (int id);
+	}
+	
+	
+	public class StringNameTable: INameEncoder, INameDecoder
+	{
+		string[] table;
+		
+		public StringNameTable (string[] names)
+		{
+			table = names;
+			Array.Sort (table);
+		}
+		
+		public string GetStringValue (int id)
+		{
+			return table [id];
+		}
+		
+		public int GetStringId (string text)
+		{
+			int i = Array.BinarySearch (table, text);
+			if (i &gt;= 0) return i;
+			else return -1;
+		}
+	}
+	
+	[Serializable]
+	class NamespaceEntry
+	{
+		Hashtable contents = new Hashtable ();
+		
+		// This is the case insensitive version of the hashtable.
+		// It is constructed only when needed.
+		[NonSerialized] Hashtable contents_ci;
+		
+		// All methods with the caseSensitive parameter, first check for an
+		// exact match, and if not found, they try with the case insensitive table.
+		
+		public NamespaceEntry GetNamespace (string ns, bool caseSensitive)
+		{
+			NamespaceEntry ne = contents[ns] as NamespaceEntry;
+			if (ne != null || caseSensitive) return ne;
+			
+			if (contents_ci == null) BuildCaseInsensitiveTable ();
+			return contents_ci[ns] as NamespaceEntry;
+		}
+		
+		public ClassEntry GetClass (string name, bool caseSensitive)
+		{
+			ClassEntry ne = contents[name] as ClassEntry;
+			if (ne != null || caseSensitive) return ne;
+			
+			if (contents_ci == null) BuildCaseInsensitiveTable ();
+			return contents_ci[name] as ClassEntry;
+		}
+		
+		public void Add (string name, object value)
+		{
+			contents [name] = value;
+			if (contents_ci != null)
+				contents_ci [name] = value;
+		}
+		
+		public void Remove (string name)
+		{
+			contents.Remove (name);
+			contents_ci = null;
+		}
+		
+		public ICollection Contents
+		{
+			get { return contents; }
+		}
+		
+		public int ContentCount
+		{
+			get { return contents.Count; }
+		}
+		
+		public void Clean ()
+		{
+			ArrayList todel = new ArrayList ();
+			foreach (DictionaryEntry en in contents)
+			{
+				NamespaceEntry h = en.Value as NamespaceEntry;
+				if (h != null) {
+					h.Clean ();
+					if (h.ContentCount == 0) todel.Add (en.Key);
+				}
+			}
+			
+			if (todel.Count &gt; 0)
+			{
+				contents_ci = null;
+				foreach (string key in todel)
+					contents.Remove (key);
+			}
+		}
+		
+		void BuildCaseInsensitiveTable ()
+		{
+			contents_ci = new Hashtable (CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);
+			foreach (DictionaryEntry en in contents)
+				contents_ci.Add (en.Key, en.Value);
+		}
+	}
+
+	[Serializable]
+	class ClassEntry
+	{
+		long position;
+		NamespaceEntry namespaceRef;
+		string name;
+		FileEntry fileEntry;
+		ClassEntry nextInFile;
+		
+		[NonSerialized]
+		int lastGetTime;
+		
+		[NonSerialized]
+		public IClass cls;
+		
+		public ClassEntry (IClass cls, FileEntry fileEntry, NamespaceEntry namespaceRef)
+		{
+			this.cls = cls;
+			this.fileEntry = fileEntry;
+			this.namespaceRef = namespaceRef;
+			this.name = cls.Name;
+			position = -1;
+		}
+		
+		public long Position
+		{
+			get { return position; }
+			set { position = value; }
+		}
+		
+		public IClass Class
+		{
+			get { 
+				return cls; 
+			}
+			set {
+				cls = value; 
+				if (cls != null) {
+					name = cls.Name; 
+					position = -1; 
+				}
+			}
+		}
+		
+		public string Name
+		{
+			get { return name; }
+		}
+		
+		public NamespaceEntry NamespaceRef
+		{
+			get { return namespaceRef; }
+		}
+		
+		public FileEntry FileEntry
+		{
+			get { return fileEntry; }
+			set { fileEntry = value; }
+		}
+		
+		public int LastGetTime
+		{
+			get { return lastGetTime; }
+			set { lastGetTime = value; }
+		}
+		
+		public ClassEntry NextInFile
+		{
+			get { return nextInFile; }
+			set { nextInFile = value; }
+		}
+	}
+	
+	[Serializable]
+	class FileEntry
+	{
+		string filePath;
+		DateTime parseTime;
+		ClassEntry firstClass;
+		
+		public FileEntry (string path)
+		{
+			filePath = path;
+			parseTime = DateTime.MinValue;
+		}
+		
+		public string FileName
+		{
+			get { return filePath; }
+		}
+		
+		public DateTime LastParseTime
+		{
+			get { return parseTime; }
+			set { parseTime = value; }
+		}
+		
+		public ClassEntry FirstClass
+		{
+			get { return firstClass; }
+		}
+		
+		public void SetClasses (ArrayList list)
+		{
+			firstClass = null;
+			foreach (ClassEntry ce in list)
+				AddClass (ce);
+		}
+		
+		public void AddClass (ClassEntry ce)
+		{
+			if (ce.FileEntry != null)
+				ce.FileEntry.RemoveClass (ce);
+				
+			ce.NextInFile = firstClass;
+			firstClass = ce;
+		}
+		
+		public void RemoveClass (ClassEntry ce)
+		{
+			ClassEntry oldent = null;
+			ClassEntry curent = firstClass;
+			
+			while (curent != null &amp;&amp; curent != ce) {
+				oldent = curent;
+				curent = curent.NextInFile;
+			}
+			
+			if (curent == null) 
+				return;
+			else if (oldent == null)
+				firstClass = curent.NextInFile;
+			else
+				oldent.NextInFile = curent.NextInFile;
+				
+			ce.FileEntry = null;
+		}
+		
+		public bool IsAssembly
+		{
+			get { return filePath.ToLower().EndsWith (&quot;.dll&quot;); }
+		}
+	}
+	
+	[Serializable]
+	class ReferenceEntry
+	{
+		string databaseUri;
+		
+		public ReferenceEntry (string dbUri)
+		{
+			databaseUri = dbUri;
+		}
+		
+		public string Uri
+		{
+			get { return databaseUri; }
+		}
+	}
+}

Modified: trunk/MonoDevelop/src/Main/Base/Services/ParserService/DefaultParserService.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/ParserService/DefaultParserService.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Services/ParserService/DefaultParserService.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -32,54 +32,52 @@
 {
 	public class DefaultParserService : AbstractService, IParserService
 	{
-		Hashtable classes                = new Hashtable();
-		Hashtable caseInsensitiveClasses = new Hashtable();
+		CodeCompletionDatabase coreDatabase;
 		
-		// used to map 'real' namespace hashtable inside case insensitive hashtable
-		const string CaseInsensitiveKey = &quot;__CASE_INSENSITIVE_HASH&quot;;
-		Hashtable namespaces                = new Hashtable();
-		Hashtable caseInsensitiveNamespaces = new Hashtable();
+		const int MAX_CACHE_SIZE = 10;
+		const string CoreDB = &quot;Assembly:mscorlib&quot;;
+
+		class ParsingCacheEntry
+		{
+			   public ParseInformation ParseInformation;
+			   public string FileName;
+			   public DateTime AccessTime;
+		}
 		
-		Hashtable parsings   = new Hashtable();
+		class ParsingJob
+		{
+			public object Data;
+			public WaitCallback ParseCallback;
+		}
+
+		Hashtable lastUpdateSize = new Hashtable();
+		Hashtable parsings = new Hashtable ();
 		
 		ParseInformation addedParseInformation = new ParseInformation();
 		ParseInformation removedParseInformation = new ParseInformation();
+		CombineEntryEventHandler combineEntryAddedHandler;
+		CombineEntryEventHandler combineEntryRemovedHandler;
 
-//// Alex: this one keeps requests for parsing and is used to start parser (pulsed)
-//// otherwise continuous reparsing of files is causing leaks
-//		public static Queue ParserPulse=new Queue();	// required for monitoring when to restart thread
-//// Alex: end of mod
+		public static Queue parseQueue = new Queue();
+		
+		string codeCompletionPath;
 
-		/// &lt;remarks&gt;
-		/// The keys are the assemblies loaded. This hash table ensures that no
-		/// assembly is loaded twice. I know that strong naming might be better but
-		/// the use case isn't there. No one references 2 differnt files if he references
-		/// the same assembly.
-		/// &lt;/remarks&gt;
-		Hashtable loadedAssemblies = new Hashtable();
+		Hashtable databases = new Hashtable();
 		
-		ClassProxyCollection classProxies = new ClassProxyCollection();
 		IParser[] parser;
+		
 		readonly static string[] assemblyList = {
 			&quot;Microsoft.VisualBasic&quot;,
-			//&quot;Microsoft.JScript&quot;,
 			&quot;mscorlib&quot;,
 			&quot;System.Data&quot;,
 			&quot;System.Design&quot;,
-			&quot;System.DirectoryServices&quot;,
 			&quot;System.Drawing.Design&quot;,
 			&quot;System.Drawing&quot;,
-			&quot;System.EnterpriseServices&quot;,
-			&quot;System.Management&quot;,
-			&quot;System.Messaging&quot;,
 			&quot;System.Runtime.Remoting&quot;,
-			&quot;System.Runtime.Serialization.Formatters.Soap&quot;,
-
 			&quot;System.Security&quot;,
 			&quot;System.ServiceProcess&quot;,
 			&quot;System.Web.Services&quot;,
 			&quot;System.Web&quot;,
-			//&quot;System.Windows.Forms&quot;,
 			&quot;System&quot;,
 			&quot;System.Xml&quot;,
 			&quot;glib-sharp&quot;,
@@ -90,48 +88,50 @@
 			&quot;gnome-sharp&quot;,
 			&quot;gconf-sharp&quot;,
 			&quot;gtkhtml-sharp&quot;,
+			//&quot;System.Windows.Forms&quot;,
+			//&quot;Microsoft.JScript&quot;,
 		};
 		
+		StringNameTable nameTable;
+		
+		string[] sharedNameTable = new string[] {
+			&quot;System.String&quot;, &quot;System.Boolean&quot;, &quot;System.Int32&quot;, &quot;System.Attribute&quot;,
+			&quot;System.Delegate&quot;, &quot;System.Enum&quot;, &quot;System.Exception&quot;, &quot;System.MarshalByRefObject&quot;,
+			&quot;System.Object&quot;, &quot;SerializableAttribtue&quot;, &quot;System.Type&quot;, &quot;System.ValueType&quot;,
+			&quot;System.ICloneable&quot;, &quot;System.IDisposable&quot;, &quot;System.IConvertible&quot;, &quot;System.Byte&quot;,
+			&quot;System.Char&quot;, &quot;System.DateTime&quot;, &quot;System.Decimal&quot;, &quot;System.Double&quot;, &quot;System.Int16&quot;,
+			&quot;System.Int64&quot;, &quot;System.IntPtr&quot;, &quot;System.SByte&quot;, &quot;System.Single&quot;, &quot;System.TimeSpan&quot;,
+			&quot;System.UInt16&quot;, &quot;System.UInt32&quot;, &quot;System.UInt64&quot;, &quot;System.Void&quot;
+		};
+		
 		public DefaultParserService()
 		{
 			addedParseInformation.DirtyCompilationUnit = new DummyCompilationUnit();
 			removedParseInformation.DirtyCompilationUnit = new DummyCompilationUnit();
+			combineEntryAddedHandler = new CombineEntryEventHandler (OnCombineEntryAdded);
+			combineEntryRemovedHandler = new CombineEntryEventHandler (OnCombineEntryRemoved);
+			nameTable = new StringNameTable (sharedNameTable);
 		}
 		
-		public static string[] AssemblyList {
-			get {
-				return assemblyList;
-			}
-		}
-		
 		public string LoadAssemblyFromGac (string name) {
 			MethodInfo gac_get = typeof (System.Environment).GetMethod (&quot;internalGetGacPath&quot;, BindingFlags.Static|BindingFlags.NonPublic);
 			
-			if (gac_get == null)
-				return String.Empty;
-			
-			string use_name = name;
-			string asmb_path;
-			string [] canidates;
-
 			if (name == &quot;mscorlib&quot;)
-				return Path.Combine ((string) gac_get.Invoke (null, null), name + &quot;.dll&quot;);
-            
-			if (name.EndsWith (&quot;.dll&quot;))
-				use_name = name.Substring (0, name.Length - 4);
+				return typeof(object).Assembly.Location;
+				
+			Assembly asm;
+			try {
+				asm = Assembly.Load (name);
+			}
+			catch {
+				asm = Assembly.LoadWithPartialName (name);
+			}
+			if (asm == null) {
+				Console.WriteLine (&quot;Could not find: &quot; + name);
+				return string.Empty;
+			}
 			
-			asmb_path = Path.Combine (Path.Combine (Path.Combine ((string) gac_get.Invoke (null, null), &quot;mono&quot;), &quot;gac&quot;), use_name);
-            
-			if (!Directory.Exists (asmb_path))
-				return String.Empty;
-			
-			canidates = Directory.GetDirectories (asmb_path, GetSysVersion () + &quot;*&quot;);
-			if (canidates.Length == 0)
-				canidates = Directory.GetDirectories (asmb_path);
-			if (canidates.Length == 0)
-				return String.Empty;
-			
-			return Path.Combine (canidates [0], use_name + &quot;.dll&quot;);
+			return asm.Location;
 		}
 		
 		string sys_version;
@@ -142,49 +142,12 @@
 			return sys_version;
 		}
 		
-		/// &lt;remarks&gt;
-		/// The initialize method writes the location of the code completion proxy
-		/// file to this string.
-		/// &lt;/remarks&gt;
-		string codeCompletionProxyFile;
-		string codeCompletionMainFile;
 
-		class ClasstableEntry
-		{
-			IClass           myClass;
-			ICompilationUnit myCompilationUnit;
-			string           myFileName;
-
-			public IClass Class {
-				get {
-					return myClass;
-				}
-			}
-
-			public ICompilationUnit CompilationUnit {
-				get {
-					return myCompilationUnit;
-				}
-			}
-
-			public string FileName {
-				get {
-					return myFileName;
-				}
-			}
-
-			public ClasstableEntry(string fileName, ICompilationUnit compilationUnit, IClass c)
-			{
-				this.myCompilationUnit = compilationUnit;
-				this.myFileName        = fileName;
-				this.myClass           = c;
-			}
-		}
-
 		private bool ContinueWithProcess(IProgressMonitor progressMonitor)
 		{
 			while (Gtk.Application.EventsPending ())
 				Gtk.Application.RunIteration ();
+
 			if (progressMonitor.Canceled)
 				return false;
 			else
@@ -193,172 +156,275 @@
 	
 		public void GenerateCodeCompletionDatabase(string createPath, IProgressMonitor progressMonitor)
 		{
-			SetCodeCompletionFileLocation(createPath);
+			if (progressMonitor != null)
+				progressMonitor.BeginTask(GettextCatalog.GetString (&quot;Generate code completion database&quot;), assemblyList.Length);
 
-			// write all classes and proxies to the disc
-			BinaryWriter classWriter = new BinaryWriter(new BufferedStream(new FileStream(codeCompletionMainFile, FileMode.Create, FileAccess.Write, FileShare.None)));
-			BinaryWriter proxyWriter = new BinaryWriter(new BufferedStream(new FileStream(codeCompletionProxyFile, FileMode.Create, FileAccess.Write, FileShare.None)));
-			if (progressMonitor != null) {
-				progressMonitor.BeginTask(GettextCatalog.GetString (&quot;Generate code completion database&quot;), assemblyList.Length);
-			}
-			
-			// convert all assemblies
-			for (int i = 0; i &lt; assemblyList.Length; ++i) {
+			for (int i = 0; i &lt; assemblyList.Length; ++i)
+			{
 				try {
-					//FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-					//string path = fileUtilityService.GetDirectoryNameWithSeparator(System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory());
+					AssemblyCodeCompletionDatabase db = new AssemblyCodeCompletionDatabase (codeCompletionPath, assemblyList[i], this);
+					db.ParseAll ();
+					db.Write ();
 					
-					AssemblyInformation frameworkAssemblyInformation = new AssemblyInformation();
-					frameworkAssemblyInformation.Load(LoadAssemblyFromGac (assemblyList[i]), false);
-					// create all class proxies
-					foreach (IClass newClass in frameworkAssemblyInformation.Classes) {
-						ClassProxy newProxy = new ClassProxy(newClass);
-						classProxies.Add(newProxy);
-						AddClassToNamespaceList(newProxy);
-
-						PersistentClass pc = new PersistentClass(classProxies, newClass);
-						newProxy.Offset = (uint)classWriter.BaseStream.Position;
-						newProxy.WriteTo(proxyWriter);
-						pc.WriteTo(classWriter);
-					}
-					
-					if (progressMonitor != null) {
+					if (progressMonitor != null)
 						progressMonitor.Worked(i, GettextCatalog.GetString (&quot;Writing class&quot;));
-					}
-					if (!ContinueWithProcess(progressMonitor))
+						
+					if (!ContinueWithProcess (progressMonitor))
 						return;
-				} catch (Exception e) {
-					Console.WriteLine(e.ToString());
 				}
-				System.GC.Collect();
+				catch (Exception ex) {
+					Console.WriteLine (ex);
+				}
 			}
 
-			classWriter.Close();
-			proxyWriter.Close();
 			if (progressMonitor != null) {
 				progressMonitor.Done();
 			}
 		}
 		
-		void SetCodeCompletionFileLocation(string path)
+		public void GenerateAssemblyDatabase (string baseDir, string name)
 		{
-			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-			string codeCompletionTemp = fileUtilityService.GetDirectoryNameWithSeparator(path);
-
-			codeCompletionProxyFile = codeCompletionTemp + &quot;CodeCompletionProxyDataV02.bin&quot;;
-			codeCompletionMainFile  = codeCompletionTemp + &quot;CodeCompletionMainDataV02.bin&quot;;
+			AssemblyCodeCompletionDatabase db = GetDatabase (baseDir, &quot;Assembly:&quot; + name) as AssemblyCodeCompletionDatabase;
+			db.ParseInExternalProcess = false;
+			db.ParseAll ();
+			db.Write ();
 		}
-
+		
 		void SetDefaultCompletionFileLocation()
 		{
 			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
-			SetCodeCompletionFileLocation(propertyService.GetProperty(&quot;SharpDevelop.CodeCompletion.DataDirectory&quot;, String.Empty).ToString());
+			string path = (propertyService.GetProperty(&quot;SharpDevelop.CodeCompletion.DataDirectory&quot;, String.Empty).ToString());
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+			codeCompletionPath = fileUtilityService.GetDirectoryNameWithSeparator(path);
 		}
 
-		public void LoadProxyDataFile()
+		public override void InitializeService()
 		{
-			if (!File.Exists(codeCompletionProxyFile)) {
-				return;
+			parser = (IParser[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/Workspace/Parser&quot;).BuildChildItems(this)).ToArray(typeof(IParser));
+			
+			SetDefaultCompletionFileLocation();
+			DeleteObsoleteDatabases ();
+
+			coreDatabase = new AssemblyCodeCompletionDatabase (codeCompletionPath, &quot;mscorlib&quot;, this);
+			databases [CoreDB] = coreDatabase;
+			
+			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			projectService.CombineOpened += new CombineEventHandler(OnCombineOpened);
+			projectService.CombineClosed += new CombineEventHandler(OnCombineClosed);
+			projectService.FileRemovedFromProject += new ProjectFileEventHandler (OnProjectFilesChanged);
+			projectService.FileAddedToProject += new ProjectFileEventHandler (OnProjectFilesChanged);
+			projectService.ReferenceAddedToProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
+			projectService.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
+			projectService.ProjectRenamed += new ProjectRenameEventHandler(OnProjectRenamed);
+		}
+		
+		internal CodeCompletionDatabase GetDatabase (string uri)
+		{
+			return GetDatabase (null, uri);
+		}
+		
+		internal ProjectCodeCompletionDatabase GetProjectDatabase (IProject project)
+		{
+			if (project == null) return null;
+			return (ProjectCodeCompletionDatabase) GetDatabase (null, &quot;Project:&quot; + project.Name);
+		}
+		
+		internal CodeCompletionDatabase GetDatabase (string baseDir, string uri)
+		{
+			lock (databases)
+			{
+				if (baseDir == null) baseDir = codeCompletionPath;
+				CodeCompletionDatabase db = (CodeCompletionDatabase) databases [uri];
+				if (db == null) 
+				{
+					// Create/load the database
+						
+					if (uri.StartsWith (&quot;Assembly:&quot;))
+					{
+						string file = uri.Substring (9);
+						db = new AssemblyCodeCompletionDatabase (baseDir, file, this);
+					}
+					else if (uri.StartsWith (&quot;Gac:&quot;))
+					{
+						string file = uri.Substring (4);
+						db = new AssemblyCodeCompletionDatabase (baseDir, file, this);
+					}
+					if (db != null)
+						databases [uri] = db;
+				}
+				return db;
 			}
-			BinaryReader reader = new BinaryReader(new BufferedStream(new FileStream(codeCompletionProxyFile, FileMode.Open, FileAccess.Read, FileShare.Read)));
-			while (true) {
-				try {
-					ClassProxy newProxy = new ClassProxy(reader);
-					classProxies.Add(newProxy);
-					AddClassToNamespaceList(newProxy);
-				} catch (Exception) {
-					break;
+		}
+		
+		void LoadProjectDatabase (IProject project)
+		{
+			lock (databases)
+			{
+				string uri = &quot;Project:&quot; + project.Name;
+				if (databases.Contains (uri)) return;
+				
+				ProjectCodeCompletionDatabase db = new ProjectCodeCompletionDatabase (project, this);
+				databases [uri] = db;
+				
+				foreach (ReferenceEntry re in db.References)
+				{
+					GetDatabase (re.Uri);
 				}
 			}
-			reader.Close();
 		}
 		
-		void LoadThread()
+		void UnloadDatabase (string uri)
 		{
-			SetDefaultCompletionFileLocation();
-			
-			BinaryFormatter formatter = new BinaryFormatter();
-			
-			if (File.Exists(codeCompletionProxyFile)) {
-				LoadProxyDataFile();
+			if (uri == CoreDB) return;
+			lock (databases)
+			{
+				CodeCompletionDatabase db = databases [uri] as CodeCompletionDatabase;
+				if (db != null) {
+					db.Write ();
+					databases.Remove (uri);
+				}
 			}
 		}
 		
-		public override void InitializeService()
+		void UnloadProjectDatabase (IProject project)
 		{
-			parser = (IParser[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/Workspace/Parser&quot;).BuildChildItems(this)).ToArray(typeof(IParser));
-			
-			Thread myThread = new Thread(new ThreadStart(LoadThread));
-			myThread.IsBackground = true;
-			myThread.Priority = ThreadPriority.Lowest;
-			myThread.Start();
-			
-			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
-			projectService.CombineOpened += new CombineEventHandler(OpenCombine);
+			string uri = &quot;Project:&quot; + project.Name;
+			UnloadDatabase (uri);
 		}
 		
-		public void AddReferenceToCompletionLookup(IProject project, ProjectReference reference)
+		void CleanUnusedDatabases ()
 		{
-			if (reference.ReferenceType != ReferenceType.Project) {
-				string fileName = reference.GetReferencedFileName(project);
-				if (fileName == null || fileName.Length == 0) {
-					return;
-				}
-				foreach (string assemblyName in assemblyList) {
-					if (Path.GetFileNameWithoutExtension(fileName).ToUpper() == assemblyName.ToUpper()) {
-						return;
+			lock (databases)
+			{
+				Hashtable references = new Hashtable ();
+				foreach (CodeCompletionDatabase db in databases.Values)
+				{
+					if (db is ProjectCodeCompletionDatabase) {
+						foreach (ReferenceEntry re in ((ProjectCodeCompletionDatabase)db).References)
+							references [re.Uri] = null;
 					}
 				}
-				// HACK : Don't load references for non C# projects
-				if (project.ProjectType != &quot;C#&quot;) {
-					return;
+				
+				ArrayList todel = new ArrayList ();
+				foreach (DictionaryEntry en in databases)
+				{
+					if (!(en.Value is ProjectCodeCompletionDatabase) &amp;&amp; !references.Contains (en.Key))
+						todel.Add (en.Key);
 				}
-				if (File.Exists(fileName)) {
-					Thread t = new Thread(new ThreadStart(new AssemblyLoader(this, fileName).LoadAssemblyParseInformations));
-					t.Start();
+				
+				foreach (string uri in todel)
+					UnloadDatabase (uri);
+			}
+		}
+		
+		public void LoadCombineDatabases (Combine combine)
+		{
+			ArrayList projects = Combine.GetAllProjects(combine);
+			foreach (ProjectCombineEntry entry in projects) {
+				LoadProjectDatabase (entry.Project);
+			}
+		}
+		
+		public void UnloadCombineDatabases (Combine combine)
+		{
+			ArrayList projects = Combine.GetAllProjects(combine);
+			foreach (ProjectCombineEntry entry in projects) {
+				UnloadProjectDatabase (entry.Project);
+			}
+		}
+		
+		public void OnCombineOpened(object sender, CombineEventArgs e)
+		{
+			LoadCombineDatabases (e.Combine);
+			e.Combine.EntryAdded += combineEntryAddedHandler;
+			e.Combine.EntryRemoved += combineEntryRemovedHandler;
+		}
+		
+		public void OnCombineClosed (object sender, CombineEventArgs e)
+		{
+			UnloadCombineDatabases (e.Combine);
+			CleanUnusedDatabases ();
+			e.Combine.EntryAdded -= combineEntryAddedHandler;
+			e.Combine.EntryRemoved -= combineEntryRemovedHandler;
+		}
+		
+		void OnProjectRenamed (object sender, ProjectRenameEventArgs args)
+		{
+			ProjectCodeCompletionDatabase db = GetProjectDatabase (args.Project);
+			if (db == null) return;
+			
+			db.Rename (args.NewName);
+			databases.Remove (&quot;Project:&quot; + args.OldName);
+			databases [&quot;Project:&quot; + args.NewName] = db;
+			RefreshProjectDatabases ();
+			CleanUnusedDatabases ();
+		}
+		
+		void OnCombineEntryAdded (object sender, CombineEntryEventArgs args)
+		{
+			if (args.CombineEntry is ProjectCombineEntry)
+				LoadProjectDatabase (((ProjectCombineEntry)args.CombineEntry).Project);
+			else if (args.CombineEntry is CombineCombineEntry)
+				LoadCombineDatabases (((CombineCombineEntry)args.CombineEntry).Combine);
+		}
+		
+		void OnCombineEntryRemoved (object sender, CombineEntryEventArgs args)
+		{
+			if (args.CombineEntry is ProjectCombineEntry)
+				UnloadProjectDatabase (((ProjectCombineEntry)args.CombineEntry).Project);
+			else if (args.CombineEntry is CombineCombineEntry)
+				UnloadCombineDatabases (((CombineCombineEntry)args.CombineEntry).Combine);
+			CleanUnusedDatabases ();
+		}
+		
+		void OnProjectFilesChanged (object sender, ProjectFileEventArgs args)
+		{
+			ProjectCodeCompletionDatabase db = GetProjectDatabase (args.Project);
+			if (db != null) db.UpdateFromProject ();
+		}
+		
+		void OnProjectReferencesChanged (object sender, ProjectReferenceEventArgs args)
+		{
+			ProjectCodeCompletionDatabase db = GetProjectDatabase (args.Project);
+			if (db != null) {
+				db.UpdateFromProject ();
+				foreach (ReferenceEntry re in db.References)
+				{
+					// Make sure the db is loaded
+					GetDatabase (re.Uri);
 				}
 			}
 		}
 		
-		class AssemblyLoader
+		void RefreshProjectDatabases ()
 		{
-			DefaultParserService parserService;
-			string assemblyFileName;
-			
-			public AssemblyLoader(DefaultParserService parserService, string assemblyFileName)
+			foreach (CodeCompletionDatabase db in databases.Values)
 			{
-				this.parserService    = parserService;
-				this.assemblyFileName = assemblyFileName;
+				ProjectCodeCompletionDatabase pdb = db as ProjectCodeCompletionDatabase;
+				if (pdb != null)
+					pdb.UpdateFromProject ();
 			}
-			
-			public void LoadAssemblyParseInformations()
+		}
+		
+		internal void QueueParseJob (WaitCallback callback, object data)
+		{
+			ParsingJob job = new ParsingJob ();
+			job.ParseCallback = callback;
+			job.Data = data;
+			lock (parseQueue)
 			{
-				if (parserService.loadedAssemblies[assemblyFileName] != null) {
-					return;
-				}
-				parserService.loadedAssemblies[assemblyFileName] = true;
-				try {
-					AssemblyInformation assemblyInformation = new AssemblyInformation();
-					assemblyInformation.Load(assemblyFileName, true);
-					foreach (IClass newClass in assemblyInformation.Classes) {
-						parserService.AddClassToNamespaceList(newClass);
-						lock (parserService.classes) {
-							parserService.caseInsensitiveClasses[newClass.FullyQualifiedName.ToLower()] = parserService.classes[newClass.FullyQualifiedName] = new ClasstableEntry(null, null, newClass);
-						}
-					}
-				} catch (Exception e) {
-					Console.WriteLine(&quot;Can't add reference : &quot; + e.ToString());
-				}
+				parseQueue.Enqueue (job);
 			}
 		}
 		
-		public void OpenCombine(object sender, CombineEventArgs e)
+		void DeleteObsoleteDatabases ()
 		{
-			ArrayList projects =  Combine.GetAllProjects(e.Combine);
-			foreach (ProjectCombineEntry entry in projects) {
-				foreach (ProjectReference r in entry.Project.ProjectReferences) {
-					AddReferenceToCompletionLookup(entry.Project, r);
-				}
+			string[] files = Directory.GetFiles (codeCompletionPath, &quot;*.pidb&quot;);
+			foreach (string file in files)
+			{
+				string name = Path.GetFileNameWithoutExtension (file);
+				string baseDir = Path.GetDirectoryName (file);
+				AssemblyCodeCompletionDatabase.CleanDatabase (baseDir, name);
 			}
 		}
 		
@@ -369,252 +435,329 @@
 			t.Start();
 		}
 		
-		Hashtable lastUpdateSize = new Hashtable();
+		
 		void ParserUpdateThread()
 		{
-// 			string fn=null;
-			while (true) {
-				////Thread.Sleep(1000); // not required
-//// Alex: if some file was pulsed - during editor load and after - get file to reparse
-//				fn = null; // set to null for each repetition
-// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-//	Mike: Doesn't work with folding marker update --&gt; look at the folding markers
-//  Mike: You can't simply BREAK a feature and say I should fix it ... either bring the folding
-//        markers in a working state or leave this change ... I don't see that your change is a good
-//        alternative ... the current parserthread looks at the text and if it changed it reparses ...
-//        it is better than the old version you fixed 
-// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-//				lock(DefaultParserService.ParserPulse) {
-//					//Console.WriteLine(&quot;Pulse got: {0} entries&quot;,DefaultParserService.ParserPulse.Count);
-//					Monitor.Wait(DefaultParserService.ParserPulse);
-//					if (DefaultParserService.ParserPulse.Count&gt;0) {
-//						fn = (string)DefaultParserService.ParserPulse.Dequeue();
-//					}
-//				}
-				try {
-					if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null &amp;&amp; WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ActiveViewContent != null) {
-						IEditable editable = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ActiveViewContent as IEditable;
-						if (editable != null) {
-							string fileName = null;
-							
-							IViewContent viewContent = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent;
-							IParseableContent parseableContent = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ActiveViewContent as IParseableContent;
-							
-							if (parseableContent != null) {
-								fileName = parseableContent.ParseableContentName;
-							} else {
-								fileName = viewContent.IsUntitled ? viewContent.UntitledName : viewContent.ContentName;
-							}
-							
-							if (!(fileName == null || fileName.Length == 0)) {
-//								Thread.Sleep(300); // not required 
-								IParseInformation parseInformation = null;
-								bool updated = false;
-								lock (parsings) {
-									string text = editable.Text;
-									if (text != null) {
-									
-										if (lastUpdateSize[fileName] == null || (int)lastUpdateSize[fileName] != text.GetHashCode()) {
-											parseInformation = ParseFile(fileName, text);
-											lastUpdateSize[fileName] = text.GetHashCode();
-											updated = true;
-										}
-									} 
-								}
-								if (updated) {
-									if (parseInformation != null &amp;&amp; editable is IParseInformationListener) {
-										((IParseInformationListener)editable).ParseInformationUpdated(parseInformation);
-									}
-								}
-//								if (fn != null) {
-//									ParseFile(fn); // TODO: this one should update file parsings requested through queue
-//								}
-							}
-						}
-					}
-				} catch (Exception e) {
-					try {
-						Console.WriteLine(e.ToString());
-					} catch {}
-				}
-				Thread.Sleep(500); // not required
-				//System.GC.Collect();
+			int loop = 0;
+			while (true)
+			{
+				Thread.Sleep(500);
+				
+				ParseCurrentFile ();
+				
+				ConsumeParsingQueue ();
+				
+				if (loop % 10 == 0)
+					CheckModifiedFiles ();
+				
+				loop++;
 			}
 		}
 		
-		Hashtable AddClassToNamespaceList(IClass addClass)
+		void CheckModifiedFiles ()
 		{
-			if (addClass.Name == null) {
-				Console.WriteLine (addClass.FullyQualifiedName);
-				return null;
+			ArrayList list = new ArrayList ();
+			lock (databases) {
+				list.AddRange (databases.Values);
 			}
-
-			string nSpace = addClass.Namespace;
-			if (nSpace == null) {
-				nSpace = String.Empty;
-			}
 			
-			string[] path = nSpace.Split('.');
-			
-			lock (namespaces) {
-				Hashtable cur                = namespaces;
-				Hashtable caseInsensitiveCur = caseInsensitiveNamespaces;
+			foreach (CodeCompletionDatabase db in list) 
+				if (!(db is AssemblyCodeCompletionDatabase))
+					db.CheckModifiedFiles ();
+		}
+		
+		void ConsumeParsingQueue ()
+		{
+			int pending;
+			do {
+				ParsingJob job = null;
+				lock (parseQueue)
+				{
+					if (parseQueue.Count &gt; 0)
+						job = (ParsingJob) parseQueue.Dequeue ();
+				}
 				
-				for (int i = 0; i &lt; path.Length; ++i) {
-					if (cur[path[i]] == null) {
-						Hashtable hashTable                = new Hashtable();
-						Hashtable caseInsensitivehashTable = new Hashtable();
-						cur[path[i]] = hashTable;
-						caseInsensitiveCur[path[i].ToLower()] = caseInsensitivehashTable;
-						caseInsensitivehashTable[CaseInsensitiveKey] = hashTable;
-					} else {
-						if (!(cur[path[i]] is Hashtable)) {
-							return null;
+				if (job != null)
+					job.ParseCallback (job.Data);
+				
+				lock (parseQueue)
+					pending = parseQueue.Count;
+				
+			}
+			while (pending &gt; 0);
+		}
+		
+		
+		void ParseCurrentFile()
+		{
+			try {
+				IWorkbenchWindow win = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+				if (win == null || win.ActiveViewContent == null) return;
+				
+				IEditable editable = win.ActiveViewContent as IEditable;
+				if (editable == null) return;
+				
+				string fileName = null;
+				
+				IViewContent viewContent = win.ViewContent;
+				IParseableContent parseableContent = win.ActiveViewContent as IParseableContent;
+				
+				if (parseableContent != null) {
+					fileName = parseableContent.ParseableContentName;
+				} else {
+					fileName = viewContent.IsUntitled ? viewContent.UntitledName : viewContent.ContentName;
+				}
+				
+				if (fileName == null || fileName.Length == 0) return;
+				
+				string text = editable.Text;
+				if (text == null) return;
+					
+				IParseInformation parseInformation = null;
+				bool updated = false;
+				lock (parsings) {
+				
+					if (lastUpdateSize[fileName] == null || (int)lastUpdateSize[fileName] != text.GetHashCode()) {
+						parseInformation = DoParseFile(fileName, text);
+						if (parseInformation == null) return;
+						
+						ProjectCodeCompletionDatabase db = GetProjectDatabase (viewContent.Project);
+						if (db != null) {
+							ICompilationUnit cu = (ICompilationUnit)parseInformation.BestCompilationUnit;
+							ClassUpdateInformation res = db.UpdateClassInformation (cu.Classes, fileName);
+							NotifyParseInfoChange (fileName, res);
 						}
+						lastUpdateSize[fileName] = text.GetHashCode();
+						updated = true;
 					}
-					cur = (Hashtable)cur[path[i]];
-					caseInsensitiveCur = (Hashtable)caseInsensitiveCur[path[i].ToLower()];
 				}
-				caseInsensitiveCur[addClass.Name.ToLower()] = cur[addClass.Name] = addClass;
-				return cur;
+				if (updated &amp;&amp; parseInformation != null &amp;&amp; editable is IParseInformationListener) {
+					((IParseInformationListener)editable).ParseInformationUpdated(parseInformation);
+				}
+			} catch (Exception e) {
+				try {
+					Console.WriteLine(e.ToString());
+				} catch {}
 			}
 		}
 		
+		
 #region Default Parser Layer dependent functions
-		public IClass GetClass(string typeName)
+
+		public IClass GetClass (IProject project, string typeName)
 		{
-			return GetClass(typeName, true);
+			return GetClass(project, typeName, true);
 		}
-		public IClass GetClass(string typeName, bool caseSensitive)
+		
+		public IClass GetClass (IProject project, string typeName, bool caseSensitive)
 		{
-			if (!caseSensitive) {
-				typeName = typeName.ToLower();
-			}
-			
-			ClasstableEntry entry = (caseSensitive ? classes[typeName] : caseInsensitiveClasses[typeName]) as ClasstableEntry;
-			if (entry != null) {
-				return entry.Class;
-			}
-			
-			// try to load the class from our data file
-			int idx = classProxies.IndexOf(typeName, caseSensitive);
-			if (idx &gt; 0) {
-				BinaryReader reader = new BinaryReader(new BufferedStream(new FileStream(codeCompletionMainFile, FileMode.Open, FileAccess.Read, FileShare.Read)));
-				reader.BaseStream.Seek(classProxies[idx].Offset, SeekOrigin.Begin);
-				IClass c = new PersistentClass(reader, classProxies);
-				reader.Close();
-				lock (classes) {
-					caseInsensitiveClasses[typeName.ToLower()] = classes[typeName] = new ClasstableEntry(null, null, c);
+			CodeCompletionDatabase db = GetProjectDatabase (project);
+			IClass c;
+			if (db != null) {
+				c = db.GetClass (typeName, caseSensitive);
+				if (c != null) return c;
+				foreach (ReferenceEntry re in db.References)
+				{
+					CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+					if (cdb == null) continue;
+					c = cdb.GetClass (typeName, caseSensitive);
+					if (c != null) return c;
 				}
-				return c;
 			}
-			return null;
+			db = GetDatabase (CoreDB);
+			return db.GetClass (typeName, caseSensitive);
 		}
 		
-		public string[] GetNamespaceList(string subNameSpace)
+		public string[] GetNamespaceList (IProject project, string subNameSpace)
 		{
-			return GetNamespaceList(subNameSpace, true);
+			return GetNamespaceList (project, subNameSpace, true);
 		}
-		public string[] GetNamespaceList(string subNameSpace, bool caseSensitive)
+		
+		public string[] GetNamespaceList (IProject project, string subNameSpace, bool caseSensitive)
 		{
-//			Console.WriteLine(&quot;GetNamespaceList &gt;{0}&lt;&quot;, subNameSpace);
+			ArrayList contents = new ArrayList ();
 			
-			System.Diagnostics.Debug.Assert(subNameSpace != null);
-			if (!caseSensitive) {
-				subNameSpace = subNameSpace.ToLower();
+			CodeCompletionDatabase db = GetProjectDatabase (project);
+			if (db != null) {
+				db.GetNamespaceList (contents, subNameSpace, caseSensitive);
+				foreach (ReferenceEntry re in db.References)
+				{
+					CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+					if (cdb == null) continue;
+					cdb.GetNamespaceList (contents, subNameSpace, caseSensitive);
+				}
 			}
 			
-			string[] path = subNameSpace.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
+			db = GetDatabase (CoreDB);
+			db.GetNamespaceList (contents, subNameSpace, caseSensitive);
 			
-			if (subNameSpace.Length &gt; 0) {
-				for (int i = 0; i &lt; path.Length; ++i) {
-					if (!(cur[path[i]] is Hashtable)) {
-						return null;
+			return (string[]) contents.ToArray (typeof(string));
+		}
+		
+		public ArrayList GetNamespaceContents (IProject project, string namspace, bool includeReferences)
+		{
+			return GetNamespaceContents (project, namspace, includeReferences, true);
+		}
+		
+		public ArrayList GetNamespaceContents (IProject project, string namspace, bool includeReferences, bool caseSensitive)
+		{
+			ArrayList contents = new ArrayList ();
+			
+			CodeCompletionDatabase db = GetProjectDatabase (project);
+			if (db != null) {
+				db.GetNamespaceContents (contents, namspace, caseSensitive);
+				if (includeReferences) {
+					foreach (ReferenceEntry re in db.References)
+					{
+						CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+						if (cdb == null) continue;
+						cdb.GetNamespaceContents (contents, namspace, caseSensitive);
 					}
-					cur = (Hashtable)cur[path[i]];
 				}
 			}
 			
-			if (!caseSensitive) {
-				cur = (Hashtable)cur[CaseInsensitiveKey];
+			if (includeReferences) {
+				db = GetDatabase (CoreDB);
+				db.GetNamespaceContents (contents, namspace, caseSensitive);
 			}
 			
-			ArrayList namespaceList = new ArrayList();
-			foreach (DictionaryEntry entry in cur) {
-				if (entry.Value is Hashtable &amp;&amp; entry.Key.ToString().Length &gt; 0) {
-					namespaceList.Add(entry.Key);
-				}
-			}
-			
-			return (string[])namespaceList.ToArray(typeof(string));
+			return contents;
 		}
 		
-		public ArrayList GetNamespaceContents(string subNameSpace)
+		public bool NamespaceExists(IProject project, string name)
 		{
-			return GetNamespaceContents(subNameSpace, true);
+			return NamespaceExists(project, name, true);
 		}
-		public ArrayList GetNamespaceContents(string subNameSpace, bool caseSensitive)
+		
+		public bool NamespaceExists(IProject project, string name, bool caseSensitive)
 		{
-//			Console.WriteLine(&quot;GetNamespaceContents &gt;{0}&lt;&quot;, subNameSpace);
+			CodeCompletionDatabase db = GetProjectDatabase (project);
+			if (db != null) {
+				if (db.NamespaceExists (name, caseSensitive)) return true;
+				foreach (ReferenceEntry re in db.References)
+				{
+					CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+					if (cdb == null) continue;
+					if (cdb.NamespaceExists (name, caseSensitive)) return true;
+				}
+			}
 			
-			ArrayList namespaceList = new ArrayList();
-			if (subNameSpace == null) {
-				return namespaceList;
+			db = GetDatabase (CoreDB);
+			return db.NamespaceExists (name, caseSensitive);
 			}
-			if (!caseSensitive) {
-				subNameSpace = subNameSpace.ToLower();
+
+		public string SearchNamespace(IProject project, IUsing usin, string partitialNamespaceName)
+		{
+			return SearchNamespace(project, usin, partitialNamespaceName, true);
+		}
+		
+		public string SearchNamespace(IProject project, IUsing usin, string partitialNamespaceName, bool caseSensitive)
+		{
+//			Console.WriteLine(&quot;SearchNamespace : &gt;{0}&lt;&quot;, partitialNamespaceName);
+			if (NamespaceExists(project, partitialNamespaceName, caseSensitive)) {
+				return partitialNamespaceName;
 			}
 			
-			string[] path = subNameSpace.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
-			
-			for (int i = 0; i &lt; path.Length; ++i) {
-				if (!(cur[path[i]] is Hashtable)) {
-					return namespaceList;
+			// search for partitial namespaces
+			string declaringNamespace = (string)usin.Aliases[&quot;&quot;];
+			if (declaringNamespace != null) {
+				while (declaringNamespace.Length &gt; 0) {
+					if ((caseSensitive ? declaringNamespace.EndsWith(partitialNamespaceName) : declaringNamespace.ToLower().EndsWith(partitialNamespaceName.ToLower()) ) &amp;&amp; NamespaceExists(project, declaringNamespace, caseSensitive)) {
+						return declaringNamespace;
+					}
+					int index = declaringNamespace.IndexOf('.');
+					if (index &gt; 0) {
+						declaringNamespace = declaringNamespace.Substring(0, index);
+					} else {
+						break;
+					}
 				}
-				cur = (Hashtable)cur[path[i]];
 			}
 			
-			if (!caseSensitive) {
-				cur = (Hashtable)cur[CaseInsensitiveKey];
-			}
-			
-			foreach (DictionaryEntry entry in cur)  {
-				if (entry.Value is Hashtable) {
-					namespaceList.Add(entry.Key);
-				} else {
-					namespaceList.Add(entry.Value);
+			// Remember:
+			//     Each namespace has an own using object
+			//     The namespace name is an alias which has the key &quot;&quot;
+			foreach (DictionaryEntry entry in usin.Aliases) {
+				string aliasString = entry.Key.ToString();
+				if (caseSensitive ? partitialNamespaceName.StartsWith(aliasString) : partitialNamespaceName.ToLower().StartsWith(aliasString.ToLower())) {
+					if (aliasString.Length &gt;= 0) {
+						string nsName = nsName = String.Concat(entry.Value.ToString(), partitialNamespaceName.Remove(0, aliasString.Length));
+						if (NamespaceExists (project, nsName, caseSensitive)) {
+							return nsName;
+						}
+					}
 				}
 			}
-			return namespaceList;
+			return null;
 		}
-		
-		public bool NamespaceExists(string name)
+
+		public IClass SearchType(IProject project, IUsing iusing, string partitialTypeName)
 		{
-			return NamespaceExists(name, true);
+			return SearchType(project, iusing, partitialTypeName, true);
 		}
-		public bool NamespaceExists(string name, bool caseSensitive)
+		
+		public IClass SearchType(IProject project, IUsing iusing, string partitialTypeName, bool caseSensitive)
 		{
-//			Console.WriteLine(&quot;NamespaceExists &gt;{0}&lt;&quot;, name);
-			if (name == null) {
-				return false;
+//			Console.WriteLine(&quot;Search type : &gt;{0}&lt;&quot;, partitialTypeName);
+			IClass c = GetClass(project, partitialTypeName, caseSensitive);
+			if (c != null) {
+				return c;
 			}
-			if (!caseSensitive) {
-				name = name.ToLower();
+			
+			foreach (string str in iusing.Usings) {
+				string possibleType = String.Concat(str, &quot;.&quot;, partitialTypeName);
+//				Console.WriteLine(&quot;looking for &quot; + possibleType);
+				c = GetClass(project, possibleType, caseSensitive);
+				if (c != null) {
+//					Console.WriteLine(&quot;Found!&quot;);
+					return c;
+				}
 			}
-			string[] path = name.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
 			
-			for (int i = 0; i &lt; path.Length; ++i) {
-				if (!(cur[path[i]] is Hashtable)) {
-					return false;
+			// search class in partitial namespaces
+			string declaringNamespace = (string)iusing.Aliases[&quot;&quot;];
+			if (declaringNamespace != null) {
+				while (declaringNamespace.Length &gt; 0) {
+					string className = String.Concat(declaringNamespace, &quot;.&quot;, partitialTypeName);
+//					Console.WriteLine(&quot;looking for &quot; + className);
+					c = GetClass(project, className, caseSensitive);
+					if (c != null) {
+//						Console.WriteLine(&quot;Found!&quot;);
+						return c;
+					}
+					int index = declaringNamespace.IndexOf('.');
+					if (index &gt; 0) {
+						declaringNamespace = declaringNamespace.Substring(0, index);
+					} else {
+						break;
+					}
 				}
-				cur = (Hashtable)cur[path[i]];
 			}
-			return true;
+			
+			foreach (DictionaryEntry entry in iusing.Aliases) {
+				string aliasString = entry.Key.ToString();
+				if (caseSensitive ? partitialTypeName.StartsWith(aliasString) : partitialTypeName.ToLower().StartsWith(aliasString.ToLower())) {
+					string className = null;
+					if (aliasString.Length &gt; 0) {
+						className = String.Concat(entry.Value.ToString(), partitialTypeName.Remove(0, aliasString.Length));
+//						Console.WriteLine(&quot;looking for &quot; + className);
+						c = GetClass(project, className, caseSensitive);
+						if (c != null) {
+//							Console.WriteLine(&quot;Found!&quot;);
+							return c;
+						}
+					}
+				}
+			}
+			
+			return null;
 		}
+		
+		public IEnumerable GetClassInheritanceTree (IProject project, IClass cls)
+		{
+			return new ClassInheritanceEnumerator (this, project, cls);
+		}
+		
 #endregion
 		
 		public IParseInformation ParseFile(string fileName)
@@ -622,8 +765,14 @@
 			return ParseFile(fileName, null);
 		}
 		
-		public IParseInformation ParseFile(string fileName, string fileContent)
+		public IParseInformation ParseFile (string fileName, string fileContent)
 		{
+			return DoParseFile (fileName, fileContent);
+		}
+		
+		public IParseInformation DoParseFile (string fileName, string fileContent)
+		{
+			Console.WriteLine (&quot;PARSING &quot; + fileName);
 			IParser parser = GetParser(fileName);
 			
 			if (parser == null) {
@@ -652,26 +801,14 @@
 				parserOutput = parser.Parse(fileName);
 			}
 			
-			ParseInformation parseInformation = parsings[fileName] as ParseInformation;
+			ParseInformation parseInformation = GetCachedParseInformation (fileName);
+			bool newInfo = false;
 			
-			int itemsAdded = 0;
-			int itemsRemoved = 0;
-			
 			if (parseInformation == null) {
 				parseInformation = new ParseInformation();
-			} else {
-				itemsAdded = GetAddedItems(
-				                           (ICompilationUnit)parseInformation.MostRecentCompilationUnit,
-				                           (ICompilationUnit)parserOutput,
-				                           (ICompilationUnit)addedParseInformation.DirtyCompilationUnit
-				                           );
-				
-				itemsRemoved = GetRemovedItems(
-				                               (ICompilationUnit)parseInformation.MostRecentCompilationUnit,
-				                               (ICompilationUnit)parserOutput,
-				                               (ICompilationUnit)removedParseInformation.DirtyCompilationUnit
-				                               );
+				newInfo = true;
 			}
+			
 			if (parserOutput.ErrorsDuringCompile) {
 				parseInformation.DirtyCompilationUnit = parserOutput;
 			} else {
@@ -679,43 +816,51 @@
 				parseInformation.DirtyCompilationUnit = null;
 			}
 			
-			parsings[fileName] = parseInformation;
-			
-			if (parseInformation.BestCompilationUnit is ICompilationUnit) {
-				ICompilationUnit cu = (ICompilationUnit)parseInformation.BestCompilationUnit;
-				foreach (IClass c in cu.Classes) {
-					AddClassToNamespaceList(c);
-					lock (classes) {
-						caseInsensitiveClasses[c.FullyQualifiedName.ToLower()] = classes[c.FullyQualifiedName] = new ClasstableEntry(fileName, cu, c);
-					}
-				}
-			} else {
-//				Console.WriteLine(&quot;SKIP!&quot;);
+			if (newInfo) {
+				AddToCache (parseInformation, fileName);
 			}
 			
-			OnParseInformationChanged(new ParseInformationEventArgs(fileName, parseInformation));
-			
-			if (itemsRemoved &gt; 0) {
-				OnParseInformationRemoved (new ParseInformationEventArgs (fileName, removedParseInformation));
-			}
-			if(itemsAdded &gt; 0) {
-				OnParseInformationAdded(new ParseInformationEventArgs(fileName, addedParseInformation));
-			}
-			//if(itemsRemoved &gt; 0) {
-			//	OnParseInformationRemoved(new ParseInformationEventArgs(fileName, removedParseInformation));
-			//}
+			OnParseInformationChanged (new ParseInformationEventArgs (fileName, parseInformation));
 			return parseInformation;
 		}
 		
-		void RemoveClasses(ICompilationUnit cu)
+		ParseInformation GetCachedParseInformation (string fileName)
 		{
-			if (cu != null) {
-				lock (classes) {
-					foreach (IClass c in cu.Classes) {
-							classes.Remove(c.FullyQualifiedName);
-							caseInsensitiveClasses.Remove(c.FullyQualifiedName.ToLower());
+			lock (parsings) 
+			{
+				ParsingCacheEntry en = parsings [fileName] as ParsingCacheEntry;
+				if (en != null) {
+					en.AccessTime = DateTime.Now;
+					return en.ParseInformation;
+				}
+				else
+					return null;
+			}
+		}
+		
+		void AddToCache (ParseInformation info, string fileName)
+		{
+			lock (parsings) 
+			{
+				if (parsings.Count &gt;= MAX_CACHE_SIZE)
+				{
+					DateTime tim = DateTime.MaxValue;
+					string toDelete = null;
+					foreach (DictionaryEntry pce in parsings)
+					{
+						DateTime ptim = ((ParsingCacheEntry)pce.Value).AccessTime;
+						if (ptim &lt; tim) {
+							tim = ptim;
+							toDelete = pce.Key.ToString();
+						}
 					}
+					parsings.Remove (toDelete);
 				}
+				
+				ParsingCacheEntry en = new ParsingCacheEntry();
+				en.ParseInformation = info;
+				en.AccessTime = DateTime.Now;
+				parsings [fileName] = en;
 			}
 		}
 
@@ -724,11 +869,10 @@
 			if (fileName == null || fileName.Length == 0) {
 				return null;
 			}
-			object cu = parsings[fileName];
-			if (cu == null) {
-				return ParseFile(fileName);
-			}
-			return (IParseInformation)cu;
+			
+			IParseInformation info = GetCachedParseInformation (fileName);
+			if (info != null) return info;
+			else return ParseFile(fileName);
 		}
 		
 		public IExpressionFinder GetExpressionFinder(string fileName)
@@ -753,38 +897,13 @@
 			return null;
 		}
 		
-		int GetAddedItems(ICompilationUnit original, ICompilationUnit changed, ICompilationUnit result)
-		{
-			int count = 0;
-			//result.LookUpTable.Clear();
-			//result.Usings.Clear();
-			//result.Attributes.Clear();
-			result.Classes.Clear();
-			//result.MiscComments.Clear();
-			//result.DokuComments.Clear();
-			//result.TagComments.Clear();
-			
-			//count += DiffUtility.GetAddedItems(original.LookUpTable,  changed.LookUpTable,  result.LookUpTable);
-			//count += DiffUtility.GetAddedItems(original.Usings,       changed.Usings,       result.Usings);
-			//count += DiffUtility.GetAddedItems(original.Attributes,   changed.Attributes,   result.Attributes);
-			count += DiffUtility.GetAddedItems(original.Classes,      changed.Classes,      result.Classes);
-			//count += DiffUtility.GetAddedItems(original.MiscComments, changed.MiscComments, result.MiscComments);
-			//count += DiffUtility.GetAddedItems(original.DokuComments, changed.DokuComments, result.DokuComments);
-			//count += DiffUtility.GetAddedItems(original.TagComments,  changed.TagComments,  result.TagComments);
-			return count;
-		}
-		
-		int GetRemovedItems(ICompilationUnit original, ICompilationUnit changed, ICompilationUnit result) {
-			return GetAddedItems(changed, original, result);
-		}
-		
 		////////////////////////////////////
 		
-		public ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName)
+		public ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName)
 		{
 			IParser parser = GetParser(fileName);
 			if (parser != null) {
-				return parser.CtrlSpace(parserService, caretLine, caretColumn, fileName);
+				return parser.CtrlSpace(parserService, project, caretLine, caretColumn, fileName);
 			}
 			return null;
 		}
@@ -802,7 +921,8 @@
 			}
 		}
 		
-		public ResolveResult Resolve(string expression,
+		public ResolveResult Resolve(IProject project,
+									 string expression, 
 		                             int caretLineNumber,
 		                             int caretColumn,
 		                             string fileName,
@@ -814,14 +934,22 @@
 				IParser parser = GetParser(fileName);
 				//Console.WriteLine(&quot;Parse info : &quot; + GetParseInformation(fileName).MostRecentCompilationUnit.Tag);
 				if (parser != null) {
-					return parser.Resolve(this, expression, caretLineNumber, caretColumn, fileName, fileContent);
+					return parser.Resolve(this, project, expression, caretLineNumber, caretColumn, fileName, fileContent);
 				}
 				return null;
 			} catch {
 				return null;
 			}
 		}
+		
+		internal INameEncoder DefaultNameEncoder {
+			get { return nameTable; }
+		}
 
+		internal INameDecoder DefaultNameDecoder {
+			get { return nameTable; }
+		}
+		
 		public string MonodocResolver (string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
 			try {
@@ -834,20 +962,13 @@
 				return null;
 			}
 		}
-
-		protected void OnParseInformationAdded(ParseInformationEventArgs e)
+		
+		public void NotifyParseInfoChange (string file, ClassUpdateInformation res)
 		{
-			if (ParseInformationAdded != null) {
-				ParseInformationAdded(this, e);
-			}
+			ClassInformationEventArgs args = new ClassInformationEventArgs (file, res);
+			OnClassInformationChanged (args);
 		}
 
-		protected void OnParseInformationRemoved(ParseInformationEventArgs e)
-		{
-			if (ParseInformationRemoved != null) {
-				ParseInformationRemoved(this, e);
-			}
-		}
 		protected virtual void OnParseInformationChanged(ParseInformationEventArgs e)
 		{
 			if (ParseInformationChanged != null) {
@@ -855,9 +976,15 @@
 			}
 		}
 		
-		public event ParseInformationEventHandler ParseInformationAdded;
-		public event ParseInformationEventHandler ParseInformationRemoved;
+		protected virtual void OnClassInformationChanged(ClassInformationEventArgs e)
+		{
+			if (ClassInformationChanged != null) {
+				ClassInformationChanged(this, e);
+			}
+		}
+		
 		public event ParseInformationEventHandler ParseInformationChanged;
+		public event ClassInformationEventHandler ClassInformationChanged;
 	}
 	
 	[Serializable]
@@ -885,4 +1012,104 @@
 			}
 		}
 	}
+	
+	public class ClassInheritanceEnumerator : IEnumerator, IEnumerable
+	{
+		IParserService parserService;
+		IClass topLevelClass;
+		IClass currentClass  = null;
+		Queue  baseTypeQueue = new Queue();
+		IProject project;
+
+		public ClassInheritanceEnumerator(IParserService parserService, IProject project, IClass topLevelClass)
+		{
+			this.parserService = parserService;
+			this.project = project;
+			this.topLevelClass = topLevelClass;
+			baseTypeQueue.Enqueue(topLevelClass.FullyQualifiedName);
+			PutBaseClassesOnStack(topLevelClass);
+			baseTypeQueue.Enqueue(&quot;System.Object&quot;);
+		}
+		public IEnumerator GetEnumerator()
+		{
+			return this;
+		}
+
+		void PutBaseClassesOnStack(IClass c)
+		{
+			foreach (string baseTypeName in c.BaseTypes) {
+				baseTypeQueue.Enqueue(baseTypeName);
+			}
+		}
+
+		public IClass Current {
+			get {
+				return currentClass;
+			}
+		}
+
+		object IEnumerator.Current {
+			get {
+				return currentClass;
+			}
+		}
+
+		public bool MoveNext()
+		{
+			if (baseTypeQueue.Count == 0) {
+				return false;
+			}
+			string baseTypeName = baseTypeQueue.Dequeue().ToString();
+
+			IClass baseType = parserService.GetClass(project, baseTypeName);
+			if (baseType == null) {
+				ICompilationUnit unit = currentClass == null ? null : currentClass.CompilationUnit;
+				if (unit != null) {
+					foreach (IUsing u in unit.Usings) {
+						baseType = parserService.SearchType(project, u, baseTypeName);
+						if (baseType != null) {
+							break;
+						}
+					}
+				}
+			}
+
+			if (baseType != null) {
+				currentClass = baseType;
+				PutBaseClassesOnStack(currentClass);
+			}
+
+			return baseType != null;
+		}
+
+		public void Reset()
+		{
+			baseTypeQueue.Clear();
+			baseTypeQueue.Enqueue(topLevelClass.FullyQualifiedName);
+			PutBaseClassesOnStack(topLevelClass);
+			baseTypeQueue.Enqueue(&quot;System.Object&quot;);
+		}
+	}	
+	
+	public class ClassUpdateInformation
+	{
+		ClassCollection added = new ClassCollection ();
+		ClassCollection removed = new ClassCollection ();
+		ClassCollection modified = new ClassCollection ();
+		
+		public ClassCollection Added
+		{
+			get { return added; }
+		}
+		
+		public ClassCollection Removed
+		{
+			get { return removed; }
+		}
+		
+		public ClassCollection Modified
+		{
+			get { return modified; }
+		}
+	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Services/ParserService/IParserService.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/ParserService/IParserService.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Services/ParserService/IParserService.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -48,34 +48,40 @@
 		IExpressionFinder GetExpressionFinder(string fileName);
 		
 		// Default Parser Layer dependent functions
-		IClass    GetClass(string typeName);
-		string[]  GetNamespaceList(string subNameSpace);
-		ArrayList GetNamespaceContents(string subNameSpace);
-		bool      NamespaceExists(string name);
+		IClass    GetClass(IProject project, string typeName);
+		string[]  GetNamespaceList(IProject project, string subNameSpace);
+		ArrayList GetNamespaceContents(IProject project, string subNameSpace, bool includeReferences);
+		bool      NamespaceExists(IProject project, string name);
+		string    SearchNamespace(IProject project, IUsing iusing, string partitialNamespaceName);
+		IClass    SearchType(IProject project, IUsing iusing, string partitialTypeName);
 		
-		IClass    GetClass(string typeName, bool caseSensitive);
-		string[]  GetNamespaceList(string subNameSpace, bool caseSensitive);
-		ArrayList GetNamespaceContents(string subNameSpace, bool caseSensitive);
-		bool      NamespaceExists(string name, bool caseSensitive);
+		IClass    GetClass(IProject project, string typeName, bool caseSensitive);
+		string[]  GetNamespaceList(IProject project, string subNameSpace, bool caseSensitive);
+		ArrayList GetNamespaceContents(IProject project, string subNameSpace, bool includeReferences, bool caseSensitive);
+		bool      NamespaceExists(IProject project, string name, bool caseSensitive);
+		string    SearchNamespace(IProject project, IUsing iusing, string partitialNamespaceName, bool caseSensitive);
+		IClass    SearchType(IProject project, IUsing iusing, string partitialTypeName, bool caseSensitive);
+		
+		IEnumerable GetClassInheritanceTree (IProject project, IClass cls);
+		
 		////////////////////////////////////////////
 
 		/// &lt;summary&gt;
 		/// Resolves an expression.
 		/// The caretLineNumber and caretColumn is 1 based.
 		/// &lt;/summary&gt;
-		ResolveResult Resolve(string expression,
+		ResolveResult Resolve(IProject project,
+							  string expression,
 		                      int caretLineNumber,
 		                      int caretColumn,
 		                      string fileName,
 		                      string fileContent);
 		string MonodocResolver (string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
 		ArrayList IsAsResolve (string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
-		ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName);
-		void AddReferenceToCompletionLookup(IProject project, ProjectReference reference);
+		ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName);
 		string LoadAssemblyFromGac (string name);
 
-		event ParseInformationEventHandler ParseInformationAdded;
-		event ParseInformationEventHandler ParseInformationRemoved;
 		event ParseInformationEventHandler ParseInformationChanged;
+		event ClassInformationEventHandler ClassInformationChanged;
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Services/Project/DefaultProjectService.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/Project/DefaultProjectService.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Services/Project/DefaultProjectService.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -170,6 +170,10 @@
 			fileService.RecentOpen.AddLastProject(filename);
 			
 			OnCombineOpened(new CombineEventArgs(openCombine));
+			openCombine.FileAddedToProject += new ProjectFileEventHandler (NotifyFileAddedToProject);
+			openCombine.FileRemovedFromProject += new ProjectFileEventHandler (NotifyFileRemovedFromProject);
+			openCombine.ReferenceAddedToProject += new ProjectReferenceEventHandler (NotifyReferenceAddedToProject);
+			openCombine.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (NotifyReferenceRemovedFromProject);
 			
 			RestoreCombinePreferences(CurrentOpenCombine, openCombineFileName);
 		}
@@ -202,13 +206,11 @@
 			}
 			ProjectFile newFileInformation = new ProjectFile(filename, action);
 			prj.ProjectFiles.Add(newFileInformation);
-			OnFileAddedToProject (new FileEventArgs (filename, false));
 			return newFileInformation;
 		}
 		
 		public void AddFileToProject(IProject prj, ProjectFile projectFile) {
 			prj.ProjectFiles.Add(projectFile);
-			OnFileAddedToProject (new FileEventArgs (projectFile.Name, false));
 		}
 
 		
@@ -462,7 +464,6 @@
 			base.InitializeService();
 			IFileService fileService = (IFileService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
 			
-			FileRemovedFromProject += new FileEventHandler(CheckFileRemove);
 			fileService.FileRemoved += new FileEventHandler(CheckFileRemove);
 			fileService.FileRenamed += new FileEventHandler(CheckFileRename);
 		}
@@ -657,11 +658,6 @@
 		
 		public void RemoveFileFromProject(string fileName)
 		{
-			if (Directory.Exists(fileName)) {
-				OnFileRemovedFromProject(new FileEventArgs(fileName, true));
-			} else {
-				OnFileRemovedFromProject(new FileEventArgs(fileName, false));
-			}
 		}
 			
 		public void OnStartBuild()
@@ -684,20 +680,54 @@
 			}
 		}
 		
-		public virtual void OnFileRemovedFromProject (FileEventArgs e)
+		void NotifyFileRemovedFromProject (object sender, ProjectFileEventArgs e)
 		{
+			OnFileRemovedFromProject (e);
+		}
+		
+		void NotifyFileAddedToProject (object sender, ProjectFileEventArgs e)
+		{
+			OnFileAddedToProject (e);
+		}
+		
+		internal void NotifyReferenceAddedToProject (object sender, ProjectReferenceEventArgs e)
+		{
+			OnReferenceRemovedFromProject (e);
+		}
+		
+		internal void NotifyReferenceRemovedFromProject (object sender, ProjectReferenceEventArgs e)
+		{
+			OnReferenceAddedToProject (e);
+		}
+		
+		protected virtual void OnFileRemovedFromProject (ProjectFileEventArgs e)
+		{
 			if (FileRemovedFromProject != null) {
 				FileRemovedFromProject(this, e);
 			}
 		}
 
-		public virtual void OnFileAddedToProject (FileEventArgs e)
+		protected virtual void OnFileAddedToProject (ProjectFileEventArgs e)
 		{
 			if (FileAddedToProject != null) {
 				FileAddedToProject (this, e);
 			}
 		}
 		
+		protected virtual void OnReferenceRemovedFromProject (ProjectReferenceEventArgs e)
+		{
+			if (ReferenceRemovedFromProject != null) {
+				ReferenceRemovedFromProject (this, e);
+			}
+		}
+		
+		protected virtual void OnReferenceAddedToProject (ProjectReferenceEventArgs e)
+		{
+			if (ReferenceAddedToProject != null) {
+				ReferenceAddedToProject (this, e);
+			}
+		}
+
 		public string GetFileName(IProject project)
 		{
 			if (openCombine != null) {
@@ -739,8 +769,8 @@
 			openCombine.GenerateMakefiles ();
 		}
 		
-		public event FileEventHandler FileRemovedFromProject;
-		public event FileEventHandler FileAddedToProject;
+		public event ProjectFileEventHandler FileRemovedFromProject;
+		public event ProjectFileEventHandler FileAddedToProject;
 		public event EventHandler     StartBuild;
 		public event EventHandler     EndBuild;
 		public event EventHandler     BeforeStartProject;
@@ -752,5 +782,8 @@
 		
 		public event ProjectRenameEventHandler ProjectRenamed;
 		public event ProjectEventHandler       CurrentProjectChanged;
+		
+		public event ProjectReferenceEventHandler ReferenceAddedToProject;
+		public event ProjectReferenceEventHandler ReferenceRemovedFromProject;
 	}
 }

Modified: trunk/MonoDevelop/src/Main/Base/Services/Project/IProjectService.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/Project/IProjectService.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Main/Base/Services/Project/IProjectService.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -187,10 +187,16 @@
 		/// &lt;remarks&gt;
 		/// Is called, when a file is removed from and added to a project.
 		/// &lt;/remarks&gt;
-		event FileEventHandler FileRemovedFromProject;
-		event FileEventHandler FileAddedToProject;
+		event ProjectFileEventHandler FileRemovedFromProject;
+		event ProjectFileEventHandler FileAddedToProject;
 				
 		/// &lt;remarks&gt;
+		/// Is called, when a reference is removed from and added to a project.
+		/// &lt;/remarks&gt;
+		event ProjectReferenceEventHandler ReferenceAddedToProject;
+		event ProjectReferenceEventHandler ReferenceRemovedFromProject;
+		
+		/// &lt;remarks&gt;
 		/// Called before a build run
 		/// &lt;/remarks&gt;
 		event EventHandler StartBuild;

Modified: trunk/MonoDevelop/src/Makefile.am
===================================================================
--- trunk/MonoDevelop/src/Makefile.am	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Makefile.am	2004-05-25 19:32:09 UTC (rev 1631)
@@ -1,3 +1,3 @@
 
-SUBDIRS = Tools Libraries Main AddIns
+SUBDIRS = Libraries Main Tools AddIns
 

Modified: trunk/MonoDevelop/src/Tools/Makefile.am
===================================================================
--- trunk/MonoDevelop/src/Tools/Makefile.am	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Tools/Makefile.am	2004-05-25 19:32:09 UTC (rev 1631)
@@ -1,3 +1,3 @@
 
-SUBDIRS = SharpCoco
+SUBDIRS = SharpCoco dbgen
 

Added: trunk/MonoDevelop/src/Tools/dbgen/Makefile.am
===================================================================
--- trunk/MonoDevelop/src/Tools/dbgen/Makefile.am	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Tools/dbgen/Makefile.am	2004-05-25 19:32:09 UTC (rev 1631)
@@ -0,0 +1,23 @@
+
+CSC = mcs /debug
+ASSEMBLY = dbgen.exe
+
+FILES = src/AssemblyInfo.cs \
+src/dbgen.cs
+
+build_sources = $(addprefix $(srcdir)/, $(FILES))
+
+all: $(ASSEMBLY)
+
+REFS = /r:../../../build/bin/MonoDevelop.Base.dll
+	
+$(ASSEMBLY): $(build_sources)
+	$(CSC) $(build_sources) $(REFS) /out:$(ASSEMBLY)
+	cp $(ASSEMBLY) ../../../build/bin/.
+
+assemblydir = $(libdir)/monodevelop/bin
+assembly_DATA = $(ASSEMBLY)           
+
+CLEANFILES = $(ASSEMBLY)
+EXTRA_DIST = $(FILES)
+

Added: trunk/MonoDevelop/src/Tools/dbgen/src/AssemblyInfo.cs
===================================================================
--- trunk/MonoDevelop/src/Tools/dbgen/src/AssemblyInfo.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Tools/dbgen/src/AssemblyInfo.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -0,0 +1,32 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+
+[assembly: AssemblyTitle(&quot;&quot;)]
+[assembly: AssemblyDescription(&quot;&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.*&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]

Added: trunk/MonoDevelop/src/Tools/dbgen/src/dbgen.cs
===================================================================
--- trunk/MonoDevelop/src/Tools/dbgen/src/dbgen.cs	2004-05-25 19:11:36 UTC (rev 1630)
+++ trunk/MonoDevelop/src/Tools/dbgen/src/dbgen.cs	2004-05-25 19:32:09 UTC (rev 1631)
@@ -0,0 +1,20 @@
+
+using System;
+using System.Reflection;
+using MonoDevelop.Services;
+
+public class CodeCompletionDatabaseGeneratorTool
+{
+	public static int Main (string[] args)
+	{
+		if (args.Length == 0) {
+			Console.WriteLine (&quot;MonoDevelop Code Completion Database Generation Tool&quot;);
+			Console.WriteLine (&quot;Usage: dbgen &lt;destDirectory&gt; [&lt;assemblyName&gt; | &lt;assemblyPath&gt;]&quot;);
+			return 0;
+		}
+		DefaultParserService parserService = new DefaultParserService ();
+		parserService.GenerateAssemblyDatabase (args[0], args[1]);
+		return 0;
+	}
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001237.html">[Monodevelop-patches-list] r1630 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui InsightWindow
</A></li>
	<LI>Next message: <A HREF="001239.html">[Monodevelop-patches-list] r1632 - in trunk/MonoDevelop: . po src/Main/Base src/Main/Base/Services/ParserService src/Tools/dbgen
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1238">[ date ]</a>
              <a href="thread.html#1238">[ thread ]</a>
              <a href="subject.html#1238">[ subject ]</a>
              <a href="author.html#1238">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
