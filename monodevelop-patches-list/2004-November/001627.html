<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2023 - in trunk/MonoDevelop/Core: . build/AddIns/AddIns/BackendBindings build/AddIns/AddIns/BackendBindings/templates data/resources/glade src/AddIns/BackendBindings src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/BackendBindings/JavaBinding src/AddIns/BackendBindings/JavaBinding/Parser src/AddIns/BackendBindings/VBNetBinding src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy src/AddIns/BackendBindings/VBNetBinding/Gui src/AddIns/BackendBindings/VBNetBinding/Parser src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree src/AddIns/BackendBindings/VBNetBinding/Project src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer src/Add Ins/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist src/Main/Base src/Main/Base/Internal/Parser src/Main/Base/Services/ParserService
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2023%20-%20in%20trunk/MonoDevelop/Core%3A%20.%20build/AddIns/AddIns/BackendBindings%20build/AddIns/AddIns/BackendBindings/templates%20data/resources/glade%20src/AddIns/BackendBindings%20src/AddIns/BackendBindings/CSharpBinding%20src/AddIns/BackendBindings/CSharpBinding/Parser%20src/AddIns/BackendBindings/JavaBinding%20src/AddIns/BackendBindings/JavaBinding/Parser%20src/AddIns/BackendBindings/VBNetBinding%20src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy%20src/AddIns/BackendBindings/VBNetBinding/Gui%20src/AddIns/BackendBindings/VBNetBinding/Parser%20src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree%20src/AddIns/BackendBindings/VBNetBinding/Project%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer%20src/Add%0A%20Ins/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist%20src/Main/Base%20src/Main/Base/Internal/Parser%20src/Main/Base/Services/ParserService&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001626.html">
   <LINK REL="Next"  HREF="001628.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2023 - in trunk/MonoDevelop/Core: . build/AddIns/AddIns/BackendBindings build/AddIns/AddIns/BackendBindings/templates data/resources/glade src/AddIns/BackendBindings src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/BackendBindings/JavaBinding src/AddIns/BackendBindings/JavaBinding/Parser src/AddIns/BackendBindings/VBNetBinding src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy src/AddIns/BackendBindings/VBNetBinding/Gui src/AddIns/BackendBindings/VBNetBinding/Parser src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree src/AddIns/BackendBindings/VBNetBinding/Project src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer src/Add Ins/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist src/Main/Base src/Main/Base/Internal/Parser src/Main/Base/Services/ParserService</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2023%20-%20in%20trunk/MonoDevelop/Core%3A%20.%20build/AddIns/AddIns/BackendBindings%20build/AddIns/AddIns/BackendBindings/templates%20data/resources/glade%20src/AddIns/BackendBindings%20src/AddIns/BackendBindings/CSharpBinding%20src/AddIns/BackendBindings/CSharpBinding/Parser%20src/AddIns/BackendBindings/JavaBinding%20src/AddIns/BackendBindings/JavaBinding/Parser%20src/AddIns/BackendBindings/VBNetBinding%20src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy%20src/AddIns/BackendBindings/VBNetBinding/Gui%20src/AddIns/BackendBindings/VBNetBinding/Parser%20src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree%20src/AddIns/BackendBindings/VBNetBinding/Project%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer%20src/Add%0A%20Ins/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated%20src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist%20src/Main/Base%20src/Main/Base/Internal/Parser%20src/Main/Base/Services/ParserService&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2023 - in trunk/MonoDevelop/Core: . build/AddIns/AddIns/BackendBindings build/AddIns/AddIns/BackendBindings/templates data/resources/glade src/AddIns/BackendBindings src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/BackendBindings/JavaBinding src/AddIns/BackendBindings/JavaBinding/Parser src/AddIns/BackendBindings/VBNetBinding src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy src/AddIns/BackendBindings/VBNetBinding/Gui src/AddIns/BackendBindings/VBNetBinding/Parser src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree src/AddIns/BackendBindings/VBNetBinding/Project src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer src/Add Ins/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist src/Main/Base src/Main/Base/Internal/Parser src/Main/Base/Services/ParserService">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Wed Nov 10 13:03:33 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001626.html">[Monodevelop-patches-list] r2022 - trunk/md-website/include
</A></li>
        <LI>Next message: <A HREF="001628.html">[Monodevelop-patches-list] r2024 - in trunk/MonoDevelop/Core: . src/Main/Base src/Main/Base/Internal/Project/Combine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1627">[ date ]</a>
              <a href="thread.html#1627">[ thread ]</a>
              <a href="subject.html#1627">[ subject ]</a>
              <a href="author.html#1627">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: levibard
Date: 2004-11-10 13:03:32 -0500 (Wed, 10 Nov 2004)
New Revision: 2023

Added:
   trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/VBNetBinding.addin.xml
   trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/EmptyVBFile.xft.xml
   trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/EmptyVBProject.xpt.xml
   trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/VBConsoleApplicationProject.xpt.xml
   trunk/MonoDevelop/Core/data/resources/glade/VB.glade
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy/VBFormattingStrategy.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/ChooseRuntimePanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/CodeGenerationPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/OutputOptionsPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Makefile.am
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/Parser.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/Resolver.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/AttributeSection.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/CompilationUnit.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/TypeVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/VBNetVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/VBCompilerParameters.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/VBProject.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ProjectNodeBuilder.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/Makefile.am
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/SharpRefactoryVB.cmbx
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/SharpRefactoryVB.prjx
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom/CodeDOMVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/FieldReferenceOrInvocationExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactory.prjx
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.cmbx
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.mdsx
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.prjx
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VB.glade
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBAmbience.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBBindingCompilerServices.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBBindingExecutionServices.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBLanguageBinding.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.cmbx
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.mdsx
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.prjx
Modified:
   trunk/MonoDevelop/Core/ChangeLog
   trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/Makefile.am
   trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/Makefile.am
   trunk/MonoDevelop/Core/configure.in
   trunk/MonoDevelop/Core/monodevelop.xml
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/JavaBinding/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/JavaBinding/Parser/Parser.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/Makefile.am
   trunk/MonoDevelop/Core/src/Main/Base/ChangeLog
   trunk/MonoDevelop/Core/src/Main/Base/Internal/Parser/IParser.cs
   trunk/MonoDevelop/Core/src/Main/Base/Services/ParserService/DefaultParserService.cs
Log:
Adds project management, compilation, and rudimentary code completion support for vb.net.


Modified: trunk/MonoDevelop/Core/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/ChangeLog	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/ChangeLog	2004-11-10 18:03:32 UTC (rev 2023)
@@ -1,3 +1,8 @@
+2004-11-05  Levi Bard  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">taktaktaktaktaktaktaktaktaktak at gmail.com</A>&gt;
+
+	* *: Large changeset, adds project management, compilation, and
+	rudimentary code completion support for vb.net
+
 2004-10-27  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at off.net</A>&gt;
 
 	* configure.in: Make sure a valid gnome prefix is returned, error out

Modified: trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/Makefile.am	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/Makefile.am	2004-11-10 18:03:32 UTC (rev 2023)
@@ -4,9 +4,9 @@
 monodevelopdir = $(libdir)/monodevelop
 backendbindingsdir = $(monodevelopdir)/AddIns/AddIns/BackendBindings
 
-backendbindings_DATA = BackendBindings.addin.xml ILAsmBinding.addin.xml JavaBinding.addin.xml NemerleBinding.addin.xml
+backendbindings_DATA = BackendBindings.addin.xml ILAsmBinding.addin.xml JavaBinding.addin.xml NemerleBinding.addin.xml VBNetBinding.addin.xml
 
 EXTRA_DIST = $(backendbindings_DATA)
 
-CLEANFILES = CSharpBinding.dll JavaBinding.dll NemerleBinding.dll ILAsmBinding.dll
+CLEANFILES = CSharpBinding.dll JavaBinding.dll NemerleBinding.dll ILAsmBinding.dll VBNetBinding.dll
 

Added: trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/VBNetBinding.addin.xml
===================================================================
--- trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/VBNetBinding.addin.xml	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/VBNetBinding.addin.xml	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,81 @@
+&lt;AddIn name        = &quot;VB.NET Language Binding&quot;
+       author      = &quot;Levi Bard&quot;
+       copyright   = &quot;GPL&quot;
+       url         = &quot;<A HREF="http://bard.sytes.net/vbnetbinding&quot;">http://bard.sytes.net/vbnetbinding&quot;</A>
+       description = &quot;VB.NET Language Binding&quot;
+       version     = &quot;0.1&quot;&gt;
+
+  &lt;Runtime&gt;
+    &lt;Import assembly = &quot;VBNetBinding.dll&quot;/&gt;
+  &lt;/Runtime&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/FileFilter&quot;&gt;
+    &lt;FileFilter id = &quot;VBNet&quot;
+                insertbefore = &quot;AllFiles&quot;
+                name = &quot;VB.NET Files (*.vb)&quot;
+                extensions = &quot;*.vb&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/MonoDevelop/FileTemplates&quot;&gt;
+    &lt;FileTemplate id = &quot;EmptyVBFile&quot;
+                  location = &quot;templates/EmptyVBFile.xft.xml&quot;/&gt;
+  &lt;/Extension&gt;
+
+  &lt;Extension path = &quot;/MonoDevelop/ProjectTemplates&quot;&gt;
+    &lt;ProjectTemplate id = &quot;EmptyVBProject&quot;
+                     location = &quot;templates/EmptyVBProject.xpt.xml&quot;/&gt;
+    &lt;ProjectTemplate id = &quot;VBConsoleApplicationProject&quot;
+                     location = &quot;templates/VBConsoleApplicationProject.xpt.xml&quot;/&gt;
+  &lt;/Extension&gt;
+  
+	&lt;Extension path = &quot;/Workspace/Parser&quot;&gt;
+		&lt;Class id    = &quot;VBParser&quot; 
+		       class = &quot;VBBinding.Parser.TParser&quot;/&gt;
+	&lt;/Extension&gt;
+  
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/ProjectOptions/ConfigurationProperties&quot;&gt;
+    &lt;Conditional activeproject = &quot;VBNet&quot;&gt;
+      &lt;DialogPanel id = &quot;VBNetCodeGenerationPanel&quot;
+                   _label = &quot;Code Generation&quot;
+                   class = &quot;VBBinding.CodeGenerationPanel&quot;/&gt;
+    &lt;/Conditional&gt;
+  &lt;/Extension&gt;
+  
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/ProjectOptions/ConfigurationProperties&quot;&gt;
+    &lt;Conditional activeproject = &quot;VBNet&quot;&gt;
+      &lt;DialogPanel id = &quot;VBNetOutputOptionsPanel&quot;
+                   _label = &quot;Output Options&quot;
+                   class = &quot;VBBinding.OutputOptionsPanel&quot;/&gt;
+    &lt;/Conditional&gt;
+  &lt;/Extension&gt;
+
+  &lt;!-- &lt;Extension path = &quot;/SharpDevelop/Workbench/ProjectOptions/ConfigurationProperties&quot;&gt;
+    &lt;Conditional activeproject = &quot;VBNet&quot;&gt;
+      &lt;DialogPanel id = &quot;VBNetChooseRuntimePanel&quot;
+                   _label = &quot;Choose Runtime&quot;
+                   class = &quot;VBBinding.ChooseRuntimePanel&quot;/&gt;
+    &lt;/Conditional&gt;
+  &lt;/Extension&gt; --&gt;
+
+
+  &lt;Extension path = &quot;/Workspace/Icons&quot;&gt;
+    &lt;Icon id = &quot;VBPrj&quot;
+          language = &quot;VBNet&quot;
+          resource = &quot;VB.ProjectIcon&quot;/&gt;
+    &lt;Icon id = &quot;VBFile&quot;
+          extensions = &quot;.vb&quot;
+          resource = &quot;VB.FileIcon&quot;/&gt;
+  &lt;/Extension&gt;
+	
+	&lt;!-- &lt;Extension path = &quot;/AddIns/DefaultTextEditor/Formatter&quot;&gt;  
+  		&lt;Conditional textcontent = &quot;VBNet&quot;&gt;
+			&lt;Class id =&quot;VBNetFormatter&quot; insertbefore=&quot;DefaultFormatter&quot; class =&quot;VBBinding.FormattingStrategy.VBFormattingStrategy&quot;/&gt;
+		&lt;/Conditional&gt;
+	&lt;/Extension&gt; --&gt;
+
+  &lt;Extension path = &quot;/SharpDevelop/Workbench/LanguageBindings&quot;&gt;
+    &lt;LanguageBinding id = &quot;VBNet&quot;
+                     supportedextensions = &quot;.vb&quot;
+                     class = &quot;VBBinding.VBLanguageBinding&quot; /&gt;
+  &lt;/Extension&gt;
+&lt;/AddIn&gt;

Added: trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/EmptyVBFile.xft.xml
===================================================================
--- trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/EmptyVBFile.xft.xml	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/EmptyVBFile.xft.xml	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,20 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;Template Originator=&quot;Levi Bard&quot; Language=&quot;VBNet&quot; Created=&quot;10/19/2004&quot; LastModified=&quot;10/19/2004&quot;&gt;
+	
+	&lt;TemplateConfiguration&gt;
+                &lt;_Name&gt;Empty VB File&lt;/_Name&gt;
+                &lt;Icon&gt;VB.File.EmptyFile&lt;/Icon&gt;
+                &lt;Category&gt;VBNet&lt;/Category&gt;
+                &lt;LanguageName&gt;VBNet&lt;/LanguageName&gt;
+                &lt;_Description&gt;Creates an empty VB.Net file.&lt;/_Description&gt;
+	&lt;/TemplateConfiguration&gt;
+	
+	&lt;TemplateFiles&gt;
+        &lt;File DefaultExtension=&quot;.vb&quot; DefaultName=&quot;EmptyVBfile&quot;&gt;
+			&lt;![CDATA['created on ${Date} at ${Time}]]&gt;
+		&lt;/File&gt;
+	&lt;/TemplateFiles&gt;
+	
+	&lt;FileOptions/&gt;
+	
+&lt;/Template&gt;

Added: trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/EmptyVBProject.xpt.xml
===================================================================
--- trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/EmptyVBProject.xpt.xml	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/EmptyVBProject.xpt.xml	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,19 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;Template originator   = &quot;Levi Bard&quot; 
+          created      = &quot;10/19/2004&quot;
+          lastModified = &quot;10/19/2004&quot;&gt;
+	
+	&lt;!-- Template Header --&gt;
+	&lt;TemplateConfiguration&gt;
+                &lt;_Name&gt;Empty VB.NET Project&lt;/_Name&gt;
+                &lt;Category&gt;VBNet&lt;/Category&gt;
+                &lt;Icon&gt;VB.Project.EmptyProject&lt;/Icon&gt;
+                &lt;LanguageName&gt;VBNet&lt;/LanguageName&gt;
+                &lt;_Description&gt;Creates an empty VB.Net solution.&lt;/_Description&gt;
+	&lt;/TemplateConfiguration&gt;
+	
+	&lt;!-- Template Content --&gt;
+	&lt;Combine name = &quot;${ProjectName}&quot; directory = &quot;.&quot;&gt;
+		&lt;Project name = &quot;${ProjectName}&quot; directory = &quot;.&quot;/&gt;
+	&lt;/Combine&gt;
+&lt;/Template&gt;

Modified: trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/Makefile.am	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/Makefile.am	2004-11-10 18:03:32 UTC (rev 2023)
@@ -36,6 +36,9 @@
 NemerleEmptyProject.xpt.xml \
 NemerleGtkSharpProject.xpt.xml \
 NemerleGtkSharpWindow.xft.xml \
-AppConfigFile.xft.xml
+AppConfigFile.xft.xml \
+EmptyVBFile.xft.xml \
+EmptyVBProject.xpt.xml \
+VBConsoleApplicationProject.xpt.xml
 
 EXTRA_DIST = $(template_DATA)

Added: trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/VBConsoleApplicationProject.xpt.xml
===================================================================
--- trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/VBConsoleApplicationProject.xpt.xml	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/build/AddIns/AddIns/BackendBindings/templates/VBConsoleApplicationProject.xpt.xml	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,46 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;Template originator   = &quot;Levi Bard&quot; 
+          created      = &quot;10/19/2004&quot;
+          lastModified = &quot;10/23/2004&quot;&gt;
+	
+	&lt;!-- Template Header --&gt;
+	&lt;TemplateConfiguration&gt;
+		&lt;_Name&gt;VB.NET Console Project&lt;/_Name&gt;
+		&lt;Category&gt;VBNet&lt;/Category&gt;
+		&lt;Icon&gt;VB.Project.DOSProject&lt;/Icon&gt;
+		&lt;LanguageName&gt;VBNet&lt;/LanguageName&gt;
+		&lt;_Description&gt;Create a console VB.Net project&lt;/_Description&gt;
+	&lt;/TemplateConfiguration&gt;
+	
+	&lt;!-- Actions --&gt;
+	&lt;Actions&gt;
+		&lt;Open filename = &quot;application.vb&quot;/&gt;
+	&lt;/Actions&gt;
+
+	&lt;!-- Template Content --&gt;
+	&lt;Combine name = &quot;${ProjectName}&quot; directory = &quot;.&quot;&gt;
+		&lt;Options&gt;
+			&lt;StartupProject&gt;${ProjectName}&lt;/StartupProject&gt;
+		&lt;/Options&gt;
+		
+		&lt;Project name = &quot;${ProjectName}&quot; directory = &quot;.&quot;&gt;
+			&lt;!--  &lt;Options Target = &quot;Class&quot; PauseConsoleOutput = &quot;True&quot; /&gt; --&gt;
+	
+			&lt;Files&gt;
+				&lt;File name = &quot;application.vb&quot;&gt;
+&lt;![CDATA['''''
+'  application.vb
+' 
+'  created on ${Date} at ${Time}
+'''''
+
+Public Class application
+	Public Shared Sub Main()
+		System.Console.WriteLine(&quot;Hello world!&quot;)
+	End Sub
+End Class
+]]&gt;&lt;/File&gt;		
+			&lt;/Files&gt;
+		&lt;/Project&gt;
+	&lt;/Combine&gt;
+&lt;/Template&gt;

Modified: trunk/MonoDevelop/Core/configure.in
===================================================================
--- trunk/MonoDevelop/Core/configure.in	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/configure.in	2004-11-10 18:03:32 UTC (rev 2023)
@@ -157,6 +157,8 @@
 src/AddIns/BackendBindings/JavaBinding/Makefile
 src/AddIns/BackendBindings/ILAsmBinding/Makefile
 src/AddIns/BackendBindings/NemerleBinding/Makefile
+src/AddIns/BackendBindings/VBNetBinding/Makefile
+src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/Makefile
 src/AddIns/DisplayBindings/Makefile
 src/AddIns/DisplayBindings/SourceEditor/Makefile
 src/AddIns/DisplayBindings/SourceEditor/MonoDevelop.SourceEditor.dll.config

Added: trunk/MonoDevelop/Core/data/resources/glade/VB.glade
===================================================================
--- trunk/MonoDevelop/Core/data/resources/glade/VB.glade	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/data/resources/glade/VB.glade	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,1017 @@
+&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt; &lt;!--*- mode: xml -*--&gt;
+&lt;!DOCTYPE glade-interface SYSTEM &quot;<A HREF="http://glade.gnome.org/glade-2.0.dtd&quot;">http://glade.gnome.org/glade-2.0.dtd&quot;</A>&gt;
+
+&lt;glade-interface&gt;
+&lt;requires lib=&quot;gnome&quot;/&gt;
+
+&lt;widget class=&quot;GtkWindow&quot; id=&quot;CodeGenerationPanel&quot;&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;CodeGenerationPanel&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+
+  &lt;child&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox62&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;12&lt;/property&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkLabel&quot; id=&quot;label82&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Code Generation&amp;lt;/b&amp;gt;&lt;/property&gt;
+	  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox56&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label81&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox65&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkTable&quot; id=&quot;table7&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;n_rows&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;n_columns&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;row_spacing&quot;&gt;6&lt;/property&gt;
+		  &lt;property name=&quot;column_spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label86&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Compile _Target&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;CompileTargetOptionMenu&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label87&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Define S_ymbols&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;symbolsEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label88&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Main Class&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;mainClassEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;symbolsEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;mainClassEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkOptionMenu&quot; id=&quot;CompileTargetOptionMenu&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkLabel&quot; id=&quot;label90&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Warnings&amp;lt;/b&amp;gt;&lt;/property&gt;
+	  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox47&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label72&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox64&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox55&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label80&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Warning Level&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;warningLevelSpinButton&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkSpinButton&quot; id=&quot;warningLevelSpinButton&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;climb_rate&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;digits&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;numeric&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;update_policy&quot;&gt;GTK_UPDATE_ALWAYS&lt;/property&gt;
+		      &lt;property name=&quot;snap_to_ticks&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;adjustment&quot;&gt;2 0 4 1 1 1&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;generateOverflowChecksCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Generate overflow checks&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;allowUnsafeCodeCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Allow '_unsafe' code&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;enableOptimizationCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Enable _optimizations&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;warningsAsErrorsCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Treat warnings as _errors&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;generateXmlOutputCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Generate _xml documentation&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;widget class=&quot;GtkWindow&quot; id=&quot;OutputOptionsPanel&quot;&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;OutputOptionsPanel&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+
+  &lt;child&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox66&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;12&lt;/property&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox67&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label93&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Output&amp;lt;/b&amp;gt;&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox57&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;label91&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox69&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkTable&quot; id=&quot;table10&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;n_rows&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;n_columns&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;row_spacing&quot;&gt;6&lt;/property&gt;
+		      &lt;property name=&quot;column_spacing&quot;&gt;6&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label98&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Assembly _name&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;assemblyNameEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label99&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Output _path&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;outputDirectoryEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label100&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Paramet_ers&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;parametersEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;outputDirectoryEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;assemblyNameEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;parametersEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkCheckButton&quot; id=&quot;pauseConsoleOutputCheckButton&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Pause _console output&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		      &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox68&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label94&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Execute scripts &amp;lt;/b&amp;gt;&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox58&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;label92&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkTable&quot; id=&quot;table9&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;n_rows&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;n_columns&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;row_spacing&quot;&gt;6&lt;/property&gt;
+		  &lt;property name=&quot;column_spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label95&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Execute Command&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label96&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_After Build&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;executeAfterEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label97&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Before build&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;executeBeforeEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeScriptEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeAfterEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeBeforeEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton2&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton3&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton4&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;/glade-interface&gt;

Modified: trunk/MonoDevelop/Core/monodevelop.xml
===================================================================
--- trunk/MonoDevelop/Core/monodevelop.xml	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/monodevelop.xml	2004-11-10 18:03:32 UTC (rev 2023)
@@ -12,7 +12,7 @@
     &lt;comment xml:lang=&quot;en&quot;&gt;Nemerle source&lt;/comment&gt;
     &lt;glob pattern=&quot;*.n&quot;/&gt;
   &lt;/mime-type&gt;
-  &lt;mime-type type=&quot;text/x-vbnet&quot;&gt;
+  &lt;mime-type type=&quot;text/x-vb&quot;&gt;
     &lt;comment xml:lang=&quot;en&quot;&gt;VB source&lt;/comment&gt;
     &lt;glob pattern=&quot;*.vb&quot;/&gt;
   &lt;/mime-type&gt;

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding/ChangeLog	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding/ChangeLog	2004-11-10 18:03:32 UTC (rev 2023)
@@ -3,6 +3,11 @@
 	* CSharpBindingCompilerManager.cs: Use SAS for assembly detection.
 	This doesnt seem to break anything for me.
 
+2004-11-05  Levi Bard  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">taktaktaktaktaktaktaktaktaktak at gmail.com</A>&gt;
+      
+      * Parser/Parser.cs: Added HandlesFileExtension to work with new
+      IParser
+
 2004-11-01  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at off.net</A>&gt;
 
 	* CSharpBindingExecutionManager.cs.in: Add fu to actually properly run

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -113,6 +113,12 @@
 		{
 			return new Resolver (project).MonodocResolver (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 		}
+
+
+		public bool HandlesFileExtension(string fileExtension){
+			if(fileExtension == null) return false;
+			return (fileExtension.ToLower() == &quot;.cs&quot;);
+		}
 		
 		///////// IParser Interface END
 	}

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/JavaBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/JavaBinding/ChangeLog	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/JavaBinding/ChangeLog	2004-11-10 18:03:32 UTC (rev 2023)
@@ -1,3 +1,8 @@
+2004-11-05  Levi Bard  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">taktaktaktaktaktaktaktaktaktak at gmail.com</A>&gt;
+
+	* Parser/Parser.cs: Added HandlesFileExtension() to work with new
+	IParser
+
 2004-07-05  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jluke at cfl.rr.com</A>&gt;
 
 	* *.cs: cleanup everything

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/JavaBinding/Parser/Parser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/JavaBinding/Parser/Parser.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/JavaBinding/Parser/Parser.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -98,6 +98,13 @@
 		{
 			return new Resolver().Resolve(parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 		}
+
+
+		public bool HandlesFileExtension(string fileExtension){
+			if(fileExtension == null) return false;
+			return (fileExtension.ToLower() == &quot;.java&quot;);
+		}
+
 		
 		///////// IParser Interface END
 	}

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/Makefile.am	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/Makefile.am	2004-11-10 18:03:32 UTC (rev 2023)
@@ -1,3 +1,3 @@
 
-SUBDIRS = CSharpBinding JavaBinding NemerleBinding ILAsmBinding
+SUBDIRS = CSharpBinding JavaBinding NemerleBinding ILAsmBinding VBNetBinding
 

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,32 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+
+[assembly: AssemblyTitle(&quot;VB.NET Binding&quot;)]
+[assembly: AssemblyDescription(&quot;VB.NET language binding for monodevelop&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;www.monodevelop.com&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;(c) 2004 Markus Palme, MonoDevelop team, Levi Bard&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.1.1649&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,3 @@
+2004-11-05  Levi Bard  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">taktaktaktaktaktaktaktaktaktak at gmail.com</A>&gt;
+
+	* Imported from #D and made to work with MD tools and namespaces

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy/VBFormattingStrategy.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy/VBFormattingStrategy.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/FormattingStrategy/VBFormattingStrategy.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,476 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text.RegularExpressions;
+using System.Diagnostics;
+using System.Drawing;
+using System.Text;
+
+using MonoDevelop.TextEditor.Document;
+using MonoDevelop.TextEditor.Actions;
+using MonoDevelop.TextEditor;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+
+using MonoDevelop.EditorBindings.FormattingStrategy;
+
+namespace VBBinding.FormattingStrategy
+{
+	/// &lt;summary&gt;
+	/// This class handles the auto and smart indenting in the textbuffer while
+	/// you type.
+	/// &lt;/summary&gt;
+	public class VBFormattingStrategy : DefaultFormattingStrategy
+	{
+		ArrayList statements;
+		StringCollection keywords;
+		
+		bool doCasing;
+		bool doInsertion;
+		
+		public VBFormattingStrategy()
+		{
+			
+			statements = new ArrayList();
+			statements.Add(new VBStatement(&quot;^if.*?then$&quot;, &quot;^end ?if$&quot;, &quot;End If&quot;, 1));
+			statements.Add(new VBStatement(&quot;\\bclass \\w+$&quot;, &quot;^end class$&quot;, &quot;End Class&quot;, 1));
+			statements.Add(new VBStatement(&quot;\\bnamespace \\w+$&quot;, &quot;^end namespace$&quot;, &quot;End Namespace&quot;, 1));
+			statements.Add(new VBStatement(&quot;\\bmodule \\w+$&quot;, &quot;^end module$&quot;, &quot;End Module&quot;, 1));
+			statements.Add(new VBStatement(&quot;\\bstructure \\w+$&quot;, &quot;^end structure$&quot;, &quot;End Structure&quot;, 1));
+			statements.Add(new VBStatement(&quot;^while &quot;, &quot;^end while$&quot;, &quot;End While&quot;, 1));
+			statements.Add(new VBStatement(&quot;^select case&quot;, &quot;^end select$&quot;, &quot;End Select&quot;, 2));
+			statements.Add(new VBStatement(&quot;(?&lt;!\\bmustoverride )\\bsub \\w+&quot;, &quot;^end sub$&quot;, &quot;End Sub&quot;, 1));
+			statements.Add(new VBStatement(&quot;(?&lt;!\\bmustoverride (readonly |writeonly )?)\\bproperty \\w+&quot;, &quot;^end property$&quot;, &quot;End Property&quot;, 1));
+			statements.Add(new VBStatement(&quot;(?&lt;!\\bmustoverride )\\bfunction \\w+&quot;, &quot;^end function$&quot;, &quot;End Function&quot;, 1));
+			statements.Add(new VBStatement(&quot;\\bfor .*?$&quot;, &quot;^next( \\w+)?$&quot;, &quot;Next&quot;, 1));
+			statements.Add(new VBStatement(&quot;^synclock .*?$&quot;, &quot;^end synclock$&quot;, &quot;End SyncLock&quot;, 1));
+			statements.Add(new VBStatement(&quot;^get$&quot;, &quot;^end get$&quot;, &quot;End Get&quot;, 1));
+			statements.Add(new VBStatement(&quot;^with \\w+$&quot;, &quot;^end with$&quot;, &quot;End With&quot;, 1));
+			statements.Add(new VBStatement(&quot;^set\\s*\\(.*?\\)$&quot;, &quot;^end set$&quot;, &quot;End Set&quot;, 1));
+			statements.Add(new VBStatement(&quot;^try$&quot;, &quot;^end try$&quot;, &quot;End Try&quot;, 1));
+			statements.Add(new VBStatement(&quot;^do .+?$&quot;, &quot;^loop$&quot;, &quot;Loop&quot;, 1));
+			statements.Add(new VBStatement(&quot;^do$&quot;, &quot;^loop .+?$&quot;, &quot;Loop While &quot;, 1));
+			statements.Add(new VBStatement(&quot;\\benum .*?$&quot;, &quot;^end enum$&quot;, &quot;End Enum&quot;, 1));
+			
+			keywords = new StringCollection();
+			keywords.AddRange(new string[] {
+				&quot;AddHandler&quot;, &quot;AddressOf&quot;, &quot;Alias&quot;, &quot;And&quot;, &quot;AndAlso&quot;, &quot;Ansi&quot;, &quot;As&quot;, &quot;Assembly&quot;,
+				&quot;Auto&quot;, &quot;Boolean&quot;, &quot;ByRef&quot;, &quot;Byte&quot;, &quot;ByVal&quot;, &quot;Call&quot;, &quot;Case&quot;, &quot;Catch&quot;,
+				&quot;CBool&quot;, &quot;CByte&quot;, &quot;CChar&quot;, &quot;CDate&quot;, &quot;CDec&quot;, &quot;CDbl&quot;, &quot;Char&quot;, &quot;CInt&quot;, &quot;Class&quot;,
+				&quot;CLng&quot;, &quot;CObj&quot;, &quot;Const&quot;, &quot;CShort&quot;, &quot;CSng&quot;, &quot;CStr&quot;, &quot;CType&quot;,
+				&quot;Date&quot;, &quot;Decimal&quot;, &quot;Declare&quot;, &quot;Default&quot;, &quot;Delegate&quot;, &quot;Dim&quot;, &quot;DirectCast&quot;, &quot;Do&quot;,
+				&quot;Double&quot;, &quot;Each&quot;, &quot;Else&quot;, &quot;ElseIf&quot;, &quot;End&quot;, &quot;Enum&quot;, &quot;Erase&quot;, &quot;Error&quot;,
+				&quot;Event&quot;, &quot;Exit&quot;, &quot;False&quot;, &quot;Finally&quot;, &quot;For&quot;, &quot;Friend&quot;, &quot;Function&quot;, &quot;Get&quot;,
+				&quot;GetType&quot;, &quot;GoSub&quot;, &quot;GoTo&quot;, &quot;Handles&quot;, &quot;If&quot;, &quot;Implements&quot;, &quot;Imports&quot;, &quot;In&quot;,
+				&quot;Inherits&quot;, &quot;Integer&quot;, &quot;Interface&quot;, &quot;Is&quot;, &quot;Let&quot;, &quot;Lib&quot;, &quot;Like&quot;, &quot;Long&quot;,
+				&quot;Loop&quot;, &quot;Me&quot;, &quot;Mod&quot;, &quot;Module&quot;, &quot;MustInherit&quot;, &quot;MustOverride&quot;, &quot;MyBase&quot;, &quot;MyClass&quot;,
+				&quot;Namespace&quot;, &quot;New&quot;, &quot;Next&quot;, &quot;Not&quot;, &quot;Nothing&quot;, &quot;NotInheritable&quot;, &quot;NotOverridable&quot;, &quot;Object&quot;,
+				&quot;On&quot;, &quot;Option&quot;, &quot;Optional&quot;, &quot;Or&quot;, &quot;OrElse&quot;, &quot;Overloads&quot;, &quot;Overridable&quot;, &quot;Overrides&quot;,
+				&quot;ParamArray&quot;, &quot;Preserve&quot;, &quot;Private&quot;, &quot;Property&quot;, &quot;Protected&quot;, &quot;Public&quot;, &quot;RaiseEvent&quot;, &quot;ReadOnly&quot;,
+				&quot;ReDim&quot;, &quot;Region&quot;, &quot;REM&quot;, &quot;RemoveHandler&quot;, &quot;Resume&quot;, &quot;Return&quot;, &quot;Select&quot;, &quot;Set&quot;, &quot;Shadows&quot;,
+				&quot;Shared&quot;, &quot;Short&quot;, &quot;Single&quot;, &quot;Static&quot;, &quot;Step&quot;, &quot;Stop&quot;, &quot;String&quot;, &quot;Structure&quot;,
+				&quot;Sub&quot;, &quot;SyncLock&quot;, &quot;Then&quot;, &quot;Throw&quot;, &quot;To&quot;, &quot;True&quot;, &quot;Try&quot;, &quot;TypeOf&quot;,
+				&quot;Unicode&quot;, &quot;Until&quot;, &quot;Variant&quot;, &quot;When&quot;, &quot;While&quot;, &quot;With&quot;, &quot;WithEvents&quot;, &quot;WriteOnly&quot;, &quot;Xor&quot;
+			});
+		}
+		
+		/// &lt;summary&gt;
+		/// Define VB.net specific smart indenting for a line :)
+		/// &lt;/summary&gt;
+		protected override int SmartIndentLine(IFormattableDocument textArea, int lineNr)
+		{
+			PropertyService propertyService = (PropertyService)ServiceManager.GetService(typeof(PropertyService));
+			doCasing = propertyService.GetProperty(&quot;VBBinding.TextEditor.EnableCasing&quot;, true);
+			IFormattableDocument document = textArea;
+			if (lineNr &lt;= 0)
+				return AutoIndentLine(textArea, lineNr);
+			//LineSegment lineAbove = document.GetLineSegment(lineNr - 1);
+			//string lineAboveText = document.GetText(lineAbove.Offset, lineAbove.Length).Trim();
+			string lineAboveText=document.GetLineAsString(lineNr-1).Trim();
+			
+			//LineSegment curLine = document.GetLineSegment(lineNr);
+			//string oldLineText = document.GetText(curLine.Offset, curLine.Length);
+			string oldLineText=document.GetLineAsString(lineNr);
+			string curLineText = oldLineText.Trim();
+			
+			// remove comments
+			string texttoreplace = Regex.Replace(lineAboveText, &quot;'.*$&quot;, &quot;&quot;, RegexOptions.Singleline).Trim();
+			// remove string content
+			foreach (Match match in Regex.Matches(texttoreplace, &quot;\&quot;[^\&quot;]*?\&quot;&quot;)) {
+				texttoreplace = texttoreplace.Remove(match.Index, match.Length).Insert(match.Index, new String('-', match.Length));
+			}
+			
+			string curLineReplace = Regex.Replace(curLineText, &quot;'.*$&quot;, &quot;&quot;, RegexOptions.Singleline).Trim();
+			// remove string content
+			foreach (Match match in Regex.Matches(curLineReplace, &quot;\&quot;[^\&quot;]*?\&quot;&quot;)) {
+				curLineReplace = curLineReplace.Remove(match.Index, match.Length).Insert(match.Index, new String('-', match.Length));
+			}
+			
+			StringBuilder b = new StringBuilder(GetIndentation(textArea, lineNr - 1));
+			
+			//string indentString = Tab.GetIndentationString(document);
+			string indentString=&quot;\t&quot;;
+			
+			if (texttoreplace.IndexOf(':') &gt; 0)
+				texttoreplace = texttoreplace.Substring(0, texttoreplace.IndexOf(':')).TrimEnd();
+			
+			bool matched = false;
+			foreach (VBStatement statement in statements) {
+				if (statement.IndentPlus == 0) continue;
+				if (Regex.IsMatch(curLineReplace, statement.EndRegex, RegexOptions.IgnoreCase)) {
+					for (int i = 0; i &lt; statement.IndentPlus; ++i) {
+						RemoveIndent(b);
+					}
+					if (doCasing &amp;&amp; !statement.EndStatement.EndsWith(&quot; &quot;))
+						curLineText = statement.EndStatement;
+					matched = true;
+				}
+				if (Regex.IsMatch(texttoreplace, statement.StartRegex, RegexOptions.IgnoreCase)) {
+					for (int i = 0; i &lt; statement.IndentPlus; ++i) {
+						b.Append(indentString);
+					}
+					matched = true;
+				}
+				if (matched)
+					break;
+			}
+			
+			if (lineNr &gt;= 2) {
+				if (texttoreplace.EndsWith(&quot;_&quot;)) {
+					// Line continuation
+					char secondLastChar = ' ';
+					for (int i = texttoreplace.Length - 2; i &gt;= 0; --i) {
+						secondLastChar = texttoreplace[i];
+						if (!Char.IsWhiteSpace(secondLastChar))
+							break;
+					}
+					if (secondLastChar != '&gt;') {
+						// is not end of attribute
+						//LineSegment line2Above = document.GetLineSegment(lineNr - 2);
+						//string lineAboveText2 = document.GetText(line2Above.Offset, line2Above.Length).Trim();
+						string lineAboveText2=document.GetLineAsString(lineNr-2).Trim();
+						lineAboveText2 = Regex.Replace(lineAboveText2, &quot;'.*$&quot;, &quot;&quot;, RegexOptions.Singleline).Trim();
+						if (!lineAboveText2.EndsWith(&quot;_&quot;)) {
+							b.Append(indentString);
+						}
+					}
+				} else {
+					//LineSegment line2Above = document.GetLineSegment(lineNr - 2);
+					//string lineAboveText2 = document.GetText(line2Above.Offset, line2Above.Length).Trim();
+					string lineAboveText2=document.GetLineAsString(lineNr-2).Trim();
+					lineAboveText2 = StripComment(lineAboveText2);
+					if (lineAboveText2.EndsWith(&quot;_&quot;)) {
+						char secondLastChar = ' ';
+						for (int i = texttoreplace.Length - 2; i &gt;= 0; --i) {
+							secondLastChar = texttoreplace[i];
+							if (!Char.IsWhiteSpace(secondLastChar))
+								break;
+						}
+						if (secondLastChar != '&gt;')
+							RemoveIndent(b);
+					}
+				}
+			}
+			
+			if (IsElseConstruct(curLineText))
+				RemoveIndent(b);
+			
+			if (IsElseConstruct(lineAboveText))
+				b.Append(indentString);
+			
+			int indentLength = b.Length;
+			b.Append(curLineText);
+			if (b.ToString() != oldLineText)
+				textArea.ReplaceLine(lineNr, b.ToString());
+			return indentLength;
+		}
+		
+		bool IsElseConstruct(string line)
+		{
+			string t = StripComment(line).ToLower();
+			if (t.StartsWith(&quot;case &quot;)) return true;
+			if (t == &quot;else&quot; || t.StartsWith(&quot;elseif &quot;)) return true;
+			if (t == &quot;catch&quot; || t.StartsWith(&quot;catch &quot;)) return true;
+			if (t == &quot;finally&quot;) return true;
+			
+			return false;
+		}
+		
+		string StripComment(string text)
+		{
+			return Regex.Replace(text, &quot;'.*$&quot;, &quot;&quot;, RegexOptions.Singleline).Trim();
+		}
+		
+		void RemoveIndent(StringBuilder b)
+		{
+			if (b.Length == 0) return;
+			if (b[b.Length - 1] == '\t') {
+				b.Remove(b.Length - 1, 1);
+			} else {
+				for (int j = 0; j &lt; 4; ++j) {
+					if (b.Length == 0) return;
+					if (b[b.Length - 1] != ' ')
+						break;
+					b.Remove(b.Length - 1, 1);
+				}
+			}
+		}
+		
+		public override int FormatLine(IFormattableDocument textArea, int lineNr, int cursorOffset, char ch)
+		{
+			PropertyService propertyService = (PropertyService)ServiceManager.GetService(typeof(PropertyService));
+			doCasing = propertyService.GetProperty(&quot;VBBinding.TextEditor.EnableCasing&quot;, true);
+			doInsertion = propertyService.GetProperty(&quot;VBBinding.TextEditor.EnableEndConstructs&quot;, true);
+			
+			if (lineNr &gt; 0) {
+				//LineSegment curLine = textArea.Document.GetLineSegment(lineNr);
+				//LineSegment lineAbove = lineNr &gt; 0 ? textArea.Document.GetLineSegment(lineNr - 1) : null;
+				
+				//string curLineText = textArea.Document.GetText(curLine.Offset, curLine.Length);
+				//string lineAboveText = textArea.Document.GetText(lineAbove.Offset, lineAbove.Length);
+				string curLineText=textArea.GetLineAsString(lineNr).Trim();
+				string lineAboveText=textArea.GetLineAsString(lineNr-1).Trim();
+				
+				if (ch == '\n' &amp;&amp; lineAboveText != null) {
+					int undoCount = 1;
+					
+					// remove comments
+					string texttoreplace = Regex.Replace(lineAboveText, &quot;'.*$&quot;, &quot;&quot;, RegexOptions.Singleline);
+					// remove string content
+					MatchCollection strmatches = Regex.Matches(texttoreplace, &quot;\&quot;[^\&quot;]*?\&quot;&quot;, RegexOptions.Singleline);
+					foreach (Match match in strmatches) {
+						texttoreplace = texttoreplace.Remove(match.Index, match.Length).Insert(match.Index, new String('-', match.Length));
+					}
+					
+					if (doCasing) {
+						foreach (string keyword in keywords) {
+							string regex = &quot;(?:\\W|^)(&quot; + keyword + &quot;)(?:\\W|$)&quot;;
+							MatchCollection matches = Regex.Matches(texttoreplace, regex, RegexOptions.IgnoreCase | RegexOptions.Singleline);
+							foreach (Match match in matches) {
+								textArea.ReplaceLine(lineNr-1 + match.Groups[1].Index, keyword);
+								++undoCount;
+							}
+						}
+					}
+					
+					if (doInsertion) {
+						foreach (VBStatement statement in statements) {
+							if (Regex.IsMatch(texttoreplace.Trim(), statement.StartRegex, RegexOptions.IgnoreCase)) {
+								string indentation = GetIndentation(textArea, lineNr - 1);
+								if (isEndStatementNeeded(textArea, statement, lineNr)) {
+									//textArea.Insert(textArea.Caret.Offset, &quot;\n&quot; + indentation + statement.EndStatement);
+									//++undoCount;
+								}
+								for (int i = 0; i &lt; statement.IndentPlus; i++) {
+									indentation += &quot;\t&quot;;	//Tab.GetIndentationString(textArea.Document);
+								}
+								
+								textArea.ReplaceLine(lineNr, indentation + curLineText.Trim());
+								//Is this automagic now?
+								//textArea.Document.UndoStack.UndoLast(undoCount + 1);	
+								return indentation.Length;
+							}
+						}
+					}
+					
+					
+					if (IsInString(lineAboveText)) {
+						if (IsFinishedString(curLineText)) {
+							textArea.Insert(lineNr-1 + lineAboveText.Length,
+							                         &quot;\&quot; &amp; _&quot;);
+							curLineText = textArea.GetLineAsString(lineNr);
+							textArea.Insert(lineNr, &quot;\&quot;&quot;);
+							
+							if (IsElseConstruct(lineAboveText))
+								SmartIndentLine(textArea, lineNr - 1);
+							int result = SmartIndentLine(textArea, lineNr) + 1;
+							//textArea.UndoStack.UndoLast(undoCount + 3);
+							return result;
+						} else {
+							textArea.Insert(lineNr-1 + lineAboveText.Length,
+							                         &quot;\&quot;&quot;);
+							if (IsElseConstruct(lineAboveText))
+								SmartIndentLine(textArea, lineNr - 1);
+							int result = SmartIndentLine(textArea, lineNr);
+							//textArea.Document.UndoStack.UndoLast(undoCount + 2);
+							return result;
+						}
+					} else {
+						string indent = GetIndentation(textArea, lineNr - 1);
+						if (indent.Length &gt; 0) {
+							//string newLineText = indent + TextUtilities.GetLineAsString(textArea.Document, lineNr).Trim();
+							string newLineText=indent + textArea.GetLineAsString(lineNr).Trim();
+							//curLine = textArea.GetLineAsString(lineNr);
+							textArea.ReplaceLine(lineNr, newLineText);
+							//++undoCount;
+						}
+						if (IsElseConstruct(lineAboveText))
+							SmartIndentLine(textArea, lineNr - 1);
+						//textArea.Document.UndoStack.UndoLast(undoCount);
+						return indent.Length;
+					}
+				}
+			}
+			return 0;
+		}
+		
+		bool IsInString(string start)
+		{
+			bool inString = false;
+			for (int i = 0; i &lt; start.Length; i++) {
+				if (start[i] == '&quot;')
+					inString = !inString;
+				if (!inString &amp;&amp; start[i] == '\'')
+					return false;
+			}
+			return inString;
+		}
+		bool IsFinishedString(string end)
+		{
+			bool inString = true;
+			for (int i = 0; i &lt; end.Length; i++) {
+				if (end[i] == '&quot;')
+					inString = !inString;
+				if (!inString &amp;&amp; end[i] == '\'')
+					break;
+			}
+			return !inString;
+		}
+		
+		bool isEndStatementNeeded(IFormattableDocument textArea, VBStatement statement, int lineNr)
+		{
+			int count = 0;
+			int i=0;
+			
+			//for (int i = 0; i &lt; textArea.TotalNumberOfLines; i++) {
+			try{
+				while(true){
+					//LineSegment line = textArea.Document.GetLineSegment(i);
+					//string lineText = textArea.Document.GetText(line.Offset, line.Length).Trim();
+					string lineText=textArea.GetLineAsString(i++).Trim();
+					
+					if (lineText.StartsWith(&quot;'&quot;)) {
+						continue;
+					}
+					
+					if (Regex.IsMatch(lineText, statement.StartRegex, RegexOptions.IgnoreCase)) {
+						count++;
+					} else if (Regex.IsMatch(lineText, statement.EndRegex, RegexOptions.IgnoreCase)) {
+						count--;
+					}
+				}
+			} catch(Exception ex){
+				//exit while
+			}//try
+			return count &gt; 0;
+		}
+		
+		class VBStatement
+		{
+			public string StartRegex   = &quot;&quot;;
+			public string EndRegex     = &quot;&quot;;
+			public string EndStatement = &quot;&quot;;
+			
+			public int IndentPlus = 0;
+			
+			public VBStatement()
+			{
+			}
+			
+			public VBStatement(string startRegex, string endRegex, string endStatement, int indentPlus)
+			{
+				StartRegex = startRegex;
+				EndRegex   = endRegex;
+				EndStatement = endStatement;
+				IndentPlus   = indentPlus;
+			}
+		}
+		
+		
+		#region SearchBracket
+		public int SearchBracketBackward(IFormattableDocument document, int offset, char openBracket, char closingBracket)
+		{
+			bool inString  = false;
+			char ch;
+			int brackets = -1;
+			for (int i = offset; i &gt; 0; --i) {
+				ch = document.GetCharAt(i);
+				if (ch == openBracket &amp;&amp; !inString) {
+					++brackets;
+					if (brackets == 0) return i;
+				} else if (ch == closingBracket &amp;&amp; !inString) {
+					--brackets;
+				} else if (ch == '&quot;') {
+					inString = !inString;
+				} else if (ch == '\n') {
+					int lineStart = ScanLineStart(document, i);
+					if (lineStart &gt;= 0) { // line could have a comment
+						inString = false;
+						for (int j = lineStart; j &lt; i; ++j) {
+							ch = document.GetCharAt(j);
+							if (ch == '&quot;') inString = !inString;
+							if (ch == '\'' &amp;&amp; !inString) {
+								// comment found!
+								// Skip searching in the comment:
+								i = j;
+								break;
+							}
+						}
+					}
+					inString = false;
+				}
+			}
+			return -1;
+		}
+		
+		static int ScanLineStart(IFormattableDocument document, int offset)
+		{
+			bool hasComment = false;
+			for (int i = offset - 1; i &gt; 0; --i) {
+				char ch = document.GetCharAt(i);
+				if (ch == '\n') {
+					if (!hasComment) return -1;
+					return i + 1;
+				} else if (ch == '\'') {
+					hasComment = true;
+				}
+			}
+			return 0;
+		}
+		
+		public int SearchBracketForward(IFormattableDocument document, int offset, char openBracket, char closingBracket)
+		{
+			bool inString  = false;
+			bool inComment = false;
+			int  brackets  = 1;
+			for (int i = offset; i &lt; document.TextLength; ++i) {
+				char ch = document.GetCharAt(i);
+				if (ch == '\n') {
+					inString  = false;
+					inComment = false;
+				}
+				if (inComment) continue;
+				if (ch == '&quot;') inString = !inString;
+				if (inString)  continue;
+				if (ch == '\'') {
+					inComment = true;
+				} else if (ch == openBracket) {
+					++brackets;
+				} else if (ch == closingBracket) {
+					--brackets;
+					if (brackets == 0) return i;
+				}
+			}
+			return -1;
+		}
+		#endregion
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/ChooseRuntimePanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/ChooseRuntimePanel.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/ChooseRuntimePanel.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,136 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+using Gtk;
+using GLib;
+
+namespace VBBinding
+{
+	public class ChooseRuntimePanel : AbstractOptionPanel
+	{
+		VBCompilerParameters config = null;
+		// FIXME: set the right rb groups
+		RadioButton monoRadioButton;
+		RadioButton mintRadioButton;
+		RadioButton msnetRadioButton;
+	
+		RadioButton mbasRadioButton;
+		RadioButton vbcRadioButton;
+		
+		Label labelCompiler=new Label(GettextCatalog.GetString(&quot;Compiler:&quot;));
+		Label labelRuntime=new Label(GettextCatalog.GetString(&quot;Runtime:&quot;));
+
+		//For grouping
+		//SList compilers=new SList(null);
+		//SList runtimes=new SList(null);
+		
+		public ChooseRuntimePanel(): base(){
+			InitializeComponent ();						
+			VBox vbox = new VBox ();
+			//HBox hboxTitle = new HBox ();
+			//hboxTitle.PackStart (titleLabel, false, false, 0);
+			//vbox.PackStart (hboxTitle);
+			//vbox.PackStart (outputAssembly);
+			
+			HBox hboxCompiler = new HBox ();
+			hboxCompiler.PackStart (labelCompiler, false, false, 0);
+			vbox.PackStart (hboxCompiler);
+			VBox comps = new VBox ();
+			comps.PackStart (mbasRadioButton);
+			comps.PackStart (vbcRadioButton);
+			vbox.PackStart (comps);
+			//vbox.PackStart (compilerPath);
+			HBox hboxRuntime = new HBox ();
+			hboxRuntime.PackStart (labelRuntime, false, false, 0);
+			VBox runs=new VBox();
+			runs.PackStart(monoRadioButton);
+			runs.PackStart(mintRadioButton);
+			runs.PackStart(msnetRadioButton);
+			vbox.PackStart (hboxRuntime);
+			vbox.PackStart(runs);
+			/* HBox hboxClasspath = new HBox ();
+			hboxClasspath.PackStart (labelClasspath, false, false, 0);
+			vbox.PackStart (hboxClasspath);
+			vbox.PackStart (classPath);
+			HBox hboxMainClass = new HBox ();
+			hboxMainClass.PackStart (labelMainClass, false, false, 0);
+			vbox.PackStart (hboxMainClass);
+			vbox.PackStart (mainClass);
+			HBox hboxWarnings = new HBox ();
+			hboxWarnings.PackStart (labelWarnings, false, false, 0);
+			vbox.PackStart (hboxWarnings);
+			HBox hbox = new HBox ();
+			hbox.PackStart (checkDeprecation);
+			hbox.PackStart (checkDebug);
+			hbox.PackStart (checkOptimize);
+			vbox.PackStart (hbox);
+			HBox hboxOutput = new HBox ();
+			hboxOutput.PackStart (labelOutput, false, false, 0);
+			vbox.PackStart (hboxOutput);
+			vbox.PackStart (outputDirectory); */
+			this.Add (vbox);
+		}
+		
+		private void InitializeComponent(){
+		/*	runtimes.Append(monoRadioButton);
+			runtimes.Append(mintRadioButton);
+			runtimes.Append(msnetRadioButton);
+			compilers.Append(mbasRadioButton);
+			compilers.Append(vbcRadioButton);
+			
+			msnetRadioButton.Group=runtimes;
+			monoRadioButton.Group=runtimes;
+			mintRadioButton.Group=runtimes;
+			vbcRadioButton.Group=compilers;
+			mbasRadioButton.Group=compilers; */
+			
+			monoRadioButton = new RadioButton (&quot;Mono&quot;);
+			mintRadioButton = new RadioButton (monoRadioButton,&quot;Mint&quot;);
+			msnetRadioButton = new RadioButton (monoRadioButton,&quot;Msnet&quot;);
+		
+			mbasRadioButton = new RadioButton (&quot;MBAS&quot;);
+			vbcRadioButton = new RadioButton (mbasRadioButton,&quot;VBC&quot;);
+		}
+		
+		public override void LoadPanelContents()
+		{
+			this.config = (VBCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+			
+			msnetRadioButton.Active = config.NetRuntime == NetRuntime.MsNet;
+			monoRadioButton.Active  = config.NetRuntime == NetRuntime.Mono;
+			mintRadioButton.Active  = config.NetRuntime == NetRuntime.MonoInterpreter;
+			
+			vbcRadioButton.Active = config.VBCompiler == VBCompiler.Vbc;
+			mbasRadioButton.Active = config.VBCompiler == VBCompiler.Mbas;
+		}
+		
+		public override bool StorePanelContents()
+		{
+			if (msnetRadioButton.Active) {
+				config.NetRuntime =  NetRuntime.MsNet;
+			} else if (monoRadioButton.Active) {
+				config.NetRuntime =  NetRuntime.Mono;
+			} else {
+				config.NetRuntime =  NetRuntime.MonoInterpreter;
+			}
+			config.VBCompiler = vbcRadioButton.Active ? VBCompiler.Vbc : VBCompiler.Mbas;
+			
+			return true;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/CodeGenerationPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/CodeGenerationPanel.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/CodeGenerationPanel.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,215 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.ExternalTool;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.AddIns.Codons;
+
+using Gtk;
+using MonoDevelop.Gui.Widgets;
+using MonoDevelop.Services;
+
+namespace VBBinding
+{
+	public class CodeGenerationPanel : AbstractOptionPanel
+	{
+		VBCompilerParameters compilerParameters = null;
+	
+		/*
+		
+		ResourceService resourceService = (ResourceService)ServiceManager.GetService(typeof(IResourceService));
+		static FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
+		
+		public override bool ReceiveDialogMessage(DialogMessage message)
+		{
+			if (message == DialogMessage.OK) {
+				if (compilerParameters == null) {
+					return true;
+				}
+				FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
+				
+				
+				compilerParameters.DefineSymbols = ControlDictionary[&quot;symbolsTextBox&quot;].Text;
+				compilerParameters.MainClass     = ControlDictionary[&quot;mainClassTextBox&quot;].Text;
+				compilerParameters.Imports       = ControlDictionary[&quot;importsTextBox&quot;].Text;
+				compilerParameters.RootNamespace = ControlDictionary[&quot;RootNamespaceTextBox&quot;].Text;
+				
+				compilerParameters.Debugmode = ((CheckBox)ControlDictionary[&quot;generateDebugInformationCheckBox&quot;]).Checked;
+				compilerParameters.Optimize = ((CheckBox)ControlDictionary[&quot;enableOptimizationCheckBox&quot;]).Checked;
+				compilerParameters.GenerateOverflowChecks = ((CheckBox)ControlDictionary[&quot;generateOverflowChecksCheckBox&quot;]).Checked;
+				compilerParameters.TreatWarningsAsErrors  = ((CheckBox)ControlDictionary[&quot;warningsAsErrorsCheckBox&quot;]).Checked;
+				
+				compilerParameters.OptionExplicit = ((CheckBox)ControlDictionary[&quot;optionExplicitCheckBox&quot;]).Checked ;
+				compilerParameters.OptionStrict = ((CheckBox)ControlDictionary[&quot;optionStrictCheckBox&quot;]).Checked;
+			}
+			return true;
+		}
+		
+		void SetValues(object sender, EventArgs e)
+		{
+			this.compilerParameters = (VBCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+			
+			ControlDictionary[&quot;symbolsTextBox&quot;].Text = compilerParameters.DefineSymbols;
+			ControlDictionary[&quot;mainClassTextBox&quot;].Text = compilerParameters.MainClass;
+			ControlDictionary[&quot;importsTextBox&quot;].Text = compilerParameters.Imports;
+			ControlDictionary[&quot;RootNamespaceTextBox&quot;].Text = compilerParameters.RootNamespace;
+			
+			
+			((CheckBox)ControlDictionary[&quot;generateDebugInformationCheckBox&quot;]).Checked = compilerParameters.Debugmode;
+			((CheckBox)ControlDictionary[&quot;enableOptimizationCheckBox&quot;]).Checked = compilerParameters.Optimize;
+			((CheckBox)ControlDictionary[&quot;generateOverflowChecksCheckBox&quot;]).Checked = compilerParameters.GenerateOverflowChecks;
+			((CheckBox)ControlDictionary[&quot;warningsAsErrorsCheckBox&quot;]).Checked = compilerParameters.TreatWarningsAsErrors;
+			
+			((CheckBox)ControlDictionary[&quot;optionExplicitCheckBox&quot;]).Checked = compilerParameters.OptionExplicit;
+			((CheckBox)ControlDictionary[&quot;optionStrictCheckBox&quot;]).Checked = compilerParameters.OptionStrict;
+		}
+		
+		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		public CodeGenerationPanel() : base(propertyService.DataDirectory + @&quot;\resources\panels\ProjectOptions\VBNetCodeGenerationPanel.xfrm&quot;)
+		{
+			CustomizationObjectChanged += new EventHandler(SetValues);
+			
+		}
+		*/
+		
+			/* public override bool ReceiveDialogMessage(DialogMessage message)
+			{
+				if (message == DialogMessage.OK) {
+					return widget.Store();
+				}
+				return true;
+			}
+
+		
+			void SetValues(object sender, EventArgs e){
+				LoadPanelContents();		
+			}
+			
+		public CodeGenerationPanel() : base()
+		{
+			CustomizationObjectChanged += new EventHandler(SetValues);
+		} */
+
+
+		
+		class CodeGenerationPanelWidget : GladeWidgetExtract 
+		{
+			//
+			// Gtk Controls	
+			//
+ 			[Glade.Widget] Entry symbolsEntry;
+ 			[Glade.Widget] Entry mainClassEntry;
+			[Glade.Widget] OptionMenu CompileTargetOptionMenu;
+ 			[Glade.Widget] CheckButton generateOverflowChecksCheckButton;
+			[Glade.Widget] CheckButton allowUnsafeCodeCheckButton;
+ 			[Glade.Widget] CheckButton enableOptimizationCheckButton;
+ 			[Glade.Widget] CheckButton warningsAsErrorsCheckButton;
+//			[Glade.Widget] CheckButton generateDebugInformationCheckButton;
+ 			[Glade.Widget] CheckButton generateXmlOutputCheckButton;
+ 			[Glade.Widget] SpinButton warningLevelSpinButton;
+
+			//
+			// services needed
+			//
+			StringParserService StringParserService = (StringParserService)ServiceManager.GetService (
+				typeof (StringParserService));
+
+			VBCompilerParameters compilerParameters = null;
+			
+			//static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+			
+
+ 			public  CodeGenerationPanelWidget(IProperties CustomizationObject) : base (&quot;VB.glade&quot;, &quot;CodeGenerationPanel&quot;)
+ 			{	
+ 				compilerParameters=(VBCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+				SetValues();
+				//CustomizationObjectChanged += new EventHandler(SetValues);
+ 			}
+ 			
+			public void SetValues(){
+				//this.compilerParameters = (VBCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+
+				// FIXME: Enable when mbas has this feature
+				generateXmlOutputCheckButton.Sensitive = false;
+				
+
+				//string[] compileTargets=new string[]{GettextCatalog.GetString (&quot;Executable&quot;),GettextCatalog.GetString(&quot;WinEXE&quot;),	GettextCatalog.GetString (&quot;Library&quot;),GettextCatalog.GetString (&quot;Module&quot;)};
+
+				Menu CompileTargetMenu = new Menu ();
+				CompileTargetMenu.Add(new MenuItem(GettextCatalog.GetString (&quot;Executable&quot;)));
+				CompileTargetMenu.Add(new MenuItem(GettextCatalog.GetString(&quot;WinEXE&quot;)));
+				CompileTargetMenu.Add(new MenuItem(GettextCatalog.GetString (&quot;Library&quot;)));
+				CompileTargetMenu.Add(new MenuItem(GettextCatalog.GetString (&quot;Module&quot;))); 
+				// FIXME commented until the Module capability is ported
+// 				CompileTargetMenu.Append(new MenuItem(
+// 								 StringParserService.Parse(
+// 									 &quot;${res:Dialog.Options.PrjOptions.Configuration.CompileTarget.Module}&quot;)));
+
+				CompileTargetOptionMenu.Menu=CompileTargetMenu;
+				CompileTargetOptionMenu.SetHistory ( (uint) compilerParameters.CompileTarget);
+				//CompileTargetOptionMenu.Active=(int)compilerParameters.CompileTarget;
+
+				symbolsEntry.Text = compilerParameters.DefineSymbols;
+				mainClassEntry.Text = compilerParameters.MainClass;
+
+//				generateDebugInformationCheckButton.Active = compilerParameters.Debugmode;
+				generateXmlOutputCheckButton.Active        = compilerParameters.GenerateXmlDocumentation;
+				enableOptimizationCheckButton.Active       = compilerParameters.Optimize;
+				allowUnsafeCodeCheckButton.Active          = compilerParameters.UnsafeCode;
+				generateOverflowChecksCheckButton.Active   = compilerParameters.GenerateOverflowChecks;
+				warningsAsErrorsCheckButton.Active         = ! compilerParameters.RunWithWarnings;
+				warningLevelSpinButton.Value               = compilerParameters.WarningLevel;		
+			} 
+
+
+			public bool Store ()
+			{	
+				if (compilerParameters == null) {
+					System.Console.WriteLine(&quot;NULL compiler parameters for VBNet!&quot;);
+					return true;
+				}
+				//compilerParameters.CompileTarget =  (CompileTarget)  CompileTargetOptionMenu.History;
+				compilerParameters.CompileTarget=(CompileTarget)CompileTargetOptionMenu.History;
+				compilerParameters.DefineSymbols =  symbolsEntry.Text;
+				compilerParameters.MainClass     =  mainClassEntry.Text;
+
+//				compilerParameters.Debugmode                = generateDebugInformationCheckButton.Active;
+				compilerParameters.GenerateXmlDocumentation = generateXmlOutputCheckButton.Active;
+				compilerParameters.Optimize                 = enableOptimizationCheckButton.Active;
+				compilerParameters.UnsafeCode               = allowUnsafeCodeCheckButton.Active;
+				compilerParameters.GenerateOverflowChecks   = generateOverflowChecksCheckButton.Active;
+				compilerParameters.RunWithWarnings          = ! warningsAsErrorsCheckButton.Active;
+
+				compilerParameters.WarningLevel = warningLevelSpinButton.ValueAsInt;
+
+				return true;
+			}
+		}//CodeGenerationPanelWidget
+				
+		CodeGenerationPanelWidget widget;
+		
+		public override void LoadPanelContents()
+		{
+			Add (widget = new  CodeGenerationPanelWidget ((IProperties) CustomizationObject));
+		}
+		
+		public override bool StorePanelContents()
+		{
+			bool result = true;
+			result = widget.Store ();
+ 			return result;
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,66 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Windows.Forms;
+
+namespace VBBinding
+{
+	[Serializable()]
+	class GuiMessageRecipient : IMessageRecipient
+	{
+		class StatusForm : Form
+		{
+			Label statusLabel;
+			
+			public StatusForm()
+			{
+				this.Text = &quot;VB.DOC status&quot;;
+				this.ControlBox = false;
+				this.StartPosition = FormStartPosition.CenterScreen;
+				this.ShowInTaskbar = false;
+				
+				this.Size = new System.Drawing.Size(400, 50);
+				
+				statusLabel = new Label();
+				statusLabel.Dock = DockStyle.Fill;
+				statusLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
+				Controls.Add(statusLabel);
+			}
+			
+			public void Status(string statusMessage)
+			{
+				statusLabel.Text = statusMessage;
+				Application.DoEvents();
+			}
+		}
+		
+		StatusForm messageForm;
+		
+		public GuiMessageRecipient()
+		{
+			messageForm = new StatusForm();
+			messageForm.Show();
+		}
+		
+		public void Finished()
+		{
+			messageForm.Close();
+		}
+		
+		public void DisplayStatusMessage(string message)
+		{
+			messageForm.Status(message);
+		}
+		
+		public void DisplayErrorMessage(string message)
+		{
+			// message doesn't work in this app domain
+			System.Windows.Forms.MessageBox.Show(message);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/OutputOptionsPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/OutputOptionsPanel.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/OutputOptionsPanel.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,303 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+
+using Gtk;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.ExternalTool;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Gui.Widgets;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Services;
+
+namespace VBBinding
+{
+	public class OutputOptionsPanel : AbstractOptionPanel
+	{
+		VBCompilerParameters compilerParameters;
+		static FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
+		StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+		
+		/* public override bool ReceiveDialogMessage(DialogMessage message)
+		{
+			if (message == DialogMessage.OK) {
+				if (compilerParameters == null) {
+					return true;
+				}
+				
+				FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+				if (!fileUtilityService.IsValidFileName(ControlDictionary[&quot;assemblyNameTextBox&quot;].Text)) {
+					MessageBox.Show(&quot;Invalid assembly name specified&quot;, &quot;Error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button1);
+					return false;
+				}
+				if (!fileUtilityService.IsValidFileName(ControlDictionary[&quot;outputDirectoryTextBox&quot;].Text)) {
+					MessageBox.Show(&quot;Invalid output directory specified&quot;, &quot;Error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button1);
+					return false;
+				}
+				
+				if (ControlDictionary[&quot;win32IconTextBox&quot;].Text.Length &gt; 0) {
+					if (!fileUtilityService.IsValidFileName(ControlDictionary[&quot;win32IconTextBox&quot;].Text)) {
+						MessageBox.Show(&quot;Invalid Win32Icon specified&quot;, &quot;Error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button1);
+						return false;
+					}
+					if (!File.Exists(ControlDictionary[&quot;win32IconTextBox&quot;].Text)) {
+						MessageBox.Show(&quot;Win32Icon doesn't exists&quot;, &quot;Error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button1);
+						return false;
+					}
+				}
+				
+				compilerParameters.CompileTarget               = (CompileTarget)((ComboBox)ControlDictionary[&quot;compileTargetComboBox&quot;]).SelectedIndex;
+				compilerParameters.OutputAssembly              = ControlDictionary[&quot;assemblyNameTextBox&quot;].Text;
+				compilerParameters.OutputDirectory             = ControlDictionary[&quot;outputDirectoryTextBox&quot;].Text;
+				compilerParameters.CommandLineParameters       = ControlDictionary[&quot;parametersTextBox&quot;].Text;
+				compilerParameters.ExecuteBeforeBuild          = ControlDictionary[&quot;executeBeforeTextBox&quot;].Text;
+				compilerParameters.ExecuteAfterBuild           = ControlDictionary[&quot;executeAfterTextBox&quot;].Text;
+				compilerParameters.ExecuteScript               = ControlDictionary[&quot;executeScriptTextBox&quot;].Text;
+				compilerParameters.Win32Icon                   = ControlDictionary[&quot;win32IconTextBox&quot;].Text;
+				compilerParameters.ExecuteBeforeBuildArguments = ControlDictionary[&quot;executeBeforeArgumentsTextBox&quot;].Text;
+				compilerParameters.ExecuteAfterBuildArguments  = ControlDictionary[&quot;executeAfterArgumentsTextBox&quot;].Text;
+				
+				compilerParameters.PauseConsoleOutput = ((CheckBox)ControlDictionary[&quot;pauseConsoleOutputCheckBox&quot;]).Checked;
+			}
+			return true;
+		}
+	
+		void SetValues(object sender, EventArgs e)
+		{
+			this.compilerParameters = (VBCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+			
+			((ComboBox)ControlDictionary[&quot;compileTargetComboBox&quot;]).SelectedIndex = (int)compilerParameters.CompileTarget;
+			ControlDictionary[&quot;win32IconTextBox&quot;].Text              = compilerParameters.Win32Icon;
+			ControlDictionary[&quot;assemblyNameTextBox&quot;].Text           = compilerParameters.OutputAssembly;
+			ControlDictionary[&quot;outputDirectoryTextBox&quot;].Text        = compilerParameters.OutputDirectory;
+			ControlDictionary[&quot;parametersTextBox&quot;].Text             = compilerParameters.CommandLineParameters;
+			ControlDictionary[&quot;executeScriptTextBox&quot;].Text          = compilerParameters.ExecuteScript;
+			ControlDictionary[&quot;executeBeforeTextBox&quot;].Text          = compilerParameters.ExecuteBeforeBuild;
+			ControlDictionary[&quot;executeAfterTextBox&quot;].Text           = compilerParameters.ExecuteAfterBuild;
+			ControlDictionary[&quot;executeBeforeArgumentsTextBox&quot;].Text = compilerParameters.ExecuteBeforeBuildArguments;
+			ControlDictionary[&quot;executeAfterArgumentsTextBox&quot;].Text  = compilerParameters.ExecuteAfterBuildArguments;
+			
+			((CheckBox)ControlDictionary[&quot;pauseConsoleOutputCheckBox&quot;]).Checked = compilerParameters.PauseConsoleOutput;
+		}
+		
+		void SelectFolder(object sender, EventArgs e)
+		{
+			FolderDialog fdiag = new  FolderDialog();
+			
+			if (fdiag.DisplayDialog(&quot;${res:Dialog.Options.PrjOptions.Configuration.FolderBrowserDescription}&quot;) == DialogResult.OK) {
+				ControlDictionary[&quot;outputDirectoryTextBox&quot;].Text = fdiag.Path;
+			}
+		}
+		
+		void SelectFile2(object sender, EventArgs e)
+		{
+			OpenFileDialog fdiag = new OpenFileDialog();
+			fdiag.Filter      = stringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+			fdiag.Multiselect = false;
+			
+			if(fdiag.ShowDialog() == DialogResult.OK) {
+				ControlDictionary[&quot;executeBeforeTextBox&quot;].Text = fdiag.FileName;
+			}
+		}
+		
+		void SelectFile3(object sender, EventArgs e)
+		{
+			OpenFileDialog fdiag = new OpenFileDialog();
+			fdiag.Filter      = stringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+			fdiag.Multiselect = false;
+			
+			if(fdiag.ShowDialog() == DialogResult.OK) {
+				ControlDictionary[&quot;executeAfterTextBox&quot;].Text = fdiag.FileName;
+			}
+		}
+		void SelectFile4(object sender, EventArgs e)
+		{
+			OpenFileDialog fdiag = new OpenFileDialog();
+			fdiag.Filter      = stringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+			fdiag.Multiselect = false;
+			
+			if(fdiag.ShowDialog() == DialogResult.OK) {
+				ControlDictionary[&quot;executeScriptTextBox&quot;].Text = fdiag.FileName;
+			}
+		}
+		void SelectWin32Icon(object sender, EventArgs e) 
+		{
+			using (OpenFileDialog fdiag  = new OpenFileDialog()) {
+				fdiag.AddExtension    = true;
+				fdiag.Filter = stringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.Icons}|*.ico|${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+				fdiag.Multiselect     = false;
+				fdiag.CheckFileExists = true;
+				
+				if (fdiag.ShowDialog() == DialogResult.OK) {
+					ControlDictionary[&quot;win32IconTextBox&quot;].Text = fdiag.FileName;
+				}
+			}
+		}
+		
+		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		public OutputOptionsPanel() : base(propertyService.DataDirectory + @&quot;\resources\panels\ProjectOptions\OutputPanel.xfrm&quot;)
+		{
+			CustomizationObjectChanged += new EventHandler(SetValues);
+			ControlDictionary[&quot;browseButton&quot;].Click += new EventHandler(SelectFolder);
+			ControlDictionary[&quot;browseButton2&quot;].Click += new EventHandler(SelectFile2);
+			ControlDictionary[&quot;browseButton3&quot;].Click += new EventHandler(SelectFile3);
+			ControlDictionary[&quot;browseButton4&quot;].Click += new EventHandler(SelectFile4);
+			ControlDictionary[&quot;browseWin32IconButton&quot;].Click += new EventHandler(SelectWin32Icon);
+			
+			ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+			((ComboBox)ControlDictionary[&quot;compileTargetComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.CompileTarget.Exe&quot;));
+			((ComboBox)ControlDictionary[&quot;compileTargetComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.CompileTarget.WinExe&quot;));
+			((ComboBox)ControlDictionary[&quot;compileTargetComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.CompileTarget.Library&quot;));
+			((ComboBox)ControlDictionary[&quot;compileTargetComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.CompileTarget.Module&quot;));
+			
+		}
+	} */
+	
+			static MessageService messageService = (MessageService) ServiceManager.GetService (typeof (MessageService));
+
+		class OutputOptionsPanelWidget : GladeWidgetExtract 
+		{
+			//
+			// Gtk Controls	
+			//
+			[Glade.Widget] Entry assemblyNameEntry;
+			[Glade.Widget] Entry outputDirectoryEntry;
+			[Glade.Widget] Entry parametersEntry;
+			[Glade.Widget] Entry executeBeforeEntry;
+			[Glade.Widget] Entry executeScriptEntry;
+			[Glade.Widget] Entry executeAfterEntry;
+			[Glade.Widget] CheckButton pauseConsoleOutputCheckButton;			
+			[Glade.Widget] Button browseButton;
+			[Glade.Widget] Button browseButton2;
+			[Glade.Widget] Button browseButton3;
+			[Glade.Widget] Button browseButton4;
+			
+			VBCompilerParameters compilerParameters;
+
+			public  OutputOptionsPanelWidget(IProperties CustomizationObject) : base (&quot;VB.glade&quot;, &quot;OutputOptionsPanel&quot;)
+ 			{			
+				this.compilerParameters = (VBCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+				browseButton.Clicked += new EventHandler (SelectFolder);
+				browseButton2.Clicked += new EventHandler (SelectFile4);
+				browseButton3.Clicked += new EventHandler (SelectFile3);
+				browseButton4.Clicked += new EventHandler (SelectFile2);
+				
+				assemblyNameEntry.Text = compilerParameters.OutputAssembly;
+				outputDirectoryEntry.Text = compilerParameters.OutputDirectory;
+				parametersEntry.Text      = compilerParameters.CommandLineParameters;
+				executeScriptEntry.Text   = compilerParameters.ExecuteScript;
+ 				executeBeforeEntry.Text   = compilerParameters.ExecuteBeforeBuild;
+ 				executeAfterEntry.Text    = compilerParameters.ExecuteAfterBuild;
+				
+ 				pauseConsoleOutputCheckButton.Active = compilerParameters.PauseConsoleOutput;
+			}
+
+			public bool Store ()
+			{	
+				if (compilerParameters == null) {
+					return true;
+				}
+				
+				FileUtilityService fileUtilityService = (FileUtilityService) ServiceManager.GetService (typeof (FileUtilityService));
+
+				if (!fileUtilityService.IsValidFileName(assemblyNameEntry.Text)) {
+					messageService.ShowError (GettextCatalog.GetString (&quot;Invalid assembly name specified&quot;));
+					return false;
+				}
+
+				if (!fileUtilityService.IsValidFileName (outputDirectoryEntry.Text)) {
+					messageService.ShowError (GettextCatalog.GetString (&quot;Invalid output directory specified&quot;));
+					return false;
+				}
+				
+				compilerParameters.OutputAssembly = assemblyNameEntry.Text;
+				compilerParameters.OutputDirectory = outputDirectoryEntry.Text;
+				compilerParameters.CommandLineParameters = parametersEntry.Text;
+				compilerParameters.ExecuteBeforeBuild = executeBeforeEntry.Text;
+				compilerParameters.ExecuteAfterBuild = executeAfterEntry.Text;
+				compilerParameters.ExecuteScript = executeScriptEntry.Text;
+				
+				compilerParameters.PauseConsoleOutput = pauseConsoleOutputCheckButton.Active;
+				return true;
+			}
+			
+			void SelectFolder(object sender, EventArgs e)
+			{
+				using (FileSelector fdiag = new FileSelector (GettextCatalog.GetString (&quot;Select the directory in which the assembly will be created&quot;))) {
+					if (fdiag.Run () == (int) ResponseType.Ok) {
+						outputDirectoryEntry.Text = fdiag.Filename;
+					}
+				
+					fdiag.Hide ();
+				}
+			}
+		
+			void SelectFile2(object sender, EventArgs e)
+			{
+				using (FileSelector fdiag = new FileSelector (&quot;&quot;)) {
+					//fdiag.Filter = StringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+					fdiag.SelectMultiple = false;
+				
+					if(fdiag.Run () == (int) ResponseType.Ok) {
+						executeBeforeEntry.Text = fdiag.Filename;
+					}
+
+					fdiag.Hide ();
+				}
+			}
+			
+			void SelectFile3(object sender, EventArgs e)
+			{
+				using (FileSelector fdiag = new FileSelector (&quot;&quot;)) {
+					//fdiag.Filter = StringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+					fdiag.SelectMultiple = false;
+				
+					if(fdiag.Run () == (int) ResponseType.Ok) {
+						executeAfterEntry.Text = fdiag.Filename;
+					}
+
+					fdiag.Hide ();
+				}
+			}
+		
+			void SelectFile4(object sender, EventArgs e)
+			{
+				using (FileSelector fdiag = new FileSelector (&quot;&quot;)) {
+					//fdiag.Filter = StringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+					fdiag.SelectMultiple = false;
+				
+					if(fdiag.Run () == (int) ResponseType.Ok) {
+						executeScriptEntry.Text = fdiag.Filename;
+					}
+
+					fdiag.Hide ();
+				}
+			}
+		}
+
+		OutputOptionsPanelWidget  widget;
+
+		public override void LoadPanelContents()
+		{
+			Add (widget = new  OutputOptionsPanelWidget ((IProperties) CustomizationObject));
+		}
+		
+		public override bool StorePanelContents()
+		{
+			bool result = true;
+			result = widget.Store ();
+ 			return result;
+		}
+	}
+
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,39 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.ExternalTool;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.AddIns.Codons;
+
+namespace VBBinding
+{
+	public class TextEditorOptionsPanel : AbstractOptionPanel
+	{
+		public override void LoadPanelContents()
+		{
+			SetupFromXml(Path.Combine(PropertyService.DataDirectory, 
+			                          @&quot;resources\panels\VBSpecificTextEditorOptions.xfrm&quot;));
+			((CheckBox)ControlDictionary[&quot;enableEndConstructsCheckBox&quot;]).Checked   = PropertyService.GetProperty(&quot;VBBinding.TextEditor.EnableEndConstructs&quot;, true);
+			((CheckBox)ControlDictionary[&quot;enableCasingCheckBox&quot;]).Checked = PropertyService.GetProperty(&quot;VBBinding.TextEditor.EnableCasing&quot;, true);
+		}
+		
+		public override bool StorePanelContents()
+		{
+			PropertyService.SetProperty(&quot;VBBinding.TextEditor.EnableEndConstructs&quot;, ((CheckBox)ControlDictionary[&quot;enableEndConstructsCheckBox&quot;]).Checked);
+			PropertyService.SetProperty(&quot;VBBinding.TextEditor.EnableCasing&quot;, ((CheckBox)ControlDictionary[&quot;enableCasingCheckBox&quot;]).Checked);
+			
+			return true;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,49 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+using System.Collections;
+using System.ComponentModel;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Core.Properties;
+
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.Services;
+
+namespace VBBinding
+{
+	public class VBCompilerPanel : AbstractOptionPanel
+	{
+		VBCompilerParameters config = null;
+		
+		public override void LoadPanelContents()
+		{
+			SetupFromXml(Path.Combine(PropertyService.DataDirectory, 
+			                          @&quot;resources\panels\VBCompilerPanel.xfrm&quot;));
+			
+			this.config = (VBCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+			
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+			((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Items.Add(&quot;Standard&quot;);
+			foreach (string runtime in fileUtilityService.GetAvaiableRuntimeVersions()) {
+				((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Items.Add(runtime);
+			}
+			
+			((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Text = config.VBCompilerVersion.Length == 0 ? &quot;Standard&quot; : config.VBCompilerVersion;
+		}
+
+		public override bool StorePanelContents()
+		{
+			config.VBCompilerVersion = ControlDictionary[&quot;compilerVersionComboBox&quot;].Text;
+			return true;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,90 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.ExternalTool;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.AddIns.Codons;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.Properties;
+
+namespace VBBinding
+{
+	public class VBDOCConfigurationPanel  : AbstractOptionPanel
+	{
+		VBCompilerParameters compilerParameters = null;
+		VBProject project = null;
+		ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+		static FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		
+		///&lt;summary&gt;
+		/// Returns if the filename will be parsed when running VB.DOC.
+		/// &lt;/summary&gt;
+		public static bool IsFileIncluded(string filename, VBProject project)
+		{
+			VBCompilerParameters compilerparameters = (VBCompilerParameters)project.ActiveConfiguration;
+			return Array.IndexOf(compilerparameters.VBDOCFiles, filename) == -1;
+		}
+		
+		
+		public VBDOCConfigurationPanel() : base(propertyService.DataDirectory + @&quot;\resources\panels\ProjectOptions\VBDOCConfigurationPanel.xfrm&quot;)
+		{
+			CustomizationObjectChanged += new EventHandler(SetValues);
+			ControlDictionary[&quot;BrowseOutputFileButton&quot;].Click += new EventHandler(BrowseOutputFileButton_Click);
+		}
+		
+		private void BrowseOutputFileButton_Click(object sender, EventArgs e) {
+			SaveFileDialog dialog = new SaveFileDialog();
+			dialog.Filter = &quot;XML files (*.xml)|*.xml&quot;;
+			if(dialog.ShowDialog() == DialogResult.OK) {
+				((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text = dialog.FileName;
+			}
+		}
+		
+		public override bool ReceiveDialogMessage(DialogMessage message)
+		{
+			if (message == DialogMessage.OK) {
+				if (compilerParameters == null) {
+					return true;
+				}
+				
+				compilerParameters.VBDOCOutputFile = ((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text;
+				compilerParameters.VBDOCCommentPrefix = ((TextBox)ControlDictionary[&quot;CommentPrefixTextBox&quot;]).Text;
+				
+				string[] files = new string[((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Count - ((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).CheckedIndices.Count];
+				int count = 0;
+				for(int index = 0; index &lt; ((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Count; index++) {
+					if(((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).GetItemChecked(index) == false) {
+						files[count] = (string)((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items[index];
+						count++;
+					}
+				}
+				compilerParameters.VBDOCFiles = files;
+			}
+			return true;
+		}
+		
+		void SetValues(object sender, EventArgs e)
+		{
+			this.compilerParameters = (VBCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+			project = (VBProject)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);
+			
+			((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text = compilerParameters.VBDOCOutputFile;
+			((TextBox)ControlDictionary[&quot;CommentPrefixTextBox&quot;]). Text = compilerParameters.VBDOCCommentPrefix;
+			
+			foreach(ProjectFile pfile in project.ProjectFiles) {
+				bool included = IsFileIncluded(pfile.Name, project);
+				((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Add(pfile.Name, included);
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Makefile.am	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Makefile.am	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,61 @@
+ASSEMBLY = VBNetBinding.dll
+
+SUBDIRS = SharpRefactoryVB
+
+DLLS = /r:System.Drawing.dll \
+	/r:../../../../build/bin/MonoDevelop.Core.dll \
+	/r:../../../../build/bin/MonoDevelop.SourceEditor.dll \
+	/r:../../../../build/bin/MonoDevelop.Base.dll \
+	/r:../../../../build/bin/ICSharpCode.SharpRefactory.dll \
+	/r:../../../../build/bin/ICSharpCode.SharpRefactory.VB.dll \
+	/r:../../../../build/bin/ICSharpCode.SharpAssembly.dll \
+	/r:../../../../build/bin/MonoDevelop.Gui.Widgets.dll  \
+	$(BASE_DEPENDENCIES_LIBS)
+
+FILES = \
+./AssemblyInfo.cs \
+./VBAmbience.cs \
+./VBBindingCompilerServices.cs \
+./VBBindingExecutionServices.cs \
+./VBLanguageBinding.cs \
+./Gui/CodeGenerationPanel.cs \
+./Gui/OutputOptionsPanel.cs \
+./Parser/ExpressionFinder.cs \
+./Parser/Parser.cs \
+./Parser/Resolver.cs \
+./Parser/TypeVisitor.cs \
+./Parser/VBNetVisitor.cs \
+./Parser/SharpDevelopTree/AttributeSection.cs \
+./Parser/SharpDevelopTree/Class.cs \
+./Parser/SharpDevelopTree/CompilationUnit.cs \
+./Parser/SharpDevelopTree/Constructor.cs \
+./Parser/SharpDevelopTree/Event.cs \
+./Parser/SharpDevelopTree/Field.cs \
+./Parser/SharpDevelopTree/Indexer.cs \
+./Parser/SharpDevelopTree/Method.cs \
+./Parser/SharpDevelopTree/Parameter.cs \
+./Parser/SharpDevelopTree/Property.cs \
+./Parser/SharpDevelopTree/ReturnType.cs \
+./Project/VBCompilerParameters.cs \
+./Project/VBProject.cs
+
+build_sources = $(addprefix $(srcdir)/, $(FILES))
+
+all: $(ASSEMBLY)
+
+$(ASSEMBLY): $(build_sources)
+	cd SharpRefactoryVB &amp;&amp; make
+	$(CSC) /out:$(ASSEMBLY) /target:library $(DLLS) \
+		/resource:$(srcdir)/../../../../data/resources/glade/VB.glade,VB.glade \
+		$(build_sources) \
+	&amp;&amp; cp $(ASSEMBLY) ../../../../build/AddIns/AddIns/BackendBindings/.
+
+vbnetbindinglibdir = $(libdir)/monodevelop/AddIns/AddIns/BackendBindings
+vbnetbindinglib_DATA = $(ASSEMBLY)
+
+CLEANFILES = $(ASSEMBLY) $(ASSEMBLY).mdb
+
+DISTCLEANFILES =
+
+EXTRA_DIST = $(FILES)
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,371 @@
+using System;
+using System.Text;
+using MonoDevelop.Internal.Parser;
+
+namespace VBBinding.Parser
+{
+	/// &lt;summary&gt;
+	/// Description of ExpressionFinder.	
+	/// &lt;/summary&gt;
+	public class ExpressionFinder  : IExpressionFinder
+	{
+		public string FindExpression(string inText, int offset)
+		{
+			this.text = FilterComments(inText, ref offset);
+			this.text   = text;
+			this.offset = this.lastAccept = offset;
+			this.state  = START;
+			if (this.text == null) {
+				return null;
+			}
+			while (state != ERROR) {
+				ReadNextToken();
+				//Console.WriteLine(&quot;cur state {0} got token {1}/{3} going to {2}&quot;, GetStateName(state), GetTokenName(curTokenType), GetStateName(stateTable[state, curTokenType]), curTokenType);
+				state = stateTable[state, curTokenType];
+				
+				if (state == ACCEPT || state == ACCEPT2) {
+					lastAccept = this.offset;
+				}
+				if (state == ACCEPTNOMORE) {
+					return this.text.Substring(this.offset + 1, offset - this.offset);
+				}
+			}
+			return this.text.Substring(this.lastAccept + 1, offset - this.lastAccept);
+		}
+		
+		#region Comment Filter and 'inside string watcher'
+		int initialOffset;
+		public string FilterComments(string text, ref int offset)
+		{
+			this.initialOffset = offset;
+			StringBuilder outText = new StringBuilder();
+			int curOffset = 0;
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset];
+				
+				switch (ch) {
+					case '@':
+						if (curOffset + 1 &lt; text.Length &amp;&amp; text[curOffset + 1] == '&quot;') {
+							outText.Append(text[curOffset++]); // @
+							outText.Append(text[curOffset++]); // &quot;
+							if (!ReadVerbatimString(outText, text, ref curOffset)) {
+								return null;
+							}
+						}else{
+							outText.Append(ch);
+							++curOffset;
+						}
+						break;
+					case '&quot;':
+						outText.Append(ch);
+						curOffset++;
+						if (!ReadString(outText, text, ref curOffset)) {
+							return null;
+						}
+						break;
+					case '\'':
+						offset    -= 1;
+						curOffset += 1;
+						if (!ReadToEOL(text, ref curOffset, ref offset)) {
+							return null;
+						}
+						break;
+					default:
+						outText.Append(ch);
+						++curOffset;
+						break;
+				}
+			}
+			
+			return outText.ToString();
+		}
+		
+		bool ReadToEOL(string text, ref int curOffset, ref int offset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				--offset;
+				if (ch == '\n') {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		bool ReadString(StringBuilder outText, string text, ref int curOffset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				outText.Append(ch);
+				if (ch == '&quot;') {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		bool ReadVerbatimString(StringBuilder outText, string text, ref int curOffset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				outText.Append(ch);
+				if (ch == '&quot;') {
+					if (curOffset &lt; text.Length &amp;&amp; text[curOffset] == '&quot;') {
+						outText.Append(text[curOffset++]);
+					} else {
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+		
+		bool ReadMultiLineComment(string text, ref int curOffset, ref int offset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				--offset;
+				if (ch == '*') {
+					if (curOffset &lt; text.Length &amp;&amp; text[curOffset] == '/') {
+						++curOffset;
+						--offset;
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+		#endregion
+		
+		#region mini backward lexer
+		string text;
+		int    offset;
+		
+		char GetNext()
+		{
+			if (offset &gt;= 0) {
+				return text[offset--];
+			}
+			return '\0';
+		}
+		
+		char Peek()
+		{
+			if (offset &gt;= 0) {
+				return text[offset];
+			}
+			return '\0';
+		}
+		
+		void UnGet()
+		{
+			++offset;
+		}
+		
+		// tokens for our lexer
+		static int Err     = 0;
+		static int Dot     = 1;
+		static int StrLit  = 2;
+		static int Ident   = 3;
+		static int New     = 4;
+//		static int Bracket = 5;
+		static int Parent  = 6;
+		static int Curly   = 7;
+		static int Using   = 8;
+		int curTokenType;
+		
+		readonly static string[] tokenStateName = new string[] {
+			&quot;Err&quot;, &quot;Dot&quot;, &quot;StrLit&quot;, &quot;Ident&quot;, &quot;New&quot;, &quot;Bracket&quot;, &quot;Paren&quot;, &quot;Curly&quot;, &quot;Using&quot;
+		};
+		string GetTokenName(int state)
+		{
+			return tokenStateName[state];
+		}
+		
+		void ReadNextToken()
+		{
+			char ch = GetNext();
+				
+			curTokenType = Err;
+			if (ch == '\0' || ch == '\n' || ch == '\r') {
+				return;
+			}
+			while (Char.IsWhiteSpace(ch)) {
+				ch = GetNext();
+				if (ch == '\n' || ch == '\r') {
+					return;
+				}
+			}
+			
+			switch (ch) {
+				case '}':
+					if (ReadBracket('{', '}')) {
+						curTokenType = Curly;
+					}
+					break;
+				case ')':
+					if (ReadBracket('(', ')')) {
+						curTokenType = Parent;
+					}
+					break;
+				case ']':
+					if (ReadBracket('[', ']')) {
+						curTokenType = Ident;
+					}
+					break;
+				case '.':
+					curTokenType = Dot;
+					break;
+				case '\'':
+				case '&quot;':
+					if (ReadStringLiteral(ch)) {
+						curTokenType = StrLit;
+					}
+					break;
+				default:
+					if (IsIdentifierPart(ch)) {
+						string ident = ReadIdentifier(ch);
+						if (ident != null) {
+							switch (ident.ToLower()) {
+								case &quot;new&quot;:
+									curTokenType = New;
+									break;
+								case &quot;imports&quot;:
+									curTokenType = Using;
+									break;
+								default:
+									curTokenType = Ident;
+									break;
+							}
+						}
+					}
+					break;
+			}
+		}
+		
+		bool ReadStringLiteral(char litStart)
+		{
+			while (true) {
+				char ch = GetNext();
+				if (ch == '\0') {
+					return false;
+				}
+				if (ch == litStart) {
+					if (Peek() == '@' &amp;&amp; litStart == '&quot;') {
+						GetNext();
+					}
+					return true;
+				}
+			}
+		}
+		
+		bool ReadBracket(char openBracket, char closingBracket)
+		{
+			int curlyBraceLevel    = 0;
+			int squareBracketLevel = 0;
+			int parenthesisLevel   = 0;
+			switch (openBracket) {
+				case '(':
+					parenthesisLevel++;
+					break;
+				case '[':
+					squareBracketLevel++;
+					break;
+				case '{':
+					curlyBraceLevel++;
+					break;
+			}
+			
+			while (parenthesisLevel != 0 || squareBracketLevel != 0 || curlyBraceLevel != 0) {
+				char ch = GetNext();
+				if (ch == '\0') {
+					return false;
+				}
+				switch (ch) {
+					case '(':
+						parenthesisLevel--;
+						break;
+					case '[':
+						squareBracketLevel--;
+						break;
+					case '{':
+						curlyBraceLevel--;
+						break;
+					case ')':
+						parenthesisLevel++;
+						break;
+					case ']':
+						squareBracketLevel++;
+						break;
+					case '}':
+						curlyBraceLevel++;
+						break;
+				}
+			}
+			return true;
+		}
+		
+		string ReadIdentifier(char ch)
+		{
+			string identifier = ch.ToString();
+			while (IsIdentifierPart(Peek())) {
+				identifier = GetNext() + identifier;
+			}
+			return identifier;
+		}
+		
+		bool IsIdentifierPart(char ch)
+		{
+			return Char.IsLetterOrDigit(ch) || ch == '_';
+		}
+		#endregion
+		
+		#region finite state machine 
+		readonly static int ERROR  = 0;
+		readonly static int START  = 1;
+		readonly static int DOT    = 2;
+		readonly static int MORE   = 3;
+		readonly static int CURLY  = 4;
+		readonly static int CURLY2 = 5;
+		readonly static int CURLY3 = 6;
+		
+		readonly static int ACCEPT = 7;
+		readonly static int ACCEPTNOMORE = 8;
+		readonly static int ACCEPT2 = 9;
+		
+		readonly static string[] stateName = new string[] {
+			&quot;ERROR&quot;,
+			&quot;START&quot;,
+			&quot;DOT&quot;,
+			&quot;MORE&quot;,
+			&quot;CURLY&quot;,
+			&quot;CURLY2&quot;,
+			&quot;CURLY3&quot;,
+			&quot;ACCEPT&quot;,
+			&quot;ACCEPTNOMORE&quot;,
+			&quot;ACCEPT2&quot;
+		};
+			
+		string GetStateName(int state)
+		{
+			return stateName[state];
+		}
+		
+		int state = 0;
+		int lastAccept = 0;
+		static int[,] stateTable = new int[,] {
+			//                   Err,     Dot,     Str,      ID,         New,     Brk,     Par,     Cur,   Using
+			/*ERROR*/        { ERROR,   ERROR,   ERROR,   ERROR,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*START*/        { ERROR,     DOT,  ACCEPT,  ACCEPT,        ERROR,   MORE, ACCEPT2,   CURLY,   ACCEPTNOMORE},
+			/*DOT*/          { ERROR,   ERROR,  ACCEPT,  ACCEPT,        ERROR,   MORE,  ACCEPT,   CURLY,   ERROR},
+			/*MORE*/         { ERROR,   ERROR,  ACCEPT,  ACCEPT,        ERROR,   MORE, ACCEPT2,   CURLY,   ERROR},
+			/*CURLY*/        { ERROR,   ERROR,   ERROR,   ERROR,        ERROR, CURLY2,   ERROR,   ERROR,   ERROR},
+			/*CURLY2*/       { ERROR,   ERROR,   ERROR,  CURLY3,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*CURLY3*/       { ERROR,   ERROR,   ERROR,   ERROR, ACCEPTNOMORE,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*ACCEPT*/       { ERROR,    MORE,   ERROR,   ERROR,       ACCEPT,  ERROR,   ERROR,   ERROR,   ACCEPTNOMORE},
+			/*ACCEPTNOMORE*/ { ERROR,   ERROR,   ERROR,   ERROR,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*ACCEPT2*/      { ERROR,    MORE,   ERROR,  ACCEPT,       ACCEPT,  ERROR,   ERROR,   ERROR,   ERROR},
+		};
+		#endregion 
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/Parser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/Parser.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/Parser.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,153 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Drawing;
+using System.Collections;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+using VBBinding.Parser.SharpDevelopTree;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+
+namespace VBBinding.Parser
+{
+	public class TParser : IParser
+	{
+	
+		public TParser() : base(){
+			//Keep this one for now, just as a basic verification of parser detection/loading
+			Console.WriteLine(&quot;Entering VB.NET parser&quot;);
+		}//constructor
+	
+		///&lt;summary&gt;IParser Interface&lt;/summary&gt; 
+		string[] lexerTags;
+		public string[] LexerTags {
+//// Alex: get accessor needed
+			get {
+				return lexerTags;
+			}
+			set {
+				lexerTags = value;
+			}
+		}
+		public IExpressionFinder ExpressionFinder {
+			get {
+				return new ExpressionFinder();
+			}
+		}
+		
+		void RetrieveRegions(CompilationUnit cu, SpecialTracker tracker)
+		{
+			for (int i = 0; i &lt; tracker.CurrentSpecials.Count; ++i) {
+				PreProcessingDirective directive = tracker.CurrentSpecials[i] as PreProcessingDirective;
+				if (directive != null) {
+					if (directive.Cmd.ToLower() == &quot;#region&quot;) {
+						int deep = 1; 
+						for (int j = i + 1; j &lt; tracker.CurrentSpecials.Count; ++j) {
+							PreProcessingDirective nextDirective = tracker.CurrentSpecials[j] as PreProcessingDirective;
+							if(nextDirective != null) {
+								switch (nextDirective.Cmd.ToLower()) {
+									case &quot;#region&quot;:
+										++deep;
+										break;
+									case &quot;#end&quot;:
+										if (nextDirective.Arg.ToLower() == &quot;region&quot;) {
+											--deep;
+											if (deep == 0) {
+												cu.FoldingRegions.Add(new FoldingRegion(directive.Arg.Trim('&quot;'), new DefaultRegion(directive.Start, nextDirective.End)));
+												goto end;
+											}
+										}
+										break;
+								}
+							}
+						}
+						end: ;
+					}
+				}
+			}
+		}
+		
+		public ICompilationUnitBase Parse(string fileName)
+		{
+			ICSharpCode.SharpRefactory.Parser.VB.Parser p = new ICSharpCode.SharpRefactory.Parser.VB.Parser();
+			
+			Lexer lexer = new Lexer(new FileReader(fileName));
+			lexer.SpecialCommentTags = lexerTags;
+			p.Parse(lexer);
+			
+			VBNetVisitor visitor = new VBNetVisitor();
+			visitor.Visit(p.compilationUnit, null);
+			//visitor.Cu.FileName = fileName;
+			visitor.Cu.ErrorsDuringCompile = p.Errors.count &gt; 0;
+			RetrieveRegions(visitor.Cu, lexer.SpecialTracker);
+			
+			AddCommentTags(visitor.Cu, lexer.TagComments);
+			return visitor.Cu;
+		}
+		
+		public ICompilationUnitBase Parse(string fileName, string fileContent)
+		{
+			ICSharpCode.SharpRefactory.Parser.VB.Parser p = new ICSharpCode.SharpRefactory.Parser.VB.Parser();
+			
+			Lexer lexer = new Lexer(new StringReader(fileContent));
+			lexer.SpecialCommentTags = lexerTags;
+			p.Parse(lexer);
+			
+			VBNetVisitor visitor = new VBNetVisitor();
+			visitor.Visit(p.compilationUnit, null);
+			//visitor.Cu.FileName = fileName;
+			visitor.Cu.ErrorsDuringCompile = p.Errors.count &gt; 0;
+			visitor.Cu.Tag = p.compilationUnit;
+			RetrieveRegions(visitor.Cu, lexer.SpecialTracker);
+			AddCommentTags(visitor.Cu, lexer.TagComments);
+			return visitor.Cu;
+		}
+		
+		void AddCommentTags(ICompilationUnit cu, ArrayList tagComments)
+		{
+			foreach (ICSharpCode.SharpRefactory.Parser.VB.TagComment tagComment in tagComments) {
+				DefaultRegion tagRegion = new DefaultRegion(tagComment.StartPosition.Y, tagComment.StartPosition.X);
+				MonoDevelop.Internal.Parser.Tag tag = new MonoDevelop.Internal.Parser.Tag(tagComment.Tag, tagRegion);
+				tag.CommentString = tagComment.CommentText;
+				cu.TagComments.Add(tag);
+			}
+		}
+		
+		
+		
+		public ArrayList CtrlSpace(IParserService parserService,IProject proj, int caretLine, int caretColumn, string fileName)
+		{
+			return new Resolver(proj).CtrlSpace(parserService, caretLine, caretColumn, fileName);
+		}
+		
+		public ResolveResult Resolve(IParserService parserService,IProject proj, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			return new Resolver(proj).Resolve(parserService,expression, caretLineNumber, caretColumn, fileName, fileContent);
+		}
+		
+		public ArrayList IsAsResolve (IParserService parserService, IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			return new Resolver (project).IsAsResolve (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+		}
+		
+		public string MonodocResolver (IParserService parserService, IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			return new Resolver (project).MonodocResolver (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+		}
+		
+		
+		public bool HandlesFileExtension(string fileExtension){
+        	if(fileExtension == null) return false;
+			return (fileExtension.ToLower() == &quot;.vb&quot;);
+		}
+
+		
+		///////// IParser Interface END
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/Resolver.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/Resolver.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/Resolver.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,1253 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Drawing;
+
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+using VBBinding.Parser.SharpDevelopTree;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser
+{
+	public class Resolver
+	{
+		IParserService parserService;
+		ICompilationUnit cu;
+		IClass callingClass;
+		LookupTableVisitor lookupTableVisitor;
+		IProject project;
+		
+		public Resolver (IProject project)
+		{
+			this.project = project;
+		}
+		
+		public IParserService ParserService {
+			get {
+				return parserService;
+			}
+		}
+		
+		public ICompilationUnit CompilationUnit {
+			get {
+				return cu;
+			}
+		}
+		
+		public IClass CallingClass {
+			get {
+				return callingClass;
+			}
+		}
+		
+		bool showStatic = false;
+		
+		bool inNew = false;
+		
+		public bool ShowStatic {
+			get {
+				return showStatic;
+			}
+			
+			set {
+				showStatic = value;
+			}
+		}
+		
+		int caretLine;
+		int caretColumn;
+		
+		public IReturnType internalResolve(IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			try{
+			//Console.WriteLine(&quot;Start Resolving &quot; + expression);
+			if (expression == null) {
+				return null;
+			}
+			expression = expression.TrimStart(null);
+			if (expression == &quot;&quot;) {
+				return null;
+			}
+			this.caretLine     = caretLineNumber;
+			this.caretColumn   = caretColumn;
+			
+			this.parserService = parserService;
+			IParseInformation parseInfo = parserService.GetParseInformation(fileName);
+			ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit fileCompilationUnit = parseInfo.MostRecentCompilationUnit.Tag as ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit;
+			if (fileCompilationUnit == null) {
+				ICSharpCode.SharpRefactory.Parser.VB.Parser fileParser = new ICSharpCode.SharpRefactory.Parser.VB.Parser();
+				fileParser.Parse(new Lexer(new StringReader(fileContent)));
+				//Console.WriteLine(&quot;!Warning: no parseinformation!&quot;);
+				return null;
+			}
+			/*
+			//// try to find last expression in original string, it could be like &quot; if (act!=null) act&quot;
+			//// in this case only &quot;act&quot; should be parsed as expression  
+			!!is so!! don't change things that work
+			Expression expr=null;	// tentative expression
+			Lexer l=null;
+			ICSharpCode.SharpRefactory.Parser.Parser p = new ICSharpCode.SharpRefactory.Parser.Parser();
+			while (expression.Length &gt; 0) {
+				l = new Lexer(new StringReader(expression));
+				expr = p.ParseExpression(l);
+				if (l.LookAhead.val != &quot;&quot; &amp;&amp; expression.LastIndexOf(l.LookAhead.val) &gt;= 0) {
+					if (expression.Substring(expression.LastIndexOf(l.LookAhead.val) + l.LookAhead.val.Length).Length &gt; 0) 
+						expression=expression.Substring(expression.LastIndexOf(l.LookAhead.val) + l.LookAhead.val.Length).Trim();
+					else {
+						expression=l.LookAhead.val.Trim();
+						l=new Lexer(new StringReader(expression));
+						expr=p.ParseExpression(l);
+						break;
+					}
+				} else {
+					if (l.Token.val!=&quot;&quot; || expr!=null) break;
+				}
+			}
+			//// here last subexpression should be fixed in expr
+			if it should be changed in expressionfinder don't fix it here
+			*/
+			ICSharpCode.SharpRefactory.Parser.VB.Parser p = new ICSharpCode.SharpRefactory.Parser.VB.Parser();
+			Lexer l = new Lexer(new StringReader(expression));
+			Expression expr = p.ParseExpression(l);
+			if (expr == null) {
+				return null;
+			//}else{
+				//Console.WriteLine(expr.ToString());
+			}
+			lookupTableVisitor = new LookupTableVisitor();
+			lookupTableVisitor.Visit(fileCompilationUnit, null);
+			//Console.WriteLine(&quot;Visited lookup table&quot;);
+			
+			TypeVisitor typeVisitor = new TypeVisitor(this);
+			
+			VBNetVisitor vbVisitor = new VBNetVisitor();
+			cu = (ICompilationUnit)vbVisitor.Visit(fileCompilationUnit, null);
+			//Console.WriteLine(&quot;Visited VBNetVisitor&quot;);
+			if (cu != null) {
+				callingClass = GetInnermostClass();
+				//Console.WriteLine(&quot;CallingClass is &quot; + callingClass == null ? &quot;null&quot; : callingClass.Name);
+			}
+//			Console.WriteLine(&quot;expression = &quot; + expr.ToString());
+			IReturnType type = expr.AcceptVisitor(typeVisitor, null) as IReturnType;
+			//Console.WriteLine(&quot;type visited&quot;);
+			if (type == null || type.PointerNestingLevel != 0) {
+				//Console.WriteLine(&quot;Type == null || type.PointerNestingLevel != 0&quot;);
+				//if (type != null) {
+					//Console.WriteLine(&quot;Accepted visitor: &quot; + type.FullyQualifiedName);
+					//Console.WriteLine(&quot;PointerNestingLevel is &quot; + type.PointerNestingLevel);
+				//} else {
+					//Console.WriteLine(&quot;Type == null&quot;);
+				//}
+				
+				//// when type is null might be file needs to be reparsed - some vars were lost
+				fileCompilationUnit=parserService.ParseFile(fileName, fileContent).MostRecentCompilationUnit.Tag 
+					as ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit;
+				lookupTableVisitor.Visit(fileCompilationUnit,null);
+				//Console.WriteLine(&quot;Lookup table visited again&quot;);
+				
+				cu = (ICompilationUnit)vbVisitor.Visit(fileCompilationUnit, null);
+				if (cu != null) {
+					callingClass = GetInnermostClass();
+					//Console.WriteLine(&quot;Got new cu, calling class = &quot; + callingClass.FullyQualifiedName);
+				}
+				type=expr.AcceptVisitor(typeVisitor,null) as IReturnType;
+				//Console.WriteLine(&quot;Type visited again&quot;);
+				if (type==null)	return null;
+			}
+			if (type.ArrayDimensions != null &amp;&amp; type.ArrayDimensions.Length &gt; 0) {
+				type = new ReturnType(&quot;System.Array&quot;);
+			}
+			//Console.WriteLine(&quot;Here: Type is &quot; + type.FullyQualifiedName);
+			return type;
+			}catch(Exception ex){
+				//Console.WriteLine(&quot;Exception in internalResolve: &quot; + ex.Message);
+				//Console.WriteLine(ex.StackTrace);
+				return null;
+			}
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns the innerst class in which the carret currently is, returns null
+		/// if the carret is outside any class boundaries.
+		/// &lt;/remarks&gt;
+		IClass GetInnermostClass()
+		{
+			if (cu != null) {
+				foreach (IClass c in cu.Classes) {
+					if (c != null &amp;&amp; c.Region != null &amp;&amp; c.Region.IsInside(caretLine, caretColumn)) {
+						return GetInnermostClass(c);
+					}
+				}
+			}
+			return null;
+		}
+		
+		IClass GetInnermostClass(IClass curClass)
+		{
+			if (curClass == null) {
+				return null;
+			}
+			if (curClass.InnerClasses == null) {
+				return GetResolvedClass (curClass);
+			}
+			foreach (IClass c in curClass.InnerClasses) {
+				if (c != null &amp;&amp; c.Region != null &amp;&amp; c.Region.IsInside(caretLine, caretColumn)) {
+					return GetInnermostClass(c);
+				}
+			}
+			return GetResolvedClass (curClass);
+		}
+		
+		
+		public IClass GetResolvedClass (IClass cls)
+		{
+			// Returns an IClass in which all type names have been properly resolved
+			return parserService.GetClass (project, cls.FullyQualifiedName,true,false);
+		}
+
+
+		
+		public string MonodocResolver (IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent) 
+		{
+			//Console.WriteLine(&quot;Entering MonodocResolver for &quot; + expression);
+			if (expression == null) {
+				return null;
+			}
+			expression = expression.TrimStart (null);
+			if (expression == &quot;&quot;) {
+				return null;
+			}
+			IReturnType retType = internalResolve (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+			IClass retClass = parserService.SearchType (project, retType.FullyQualifiedName, null, cu);
+			if (retClass == null) {
+				//Console.WriteLine (&quot;Retclass was null&quot;);
+				return null;
+			}
+			
+			//Console.WriteLine (retClass.FullyQualifiedName);
+			return &quot;T:&quot; + retClass.FullyQualifiedName;
+		}
+		
+		public ArrayList IsAsResolve (IParserService parserService, string expression, int caretLine, int caretColumn, string fileName, string fileContent)
+		{
+			//Console.WriteLine(&quot;Entering IsAsResolve for &quot; + expression);
+			ArrayList result = new ArrayList ();
+			this.parserService = parserService;
+			this.caretLine = caretLine;
+			this.caretColumn = caretColumn;
+			
+			IParseInformation parseInfo = parserService.GetParseInformation (fileName);
+			ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit fcu = parseInfo.MostRecentCompilationUnit.Tag as ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit;
+			if (fcu == null)
+				return null;
+			ICSharpCode.SharpRefactory.Parser.VB.Parser p = new ICSharpCode.SharpRefactory.Parser.VB.Parser ();
+			Lexer l = new Lexer (new StringReader (expression));
+			Expression expr = p.ParseExpression(l);
+			if (expr == null)
+				return null;
+
+			lookupTableVisitor = new LookupTableVisitor ();
+			lookupTableVisitor.Visit (fcu, null);
+
+			TypeVisitor typeVisitor = new TypeVisitor (this);
+
+			VBNetVisitor vbVisitor = new VBNetVisitor ();
+			cu = (ICompilationUnit)vbVisitor.Visit (fcu, null);
+			if (cu != null) {
+				callingClass = GetInnermostClass ();
+			}
+
+			IReturnType type = expr.AcceptVisitor (typeVisitor, null) as IReturnType;
+			if (type == null || type.PointerNestingLevel != 0) {
+				fcu = parserService.ParseFile (fileName, fileContent).MostRecentCompilationUnit.Tag as ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit;
+				lookupTableVisitor.Visit (fcu, null);
+				cu = (ICompilationUnit)vbVisitor.Visit (fcu, null);
+
+				if (cu != null) {
+					callingClass = GetInnermostClass ();
+				}
+				type = expr.AcceptVisitor (typeVisitor, null) as IReturnType;
+				if (type == null)
+					return null;
+			}
+			if (type.ArrayDimensions != null &amp;&amp; type.ArrayDimensions.Length &gt; 0)
+				type = new ReturnType (&quot;System.Array&quot;);
+
+//			IClass returnClass = SearchType (type.FullyQualifiedName, null, cu);
+			IClass returnClass = parserService.SearchType (project, type.FullyQualifiedName, null, cu);
+			if (returnClass == null)
+				return null;
+
+			foreach (IClass iclass in parserService.GetClassInheritanceTree (project, returnClass)) {
+				if (!result.Contains (iclass))
+					result.Add (iclass);
+			}
+			return result;
+		}
+		
+/***** #D Legacy Code - remove once replacement code is verified *****
+
+		public ResolveResult Resolve(IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			Console.WriteLine(&quot;Entering Resolve for &quot; + expression);
+			expression = expression.TrimStart(null);
+			expression = expression.ToLower();
+			if (expression.StartsWith(&quot;new &quot;)) {
+				inNew = true;
+				expression = expression.Substring(4);
+			} else {
+				inNew = false;
+			}
+			//Console.WriteLine(&quot;\nStart Resolving expression : &gt;{0}&lt;&quot;, expression);
+			
+			Expression expr = null;
+			this.caretLine     = caretLineNumber;
+			this.caretColumn   = caretColumn;
+			this.parserService = parserService;
+			IParseInformation parseInfo = parserService.GetParseInformation(fileName);
+			ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit fileCompilationUnit = parseInfo.MostRecentCompilationUnit.Tag as ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit;
+			if (fileCompilationUnit == null) {
+				ICSharpCode.SharpRefactory.Parser.VB.Parser fileParser = new ICSharpCode.SharpRefactory.Parser.VB.Parser();
+				fileParser.Parse(new Lexer(new StringReader(fileContent)));
+				Console.WriteLine(&quot;!Warning: no parseinformation!&quot;);
+				return null;
+			}
+			VBNetVisitor vBNetVisitor = new VBNetVisitor();
+			cu = (ICompilationUnit)vBNetVisitor.Visit(fileCompilationUnit, null);
+			if (cu != null) {
+				callingClass = GetInnermostClass();
+				Console.WriteLine(&quot;CallingClass is &quot; + callingClass == null ? &quot;null&quot; : callingClass.Name);
+			}else{
+				Console.WriteLine(&quot;NULL compilation unit!&quot;);
+			}
+			lookupTableVisitor = new LookupTableVisitor();
+			lookupTableVisitor.Visit(fileCompilationUnit, null);
+			
+			if (expression == null || expression == &quot;&quot;) {
+				expr = WithResolve();
+				if (expr == null) {
+					return null;
+				}
+			}
+			
+			if (expression.StartsWith(&quot;imports &quot;)) {
+				return ImportsResolve(expression);
+			}
+			Console.WriteLine(&quot;Not in imports &gt;{0}&lt;&quot;, expression);
+			
+			if (InMain()) {
+				showStatic = true;
+			}
+			
+			// MyBase and MyClass are no expressions, only MyBase.Identifier and MyClass.Identifier
+			if (expression == &quot;mybase&quot;) {
+				expr = new BaseReferenceExpression();
+			} else if (expression == &quot;myclass&quot;) {
+				expr = new ClassReferenceExpression();
+			}
+			
+			if (expr == null) {
+				Lexer l = new Lexer(new StringReader(expression));
+				ICSharpCode.SharpRefactory.Parser.VB.Parser p = new ICSharpCode.SharpRefactory.Parser.VB.Parser();
+				expr = p.ParseExpression(l);
+				if (expr == null) {
+					Console.WriteLine(&quot;Warning: No Expression from parsing!&quot;);
+					return null;
+				}
+			}
+			
+			Console.WriteLine(expr.ToString());
+			//TypeVisitor typeVisitor = new TypeVisitor(this);
+			//TypeVisitor typeVisitor = new VBBinding.Parser.TypeVisitor(this);
+			//IReturnType type = expr.AcceptVisitor(typeVisitor, null) as IReturnType;
+			//Console.WriteLine(&quot;type visited&quot;);
+			
+			IReturnType type = internalResolve (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+			//IClass returnClass = SearchType (type.FullyQualifiedName, cu);
+			
+			if (type == null || type.PointerNestingLevel != 0) {
+				Console.WriteLine(&quot;Type == null || type.PointerNestingLevel != 0&quot;);
+				if (type != null) {
+					Console.WriteLine(&quot;PointerNestingLevel is &quot; + type.PointerNestingLevel);
+				} else {
+					Console.WriteLine(&quot;Type == null&quot;);
+				}
+				return null;
+			}
+			if (type.ArrayDimensions != null &amp;&amp; type.ArrayDimensions.Length &gt; 0) {
+				type = new ReturnType(&quot;System.Array&quot;);
+			}
+			Console.WriteLine(&quot;Here: Type is &quot; + type.FullyQualifiedName);
+			//IClass returnClass = SearchType(type.FullyQualifiedName, callingClass, cu);
+			IClass returnClass = parserService.GetClass(project,type.FullyQualifiedName);
+			if (returnClass == null) {
+				Console.WriteLine(&quot;IClass is null! Trying namespace!&quot;);
+				// Try if type is Namespace:
+				string n = SearchNamespace(type.FullyQualifiedName, cu);
+				if (n == null) {
+					return null;
+				}
+				ArrayList content = parserService.GetNamespaceContents(project,n, true,false);
+				ArrayList classes = new ArrayList();
+				for (int i = 0; i &lt; content.Count; ++i) {
+					if (content[i] is IClass) {
+						if (inNew) {
+							IClass c = (IClass)content[i];
+//							Console.WriteLine(&quot;Testing &quot; + c.Name);
+							if ((c.ClassType == ClassType.Class) || (c.ClassType == ClassType.Struct)) {
+								classes.Add(c);
+//								Console.WriteLine(&quot;Added&quot;);
+							}
+						} else {
+							classes.Add((IClass)content[i]);
+						}
+					}
+				}
+				
+				Console.WriteLine(&quot;Checking subnamespace &quot; + n);
+				string[] namespaces = parserService.GetNamespaceList(project,n, false);
+				Console.WriteLine(&quot;Got &quot; + namespaces);
+				return new ResolveResult(namespaces, classes);
+			}
+			Console.WriteLine(&quot;Returning Result!&quot;);
+			if (inNew) {
+				return new ResolveResult(returnClass, ListTypes(new ArrayList(), returnClass));
+			} else {
+				return new ResolveResult(returnClass,ListMembers(new ArrayList(), returnClass));
+			}
+//			return new ResolveResult(returnClass, ListMembers(new ArrayList(),returnClass));
+		}
+*/
+		
+		
+		
+		
+		
+		public ResolveResult Resolve(IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent) 
+		{
+			if (expression == null) {
+				return null;
+			}
+			expression = expression.TrimStart(null);
+			if (expression == &quot;&quot;) {
+				return null;
+			}
+			if (expression.ToLower().StartsWith(&quot;imports&quot;)) {
+				// expression[expression.Length - 1] != '.'
+				// the period that causes this Resove() is not part of the expression
+				if (expression[expression.Length - 1] == '.') {
+					return null;
+				}
+				int i;
+				for (i = expression.Length - 1; i &gt;= 0; --i) {
+					if (!(Char.IsLetterOrDigit(expression[i]) || expression[i] == '_' || expression[i] == '.')) {
+						break;
+					}
+				}
+				// no Identifier before the period
+				if (i == expression.Length - 1) {
+					return null;
+				}
+				string t = expression.Substring(i + 1);
+//				Console.WriteLine(&quot;in Imports Statement&quot;);
+				string[] namespaces = parserService.GetNamespaceList(project, t);
+				if (namespaces == null || namespaces.Length &lt;= 0) {
+					return null;
+				}
+				return new ResolveResult(namespaces);
+			}
+			
+			//Console.WriteLine(&quot;Not in Imports&quot;);
+			IReturnType type = internalResolve (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+			IClass returnClass = SearchType (type.FullyQualifiedName, cu);
+			if (returnClass == null) {
+				// Try if type is Namespace:
+				string n = SearchNamespace(type.FullyQualifiedName, cu);
+				if (n == null) {
+					return null;
+				}
+				ArrayList content = parserService.GetNamespaceContents(project,n,true,false);
+				ArrayList classes = new ArrayList();
+				for (int i = 0; i &lt; content.Count; ++i) {
+					if (content[i] is IClass) {
+						classes.Add((IClass)content[i]);
+					}
+				}
+				string[] namespaces = parserService.GetNamespaceList(project, n, false);
+				return new ResolveResult(namespaces, classes);
+			}
+			//Console.WriteLine(&quot;Returning Result!&quot;);
+			if (returnClass.FullyQualifiedName == &quot;System.Void&quot;)
+				return null;
+			return new ResolveResult(returnClass, ListMembers(new ArrayList(), returnClass));
+		}
+		
+		
+		
+		
+		
+		
+		
+		
+		ArrayList ListMembers(ArrayList members, IClass curType)
+		{
+			//Console.WriteLine(&quot;LIST MEMBERS!!!&quot;);
+			//Console.WriteLine(&quot;showStatic = &quot; + showStatic);
+			//Console.WriteLine(curType.InnerClasses.Count + &quot; classes&quot;);
+			//Console.WriteLine(curType.Properties.Count + &quot; properties&quot;);
+			//Console.WriteLine(curType.Methods.Count + &quot; methods&quot;);
+			//Console.WriteLine(curType.Events.Count + &quot; events&quot;);
+			//Console.WriteLine(curType.Fields.Count + &quot; fields&quot;);
+			if (showStatic) {
+				foreach (IClass c in curType.InnerClasses) {
+					if (IsAccessible(curType, c)) {
+						members.Add(c);
+//						Console.WriteLine(&quot;Member added&quot;);
+					}
+				}
+			}
+			foreach (IProperty p in curType.Properties) {
+				if (MustBeShown(curType, p)) {
+					members.Add(p);
+//					Console.WriteLine(&quot;Member added&quot;);
+				} else {
+					//// for some public static properties msutbeshowen is false, so additional check
+					//// this is lame fix because curType doesn't allow to find out if to show only
+					//// static public or simply public properties
+					if (((AbstractMember)p).ReturnType!=null) {
+						// if public add it to completion window
+						if (((AbstractDecoration)p).IsPublic) members.Add(p);
+//						Console.WriteLine(&quot;Property {0} added&quot;, p.FullyQualifiedName);
+					}
+				}
+			}
+//			Console.WriteLine(&quot;ADDING METHODS!!!&quot;);
+			foreach (IMethod m in curType.Methods) {
+//				Console.WriteLine(&quot;Method : &quot; + m);
+				if (MustBeShown(curType, m)) {
+					members.Add(m);
+//					Console.WriteLine(&quot;Member added&quot;);
+				}
+			}
+			foreach (IEvent e in curType.Events) {
+				if (MustBeShown(curType, e)) {
+					members.Add(e);
+//					Console.WriteLine(&quot;Member added&quot;);
+				}
+			}
+			foreach (IField f in curType.Fields) {
+				if (MustBeShown(curType, f)) {
+					members.Add(f);
+//					Console.WriteLine(&quot;Member added&quot;);
+				} else {
+					//// enum fields must be shown here if present
+					if (curType.ClassType == ClassType.Enum) {
+						if (IsAccessible(curType,f)) members.Add(f);
+//						Console.WriteLine(&quot;Member {0} added&quot;, f.FullyQualifiedName);
+					}
+				}
+			}
+//			Console.WriteLine(&quot;ClassType = &quot; + curType.ClassType);
+			if (curType.ClassType == ClassType.Interface &amp;&amp; !showStatic) {
+				foreach (string s in curType.BaseTypes) {
+					IClass baseClass = parserService.GetClass (project, s, true, false);
+					if (baseClass != null &amp;&amp; baseClass.ClassType == ClassType.Interface) {
+						ListMembers(members, baseClass);
+					}
+				}
+			} else {
+				IClass baseClass = BaseClass(curType);
+				if (baseClass != null) {
+//					Console.WriteLine(&quot;Base Class = &quot; + baseClass.FullyQualifiedName);
+					ListMembers(members, baseClass);
+				}
+			}
+//			Console.WriteLine(&quot;listing finished&quot;);
+			return members;
+		}
+		
+		
+		//Hacked from ListMembers - not sure if entirely correct or necessary
+		ArrayList ListTypes(ArrayList members, IClass curType)
+		{
+			//Console.WriteLine(&quot;LIST TYPES!!!&quot;);
+			//Console.WriteLine(&quot;showStatic = &quot; + showStatic);
+			//Console.WriteLine(curType.InnerClasses.Count + &quot; classes&quot;);
+			if (showStatic) {
+				foreach (IClass c in curType.InnerClasses) {
+					if (IsAccessible(curType, c)) {
+						members.Add(c);
+//						Console.WriteLine(&quot;Member added&quot;);
+					}
+				}
+			}
+//			Console.WriteLine(&quot;ClassType = &quot; + curType.ClassType);
+			if (curType.ClassType == ClassType.Interface &amp;&amp; !showStatic) {
+				foreach (string s in curType.BaseTypes) {
+					IClass baseClass = parserService.GetClass (project, s, true, false);
+					if (baseClass != null &amp;&amp; baseClass.ClassType == ClassType.Interface) {
+						ListTypes(members, baseClass);
+					}
+				}
+			} else {
+				IClass baseClass = BaseClass(curType);
+				if (baseClass != null) {
+//					Console.WriteLine(&quot;Base Class = &quot; + baseClass.FullyQualifiedName);
+					ListTypes(members, baseClass);
+				}
+			}
+//			Console.WriteLine(&quot;listing finished&quot;);
+			return members;
+		}
+		
+		bool InMain()
+		{
+			return false;
+		}
+		
+		Expression WithResolve()
+		{
+			//Console.WriteLine(&quot;in WithResolve&quot;);
+			Expression expr = null;
+			if (lookupTableVisitor.WithStatements != null) {
+				//Console.WriteLine(&quot;{0} WithStatements&quot;, lookupTableVisitor.WithStatements.Count);
+				foreach (WithStatement with in lookupTableVisitor.WithStatements) {
+//					Console.WriteLine(&quot;Position: ({0}/{1})&quot;, with.StartLocation, with.EndLocation);
+					if (IsInside(new Point(caretColumn, caretLine), with.StartLocation, with.EndLocation)) {
+						expr = with.WithExpression;
+					}
+				}
+			}
+//			if (expr == null) {
+//				Console.WriteLine(&quot;No WithStatement found&quot;);
+//			} else {
+//				Console.WriteLine(&quot;WithExpression : &quot; + expr);
+//			}
+			return expr;
+		}
+		
+		ResolveResult ImportsResolve(string expression)
+		{
+			// expression[expression.Length - 1] != '.'
+			// the period that causes this Resove() is not part of the expression
+			if (expression[expression.Length - 1] == '.') {
+				return null;
+			}
+			int i;
+			for (i = expression.Length - 1; i &gt;= 0; --i) {
+				if (!(Char.IsLetterOrDigit(expression[i]) || expression[i] == '_' || expression[i] == '.')) {
+					break;
+				}
+			}
+			// no Identifier before the period
+			if (i == expression.Length - 1) {
+				return null;
+			}
+			string t = expression.Substring(i + 1);
+//			Console.WriteLine(&quot;in imports Statement&quot;);
+			string[] namespaces = parserService.GetNamespaceList(project,t, false);
+			if (namespaces == null || namespaces.Length &lt;= 0) {
+				return null;
+			}
+			return new ResolveResult(namespaces);
+		}
+		
+		bool InStatic()
+		{
+			IProperty property = GetProperty();
+			if (property != null) {
+				return property.IsStatic;
+			}
+			IMethod method = GetMethod();
+			if (method != null) {
+				return method.IsStatic;
+			}
+			return false;
+		}
+		
+		public ArrayList SearchMethod(IReturnType type, string memberName)
+		{
+			if (type == null || type.PointerNestingLevel != 0) {
+				return new ArrayList();
+			}
+			IClass curType;
+			if (type.ArrayDimensions != null &amp;&amp; type.ArrayDimensions.Length &gt; 0) {
+				curType = SearchType(&quot;System.Array&quot;, null, null);
+			} else {
+				curType = SearchType(type.FullyQualifiedName, null, null);
+				if (curType == null) {
+					return new ArrayList();
+				}
+			}
+			return SearchMethod(new ArrayList(), curType, memberName);
+		}
+		
+		ArrayList SearchMethod(ArrayList methods, IClass curType, string memberName)
+		{
+			bool isClassInInheritanceTree = IsClassInInheritanceTree(curType, callingClass);
+			
+			foreach (IMethod m in curType.Methods) {
+				if (m.Name.ToLower() == memberName.ToLower() &amp;&amp;
+				    MustBeShown(curType, m) &amp;&amp;  //,  callingClass, showStatic, isClassInInheritanceTree) &amp;&amp;
+				    !((m.Modifiers &amp; ModifierEnum.Override) == ModifierEnum.Override)) {
+					methods.Add(m);
+				}
+			}
+			IClass baseClass = BaseClass(curType); //, false);
+			if (baseClass != null) {
+				return SearchMethod(methods, baseClass, memberName);
+			}
+			showStatic = false;
+			return methods;
+		}
+		
+		public ArrayList SearchIndexer(IReturnType type)
+		{
+			IClass curType = SearchType(type.FullyQualifiedName, null, null);
+			if (curType != null) {
+				return SearchIndexer(new ArrayList(), curType);
+			}
+			return new ArrayList();
+		}
+		
+		public ArrayList SearchIndexer(ArrayList indexer, IClass curType)
+		{
+			bool isClassInInheritanceTree =IsClassInInheritanceTree(curType, callingClass);
+			foreach (IIndexer i in curType.Indexer) {
+				if (MustBeShown(curType, i) /* , callingClass, showStatic, isClassInInheritanceTree) */ 
+				&amp;&amp; !((i.Modifiers &amp; ModifierEnum.Override) == ModifierEnum.Override)) {
+					indexer.Add(i);
+				}
+			}
+			IClass baseClass = BaseClass(curType);
+			if (baseClass != null) {
+				return SearchIndexer(indexer, baseClass);
+			}
+			showStatic = false;
+			return indexer;
+		}
+		
+		// no methods or indexer
+		public IReturnType SearchMember(IReturnType type, string memberName)
+		{
+			if (type == null || memberName == null || memberName == &quot;&quot;) {
+				return null;
+			}
+//			Console.WriteLine(&quot;searching member {0} in {1}&quot;, memberName, type.Name);
+			IClass curType = SearchType(type.FullyQualifiedName, callingClass, cu);
+			bool isClassInInheritanceTree =IsClassInInheritanceTree(curType, callingClass);
+			
+			if (curType == null) {
+//				Console.WriteLine(&quot;Type not found in SearchMember&quot;);
+				return null;
+			}
+			if (type.PointerNestingLevel != 0) {
+				return null;
+			}
+			if (type.ArrayDimensions != null &amp;&amp; type.ArrayDimensions.Length &gt; 0) {
+				curType = SearchType(&quot;System.Array&quot;, null, null);
+			}
+			if (curType.ClassType == ClassType.Enum) {
+				foreach (IField f in curType.Fields) {
+					if (f.Name.ToLower() == memberName.ToLower() &amp;&amp; MustBeShown(curType, f) /* , callingClass, showStatic, isClassInInheritanceTree) */ ) {
+						showStatic = false;
+						return type; // enum members have the type of the enum
+					}
+				}
+			}
+			if (showStatic) {
+//				Console.WriteLine(&quot;showStatic == true&quot;);
+				foreach (IClass c in curType.InnerClasses) {
+					if (c.Name.ToLower() == memberName.ToLower()  &amp;&amp; IsAccessible(curType, c) /*, callingClass, isClassInInheritanceTree) */) {
+						return new ReturnType(c.FullyQualifiedName);
+					}
+				}
+			}
+//			Console.WriteLine(&quot;#Properties &quot; + curType.Properties.Count);
+			foreach (IProperty p in curType.Properties) {
+//				Console.WriteLine(&quot;checke Property &quot; + p.Name);
+//				Console.WriteLine(&quot;member name &quot; + memberName);
+				if (p.Name.ToLower() == memberName.ToLower() &amp;&amp; MustBeShown(curType, p) /*, callingClass, showStatic, isClassInInheritanceTree)*/) {
+//					Console.WriteLine(&quot;Property found &quot; + p.Name);
+					showStatic = false;
+					return p.ReturnType;
+				}
+			}
+			foreach (IField f in curType.Fields) {
+//				Console.WriteLine(&quot;checke Feld &quot; + f.Name);
+//				Console.WriteLine(&quot;member name &quot; + memberName);
+				if (f.Name.ToLower() == memberName.ToLower() &amp;&amp; MustBeShown(curType, f) /*, callingClass, showStatic, isClassInInheritanceTree)*/) {
+//					Console.WriteLine(&quot;Field found &quot; + f.Name);
+					showStatic = false;
+					return f.ReturnType;
+				}
+			}
+			foreach (IEvent e in curType.Events) {
+				if (e.Name.ToLower() == memberName.ToLower() &amp;&amp; MustBeShown(curType, e) /*, callingClass, showStatic, isClassInInheritanceTree)*/) {
+					showStatic = false;
+					return e.ReturnType;
+				}
+			}
+			foreach (IMethod m in curType.Methods) {
+//				Console.WriteLine(&quot;checke Method &quot; + m.Name);
+//				Console.WriteLine(&quot;member name &quot; + memberName);
+				if (m.Name.ToLower() == memberName.ToLower() &amp;&amp; MustBeShown(curType, m) /*, callingClass, showStatic, isClassInInheritanceTree) /* check if m has no parameters &amp;&amp; m.*/) {
+//					Console.WriteLine(&quot;Method found &quot; + m.Name);
+					showStatic = false;
+					return m.ReturnType;
+				}
+			}
+			foreach (string baseType in curType.BaseTypes) {
+				IClass c = SearchType(baseType, curType);
+				if (c != null) {
+					IReturnType erg = SearchMember(new ReturnType(c.FullyQualifiedName), memberName);
+					if (erg != null) {
+						return erg;
+					}
+				}
+			}
+			return null;
+		}
+		
+		bool IsInside(Point between, Point start, Point end)
+		{
+			if (between.Y &lt; start.Y || between.Y &gt; end.Y) {
+//				Console.WriteLine(&quot;Y = {0} not between {1} and {2}&quot;, between.Y, start.Y, end.Y);
+				return false;
+			}
+			if (between.Y &gt; start.Y) {
+				if (between.Y &lt; end.Y) {
+					return true;
+				}
+				// between.Y == end.Y
+//				Console.WriteLine(&quot;between.Y = {0} == end.Y = {1}&quot;, between.Y, end.Y);
+//				Console.WriteLine(&quot;returning {0}:, between.X = {1} &lt;= end.X = {2}&quot;, between.X &lt;= end.X, between.X, end.X);
+				return between.X &lt;= end.X;
+			}
+			// between.Y == start.Y
+//			Console.WriteLine(&quot;between.Y = {0} == start.Y = {1}&quot;, between.Y, start.Y);
+			if (between.X &lt; start.X) {
+				return false;
+			}
+			// start is OK and between.Y &lt;= end.Y
+			return between.Y &lt; end.Y || between.X &lt;= end.X;
+		}
+		
+		ReturnType SearchVariable(string name)
+		{
+//			Console.WriteLine(&quot;Searching Variable&quot;);
+//			
+//			Console.WriteLine(&quot;LookUpTable has {0} entries&quot;, lookupTableVisitor.variables.Count);
+//			Console.WriteLine(&quot;Listing Variables:&quot;);
+//			IDictionaryEnumerator enumerator = lookupTableVisitor.variables.GetEnumerator();
+//			while (enumerator.MoveNext()) {
+//				Console.WriteLine(enumerator.Key);
+//			}
+//			Console.WriteLine(&quot;end listing&quot;);
+			ArrayList variables = (ArrayList)lookupTableVisitor.Variables[name.ToLower()];
+//			if (variables == null || variables.Count &lt;= 0) {
+//				Console.WriteLine(name + &quot; not in LookUpTable&quot;);
+//				return null;
+//			}
+			
+			ReturnType found = null;
+			if (variables != null) {
+				foreach (LocalLookupVariable v in variables) {
+//					Console.WriteLine(&quot;Position: ({0}/{1})&quot;, v.StartPos, v.EndPos);
+					if (IsInside(new Point(caretColumn, caretLine), v.StartPos, v.EndPos)) {
+						found = new ReturnType(v.TypeRef);
+//						Console.WriteLine(&quot;Variable found&quot;);
+						break;
+					}
+				}
+			}
+//			if (found == null) {
+//				Console.WriteLine(&quot;No Variable found&quot;);
+//				return null;
+//			}
+			return found;
+		}
+		
+		/// &lt;remarks&gt;
+		/// does the dynamic lookup for the typeName
+		/// &lt;/remarks&gt;
+		public IReturnType DynamicLookup(string typeName)
+		{
+//			Console.WriteLine(&quot;starting dynamic lookup&quot;);
+//			Console.WriteLine(&quot;name == &quot; + typeName);
+			
+			// try if it exists a variable named typeName
+			ReturnType variable = SearchVariable(typeName);
+			if (variable != null) {
+				showStatic = false;
+				return variable;
+			}
+//			Console.WriteLine(&quot;No Variable found&quot;);
+			
+			if (callingClass == null) {
+				return null;
+			}
+			//// somehow search in callingClass fields is not returning anything, so I am searching here once again
+			foreach (IField f in callingClass.Fields) {
+				if (f.Name.ToLower() == typeName.ToLower()) {
+//					Console.WriteLine(&quot;Field found &quot; + f.Name);
+					return f.ReturnType;
+				}
+			}
+			//// end of mod for search in Fields
+		
+			// try if typeName is a method parameter
+			IReturnType p = SearchMethodParameter(typeName);
+			if (p != null) {
+//				Console.WriteLine(&quot;MethodParameter Found&quot;);
+				showStatic = false;
+				return p;
+			}
+//			Console.WriteLine(&quot;No Parameter found&quot;);
+			
+			// check if typeName == value in set method of a property
+			if (typeName == &quot;value&quot;) {
+				p = SearchProperty();
+				if (p != null) {
+					showStatic = false;
+					return p;
+				}
+			}
+//			Console.WriteLine(&quot;No Property found&quot;);
+			
+			// try if there exists a nonstatic member named typeName
+			showStatic = false;
+			IReturnType t = SearchMember(callingClass == null ? null : new ReturnType(callingClass.FullyQualifiedName), typeName);
+			if (t != null) {
+				return t;
+			}
+//			Console.WriteLine(&quot;No nonstatic member found&quot;);
+			
+			// try if there exists a static member named typeName
+			showStatic = true;
+			t = SearchMember(callingClass == null ? null : new ReturnType(callingClass.FullyQualifiedName), typeName);
+			if (t != null) {
+				showStatic = false;
+				return t;
+			}
+//			Console.WriteLine(&quot;No static member found&quot;);
+			
+			// try if there exists a static member in outer classes named typeName
+			ClassCollection classes = GetOuterClasses(); //cu, caretLine, caretColumn);
+			foreach (IClass c in classes) {
+				t = SearchMember(callingClass == null ? null : new ReturnType(c.FullyQualifiedName), typeName);
+				if (t != null) {
+					showStatic = false;
+					return t;
+				}
+			}
+//			Console.WriteLine(&quot;No static member in outer classes found&quot;);
+//			Console.WriteLine(&quot;DynamicLookUp resultless&quot;);
+			return null;
+		}
+		
+		IProperty GetProperty()
+		{
+			foreach (IProperty property in callingClass.Properties) {
+				if (property.BodyRegion != null &amp;&amp; property.BodyRegion.IsInside(caretLine, caretColumn)) {
+					return property;
+				}
+			}
+			return null;
+		}
+		
+		IMethod GetMethod()
+		{
+			foreach (IMethod method in callingClass.Methods) {
+				if (method.BodyRegion != null &amp;&amp; method.BodyRegion.IsInside(caretLine, caretColumn)) {
+					return method;
+				}
+			}
+			return null;
+		}
+		
+		IReturnType SearchProperty()
+		{
+			IProperty property = GetProperty();
+			if (property == null) {
+				return null;
+			}
+			if (property.SetterRegion != null &amp;&amp; property.SetterRegion.IsInside(caretLine, caretColumn)) {
+				return property.ReturnType;
+			}
+			return null;
+		}
+		
+		IReturnType SearchMethodParameter(string parameter)
+		{
+			IMethod method = GetMethod();
+			if (method == null) {
+				//Console.WriteLine(&quot;Method not found&quot;);
+				return null;
+			}
+			foreach (IParameter p in method.Parameters) {
+				if (p.Name.ToLower() == parameter.ToLower()) {
+				//	Console.WriteLine(&quot;Parameter found&quot;);
+					return p.ReturnType;
+				}
+			}
+			return null;
+		}
+		
+		public string SearchNamespace(string name, ICompilationUnit unit)
+		{
+			try{
+			//return parserService.SearchNamespace(project,null,name,false); //, unit, caretLine, caretColumn, false);
+			if (parserService.NamespaceExists(project, name)) {
+				return name;
+			}
+			if (unit == null) {
+				//Console.WriteLine(&quot;done, resultless&quot;);
+				//return null;
+				return parserService.SearchNamespace(project,null,name,false); //, unit, caretLine, caretColumn, false);
+			}
+			foreach (IUsing u in unit.Usings) {
+				if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
+					string nameSpace = parserService.SearchNamespace (project, u, name);
+					if (nameSpace != null) {
+						return nameSpace;
+					}
+				}
+			}
+ 			//Console.WriteLine(&quot;done, resultless&quot;);
+			//return null;
+			return parserService.SearchNamespace(project,null,name,false); //, unit, caretLine, caretColumn, false);
+			}catch(Exception ex){
+				//Console.WriteLine(&quot;done, resultless&quot;);
+				return null;
+			}
+		}
+		
+		
+		/// &lt;remarks&gt;
+		/// use the usings and the name of the namespace to find a class
+		/// &lt;/remarks&gt;
+		public IClass SearchType(string name, ICompilationUnit unit)
+		{
+//			Console.WriteLine(&quot;Searching Type &quot; + name);
+			if (name == null || name == String.Empty) {
+//				Console.WriteLine(&quot;No Name!&quot;);
+				return null;
+			}
+			IClass c;
+			c = parserService.GetClass(project, name,true,false);
+			if (c != null) {
+//				Console.WriteLine(&quot;Found!&quot;);
+				return c;
+			}
+			//Console.WriteLine(&quot;No FullName&quot;);
+			if (unit != null) {
+				//Console.WriteLine(unit.Usings.Count + &quot; Usings&quot;);
+				foreach (IUsing u in unit.Usings) {
+					if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
+//						Console.WriteLine(&quot;In UsingRegion&quot;);
+						c = parserService.SearchType(project, u, name);
+						if (c != null) {
+//							Console.WriteLine(&quot;SearchType Successfull!!!&quot;);
+							return c;
+						}
+					}
+				}
+			}
+			if (callingClass == null) {
+				//Console.WriteLine(&quot;NULL calling class!&quot;);
+				return null;
+			}
+			string fullname = callingClass.FullyQualifiedName;
+			string[] namespaces = fullname.Split(new char[] {'.'});
+			string curnamespace = &quot;&quot;;
+			int i = 0;
+			
+			do {
+				curnamespace += namespaces[i] + '.';
+				c = parserService.GetClass(project, curnamespace + name,true,false);
+				if (c != null) {
+					return c;
+				}
+				i++;
+			}
+			while (i &lt; namespaces.Length);
+			
+			return null;
+		}
+		
+		/// &lt;remarks&gt;
+		/// use the usings and the name of the namespace to find a class
+		/// &lt;/remarks&gt;
+		public IClass SearchType(string name, IClass curType)
+		{
+			return parserService.SearchType(project,name, curType,null); //, caretLine, caretColumn, false);
+		}
+		
+		/// &lt;remarks&gt;
+		/// use the usings and the name of the namespace to find a class
+		/// &lt;/remarks&gt;
+		public IClass SearchType(string name, IClass curType, ICompilationUnit unit)
+		{
+			return parserService.SearchType(project,name, curType,unit); //, unit, caretLine, caretColumn, false);
+		}
+		
+		public ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName)
+		{
+			//Console.WriteLine(&quot;Entering CtrlSpace for &quot; + caretLine + &quot;:&quot; + caretColumn + &quot; in &quot; + fileName);
+			ArrayList result = new ArrayList(TypeReference.PrimitiveTypes);
+			this.parserService = parserService;
+			IParseInformation parseInfo = parserService.GetParseInformation(fileName);
+			ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit fileCompilationUnit = parseInfo.MostRecentCompilationUnit.Tag as ICSharpCode.SharpRefactory.Parser.AST.VB.CompilationUnit;
+			if (fileCompilationUnit == null) {
+				//Console.WriteLine(&quot;!Warning: no parseinformation!&quot;);
+				return null;
+			}
+			LookupTableVisitor lookupTableVisitor = new LookupTableVisitor();
+			lookupTableVisitor.Visit(fileCompilationUnit, null);
+			VBNetVisitor vBNetVisitor = new VBNetVisitor();
+			cu = (ICompilationUnit)vBNetVisitor.Visit(fileCompilationUnit, null);
+			if (cu != null) {
+				callingClass = GetInnermostClass();
+				//Console.WriteLine(&quot;CallingClass is &quot; + callingClass == null ? &quot;null&quot; : callingClass.Name);
+			}
+			foreach (string name in lookupTableVisitor.Variables.Keys) {
+				ArrayList variables = (ArrayList)lookupTableVisitor.Variables[name.ToLower()];
+				if (variables != null &amp;&amp; variables.Count &gt; 0) {
+					foreach (LocalLookupVariable v in variables) {
+						if (IsInside(new Point(caretColumn, caretLine), v.StartPos, v.EndPos)) {
+							result.Add(v);
+							break;
+						}
+					}
+				}
+			}
+			if (callingClass != null) {
+				//result = parserService.ListMembers(result, callingClass, callingClass, InStatic());
+				result=ListMembers(result,callingClass);
+			}
+			string n = &quot;&quot;;
+			result.AddRange(parserService.GetNamespaceContents(project,n, true,false));
+			foreach (IUsing u in cu.Usings) {
+				if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
+					foreach (string name in u.Usings) {
+						result.AddRange(parserService.GetNamespaceContents(project,name,true, false));
+					}
+					foreach (string alias in u.Aliases.Keys) {
+						result.Add(alias);
+					}
+				}
+			}
+			return result;
+		}
+	
+	
+		public IClass BaseClass(IClass curClass)
+		{
+			foreach (string s in curClass.BaseTypes) {
+				IClass baseClass = parserService.GetClass (project, s, true, false);
+				if (baseClass != null &amp;&amp; baseClass.ClassType != ClassType.Interface) {
+					return baseClass;
+				}
+			}
+			return null;
+		}
+		
+		bool IsAccessible(IClass c, IDecoration member)
+		{
+//			Console.WriteLine(&quot;member.Modifiers = &quot; + member.Modifiers);
+			if ((member.Modifiers &amp; ModifierEnum.Internal) == ModifierEnum.Internal) {
+				return false;
+			}
+			if ((member.Modifiers &amp; ModifierEnum.Public) == ModifierEnum.Public) {
+//				Console.WriteLine(&quot;IsAccessible&quot;);
+				return true;
+			}
+			if ((member.Modifiers &amp; ModifierEnum.Protected) == ModifierEnum.Protected &amp;&amp; IsClassInInheritanceTree(c, callingClass)) {
+//				Console.WriteLine(&quot;IsAccessible&quot;);
+				return true;
+			}
+			return c.FullyQualifiedName == callingClass.FullyQualifiedName;
+		}
+		
+		bool MustBeShown(IClass c, IDecoration member)
+		{
+//			Console.WriteLine(&quot;member:&quot; + member.Modifiers);
+			if ((!showStatic &amp;&amp;  ((member.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static)) ||
+			    ( showStatic &amp;&amp; !((member.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static))) {
+				//// enum type fields are not shown here - there is no info in member about enum field
+				return false;
+			}
+//			Console.WriteLine(&quot;Testing Accessibility&quot;);
+			return IsAccessible(c, member);
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns true, if class possibleBaseClass is in the inheritance tree from c
+		/// &lt;/remarks&gt;
+		bool IsClassInInheritanceTree(IClass possibleBaseClass, IClass c)
+		{
+			if (possibleBaseClass == null || c == null) {
+				return false;
+			}
+			if (possibleBaseClass.FullyQualifiedName == c.FullyQualifiedName) {
+				return true;
+			}
+			foreach (string baseClass in c.BaseTypes) {
+				IClass bc = parserService.GetClass (project, baseClass, true, false);
+				if (IsClassInInheritanceTree(possibleBaseClass, bc)) {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns all (nestet) classes in which the carret currently is exept
+		/// the innermost class, returns an empty collection if the carret is in 
+		/// no class or only in the innermost class.
+		/// the most outer class is the last in the collection.
+		/// &lt;/remarks&gt;
+		ClassCollection GetOuterClasses()
+		{
+			ClassCollection classes = new ClassCollection();
+			if (cu != null) {
+				foreach (IClass c in cu.Classes) {
+					if (c != null &amp;&amp; c.Region != null &amp;&amp; c.Region.IsInside(caretLine, caretColumn)) {
+						if (c != GetInnermostClass()) {
+							GetOuterClasses(classes, c);
+							classes.Add(GetResolvedClass (c));
+						}
+						break;
+					}
+				}
+			}
+			
+			return classes;
+		}
+		
+		void GetOuterClasses(ClassCollection classes, IClass curClass)
+		{
+			if (curClass != null) {
+				foreach (IClass c in curClass.InnerClasses) {
+					if (c != null &amp;&amp; c.Region != null &amp;&amp; c.Region.IsInside(caretLine, caretColumn)) {
+						if (c != GetInnermostClass()) {
+							GetOuterClasses(classes, c);
+							classes.Add(GetResolvedClass (c));
+						}
+						break;
+					}
+				}
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/AttributeSection.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/AttributeSection.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/AttributeSection.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,27 @@
+// created on 08.09.2003 at 16:17
+
+using MonoDevelop.Internal.Parser;
+using System.Collections;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class AttributeSection : AbstractAttributeSection
+	{
+		public AttributeSection(AttributeTarget attributeTarget,
+		                        AttributeCollection attributes) {
+			this.attributeTarget = attributeTarget;
+			this.attributes = attributes;
+		}
+	}
+	public class ASTAttribute : AbstractAttribute
+	{
+		public ASTAttribute(string name, ArrayList positionalArguments, SortedList namedArguments)
+		{
+			this.name = name;
+			this.positionalArguments = positionalArguments;
+			this.namedArguments = namedArguments;
+		}
+	}
+	
+	
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,65 @@
+// created on 06.08.2003 at 12:37
+
+using System.Diagnostics;
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Class : AbstractClass
+	{
+		ICompilationUnit cu;
+		
+		public Class(CompilationUnit cu, ClassType t, Modifier m, IRegion region)
+		{
+			this.cu = cu;
+			classType = t;
+			this.region = region;
+			modifiers = (ModifierEnum)m;
+		}
+		
+		public void UpdateModifier()
+		{
+			if (classType == ClassType.Enum) {
+				foreach (Field f in Fields) {
+					f.AddModifier(ModifierEnum.Public);
+				}
+				return;
+			}
+			if (classType != ClassType.Interface) {
+				return;
+			}
+			foreach (Class c in InnerClasses) {
+				c.modifiers = c.modifiers | ModifierEnum.Public;
+			}
+			foreach (IMethod m in Methods) {
+				if (m is Constructor) {
+					((Constructor)m).AddModifier(ModifierEnum.Public);
+				} else if (m is Method) {
+					((Method)m).AddModifier(ModifierEnum.Public);
+				} else {
+					Debug.Assert(false, &quot;Unexpected type in method of interface. Can not set modifier to public!&quot;);
+				}
+			}
+			foreach (Event e in Events) {
+				e.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Field f in Fields) {
+				f.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Indexer i in Indexer) {
+				i.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Property p in Properties) {
+				p.AddModifier(ModifierEnum.Public);
+			}
+			
+		}
+		public override ICompilationUnit CompilationUnit {
+			get {
+				return cu;
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/CompilationUnit.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/CompilationUnit.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/CompilationUnit.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,26 @@
+// created on 04.08.2003 at 17:31
+
+using MonoDevelop.Internal.Parser;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class CompilationUnit : AbstractCompilationUnit
+	{
+		
+		public override CommentCollection MiscComments {
+			get {
+				return null;
+			}
+		}
+		public override CommentCollection DokuComments {
+			get {
+				return null;
+			}
+		}
+		public override TagCollection TagComments {
+			get {
+				return null;
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,23 @@
+// created on 06.08.2003 at 12:35
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Constructor : AbstractMethod
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Constructor(Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = &quot;#ctor&quot;;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,24 @@
+// created on 06.08.2003 at 12:30
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Event : AbstractEvent
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Event(string name, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = name;
+			returnType         = type;
+			this.region        = region;
+			this.bodyRegion    = bodyRegion;
+			modifiers          = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,29 @@
+// created on 04.08.2003 at 18:06
+using System;
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Field : AbstractField
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Field(ReturnType type, string fullyQualifiedName, Modifier m, IRegion region)
+		{
+			this.returnType = type;
+			this.FullyQualifiedName = fullyQualifiedName;
+			this.region = region;
+			modifiers = (ModifierEnum)m;
+//			Console.WriteLine(&quot;modifiers for field {0} are {1} were {2}&quot;, fullyQualifiedName, modifiers, m);
+		}
+		
+		public void SetModifiers(ModifierEnum m)
+		{
+			modifiers = m;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,24 @@
+// created on 06.08.2003 at 12:34
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Indexer : AbstractIndexer
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Indexer(ReturnType type, ParameterCollection parameters, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			returnType      = type;
+			this.parameters = parameters;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,24 @@
+// created on 06.08.2003 at 12:35
+using System;
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Method : AbstractMethod
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Method(string name, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = name;
+			returnType = type;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,15 @@
+// created on 07.08.2003 at 20:12
+
+using MonoDevelop.Internal.Parser;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Parameter : AbstractParameter
+	{
+		public Parameter(string name, ReturnType type)
+		{
+			Name = name;
+			returnType = type;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,24 @@
+// created on 06.08.2003 at 12:36
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Property : AbstractProperty
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Property(string fullyQualifiedName, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			this.FullyQualifiedName = fullyQualifiedName;
+			returnType = type;
+			this.region = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,52 @@
+// created on 04.08.2003 at 18:08
+using System;
+using MonoDevelop.Internal.Parser;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class ReturnType : AbstractReturnType
+	{
+		public new int PointerNestingLevel {
+			get {
+				return base.pointerNestingLevel;
+			}
+			set {
+				base.pointerNestingLevel = value;
+			}
+		}
+		
+		public new int[] ArrayDimensions {
+			get {
+				return base.arrayDimensions;
+			}
+			set {
+				base.arrayDimensions = value;
+			}
+		}
+		
+		public ReturnType(string fullyQualifiedName)
+		{
+			base.FullyQualifiedName = fullyQualifiedName;
+//			Console.WriteLine(&quot;NEW RETURN TYPE WITH : &quot; + fullyQualifiedName);
+		}
+		
+		public ReturnType(string fullyQualifiedName, int[] arrayDimensions, int pointerNestingLevel)
+		{
+			this.FullyQualifiedName  = fullyQualifiedName;
+			this.arrayDimensions     = arrayDimensions;
+			this.pointerNestingLevel = pointerNestingLevel;
+		}
+		
+		public ReturnType(ICSharpCode.SharpRefactory.Parser.AST.VB.TypeReference type)
+		{
+			base.FullyQualifiedName  = type.SystemType == null ? type.Type : type.SystemType;
+			base.arrayDimensions     = type.RankSpecifier == null ? new int[] { } : (int[])type.RankSpecifier.ToArray(typeof(int));
+			base.pointerNestingLevel = 0;
+		}
+		
+		public ReturnType Clone()
+		{
+			return new ReturnType(FullyQualifiedName, arrayDimensions, pointerNestingLevel);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/TypeVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/TypeVisitor.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/TypeVisitor.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,272 @@
+// created on 22.08.2003 at 19:02
+
+using System;
+using System.Collections;
+
+//using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using VBBinding.Parser.SharpDevelopTree;
+
+using MonoDevelop.Internal.Parser;
+
+namespace VBBinding.Parser
+{
+	
+	public class TypeVisitor : AbstractASTVisitor
+	{
+		Resolver resolver;
+		
+		public TypeVisitor(Resolver resolver)
+		{
+			this.resolver = resolver;
+		}
+		
+		public override object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			if (primitiveExpression.Value != null) {
+//				Console.WriteLine(&quot;Visiting &quot; + primitiveExpression.Value);
+				return new ReturnType(primitiveExpression.Value.GetType().FullName);
+			}
+			return null;
+		}
+		
+		public override object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			// TODO : Operators 
+			return binaryOperatorExpression.Left.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			if (parenthesizedExpression == null) {
+				return null;
+			}
+			return parenthesizedExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(InvocationExpression invocationExpression, object data)
+		{
+			if (invocationExpression.TargetObject is FieldReferenceOrInvocationExpression) {
+				FieldReferenceOrInvocationExpression field = (FieldReferenceOrInvocationExpression)invocationExpression.TargetObject;
+				IReturnType type = field.TargetObject.AcceptVisitor(this, data) as IReturnType;
+				ArrayList methods = resolver.SearchMethod(type, field.FieldName);
+				resolver.ShowStatic = false;
+				if (methods.Count &lt;= 0) {
+					return null;
+				}
+				// TODO: Find the right method
+				return ((IMethod)methods[0]).ReturnType;
+			} else if (invocationExpression.TargetObject is IdentifierExpression) {
+				string id = ((IdentifierExpression)invocationExpression.TargetObject).Identifier;
+				if (resolver.CallingClass == null) {
+					return null;
+				}
+				IReturnType type = new ReturnType(resolver.CallingClass.FullyQualifiedName);
+				ArrayList methods = resolver.SearchMethod(type, id);
+				resolver.ShowStatic = false;
+				if (methods.Count &lt;= 0) {
+					return null;
+				}
+				// TODO: Find the right method
+				return ((IMethod)methods[0]).ReturnType;
+			}
+			// invocationExpression is delegate call
+			IReturnType t = invocationExpression.AcceptChildren(this, data) as IReturnType;
+			if (t == null) {
+				return null;
+			}
+			IClass c = resolver.SearchType(t.FullyQualifiedName, resolver.CallingClass, resolver.CompilationUnit);
+			if (c.ClassType == ClassType.Delegate) {
+				ArrayList methods = resolver.SearchMethod(t, &quot;invoke&quot;);
+				if (methods.Count &lt;= 0) {
+					return null;
+				}
+				return ((IMethod)methods[0]).ReturnType;
+			}
+			return null;
+		}
+		
+		
+		//TODO - Verify logic; did a lot of &quot;just make it work&quot; hacking in this method
+		public override object Visit(FieldReferenceOrInvocationExpression fieldReferenceExpression, object data)
+		{
+			if (fieldReferenceExpression == null) {
+				return null;
+			}
+			
+			IReturnType returnType = fieldReferenceExpression.TargetObject.AcceptVisitor(this, data) as IReturnType;
+			if (returnType != null) {
+				//Console.WriteLine(&quot;Got type: &quot; + returnType.FullyQualifiedName);
+				string name = resolver.SearchNamespace(returnType.FullyQualifiedName, resolver.CompilationUnit);
+				if (name != null) {
+					//Console.WriteLine(&quot;Got subtype: &quot; + name + &quot;.&quot; + fieldReferenceExpression.FieldName);
+					string n = resolver.SearchNamespace(string.Concat(name, &quot;.&quot;, fieldReferenceExpression.FieldName), null);
+					if (n != null) {
+						return new ReturnType(n);
+					}
+					//Console.WriteLine(&quot;Trying classes&quot;);
+					IClass c = resolver.SearchType(string.Concat(name, &quot;.&quot;, fieldReferenceExpression.FieldName), resolver.CallingClass, resolver.CompilationUnit);
+					//IClass c = resolver.SearchType(string.Concat(name, &quot;.&quot;, fieldReferenceExpression.FieldName),  resolver.CompilationUnit);
+					if (c != null) {
+						resolver.ShowStatic = true;
+						return new ReturnType(c.FullyQualifiedName);
+					}
+					
+					//FIXME?
+					try{
+						return new ReturnType(name + &quot;.&quot; + fieldReferenceExpression.FieldName);
+					}catch(Exception ex){
+						return null;	
+					}
+				}
+				//Console.WriteLine(&quot;Trying Members&quot;);
+				return resolver.SearchMember(returnType, fieldReferenceExpression.FieldName);
+			}
+//			Console.WriteLine(&quot;returnType of child is null!&quot;);
+			return null;
+		}
+		
+		public override object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			//Console.WriteLine(&quot;visiting IdentifierExpression&quot;);
+			if (identifierExpression == null) {
+				//Console.WriteLine(&quot;identifierExpression == null&quot;);
+				return null;
+			}
+			string name = resolver.SearchNamespace(identifierExpression.Identifier, resolver.CompilationUnit);
+			if (name != null) {
+				return new ReturnType(name);
+			}
+			//Console.WriteLine(&quot;no namespace found&quot;);
+			IClass c = resolver.SearchType(identifierExpression.Identifier, resolver.CallingClass, resolver.CompilationUnit);
+			if (c != null) {
+				resolver.ShowStatic = true;
+				return new ReturnType(c.FullyQualifiedName);
+			}
+			//Console.WriteLine(&quot;no type found&quot;);
+			return resolver.DynamicLookup(identifierExpression.Identifier);
+		}
+		
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			return new ReturnType(typeReferenceExpression.TypeReference);
+		}
+		
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			if (unaryOperatorExpression == null) {
+				return null;
+			}
+			ReturnType expressionType = unaryOperatorExpression.Expression.AcceptVisitor(this, data) as ReturnType;
+			// TODO: Little bug: unary operator MAY change the return type,
+			//                   but that is only a minor issue
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.Not:
+					break;
+				case UnaryOperatorType.BitNot:
+					break;
+				case UnaryOperatorType.Minus:
+					break;
+				case UnaryOperatorType.Plus:
+					break;
+				case UnaryOperatorType.Increment:
+				case UnaryOperatorType.PostIncrement:
+					break;
+				case UnaryOperatorType.Decrement:
+				case UnaryOperatorType.PostDecrement:
+					break;
+				case UnaryOperatorType.Star:       // dereference
+					--expressionType.PointerNestingLevel;
+					break;
+				case UnaryOperatorType.BitWiseAnd: // get reference
+					++expressionType.PointerNestingLevel; 
+					break;
+				case UnaryOperatorType.None:
+					break;
+			}
+			return expressionType;
+		}
+		
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			return assignmentExpression.Left.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(GetTypeExpression getTypeExpression, object data)
+		{
+			return new ReturnType(&quot;System.Type&quot;);
+		}
+		
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			return new ReturnType(&quot;System.Type&quot;);
+		}
+		
+		public override object Visit(AddressOfExpression addressOfExpression, object data)
+		{
+			// no calls allowed !!!
+			return null;
+		}
+		
+		public override object Visit(CastExpression castExpression, object data)
+		{
+			return new ReturnType(castExpression.CastTo.Type);
+		}
+		
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			if (resolver.CallingClass == null) {
+				return null;
+			}
+			return new ReturnType(resolver.CallingClass.FullyQualifiedName);
+		}
+		
+		public override object Visit(ClassReferenceExpression classReferenceExpression, object data)
+		{
+			if (resolver.CallingClass == null) {
+				return null;
+			}
+			return new ReturnType(resolver.CallingClass.FullyQualifiedName);
+		}
+		
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			if (resolver.CallingClass == null) {
+				return null;
+			}
+			IClass baseClass = resolver.BaseClass(resolver.CallingClass);
+			if (baseClass == null) {
+				return null;
+			}
+			return new ReturnType(baseClass.FullyQualifiedName);
+		}
+		
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			string name = resolver.SearchType(objectCreateExpression.CreateType.Type, resolver.CallingClass, resolver.CompilationUnit).FullyQualifiedName;
+			return new ReturnType(name, (int[])objectCreateExpression.CreateType.RankSpecifier.ToArray(typeof(int)), 0);
+		}
+		
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			ReturnType type = new ReturnType(arrayCreateExpression.CreateType);
+			if (arrayCreateExpression.Parameters != null &amp;&amp; arrayCreateExpression.Parameters.Count &gt; 0) {
+				int[] newRank = new int[arrayCreateExpression.CreateType.RankSpecifier.Count + 1];
+				newRank[0] = arrayCreateExpression.Parameters.Count - 1;
+				for (int i = 0; i &lt; type.ArrayDimensions.Length; ++i) {
+					newRank[i + 1] = type.ArrayDimensions[i];
+				}
+				Array.Copy(type.ArrayDimensions, 0, newRank, 1, type.ArrayDimensions.Length);
+				type.ArrayDimensions = newRank;
+			}
+			return type;
+		}
+		
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			// no calls allowed !!!
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/VBNetVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/VBNetVisitor.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/VBNetVisitor.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,230 @@
+// created on 04.08.2003 at 17:49
+using System;
+using System.Drawing;
+using System.Diagnostics;
+using System.Collections;
+
+using RefParser = ICSharpCode.SharpRefactory.Parser.VB;
+using AST = ICSharpCode.SharpRefactory.Parser.AST.VB;
+using MonoDevelop.Internal.Parser;
+using VBBinding.Parser.SharpDevelopTree;
+
+namespace VBBinding.Parser
+{
+	public class Using : AbstractUsing
+	{
+	}
+	
+	public class VBNetVisitor : RefParser.AbstractASTVisitor
+	{
+		CompilationUnit cu = new CompilationUnit();
+		Stack currentNamespace = new Stack();
+		Stack currentClass = new Stack();
+		
+		public CompilationUnit Cu {
+			get {
+				return cu;
+			}
+		}
+		
+		public override object Visit(AST.CompilationUnit compilationUnit, object data)
+		{
+			//TODO: Imports, Comments
+			compilationUnit.AcceptChildren(this, data);
+			return cu;
+		}
+		
+		public override object Visit(AST.ImportsDeclaration usingDeclaration, object data)
+		{
+			Using u = new Using();
+			u.Usings.Add(usingDeclaration.Namespace);
+			cu.Usings.Add(u);
+			return data;
+		}
+		
+		public override object Visit(AST.ImportsAliasDeclaration usingAliasDeclaration, object data)
+		{
+			Using u = new Using();
+			u.Aliases[usingAliasDeclaration.Alias] = usingAliasDeclaration.Namespace;
+			cu.Usings.Add(u);
+			return data;
+		}
+		
+		AttributeSectionCollection VisitAttributes(ArrayList attributes)
+		{
+			// TODO Expressions???
+			AttributeSectionCollection result = new AttributeSectionCollection();
+			foreach (AST.AttributeSection section in attributes) {
+				AttributeCollection resultAttributes = new AttributeCollection();
+				foreach (AST.Attribute attribute in section.Attributes) {
+					IAttribute a = new ASTAttribute(attribute.Name, new ArrayList(attribute.PositionalArguments), new SortedList());
+					foreach (AST.NamedArgumentExpression n in attribute.NamedArguments) {
+						a.NamedArguments[n.Parametername] = n.Expression;
+					}
+				}
+				IAttributeSection s = new AttributeSection((AttributeTarget)Enum.Parse(typeof (AttributeTarget), section.AttributeTarget), resultAttributes);
+			}
+			return null;
+		}
+		
+//		ModifierEnum VisitModifier(ICSharpCode.SharpRefactory.Parser.Modifier m)
+//		{
+//			return (ModifierEnum)m;
+//		}
+		
+		public override object Visit(AST.NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			string name;
+			if (currentNamespace.Count == 0) {
+				name = namespaceDeclaration.NameSpace;
+			} else {
+				name = String.Concat((string)currentNamespace.Peek(), '.', namespaceDeclaration.NameSpace);
+			}
+			currentNamespace.Push(name);
+			object ret = namespaceDeclaration.AcceptChildren(this, data);
+			currentNamespace.Pop();
+			return ret;
+		}
+		
+		ClassType TranslateClassType(RefParser.Types type)
+		{
+			switch (type) {
+				case RefParser.Types.Class:
+					return ClassType.Class;
+				case RefParser.Types.Enum:
+					return ClassType.Enum;
+				case RefParser.Types.Interface:
+					return ClassType.Interface;
+				case RefParser.Types.Structure:
+					return ClassType.Struct;
+			}
+			return ClassType.Class;
+		}
+		
+		public override object Visit(AST.TypeDeclaration typeDeclaration, object data)
+		{
+			DefaultRegion region = GetRegion(typeDeclaration.StartLocation, typeDeclaration.EndLocation);
+			Class c = new Class(cu, TranslateClassType(typeDeclaration.Type), typeDeclaration.Modifier, region);
+			if (currentClass.Count &gt; 0) {
+				Class cur = ((Class)currentClass.Peek());
+				cur.InnerClasses.Add(c);
+				c.FullyQualifiedName = String.Concat(cur.FullyQualifiedName, '.', typeDeclaration.Name);
+			} else {
+				if (currentNamespace.Count == 0) {
+					c.FullyQualifiedName = typeDeclaration.Name;
+				} else {
+					c.FullyQualifiedName = String.Concat(currentNamespace.Peek(), '.', typeDeclaration.Name);
+				}
+				cu.Classes.Add(c);
+			}
+			if (typeDeclaration.BaseType != null) {
+				c.BaseTypes.Add(typeDeclaration.BaseType);
+			}
+			if (typeDeclaration.BaseInterfaces != null) {
+				foreach (AST.TypeReference type in typeDeclaration.BaseInterfaces) {
+					c.BaseTypes.Add(type.Type);
+				}
+			}
+			currentClass.Push(c);
+			object ret = typeDeclaration.AcceptChildren(this, data);
+			currentClass.Pop();
+			c.UpdateModifier();
+			return ret;
+		}
+		
+		DefaultRegion GetRegion(Point start, Point end)
+		{
+			return new DefaultRegion(start.Y, start.X, end.Y, end.X);
+		}
+		
+		public override object Visit(AST.MethodDeclaration methodDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(methodDeclaration.StartLocation, methodDeclaration.EndLocation);
+			DefaultRegion bodyRegion = GetRegion(methodDeclaration.EndLocation,   methodDeclaration.Body != null ? methodDeclaration.Body.EndLocation : new Point(-1, -1));
+			
+			ReturnType type = methodDeclaration.TypeReference == null ? new ReturnType(&quot;System.Void&quot;) : new ReturnType(methodDeclaration.TypeReference);
+			Class c       = (Class)currentClass.Peek();
+			
+			
+			Method method = new Method(String.Concat(methodDeclaration.Name), type, methodDeclaration.Modifier, region, bodyRegion);
+			ParameterCollection parameters = new ParameterCollection();
+			if (methodDeclaration.Parameters != null) {
+				foreach (AST.ParameterDeclarationExpression par in methodDeclaration.Parameters) {
+					ReturnType parType = new ReturnType(par.TypeReference);
+					Parameter p = new Parameter(par.ParameterName, parType);
+					parameters.Add(p);
+				}
+			}
+			method.Parameters = parameters;
+			c.Methods.Add(method);
+			return null;
+		}
+		
+		public override object Visit(AST.ConstructorDeclaration constructorDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(constructorDeclaration.StartLocation, constructorDeclaration.EndLocation);
+			DefaultRegion bodyRegion = GetRegion(constructorDeclaration.EndLocation, constructorDeclaration.Body != null ? constructorDeclaration.Body.EndLocation : new Point(-1, -1));
+			
+			Class c       = (Class)currentClass.Peek();
+			
+			Constructor constructor = new Constructor(constructorDeclaration.Modifier, region, bodyRegion);
+			ParameterCollection parameters = new ParameterCollection();
+			if (constructorDeclaration.Parameters != null) {
+				foreach (AST.ParameterDeclarationExpression par in constructorDeclaration.Parameters) {
+					ReturnType parType = new ReturnType(par.TypeReference);
+					Parameter p = new Parameter(par.ParameterName, parType);
+					parameters.Add(p);
+				}
+			}
+			constructor.Parameters = parameters;
+			c.Methods.Add(constructor);
+			return null;
+		}
+		
+		
+		public override object Visit(AST.FieldDeclaration fieldDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(fieldDeclaration.StartLocation, fieldDeclaration.EndLocation);
+			Class c = (Class)currentClass.Peek();
+			if (currentClass.Count &gt; 0) {
+				foreach (AST.VariableDeclaration field in fieldDeclaration.Fields) {
+					ReturnType type = null;
+					if (field.Type != null) {
+						type = new ReturnType(field.Type);
+					}
+					Field f = new Field(type, field.Name, fieldDeclaration.Modifier, region);
+					if (type == null) {
+						f.SetModifiers(ModifierEnum.Const | ModifierEnum.SpecialName);
+					}
+					c.Fields.Add(f);
+				}
+			}
+			return null;
+		}
+		
+		public override object Visit(AST.PropertyDeclaration propertyDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(propertyDeclaration.StartLocation, propertyDeclaration.EndLocation);
+			DefaultRegion bodyRegion = GetRegion(propertyDeclaration.BodyStart,     propertyDeclaration.BodyEnd);
+			
+			ReturnType type = propertyDeclaration.TypeReference == null ? new ReturnType(&quot;System.Void&quot;) : new ReturnType(propertyDeclaration.TypeReference);
+			Class c = (Class)currentClass.Peek();
+			
+			Property property = new Property(propertyDeclaration.Name, type, propertyDeclaration.Modifier, region, bodyRegion);
+			c.Properties.Add(property);
+			return null;
+		}
+		
+		public override object Visit(AST.EventDeclaration eventDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(eventDeclaration.StartLocation, eventDeclaration.EndLocation);
+			DefaultRegion bodyRegion = null;
+			
+			ReturnType type = eventDeclaration.TypeReference != null ? new ReturnType(eventDeclaration.TypeReference) : null;
+			Class c = (Class)currentClass.Peek();
+			Event e = new Event(eventDeclaration.Name, type, eventDeclaration.Modifier, region, bodyRegion);
+			c.Events.Add(e);
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/VBCompilerParameters.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/VBCompilerParameters.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/VBCompilerParameters.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,368 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Xml;
+using System.Diagnostics;
+using System.ComponentModel;
+
+using MonoDevelop.Internal.Project;
+
+namespace VBBinding {
+	
+	public enum CompileTarget
+	{
+		Exe,
+		WinExe,
+		Library,
+		Module
+	};
+	
+	public enum VBCompiler {
+		Vbc,
+		Mbas
+	};
+	
+	public enum NetRuntime {
+		Mono,
+		MonoInterpreter,
+		MsNet
+	};
+	
+	/// &lt;summary&gt;
+	/// This class handles project specific compiler parameters
+	/// &lt;/summary&gt;
+	public class VBCompilerParameters : AbstractProjectConfiguration
+	{
+		[XmlNodeName(&quot;CodeGeneration&quot;)]
+		class CodeGeneration 
+		{
+			[XmlAttribute(&quot;compilerversion&quot;)]
+			public string vbCompilerVersion = String.Empty;
+			
+			[XmlAttribute(&quot;runtime&quot;)]
+			public NetRuntime netRuntime         = NetRuntime.Mono;
+			
+			[XmlAttribute(&quot;compiler&quot;)]
+			public VBCompiler vbCompiler = VBCompiler.Mbas;
+			
+			[XmlAttribute(&quot;warninglevel&quot;)]
+			public int  warninglevel       = 4;
+			
+			[XmlAttribute(&quot;nowarn&quot;)]
+			public string noWarnings      = String.Empty;
+			
+			//[XmlAttribute(&quot;includedebuginformation&quot;)]
+			//public bool debugmode = false;
+			
+			[XmlAttribute(&quot;optimize&quot;)]
+			public bool optimize = true;
+			
+			[XmlAttribute(&quot;unsafecodeallowed&quot;)]
+			public bool unsafecode         = false;
+			
+			[XmlAttribute(&quot;generateoverflowchecks&quot;)]
+			public bool generateOverflowChecks = true;
+			
+			[XmlAttribute(&quot;rootnamespace&quot;)]
+			public string rootnamespace = String.Empty;
+			
+			[XmlAttribute(&quot;mainclass&quot;)]
+			public string mainclass = null;
+			
+			[XmlAttribute(&quot;target&quot;)]
+			public CompileTarget  compiletarget = CompileTarget.Exe;
+			
+			[XmlAttribute(&quot;definesymbols&quot;)]
+			public string definesymbols = String.Empty;
+			
+			[XmlAttribute(&quot;generatexmldocumentation&quot;)]
+			public bool generateXmlDocumentation = false;
+			
+			[XmlAttribute(&quot;optionexplicit&quot;)]
+			public bool optionExplicit = true;
+			
+			[XmlAttribute(&quot;optionstrict&quot;)]
+			public bool optionStrict = false;
+			
+			[ConvertToRelativePathAttribute()]
+			[XmlAttribute(&quot;win32Icon&quot;)]
+			public string win32Icon = String.Empty;
+			
+			[XmlAttribute(&quot;imports&quot;)]
+			public string imports = String.Empty;
+		}
+		
+		[XmlNodeName(&quot;Execution&quot;)]
+		class Execution
+		{
+			[XmlAttribute(&quot;consolepause&quot;)]
+			public bool pauseconsoleoutput = true;
+			
+			[XmlAttribute(&quot;commandlineparameters&quot;)]
+			public string commandLineParameters = String.Empty;
+			
+		}
+		
+		[XmlNodeName(&quot;VBDOC&quot;)]
+		class VBDOC
+		{
+			[XmlAttribute(&quot;outputfile&quot;)]
+			[ConvertToRelativePathAttribute()]
+			public string outputfile = String.Empty;
+			
+			[XmlAttribute(&quot;filestoparse&quot;)]
+			public string filestoparse = String.Empty;
+			
+			[XmlAttribute(&quot;commentprefix&quot;)]
+			public string commentprefix = &quot;'&quot;;
+		}
+		
+		CodeGeneration codeGeneration = new CodeGeneration();
+		VBDOC		   vbdoc		  = new VBDOC();
+		Execution      execution      = new Execution();
+		
+		[Browsable(false)]
+		public string VBCompilerVersion
+		{
+			get {
+				return codeGeneration.vbCompilerVersion;
+			}
+			set {
+				codeGeneration.vbCompilerVersion = value;
+			}
+		} 
+		
+		[Browsable(false)]
+		public VBCompiler VBCompiler {
+			get {
+				return codeGeneration.vbCompiler;
+			}
+			set {
+				codeGeneration.vbCompiler = value;
+			}
+		}
+		
+		[Browsable(false)]
+		public NetRuntime NetRuntime {
+			get {
+				return codeGeneration.netRuntime;
+			}
+			set {
+				codeGeneration.netRuntime = value;
+			}
+		}
+		
+		public string CommandLineParameters
+		{
+			get {
+				return execution.commandLineParameters;
+			}
+			set {
+				execution.commandLineParameters = value;
+			}
+		}
+		public bool GenerateOverflowChecks
+		{
+			get {
+				return codeGeneration.generateOverflowChecks;
+			}
+			set {
+				codeGeneration.generateOverflowChecks = value;
+			}
+		}
+		
+		[DefaultValue(false)]
+//		[LocalizedProperty(&quot;${res:BackendBindings.CompilerOptions.CodeGeneration.UnsafeCode}&quot;,
+//		                   Category    = &quot;${res:BackendBindings.CompilerOptions.CodeGeneration}&quot;,
+//		                   Description = &quot;${res:BackendBindings.CompilerOptions.CodeGeneration.UnsafeCode.Description}&quot;)]
+		public bool UnsafeCode {
+			get {
+				return codeGeneration.unsafecode;
+			}
+			set {
+				codeGeneration.unsafecode = value;
+			}
+		}
+		
+		[DefaultValue(false)]
+//		[LocalizedProperty(&quot;${res:BackendBindings.CompilerOptions.CodeGeneration.GenerateXmlDocumentation}&quot;,
+//		                   Category    = &quot;${res:BackendBindings.CompilerOptions.CodeGeneration}&quot;,
+//		                   Description = &quot;${res:BackendBindings.CompilerOptions.CodeGeneration.GenerateXmlDocumentation.Description}&quot;)]
+		public bool GenerateXmlDocumentation {
+			get {
+				return codeGeneration.generateXmlDocumentation;
+			}
+			set {
+				codeGeneration.generateXmlDocumentation = value;
+			}
+		}
+		
+		
+		[DefaultValue(4)]
+//		[LocalizedProperty(&quot;${res:BackendBindings.CompilerOptions.WarningAndErrorCategory.WarningLevel}&quot;,
+//		                   Category    = &quot;${res:BackendBindings.CompilerOptions.WarningAndErrorCategory}&quot;,
+//		                   Description = &quot;${res:BackendBindings.CompilerOptions.WarningAndErrorCategory.WarningLevel.Description}&quot;)]
+		public int WarningLevel {
+			get {
+				return codeGeneration.warninglevel;
+			}
+			set {
+				codeGeneration.warninglevel = value;
+			}
+		}
+		
+		public string Imports
+		{
+			get {
+				return codeGeneration.imports;
+			}
+			set {
+				codeGeneration.imports = value;
+			}
+		}
+		
+		public string Win32Icon
+		{
+			get {
+				return codeGeneration.win32Icon;
+			}
+			set {
+				codeGeneration.win32Icon = value;
+			}
+		}
+		
+		public string RootNamespace
+		{
+			get {
+				return codeGeneration.rootnamespace;
+			}
+			set {
+				codeGeneration.rootnamespace = value;
+			}
+		}
+		
+		public string DefineSymbols
+		{
+			get {
+				return codeGeneration.definesymbols;
+			}
+			set {
+				codeGeneration.definesymbols = value;
+			}
+		}
+		
+		public bool PauseConsoleOutput
+		{
+			get {
+				return execution.pauseconsoleoutput;
+			}
+			set {
+				execution.pauseconsoleoutput = value;
+			}
+		}
+		
+		//public bool Debugmode
+		//{
+		//	get {
+		//		return codeGeneration.debugmode;
+		//	}
+		//	set {
+		//		codeGeneration.debugmode = value;
+		//	}
+		//}
+		
+		public bool Optimize
+		{
+			get {
+				return codeGeneration.optimize;
+			}
+			set {
+				codeGeneration.optimize = value;
+			}
+		}
+		
+		public string MainClass
+		{
+			get {
+				return codeGeneration.mainclass;
+			}
+			set {
+				codeGeneration.mainclass = value;
+			}
+		}
+		
+		public CompileTarget CompileTarget
+		{
+			get {
+				return codeGeneration.compiletarget;
+			}
+			set {
+				codeGeneration.compiletarget = value;
+			}
+		}
+		
+		public bool OptionExplicit
+		{
+			get {
+				return codeGeneration.optionExplicit;
+			}
+			set {
+				codeGeneration.optionExplicit = value;
+			}
+		}
+		
+		public bool OptionStrict
+		{
+			get {
+				return codeGeneration.optionStrict;
+			}
+			set {
+				codeGeneration.optionStrict = value;
+			}
+		}
+		
+		public string VBDOCOutputFile
+		{
+			get {
+				return vbdoc.outputfile;
+			}
+			set {
+				vbdoc.outputfile = value;
+			}
+		}
+		
+		public string[] VBDOCFiles
+		{
+			get {
+				return vbdoc.filestoparse.Split(';');
+			}
+			set {
+				vbdoc.filestoparse = System.String.Join(&quot;;&quot;, value);
+			}
+		}
+		
+		public string VBDOCCommentPrefix
+		{
+			get {
+				return vbdoc.commentprefix;
+			}
+			set {
+				vbdoc.commentprefix = value;
+			}
+		}
+		
+		public VBCompilerParameters()
+		{
+		}
+		
+		public VBCompilerParameters(string name)
+		{
+			this.name = name;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/VBProject.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/VBProject.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Project/VBProject.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,80 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Diagnostics;
+using System.ComponentModel;
+using System.Xml;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Templates;
+
+namespace VBBinding
+{
+	/// &lt;summary&gt;
+	/// This class describes a VB.NET project and it compilation options.
+	/// &lt;/summary&gt;
+	public class VBProject : AbstractProject
+	{		
+		public override string ProjectType {
+			get {
+				return VBLanguageBinding.LanguageName;
+			}
+		}
+		
+		public override IConfiguration CreateConfiguration()
+		{
+			return new VBCompilerParameters();
+		}
+		
+		public VBProject()
+		{
+		}
+		
+		public VBProject(ProjectCreateInformation info, XmlElement projectOptions)
+		{
+			if (info != null) {
+				Name              = info.ProjectName;
+				
+				//VBCompilerParameters debug = (VBCompilerParameters)CreateConfiguration(&quot;Debug&quot;);
+				//debug.Optimize = false;
+				//release.Debugmode=false;
+				//Configurations.Add(debug);
+				
+				VBCompilerParameters release = (VBCompilerParameters)CreateConfiguration(&quot;Release&quot;);
+				//release.Optimize = true;
+				//release.Debugmode = false;
+				//release.GenerateOverflowChecks = false;
+				//release.TreatWarningsAsErrors = false;
+				Configurations.Add(release);
+
+				XmlElement el = projectOptions;
+				
+				foreach (VBCompilerParameters parameter in Configurations) {
+					parameter.OutputDirectory = info.BinPath + Path.DirectorySeparatorChar + parameter.Name;
+					parameter.OutputAssembly  = Name;
+					
+					if (el != null) {
+						System.Console.WriteLine(&quot;ProjectOptions &quot; + el.OuterXml);
+						if (el.Attributes[&quot;Target&quot;] != null) {
+							parameter.CompileTarget = (CompileTarget)Enum.Parse(typeof(CompileTarget), el.Attributes[&quot;Target&quot;].InnerText);
+						}
+						if (el.Attributes[&quot;PauseConsoleOutput&quot;] != null) {
+							parameter.PauseConsoleOutput = Boolean.Parse(el.Attributes[&quot;PauseConsoleOutput&quot;].InnerText);
+						}
+					}else{
+						System.Console.WriteLine(&quot;ProjectOptions XML is NULL!&quot;);
+					}
+				}
+			}else{
+				System.Console.WriteLine(&quot;NULL Projectinfo!&quot;);
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ProjectNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ProjectNodeBuilder.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ProjectNodeBuilder.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,148 @@
+// created on 10/20/2004 at 10:29 AM
+
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Diagnostics;
+using System.Collections;
+using System.Reflection;
+using System.Resources;
+using System.Xml;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+using MonoDevelop.Gui.Pads.ProjectBrowser;
+using MonoDevelop.Gui.Widgets;
+
+namespace VBBinding
+{
+	public class VBNodeBuilder : IProjectNodeBuilder
+	{
+		FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
+		IconService iconService = (IconService)ServiceManager.GetService(typeof(IconService));
+		
+		public bool CanBuildProjectTree(IProject project)
+		{
+			return project.ProjectType == VBLanguageBinding.LanguageName;
+		}
+		
+		public AbstractBrowserNode BuildProjectTreeNode(IProject project)
+		{
+			ProjectBrowserNode projectNode = new ProjectBrowserNode(project);
+			
+			//projectNode.IconImage = iconService.GetImageForProjectType(project.ProjectType);
+			
+			// create 'empty' directories			
+			for (int i = 0; i &lt; project.ProjectFiles.Count; ++i) {
+				if (project.ProjectFiles[i].Subtype == Subtype.Directory) {
+					string directoryName   = fileUtilityService.AbsoluteToRelativePath(project.BaseDirectory, project.ProjectFiles[i].Name);
+
+					// if directoryname starts with ./ oder .\
+					if (directoryName.StartsWith(&quot;.&quot;)) {
+						directoryName =  directoryName.Substring(2);
+					}
+					
+					string parentDirectory = Path.GetFileName(directoryName);
+					
+					AbstractBrowserNode currentPathNode = GetPath(directoryName, projectNode, true);
+					
+					DirectoryNode newFolderNode  = new DirectoryNode(project.ProjectFiles[i].Name);
+					//newFolderNode.OpenedImage = resourceService.GetBitmap (&quot;Icons.16x16.OpenFolderBitmap&quot;);
+					//newFolderNode.ClosedImage = resourceService.GetBitmap (&quot;Icons.16x16.ClosedFolderBitmap&quot;);
+					
+					currentPathNode.Nodes.Add(newFolderNode);
+				
+				}
+			}
+			
+			// create file tree
+			for (int i = 0; i &lt; project.ProjectFiles.Count; ++i) {
+				if (project.ProjectFiles[i].Subtype != Subtype.Directory) {
+					ProjectFile fileInformation = project.ProjectFiles[i];
+					
+					string relativeFile = fileUtilityService.AbsoluteToRelativePath(project.BaseDirectory, fileInformation.Name);
+					
+					string fileName     = Path.GetFileName(fileInformation.Name);
+					
+					switch (fileInformation.BuildAction) {
+						
+						case BuildAction.Exclude:
+							break;
+						
+						default:
+							AbstractBrowserNode currentPathNode = GetPath(relativeFile, projectNode, true);
+							
+							AbstractBrowserNode newNode = new FileNode(fileInformation);
+							newNode.ContextmenuAddinTreePath = FileNode.ProjectFileContextMenuPath;
+							currentPathNode.Nodes.Add(newNode);
+							break;
+					}
+				}
+			}
+			
+			return projectNode;
+		}
+
+		AbstractBrowserNode GetNodeFromCollection (TreeNodeCollection collection, string title)
+		{
+			foreach (AbstractBrowserNode node in collection) {
+				if (node.Text == title) {
+					return node;
+				}
+			}
+			return null;
+		}
+		
+		public AbstractBrowserNode GetPath(string filename, AbstractBrowserNode root, bool create)
+		{
+			string directory    = Path.GetDirectoryName(filename);
+			string[] treepath   = directory.Split(new char[] { Path.DirectorySeparatorChar });
+			AbstractBrowserNode curpathnode = root;
+			
+			foreach (string path in treepath) {
+				if (path.Length == 0 || path[0] == '.') {
+					continue;
+				}
+				
+				AbstractBrowserNode node = null;
+				//AbstractBrowserNode node = GetNodeFromCollection(curpathnode.Nodes, path);
+				
+				if (node == null) {
+					if (create) {
+						DirectoryNode newFolderNode  = new DirectoryNode(fileUtilityService.GetDirectoryNameWithSeparator(ConstructFolderName(curpathnode)) + path);
+						curpathnode.Nodes.Add(newFolderNode);
+						curpathnode = newFolderNode;
+						continue;
+					} else {
+						return null;
+					}
+				}
+				curpathnode = node;
+			}
+			
+			return curpathnode;
+		}
+		
+		public string ConstructFolderName(AbstractBrowserNode folderNode)
+		{
+			if (folderNode is DirectoryNode) {
+				return ((DirectoryNode)folderNode).FolderName;
+			}
+			
+			if (folderNode is ProjectBrowserNode) {
+				return ((ProjectBrowserNode)folderNode).Project.BaseDirectory;
+			}
+			
+			throw new ApplicationException(&quot;Folder name construction failed, got unexpected parent node :&quot; +  folderNode);
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/Makefile.am	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/Makefile.am	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,130 @@
+CSC = mcs /debug
+
+FILES = \
+./src/AssemblyInfo.cs \
+./src/CodeDom/CodeDOMVisitor.cs \
+./src/CSharpConverter/CSharpVisitor.cs \
+./src/Lexer/Lexer.cs \
+./src/Lexer/Reader/FileReader.cs \
+./src/Lexer/Reader/IReader.cs \
+./src/Lexer/Reader/StringReader.cs \
+./src/Lexer/Specials/Comment.cs \
+./src/Lexer/Specials/CommentType.cs \
+./src/Lexer/Specials/NewLine.cs \
+./src/Lexer/Specials/PreProcessingDirective.cs \
+./src/Lexer/Specials/SpecialTracker.cs \
+./src/Lexer/Specials/TagComment.cs \
+./src/Main.cs \
+./src/Parser/AST/AbstractASTVisitor.cs \
+./src/Parser/AST/AbstractNode.cs \
+./src/Parser/AST/CompilationUnit.cs \
+./src/Parser/AST/Enums.cs \
+./src/Parser/AST/Expressions/AddressOfExpression.cs \
+./src/Parser/AST/Expressions/ArrayCreateExpression.cs \
+./src/Parser/AST/Expressions/ArrayInitializerExpression.cs \
+./src/Parser/AST/Expressions/AssignmentExpression.cs \
+./src/Parser/AST/Expressions/BaseReferenceExpression.cs \
+./src/Parser/AST/Expressions/BinaryOperatorExpression.cs \
+./src/Parser/AST/Expressions/CastExpression.cs \
+./src/Parser/AST/Expressions/ClassReferenceExpression.cs \
+./src/Parser/AST/Expressions/Expression.cs \
+./src/Parser/AST/Expressions/FieldReferenceOrInvocationExpression.cs \
+./src/Parser/AST/Expressions/GetTypeExpression.cs \
+./src/Parser/AST/Expressions/IdentifierExpression.cs \
+./src/Parser/AST/Expressions/InvocationExpression.cs \
+./src/Parser/AST/Expressions/LoopControlVariableExpression.cs \
+./src/Parser/AST/Expressions/NamedArgumentExpression.cs \
+./src/Parser/AST/Expressions/ObjectCreateExpression.cs \
+./src/Parser/AST/Expressions/ParameterDeclarationExpression.cs \
+./src/Parser/AST/Expressions/ParenthesizedExpression.cs \
+./src/Parser/AST/Expressions/PrimitiveExpression.cs \
+./src/Parser/AST/Expressions/StatementExpression.cs \
+./src/Parser/AST/Expressions/ThisReferenceExpression.cs \
+./src/Parser/AST/Expressions/TypeOfExpression.cs \
+./src/Parser/AST/Expressions/TypeReferenceExpression.cs \
+./src/Parser/AST/Expressions/UnaryOperatorExpression.cs \
+./src/Parser/AST/GlobalScope/AttributeDeclaration.cs \
+./src/Parser/AST/GlobalScope/DelegateDeclaration.cs \
+./src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs \
+./src/Parser/AST/GlobalScope/ImportsDeclaration.cs \
+./src/Parser/AST/GlobalScope/ImportsStatement.cs \
+./src/Parser/AST/GlobalScope/NamespaceDeclaration.cs \
+./src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs \
+./src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs \
+./src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs \
+./src/Parser/AST/GlobalScope/TypeDeclaration.cs \
+./src/Parser/AST/IASTVisitor.cs \
+./src/Parser/AST/INode.cs \
+./src/Parser/AST/LookupTableVisitor.cs \
+./src/Parser/AST/Modifier.cs \
+./src/Parser/AST/Statements/AddHandlerStatement.cs \
+./src/Parser/AST/Statements/BlockStatement.cs \
+./src/Parser/AST/Statements/DoLoopStatement.cs \
+./src/Parser/AST/Statements/EndStatement.cs \
+./src/Parser/AST/Statements/EraseStatements.cs \
+./src/Parser/AST/Statements/ErrorStatement.cs \
+./src/Parser/AST/Statements/ExitStatement.cs \
+./src/Parser/AST/Statements/ForeachStatement.cs \
+./src/Parser/AST/Statements/ForStatement.cs \
+./src/Parser/AST/Statements/GoToStatement.cs \
+./src/Parser/AST/Statements/IfStatement.cs \
+./src/Parser/AST/Statements/LabelStatement.cs \
+./src/Parser/AST/Statements/LocalVariableDeclaration.cs \
+./src/Parser/AST/Statements/LockStatement.cs \
+./src/Parser/AST/Statements/OnErrorStatement.cs \
+./src/Parser/AST/Statements/RaiseEventStatement.cs \
+./src/Parser/AST/Statements/ReDimStatement.cs \
+./src/Parser/AST/Statements/RemoveHandlerStatement.cs \
+./src/Parser/AST/Statements/ResumeStatement.cs \
+./src/Parser/AST/Statements/ReturnStatement.cs \
+./src/Parser/AST/Statements/SelectStatement.cs \
+./src/Parser/AST/Statements/Statement.cs \
+./src/Parser/AST/Statements/StopStatement.cs \
+./src/Parser/AST/Statements/ThrowStatement.cs \
+./src/Parser/AST/Statements/TryCatchStatement.cs \
+./src/Parser/AST/Statements/WhileStatement.cs \
+./src/Parser/AST/Statements/WithStatement.cs \
+./src/Parser/AST/TypeLevel/ConstructorDeclaration.cs \
+./src/Parser/AST/TypeLevel/DeclareDeclaration.cs \
+./src/Parser/AST/TypeLevel/EventDeclaration.cs \
+./src/Parser/AST/TypeLevel/FieldDeclaration.cs \
+./src/Parser/AST/TypeLevel/HandlesClause.cs \
+./src/Parser/AST/TypeLevel/ImplementsClause.cs \
+./src/Parser/AST/TypeLevel/MethodDeclaration.cs \
+./src/Parser/AST/TypeLevel/PropertyDeclaration.cs \
+./src/Parser/AST/TypeLevel/PropertyGetRegion.cs \
+./src/Parser/AST/TypeLevel/PropertySetRegion.cs \
+./src/Parser/AST/TypeLevel/TypeReference.cs \
+./src/Parser/AST/TypeLevel/VariableDeclaration.cs \
+./src/Parser/generated/Errors.cs \
+./src/Parser/generated/keywordlist/Keywords.cs \
+./src/Parser/generated/keywordlist/Tokens.cs \
+./src/Parser/generated/Modifiers.cs \
+./src/Parser/generated/ParamModifiers.cs \
+./src/Parser/generated/Parser.cs
+
+build_sources = $(addprefix $(srcdir)/, $(FILES))
+
+DLL = ICSharpCode.SharpRefactory.VB.dll
+
+REFS = /r:System.Drawing.dll
+
+all: $(DLL)
+
+$(DLL): $(FILES)
+	@ $(CSC) /out:$(DLL) /target:library $(REFS) $(build_sources) \
+	&amp;&amp; cp $(DLL) ../../../../../build/bin/.
+
+test-parser.exe : $(DLL) src/Main.cs
+	@ $(CSC) /out:$@ /r:$(DLL) src/Main.cs
+
+run : test-parser.exe
+	@ MONO_PATH=`dirname $(DLL)` $(RUNTIME) test-parser.exe $(TEST_SOURCE)
+
+assemblydir = $(libdir)/monodevelop/bin
+assembly_DATA = $(DLL)
+
+CLEANFILES = $(DLL) $(DLL).mdb
+
+EXTRA_DIST = $(FILES)
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/SharpRefactoryVB.cmbx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/SharpRefactoryVB.cmbx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/SharpRefactoryVB.cmbx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,16 @@
+&lt;Combine fileversion=&quot;1.0&quot; name=&quot;SharpRefactoryVB&quot; description=&quot;&quot;&gt;
+  &lt;StartMode startupentry=&quot;SharpRefactoryVB&quot; single=&quot;True&quot;&gt;
+    &lt;Execute entry=&quot;SharpRefactoryVB&quot; type=&quot;None&quot; /&gt;
+  &lt;/StartMode&gt;
+  &lt;Entries&gt;
+    &lt;Entry filename=&quot;.\src\SharpRefactory.prjx&quot; /&gt;
+  &lt;/Entries&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration name=&quot;Release&quot;&gt;
+      &lt;Entry name=&quot;SharpRefactoryVB&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration name=&quot;Debug&quot;&gt;
+      &lt;Entry name=&quot;SharpRefactoryVB&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Combine&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/SharpRefactoryVB.prjx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/SharpRefactoryVB.prjx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/SharpRefactoryVB.prjx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,22 @@
+&lt;Project name=&quot;SharpRefactoryVB&quot; description=&quot;&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
+  &lt;Contents /&gt;
+  &lt;References /&gt;
+  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
+  &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Exe&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+    &lt;Output directory=&quot;./bin/Debug&quot; assembly=&quot;SharpRefactoryVB&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+  &lt;/Configuration&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Exe&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;./bin/Debug&quot; assembly=&quot;SharpRefactoryVB&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Exe&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;./bin/Release&quot; assembly=&quot;SharpRefactoryVB&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Project&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,33 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+[assembly: System.CLSCompliantAttribute(true)]
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+[assembly: AssemblyTitle(&quot;SharpRefactoryVB&quot;)]
+[assembly: AssemblyDescription(&quot;Parser for VB.NET&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;Markus Palme, Andrea Paatz, Mike Krueger, Levi Bard&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.1.1649&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,1861 @@
+// CSharpVisitor.cs
+// Copyright (C) 2004 Markus Palme (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">markuspalme at gmx.de</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Reflection;
+using System.CodeDom;
+using System.Text;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter.VB
+{
+	public class CSharpVisitor : IASTVisitor
+	{
+		readonly string newLineSep  = Environment.NewLine;
+		StringBuilder   sourceText  = new StringBuilder();
+		int             indentLevel = 0;
+		Errors          errors      = new Errors();
+		TypeDeclaration currentType = null;		
+		Stack   withExpressionStack = new Stack();
+		
+		public StringBuilder SourceText {
+			get {
+				return sourceText;
+			}
+		}
+		
+		public void AppendIndentation()
+		{
+			for (int i = 0; i &lt; indentLevel; ++i) {
+				sourceText.Append(&quot;\t&quot;);
+			}
+		}
+		
+		public void AppendNewLine()
+		{
+			sourceText.Append(newLineSep);
+		}
+		
+		public void AppendStatementEnd()
+		{
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+		}
+		
+		void DebugOutput(object o)
+		{
+//			Console.WriteLine(o.ToString());
+		}
+		
+		#region ICSharpCode.SharpRefactory.Parser.VB.IASTVisitor interface implementation
+		public object Visit(INode node, object data)
+		{
+			AppendIndentation();
+			sourceText.Append(&quot;// warning visited unknown node :&quot;);
+			sourceText.Append(node);
+			AppendNewLine();
+			return String.Empty;
+		}
+		
+		public object Visit(CompilationUnit compilationUnit, object data)
+		{
+			DebugOutput(compilationUnit);
+			compilationUnit.AcceptChildren(this, data);
+			return null;
+		}
+		
+#region GlobalScope
+		public object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			DebugOutput(namespaceDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;namespace &quot;);
+			sourceText.Append(namespaceDeclaration.NameSpace);
+			AppendNewLine();
+			sourceText.Append(&quot;{&quot;);
+			AppendNewLine();
+			++indentLevel;
+			namespaceDeclaration.AcceptChildren(this, data);
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ImportsStatement importsStatement, object data)
+		{
+			foreach (INode node in importsStatement.ImportClauses) {
+				node.AcceptVisitor(this, data);
+			}
+			return null;
+		}
+		
+		
+		public object Visit(ImportsDeclaration importsDeclaration, object data)
+		{
+			DebugOutput(importsDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;using &quot;);
+			sourceText.Append(importsDeclaration.Namespace);
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data)
+		{
+			DebugOutput(importsAliasDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;using &quot;);
+			sourceText.Append(importsAliasDeclaration.Alias);
+			sourceText.Append(&quot; = &quot;);
+			sourceText.Append(importsAliasDeclaration.Namespace);
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		
+		public object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			DebugOutput(typeDeclaration);
+			AppendAttributes(typeDeclaration.Attributes);
+			string modifier =  GetModifier(typeDeclaration.Modifier);
+			string type = String.Empty;
+			
+			switch (typeDeclaration.Type) {
+				case Types.Class:
+					type = &quot;class &quot;;
+					break;
+				case Types.Enum:
+					type = &quot;enum &quot;;
+					break;
+				case Types.Interface:
+					type = &quot;interface &quot;;
+					break;
+				case Types.Module:
+				case Types.Structure:
+					type = &quot;struct &quot;;
+					break;
+			}
+			AppendIndentation();
+			sourceText.Append(modifier);
+			sourceText.Append(type);
+			sourceText.Append(typeDeclaration.Name);
+			
+			bool hasBaseType = typeDeclaration.BaseType != null;
+			if (hasBaseType) {
+				sourceText.Append(&quot; : &quot;); 
+				sourceText.Append(ConvertTypeString(typeDeclaration.BaseType)); 
+			}
+			
+			if (typeDeclaration.BaseInterfaces != null &amp;&amp; typeDeclaration.BaseInterfaces.Count &gt; 0) {
+				if (!hasBaseType) {
+					sourceText.Append(&quot; : &quot;); 
+				} else {
+					sourceText.Append(&quot;, &quot;); 
+				}
+				for (int i = 0; i &lt; typeDeclaration.BaseInterfaces.Count; ++i) {
+					if (typeDeclaration.BaseInterfaces[i] is TypeReference) {
+						sourceText.Append((typeDeclaration.BaseInterfaces[i] as TypeReference).Type);
+					} else {
+						sourceText.Append(typeDeclaration.BaseInterfaces[i].ToString());
+					}
+					if (i + 1 &lt; typeDeclaration.BaseInterfaces.Count) {
+						sourceText.Append(&quot;, &quot;); 
+					}
+				}
+			}
+			AppendNewLine();
+			AppendIndentation();
+			sourceText.Append(&quot;{&quot;);
+			AppendNewLine();
+			++indentLevel;
+			TypeDeclaration oldType = currentType;
+			currentType = typeDeclaration;
+			typeDeclaration.AcceptChildren(this, data);
+			currentType = oldType;
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+			DebugOutput(delegateDeclaration);
+			AppendAttributes(delegateDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(delegateDeclaration.Modifier));
+			sourceText.Append(&quot;delegate &quot;);
+			sourceText.Append(GetTypeString(delegateDeclaration.ReturnType));
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(delegateDeclaration.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(delegateDeclaration.Parameters);
+			sourceText.Append(&quot;);&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			DebugOutput(eventDeclaration);
+			AppendAttributes(eventDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(eventDeclaration.Modifier));
+			sourceText.Append(&quot;event &quot;);
+			
+			if (eventDeclaration.TypeReference == null) {
+				sourceText.Append(eventDeclaration.Name);
+				sourceText.Append(&quot;EventHandler&quot;);
+			} else {
+				sourceText.Append(GetTypeString(eventDeclaration.TypeReference));
+			}
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(eventDeclaration.Name);
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+#endregion
+
+#region TypeLevel
+		public object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			// called inside ENUMS
+//			AppendAttributes(field.Attributes);
+			AppendIndentation();
+			sourceText.Append(variableDeclaration.Name);
+			if (variableDeclaration.Initializer != null) {
+				sourceText.Append(&quot; = &quot;);
+				sourceText.Append(variableDeclaration.Initializer.AcceptVisitor(this, data));
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			DebugOutput(fieldDeclaration);
+			
+			foreach (VariableDeclaration field in fieldDeclaration.Fields) {
+				AppendAttributes(fieldDeclaration.Attributes);
+				AppendIndentation();
+				if (currentType.Type == Types.Enum) {
+					if (fieldDeclaration.Fields.IndexOf(field) &gt; 0) {
+						sourceText.Append(&quot;, &quot;);
+					}
+					sourceText.Append(field.Name);
+					if (field.Initializer != null) {
+						sourceText.Append(&quot; = &quot;);
+						sourceText.Append(field.Initializer.AcceptVisitor(this, data).ToString());
+					}
+				} else {
+					if (fieldDeclaration.Modifier == Modifier.None) {
+						sourceText.Append(&quot; private &quot;);
+					} else {
+						sourceText.Append(GetModifier(fieldDeclaration.Modifier));
+					}
+					if (field.Type == null)
+						sourceText.Append(&quot;object&quot;);
+					else	
+						sourceText.Append(GetTypeString(field.Type));
+					sourceText.Append(&quot; &quot;);
+					sourceText.Append(field.Name);
+					if (field.Initializer != null) {
+						sourceText.Append(&quot; = &quot;);
+						sourceText.Append(field.Initializer.AcceptVisitor(this, data).ToString());
+					} else {
+						if (field.Type != null &amp;&amp; field.Type.Dimension != null) {
+							sourceText.Append(&quot; = new &quot;);
+							sourceText.Append(ConvertTypeString(field.Type.Type));
+							sourceText.Append(&quot;[&quot;);
+							sourceText.Append(GetExpressionList(field.Type.Dimension));
+							sourceText.Append(&quot;]&quot;);
+						}
+					}
+					sourceText.Append(&quot;;&quot;);
+					AppendNewLine();
+				}
+			}
+			
+			// if that's not the last enum member, add a comma
+			if (currentType.Type == Types.Enum) {
+				int pos = currentType.Children.IndexOf(fieldDeclaration);
+				if (pos &gt;= 0) {
+					for (int i = pos+1; i &lt; currentType.Children.Count; i++) {
+						if (currentType.Children[i] is FieldDeclaration) {
+							sourceText.Append(&quot;,&quot;);
+							break;
+						}
+					}
+				}
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			DebugOutput(methodDeclaration);
+			exitConstructStack.Push(new DictionaryEntry(typeof(MethodDeclaration), null));
+			
+			AppendNewLine();
+			AppendAttributes(methodDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(methodDeclaration.Modifier));
+			sourceText.Append(GetTypeString(methodDeclaration.TypeReference));
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(methodDeclaration.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(methodDeclaration.Parameters);
+			sourceText.Append(&quot;)&quot;);
+			
+			if (currentType.Type != Types.Interface &amp;&amp;
+				(methodDeclaration.Modifier &amp; Modifier.MustOverride) != Modifier.MustOverride)
+			{
+				AppendNewLine();
+				AppendIndentation();
+				sourceText.Append(&quot;{&quot;);
+				AppendNewLine();
+				if (methodDeclaration.Body != null) {
+					++indentLevel;
+					methodDeclaration.Body.AcceptVisitor(this, data);
+					GenerateExitConstructLabel();
+					--indentLevel;
+				}
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+			} else {
+				sourceText.Append(&quot;;&quot;);
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			DebugOutput(constructorDeclaration);
+			exitConstructStack.Push(new DictionaryEntry(typeof(MethodDeclaration), null));
+			AppendNewLine();
+			AppendAttributes(constructorDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(constructorDeclaration.Modifier));
+			sourceText.Append(this.currentType.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(constructorDeclaration.Parameters);
+			sourceText.Append(&quot;)&quot;);
+			
+			AppendNewLine();
+			AppendIndentation();
+			sourceText.Append(&quot;{&quot;);
+			AppendNewLine();
+			if (constructorDeclaration.Body != null) {
+				++indentLevel;
+				constructorDeclaration.Body.AcceptVisitor(this, data);
+				GenerateExitConstructLabel();
+				--indentLevel;
+			}
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(DeclareDeclaration declareDeclaration, object data)
+		{
+			DebugOutput(declareDeclaration);
+			AppendAttributes(declareDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(String.Format(&quot;[System.Runtime.InteropServices.DllImport({0}&quot;, declareDeclaration.Library));
+			if (declareDeclaration.Alias != null) {
+				sourceText.Append(String.Format(&quot;, EntryPoint={0}&quot;, declareDeclaration.Alias));
+			}
+			
+			switch (declareDeclaration.Charset) {
+				case CharsetModifier.ANSI:
+					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Ansi&quot;);
+					break;
+				case CharsetModifier.Unicode:
+					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Unicode&quot;);
+					break;
+				case CharsetModifier.Auto:
+					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Auto&quot;);
+					break;
+			}
+			
+			sourceText.Append(&quot;)]&quot;);
+			AppendNewLine();
+			AppendIndentation();
+			sourceText.Append(GetModifier(declareDeclaration.Modifier));
+			sourceText.Append(&quot;static extern &quot;);
+			sourceText.Append(GetTypeString(declareDeclaration.ReturnType));
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(declareDeclaration.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(declareDeclaration.Parameters);
+			sourceText.Append(&quot;);&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			DebugOutput(propertyDeclaration);
+			AppendNewLine();
+			AppendAttributes(propertyDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(propertyDeclaration.Modifier &amp; ~Modifier.ReadOnly));
+			
+			sourceText.Append(GetTypeString(propertyDeclaration.TypeReference));
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(propertyDeclaration.Name);
+			sourceText.Append(&quot; {&quot;);
+			AppendNewLine();
+			
+			if (currentType.Type != Types.Interface) {
+				if (propertyDeclaration.GetRegion != null) {
+					++indentLevel;
+					propertyDeclaration.GetRegion.AcceptVisitor(this, data);
+					--indentLevel;
+				}
+				
+				if (propertyDeclaration.SetRegion != null) {
+					++indentLevel;
+					propertyDeclaration.SetRegion.AcceptVisitor(this, data);
+					--indentLevel;
+				}
+				
+			}
+			// if abstract, add default get/set
+			if ((propertyDeclaration.Modifier &amp; Modifier.MustOverride) == Modifier.MustOverride &amp;&amp;
+			    propertyDeclaration.GetRegion == null &amp;&amp;
+			    propertyDeclaration.SetRegion == null) {
+				AppendIndentation();
+				sourceText.Append(&quot;get;&quot;);
+				AppendNewLine();
+				AppendIndentation();
+				sourceText.Append(&quot;set;&quot;);
+				AppendNewLine();
+			}			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			DebugOutput(propertyGetRegion);
+			exitConstructStack.Push(new DictionaryEntry(typeof(PropertyDeclaration), null));
+			AppendAttributes(propertyGetRegion.Attributes);
+			AppendIndentation();
+			sourceText.Append(&quot;get {&quot;);
+			AppendNewLine();
+			if (propertyGetRegion.Block != null) {
+				++indentLevel;
+				propertyGetRegion.Block.AcceptVisitor(this, data);
+				--indentLevel;
+			} 
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(PropertySetRegion propertySetRegion, object data)
+		{
+			DebugOutput(propertySetRegion);
+			exitConstructStack.Push(new DictionaryEntry(typeof(PropertyDeclaration), null));
+			AppendAttributes(propertySetRegion.Attributes);
+			AppendIndentation();
+			sourceText.Append(&quot;set {&quot;);
+			AppendNewLine();
+			if (propertySetRegion.Block != null) {
+				++indentLevel;
+				propertySetRegion.Block.AcceptVisitor(this, data);
+				--indentLevel;
+			}
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(TypeReference typeReference, object data)
+		{
+			return ConvertTypeString(typeReference.Type);
+		}
+#endregion
+
+#region Statements
+		public object Visit(Statement statement, object data)
+		{
+			AppendIndentation();
+			sourceText.Append(&quot;// warning visited unknown statment :&quot;);
+			sourceText.Append(statement);
+			AppendNewLine();
+			return String.Empty;
+		}
+		
+		public object Visit(BlockStatement blockStatement, object data)
+		{
+			DebugOutput(blockStatement);
+			blockStatement.AcceptChildren(this, data);
+			return null;
+		}
+		
+		public object Visit(StatementExpression statementExpression, object data)
+		{
+			DebugOutput(statementExpression);
+			AppendIndentation();
+			if (statementExpression.Expression == null) {
+				sourceText.Append(&quot;// warning got empty statement expression :&quot;);
+				sourceText.Append(statementExpression);
+			} else {
+				sourceText.Append(statementExpression.Expression.AcceptVisitor(this, data).ToString());
+				sourceText.Append(&quot;;&quot;);
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			DebugOutput(localVariableDeclaration);
+			for (int i = 0; i &lt; localVariableDeclaration.Variables.Count; ++i) {
+				VariableDeclaration localVar = (VariableDeclaration)localVariableDeclaration.Variables[i];
+				AppendIndentation();
+				sourceText.Append(GetModifier(localVariableDeclaration.Modifier));
+				ArrayCreateExpression ace = localVar.Initializer as ArrayCreateExpression;
+				if (ace != null &amp;&amp; (ace.ArrayInitializer == null || ace.ArrayInitializer.CreateExpressions == null)) {
+					sourceText.Append(ConvertTypeString(ace.CreateType.Type));
+					sourceText.Append(&quot; &quot;);
+					sourceText.Append(localVar.Name);
+					sourceText.Append(&quot;[&quot;);
+					sourceText.Append(GetExpressionList(ace.Parameters));
+					sourceText.Append(&quot;]&quot;);
+					
+				} else {
+					if (localVar.Type == null) {
+						bool foundType = false;
+						for (int j = i + 1; j &lt; localVariableDeclaration.Variables.Count; ++j) {
+							VariableDeclaration nextLocalVar = (VariableDeclaration)localVariableDeclaration.Variables[j];
+							if (nextLocalVar.Type != null) {
+								sourceText.Append(GetTypeString(nextLocalVar.Type));
+								foundType = true;
+								break;
+							}
+						}
+						if (!foundType) {
+							sourceText.Append(&quot;object&quot;);
+						}
+					} else {
+						sourceText.Append(GetTypeString(localVar.Type));
+					}
+					sourceText.Append(&quot; &quot;);
+					sourceText.Append(localVar.Name);
+					if (localVar.Initializer != null) {
+						sourceText.Append(&quot; = &quot;);
+						sourceText.Append(localVar.Initializer.AcceptVisitor(this, data).ToString());
+					} else {
+						if (localVar.Type != null &amp;&amp; localVar.Type.Dimension != null) {
+							sourceText.Append(&quot; = new &quot;);
+							sourceText.Append(ConvertTypeString(localVar.Type.Type));
+							sourceText.Append(&quot;[&quot;);
+							sourceText.Append(GetExpressionList(localVar.Type.Dimension));
+							sourceText.Append(&quot;]&quot;);
+						}
+					}
+				}
+				sourceText.Append(&quot;;&quot;);
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public object Visit(SimpleIfStatement ifStatement, object data)
+		{
+			AppendIndentation();
+			sourceText.Append(&quot;if (&quot;);
+			sourceText.Append(ifStatement.Condition.AcceptVisitor(this, data).ToString());
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			++indentLevel;
+			foreach(Statement statement in ifStatement.Statements) {
+				statement.AcceptVisitor(this, data);
+			}
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			
+			if(ifStatement.ElseStatements != null &amp;&amp; ifStatement.ElseStatements.Count &gt; 0) {
+				sourceText.Append(&quot; else {&quot;);
+				AppendNewLine();
+				++indentLevel;
+				foreach(Statement statement in ifStatement.ElseStatements) {
+					statement.AcceptVisitor(this, data);
+				}
+				--indentLevel;
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+			}
+			
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(IfStatement ifStatement, object data)
+		{
+			DebugOutput(ifStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;if (&quot;);
+			sourceText.Append(ifStatement.Condition.AcceptVisitor(this, data).ToString());
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			++indentLevel;
+			ifStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			
+			if (ifStatement.ElseIfStatements != null) {
+				foreach (ElseIfSection elseIfSection in ifStatement.ElseIfStatements) {
+					sourceText.Append(&quot; else if (&quot;);
+					sourceText.Append(elseIfSection.Condition.AcceptVisitor(this, data).ToString());
+					sourceText.Append(&quot;) {&quot;);
+					AppendNewLine();
+					++indentLevel;
+					elseIfSection.EmbeddedStatement.AcceptVisitor(this, data);
+					--indentLevel;
+					AppendIndentation();
+					sourceText.Append(&quot;}&quot;);
+				}
+			}
+			
+			if (ifStatement.EmbeddedElseStatement != null) {
+				sourceText.Append(&quot; else {&quot;);
+				AppendNewLine();
+				++indentLevel;
+				ifStatement.EmbeddedElseStatement.AcceptVisitor(this, data);
+				--indentLevel;
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+			}
+			
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(LabelStatement labelStatement, object data)
+		{
+			DebugOutput(labelStatement);
+			AppendIndentation();
+			sourceText.Append(labelStatement.Label);
+			sourceText.Append(&quot;:&quot;);
+			AppendNewLine();
+			if (labelStatement.EmbeddedStatement != null) {
+				labelStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			return null;
+		}
+		
+		public object Visit(GoToStatement goToStatement, object data)
+		{
+			DebugOutput(goToStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;goto&quot;);
+			sourceText.Append(goToStatement.LabelName);
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(SelectStatement selectStatement, object data)
+		{
+			DebugOutput(selectStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(SelectStatement), null));
+			string selectExpression = selectStatement.SelectExpression.AcceptVisitor(this, data).ToString();
+			AppendIndentation();
+			for (int j = 0; j &lt; selectStatement.SelectSections.Count; ++j) {
+				SelectSection selectSection = (SelectSection)selectStatement.SelectSections[j];
+				if (selectSection.CaseClauses.Count == 1 &amp;&amp; ((CaseClause)selectSection.CaseClauses[0]).IsDefaultCase) {
+					sourceText.Append(&quot;{&quot;);
+				} else {
+					sourceText.Append(&quot;if (&quot;);
+					for (int i = 0; i &lt; selectSection.CaseClauses.Count; ++i) {
+						CaseClause caseClause = (CaseClause)selectSection.CaseClauses[i];
+						if (caseClause.BoundaryExpression != null) {
+							sourceText.Append(caseClause.ComparisonExpression.AcceptVisitor(this, data));
+							sourceText.Append(&quot; &lt;= &quot;);
+							sourceText.Append(selectExpression);
+							sourceText.Append(&quot; &amp;&amp; &quot;);
+							sourceText.Append(selectExpression);
+							sourceText.Append(&quot; &lt;= &quot;);
+							sourceText.Append(caseClause.BoundaryExpression.AcceptVisitor(this, data));
+						} else {
+							if (caseClause.ComparisonExpression != null) {
+								sourceText.Append(selectExpression);
+								sourceText.Append(&quot; == &quot;);
+								sourceText.Append(caseClause.ComparisonExpression.AcceptVisitor(this, data));
+							} else {
+								// dummy default should never evaluate (only for default case)
+								sourceText.Append(&quot; true &quot;);
+							}
+						}
+						if (i + 1 &lt; selectSection.CaseClauses.Count) {
+							sourceText.Append(&quot; || &quot;);
+						}
+					}
+					sourceText.Append(&quot;) {&quot;);
+				}
+				AppendNewLine();
+				++indentLevel;
+				selectSection.EmbeddedStatement.AcceptChildren(this, data);
+				--indentLevel;
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+				if (j + 1 &lt; selectStatement.SelectSections.Count) {
+					sourceText.Append(&quot; else &quot;);
+				} 
+			}
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(StopStatement stopStatement, object data)
+		{
+			DebugOutput(stopStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;Debugger.Break();&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ResumeStatement resumeStatement, object data)
+		{
+			DebugOutput(resumeStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(resumeStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(EraseStatement eraseStatement, object data)
+		{
+			DebugOutput(eraseStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(eraseStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ErrorStatement errorStatement, object data)
+		{
+			DebugOutput(errorStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(errorStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(OnErrorStatement onErrorStatement, object data)
+		{
+			DebugOutput(onErrorStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(onErrorStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ReDimStatement reDimStatement, object data)
+		{
+			DebugOutput(reDimStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(reDimStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(AddHandlerStatement addHandlerStatement, object data)
+		{
+			DebugOutput(addHandlerStatement);
+			AppendIndentation();
+			sourceText.Append(addHandlerStatement.EventExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot; += &quot;);
+			sourceText.Append(addHandlerStatement.HandlerExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(RemoveHandlerStatement removeHandlerStatement, object data)
+		{
+			DebugOutput(removeHandlerStatement);
+			AppendIndentation();
+			sourceText.Append(removeHandlerStatement.EventExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot; -= &quot;);
+			sourceText.Append(removeHandlerStatement.HandlerExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(DoLoopStatement doLoopStatement, object data)
+		{
+			DebugOutput(doLoopStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(DoLoopStatement), null));
+			if (doLoopStatement.ConditionPosition == ConditionPosition.Start) {
+				AppendIndentation();
+				sourceText.Append(&quot;while (&quot;);
+				if (doLoopStatement.ConditionType == ConditionType.Until) {
+					sourceText.Append(&quot;!(&quot;);
+				}
+				sourceText.Append(doLoopStatement.Condition.AcceptVisitor(this, data).ToString());
+				if (doLoopStatement.ConditionType == ConditionType.Until) {
+					sourceText.Append(&quot;)&quot;);
+				}
+				sourceText.Append(&quot;) {&quot;);
+				
+				AppendNewLine();
+				
+				++indentLevel;
+				doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
+				--indentLevel;
+				
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+				AppendNewLine();
+			} else {
+				AppendIndentation();
+				sourceText.Append(&quot;do {&quot;);
+				AppendNewLine();
+				
+				++indentLevel;
+				doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
+				--indentLevel;
+				
+				AppendIndentation();
+				sourceText.Append(&quot;} while (&quot;);
+				if (doLoopStatement.Condition == null) {
+					sourceText.Append(&quot;true&quot;);
+				} else {
+					if (doLoopStatement.ConditionType == ConditionType.Until) {
+						sourceText.Append(&quot;!(&quot;);
+					}
+					sourceText.Append(doLoopStatement.Condition.AcceptVisitor(this, data).ToString());
+					if (doLoopStatement.ConditionType == ConditionType.Until) {
+						sourceText.Append(&quot;)&quot;);
+					}
+				}
+				sourceText.Append(&quot;);&quot;);
+				AppendNewLine();
+			}
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(EndStatement endStatement, object data)
+		{
+			DebugOutput(endStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;System.Environment.Exit(0);&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		Stack exitConstructStack = new Stack();
+		int   exitLabelCount     = 0;
+		public string AddExitOnConstructStack(Type exitType)
+		{
+			string labelName = String.Concat(&quot;exit&quot; + exitType.Name, exitLabelCount++);
+			if (exitConstructStack.Count &gt; 0) {
+				object[] exitArray = exitConstructStack.ToArray();
+				for (int i = exitArray.Length - 1; i &gt;= 0; --i) {
+					if ((Type)((DictionaryEntry)exitArray[i]).Key == exitType) {
+						exitArray[i] = new DictionaryEntry(((DictionaryEntry)exitArray[i]).Key, labelName);
+					}
+				}
+				Array.Reverse(exitArray);
+				exitConstructStack = new Stack(exitArray);
+			}
+			return String.Concat(labelName);
+		}
+		
+		public void GenerateExitConstructLabel()
+		{
+			if (exitConstructStack.Count &gt; 0) {
+				DictionaryEntry entry = (DictionaryEntry)exitConstructStack.Pop();
+				if (entry.Value != null) {
+					AppendIndentation();
+					sourceText.Append(entry.Value.ToString());
+					sourceText.Append(&quot;: ;&quot;);
+					AppendNewLine();
+				}
+			}
+		}
+		
+		public object Visit(ExitStatement exitStatement, object data)
+		{
+			DebugOutput(exitStatement);
+			Type   exitType  = null;
+			switch (exitStatement.ExitType) {
+				case ExitType.Sub:
+					sourceText.Append(&quot;return;&quot;);
+					AppendNewLine();
+					return null;
+				case ExitType.Function:
+					sourceText.Append(&quot;return null;&quot;);
+					AppendNewLine();
+					return null;
+				case ExitType.Property:
+					exitType = typeof(PropertyDeclaration);
+					break;
+				case ExitType.Do:
+					exitType = typeof(DoLoopStatement);
+					break;
+				case ExitType.For:
+					exitType = typeof(ForStatement);
+					break;
+				case ExitType.While:
+					exitType = typeof(WhileStatement);
+					break;
+				case ExitType.Select:
+					exitType = typeof(SelectStatement);
+					break;
+				case ExitType.Try:
+					exitType = typeof(TryCatchStatement);
+					break;
+			}
+			if (exitType != null) {
+				AppendIndentation();
+				sourceText.Append(&quot;goto &quot;);
+				sourceText.Append(AddExitOnConstructStack(exitType));
+				sourceText.Append(&quot;;&quot;);
+				AppendNewLine();
+			} else {
+				AppendIndentation();
+				sourceText.Append(&quot;ERROR IN GENERATION: EXIT TO &quot;);
+				sourceText.Append(exitStatement.ExitType);
+				sourceText.Append(&quot; FAILED!!!&quot;);
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public object Visit(ForeachStatement foreachStatement, object data)
+		{
+			DebugOutput(foreachStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(ForStatement), null));
+			
+			AppendIndentation();
+			sourceText.Append(&quot;foreach (&quot;);
+			if (foreachStatement.LoopControlVariable.Type != null) {
+				sourceText.Append(this.GetTypeString(foreachStatement.LoopControlVariable.Type));
+				sourceText.Append(&quot; &quot;);
+			}
+			sourceText.Append(foreachStatement.LoopControlVariable.Name);
+			sourceText.Append(&quot; in &quot;);
+			sourceText.Append(foreachStatement.Expression.AcceptVisitor(this, data));
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(ForStatement forStatement, object data)
+		{
+			DebugOutput(forStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(ForStatement), null));
+			bool   stepIsNegative = false;
+			string step           = null;
+			if (forStatement.Step != null) {
+				step = forStatement.Step.AcceptVisitor(this, data).ToString();
+				stepIsNegative = step.StartsWith(&quot;-&quot;);
+			}
+			
+			AppendIndentation();
+			sourceText.Append(&quot;for (&quot;);
+			
+			
+			if (forStatement.LoopControlVariable.Type != null) {
+				sourceText.Append(this.GetTypeString(forStatement.LoopControlVariable.Type));
+				sourceText.Append(&quot; &quot;);
+			}
+			sourceText.Append(forStatement.LoopControlVariable.Name);
+			sourceText.Append(&quot; = &quot;);
+			
+			sourceText.Append(forStatement.Start.AcceptVisitor(this, data));
+			sourceText.Append(&quot;; &quot;);
+			sourceText.Append(forStatement.LoopControlVariable.Name);
+			sourceText.Append(stepIsNegative ? &quot; &gt;= &quot; : &quot; &lt;= &quot;);
+			sourceText.Append(forStatement.End.AcceptVisitor(this, data));
+			sourceText.Append(&quot;; &quot;);
+			if (forStatement.Step == null) {
+				sourceText.Append(forStatement.LoopControlVariable.Name);
+				sourceText.Append(&quot;++&quot;);
+			} else {
+				sourceText.Append(forStatement.LoopControlVariable.Name);
+				if (stepIsNegative) {
+					if (step == &quot;-1&quot;) {
+						sourceText.Append(&quot;--&quot;);
+					} else {
+						sourceText.Append(&quot; -= &quot;);
+						sourceText.Append(step.Substring(1));
+					}
+				} else {
+					sourceText.Append(&quot; += &quot;);
+					sourceText.Append(step);
+				}
+			}
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			
+			return null;
+		}
+		
+		public object Visit(LockStatement lockStatement, object data)
+		{
+			DebugOutput(lockStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;lock (&quot;);
+			sourceText.Append(lockStatement.LockExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(RaiseEventStatement raiseEventStatement, object data)
+		{
+			DebugOutput(raiseEventStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;if (&quot;);
+			sourceText.Append(raiseEventStatement.EventName);
+			sourceText.Append(&quot; != null) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			AppendIndentation();
+			sourceText.Append(raiseEventStatement.EventName);
+			sourceText.Append(GetParameters(raiseEventStatement.Parameters));
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		
+		public object Visit(ReturnStatement returnStatement, object data)
+		{
+			DebugOutput(returnStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;return&quot;);
+			if (returnStatement.ReturnExpression != null) {
+				sourceText.Append(&quot; &quot;);
+				sourceText.Append(returnStatement.ReturnExpression.AcceptVisitor(this,data));
+			}
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ThrowStatement throwStatement, object data)
+		{
+			DebugOutput(throwStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;throw&quot;);
+			if (throwStatement.ThrowExpression != null) {
+				sourceText.Append(&quot; &quot;);
+				sourceText.Append(throwStatement.ThrowExpression.AcceptVisitor(this, data).ToString());
+			}
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			DebugOutput(tryCatchStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(TryCatchStatement), null));
+			AppendIndentation();
+			sourceText.Append(&quot;try {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			if (tryCatchStatement.CatchClauses != null) {
+				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
+					sourceText.Append(&quot; catch &quot;);
+					if (catchClause.Type != null) {
+						sourceText.Append(&quot;(&quot;);
+						sourceText.Append(GetTypeString(catchClause.Type));
+						if (catchClause.VariableName != null) {
+							sourceText.Append(&quot; &quot;);
+							sourceText.Append(catchClause.VariableName);
+						}
+						sourceText.Append(&quot;) &quot;);
+					}
+					sourceText.Append(&quot;{&quot;);
+					AppendNewLine();
+					++indentLevel;
+					if (catchClause.Condition != null) {
+						AppendIndentation();
+						sourceText.Append(&quot;//TODO: review the original conditional catch clause&quot;);
+						AppendNewLine();
+						AppendIndentation();
+						sourceText.Append(&quot;if (&quot;);
+						sourceText.Append(catchClause.Condition.AcceptVisitor(this, data));
+						sourceText.Append(&quot;) {&quot;);
+						AppendNewLine();
+						++indentLevel;
+						catchClause.StatementBlock.AcceptVisitor(this, data);
+						--indentLevel;
+						AppendIndentation();
+						sourceText.Append(&quot;}&quot;);
+						AppendNewLine();
+					} else {
+						catchClause.StatementBlock.AcceptVisitor(this, data);
+					}
+					--indentLevel;
+					AppendIndentation();
+					sourceText.Append(&quot;}&quot;);
+				}
+			}
+			
+			if (tryCatchStatement.FinallyBlock != null) {
+				sourceText.Append(&quot; finally {&quot;);
+				AppendNewLine();
+				
+				++indentLevel;
+				tryCatchStatement.FinallyBlock.AcceptVisitor(this, data);
+				--indentLevel;
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+			}
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(WhileStatement whileStatement, object data)
+		{
+			DebugOutput(whileStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(WhileStatement), null));
+			AppendIndentation();
+			sourceText.Append(&quot;while (&quot;);
+			sourceText.Append(whileStatement.Condition.AcceptVisitor(this, data).ToString());
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(WithStatement withStatement, object data)
+		{
+			DebugOutput(withStatement);
+			withExpressionStack.Push(withStatement.WithExpression);
+			withStatement.Body.AcceptVisitor(this, data);
+			withExpressionStack.Pop();
+			return null;
+		}
+		
+		public object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data)
+		{
+			DebugOutput(attribute);
+			AppendIndentation();
+			sourceText.Append(&quot;// Should never happen (this is handled in AttributeSection) attribute was:&quot;);
+			sourceText.Append(attribute);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(AttributeSection attributeSection, object data)
+		{
+			DebugOutput(attributeSection);
+			AppendIndentation();
+			sourceText.Append(&quot;[&quot;);
+			if (attributeSection.AttributeTarget != null &amp;&amp; attributeSection.AttributeTarget.Length &gt; 0) {
+				sourceText.Append(attributeSection.AttributeTarget);
+				sourceText.Append(&quot;: &quot;);
+			}
+			for (int j = 0; j &lt; attributeSection.Attributes.Count; ++j) {
+				ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attr = (ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute)attributeSection.Attributes[j];
+				
+				sourceText.Append(attr.Name);
+				sourceText.Append(&quot;(&quot;);
+				for (int i = 0; i &lt; attr.PositionalArguments.Count; ++i) {
+					Expression expr = (Expression)attr.PositionalArguments[i];
+					sourceText.Append(expr.AcceptVisitor(this, data).ToString());
+					if (i + 1 &lt; attr.PositionalArguments.Count | attr.NamedArguments.Count &gt; 0) { 
+						sourceText.Append(&quot;, &quot;);
+					}
+				}
+
+				for (int i = 0; i &lt; attr.NamedArguments.Count; ++i) {
+					NamedArgumentExpression named = (NamedArgumentExpression)attr.NamedArguments[i];
+					sourceText.Append(named.AcceptVisitor(this, data).ToString());
+					if (i + 1 &lt; attr.NamedArguments.Count) { 
+						sourceText.Append(&quot;, &quot;);
+					}
+				}
+				sourceText.Append(&quot;)&quot;);
+				if (j + 1 &lt; attributeSection.Attributes.Count) {
+					sourceText.Append(&quot;, &quot;);
+				}
+			}
+			sourceText.Append(&quot;]&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(OptionCompareDeclaration optionCompareDeclaration, object data)
+		{
+			DebugOutput(optionCompareDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(optionCompareDeclaration);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data)
+		{
+			DebugOutput(optionExplicitDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(optionExplicitDeclaration);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(OptionStrictDeclaration optionStrictDeclaration, object data)
+		{
+			DebugOutput(optionStrictDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(optionStrictDeclaration);
+			AppendNewLine();
+			return null;
+		}
+#endregion
+
+#region Expressions
+		public object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			DebugOutput(primitiveExpression);
+			if (primitiveExpression.Value == null) {
+				return &quot;null&quot;;
+			}
+			if (primitiveExpression.Value is bool) {
+				if ((bool)primitiveExpression.Value) {
+					return &quot;true&quot;;
+				}
+				return &quot;false&quot;;
+			}
+			
+			if (primitiveExpression.Value is string) {
+				string s = primitiveExpression.Value.ToString();
+				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
+				s = s.Replace(&quot;\&quot;&quot;,&quot;\\\&quot;&quot;);
+				return String.Concat('&quot;', s, '&quot;');
+			}
+			
+			if (primitiveExpression.Value is char) {
+				string s = primitiveExpression.Value.ToString();
+				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
+				s = s.Replace(&quot;\'&quot;,&quot;\\\'&quot;);
+				return String.Concat(&quot;'&quot;, s, &quot;'&quot;);
+			}
+			
+			if (primitiveExpression.Value is System.DateTime) {
+				string s = primitiveExpression.StringValue;
+				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
+				s = s.Replace(&quot;\&quot;&quot;,&quot;\\\&quot;&quot;);
+				return String.Concat(&quot;System.DateTime.Parse(\&quot;&quot;, s, &quot;\&quot;)&quot;);
+			}
+
+			return primitiveExpression.Value;
+		}
+		
+		public object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			DebugOutput(binaryOperatorExpression);
+			string op   = null;
+			string left = binaryOperatorExpression.Left.AcceptVisitor(this, data).ToString();
+			string right = binaryOperatorExpression.Right.AcceptVisitor(this, data).ToString();
+			
+			switch (binaryOperatorExpression.Op) {
+				case BinaryOperatorType.Concat:
+					op = &quot; + &quot;;
+					break;
+				
+				case BinaryOperatorType.Add:
+					op = &quot; + &quot;;
+					break;
+				
+				case BinaryOperatorType.Subtract:
+					op = &quot; - &quot;;
+					break;
+				
+				case BinaryOperatorType.Multiply:
+					op = &quot; * &quot;;
+					break;
+				
+				case BinaryOperatorType.DivideInteger:
+				case BinaryOperatorType.Divide:
+					op = &quot; / &quot;;
+					break;
+				
+				case BinaryOperatorType.Modulus:
+					op = &quot; % &quot;;
+					break;
+				
+				case BinaryOperatorType.ShiftLeft:
+					op = &quot; &lt;&lt; &quot;;
+					break;
+				
+				case BinaryOperatorType.ShiftRight:
+					op = &quot; &gt;&gt; &quot;;
+					break;
+				
+				case BinaryOperatorType.BitwiseAnd:
+					op = &quot; &amp; &quot;;
+					break;
+				case BinaryOperatorType.BitwiseOr:
+					op = &quot; | &quot;;
+					break;
+				case BinaryOperatorType.ExclusiveOr:
+					op = &quot; ^ &quot;;
+					break;
+				
+				case BinaryOperatorType.BooleanAnd:
+					op = &quot; &amp;&amp; &quot;;
+					break;
+				case BinaryOperatorType.BooleanOr:
+					op = &quot; || &quot;;
+					break;
+				
+				case BinaryOperatorType.Equality:
+					op = &quot; == &quot;;
+					break;
+				case BinaryOperatorType.GreaterThan:
+					op = &quot; &gt; &quot;;
+					break;
+				case BinaryOperatorType.GreaterThanOrEqual:
+					op = &quot; &gt;= &quot;;
+					break;
+				case BinaryOperatorType.InEquality:
+					op = &quot; != &quot;;
+					break;
+				case BinaryOperatorType.LessThan:
+					op = &quot; &lt; &quot;;
+					break;
+				case BinaryOperatorType.IS:
+					op = &quot; == &quot;;
+					break;
+				case BinaryOperatorType.LessThanOrEqual:
+					op = &quot; &lt;= &quot;;
+					break;
+				case BinaryOperatorType.Power:
+					return &quot;Math.Pow(&quot; + left + &quot;, &quot; + right + &quot;)&quot;;
+				default:
+					throw new Exception(&quot;Unknown binary operator:&quot; + binaryOperatorExpression.Op);
+			}
+			
+			return String.Concat(left,
+			                     op,
+			                     right);
+		}
+		
+		public object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			DebugOutput(parenthesizedExpression);
+			string innerExpr = parenthesizedExpression.Expression.AcceptVisitor(this, data).ToString();
+			return String.Concat(&quot;(&quot;, innerExpr, &quot;)&quot;);
+		}
+		
+		public object Visit(InvocationExpression invocationExpression, object data)
+		{
+			DebugOutput(invocationExpression);
+			return String.Concat(invocationExpression.TargetObject.AcceptVisitor(this, data),
+			                     GetParameters(invocationExpression.Parameters)
+			                     );
+		}
+		
+		public object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			DebugOutput(identifierExpression);
+			return identifierExpression.Identifier;
+		}
+		
+		public object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			DebugOutput(typeReferenceExpression);
+			return GetTypeString(typeReferenceExpression.TypeReference);
+		}
+		
+		public object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			DebugOutput(unaryOperatorExpression);
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.BitNot:
+					return String.Concat(&quot;~&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Decrement:
+					return String.Concat(&quot;--&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Increment:
+					return String.Concat(&quot;++&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Minus:
+					return String.Concat(&quot;-&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Not:
+					return String.Concat(&quot;!(&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Plus:
+					return String.Concat(&quot;+&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.PostDecrement:
+					return String.Concat(unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;--&quot;);
+				case UnaryOperatorType.PostIncrement:
+					return String.Concat(unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;++&quot;);
+			}
+			throw new System.NotSupportedException();
+		}
+		
+		public object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			DebugOutput(assignmentExpression);
+			string op    = null;
+			string left  = assignmentExpression.Left.AcceptVisitor(this, data).ToString();
+			string right = assignmentExpression.Right.AcceptVisitor(this, data).ToString();
+			
+			switch (assignmentExpression.Op) {
+				case AssignmentOperatorType.Assign:
+					op = &quot; = &quot;;
+					break;
+				case AssignmentOperatorType.ConcatString:
+				case AssignmentOperatorType.Add:
+					op = &quot; += &quot;;
+					break;
+				case AssignmentOperatorType.Subtract:
+					op = &quot; -= &quot;;
+					break;
+				case AssignmentOperatorType.Multiply:
+					op = &quot; *= &quot;;
+					break;
+				case AssignmentOperatorType.Divide:
+					op = &quot; /= &quot;;
+					break;
+				case AssignmentOperatorType.ShiftLeft:
+					op = &quot; &lt;&lt;= &quot;;
+					break;
+				case AssignmentOperatorType.ShiftRight:
+					op = &quot; &gt;&gt;= &quot;;
+					break;
+				
+				case AssignmentOperatorType.ExclusiveOr:
+					op = &quot; ^= &quot;;
+					break;
+				case AssignmentOperatorType.Modulus:
+					op = &quot; %= &quot;;
+					break;
+				case AssignmentOperatorType.BitwiseAnd:
+					op = &quot; &amp;= &quot;;
+					break;
+				case AssignmentOperatorType.BitwiseOr:
+					op = &quot; |= &quot;;
+					break;
+			}
+			return String.Concat(left,
+			                     op,
+			                     right);
+		}
+		
+		public object Visit(CastExpression castExpression, object data)
+		{
+			DebugOutput(castExpression);
+			string type     = ConvertTypeString(castExpression.CastTo.Type);
+			string castExpr = castExpression.Expression.AcceptVisitor(this, data).ToString();
+			
+			if (castExpression.IsSpecializedCast) {
+				switch (type) {
+					case &quot;System.Object&quot;:
+						break;
+					default:
+						string convToType = type.Substring(&quot;System.&quot;.Length);
+						return String.Format(&quot;System.Convert.To{0}({1})&quot;, convToType, castExpr);
+				}
+			}
+			return String.Format(&quot;(({0})({1}))&quot;, type, castExpr);
+		}
+		
+		public object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			DebugOutput(thisReferenceExpression);
+			return &quot;this&quot;;
+		}
+		
+		public object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			DebugOutput(baseReferenceExpression);
+			return &quot;base&quot;;
+		}
+		
+		public object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			return String.Format(&quot;new {0}{1}&quot;,
+			                     GetTypeString(objectCreateExpression.CreateType),
+			                     GetParameters(objectCreateExpression.Parameters)
+			                     );
+		}
+		
+		public object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			DebugOutput(parameterDeclarationExpression);
+			// Is handled in the AppendParameters method
+			return &quot;// should never happen&quot; + parameterDeclarationExpression;
+		}
+		
+		public object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data)
+		{
+			DebugOutput(fieldReferenceOrInvocationExpression);
+			INode target = fieldReferenceOrInvocationExpression.TargetObject;
+			if (target == null &amp;&amp; withExpressionStack.Count &gt; 0) {
+				target = withExpressionStack.Peek() as INode;
+			}
+			return String.Concat(target.AcceptVisitor(this, data),
+			                     '.',
+			                     fieldReferenceOrInvocationExpression.FieldName);
+		}
+		
+		public object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			DebugOutput(arrayInitializerExpression);
+			if (arrayInitializerExpression.CreateExpressions.Count &gt; 0) {
+				return String.Concat(&quot;{&quot;,
+				                     GetExpressionList(arrayInitializerExpression.CreateExpressions),
+				                     &quot;}&quot;);
+			}
+			return String.Empty;
+		}
+		
+		public object Visit(GetTypeExpression getTypeExpression, object data)
+		{
+			DebugOutput(getTypeExpression);
+			return String.Concat(&quot;typeof(&quot;,
+			                     this.GetTypeString(getTypeExpression.Type),
+			                     &quot;)&quot;);
+		}
+		
+		public object Visit(ClassReferenceExpression classReferenceExpression, object data)
+		{
+			// ALMOST THE SAME AS '.this' but ignores all overridings from virtual
+			// members. How can this done in C# ?
+			DebugOutput(classReferenceExpression);
+			return &quot;TODO : &quot; + classReferenceExpression;
+		}
+		
+		public object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
+		{
+			// I think the LoopControlVariableExpression is only used in the for statement
+			// and there it is handled
+			DebugOutput(loopControlVariableExpression);
+			return &quot;Should Never happen : &quot; + loopControlVariableExpression;
+		}
+		
+		public object Visit(NamedArgumentExpression namedArgumentExpression, object data)
+		{
+			return String.Concat(namedArgumentExpression.Parametername,
+			                     &quot;=&quot;,
+			                    namedArgumentExpression.Expression.AcceptVisitor(this, data));
+		}
+		
+		public object Visit(AddressOfExpression addressOfExpression, object data)
+		{
+			DebugOutput(addressOfExpression);
+			string procedureName    = addressOfExpression.Procedure.AcceptVisitor(this, data).ToString();
+			string eventHandlerType = &quot;EventHandler&quot;;
+			bool   foundEventHandler = false;
+			// try to resolve the type of the eventhandler using a little trick :)
+			foreach (INode node in currentType.Children) {
+				MethodDeclaration md = node as MethodDeclaration;
+				if (md != null &amp;&amp; md.Parameters != null &amp;&amp; md.Parameters.Count &gt; 0) {
+					if (procedureName == md.Name || procedureName.EndsWith(&quot;.&quot; + md.Name)) {
+						ParameterDeclarationExpression pde = (ParameterDeclarationExpression)md.Parameters[md.Parameters.Count - 1];
+						string typeName = GetTypeString(pde.TypeReference);
+						if (typeName.EndsWith(&quot;Args&quot;)) {
+							eventHandlerType = typeName.Substring(0, typeName.Length - &quot;Args&quot;.Length) + &quot;Handler&quot;;
+							foundEventHandler = true;
+						}
+					}
+				}
+			}
+			return String.Concat(foundEventHandler ? &quot;new &quot; : &quot;/* might be wrong, please check */ new &quot;,
+			                     eventHandlerType,
+			                     &quot;(&quot;,
+			                     procedureName,
+			                     &quot;)&quot;);
+		}
+		
+		public object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			DebugOutput(typeOfExpression);
+			return String.Concat(typeOfExpression.Expression.AcceptVisitor(this, data),
+			                     &quot; is &quot;,
+			                     GetTypeString(typeOfExpression.Type));
+		}
+		
+		public object Visit(ArrayCreateExpression ace, object data)
+		{
+			DebugOutput(ace);
+			
+			return String.Concat(&quot;new &quot;,
+			                     GetTypeString(ace.CreateType),
+			                     &quot;[&quot;,
+			                     GetExpressionList(ace.Parameters),
+			                     &quot;]&quot;,
+			                     ace.ArrayInitializer.AcceptVisitor(this, data));
+		}
+#endregion
+#endregion
+		
+		public void AppendAttributes(ArrayList attr)
+		{
+			if (attr != null) {
+				foreach (AttributeSection section in attr) {
+					section.AcceptVisitor(this, null);
+				}
+			}
+		}
+		
+		public void AppendParameters(ArrayList parameters)
+		{
+			if (parameters == null) {
+				return;
+			}
+			for (int i = 0; i &lt; parameters.Count; ++i) {
+				ParameterDeclarationExpression pde = (ParameterDeclarationExpression)parameters[i];
+				AppendAttributes(pde.Attributes);
+				
+				if ((pde.ParamModifiers.Modifier &amp; ParamModifier.ByRef) == ParamModifier.ByRef) {
+					sourceText.Append(&quot;ref &quot;);
+				} else if ((pde.ParamModifiers.Modifier &amp; ParamModifier.ParamArray) == ParamModifier.ParamArray) {
+					sourceText.Append(&quot;params &quot;);
+				}
+				
+				sourceText.Append(GetTypeString(pde.TypeReference));
+				sourceText.Append(&quot; &quot;);
+				sourceText.Append(pde.ParameterName);
+				if (i + 1 &lt; parameters.Count) {
+					sourceText.Append(&quot;, &quot;);
+				}
+			}
+		}
+		
+		string ConvertTypeString(string typeString)
+		{
+			switch (typeString.ToLower()) {
+				case &quot;boolean&quot;:
+					return &quot;bool&quot;;
+				case &quot;string&quot;:
+					return &quot;string&quot;;
+				case &quot;char&quot;:
+					return &quot;char&quot;;
+				case &quot;double&quot;:
+					return &quot;double&quot;;
+				case &quot;single&quot;:
+					return &quot;float&quot;;
+				case &quot;decimal&quot;:
+					return &quot;decimal&quot;;
+				case &quot;date&quot;:
+					return &quot;System.DateTime&quot;;
+				case &quot;long&quot;:
+					return &quot;long&quot;;
+				case &quot;integer&quot;:
+					return &quot;int&quot;;
+				case &quot;short&quot;:
+					return &quot;short&quot;;
+				case &quot;byte&quot;:
+					return &quot;byte&quot;;
+				case &quot;void&quot;:
+					return &quot;void&quot;;
+				case &quot;system.object&quot;:
+				case &quot;object&quot;:
+					return &quot;object&quot;;
+				case &quot;system.uint64&quot;:
+					return &quot;ulong&quot;;
+				case &quot;system.uint32&quot;:
+					return &quot;uint&quot;;
+				case &quot;system.uint16&quot;:
+					return &quot;ushort&quot;;
+			}
+			return typeString;
+		}
+		
+		string GetTypeString(TypeReference typeRef)
+		{
+			if (typeRef == null) {
+				return &quot;void&quot;;
+			}
+			
+			string typeStr = ConvertTypeString(typeRef.Type);
+		
+			StringBuilder arrays = new StringBuilder();
+
+			if (typeRef.RankSpecifier != null) {
+				for (int i = 0; i &lt; typeRef.RankSpecifier.Count; ++i) {
+					arrays.Append(&quot;[&quot;);
+					arrays.Append(new String(',', (int)typeRef.RankSpecifier[i]));
+					arrays.Append(&quot;]&quot;);
+				}
+			} else {
+				if (typeRef.Dimension != null) {
+					arrays.Append(&quot;[&quot;);
+					if (typeRef.Dimension.Count &gt; 0) {
+						arrays.Append(new String(',', typeRef.Dimension.Count - 1));
+					}
+					arrays.Append(&quot;]&quot;);
+				}
+			}
+			
+			return typeStr + arrays.ToString();
+		}
+		
+		string GetModifier(Modifier modifier)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			if ((modifier &amp; Modifier.Public) == Modifier.Public) {
+				builder.Append(&quot;public &quot;);
+			} else if ((modifier &amp; Modifier.Private) == Modifier.Private) {
+				builder.Append(&quot;private &quot;);
+			} else if ((modifier &amp; (Modifier.Protected | Modifier.Friend)) == (Modifier.Protected | Modifier.Friend)) {
+				builder.Append(&quot;protected internal &quot;);
+			} else if ((modifier &amp; Modifier.Friend) == Modifier.Friend) {
+				builder.Append(&quot;internal &quot;);
+			} else if ((modifier &amp; Modifier.Protected) == Modifier.Protected) {
+				builder.Append(&quot;protected &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.MustInherit) == Modifier.MustInherit) {
+				builder.Append(&quot;abstract &quot;);
+			}
+			if ((modifier &amp; Modifier.Shared) == Modifier.Shared) {
+				builder.Append(&quot;static &quot;);
+			}
+			if ((modifier &amp; Modifier.Overridable) == Modifier.Overridable) {
+				builder.Append(&quot;virtual &quot;);
+			}
+			if ((modifier &amp; Modifier.MustOverride) == Modifier.MustOverride) {
+				builder.Append(&quot;abstract &quot;);
+			}
+			if ((modifier &amp; Modifier.Overrides) == Modifier.Overrides) {
+				builder.Append(&quot;override &quot;);
+			}
+			if ((modifier &amp; Modifier.Shadows) == Modifier.Shadows) {
+				builder.Append(&quot;new &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.NotInheritable) == Modifier.NotInheritable) {
+				builder.Append(&quot;sealed &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.Constant) == Modifier.Constant) {
+				builder.Append(&quot;const &quot;);
+			}
+			if ((modifier &amp; Modifier.ReadOnly) == Modifier.ReadOnly) {
+				builder.Append(&quot;readonly &quot;);
+			}
+			return builder.ToString();
+		}
+
+		string GetParameters(ArrayList list)
+		{
+			return String.Concat(&quot;(&quot;,
+			                     GetExpressionList(list),
+			                     &quot;)&quot;);
+		}
+		
+		string GetExpressionList(ArrayList list)
+		{
+			StringBuilder sb = new StringBuilder();
+			if (list != null) {
+				for (int i = 0; i &lt; list.Count; ++i) {
+					Expression exp = (Expression)list[i];
+					if (exp != null) {
+						sb.Append(exp.AcceptVisitor(this, null));
+						if (i + 1 &lt; list.Count) {
+							sb.Append(&quot;, &quot;);
+						}
+					}
+				}
+			}
+			return sb.ToString();
+		}
+		
+	}
+}	

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom/CodeDOMVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom/CodeDOMVisitor.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CodeDom/CodeDOMVisitor.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,895 @@
+// CodeDOMVisitor.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Reflection;
+using System.CodeDom;
+using System.Text;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class CodeDOMVisitor : AbstractASTVisitor
+	{
+		Stack namespaceDeclarations = new Stack();
+		Stack typeDeclarations     = new Stack();
+		CodeMemberMethod currentMethod = null;
+		TypeDeclaration currentTypeDeclaration;
+		
+		public CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
+		public ArrayList namespaces = new ArrayList();
+		
+		static string[,] typeConversionList = new string[,] {
+			{&quot;System.Object&quot;,	&quot;OBJECT&quot;},
+			{&quot;System.Boolean&quot;,	&quot;BOOLEAN&quot;},
+			{&quot;System.Byte&quot;,		&quot;BYTE&quot;},
+			{&quot;System.Char&quot;,		&quot;CHAR&quot;},
+			{&quot;System.Int16&quot;,	&quot;SHORT&quot;},
+			{&quot;System.Int32&quot;,	&quot;INTEGER&quot;},
+			{&quot;System.Int64&quot;,	&quot;LONG&quot;},
+			{&quot;System.Single&quot;,	&quot;SINGLE&quot;},
+			{&quot;System.Double&quot;,	&quot;DOUBLE&quot;},
+			{&quot;System.Decimal&quot;,	&quot;DECIMAL&quot;},
+			{&quot;System.String&quot;,	&quot;STRING&quot;},
+			{&quot;System.DateTime&quot;,	&quot;DATE&quot;}
+		};
+		
+		static Hashtable typeConversionTable = new Hashtable();
+		
+		static CodeDOMVisitor()
+		{
+			for (int i = 0; i &lt; typeConversionList.GetLength(0); ++i) {
+				typeConversionTable[typeConversionList[i, 1]] = typeConversionList[i, 0];
+			}
+		}
+		string ConvType(string type) 
+		{
+			string upperType = type.ToUpper();
+			if (typeConversionTable[upperType] != null) {
+				return typeConversionTable[upperType].ToString();
+			}
+			return type;
+		}
+		// FIXME: map all modifiers correctly
+		MemberAttributes ConvMemberAttributes(Modifier modifier) 
+		{
+			MemberAttributes attr = (MemberAttributes)0;
+			
+			if ((modifier &amp; Modifier.Private) != 0) {
+				attr |=  MemberAttributes.Private;
+			}
+			if ((modifier &amp; Modifier.Public) != 0) {
+				attr |=  MemberAttributes.Public;
+			}
+			if ((modifier &amp; Modifier.Protected) != 0) {
+				attr |=  MemberAttributes.Family;
+			}
+			if ((modifier &amp; Modifier.Friend) != 0) {
+				attr |=  MemberAttributes.Assembly;
+			}
+			if ((modifier &amp; Modifier.Static) != 0) {
+				attr |=  MemberAttributes.Static;
+			}
+			return attr;
+		}
+		
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
+		public override object Visit(INode node, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(CompilationUnit compilationUnit, object data)
+		{
+			CodeNamespace globalNamespace = new CodeNamespace(&quot;Global&quot;);
+			namespaces.Add(globalNamespace);
+			namespaceDeclarations.Push(globalNamespace);
+			compilationUnit.AcceptChildren(this, data);
+			codeCompileUnit.Namespaces.Add(globalNamespace);
+			return globalNamespace;
+		}
+		
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			CodeNamespace currentNamespace = new CodeNamespace(namespaceDeclaration.NameSpace);
+			namespaces.Add(currentNamespace);
+			// add imports from mother namespace
+			foreach (CodeNamespaceImport import in ((CodeNamespace)namespaceDeclarations.Peek()).Imports) {
+				currentNamespace.Imports.Add(import);
+			}
+			namespaceDeclarations.Push(currentNamespace);
+			namespaceDeclaration.AcceptChildren(this, data);
+			namespaceDeclarations.Pop();
+			codeCompileUnit.Namespaces.Add(currentNamespace);
+			
+			// TODO : Nested namespaces allowed in CodeDOM ? Doesn't seem so :(
+			return null;
+		}
+		
+		public override object Visit(ImportsDeclaration importsDeclaration, object data)
+		{
+			((CodeNamespace)namespaceDeclarations.Peek()).Imports.Add(new CodeNamespaceImport(importsDeclaration.Namespace));
+			return null;
+		}
+		
+		public override object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(AttributeSection attributeSection, object data)
+		{
+			return null;
+		}
+		
+		// TODO: OptionCompareDeclaration, OptionExplicitDeclaration, OptionStrictDeclaration
+		
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			// skip nested types.
+			if (currentTypeDeclaration != null) {
+				return data;
+			}
+			if (typeDeclaration.Type == Types.Enum) {
+				return data;
+			}
+			this.currentTypeDeclaration = typeDeclaration;
+			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(typeDeclaration.Name);
+			codeTypeDeclaration.IsClass     = typeDeclaration.Type == Types.Class;
+			codeTypeDeclaration.IsEnum      = typeDeclaration.Type == Types.Enum;
+			codeTypeDeclaration.IsInterface = typeDeclaration.Type == Types.Interface;
+			codeTypeDeclaration.IsStruct    = typeDeclaration.Type == Types.Structure;
+			
+			if (typeDeclaration.BaseType != null) {
+				codeTypeDeclaration.BaseTypes.Add(new CodeTypeReference(typeDeclaration.BaseType));
+			}
+			
+			if (typeDeclaration.BaseInterfaces != null) {
+				foreach (object o in typeDeclaration.BaseInterfaces) {
+					codeTypeDeclaration.BaseTypes.Add(new CodeTypeReference(o.ToString()));
+				}
+			}
+			
+			typeDeclarations.Push(codeTypeDeclaration);
+			typeDeclaration.AcceptChildren(this,data);
+//			((INode)typeDeclaration.Children[0]).(this, data);
+			
+			typeDeclarations.Pop();
+			
+			((CodeNamespace)namespaceDeclarations.Peek()).Types.Add(codeTypeDeclaration);
+			this.currentTypeDeclaration = null;
+			return null;
+		}
+		
+		//FIXME
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+//			CodeTypeDelegate codeTypeDelegate = new CodeTypeDelegate(delegateDeclaration.Name);
+//			codeTypeDelegate.Parameters
+//			
+//			((CodeNamespace)namespaceDeclarations.Peek()).Types.Add(codeTypeDelegate);
+			return null;
+		}
+		
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			for (int i = 0; i &lt; fieldDeclaration.Fields.Count; ++i) {
+				VariableDeclaration field = (VariableDeclaration)fieldDeclaration.Fields[i];
+				if (field.Type != null) {
+					CodeMemberField memberField = new CodeMemberField(new CodeTypeReference(ConvType(field.Type.Type)), field.Name);
+					memberField.Attributes = ConvMemberAttributes(fieldDeclaration.Modifier);
+					if (field.Initializer != null) {
+						memberField.InitExpression =  (CodeExpression)((INode)field.Initializer).AcceptVisitor(this, data);
+					}
+					((CodeTypeDeclaration)typeDeclarations.Peek()).Members.Add(memberField);
+				}
+			}
+			
+			return null;
+		}
+		
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			CodeMemberMethod memberMethod = new CodeMemberMethod();
+			memberMethod.Name = methodDeclaration.Name;
+			currentMethod = memberMethod;
+			((CodeTypeDeclaration)typeDeclarations.Peek()).Members.Add(memberMethod);
+			if (memberMethod.Name.ToUpper() == &quot;INITIALIZECOMPONENT&quot;) {
+				methodDeclaration.Body.AcceptChildren(this, data);
+			}
+			currentMethod = null;
+			return null;
+		}
+		
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(PropertySetRegion PropertySetRegion, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			return null;
+		}
+		
+		// TODO: HandlesClause, ImplementsClause
+		
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			CodeConstructor memberMethod = new CodeConstructor();
+			// HACK: fake public constructor
+			memberMethod.Attributes = MemberAttributes.Public;
+			currentMethod = memberMethod;
+			((CodeTypeDeclaration)typeDeclarations.Peek()).Members.Add(memberMethod);
+			constructorDeclaration.Body.AcceptChildren(this, data);
+			currentMethod = null;
+			return null;
+		}
+		
+		public override object Visit(BlockStatement blockStatement, object data)
+		{
+			blockStatement.AcceptChildren(this, data);
+			return null;
+		}
+		
+		public override object Visit(StatementExpression statementExpression, object data)
+		{
+			if (statementExpression.Expression == null) {
+				//Console.WriteLine(&quot;Warning: Got empty statement expression!!!&quot;);
+				return null;
+			}
+			CodeExpression expr = (CodeExpression)statementExpression.Expression.AcceptVisitor(this, data);
+			if (expr == null) {
+				//if (!(statementExpression.Expression is AssignmentExpression)) {
+					//Console.WriteLine(&quot;NULL EXPRESSION : &quot; + statementExpression.Expression);
+				//}
+			} else {
+				currentMethod.Statements.Add(new CodeExpressionStatement(expr));
+			}
+			
+			return null;
+		}
+		
+		public string Convert(TypeReference typeRef)
+		{
+			StringBuilder builder = new StringBuilder();
+			builder.Append(ConvType(typeRef.Type));
+			
+			if (typeRef.RankSpecifier != null) {
+				for (int i = 0; i &lt; typeRef.RankSpecifier.Count; ++i) {
+					builder.Append('[');
+					for (int j = 1; j &lt; (int)typeRef.RankSpecifier[i]; ++j) {
+						builder.Append(',');
+					}
+					builder.Append(']');
+				}
+			}
+			
+			return builder.ToString();
+		}
+		
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			foreach (VariableDeclaration var in localVariableDeclaration.Variables) {
+				CodeTypeReference type = new CodeTypeReference(Convert(var.Type));
+				if (var.Initializer != null) {
+					currentMethod.Statements.Add(new CodeVariableDeclarationStatement(type,
+					                                                                  var.Name,
+					                                                                  (CodeExpression)((INode)var.Initializer).AcceptVisitor(this, data)));
+				} else {
+					currentMethod.Statements.Add(new CodeVariableDeclarationStatement(type,
+					                                                                  var.Name));
+				}
+			}
+			return null;
+		}
+		
+		public override object Visit(ReturnStatement returnStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(IfStatement ifStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(WhileStatement doWhileStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(DoLoopStatement doWhileStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ForStatement forStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(LabelStatement labelStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(GoToStatement gotoStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(SelectStatement switchStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ForeachStatement foreachStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(LockStatement lockStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(AddHandlerStatement addHandlerStatement, object data)
+		{
+			CodeExpression methodInvoker = (CodeExpression)addHandlerStatement.HandlerExpression.AcceptVisitor(this, null);
+			
+			if (addHandlerStatement.EventExpression is IdentifierExpression) {
+				currentMethod.Statements.Add(new CodeAttachEventStatement(new CodeEventReferenceExpression(new CodeThisReferenceExpression(), ((IdentifierExpression)addHandlerStatement.EventExpression).Identifier),
+				                                                          methodInvoker));
+			} else {
+				FieldReferenceOrInvocationExpression fr = (FieldReferenceOrInvocationExpression)addHandlerStatement.EventExpression;
+				currentMethod.Statements.Add(new CodeAttachEventStatement(new CodeEventReferenceExpression((CodeExpression)fr.TargetObject.AcceptVisitor(this, data), fr.FieldName),
+				                                                          methodInvoker));
+			}
+			return null;
+		}
+		
+		public override object Visit(RemoveHandlerStatement removeHandlerStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(EndStatement endStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ExitStatement exitStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(StopStatement stopStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ResumeStatement resumeStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(EraseStatement eraseStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ErrorStatement errorStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(OnErrorStatement onErrorStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(RaiseEventStatement raiseEventStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ReDimStatement reDimStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ThrowStatement throwStatement, object data)
+		{
+			return new CodeThrowExceptionStatement((CodeExpression)throwStatement.ThrowExpression.AcceptVisitor(this, data));
+		}
+		
+		public override object Visit(PrimitiveExpression expression, object data)
+		{
+//			if (expression.Value is string) {
+//				return new CodePrimitiveExpression(expression.Value);
+//			} else if (expression.Value is char) {
+//				return new CodePrimitiveExpression((char)expression.Value);
+//			} else if (expression.Value == null) {
+//				return new CodePrimitiveExpression(null);
+//			}
+			return new CodePrimitiveExpression(expression.Value);
+		}
+		
+		public override object Visit(BinaryOperatorExpression expression, object data)
+		{
+			CodeBinaryOperatorType op = CodeBinaryOperatorType.Add;
+			switch (expression.Op) {
+				case BinaryOperatorType.Add:
+					op = CodeBinaryOperatorType.Add;
+					break;
+				case BinaryOperatorType.BitwiseAnd:
+					op = CodeBinaryOperatorType.BitwiseAnd;
+					break;
+				case BinaryOperatorType.BitwiseOr:
+					op = CodeBinaryOperatorType.BitwiseOr;
+					break;
+				case BinaryOperatorType.Concat:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.Add;
+					break;
+				case BinaryOperatorType.BooleanAnd:
+					op = CodeBinaryOperatorType.BooleanAnd;
+					break;
+				case BinaryOperatorType.BooleanOr:
+					op = CodeBinaryOperatorType.BooleanOr;
+					break;
+				case BinaryOperatorType.Divide:
+					op = CodeBinaryOperatorType.Divide;
+					break;
+				case BinaryOperatorType.DivideInteger:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.Divide;
+					break;
+				case BinaryOperatorType.GreaterThan:
+					op = CodeBinaryOperatorType.GreaterThan;
+					break;
+				case BinaryOperatorType.GreaterThanOrEqual:
+					op = CodeBinaryOperatorType.GreaterThanOrEqual;
+					break;
+				case BinaryOperatorType.Equality:
+					op = CodeBinaryOperatorType.IdentityEquality;
+					break;
+				case BinaryOperatorType.InEquality:
+					op = CodeBinaryOperatorType.IdentityInequality;
+					break;
+				case BinaryOperatorType.LessThan:
+					op = CodeBinaryOperatorType.LessThan;
+					break;
+				case BinaryOperatorType.LessThanOrEqual:
+					op = CodeBinaryOperatorType.LessThanOrEqual;
+					break;
+				case BinaryOperatorType.Modulus:
+					op = CodeBinaryOperatorType.Modulus;
+					break;
+				case BinaryOperatorType.Multiply:
+					op = CodeBinaryOperatorType.Multiply;
+					break;
+				case BinaryOperatorType.Subtract:
+					op = CodeBinaryOperatorType.Subtract;
+					break;
+				case BinaryOperatorType.ShiftLeft:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.Multiply;
+					break;
+				case BinaryOperatorType.ShiftRight:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.Multiply;
+					break;
+				case BinaryOperatorType.IS:
+					op = CodeBinaryOperatorType.IdentityEquality;
+					break;
+				case BinaryOperatorType.Like:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.IdentityEquality;
+					break;
+				case BinaryOperatorType.ExclusiveOr:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.BitwiseOr;
+					break;
+			}
+			return new CodeBinaryOperatorExpression((CodeExpression)expression.Left.AcceptVisitor(this, data),
+			                                        op,
+			                                        (CodeExpression)expression.Right.AcceptVisitor(this, data));
+		}
+		
+		public override object Visit(ParenthesizedExpression expression, object data)
+		{
+			return expression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(InvocationExpression invocationExpression, object data)
+		{
+			Expression     target     = invocationExpression.TargetObject;
+			CodeExpression targetExpr;
+			string         methodName = null;
+			if (target == null) {
+				targetExpr = new CodeThisReferenceExpression();
+			} else if (target is FieldReferenceOrInvocationExpression) {
+				FieldReferenceOrInvocationExpression fRef = (FieldReferenceOrInvocationExpression)target;
+				targetExpr = (CodeExpression)fRef.TargetObject.AcceptVisitor(this, data);
+				if (fRef.TargetObject is FieldReferenceOrInvocationExpression) {
+					FieldReferenceOrInvocationExpression fRef2 = (FieldReferenceOrInvocationExpression)fRef.TargetObject;
+					if (fRef2.FieldName != null &amp;&amp; Char.IsUpper(fRef2.FieldName[0])) {
+						// an exception is thrown if it doesn't end in an indentifier exception
+						// for example for : this.MyObject.MyMethod() leads to an exception, which 
+						// is correct in this case ... I know this is really HACKY :)
+						try {
+							CodeExpression tExpr = ConvertToIdentifier(fRef2);
+							if (tExpr != null) {
+								targetExpr = tExpr;
+							}
+						} catch (Exception) {}
+					}
+				}
+				methodName = fRef.FieldName;
+				// HACK for : Microsoft.VisualBasic.ChrW(NUMBER)
+				//Console.WriteLine(methodName);
+				if (methodName == &quot;ChrW&quot;) {
+					//Console.WriteLine(&quot;Return CAST EXPRESSION&quot; + GetExpressionList(invocationExpression.Parameters)[0]);
+					
+					return new CodeCastExpression(&quot;System.Char&quot;, GetExpressionList(invocationExpression.Parameters)[0]);
+				}
+			} else {
+				targetExpr = (CodeExpression)target.AcceptVisitor(this, data);
+			}
+			return new CodeMethodInvokeExpression(targetExpr, methodName, GetExpressionList(invocationExpression.Parameters));
+		}
+		
+		public override object Visit(IdentifierExpression expression, object data)
+		{
+			if (IsField(expression.Identifier)) {
+				return new CodeFieldReferenceExpression(new CodeThisReferenceExpression(),
+				                                        expression.Identifier);
+			}
+			return new CodeVariableReferenceExpression(expression.Identifier);
+		}
+		
+		public override object Visit(GetTypeExpression getTypeExpression, object data)
+		{
+			// TODO
+			return null;
+		}
+		
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ClassReferenceExpression classReferenceExpression, object data)
+		{
+			//TODO
+			return null;
+		}
+		
+		public override object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
+		{
+			//TODO
+			return null;
+		}
+		
+		public override object Visit(NamedArgumentExpression namedParameterExpression, object data)
+		{
+			//TODO
+			return null;
+		}
+		
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.Minus:
+					if (unaryOperatorExpression.Expression is PrimitiveExpression) {
+						PrimitiveExpression expression = (PrimitiveExpression)unaryOperatorExpression.Expression;
+						if (expression.Value is int) {
+							return new CodePrimitiveExpression(- (int)expression.Value);
+						}
+						if (expression.Value is long) {
+							return new CodePrimitiveExpression(- (long)expression.Value);
+						}
+						if (expression.Value is double) {
+							return new CodePrimitiveExpression(- (double)expression.Value);
+						}
+						if (expression.Value is float) {
+							return new CodePrimitiveExpression(- (float)expression.Value);
+						}
+						
+					} 
+					return  new CodeBinaryOperatorExpression(new CodePrimitiveExpression(0),
+			                                        CodeBinaryOperatorType.Subtract,
+			                                        (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Plus:
+					return unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+			}
+			return null;
+		}
+		bool methodReference = false;
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			if (assignmentExpression.Op == AssignmentOperatorType.Add) {
+				
+				methodReference = true;
+				CodeExpression methodInvoker = (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null);
+				methodReference = false;
+				
+				if (assignmentExpression.Left is IdentifierExpression) {
+					currentMethod.Statements.Add(new CodeAttachEventStatement(new CodeEventReferenceExpression(new CodeThisReferenceExpression(), ((IdentifierExpression)assignmentExpression.Left).Identifier),
+					                                                          methodInvoker));
+				} else {
+					FieldReferenceOrInvocationExpression fr = (FieldReferenceOrInvocationExpression)assignmentExpression.Left;
+					
+					currentMethod.Statements.Add(new CodeAttachEventStatement(new CodeEventReferenceExpression((CodeExpression)fr.TargetObject.AcceptVisitor(this, data), fr.FieldName),
+					                                                          methodInvoker));
+				}
+			} else {
+				if (assignmentExpression.Left is IdentifierExpression) {
+					currentMethod.Statements.Add(new CodeAssignStatement((CodeExpression)assignmentExpression.Left.AcceptVisitor(this, null), (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null)));
+				} else {
+					currentMethod.Statements.Add(new CodeAssignStatement((CodeExpression)assignmentExpression.Left.AcceptVisitor(this, null), (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null)));
+					
+				}
+			}
+			return null;
+		}
+		
+		public override object Visit(AddressOfExpression addressOfExpression, object data)
+		{
+			if (addressOfExpression.Procedure is FieldReferenceOrInvocationExpression) {
+				FieldReferenceOrInvocationExpression fr = (FieldReferenceOrInvocationExpression)addressOfExpression.Procedure;
+				return new CodeObjectCreateExpression(&quot;System.EventHandler&quot;, new CodeExpression[] {
+					new CodeMethodReferenceExpression((CodeExpression)fr.TargetObject.AcceptVisitor(this, null),
+					                                        fr.FieldName)
+				});
+			}
+			return addressOfExpression.Procedure.AcceptVisitor(this, null);
+		}
+		
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			return new CodeTypeOfExpression(ConvType(typeOfExpression.Type.Type));
+		}
+		
+		public override object Visit(CastExpression castExpression, object data)
+		{
+			string typeRef = ConvType(castExpression.CastTo.Type);
+			return new CodeCastExpression(typeRef, (CodeExpression)castExpression.Expression.AcceptVisitor(this, data));
+		}
+		
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			return new CodeThisReferenceExpression();
+		}
+		
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			return new CodeBaseReferenceExpression();
+		}
+		
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			if (arrayCreateExpression.ArrayInitializer == null) {
+				return new CodeArrayCreateExpression(ConvType(arrayCreateExpression.CreateType.Type),
+				                                     0);
+			}
+			return new CodeArrayCreateExpression(ConvType(arrayCreateExpression.CreateType.Type),
+			                                     GetExpressionList(arrayCreateExpression.ArrayInitializer.CreateExpressions));
+		}
+		
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			return new CodeObjectCreateExpression(ConvType(objectCreateExpression.CreateType.Type),
+			                                      GetExpressionList(objectCreateExpression.Parameters));
+		}
+		
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			return new CodeParameterDeclarationExpression(new CodeTypeReference(ConvType(parameterDeclarationExpression.TypeReference.Type)), parameterDeclarationExpression.ParameterName);
+		}
+		
+		bool IsField(string type, string fieldName)
+		{
+			Type t       = null;
+			Assembly asm = null;
+			
+			t = this.GetType(type);
+			if (t == null) {
+				asm = typeof(System.Drawing.Point).Assembly;
+				t = asm.GetType(type);
+			}
+			
+			//necessary?
+//			if (t == null) {
+//				asm = typeof(System.Windows.Forms.Control).Assembly;
+//				t = asm.GetType(type);
+//			}
+			
+			if (t == null) {
+				asm = typeof(System.String).Assembly;
+				t = asm.GetType(type);
+			}
+			
+			bool isField = t != null &amp;&amp; (t.IsEnum || t.GetField(fieldName) != null);
+			if (!isField) {
+				int idx = type.LastIndexOf('.');
+				if (idx &gt;= 0) {
+					type = type.Substring(0, idx) + &quot;+&quot; + type.Substring(idx + 1);
+					isField = IsField(type, fieldName);
+				}
+			}
+			return isField;
+		}
+		
+		bool IsFieldReferenceExpression(FieldReferenceOrInvocationExpression fieldReferenceExpression)
+		{
+			if (fieldReferenceExpression.TargetObject is ThisReferenceExpression) {
+				foreach (object o in this.currentTypeDeclaration.Children) {
+					if (o is FieldDeclaration) {
+						FieldDeclaration fd = (FieldDeclaration)o;
+						foreach (VariableDeclaration field in fd.Fields) {
+							if (fieldReferenceExpression.FieldName.ToUpper() == field.Name.ToUpper()) {
+								return true;
+							}
+						}
+					}
+				}
+			}
+			return false; //Char.IsLower(fieldReferenceExpression.FieldName[0]);
+		}
+		
+		public override object Visit(FieldReferenceOrInvocationExpression fieldReferenceExpression, object data)
+		{
+			if (methodReference) {
+				methodReference = false;
+				return new CodeMethodReferenceExpression((CodeExpression)fieldReferenceExpression.TargetObject.AcceptVisitor(this, data), fieldReferenceExpression.FieldName);
+			}
+			if (IsFieldReferenceExpression(fieldReferenceExpression)) {
+				return new CodeFieldReferenceExpression((CodeExpression)fieldReferenceExpression.TargetObject.AcceptVisitor(this, data),
+				                                        fieldReferenceExpression.FieldName);
+			} else {
+				if (fieldReferenceExpression.TargetObject is FieldReferenceOrInvocationExpression) {
+					if (IsQualIdent((FieldReferenceOrInvocationExpression)fieldReferenceExpression.TargetObject)) {
+						CodeTypeReferenceExpression typeRef = ConvertToIdentifier((FieldReferenceOrInvocationExpression)fieldReferenceExpression.TargetObject);
+						if (IsField(typeRef.Type.BaseType, fieldReferenceExpression.FieldName)) {
+							return new CodeFieldReferenceExpression(typeRef,
+							                                        fieldReferenceExpression.FieldName);
+						} else {
+							return new CodePropertyReferenceExpression(typeRef,
+							                                           fieldReferenceExpression.FieldName);
+						}
+					}
+				}
+				
+				CodeExpression codeExpression = (CodeExpression)fieldReferenceExpression.TargetObject.AcceptVisitor(this, data);
+				return new CodePropertyReferenceExpression(codeExpression,
+				                                           fieldReferenceExpression.FieldName);
+			}
+		}
+		
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			return null;
+		}
+#endregion
+		
+		bool IsQualIdent(FieldReferenceOrInvocationExpression fieldReferenceExpression)
+		{
+			while (fieldReferenceExpression.TargetObject is FieldReferenceOrInvocationExpression) {
+				fieldReferenceExpression = (FieldReferenceOrInvocationExpression)fieldReferenceExpression.TargetObject;
+			}
+			return fieldReferenceExpression.TargetObject is IdentifierExpression;
+		}
+		
+		bool IsField(string identifier)
+		{
+			foreach (INode node in currentTypeDeclaration.Children) {
+				if (node is FieldDeclaration) {
+					FieldDeclaration fd = (FieldDeclaration)node;
+					if (fd.GetVariableDeclaration(identifier) != null) {
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+		
+		CodeTypeReferenceExpression ConvertToIdentifier(FieldReferenceOrInvocationExpression fieldReferenceExpression)
+		{
+			string type = String.Empty;
+			
+			while (fieldReferenceExpression.TargetObject is FieldReferenceOrInvocationExpression) {
+				type = &quot;.&quot;  + fieldReferenceExpression.FieldName + type;
+				fieldReferenceExpression = (FieldReferenceOrInvocationExpression)fieldReferenceExpression.TargetObject;
+			}
+			
+			type = &quot;.&quot;  + fieldReferenceExpression.FieldName + type;
+			
+			if (fieldReferenceExpression.TargetObject is IdentifierExpression) {
+				type = ((IdentifierExpression)fieldReferenceExpression.TargetObject).Identifier + type;
+				string oldType = type;
+				int idx = type.LastIndexOf('.');
+				while (idx &gt;= 0) {
+					if (Type.GetType(type) != null) {
+						break;
+					}
+					type = type.Substring(0, idx) + &quot;+&quot; + type.Substring(idx + 1);
+					idx = type.LastIndexOf('.');
+				}
+				if (Type.GetType(type) == null) {
+					type = oldType;
+				}
+				return new CodeTypeReferenceExpression(type);
+			} else {
+				throw new Exception();
+			}
+		}
+		
+		CodeExpression[] GetExpressionList(ArrayList expressionList)
+		{
+			if (expressionList == null) {
+				return new CodeExpression[0];
+			}
+			CodeExpression[] list = new CodeExpression[expressionList.Count];
+			for (int i = 0; i &lt; expressionList.Count; ++i) {
+				if (expressionList[i] != null) {
+					list[i] = (CodeExpression)((Expression)expressionList[i]).AcceptVisitor(this, null);
+				}
+				if (list[i] == null) {
+					list[i] = new CodePrimitiveExpression(0);
+				}
+			}
+			return list;
+		}
+
+		Type GetType(string typeName)
+		{
+			foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies()) 
+			{
+				Type type = asm.GetType(typeName);
+				if (type != null) 
+				{
+					return type;
+				}
+			}
+			return Type.GetType(typeName);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,887 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Drawing;
+using System.Diagnostics;
+using System.Globalization;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class Token
+	{
+		public int kind;
+		
+		public int col;
+		public int line;
+		
+		public object    literalValue = null;
+		public string    val;
+		public Token     next;
+		public ArrayList specials;
+		
+		public Point EndLocation {
+			get {
+				return new Point(col + val.Length - 1, line);
+			}
+		}
+		
+		public Point Location {
+			get {
+				return new Point(col, line);
+			}
+		}
+		
+		public Token()
+		{
+		}
+		
+		public Token(int kind)
+		{
+			this.kind = kind;
+		}
+		
+		public Token(int kind, int col, int line, string val)
+		{
+			this.kind = kind;
+			this.col  = col;
+			this.line = line;
+			this.val  = val;
+		}
+		
+		public Token(int kind, int col, int line, string val, object literalValue)
+		{
+			this.kind         = kind;
+			this.col          = col;
+			this.line         = line;
+			this.val          = val;
+			this.literalValue = literalValue;
+		}
+	}
+	
+	public class Lexer
+	{
+		IReader reader;
+		static  Hashtable keywords = new Hashtable();
+		
+		int col  = 1;
+		int line = 1;
+		
+		bool lineEnd = false;
+		
+		Errors errors   = new Errors();
+		
+		SpecialTracker specialTracker = new SpecialTracker();
+		
+		Token lastToken = null;
+		Token curToken  = null;
+		Token peekToken = null;
+		
+		string[]       specialCommentTags = null;
+		Hashtable      specialCommentHash = null;
+		ArrayList      tagComments = new ArrayList();
+		
+		public ArrayList TagComments
+		{
+			get {
+				return tagComments;
+			}
+		}
+		
+		public string[] SpecialCommentTags
+		{
+			get {
+				return specialCommentTags;
+			}
+			set {
+				specialCommentTags = value;
+				specialCommentHash = new Hashtable();
+				if (specialCommentTags != null) {
+					foreach (string str in specialCommentTags) {
+						specialCommentHash[str] = 0;
+					}
+				}
+			}
+		}
+		
+		public SpecialTracker SpecialTracker
+		{
+			get {
+				return specialTracker;
+			}
+		}
+		
+		public Errors Errors
+		{
+			get {
+				return errors;
+			}
+		}
+		
+		public Token Token
+		{
+			get {
+				return lastToken;
+			}
+		}
+		
+		public Token LookAhead
+		{
+			get {
+				return curToken;
+			}
+		}
+		
+		public void StartPeek()
+		{
+			peekToken = curToken;
+		}
+		
+		public Token Peek()
+		{
+			if (peekToken.next == null) {
+				peekToken.next = Next();
+				specialTracker.InformToken(peekToken.next.kind);
+			}
+			peekToken = peekToken.next;
+			return peekToken;
+		}
+		
+		public Token NextToken()
+		{
+			if (curToken == null) { // first call of NextToken()
+				curToken = Next();
+				specialTracker.InformToken(curToken.kind);
+				return curToken;
+			}
+			
+			lastToken = curToken;
+			
+			if (curToken.next == null) {
+				curToken.next = Next();
+				specialTracker.InformToken(curToken.next.kind);
+			}
+			
+			curToken = curToken.next;
+			
+			if (curToken.kind == Tokens.EOF &amp;&amp; !(lastToken.kind == Tokens.EOL)) { // be sure that before EOF there is an EOL token
+				curToken = new Token(Tokens.EOL, curToken.col, curToken.line, &quot;\n&quot;);
+				curToken.next = new Token(Tokens.EOF, curToken.col, curToken.line, &quot;\n&quot;);
+				specialTracker.InformToken(curToken.next.kind);
+			}
+			
+			return curToken;
+		}
+		
+		public ArrayList RetriveComments()
+		{
+			return specialTracker.RetrieveSpecials();
+		}
+		
+//		public ArrayList RetrieveSpecials()
+//		{
+//			if (lastToken == null) {
+//				return this.specialTracker.RetrieveSpecials();
+//			}
+//			
+//			Debug.Assert(lastToken.specials != null);
+//			
+//			ArrayList tmp = lastToken.specials;
+//			lastToken.specials = null;
+//			return tmp;
+//		}
+//		
+		public Lexer(IReader reader)
+		{
+			this.reader = reader;
+		}
+		
+		public Token Next()
+		{
+			while (!reader.Eos()) {
+
+				char ch = reader.GetNext();
+		
+				++col;
+				if (Char.IsWhiteSpace(ch)) {
+				
+					if (ch == '\n') {
+						int x = col - 1;
+						int y = line;
+						++line;
+						col = 1;
+						if (reader.Peek() == '\r') {
+							reader.GetNext();
+							if (!lineEnd) {
+								lineEnd = true;
+								return new Token(Tokens.EOL, x -1 , y, &quot;\n\r&quot;);
+							}
+						}
+						if (!lineEnd) {
+							lineEnd = true;
+							return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
+						}
+					}
+					continue;
+
+				}
+				if (ch == '_') {
+					if (reader.Eos()) {
+						errors.Error(line, col, String.Format(&quot;No EOF expected after _&quot;));
+					}
+					ch = reader.GetNext();
+					++col;
+					if (!Char.IsWhiteSpace(ch)) {
+						reader.UnGet();
+						--col;
+						int x = col;
+						int y = line;
+						string s = ReadIdent('_');
+						lineEnd = false;
+
+						return new Token(Tokens.Identifier, x, y, s);
+					}
+					while (Char.IsWhiteSpace(ch)) {
+						if (ch == '\n') {
+							++line;
+							col = 0;
+							break;
+						}
+						if (!reader.Eos()) {
+							ch = reader.GetNext();
+							++col;
+						}
+					}
+					if (ch != '\n') {
+						errors.Error(line, col, String.Format(&quot;Return expected&quot;));
+					}
+					continue;
+				}
+				
+				if (ch == '#') {
+					while (Char.IsWhiteSpace(reader.Peek())) {
+						++col;
+						reader.GetNext();
+					}
+					if (Char.IsDigit(reader.Peek())) {
+						int x = col;
+						int y = line;
+						string s = ReadDate();
+						DateTime time = DateTime.Now;
+						try {
+							time = System.DateTime.Parse(s, System.Globalization.CultureInfo.InvariantCulture);
+						} catch (Exception e) {
+							errors.Error(line, col, String.Format(&quot;Invalid date time {0}&quot;, e));
+						}
+						return new Token(Tokens.LiteralDate, x, y, s, time);
+					} else {
+						ReadPreprocessorDirective();
+						continue;
+					}
+				}
+				
+				if (ch == '[') { // Identifier
+					lineEnd = false;
+					if (reader.Eos()) {
+						errors.Error(line, col, String.Format(&quot;Identifier expected&quot;));
+					}
+					ch = reader.GetNext();
+					++col;
+					if (ch == ']' || Char.IsWhiteSpace(ch)) {
+						errors.Error(line, col, String.Format(&quot;Identifier expected&quot;));
+					}
+					int x = col - 1;
+					int y = line;
+					string s = ReadIdent(ch);
+					if (reader.Eos()) {
+						errors.Error(line, col, String.Format(&quot;']' expected&quot;));
+					}
+					ch = reader.GetNext();
+					++col;
+					if (!(ch == ']')) {
+						errors.Error(line, col, String.Format(&quot;']' expected&quot;));
+					}
+//					Console.WriteLine(&quot;&gt;&quot; + s + &quot;&lt;&quot;);
+					return new Token(Tokens.Identifier, x, y, s);
+				}
+				if (Char.IsLetter(ch)) {
+					int x = col - 1;
+					int y = line;
+					string s = ReadIdent(ch);
+					if (Keywords.IsKeyword(s)) {
+						lineEnd = false;
+						return new Token(Keywords.GetToken(s), x, y, s);
+					}
+					
+					// handle 'REM' comments 
+					if (s.ToUpper() == &quot;REM&quot;) {
+						ReadComment();
+						if (!lineEnd) {
+							lineEnd = true;
+							return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
+						}
+						continue;
+					}
+						
+					lineEnd = false;
+					return new Token(Tokens.Identifier, x, y, s);
+				
+				}
+				if (Char.IsDigit(ch)) {
+					lineEnd = false;
+					return ReadDigit(ch, col);
+				}
+				if (ch == '&amp;') {
+					lineEnd = false;
+					if (reader.Eos()) {
+						return ReadOperator('&amp;');
+					}
+					ch = reader.GetNext();
+					++col;
+					if (Char.ToUpper(ch) == 'H' || Char.ToUpper(ch) == 'O') {
+						reader.UnGet();
+						--col;
+						return ReadDigit('&amp;', col);
+					} else {
+						reader.UnGet();
+						return ReadOperator('&amp;');
+					}
+				}
+				if (ch == '\'') {
+					int x = col - 1;
+					int y = line;
+					ReadComment();
+					if (!lineEnd) {
+						lineEnd = true;
+						return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
+					}
+					continue;
+				}
+				if (ch == '&quot;') {
+					lineEnd = false;
+					int x = col - 1;
+					int y = line;
+					string s = ReadString();
+					if (!reader.Eos() &amp;&amp; (reader.Peek() == 'C' || reader.Peek() == 'c')) {
+						reader.GetNext();
+						++col;
+						if (s.Length != 1) {
+							errors.Error(line, col, String.Format(&quot;Chars can only have Length 1 &quot;));
+						}
+						return new Token(Tokens.LiteralCharacter, x, y, String.Concat('&quot;', s , &quot;\&quot;C&quot;) , s[0]);
+					}
+					return new Token(Tokens.LiteralString, x, y,  String.Concat('&quot;', s , '&quot;'), s);
+				}
+				Token token = ReadOperator(ch);
+				if (token != null) {
+					lineEnd = false;
+					return token;
+				}
+				errors.Error(line, col, String.Format(&quot;Unknown char({0}) which can't be read&quot;, ch));
+			}
+			
+			return new Token(Tokens.EOF);
+		}
+		
+		string ReadIdent(char ch) 
+		{
+			StringBuilder s = new StringBuilder(ch.ToString());
+			while (!reader.Eos() &amp;&amp; (Char.IsLetterOrDigit(ch = reader.GetNext()) || ch == '_')) {
+				++col;
+				s.Append(ch.ToString());
+			}
+			++col;
+			if (reader.Eos()) {
+				--col;
+				return s.ToString();
+			}
+			reader.UnGet();
+			--col;
+			if (!reader.Eos() &amp;&amp; &quot;%&amp;@!#$&quot;.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
+				reader.GetNext();
+				++col;
+			}
+			return s.ToString();
+		}
+		
+		Token ReadDigit(char ch, int x)
+		{
+			StringBuilder sb = new StringBuilder(ch.ToString());
+			int y = line;
+			string digit = &quot;&quot;;
+			if (ch != '&amp;') {
+				digit += ch;
+			}
+			
+			bool ishex      = false;
+			bool isokt      = false;
+			bool issingle   = false;
+			bool isdouble   = false;
+			bool isdecimal  = false;
+			
+			if (reader.Eos()) {
+				if (ch == '&amp;') {
+					errors.Error(line, col, String.Format(&quot;digit expected&quot;));
+				}
+				return new Token(Tokens.LiteralInteger, x, y, sb.ToString() ,ch - '0');
+			}
+			if (ch == '&amp;' &amp;&amp; Char.ToUpper(reader.Peek()) == 'H') {
+				const string hex = &quot;0123456789ABCDEF&quot;;
+				sb.Append(reader.GetNext()); // skip 'H'
+				++col;
+				while (!reader.Eos() &amp;&amp; hex.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
+					ch = reader.GetNext();
+					sb.Append(ch); 
+					digit += Char.ToUpper(ch);
+					++col;
+				}
+				ishex = true;
+			} else if (!reader.Eos() &amp;&amp; ch == '&amp;' &amp;&amp; Char.ToUpper(reader.Peek()) == 'O') {
+				const string okt = &quot;01234567&quot;;
+				sb.Append(reader.GetNext()); // skip 'O'
+				++col;
+				while (!reader.Eos() &amp;&amp; okt.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
+					ch = reader.GetNext();
+					sb.Append(ch); 
+					digit += Char.ToUpper(ch);
+					++col;
+				}
+				isokt = true;
+			} else {
+				while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())) {
+					ch = reader.GetNext();;
+					digit += ch;
+					sb.Append(ch);
+					++col;
+				}
+			}
+			if (!reader.Eos() &amp;&amp; &quot;%&amp;SIL&quot;.IndexOf(Char.ToUpper(reader.Peek())) != -1 || ishex || isokt) {
+				ch = reader.GetNext();
+				sb.Append(ch); 
+				ch = Char.ToUpper(ch);
+				++col;
+				if (isokt) {
+					long number = 0L;
+					for (int i = 0; i &lt; digit.Length; ++i) {
+						number = number * 8 + digit[i] - '0';
+					}
+					if (ch == 'S') {
+						return new Token(Tokens.LiteralSingle, x, y, sb.ToString(), (short)number);
+					} else if (ch == '%' || ch == 'I') {
+						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
+					} else if (ch == '&amp;' || ch == 'L') {
+						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (long)number);
+					} else {
+						if (number &gt; int.MaxValue || number &lt; int.MinValue) {
+							return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (long)number);
+						} else {
+							return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
+						}
+					}
+				}
+				if (ch == 'S') {
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int16.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+				} else if (ch == '%' || ch == 'I') {
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+				} else if (ch == '&amp;' || ch == 'L') {
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+				} else if (ishex) {
+					reader.UnGet();
+					--col;
+					long number = Int64.Parse(digit, NumberStyles.HexNumber);
+					if (number &gt; int.MaxValue || number &lt; int.MinValue) {
+						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), number);
+					} else {
+						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
+					}
+				}
+			}
+			if (!reader.Eos() &amp;&amp; reader.Peek() == '.') { // read floating point number
+				reader.GetNext();
+				if (!Char.IsDigit(reader.Peek())) {
+					reader.UnGet();
+				} else {
+					isdouble = true; // double is default
+					if (ishex || isokt) {
+						errors.Error(line, col, String.Format(&quot;No hexadecimal or oktadecimal floating point values allowed&quot;));
+					}
+					digit += '.';
+					++col;
+					while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())){ // read decimal digits beyond the dot
+						digit += reader.GetNext();
+						++col;
+					}
+				}
+			}
+			
+			if (!reader.Eos() &amp;&amp; Char.ToUpper(reader.Peek()) == 'E') { // read exponent
+				isdouble = true;
+				digit +=  reader.GetNext();
+				++col;
+				if (!reader.Eos() &amp;&amp; (reader.Peek() == '-' || reader.Peek() == '+')) {
+					digit += reader.GetNext();
+					++col;
+				}
+				while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())) { // read exponent value
+					digit += reader.GetNext();
+					++col;
+				}
+			}
+			
+			if (!reader.Eos()) {
+				if (Char.ToUpper(reader.Peek()) == 'R' || Char.ToUpper(reader.Peek()) == '#') { // double type suffix (obsolete, double is default)
+					reader.GetNext();
+					++col;
+					isdouble = true;
+				} else if (Char.ToUpper(reader.Peek()) == 'D' || Char.ToUpper(reader.Peek()) == '@') { // decimal value
+					reader.GetNext();
+					++col;
+					isdecimal = true;
+				} else if (Char.ToUpper(reader.Peek()) == 'F' || Char.ToUpper(reader.Peek()) == '!') { // decimal value
+					reader.GetNext();
+					++col;
+					issingle = true;
+				}
+			}
+			
+			if (issingle) {
+				NumberFormatInfo mi = new NumberFormatInfo();
+				mi.CurrencyDecimalSeparator = &quot;.&quot;;
+				return new Token(Tokens.LiteralSingle, x, y, sb.ToString(), Single.Parse(digit, mi));
+			}
+			if (isdecimal) {
+				NumberFormatInfo mi = new NumberFormatInfo();
+				mi.CurrencyDecimalSeparator = &quot;.&quot;;
+				return new Token(Tokens.LiteralDecimal, x, y, sb.ToString(), Decimal.Parse(digit, mi));
+			}
+			if (isdouble) {
+				NumberFormatInfo mi = new NumberFormatInfo();
+				mi.CurrencyDecimalSeparator = &quot;.&quot;;
+				return new Token(Tokens.LiteralDouble, x, y, sb.ToString(), Double.Parse(digit, mi));
+			}
+			try {
+				return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+			} catch (Exception) {
+				try {
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+				} catch (Exception) {
+					errors.Error(line, col, String.Format(&quot;{0} is not a parseable number (too long?)&quot;, sb.ToString()));
+					// fallback, when nothing helps :)
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), 0);
+				}
+			}
+		}
+		
+		void ReadPreprocessorDirective()
+		{
+			Point start = new Point(col - 1, line);
+			string directive = ReadIdent('#');
+			string argument  = ReadToEOL();
+			this.specialTracker.AddPreProcessingDirective(directive, argument.Trim(), start, new Point(start.X + directive.Length + argument.Length, start.Y));
+		}
+		
+		string ReadToEOL()
+		{
+			StringBuilder sb = new StringBuilder();
+			if (!reader.Eos()) {
+				char ch = reader.GetNext();
+				while (!reader.Eos()) {
+					if (ch == '\r') {
+						if (reader.Peek() == '\n') {
+							ch = reader.GetNext();
+						}
+					}
+					if (ch == '\n') {
+						++line;
+						col = 1;
+						return sb.ToString();
+					} else {
+						sb.Append(ch);
+					}
+					ch = reader.GetNext();
+					++col;
+				}
+			}
+			return sb.ToString();
+		}
+		
+		string ReadDate()
+		{
+			char ch = '\0';
+			StringBuilder sb = new StringBuilder();
+			while (!reader.Eos()) {
+				ch = reader.GetNext();
+				++col;
+				if (ch == '#') {
+					break;
+				} else if (ch == '\n') {
+					errors.Error(line, col, String.Format(&quot;No return allowed inside Date literal&quot;));
+				} else {
+					sb.Append(ch);
+				}
+			}
+			if (ch != '#') {
+				errors.Error(line, col, String.Format(&quot;End of File reached before Date literal terminated&quot;));
+			}
+			return sb.ToString();
+		}
+		
+		string ReadString()
+		{
+			char ch = '\0';
+			StringBuilder s = new StringBuilder();
+			while (!reader.Eos()) {
+				ch = reader.GetNext();
+				++col;
+				if (ch == '&quot;') {
+					if (!reader.Eos() &amp;&amp; reader.Peek() == '&quot;') {
+						s.Append('&quot;');
+						reader.GetNext();
+						++col;
+					} else {
+						break;
+					}
+				} else if (ch == '\n') {
+					errors.Error(line, col, String.Format(&quot;No return allowed inside String literal&quot;));
+				} else {
+					s.Append(ch);
+				}
+			}
+			if (ch != '&quot;') {
+				errors.Error(line, col, String.Format(&quot;End of File reached before String terminated &quot;));
+			}
+			return s.ToString();
+		}
+		
+		protected bool HandleLineEnd(char ch)
+		{
+			if (WasLineEnd(ch)) {
+				++line;
+				col = 1;
+				return true;
+			}
+			return false;
+		}
+		
+		protected bool WasLineEnd(char ch)
+		{
+			// Handle MS-DOS or MacOS line ends.
+			if (ch == '\r') {
+				if (reader.Peek() == '\n') { // MS-DOS line end '\r\n'
+					ch = (char)reader.GetNext();
+				} else { // assume MacOS line end which is '\r'
+					ch = '\n';
+				}
+			}
+			return ch == '\n';
+		}
+		
+		void ReadComment()
+		{
+			StringBuilder curWord = new StringBuilder();
+			StringBuilder comment = new StringBuilder();
+			
+			int x = col;
+			int y = line;
+			int nextChar;
+			while ((nextChar = reader.GetNext()) != -1) {
+				char ch = (char)nextChar;
+				comment.Append(ch);
+				++col;
+				if (HandleLineEnd(ch) || nextChar == 0) {
+					specialTracker.StartComment(CommentType.SingleLine, new Point(col, line));
+					specialTracker.AddString(comment.ToString());
+					specialTracker.FinishComment();
+					return;
+				}
+				
+				if (Char.IsLetter(ch)) {
+					curWord.Append(ch);
+				} else {
+					string tag = curWord.ToString();
+					curWord = new StringBuilder();
+					if (specialCommentHash != null &amp;&amp; specialCommentHash[tag] != null) {
+						Point p = new Point(col, line);
+						string commentStr = ReadToEOL();
+						tagComments.Add(new TagComment(tag, commentStr, p));
+						return;
+					}
+				}
+			}
+		}
+		
+		Token ReadOperator(char ch)
+		{
+			int x = col;
+			int y = line;
+			switch(ch) {
+				case '+':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.PlusAssign, x, y, &quot;+=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Plus, x, y, &quot;+&quot;);
+				case '-':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.MinusAssign, x, y, &quot;-=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Minus, x, y, &quot;-&quot;);
+				case '*':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.TimesAssign, x, y, &quot;*=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Times, x, y, &quot;*&quot;);
+				case '/':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.DivAssign, x, y, &quot;/=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Div, x, y, &quot;/&quot;);
+				case '\\':
+					switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.DivIntegerAssign, x, y, &quot;\\=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					return new Token(Tokens.DivInteger, x, y, &quot;\\&quot;);
+				case '&amp;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.ConcatStringAssign, x, y, &quot;&amp;=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.ConcatString, x, y, &quot;&amp;&quot;);
+				case '^':
+					switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.PowerAssign, x, y, &quot;^=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					return new Token(Tokens.Power, x, y, &quot;^&quot;);
+				case ':':
+					return new Token(Tokens.Colon, x, y, &quot;:&quot;);
+				case '=':
+					return new Token(Tokens.Assign, x, y, &quot;=&quot;);
+				case '&lt;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.LessEqual, x, y, &quot;&lt;=&quot;);
+							case '&gt;':
+								++col;
+								return new Token(Tokens.NotEqual, x, y, &quot;&lt;&gt;&quot;);
+							case '&lt;':
+								if (!reader.Eos()) {
+									switch (reader.GetNext()) {
+										case '=':
+											col += 2;
+											return new Token(Tokens.ShiftLeftAssign, x, y, &quot;&lt;&lt;=&quot;);
+										default:
+											++col;
+											reader.UnGet();
+											break;
+									}
+								}
+								return new Token(Tokens.ShiftLeft, x, y, &quot;&lt;&lt;&quot;);
+							default:
+								reader.UnGet();
+								return new Token(Tokens.LessThan, x, y, &quot;&lt;&quot;);
+						}
+					}
+					return new Token(Tokens.LessThan, x, y, &quot;&lt;&quot;);
+				case '&gt;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.GreaterEqual, x, y, &quot;&gt;=&quot;);
+							case '&gt;':
+								if (!reader.Eos()) {
+									switch (reader.GetNext()) {
+										case '=':
+											col += 2;
+											return new Token(Tokens.ShiftRightAssign, x, y, &quot;&gt;&gt;=&quot;);
+										default:
+											++col;
+											reader.UnGet();
+											break;
+									}
+								}
+								return new Token(Tokens.ShiftRight, x, y, &quot;&gt;&gt;&quot;);
+							default:
+								reader.UnGet();
+								return new Token(Tokens.GreaterThan, x, y, &quot;&gt;&quot;);
+						}
+					}
+					return new Token(Tokens.GreaterThan, x, y, &quot;&lt;=&quot;);
+				case ',':
+					return new Token(Tokens.Comma, x, y, &quot;,&quot;);
+				case '.':
+					if (Char.IsDigit(reader.Peek())) {
+						 reader.UnGet();
+						 --col;
+						 return ReadDigit('0', col);
+					}
+					return new Token(Tokens.Dot, x, y, &quot;.&quot;);
+				case '(':
+					return new Token(Tokens.OpenParenthesis, x, y, &quot;(&quot;);
+				case ')':
+					return new Token(Tokens.CloseParenthesis, x, y, &quot;)&quot;);
+				case '{':
+					return new Token(Tokens.OpenCurlyBrace, x, y, &quot;{&quot;);
+				case '}':
+					return new Token(Tokens.CloseCurlyBrace, x, y, &quot;}&quot;);
+				case '[':
+					return new Token(Tokens.OpenSquareBracket, x, y, &quot;[&quot;);
+				case ']':
+					return new Token(Tokens.CloseSquareBracket, x, y, &quot;]&quot;);
+			}
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,53 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class FileReader : IReader
+	{
+		string file = null;
+		int    ptr  = 0;
+		
+		public FileReader(string filename)
+		{
+			StreamReader sreader = File.OpenText(filename);
+			file = sreader.ReadToEnd();
+			sreader.Close();
+		}
+		
+		public char GetNext()
+		{
+			if (Eos()) {
+				return '\0';
+//				throw new ParserException(&quot;warning : FileReader.GetNext : Read char over eos.&quot;, 0, 0);
+			}
+			return file[ptr++];
+		}
+		
+		public char Peek()
+		{
+			if (Eos()) {
+				return '\0';
+//				throw new ParserException(&quot;warning : FileReader.Peek : Read char over eos.&quot;, 0, 0);
+			}
+			return file[ptr];
+		}
+		
+		public void UnGet()
+		{
+			ptr = Math.Max(0, ptr -1);
+		}
+		
+		public bool Eos()
+		{
+			return ptr &gt;= file.Length;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,19 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public interface IReader
+	{
+		char GetNext();
+		char Peek();
+		
+		void UnGet();
+		
+		bool Eos();
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,49 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class StringReader : IReader
+	{
+		string data = null;
+		int    ptr  = 0;
+		
+		public StringReader(string data)
+		{
+			this.data = data;
+		}
+		
+		public char GetNext()
+		{
+			if (Eos()) {
+				return '\n';
+			}
+			return data[ptr++];
+		}
+		
+		public char Peek()
+		{
+			if (Eos()) {
+				return '\n';
+			}
+			return data[ptr];
+		}
+		
+		public void UnGet()
+		{
+			ptr = Math.Max(0, ptr -1);
+		}
+		
+		public bool Eos()
+		{
+			return ptr &gt;= data.Length;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,49 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+using System.Drawing;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class Comment
+	{
+		CommentType   commentType;
+		string        comment;
+		Point         startPosition;
+		
+		public CommentType CommentType {
+			get {
+				return commentType;
+			}
+			set {
+				commentType = value;
+			}
+		}
+		
+		public string CommentText {
+			get {
+				return comment;
+			}
+			set {
+				comment = value;
+			}
+		}
+		
+		public Point StartPosition {
+			get {
+				return startPosition;
+			}
+			set {
+				startPosition = value;
+			}
+		}
+		
+		public Comment(CommentType commentType, string comment, Point startPosition)
+		{
+			this.commentType   = commentType;
+			this.comment       = comment;
+			this.startPosition = startPosition;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,13 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public enum CommentType
+	{
+		REM,
+		SingleLine
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,14 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class NewLine
+	{
+		public NewLine()
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,61 @@
+using System;
+using System.Drawing;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class PreProcessingDirective
+	{
+		string cmd;
+		string arg;
+		Point  start;
+		Point  end;
+		
+		public Point Start {
+			get {
+				return start;
+			}
+			set {
+				start = value;
+			}
+		}
+		
+		public Point End {
+			get {
+				return end;
+			}
+			set {
+				end = value;
+			}
+		}
+		
+		public string Cmd {
+			get {
+				return cmd;
+			}
+			set {
+				cmd = value;
+			}
+		}
+		
+		public string Arg {
+			get {
+				return arg;
+			}
+			set {
+				arg = value;
+			}
+		}
+		
+		public PreProcessingDirective(string cmd, string arg, Point start, Point end)
+		{
+			this.cmd = cmd;
+			this.arg = arg;
+			this.start = start;
+			this.end = end;
+		}
+	}
+}
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,79 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+using System.Drawing;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class SpecialTracker
+	{
+		ArrayList currentSpecials = new ArrayList();
+		ArrayList tempComments = new ArrayList();
+		
+		CommentType currentCommentType;
+		StringBuilder sb = new StringBuilder();
+		Point startPosition;
+		
+		public ArrayList CurrentSpecials
+		{
+			get {
+				return currentSpecials;
+			}
+		}
+		
+		public void InformToken(int kind)
+		{
+			currentSpecials.Add(kind);
+		}
+		
+		public ArrayList RetrieveSpecials()
+		{
+			ArrayList tmp = currentSpecials;
+			currentSpecials = new ArrayList();
+			return tmp;
+		}
+		
+		public ArrayList RetreiveComments()
+		{
+			ArrayList tmp = tempComments;
+			tempComments = new ArrayList();
+			return tmp;
+		}
+		
+		public void AddEndOfLine()
+		{
+			currentSpecials.Add(new NewLine());
+		}
+		
+		public void AddPreProcessingDirective(string cmd, string arg, Point start, Point end)
+		{
+			currentSpecials.Add(new PreProcessingDirective(cmd, arg, start, end));
+		}
+		
+		// used for comment tracking
+		public void StartComment(CommentType commentType, Point startPosition)
+		{
+			this.currentCommentType = commentType;
+			this.startPosition      = startPosition;
+			this.sb.Length          = 0; 
+		}
+		
+		public void AddChar(char c)
+		{
+			sb.Append(c);
+		}
+		
+		public void AddString(string s)
+		{
+			sb.Append(s);
+		}
+		
+		public void FinishComment()
+		{
+			Comment comment = new Comment(currentCommentType, sb.ToString(), startPosition);
+			currentSpecials.Add(comment);
+			tempComments.Add(comment);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,30 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+using System.Drawing;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	/// &lt;summary&gt;
+	/// Description of TagComment.	
+	/// &lt;/summary&gt;
+	public class TagComment : Comment
+	{
+		string tag;
+		
+		public string Tag {
+			get {
+				return tag;
+			}
+			set {
+				tag = value;
+			}
+		}
+		
+		public TagComment(string tag, string comment, Point startPosition) : base(CommentType.SingleLine, comment, startPosition)
+		{
+			this.tag = tag;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,41 @@
+/*using System;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+class MainClass
+{
+	public static void Main (string[] args) {
+		
+		string fileName = args[0];
+		
+		Console.WriteLine(&quot;Parsing source file {0}&quot;, fileName);
+		IReader reader = new FileReader(fileName);
+		Lexer lexer = new Lexer(reader);
+		
+//		while(true)
+//		{
+//			Token t = lexer.NextToken();
+//			if(t.kind == Tokens.EOF) break;
+//			
+//			System.Console.WriteLine(t.val + &quot;\t&quot; + t.kind);
+//		}
+		
+		Parser p = new Parser();
+		p.Parse(lexer);
+		if(p.Errors.count == 0) {
+//			p.compilationUnit.AcceptVisitor(new DebugVisitor(), null);
+		}
+		
+		System.Console.WriteLine(&quot;=======================&quot;);
+		if (p.Errors.count == 1)
+			Console.WriteLine(&quot;1 error dectected&quot;);
+		else {
+			Console.WriteLine(&quot;{0} errors dectected&quot;, p.Errors.count);
+		}
+		
+		if(p.Errors.count != 0) {
+			System.Console.WriteLine(p.Errors.ErrorOutput);
+		}
+		System.Console.WriteLine(&quot;=======================&quot;);
+	}
+}*/

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,678 @@
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public abstract class AbstractASTVisitor : IASTVisitor
+	{
+		protected Stack blockStack = new Stack();
+		
+		public BlockStatement CurrentBlock {
+			get {
+				if (blockStack.Count == 0) {
+					return null;
+				}
+				return (BlockStatement)blockStack.Peek();
+			}
+		}
+		
+		public virtual object Visit(INode node, object data)
+		{
+			Console.WriteLine(&quot;Warning, INode visited!&quot;);
+			Console.WriteLine(&quot;Type is &quot; + node.GetType());
+			Console.WriteLine(&quot;Visitor is &quot; + this.GetType());
+			return node.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(CompilationUnit compilationUnit, object data)
+		{
+			if (compilationUnit == null) {
+				return data;
+			}
+			return compilationUnit.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			return namespaceDeclaration.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(OptionStrictDeclaration optionStrictDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(OptionCompareDeclaration optionCompareDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ImportsStatement importsStatement, object data)
+		{
+			object ret = data;
+			foreach (INode n in importsStatement.ImportClauses) {
+				ret = n.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ImportsDeclaration importsDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(AttributeSection attributeSection, object data)
+		{
+			object ret = data;
+			foreach (ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute a in attributeSection.Attributes) {
+				ret = a.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data)
+		{
+			object ret = data;
+			foreach (Expression e in attribute.PositionalArguments) {
+				ret = e.AcceptVisitor(this, data);
+			}
+			foreach (NamedArgumentExpression n in attribute.NamedArguments) {
+				ret = n.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(NamedArgumentExpression namedArgumentExpression, object data)
+		{
+			return namedArgumentExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(TypeReference typeReference, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			foreach (AttributeSection a in typeDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			return typeDeclaration.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+			foreach (AttributeSection a in delegateDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			if (delegateDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in delegateDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			if (delegateDeclaration.ReturnType == null) {
+				return data;
+			}
+			return delegateDeclaration.ReturnType.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			foreach (AttributeSection a in fieldDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			if (fieldDeclaration.Fields != null) {
+				foreach (VariableDeclaration v in fieldDeclaration.Fields) {
+					v.AcceptVisitor(this, data);
+				}
+			}
+			if (fieldDeclaration.TypeReference == null) {
+				return data;
+			}
+			return fieldDeclaration.TypeReference.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			if (variableDeclaration.Initializer == null) {
+				return data;
+			}
+			return variableDeclaration.Initializer.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			object ret = data;
+			foreach (AttributeSection a in parameterDeclarationExpression.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			ret = parameterDeclarationExpression.TypeReference.AcceptVisitor(this, data);
+			if (parameterDeclarationExpression.DefaultValue != null) {
+				ret = parameterDeclarationExpression.DefaultValue.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			blockStack.Push(constructorDeclaration.Body);
+			foreach (AttributeSection a in constructorDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			if (constructorDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in constructorDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			object ret = null;
+			if (constructorDeclaration.Body != null) {
+				ret = constructorDeclaration.Body.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			blockStack.Push(methodDeclaration.Body);
+			foreach (AttributeSection a in methodDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			if (methodDeclaration.TypeReference != null) {
+				methodDeclaration.TypeReference.AcceptVisitor(this, data);
+			}
+			
+			if (methodDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in methodDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			
+			if (methodDeclaration.HandlesClause != null) {
+				methodDeclaration.HandlesClause.AcceptVisitor(this, data);
+			}
+			if (methodDeclaration.ImplementsClause != null) {
+				methodDeclaration.ImplementsClause.AcceptVisitor(this, data);
+			}
+			object ret = null;
+			if (methodDeclaration.Body != null) {
+				methodDeclaration.Body.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(DeclareDeclaration declareDeclaration, object data)
+		{
+			if (declareDeclaration != null) {
+				if (declareDeclaration.Attributes != null) {
+					foreach (AttributeSection a in declareDeclaration.Attributes) {
+						a.AcceptVisitor(this, data);
+					}
+				}
+				
+				if (declareDeclaration.ReturnType != null) {
+					declareDeclaration.ReturnType.AcceptVisitor(this, data);
+				}
+				
+				if (declareDeclaration.Parameters != null) {
+					foreach (ParameterDeclarationExpression p in declareDeclaration.Parameters) {
+						p.AcceptVisitor(this, data);
+					}
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			foreach (AttributeSection a in propertyDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			propertyDeclaration.TypeReference.AcceptVisitor(this, data);
+			if (propertyDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in propertyDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			if (propertyDeclaration.ImplementsClause != null) {
+				propertyDeclaration.ImplementsClause.AcceptVisitor(this, data);
+			}
+			if (propertyDeclaration.HasGetRegion) {
+				propertyDeclaration.GetRegion.AcceptVisitor(this, data);
+			}
+			if (propertyDeclaration.HasSetRegion) {
+				propertyDeclaration.SetRegion.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			blockStack.Push(propertyGetRegion.Block);
+			foreach (AttributeSection a in propertyGetRegion.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			object ret = null;
+			if (propertyGetRegion.Block != null) {
+				ret = propertyGetRegion.Block.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(PropertySetRegion propertySetRegion, object data)
+		{
+			blockStack.Push(propertySetRegion.Block);
+			foreach (AttributeSection a in propertySetRegion.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			object ret = null;
+			if (propertySetRegion.Block != null) {
+				ret = propertySetRegion.Block.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			foreach (AttributeSection a in eventDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			eventDeclaration.TypeReference.AcceptVisitor(this, data);
+			if (eventDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in eventDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			if (eventDeclaration.ImplementsClause != null) {
+				eventDeclaration.ImplementsClause.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(BlockStatement blockStatement, object data)
+		{
+			if (blockStatement == null) {
+				return null;
+			}
+			blockStack.Push(blockStatement);
+			object ret = blockStatement.AcceptChildren(this, data);
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(Statement statement, object data)
+		{
+			Console.WriteLine(&quot;Warning, visited Statement!&quot;);
+			return data;
+		}
+		
+		public virtual object Visit(StatementExpression statementExpression, object data)
+		{
+			if (statementExpression.Expression == null) {
+				return data;
+			}
+			return statementExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			object ret = data;
+			if (localVariableDeclaration.Variables != null) {
+				foreach (VariableDeclaration v in localVariableDeclaration.Variables) {
+					ret = v.AcceptVisitor(this, data);
+				}
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(SimpleIfStatement ifStatement, object data)
+		{
+			object ret = ifStatement.Condition.AcceptVisitor(this, data);
+			if(ifStatement.Statements != null) {
+				foreach (Statement s in ifStatement.Statements) {
+					ret = s.AcceptVisitor(this, data);
+				}
+			}
+			if(ifStatement.ElseStatements != null) {
+				foreach (Statement s in ifStatement.ElseStatements) {
+					ret = s.AcceptVisitor(this, data);
+				}
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(IfStatement ifStatement, object data)
+		{
+			object ret = ifStatement.Condition.AcceptVisitor(this, data);
+			if(ifStatement.ElseIfStatements != null) {
+				foreach (Statement s in ifStatement.ElseIfStatements) {
+					ret = s.AcceptVisitor(this, data);
+				}
+			}
+			if (ifStatement.EmbeddedElseStatement != null) {
+				ret = ifStatement.EmbeddedElseStatement.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(LabelStatement labelStatement, object data)
+		{
+			if (labelStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return labelStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(GoToStatement goToStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(SelectStatement selectStatement, object data)
+		{
+			selectStatement.SelectExpression.AcceptVisitor(this, data);
+			if (selectStatement.SelectSections != null) {
+				foreach (SelectSection s in selectStatement.SelectSections) {
+					s.AcceptVisitor(this, data);
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(SelectSection selectSection, object data)
+		{
+			if (selectSection.CaseClauses != null) {
+				foreach (CaseClause c in selectSection.CaseClauses) {
+					c.AcceptVisitor(this, data);
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(CaseClause caseClause, object data)
+		{
+			caseClause.ComparisonExpression.AcceptVisitor(this, data);
+			return caseClause.BoundaryExpression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ExitStatement exitStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(EndStatement endStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(StopStatement stopStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ResumeStatement resumeStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ErrorStatement errorStatement, object data)
+		{
+			return errorStatement.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(OnErrorStatement onErrorStatement, object data)
+		{
+			return onErrorStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(EraseStatement eraseStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ReDimStatement reDimStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(AddHandlerStatement addHandlerStatement, object data)
+		{
+			addHandlerStatement.EventExpression.AcceptVisitor(this, data);
+			addHandlerStatement.HandlerExpression.AcceptVisitor(this, data);
+			return data;
+		}
+		
+		public virtual object Visit(RemoveHandlerStatement removeHandlerStatement, object data)
+		{
+			removeHandlerStatement.EventExpression.AcceptVisitor(this, data);
+			removeHandlerStatement.HandlerExpression.AcceptVisitor(this, data);
+			return data;
+		}
+		
+		public virtual object Visit(ReturnStatement returnStatement, object data)
+		{
+			return returnStatement.ReturnExpression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(RaiseEventStatement raiseEventStatement, object data)
+		{
+			if (raiseEventStatement.Parameters != null) {
+				foreach (INode node in raiseEventStatement.Parameters) {
+					node.AcceptVisitor(this, data);
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(WhileStatement whileStatement, object data)
+		{
+			if (whileStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(WithStatement withStatement, object data)
+		{
+			if (withStatement.WithExpression != null) {
+				withStatement.WithExpression.AcceptVisitor(this, data);
+			}
+			
+			if (withStatement.Body == null) {
+				return null;
+			}
+			return withStatement.Body.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(DoLoopStatement doLoopStatement, object data)
+		{
+			if (doLoopStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ForStatement forStatement, object data)
+		{
+			if (forStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ForeachStatement foreachStatement, object data)
+		{
+			if (foreachStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(LockStatement lockStatement, object data)
+		{
+			if (lockStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			if (tryCatchStatement.StatementBlock == null) {
+				return null;
+			}
+			return tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ThrowStatement throwStatement, object data)
+		{
+			if (throwStatement.ThrowExpression == null) {
+				return null;
+			}
+			return throwStatement.ThrowExpression.AcceptVisitor(this, data);
+		}
+		
+#region Expressions
+		public virtual object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data)
+		{
+			if (fieldReferenceOrInvocationExpression.TargetObject == null) {
+				return null;
+			}
+			return fieldReferenceOrInvocationExpression.TargetObject.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			// visit but can't give back 2 values
+			binaryOperatorExpression.Left.AcceptVisitor(this, data);
+			binaryOperatorExpression.Right.AcceptVisitor(this, data);
+			
+			return data;
+		}
+		public virtual object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			return parenthesizedExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(InvocationExpression invocationExpression, object data)
+		{
+			if (invocationExpression.TargetObject == null) {
+				return data;
+			}
+			return invocationExpression.TargetObject.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			return unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			// visit but can't give back 2 values
+			assignmentExpression.Left.AcceptVisitor(this, data);
+			assignmentExpression.Right.AcceptVisitor(this, data);
+			
+			return data;
+		}
+		
+		public virtual object Visit(CastExpression castExpression, object data)
+		{
+			return castExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			if (arrayInitializerExpression.CreateExpressions != null) {
+				foreach (INode node in arrayInitializerExpression.CreateExpressions) {
+					node.AcceptVisitor(this, data);
+				}
+			}
+			
+			return data;
+		}
+		
+		public virtual object Visit(GetTypeExpression getTypeExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(ClassReferenceExpression classReferenceExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
+		{
+			return loopControlVariableExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(AddressOfExpression addressOfExpression, object data)
+		{
+			return addressOfExpression.Procedure.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			return typeOfExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			if (arrayCreateExpression.ArrayInitializer == null) {
+				return data;
+			}
+			return arrayCreateExpression.ArrayInitializer.AcceptVisitor(this, data);
+		}
+#endregion
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,125 @@
+// AbstractNode.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Text;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public abstract class AbstractNode : INode
+	{
+		INode     parent;
+		ArrayList children = new ArrayList();
+		Hashtable specials = new Hashtable();
+		Point     startLocation;
+		Point     endLocation;
+		
+		public INode Parent {
+			get	{
+				return parent;
+			}
+			set {
+				parent = value;
+			}
+		}
+		
+		public Point StartLocation {
+			get {
+				return startLocation;
+			}
+			set {
+				startLocation = value;
+			}
+		}
+		
+		public Point EndLocation {
+			get {
+				return endLocation;
+			}
+			set {
+				endLocation = value;
+			}
+		}
+		
+		public Hashtable Specials {
+			get {
+				return specials;
+			}
+		}
+		
+		public ArrayList Children {
+			get {
+				return children;
+			}
+		}
+		
+		public virtual void AddChild(INode childNode)
+		{
+			children.Add(childNode);
+		}
+		
+		public virtual object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public object AcceptChildren(IASTVisitor visitor, object data)
+		{
+			foreach (INode child in children) {
+				if (child != null) {
+					child.AcceptVisitor(visitor, data);
+				}
+			}
+			return data;
+		}
+		
+		public static string GetCollectionString(ICollection collection)
+		{
+			if (collection == null) {
+				return &quot;null&quot;;
+			}
+			StringBuilder output = new StringBuilder();
+			output.Append('{');
+			
+			if (collection != null) {
+				IEnumerator en = collection.GetEnumerator();
+				bool isFirst = true;
+				while (en.MoveNext()) {
+					if (!isFirst) {
+						output.Append(&quot;, &quot;);
+					} else {
+						isFirst = false;
+					}
+					if (en.Current == null) {
+						output.Append(&quot;null&quot;);
+					} else {
+						output.Append(en.Current.ToString());
+					}
+				}
+			} else {
+				return &quot;null&quot;;
+			}
+			
+			output.Append('}');
+			return output.ToString();
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,81 @@
+// CompilationUnit.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class CompilationUnit : AbstractNode
+	{
+		Stack blockStack = new Stack();
+		INode lastChild = null;
+		
+		public CompilationUnit()
+		{
+			blockStack.Push(this);
+		}
+		
+		public void BlockStart(INode block)
+		{
+			blockStack.Push(block);
+		}
+		
+		public void BlockEnd()
+		{
+			lastChild = (INode)blockStack.Pop();
+		}
+		
+		public INode TakeBlock()
+		{
+			return (INode)blockStack.Pop();
+		}
+		
+		public override void AddChild(INode childNode)
+		{
+			if (childNode != null) {
+				INode parent = (INode)blockStack.Peek();
+				parent.Children.Add(childNode);
+				childNode.Parent = parent;
+				lastChild = childNode;
+			}
+		}
+		
+		ArrayList specials = new ArrayList();
+		public void AddSpecial(string key, object val)
+		{
+			specials.Add(new DictionaryEntry(key, val));
+		}
+		
+		public void CommitSpecials()
+		{
+			if (lastChild == null) {
+				return;
+			}
+			foreach (DictionaryEntry entry in specials) {
+				lastChild.Specials[entry.Key] = entry.Value;
+			}
+			specials.Clear();
+		}
+			
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,160 @@
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	/// &lt;summary&gt;
+	/// The type of a type declaration.
+	/// &lt;/summary&gt;
+	public enum Types
+	{
+		Class,
+		Interface,
+		Structure,
+		Module,
+		Enum
+	}
+	
+	///&lt;summary&gt;
+	/// Compare type, used in the &lt;c&gt;Option Compare&lt;/c&gt;
+	/// pragma.
+	///&lt;/summary&gt;
+	public enum CompareType
+	{
+		Binary,
+		Text
+	}
+	
+	///&lt;summary&gt;
+	/// Charset types, used in external mehtods
+	/// declarations.
+	///&lt;/summary&gt;
+	public enum CharsetModifier
+	{
+		None,
+		Auto,
+		Unicode,
+		ANSI
+	}
+	
+	public enum ParentType
+	{
+		ClassOrStruct,
+		InterfaceOrEnum,
+		Namespace,
+		Unknown
+	}
+	
+	public enum Members
+	{
+		Constant,
+		Field,
+		Method,
+		Property,
+		Event,
+		Constructor,
+		StaticConstructor,
+		NestedType
+	}
+	
+	///&lt;summary&gt;
+	/// Used at the exit statement.
+	///&lt;/summary&gt;
+	public enum ExitType
+	{
+		None,
+		Sub,
+		Function,
+		Property,
+		Do,
+		For,
+		While,
+		Select,
+		Try
+	}
+	
+	public enum ConditionType
+	{
+		None,
+		Until,
+		While
+	}
+	
+	public enum ConditionPosition
+	{
+		None,
+		Start,
+		End
+	}
+	
+	public enum UnaryOperatorType
+	{
+		None,
+		Not,
+		BitNot,
+		
+		Minus,
+		Plus,
+		
+		Increment,
+		Decrement,
+		
+		PostIncrement,
+		PostDecrement,
+		
+		Star,
+		BitWiseAnd
+	}
+	
+	public enum AssignmentOperatorType
+	{
+		None,
+		Assign,
+		
+		Add,
+		Subtract,
+		Multiply,
+		Divide,
+		Modulus,
+		
+		ConcatString,
+		
+		ShiftLeft,
+		ShiftRight,
+		
+		BitwiseAnd,
+		BitwiseOr,
+		ExclusiveOr,
+		Power,
+		DivideInteger
+	}
+	
+	public enum BinaryOperatorType
+	{
+		None,
+		Add,
+		Concat,
+		BitwiseAnd,
+		BitwiseOr,
+		BooleanAnd,
+		BooleanOr,
+		Divide,
+		GreaterThan,
+		GreaterThanOrEqual,
+		Equality,
+		InEquality,
+		LessThan,
+		LessThanOrEqual,
+		Modulus,
+		Multiply,
+		Subtract,
+		DivideInteger,
+		Power,
+		
+		// additional
+		ShiftLeft,
+		ShiftRight,
+		IS,
+		ExclusiveOr,
+		Like,
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,31 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class AddressOfExpression : Expression
+	{
+		Expression procedure;
+		
+		public Expression Procedure {
+			get {
+				return procedure;
+			}
+			set {
+				procedure = value;
+			}
+		}
+		
+		public AddressOfExpression(Expression Procedure)
+		{
+			this.Procedure = Procedure;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,60 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ArrayCreateExpression : Expression
+	{
+		TypeReference              createType       = null;
+		ArrayList                  parameters       = null; // Expressions
+		ArrayInitializerExpression arrayInitializer = null; // Array Initializer OR NULL
+		
+		public TypeReference CreateType {
+			get {
+				return createType;
+			}
+			set {
+				createType = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayInitializerExpression ArrayInitializer
+		{
+			get {
+				return arrayInitializer;
+			}
+			set {
+				arrayInitializer = value;
+			}
+		}
+		
+		public ArrayCreateExpression(TypeReference createType, ArrayList parameters)
+		{
+			this.createType = createType;
+			this.parameters = parameters;
+		}
+		
+		public ArrayCreateExpression(TypeReference createType, ArrayInitializerExpression arrayInitializer)
+		{
+			this.createType = createType;
+			this.arrayInitializer = arrayInitializer;
+		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,33 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ArrayInitializerExpression : Expression
+	{
+		ArrayList     createExpressions = new ArrayList();
+		
+		public ArrayList CreateExpressions {
+			get {
+				return createExpressions;
+			}
+			set {
+				createExpressions = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ArrayInitializerExpression: CreateExpressions={0}]&quot;, 
+			                     GetCollectionString(createExpressions));
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,60 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class AssignmentExpression : Expression
+	{
+		Expression left;
+		AssignmentOperatorType op;
+		Expression right;
+		
+		public Expression Left {
+			get {
+				return left;
+			}
+			set {
+				left = value;
+			}
+		}
+		
+		public AssignmentOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public Expression Right {
+			get {
+				return right;
+			}
+			set {
+				right = value;
+			}
+		}
+		
+		public AssignmentExpression(Expression left, AssignmentOperatorType op, Expression right)
+		{
+			this.left  = left;
+			this.op    = op;
+			this.right = right;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[AssignmentExpression: Op={0}, Left={1}, Right={2}]&quot;,
+			                     op,
+			                     left,
+			                     right);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,20 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class BaseReferenceExpression : Expression
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BaseReferenceExpression]&quot;);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,61 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class BinaryOperatorExpression : Expression
+	{
+		Expression left;
+		BinaryOperatorType op;
+		Expression right;
+		
+		public Expression Left {
+			get {
+				return left;
+			}
+			set {
+				left = value;
+			}
+		}
+		
+		public BinaryOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public Expression Right {
+			get {
+				return right;
+			}
+			set {
+				right = value;
+			}
+		}
+		
+		public BinaryOperatorExpression(Expression left, BinaryOperatorType op, Expression right)
+		{
+			this.left  = left;
+			this.op    = op;
+			this.right = right;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BinaryOperatorExpression: Op={0}, Left={1}, Right={2}]&quot;,
+			                     op,
+			                     left,
+			                     right);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,68 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class CastExpression : Expression
+	{
+		TypeReference castTo;
+		Expression expression;
+		bool       isSpecializedCast = false;
+		
+		
+		public TypeReference CastTo {
+			get {
+				return castTo;
+			}
+			set {
+				castTo = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public bool IsSpecializedCast {
+			get {
+				return isSpecializedCast;
+			}
+			set {
+				isSpecializedCast = value;
+			}
+		}
+		
+		
+		public CastExpression(TypeReference castTo, Expression expression)
+		{
+			this.castTo = castTo;
+			this.expression = expression;
+		}
+		
+		public CastExpression(TypeReference castTo, Expression expression, bool isSpecializedCast)
+		{
+			this.castTo = castTo;
+			this.expression = expression;
+			this.isSpecializedCast = isSpecializedCast;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[CastExpression: CastTo={0}, Expression={1}]&quot;,
+			                     castTo,
+			                     expression);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,20 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ClassReferenceExpression : Expression
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ClassReferenceExpression]&quot;);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,29 @@
+// Expression.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB 
+{
+	public class Expression : AbstractNode
+	{
+		public Expression()
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/FieldReferenceOrInvocationExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/FieldReferenceOrInvocationExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/FieldReferenceOrInvocationExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,51 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	
+	public class FieldReferenceOrInvocationExpression : Expression
+	{
+		Expression targetObject;
+		string fieldName;
+		
+		public Expression TargetObject {
+			get {
+				return targetObject;
+			}
+			set {
+				targetObject = value;
+			}
+		}
+		
+		public string FieldName {
+			get {
+				return fieldName;
+			}
+			set {
+				fieldName = value;
+			}
+		}
+		
+		public FieldReferenceOrInvocationExpression(Expression targetObject, string fieldName)
+		{
+			this.targetObject = targetObject;
+			this.fieldName = fieldName;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			if(visitor==null) return null;
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[FieldReferenceOrInvocationExpression: FieldName={0}, TargetObject={1}]&quot;,
+			                     fieldName,
+			                     targetObject);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,31 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class GetTypeExpression : Expression
+	{
+		TypeReference type;
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public GetTypeExpression(TypeReference type)
+		{
+			this.type = type;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,38 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class IdentifierExpression : Expression
+	{
+		string identifier;
+		
+		public string Identifier {
+			get {
+				return identifier;
+			}
+			set {
+				identifier = value;
+			}
+		}
+		
+		public IdentifierExpression(string identifier)
+		{
+			this.identifier = identifier;
+		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[IdentifierExpression: Identifier={0}]&quot;,
+			                     identifier);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,49 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class InvocationExpression : Expression
+	{
+		Expression  targetObject;
+		ArrayList   parameters; // Expression list
+		
+		public Expression TargetObject {
+			get {
+				return targetObject;
+			}
+			set {
+				targetObject = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public InvocationExpression(Expression targetObject, ArrayList parameters)
+		{
+			this.targetObject = targetObject;
+			this.parameters = parameters;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[InvocationExpression: TargetObject={0}, parameters={1}]&quot;,
+			                     targetObject,
+			                     GetCollectionString(parameters));
+		}
+	}
+}
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,60 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class LoopControlVariableExpression : Expression
+	{
+		Expression expression = null;
+		string name;
+		TypeReference type;
+		
+		public LoopControlVariableExpression(string name, TypeReference type)
+		{
+			this.name = name;
+			this.type = type;
+		}
+		
+		public LoopControlVariableExpression(Expression expression)
+		{
+			this.expression = expression;
+		}
+		
+		public string Name
+		{
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public TypeReference Type
+		{
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public Expression Expression
+		{
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,44 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB {
+	
+	public class NamedArgumentExpression : Expression
+	{
+		string parametername;
+		Expression     expression;
+		
+		public string Parametername {
+			get {
+				return parametername;
+			}
+			set {
+				parametername = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public NamedArgumentExpression(string parametername, Expression expression)
+		{
+			this.parametername = parametername;
+			this.expression = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ObjectCreateExpression : Expression
+	{
+		TypeReference createType;
+		ArrayList     parameters;
+		
+		public TypeReference CreateType {
+			get {
+				return createType;
+			}
+			set {
+				createType = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ObjectCreateExpression(TypeReference createType, ArrayList parameters)
+		{
+			this.createType = createType;
+			this.parameters = parameters;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ObjectCreateExpression: CreateType={0}, Parameters={1}]&quot;,
+			                     createType,
+			                     GetCollectionString(parameters));
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,90 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB {
+	
+	public class ParameterDeclarationExpression : Expression
+	{
+		TypeReference  typeReference;
+		string         parameterName;
+		ParamModifiers paramModifiers;
+		ArrayList      attributes = new ArrayList();
+		Expression	   defaultValue;
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ParameterDeclarationExpression: DefaultValue={0}, TypeReference={1}, ParameterName={2}, ParamModifiers={3}, Attributes=TODO]&quot;,
+			                     defaultValue,
+			                     typeReference,
+			                     parameterName,
+			                     paramModifiers);
+		}
+		
+		public Expression DefaultValue {
+			get {
+				return defaultValue;
+			}
+			set {
+				defaultValue = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public string ParameterName {
+			get {
+				return parameterName;
+			}
+			set {
+				parameterName = value;
+			}
+		}
+		
+		public ParamModifiers ParamModifiers {
+			get {
+				return paramModifiers;
+			}
+			set {
+				paramModifiers = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public ParameterDeclarationExpression(TypeReference typeReference, string parameterName, ParamModifiers paramModifiers, Expression defaultValue)
+		{
+			this.typeReference = typeReference;
+			this.parameterName = parameterName;
+			this.paramModifiers = paramModifiers;
+			this.attributes = attributes;
+			this.defaultValue = defaultValue;
+		}
+		
+		public ParameterDeclarationExpression(TypeReference typeReference, string parameterName, ParamModifiers paramModifiers)
+		{
+			this.typeReference  = typeReference;
+			this.parameterName  = parameterName;
+			this.paramModifiers = paramModifiers;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,37 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ParenthesizedExpression : Expression
+	{
+		Expression expression;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public ParenthesizedExpression(Expression expression)
+		{
+			this.expression  = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ParenthesizedExpression: Expression={0}]&quot;,
+			                     expression);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,51 @@
+using System;
+using System.Collections;
+using System.Globalization;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class PrimitiveExpression : Expression
+	{
+		object val;
+		string stringValue;
+		
+		public object Value {
+			get {
+				return val;
+			}
+			set {
+				val = value;
+			}
+		}
+		
+		public string StringValue {
+			get {
+				return stringValue;
+			}
+			set {
+				stringValue = value;
+			}
+		}
+		
+		public PrimitiveExpression(object val, string stringValue)
+		{
+			this.val = val;
+			this.stringValue = stringValue;
+		}
+		
+		static NumberFormatInfo nfi = new CultureInfo( &quot;en-US&quot;, false ).NumberFormat;
+
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[PrimitiveExpression: StringValue={0}]&quot;,
+			                     stringValue);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,54 @@
+// StatementExpression.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class StatementExpression : Statement
+	{
+		Expression expression;
+		
+		public Expression Expression
+		{
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public StatementExpression(Expression expression)
+		{
+			this.expression = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[StatementExpression: Expression={0}]&quot;, expression);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,21 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ThisReferenceExpression : Expression
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ThisReferenceExpression]&quot;);
+		}
+
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,43 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TypeOfExpression : Expression
+	{
+		TypeReference type;
+		
+		Expression expression;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public TypeOfExpression(Expression expression, TypeReference type)
+		{
+			this.type = type;
+			this.expression = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,41 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TypeReferenceExpression : Expression
+	{
+		TypeReference  typeReference;
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public TypeReferenceExpression(string type)
+		{
+			this.typeReference = new TypeReference(type);
+		}
+		public TypeReferenceExpression(TypeReference  typeReference)
+		{
+			this.typeReference = typeReference;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeReferenceExpression: TypeReference={0}]&quot;, 
+			                     typeReference);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class UnaryOperatorExpression : Expression
+	{
+		Expression        expression;
+		UnaryOperatorType op;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		public UnaryOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public UnaryOperatorExpression(Expression expression, UnaryOperatorType op)
+		{
+			this.expression  = expression;
+			this.op    = op;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UnaryOperatorExpression: Op={0}, Expression={1}]&quot;,
+			                     op,
+			                     expression);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,93 @@
+// AttributeDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class Attribute : AbstractNode
+	{
+		string name;
+		ArrayList positionalArguments; // [Expression]
+		ArrayList namedArguments; // [NamedArgumentExpression]
+		
+		public Attribute(string name, ArrayList positionalArguments, ArrayList namedArguments)
+		{
+			this.name = name;
+			this.positionalArguments = positionalArguments;
+			this.namedArguments = namedArguments;
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+		}
+		public ArrayList PositionalArguments {
+			get {
+				return positionalArguments;
+			}
+		}
+		public ArrayList NamedArguments {
+			get {
+				return namedArguments;
+			}
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class AttributeSection : AbstractNode
+	{
+		string    attributeTarget;
+		ArrayList attributes; // [Attribute]
+		
+		public string AttributeTarget {
+			get {
+				return attributeTarget;
+			}
+			set {
+				attributeTarget = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public AttributeSection(string attributeTarget, ArrayList attributes)
+		{
+			this.attributeTarget = attributeTarget;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,102 @@
+// DelegateDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class DelegateDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		TypeReference   returnType;
+		ArrayList       parameters; // [ParameterDeclarationExpression]
+		ArrayList       attributes;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference ReturnType {
+			get {
+				return returnType;
+			}
+			set {
+				returnType = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+//		public DelegateDeclaration(string name, Modifier modifier, TypeReference returnType, ArrayList parameters, ArrayList attributes)
+//		{
+//			this.name = name;
+//			this.modifier = modifier;
+//			this.returnType = returnType;
+//			this.parameters = parameters;
+//			this.attributes = attributes;
+//		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[DelegateDeclaration: Name={0}, Modifier={1}, ReturnType={2}, parameters={3}, attributes={4}]&quot;,
+			                     name,
+			                     modifier,
+			                     returnType,
+			                     GetCollectionString(parameters),
+			                     GetCollectionString(attributes));
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,59 @@
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ImportsAliasDeclaration : AbstractNode
+	{
+		string    alias;
+		string    nameSpace;
+		
+		public string Alias {
+			get {
+				return alias;
+			}
+			set {
+				alias = value;
+			}
+		}
+		
+		public string Namespace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public ImportsAliasDeclaration(string alias, string nameSpace)
+		{
+			this.alias     = alias;
+			this.nameSpace = nameSpace;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+// UsingDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ImportsDeclaration : AbstractNode
+	{
+		string nameSpace;
+		
+		public string Namespace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public ImportsDeclaration(string nameSpace)
+		{
+			this.nameSpace = nameSpace;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+// UsingDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ImportsStatement : AbstractNode
+	{
+		ArrayList importClauses;
+		
+		public ArrayList ImportClauses {
+			get {
+				return importClauses;
+			}
+			set {
+				importClauses = value;
+			}
+		}
+		
+		public ImportsStatement(ArrayList importClauses)
+		{
+			this.importClauses = importClauses;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,47 @@
+// NamespaceDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class NamespaceDeclaration : AbstractNode
+	{
+		string    nameSpace;
+		
+		public string NameSpace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public NamespaceDeclaration(string nameSpace)
+		{
+			this.nameSpace = nameSpace;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,57 @@
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class OptionCompareDeclaration : AbstractNode
+	{
+		CompareType compareType;
+		bool optionvalue;
+		
+		public CompareType CompareType {
+			get {
+				return compareType;
+			}
+			set {
+				compareType = value;
+			}
+		}
+		
+		public bool OptionValue {
+			get {
+				return optionvalue;
+			}
+			set {
+				optionvalue = value;
+			}
+		}
+		
+		public OptionCompareDeclaration(CompareType compareType)
+		{
+			this.compareType = compareType;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class OptionExplicitDeclaration : AbstractNode
+	{
+		bool optionvalue;
+		
+		public bool OptionValue {
+			get {
+				return optionvalue;
+			}
+			set {
+				optionvalue = value;
+			}
+		}
+		
+		public OptionExplicitDeclaration(bool optionvalue)
+		{
+			this.optionvalue = optionvalue;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class OptionStrictDeclaration : AbstractNode
+	{
+		bool optionvalue;
+		
+		public bool OptionValue {
+			get {
+				return optionvalue;
+			}
+			set {
+				optionvalue = value;
+			}
+		}
+		
+		public OptionStrictDeclaration(bool optionvalue)
+		{
+			this.optionvalue = optionvalue;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,112 @@
+// TypeDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TypeDeclaration : AbstractNode
+	{
+		// Children of Enum : [Field]
+		string name;
+		Modifier modifier;
+		Types type; // Class | Interface | Structure | Enum | Module
+		string baseType = null;
+		ArrayList attributes;
+		ArrayList baseInterfaces;
+		
+		public string BaseType {
+			get {
+				return baseType;
+			}
+			set {
+				baseType = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		public Types Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		public ArrayList BaseInterfaces  {
+			get {
+				return baseInterfaces;
+			}
+			set {
+				baseInterfaces = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+//		public TypeDeclaration(string name, Modifier modifier, Types type, StringCollection bases, ArrayList attributes)
+//		{
+//			this.name = name;
+//			this.modifier = modifier;
+//			this.type = type;
+//			this.bases = bases;
+//			this.attributes = attributes;
+//		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeDeclaration: Name={0}, Modifier={1}, Type={2}, BaseType={3}]&quot;,
+			                     name,
+			                     modifier,
+			                     type,
+			                     baseType
+//			                     ,GetCollectionString(bases)
+			                     );
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,94 @@
+using System;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public interface IASTVisitor
+	{
+		// Abstract
+		object Visit(INode node, object data);
+		object Visit(CompilationUnit compilationUnit, object data);
+		
+		// Statements
+		object Visit(Statement statement, object data);
+		object Visit(StatementExpression statementExpression, object data);
+		object Visit(LocalVariableDeclaration localVariableDeclaration, object data);
+		object Visit(SimpleIfStatement ifStatement, object data);
+		object Visit(IfStatement ifStatement, object data);
+		object Visit(LabelStatement labelStatement, object data);
+		object Visit(GoToStatement goToStatement, object data);
+		object Visit(SelectStatement selectStatement, object data);
+		object Visit(StopStatement stopStatement, object data);
+		object Visit(ResumeStatement resumeStatement, object data);
+		object Visit(EraseStatement eraseStatement, object data);
+		object Visit(ErrorStatement errorStatement, object data);
+		object Visit(OnErrorStatement onErrorStatement, object data);
+		object Visit(ReDimStatement reDimStatement, object data);
+		object Visit(AddHandlerStatement addHandlerStatement, object data);
+		object Visit(BlockStatement blockStatement, object data);
+		object Visit(DoLoopStatement doLoopStatement, object data);
+		object Visit(EndStatement endStatement, object data);
+		object Visit(ExitStatement exitStatement, object data);
+		object Visit(ForeachStatement foreachStatement, object data);
+		object Visit(ForStatement forStatement, object data);
+		object Visit(LockStatement lockStatement, object data);
+		object Visit(RaiseEventStatement raiseEventStatement, object data);
+		object Visit(RemoveHandlerStatement removeHandlerStatement, object data);
+		object Visit(ReturnStatement returnStatement, object data);
+		object Visit(ThrowStatement throwStatement, object data);
+		object Visit(TryCatchStatement tryCatchStatement, object data);
+		object Visit(WhileStatement whileStatement, object data);
+		object Visit(WithStatement withStatement, object data);
+		
+		// Declarations
+		object Visit(VariableDeclaration variableDeclaration, object data);
+		object Visit(FieldDeclaration    fieldDeclaration, object data);
+		
+		object Visit(MethodDeclaration methodDeclaration, object data);
+		object Visit(ConstructorDeclaration constructorDeclaration, object data);
+		object Visit(DeclareDeclaration declareDeclaration, object data);
+		object Visit(PropertyDeclaration propertyDeclaration, object data);
+		object Visit(PropertyGetRegion propertyGetRegion, object data);
+		object Visit(PropertySetRegion PropertySetRegion, object data);
+		object Visit(EventDeclaration eventDeclaration, object data);
+		
+		// Global scope
+		object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data);
+		object Visit(AttributeSection attributeDeclaration, object data);
+		object Visit(DelegateDeclaration delegateDeclaration, object data);
+		object Visit(ImportsDeclaration importsAliasDeclaration, object data);
+		object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data);
+		object Visit(ImportsStatement importsStatement, object data);
+		object Visit(NamespaceDeclaration namespaceDeclaration, object data);
+		object Visit(OptionCompareDeclaration optionCompareDeclaration, object data);
+		object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data);
+		object Visit(OptionStrictDeclaration optionStrictDeclaration, object data);
+		object Visit(TypeDeclaration typeDeclaration, object data);
+		object Visit(TypeReference typeReference, object data);
+		
+		// Expressions
+		object Visit(PrimitiveExpression      primitiveExpression, object data);
+		object Visit(BinaryOperatorExpression binaryOperatorExpression, object data);
+		object Visit(ParenthesizedExpression parenthesizedExpression, object data);
+		object Visit(InvocationExpression invocationExpression, object data);
+		object Visit(IdentifierExpression identifierExpression, object data);
+		object Visit(TypeReferenceExpression typeReferenceExpression, object data);
+		object Visit(UnaryOperatorExpression unaryOperatorExpression, object data);
+		object Visit(AssignmentExpression assignmentExpression, object data);
+		object Visit(CastExpression castExpression, object data);
+		object Visit(ThisReferenceExpression thisReferenceExpression, object data);
+		object Visit(BaseReferenceExpression baseReferenceExpression, object data);
+		object Visit(ObjectCreateExpression objectCreateExpression, object data);
+		object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data);
+		object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data);
+		object Visit(ArrayInitializerExpression arrayInitializerExpression, object data);
+		object Visit(GetTypeExpression getTypeExpression, object data);
+		object Visit(ClassReferenceExpression classReferenceExpression, object data);
+		object Visit(LoopControlVariableExpression loopControlVariableExpression, object data);
+		object Visit(NamedArgumentExpression namedArgumentExpression, object data);
+		object Visit(AddressOfExpression addressOfExpression, object data);
+		object Visit(TypeOfExpression typeOfExpression, object data);
+		object Visit(ArrayCreateExpression arrayCreateExpression, object data);
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,67 @@
+// INode.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public interface INode
+	{
+		INode Parent { 
+			get;
+			set;
+		}
+		
+		Hashtable Specials {
+			get;
+		}
+		
+		ArrayList Children {
+			get;
+		}
+		
+		Point StartLocation {
+			get;
+			set;
+		}
+		
+		Point EndLocation {
+			get;
+			set;
+		}
+		
+		/// &lt;summary&gt;
+		/// Visits all children
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;visitor&quot;&gt;The visitor to accept&lt;/param&gt;
+		/// &lt;param name=&quot;data&quot;&gt;Additional data for the visitor&lt;/param&gt;
+		/// &lt;returns&gt;The paremeter &lt;paramref name=&quot;data&quot;/&gt;&lt;/returns&gt;
+		object AcceptChildren(IASTVisitor visitor, object data);
+		
+		/// &lt;summary&gt;
+		/// Accept the visitor
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;visitor&quot;&gt;The visitor to accept&lt;/param&gt;
+		/// &lt;param name=&quot;data&quot;&gt;Additional data for the visitor&lt;/param&gt;
+		/// &lt;returns&gt;The value the visitor returns after the visit&lt;/returns&gt;
+		object AcceptVisitor(IASTVisitor visitor, object data);
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,98 @@
+using System;
+using System.Drawing;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class LocalLookupVariable
+	{
+		TypeReference typeRef;
+		Point         startPos;
+		Point         endPos;
+		
+		public TypeReference TypeRef {
+			get {
+				return typeRef;
+			}
+		}
+		public Point StartPos {
+			get {
+				return startPos;
+			}
+		}
+		public Point EndPos {
+			get {
+				return endPos;
+			}
+		}
+		
+		public LocalLookupVariable(TypeReference typeRef, Point startPos, Point endPos)
+		{
+			this.typeRef = typeRef;
+			this.startPos = startPos;
+			this.endPos = endPos;
+		}
+	}
+	
+	public class LookupTableVisitor : AbstractASTVisitor
+	{
+		Hashtable variables      = new Hashtable();
+		ArrayList withStatements = new ArrayList();
+		
+		public Hashtable Variables {
+			get {
+				return variables;
+			}
+		}
+		
+		public ArrayList WithStatements {
+			get {
+				return withStatements;
+			}
+		}
+		
+		public void AddVariable(TypeReference typeRef, string name, Point startPos, Point endPos)
+		{
+			if (name == null || name.Length == 0) {
+				return;
+			}
+			name = name.ToLower();
+			ArrayList list;
+			if (variables[name] == null) {
+				variables[name] = list = new ArrayList();
+			} else {
+				list = (ArrayList)variables[name];
+			}
+			list.Add(new LocalLookupVariable(typeRef, startPos, endPos));
+		}
+		
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			foreach (VariableDeclaration varDecl in localVariableDeclaration.Variables) {
+				AddVariable(varDecl.Type, 
+				            varDecl.Name,
+				            localVariableDeclaration.StartLocation,
+				            CurrentBlock == null ? new Point(-1, -1) : CurrentBlock.EndLocation);
+			}
+			return data;
+		}
+		
+		public override object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
+		{
+			AddVariable(loopControlVariableExpression.Type, 
+			            loopControlVariableExpression.Name,
+			            loopControlVariableExpression.StartLocation,
+			            CurrentBlock == null ? new Point(-1, -1) : CurrentBlock.EndLocation);
+			return data;
+		}
+		
+		public override object Visit(WithStatement withStatement, object data)
+		{
+			withStatements.Add(withStatement);
+			return base.Visit(withStatement, data);
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,74 @@
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+
+	[Flags()]
+	public enum ParamModifier
+	{
+		None						= 0x0000,	// 0
+		ByVal						= 0x0001,	// 1
+		ByRef						= 0x0002,	// 2
+		ParamArray					= 0x0004,	// 4
+		Optional					= 0x0008,	// 8
+		All							= ByVal | ByRef | ParamArray | Optional
+	}
+
+	[Flags()]
+	public enum Modifier
+	{
+		None						= 0x0000,	// 0
+		
+		// Access
+		Private						= 0x0001,	// 1
+		Friend						= 0x0002,	// 2
+		Protected					= 0x0004,	// 4
+		Public						= 0x0008,	// 8
+		Dim							= 0x0010,	// 16
+		
+		// Scope
+		Shadows						= 0x000020,	// 32
+		Overloads					= 0x000040,	// 64
+		Overrides					= 0x000080,	// 128
+		NotOverridable				= 0x000100,	// 256
+		MustOverride				= 0x000200,	// 512
+		MustInherit					= 0x000400,	// 1024
+		NotInheritable				= 0x000800,	// 2048
+		Shared						= 0x001000,	// 4096
+		Overridable					= 0x002000,	// 8192
+		Constant					= 0x004000,
+		// Methods and properties
+		WithEvents					= 0x008000,
+		ReadOnly					= 0x010000,
+		WriteOnly					= 0x020000,
+		Default						= 0x040000,
+		
+		// local variables
+		Static						= 0x100000,
+		
+		All							= Private | Public | Protected  | Friend | Shadows | Constant |
+									  Overloads | Overrides | NotOverridable | MustOverride |
+									  MustInherit | NotInheritable | Shared | Overridable |
+									  WithEvents | ReadOnly | WriteOnly | Default | Dim,
+		
+		Classes						= Private | Public | Protected | Friend | Shadows | MustInherit | NotInheritable,
+		Structures					= Private | Public | Protected | Friend | Shadows,
+		Enums						= Private | Public | Protected | Friend | Shadows,
+		Modules						= Private | Public | Protected | Friend,
+		Interfaces					= Private | Public | Protected | Friend | Shadows,
+		Delegates					= Private | Public | Protected | Friend | Shadows,
+		Methods						= Private | Public | Protected | Friend | Shadows | Shared | Overridable | NotOverridable | MustOverride | Overrides | Overloads,
+		ExternalMethods				= Private | Public | Protected | Friend | Shadows | Overloads,
+		Constructors				= Private | Public | Protected | Friend | Shared,
+		Events						= Private | Public | Protected | Friend | Shadows | Shared,
+		Constants					= Private | Public | Protected | Friend | Shadows,
+		Fields						= Private | Public | Protected | Friend | Shadows | Shared | ReadOnly | WithEvents | Dim ,
+		Properties					= Private | Public | Protected | Friend | Shadows | Shared | Overridable | NotOverridable | MustOverride | Overrides | Overloads | Default | ReadOnly | WriteOnly,
+		
+		// this is not documented in the spec
+		InterfaceEvents				= Shadows,
+		InterfaceMethods			= Shadows | Overloads,
+		InterfaceProperties			= Shadows | Overloads | ReadOnly | WriteOnly | Default,
+		InterfaceEnums				= Shadows,
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,41 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class AddHandlerStatement : Statement
+	{
+		Expression eventExpression;
+		Expression handlerExpression;
+		
+		public Expression EventExpression {
+			get {
+				return eventExpression;
+			}
+			set {
+				eventExpression = value;
+			}
+		}
+		public Expression HandlerExpression {
+			get {
+				return handlerExpression;
+			}
+			set {
+				handlerExpression = value;
+			}
+		}
+		
+		public AddHandlerStatement(Expression eventExpression, Expression handlerExpression)
+		{
+			this.eventExpression = eventExpression;
+			this.handlerExpression = handlerExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,21 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class BlockStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BlockStatement: Children={0}]&quot;, 
+			                     GetCollectionString(base.Children));
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,64 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class DoLoopStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		ConditionType conditionType;
+		ConditionPosition conditionPosition;
+		
+		public ConditionPosition ConditionPosition {
+			get {
+				return conditionPosition;
+			}
+			set {
+				conditionPosition = value;
+			}
+		}
+		
+		public ConditionType ConditionType {
+			get {
+				return conditionType;
+			}
+			set {
+				conditionType = value;
+			}
+		}
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public DoLoopStatement(Expression condition, Statement embeddedStatement, ConditionType conditionType, ConditionPosition conditionPosition)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+			this.conditionType = conditionType;
+			this.conditionPosition = conditionPosition;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,20 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class EndStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[EndStatement]&quot;);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,31 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class EraseStatement : Statement
+	{
+		ArrayList expressions;
+		
+		public ArrayList Expressions
+		{
+			get {
+				return expressions;
+			} set {
+				expressions = value;
+			}
+		}
+		
+		public EraseStatement(ArrayList expressions)
+		{
+			this.expressions = expressions;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,31 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ErrorStatement : Statement
+	{
+		Expression expression;
+		
+		public ErrorStatement(Expression expression)
+		{
+			this.expression = expression;
+		}
+		
+		public Expression Expression
+		{
+			get {
+				return expression;
+			}set {
+				expression = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,36 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ExitStatement : Statement
+	{
+		ExitType exitType;
+		
+		public ExitType ExitType {
+			get {
+				return exitType;
+			}
+			set {
+				exitType = value;
+			}
+		}
+		
+		public ExitStatement(ExitType exitType)
+		{
+			this.exitType = exitType;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ExitStatement]&quot;);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,92 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ForStatement : Statement
+	{
+		Expression start;
+		Expression end;
+		Expression step;
+		Statement embeddedStatement;
+		ArrayList nextExpressions;
+		LoopControlVariableExpression loopControlVariable;
+		
+		public LoopControlVariableExpression LoopControlVariable
+		{
+			get {
+				return loopControlVariable;
+			}
+			set {
+				loopControlVariable = value;
+			}
+		}
+		
+		public ArrayList NextExpressions
+		{
+			get {
+				return nextExpressions;
+			}
+			set {
+				nextExpressions = value;
+			}
+		}
+		
+		public Expression Start
+		{
+			get {
+				return start;
+			}
+			set {
+				start = value;
+			}
+		}
+		
+		public Expression End
+		{
+			get {
+				return end;
+			}
+			set {
+				end = value;
+			}
+		}
+		
+		public Expression Step
+		{
+			get {
+				return step;
+			}
+			set {
+				step = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public ForStatement(LoopControlVariableExpression loopControlVariable, Expression start, Expression end, Expression step, Statement embeddedStatement, ArrayList nextExpressions)
+		{
+			this.start = start;
+			this.nextExpressions = nextExpressions;
+			this.end = end;
+			this.step = step;
+			this.embeddedStatement = embeddedStatement;
+			this.loopControlVariable = loopControlVariable;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,64 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ForeachStatement : Statement
+	{
+		LoopControlVariableExpression loopControlVariable;
+		Expression    expression;
+		Statement     embeddedStatement;
+		Expression    element;
+		
+		public LoopControlVariableExpression LoopControlVariable
+		{
+			get {
+				return loopControlVariable;
+			}
+			set {
+				loopControlVariable = value;
+			}
+		}
+		
+		public Expression Element {
+			get {
+				return element;
+			}
+			set {
+				element = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public ForeachStatement(LoopControlVariableExpression loopControlVariable , Expression expression, Statement embeddedStatement, Expression element)
+		{
+			this.loopControlVariable = loopControlVariable;
+			this.expression        = expression;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,32 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class GoToStatement : Statement
+	{
+		string labelName;
+		
+		public string LabelName
+		{
+			get {
+				return labelName;
+			}
+			set {
+				labelName = value;
+			}
+		}
+		
+		public GoToStatement(string labelName)
+		{
+			this.labelName = labelName;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,147 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB 
+{
+	public class IfStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedElseStatement;
+		Statement  embeddedStatement;
+		ArrayList elseIfStatements;
+		
+		public ArrayList ElseIfStatements
+		{
+			get {
+				return elseIfStatements;
+			}
+			set {
+				elseIfStatements = value;
+			}
+		}
+		
+		public Statement EmbeddedElseStatement
+		{
+			get {
+				return embeddedElseStatement;
+			}
+			set {
+				embeddedElseStatement = value;
+			}
+		}
+		
+		public Expression Condition
+		{
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public IfStatement(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class ElseIfSection : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		
+		public Expression Condition
+		{
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public ElseIfSection(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class SimpleIfStatement : Statement
+	{
+		Expression condition;
+		ArrayList statements;
+		ArrayList elseStatements;
+		
+		public ArrayList ElseStatements
+		{
+			get {
+				return elseStatements;
+			}
+			set {
+				elseStatements = value;
+			}
+		}
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		public ArrayList Statements {
+			get {
+				return statements;
+			}
+			set {
+				statements = value;
+			}
+		}
+		
+		public SimpleIfStatement(Expression condition)
+		{
+			this.condition = condition;
+		}
+	
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class LabelStatement : Statement
+	{
+		string label;
+		Statement embeddedStatement;
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public string Label {
+			get {
+				return label;
+			}
+			set {
+				label = value;
+			}
+		}
+		
+		public LabelStatement(string label)
+		{
+			this.label = label;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LabelStatement: Label={0}]&quot;,
+			                     label);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,67 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class LocalVariableDeclaration : Statement
+	{
+		Modifier      modifier = Modifier.None;
+		ArrayList     variables = new ArrayList(); // [VariableDeclaration]
+		INode block;
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Variables {
+			get {
+				return variables;
+			} set {
+				variables = value;
+			}
+		}
+		
+		public INode Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public LocalVariableDeclaration(Modifier modifier)
+		{
+			this.modifier = modifier;
+		}
+		
+		public VariableDeclaration GetVariableDeclaration(string variableName)
+		{
+			foreach (VariableDeclaration variableDeclaration in variables) {
+				if (variableDeclaration.Name == variableName) {
+					return variableDeclaration;
+				}
+			}
+			return null;
+		}
+				
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LocalVariableDeclaration: Modifier ={0} Variables={1}]&quot;, 
+			                     modifier, 
+			                     GetCollectionString(variables));
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,46 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class LockStatement : Statement
+	{
+		Expression lockExpression;
+		Statement  embeddedStatement;
+		
+		public Expression LockExpression {
+			get {
+				return lockExpression;
+			}
+			set {
+				lockExpression = value;
+			}
+		}
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		public LockStatement(Expression lockExpression, Statement embeddedStatement)
+		{
+			this.lockExpression = lockExpression;
+			this.embeddedStatement = embeddedStatement;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LockStatement: LockExpression={0}, EmbeddedStatement={1}]&quot;, 
+			                     lockExpression,
+			                     embeddedStatement);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,32 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class OnErrorStatement : Statement
+	{
+		Statement embeddedStatement;
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public OnErrorStatement(Statement embeddedStatement)
+		{
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,47 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class RaiseEventStatement : Statement
+	{
+		string eventName;
+		ArrayList parameters;
+		
+		public string EventName {
+			get {
+				return eventName;
+			}
+			set {
+				eventName = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public RaiseEventStatement(string eventName, ArrayList parameters)
+		{
+			this.eventName = eventName;
+			this.parameters = parameters;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return  String.Format(&quot;[RaiseEventStatement: EventName={0}]&quot;, 
+			                     EventName);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,31 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ReDimStatement : Statement
+	{
+		ArrayList reDimClauses;
+		
+		public ArrayList ReDimClauses
+		{
+			get {
+				return reDimClauses;
+			} set {
+				reDimClauses = value;
+			}
+		}
+		
+		public ReDimStatement(ArrayList reDimClauses)
+		{
+			this.reDimClauses = reDimClauses;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,41 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class RemoveHandlerStatement : Statement
+	{
+		Expression eventExpression;
+		Expression handlerExpression;
+		
+		public Expression EventExpression {
+			get {
+				return eventExpression;
+			}
+			set {
+				eventExpression = value;
+			}
+		}
+		public Expression HandlerExpression {
+			get {
+				return handlerExpression;
+			}
+			set {
+				handlerExpression = value;
+			}
+		}
+		
+		public RemoveHandlerStatement(Expression eventExpression, Expression handlerExpression)
+		{
+			this.eventExpression = eventExpression;
+			this.handlerExpression = handlerExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ResumeStatement : Statement
+	{
+		string labelName;
+		bool next;
+		
+		public string LabelName
+		{
+			get {
+				return labelName;
+			}
+			set {
+				labelName = value;
+			}
+		}
+		
+		public bool Next
+		{
+			get {
+				return next;
+			}
+			set {
+				next = value;
+			}
+		}
+		
+		public ResumeStatement(bool next)
+		{
+			this.next = next;
+		}
+		
+		public ResumeStatement(string labelName)
+		{
+			this.labelName = labelName;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,37 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ReturnStatement : Statement
+	{
+		Expression returnExpression;
+		
+		public Expression ReturnExpression {
+			get {
+				return returnExpression;
+			}
+			set {
+				returnExpression = value;
+			}
+		}
+		
+		public ReturnStatement(Expression returnExpression)
+		{
+			this.returnExpression = returnExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ReturnStatement: ReturnExpression={0}]&quot;, 
+			                     returnExpression);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,144 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class SelectStatement : Statement
+	{
+		Expression selectExpression;
+		ArrayList  selectSections  = new ArrayList();
+		
+		public Expression SelectExpression {
+			get {
+				return selectExpression;
+			}
+			set {
+				selectExpression = value;
+			}
+		}
+		
+		public ArrayList SelectSections
+		{
+			get {
+				return selectSections;
+			}
+			set {
+				selectSections = value;
+			}
+		}
+		
+		public SelectStatement(Expression selectExpression, ArrayList selectSections)
+		{
+			this.selectExpression = selectExpression;
+			this.selectSections = selectSections;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class SelectSection : Statement
+	{
+		ArrayList caseClauses = new ArrayList();
+		Statement embeddedStatement;
+		
+		public ArrayList CaseClauses
+		{
+			get {
+				return caseClauses;
+			}
+			set {
+				caseClauses = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class CaseClause : AbstractNode
+	{
+		BinaryOperatorType comparisonOperator = BinaryOperatorType.None;
+		Expression comparisonExpression;
+		Expression boundaryExpression;
+		bool isDefaultCase = false;
+		
+		public bool IsDefaultCase
+		{
+			get {
+				return isDefaultCase;
+			}
+			set {
+				isDefaultCase = value;
+			}
+		}
+		
+		public BinaryOperatorType ComparisonOperator
+		{
+			get {
+				return comparisonOperator;
+			}
+			set {
+				comparisonOperator = value;
+			}
+		}
+		
+		public Expression ComparisonExpression
+		{
+			get {
+				return comparisonExpression;
+			}
+			set {
+				comparisonExpression = value;
+			}
+		}
+		
+		public Expression BoundaryExpression
+		{
+			get {
+				return boundaryExpression;
+			}
+			set {
+				boundaryExpression = value;
+			}
+		}
+		
+		public CaseClause(bool isDefaultCase)
+		{
+			this.isDefaultCase = isDefaultCase;
+		}
+		
+		public CaseClause(Expression comparisonExpression, Expression boundaryExpression)
+		{
+			this.boundaryExpression = boundaryExpression;
+			this.comparisonExpression = comparisonExpression;
+		}
+		
+		public CaseClause(BinaryOperatorType comparisonOperator, Expression comparisonExpression)
+		{
+			this.comparisonOperator = comparisonOperator;
+			this.comparisonExpression = comparisonExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,28 @@
+// Statement.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class Statement : AbstractNode
+	{
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,20 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class StopStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[StopStatement]&quot;);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,37 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ThrowStatement : Statement
+	{
+		Expression throwExpression;
+		
+		public Expression ThrowExpression {
+			get {
+				return throwExpression;
+			}
+			set {
+				throwExpression = value;
+			}
+		}
+		
+		public ThrowStatement(Expression throwExpression)
+		{
+			this.throwExpression = throwExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ThrowStatement: ThrowExpression={0}]&quot;, 
+			                     throwExpression);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,135 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TryCatchStatement : Statement
+	{
+		Statement statementBlock;
+		ArrayList catchClauses;
+		Statement finallyBlock;
+		
+		public Statement StatementBlock {
+			get {
+				return statementBlock;
+			}
+			set {
+				statementBlock = value;
+			}
+		}
+		
+		public ArrayList CatchClauses {
+			get {
+				return catchClauses;
+			}
+			set {
+				catchClauses = value;
+			}
+		}
+		
+		public Statement FinallyBlock {
+			get {
+				return finallyBlock;
+			}
+			set {
+				finallyBlock = value;
+			}
+		}
+		
+		public TryCatchStatement(Statement statementBlock, ArrayList catchClauses, Statement finallyBlock)
+		{
+			this.statementBlock = statementBlock;
+			this.catchClauses = catchClauses;
+			this.finallyBlock = finallyBlock;
+		}
+		
+		public TryCatchStatement(Statement statementBlock, ArrayList catchClauses)
+		{
+			this.statementBlock = statementBlock;
+			this.catchClauses = catchClauses;
+			this.finallyBlock = null;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TryCatchStatement: StatementBlock={0}, CatchClauses={1}, FinallyBlock={2}]&quot;,
+			                     statementBlock,
+			                     GetCollectionString(catchClauses),
+			                     finallyBlock);
+		}
+	}
+	
+	public class CatchClause
+	{
+		TypeReference type;
+		string variableName;
+		Statement       statementBlock;
+		Expression condition;
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public string VariableName {
+			get {
+				return variableName;
+			}
+			set {
+				variableName = value;
+			}
+		}
+		
+		public Statement StatementBlock {
+			get {
+				return statementBlock;
+			}
+			set {
+				statementBlock = value;
+			}
+		}
+		
+		public CatchClause(TypeReference type, string variableName, Statement statementBlock, Expression condition)
+		{
+			this.type = type;
+			this.variableName = variableName;
+			this.statementBlock = statementBlock;
+			this.condition = condition;
+		}
+		
+		public CatchClause(Statement statementBlock)
+		{
+			this.type         = null;
+			this.variableName = null;
+			this.statementBlock = statementBlock;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[CatchClause: Type={0}, VariableName={1}, StatementBlock={2}]&quot;, 
+			                     type,
+			                     variableName,
+			                     statementBlock);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,49 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class WhileStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public WhileStatement(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[WhileStatement: Condition={0}, EmbeddedStatement={1}]&quot;, 
+			                     condition,
+			                     embeddedStatement);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,44 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class WithStatement : Statement
+	{
+		Expression withExpression;
+		BlockStatement body = null;
+		
+		public Expression WithExpression {
+			get {
+				return withExpression;
+			}
+		}
+		
+		public BlockStatement Body {
+			get {
+				return body;
+			}
+			set {
+				body = value;
+			}
+		}
+		
+		public WithStatement(Expression withExpression)
+		{
+			this.withExpression = withExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		public override string ToString()
+		{
+			return String.Format(&quot;[WithStatment: WidthExpression={0}, Body={1}]&quot;, 
+			                     withExpression,
+			                     body);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,92 @@
+// ConstructorDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ConstructorDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		ArrayList       parameters = new ArrayList(); // [ParameterDeclarationExpression]
+		ArrayList       attributes = new ArrayList();
+		BlockStatement  blockStatement = null;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public BlockStatement Body {
+			get {
+				return blockStatement;
+			}
+			set {
+				blockStatement = value;
+			}
+		}
+		
+		public ConstructorDeclaration(string name, Modifier modifier, ArrayList parameters, ArrayList attributes)
+		{
+			this.name     = name;
+			this.modifier = modifier;
+			this.parameters = parameters;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,127 @@
+// DeclareDeclaration.cs
+// Copyright (C) 2003 Markus Palme (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">markuspalme at gmx.de</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class DeclareDeclaration : AbstractNode
+	{
+		string          name;
+		string          alias;
+		string          library;
+		CharsetModifier charset = CharsetModifier.None;
+		Modifier modifier;
+		TypeReference   returnType;
+		ArrayList       parameters;
+		ArrayList       attributes;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference ReturnType {
+			get {
+				return returnType;
+			}
+			set {
+				returnType = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public CharsetModifier Charset
+		{
+			get {
+				return charset;
+			}
+			set {
+				charset = value;
+			}
+		}
+		
+		public string Alias
+		{
+			get {
+				return alias;
+			}
+			set {
+				alias = value;
+			}
+		}
+		
+		public string Library
+		{
+			get {
+				return library;
+			}
+			set {
+				library = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public DeclareDeclaration(string name, Modifier modifier, TypeReference returnType, ArrayList parameters, ArrayList attributes, string library, string alias, CharsetModifier charset)
+		{
+			this.name = name;
+			this.modifier = modifier;
+			this.returnType = returnType;
+			this.parameters = parameters;
+			this.attributes = attributes;
+			this.library = library;
+			this.alias = alias;
+			this.charset = charset;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,117 @@
+// EventDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class EventDeclaration : AbstractNode
+	{
+		TypeReference typeReference;
+		Modifier modifier;
+		ArrayList parameters;
+		ArrayList attributes;
+		string name;
+		ImplementsClause implementsClause;
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		public ImplementsClause ImplementsClause {
+			get {
+				return implementsClause;
+			}
+			set {
+				implementsClause = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		
+		
+		public EventDeclaration(TypeReference typeReference, Modifier modifier, ArrayList parameters, ArrayList attributes, string name, ImplementsClause implementsClause)
+		{
+			this.typeReference = typeReference;
+			this.modifier = modifier;
+			this.parameters = parameters;
+			this.attributes = attributes;
+			this.name = name;
+			this.implementsClause = implementsClause;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[EventDeclaration: typeReference = {0}, modifier = {1}, parameters = {2}, attributes = {3}, name = {4}, implementsClause = {5}]&quot;,
+			                     typeReference,
+			                     modifier,
+			                     parameters,
+			                     attributes,
+			                     name,
+			                     implementsClause);
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,104 @@
+// FieldDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class FieldDeclaration : AbstractNode
+	{
+		ArrayList       attributes = null;
+		TypeReference   typeReference = null;
+		Modifier        modifier;
+		ArrayList       fields = new ArrayList(); // [VariableDeclaration]
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		public ArrayList Fields {
+			get {
+				return fields;
+			}
+			set {
+				fields = value;
+			}
+		}
+		
+		// for enum members
+		public FieldDeclaration(ArrayList attributes)
+		{
+			this.attributes = attributes;
+		}
+		
+		// for all other cases
+		public FieldDeclaration(ArrayList attributes, TypeReference typeReference, Modifier modifier)
+		{
+			this.attributes    = attributes;
+			this.typeReference = typeReference;
+			this.modifier      = modifier;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public VariableDeclaration GetVariableDeclaration(string variableName)
+		{
+			foreach (VariableDeclaration variableDeclaration in Fields) {
+				if (variableDeclaration.Name == variableName) {
+					return variableDeclaration;
+				}
+			}
+			return null;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[FieldDeclaration: attributes = {0}, typeReference = {1}, modifier = {2}, fields = {3}]&quot;,
+			                     attributes,
+			                     typeReference,
+			                     modifier,
+			                     GetCollectionString(fields));		
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,27 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class HandlesClause : AbstractNode
+	{
+		ArrayList eventNames;
+		
+		public HandlesClause()
+		{
+			this.eventNames = new ArrayList();
+		}
+		
+		public ArrayList EventNames {
+			get {
+				return eventNames;
+			}
+			set {
+				eventNames = value;
+			}
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,27 @@
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ImplementsClause : AbstractNode
+	{
+		ArrayList baseMembers;
+		
+		public ImplementsClause()
+		{
+			this.baseMembers = new ArrayList();
+		}
+		
+		public ArrayList BaseMembers
+		{
+			get {
+				return baseMembers;
+			}
+			set {
+				baseMembers = value;
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,127 @@
+// MethodDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class MethodDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		TypeReference   typeReference;
+		ArrayList       parameters; // [ParameterDeclarationExpression]
+		ArrayList       attributes;
+		BlockStatement  body;
+		HandlesClause   handlesClause;
+		ImplementsClause implementsClause;
+		
+		public ImplementsClause ImplementsClause {
+			get {
+				return implementsClause;
+			}
+			set {
+				implementsClause = value;
+			}
+		}
+		
+		public HandlesClause HandlesClause {
+			get {
+				return handlesClause;
+			}
+			set {
+				handlesClause = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public BlockStatement Body {
+			get {
+				return body;
+			}
+			set {
+				body = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public MethodDeclaration(string name, Modifier modifier, TypeReference typeReference, ArrayList parameters, ArrayList attributes)
+		{
+			this.name = name;
+			this.modifier = modifier;
+			this.typeReference = typeReference;
+			this.parameters = parameters;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[MethodDeclaration: Name={0}, Modifier={1}, TypeReference={2}]&quot;, name, modifier, typeReference);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,167 @@
+// PropertyDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class PropertyDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier        modifier;
+		TypeReference   typeReference;
+		ArrayList       attributes;
+		ArrayList       parameters;
+		Point           bodyStart;
+		Point           bodyEnd;
+		ImplementsClause implementsClause;
+		
+		PropertyGetRegion  propertyGetRegion = null;
+		PropertySetRegion  propertySetRegion = null;
+		
+		public ImplementsClause ImplementsClause {
+			get {
+				return implementsClause;
+			}
+			set {
+				implementsClause = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public PropertyGetRegion GetRegion {
+			get {
+				return propertyGetRegion;
+			}
+			set {
+				propertyGetRegion = value;
+			}
+		}
+		public PropertySetRegion SetRegion {
+			get {
+				return propertySetRegion;
+			}
+			set {
+				propertySetRegion = value;
+			}
+		}
+		
+		public bool HasGetRegion {
+			get {
+				return propertyGetRegion != null;
+			}
+		}
+		
+		public bool HasSetRegion {
+			get {
+				return propertySetRegion != null;
+			}
+		}
+		
+		public bool IsReadOnly {
+			get {
+				return HasGetRegion &amp;&amp; !HasSetRegion;
+			}
+		}
+		
+		public bool IsWriteOnly {
+			get {
+				return !HasGetRegion &amp;&amp; HasSetRegion;
+			}
+		}
+		
+		
+		public Point BodyStart {
+			get {
+				return bodyStart;
+			}
+			set {
+				bodyStart = value;
+			}
+		}
+		
+		public Point BodyEnd {
+			get {
+				return bodyEnd;
+			}
+			set {
+				bodyEnd = value;
+			}
+		}
+		
+		public PropertyDeclaration(string name, TypeReference typeReference, Modifier modifier, ArrayList attributes)
+		{
+			this.name = name;
+			this.typeReference = typeReference;
+			this.modifier = modifier;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,58 @@
+// PropertyGetRegion.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class PropertyGetRegion : AbstractNode
+	{
+		BlockStatement block;
+		ArrayList      attributes;
+		
+		public BlockStatement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public PropertyGetRegion(BlockStatement block, ArrayList attributes)
+		{
+			this.block = block;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,69 @@
+// PropertySetRegion.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class PropertySetRegion : AbstractNode
+	{
+		BlockStatement block;
+		ArrayList      attributes;
+		ArrayList       parameters;
+		
+		public BlockStatement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+			
+		public PropertySetRegion(BlockStatement block, ArrayList attributes)
+		{
+			this.block = block;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,139 @@
+// TypeReference.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TypeReference : AbstractNode
+	{
+		string type;
+		string systemType;
+		ArrayList rankSpecifier;
+		ArrayList dimension;
+		AttributeSection attributes = null;
+		
+		static Hashtable types = new Hashtable();
+		static TypeReference()
+		{
+			types.Add(&quot;boolean&quot;, &quot;System.Boolean&quot;);
+			types.Add(&quot;byte&quot;,    &quot;System.Byte&quot;);
+			types.Add(&quot;date&quot;,	 &quot;System.DateTime&quot;);
+			types.Add(&quot;char&quot;,    &quot;System.Char&quot;);
+			types.Add(&quot;decimal&quot;, &quot;System.Decimal&quot;);
+			types.Add(&quot;double&quot;,  &quot;System.Double&quot;);
+			types.Add(&quot;single&quot;,  &quot;System.Single&quot;);
+			types.Add(&quot;integer&quot;, &quot;System.Int32&quot;);
+			types.Add(&quot;long&quot;,    &quot;System.Int64&quot;);
+			types.Add(&quot;object&quot;,  &quot;System.Object&quot;);
+			types.Add(&quot;short&quot;,   &quot;System.Int16&quot;);
+			types.Add(&quot;string&quot;,  &quot;System.String&quot;);
+		}
+		
+		public AttributeSection Attributes
+		{
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public static ICollection PrimitiveTypes
+		{
+			get {
+				return types.Keys;
+			}
+		}
+		
+		public string Type
+		{
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public string SystemType
+		{
+			get {
+				return systemType;
+			}
+		}
+		
+		public ArrayList RankSpecifier
+		{
+			get {
+				return rankSpecifier;
+			}
+			set {
+				rankSpecifier = value;
+			}
+		}
+		
+		public bool IsArrayType
+		{
+			get {
+				return rankSpecifier != null &amp;&amp; rankSpecifier.Count&gt; 0;
+			}
+		}
+		
+		public ArrayList Dimension
+		{
+			get {
+				return dimension;
+			}
+			set {
+				dimension = value;
+			}
+		}
+		
+		string GetSystemType(string type)
+		{
+			return (string)types[type.ToLower()];
+		}
+		
+		public TypeReference(string type)
+		{
+			this.systemType = GetSystemType(type);
+			this.type = type;
+		}
+		
+		public TypeReference(string type, ArrayList rankSpecifier)
+		{
+			this.type = type;
+			this.systemType = GetSystemType(type);
+			this.rankSpecifier = rankSpecifier;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeReference: Type={0}, RankSpeifier={1}]&quot;, type, AbstractNode.GetCollectionString(rankSpecifier));
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,79 @@
+// Field.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class VariableDeclaration : AbstractNode
+	{
+		string     name;
+		Expression initializer = null;
+		TypeReference type;
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Expression Initializer {
+			get {
+				return initializer;
+			}
+			set {
+				initializer = value;
+			}
+		}
+		
+		public VariableDeclaration(string name)
+		{
+			this.name = name;
+		}
+		
+		public VariableDeclaration(string name, Expression initializer)
+		{
+			this.name = name;
+			this.initializer = initializer;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[VariableDeclaration: Name={0}, Initializer={1}]&quot;, name, initializer);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,48 @@
+using System;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public delegate void ErrorCodeProc(int line, int col, int n);
+	public delegate void ErrorMsgProc(int line, int col, string msg);
+	
+	public class Errors
+	{
+		public int count = 0;                                               // number of errors detected
+		public ErrorCodeProc SynErr;
+		public ErrorCodeProc SemErr;
+		public ErrorMsgProc  Error;
+		StringBuilder errorText = new StringBuilder();
+		
+		public string ErrorOutput {
+			get {
+				return errorText.ToString();
+			}
+		}
+		public Errors()
+		{
+			SynErr = new ErrorCodeProc(DefaultCodeError);  // syntactic errors
+			SemErr = new ErrorCodeProc(DefaultCodeError);  // semantic errors
+			Error  = new ErrorMsgProc(DefaultMsgError);    // user defined string based errors
+		}
+		
+	//	public void Exception (string s)
+	//	{
+	//		Console.WriteLine(s); 
+	//		System.Environment.Exit(0);
+	//	}
+	
+		void DefaultCodeError (int line, int col, int n)
+		{
+			errorText.Append(String.Format(&quot;-- line {0} col {1}: error {2}&quot;, line, col, n));
+			errorText.Append(&quot;\n&quot;);
+			count++;
+		}
+	
+		void DefaultMsgError (int line, int col, string s) {
+			errorText.Append(String.Format(&quot;-- line {0} col {1}: {2}&quot;, line, col, s));
+			errorText.Append(&quot;\n&quot;);
+			count++;
+		}
+	} // Errors
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,51 @@
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class Modifiers
+	{
+		Modifier cur;
+		Parser   parser;
+		
+		public Modifier Modifier {
+			get {
+				return cur;
+			}
+		}
+		
+		public Modifiers(Parser parser)
+		{
+			this.parser = parser;
+			cur         = Modifier.None;
+		}
+		
+		public bool isNone { get { return cur == Modifier.None; } }
+		
+		public bool Contains(Modifier m)
+		{
+			return ((cur &amp; m) != 0);
+		}
+		
+		public void Add(Modifier m) 
+		{
+			if ((cur &amp; m) == 0) {
+				cur |= m;
+			} else {
+				parser.Error(&quot;modifier &quot; + m + &quot; already defined&quot;);
+			}
+		}
+		
+		public void Add(Modifiers m)
+		{
+			Add(m.cur);
+		}
+		
+		public void Check(Modifier allowed)
+		{
+			Modifier wrong = cur &amp; (allowed ^ Modifier.All);
+			if (wrong != Modifier.None) {
+				parser.Error(&quot;modifier(s) &quot; + wrong + &quot; not allowed here&quot;);
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,46 @@
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class ParamModifiers
+	{
+		ParamModifier cur;
+		Parser   parser;
+		
+		public ParamModifier Modifier {
+			get {
+				return cur;
+			}
+		}
+		
+		public ParamModifiers(Parser parser)
+		{
+			this.parser = parser;
+			cur         = ParamModifier.None;
+		}
+		
+		public bool isNone { get { return cur == ParamModifier.None; } }
+		
+		public void Add(ParamModifier m) 
+		{
+			if ((cur &amp; m) == 0) {
+				cur |= m;
+			} else {
+				parser.Error(&quot;param modifier &quot; + m + &quot; already defined&quot;);
+			}
+		}
+		
+		public void Add(ParamModifiers m)
+		{
+			Add(m.cur);
+		}
+		
+		public void Check()
+		{
+			if((cur &amp; ParamModifier.ByVal) != 0 &amp;&amp; (cur &amp; ParamModifier.ByRef) != 0) {
+				parser.Error(&quot;ByRef and ByVal are not allowed at the same time.&quot;);
+			}
+		}
+	}
+}
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,6571 @@
+
+#line  1 &quot;VBNET.ATG&quot; 
+using System.Drawing;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB {
+
+
+
+public class Parser
+{
+	const int maxT = 188;
+
+	const  bool   T            = true;
+	const  bool   x            = false;
+	const  int    minErrDist   = 2;
+	const  string errMsgFormat = &quot;-- line {0} col {1}: {2}&quot;;  // 0=line, 1=column, 2=text
+	int    errDist             = minErrDist;
+	Errors errors;
+	Lexer  lexer;
+
+	public Errors Errors {
+		get {
+			return errors;
+		}
+	}
+
+
+#line  10 &quot;VBNET.ATG&quot; 
+private string assemblyName = null;
+public CompilationUnit compilationUnit;
+private ArrayList importedNamespaces = null;
+private Stack withStatements;
+private bool isLabel = false;
+private LabelStatement labelStatement = null;
+
+public string ContainingAssembly
+{
+	set { assemblyName = value; }
+}
+
+Token t
+{
+	get {
+		return lexer.Token;
+	}
+}
+Token la
+{
+	get {
+		return lexer.LookAhead;
+	}
+}
+
+void updateLabelStatement(Statement stmt)
+{
+	if(isLabel) {
+		labelStatement.EmbeddedStatement = stmt;
+		isLabel = false;
+	} else {
+		compilationUnit.AddChild(stmt);
+	}
+}
+
+/* Return the n-th token after the current lookahead token */
+void StartPeek()
+{
+	lexer.StartPeek();
+}
+
+Token Peek()
+{
+	return lexer.Peek();
+}
+
+Token Peek (int n)
+{
+	lexer.StartPeek();
+	Token x = la;
+	while (n &gt; 0) {
+		x = lexer.Peek();
+		n--;
+	}
+	return x;
+}
+
+public void Error(string s)
+{
+	if (errDist &gt;= minErrDist) {
+		errors.Error(la.line, la.col, s);
+	}
+	errDist = 0;
+}
+
+public Expression ParseExpression(Lexer lexer)
+{
+	this.errors = lexer.Errors;
+	this.lexer = lexer;
+	errors.SynErr = new ErrorCodeProc(SynErr);
+	lexer.NextToken();
+	Expression expr;
+	Expr(out expr);
+	return expr;
+}
+
+bool IsEndStmtAhead()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.End &amp;&amp; (peek == Tokens.EOL || peek == Tokens.Colon);
+}
+
+bool IsNotClosingParenthesis() {
+	return la.kind != Tokens.CloseParenthesis;
+}
+
+/*
+	True, if ident is followed by &quot;=&quot;
+*/
+bool IdentAndAsgn () {
+	if(la.kind == Tokens.Identifier) {
+		if(Peek(1).kind == Tokens.Assign) return true;
+		if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
+	}
+	return false;
+}
+
+/*
+	True, if ident is followed by &quot;=&quot; or by &quot;:&quot; and &quot;=&quot;
+*/
+bool IsNamedAssign() {
+//	if(Peek(1).kind == Tokens.Assign) return true; // removed: not in the lang spec
+	if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
+	return false;
+}
+
+bool IsObjectCreation() {
+	return la.kind == Tokens.As &amp;&amp; Peek(1).kind == Tokens.New;
+}
+
+/*
+	True, if &quot;&lt;&quot; is followed by the ident &quot;assembly&quot; or &quot;module&quot;
+*/
+bool IsGlobalAttrTarget () {
+	Token pt = Peek(1);
+	return la.kind == Tokens.LessThan &amp;&amp; ( pt.val.ToLower() == &quot;assembly&quot; || pt.val.ToLower() == &quot;module&quot;);
+}
+
+/*
+	True if the next token is a &quot;(&quot; and is followed by &quot;,&quot; or &quot;)&quot;
+*/
+bool IsRank()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.OpenParenthesis
+						&amp;&amp; (peek == Tokens.Comma || peek == Tokens.CloseParenthesis);
+}
+
+bool IsDims()
+{
+	int peek = Peek(1).kind;
+	int peek_n = Peek(2).kind;
+	return la.kind == Tokens.OpenParenthesis
+						&amp;&amp; (peek == Tokens.LiteralInteger &amp;&amp; peek_n == Tokens.CloseParenthesis);
+}
+
+bool IsSize()
+{
+	return la.kind == Tokens.OpenParenthesis;
+}
+
+/*
+	True, if the comma is not a trailing one,
+	like the last one in: a, b, c,
+*/
+bool NotFinalComma() {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Comma &amp;&amp;
+		   peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
+}
+
+/*
+	True, if the next token is &quot;Else&quot; and this one
+	if followed by &quot;If&quot;
+*/
+bool IsElseIf()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Else &amp;&amp; peek == Tokens.If;
+}
+
+/*
+	True if the next token is goto and this one is
+	followed by minus (&quot;-&quot;) (this is allowd in in
+	error clauses)
+*/
+bool IsNegativeLabelName()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.GoTo &amp;&amp; peek == Tokens.Minus;
+}
+
+/*
+	True if the next statement is a &quot;Resume next&quot; statement
+*/
+bool IsResumeNext()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Resume &amp;&amp; peek == Tokens.Next;
+}
+
+/*
+	True, if ident/literal integer is followed by &quot;:&quot;
+*/
+bool IsLabel()
+{
+	return (la.kind == Tokens.Identifier || la.kind == Tokens.LiteralInteger)
+			&amp;&amp; Peek(1).kind == Tokens.Colon;
+}
+
+bool IsNotStatementSeparator()
+{
+	return la.kind == Tokens.Colon &amp;&amp; Peek(1).kind == Tokens.EOL;
+}
+
+bool IsAssignment ()
+{
+	return IdentAndAsgn();
+}
+
+bool IsMustOverride(Modifiers m)
+{
+	return m.Contains(Modifier.MustOverride);
+}
+
+/*
+	True, if lookahead is a local attribute target specifier,
+	i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,
+	&quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;
+*/
+bool IsLocalAttrTarget() {
+	// TODO
+	return false;
+}
+
+
+
+/*
+
+*/
+	void SynErr(int n)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.SynErr(lexer.LookAhead.line, lexer.LookAhead.col, n);
+		}
+		errDist = 0;
+	}
+
+	public void SemErr(string msg)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.Error(lexer.Token.line, lexer.Token.col, msg);
+		}
+		errDist = 0;
+	}
+	
+	void Expect(int n)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+		}
+	}
+	
+	bool StartOf(int s)
+	{
+		return set[s, lexer.LookAhead.kind];
+	}
+	
+	void ExpectWeak(int n, int follow)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+			while (!StartOf(follow)) {
+				lexer.NextToken();
+			}
+		}
+	}
+	
+	bool WeakSeparator(int n, int syFol, int repFol)
+	{
+		bool[] s = new bool[maxT + 1];
+		
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+			return true; 
+		} else if (StartOf(repFol)) {
+			return false;
+		} else {
+			for (int i = 0; i &lt;= maxT; i++) {
+				s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
+			}
+			SynErr(n);
+			while (!s[lexer.LookAhead.kind]) {
+				lexer.NextToken();
+			}
+			return StartOf(syFol);
+		}
+	}
+	
+	void VBNET() {
+
+#line  431 &quot;VBNET.ATG&quot; 
+		compilationUnit = new CompilationUnit();
+		withStatements = new Stack();
+		
+		while (la.kind == 1) {
+			lexer.NextToken();
+		}
+		while (la.kind == 137) {
+			OptionStmt();
+		}
+		while (la.kind == 109) {
+			ImportsStmt();
+		}
+		while (
+#line  437 &quot;VBNET.ATG&quot; 
+IsGlobalAttrTarget()) {
+			GlobalAttributeSection();
+		}
+		while (StartOf(1)) {
+			NamespaceMemberDecl();
+		}
+		Expect(0);
+	}
+
+	void OptionStmt() {
+
+#line  442 &quot;VBNET.ATG&quot; 
+		INode node = null; bool val = true; 
+		Expect(137);
+
+#line  443 &quot;VBNET.ATG&quot; 
+		Point startPos = t.Location; 
+		if (la.kind == 96) {
+			lexer.NextToken();
+			if (la.kind == 135 || la.kind == 136) {
+				OptionValue(
+#line  445 &quot;VBNET.ATG&quot; 
+ref val);
+			}
+
+#line  446 &quot;VBNET.ATG&quot; 
+			node = new OptionExplicitDeclaration(val); 
+		} else if (la.kind == 166) {
+			lexer.NextToken();
+			if (la.kind == 135 || la.kind == 136) {
+				OptionValue(
+#line  448 &quot;VBNET.ATG&quot; 
+ref val);
+			}
+
+#line  449 &quot;VBNET.ATG&quot; 
+			node = new OptionStrictDeclaration(val); 
+		} else if (la.kind == 71) {
+			lexer.NextToken();
+			if (la.kind == 52) {
+				lexer.NextToken();
+
+#line  451 &quot;VBNET.ATG&quot; 
+				node = new OptionCompareDeclaration(CompareType.Binary); 
+			} else if (la.kind == 171) {
+				lexer.NextToken();
+
+#line  452 &quot;VBNET.ATG&quot; 
+				node = new OptionCompareDeclaration(CompareType.Text); 
+			} else SynErr(189);
+		} else SynErr(190);
+		EndOfStmt();
+
+#line  457 &quot;VBNET.ATG&quot; 
+		node.StartLocation = startPos;
+		node.EndLocation   = t.Location;
+		compilationUnit.AddChild(node);
+		
+	}
+
+	void ImportsStmt() {
+
+#line  481 &quot;VBNET.ATG&quot; 
+		ArrayList importClauses = new ArrayList();
+		importedNamespaces = new ArrayList();
+		object importClause;
+		
+		Expect(109);
+
+#line  487 &quot;VBNET.ATG&quot; 
+		Point startPos = t.Location;
+		ImportsStatement importsStatement = new ImportsStatement(null);
+		
+		ImportClause(
+#line  490 &quot;VBNET.ATG&quot; 
+out importClause);
+
+#line  490 &quot;VBNET.ATG&quot; 
+		importClauses.Add(importClause); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			ImportClause(
+#line  492 &quot;VBNET.ATG&quot; 
+out importClause);
+
+#line  492 &quot;VBNET.ATG&quot; 
+			importClauses.Add(importClause); 
+		}
+		EndOfStmt();
+
+#line  496 &quot;VBNET.ATG&quot; 
+		importsStatement.ImportClauses = importClauses;
+		importsStatement.StartLocation = startPos;
+		importsStatement.EndLocation   = t.Location;
+		compilationUnit.AddChild(importsStatement);
+		
+	}
+
+	void GlobalAttributeSection() {
+
+#line  1840 &quot;VBNET.ATG&quot; 
+		Point startPos = t.Location; 
+		Expect(28);
+		if (la.kind == 50) {
+			lexer.NextToken();
+		} else if (la.kind == 122) {
+			lexer.NextToken();
+		} else SynErr(191);
+
+#line  1843 &quot;VBNET.ATG&quot; 
+		string attributeTarget = t.val.ToLower();
+		ArrayList attributes = new ArrayList();
+		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
+		
+		Expect(13);
+		Attribute(
+#line  1847 &quot;VBNET.ATG&quot; 
+out attribute);
+
+#line  1847 &quot;VBNET.ATG&quot; 
+		attributes.Add(attribute); 
+		while (
+#line  1848 &quot;VBNET.ATG&quot; 
+NotFinalComma()) {
+			Expect(12);
+			Attribute(
+#line  1848 &quot;VBNET.ATG&quot; 
+out attribute);
+
+#line  1848 &quot;VBNET.ATG&quot; 
+			attributes.Add(attribute); 
+		}
+		if (la.kind == 12) {
+			lexer.NextToken();
+		}
+		Expect(27);
+		EndOfStmt();
+
+#line  1853 &quot;VBNET.ATG&quot; 
+		AttributeSection section = new AttributeSection(attributeTarget, attributes);
+		section.StartLocation = startPos;
+		section.EndLocation = t.EndLocation;
+		compilationUnit.AddChild(section);
+		
+	}
+
+	void NamespaceMemberDecl() {
+
+#line  526 &quot;VBNET.ATG&quot; 
+		Modifiers m = new Modifiers(this);
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		string qualident;
+		
+		if (la.kind == 127) {
+			lexer.NextToken();
+
+#line  533 &quot;VBNET.ATG&quot; 
+			Point startPos = t.Location;
+			
+			Qualident(
+#line  535 &quot;VBNET.ATG&quot; 
+out qualident);
+
+#line  537 &quot;VBNET.ATG&quot; 
+			INode node =  new NamespaceDeclaration(qualident);
+			node.StartLocation = startPos;
+			compilationUnit.AddChild(node);
+			compilationUnit.BlockStart(node);
+			
+			Expect(1);
+			NamespaceBody();
+
+#line  545 &quot;VBNET.ATG&quot; 
+			node.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+		} else if (StartOf(2)) {
+			while (la.kind == 28) {
+				AttributeSection(
+#line  549 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  549 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(3)) {
+				TypeModifier(
+#line  550 &quot;VBNET.ATG&quot; 
+m);
+			}
+			NonModuleDeclaration(
+#line  550 &quot;VBNET.ATG&quot; 
+m, attributes);
+		} else SynErr(192);
+	}
+
+	void OptionValue(
+#line  463 &quot;VBNET.ATG&quot; 
+ref bool val) {
+		if (la.kind == 136) {
+			lexer.NextToken();
+
+#line  465 &quot;VBNET.ATG&quot; 
+			val = true; 
+		} else if (la.kind == 135) {
+			lexer.NextToken();
+
+#line  467 &quot;VBNET.ATG&quot; 
+			val = true; 
+		} else SynErr(193);
+	}
+
+	void EndOfStmt() {
+		if (la.kind == 1) {
+			lexer.NextToken();
+		} else if (la.kind == 13) {
+			lexer.NextToken();
+		} else SynErr(194);
+	}
+
+	void ImportClause(
+#line  503 &quot;VBNET.ATG&quot; 
+out object importClause) {
+
+#line  505 &quot;VBNET.ATG&quot; 
+		string qualident = null;
+		string aliasident = null;
+		importClause = null;
+		
+		if (
+#line  509 &quot;VBNET.ATG&quot; 
+IsAssignment()) {
+			Identifier();
+
+#line  509 &quot;VBNET.ATG&quot; 
+			aliasident = t.val;  
+			Expect(11);
+		}
+		Qualident(
+#line  510 &quot;VBNET.ATG&quot; 
+out qualident);
+
+#line  512 &quot;VBNET.ATG&quot; 
+		if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
+		if (aliasident != null) {
+			importClause = new ImportsAliasDeclaration(aliasident, qualident);
+		} else {
+			importedNamespaces.Add(qualident);
+			importClause = new ImportsDeclaration(qualident);
+		}
+		}
+		
+	}
+
+	void Identifier() {
+		if (la.kind == 2) {
+			lexer.NextToken();
+		} else if (la.kind == 171) {
+			lexer.NextToken();
+		} else if (la.kind == 52) {
+			lexer.NextToken();
+		} else if (la.kind == 71) {
+			lexer.NextToken();
+		} else SynErr(195);
+	}
+
+	void Qualident(
+#line  2527 &quot;VBNET.ATG&quot; 
+out string qualident) {
+
+#line  2528 &quot;VBNET.ATG&quot; 
+		string name = String.Empty; 
+		Identifier();
+
+#line  2529 &quot;VBNET.ATG&quot; 
+		StringBuilder qualidentBuilder = new StringBuilder(t.val); 
+		while (la.kind == 10) {
+			lexer.NextToken();
+			IdentifierOrKeyword(
+#line  2531 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  2531 &quot;VBNET.ATG&quot; 
+			qualidentBuilder.Append('.');
+			  qualidentBuilder.Append(name); 
+			
+		}
+
+#line  2535 &quot;VBNET.ATG&quot; 
+		qualident = qualidentBuilder.ToString(); 
+	}
+
+	void NamespaceBody() {
+		while (StartOf(1)) {
+			NamespaceMemberDecl();
+		}
+		Expect(89);
+		Expect(127);
+		Expect(1);
+	}
+
+	void AttributeSection(
+#line  1911 &quot;VBNET.ATG&quot; 
+out AttributeSection section) {
+
+#line  1913 &quot;VBNET.ATG&quot; 
+		string attributeTarget = &quot;&quot;;
+		ArrayList attributes = new ArrayList();
+		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
+		
+		
+		Expect(28);
+
+#line  1918 &quot;VBNET.ATG&quot; 
+		Point startPos = t.Location; 
+		if (
+#line  1919 &quot;VBNET.ATG&quot; 
+IsLocalAttrTarget()) {
+			if (la.kind == 94) {
+				lexer.NextToken();
+
+#line  1920 &quot;VBNET.ATG&quot; 
+				attributeTarget = &quot;event&quot;;
+			} else if (la.kind == 156) {
+				lexer.NextToken();
+
+#line  1921 &quot;VBNET.ATG&quot; 
+				attributeTarget = &quot;return&quot;;
+			} else {
+				Identifier();
+
+#line  1924 &quot;VBNET.ATG&quot; 
+				string val = t.val.ToLower();
+				if (val != &quot;field&quot;	|| val != &quot;method&quot; ||
+					val != &quot;module&quot; || val != &quot;param&quot;  ||
+					val != &quot;property&quot; || val != &quot;type&quot;)
+				Error(&quot;attribute target specifier (event, return, field,&quot; +
+						&quot;method, module, param, property, or type) expected&quot;);
+				attributeTarget = t.val;
+				
+			}
+			Expect(13);
+		}
+		Attribute(
+#line  1934 &quot;VBNET.ATG&quot; 
+out attribute);
+
+#line  1934 &quot;VBNET.ATG&quot; 
+		attributes.Add(attribute); 
+		while (
+#line  1935 &quot;VBNET.ATG&quot; 
+NotFinalComma()) {
+			Expect(12);
+			Attribute(
+#line  1935 &quot;VBNET.ATG&quot; 
+out attribute);
+
+#line  1935 &quot;VBNET.ATG&quot; 
+			attributes.Add(attribute); 
+		}
+		if (la.kind == 12) {
+			lexer.NextToken();
+		}
+		Expect(27);
+
+#line  1939 &quot;VBNET.ATG&quot; 
+		section = new AttributeSection(attributeTarget, attributes);
+		section.StartLocation = startPos;
+		section.EndLocation = t.EndLocation;
+		
+	}
+
+	void TypeModifier(
+#line  2715 &quot;VBNET.ATG&quot; 
+Modifiers m) {
+		switch (la.kind) {
+		case 150: {
+			lexer.NextToken();
+
+#line  2716 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Public); 
+			break;
+		}
+		case 149: {
+			lexer.NextToken();
+
+#line  2717 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Protected); 
+			break;
+		}
+		case 100: {
+			lexer.NextToken();
+
+#line  2718 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Friend); 
+			break;
+		}
+		case 147: {
+			lexer.NextToken();
+
+#line  2719 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Private); 
+			break;
+		}
+		case 160: {
+			lexer.NextToken();
+
+#line  2720 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Shared); 
+			break;
+		}
+		case 159: {
+			lexer.NextToken();
+
+#line  2721 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Shadows); 
+			break;
+		}
+		case 123: {
+			lexer.NextToken();
+
+#line  2722 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.MustInherit); 
+			break;
+		}
+		case 132: {
+			lexer.NextToken();
+
+#line  2723 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.NotInheritable); 
+			break;
+		}
+		default: SynErr(196); break;
+		}
+	}
+
+	void NonModuleDeclaration(
+#line  554 &quot;VBNET.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+
+#line  556 &quot;VBNET.ATG&quot; 
+		string name = String.Empty;
+		ArrayList names = null;
+		
+		switch (la.kind) {
+		case 68: {
+
+#line  559 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Classes); 
+			lexer.NextToken();
+
+#line  562 &quot;VBNET.ATG&quot; 
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			newType.Type = Types.Class;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			
+			Identifier();
+
+#line  570 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
+			EndOfStmt();
+			if (la.kind == 111) {
+				ClassBaseType(
+#line  572 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  572 &quot;VBNET.ATG&quot; 
+				newType.BaseType = name; 
+			}
+			while (la.kind == 108) {
+				TypeImplementsClause(
+#line  573 &quot;VBNET.ATG&quot; 
+out names);
+
+#line  573 &quot;VBNET.ATG&quot; 
+				newType.BaseInterfaces = names; 
+			}
+			ClassBody(
+#line  574 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  576 &quot;VBNET.ATG&quot; 
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 122: {
+			lexer.NextToken();
+
+#line  580 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Modules);
+			TypeDeclaration newType = new TypeDeclaration();
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.StartLocation = t.Location;
+			newType.Type = Types.Module;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			
+			Identifier();
+
+#line  590 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation;  
+			Expect(1);
+			ModuleBody(
+#line  592 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  594 &quot;VBNET.ATG&quot; 
+			newType.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 168: {
+			lexer.NextToken();
+
+#line  599 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Structures);
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			newType.StartLocation = t.Location;
+			newType.Type = Types.Structure;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			ArrayList baseInterfaces = new ArrayList();
+			
+			Identifier();
+
+#line  610 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
+			Expect(1);
+			while (la.kind == 108) {
+				TypeImplementsClause(
+#line  611 &quot;VBNET.ATG&quot; 
+out baseInterfaces);
+			}
+			StructureBody(
+#line  612 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  614 &quot;VBNET.ATG&quot; 
+			newType.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 91: {
+			lexer.NextToken();
+
+#line  620 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Enums);
+			TypeDeclaration newType = new TypeDeclaration();
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			
+			newType.Type = Types.Enum;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			
+			Identifier();
+
+#line  631 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
+			if (la.kind == 49) {
+				lexer.NextToken();
+				PrimitiveTypeName(
+#line  632 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  632 &quot;VBNET.ATG&quot; 
+				newType.BaseType = name; 
+			}
+			Expect(1);
+			EnumBody(
+#line  634 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  636 &quot;VBNET.ATG&quot; 
+			newType.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 113: {
+			lexer.NextToken();
+
+#line  642 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Interfaces);
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			
+			newType.Type = Types.Interface;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			ArrayList baseInterfaces = new ArrayList();
+			
+			Identifier();
+
+#line  653 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
+			EndOfStmt();
+			while (la.kind == 111) {
+				InterfaceBase(
+#line  654 &quot;VBNET.ATG&quot; 
+out baseInterfaces);
+
+#line  654 &quot;VBNET.ATG&quot; 
+				newType.BaseInterfaces = baseInterfaces; 
+			}
+			InterfaceBody(
+#line  655 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  657 &quot;VBNET.ATG&quot; 
+			newType.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 81: {
+			lexer.NextToken();
+
+#line  663 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Delegates);
+			DelegateDeclaration delegateDeclr = new DelegateDeclaration();
+			ArrayList p = null;
+			TypeReference type = null;
+			delegateDeclr.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			delegateDeclr.StartLocation = t.Location;
+			delegateDeclr.Modifier = m.Modifier;
+			delegateDeclr.Attributes = attributes;
+			
+			if (la.kind == 169) {
+				lexer.NextToken();
+				Identifier();
+
+#line  673 &quot;VBNET.ATG&quot; 
+				delegateDeclr.Name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  674 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+
+#line  674 &quot;VBNET.ATG&quot; 
+					delegateDeclr.Parameters = p; 
+				}
+			} else if (la.kind == 101) {
+				lexer.NextToken();
+				Identifier();
+
+#line  676 &quot;VBNET.ATG&quot; 
+				delegateDeclr.Name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  677 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+
+#line  677 &quot;VBNET.ATG&quot; 
+					delegateDeclr.Parameters = p; 
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  678 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  678 &quot;VBNET.ATG&quot; 
+					delegateDeclr.ReturnType = type; 
+				}
+			} else SynErr(197);
+
+#line  680 &quot;VBNET.ATG&quot; 
+			delegateDeclr.EndLocation = t.EndLocation; 
+			Expect(1);
+
+#line  683 &quot;VBNET.ATG&quot; 
+			compilationUnit.AddChild(delegateDeclr);
+			
+			break;
+		}
+		default: SynErr(198); break;
+		}
+	}
+
+	void ClassBaseType(
+#line  873 &quot;VBNET.ATG&quot; 
+out string name) {
+
+#line  875 &quot;VBNET.ATG&quot; 
+		TypeReference type;
+		name = String.Empty;
+		
+		Expect(111);
+		TypeName(
+#line  879 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  879 &quot;VBNET.ATG&quot; 
+		name = type.Type; 
+		EndOfStmt();
+	}
+
+	void TypeImplementsClause(
+#line  1408 &quot;VBNET.ATG&quot; 
+out ArrayList baseInterfaces) {
+
+#line  1410 &quot;VBNET.ATG&quot; 
+		baseInterfaces = new ArrayList();
+		TypeReference type = null;
+		
+		Expect(108);
+		TypeName(
+#line  1413 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1415 &quot;VBNET.ATG&quot; 
+		baseInterfaces.Add(type);
+		
+		while (la.kind == 12) {
+			lexer.NextToken();
+			TypeName(
+#line  1418 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1419 &quot;VBNET.ATG&quot; 
+			baseInterfaces.Add(type); 
+		}
+		EndOfStmt();
+	}
+
+	void ClassBody(
+#line  693 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+
+#line  694 &quot;VBNET.ATG&quot; 
+		AttributeSection section; 
+		while (StartOf(5)) {
+
+#line  697 &quot;VBNET.ATG&quot; 
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+			
+			while (la.kind == 28) {
+				AttributeSection(
+#line  700 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  700 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(6)) {
+				MemberModifier(
+#line  701 &quot;VBNET.ATG&quot; 
+m);
+			}
+			ClassMemberDecl(
+#line  702 &quot;VBNET.ATG&quot; 
+m, attributes);
+		}
+		Expect(89);
+		Expect(68);
+
+#line  704 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void ModuleBody(
+#line  724 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+
+#line  725 &quot;VBNET.ATG&quot; 
+		AttributeSection section; 
+		while (StartOf(5)) {
+
+#line  728 &quot;VBNET.ATG&quot; 
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+			
+			while (la.kind == 28) {
+				AttributeSection(
+#line  731 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  731 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(6)) {
+				MemberModifier(
+#line  732 &quot;VBNET.ATG&quot; 
+m);
+			}
+			ClassMemberDecl(
+#line  733 &quot;VBNET.ATG&quot; 
+m, attributes);
+		}
+		Expect(89);
+		Expect(122);
+
+#line  735 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void StructureBody(
+#line  708 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+
+#line  709 &quot;VBNET.ATG&quot; 
+		AttributeSection section; 
+		while (StartOf(5)) {
+
+#line  712 &quot;VBNET.ATG&quot; 
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+			
+			while (la.kind == 28) {
+				AttributeSection(
+#line  715 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  715 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(6)) {
+				MemberModifier(
+#line  716 &quot;VBNET.ATG&quot; 
+m);
+			}
+			StructureMemberDecl(
+#line  717 &quot;VBNET.ATG&quot; 
+m, attributes);
+		}
+		Expect(89);
+		Expect(168);
+
+#line  719 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void PrimitiveTypeName(
+#line  2693 &quot;VBNET.ATG&quot; 
+out string type) {
+
+#line  2694 &quot;VBNET.ATG&quot; 
+		type = String.Empty; 
+		switch (la.kind) {
+		case 53: {
+			lexer.NextToken();
+
+#line  2695 &quot;VBNET.ATG&quot; 
+			type = &quot;Boolean&quot;; 
+			break;
+		}
+		case 77: {
+			lexer.NextToken();
+
+#line  2696 &quot;VBNET.ATG&quot; 
+			type = &quot;Date&quot;; 
+			break;
+		}
+		case 66: {
+			lexer.NextToken();
+
+#line  2697 &quot;VBNET.ATG&quot; 
+			type = &quot;Char&quot;; 
+			break;
+		}
+		case 167: {
+			lexer.NextToken();
+
+#line  2698 &quot;VBNET.ATG&quot; 
+			type = &quot;String&quot;; 
+			break;
+		}
+		case 78: {
+			lexer.NextToken();
+
+#line  2699 &quot;VBNET.ATG&quot; 
+			type = &quot;Decimal&quot;; 
+			break;
+		}
+		case 55: {
+			lexer.NextToken();
+
+#line  2700 &quot;VBNET.ATG&quot; 
+			type = &quot;Byte&quot;; 
+			break;
+		}
+		case 161: {
+			lexer.NextToken();
+
+#line  2701 &quot;VBNET.ATG&quot; 
+			type = &quot;Short&quot;; 
+			break;
+		}
+		case 112: {
+			lexer.NextToken();
+
+#line  2702 &quot;VBNET.ATG&quot; 
+			type = &quot;Integer&quot;; 
+			break;
+		}
+		case 118: {
+			lexer.NextToken();
+
+#line  2703 &quot;VBNET.ATG&quot; 
+			type = &quot;Long&quot;; 
+			break;
+		}
+		case 162: {
+			lexer.NextToken();
+
+#line  2704 &quot;VBNET.ATG&quot; 
+			type = &quot;Single&quot;; 
+			break;
+		}
+		case 85: {
+			lexer.NextToken();
+
+#line  2705 &quot;VBNET.ATG&quot; 
+			type = &quot;Double&quot;; 
+			break;
+		}
+		default: SynErr(199); break;
+		}
+	}
+
+	void EnumBody(
+#line  739 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+
+#line  740 &quot;VBNET.ATG&quot; 
+		FieldDeclaration f; 
+		while (StartOf(7)) {
+			EnumMemberDecl(
+#line  742 &quot;VBNET.ATG&quot; 
+out f);
+
+#line  742 &quot;VBNET.ATG&quot; 
+			compilationUnit.AddChild(f); 
+		}
+		Expect(89);
+		Expect(91);
+
+#line  744 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void InterfaceBase(
+#line  1393 &quot;VBNET.ATG&quot; 
+out ArrayList bases) {
+
+#line  1395 &quot;VBNET.ATG&quot; 
+		TypeReference type;
+		bases = new ArrayList();
+		
+		Expect(111);
+		TypeName(
+#line  1399 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1399 &quot;VBNET.ATG&quot; 
+		bases.Add(type); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			TypeName(
+#line  1402 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1402 &quot;VBNET.ATG&quot; 
+			bases.Add(type); 
+		}
+		Expect(1);
+	}
+
+	void InterfaceBody(
+#line  748 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+		while (StartOf(8)) {
+			InterfaceMemberDecl();
+		}
+		Expect(89);
+		Expect(113);
+
+#line  750 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void FormalParameterList(
+#line  1946 &quot;VBNET.ATG&quot; 
+out ArrayList parameter) {
+
+#line  1948 &quot;VBNET.ATG&quot; 
+		parameter = new ArrayList();
+		ParameterDeclarationExpression p;
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		
+		while (la.kind == 28) {
+			AttributeSection(
+#line  1953 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1953 &quot;VBNET.ATG&quot; 
+			attributes.Add(section); 
+		}
+		FormalParameter(
+#line  1955 &quot;VBNET.ATG&quot; 
+out p);
+
+#line  1957 &quot;VBNET.ATG&quot; 
+		bool paramsFound = false;
+		p.Attributes = attributes;
+		parameter.Add(p);
+		
+		while (la.kind == 12) {
+			lexer.NextToken();
+
+#line  1962 &quot;VBNET.ATG&quot; 
+			attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); 
+			while (la.kind == 28) {
+				AttributeSection(
+#line  1963 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1963 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			FormalParameter(
+#line  1965 &quot;VBNET.ATG&quot; 
+out p);
+
+#line  1965 &quot;VBNET.ATG&quot; 
+			p.Attributes = attributes; parameter.Add(p); 
+		}
+	}
+
+	void TypeName(
+#line  1758 &quot;VBNET.ATG&quot; 
+out TypeReference typeref) {
+
+#line  1760 &quot;VBNET.ATG&quot; 
+		ArrayList rank = null;
+		
+		NonArrayTypeName(
+#line  1762 &quot;VBNET.ATG&quot; 
+out typeref);
+		ArrayTypeModifiers(
+#line  1763 &quot;VBNET.ATG&quot; 
+out rank);
+
+#line  1765 &quot;VBNET.ATG&quot; 
+		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
+		
+	}
+
+	void MemberModifier(
+#line  2726 &quot;VBNET.ATG&quot; 
+Modifiers m) {
+		switch (la.kind) {
+		case 123: {
+			lexer.NextToken();
+
+#line  2727 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.MustInherit);
+			break;
+		}
+		case 80: {
+			lexer.NextToken();
+
+#line  2728 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Default);
+			break;
+		}
+		case 100: {
+			lexer.NextToken();
+
+#line  2729 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Friend);
+			break;
+		}
+		case 159: {
+			lexer.NextToken();
+
+#line  2730 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Shadows);
+			break;
+		}
+		case 144: {
+			lexer.NextToken();
+
+#line  2731 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Overrides);
+			break;
+		}
+		case 124: {
+			lexer.NextToken();
+
+#line  2732 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.MustOverride);
+			break;
+		}
+		case 147: {
+			lexer.NextToken();
+
+#line  2733 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Private);
+			break;
+		}
+		case 149: {
+			lexer.NextToken();
+
+#line  2734 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Protected);
+			break;
+		}
+		case 150: {
+			lexer.NextToken();
+
+#line  2735 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Public);
+			break;
+		}
+		case 132: {
+			lexer.NextToken();
+
+#line  2736 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.NotInheritable);
+			break;
+		}
+		case 133: {
+			lexer.NextToken();
+
+#line  2737 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.NotOverridable);
+			break;
+		}
+		case 160: {
+			lexer.NextToken();
+
+#line  2738 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Shared);
+			break;
+		}
+		case 142: {
+			lexer.NextToken();
+
+#line  2739 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Overridable);
+			break;
+		}
+		case 141: {
+			lexer.NextToken();
+
+#line  2740 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Overloads);
+			break;
+		}
+		case 152: {
+			lexer.NextToken();
+
+#line  2741 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.ReadOnly);
+			break;
+		}
+		case 186: {
+			lexer.NextToken();
+
+#line  2742 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.WriteOnly);
+			break;
+		}
+		case 185: {
+			lexer.NextToken();
+
+#line  2743 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.WithEvents);
+			break;
+		}
+		case 82: {
+			lexer.NextToken();
+
+#line  2744 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Dim);
+			break;
+		}
+		default: SynErr(200); break;
+		}
+	}
+
+	void ClassMemberDecl(
+#line  869 &quot;VBNET.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+		StructureMemberDecl(
+#line  870 &quot;VBNET.ATG&quot; 
+m, attributes);
+	}
+
+	void StructureMemberDecl(
+#line  884 &quot;VBNET.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+
+#line  886 &quot;VBNET.ATG&quot; 
+		TypeReference type = null;
+		ArrayList p = null;
+		Statement stmt = null;
+		ArrayList variableDeclarators = new ArrayList();
+		
+		switch (la.kind) {
+		case 68: case 81: case 91: case 113: case 122: case 168: {
+			NonModuleDeclaration(
+#line  891 &quot;VBNET.ATG&quot; 
+m, attributes);
+			break;
+		}
+		case 169: {
+			lexer.NextToken();
+
+#line  895 &quot;VBNET.ATG&quot; 
+			Point startPos = t.Location;
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+			
+			if (StartOf(9)) {
+
+#line  900 &quot;VBNET.ATG&quot; 
+				string name = String.Empty;
+				MethodDeclaration methodDeclaration;
+				HandlesClause handlesClause = null;
+				ImplementsClause implementsClause = null;
+				
+				Identifier();
+
+#line  907 &quot;VBNET.ATG&quot; 
+				name = t.val;
+				m.Check(Modifier.Methods);
+				
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  910 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 106 || la.kind == 108) {
+					if (la.kind == 108) {
+						ImplementsClause(
+#line  913 &quot;VBNET.ATG&quot; 
+out implementsClause);
+					} else {
+						HandlesClause(
+#line  915 &quot;VBNET.ATG&quot; 
+out handlesClause);
+					}
+				}
+
+#line  918 &quot;VBNET.ATG&quot; 
+				Point endLocation = t.EndLocation; 
+				Expect(1);
+				if (
+#line  922 &quot;VBNET.ATG&quot; 
+IsMustOverride(m)) {
+
+#line  924 &quot;VBNET.ATG&quot; 
+					methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
+					methodDeclaration.Specials[&quot;before&quot;] = comments;
+					methodDeclaration.StartLocation = startPos;
+					methodDeclaration.EndLocation   = endLocation;
+					
+					methodDeclaration.HandlesClause = handlesClause;
+					methodDeclaration.ImplementsClause = implementsClause;
+					
+					compilationUnit.AddChild(methodDeclaration);
+					
+				} else if (StartOf(10)) {
+
+#line  936 &quot;VBNET.ATG&quot; 
+					methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
+					methodDeclaration.Specials[&quot;before&quot;] = comments;
+					methodDeclaration.StartLocation = startPos;
+					methodDeclaration.EndLocation   = endLocation;
+					
+					methodDeclaration.HandlesClause = handlesClause;
+					methodDeclaration.ImplementsClause = implementsClause;
+					
+					compilationUnit.AddChild(methodDeclaration);
+					compilationUnit.BlockStart(methodDeclaration);
+					
+					Block(
+#line  947 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  949 &quot;VBNET.ATG&quot; 
+					compilationUnit.BlockEnd();
+					methodDeclaration.Body  = (BlockStatement)stmt;
+					
+					Expect(89);
+					Expect(169);
+
+#line  952 &quot;VBNET.ATG&quot; 
+					methodDeclaration.Body.EndLocation = t.EndLocation; 
+					Expect(1);
+				} else SynErr(201);
+			} else if (la.kind == 128) {
+				lexer.NextToken();
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  955 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+
+#line  956 &quot;VBNET.ATG&quot; 
+				m.Check(Modifier.Constructors); 
+
+#line  957 &quot;VBNET.ATG&quot; 
+				Point constructorEndLocation = t.EndLocation; 
+				Expect(1);
+				Block(
+#line  959 &quot;VBNET.ATG&quot; 
+out stmt);
+				Expect(89);
+				Expect(169);
+
+#line  960 &quot;VBNET.ATG&quot; 
+				Point endLocation = t.EndLocation; 
+				Expect(1);
+
+#line  962 &quot;VBNET.ATG&quot; 
+				ConstructorDeclaration cd = new ConstructorDeclaration(&quot;New&quot;, m.Modifier, p, attributes); 
+				cd.StartLocation = startPos;
+				cd.Specials[&quot;before&quot;] = comments;
+				cd.EndLocation   = constructorEndLocation;
+				cd.Body = (BlockStatement)stmt;
+				cd.Body.EndLocation   = endLocation;
+				compilationUnit.AddChild(cd);
+				
+			} else SynErr(202);
+			break;
+		}
+		case 101: {
+			lexer.NextToken();
+
+#line  975 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Methods);
+			string name = String.Empty;
+			Point startPos = t.Location;
+			MethodDeclaration methodDeclaration;
+			HandlesClause handlesClause = null;
+			ImplementsClause implementsClause = null;
+			AttributeSection attributeSection = null;
+			
+			Identifier();
+
+#line  983 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			if (la.kind == 25) {
+				lexer.NextToken();
+				if (StartOf(4)) {
+					FormalParameterList(
+#line  984 &quot;VBNET.ATG&quot; 
+out p);
+				}
+				Expect(26);
+			}
+			if (la.kind == 49) {
+				lexer.NextToken();
+				if (la.kind == 28) {
+					AttributeSection(
+#line  985 &quot;VBNET.ATG&quot; 
+out attributeSection);
+				}
+				TypeName(
+#line  985 &quot;VBNET.ATG&quot; 
+out type);
+			}
+
+#line  987 &quot;VBNET.ATG&quot; 
+			if(type == null) {
+			type = new TypeReference(&quot;System.Object&quot;);
+			}
+			type.Attributes = attributeSection;
+			
+			if (la.kind == 106 || la.kind == 108) {
+				if (la.kind == 108) {
+					ImplementsClause(
+#line  994 &quot;VBNET.ATG&quot; 
+out implementsClause);
+				} else {
+					HandlesClause(
+#line  996 &quot;VBNET.ATG&quot; 
+out handlesClause);
+				}
+			}
+			Expect(1);
+			if (
+#line  1002 &quot;VBNET.ATG&quot; 
+IsMustOverride(m)) {
+
+#line  1004 &quot;VBNET.ATG&quot; 
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = t.EndLocation;
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				compilationUnit.AddChild(methodDeclaration);
+				
+			} else if (StartOf(10)) {
+
+#line  1014 &quot;VBNET.ATG&quot; 
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = t.EndLocation;
+				
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				
+				compilationUnit.AddChild(methodDeclaration);
+				compilationUnit.BlockStart(methodDeclaration);
+				
+				Block(
+#line  1025 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  1027 &quot;VBNET.ATG&quot; 
+				compilationUnit.BlockEnd();
+				methodDeclaration.Body  = (BlockStatement)stmt;
+				
+				Expect(89);
+				Expect(101);
+
+#line  1032 &quot;VBNET.ATG&quot; 
+				methodDeclaration.Body.StartLocation = methodDeclaration.EndLocation;
+				methodDeclaration.Body.EndLocation   = t.EndLocation;
+				
+				Expect(1);
+			} else SynErr(203);
+			break;
+		}
+		case 79: {
+			lexer.NextToken();
+
+#line  1041 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.ExternalMethods);
+			Point startPos = t.Location;
+			CharsetModifier charsetModifer = CharsetModifier.None;
+			string library = String.Empty;
+			string alias = null;
+			string name = String.Empty;
+			
+			if (StartOf(11)) {
+				Charset(
+#line  1048 &quot;VBNET.ATG&quot; 
+out charsetModifer);
+			}
+			if (la.kind == 169) {
+				lexer.NextToken();
+				Identifier();
+
+#line  1051 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				Expect(116);
+				Expect(3);
+
+#line  1052 &quot;VBNET.ATG&quot; 
+				library = t.val; 
+				if (la.kind == 45) {
+					lexer.NextToken();
+					Expect(3);
+
+#line  1053 &quot;VBNET.ATG&quot; 
+					alias = t.val; 
+				}
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  1054 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				Expect(1);
+
+#line  1057 &quot;VBNET.ATG&quot; 
+				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, null, p, attributes, library, alias, charsetModifer);
+				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				declareDeclaration.StartLocation = startPos;
+				declareDeclaration.EndLocation   = t.EndLocation;
+				compilationUnit.AddChild(declareDeclaration);
+				
+			} else if (la.kind == 101) {
+				lexer.NextToken();
+				Identifier();
+
+#line  1065 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				Expect(116);
+				Expect(3);
+
+#line  1066 &quot;VBNET.ATG&quot; 
+				library = t.val; 
+				if (la.kind == 45) {
+					lexer.NextToken();
+					Expect(3);
+
+#line  1067 &quot;VBNET.ATG&quot; 
+					alias = t.val; 
+				}
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  1068 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  1069 &quot;VBNET.ATG&quot; 
+out type);
+				}
+				Expect(1);
+
+#line  1072 &quot;VBNET.ATG&quot; 
+				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, type, p, attributes, library, alias, charsetModifer);
+				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				declareDeclaration.StartLocation = startPos;
+				declareDeclaration.EndLocation   = t.EndLocation;
+				compilationUnit.AddChild(declareDeclaration);
+				
+			} else SynErr(204);
+			break;
+		}
+		case 94: {
+			lexer.NextToken();
+
+#line  1083 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Events);
+			Point startPos = t.Location;
+			EventDeclaration eventDeclaration;
+			string name = String.Empty;
+			ImplementsClause implementsClause = null;
+			
+			Identifier();
+
+#line  1089 &quot;VBNET.ATG&quot; 
+			name= t.val; 
+			if (la.kind == 49) {
+				lexer.NextToken();
+				TypeName(
+#line  1091 &quot;VBNET.ATG&quot; 
+out type);
+			} else if (la.kind == 1 || la.kind == 25 || la.kind == 108) {
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  1093 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+			} else SynErr(205);
+			if (la.kind == 108) {
+				ImplementsClause(
+#line  1095 &quot;VBNET.ATG&quot; 
+out implementsClause);
+			}
+
+#line  1097 &quot;VBNET.ATG&quot; 
+			eventDeclaration = new EventDeclaration(type, m.Modifier, p, attributes, name, implementsClause);
+			eventDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			eventDeclaration.StartLocation = startPos;
+			eventDeclaration.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(eventDeclaration);
+			
+			Expect(1);
+			break;
+		}
+		case 2: case 52: case 71: case 171: {
+
+#line  1105 &quot;VBNET.ATG&quot; 
+			Point startPos = t.Location; 
+
+#line  1107 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Fields);
+			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+			fd.StartLocation = startPos;
+			
+			VariableDeclarator(
+#line  1112 &quot;VBNET.ATG&quot; 
+variableDeclarators);
+
+#line  1114 &quot;VBNET.ATG&quot; 
+			((INode)variableDeclarators[0]).Specials[&quot;before&quot;] = comments;
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				VariableDeclarator(
+#line  1116 &quot;VBNET.ATG&quot; 
+variableDeclarators);
+			}
+			Expect(1);
+
+#line  1119 &quot;VBNET.ATG&quot; 
+			fd.EndLocation = t.EndLocation;
+			fd.Fields = variableDeclarators;
+			compilationUnit.AddChild(fd);
+			
+			break;
+		}
+		case 72: {
+
+#line  1124 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Fields); 
+			lexer.NextToken();
+
+#line  1125 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Constant);  
+
+#line  1127 &quot;VBNET.ATG&quot; 
+			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+			fd.StartLocation = t.Location;
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+			ArrayList constantDeclarators = new ArrayList();
+			
+			ConstantDeclarator(
+#line  1132 &quot;VBNET.ATG&quot; 
+constantDeclarators);
+
+#line  1134 &quot;VBNET.ATG&quot; 
+			((INode)constantDeclarators[0]).Specials[&quot;before&quot;] = comments;
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				ConstantDeclarator(
+#line  1136 &quot;VBNET.ATG&quot; 
+constantDeclarators);
+			}
+
+#line  1138 &quot;VBNET.ATG&quot; 
+			fd.Fields = constantDeclarators;
+			fd.EndLocation = t.Location;
+			
+			Expect(1);
+
+#line  1143 &quot;VBNET.ATG&quot; 
+			fd.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(fd);
+			
+			break;
+		}
+		case 148: {
+			lexer.NextToken();
+
+#line  1149 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Properties);
+			Point startPos = t.Location;
+			ImplementsClause implementsClause = null;
+			
+			Identifier();
+
+#line  1153 &quot;VBNET.ATG&quot; 
+			string propertyName = t.val; 
+			if (la.kind == 25) {
+				lexer.NextToken();
+				if (StartOf(4)) {
+					FormalParameterList(
+#line  1154 &quot;VBNET.ATG&quot; 
+out p);
+				}
+				Expect(26);
+			}
+			if (la.kind == 49) {
+				lexer.NextToken();
+				TypeName(
+#line  1155 &quot;VBNET.ATG&quot; 
+out type);
+			}
+
+#line  1157 &quot;VBNET.ATG&quot; 
+			if(type == null) {
+			type = new TypeReference(&quot;System.Object&quot;);
+			}
+			
+			if (la.kind == 108) {
+				ImplementsClause(
+#line  1161 &quot;VBNET.ATG&quot; 
+out implementsClause);
+			}
+			Expect(1);
+			if (
+#line  1165 &quot;VBNET.ATG&quot; 
+IsMustOverride(m)) {
+
+#line  1167 &quot;VBNET.ATG&quot; 
+				PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
+				pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				pDecl.StartLocation = startPos;
+				pDecl.EndLocation   = t.Location;
+				pDecl.TypeReference = type;
+				pDecl.ImplementsClause = implementsClause;
+				pDecl.Parameters = p;
+				compilationUnit.AddChild(pDecl);
+				
+			} else if (la.kind == 28 || la.kind == 102 || la.kind == 158) {
+
+#line  1178 &quot;VBNET.ATG&quot; 
+				PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
+				pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				pDecl.StartLocation = startPos;
+				pDecl.EndLocation   = t.Location;
+				pDecl.BodyStart   = t.Location;
+				pDecl.TypeReference = type;
+				pDecl.ImplementsClause = implementsClause;
+				pDecl.Parameters = p;
+				PropertyGetRegion getRegion;
+				PropertySetRegion setRegion;
+				
+				AccessorDecls(
+#line  1189 &quot;VBNET.ATG&quot; 
+out getRegion, out setRegion);
+				Expect(89);
+				Expect(148);
+				Expect(1);
+
+#line  1193 &quot;VBNET.ATG&quot; 
+				pDecl.GetRegion = getRegion;
+				pDecl.SetRegion = setRegion;
+				pDecl.BodyEnd = t.EndLocation;
+				compilationUnit.AddChild(pDecl);
+				
+			} else SynErr(206);
+			break;
+		}
+		default: SynErr(207); break;
+		}
+	}
+
+	void EnumMemberDecl(
+#line  849 &quot;VBNET.ATG&quot; 
+out FieldDeclaration f) {
+
+#line  851 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		ArrayList attributes = new ArrayList();
+		AttributeSection section = null;
+		VariableDeclaration varDecl = null;
+		
+		while (la.kind == 28) {
+			AttributeSection(
+#line  856 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  856 &quot;VBNET.ATG&quot; 
+			attributes.Add(section); 
+		}
+		Identifier();
+
+#line  859 &quot;VBNET.ATG&quot; 
+		f = new FieldDeclaration(attributes);
+		varDecl = new VariableDeclaration(t.val);
+		varDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+		f.Fields.Add(varDecl);
+		f.StartLocation = t.Location;
+		
+		if (la.kind == 11) {
+			lexer.NextToken();
+			Expr(
+#line  865 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  865 &quot;VBNET.ATG&quot; 
+			varDecl.Initializer = expr; 
+		}
+		Expect(1);
+	}
+
+	void InterfaceMemberDecl() {
+
+#line  760 &quot;VBNET.ATG&quot; 
+		TypeReference type =null;
+		ArrayList p = null;
+		AttributeSection section;
+		Modifiers mod = new Modifiers(this);
+		ArrayList attributes = new ArrayList();
+		ArrayList parameters = new ArrayList();
+		string name;
+		
+		if (StartOf(12)) {
+			while (la.kind == 28) {
+				AttributeSection(
+#line  768 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  768 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(6)) {
+				MemberModifier(
+#line  772 &quot;VBNET.ATG&quot; 
+mod);
+			}
+			if (la.kind == 94) {
+				lexer.NextToken();
+
+#line  775 &quot;VBNET.ATG&quot; 
+				mod.Check(Modifier.InterfaceEvents); 
+				Identifier();
+
+#line  776 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  777 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  778 &quot;VBNET.ATG&quot; 
+out type);
+				}
+				Expect(1);
+
+#line  781 &quot;VBNET.ATG&quot; 
+				EventDeclaration ed = new EventDeclaration(type, mod.Modifier, p, attributes, name, null);
+				ed.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				compilationUnit.AddChild(ed);
+				ed.EndLocation = t.EndLocation;
+				
+			} else if (la.kind == 169) {
+				lexer.NextToken();
+
+#line  789 &quot;VBNET.ATG&quot; 
+				mod.Check(Modifier.InterfaceMethods);
+				ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+				
+				Identifier();
+
+#line  792 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  793 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				Expect(1);
+
+#line  796 &quot;VBNET.ATG&quot; 
+				MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, null, p, attributes);
+				md.Specials[&quot;before&quot;] = comments;
+				md.EndLocation = t.EndLocation;
+				compilationUnit.AddChild(md);
+				
+			} else if (la.kind == 101) {
+				lexer.NextToken();
+
+#line  804 &quot;VBNET.ATG&quot; 
+				mod.Check(Modifier.InterfaceMethods);
+				AttributeSection attributeSection = null;
+				
+				Identifier();
+
+#line  807 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  808 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					if (la.kind == 28) {
+						AttributeSection(
+#line  809 &quot;VBNET.ATG&quot; 
+out attributeSection);
+					}
+					TypeName(
+#line  809 &quot;VBNET.ATG&quot; 
+out type);
+				}
+
+#line  811 &quot;VBNET.ATG&quot; 
+				if(type == null) {
+				type = new TypeReference(&quot;System.Object&quot;);
+				}
+				type.Attributes = attributeSection;
+				MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, type, p, attributes);
+				md.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				md.EndLocation = t.EndLocation;
+				compilationUnit.AddChild(md);
+				
+				Expect(1);
+			} else if (la.kind == 148) {
+				lexer.NextToken();
+
+#line  824 &quot;VBNET.ATG&quot; 
+				mod.Check(Modifier.InterfaceProperties);
+				ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+				
+				Identifier();
+
+#line  827 &quot;VBNET.ATG&quot; 
+				name = t.val;  
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  828 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  829 &quot;VBNET.ATG&quot; 
+out type);
+				}
+
+#line  831 &quot;VBNET.ATG&quot; 
+				if(type == null) {
+				type = new TypeReference(&quot;System.Object&quot;);
+				}
+				
+				Expect(1);
+
+#line  837 &quot;VBNET.ATG&quot; 
+				PropertyDeclaration pd = new PropertyDeclaration(name, type, mod.Modifier, attributes);
+				pd.Parameters = p;
+				pd.Specials[&quot;before&quot;] = comments;
+				pd.EndLocation = t.EndLocation;
+				compilationUnit.AddChild(pd);
+				
+			} else SynErr(208);
+		} else if (StartOf(13)) {
+			NonModuleDeclaration(
+#line  845 &quot;VBNET.ATG&quot; 
+mod, attributes);
+		} else SynErr(209);
+	}
+
+	void Expr(
+#line  1447 &quot;VBNET.ATG&quot; 
+out Expression expr) {
+
+#line  1448 &quot;VBNET.ATG&quot; 
+		expr = new Expression(); 
+		ConditionalOrExpr(
+#line  1449 &quot;VBNET.ATG&quot; 
+out expr);
+		while (StartOf(14)) {
+
+#line  1452 &quot;VBNET.ATG&quot; 
+			AssignmentOperatorType op; Expression val; 
+			AssignmentOperator(
+#line  1453 &quot;VBNET.ATG&quot; 
+out op);
+			Expr(
+#line  1453 &quot;VBNET.ATG&quot; 
+out val);
+
+#line  1453 &quot;VBNET.ATG&quot; 
+			expr = new AssignmentExpression(expr, op, val); 
+		}
+	}
+
+	void ImplementsClause(
+#line  1425 &quot;VBNET.ATG&quot; 
+out ImplementsClause clause) {
+
+#line  1427 &quot;VBNET.ATG&quot; 
+		clause = new ImplementsClause();
+		string typename = String.Empty;
+		string first;
+		
+		Expect(108);
+		Identifier();
+
+#line  1431 &quot;VBNET.ATG&quot; 
+		first = t.val; 
+		Expect(10);
+		Qualident(
+#line  1431 &quot;VBNET.ATG&quot; 
+out typename);
+
+#line  1431 &quot;VBNET.ATG&quot; 
+		((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			Identifier();
+
+#line  1432 &quot;VBNET.ATG&quot; 
+			first = t.val; 
+			Expect(10);
+			Qualident(
+#line  1432 &quot;VBNET.ATG&quot; 
+out typename);
+
+#line  1432 &quot;VBNET.ATG&quot; 
+			((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); 
+		}
+	}
+
+	void HandlesClause(
+#line  1383 &quot;VBNET.ATG&quot; 
+out HandlesClause handlesClause) {
+
+#line  1385 &quot;VBNET.ATG&quot; 
+		handlesClause = new HandlesClause();
+		string name;
+		
+		Expect(106);
+		EventMemberSpecifier(
+#line  1388 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1388 &quot;VBNET.ATG&quot; 
+		handlesClause.EventNames.Add(name); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			EventMemberSpecifier(
+#line  1389 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1389 &quot;VBNET.ATG&quot; 
+			handlesClause.EventNames.Add(name); 
+		}
+	}
+
+	void Block(
+#line  2004 &quot;VBNET.ATG&quot; 
+out Statement stmt) {
+
+#line  2007 &quot;VBNET.ATG&quot; 
+		BlockStatement blockStmt = new BlockStatement();
+		blockStmt.StartLocation = t.Location;
+		compilationUnit.BlockStart(blockStmt);
+		
+		while (StartOf(15) || 
+#line  2012 &quot;VBNET.ATG&quot; 
+IsEndStmtAhead()) {
+			if (StartOf(15)) {
+				Statement();
+				EndOfStmt();
+			} else {
+				Expect(89);
+				EndOfStmt();
+
+#line  2012 &quot;VBNET.ATG&quot; 
+				compilationUnit.AddChild(new EndStatement()); 
+			}
+		}
+
+#line  2015 &quot;VBNET.ATG&quot; 
+		stmt = blockStmt;
+		blockStmt.EndLocation = t.EndLocation;
+		compilationUnit.BlockEnd();
+		
+	}
+
+	void Charset(
+#line  1375 &quot;VBNET.ATG&quot; 
+out CharsetModifier charsetModifier) {
+
+#line  1376 &quot;VBNET.ATG&quot; 
+		charsetModifier = CharsetModifier.None; 
+		if (la.kind == 101 || la.kind == 169) {
+		} else if (la.kind == 48) {
+			lexer.NextToken();
+
+#line  1377 &quot;VBNET.ATG&quot; 
+			charsetModifier = CharsetModifier.ANSI; 
+		} else if (la.kind == 51) {
+			lexer.NextToken();
+
+#line  1378 &quot;VBNET.ATG&quot; 
+			charsetModifier = CharsetModifier.Auto; 
+		} else if (la.kind == 178) {
+			lexer.NextToken();
+
+#line  1379 &quot;VBNET.ATG&quot; 
+			charsetModifier = CharsetModifier.Unicode; 
+		} else SynErr(210);
+	}
+
+	void VariableDeclarator(
+#line  1276 &quot;VBNET.ATG&quot; 
+ArrayList fieldDeclaration) {
+
+#line  1278 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		TypeReference type = null;
+		ObjectCreateExpression oce = null;
+		ArrayCreateExpression ace = null;
+		ArrayList rank = null;
+		ArrayList dimension = null;
+		
+		Identifier();
+
+#line  1287 &quot;VBNET.ATG&quot; 
+		VariableDeclaration f = new VariableDeclaration(t.val);
+		
+		if (
+#line  1289 &quot;VBNET.ATG&quot; 
+IsRank()) {
+			ArrayTypeModifiers(
+#line  1289 &quot;VBNET.ATG&quot; 
+out rank);
+		}
+		if (
+#line  1290 &quot;VBNET.ATG&quot; 
+IsSize()) {
+			ArrayInitializationModifier(
+#line  1290 &quot;VBNET.ATG&quot; 
+out dimension);
+		}
+		if (
+#line  1292 &quot;VBNET.ATG&quot; 
+IsObjectCreation()) {
+			Expect(49);
+			ObjectCreateExpression(
+#line  1292 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1294 &quot;VBNET.ATG&quot; 
+			if(expr is ArrayCreateExpression) {
+			ace = expr as ArrayCreateExpression;
+			f.Initializer = ace.ArrayInitializer;
+			
+			} else {
+				oce = expr as ObjectCreateExpression;
+				f.Initializer = oce;
+				if(oce.CreateType != null) {
+					f.Type = oce.CreateType;
+				}
+			}
+			
+		} else if (StartOf(16)) {
+			if (la.kind == 49) {
+				lexer.NextToken();
+				TypeName(
+#line  1307 &quot;VBNET.ATG&quot; 
+out type);
+			}
+
+#line  1309 &quot;VBNET.ATG&quot; 
+			if(type != null) {
+			type.Dimension = dimension;
+			}
+			f.Type = type;
+			if (type != null &amp;&amp; rank != null) {
+				if(type.RankSpecifier != null) {
+					Error(&quot;array rank only allowed one time&quot;);
+				} else {
+					type.RankSpecifier = rank;
+				}
+			}
+			
+			if (la.kind == 11) {
+				lexer.NextToken();
+				VariableInitializer(
+#line  1321 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1321 &quot;VBNET.ATG&quot; 
+				f.Initializer = expr; 
+			}
+		} else SynErr(211);
+
+#line  1323 &quot;VBNET.ATG&quot; 
+		fieldDeclaration.Add(f); 
+	}
+
+	void ConstantDeclarator(
+#line  1259 &quot;VBNET.ATG&quot; 
+ArrayList constantDeclaration) {
+
+#line  1261 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		TypeReference type = null;
+		string name = String.Empty;
+		
+		Identifier();
+
+#line  1265 &quot;VBNET.ATG&quot; 
+		name = t.val; 
+		if (la.kind == 49) {
+			lexer.NextToken();
+			TypeName(
+#line  1266 &quot;VBNET.ATG&quot; 
+out type);
+		}
+		Expect(11);
+		Expr(
+#line  1267 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1269 &quot;VBNET.ATG&quot; 
+		VariableDeclaration f = new VariableDeclaration(name, expr);
+		f.Type = type;
+		constantDeclaration.Add(f);
+		
+	}
+
+	void AccessorDecls(
+#line  1202 &quot;VBNET.ATG&quot; 
+out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
+
+#line  1204 &quot;VBNET.ATG&quot; 
+		ArrayList attributes = new ArrayList(); 
+		AttributeSection section;
+		getBlock = null;
+		setBlock = null; 
+		
+		while (la.kind == 28) {
+			AttributeSection(
+#line  1209 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1209 &quot;VBNET.ATG&quot; 
+			attributes.Add(section); 
+		}
+		if (la.kind == 102) {
+			GetAccessorDecl(
+#line  1211 &quot;VBNET.ATG&quot; 
+out getBlock, attributes);
+			if (la.kind == 28 || la.kind == 158) {
+
+#line  1213 &quot;VBNET.ATG&quot; 
+				attributes = new ArrayList(); 
+				while (la.kind == 28) {
+					AttributeSection(
+#line  1214 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1214 &quot;VBNET.ATG&quot; 
+					attributes.Add(section); 
+				}
+				SetAccessorDecl(
+#line  1215 &quot;VBNET.ATG&quot; 
+out setBlock, attributes);
+			}
+		} else if (la.kind == 158) {
+			SetAccessorDecl(
+#line  1218 &quot;VBNET.ATG&quot; 
+out setBlock, attributes);
+			if (la.kind == 28 || la.kind == 102) {
+
+#line  1220 &quot;VBNET.ATG&quot; 
+				attributes = new ArrayList(); 
+				while (la.kind == 28) {
+					AttributeSection(
+#line  1221 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1221 &quot;VBNET.ATG&quot; 
+					attributes.Add(section); 
+				}
+				GetAccessorDecl(
+#line  1222 &quot;VBNET.ATG&quot; 
+out getBlock, attributes);
+			}
+		} else SynErr(212);
+	}
+
+	void GetAccessorDecl(
+#line  1228 &quot;VBNET.ATG&quot; 
+out PropertyGetRegion getBlock, ArrayList attributes) {
+
+#line  1229 &quot;VBNET.ATG&quot; 
+		Statement stmt = null; 
+		Expect(102);
+		Expect(1);
+		Block(
+#line  1232 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  1234 &quot;VBNET.ATG&quot; 
+		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes);
+		
+		Expect(89);
+		Expect(102);
+		Expect(1);
+	}
+
+	void SetAccessorDecl(
+#line  1241 &quot;VBNET.ATG&quot; 
+out PropertySetRegion setBlock, ArrayList attributes) {
+
+#line  1243 &quot;VBNET.ATG&quot; 
+		Statement stmt = null;
+		ArrayList p = null;
+		
+		Expect(158);
+		if (la.kind == 25) {
+			lexer.NextToken();
+			if (StartOf(4)) {
+				FormalParameterList(
+#line  1247 &quot;VBNET.ATG&quot; 
+out p);
+			}
+			Expect(26);
+		}
+		Expect(1);
+		Block(
+#line  1249 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  1251 &quot;VBNET.ATG&quot; 
+		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes);
+		setBlock.Parameters = p;
+		
+		Expect(89);
+		Expect(158);
+		Expect(1);
+	}
+
+	void ArrayTypeModifiers(
+#line  1813 &quot;VBNET.ATG&quot; 
+out ArrayList arrayModifiers) {
+
+#line  1815 &quot;VBNET.ATG&quot; 
+		arrayModifiers = new ArrayList();
+		int i = 0;
+		
+		while (
+#line  1818 &quot;VBNET.ATG&quot; 
+IsRank()) {
+			Expect(25);
+			if (la.kind == 12 || la.kind == 26) {
+				RankList(
+#line  1820 &quot;VBNET.ATG&quot; 
+out i);
+			}
+
+#line  1822 &quot;VBNET.ATG&quot; 
+			arrayModifiers.Add(i);
+			
+			Expect(26);
+		}
+
+#line  1827 &quot;VBNET.ATG&quot; 
+		if(arrayModifiers.Count == 0) {
+		 arrayModifiers = null;
+		}
+		
+	}
+
+	void ArrayInitializationModifier(
+#line  1327 &quot;VBNET.ATG&quot; 
+out ArrayList arrayModifiers) {
+
+#line  1329 &quot;VBNET.ATG&quot; 
+		arrayModifiers = null;
+		
+		Expect(25);
+		InitializationRankList(
+#line  1331 &quot;VBNET.ATG&quot; 
+out arrayModifiers);
+		Expect(26);
+	}
+
+	void ObjectCreateExpression(
+#line  1701 &quot;VBNET.ATG&quot; 
+out Expression oce) {
+
+#line  1703 &quot;VBNET.ATG&quot; 
+		TypeReference type = null;
+		Expression initializer = null;
+		ArrayList arguments = null;
+		oce = null;
+		
+		Expect(128);
+		ArrayTypeName(
+#line  1708 &quot;VBNET.ATG&quot; 
+out type);
+		if (la.kind == 25) {
+			lexer.NextToken();
+			if (StartOf(17)) {
+				ArgumentList(
+#line  1710 &quot;VBNET.ATG&quot; 
+out arguments);
+			}
+			Expect(26);
+		}
+		if (la.kind == 21) {
+			ArrayInitializer(
+#line  1714 &quot;VBNET.ATG&quot; 
+out initializer);
+		}
+
+#line  1717 &quot;VBNET.ATG&quot; 
+		if(initializer == null) {
+		oce = new ObjectCreateExpression(type, arguments);
+		} else {
+			ArrayCreateExpression ace = new ArrayCreateExpression(type, initializer as ArrayInitializerExpression);
+			ace.Parameters = arguments;
+			oce = ace;
+		}
+		
+	}
+
+	void VariableInitializer(
+#line  1347 &quot;VBNET.ATG&quot; 
+out Expression initializerExpression) {
+
+#line  1349 &quot;VBNET.ATG&quot; 
+		initializerExpression = null;
+		
+		if (StartOf(18)) {
+			Expr(
+#line  1351 &quot;VBNET.ATG&quot; 
+out initializerExpression);
+		} else if (la.kind == 21) {
+			ArrayInitializer(
+#line  1352 &quot;VBNET.ATG&quot; 
+out initializerExpression);
+		} else SynErr(213);
+	}
+
+	void InitializationRankList(
+#line  1335 &quot;VBNET.ATG&quot; 
+out ArrayList rank) {
+
+#line  1337 &quot;VBNET.ATG&quot; 
+		rank = null;
+		Expression expr = null;
+		
+		Expr(
+#line  1340 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1340 &quot;VBNET.ATG&quot; 
+		rank = new ArrayList(); rank.Add(expr); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			Expr(
+#line  1342 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1342 &quot;VBNET.ATG&quot; 
+			rank.Add(expr); 
+		}
+	}
+
+	void ArrayInitializer(
+#line  1356 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1358 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
+		
+		Expect(21);
+		if (StartOf(19)) {
+			VariableInitializer(
+#line  1363 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1365 &quot;VBNET.ATG&quot; 
+			initializer.CreateExpressions.Add(expr);
+			
+			while (
+#line  1368 &quot;VBNET.ATG&quot; 
+NotFinalComma()) {
+				Expect(12);
+				VariableInitializer(
+#line  1368 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1369 &quot;VBNET.ATG&quot; 
+				initializer.CreateExpressions.Add(expr); 
+			}
+		}
+		Expect(22);
+
+#line  1372 &quot;VBNET.ATG&quot; 
+		outExpr = initializer; 
+	}
+
+	void EventMemberSpecifier(
+#line  1435 &quot;VBNET.ATG&quot; 
+out string name) {
+
+#line  1436 &quot;VBNET.ATG&quot; 
+		string type; name = String.Empty; 
+		if (StartOf(9)) {
+			Identifier();
+
+#line  1437 &quot;VBNET.ATG&quot; 
+			type = t.val; 
+			Expect(10);
+			Identifier();
+
+#line  1439 &quot;VBNET.ATG&quot; 
+			name = type + &quot;.&quot; + t.val; 
+		} else if (la.kind == 125) {
+			lexer.NextToken();
+			Expect(10);
+			if (StartOf(9)) {
+				Identifier();
+
+#line  1442 &quot;VBNET.ATG&quot; 
+				name = &quot;MyBase.&quot; + t.val; 
+			} else if (la.kind == 93) {
+				lexer.NextToken();
+
+#line  1443 &quot;VBNET.ATG&quot; 
+				name = &quot;MyBase.Error&quot;; 
+			} else SynErr(214);
+		} else SynErr(215);
+	}
+
+	void ConditionalOrExpr(
+#line  1581 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1582 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		ConditionalAndExpr(
+#line  1583 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 140) {
+			lexer.NextToken();
+			ConditionalAndExpr(
+#line  1583 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1583 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanOr, expr);  
+		}
+	}
+
+	void AssignmentOperator(
+#line  1478 &quot;VBNET.ATG&quot; 
+out AssignmentOperatorType op) {
+
+#line  1479 &quot;VBNET.ATG&quot; 
+		op = AssignmentOperatorType.None; 
+		switch (la.kind) {
+		case 11: {
+			lexer.NextToken();
+
+#line  1480 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Assign; 
+			break;
+		}
+		case 42: {
+			lexer.NextToken();
+
+#line  1481 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.ConcatString; 
+			break;
+		}
+		case 34: {
+			lexer.NextToken();
+
+#line  1482 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Add; 
+			break;
+		}
+		case 36: {
+			lexer.NextToken();
+
+#line  1483 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Subtract; 
+			break;
+		}
+		case 37: {
+			lexer.NextToken();
+
+#line  1484 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Multiply; 
+			break;
+		}
+		case 38: {
+			lexer.NextToken();
+
+#line  1485 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Divide; 
+			break;
+		}
+		case 39: {
+			lexer.NextToken();
+
+#line  1486 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.DivideInteger; 
+			break;
+		}
+		case 35: {
+			lexer.NextToken();
+
+#line  1487 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Power; 
+			break;
+		}
+		case 40: {
+			lexer.NextToken();
+
+#line  1488 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.ShiftLeft; 
+			break;
+		}
+		case 41: {
+			lexer.NextToken();
+
+#line  1489 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.ShiftRight; 
+			break;
+		}
+		default: SynErr(216); break;
+		}
+	}
+
+	void UnaryExpr(
+#line  1457 &quot;VBNET.ATG&quot; 
+out Expression uExpr) {
+
+#line  1459 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		UnaryOperatorType uop = UnaryOperatorType.None;
+		bool isUOp = false;
+		
+		while (la.kind == 14 || la.kind == 15 || la.kind == 16) {
+			if (la.kind == 14) {
+				lexer.NextToken();
+
+#line  1463 &quot;VBNET.ATG&quot; 
+				uop = UnaryOperatorType.Plus; isUOp = true; 
+			} else if (la.kind == 15) {
+				lexer.NextToken();
+
+#line  1464 &quot;VBNET.ATG&quot; 
+				uop = UnaryOperatorType.Minus; isUOp = true; 
+			} else {
+				lexer.NextToken();
+
+#line  1466 &quot;VBNET.ATG&quot; 
+				uop = UnaryOperatorType.Star;  isUOp = true;
+			}
+		}
+		SimpleExpr(
+#line  1468 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1470 &quot;VBNET.ATG&quot; 
+		if (isUOp) {
+		uExpr = new UnaryOperatorExpression(expr, uop);
+		} else {
+			uExpr = expr;
+		}
+		
+	}
+
+	void SimpleExpr(
+#line  1493 &quot;VBNET.ATG&quot; 
+out Expression pexpr) {
+
+#line  1495 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		TypeReference type = null;
+		string name = String.Empty;
+		pexpr = null;
+		
+		if (StartOf(20)) {
+			switch (la.kind) {
+			case 3: {
+				lexer.NextToken();
+
+#line  1503 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 4: {
+				lexer.NextToken();
+
+#line  1504 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 7: {
+				lexer.NextToken();
+
+#line  1505 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 6: {
+				lexer.NextToken();
+
+#line  1506 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 5: {
+				lexer.NextToken();
+
+#line  1507 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 9: {
+				lexer.NextToken();
+
+#line  1508 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 8: {
+				lexer.NextToken();
+
+#line  1509 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 175: {
+				lexer.NextToken();
+
+#line  1511 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(true, &quot;true&quot;);  
+				break;
+			}
+			case 97: {
+				lexer.NextToken();
+
+#line  1512 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(false, &quot;false&quot;); 
+				break;
+			}
+			case 131: {
+				lexer.NextToken();
+
+#line  1513 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(null, &quot;null&quot;);  
+				break;
+			}
+			case 25: {
+				lexer.NextToken();
+				Expr(
+#line  1514 &quot;VBNET.ATG&quot; 
+out expr);
+				Expect(26);
+
+#line  1514 &quot;VBNET.ATG&quot; 
+				pexpr = new ParenthesizedExpression(expr); 
+				break;
+			}
+			case 2: case 52: case 71: case 171: {
+				Identifier();
+
+#line  1515 &quot;VBNET.ATG&quot; 
+				pexpr = new IdentifierExpression(t.val); 
+				break;
+			}
+			case 53: case 55: case 66: case 77: case 78: case 85: case 112: case 118: case 161: case 162: case 167: {
+
+#line  1516 &quot;VBNET.ATG&quot; 
+				string val = String.Empty; 
+				PrimitiveTypeName(
+#line  1516 &quot;VBNET.ATG&quot; 
+out val);
+				Expect(10);
+				Identifier();
+
+#line  1517 &quot;VBNET.ATG&quot; 
+				pexpr = new FieldReferenceOrInvocationExpression(new TypeReferenceExpression(val), t.val); 
+				break;
+			}
+			case 120: {
+				lexer.NextToken();
+
+#line  1518 &quot;VBNET.ATG&quot; 
+				pexpr = new ThisReferenceExpression(); 
+				break;
+			}
+			case 125: case 126: {
+
+#line  1519 &quot;VBNET.ATG&quot; 
+				Expression retExpr = null; 
+				if (la.kind == 125) {
+					lexer.NextToken();
+
+#line  1520 &quot;VBNET.ATG&quot; 
+					retExpr = new BaseReferenceExpression(); 
+				} else if (la.kind == 126) {
+					lexer.NextToken();
+
+#line  1521 &quot;VBNET.ATG&quot; 
+					retExpr = new ClassReferenceExpression(); 
+				} else SynErr(217);
+				Expect(10);
+				IdentifierOrKeyword(
+#line  1523 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1523 &quot;VBNET.ATG&quot; 
+				pexpr = new FieldReferenceOrInvocationExpression(retExpr, name); 
+				break;
+			}
+			case 128: {
+				ObjectCreateExpression(
+#line  1524 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1524 &quot;VBNET.ATG&quot; 
+				pexpr = expr; 
+				break;
+			}
+			case 76: case 83: {
+				if (la.kind == 83) {
+					lexer.NextToken();
+				} else if (la.kind == 76) {
+					lexer.NextToken();
+				} else SynErr(218);
+				Expect(25);
+				Expr(
+#line  1525 &quot;VBNET.ATG&quot; 
+out expr);
+				Expect(12);
+				TypeName(
+#line  1525 &quot;VBNET.ATG&quot; 
+out type);
+				Expect(26);
+
+#line  1525 &quot;VBNET.ATG&quot; 
+				pexpr = new CastExpression(type, expr); 
+				break;
+			}
+			case 60: case 61: case 62: case 63: case 64: case 65: case 67: case 69: case 70: case 73: case 74: case 75: {
+				CastTarget(
+#line  1526 &quot;VBNET.ATG&quot; 
+out type);
+				Expect(25);
+				Expr(
+#line  1526 &quot;VBNET.ATG&quot; 
+out expr);
+				Expect(26);
+
+#line  1526 &quot;VBNET.ATG&quot; 
+				pexpr = new CastExpression(type, expr, true); 
+				break;
+			}
+			case 44: {
+				lexer.NextToken();
+				Expr(
+#line  1527 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1527 &quot;VBNET.ATG&quot; 
+				pexpr = new AddressOfExpression(expr); 
+				break;
+			}
+			case 103: {
+				lexer.NextToken();
+				Expect(25);
+				TypeName(
+#line  1528 &quot;VBNET.ATG&quot; 
+out type);
+				Expect(26);
+
+#line  1528 &quot;VBNET.ATG&quot; 
+				pexpr = new GetTypeExpression(type); 
+				break;
+			}
+			case 177: {
+				lexer.NextToken();
+				SimpleExpr(
+#line  1529 &quot;VBNET.ATG&quot; 
+out expr);
+				Expect(114);
+				TypeName(
+#line  1529 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1529 &quot;VBNET.ATG&quot; 
+				pexpr = new TypeOfExpression(expr, type); 
+				break;
+			}
+			}
+			while (la.kind == 10 || la.kind == 25) {
+				if (la.kind == 10) {
+					lexer.NextToken();
+					IdentifierOrKeyword(
+#line  1532 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1532 &quot;VBNET.ATG&quot; 
+					pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); 
+				} else {
+					lexer.NextToken();
+
+#line  1533 &quot;VBNET.ATG&quot; 
+					ArrayList parameters = new ArrayList(); 
+					if (StartOf(21)) {
+
+#line  1535 &quot;VBNET.ATG&quot; 
+						expr = null; 
+						if (StartOf(18)) {
+							Argument(
+#line  1535 &quot;VBNET.ATG&quot; 
+out expr);
+						}
+
+#line  1535 &quot;VBNET.ATG&quot; 
+						parameters.Add(expr); 
+						while (la.kind == 12) {
+							lexer.NextToken();
+
+#line  1537 &quot;VBNET.ATG&quot; 
+							expr = null; 
+							if (StartOf(18)) {
+								Argument(
+#line  1538 &quot;VBNET.ATG&quot; 
+out expr);
+							}
+
+#line  1538 &quot;VBNET.ATG&quot; 
+							parameters.Add(expr); 
+						}
+					}
+					Expect(26);
+
+#line  1541 &quot;VBNET.ATG&quot; 
+					pexpr = new InvocationExpression(pexpr, parameters); 
+				}
+			}
+		} else if (la.kind == 10) {
+			lexer.NextToken();
+			IdentifierOrKeyword(
+#line  1545 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1545 &quot;VBNET.ATG&quot; 
+			pexpr = new FieldReferenceOrInvocationExpression(pexpr, name);
+			while (la.kind == 10 || la.kind == 25) {
+				if (la.kind == 10) {
+					lexer.NextToken();
+					IdentifierOrKeyword(
+#line  1547 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1547 &quot;VBNET.ATG&quot; 
+					pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); 
+				} else {
+					lexer.NextToken();
+
+#line  1548 &quot;VBNET.ATG&quot; 
+					ArrayList parameters = new ArrayList(); 
+					if (StartOf(21)) {
+
+#line  1550 &quot;VBNET.ATG&quot; 
+						expr = null; 
+						if (StartOf(18)) {
+							Argument(
+#line  1550 &quot;VBNET.ATG&quot; 
+out expr);
+						}
+
+#line  1550 &quot;VBNET.ATG&quot; 
+						parameters.Add(expr); 
+						while (la.kind == 12) {
+							lexer.NextToken();
+
+#line  1552 &quot;VBNET.ATG&quot; 
+							expr = null; 
+							if (StartOf(18)) {
+								Argument(
+#line  1553 &quot;VBNET.ATG&quot; 
+out expr);
+							}
+
+#line  1553 &quot;VBNET.ATG&quot; 
+							parameters.Add(expr); 
+						}
+					}
+					Expect(26);
+
+#line  1556 &quot;VBNET.ATG&quot; 
+					pexpr = new InvocationExpression(pexpr, parameters); 
+				}
+			}
+		} else SynErr(219);
+	}
+
+	void IdentifierOrKeyword(
+#line  2547 &quot;VBNET.ATG&quot; 
+out string name) {
+
+#line  2549 &quot;VBNET.ATG&quot; 
+		name = String.Empty;
+		
+		switch (la.kind) {
+		case 2: case 52: case 71: case 171: {
+			Identifier();
+
+#line  2551 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 43: {
+			lexer.NextToken();
+
+#line  2552 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 44: {
+			lexer.NextToken();
+
+#line  2553 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 45: {
+			lexer.NextToken();
+
+#line  2554 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 46: {
+			lexer.NextToken();
+
+#line  2555 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 47: {
+			lexer.NextToken();
+
+#line  2556 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 48: {
+			lexer.NextToken();
+
+#line  2557 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 49: {
+			lexer.NextToken();
+
+#line  2558 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 50: {
+			lexer.NextToken();
+
+#line  2559 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 51: {
+			lexer.NextToken();
+
+#line  2560 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 53: {
+			lexer.NextToken();
+
+#line  2561 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 54: {
+			lexer.NextToken();
+
+#line  2562 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 55: {
+			lexer.NextToken();
+
+#line  2563 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 56: {
+			lexer.NextToken();
+
+#line  2564 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 57: {
+			lexer.NextToken();
+
+#line  2565 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 58: {
+			lexer.NextToken();
+
+#line  2566 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 59: {
+			lexer.NextToken();
+
+#line  2567 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 60: {
+			lexer.NextToken();
+
+#line  2568 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 61: {
+			lexer.NextToken();
+
+#line  2569 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 62: {
+			lexer.NextToken();
+
+#line  2570 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 63: {
+			lexer.NextToken();
+
+#line  2571 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 64: {
+			lexer.NextToken();
+
+#line  2572 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 65: {
+			lexer.NextToken();
+
+#line  2573 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 66: {
+			lexer.NextToken();
+
+#line  2574 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 67: {
+			lexer.NextToken();
+
+#line  2575 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 68: {
+			lexer.NextToken();
+
+#line  2576 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 69: {
+			lexer.NextToken();
+
+#line  2577 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 70: {
+			lexer.NextToken();
+
+#line  2578 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 72: {
+			lexer.NextToken();
+
+#line  2579 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 73: {
+			lexer.NextToken();
+
+#line  2580 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 74: {
+			lexer.NextToken();
+
+#line  2581 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 75: {
+			lexer.NextToken();
+
+#line  2582 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 76: {
+			lexer.NextToken();
+
+#line  2583 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 77: {
+			lexer.NextToken();
+
+#line  2584 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 78: {
+			lexer.NextToken();
+
+#line  2585 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 79: {
+			lexer.NextToken();
+
+#line  2586 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 80: {
+			lexer.NextToken();
+
+#line  2587 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 81: {
+			lexer.NextToken();
+
+#line  2588 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 82: {
+			lexer.NextToken();
+
+#line  2589 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 83: {
+			lexer.NextToken();
+
+#line  2590 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 84: {
+			lexer.NextToken();
+
+#line  2591 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 85: {
+			lexer.NextToken();
+
+#line  2592 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 86: {
+			lexer.NextToken();
+
+#line  2593 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 87: {
+			lexer.NextToken();
+
+#line  2594 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 88: {
+			lexer.NextToken();
+
+#line  2595 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 89: {
+			lexer.NextToken();
+
+#line  2596 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 90: {
+			lexer.NextToken();
+
+#line  2597 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 91: {
+			lexer.NextToken();
+
+#line  2598 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 92: {
+			lexer.NextToken();
+
+#line  2599 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 93: {
+			lexer.NextToken();
+
+#line  2600 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 94: {
+			lexer.NextToken();
+
+#line  2601 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 95: {
+			lexer.NextToken();
+
+#line  2602 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 97: {
+			lexer.NextToken();
+
+#line  2603 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 98: {
+			lexer.NextToken();
+
+#line  2604 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 99: {
+			lexer.NextToken();
+
+#line  2605 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 100: {
+			lexer.NextToken();
+
+#line  2606 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 101: {
+			lexer.NextToken();
+
+#line  2607 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 102: {
+			lexer.NextToken();
+
+#line  2608 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 103: {
+			lexer.NextToken();
+
+#line  2609 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 104: {
+			lexer.NextToken();
+
+#line  2610 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 105: {
+			lexer.NextToken();
+
+#line  2611 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 106: {
+			lexer.NextToken();
+
+#line  2612 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 107: {
+			lexer.NextToken();
+
+#line  2613 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 108: {
+			lexer.NextToken();
+
+#line  2614 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 109: {
+			lexer.NextToken();
+
+#line  2615 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 110: {
+			lexer.NextToken();
+
+#line  2616 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 111: {
+			lexer.NextToken();
+
+#line  2617 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 112: {
+			lexer.NextToken();
+
+#line  2618 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 113: {
+			lexer.NextToken();
+
+#line  2619 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 114: {
+			lexer.NextToken();
+
+#line  2620 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 115: {
+			lexer.NextToken();
+
+#line  2621 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 116: {
+			lexer.NextToken();
+
+#line  2622 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 117: {
+			lexer.NextToken();
+
+#line  2623 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 118: {
+			lexer.NextToken();
+
+#line  2624 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 119: {
+			lexer.NextToken();
+
+#line  2625 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 120: {
+			lexer.NextToken();
+
+#line  2626 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 121: {
+			lexer.NextToken();
+
+#line  2627 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 122: {
+			lexer.NextToken();
+
+#line  2628 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 123: {
+			lexer.NextToken();
+
+#line  2629 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 124: {
+			lexer.NextToken();
+
+#line  2630 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 125: {
+			lexer.NextToken();
+
+#line  2631 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 126: {
+			lexer.NextToken();
+
+#line  2632 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 127: {
+			lexer.NextToken();
+
+#line  2633 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 128: {
+			lexer.NextToken();
+
+#line  2634 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 129: {
+			lexer.NextToken();
+
+#line  2635 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 130: {
+			lexer.NextToken();
+
+#line  2636 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 131: {
+			lexer.NextToken();
+
+#line  2637 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 132: {
+			lexer.NextToken();
+
+#line  2638 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 133: {
+			lexer.NextToken();
+
+#line  2639 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 134: {
+			lexer.NextToken();
+
+#line  2640 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 136: {
+			lexer.NextToken();
+
+#line  2641 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 137: {
+			lexer.NextToken();
+
+#line  2642 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 138: {
+			lexer.NextToken();
+
+#line  2643 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 139: {
+			lexer.NextToken();
+
+#line  2644 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 140: {
+			lexer.NextToken();
+
+#line  2645 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 141: {
+			lexer.NextToken();
+
+#line  2646 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 142: {
+			lexer.NextToken();
+
+#line  2647 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 144: {
+			lexer.NextToken();
+
+#line  2648 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 145: {
+			lexer.NextToken();
+
+#line  2649 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 146: {
+			lexer.NextToken();
+
+#line  2650 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 147: {
+			lexer.NextToken();
+
+#line  2651 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 148: {
+			lexer.NextToken();
+
+#line  2652 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 149: {
+			lexer.NextToken();
+
+#line  2653 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 150: {
+			lexer.NextToken();
+
+#line  2654 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 151: {
+			lexer.NextToken();
+
+#line  2655 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 152: {
+			lexer.NextToken();
+
+#line  2656 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 153: {
+			lexer.NextToken();
+
+#line  2657 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 154: {
+			lexer.NextToken();
+
+#line  2658 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 155: {
+			lexer.NextToken();
+
+#line  2659 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 156: {
+			lexer.NextToken();
+
+#line  2660 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 157: {
+			lexer.NextToken();
+
+#line  2661 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 158: {
+			lexer.NextToken();
+
+#line  2662 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 159: {
+			lexer.NextToken();
+
+#line  2663 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 160: {
+			lexer.NextToken();
+
+#line  2664 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 161: {
+			lexer.NextToken();
+
+#line  2665 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 162: {
+			lexer.NextToken();
+
+#line  2666 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 163: {
+			lexer.NextToken();
+
+#line  2667 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 164: {
+			lexer.NextToken();
+
+#line  2668 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 165: {
+			lexer.NextToken();
+
+#line  2669 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 167: {
+			lexer.NextToken();
+
+#line  2670 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 168: {
+			lexer.NextToken();
+
+#line  2671 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 169: {
+			lexer.NextToken();
+
+#line  2672 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 170: {
+			lexer.NextToken();
+
+#line  2673 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 172: {
+			lexer.NextToken();
+
+#line  2674 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 173: {
+			lexer.NextToken();
+
+#line  2675 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 174: {
+			lexer.NextToken();
+
+#line  2676 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 175: {
+			lexer.NextToken();
+
+#line  2677 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 176: {
+			lexer.NextToken();
+
+#line  2678 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 177: {
+			lexer.NextToken();
+
+#line  2679 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 178: {
+			lexer.NextToken();
+
+#line  2680 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 179: {
+			lexer.NextToken();
+
+#line  2681 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 180: {
+			lexer.NextToken();
+
+#line  2682 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 181: {
+			lexer.NextToken();
+
+#line  2683 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 182: {
+			lexer.NextToken();
+
+#line  2684 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 183: {
+			lexer.NextToken();
+
+#line  2685 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 184: {
+			lexer.NextToken();
+
+#line  2686 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 185: {
+			lexer.NextToken();
+
+#line  2687 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 186: {
+			lexer.NextToken();
+
+#line  2688 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 187: {
+			lexer.NextToken();
+
+#line  2689 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		default: SynErr(220); break;
+		}
+	}
+
+	void CastTarget(
+#line  1563 &quot;VBNET.ATG&quot; 
+out TypeReference type) {
+
+#line  1565 &quot;VBNET.ATG&quot; 
+		type = null;
+		
+		switch (la.kind) {
+		case 60: {
+			lexer.NextToken();
+
+#line  1567 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Boolean&quot;); 
+			break;
+		}
+		case 61: {
+			lexer.NextToken();
+
+#line  1568 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Byte&quot;); 
+			break;
+		}
+		case 62: {
+			lexer.NextToken();
+
+#line  1569 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Char&quot;); 
+			break;
+		}
+		case 63: {
+			lexer.NextToken();
+
+#line  1570 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.DateTime&quot;); 
+			break;
+		}
+		case 65: {
+			lexer.NextToken();
+
+#line  1571 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Decimal&quot;); 
+			break;
+		}
+		case 64: {
+			lexer.NextToken();
+
+#line  1572 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Double&quot;); 
+			break;
+		}
+		case 67: {
+			lexer.NextToken();
+
+#line  1573 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Int32&quot;); 
+			break;
+		}
+		case 69: {
+			lexer.NextToken();
+
+#line  1574 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Int64&quot;); 
+			break;
+		}
+		case 70: {
+			lexer.NextToken();
+
+#line  1575 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Object&quot;); 
+			break;
+		}
+		case 73: {
+			lexer.NextToken();
+
+#line  1576 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Int16&quot;); 
+			break;
+		}
+		case 74: {
+			lexer.NextToken();
+
+#line  1577 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Single&quot;); 
+			break;
+		}
+		case 75: {
+			lexer.NextToken();
+
+#line  1578 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.String&quot;); 
+			break;
+		}
+		default: SynErr(221); break;
+		}
+	}
+
+	void Argument(
+#line  1743 &quot;VBNET.ATG&quot; 
+out Expression argumentexpr) {
+
+#line  1745 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		argumentexpr = null;
+		string name;
+		
+		if (
+#line  1749 &quot;VBNET.ATG&quot; 
+IsNamedAssign()) {
+			Identifier();
+
+#line  1749 &quot;VBNET.ATG&quot; 
+			name = t.val;  
+			Expect(13);
+			Expect(11);
+			Expr(
+#line  1749 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1751 &quot;VBNET.ATG&quot; 
+			argumentexpr = new NamedArgumentExpression(name, expr);
+			
+		} else if (StartOf(18)) {
+			Expr(
+#line  1754 &quot;VBNET.ATG&quot; 
+out argumentexpr);
+		} else SynErr(222);
+	}
+
+	void ConditionalAndExpr(
+#line  1586 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1587 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		InclusiveOrExpr(
+#line  1588 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 47) {
+			lexer.NextToken();
+			InclusiveOrExpr(
+#line  1588 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1588 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanAnd, expr);  
+		}
+	}
+
+	void InclusiveOrExpr(
+#line  1591 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1592 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		ExclusiveOrExpr(
+#line  1593 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 187) {
+			lexer.NextToken();
+			ExclusiveOrExpr(
+#line  1593 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1593 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  
+		}
+	}
+
+	void ExclusiveOrExpr(
+#line  1596 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1597 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		AndExpr(
+#line  1598 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 139) {
+			lexer.NextToken();
+			AndExpr(
+#line  1598 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1598 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  
+		}
+	}
+
+	void AndExpr(
+#line  1601 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1602 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		NotExpr(
+#line  1603 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 46) {
+			lexer.NextToken();
+			NotExpr(
+#line  1603 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1603 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  
+		}
+	}
+
+	void NotExpr(
+#line  1606 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1607 &quot;VBNET.ATG&quot; 
+		UnaryOperatorType uop = UnaryOperatorType.None; 
+		while (la.kind == 130) {
+			lexer.NextToken();
+
+#line  1608 &quot;VBNET.ATG&quot; 
+			uop = UnaryOperatorType.Not; 
+		}
+		EqualityExpr(
+#line  1609 &quot;VBNET.ATG&quot; 
+out outExpr);
+
+#line  1610 &quot;VBNET.ATG&quot; 
+		if (uop != UnaryOperatorType.None)
+		outExpr = new UnaryOperatorExpression(outExpr, uop);
+		
+	}
+
+	void EqualityExpr(
+#line  1615 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1617 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		RelationalExpr(
+#line  1620 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 11 || la.kind == 29 || la.kind == 117) {
+			if (la.kind == 29) {
+				lexer.NextToken();
+
+#line  1623 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.InEquality; 
+			} else if (la.kind == 11) {
+				lexer.NextToken();
+
+#line  1624 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Equality; 
+			} else {
+				lexer.NextToken();
+
+#line  1625 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Like; 
+			}
+			RelationalExpr(
+#line  1627 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1627 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void RelationalExpr(
+#line  1631 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1633 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		ShiftExpr(
+#line  1636 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (StartOf(22)) {
+			if (StartOf(23)) {
+				if (la.kind == 28) {
+					lexer.NextToken();
+
+#line  1639 &quot;VBNET.ATG&quot; 
+					op = BinaryOperatorType.LessThan; 
+				} else if (la.kind == 27) {
+					lexer.NextToken();
+
+#line  1640 &quot;VBNET.ATG&quot; 
+					op = BinaryOperatorType.GreaterThan; 
+				} else if (la.kind == 31) {
+					lexer.NextToken();
+
+#line  1641 &quot;VBNET.ATG&quot; 
+					op = BinaryOperatorType.LessThanOrEqual; 
+				} else if (la.kind == 30) {
+					lexer.NextToken();
+
+#line  1642 &quot;VBNET.ATG&quot; 
+					op = BinaryOperatorType.GreaterThanOrEqual; 
+				} else SynErr(223);
+				ShiftExpr(
+#line  1644 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1644 &quot;VBNET.ATG&quot; 
+				outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+			} else {
+				lexer.NextToken();
+
+#line  1647 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.IS; 
+				Expr(
+#line  1648 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1648 &quot;VBNET.ATG&quot; 
+				outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
+			}
+		}
+	}
+
+	void ShiftExpr(
+#line  1652 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1654 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		AdditiveExpr(
+#line  1657 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 32 || la.kind == 33) {
+			if (la.kind == 32) {
+				lexer.NextToken();
+
+#line  1660 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.ShiftLeft; 
+			} else {
+				lexer.NextToken();
+
+#line  1661 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.ShiftRight; 
+			}
+			AdditiveExpr(
+#line  1663 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1663 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void AdditiveExpr(
+#line  1667 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1669 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		MultiplicativeExpr(
+#line  1672 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 14 || la.kind == 15 || la.kind == 19) {
+			if (la.kind == 14) {
+				lexer.NextToken();
+
+#line  1675 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Add; 
+			} else if (la.kind == 15) {
+				lexer.NextToken();
+
+#line  1676 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Subtract; 
+			} else {
+				lexer.NextToken();
+
+#line  1677 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Concat; 
+			}
+			MultiplicativeExpr(
+#line  1679 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1679 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void MultiplicativeExpr(
+#line  1683 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1685 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		UnaryExpr(
+#line  1688 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (StartOf(24)) {
+			if (la.kind == 16) {
+				lexer.NextToken();
+
+#line  1691 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Multiply; 
+			} else if (la.kind == 17) {
+				lexer.NextToken();
+
+#line  1692 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Divide; 
+			} else if (la.kind == 18) {
+				lexer.NextToken();
+
+#line  1693 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.DivideInteger; 
+			} else if (la.kind == 121) {
+				lexer.NextToken();
+
+#line  1694 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Modulus; 
+			} else {
+				lexer.NextToken();
+
+#line  1695 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Power; 
+			}
+			UnaryExpr(
+#line  1697 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1697 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
+		}
+	}
+
+	void ArrayTypeName(
+#line  1770 &quot;VBNET.ATG&quot; 
+out TypeReference typeref) {
+
+#line  1772 &quot;VBNET.ATG&quot; 
+		ArrayList rank = null;
+		
+		NonArrayTypeName(
+#line  1774 &quot;VBNET.ATG&quot; 
+out typeref);
+		ArrayInitializationModifiers(
+#line  1775 &quot;VBNET.ATG&quot; 
+out rank);
+
+#line  1777 &quot;VBNET.ATG&quot; 
+		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
+		
+	}
+
+	void ArgumentList(
+#line  1728 &quot;VBNET.ATG&quot; 
+out ArrayList arguments) {
+
+#line  1730 &quot;VBNET.ATG&quot; 
+		arguments = new ArrayList();
+		Expression expr = null;
+		
+		if (StartOf(18)) {
+			Argument(
+#line  1734 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1734 &quot;VBNET.ATG&quot; 
+			arguments.Add(expr); 
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Argument(
+#line  1737 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1737 &quot;VBNET.ATG&quot; 
+				arguments.Add(expr); 
+			}
+		}
+	}
+
+	void NonArrayTypeName(
+#line  1782 &quot;VBNET.ATG&quot; 
+out TypeReference typeref) {
+
+#line  1784 &quot;VBNET.ATG&quot; 
+		string name;
+		typeref = null;
+		
+		if (StartOf(9)) {
+			Qualident(
+#line  1787 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1787 &quot;VBNET.ATG&quot; 
+			typeref = new TypeReference(name); 
+		} else if (la.kind == 134) {
+			lexer.NextToken();
+
+#line  1788 &quot;VBNET.ATG&quot; 
+			typeref = new TypeReference(&quot;System.Object&quot;); 
+		} else if (StartOf(25)) {
+			PrimitiveTypeName(
+#line  1789 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1789 &quot;VBNET.ATG&quot; 
+			typeref = new TypeReference(name); 
+		} else SynErr(224);
+	}
+
+	void ArrayInitializationModifiers(
+#line  1792 &quot;VBNET.ATG&quot; 
+out ArrayList arrayModifiers) {
+
+#line  1794 &quot;VBNET.ATG&quot; 
+		arrayModifiers = new ArrayList();
+		ArrayList dim = new ArrayList();
+		
+		while (
+#line  1798 &quot;VBNET.ATG&quot; 
+IsDims()) {
+			Expect(25);
+			if (StartOf(18)) {
+				InitializationRankList(
+#line  1799 &quot;VBNET.ATG&quot; 
+out dim);
+			}
+
+#line  1801 &quot;VBNET.ATG&quot; 
+			arrayModifiers.Add(dim);
+			
+			Expect(26);
+		}
+
+#line  1806 &quot;VBNET.ATG&quot; 
+		if(arrayModifiers.Count == 0) {
+		 arrayModifiers = null;
+		}
+		
+	}
+
+	void RankList(
+#line  1834 &quot;VBNET.ATG&quot; 
+out int i) {
+
+#line  1835 &quot;VBNET.ATG&quot; 
+		i = 0; 
+		while (la.kind == 12) {
+			lexer.NextToken();
+
+#line  1836 &quot;VBNET.ATG&quot; 
+			++i; 
+		}
+	}
+
+	void Attribute(
+#line  1861 &quot;VBNET.ATG&quot; 
+out ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute) {
+
+#line  1862 &quot;VBNET.ATG&quot; 
+		string qualident; 
+		Qualident(
+#line  1863 &quot;VBNET.ATG&quot; 
+out qualident);
+
+#line  1865 &quot;VBNET.ATG&quot; 
+		ArrayList positional = new ArrayList();
+		ArrayList named      = new ArrayList();
+		string name = qualident;
+		
+		if (la.kind == 25) {
+			AttributeArguments(
+#line  1869 &quot;VBNET.ATG&quot; 
+ref positional, ref named);
+		}
+
+#line  1871 &quot;VBNET.ATG&quot; 
+		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute(name, positional, named);
+		
+	}
+
+	void AttributeArguments(
+#line  1876 &quot;VBNET.ATG&quot; 
+ref ArrayList positional, ref ArrayList named) {
+
+#line  1878 &quot;VBNET.ATG&quot; 
+		bool nameFound = false;
+		string name = &quot;&quot;;
+		Expression expr;
+		
+		Expect(25);
+		if (
+#line  1884 &quot;VBNET.ATG&quot; 
+IsNotClosingParenthesis()) {
+			if (
+#line  1886 &quot;VBNET.ATG&quot; 
+IsNamedAssign()) {
+
+#line  1886 &quot;VBNET.ATG&quot; 
+				nameFound = true; 
+				IdentifierOrKeyword(
+#line  1887 &quot;VBNET.ATG&quot; 
+out name);
+				if (la.kind == 13) {
+					lexer.NextToken();
+				}
+				Expect(11);
+			}
+			Expr(
+#line  1889 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1891 &quot;VBNET.ATG&quot; 
+			if(name == &quot;&quot;) positional.Add(expr);
+			else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				if (
+#line  1897 &quot;VBNET.ATG&quot; 
+IsNamedAssign()) {
+
+#line  1897 &quot;VBNET.ATG&quot; 
+					nameFound = true; 
+					IdentifierOrKeyword(
+#line  1898 &quot;VBNET.ATG&quot; 
+out name);
+					if (la.kind == 13) {
+						lexer.NextToken();
+					}
+					Expect(11);
+				} else if (StartOf(18)) {
+
+#line  1900 &quot;VBNET.ATG&quot; 
+					if (nameFound) Error(&quot;no positional argument after named argument&quot;); 
+				} else SynErr(225);
+				Expr(
+#line  1901 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1901 &quot;VBNET.ATG&quot; 
+				if(name == &quot;&quot;) positional.Add(expr);
+				else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
+				
+			}
+		}
+		Expect(26);
+	}
+
+	void FormalParameter(
+#line  1971 &quot;VBNET.ATG&quot; 
+out ParameterDeclarationExpression p) {
+
+#line  1973 &quot;VBNET.ATG&quot; 
+		TypeReference type = null;
+		ParamModifiers mod = new ParamModifiers(this);
+		Expression expr = null;
+		p = null;
+		ArrayList arrayModifiers = null;
+		
+		while (StartOf(26)) {
+			ParameterModifier(
+#line  1979 &quot;VBNET.ATG&quot; 
+mod);
+		}
+		Identifier();
+
+#line  1980 &quot;VBNET.ATG&quot; 
+		string parameterName = t.val; 
+		if (
+#line  1981 &quot;VBNET.ATG&quot; 
+IsRank()) {
+			ArrayTypeModifiers(
+#line  1981 &quot;VBNET.ATG&quot; 
+out arrayModifiers);
+		}
+		if (la.kind == 49) {
+			lexer.NextToken();
+			TypeName(
+#line  1982 &quot;VBNET.ATG&quot; 
+out type);
+		}
+
+#line  1984 &quot;VBNET.ATG&quot; 
+		if(type != null) {
+		if (arrayModifiers != null) {
+			if (type.RankSpecifier != null) {
+				Error(&quot;array rank only allowed one time&quot;);
+			} else {
+				type.RankSpecifier = arrayModifiers;
+			}
+		}
+		} else {
+			type = new TypeReference(&quot;System.Object&quot;, arrayModifiers);
+		}
+		
+		if (la.kind == 11) {
+			lexer.NextToken();
+			Expr(
+#line  1996 &quot;VBNET.ATG&quot; 
+out expr);
+		}
+
+#line  1998 &quot;VBNET.ATG&quot; 
+		mod.Check();
+		p = new ParameterDeclarationExpression(type, parameterName, mod, expr);
+		
+	}
+
+	void ParameterModifier(
+#line  2708 &quot;VBNET.ATG&quot; 
+ParamModifiers m) {
+		if (la.kind == 56) {
+			lexer.NextToken();
+
+#line  2709 &quot;VBNET.ATG&quot; 
+			m.Add(ParamModifier.ByVal); 
+		} else if (la.kind == 54) {
+			lexer.NextToken();
+
+#line  2710 &quot;VBNET.ATG&quot; 
+			m.Add(ParamModifier.ByRef); 
+		} else if (la.kind == 138) {
+			lexer.NextToken();
+
+#line  2711 &quot;VBNET.ATG&quot; 
+			m.Add(ParamModifier.Optional); 
+		} else if (la.kind == 145) {
+			lexer.NextToken();
+
+#line  2712 &quot;VBNET.ATG&quot; 
+			m.Add(ParamModifier.ParamArray); 
+		} else SynErr(226);
+	}
+
+	void Statement() {
+
+#line  2023 &quot;VBNET.ATG&quot; 
+		Statement stmt;
+		string label = String.Empty;
+		
+		
+		if (
+#line  2027 &quot;VBNET.ATG&quot; 
+IsLabel()) {
+			LabelName(
+#line  2027 &quot;VBNET.ATG&quot; 
+out label);
+
+#line  2029 &quot;VBNET.ATG&quot; 
+			labelStatement = new LabelStatement(t.val);
+			compilationUnit.AddChild(labelStatement);
+			
+			Expect(13);
+			if (StartOf(15)) {
+
+#line  2032 &quot;VBNET.ATG&quot; 
+				isLabel = true; 
+				Statement();
+			}
+		} else if (StartOf(27)) {
+			EmbeddedStatement(
+#line  2033 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  2033 &quot;VBNET.ATG&quot; 
+			updateLabelStatement(stmt); 
+		} else if (StartOf(28)) {
+			LocalDeclarationStatement(
+#line  2034 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  2034 &quot;VBNET.ATG&quot; 
+			updateLabelStatement(stmt); 
+		} else SynErr(227);
+	}
+
+	void LabelName(
+#line  2396 &quot;VBNET.ATG&quot; 
+out string name) {
+
+#line  2398 &quot;VBNET.ATG&quot; 
+		name = String.Empty;
+		
+		if (StartOf(9)) {
+			Identifier();
+
+#line  2400 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+		} else if (la.kind == 5) {
+			lexer.NextToken();
+
+#line  2401 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+		} else SynErr(228);
+	}
+
+	void EmbeddedStatement(
+#line  2071 &quot;VBNET.ATG&quot; 
+out Statement statement) {
+
+#line  2073 &quot;VBNET.ATG&quot; 
+		Statement embeddedStatement = null;
+		statement = null;
+		Expression expr = null;
+		string name = String.Empty;
+		ArrayList p = null;
+		
+		switch (la.kind) {
+		case 95: {
+			lexer.NextToken();
+
+#line  2079 &quot;VBNET.ATG&quot; 
+			ExitType exitType = ExitType.None; 
+			switch (la.kind) {
+			case 169: {
+				lexer.NextToken();
+
+#line  2081 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Sub; 
+				break;
+			}
+			case 101: {
+				lexer.NextToken();
+
+#line  2083 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Function; 
+				break;
+			}
+			case 148: {
+				lexer.NextToken();
+
+#line  2085 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Property; 
+				break;
+			}
+			case 84: {
+				lexer.NextToken();
+
+#line  2087 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Do; 
+				break;
+			}
+			case 99: {
+				lexer.NextToken();
+
+#line  2089 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.For; 
+				break;
+			}
+			case 176: {
+				lexer.NextToken();
+
+#line  2091 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Try; 
+				break;
+			}
+			case 183: {
+				lexer.NextToken();
+
+#line  2093 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.While; 
+				break;
+			}
+			case 157: {
+				lexer.NextToken();
+
+#line  2095 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Select; 
+				break;
+			}
+			default: SynErr(229); break;
+			}
+
+#line  2097 &quot;VBNET.ATG&quot; 
+			statement = new ExitStatement(exitType); 
+			break;
+		}
+		case 176: {
+			TryStatement(
+#line  2098 &quot;VBNET.ATG&quot; 
+out statement);
+			break;
+		}
+		case 173: {
+			lexer.NextToken();
+			if (StartOf(18)) {
+				Expr(
+#line  2100 &quot;VBNET.ATG&quot; 
+out expr);
+			}
+
+#line  2100 &quot;VBNET.ATG&quot; 
+			statement = new ThrowStatement(expr); 
+			break;
+		}
+		case 156: {
+			lexer.NextToken();
+			if (StartOf(18)) {
+				Expr(
+#line  2102 &quot;VBNET.ATG&quot; 
+out expr);
+			}
+
+#line  2102 &quot;VBNET.ATG&quot; 
+			statement = new ReturnStatement(expr); 
+			break;
+		}
+		case 170: {
+			lexer.NextToken();
+			Expr(
+#line  2104 &quot;VBNET.ATG&quot; 
+out expr);
+			EndOfStmt();
+			Block(
+#line  2104 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+			Expect(89);
+			Expect(170);
+
+#line  2105 &quot;VBNET.ATG&quot; 
+			statement = new LockStatement(expr, embeddedStatement); 
+			break;
+		}
+		case 151: {
+			lexer.NextToken();
+			Identifier();
+
+#line  2107 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			if (la.kind == 25) {
+				lexer.NextToken();
+				if (StartOf(17)) {
+					ArgumentList(
+#line  2108 &quot;VBNET.ATG&quot; 
+out p);
+				}
+				Expect(26);
+			}
+
+#line  2109 &quot;VBNET.ATG&quot; 
+			statement = new RaiseEventStatement(name, p); 
+			break;
+		}
+		case 184: {
+			WithStatement(
+#line  2111 &quot;VBNET.ATG&quot; 
+out statement);
+			break;
+		}
+		case 43: {
+			lexer.NextToken();
+
+#line  2113 &quot;VBNET.ATG&quot; 
+			Expression handlerExpr = null; 
+			Expr(
+#line  2114 &quot;VBNET.ATG&quot; 
+out expr);
+			Expect(12);
+			Expr(
+#line  2114 &quot;VBNET.ATG&quot; 
+out handlerExpr);
+
+#line  2116 &quot;VBNET.ATG&quot; 
+			statement = new AddHandlerStatement(expr, handlerExpr);
+			
+			break;
+		}
+		case 154: {
+			lexer.NextToken();
+
+#line  2119 &quot;VBNET.ATG&quot; 
+			Expression handlerExpr = null; 
+			Expr(
+#line  2120 &quot;VBNET.ATG&quot; 
+out expr);
+			Expect(12);
+			Expr(
+#line  2120 &quot;VBNET.ATG&quot; 
+out handlerExpr);
+
+#line  2122 &quot;VBNET.ATG&quot; 
+			statement = new RemoveHandlerStatement(expr, handlerExpr);
+			
+			break;
+		}
+		case 183: {
+			lexer.NextToken();
+			Expr(
+#line  2125 &quot;VBNET.ATG&quot; 
+out expr);
+			EndOfStmt();
+			Block(
+#line  2126 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+			Expect(89);
+			Expect(183);
+
+#line  2128 &quot;VBNET.ATG&quot; 
+			statement = new WhileStatement(expr, embeddedStatement);
+			
+			break;
+		}
+		case 84: {
+			lexer.NextToken();
+
+#line  2133 &quot;VBNET.ATG&quot; 
+			ConditionType conditionType = ConditionType.None;
+			
+			if (la.kind == 179 || la.kind == 183) {
+				WhileOrUntil(
+#line  2136 &quot;VBNET.ATG&quot; 
+out conditionType);
+				Expr(
+#line  2136 &quot;VBNET.ATG&quot; 
+out expr);
+				EndOfStmt();
+				Block(
+#line  2137 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+				Expect(119);
+
+#line  2140 &quot;VBNET.ATG&quot; 
+				statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.Start);
+				
+			} else if (la.kind == 1 || la.kind == 13) {
+				EndOfStmt();
+				Block(
+#line  2144 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+				Expect(119);
+				if (la.kind == 179 || la.kind == 183) {
+					WhileOrUntil(
+#line  2145 &quot;VBNET.ATG&quot; 
+out conditionType);
+					Expr(
+#line  2145 &quot;VBNET.ATG&quot; 
+out expr);
+				}
+
+#line  2147 &quot;VBNET.ATG&quot; 
+				statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.End);
+				
+			} else SynErr(230);
+			break;
+		}
+		case 99: {
+			lexer.NextToken();
+
+#line  2152 &quot;VBNET.ATG&quot; 
+			Expression group = null;
+			LoopControlVariableExpression loopControlExpr = null;
+			
+			if (la.kind == 86) {
+				lexer.NextToken();
+				LoopControlVariable(
+#line  2157 &quot;VBNET.ATG&quot; 
+out loopControlExpr);
+				Expect(110);
+				Expr(
+#line  2158 &quot;VBNET.ATG&quot; 
+out group);
+				EndOfStmt();
+				Block(
+#line  2159 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+				Expect(129);
+				if (StartOf(18)) {
+					Expr(
+#line  2160 &quot;VBNET.ATG&quot; 
+out expr);
+				}
+
+#line  2162 &quot;VBNET.ATG&quot; 
+				statement = new ForeachStatement(loopControlExpr, group, embeddedStatement, expr);
+				
+			} else if (StartOf(9)) {
+
+#line  2166 &quot;VBNET.ATG&quot; 
+				Expression start = null;
+				Expression end = null;
+				Expression step = null;
+				Expression nextExpr = null;
+				ArrayList nextExpressions = null;
+				
+				LoopControlVariable(
+#line  2172 &quot;VBNET.ATG&quot; 
+out loopControlExpr);
+				Expect(11);
+				Expr(
+#line  2173 &quot;VBNET.ATG&quot; 
+out start);
+				Expect(174);
+				Expr(
+#line  2173 &quot;VBNET.ATG&quot; 
+out end);
+				if (la.kind == 164) {
+					lexer.NextToken();
+					Expr(
+#line  2173 &quot;VBNET.ATG&quot; 
+out step);
+				}
+				EndOfStmt();
+				Block(
+#line  2174 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+				Expect(129);
+				if (StartOf(18)) {
+					Expr(
+#line  2177 &quot;VBNET.ATG&quot; 
+out nextExpr);
+
+#line  2177 &quot;VBNET.ATG&quot; 
+					nextExpressions = new ArrayList(); nextExpressions.Add(nextExpr); 
+					while (la.kind == 12) {
+						lexer.NextToken();
+						Expr(
+#line  2178 &quot;VBNET.ATG&quot; 
+out nextExpr);
+
+#line  2178 &quot;VBNET.ATG&quot; 
+						nextExpressions.Add(nextExpr); 
+					}
+				}
+
+#line  2181 &quot;VBNET.ATG&quot; 
+				statement = new ForStatement(loopControlExpr, start, end, step, embeddedStatement, nextExpressions);
+				
+			} else SynErr(231);
+			break;
+		}
+		case 93: {
+			lexer.NextToken();
+			Expr(
+#line  2185 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2185 &quot;VBNET.ATG&quot; 
+			statement = new ErrorStatement(expr); 
+			break;
+		}
+		case 153: {
+			lexer.NextToken();
+
+#line  2187 &quot;VBNET.ATG&quot; 
+			Expression clause = null; 
+			if (la.kind == 146) {
+				lexer.NextToken();
+			}
+			Expr(
+#line  2188 &quot;VBNET.ATG&quot; 
+out clause);
+
+#line  2190 &quot;VBNET.ATG&quot; 
+			ArrayList clauses = new ArrayList();
+			clauses.Add(clause);
+			ReDimStatement reDimStatement = new ReDimStatement(clauses);
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Expr(
+#line  2194 &quot;VBNET.ATG&quot; 
+out clause);
+
+#line  2194 &quot;VBNET.ATG&quot; 
+				clauses.Add(clause); 
+			}
+			break;
+		}
+		case 92: {
+			lexer.NextToken();
+			Expr(
+#line  2197 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2199 &quot;VBNET.ATG&quot; 
+			ArrayList arrays = new ArrayList();
+			arrays.Add(expr);
+			EraseStatement eraseStatement = new EraseStatement(arrays);
+			
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Expr(
+#line  2204 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2204 &quot;VBNET.ATG&quot; 
+				arrays.Add(expr); 
+			}
+
+#line  2205 &quot;VBNET.ATG&quot; 
+			statement = eraseStatement; 
+			break;
+		}
+		case 165: {
+			lexer.NextToken();
+
+#line  2207 &quot;VBNET.ATG&quot; 
+			statement = new StopStatement(); 
+			break;
+		}
+		case 107: {
+			lexer.NextToken();
+			Expr(
+#line  2209 &quot;VBNET.ATG&quot; 
+out expr);
+			if (la.kind == 172) {
+				lexer.NextToken();
+			}
+			if (
+#line  2211 &quot;VBNET.ATG&quot; 
+IsEndStmtAhead()) {
+				Expect(89);
+
+#line  2211 &quot;VBNET.ATG&quot; 
+				statement = new IfStatement(expr, new EndStatement()); 
+			} else if (la.kind == 1 || la.kind == 13) {
+				EndOfStmt();
+				Block(
+#line  2214 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2216 &quot;VBNET.ATG&quot; 
+				ArrayList elseIfSections = new ArrayList();
+				IfStatement ifStatement = new IfStatement(expr, embeddedStatement);
+				
+				while (la.kind == 88 || 
+#line  2221 &quot;VBNET.ATG&quot; 
+IsElseIf()) {
+					if (
+#line  2221 &quot;VBNET.ATG&quot; 
+IsElseIf()) {
+						Expect(87);
+						Expect(107);
+					} else {
+						lexer.NextToken();
+					}
+
+#line  2224 &quot;VBNET.ATG&quot; 
+					Expression condition = null; Statement block = null; 
+					Expr(
+#line  2225 &quot;VBNET.ATG&quot; 
+out condition);
+					if (la.kind == 172) {
+						lexer.NextToken();
+					}
+					EndOfStmt();
+					Block(
+#line  2226 &quot;VBNET.ATG&quot; 
+out block);
+
+#line  2228 &quot;VBNET.ATG&quot; 
+					ElseIfSection elseIfSection = new ElseIfSection(condition, block);
+					elseIfSections.Add(elseIfSection);
+					
+				}
+				if (la.kind == 87) {
+					lexer.NextToken();
+					EndOfStmt();
+					Block(
+#line  2234 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2236 &quot;VBNET.ATG&quot; 
+					ifStatement.EmbeddedElseStatement = embeddedStatement;
+					
+				}
+				Expect(89);
+				Expect(107);
+
+#line  2240 &quot;VBNET.ATG&quot; 
+				ifStatement.ElseIfStatements = elseIfSections;
+				statement = ifStatement;
+				
+			} else if (StartOf(27)) {
+				EmbeddedStatement(
+#line  2244 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2246 &quot;VBNET.ATG&quot; 
+				SimpleIfStatement ifStatement = new SimpleIfStatement(expr);
+				ArrayList statements = new ArrayList();
+				statements.Add(embeddedStatement);
+				ifStatement.Statements = statements;
+				
+				while (la.kind == 13) {
+					lexer.NextToken();
+					EmbeddedStatement(
+#line  2251 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2251 &quot;VBNET.ATG&quot; 
+					statements.Add(embeddedStatement); 
+				}
+				if (la.kind == 87) {
+					lexer.NextToken();
+					if (StartOf(27)) {
+						EmbeddedStatement(
+#line  2253 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+					}
+
+#line  2255 &quot;VBNET.ATG&quot; 
+					ArrayList elseStatements = new ArrayList();
+					elseStatements.Add(embeddedStatement);
+					ifStatement.ElseStatements = elseStatements;
+					
+					while (la.kind == 13) {
+						lexer.NextToken();
+						EmbeddedStatement(
+#line  2260 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2261 &quot;VBNET.ATG&quot; 
+						elseStatements.Add(embeddedStatement); 
+					}
+				}
+
+#line  2264 &quot;VBNET.ATG&quot; 
+				statement = ifStatement; 
+			} else SynErr(232);
+			break;
+		}
+		case 157: {
+			lexer.NextToken();
+			if (la.kind == 58) {
+				lexer.NextToken();
+			}
+			Expr(
+#line  2267 &quot;VBNET.ATG&quot; 
+out expr);
+			EndOfStmt();
+
+#line  2269 &quot;VBNET.ATG&quot; 
+			ArrayList selectSections = new ArrayList();
+			Statement block = null;
+			
+			while (la.kind == 58) {
+
+#line  2273 &quot;VBNET.ATG&quot; 
+				ArrayList caseClauses = null; 
+				lexer.NextToken();
+				CaseClauses(
+#line  2274 &quot;VBNET.ATG&quot; 
+out caseClauses);
+				if (
+#line  2274 &quot;VBNET.ATG&quot; 
+IsNotStatementSeparator()) {
+					lexer.NextToken();
+				}
+				EndOfStmt();
+
+#line  2276 &quot;VBNET.ATG&quot; 
+				SelectSection selectSection = new SelectSection();
+				selectSection.CaseClauses = caseClauses;
+				compilationUnit.BlockStart(selectSection);
+				
+				Block(
+#line  2280 &quot;VBNET.ATG&quot; 
+out block);
+
+#line  2282 &quot;VBNET.ATG&quot; 
+				selectSection.EmbeddedStatement = block;
+				compilationUnit.BlockEnd();
+				selectSections.Add(selectSection);
+				
+			}
+
+#line  2287 &quot;VBNET.ATG&quot; 
+			statement = new SelectStatement(expr, selectSections); 
+			Expect(89);
+			Expect(157);
+			break;
+		}
+		case 136: {
+
+#line  2289 &quot;VBNET.ATG&quot; 
+			OnErrorStatement onErrorStatement = null; 
+			OnErrorStatement(
+#line  2290 &quot;VBNET.ATG&quot; 
+out onErrorStatement);
+
+#line  2290 &quot;VBNET.ATG&quot; 
+			statement = onErrorStatement; 
+			break;
+		}
+		case 105: {
+
+#line  2291 &quot;VBNET.ATG&quot; 
+			GoToStatement goToStatement = null; 
+			GoToStatement(
+#line  2292 &quot;VBNET.ATG&quot; 
+out goToStatement);
+
+#line  2292 &quot;VBNET.ATG&quot; 
+			statement = goToStatement; 
+			break;
+		}
+		case 155: {
+
+#line  2293 &quot;VBNET.ATG&quot; 
+			ResumeStatement resumeStatement = null; 
+			ResumeStatement(
+#line  2294 &quot;VBNET.ATG&quot; 
+out resumeStatement);
+
+#line  2294 &quot;VBNET.ATG&quot; 
+			statement = resumeStatement; 
+			break;
+		}
+		case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 14: case 15: case 16: case 25: case 44: case 52: case 53: case 55: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 69: case 70: case 71: case 73: case 74: case 75: case 76: case 77: case 78: case 83: case 85: case 97: case 103: case 112: case 118: case 120: case 125: case 126: case 128: case 131: case 161: case 162: case 167: case 171: case 175: case 177: {
+
+#line  2297 &quot;VBNET.ATG&quot; 
+			Expression val = null;
+			AssignmentOperatorType op;
+			
+			bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
+			                        la.kind == Tokens.Not   || la.kind == Tokens.Times;
+			
+			UnaryExpr(
+#line  2303 &quot;VBNET.ATG&quot; 
+out expr);
+			if (StartOf(14)) {
+				AssignmentOperator(
+#line  2305 &quot;VBNET.ATG&quot; 
+out op);
+				Expr(
+#line  2305 &quot;VBNET.ATG&quot; 
+out val);
+
+#line  2305 &quot;VBNET.ATG&quot; 
+				expr = new AssignmentExpression(expr, op, val); 
+			} else if (la.kind == 1 || la.kind == 13 || la.kind == 87) {
+
+#line  2306 &quot;VBNET.ATG&quot; 
+				if (mustBeAssignment) Error(&quot;error in assignment.&quot;); 
+			} else SynErr(233);
+
+#line  2309 &quot;VBNET.ATG&quot; 
+			// a field reference expression that stands alone is a
+			// invocation expression without parantheses and arguments
+			if(expr is FieldReferenceOrInvocationExpression) {
+				expr = new InvocationExpression(expr, new ArrayList());
+			}
+			statement = new StatementExpression(expr);
+			
+			break;
+		}
+		case 57: {
+			lexer.NextToken();
+			UnaryExpr(
+#line  2316 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2316 &quot;VBNET.ATG&quot; 
+			statement = new StatementExpression(expr); 
+			break;
+		}
+		default: SynErr(234); break;
+		}
+	}
+
+	void LocalDeclarationStatement(
+#line  2038 &quot;VBNET.ATG&quot; 
+out Statement statement) {
+
+#line  2040 &quot;VBNET.ATG&quot; 
+		Modifiers m = new Modifiers(this);
+		ArrayList vars = new ArrayList();
+		LocalVariableDeclaration localVariableDeclaration;
+		bool dimfound = false;
+		
+		while (la.kind == 72 || la.kind == 82 || la.kind == 163) {
+			if (la.kind == 72) {
+				lexer.NextToken();
+
+#line  2047 &quot;VBNET.ATG&quot; 
+				m.Add(Modifier.Constant); 
+			} else if (la.kind == 163) {
+				lexer.NextToken();
+
+#line  2048 &quot;VBNET.ATG&quot; 
+				m.Add(Modifier.Static); 
+			} else {
+				lexer.NextToken();
+
+#line  2049 &quot;VBNET.ATG&quot; 
+				dimfound = true; 
+			}
+		}
+
+#line  2052 &quot;VBNET.ATG&quot; 
+		if(dimfound &amp;&amp; (m.Modifier &amp; Modifier.Constant) != 0) {
+		Error(&quot;Dim is not allowed on constants.&quot;);
+		}
+		
+		if(m.isNone &amp;&amp; dimfound == false) {
+			Error(&quot;Const, Dim or Static expected&quot;);
+		}
+		
+		localVariableDeclaration = new LocalVariableDeclaration(m.Modifier);
+		localVariableDeclaration.StartLocation = t.Location;
+		
+		VariableDeclarator(
+#line  2063 &quot;VBNET.ATG&quot; 
+vars);
+		while (la.kind == 12) {
+			lexer.NextToken();
+			VariableDeclarator(
+#line  2064 &quot;VBNET.ATG&quot; 
+vars);
+		}
+
+#line  2066 &quot;VBNET.ATG&quot; 
+		localVariableDeclaration.Variables = vars;
+		statement = localVariableDeclaration;
+		
+	}
+
+	void TryStatement(
+#line  2489 &quot;VBNET.ATG&quot; 
+out Statement tryStatement) {
+
+#line  2491 &quot;VBNET.ATG&quot; 
+		Statement blockStmt = null, finallyStmt = null;
+		ArrayList catchClauses = null;
+		
+		Expect(176);
+		EndOfStmt();
+		Block(
+#line  2495 &quot;VBNET.ATG&quot; 
+out blockStmt);
+		if (la.kind == 59 || la.kind == 89 || la.kind == 98) {
+			CatchClauses(
+#line  2497 &quot;VBNET.ATG&quot; 
+out catchClauses);
+			if (la.kind == 98) {
+				lexer.NextToken();
+				EndOfStmt();
+				Block(
+#line  2498 &quot;VBNET.ATG&quot; 
+out finallyStmt);
+			}
+		} else if (la.kind == 98) {
+			lexer.NextToken();
+			EndOfStmt();
+			Block(
+#line  2499 &quot;VBNET.ATG&quot; 
+out finallyStmt);
+		} else SynErr(235);
+		Expect(89);
+		Expect(176);
+
+#line  2503 &quot;VBNET.ATG&quot; 
+		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
+		
+	}
+
+	void WithStatement(
+#line  2467 &quot;VBNET.ATG&quot; 
+out Statement withStatement) {
+
+#line  2469 &quot;VBNET.ATG&quot; 
+		Statement blockStmt = null;
+		Expression expr = null;
+		
+		Expect(184);
+
+#line  2472 &quot;VBNET.ATG&quot; 
+		Point start = t.Location; 
+		Expr(
+#line  2473 &quot;VBNET.ATG&quot; 
+out expr);
+		EndOfStmt();
+
+#line  2475 &quot;VBNET.ATG&quot; 
+		withStatement = new WithStatement(expr);
+		withStatement.StartLocation = start;
+		withStatements.Push(withStatement);
+		
+		Block(
+#line  2479 &quot;VBNET.ATG&quot; 
+out blockStmt);
+
+#line  2481 &quot;VBNET.ATG&quot; 
+		((WithStatement)withStatement).Body = (BlockStatement)blockStmt;
+		withStatements.Pop();
+		
+		Expect(89);
+		Expect(184);
+
+#line  2485 &quot;VBNET.ATG&quot; 
+		withStatement.EndLocation = t.Location; 
+	}
+
+	void WhileOrUntil(
+#line  2460 &quot;VBNET.ATG&quot; 
+out ConditionType conditionType) {
+
+#line  2461 &quot;VBNET.ATG&quot; 
+		conditionType = ConditionType.None; 
+		if (la.kind == 183) {
+			lexer.NextToken();
+
+#line  2462 &quot;VBNET.ATG&quot; 
+			conditionType = ConditionType.While; 
+		} else if (la.kind == 179) {
+			lexer.NextToken();
+
+#line  2463 &quot;VBNET.ATG&quot; 
+			conditionType = ConditionType.Until; 
+		} else SynErr(236);
+	}
+
+	void LoopControlVariable(
+#line  2320 &quot;VBNET.ATG&quot; 
+out LoopControlVariableExpression loopExpr) {
+
+#line  2322 &quot;VBNET.ATG&quot; 
+		loopExpr = null;
+		//Expression expr = null;
+		TypeReference type = null;
+		ArrayList arrayModifiers = null;
+		string name;
+		
+		Qualident(
+#line  2328 &quot;VBNET.ATG&quot; 
+out name);
+		if (
+#line  2329 &quot;VBNET.ATG&quot; 
+IsRank()) {
+			ArrayTypeModifiers(
+#line  2329 &quot;VBNET.ATG&quot; 
+out arrayModifiers);
+		}
+		if (la.kind == 49) {
+			lexer.NextToken();
+			TypeName(
+#line  2330 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  2330 &quot;VBNET.ATG&quot; 
+			if (name.IndexOf('.') &gt; 0) { Error(&quot;No type def for 'for each' member indexer allowed.&quot;); } 
+		}
+
+#line  2332 &quot;VBNET.ATG&quot; 
+		if(type != null) {
+		if(type.RankSpecifier != null &amp;&amp; arrayModifiers != null) {
+			Error(&quot;array rank only allowed one time&quot;);
+		} else {
+			type.RankSpecifier = arrayModifiers;
+		}
+		} else {
+			type = new TypeReference(&quot;Integer&quot;, arrayModifiers);
+		}
+		loopExpr = new LoopControlVariableExpression(name, type);
+		
+	}
+
+	void CaseClauses(
+#line  2416 &quot;VBNET.ATG&quot; 
+out ArrayList caseClauses) {
+
+#line  2418 &quot;VBNET.ATG&quot; 
+		caseClauses = null;
+		CaseClause caseClause = null;
+		
+		CaseClause(
+#line  2421 &quot;VBNET.ATG&quot; 
+out caseClause);
+
+#line  2423 &quot;VBNET.ATG&quot; 
+		caseClauses = new ArrayList();
+		caseClauses.Add(caseClause);
+		
+		while (la.kind == 12) {
+			lexer.NextToken();
+			CaseClause(
+#line  2426 &quot;VBNET.ATG&quot; 
+out caseClause);
+
+#line  2426 &quot;VBNET.ATG&quot; 
+			caseClauses.Add(caseClause); 
+		}
+	}
+
+	void OnErrorStatement(
+#line  2346 &quot;VBNET.ATG&quot; 
+out OnErrorStatement stmt) {
+
+#line  2348 &quot;VBNET.ATG&quot; 
+		stmt = null;
+		GoToStatement goToStatement = null;
+		
+		Expect(136);
+		Expect(93);
+		if (
+#line  2354 &quot;VBNET.ATG&quot; 
+IsNegativeLabelName()) {
+			Expect(105);
+			Expect(15);
+			Expect(5);
+
+#line  2356 &quot;VBNET.ATG&quot; 
+			long intLabel = Int64.Parse(t.val);
+			if(intLabel != 1) {
+				Error(&quot;invalid label in on error statement.&quot;);
+			}
+			stmt = new OnErrorStatement(new GoToStatement((intLabel * -1).ToString()));
+			
+		} else if (la.kind == 105) {
+			GoToStatement(
+#line  2362 &quot;VBNET.ATG&quot; 
+out goToStatement);
+
+#line  2364 &quot;VBNET.ATG&quot; 
+			string val = goToStatement.LabelName;
+			
+			// if value is numeric, make sure that is 0
+			try {
+				long intLabel = Int64.Parse(val);
+				if(intLabel != 0) {
+					Error(&quot;invalid label in on error statement.&quot;);
+				}
+			} catch {
+			}
+			stmt = new OnErrorStatement(goToStatement);
+			
+		} else if (la.kind == 155) {
+			lexer.NextToken();
+			Expect(129);
+
+#line  2378 &quot;VBNET.ATG&quot; 
+			stmt = new OnErrorStatement(new ResumeStatement(true));
+			
+		} else SynErr(237);
+	}
+
+	void GoToStatement(
+#line  2384 &quot;VBNET.ATG&quot; 
+out GoToStatement goToStatement) {
+
+#line  2386 &quot;VBNET.ATG&quot; 
+		string label = String.Empty;
+		
+		Expect(105);
+		LabelName(
+#line  2389 &quot;VBNET.ATG&quot; 
+out label);
+
+#line  2391 &quot;VBNET.ATG&quot; 
+		goToStatement = new GoToStatement(label);
+		
+	}
+
+	void ResumeStatement(
+#line  2405 &quot;VBNET.ATG&quot; 
+out ResumeStatement resumeStatement) {
+
+#line  2407 &quot;VBNET.ATG&quot; 
+		resumeStatement = null;
+		string label = String.Empty;
+		
+		if (
+#line  2410 &quot;VBNET.ATG&quot; 
+IsResumeNext()) {
+			Expect(155);
+			Expect(129);
+
+#line  2411 &quot;VBNET.ATG&quot; 
+			resumeStatement = new ResumeStatement(true); 
+		} else if (la.kind == 155) {
+			lexer.NextToken();
+			if (StartOf(29)) {
+				LabelName(
+#line  2412 &quot;VBNET.ATG&quot; 
+out label);
+			}
+
+#line  2412 &quot;VBNET.ATG&quot; 
+			resumeStatement = new ResumeStatement(label); 
+		} else SynErr(238);
+	}
+
+	void CaseClause(
+#line  2430 &quot;VBNET.ATG&quot; 
+out CaseClause caseClause) {
+
+#line  2432 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		Expression sexpr = null;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		caseClause = null;
+		
+		if (la.kind == 87) {
+			lexer.NextToken();
+
+#line  2438 &quot;VBNET.ATG&quot; 
+			caseClause = new CaseClause(true); 
+		} else if (StartOf(30)) {
+			if (la.kind == 114) {
+				lexer.NextToken();
+			}
+			switch (la.kind) {
+			case 28: {
+				lexer.NextToken();
+
+#line  2442 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.LessThan; 
+				break;
+			}
+			case 27: {
+				lexer.NextToken();
+
+#line  2443 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.GreaterThan; 
+				break;
+			}
+			case 31: {
+				lexer.NextToken();
+
+#line  2444 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.LessThanOrEqual; 
+				break;
+			}
+			case 30: {
+				lexer.NextToken();
+
+#line  2445 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.GreaterThanOrEqual; 
+				break;
+			}
+			case 11: {
+				lexer.NextToken();
+
+#line  2446 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Equality; 
+				break;
+			}
+			case 29: {
+				lexer.NextToken();
+
+#line  2447 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.InEquality; 
+				break;
+			}
+			default: SynErr(239); break;
+			}
+			Expr(
+#line  2449 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2451 &quot;VBNET.ATG&quot; 
+			caseClause = new CaseClause(op, expr);
+			
+		} else if (StartOf(18)) {
+			Expr(
+#line  2453 &quot;VBNET.ATG&quot; 
+out expr);
+			if (la.kind == 174) {
+				lexer.NextToken();
+				Expr(
+#line  2453 &quot;VBNET.ATG&quot; 
+out sexpr);
+			}
+
+#line  2455 &quot;VBNET.ATG&quot; 
+			caseClause = new CaseClause(expr, sexpr);
+			
+		} else SynErr(240);
+	}
+
+	void CatchClauses(
+#line  2508 &quot;VBNET.ATG&quot; 
+out ArrayList catchClauses) {
+
+#line  2510 &quot;VBNET.ATG&quot; 
+		catchClauses = new ArrayList();
+		TypeReference type = null;
+		Statement blockStmt = null;
+		Expression expr = null;
+		string name = String.Empty;
+		
+		while (la.kind == 59) {
+			lexer.NextToken();
+			if (StartOf(9)) {
+				Identifier();
+
+#line  2518 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  2518 &quot;VBNET.ATG&quot; 
+out type);
+				}
+			}
+			if (la.kind == 182) {
+				lexer.NextToken();
+				Expr(
+#line  2519 &quot;VBNET.ATG&quot; 
+out expr);
+			}
+			EndOfStmt();
+			Block(
+#line  2521 &quot;VBNET.ATG&quot; 
+out blockStmt);
+
+#line  2522 &quot;VBNET.ATG&quot; 
+			catchClauses.Add(new CatchClause(type, name, blockStmt, expr)); 
+		}
+	}
+
+
+
+	public void Parse(Lexer lexer)
+	{
+		this.errors = lexer.Errors;
+		this.lexer = lexer;
+		errors.SynErr = new ErrorCodeProc(SynErr);
+		lexer.NextToken();
+		VBNET();
+
+	}
+
+	void SynErr(int line, int col, int errorNumber)
+	{
+		errors.count++; 
+		string s;
+		switch (errorNumber) {
+			case 0: s = &quot;EOF expected&quot;; break;
+			case 1: s = &quot;EOL expected&quot;; break;
+			case 2: s = &quot;ident expected&quot;; break;
+			case 3: s = &quot;LiteralString expected&quot;; break;
+			case 4: s = &quot;LiteralCharacter expected&quot;; break;
+			case 5: s = &quot;LiteralInteger expected&quot;; break;
+			case 6: s = &quot;LiteralDouble expected&quot;; break;
+			case 7: s = &quot;LiteralSingle expected&quot;; break;
+			case 8: s = &quot;LiteralDecimal expected&quot;; break;
+			case 9: s = &quot;LiteralDate expected&quot;; break;
+			case 10: s = &quot;\&quot;.\&quot; expected&quot;; break;
+			case 11: s = &quot;\&quot;=\&quot; expected&quot;; break;
+			case 12: s = &quot;\&quot;,\&quot; expected&quot;; break;
+			case 13: s = &quot;\&quot;:\&quot; expected&quot;; break;
+			case 14: s = &quot;\&quot;+\&quot; expected&quot;; break;
+			case 15: s = &quot;\&quot;-\&quot; expected&quot;; break;
+			case 16: s = &quot;\&quot;*\&quot; expected&quot;; break;
+			case 17: s = &quot;\&quot;/\&quot; expected&quot;; break;
+			case 18: s = &quot;\&quot;\\\\\&quot; expected&quot;; break;
+			case 19: s = &quot;\&quot;&amp;\&quot; expected&quot;; break;
+			case 20: s = &quot;\&quot;^\&quot; expected&quot;; break;
+			case 21: s = &quot;\&quot;{\&quot; expected&quot;; break;
+			case 22: s = &quot;\&quot;}\&quot; expected&quot;; break;
+			case 23: s = &quot;\&quot;[\&quot; expected&quot;; break;
+			case 24: s = &quot;\&quot;]\&quot; expected&quot;; break;
+			case 25: s = &quot;\&quot;(\&quot; expected&quot;; break;
+			case 26: s = &quot;\&quot;)\&quot; expected&quot;; break;
+			case 27: s = &quot;\&quot;&gt;\&quot; expected&quot;; break;
+			case 28: s = &quot;\&quot;&lt;\&quot; expected&quot;; break;
+			case 29: s = &quot;\&quot;&lt;&gt;\&quot; expected&quot;; break;
+			case 30: s = &quot;\&quot;&gt;=\&quot; expected&quot;; break;
+			case 31: s = &quot;\&quot;&lt;=\&quot; expected&quot;; break;
+			case 32: s = &quot;\&quot;&lt;&lt;\&quot; expected&quot;; break;
+			case 33: s = &quot;\&quot;&gt;&gt;\&quot; expected&quot;; break;
+			case 34: s = &quot;\&quot;+=\&quot; expected&quot;; break;
+			case 35: s = &quot;\&quot;^=\&quot; expected&quot;; break;
+			case 36: s = &quot;\&quot;-=\&quot; expected&quot;; break;
+			case 37: s = &quot;\&quot;*=\&quot; expected&quot;; break;
+			case 38: s = &quot;\&quot;/=\&quot; expected&quot;; break;
+			case 39: s = &quot;\&quot;\\\\=\&quot; expected&quot;; break;
+			case 40: s = &quot;\&quot;&lt;&lt;=\&quot; expected&quot;; break;
+			case 41: s = &quot;\&quot;&gt;&gt;=\&quot; expected&quot;; break;
+			case 42: s = &quot;\&quot;&amp;=\&quot; expected&quot;; break;
+			case 43: s = &quot;\&quot;AddHandler\&quot; expected&quot;; break;
+			case 44: s = &quot;\&quot;AddressOf\&quot; expected&quot;; break;
+			case 45: s = &quot;\&quot;Alias\&quot; expected&quot;; break;
+			case 46: s = &quot;\&quot;And\&quot; expected&quot;; break;
+			case 47: s = &quot;\&quot;AndAlso\&quot; expected&quot;; break;
+			case 48: s = &quot;\&quot;Ansi\&quot; expected&quot;; break;
+			case 49: s = &quot;\&quot;As\&quot; expected&quot;; break;
+			case 50: s = &quot;\&quot;Assembly\&quot; expected&quot;; break;
+			case 51: s = &quot;\&quot;Auto\&quot; expected&quot;; break;
+			case 52: s = &quot;\&quot;Binary\&quot; expected&quot;; break;
+			case 53: s = &quot;\&quot;Boolean\&quot; expected&quot;; break;
+			case 54: s = &quot;\&quot;ByRef\&quot; expected&quot;; break;
+			case 55: s = &quot;\&quot;Byte\&quot; expected&quot;; break;
+			case 56: s = &quot;\&quot;ByVal\&quot; expected&quot;; break;
+			case 57: s = &quot;\&quot;Call\&quot; expected&quot;; break;
+			case 58: s = &quot;\&quot;Case\&quot; expected&quot;; break;
+			case 59: s = &quot;\&quot;Catch\&quot; expected&quot;; break;
+			case 60: s = &quot;\&quot;CBool\&quot; expected&quot;; break;
+			case 61: s = &quot;\&quot;CByte\&quot; expected&quot;; break;
+			case 62: s = &quot;\&quot;CChar\&quot; expected&quot;; break;
+			case 63: s = &quot;\&quot;CDate\&quot; expected&quot;; break;
+			case 64: s = &quot;\&quot;CDbl\&quot; expected&quot;; break;
+			case 65: s = &quot;\&quot;CDec\&quot; expected&quot;; break;
+			case 66: s = &quot;\&quot;Char\&quot; expected&quot;; break;
+			case 67: s = &quot;\&quot;CInt\&quot; expected&quot;; break;
+			case 68: s = &quot;\&quot;Class\&quot; expected&quot;; break;
+			case 69: s = &quot;\&quot;CLng\&quot; expected&quot;; break;
+			case 70: s = &quot;\&quot;CObj\&quot; expected&quot;; break;
+			case 71: s = &quot;\&quot;Compare\&quot; expected&quot;; break;
+			case 72: s = &quot;\&quot;Const\&quot; expected&quot;; break;
+			case 73: s = &quot;\&quot;CShort\&quot; expected&quot;; break;
+			case 74: s = &quot;\&quot;CSng\&quot; expected&quot;; break;
+			case 75: s = &quot;\&quot;CStr\&quot; expected&quot;; break;
+			case 76: s = &quot;\&quot;CType\&quot; expected&quot;; break;
+			case 77: s = &quot;\&quot;Date\&quot; expected&quot;; break;
+			case 78: s = &quot;\&quot;Decimal\&quot; expected&quot;; break;
+			case 79: s = &quot;\&quot;Declare\&quot; expected&quot;; break;
+			case 80: s = &quot;\&quot;Default\&quot; expected&quot;; break;
+			case 81: s = &quot;\&quot;Delegate\&quot; expected&quot;; break;
+			case 82: s = &quot;\&quot;Dim\&quot; expected&quot;; break;
+			case 83: s = &quot;\&quot;DirectCast\&quot; expected&quot;; break;
+			case 84: s = &quot;\&quot;Do\&quot; expected&quot;; break;
+			case 85: s = &quot;\&quot;Double\&quot; expected&quot;; break;
+			case 86: s = &quot;\&quot;Each\&quot; expected&quot;; break;
+			case 87: s = &quot;\&quot;Else\&quot; expected&quot;; break;
+			case 88: s = &quot;\&quot;ElseIf\&quot; expected&quot;; break;
+			case 89: s = &quot;\&quot;End\&quot; expected&quot;; break;
+			case 90: s = &quot;\&quot;EndIf\&quot; expected&quot;; break;
+			case 91: s = &quot;\&quot;Enum\&quot; expected&quot;; break;
+			case 92: s = &quot;\&quot;Erase\&quot; expected&quot;; break;
+			case 93: s = &quot;\&quot;Error\&quot; expected&quot;; break;
+			case 94: s = &quot;\&quot;Event\&quot; expected&quot;; break;
+			case 95: s = &quot;\&quot;Exit\&quot; expected&quot;; break;
+			case 96: s = &quot;\&quot;Explicit\&quot; expected&quot;; break;
+			case 97: s = &quot;\&quot;False\&quot; expected&quot;; break;
+			case 98: s = &quot;\&quot;Finally\&quot; expected&quot;; break;
+			case 99: s = &quot;\&quot;For\&quot; expected&quot;; break;
+			case 100: s = &quot;\&quot;Friend\&quot; expected&quot;; break;
+			case 101: s = &quot;\&quot;Function\&quot; expected&quot;; break;
+			case 102: s = &quot;\&quot;Get\&quot; expected&quot;; break;
+			case 103: s = &quot;\&quot;GetType\&quot; expected&quot;; break;
+			case 104: s = &quot;\&quot;GoSub\&quot; expected&quot;; break;
+			case 105: s = &quot;\&quot;GoTo\&quot; expected&quot;; break;
+			case 106: s = &quot;\&quot;Handles\&quot; expected&quot;; break;
+			case 107: s = &quot;\&quot;If\&quot; expected&quot;; break;
+			case 108: s = &quot;\&quot;Implements\&quot; expected&quot;; break;
+			case 109: s = &quot;\&quot;Imports\&quot; expected&quot;; break;
+			case 110: s = &quot;\&quot;In\&quot; expected&quot;; break;
+			case 111: s = &quot;\&quot;Inherits\&quot; expected&quot;; break;
+			case 112: s = &quot;\&quot;Integer\&quot; expected&quot;; break;
+			case 113: s = &quot;\&quot;Interface\&quot; expected&quot;; break;
+			case 114: s = &quot;\&quot;Is\&quot; expected&quot;; break;
+			case 115: s = &quot;\&quot;Let\&quot; expected&quot;; break;
+			case 116: s = &quot;\&quot;Lib\&quot; expected&quot;; break;
+			case 117: s = &quot;\&quot;Like\&quot; expected&quot;; break;
+			case 118: s = &quot;\&quot;Long\&quot; expected&quot;; break;
+			case 119: s = &quot;\&quot;Loop\&quot; expected&quot;; break;
+			case 120: s = &quot;\&quot;Me\&quot; expected&quot;; break;
+			case 121: s = &quot;\&quot;Mod\&quot; expected&quot;; break;
+			case 122: s = &quot;\&quot;Module\&quot; expected&quot;; break;
+			case 123: s = &quot;\&quot;MustInherit\&quot; expected&quot;; break;
+			case 124: s = &quot;\&quot;MustOverride\&quot; expected&quot;; break;
+			case 125: s = &quot;\&quot;MyBase\&quot; expected&quot;; break;
+			case 126: s = &quot;\&quot;MyClass\&quot; expected&quot;; break;
+			case 127: s = &quot;\&quot;Namespace\&quot; expected&quot;; break;
+			case 128: s = &quot;\&quot;New\&quot; expected&quot;; break;
+			case 129: s = &quot;\&quot;Next\&quot; expected&quot;; break;
+			case 130: s = &quot;\&quot;Not\&quot; expected&quot;; break;
+			case 131: s = &quot;\&quot;Nothing\&quot; expected&quot;; break;
+			case 132: s = &quot;\&quot;NotInheritable\&quot; expected&quot;; break;
+			case 133: s = &quot;\&quot;NotOverridable\&quot; expected&quot;; break;
+			case 134: s = &quot;\&quot;Object\&quot; expected&quot;; break;
+			case 135: s = &quot;\&quot;Off\&quot; expected&quot;; break;
+			case 136: s = &quot;\&quot;On\&quot; expected&quot;; break;
+			case 137: s = &quot;\&quot;Option\&quot; expected&quot;; break;
+			case 138: s = &quot;\&quot;Optional\&quot; expected&quot;; break;
+			case 139: s = &quot;\&quot;Or\&quot; expected&quot;; break;
+			case 140: s = &quot;\&quot;OrElse\&quot; expected&quot;; break;
+			case 141: s = &quot;\&quot;Overloads\&quot; expected&quot;; break;
+			case 142: s = &quot;\&quot;Overridable\&quot; expected&quot;; break;
+			case 143: s = &quot;\&quot;Override\&quot; expected&quot;; break;
+			case 144: s = &quot;\&quot;Overrides\&quot; expected&quot;; break;
+			case 145: s = &quot;\&quot;ParamArray\&quot; expected&quot;; break;
+			case 146: s = &quot;\&quot;Preserve\&quot; expected&quot;; break;
+			case 147: s = &quot;\&quot;Private\&quot; expected&quot;; break;
+			case 148: s = &quot;\&quot;Property\&quot; expected&quot;; break;
+			case 149: s = &quot;\&quot;Protected\&quot; expected&quot;; break;
+			case 150: s = &quot;\&quot;Public\&quot; expected&quot;; break;
+			case 151: s = &quot;\&quot;RaiseEvent\&quot; expected&quot;; break;
+			case 152: s = &quot;\&quot;ReadOnly\&quot; expected&quot;; break;
+			case 153: s = &quot;\&quot;ReDim\&quot; expected&quot;; break;
+			case 154: s = &quot;\&quot;RemoveHandler\&quot; expected&quot;; break;
+			case 155: s = &quot;\&quot;Resume\&quot; expected&quot;; break;
+			case 156: s = &quot;\&quot;Return\&quot; expected&quot;; break;
+			case 157: s = &quot;\&quot;Select\&quot; expected&quot;; break;
+			case 158: s = &quot;\&quot;Set\&quot; expected&quot;; break;
+			case 159: s = &quot;\&quot;Shadows\&quot; expected&quot;; break;
+			case 160: s = &quot;\&quot;Shared\&quot; expected&quot;; break;
+			case 161: s = &quot;\&quot;Short\&quot; expected&quot;; break;
+			case 162: s = &quot;\&quot;Single\&quot; expected&quot;; break;
+			case 163: s = &quot;\&quot;Static\&quot; expected&quot;; break;
+			case 164: s = &quot;\&quot;Step\&quot; expected&quot;; break;
+			case 165: s = &quot;\&quot;Stop\&quot; expected&quot;; break;
+			case 166: s = &quot;\&quot;Strict\&quot; expected&quot;; break;
+			case 167: s = &quot;\&quot;String\&quot; expected&quot;; break;
+			case 168: s = &quot;\&quot;Structure\&quot; expected&quot;; break;
+			case 169: s = &quot;\&quot;Sub\&quot; expected&quot;; break;
+			case 170: s = &quot;\&quot;SyncLock\&quot; expected&quot;; break;
+			case 171: s = &quot;\&quot;Text\&quot; expected&quot;; break;
+			case 172: s = &quot;\&quot;Then\&quot; expected&quot;; break;
+			case 173: s = &quot;\&quot;Throw\&quot; expected&quot;; break;
+			case 174: s = &quot;\&quot;To\&quot; expected&quot;; break;
+			case 175: s = &quot;\&quot;True\&quot; expected&quot;; break;
+			case 176: s = &quot;\&quot;Try\&quot; expected&quot;; break;
+			case 177: s = &quot;\&quot;TypeOf\&quot; expected&quot;; break;
+			case 178: s = &quot;\&quot;Unicode\&quot; expected&quot;; break;
+			case 179: s = &quot;\&quot;Until\&quot; expected&quot;; break;
+			case 180: s = &quot;\&quot;Variant\&quot; expected&quot;; break;
+			case 181: s = &quot;\&quot;Wend\&quot; expected&quot;; break;
+			case 182: s = &quot;\&quot;When\&quot; expected&quot;; break;
+			case 183: s = &quot;\&quot;While\&quot; expected&quot;; break;
+			case 184: s = &quot;\&quot;With\&quot; expected&quot;; break;
+			case 185: s = &quot;\&quot;WithEvents\&quot; expected&quot;; break;
+			case 186: s = &quot;\&quot;WriteOnly\&quot; expected&quot;; break;
+			case 187: s = &quot;\&quot;Xor\&quot; expected&quot;; break;
+			case 188: s = &quot;??? expected&quot;; break;
+			case 189: s = &quot;invalid OptionStmt&quot;; break;
+			case 190: s = &quot;invalid OptionStmt&quot;; break;
+			case 191: s = &quot;invalid GlobalAttributeSection&quot;; break;
+			case 192: s = &quot;invalid NamespaceMemberDecl&quot;; break;
+			case 193: s = &quot;invalid OptionValue&quot;; break;
+			case 194: s = &quot;invalid EndOfStmt&quot;; break;
+			case 195: s = &quot;invalid Identifier&quot;; break;
+			case 196: s = &quot;invalid TypeModifier&quot;; break;
+			case 197: s = &quot;invalid NonModuleDeclaration&quot;; break;
+			case 198: s = &quot;invalid NonModuleDeclaration&quot;; break;
+			case 199: s = &quot;invalid PrimitiveTypeName&quot;; break;
+			case 200: s = &quot;invalid MemberModifier&quot;; break;
+			case 201: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 202: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 203: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 204: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 205: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 206: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 207: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 208: s = &quot;invalid InterfaceMemberDecl&quot;; break;
+			case 209: s = &quot;invalid InterfaceMemberDecl&quot;; break;
+			case 210: s = &quot;invalid Charset&quot;; break;
+			case 211: s = &quot;invalid VariableDeclarator&quot;; break;
+			case 212: s = &quot;invalid AccessorDecls&quot;; break;
+			case 213: s = &quot;invalid VariableInitializer&quot;; break;
+			case 214: s = &quot;invalid EventMemberSpecifier&quot;; break;
+			case 215: s = &quot;invalid EventMemberSpecifier&quot;; break;
+			case 216: s = &quot;invalid AssignmentOperator&quot;; break;
+			case 217: s = &quot;invalid SimpleExpr&quot;; break;
+			case 218: s = &quot;invalid SimpleExpr&quot;; break;
+			case 219: s = &quot;invalid SimpleExpr&quot;; break;
+			case 220: s = &quot;invalid IdentifierOrKeyword&quot;; break;
+			case 221: s = &quot;invalid CastTarget&quot;; break;
+			case 222: s = &quot;invalid Argument&quot;; break;
+			case 223: s = &quot;invalid RelationalExpr&quot;; break;
+			case 224: s = &quot;invalid NonArrayTypeName&quot;; break;
+			case 225: s = &quot;invalid AttributeArguments&quot;; break;
+			case 226: s = &quot;invalid ParameterModifier&quot;; break;
+			case 227: s = &quot;invalid Statement&quot;; break;
+			case 228: s = &quot;invalid LabelName&quot;; break;
+			case 229: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 230: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 231: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 232: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 233: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 234: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 235: s = &quot;invalid TryStatement&quot;; break;
+			case 236: s = &quot;invalid WhileOrUntil&quot;; break;
+			case 237: s = &quot;invalid OnErrorStatement&quot;; break;
+			case 238: s = &quot;invalid ResumeStatement&quot;; break;
+			case 239: s = &quot;invalid CaseClause&quot;; break;
+			case 240: s = &quot;invalid CaseClause&quot;; break;
+
+			default: s = &quot;error &quot; + errorNumber; break;
+		}
+		errors.Error(line, col, s);
+	}
+
+	static bool[,] set = {
+	{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, T,x,x,x, x,x,x,T, T,T,T,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, x,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,T,x,x, x,T,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,T,x,x, x,x,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, T,x,T,T, T,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, T,T,x,x, x,x,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,x, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x}
+
+	};
+} // end Parser
+
+}
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,120 @@
+using System;
+using System.Reflection;
+
+--&gt;namespace
+
+--&gt;tokens
+
+public class Parser
+{
+--&gt;constants
+	const  bool   T            = true;
+	const  bool   x            = false;
+	const  int    minErrDist   = 2;
+	const  string errMsgFormat = &quot;-- line {0} col {1}: {2}&quot;;  // 0=line, 1=column, 2=text
+	int    errDist             = minErrDist;
+	Errors errors;
+	Lexer  lexer;
+
+	public Errors Errors {
+		get {
+			return errors;
+		}
+	}
+
+--&gt;declarations
+
+/*
+--&gt;pragmas
+*/
+	void SynErr(int n)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.SynErr(lexer.LookAhead.line, lexer.LookAhead.col, n);
+		}
+		errDist = 0;
+	}
+
+	public void SemErr(string msg)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.Error(lexer.Token.line, lexer.Token.col, msg);
+		}
+		errDist = 0;
+	}
+	
+	void Expect(int n)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+		}
+	}
+	
+	bool StartOf(int s)
+	{
+		return set[s, lexer.LookAhead.kind];
+	}
+	
+	void ExpectWeak(int n, int follow)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+			while (!StartOf(follow)) {
+				lexer.NextToken();
+			}
+		}
+	}
+	
+	bool WeakSeparator(int n, int syFol, int repFol)
+	{
+		bool[] s = new bool[maxT + 1];
+		
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+			return true; 
+		} else if (StartOf(repFol)) {
+			return false;
+		} else {
+			for (int i = 0; i &lt;= maxT; i++) {
+				s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
+			}
+			SynErr(n);
+			while (!s[lexer.LookAhead.kind]) {
+				lexer.NextToken();
+			}
+			return StartOf(syFol);
+		}
+	}
+	
+--&gt;productions
+
+	public void Parse(Lexer lexer)
+	{
+		this.errors = lexer.Errors;
+		this.lexer = lexer;
+		errors.SynErr = new ErrorCodeProc(SynErr);
+		lexer.NextToken();
+--&gt;parseRoot
+	}
+
+	void SynErr(int line, int col, int errorNumber)
+	{
+		errors.count++; 
+		string s;
+		switch (errorNumber) {
+--&gt;errors
+			default: s = &quot;error &quot; + errorNumber; break;
+		}
+		errors.Error(line, col, s);
+	}
+
+	static bool[,] set = {
+--&gt;initialization
+	};
+} // end Parser
+
+$$$

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,222 @@
+using System;
+using System.Drawing;
+using System.IO;
+using System.Collections;
+using System.Text;
+
+--&gt;namespace
+
+public class Token {
+	public int kind;    // token kind
+	public int pos;     // token position in the source text (starting at 0)
+	public int col;     // token column (starting at 0)
+	public int line;    // token line (starting at 1)
+	public string val;  // token value
+	public Token next;  // AW 2003-03-07 Tokens are kept in linked list
+	
+	public Point Location {
+		get {
+			return new Point(line, col);
+		}
+	}
+
+	public Token () { }
+	public Token (int kind) { this.kind = kind; }
+}
+
+public class Buffer {
+	public const int eof = '\uffff';
+
+	static byte[] buf;
+	static int bufLen;
+	static int pos;
+	
+	public static void Fill (string fileName) {
+		FileStream s = null;
+		try {
+			s = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
+			Fill(s);
+		} catch (IOException) {
+			Console.WriteLine(&quot;--- Cannot open file {0}&quot;, fileName);
+			System.Environment.Exit(0);
+		} finally {
+			if (s != null) s.Close();
+		}
+	}
+	
+	public static void Fill (Stream s) {
+		bufLen = (int) s.Length;
+		buf = new byte[bufLen];
+		s.Read(buf, 0, bufLen); 
+		pos = 0;
+	}
+		
+	public static int Read () {
+		if (pos &lt; bufLen) return buf[pos++];
+		else return 0;
+	}
+
+	public static int Peek () {
+		if (pos &lt; bufLen) return buf[pos];
+		else return 0;
+	}
+	
+	/* AW 2003-03-10 moved this from ParserGen.cs */
+	public static string GetString (int beg, int end) {
+		StringBuilder s = new StringBuilder(64);
+		int oldPos = Buffer.Pos;
+		Buffer.Pos = beg;
+		while (beg &lt; end) { s.Append((char)Buffer.Read()); beg++; }
+		Buffer.Pos = oldPos;
+		return s.ToString();
+	}
+
+	public static int Pos {
+		get { return pos; }
+		set {
+			if (value &lt; 0) pos = 0; 
+			else if (value &gt;= bufLen) pos = bufLen; 
+			else pos = value;
+		}
+	}
+}
+
+public class Scanner {
+	const char EOF = '\0';
+	const char EOL = '\n';
+	const char CR  = '\n';
+
+--&gt;constants
+	
+--&gt;declarations
+
+	static Token t;          // current token
+	static char ch;          // current input character
+	static int pos;          // column number of current character
+	static int line;         // line number of current character
+	static int lineStart;    // start position of current line
+	static int oldEols;    // EOLs that appeared in a comment;
+	static BitArray ignore;  // set of characters to be ignored by the scanner
+
+	/* ML ----- begin */
+	static Token tokens;  // the complete input token stream
+	static Token pt;      // current peek token
+	
+	static int peekCount = 0;
+	
+	public static int PeekCount { get { return peekCount; } }
+	
+	static void Init()
+	{
+		pos = -1; line = 1; lineStart = 0;
+		oldEols = 0;
+		NextCh();
+--&gt;initialization
+
+		/* AW 2003-03-07 fill token list */
+		tokens = new Token();  // first token is a dummy
+		Token node = tokens;
+		do {
+			node.next = NextToken();
+			node = node.next;
+		} while (node.kind != 0);	/* AW: 0 =&gt; EOF */
+		t = pt = tokens;
+	}
+
+	public static void Init(String fileName) {
+		Buffer.Fill(fileName);
+		Init();
+	}
+	
+	public static void Init(Stream s) {
+		Buffer.Fill(s);
+		Init();
+	}
+
+	static void NextCh() {
+		if (oldEols &gt; 0) { ch = EOL; oldEols--; } 
+		else {
+			ch = (char)Buffer.Read(); pos++;
+			// replace isolated '\r' by '\n' in order to make
+			// eol handling uniform across Windows, Unix and Mac
+			if (ch == '\r' &amp;&amp; Buffer.Peek() != '\n') ch = EOL;
+			else if (ch &gt; '\u007f') ch = '?';
+			if (ch == EOL) { line++; lineStart = pos + 1; }
+		}
+	}
+	
+--&gt;comment
+	
+	static void CheckLiteral() {
+		switch (t.val) {
+--&gt;literals
+		}
+	}
+
+	/* AW Scan() renamed to NextToken() */
+	static Token NextToken() {
+		while (ignore[ch]) NextCh();
+--&gt;scan1
+		t = new Token();
+		t.pos = pos; t.col = pos - lineStart + 1; t.line = line; 
+		int state = start[ch];
+		StringBuilder buf = new StringBuilder(16);
+		buf.Append(ch); NextCh();
+		
+		switch (state) {
+			case 0: { t.kind = noSym; goto done; }  // NextCh already done
+--&gt;scan2
+		}
+		done: 
+		t.val = buf.ToString();
+		return t;
+	}
+	
+	/* AW 2003-03-07 get the next token, move on and synch peek token with current */
+	public static Token Scan () {
+		t = pt = t.next;
+		return t;
+	}
+
+	/* AW 2003-03-07 get the next token, ignore pragmas */
+	public static Token Peek () {
+		do {                      // skip pragmas while peeking
+			pt = pt.next;
+		} while (pt != null &amp;&amp; pt.kind &gt; maxT);
+		return pt;
+	}
+	
+	/* AW 2003-03-11 to make sure peek start at current scan position */
+	public static void StartPeek () { pt = t; }
+} // end Scanner
+
+
+public delegate void ErrorCodeProc (int line, int col, int n);
+public delegate void ErrorMsgProc (int line, int col, string msg);
+
+public class Errors {
+	public static int count = 0;                                               // number of errors detected
+	public static ErrorCodeProc SynErr = new ErrorCodeProc(DefaultCodeError);  // syntactic errors
+	public static ErrorCodeProc SemErr = new ErrorCodeProc(DefaultCodeError);  // semantic errors
+	public static ErrorMsgProc Error = new ErrorMsgProc(DefaultMsgError);      // user defined string based errors
+	public static StringBuilder errorText = new StringBuilder();
+	
+	public static void Exception (string s) {
+		Console.WriteLine(s); 
+		System.Environment.Exit(0);
+	}
+
+	static void DefaultCodeError (int line, int col, int n) {
+		errorText.Append(String.Format(&quot;-- line {0} col {1}: error {2}&quot;, line, col, n));
+		errorText.Append(&quot;\n&quot;);
+		count++;
+	}
+
+	static void DefaultMsgError (int line, int col, string s) {
+		errorText.Append(String.Format(&quot;-- line {0} col {1}: {2}&quot;, line, col, s));
+		errorText.Append(&quot;\n&quot;);
+		count++;
+	}
+} // Errors
+
+$$$

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,2747 @@
+using System.Drawing;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+COMPILER VBNET
+
+private string assemblyName = null;
+public CompilationUnit compilationUnit;
+private ArrayList importedNamespaces = null;
+private Stack withStatements;
+private bool isLabel = false;
+private LabelStatement labelStatement = null;
+
+public string ContainingAssembly
+{
+	set { assemblyName = value; }
+}
+
+Token t
+{
+	get {
+		return lexer.Token;
+	}
+}
+Token la
+{
+	get {
+		return lexer.LookAhead;
+	}
+}
+
+void updateLabelStatement(Statement stmt)
+{
+	if(isLabel) {
+		labelStatement.EmbeddedStatement = stmt;
+		isLabel = false;
+	} else {
+		compilationUnit.AddChild(stmt);
+	}
+}
+
+/* Return the n-th token after the current lookahead token */
+void StartPeek()
+{
+	lexer.StartPeek();
+}
+
+Token Peek()
+{
+	return lexer.Peek();
+}
+
+Token Peek (int n)
+{
+	lexer.StartPeek();
+	Token x = la;
+	while (n &gt; 0) {
+		x = lexer.Peek();
+		n--;
+	}
+	return x;
+}
+
+public void Error(string s)
+{
+	if (errDist &gt;= minErrDist) {
+		errors.Error(la.line, la.col, s);
+	}
+	errDist = 0;
+}
+
+public Expression ParseExpression(Lexer lexer)
+{
+	this.errors = lexer.Errors;
+	this.lexer = lexer;
+	errors.SynErr = new ErrorCodeProc(SynErr);
+	lexer.NextToken();
+	Expression expr;
+	Expr(out expr);
+	return expr;
+}
+
+bool IsEndStmtAhead()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.End &amp;&amp; (peek == Tokens.EOL || peek == Tokens.Colon);
+}
+
+bool IsNotClosingParenthesis() {
+	return la.kind != Tokens.CloseParenthesis;
+}
+
+/*
+	True, if ident is followed by &quot;=&quot;
+*/
+bool IdentAndAsgn () {
+	if(la.kind == Tokens.Identifier) {
+		if(Peek(1).kind == Tokens.Assign) return true;
+		if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
+	}
+	return false;
+}
+
+/*
+	True, if ident is followed by &quot;=&quot; or by &quot;:&quot; and &quot;=&quot;
+*/
+bool IsNamedAssign() {
+//	if(Peek(1).kind == Tokens.Assign) return true; // removed: not in the lang spec
+	if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
+	return false;
+}
+
+bool IsObjectCreation() {
+	return la.kind == Tokens.As &amp;&amp; Peek(1).kind == Tokens.New;
+}
+
+/*
+	True, if &quot;&lt;&quot; is followed by the ident &quot;assembly&quot; or &quot;module&quot;
+*/
+bool IsGlobalAttrTarget () {
+	Token pt = Peek(1);
+	return la.kind == Tokens.LessThan &amp;&amp; ( pt.val.ToLower() == &quot;assembly&quot; || pt.val.ToLower() == &quot;module&quot;);
+}
+
+/*
+	True if the next token is a &quot;(&quot; and is followed by &quot;,&quot; or &quot;)&quot;
+*/
+bool IsRank()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.OpenParenthesis
+						&amp;&amp; (peek == Tokens.Comma || peek == Tokens.CloseParenthesis);
+}
+
+bool IsDims()
+{
+	int peek = Peek(1).kind;
+	int peek_n = Peek(2).kind;
+	return la.kind == Tokens.OpenParenthesis
+						&amp;&amp; (peek == Tokens.LiteralInteger &amp;&amp; peek_n == Tokens.CloseParenthesis);
+}
+
+bool IsSize()
+{
+	return la.kind == Tokens.OpenParenthesis;
+}
+
+/*
+	True, if the comma is not a trailing one,
+	like the last one in: a, b, c,
+*/
+bool NotFinalComma() {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Comma &amp;&amp;
+		   peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
+}
+
+/*
+	True, if the next token is &quot;Else&quot; and this one
+	if followed by &quot;If&quot;
+*/
+bool IsElseIf()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Else &amp;&amp; peek == Tokens.If;
+}
+
+/*
+	True if the next token is goto and this one is
+	followed by minus (&quot;-&quot;) (this is allowd in in
+	error clauses)
+*/
+bool IsNegativeLabelName()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.GoTo &amp;&amp; peek == Tokens.Minus;
+}
+
+/*
+	True if the next statement is a &quot;Resume next&quot; statement
+*/
+bool IsResumeNext()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Resume &amp;&amp; peek == Tokens.Next;
+}
+
+/*
+	True, if ident/literal integer is followed by &quot;:&quot;
+*/
+bool IsLabel()
+{
+	return (la.kind == Tokens.Identifier || la.kind == Tokens.LiteralInteger)
+			&amp;&amp; Peek(1).kind == Tokens.Colon;
+}
+
+bool IsNotStatementSeparator()
+{
+	return la.kind == Tokens.Colon &amp;&amp; Peek(1).kind == Tokens.EOL;
+}
+
+bool IsAssignment ()
+{
+	return IdentAndAsgn();
+}
+
+bool IsMustOverride(Modifiers m)
+{
+	return m.Contains(Modifier.MustOverride);
+}
+
+/*
+	True, if lookahead is a local attribute target specifier,
+	i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,
+	&quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;
+*/
+bool IsLocalAttrTarget() {
+	// TODO
+	return false;
+}
+
+TOKENS
+	/*----- terminal classes -----*/
+	/* EOF is 0 */
+	EOL
+	ident
+	LiteralString
+	LiteralCharacter
+	LiteralInteger
+	LiteralDouble
+	LiteralSingle
+	LiteralDecimal
+	LiteralDate
+	
+	/*----- special character -----*/
+	&quot;.&quot;
+	&quot;=&quot;
+	&quot;,&quot;
+	&quot;:&quot;
+	&quot;+&quot;
+	&quot;-&quot;
+	&quot;*&quot;
+	&quot;/&quot;
+	&quot;\\&quot;
+	&quot;&amp;&quot;
+	&quot;^&quot;
+	
+	&quot;{&quot;
+	&quot;}&quot;
+	
+	&quot;[&quot;
+	&quot;]&quot;
+	
+	&quot;(&quot;
+	&quot;)&quot;
+	
+	&quot;&gt;&quot;
+	&quot;&lt;&quot;
+	
+	&quot;&lt;&gt;&quot;
+	&quot;&gt;=&quot;
+	&quot;&lt;=&quot;
+	
+	&quot;&lt;&lt;&quot;
+	&quot;&gt;&gt;&quot;
+	
+	&quot;+=&quot;
+	&quot;^=&quot;
+	&quot;-=&quot;
+	&quot;*=&quot;
+	&quot;/=&quot;
+	&quot;\\=&quot;
+	&quot;&lt;&lt;=&quot;
+	&quot;&gt;&gt;=&quot;
+	&quot;&amp;=&quot;
+	
+	/*----- VB.NET keywords -----*/
+	&quot;AddHandler&quot;
+	&quot;AddressOf&quot;
+	&quot;Alias&quot;
+	&quot;And&quot;
+	&quot;AndAlso&quot;
+	&quot;Ansi&quot;
+	&quot;As&quot;
+	&quot;Assembly&quot;
+	&quot;Auto&quot;
+	&quot;Binary&quot;
+	&quot;Boolean&quot;
+	&quot;ByRef&quot;
+	&quot;Byte&quot;
+	&quot;ByVal&quot;
+	&quot;Call&quot;
+	&quot;Case&quot;
+	&quot;Catch&quot;
+	&quot;CBool&quot;
+	&quot;CByte&quot;
+	&quot;CChar&quot;
+	&quot;CDate&quot;
+	&quot;CDbl&quot;
+	&quot;CDec&quot;
+	&quot;Char&quot;
+	&quot;CInt&quot;
+	&quot;Class&quot;
+	&quot;CLng&quot;
+	&quot;CObj&quot;
+	&quot;Compare&quot;
+	&quot;Const&quot;
+	&quot;CShort&quot;
+	&quot;CSng&quot;
+	&quot;CStr&quot;
+	&quot;CType&quot;
+	&quot;Date&quot;
+	&quot;Decimal&quot;
+	&quot;Declare&quot;
+	&quot;Default&quot;
+	&quot;Delegate&quot;
+	&quot;Dim&quot;
+	&quot;DirectCast&quot;
+	&quot;Do&quot;
+	&quot;Double&quot;
+	&quot;Each&quot;
+	&quot;Else&quot;
+	&quot;ElseIf&quot;
+	&quot;End&quot;
+	&quot;EndIf&quot;
+	&quot;Enum&quot;
+	&quot;Erase&quot;
+	&quot;Error&quot;
+	&quot;Event&quot;
+	&quot;Exit&quot;
+	&quot;Explicit&quot;
+	&quot;False&quot;
+	&quot;Finally&quot;
+	&quot;For&quot;
+	&quot;Friend&quot;
+	&quot;Function&quot;
+	&quot;Get&quot;
+	&quot;GetType&quot;
+	&quot;GoSub&quot;
+	&quot;GoTo&quot;
+	&quot;Handles&quot;
+	&quot;If&quot;
+	&quot;Implements&quot;
+	&quot;Imports&quot;
+	&quot;In&quot;
+	&quot;Inherits&quot;
+	&quot;Integer&quot;
+	&quot;Interface&quot;
+	&quot;Is&quot;
+	&quot;Let&quot;
+	&quot;Lib&quot;
+	&quot;Like&quot;
+	&quot;Long&quot;
+	&quot;Loop&quot;
+	&quot;Me&quot;
+	&quot;Mod&quot;
+	&quot;Module&quot;
+	&quot;MustInherit&quot;
+	&quot;MustOverride&quot;
+	&quot;MyBase&quot;
+	&quot;MyClass&quot;
+	&quot;Namespace&quot;
+	&quot;New&quot;
+	&quot;Next&quot;
+	&quot;Not&quot;
+	&quot;Nothing&quot;
+	&quot;NotInheritable&quot;
+	&quot;NotOverridable&quot;
+	&quot;Object&quot;
+	&quot;Off&quot;
+	&quot;On&quot;
+	&quot;Option&quot;
+	&quot;Optional&quot;
+	&quot;Or&quot;
+	&quot;OrElse&quot;
+	&quot;Overloads&quot;
+	&quot;Overridable&quot;
+	&quot;Override&quot;
+	&quot;Overrides&quot;
+	&quot;ParamArray&quot;
+	&quot;Preserve&quot;
+	&quot;Private&quot;
+	&quot;Property&quot;
+	&quot;Protected&quot;
+	&quot;Public&quot;
+	&quot;RaiseEvent&quot;
+	&quot;ReadOnly&quot;
+	&quot;ReDim&quot;
+	&quot;RemoveHandler&quot;
+	&quot;Resume&quot;
+	&quot;Return&quot;
+	&quot;Select&quot;
+	&quot;Set&quot;
+	&quot;Shadows&quot;
+	&quot;Shared&quot;
+	&quot;Short&quot;
+	&quot;Single&quot;
+	&quot;Static&quot;
+	&quot;Step&quot;
+	&quot;Stop&quot;
+	&quot;Strict&quot;
+	&quot;String&quot;
+	&quot;Structure&quot;
+	&quot;Sub&quot;
+	&quot;SyncLock&quot;
+	&quot;Text&quot;
+	&quot;Then&quot;
+	&quot;Throw&quot;
+	&quot;To&quot;
+	&quot;True&quot;
+	&quot;Try&quot;
+	&quot;TypeOf&quot;
+	&quot;Unicode&quot;
+	&quot;Until&quot;
+	&quot;Variant&quot;
+	&quot;Wend&quot;
+	&quot;When&quot;
+	&quot;While&quot;
+	&quot;With&quot;
+	&quot;WithEvents&quot;
+	&quot;WriteOnly&quot;
+	&quot;Xor&quot;
+	
+PRODUCTIONS
+
+VBNET
+	(.
+		compilationUnit = new CompilationUnit();
+		withStatements = new Stack();
+	.) =
+	{ EOL }
+	{ OptionStmt }
+	{ ImportsStmt}
+	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
+	{ NamespaceMemberDecl }
+	EOF
+	.
+
+OptionStmt (. INode node = null; bool val = true; .) =
+	&quot;Option&quot; (. Point startPos = t.Location; .)
+	(
+		&quot;Explicit&quot; [ OptionValue&lt;ref val&gt; ]
+		(. node = new OptionExplicitDeclaration(val); .)
+		|
+		&quot;Strict&quot; [ OptionValue&lt;ref val&gt; ]
+		(. node = new OptionStrictDeclaration(val); .)
+		|
+		&quot;Compare&quot; ( &quot;Binary&quot; (. node = new OptionCompareDeclaration(CompareType.Binary); .)
+				  | &quot;Text&quot; (. node = new OptionCompareDeclaration(CompareType.Text); .)
+				  )
+	)
+	EndOfStmt
+	(.
+		node.StartLocation = startPos;
+		node.EndLocation   = t.Location;
+		compilationUnit.AddChild(node);
+	.)
+	.
+
+OptionValue&lt;ref bool val&gt; =
+	(
+		&quot;On&quot; (. val = true; .)
+	|
+		&quot;Off&quot; (. val = true; .)
+	)
+	.
+
+EndOfStmt =
+	(
+		EOL
+	|
+		&quot;:&quot;
+	)
+	.
+
+ImportsStmt
+	(.
+		ArrayList importClauses = new ArrayList();
+		importedNamespaces = new ArrayList();
+		object importClause;
+	.) =
+	&quot;Imports&quot;
+	(.
+		Point startPos = t.Location;
+		ImportsStatement importsStatement = new ImportsStatement(null);
+	.)
+	ImportClause&lt;out importClause&gt; (. importClauses.Add(importClause); .)
+	{
+		&quot;,&quot; ImportClause&lt;out importClause&gt; (. importClauses.Add(importClause); .)
+	}
+	EndOfStmt
+	(.
+		importsStatement.ImportClauses = importClauses;
+		importsStatement.StartLocation = startPos;
+		importsStatement.EndLocation   = t.Location;
+		compilationUnit.AddChild(importsStatement);
+	.)
+	.
+
+ImportClause&lt;out object importClause&gt;
+	(.
+		string qualident = null;
+		string aliasident = null;
+		importClause = null;
+	.) =
+	[ IF (IsAssignment()) Identifier (. aliasident = t.val;  .) &quot;=&quot; ]
+	Qualident&lt;out qualident&gt;
+	(.
+		if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
+			if (aliasident != null) {
+				importClause = new ImportsAliasDeclaration(aliasident, qualident);
+			} else {
+				importedNamespaces.Add(qualident);
+				importClause = new ImportsDeclaration(qualident);
+			}
+		}
+	.)
+	.
+
+/* 6.4.2 */
+NamespaceMemberDecl
+	(.
+		Modifiers m = new Modifiers(this);
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		string qualident;
+	.) =
+	&quot;Namespace&quot;
+	(.
+		Point startPos = t.Location;
+	.)
+	Qualident&lt;out qualident&gt;
+	(.
+		INode node =  new NamespaceDeclaration(qualident);
+		node.StartLocation = startPos;
+		compilationUnit.AddChild(node);
+		compilationUnit.BlockStart(node);
+	.)
+	EOL
+	NamespaceBody
+	(.
+		node.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	|
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	{ TypeModifier&lt;m&gt; } NonModuleDeclaration&lt;m, attributes&gt;
+	.
+
+/* 6.4.2 */
+NonModuleDeclaration&lt;Modifiers m, ArrayList attributes&gt;
+			(.
+				string name = String.Empty;
+				ArrayList names = null;
+			.) =
+	(. m.Check(Modifier.Classes); .)
+	/* Spec, 7.5 */
+	&quot;Class&quot;
+					(. TypeDeclaration newType = new TypeDeclaration();
+						compilationUnit.AddChild(newType);
+						compilationUnit.BlockStart(newType);
+						newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+						newType.Type = Types.Class;
+						newType.Modifier = m.Modifier;
+						newType.Attributes = attributes;
+					.)
+	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
+	EndOfStmt
+	[ ClassBaseType&lt;out name&gt; (. newType.BaseType = name; .) ]
+	{ TypeImplementsClause&lt;out names&gt; (. newType.BaseInterfaces = names; .) }
+	ClassBody&lt;newType&gt;
+	(.
+		compilationUnit.BlockEnd();
+	.)
+	| &quot;Module&quot;
+		(.
+			m.Check(Modifier.Modules);
+			TypeDeclaration newType = new TypeDeclaration();
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.StartLocation = t.Location;
+			newType.Type = Types.Module;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+		.)
+	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation;  .) 
+	EOL
+	ModuleBody&lt;newType&gt;
+	(.
+		newType.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	| &quot;Structure&quot;
+		(.
+			m.Check(Modifier.Structures);
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			newType.StartLocation = t.Location;
+			newType.Type = Types.Structure;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			ArrayList baseInterfaces = new ArrayList();
+		.)
+	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
+	EOL { TypeImplementsClause&lt;out baseInterfaces&gt; }
+	StructureBody&lt;newType&gt;
+	(.
+		newType.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	| /* 7.4 */
+	&quot;Enum&quot;
+		(.
+			m.Check(Modifier.Enums);
+			TypeDeclaration newType = new TypeDeclaration();
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			
+			newType.Type = Types.Enum;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+		.)
+	Identifier
+	(. newType.Name = t.val; newType.StartLocation = t.EndLocation; .)
+	[ &quot;As&quot; PrimitiveTypeName&lt;out name&gt; (. newType.BaseType = name; .) ]
+	EOL
+	EnumBody&lt;newType&gt;
+	(.
+		newType.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	| /* 7.8 */
+	&quot;Interface&quot;
+		(.
+			m.Check(Modifier.Interfaces);
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			
+			newType.Type = Types.Interface;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			ArrayList baseInterfaces = new ArrayList();
+		.)
+	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
+	EndOfStmt { InterfaceBase&lt;out baseInterfaces&gt; (. newType.BaseInterfaces = baseInterfaces; .) }
+	InterfaceBody&lt;newType&gt;
+	(.
+		newType.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	| /* 7.10 */
+	&quot;Delegate&quot;
+	(.
+		m.Check(Modifier.Delegates);
+		DelegateDeclaration delegateDeclr = new DelegateDeclaration();
+		ArrayList p = null;
+		TypeReference type = null;
+		delegateDeclr.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+		delegateDeclr.StartLocation = t.Location;
+		delegateDeclr.Modifier = m.Modifier;
+		delegateDeclr.Attributes = attributes;
+	.)
+	(
+		&quot;Sub&quot; Identifier (. delegateDeclr.Name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. delegateDeclr.Parameters = p; .) ]
+		|
+		&quot;Function&quot; Identifier (. delegateDeclr.Name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. delegateDeclr.Parameters = p; .) ]
+		[ &quot;As&quot; TypeName&lt;out type&gt; (. delegateDeclr.ReturnType = type; .)]
+	)
+	(. 		delegateDeclr.EndLocation = t.EndLocation; .)
+	EOL
+	(.
+		compilationUnit.AddChild(delegateDeclr);
+	.)
+	.
+
+NamespaceBody =
+	{ NamespaceMemberDecl }
+	&quot;End&quot; &quot;Namespace&quot;
+	EOL
+	.
+
+ClassBody&lt;TypeDeclaration newType&gt;
+	(. AttributeSection section; .) =
+	{
+		(.
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+		.)
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; }
+		ClassMemberDecl&lt;m, attributes&gt;
+	}
+	&quot;End&quot; &quot;Class&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+StructureBody&lt;TypeDeclaration newType&gt;
+	(. AttributeSection section; .) =
+	{
+		(.
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+		.)
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; }
+		StructureMemberDecl&lt;m, attributes&gt;
+	}
+	&quot;End&quot; &quot;Structure&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+/* 7.7.1 */
+ModuleBody&lt;TypeDeclaration newType&gt;
+	(. AttributeSection section; .) =
+	{
+		(.
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+		.)
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; }
+		ClassMemberDecl&lt;m, attributes&gt;
+	}
+	&quot;End&quot; &quot;Module&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+EnumBody&lt;TypeDeclaration newType&gt;
+	(. FieldDeclaration f; .) =
+	{
+		EnumMemberDecl&lt;out f&gt; (. compilationUnit.AddChild(f); .)
+	}
+	&quot;End&quot; &quot;Enum&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+InterfaceBody&lt;TypeDeclaration newType&gt; =
+	{ InterfaceMemberDecl }
+	&quot;End&quot; &quot;Interface&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+/*
+	The information provided in the spec about
+	interface declarations is wrong
+*/
+InterfaceMemberDecl
+	(.
+		TypeReference type =null;
+		ArrayList p = null;
+		AttributeSection section;
+		Modifiers mod = new Modifiers(this);
+		ArrayList attributes = new ArrayList();
+		ArrayList parameters = new ArrayList();
+		string name;
+	.) =
+	{ AttributeSection&lt;out section&gt;			(. attributes.Add(section); .) }
+	/* this is different to c#: not only the Shadows modifier is allowed,
+	   also member modifiers like overloads etc.
+	*/
+	{ MemberModifier&lt;mod&gt; }
+	(
+		&quot;Event&quot;
+		(. mod.Check(Modifier.InterfaceEvents); .)
+		Identifier (. name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		[ &quot;As&quot; TypeName&lt;out type&gt; ]
+		EOL
+		(.
+			EventDeclaration ed = new EventDeclaration(type, mod.Modifier, p, attributes, name, null);
+			ed.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(ed);
+			ed.EndLocation = t.EndLocation;
+		.)
+		|
+		&quot;Sub&quot;
+		(.
+			mod.Check(Modifier.InterfaceMethods);
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+		.)
+		Identifier (. name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		EOL
+		(.
+			MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, null, p, attributes);
+			md.Specials[&quot;before&quot;] = comments;
+			md.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(md);
+		.)
+		|
+		&quot;Function&quot;
+		(.
+			mod.Check(Modifier.InterfaceMethods);
+			AttributeSection attributeSection = null;
+		.)
+		Identifier (. name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		[ &quot;As&quot; [AttributeSection&lt;out attributeSection&gt; ] TypeName&lt;out type&gt; ]
+		(.
+			if(type == null) {
+				type = new TypeReference(&quot;System.Object&quot;);
+			}
+			type.Attributes = attributeSection;
+			MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, type, p, attributes);
+			md.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			md.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(md);
+		.)
+		EOL
+		|
+		&quot;Property&quot;
+		(.
+			mod.Check(Modifier.InterfaceProperties);
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+		.)
+		Identifier	(. name = t.val;  .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		[ &quot;As&quot; TypeName&lt;out type&gt; ]
+		(.
+			if(type == null) {
+				type = new TypeReference(&quot;System.Object&quot;);
+			}
+		.)
+		EOL
+		(.
+			PropertyDeclaration pd = new PropertyDeclaration(name, type, mod.Modifier, attributes);
+			pd.Parameters = p;
+			pd.Specials[&quot;before&quot;] = comments;
+			pd.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(pd);
+		.)
+	)
+	| /* inner type declarations */
+	NonModuleDeclaration&lt;mod, attributes&gt;
+	.
+
+/* 7.4.1 */
+EnumMemberDecl&lt;out FieldDeclaration f&gt;
+	(.
+		Expression expr = null;
+		ArrayList attributes = new ArrayList();
+		AttributeSection section = null;
+		VariableDeclaration varDecl = null;
+	.) =
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	Identifier
+	(.
+		f = new FieldDeclaration(attributes);
+		varDecl = new VariableDeclaration(t.val);
+		varDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+		f.Fields.Add(varDecl);
+		f.StartLocation = t.Location;
+	.)
+	[ &quot;=&quot; Expr&lt;out expr&gt; (. varDecl.Initializer = expr; .) ]
+	EOL
+	.
+
+ClassMemberDecl&lt;Modifiers m, ArrayList attributes&gt; =
+	StructureMemberDecl&lt;m, attributes&gt;
+	.
+
+ClassBaseType&lt;out string name&gt;
+	(.
+		TypeReference type;
+		name = String.Empty;
+	.) =
+	&quot;Inherits&quot;
+	TypeName&lt;out type&gt; (. name = type.Type; .)
+	EndOfStmt
+	.
+
+/* 7.6.1 */
+StructureMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
+	(.
+		TypeReference type = null;
+		ArrayList p = null;
+		Statement stmt = null;
+		ArrayList variableDeclarators = new ArrayList();
+	.)=
+	NonModuleDeclaration&lt;m, attributes&gt;
+	| /* 9.2.1 */
+	&quot;Sub&quot;
+	(.
+		Point startPos = t.Location;
+		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+	.)
+	(
+		(.
+			string name = String.Empty;
+			MethodDeclaration methodDeclaration;
+			HandlesClause handlesClause = null;
+			ImplementsClause implementsClause = null;
+		.)
+		Identifier
+		(.
+			name = t.val;
+			m.Check(Modifier.Methods);
+		.)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		[
+			(
+				ImplementsClause&lt;out implementsClause&gt;
+				|
+				HandlesClause&lt;out handlesClause&gt;
+			)
+		]
+		(. Point endLocation = t.EndLocation; .)
+		EOL
+		(
+			/* abstract methods without a body */
+			IF(IsMustOverride(m))
+			(.
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = comments;
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = endLocation;
+				
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				
+				compilationUnit.AddChild(methodDeclaration);
+			.)
+		|
+			(.
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = comments;
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = endLocation;
+				
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				
+				compilationUnit.AddChild(methodDeclaration);
+				compilationUnit.BlockStart(methodDeclaration);
+			.)
+			Block&lt;out stmt&gt;
+			(.
+				compilationUnit.BlockEnd();
+				methodDeclaration.Body  = (BlockStatement)stmt;
+			.)
+			&quot;End&quot; &quot;Sub&quot; (. methodDeclaration.Body.EndLocation = t.EndLocation; .) EOL 
+		)
+		/* 9.3 */
+		| &quot;New&quot; [ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		(. m.Check(Modifier.Constructors); .)
+		(. Point constructorEndLocation = t.EndLocation; .)
+		EOL
+		Block&lt;out stmt&gt;
+		&quot;End&quot; &quot;Sub&quot; (. Point endLocation = t.EndLocation; .) EOL
+		(.
+			ConstructorDeclaration cd = new ConstructorDeclaration(&quot;New&quot;, m.Modifier, p, attributes); 
+			cd.StartLocation = startPos;
+			cd.Specials[&quot;before&quot;] = comments;
+			cd.EndLocation   = constructorEndLocation;
+			cd.Body = (BlockStatement)stmt;
+			cd.Body.EndLocation   = endLocation;
+			compilationUnit.AddChild(cd);
+		.)
+	)
+	|
+	/* 9.2.1 */
+	&quot;Function&quot;
+	(.
+		m.Check(Modifier.Methods);
+		string name = String.Empty;
+		Point startPos = t.Location;
+		MethodDeclaration methodDeclaration;
+		HandlesClause handlesClause = null;
+		ImplementsClause implementsClause = null;
+		AttributeSection attributeSection = null;
+	.)
+	Identifier			(. name = t.val; .)
+	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+	[&quot;As&quot; [AttributeSection&lt;out attributeSection&gt;] TypeName&lt;out type&gt; ]
+	(.
+		if(type == null) {
+			type = new TypeReference(&quot;System.Object&quot;);
+		}
+		type.Attributes = attributeSection;
+	.)
+	[
+		(
+			ImplementsClause&lt;out implementsClause&gt;
+			|
+			HandlesClause&lt;out handlesClause&gt;
+		)
+	]
+	EOL
+	(
+		/* abstract methods without a body */
+		IF(IsMustOverride(m))
+			(.
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = t.EndLocation;
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				compilationUnit.AddChild(methodDeclaration);
+			.)
+		|
+			(.
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = t.EndLocation;
+				
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				
+				compilationUnit.AddChild(methodDeclaration);
+				compilationUnit.BlockStart(methodDeclaration);
+			.)
+			Block&lt;out stmt&gt;
+			(.
+				compilationUnit.BlockEnd();
+				methodDeclaration.Body  = (BlockStatement)stmt;
+			.)
+			&quot;End&quot; &quot;Function&quot; 
+			(.
+				methodDeclaration.Body.StartLocation = methodDeclaration.EndLocation;
+				methodDeclaration.Body.EndLocation   = t.EndLocation;
+			.)
+			EOL
+	)
+	|
+	/* 9.2.2. */
+	&quot;Declare&quot;
+	(.
+		m.Check(Modifier.ExternalMethods);
+		Point startPos = t.Location;
+		CharsetModifier charsetModifer = CharsetModifier.None;
+		string library = String.Empty;
+		string alias = null;
+		string name = String.Empty;
+	.)
+	[Charset&lt;out charsetModifer&gt; ]
+	(
+			&quot;Sub&quot;
+			Identifier				(. name = t.val; .)
+			&quot;Lib&quot; LiteralString		(. library = t.val; .)
+			[&quot;Alias&quot; LiteralString	(. alias = t.val; .)]
+			[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+			EOL
+			(.
+				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, null, p, attributes, library, alias, charsetModifer);
+				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				declareDeclaration.StartLocation = startPos;
+				declareDeclaration.EndLocation   = t.EndLocation;
+				compilationUnit.AddChild(declareDeclaration);
+			.)
+		|
+			&quot;Function&quot; 
+			Identifier					(. name = t.val; .)
+			&quot;Lib&quot; LiteralString		(. library = t.val; .)
+			[&quot;Alias&quot; LiteralString	(. alias = t.val; .)]
+			[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+			[&quot;As&quot; TypeName&lt;out type&gt; ]
+			EOL
+			(.
+				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, type, p, attributes, library, alias, charsetModifer);
+				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				declareDeclaration.StartLocation = startPos;
+				declareDeclaration.EndLocation   = t.EndLocation;
+				compilationUnit.AddChild(declareDeclaration);
+			.)
+		)
+	|
+	/* 9. 4 */
+	&quot;Event&quot;
+	(.
+		m.Check(Modifier.Events);
+		Point startPos = t.Location;
+		EventDeclaration eventDeclaration;
+		string name = String.Empty;
+		ImplementsClause implementsClause = null;
+	.)
+	Identifier (. name= t.val; .)
+	(
+		&quot;As&quot; TypeName&lt;out type&gt;
+		|
+		[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+	)
+	[ ImplementsClause&lt;out implementsClause&gt; ]
+	(.
+		eventDeclaration = new EventDeclaration(type, m.Modifier, p, attributes, name, implementsClause);
+		eventDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+		eventDeclaration.StartLocation = startPos;
+		eventDeclaration.EndLocation = t.EndLocation;
+		compilationUnit.AddChild(eventDeclaration);
+	.)
+	EOL
+	| /* 9.6 */
+	(. Point startPos = t.Location; .)
+	(.
+		m.Check(Modifier.Fields);
+		FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+		fd.StartLocation = startPos;
+	.)
+	VariableDeclarator&lt;variableDeclarators&gt;
+	(.
+		((INode)variableDeclarators[0]).Specials[&quot;before&quot;] = comments;
+	.)
+	{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; }
+	EOL
+	(.
+		fd.EndLocation = t.EndLocation;
+		fd.Fields = variableDeclarators;
+		compilationUnit.AddChild(fd);
+	.)
+	| /* 9.4 */
+	(. m.Check(Modifier.Fields); .)
+	&quot;Const&quot; (.  m.Add(Modifier.Constant);  .)
+	(.
+		FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+		fd.StartLocation = t.Location;
+		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+		ArrayList constantDeclarators = new ArrayList();
+	.)
+	ConstantDeclarator&lt;constantDeclarators&gt;
+	(.
+		((INode)constantDeclarators[0]).Specials[&quot;before&quot;] = comments;
+	.)
+	{ &quot;,&quot; ConstantDeclarator&lt;constantDeclarators&gt; }
+	(.
+		fd.Fields = constantDeclarators;
+		fd.EndLocation = t.Location;
+	.)
+	EOL
+	(.
+		fd.EndLocation = t.EndLocation;
+		compilationUnit.AddChild(fd);
+	.)
+	| /* 9.7 */
+	&quot;Property&quot;
+	(.
+		m.Check(Modifier.Properties);
+		Point startPos = t.Location;
+		ImplementsClause implementsClause = null;
+	.)
+	Identifier (. string propertyName = t.val; .)
+	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+	[ &quot;As&quot; TypeName&lt;out type&gt; ]
+	(.
+		if(type == null) {
+			type = new TypeReference(&quot;System.Object&quot;);
+		}
+	.)
+	[ ImplementsClause&lt;out implementsClause&gt; ]
+	EOL
+	(
+	/* abstract properties without a body */
+	IF(IsMustOverride(m))
+		(.
+			PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
+			pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			pDecl.StartLocation = startPos;
+			pDecl.EndLocation   = t.Location;
+			pDecl.TypeReference = type;
+			pDecl.ImplementsClause = implementsClause;
+			pDecl.Parameters = p;
+			compilationUnit.AddChild(pDecl);
+		.)
+	|
+		(.
+			PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
+			pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			pDecl.StartLocation = startPos;
+			pDecl.EndLocation   = t.Location;
+			pDecl.BodyStart   = t.Location;
+			pDecl.TypeReference = type;
+			pDecl.ImplementsClause = implementsClause;
+			pDecl.Parameters = p;
+			PropertyGetRegion getRegion;
+			PropertySetRegion setRegion;
+		.)
+		AccessorDecls&lt;out getRegion, out setRegion&gt; 
+		&quot;End&quot; &quot;Property&quot;
+		EOL
+		(.
+			pDecl.GetRegion = getRegion;
+			pDecl.SetRegion = setRegion;
+			pDecl.BodyEnd = t.EndLocation;
+			compilationUnit.AddChild(pDecl);
+		.)
+	)
+	.
+
+/* 9.7 */
+AccessorDecls&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
+	(.
+		ArrayList attributes = new ArrayList(); 
+		AttributeSection section;
+		getBlock = null;
+		setBlock = null; 
+	.) =
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	(
+		GetAccessorDecl&lt;out getBlock, attributes&gt;
+		[
+			(. attributes = new ArrayList(); .)
+			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+			SetAccessorDecl&lt;out setBlock, attributes&gt;
+		]
+		|
+		SetAccessorDecl&lt;out setBlock, attributes&gt;
+		[
+			(. attributes = new ArrayList(); .)
+			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+			GetAccessorDecl&lt;out getBlock, attributes&gt;
+		]
+	)
+	.
+
+/* 9.7.1 */
+GetAccessorDecl&lt;out PropertyGetRegion getBlock, ArrayList attributes&gt;
+	(. Statement stmt = null; .) =
+	&quot;Get&quot;
+	EOL
+	Block&lt;out stmt&gt;
+	(.
+		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes);
+	.)
+	&quot;End&quot; &quot;Get&quot;
+	EOL
+	.
+
+/* 9.7.2 */
+SetAccessorDecl&lt;out PropertySetRegion setBlock, ArrayList attributes&gt;
+	(.
+		Statement stmt = null;
+		ArrayList p = null;
+	.) =
+	&quot;Set&quot;
+	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+	EOL
+	Block&lt;out stmt&gt;
+	(.
+		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes);
+		setBlock.Parameters = p;
+	.)
+	&quot;End&quot; &quot;Set&quot;
+	EOL
+	.
+
+/* 9.5 */
+ConstantDeclarator&lt;ArrayList constantDeclaration&gt;
+	(.
+		Expression expr = null;
+		TypeReference type = null;
+		string name = String.Empty;
+	.) =
+	Identifier				(. name = t.val; .)
+	[&quot;As&quot; TypeName&lt;out type&gt; ]
+	&quot;=&quot; Expr&lt;out expr&gt;
+	(.
+		VariableDeclaration f = new VariableDeclaration(name, expr);
+		f.Type = type;
+		constantDeclaration.Add(f);
+	.)
+	.
+
+/* 9.6 */
+VariableDeclarator&lt;ArrayList fieldDeclaration&gt;
+	(.
+		Expression expr = null;
+		TypeReference type = null;
+		ObjectCreateExpression oce = null;
+		ArrayCreateExpression ace = null;
+		ArrayList rank = null;
+		ArrayList dimension = null;
+	.) =
+	Identifier
+	(.
+		VariableDeclaration f = new VariableDeclaration(t.val);
+	.)
+	[ IF(IsRank()) ArrayTypeModifiers&lt;out rank&gt; ]
+	[ IF(IsSize()) ArrayInitializationModifier&lt;out dimension&gt; ]
+	(
+			IF(IsObjectCreation()) &quot;As&quot; ObjectCreateExpression&lt;out expr&gt;
+			(.
+				if(expr is ArrayCreateExpression) {
+					ace = expr as ArrayCreateExpression;
+					f.Initializer = ace.ArrayInitializer;
+					
+				} else {
+					oce = expr as ObjectCreateExpression;
+					f.Initializer = oce;
+					if(oce.CreateType != null) {
+						f.Type = oce.CreateType;
+					}
+				}
+			.)
+		|
+			[ &quot;As&quot; TypeName&lt;out type&gt; ]
+			(.
+				if(type != null) {
+					type.Dimension = dimension;
+				}
+				f.Type = type;
+				if (type != null &amp;&amp; rank != null) {
+					if(type.RankSpecifier != null) {
+						Error(&quot;array rank only allowed one time&quot;);
+					} else {
+						type.RankSpecifier = rank;
+					}
+				}
+			.)
+			[ &quot;=&quot; VariableInitializer&lt;out expr&gt; (. f.Initializer = expr; .) ]
+	)
+	(. fieldDeclaration.Add(f); .)
+	.
+
+/* 6.8 */
+ArrayInitializationModifier&lt;out ArrayList arrayModifiers&gt;
+	(.
+		arrayModifiers = null;
+	.) =
+	&quot;(&quot; InitializationRankList&lt;out arrayModifiers&gt; &quot;)&quot;
+	.
+
+/* 7.5.4.3 */
+InitializationRankList&lt;out ArrayList rank&gt;
+	(.
+		rank = null;
+		Expression expr = null;
+	.) =
+	Expr&lt;out expr&gt;	(. rank = new ArrayList(); rank.Add(expr); .)
+	{
+		&quot;,&quot; Expr&lt;out expr&gt;		(. rank.Add(expr); .)
+	}
+	.
+
+/* 9.6.3 */
+VariableInitializer&lt;out Expression initializerExpression&gt;
+	(.
+		initializerExpression = null;
+	.) =
+	Expr&lt;out initializerExpression&gt;
+	| ArrayInitializer&lt;out initializerExpression&gt;
+	.
+
+/* 9.6.3.4 */
+ArrayInitializer&lt;out Expression outExpr&gt;
+	(.
+		Expression expr = null;
+		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
+	.) =
+	&quot;{&quot;
+	[
+		VariableInitializer&lt;out expr&gt;
+		(.
+			initializer.CreateExpressions.Add(expr);
+		.)
+		{
+			IF (NotFinalComma()) &quot;,&quot; VariableInitializer&lt;out expr&gt;
+			(. initializer.CreateExpressions.Add(expr); .)
+		}
+	]
+	&quot;}&quot; (. outExpr = initializer; .)
+	.
+
+Charset&lt;out CharsetModifier charsetModifier&gt;
+	(. charsetModifier = CharsetModifier.None; .) =
+	| &quot;Ansi&quot;		(. charsetModifier = CharsetModifier.ANSI; .)
+	| &quot;Auto&quot;		(. charsetModifier = CharsetModifier.Auto; .)
+	| &quot;Unicode&quot;		(. charsetModifier = CharsetModifier.Unicode; .)
+	.
+
+/* 9.2.6 */
+HandlesClause&lt;out HandlesClause handlesClause&gt;
+	(.
+		handlesClause = new HandlesClause();
+		string name;
+	.) =
+	&quot;Handles&quot; EventMemberSpecifier&lt;out name&gt;	(. handlesClause.EventNames.Add(name); .)
+	{ &quot;,&quot; EventMemberSpecifier&lt;out name&gt;		(. handlesClause.EventNames.Add(name); .) }
+	.
+
+/* 7.8. */
+InterfaceBase &lt;out ArrayList bases&gt;
+	(.
+		TypeReference type;
+		bases = new ArrayList();
+	.) =
+	&quot;Inherits&quot;
+	TypeName&lt;out type&gt; (. bases.Add(type); .)
+	{
+		&quot;,&quot;
+		TypeName&lt;out type&gt; (. bases.Add(type); .)
+	}
+	EOL
+	.
+
+/* 7.2 */
+TypeImplementsClause&lt;out ArrayList baseInterfaces&gt;
+	(.
+		baseInterfaces = new ArrayList();
+		TypeReference type = null;
+	.) =
+	&quot;Implements&quot; TypeName&lt;out type&gt;
+	(.
+		baseInterfaces.Add(type);
+	.)
+	{
+		&quot;,&quot; TypeName&lt;out type&gt;
+		(. baseInterfaces.Add(type); .)
+	}
+	EndOfStmt
+	.
+
+/* 9.1 */
+ImplementsClause&lt;out ImplementsClause clause&gt;
+	(.
+		clause = new ImplementsClause();
+		string typename = String.Empty;
+		string first;
+	.) =
+	&quot;Implements&quot; Identifier (. first = t.val; .) &quot;.&quot; Qualident&lt;out typename&gt; (. ((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); .)
+	{ &quot;,&quot; Identifier (. first = t.val; .) &quot;.&quot; Qualident&lt;out typename&gt; (. ((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); .) }
+		.
+
+EventMemberSpecifier&lt;out string name&gt;
+	(. string type; name = String.Empty; .) =
+	Identifier (. type = t.val; .)
+	&quot;.&quot;
+	Identifier (. name = type + &quot;.&quot; + t.val; .)
+	| &quot;MyBase&quot; &quot;.&quot;
+	(
+		Identifier (. name = &quot;MyBase.&quot; + t.val; .)
+		| &quot;Error&quot;  (. name = &quot;MyBase.Error&quot;; .)
+	)
+	.
+
+Expr&lt;out Expression expr&gt;
+	(. expr = new Expression(); .) =
+	ConditionalOrExpr&lt;out expr&gt;
+	{
+		/*ConditionalOrExpr&lt;out expr&gt;	|*/
+		(. AssignmentOperatorType op; Expression val; .)
+		AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
+	}
+	.
+
+UnaryExpr&lt;out Expression uExpr&gt; 
+	(.
+		Expression expr;
+		UnaryOperatorType uop = UnaryOperatorType.None;
+		bool isUOp = false;
+	.) =
+	{ 	&quot;+&quot; 		(. uop = UnaryOperatorType.Plus; isUOp = true; .)
+		| &quot;-&quot; 		(. uop = UnaryOperatorType.Minus; isUOp = true; .)
+/*		| &quot;Not&quot;		(. uop = UnaryOperatorType.Not;  isUOp = true;.) */
+		| &quot;*&quot; 		(. uop = UnaryOperatorType.Star;  isUOp = true;.)
+	}
+	SimpleExpr&lt;out expr&gt;
+		(.
+			if (isUOp) {
+				uExpr = new UnaryOperatorExpression(expr, uop);
+			} else {
+				uExpr = expr;
+			}
+		.)
+	.
+
+AssignmentOperator&lt;out AssignmentOperatorType op&gt;
+	(. op = AssignmentOperatorType.None; .) =
+	&quot;=&quot;		(. op = AssignmentOperatorType.Assign; .)
+	| &quot;&amp;=&quot;	(. op = AssignmentOperatorType.ConcatString; .)
+	| &quot;+=&quot;	(. op = AssignmentOperatorType.Add; .)
+	| &quot;-=&quot;	(. op = AssignmentOperatorType.Subtract; .)
+	| &quot;*=&quot;	(. op = AssignmentOperatorType.Multiply; .)
+	| &quot;/=&quot;	(. op = AssignmentOperatorType.Divide; .)
+	| &quot;\\=&quot;	(. op = AssignmentOperatorType.DivideInteger; .)
+	| &quot;^=&quot;	(. op = AssignmentOperatorType.Power; .)
+	| &quot;&lt;&lt;=&quot;	(. op = AssignmentOperatorType.ShiftLeft; .)
+	| &quot;&gt;&gt;=&quot;	(. op = AssignmentOperatorType.ShiftRight; .)
+	.
+
+/* 11.4 */
+SimpleExpr&lt;out Expression pexpr&gt;
+	(.
+		Expression expr;
+		TypeReference type = null;
+		string name = String.Empty;
+		pexpr = null;
+	.) =
+	(
+		(
+			/* 11.4.1 */ 
+			LiteralString							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralCharacter						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralSingle							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralDouble							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralInteger						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralDate							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralDecimal						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			/* True, False and Nothing are handled as literals in the spec */
+			| &quot;True&quot;											(.pexpr = new PrimitiveExpression(true, &quot;true&quot;);  .)
+			| &quot;False&quot;											(.pexpr = new PrimitiveExpression(false, &quot;false&quot;); .)
+			| &quot;Nothing&quot;											(.pexpr = new PrimitiveExpression(null, &quot;null&quot;);  .)
+			| /* 11.4.2 */ &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; 				(. pexpr = new ParenthesizedExpression(expr); .)
+			| /* 11.4.4 */ Identifier					(. pexpr = new IdentifierExpression(t.val); .)
+			| (. string val = String.Empty; .) PrimitiveTypeName&lt;out val&gt;
+			&quot;.&quot; Identifier	(. pexpr = new FieldReferenceOrInvocationExpression(new TypeReferenceExpression(val), t.val); .)
+			| &quot;Me&quot;												(. pexpr = new ThisReferenceExpression(); .)
+			| (. Expression retExpr = null; .)
+				( &quot;MyBase&quot;										(. retExpr = new BaseReferenceExpression(); .)
+				| &quot;MyClass&quot;										(. retExpr = new ClassReferenceExpression(); .)
+				)
+				&quot;.&quot; IdentifierOrKeyword&lt;out name&gt;				(. pexpr = new FieldReferenceOrInvocationExpression(retExpr, name); .)
+			| ObjectCreateExpression&lt;out expr&gt;					(. pexpr = expr; .)
+			| /* 11.11 */ ( &quot;DirectCast&quot; | &quot;CType&quot; ) &quot;(&quot; Expr&lt;out expr&gt; &quot;,&quot; TypeName&lt;out type&gt; &quot;)&quot;	(. pexpr = new CastExpression(type, expr); .)
+			| /* 11.11 */ CastTarget&lt;out type&gt; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;	(. pexpr = new CastExpression(type, expr, true); .)
+			| /* 11.4.5 */ &quot;AddressOf&quot; Expr&lt;out expr&gt;			(. pexpr = new AddressOfExpression(expr); .)
+			| /* 11.5.1 */ &quot;GetType&quot; &quot;(&quot; TypeName&lt;out type&gt; &quot;)&quot;	(. pexpr = new GetTypeExpression(type); .)
+			| /* 11.5.2 */ &quot;TypeOf&quot; SimpleExpr&lt;out expr&gt; &quot;Is&quot; TypeName&lt;out type&gt; (. pexpr = new TypeOfExpression(expr, type); .)
+		)
+		{
+			&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); .)
+			| &quot;(&quot;	(. ArrayList parameters = new ArrayList(); .)
+				[
+					(. expr = null; .) [ Argument&lt;out expr&gt;]	(. parameters.Add(expr); .)
+					{
+						&quot;,&quot; (. expr = null; .)
+						[ Argument&lt;out expr&gt;  ] (. parameters.Add(expr); .)
+					}
+				]
+			&quot;)&quot;		(. pexpr = new InvocationExpression(pexpr, parameters); .)
+		}
+	|
+	/* this form only occurs in with statements*/
+	&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name);.)
+	{
+		&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); .)
+		| &quot;(&quot;	(. ArrayList parameters = new ArrayList(); .)
+			[
+				(. expr = null; .) [ Argument&lt;out expr&gt;]	(. parameters.Add(expr); .)
+				{
+					&quot;,&quot; (. expr = null; .)
+					[ Argument&lt;out expr&gt;  ] (. parameters.Add(expr); .)
+				}
+			]
+		&quot;)&quot;		(. pexpr = new InvocationExpression(pexpr, parameters); .)
+	}
+	)
+	.
+
+/* 11.11 */
+
+CastTarget&lt;out TypeReference type&gt;
+	(.
+		type = null;
+	.) =
+	&quot;CBool&quot;		(. type = new TypeReference(&quot;System.Boolean&quot;); .)
+	| &quot;CByte&quot;	(. type = new TypeReference(&quot;System.Byte&quot;); .)
+	| &quot;CChar&quot;	(. type = new TypeReference(&quot;System.Char&quot;); .)
+	| &quot;CDate&quot;	(. type = new TypeReference(&quot;System.DateTime&quot;); .)
+	| &quot;CDec&quot;	(. type = new TypeReference(&quot;System.Decimal&quot;); .)
+	| &quot;CDbl&quot;	(. type = new TypeReference(&quot;System.Double&quot;); .)
+	| &quot;CInt&quot;	(. type = new TypeReference(&quot;System.Int32&quot;); .)
+	| &quot;CLng&quot;	(. type = new TypeReference(&quot;System.Int64&quot;); .)
+	| &quot;CObj&quot;	(. type = new TypeReference(&quot;System.Object&quot;); .)
+	| &quot;CShort&quot;	(. type = new TypeReference(&quot;System.Int16&quot;); .)
+	| &quot;CSng&quot;	(. type = new TypeReference(&quot;System.Single&quot;); .)
+	| &quot;CStr&quot;	(. type = new TypeReference(&quot;System.String&quot;); .)
+	.
+
+ConditionalOrExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	ConditionalAndExpr&lt;out outExpr&gt;  { &quot;OrElse&quot; ConditionalAndExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanOr, expr);  .) }
+	.
+
+ConditionalAndExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	InclusiveOrExpr&lt;out outExpr&gt;  { &quot;AndAlso&quot; InclusiveOrExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanAnd, expr);  .) }
+	.
+
+InclusiveOrExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	ExclusiveOrExpr&lt;out outExpr&gt;  { &quot;Xor&quot; ExclusiveOrExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  .) }
+	.
+
+ExclusiveOrExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	AndExpr&lt;out outExpr&gt;  { &quot;Or&quot; AndExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  .) }
+	.
+
+AndExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	NotExpr&lt;out outExpr&gt; { &quot;And&quot; NotExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  .) }
+	.
+
+NotExpr&lt;out Expression outExpr&gt; 
+	(. UnaryOperatorType uop = UnaryOperatorType.None; .) =
+	{	&quot;Not&quot; (. uop = UnaryOperatorType.Not; .) }
+	EqualityExpr&lt;out outExpr&gt;
+                (. if (uop != UnaryOperatorType.None)
+	                   outExpr = new UnaryOperatorExpression(outExpr, uop);
+                .)
+	.
+
+EqualityExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+	RelationalExpr&lt;out outExpr&gt;
+	{
+		(
+			&quot;&lt;&gt;&quot;		(. op = BinaryOperatorType.InEquality; .)
+			| &quot;=&quot; 		(. op = BinaryOperatorType.Equality; .)
+			| &quot;Like&quot;	(. op = BinaryOperatorType.Like; .)
+		)
+		RelationalExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
+	}
+	.
+
+RelationalExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+	ShiftExpr&lt;out outExpr&gt;
+	{
+		(
+			&quot;&lt;&quot;    (. op = BinaryOperatorType.LessThan; .)
+			| &quot;&gt;&quot;  (. op = BinaryOperatorType.GreaterThan; .)
+			| &quot;&lt;=&quot; (. op = BinaryOperatorType.LessThanOrEqual; .)
+			| &quot;&gt;=&quot; (. op = BinaryOperatorType.GreaterThanOrEqual; .)
+		)
+		ShiftExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
+		|
+		/* 11.5.3 */
+		&quot;Is&quot; (. op = BinaryOperatorType.IS; .)
+		Expr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr); .)
+	}
+	.
+
+ShiftExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+	AdditiveExpr&lt;out outExpr&gt; 
+	{
+		(
+			&quot;&lt;&lt;&quot;   (. op = BinaryOperatorType.ShiftLeft; .)
+			| &quot;&gt;&gt;&quot; (. op = BinaryOperatorType.ShiftRight; .)
+		)
+		AdditiveExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
+	}
+	.
+
+AdditiveExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+	MultiplicativeExpr&lt;out outExpr&gt;
+	{
+		(
+			&quot;+&quot;   (. op = BinaryOperatorType.Add; .)
+			| &quot;-&quot; (. op = BinaryOperatorType.Subtract; .)
+			| &quot;&amp;&quot; (. op = BinaryOperatorType.Concat; .)
+		)
+		MultiplicativeExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
+	}
+	.
+
+MultiplicativeExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+    UnaryExpr&lt;out outExpr&gt;
+	{
+		(
+			&quot;*&quot;   (. op = BinaryOperatorType.Multiply; .)
+			| &quot;/&quot; (. op = BinaryOperatorType.Divide; .)
+			| &quot;\\&quot; (. op = BinaryOperatorType.DivideInteger; .)
+			| &quot;Mod&quot; (. op = BinaryOperatorType.Modulus; .)
+			| &quot;^&quot;	(. op = BinaryOperatorType.Power; .)
+		) 
+		UnaryExpr&lt;out expr&gt; (. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .) 
+	}
+	.
+	
+ObjectCreateExpression&lt;out Expression oce&gt;
+	(.
+		TypeReference type = null;
+		Expression initializer = null;
+		ArrayList arguments = null;
+		oce = null;
+	.) =
+	&quot;New&quot; ArrayTypeName&lt;out type&gt;
+	[&quot;(&quot;
+		[ ArgumentList&lt;out arguments&gt; ]
+	&quot;)&quot;
+	]
+	[
+		ArrayInitializer&lt;out initializer&gt;
+	]
+	(.
+		if(initializer == null) {
+			oce = new ObjectCreateExpression(type, arguments);
+		} else {
+			ArrayCreateExpression ace = new ArrayCreateExpression(type, initializer as ArrayInitializerExpression);
+			ace.Parameters = arguments;
+			oce = ace;
+		}
+	.)
+	.
+
+/* 9.3.2 */
+ArgumentList&lt;out ArrayList arguments&gt;
+	(.
+		arguments = new ArrayList();
+		Expression expr = null;
+	.) =
+	[
+		Argument&lt;out expr&gt;			(. arguments.Add(expr); .)
+		{
+			&quot;,&quot;
+			Argument&lt;out expr&gt;		(. arguments.Add(expr); .)
+		}
+	]
+	.
+
+/* Spec, 11.8 */
+Argument&lt;out Expression argumentexpr&gt;
+	(.
+		Expression expr;
+		argumentexpr = null;
+		string name;
+	.) =
+	IF(IsNamedAssign()) Identifier (. name = t.val;  .) &quot;:&quot; &quot;=&quot; Expr&lt;out expr&gt;
+	(.
+		argumentexpr = new NamedArgumentExpression(name, expr);
+	.)
+	|
+	Expr&lt;out argumentexpr&gt;
+	.
+
+/* 7.1. */
+TypeName&lt;out TypeReference typeref&gt;
+	(.
+		ArrayList rank = null;
+	.) =
+	NonArrayTypeName&lt;out typeref&gt;
+	ArrayTypeModifiers&lt;out rank&gt;
+	(.
+		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
+	.)
+	.
+	
+
+ArrayTypeName&lt;out TypeReference typeref&gt;
+	(.
+		ArrayList rank = null;
+	.) =
+	NonArrayTypeName&lt;out typeref&gt;
+	ArrayInitializationModifiers&lt;out rank&gt;
+	(.
+		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
+	.)
+	.
+
+/* 7.1 */
+NonArrayTypeName&lt;out TypeReference typeref&gt;
+	(.
+		string name;
+		typeref = null;
+	.) =
+	Qualident&lt;out name&gt; (. typeref = new TypeReference(name); .)
+	| &quot;Object&quot; (. typeref = new TypeReference(&quot;System.Object&quot;); .)
+	| PrimitiveTypeName&lt;out name&gt; (. typeref = new TypeReference(name); .)
+	.
+
+ArrayInitializationModifiers&lt;out ArrayList arrayModifiers&gt;
+	(.
+		arrayModifiers = new ArrayList();
+		ArrayList dim = new ArrayList();
+	.) =
+	{	
+		IF (IsDims()) &quot;(&quot;
+		[ InitializationRankList &lt;out dim&gt;]
+		(.
+			arrayModifiers.Add(dim);
+		.)
+		&quot;)&quot;
+	}
+	(.
+		if(arrayModifiers.Count == 0) {
+			 arrayModifiers = null;
+		}
+	.)
+	.
+
+/* 7.9 */
+ArrayTypeModifiers&lt;out ArrayList arrayModifiers&gt;
+	(.
+		arrayModifiers = new ArrayList();
+		int i = 0;
+	.) =
+	{	IF (IsRank())
+		&quot;(&quot;
+		[ RankList &lt;out i&gt;]
+		(.
+			arrayModifiers.Add(i);
+		.)
+		&quot;)&quot;
+	}
+	(.
+		if(arrayModifiers.Count == 0) {
+			 arrayModifiers = null;
+		}
+	.)
+	.
+
+/* 7.9 */
+RankList&lt;out int i&gt;
+	(. i = 0; .) =
+	{ &quot;,&quot; (. ++i; .) }
+	.
+
+GlobalAttributeSection =
+	(. Point startPos = t.Location; .)
+	&quot;&lt;&quot; (&quot;Assembly&quot; | &quot;Module&quot;)
+		(.
+			string attributeTarget = t.val.ToLower();
+			ArrayList attributes = new ArrayList();
+			ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
+		.)
+	&quot;:&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)
+	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
+	[ &quot;,&quot; ]
+	&quot;&gt;&quot;
+	EndOfStmt
+		(.
+			AttributeSection section = new AttributeSection(attributeTarget, attributes);
+			section.StartLocation = startPos;
+			section.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(section);
+		.)
+	.
+
+/* Spec, 5. */
+Attribute&lt;out ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute&gt;
+	(. string qualident; .) =
+	Qualident&lt;out qualident&gt;
+		(.
+			ArrayList positional = new ArrayList();
+			ArrayList named      = new ArrayList();
+			string name = qualident;
+		.)
+	[ AttributeArguments&lt;ref positional, ref named&gt; ]
+	(.
+		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute(name, positional, named);
+	.)
+	.
+
+/* Spec, 5.2.2 */
+AttributeArguments&lt;ref ArrayList positional, ref ArrayList named&gt;
+	(.
+		bool nameFound = false;
+		string name = &quot;&quot;;
+		Expression expr;
+	.) =
+	&quot;(&quot;
+	[
+		IF (IsNotClosingParenthesis()) ( 
+			[
+				IF (IsNamedAssign()) (. nameFound = true; .)
+				IdentifierOrKeyword&lt;out name&gt;
+				[&quot;:&quot;] &quot;=&quot;
+			] Expr&lt;out expr&gt;
+				(.
+					if(name == &quot;&quot;) positional.Add(expr);
+					else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
+				.)
+			{
+				&quot;,&quot;
+					(
+						IF (IsNamedAssign())	(. nameFound = true; .)
+						IdentifierOrKeyword&lt;out name&gt;
+						[ &quot;:&quot; ] &quot;=&quot;
+						| (. if (nameFound) Error(&quot;no positional argument after named argument&quot;); .)
+					) Expr&lt;out expr&gt;	(. 	if(name == &quot;&quot;) positional.Add(expr);
+											else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
+										.)
+			}
+		)
+	]
+	&quot;)&quot;
+	.
+
+/* Spec, 5. */
+AttributeSection&lt;out AttributeSection section&gt;
+	(.
+		string attributeTarget = &quot;&quot;;
+		ArrayList attributes = new ArrayList();
+		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
+		
+	.) =
+	&quot;&lt;&quot; (. Point startPos = t.Location; .)
+	[ IF (IsLocalAttrTarget())
+		( &quot;Event&quot;		(. attributeTarget = &quot;event&quot;;.)
+		| &quot;Return&quot;		(. attributeTarget = &quot;return&quot;;.)
+		| Identifier
+			(.
+				string val = t.val.ToLower();
+				if (val != &quot;field&quot;	|| val != &quot;method&quot; ||
+					val != &quot;module&quot; || val != &quot;param&quot;  ||
+					val != &quot;property&quot; || val != &quot;type&quot;)
+				Error(&quot;attribute target specifier (event, return, field,&quot; +
+						&quot;method, module, param, property, or type) expected&quot;);
+				attributeTarget = t.val;
+			.)
+		) &quot;:&quot; 
+	]
+	Attribute&lt;out attribute&gt;	(. attributes.Add(attribute); .)
+	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .) }
+	[ &quot;,&quot; ]
+	&quot;&gt;&quot;
+		(.
+			section = new AttributeSection(attributeTarget, attributes);
+			section.StartLocation = startPos;
+			section.EndLocation = t.EndLocation;
+		.)
+	.
+
+/* 9.2.5 */
+FormalParameterList&lt;out ArrayList parameter&gt;
+	(.
+		parameter = new ArrayList();
+		ParameterDeclarationExpression p;
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+	.) =
+	{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
+	(
+		FormalParameter&lt;out p&gt;
+		(.
+			bool paramsFound = false;
+			p.Attributes = attributes;
+			parameter.Add(p);
+		.)
+		{
+			&quot;,&quot;	(. attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); .)
+			{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
+			(
+				FormalParameter &lt;out p&gt;	(. p.Attributes = attributes; parameter.Add(p); .)
+			)
+		}
+	)
+	.
+/* 9.2.5 */
+FormalParameter&lt;out ParameterDeclarationExpression p&gt;
+	(.
+		TypeReference type = null;
+		ParamModifiers mod = new ParamModifiers(this);
+		Expression expr = null;
+		p = null;
+		ArrayList arrayModifiers = null;
+	.) =
+	{ ParameterModifier&lt;mod&gt; }
+	Identifier (. string parameterName = t.val; .)
+	[ IF(IsRank()) ArrayTypeModifiers&lt;out arrayModifiers&gt; ]
+	[ &quot;As&quot; TypeName&lt;out type&gt; ]
+	(.
+		if(type != null) {
+			if (arrayModifiers != null) {
+				if (type.RankSpecifier != null) {
+					Error(&quot;array rank only allowed one time&quot;);
+				} else {
+					type.RankSpecifier = arrayModifiers;
+				}
+			}
+		} else {
+			type = new TypeReference(&quot;System.Object&quot;, arrayModifiers);
+		}
+	.)
+	[ &quot;=&quot; Expr&lt;out expr&gt; ]
+	(.
+		mod.Check();
+		p = new ParameterDeclarationExpression(type, parameterName, mod, expr);
+	.)
+	.
+
+/* 10.1 */
+Block&lt;out Statement stmt&gt;
+	=
+	(.
+		BlockStatement blockStmt = new BlockStatement();
+		blockStmt.StartLocation = t.Location;
+		compilationUnit.BlockStart(blockStmt);
+	.)
+	{ Statement EndOfStmt |
+	  IF (IsEndStmtAhead()) &quot;End&quot; EndOfStmt (. compilationUnit.AddChild(new EndStatement()); .) 
+	}
+	(.
+		stmt = blockStmt;
+		blockStmt.EndLocation = t.EndLocation;
+		compilationUnit.BlockEnd();
+	.)
+	.
+
+Statement
+	(.
+		Statement stmt;
+		string label = String.Empty;
+		
+	.) =
+	IF (IsLabel()) LabelName&lt;out label&gt;
+	(.
+		labelStatement = new LabelStatement(t.val);
+		compilationUnit.AddChild(labelStatement);
+	.)
+	&quot;:&quot; [ (. isLabel = true; .) Statement ]
+	| EmbeddedStatement&lt;out stmt&gt;			(. updateLabelStatement(stmt); .)
+	| LocalDeclarationStatement&lt;out stmt&gt;	(. updateLabelStatement(stmt); .)
+	.
+
+/* 10.2 */
+LocalDeclarationStatement&lt;out Statement statement&gt;
+	(.
+		Modifiers m = new Modifiers(this);
+		ArrayList vars = new ArrayList();
+		LocalVariableDeclaration localVariableDeclaration;
+		bool dimfound = false;
+	.) =
+	/* this differs from the spec: dim static x	compiles with vbc. */
+	{
+		&quot;Const&quot; 	(. m.Add(Modifier.Constant); .)
+		| &quot;Static&quot;	(. m.Add(Modifier.Static); .)
+		| &quot;Dim&quot;		(. dimfound = true; .)
+	}
+	(.
+		if(dimfound &amp;&amp; (m.Modifier &amp; Modifier.Constant) != 0) {
+			Error(&quot;Dim is not allowed on constants.&quot;);
+		}
+		
+		if(m.isNone &amp;&amp; dimfound == false) {
+			Error(&quot;Const, Dim or Static expected&quot;);
+		}
+		
+		localVariableDeclaration = new LocalVariableDeclaration(m.Modifier);
+		localVariableDeclaration.StartLocation = t.Location;
+	.)
+	VariableDeclarator&lt;vars&gt;
+	{ &quot;,&quot; VariableDeclarator&lt;vars&gt; }
+	(.
+		localVariableDeclaration.Variables = vars;
+		statement = localVariableDeclaration;
+	.)
+	.
+
+EmbeddedStatement&lt;out Statement statement&gt;
+	(.
+		Statement embeddedStatement = null;
+		statement = null;
+		Expression expr = null;
+		string name = String.Empty;
+		ArrayList p = null;
+	.) =
+		&quot;Exit&quot;				(. ExitType exitType = ExitType.None; .)
+		(
+		&quot;Sub&quot;				(. exitType = ExitType.Sub; .)
+		|
+		&quot;Function&quot;			(. exitType = ExitType.Function; .)
+		|
+		&quot;Property&quot;			(. exitType = ExitType.Property; .)
+		|
+		&quot;Do&quot;				(. exitType = ExitType.Do; .)
+		|
+		&quot;For&quot;				(. exitType = ExitType.For; .)
+		|
+		&quot;Try&quot;				(. exitType = ExitType.Try; .)
+		|
+		&quot;While&quot;				(. exitType = ExitType.While; .)
+		|
+		&quot;Select&quot;			(. exitType = ExitType.Select; .)
+		)
+	(. statement = new ExitStatement(exitType); .)
+	| TryStatement&lt;out statement&gt;
+	| /* 10.10.1.3 */
+	&quot;Throw&quot; [ Expr&lt;out expr&gt; ]				(. statement = new ThrowStatement(expr); .)
+	| /* 10.11 */
+	&quot;Return&quot; [ Expr&lt;out expr&gt; ] 			(. statement = new ReturnStatement(expr); .)
+	| /* 10.4 */
+	&quot;SyncLock&quot; Expr&lt;out expr&gt; EndOfStmt Block&lt;out embeddedStatement&gt;
+	&quot;End&quot; &quot;SyncLock&quot; 						(. statement = new LockStatement(expr, embeddedStatement); .)
+	| /* 10.5.1 */
+	&quot;RaiseEvent&quot; Identifier (. name = t.val; .)
+	[ &quot;(&quot; [ ArgumentList&lt;out p&gt; ] &quot;)&quot; ]
+	(. statement = new RaiseEventStatement(name, p); .)
+	| /* 10.3 */
+	WithStatement&lt;out statement&gt;
+	| /* 10.5.2 */
+	&quot;AddHandler&quot; (. Expression handlerExpr = null; .)
+	Expr&lt;out expr&gt; &quot;,&quot; Expr&lt;out handlerExpr&gt;
+	(.
+		statement = new AddHandlerStatement(expr, handlerExpr);
+	.)
+	| /* 10.5.2 */
+	&quot;RemoveHandler&quot; (. Expression handlerExpr = null; .)
+	Expr&lt;out expr&gt; &quot;,&quot; Expr&lt;out handlerExpr&gt;
+	(.
+		statement = new RemoveHandlerStatement(expr, handlerExpr);
+	.)
+	| /* 10.9.1 */
+	&quot;While&quot; Expr&lt;out expr&gt; EndOfStmt
+	Block&lt;out embeddedStatement&gt; &quot;End&quot; &quot;While&quot;
+	(.
+		statement = new WhileStatement(expr, embeddedStatement);
+	.)
+	| /* 10.9.1 */
+	&quot;Do&quot;
+	(.
+		ConditionType conditionType = ConditionType.None;
+	.)
+	(
+		WhileOrUntil&lt;out conditionType&gt; Expr&lt;out expr&gt; EndOfStmt
+		Block&lt;out embeddedStatement&gt;
+		&quot;Loop&quot;
+		(.
+			statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.Start);
+		.)
+		|
+		EndOfStmt
+		Block&lt;out embeddedStatement&gt;
+		&quot;Loop&quot; [WhileOrUntil&lt;out conditionType&gt; Expr&lt;out expr&gt;]
+		(.
+			statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.End);
+		.)
+	)
+	| &quot;For&quot;
+	(.
+			Expression group = null;
+			LoopControlVariableExpression loopControlExpr = null;
+	.)
+	(
+		/* 10.9.3  */
+ 		&quot;Each&quot; LoopControlVariable&lt;out loopControlExpr&gt;
+		&quot;In&quot; Expr&lt;out group&gt; EndOfStmt
+		Block&lt;out embeddedStatement&gt;
+		&quot;Next&quot; [ Expr&lt;out expr&gt; ]
+		(.
+			statement = new ForeachStatement(loopControlExpr, group, embeddedStatement, expr);
+		.)
+		| /* 10.9.2 */
+		(.
+			Expression start = null;
+			Expression end = null;
+			Expression step = null;
+			Expression nextExpr = null;
+			ArrayList nextExpressions = null;
+		.)
+		LoopControlVariable&lt;out loopControlExpr&gt;
+		&quot;=&quot; Expr&lt;out start&gt; &quot;To&quot; Expr&lt;out end&gt; [ &quot;Step&quot; Expr&lt;out step&gt; ]
+		EndOfStmt Block&lt;out embeddedStatement&gt;
+		&quot;Next&quot;
+		[
+			Expr&lt;out nextExpr&gt; (. nextExpressions = new ArrayList(); nextExpressions.Add(nextExpr); .) 
+			{ &quot;,&quot; Expr&lt;out nextExpr&gt; (. nextExpressions.Add(nextExpr); .) }
+		]
+		(.
+			statement = new ForStatement(loopControlExpr, start, end, step, embeddedStatement, nextExpressions);
+		.)
+	)
+	| /* 10.10.2.1 */
+	&quot;Error&quot; Expr&lt;out expr&gt; 				(. statement = new ErrorStatement(expr); .)
+	| /* 10.12.1 */
+	&quot;ReDim&quot; (. Expression clause = null; .) [ &quot;Preserve&quot; ]
+	Expr&lt;out clause&gt;
+	(.
+		ArrayList clauses = new ArrayList();
+		clauses.Add(clause);
+		ReDimStatement reDimStatement = new ReDimStatement(clauses);
+	.)
+	{ &quot;,&quot; Expr&lt;out clause&gt; (. clauses.Add(clause); .) }
+	| /* 10.12.2 */
+	&quot;Erase&quot;	
+	Expr&lt;out expr&gt;
+	(.
+		ArrayList arrays = new ArrayList();
+		arrays.Add(expr);
+		EraseStatement eraseStatement = new EraseStatement(arrays);
+		
+	.)
+	{ &quot;,&quot; Expr&lt;out expr&gt; (. arrays.Add(expr); .) }
+	(. statement = eraseStatement; .)
+	| /* 10.11 */
+	&quot;Stop&quot; (. statement = new StopStatement(); .)
+	| /* 10.8.1 */
+	&quot;If&quot; Expr&lt;out expr&gt; [ &quot;Then&quot; ] 
+	(	
+		IF (IsEndStmtAhead()) &quot;End&quot; (. statement = new IfStatement(expr, new EndStatement()); .) 
+		|
+		/* multiline if statement */
+		EndOfStmt Block&lt;out embeddedStatement&gt;
+		(.
+			ArrayList elseIfSections = new ArrayList();
+			IfStatement ifStatement = new IfStatement(expr, embeddedStatement);
+		.)
+		{
+			(
+				IF(IsElseIf()) &quot;Else&quot; &quot;If&quot;
+				| &quot;ElseIf&quot;
+			)
+			(. Expression condition = null; Statement block = null; .)
+			Expr&lt;out condition&gt; [ &quot;Then&quot;] EndOfStmt
+			Block&lt;out block&gt;
+			(.
+				ElseIfSection elseIfSection = new ElseIfSection(condition, block);
+				elseIfSections.Add(elseIfSection);
+			.)
+		}
+		[
+			&quot;Else&quot; EndOfStmt
+			Block&lt;out embeddedStatement&gt;
+			(.
+				ifStatement.EmbeddedElseStatement = embeddedStatement;
+			.)
+		] &quot;End&quot; &quot;If&quot;
+		(.
+			ifStatement.ElseIfStatements = elseIfSections;
+			statement = ifStatement;
+		.)
+		| /* singleline if statement */
+		EmbeddedStatement&lt;out embeddedStatement&gt;
+		(.
+			SimpleIfStatement ifStatement = new SimpleIfStatement(expr);
+			ArrayList statements = new ArrayList();
+			statements.Add(embeddedStatement);
+			ifStatement.Statements = statements;
+		.)
+		{ &quot;:&quot; EmbeddedStatement&lt;out embeddedStatement&gt; (. statements.Add(embeddedStatement); .) }
+		[
+			&quot;Else&quot; [ EmbeddedStatement&lt;out embeddedStatement&gt; ]
+			(.
+				ArrayList elseStatements = new ArrayList();
+				elseStatements.Add(embeddedStatement);
+				ifStatement.ElseStatements = elseStatements;
+			.)
+			{
+				&quot;:&quot; EmbeddedStatement&lt;out embeddedStatement&gt;
+				(. elseStatements.Add(embeddedStatement); .)
+			}
+		]
+		(. statement = ifStatement; .)
+	)
+	| /* 10.8.2 */
+	&quot;Select&quot; [ &quot;Case&quot; ] Expr&lt;out expr&gt; EndOfStmt
+	(.
+		ArrayList selectSections = new ArrayList();
+		Statement block = null;
+	.)
+	{
+		(. ArrayList caseClauses = null; .)
+		&quot;Case&quot; CaseClauses&lt;out caseClauses&gt; [ IF(IsNotStatementSeparator()) &quot;:&quot; ] EndOfStmt
+		(.
+			SelectSection selectSection = new SelectSection();
+			selectSection.CaseClauses = caseClauses;
+			compilationUnit.BlockStart(selectSection);
+		.)
+		Block&lt;out block&gt;
+		(.
+			selectSection.EmbeddedStatement = block;
+			compilationUnit.BlockEnd();
+			selectSections.Add(selectSection);
+		.)
+	}
+	(. statement = new SelectStatement(expr, selectSections); .)
+	&quot;End&quot; &quot;Select&quot;
+	| (. OnErrorStatement onErrorStatement = null; .)
+	OnErrorStatement&lt;out onErrorStatement&gt; (. statement = onErrorStatement; .)
+	| (. GoToStatement goToStatement = null; .)
+	GoToStatement&lt;out goToStatement&gt; (. statement = goToStatement; .)
+	| (. ResumeStatement resumeStatement = null; .)
+	ResumeStatement&lt;out resumeStatement&gt; (. statement = resumeStatement; .)
+	|/* Statement expression (invocation and assignment) 10.6.1, 10.6.2, 10.6.3 */
+	(.
+		Expression val = null;
+		AssignmentOperatorType op;
+		
+		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
+		                        la.kind == Tokens.Not   || la.kind == Tokens.Times;
+	.)
+	UnaryExpr&lt;out expr&gt;
+		(
+		AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt;	(. expr = new AssignmentExpression(expr, op, val); .)
+		| (. if (mustBeAssignment) Error(&quot;error in assignment.&quot;); .)
+		)
+		(.
+			// a field reference expression that stands alone is a
+			// invocation expression without parantheses and arguments
+			if(expr is FieldReferenceOrInvocationExpression) {
+				expr = new InvocationExpression(expr, new ArrayList());
+			}
+			statement = new StatementExpression(expr);
+		.)
+	| &quot;Call&quot; UnaryExpr&lt;out expr&gt; (. statement = new StatementExpression(expr); .)
+	.
+
+/* 10.9.2 */
+LoopControlVariable&lt;out LoopControlVariableExpression loopExpr&gt;
+	(.
+		loopExpr = null;
+		//Expression expr = null;
+		TypeReference type = null;
+		ArrayList arrayModifiers = null;
+		string name;
+	.) =
+	Qualident&lt;out name&gt;
+	[ IF(IsRank()) ArrayTypeModifiers&lt;out arrayModifiers&gt; ]
+	[ &quot;As&quot; TypeName&lt;out type&gt; (. if (name.IndexOf('.') &gt; 0) { Error(&quot;No type def for 'for each' member indexer allowed.&quot;); } .) ]
+	(.
+		if(type != null) {
+			if(type.RankSpecifier != null &amp;&amp; arrayModifiers != null) {
+				Error(&quot;array rank only allowed one time&quot;);
+			} else {
+				type.RankSpecifier = arrayModifiers;
+			}
+		} else {
+			type = new TypeReference(&quot;Integer&quot;, arrayModifiers);
+		}
+		loopExpr = new LoopControlVariableExpression(name, type);
+	.)
+	.
+
+/* 10.2.2 */
+OnErrorStatement&lt;out OnErrorStatement stmt&gt;
+	(.
+		stmt = null;
+		GoToStatement goToStatement = null;
+	.)
+	=
+	&quot;On&quot; &quot;Error&quot;
+	(
+		IF(IsNegativeLabelName())&quot;GoTo&quot; &quot;-&quot; LiteralInteger
+		(.
+			long intLabel = Int64.Parse(t.val);
+			if(intLabel != 1) {
+				Error(&quot;invalid label in on error statement.&quot;);
+			}
+			stmt = new OnErrorStatement(new GoToStatement((intLabel * -1).ToString()));
+		.)
+		| GoToStatement&lt;out goToStatement&gt;
+		(.
+			string val = goToStatement.LabelName;
+			
+			// if value is numeric, make sure that is 0
+			try {
+				long intLabel = Int64.Parse(val);
+				if(intLabel != 0) {
+					Error(&quot;invalid label in on error statement.&quot;);
+				}
+			} catch {
+			}
+			stmt = new OnErrorStatement(goToStatement);
+		.)
+		| &quot;Resume&quot; &quot;Next&quot;
+		(.
+			stmt = new OnErrorStatement(new ResumeStatement(true));
+		.)
+	)
+	.
+
+/* 10.11 */
+GoToStatement&lt;out GoToStatement goToStatement&gt;
+	(.
+		string label = String.Empty;
+	.)
+	=
+	&quot;GoTo&quot; LabelName&lt;out label&gt;
+	(.
+		goToStatement = new GoToStatement(label);
+	.)
+	.
+
+/* 10.1 */
+LabelName&lt;out string name&gt;
+	(.
+		name = String.Empty;
+	.) =
+	Identifier 				(. name = t.val; .)
+	| LiteralInteger	(. name = t.val; .)
+	.
+
+/* 10.10.2.3 */
+ResumeStatement&lt;out ResumeStatement resumeStatement&gt;
+	(.
+		resumeStatement = null;
+		string label = String.Empty;
+	.) =
+	IF(IsResumeNext())
+	&quot;Resume&quot; &quot;Next&quot; 					(. resumeStatement = new ResumeStatement(true); .)
+	| &quot;Resume&quot; [ LabelName&lt;out label&gt; ]	(. resumeStatement = new ResumeStatement(label); .)
+	.
+
+/* 18.8.2 */
+CaseClauses&lt;out ArrayList caseClauses&gt;
+	(.
+		caseClauses = null;
+		CaseClause caseClause = null;
+	.) =
+	CaseClause&lt;out caseClause&gt;
+	(.
+		caseClauses = new ArrayList();
+		caseClauses.Add(caseClause);
+	.)
+	{ &quot;,&quot; CaseClause&lt;out caseClause&gt; (. caseClauses.Add(caseClause); .) }
+	.
+
+/* 19.8.2 */
+CaseClause&lt;out CaseClause caseClause&gt;
+	(.
+		Expression expr = null;
+		Expression sexpr = null;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		caseClause = null;
+	.) =
+	&quot;Else&quot;
+	(. caseClause = new CaseClause(true); .)
+	|
+	[ &quot;Is&quot; ] 
+	(
+		&quot;&lt;&quot;		(. op = BinaryOperatorType.LessThan; .)
+		| &quot;&gt;&quot;	(. op = BinaryOperatorType.GreaterThan; .)
+		| &quot;&lt;=&quot;	(. op = BinaryOperatorType.LessThanOrEqual; .)
+		| &quot;&gt;=&quot;	(. op = BinaryOperatorType.GreaterThanOrEqual; .)
+		| &quot;=&quot;	(. op = BinaryOperatorType.Equality; .)
+		| &quot;&lt;&gt;&quot;	(. op = BinaryOperatorType.InEquality; .)
+	)
+	Expr&lt;out expr&gt;
+	(.
+		caseClause = new CaseClause(op, expr);
+	.)
+	| Expr&lt;out expr&gt; [ &quot;To&quot; Expr&lt;out sexpr&gt; ]
+	(.
+		caseClause = new CaseClause(expr, sexpr);
+	.)
+	.
+
+/* 10.9.1 */
+WhileOrUntil&lt;out ConditionType conditionType&gt;
+	(. conditionType = ConditionType.None; .) =
+	&quot;While&quot;		(. conditionType = ConditionType.While; .)
+	| &quot;Until&quot;	(. conditionType = ConditionType.Until; .)
+	.
+
+/* 10.3 */
+WithStatement&lt;out Statement withStatement&gt;
+	(.
+		Statement blockStmt = null;
+		Expression expr = null;
+	.) =
+	&quot;With&quot; (. Point start = t.Location; .)
+	Expr&lt;out expr&gt; EndOfStmt
+	(.
+		withStatement = new WithStatement(expr);
+		withStatement.StartLocation = start;
+		withStatements.Push(withStatement);
+	.)
+	Block&lt;out blockStmt&gt;
+	(.
+		((WithStatement)withStatement).Body = (BlockStatement)blockStmt;
+		withStatements.Pop();
+	.)
+	&quot;End&quot; &quot;With&quot;
+	(. withStatement.EndLocation = t.Location; .)
+	.
+	
+/* 10.10.1 */
+TryStatement&lt;out Statement tryStatement&gt;
+	(.
+		Statement blockStmt = null, finallyStmt = null;
+		ArrayList catchClauses = null;
+	.) =
+	&quot;Try&quot; EndOfStmt
+	Block&lt;out blockStmt&gt;
+	(
+		CatchClauses&lt;out catchClauses&gt;
+		[ &quot;Finally&quot; EndOfStmt Block&lt;out finallyStmt&gt; ]
+		| &quot;Finally&quot; EndOfStmt Block&lt;out finallyStmt&gt;
+	)
+	&quot;End&quot; &quot;Try&quot;
+	(.
+		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
+	.)
+	.
+
+/* 10.10.1.2 */
+CatchClauses&lt;out ArrayList catchClauses&gt;
+	(.
+		catchClauses = new ArrayList();
+		TypeReference type = null;
+		Statement blockStmt = null;
+		Expression expr = null;
+		string name = String.Empty;
+	.) =
+	{
+		&quot;Catch&quot;
+		[ Identifier (. name = t.val; .) [&quot;As&quot; TypeName&lt;out type&gt;] ]
+		[ &quot;When&quot; Expr&lt;out expr&gt; ]
+		EndOfStmt
+		Block&lt;out blockStmt&gt;
+		(. catchClauses.Add(new CatchClause(type, name, blockStmt, expr)); .)
+	}
+	.
+
+/* 4.7 */
+Qualident&lt;out string qualident&gt;
+	(. string name = String.Empty; .) =
+	Identifier	(. StringBuilder qualidentBuilder = new StringBuilder(t.val); .)
+	{
+		&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. qualidentBuilder.Append('.');
+	                                         qualidentBuilder.Append(name); 
+	                                       .)
+	}
+	(. qualident = qualidentBuilder.ToString(); .)
+	.
+
+/* This production handles pseudo keywords that are needed in the grammar */
+Identifier	=
+	ident
+	| &quot;Text&quot;
+	| &quot;Binary&quot;
+	| &quot;Compare&quot;
+	.
+
+/* 2.2 */
+IdentifierOrKeyword&lt;out string name&gt;
+	(.
+		name = String.Empty;
+	.) =
+	Identifier		(. name = t.val; .)
+	| &quot;AddHandler&quot;		(. name = t.val; .)
+	| &quot;AddressOf&quot;		(. name = t.val; .)
+	| &quot;Alias&quot;			(. name = t.val; .)
+	| &quot;And&quot;				(. name = t.val; .)
+	| &quot;AndAlso&quot;			(. name = t.val; .)
+	| &quot;Ansi&quot;			(. name = t.val; .)
+	| &quot;As&quot;				(. name = t.val; .)
+	| &quot;Assembly&quot;		(. name = t.val; .)
+	| &quot;Auto&quot;			(. name = t.val; .)
+	| &quot;Boolean&quot;			(. name = t.val; .)
+	| &quot;ByRef&quot;			(. name = t.val; .)
+	| &quot;Byte&quot;			(. name = t.val; .)
+	| &quot;ByVal&quot;			(. name = t.val; .)
+	| &quot;Call&quot;			(. name = t.val; .)
+	| &quot;Case&quot;			(. name = t.val; .)
+	| &quot;Catch&quot;			(. name = t.val; .)
+	| &quot;CBool&quot;			(. name = t.val; .)
+	| &quot;CByte&quot;			(. name = t.val; .)
+	| &quot;CChar&quot;			(. name = t.val; .)
+	| &quot;CDate&quot;			(. name = t.val; .)
+	| &quot;CDbl&quot;			(. name = t.val; .)
+	| &quot;CDec&quot;			(. name = t.val; .)
+	| &quot;Char&quot;			(. name = t.val; .)
+	| &quot;CInt&quot;			(. name = t.val; .)
+	| &quot;Class&quot;			(. name = t.val; .)
+	| &quot;CLng&quot;			(. name = t.val; .)
+	| &quot;CObj&quot;			(. name = t.val; .)
+	| &quot;Const&quot;			(. name = t.val; .)
+	| &quot;CShort&quot;			(. name = t.val; .)
+	| &quot;CSng&quot;			(. name = t.val; .)
+	| &quot;CStr&quot;			(. name = t.val; .)
+	| &quot;CType&quot;			(. name = t.val; .)
+	| &quot;Date&quot;			(. name = t.val; .)
+	| &quot;Decimal&quot;			(. name = t.val; .)
+	| &quot;Declare&quot;			(. name = t.val; .)
+	| &quot;Default&quot;			(. name = t.val; .)
+	| &quot;Delegate&quot;		(. name = t.val; .)
+	| &quot;Dim&quot;				(. name = t.val; .)
+	| &quot;DirectCast&quot;		(. name = t.val; .)
+	| &quot;Do&quot;				(. name = t.val; .)
+	| &quot;Double&quot;			(. name = t.val; .)
+	| &quot;Each&quot;			(. name = t.val; .)
+	| &quot;Else&quot;			(. name = t.val; .)
+	| &quot;ElseIf&quot;			(. name = t.val; .)
+	| &quot;End&quot;				(. name = t.val; .)
+	| &quot;EndIf&quot;			(. name = t.val; .)
+	| &quot;Enum&quot;			(. name = t.val; .)
+	| &quot;Erase&quot;			(. name = t.val; .)
+	| &quot;Error&quot;			(. name = t.val; .)
+	| &quot;Event&quot;			(. name = t.val; .)
+	| &quot;Exit&quot;			(. name = t.val; .)
+	| &quot;False&quot;			(. name = t.val; .)
+	| &quot;Finally&quot;			(. name = t.val; .)
+	| &quot;For&quot;				(. name = t.val; .)
+	| &quot;Friend&quot;			(. name = t.val; .)
+	| &quot;Function&quot;		(. name = t.val; .)
+	| &quot;Get&quot;				(. name = t.val; .)
+	| &quot;GetType&quot;			(. name = t.val; .)
+	| &quot;GoSub&quot;			(. name = t.val; .)
+	| &quot;GoTo&quot;			(. name = t.val; .)
+	| &quot;Handles&quot;			(. name = t.val; .)
+	| &quot;If&quot;				(. name = t.val; .)
+	| &quot;Implements&quot;		(. name = t.val; .)
+	| &quot;Imports&quot;			(. name = t.val; .)
+	| &quot;In&quot;				(. name = t.val; .)
+	| &quot;Inherits&quot;		(. name = t.val; .)
+	| &quot;Integer&quot;			(. name = t.val; .)
+	| &quot;Interface&quot;		(. name = t.val; .)
+	| &quot;Is&quot;				(. name = t.val; .)
+	| &quot;Let&quot;				(. name = t.val; .)
+	| &quot;Lib&quot;				(. name = t.val; .)
+	| &quot;Like&quot;			(. name = t.val; .)
+	| &quot;Long&quot;			(. name = t.val; .)
+	| &quot;Loop&quot;			(. name = t.val; .)
+	| &quot;Me&quot;				(. name = t.val; .)
+	| &quot;Mod&quot;				(. name = t.val; .)
+	| &quot;Module&quot;			(. name = t.val; .)
+	| &quot;MustInherit&quot;		(. name = t.val; .)
+	| &quot;MustOverride&quot;	(. name = t.val; .)
+	| &quot;MyBase&quot;			(. name = t.val; .)
+	| &quot;MyClass&quot;			(. name = t.val; .)
+	| &quot;Namespace&quot;		(. name = t.val; .)
+	| &quot;New&quot;				(. name = t.val; .)
+	| &quot;Next&quot;			(. name = t.val; .)
+	| &quot;Not&quot;				(. name = t.val; .)
+	| &quot;Nothing&quot;			(. name = t.val; .)
+	| &quot;NotInheritable&quot;	(. name = t.val; .)
+	| &quot;NotOverridable&quot;	(. name = t.val; .)
+	| &quot;Object&quot;			(. name = t.val; .)
+	| &quot;On&quot;				(. name = t.val; .)
+	| &quot;Option&quot;			(. name = t.val; .)
+	| &quot;Optional&quot;		(. name = t.val; .)
+	| &quot;Or&quot;				(. name = t.val; .)
+	| &quot;OrElse&quot;			(. name = t.val; .)
+	| &quot;Overloads&quot;		(. name = t.val; .)
+	| &quot;Overridable&quot;		(. name = t.val; .)
+	| &quot;Overrides&quot;		(. name = t.val; .)
+	| &quot;ParamArray&quot;		(. name = t.val; .)
+	| &quot;Preserve&quot;		(. name = t.val; .)
+	| &quot;Private&quot;			(. name = t.val; .)
+	| &quot;Property&quot;		(. name = t.val; .)
+	| &quot;Protected&quot;		(. name = t.val; .)
+	| &quot;Public&quot;			(. name = t.val; .)
+	| &quot;RaiseEvent&quot;		(. name = t.val; .)
+	| &quot;ReadOnly&quot;		(. name = t.val; .)
+	| &quot;ReDim&quot;			(. name = t.val; .)
+	| &quot;RemoveHandler&quot;	(. name = t.val; .)
+	| &quot;Resume&quot;			(. name = t.val; .)
+	| &quot;Return&quot;			(. name = t.val; .)
+	| &quot;Select&quot;			(. name = t.val; .)
+	| &quot;Set&quot;				(. name = t.val; .)
+	| &quot;Shadows&quot;			(. name = t.val; .)
+	| &quot;Shared&quot;			(. name = t.val; .)
+	| &quot;Short&quot;			(. name = t.val; .)
+	| &quot;Single&quot;			(. name = t.val; .)
+	| &quot;Static&quot;			(. name = t.val; .)
+	| &quot;Step&quot;			(. name = t.val; .)
+	| &quot;Stop&quot;			(. name = t.val; .)
+	| &quot;String&quot;			(. name = t.val; .)
+	| &quot;Structure&quot;		(. name = t.val; .)
+	| &quot;Sub&quot;				(. name = t.val; .)
+	| &quot;SyncLock&quot;		(. name = t.val; .)
+	| &quot;Then&quot;			(. name = t.val; .)
+	| &quot;Throw&quot;			(. name = t.val; .)
+	| &quot;To&quot;				(. name = t.val; .)
+	| &quot;True&quot;			(. name = t.val; .)
+	| &quot;Try&quot;				(. name = t.val; .)
+	| &quot;TypeOf&quot;			(. name = t.val; .)
+	| &quot;Unicode&quot;			(. name = t.val; .)
+	| &quot;Until&quot;			(. name = t.val; .)
+	| &quot;Variant&quot;			(. name = t.val; .)
+	| &quot;Wend&quot;			(. name = t.val; .)
+	| &quot;When&quot;			(. name = t.val; .)
+	| &quot;While&quot;			(. name = t.val; .)
+	| &quot;With&quot;			(. name = t.val; .)
+	| &quot;WithEvents&quot;		(. name = t.val; .)
+	| &quot;WriteOnly&quot;		(. name = t.val; .)
+	| &quot;Xor&quot;				(. name = t.val; .)
+	.
+
+/* 7.3 */
+PrimitiveTypeName&lt;out string type&gt;
+	(. type = String.Empty; .) =
+	&quot;Boolean&quot;		(. type = &quot;Boolean&quot;; .)
+	| &quot;Date&quot;		(. type = &quot;Date&quot;; .)
+	| &quot;Char&quot;		(. type = &quot;Char&quot;; .)
+	| &quot;String&quot;		(. type = &quot;String&quot;; .)
+	| &quot;Decimal&quot;		(. type = &quot;Decimal&quot;; .)
+	| &quot;Byte&quot;		(. type = &quot;Byte&quot;; .)
+	| &quot;Short&quot;		(. type = &quot;Short&quot;; .)
+	| &quot;Integer&quot;		(. type = &quot;Integer&quot;; .)
+	| &quot;Long&quot;		(. type = &quot;Long&quot;; .)
+	| &quot;Single&quot;		(. type = &quot;Single&quot;; .)
+	| &quot;Double&quot;		(. type = &quot;Double&quot;; .)
+	.
+
+ParameterModifier&lt;ParamModifiers m&gt;
+	= &quot;ByVal&quot;			(. m.Add(ParamModifier.ByVal); .)
+	| &quot;ByRef&quot;			(. m.Add(ParamModifier.ByRef); .)
+	| &quot;Optional&quot;		(. m.Add(ParamModifier.Optional); .)
+	| &quot;ParamArray&quot;		(. m.Add(ParamModifier.ParamArray); .)
+	.
+
+TypeModifier&lt;Modifiers m&gt;
+	= &quot;Public&quot;			(. m.Add(Modifier.Public); .)
+	| &quot;Protected&quot;		(. m.Add(Modifier.Protected); .)
+	| &quot;Friend&quot;			(. m.Add(Modifier.Friend); .)
+	| &quot;Private&quot;			(. m.Add(Modifier.Private); .)
+	| &quot;Shared&quot;			(. m.Add(Modifier.Shared); .)
+	| &quot;Shadows&quot;			(. m.Add(Modifier.Shadows); .)
+	| &quot;MustInherit&quot;		(. m.Add(Modifier.MustInherit); .)
+	| &quot;NotInheritable&quot;	(. m.Add(Modifier.NotInheritable); .)
+	.
+
+MemberModifier&lt;Modifiers m&gt; =
+	&quot;MustInherit&quot;		(.m.Add(Modifier.MustInherit);.)
+	|&quot;Default&quot;			(.m.Add(Modifier.Default);.)
+	|&quot;Friend&quot;			(.m.Add(Modifier.Friend);.)
+	|&quot;Shadows&quot;			(.m.Add(Modifier.Shadows);.)
+	|&quot;Overrides&quot;		(.m.Add(Modifier.Overrides);.)
+	|&quot;MustOverride&quot;		(.m.Add(Modifier.MustOverride);.)
+	|&quot;Private&quot;			(.m.Add(Modifier.Private);.)
+	|&quot;Protected&quot;		(.m.Add(Modifier.Protected);.)
+	|&quot;Public&quot;			(.m.Add(Modifier.Public);.)
+	|&quot;NotInheritable&quot;	(.m.Add(Modifier.NotInheritable);.)
+	|&quot;NotOverridable&quot;	(.m.Add(Modifier.NotOverridable);.)
+	|&quot;Shared&quot;			(.m.Add(Modifier.Shared);.)
+	|&quot;Overridable&quot;		(.m.Add(Modifier.Overridable);.)
+	|&quot;Overloads&quot;		(.m.Add(Modifier.Overloads);.)
+	| &quot;ReadOnly&quot;		(.m.Add(Modifier.ReadOnly);.)
+	| &quot;WriteOnly&quot;		(.m.Add(Modifier.WriteOnly);.)
+	| &quot;WithEvents&quot;		(.m.Add(Modifier.WithEvents);.)
+	| &quot;Dim&quot;				(.m.Add(Modifier.Dim);.)
+	.
+
+END VBNET.

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,4 @@
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">+ at echo</A> off
+SharpCoco -namespace ICSharpCode.SharpRefactory.Parser.VB VBNET.ATG
+del Parser.old.cs
+pause
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,222 @@
+#!/bin/perl
+
+# File names
+$keyword_file     = &quot;KeywordList.txt&quot;;
+$keywords_outfile = &quot;Keywords.cs&quot;;
+$tokens_outfile   = &quot;Tokens.cs&quot;;
+$ATGTokensSection = &quot;ATGTokensSection.gen&quot;;
+
+#read infile
+print &quot;\n&quot;;
+print &quot;Reading keyword definition from '$keyword_file'.\n&quot;;
+open(DAT, $keyword_file) || die(&quot;Could not open file!&quot;);
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">+ at raw_data</A>=&lt;DAT&gt;;
+close(DAT);
+print &quot;done.\n&quot;;
+
+#analyse infile
+print &quot;starting analysation ... this could take a few minutes.\n&quot;;
+
+foreach (@raw_data) {
+	if ($_=~/\A\s*\$(\w+)\s*=\s*(\S+)/) {
+		#properties form: $PROPERTY = &quot;VALUE&quot;
+		$properties{$1} = $2;
+	} elsif  ($_=~/\A\s*(\w+)\s*=\s*(\S+)/) {
+		#special characters form: name = &quot;VALUE&quot;
+		$special_chars[$#special_chars + 1] = $1;
+		$special_values[$#special_values + 1] = $2;
+	} elsif  ($_=~/\A\s*\&quot;(\S+)\s*\&quot;/) {
+		#special keywords form: &quot;VALUE&quot;
+		$keywords[$#keywords + 1] = $1
+	} elsif  ($_=~/\A\s*(\w+)\s*/) {
+		#special terminal classes form: name
+		$terminals[$#terminals + 1] = $1
+	}
+}
+
+for ($i=0; $i &lt;= $#keywords; $i++) {
+	$upperKeywords[$i] = uc $keywords[$i];
+}
+sort (ascend @upperKeywords);
+
+
+sort (ascend @keywords);
+print &quot;done.\n&quot;;
+
+#write output
+print &quot;writing output files.\nIf your computer doesn&#146;t respond, then press \&quot;Ctrl-Alt-Delete\&quot;\n&quot;;
+print &quot;\n&quot;;
+&amp;write_keywordfile;
+print &quot;\n&quot;;
+&amp;write_tokensfile;
+print &quot;\n&quot;;
+&amp;write_atgtokensfile;
+print &quot;\n&quot;;
+print &quot;finished.\n&quot;;
+
+sub write_keywordfile {
+	print &quot;  -&gt;Generating Keywords class to file '$keywords_outfile'\n&quot;;
+	open(DAT,&quot;&gt;$keywords_outfile&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
+	print DAT &quot;using System;\n&quot;;
+	print DAT &quot;using System.Collections;\n&quot;;
+	print DAT &quot;using System.Text;\n&quot;;
+	print DAT &quot;\n&quot;;
+	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
+	print DAT &quot;{\n&quot;;
+	print DAT &quot;	public class Keywords\n&quot;;
+	print DAT &quot;	{\n&quot;;
+	print DAT &quot;		static readonly string[] keywordList = {\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		for ($i=0; $i &lt;= $#upperKeywords; $i++) {
+			print DAT &quot;			\&quot;$upperKeywords[$i]\&quot;&quot;;
+			if ($i + 1 &lt;= $#upperKeywords) {
+				print DAT &quot;,&quot;;
+			}
+			print DAT &quot;\n&quot;;
+		}
+	} else {
+		for ($i=0; $i &lt;= $#keywords; $i++) {
+			print DAT &quot;			\&quot;$keywords[$i]\&quot;&quot;;
+			if ($i + 1 &lt;= $#keywords) {
+				print DAT &quot;,&quot;;
+			}
+			print DAT &quot;\n&quot;;
+		}
+	}
+	
+	print DAT &quot;		};\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		static Hashtable keywords = new Hashtable();\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		static Keywords()\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	print DAT &quot;			for (int i = 0; i &lt; keywordList.Length; ++i) {\n&quot;;
+	print DAT &quot;				keywords.Add(keywordList[i], i + Tokens.$keywords[0]);\n&quot;;
+	print DAT &quot;			}\n&quot;;
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		public static bool IsKeyword(string identifier)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		print DAT &quot;			return keywords[identifier.ToUpper()] != null;\n&quot;;
+	} else {
+		print DAT &quot;			return keywords[identifier] != null;\n&quot;;
+	}
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		public static int GetToken(string keyword)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		print DAT &quot;			return (int)keywords[keyword.ToUpper()];\n&quot;;
+	} else {
+		print DAT &quot;			return (int)keywords[keyword];\n&quot;;
+	}
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;	}\n&quot;;
+	print DAT &quot;}\n&quot;;
+	
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+
+sub write_token {
+	$formattedString = sprintf(&quot;%-20s&quot;, $tokenName);
+	if ($tokenName eq &quot;GetType&quot;) {
+		print DAT &quot;		new public const int $formattedString = $tokenValue;\n&quot;;
+	} else {
+		print DAT &quot;		public const int $formattedString = $tokenValue;\n&quot;;
+	}
+	$tokenValue++;
+	
+}
+
+sub write_tokensfile {
+	print &quot;  -&gt;Generating Tokens class to file '$tokens_outfile'\n&quot;;
+	open(DAT,&quot;&gt;$tokens_outfile&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
+	print DAT &quot;using System;\n&quot;;
+	print DAT &quot;\n&quot;;
+	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
+	print DAT &quot;{\n&quot;;
+	print DAT &quot;	public sealed class Tokens\n&quot;;
+	print DAT &quot;	{\n&quot;;
+	$tokenValue = 0;
+	
+	print DAT &quot;		// ----- terminal classes -----\n&quot;;
+	foreach (@terminals) {
+		$tokenName = $_;
+		write_token();
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;		// ----- special character -----\n&quot;;
+	foreach (@special_chars) {
+		$tokenName = $_;
+		write_token();
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;		// ----- keywords -----\n&quot;;
+	foreach (@keywords) {
+		$tokenName = $_;
+		write_token();
+	}
+	print DAT &quot;\n&quot;;
+	
+	print DAT &quot;		public static string GetTokenString(int token)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	print DAT &quot;			switch (token) {\n&quot;;
+	for ($i = 0; $i &lt;= $#special_chars; $i++) {
+		print DAT &quot;				case $special_chars[$i]:\n&quot;;
+		print DAT &quot;					return $special_values[$i];\n&quot;;
+	}
+	foreach (@keywords) {
+		print DAT &quot;				case $_:\n&quot;;
+		print DAT &quot;					return \&quot;$_\&quot;;\n&quot;;
+	}
+	
+	print DAT &quot;			}\n&quot;;
+	print DAT &quot;			throw new System.NotSupportedException(\&quot;Unknown token:\&quot; + token);\n&quot;;
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;	}\n&quot;;
+	
+	
+	
+	print DAT &quot;}\n&quot;;
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+
+sub write_atgtokensfile {
+	print &quot;  -&gt;Generating ATG TOKENS section and writing it to file '$ATGTokensSection'\n&quot;;
+	open(DAT,&quot;&gt;$ATGTokensSection&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;/* START AUTOGENERATED TOKENS SECTION */\n&quot;;
+	print DAT &quot;TOKENS\n&quot;;
+
+	print DAT &quot;	/* ----- terminal classes ----- */\n&quot;;
+	print DAT &quot;	/* EOF is 0 */\n&quot;;
+	foreach $term (@terminals) {
+		if ($term eq &quot;EOF&quot;) {
+		} elsif ($term eq &quot;Identifier&quot;) {
+			print DAT &quot;\tident\n&quot;;
+		} else {
+			print DAT &quot;\t$term\n&quot;;
+		}
+			
+	}
+	
+	print DAT &quot;\n&quot;;
+	print DAT &quot;	/* ----- special character ----- */\n&quot;;
+	foreach (@special_values) {
+		print DAT &quot;\t$_\n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;	/* ----- keywords ----- */\n&quot;;
+	foreach (@keywords) {
+		print DAT &quot;\t\&quot;$_\&quot;\n&quot;;
+	}
+
+	print DAT &quot;/* END AUTOGENERATED TOKENS SECTION */\n&quot;;
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,211 @@
+# this list is used for autogeneration of:
+# - Keywords.cs
+# - Tokens.cs
+# - ATGTokensSection.txt - the TOKENS section of the ATG file
+
+# use BuildKeywords to generate the different lists.
+
+$Namespace=ICSharpCode.SharpRefactory.Parser.VB
+$UpperCaseKeywords=True
+
+# TERMINAL_CLASSES
+EOF
+EOL
+Identifier
+LiteralString
+LiteralCharacter
+LiteralInteger
+LiteralDouble
+LiteralSingle
+LiteralDecimal
+LiteralDate
+
+# SPECIAL_CHARACTERS
+Dot = &quot;.&quot;
+Assign = &quot;=&quot;
+Comma = &quot;,&quot;
+Colon =&quot;:&quot;
+Plus = &quot;+&quot;
+Minus = &quot;-&quot;
+Times = &quot;*&quot;
+Div =&quot;/&quot;
+DivInteger = &quot;\\&quot;
+ConcatString = &quot;&amp;&quot;
+Power = &quot;^&quot;
+	
+OpenCurlyBrace = &quot;{&quot;
+CloseCurlyBrace = &quot;}&quot;
+	
+OpenSquareBracket = &quot;[&quot;
+CloseSquareBracket =&quot;]&quot;
+	
+OpenParenthesis = &quot;(&quot;
+CloseParenthesis = &quot;)&quot;
+	
+GreaterThan = &quot;&gt;&quot;
+LessThan = &quot;&lt;&quot;
+	
+NotEqual = &quot;&lt;&gt;&quot;
+GreaterEqual = &quot;&gt;=&quot;
+LessEqual = &quot;&lt;=&quot;
+	
+ShiftLeft = &quot;&lt;&lt;&quot;
+ShiftRight = &quot;&gt;&gt;&quot;
+	
+PlusAssign = &quot;+=&quot;
+PowerAssign = &quot;^=&quot;
+MinusAssign = &quot;-=&quot;
+TimesAssign = &quot;*=&quot;
+DivAssign = &quot;/=&quot;
+DivIntegerAssign = &quot;\\=&quot;
+ShiftLeftAssign = &quot;&lt;&lt;=&quot;
+ShiftRightAssign = &quot;&gt;&gt;=&quot;
+ConcatStringAssign = &quot;&amp;=&quot;
+
+# keywords according to the spec:
+# Keywordlist
+&quot;AddHandler&quot;
+&quot;AddressOf&quot;
+&quot;Alias&quot;
+&quot;And&quot;
+&quot;AndAlso&quot;
+&quot;Ansi&quot;
+&quot;As&quot;
+&quot;Assembly&quot;
+&quot;Auto&quot;
+&quot;Binary&quot;
+&quot;Boolean&quot;
+&quot;ByRef&quot;
+&quot;Byte&quot;
+&quot;ByVal&quot;
+&quot;Call&quot;
+&quot;Case&quot;
+&quot;Catch&quot;
+&quot;CBool&quot;
+&quot;CByte&quot;
+&quot;CChar&quot;
+&quot;CDate&quot;
+&quot;CDbl&quot;
+&quot;CDec&quot;
+&quot;Char&quot;
+&quot;CInt&quot;
+&quot;Class&quot;
+&quot;CLng&quot;
+&quot;CObj&quot;
+&quot;Compare&quot;
+&quot;Const&quot;
+&quot;CShort&quot;
+&quot;CSng&quot;
+&quot;CStr&quot;
+&quot;CType&quot;
+&quot;Date&quot;
+&quot;Decimal&quot;
+&quot;Declare&quot;
+&quot;Default&quot;
+&quot;Delegate&quot;
+&quot;Dim&quot;
+&quot;DirectCast&quot;
+&quot;Do&quot;
+&quot;Double&quot;
+&quot;Each&quot;
+&quot;Else&quot;
+&quot;ElseIf&quot;
+&quot;End&quot;
+&quot;EndIf&quot;
+&quot;Enum&quot;
+&quot;Erase&quot;
+&quot;Error&quot;
+&quot;Event&quot;
+&quot;Exit&quot;
+&quot;Explicit&quot;
+&quot;False&quot;
+&quot;Finally&quot;
+&quot;For&quot;
+&quot;Friend&quot;
+&quot;Function&quot;
+&quot;Get&quot;
+&quot;GetType&quot;
+&quot;GoSub&quot;
+&quot;GoTo&quot;
+&quot;Handles&quot;
+&quot;If&quot;
+&quot;Implements&quot;
+&quot;Imports&quot;
+&quot;In&quot;
+&quot;Inherits&quot;
+&quot;Integer&quot;
+&quot;Interface&quot;
+&quot;Is&quot;
+&quot;Let&quot;
+&quot;Lib&quot;
+&quot;Like&quot;
+&quot;Long&quot;
+&quot;Loop&quot;
+&quot;Me&quot;
+&quot;Mod&quot;
+&quot;Module&quot;
+&quot;MustInherit&quot;
+&quot;MustOverride&quot;
+&quot;MyBase&quot;
+&quot;MyClass&quot;
+&quot;Namespace&quot;
+&quot;New&quot;
+&quot;Next&quot;
+&quot;Not&quot;
+&quot;Nothing&quot;
+&quot;NotInheritable&quot;
+&quot;NotOverridable&quot;
+&quot;Object&quot;
+&quot;Off&quot;
+&quot;On&quot;
+&quot;Option&quot;
+&quot;Optional&quot;
+&quot;Or&quot;
+&quot;OrElse&quot;
+&quot;Overloads&quot;
+&quot;Overridable&quot;
+&quot;Override&quot;
+&quot;Overrides&quot;
+&quot;ParamArray&quot;
+&quot;Preserve&quot;
+&quot;Private&quot;
+&quot;Property&quot;
+&quot;Protected&quot;
+&quot;Public&quot;
+&quot;RaiseEvent&quot;
+&quot;ReadOnly&quot;
+&quot;ReDim&quot;
+&quot;RemoveHandler&quot;
+&quot;Resume&quot;
+&quot;Return&quot;
+&quot;Select&quot;
+&quot;Set&quot;
+&quot;Shadows&quot;
+&quot;Shared&quot;
+&quot;Short&quot;
+&quot;Single&quot;
+&quot;Static&quot;
+&quot;Step&quot;
+&quot;Stop&quot;
+&quot;Strict&quot;
+&quot;String&quot;
+&quot;Structure&quot;
+&quot;Sub&quot;
+&quot;SyncLock&quot;
+&quot;Text&quot;
+&quot;Then&quot;
+&quot;Throw&quot;
+&quot;To&quot;
+&quot;True&quot;
+&quot;Try&quot;
+&quot;TypeOf&quot;
+&quot;Unicode&quot;
+&quot;Until&quot;
+&quot;Variant&quot;
+&quot;Wend&quot;
+&quot;When&quot;
+&quot;While&quot;
+&quot;With&quot;
+&quot;WithEvents&quot;
+&quot;WriteOnly&quot;
+&quot;Xor&quot;

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,177 @@
+// this file was autogenerated by a tool.
+using System;
+using System.Collections;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class Keywords
+	{
+		static readonly string[] keywordList = {
+			&quot;ADDHANDLER&quot;,
+			&quot;ADDRESSOF&quot;,
+			&quot;ALIAS&quot;,
+			&quot;AND&quot;,
+			&quot;ANDALSO&quot;,
+			&quot;ANSI&quot;,
+			&quot;AS&quot;,
+			&quot;ASSEMBLY&quot;,
+			&quot;AUTO&quot;,
+			&quot;BINARY&quot;,
+			&quot;BOOLEAN&quot;,
+			&quot;BYREF&quot;,
+			&quot;BYTE&quot;,
+			&quot;BYVAL&quot;,
+			&quot;CALL&quot;,
+			&quot;CASE&quot;,
+			&quot;CATCH&quot;,
+			&quot;CBOOL&quot;,
+			&quot;CBYTE&quot;,
+			&quot;CCHAR&quot;,
+			&quot;CDATE&quot;,
+			&quot;CDBL&quot;,
+			&quot;CDEC&quot;,
+			&quot;CHAR&quot;,
+			&quot;CINT&quot;,
+			&quot;CLASS&quot;,
+			&quot;CLNG&quot;,
+			&quot;COBJ&quot;,
+			&quot;COMPARE&quot;,
+			&quot;CONST&quot;,
+			&quot;CSHORT&quot;,
+			&quot;CSNG&quot;,
+			&quot;CSTR&quot;,
+			&quot;CTYPE&quot;,
+			&quot;DATE&quot;,
+			&quot;DECIMAL&quot;,
+			&quot;DECLARE&quot;,
+			&quot;DEFAULT&quot;,
+			&quot;DELEGATE&quot;,
+			&quot;DIM&quot;,
+			&quot;DIRECTCAST&quot;,
+			&quot;DO&quot;,
+			&quot;DOUBLE&quot;,
+			&quot;EACH&quot;,
+			&quot;ELSE&quot;,
+			&quot;ELSEIF&quot;,
+			&quot;END&quot;,
+			&quot;ENDIF&quot;,
+			&quot;ENUM&quot;,
+			&quot;ERASE&quot;,
+			&quot;ERROR&quot;,
+			&quot;EVENT&quot;,
+			&quot;EXIT&quot;,
+			&quot;EXPLICIT&quot;,
+			&quot;FALSE&quot;,
+			&quot;FINALLY&quot;,
+			&quot;FOR&quot;,
+			&quot;FRIEND&quot;,
+			&quot;FUNCTION&quot;,
+			&quot;GET&quot;,
+			&quot;GETTYPE&quot;,
+			&quot;GOSUB&quot;,
+			&quot;GOTO&quot;,
+			&quot;HANDLES&quot;,
+			&quot;IF&quot;,
+			&quot;IMPLEMENTS&quot;,
+			&quot;IMPORTS&quot;,
+			&quot;IN&quot;,
+			&quot;INHERITS&quot;,
+			&quot;INTEGER&quot;,
+			&quot;INTERFACE&quot;,
+			&quot;IS&quot;,
+			&quot;LET&quot;,
+			&quot;LIB&quot;,
+			&quot;LIKE&quot;,
+			&quot;LONG&quot;,
+			&quot;LOOP&quot;,
+			&quot;ME&quot;,
+			&quot;MOD&quot;,
+			&quot;MODULE&quot;,
+			&quot;MUSTINHERIT&quot;,
+			&quot;MUSTOVERRIDE&quot;,
+			&quot;MYBASE&quot;,
+			&quot;MYCLASS&quot;,
+			&quot;NAMESPACE&quot;,
+			&quot;NEW&quot;,
+			&quot;NEXT&quot;,
+			&quot;NOT&quot;,
+			&quot;NOTHING&quot;,
+			&quot;NOTINHERITABLE&quot;,
+			&quot;NOTOVERRIDABLE&quot;,
+			&quot;OBJECT&quot;,
+			&quot;OFF&quot;,
+			&quot;ON&quot;,
+			&quot;OPTION&quot;,
+			&quot;OPTIONAL&quot;,
+			&quot;OR&quot;,
+			&quot;ORELSE&quot;,
+			&quot;OVERLOADS&quot;,
+			&quot;OVERRIDABLE&quot;,
+			&quot;OVERRIDE&quot;,
+			&quot;OVERRIDES&quot;,
+			&quot;PARAMARRAY&quot;,
+			&quot;PRESERVE&quot;,
+			&quot;PRIVATE&quot;,
+			&quot;PROPERTY&quot;,
+			&quot;PROTECTED&quot;,
+			&quot;PUBLIC&quot;,
+			&quot;RAISEEVENT&quot;,
+			&quot;READONLY&quot;,
+			&quot;REDIM&quot;,
+			&quot;REMOVEHANDLER&quot;,
+			&quot;RESUME&quot;,
+			&quot;RETURN&quot;,
+			&quot;SELECT&quot;,
+			&quot;SET&quot;,
+			&quot;SHADOWS&quot;,
+			&quot;SHARED&quot;,
+			&quot;SHORT&quot;,
+			&quot;SINGLE&quot;,
+			&quot;STATIC&quot;,
+			&quot;STEP&quot;,
+			&quot;STOP&quot;,
+			&quot;STRICT&quot;,
+			&quot;STRING&quot;,
+			&quot;STRUCTURE&quot;,
+			&quot;SUB&quot;,
+			&quot;SYNCLOCK&quot;,
+			&quot;TEXT&quot;,
+			&quot;THEN&quot;,
+			&quot;THROW&quot;,
+			&quot;TO&quot;,
+			&quot;TRUE&quot;,
+			&quot;TRY&quot;,
+			&quot;TYPEOF&quot;,
+			&quot;UNICODE&quot;,
+			&quot;UNTIL&quot;,
+			&quot;VARIANT&quot;,
+			&quot;WEND&quot;,
+			&quot;WHEN&quot;,
+			&quot;WHILE&quot;,
+			&quot;WITH&quot;,
+			&quot;WITHEVENTS&quot;,
+			&quot;WRITEONLY&quot;,
+			&quot;XOR&quot;
+		};
+		
+		static Hashtable keywords = new Hashtable();
+		
+		static Keywords()
+		{
+			for (int i = 0; i &lt; keywordList.Length; ++i) {
+				keywords.Add(keywordList[i], i + Tokens.AddHandler);
+			}
+		}
+		
+		public static bool IsKeyword(string identifier)
+		{
+			return keywords[identifier.ToUpper()] != null;
+		}
+		
+		public static int GetToken(string keyword)
+		{
+			return (int)keywords[keyword.ToUpper()];
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,565 @@
+// this file was autogenerated by a tool.
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public sealed class Tokens
+	{
+		// ----- terminal classes -----
+		public const int EOF                  = 0;
+		public const int EOL                  = 1;
+		public const int Identifier           = 2;
+		public const int LiteralString        = 3;
+		public const int LiteralCharacter     = 4;
+		public const int LiteralInteger       = 5;
+		public const int LiteralDouble        = 6;
+		public const int LiteralSingle        = 7;
+		public const int LiteralDecimal       = 8;
+		public const int LiteralDate          = 9;
+
+		// ----- special character -----
+		public const int Dot                  = 10;
+		public const int Assign               = 11;
+		public const int Comma                = 12;
+		public const int Colon                = 13;
+		public const int Plus                 = 14;
+		public const int Minus                = 15;
+		public const int Times                = 16;
+		public const int Div                  = 17;
+		public const int DivInteger           = 18;
+		public const int ConcatString         = 19;
+		public const int Power                = 20;
+		public const int OpenCurlyBrace       = 21;
+		public const int CloseCurlyBrace      = 22;
+		public const int OpenSquareBracket    = 23;
+		public const int CloseSquareBracket   = 24;
+		public const int OpenParenthesis      = 25;
+		public const int CloseParenthesis     = 26;
+		public const int GreaterThan          = 27;
+		public const int LessThan             = 28;
+		public const int NotEqual             = 29;
+		public const int GreaterEqual         = 30;
+		public const int LessEqual            = 31;
+		public const int ShiftLeft            = 32;
+		public const int ShiftRight           = 33;
+		public const int PlusAssign           = 34;
+		public const int PowerAssign          = 35;
+		public const int MinusAssign          = 36;
+		public const int TimesAssign          = 37;
+		public const int DivAssign            = 38;
+		public const int DivIntegerAssign     = 39;
+		public const int ShiftLeftAssign      = 40;
+		public const int ShiftRightAssign     = 41;
+		public const int ConcatStringAssign   = 42;
+
+		// ----- keywords -----
+		public const int AddHandler           = 43;
+		public const int AddressOf            = 44;
+		public const int Alias                = 45;
+		public const int And                  = 46;
+		public const int AndAlso              = 47;
+		public const int Ansi                 = 48;
+		public const int As                   = 49;
+		public const int Assembly             = 50;
+		public const int Auto                 = 51;
+		public const int Binary               = 52;
+		public const int Boolean              = 53;
+		public const int ByRef                = 54;
+		public const int Byte                 = 55;
+		public const int ByVal                = 56;
+		public const int Call                 = 57;
+		public const int Case                 = 58;
+		public const int Catch                = 59;
+		public const int CBool                = 60;
+		public const int CByte                = 61;
+		public const int CChar                = 62;
+		public const int CDate                = 63;
+		public const int CDbl                 = 64;
+		public const int CDec                 = 65;
+		public const int Char                 = 66;
+		public const int CInt                 = 67;
+		public const int Class                = 68;
+		public const int CLng                 = 69;
+		public const int CObj                 = 70;
+		public const int Compare              = 71;
+		public const int Const                = 72;
+		public const int CShort               = 73;
+		public const int CSng                 = 74;
+		public const int CStr                 = 75;
+		public const int CType                = 76;
+		public const int Date                 = 77;
+		public const int Decimal              = 78;
+		public const int Declare              = 79;
+		public const int Default              = 80;
+		public const int Delegate             = 81;
+		public const int Dim                  = 82;
+		public const int DirectCast           = 83;
+		public const int Do                   = 84;
+		public const int Double               = 85;
+		public const int Each                 = 86;
+		public const int Else                 = 87;
+		public const int ElseIf               = 88;
+		public const int End                  = 89;
+		public const int EndIf                = 90;
+		public const int Enum                 = 91;
+		public const int Erase                = 92;
+		public const int Error                = 93;
+		public const int Event                = 94;
+		public const int Exit                 = 95;
+		public const int Explicit             = 96;
+		public const int False                = 97;
+		public const int Finally              = 98;
+		public const int For                  = 99;
+		public const int Friend               = 100;
+		public const int Function             = 101;
+		public const int Get                  = 102;
+		new public const int GetType              = 103;
+		public const int GoSub                = 104;
+		public const int GoTo                 = 105;
+		public const int Handles              = 106;
+		public const int If                   = 107;
+		public const int Implements           = 108;
+		public const int Imports              = 109;
+		public const int In                   = 110;
+		public const int Inherits             = 111;
+		public const int Integer              = 112;
+		public const int Interface            = 113;
+		public const int Is                   = 114;
+		public const int Let                  = 115;
+		public const int Lib                  = 116;
+		public const int Like                 = 117;
+		public const int Long                 = 118;
+		public const int Loop                 = 119;
+		public const int Me                   = 120;
+		public const int Mod                  = 121;
+		public const int Module               = 122;
+		public const int MustInherit          = 123;
+		public const int MustOverride         = 124;
+		public const int MyBase               = 125;
+		public const int MyClass              = 126;
+		public const int Namespace            = 127;
+		public const int New                  = 128;
+		public const int Next                 = 129;
+		public const int Not                  = 130;
+		public const int Nothing              = 131;
+		public const int NotInheritable       = 132;
+		public const int NotOverridable       = 133;
+		public const int Object               = 134;
+		public const int Off                  = 135;
+		public const int On                   = 136;
+		public const int Option               = 137;
+		public const int Optional             = 138;
+		public const int Or                   = 139;
+		public const int OrElse               = 140;
+		public const int Overloads            = 141;
+		public const int Overridable          = 142;
+		public const int Override             = 143;
+		public const int Overrides            = 144;
+		public const int ParamArray           = 145;
+		public const int Preserve             = 146;
+		public const int Private              = 147;
+		public const int Property             = 148;
+		public const int Protected            = 149;
+		public const int Public               = 150;
+		public const int RaiseEvent           = 151;
+		public const int ReadOnly             = 152;
+		public const int ReDim                = 153;
+		public const int RemoveHandler        = 154;
+		public const int Resume               = 155;
+		public const int Return               = 156;
+		public const int Select               = 157;
+		public const int Set                  = 158;
+		public const int Shadows              = 159;
+		public const int Shared               = 160;
+		public const int Short                = 161;
+		public const int Single               = 162;
+		public const int Static               = 163;
+		public const int Step                 = 164;
+		public const int Stop                 = 165;
+		public const int Strict               = 166;
+		public const int String               = 167;
+		public const int Structure            = 168;
+		public const int Sub                  = 169;
+		public const int SyncLock             = 170;
+		public const int Text                 = 171;
+		public const int Then                 = 172;
+		public const int Throw                = 173;
+		public const int To                   = 174;
+		public const int True                 = 175;
+		public const int Try                  = 176;
+		public const int TypeOf               = 177;
+		public const int Unicode              = 178;
+		public const int Until                = 179;
+		public const int Variant              = 180;
+		public const int Wend                 = 181;
+		public const int When                 = 182;
+		public const int While                = 183;
+		public const int With                 = 184;
+		public const int WithEvents           = 185;
+		public const int WriteOnly            = 186;
+		public const int Xor                  = 187;
+
+		string GetTokenString(int token)
+		{
+			switch (token) {
+				case Dot:
+					return &quot;.&quot;;
+				case Assign:
+					return &quot;=&quot;;
+				case Comma:
+					return &quot;,&quot;;
+				case Colon:
+					return &quot;:&quot;;
+				case Plus:
+					return &quot;+&quot;;
+				case Minus:
+					return &quot;-&quot;;
+				case Times:
+					return &quot;*&quot;;
+				case Div:
+					return &quot;/&quot;;
+				case DivInteger:
+					return &quot;\\&quot;;
+				case ConcatString:
+					return &quot;&amp;&quot;;
+				case Power:
+					return &quot;^&quot;;
+				case OpenCurlyBrace:
+					return &quot;{&quot;;
+				case CloseCurlyBrace:
+					return &quot;}&quot;;
+				case OpenSquareBracket:
+					return &quot;[&quot;;
+				case CloseSquareBracket:
+					return &quot;]&quot;;
+				case OpenParenthesis:
+					return &quot;(&quot;;
+				case CloseParenthesis:
+					return &quot;)&quot;;
+				case GreaterThan:
+					return &quot;&gt;&quot;;
+				case LessThan:
+					return &quot;&lt;&quot;;
+				case NotEqual:
+					return &quot;&lt;&gt;&quot;;
+				case GreaterEqual:
+					return &quot;&gt;=&quot;;
+				case LessEqual:
+					return &quot;&lt;=&quot;;
+				case ShiftLeft:
+					return &quot;&lt;&lt;&quot;;
+				case ShiftRight:
+					return &quot;&gt;&gt;&quot;;
+				case PlusAssign:
+					return &quot;+=&quot;;
+				case PowerAssign:
+					return &quot;^=&quot;;
+				case MinusAssign:
+					return &quot;-=&quot;;
+				case TimesAssign:
+					return &quot;*=&quot;;
+				case DivAssign:
+					return &quot;/=&quot;;
+				case DivIntegerAssign:
+					return &quot;\\=&quot;;
+				case ShiftLeftAssign:
+					return &quot;&lt;&lt;=&quot;;
+				case ShiftRightAssign:
+					return &quot;&gt;&gt;=&quot;;
+				case ConcatStringAssign:
+					return &quot;&amp;=&quot;;
+				case AddHandler:
+					return &quot;AddHandler&quot;;
+				case AddressOf:
+					return &quot;AddressOf&quot;;
+				case Alias:
+					return &quot;Alias&quot;;
+				case And:
+					return &quot;And&quot;;
+				case AndAlso:
+					return &quot;AndAlso&quot;;
+				case Ansi:
+					return &quot;Ansi&quot;;
+				case As:
+					return &quot;As&quot;;
+				case Assembly:
+					return &quot;Assembly&quot;;
+				case Auto:
+					return &quot;Auto&quot;;
+				case Binary:
+					return &quot;Binary&quot;;
+				case Boolean:
+					return &quot;Boolean&quot;;
+				case ByRef:
+					return &quot;ByRef&quot;;
+				case Byte:
+					return &quot;Byte&quot;;
+				case ByVal:
+					return &quot;ByVal&quot;;
+				case Call:
+					return &quot;Call&quot;;
+				case Case:
+					return &quot;Case&quot;;
+				case Catch:
+					return &quot;Catch&quot;;
+				case CBool:
+					return &quot;CBool&quot;;
+				case CByte:
+					return &quot;CByte&quot;;
+				case CChar:
+					return &quot;CChar&quot;;
+				case CDate:
+					return &quot;CDate&quot;;
+				case CDbl:
+					return &quot;CDbl&quot;;
+				case CDec:
+					return &quot;CDec&quot;;
+				case Char:
+					return &quot;Char&quot;;
+				case CInt:
+					return &quot;CInt&quot;;
+				case Class:
+					return &quot;Class&quot;;
+				case CLng:
+					return &quot;CLng&quot;;
+				case CObj:
+					return &quot;CObj&quot;;
+				case Compare:
+					return &quot;Compare&quot;;
+				case Const:
+					return &quot;Const&quot;;
+				case CShort:
+					return &quot;CShort&quot;;
+				case CSng:
+					return &quot;CSng&quot;;
+				case CStr:
+					return &quot;CStr&quot;;
+				case CType:
+					return &quot;CType&quot;;
+				case Date:
+					return &quot;Date&quot;;
+				case Decimal:
+					return &quot;Decimal&quot;;
+				case Declare:
+					return &quot;Declare&quot;;
+				case Default:
+					return &quot;Default&quot;;
+				case Delegate:
+					return &quot;Delegate&quot;;
+				case Dim:
+					return &quot;Dim&quot;;
+				case DirectCast:
+					return &quot;DirectCast&quot;;
+				case Do:
+					return &quot;Do&quot;;
+				case Double:
+					return &quot;Double&quot;;
+				case Each:
+					return &quot;Each&quot;;
+				case Else:
+					return &quot;Else&quot;;
+				case ElseIf:
+					return &quot;ElseIf&quot;;
+				case End:
+					return &quot;End&quot;;
+				case EndIf:
+					return &quot;EndIf&quot;;
+				case Enum:
+					return &quot;Enum&quot;;
+				case Erase:
+					return &quot;Erase&quot;;
+				case Error:
+					return &quot;Error&quot;;
+				case Event:
+					return &quot;Event&quot;;
+				case Exit:
+					return &quot;Exit&quot;;
+				case Explicit:
+					return &quot;Explicit&quot;;
+				case False:
+					return &quot;False&quot;;
+				case Finally:
+					return &quot;Finally&quot;;
+				case For:
+					return &quot;For&quot;;
+				case Friend:
+					return &quot;Friend&quot;;
+				case Function:
+					return &quot;Function&quot;;
+				case Get:
+					return &quot;Get&quot;;
+				case GetType:
+					return &quot;GetType&quot;;
+				case GoSub:
+					return &quot;GoSub&quot;;
+				case GoTo:
+					return &quot;GoTo&quot;;
+				case Handles:
+					return &quot;Handles&quot;;
+				case If:
+					return &quot;If&quot;;
+				case Implements:
+					return &quot;Implements&quot;;
+				case Imports:
+					return &quot;Imports&quot;;
+				case In:
+					return &quot;In&quot;;
+				case Inherits:
+					return &quot;Inherits&quot;;
+				case Integer:
+					return &quot;Integer&quot;;
+				case Interface:
+					return &quot;Interface&quot;;
+				case Is:
+					return &quot;Is&quot;;
+				case Let:
+					return &quot;Let&quot;;
+				case Lib:
+					return &quot;Lib&quot;;
+				case Like:
+					return &quot;Like&quot;;
+				case Long:
+					return &quot;Long&quot;;
+				case Loop:
+					return &quot;Loop&quot;;
+				case Me:
+					return &quot;Me&quot;;
+				case Mod:
+					return &quot;Mod&quot;;
+				case Module:
+					return &quot;Module&quot;;
+				case MustInherit:
+					return &quot;MustInherit&quot;;
+				case MustOverride:
+					return &quot;MustOverride&quot;;
+				case MyBase:
+					return &quot;MyBase&quot;;
+				case MyClass:
+					return &quot;MyClass&quot;;
+				case Namespace:
+					return &quot;Namespace&quot;;
+				case New:
+					return &quot;New&quot;;
+				case Next:
+					return &quot;Next&quot;;
+				case Not:
+					return &quot;Not&quot;;
+				case Nothing:
+					return &quot;Nothing&quot;;
+				case NotInheritable:
+					return &quot;NotInheritable&quot;;
+				case NotOverridable:
+					return &quot;NotOverridable&quot;;
+				case Object:
+					return &quot;Object&quot;;
+				case Off:
+					return &quot;Off&quot;;
+				case On:
+					return &quot;On&quot;;
+				case Option:
+					return &quot;Option&quot;;
+				case Optional:
+					return &quot;Optional&quot;;
+				case Or:
+					return &quot;Or&quot;;
+				case OrElse:
+					return &quot;OrElse&quot;;
+				case Overloads:
+					return &quot;Overloads&quot;;
+				case Overridable:
+					return &quot;Overridable&quot;;
+				case Override:
+					return &quot;Override&quot;;
+				case Overrides:
+					return &quot;Overrides&quot;;
+				case ParamArray:
+					return &quot;ParamArray&quot;;
+				case Preserve:
+					return &quot;Preserve&quot;;
+				case Private:
+					return &quot;Private&quot;;
+				case Property:
+					return &quot;Property&quot;;
+				case Protected:
+					return &quot;Protected&quot;;
+				case Public:
+					return &quot;Public&quot;;
+				case RaiseEvent:
+					return &quot;RaiseEvent&quot;;
+				case ReadOnly:
+					return &quot;ReadOnly&quot;;
+				case ReDim:
+					return &quot;ReDim&quot;;
+				case RemoveHandler:
+					return &quot;RemoveHandler&quot;;
+				case Resume:
+					return &quot;Resume&quot;;
+				case Return:
+					return &quot;Return&quot;;
+				case Select:
+					return &quot;Select&quot;;
+				case Set:
+					return &quot;Set&quot;;
+				case Shadows:
+					return &quot;Shadows&quot;;
+				case Shared:
+					return &quot;Shared&quot;;
+				case Short:
+					return &quot;Short&quot;;
+				case Single:
+					return &quot;Single&quot;;
+				case Static:
+					return &quot;Static&quot;;
+				case Step:
+					return &quot;Step&quot;;
+				case Stop:
+					return &quot;Stop&quot;;
+				case Strict:
+					return &quot;Strict&quot;;
+				case String:
+					return &quot;String&quot;;
+				case Structure:
+					return &quot;Structure&quot;;
+				case Sub:
+					return &quot;Sub&quot;;
+				case SyncLock:
+					return &quot;SyncLock&quot;;
+				case Text:
+					return &quot;Text&quot;;
+				case Then:
+					return &quot;Then&quot;;
+				case Throw:
+					return &quot;Throw&quot;;
+				case To:
+					return &quot;To&quot;;
+				case True:
+					return &quot;True&quot;;
+				case Try:
+					return &quot;Try&quot;;
+				case TypeOf:
+					return &quot;TypeOf&quot;;
+				case Unicode:
+					return &quot;Unicode&quot;;
+				case Until:
+					return &quot;Until&quot;;
+				case Variant:
+					return &quot;Variant&quot;;
+				case Wend:
+					return &quot;Wend&quot;;
+				case When:
+					return &quot;When&quot;;
+				case While:
+					return &quot;While&quot;;
+				case With:
+					return &quot;With&quot;;
+				case WithEvents:
+					return &quot;WithEvents&quot;;
+				case WriteOnly:
+					return &quot;WriteOnly&quot;;
+				case Xor:
+					return &quot;Xor&quot;;
+			}
+			throw new System.NotSupportedException(&quot;Unknown token:&quot; + token);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactory.prjx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactory.prjx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactory.prjx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,283 @@
+&lt;Project name=&quot;SharpRefactoryVB&quot; standardNamespace=&quot;NewProject&quot; description=&quot;&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
+  &lt;Contents&gt;
+    &lt;File name=&quot;.\AssemblyInfo.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Main.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\AbstractASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\AbstractNode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\CompilationUnit.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Enums.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\IASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\INode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Parser.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\VBNET.ATG&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\OptionStrictDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\ImportsAliasDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\ImportsStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\OptionExplicitDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\OptionCompareDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\ImportsDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\TypeDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\NamespaceDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\NamedArgumentExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\Expression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\AttributeDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Modifier.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\SharpRefactory.prjx~&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Lexer.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\Tokens.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\FileReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\IReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\StringReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\Comment.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\CommentType.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\NewLine.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\PreProcessingDirective.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\SpecialTracker.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\buildparser.cmd&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\cs.ATG&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Parser.frame&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\ParserUtil.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Scanner.frame&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\trace.txt&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\Keywords.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Errors.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Modifiers.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.KewordList.tokens.swp&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.KewordList.upper.swp&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\BuildKeywords.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\KeywordList.txt&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\TypeReference.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\AssignmentExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\UnaryOperatorExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\BinaryOperatorExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\PrimitiveExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ThisReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\BaseReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\InvocationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\IdentifierExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ParenthesizedExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\TypeReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ObjectCreateExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\.svn\text-base\AssemblyInfo.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\.svn\text-base\Main.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\.svn\text-base\SharpRefactory.prjx.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\.svn\wcprops\AssemblyInfo.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\.svn\wcprops\Main.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\.svn\wcprops\SharpRefactory.prjx.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\.svn\text-base\Keywords.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\.svn\text-base\Lexer.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\.svn\text-base\Tokens.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\.svn\wcprops\Keywords.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\.svn\wcprops\Lexer.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\.svn\wcprops\Tokens.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\.svn\text-base\FileReader.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\.svn\text-base\IReader.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\.svn\text-base\StringReader.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\.svn\wcprops\FileReader.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\.svn\wcprops\IReader.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\.svn\wcprops\StringReader.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\text-base\Comment.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\text-base\CommentType.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\text-base\NewLine.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\text-base\PreProcessingDirective.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\text-base\SpecialTracker.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\wcprops\Comment.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\wcprops\CommentType.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\wcprops\NewLine.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\wcprops\PreProcessingDirective.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\.svn\wcprops\SpecialTracker.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\text-base\AbstractASTVisitor.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\text-base\AbstractNode.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\text-base\CompilationUnit.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\text-base\Enums.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\text-base\IASTVisitor.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\text-base\INode.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\text-base\Modifier.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\wcprops\AbstractASTVisitor.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\wcprops\AbstractNode.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\wcprops\CompilationUnit.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\wcprops\Enums.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\wcprops\IASTVisitor.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\wcprops\INode.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\.svn\wcprops\Modifier.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\AssignmentExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\BaseReferenceExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\BinaryOperatorExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\Expression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\FieldReferenceExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\IdentifierExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\InvocationExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\NamedParameterExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\ObjectCreateExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\ParenthesizedExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\PrimitiveExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\ThisReferenceExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\TypeReferenceExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\text-base\UnaryOperatorExpression.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\AssignmentExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\BaseReferenceExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\BinaryOperatorExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\Expression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\FieldReferenceExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\IdentifierExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\InvocationExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\NamedParameterExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\ObjectCreateExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\ParenthesizedExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\PrimitiveExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\ThisReferenceExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\TypeReferenceExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\.svn\wcprops\UnaryOperatorExpression.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\AttributeDeclaration.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\DebugVisitor.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\ImportsAliasClause.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\ImportsClause.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\ImportsDeclaration.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\NamespaceDeclaration.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\OptionCompareDeclaration.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\OptionExplicitDeclaration.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\OptionStrictDeclaration.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\text-base\TypeDeclaration.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\AttributeDeclaration.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\DebugVisitor.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\ImportsAliasClause.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\ImportsClause.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\ImportsDeclaration.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\NamespaceDeclaration.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\OptionCompareDeclaration.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\OptionExplicitDeclaration.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\OptionStrictDeclaration.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\.svn\wcprops\TypeDeclaration.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\.svn\text-base\TypeReference.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\.svn\wcprops\TypeReference.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\prop-base\BuildKeywords.pdb.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\prop-base\SharpCoco.exe.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\props\BuildKeywords.pdb.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\props\SharpCoco.exe.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\BuildKeywords.pdb.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\buildparser.cmd.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\Error.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\Modifiers.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\Parser.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\Parser.frame.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\Scanner.frame.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\SharpCoco.exe.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\trace.txt.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\text-base\VBNET.ATG.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\BuildKeywords.pdb.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\buildparser.cmd.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\Error.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\Modifiers.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\Parser.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\Parser.frame.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\Scanner.frame.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\SharpCoco.exe.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\trace.txt.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\.svn\wcprops\VBNET.ATG.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\prop-base\BuildKeywords.exe.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\prop-base\BuildKeywords.pdb.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\props\BuildKeywords.exe.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\props\BuildKeywords.pdb.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\text-base\BuildKeywords.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\text-base\BuildKeywords.exe.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\text-base\BuildKeywords.pdb.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\text-base\KewordList.list.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\text-base\KewordList.tokens.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\text-base\KewordList.txt.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\text-base\KewordList.upper.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\wcprops\BuildKeywords.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\wcprops\BuildKeywords.exe.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\wcprops\BuildKeywords.pdb.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\wcprops\KewordList.list.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\wcprops\KewordList.tokens.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\wcprops\KewordList.txt.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\.svn\wcprops\KewordList.upper.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Keywords.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\DebugVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\FieldDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\VariableDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ParameterDeclarationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\Statement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\MethodDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\BlockStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\EndStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ExitStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\HandlesClause.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\ImplementsClause.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\DeclareDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\EventDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ArrayInitializerExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertyDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertyGetRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertySetRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\TryCatchStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ThrowStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ReturnStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\LockStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\RaiseEventStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\WithStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\DelegateDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\AddHandlerStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\AddressOfExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\RemoveHandlerStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\GetTypeExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\CastExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\WhileStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\DoLoopStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ForeachStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ForStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\LocalVariableDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ErrorStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\EraseStatements.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\StopStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\IfStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\SelectStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ClassReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\TypeOfExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ReDimStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\ConstructorDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\GoToStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\OnErrorStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ResumeStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\LabelStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\StatementExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\ParamModifiers.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\FieldReferenceOrInvocationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\LoopControlVariableExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ArrayCreateExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\CodeDOM\CodeDOMVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\LookupTableVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\CSharpConverter\CSharpVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\BuildKeywords.pl&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\TagComment.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+  &lt;/Contents&gt;
+  &lt;References /&gt;
+  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
+  &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; noconfig=&quot;False&quot; nostdlib=&quot;False&quot; /&gt;
+    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+    &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactoryVB&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;.\Parser\generated\buildparser.cmd&quot; executeAfterBuild=&quot;&quot; executeBeforeBuildArguments=&quot;&quot; executeAfterBuildArguments=&quot;&quot; /&gt;
+  &lt;/Configuration&gt;
+  &lt;Configurations active=&quot;Release&quot;&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; noconfig=&quot;False&quot; nostdlib=&quot;False&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactoryVB&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;.\Parser\generated\buildparser.cmd&quot; executeAfterBuild=&quot;&quot; executeBeforeBuildArguments=&quot;&quot; executeAfterBuildArguments=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; noconfig=&quot;False&quot; nostdlib=&quot;False&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactoryVB&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;.\Parser\generated\buildparser.cmd&quot; executeAfterBuild=&quot;&quot; executeBeforeBuildArguments=&quot;&quot; executeAfterBuildArguments=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;WithoutParserGeneration&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; noconfig=&quot;False&quot; nostdlib=&quot;False&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactoryVB&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; executeBeforeBuildArguments=&quot;&quot; executeAfterBuildArguments=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Exe&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Exe&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; noconfig=&quot;False&quot; nostdlib=&quot;False&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\bin\Debug&quot; assembly=&quot;ICSharpCode.SharpRefactoryVB&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;.\Parser\generated\buildparser.cmd&quot; executeAfterBuild=&quot;&quot; executeBeforeBuildArguments=&quot;&quot; executeAfterBuildArguments=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Project&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.cmbx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.cmbx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.cmbx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,16 @@
+&lt;Combine fileversion=&quot;1.0&quot; name=&quot;SharpRefactoryVB&quot; description=&quot;&quot;&gt;
+  &lt;StartMode startupentry=&quot;SharpRefactoryVB&quot; single=&quot;True&quot;&gt;
+    &lt;Execute entry=&quot;SharpRefactoryVB&quot; type=&quot;None&quot; /&gt;
+  &lt;/StartMode&gt;
+  &lt;Entries&gt;
+    &lt;Entry filename=&quot;./SharpRefactoryVB.prjx&quot; /&gt;
+  &lt;/Entries&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration name=&quot;Release&quot;&gt;
+      &lt;Entry name=&quot;SharpRefactoryVB&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration name=&quot;Debug&quot;&gt;
+      &lt;Entry name=&quot;SharpRefactoryVB&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Combine&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.mdsx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.mdsx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.mdsx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,3 @@
+&lt;MonoDevelopSolution fileversion=&quot;1.0&quot;&gt;
+  &lt;RelativeOutputPath&gt;./build/bin&lt;/RelativeOutputPath&gt;
+&lt;/MonoDevelopSolution&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.prjx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.prjx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/SharpRefactoryVB.prjx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,126 @@
+&lt;Project name=&quot;SharpRefactoryVB&quot; description=&quot;&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
+  &lt;Contents&gt;
+    &lt;File name=&quot;./AssemblyInfo.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Main.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./CodeDom/CodeDOMVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./CSharpConverter/CSharpVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Lexer.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Reader/FileReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Reader/IReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Reader/StringReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Specials/Comment.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Specials/CommentType.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Specials/NewLine.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Specials/PreProcessingDirective.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Specials/SpecialTracker.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Lexer/Specials/TagComment.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/AbstractASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/AbstractNode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/CompilationUnit.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Enums.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/IASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/INode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/LookupTableVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Modifier.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/AddressOfExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/ArrayCreateExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/ArrayInitializerExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/AssignmentExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/BaseReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/BinaryOperatorExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/CastExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/ClassReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/Expression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/FieldReferenceOrInvocationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/GetTypeExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/IdentifierExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/InvocationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/LoopControlVariableExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/NamedArgumentExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/ObjectCreateExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/ParameterDeclarationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/ParenthesizedExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/PrimitiveExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/StatementExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/ThisReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/TypeOfExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/TypeReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Expressions/UnaryOperatorExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/AttributeDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/DelegateDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/ImportsAliasDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/ImportsDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/ImportsStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/NamespaceDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/OptionCompareDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/OptionExplicitDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/OptionStrictDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/GlobalScope/TypeDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/AddHandlerStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/BlockStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/DoLoopStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/EndStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/EraseStatements.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/ErrorStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/ExitStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/ForeachStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/ForStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/GoToStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/IfStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/LabelStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/LocalVariableDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/LockStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/OnErrorStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/RaiseEventStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/ReDimStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/RemoveHandlerStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/ResumeStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/ReturnStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/SelectStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/Statement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/StopStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/ThrowStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/TryCatchStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/WhileStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/Statements/WithStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/ConstructorDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/DeclareDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/EventDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/FieldDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/HandlesClause.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/ImplementsClause.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/MethodDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/PropertyDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/PropertyGetRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/PropertySetRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/TypeReference.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/AST/TypeLevel/VariableDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/generated/Errors.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/generated/Modifiers.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/generated/ParamModifiers.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/generated/Parser.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/generated/keywordlist/Keywords.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/generated/keywordlist/Tokens.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+  &lt;/Contents&gt;
+  &lt;References&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot; localcopy=&quot;True&quot; /&gt;
+  &lt;/References&gt;
+  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
+  &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+    &lt;Output directory=&quot;./bin/Debug&quot; assembly=&quot;ICSharpCode.SharpRefactory.VB&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+  &lt;/Configuration&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;./bin/Debug&quot; assembly=&quot;ICSharpCode.SharpRefactory.VB&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;./bin/Release&quot; assembly=&quot;SharpRefactoryVB&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Project&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VB.glade
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VB.glade	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VB.glade	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,1017 @@
+&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt; &lt;!--*- mode: xml -*--&gt;
+&lt;!DOCTYPE glade-interface SYSTEM &quot;<A HREF="http://glade.gnome.org/glade-2.0.dtd&quot;">http://glade.gnome.org/glade-2.0.dtd&quot;</A>&gt;
+
+&lt;glade-interface&gt;
+&lt;requires lib=&quot;gnome&quot;/&gt;
+
+&lt;widget class=&quot;GtkWindow&quot; id=&quot;CodeGenerationPanel&quot;&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;CodeGenerationPanel&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+
+  &lt;child&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox62&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;12&lt;/property&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkLabel&quot; id=&quot;label82&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Code Generation&amp;lt;/b&amp;gt;&lt;/property&gt;
+	  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox56&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label81&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox65&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkTable&quot; id=&quot;table7&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;n_rows&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;n_columns&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;row_spacing&quot;&gt;6&lt;/property&gt;
+		  &lt;property name=&quot;column_spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label86&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Compile _Target&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;CompileTargetOptionMenu&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label87&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Define S_ymbols&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;symbolsEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label88&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Main Class&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;mainClassEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;symbolsEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;mainClassEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkOptionMenu&quot; id=&quot;CompileTargetOptionMenu&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkLabel&quot; id=&quot;label90&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Warnings&amp;lt;/b&amp;gt;&lt;/property&gt;
+	  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox47&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label72&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox64&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox55&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label80&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Warning Level&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;warningLevelSpinButton&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkSpinButton&quot; id=&quot;warningLevelSpinButton&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;climb_rate&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;digits&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;numeric&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;update_policy&quot;&gt;GTK_UPDATE_ALWAYS&lt;/property&gt;
+		      &lt;property name=&quot;snap_to_ticks&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;adjustment&quot;&gt;2 0 4 1 1 1&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;generateOverflowChecksCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Generate overflow checks&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;allowUnsafeCodeCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Allow '_unsafe' code&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;enableOptimizationCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Enable _optimizations&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;warningsAsErrorsCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Treat warnings as _errors&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;generateXmlOutputCheckButton&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Generate _xml documentation&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;widget class=&quot;GtkWindow&quot; id=&quot;OutputOptionsPanel&quot;&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;OutputOptionsPanel&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+
+  &lt;child&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox66&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;12&lt;/property&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox67&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label93&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Output&amp;lt;/b&amp;gt;&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox57&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;label91&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox69&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkTable&quot; id=&quot;table10&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;n_rows&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;n_columns&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;row_spacing&quot;&gt;6&lt;/property&gt;
+		      &lt;property name=&quot;column_spacing&quot;&gt;6&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label98&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Assembly _name&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;assemblyNameEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label99&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Output _path&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;outputDirectoryEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label100&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Paramet_ers&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;parametersEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;outputDirectoryEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;assemblyNameEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;parametersEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkCheckButton&quot; id=&quot;pauseConsoleOutputCheckButton&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Pause _console output&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		      &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox68&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label94&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Execute scripts &amp;lt;/b&amp;gt;&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox58&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;label92&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkTable&quot; id=&quot;table9&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;n_rows&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;n_columns&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;row_spacing&quot;&gt;6&lt;/property&gt;
+		  &lt;property name=&quot;column_spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label95&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Execute Command&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label96&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_After Build&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;executeAfterEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label97&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Before build&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;executeBeforeEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeScriptEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeAfterEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeBeforeEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton2&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton3&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton4&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;/glade-interface&gt;

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBAmbience.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBAmbience.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBAmbience.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,572 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Text;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+
+namespace MonoDevelop.Services
+{
+	public class VBAmbience :  AbstractAmbience
+	{
+		static string[,] typeConversionList = new string[,] {
+			{&quot;System.String&quot;,  &quot;String&quot;},
+			{&quot;System.Single&quot;,  &quot;Single&quot;},
+			{&quot;System.Int16&quot;,   &quot;Short&quot;},
+			{&quot;System.Void&quot;,    &quot;Void&quot;},
+			{&quot;System.Object&quot;,  &quot;Object&quot;},
+			{&quot;System.Int64&quot;,   &quot;Long&quot;},
+			{&quot;System.Int32&quot;,   &quot;Integer&quot;},
+			{&quot;System.Double&quot;,  &quot;Double&quot;},
+			{&quot;System.Char&quot;,    &quot;Char&quot;},
+			{&quot;System.Boolean&quot;, &quot;Boolean&quot;},
+			{&quot;System.Byte&quot;,    &quot;Byte&quot;},
+			{&quot;System.Decimal&quot;, &quot;Decimal&quot;},
+			{&quot;System.DateTime&quot;,  &quot;Date&quot;},
+		};
+		
+		static Hashtable typeConversionTable = new Hashtable();
+		
+		public const bool ShowReturnType=true;
+		
+		static VBAmbience()
+		{
+			for (int i = 0; i &lt; typeConversionList.GetLength(0); ++i) {
+				typeConversionTable[typeConversionList[i, 0]] = typeConversionList[i, 1];
+			}
+		}
+		
+		string GetModifier(IDecoration decoration)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;i&gt;&quot;);
+			}
+			
+			if (decoration.IsStatic) {
+				builder.Append(&quot;Shared &quot;);
+			} 
+			if (decoration.IsAbstract) {
+				builder.Append(&quot;MustOverride &quot;);
+			} else if (decoration.IsFinal) {
+				builder.Append(&quot;NotOverridable &quot;);
+			} else if (decoration.IsVirtual) {
+				builder.Append(&quot;Overridable &quot;);
+			} else if (decoration.IsOverride) {
+				builder.Append(&quot;Overrides &quot;);
+			} else if (decoration.IsNew) {
+				builder.Append(&quot;Shadows &quot;);
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/i&gt;&quot;);
+			}
+			
+			return builder.ToString();
+		}
+		
+		public override string Convert(ModifierEnum modifier)
+		{
+			StringBuilder builder = new StringBuilder();
+			if (ShowAccessibility) {
+				if ((modifier &amp; ModifierEnum.Public) == ModifierEnum.Public) {
+					builder.Append(&quot;Public&quot;);
+				} else if ((modifier &amp; ModifierEnum.Private) == ModifierEnum.Private) {
+					builder.Append(&quot;Private&quot;);
+				} else if ((modifier &amp; (ModifierEnum.Protected | ModifierEnum.Internal)) == (ModifierEnum.Protected | ModifierEnum.Internal)) {
+					builder.Append(&quot;Protected Friend&quot;);
+				} else if ((modifier &amp; ModifierEnum.ProtectedOrInternal) == ModifierEnum.ProtectedOrInternal) {
+					builder.Append(&quot;Protected Friend&quot;);
+				} else if ((modifier &amp; ModifierEnum.Internal) == ModifierEnum.Internal) {
+					builder.Append(&quot;Friend&quot;);
+				} else if ((modifier &amp; ModifierEnum.Protected) == ModifierEnum.Protected) {
+					builder.Append(&quot;Protected&quot;);
+				}
+				builder.Append(' ');
+			}
+			return builder.ToString();
+		}
+		
+		public override string Convert(IClass c)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			builder.Append(Convert(c.Modifiers));
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;i&gt;&quot;);
+			}
+			
+			if (ShowModifiers) {
+				if (c.IsSealed) {
+					if (c.ClassType == ClassType.Class) {
+						builder.Append(&quot;NotInheritable &quot;);
+					}
+				} else if (c.IsAbstract &amp;&amp; c.ClassType != ClassType.Interface) {
+					builder.Append(&quot;MustInherit &quot;);
+				}
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/i&gt;&quot;);
+			}
+			
+			switch (c.ClassType) {
+				case ClassType.Delegate:
+					builder.Append(&quot;Delegate &quot;);
+					if (ShowReturnType) {
+						foreach (IMethod m in c.Methods) {
+							if (m.Name != &quot;Invoke&quot;) {
+								continue;
+							}
+							
+							if (m.ReturnType == null || m.ReturnType.FullyQualifiedName == &quot;System.Void&quot;) {
+								builder.Append(&quot;Sub&quot;);
+							} else {
+								builder.Append(&quot;Function&quot;);
+							}
+						}
+					}
+					break;
+				case ClassType.Class:
+					builder.Append(&quot;Class&quot;);
+					break;
+				case ClassType.Struct:
+					builder.Append(&quot;Structure&quot;);
+					break;
+				case ClassType.Interface:
+					builder.Append(&quot;Interface&quot;);
+					break;
+				case ClassType.Enum:
+					builder.Append(&quot;Enum&quot;);
+					break;
+			}
+			builder.Append(' ');
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;b&gt;&quot;);
+			}
+			
+			if (UseFullyQualifiedMemberNames) {
+				builder.Append(c.FullyQualifiedName);
+			} else {
+				builder.Append(c.Name);
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/b&gt;&quot;);
+			}
+			
+			if (c.ClassType == ClassType.Delegate) {
+				builder.Append(&quot;(&quot;);
+				if (IncludeHTMLMarkup) builder.Append(&quot;&lt;br&gt;&quot;);
+				
+				foreach (IMethod m in c.Methods) {
+					if (m.Name != &quot;Invoke&quot;) continue;
+					
+					for (int i = 0; i &lt; m.Parameters.Count; ++i) {
+						if (IncludeHTMLMarkup) builder.Append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);
+						
+						builder.Append(Convert(m.Parameters[i]));
+						if (i + 1 &lt; m.Parameters.Count) builder.Append(&quot;, &quot;);
+
+						if (IncludeHTMLMarkup) builder.Append(&quot;&lt;br&gt;&quot;);
+					}
+				}
+
+				builder.Append(&quot;)&quot;);
+				
+				foreach (IMethod m in c.Methods) {
+					if (m.Name != &quot;Invoke&quot;) continue;
+					
+					if (m.ReturnType == null || m.ReturnType.FullyQualifiedName == &quot;System.Void&quot;) {
+					} else {
+						if (ShowReturnType) {
+							builder.Append(&quot; As &quot;);
+							builder.Append(Convert(m.ReturnType));
+						}
+					}
+				}
+
+			} else if (ShowInheritanceList) {
+				if (c.BaseTypes.Count &gt; 0) {
+					builder.Append(&quot; Inherits &quot;);
+					for (int i = 0; i &lt; c.BaseTypes.Count; ++i) {
+						builder.Append(c.BaseTypes[i]);
+						if (i + 1 &lt; c.BaseTypes.Count) {
+							builder.Append(&quot;, &quot;);
+						}
+					}
+				}
+			}
+			
+			return builder.ToString();		
+		}
+		
+		public override string ConvertEnd(IClass c)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			builder.Append(&quot;End &quot;);
+			
+			switch (c.ClassType) {
+				case ClassType.Delegate:
+					builder.Append(&quot;Delegate&quot;);
+					break;
+				case ClassType.Class:
+					builder.Append(&quot;Class&quot;);
+					break;
+				case ClassType.Struct:
+					builder.Append(&quot;Structure&quot;);
+					break;
+				case ClassType.Interface:
+					builder.Append(&quot;Interface&quot;);
+					break;
+				case ClassType.Enum:
+					builder.Append(&quot;Enum&quot;);
+					break;
+			}
+			
+			return builder.ToString();
+		}
+		
+		public override string Convert(IField field)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			builder.Append(Convert(field.Modifiers));
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;i&gt;&quot;);
+			}
+			
+			if (ShowModifiers) {
+				if (field.IsStatic &amp;&amp; field.IsLiteral) {
+					builder.Append(&quot;Const &quot;);
+				} else if (field.IsStatic) {
+					builder.Append(&quot;Shared &quot;);
+				}
+			}
+						
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/i&gt;&quot;);
+				builder.Append(&quot;&lt;b&gt;&quot;);
+			}
+			
+			if (UseFullyQualifiedMemberNames) {
+				builder.Append(field.FullyQualifiedName);
+			} else {
+				builder.Append(field.Name);
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/b&gt;&quot;);
+			}
+			
+			if (field.ReturnType != null &amp;&amp; ShowReturnType) {
+				builder.Append(&quot; As &quot;);
+				builder.Append(Convert(field.ReturnType));
+			}			
+			
+			return builder.ToString();			
+		}
+		
+		public override string Convert(IProperty property)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			builder.Append(Convert(property.Modifiers));
+			
+			if (ShowModifiers) {
+				builder.Append(GetModifier(property));
+			}
+			
+			if (property.CanGet &amp;&amp; !property.CanSet) {
+				builder.Append(&quot;ReadOnly &quot;);
+			}
+			
+			if (property.CanSet &amp;&amp; !property.CanGet) {
+				builder.Append(&quot;WriteOnly &quot;);
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;b&gt;&quot;);
+			}
+			
+			if (UseFullyQualifiedMemberNames) {
+				builder.Append(property.FullyQualifiedName);
+			} else {
+				builder.Append(property.Name);
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/b&gt;&quot;);
+			}
+			
+			if (property.Parameters.Count &gt; 0) {
+				builder.Append(&quot;(&quot;);
+				if (IncludeHTMLMarkup) builder.Append(&quot;&lt;br&gt;&quot;);
+				
+				for (int i = 0; i &lt; property.Parameters.Count; ++i) {
+					if (IncludeHTMLMarkup) builder.Append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);
+					builder.Append(Convert(property.Parameters[i]));
+					if (i + 1 &lt; property.Parameters.Count) {
+						builder.Append(&quot;, &quot;);
+					}
+					if (IncludeHTMLMarkup) builder.Append(&quot;&lt;br&gt;&quot;);
+				}
+				
+				builder.Append(')');
+			}
+			
+			if (property.ReturnType != null &amp;&amp; ShowReturnType) {
+				builder.Append(&quot; As &quot;);
+				builder.Append(Convert(property.ReturnType));
+			}
+			
+			return builder.ToString();
+		}
+		
+		public override string Convert(IEvent e)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			builder.Append(Convert(e.Modifiers));
+			
+			if (ShowModifiers) {
+				builder.Append(GetModifier(e));
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;b&gt;&quot;);
+			}
+			
+			if (UseFullyQualifiedMemberNames) {
+				builder.Append(e.FullyQualifiedName);
+			} else {
+				builder.Append(e.Name);
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/b&gt;&quot;);
+			}
+			
+			if (e.ReturnType != null &amp;&amp; ShowReturnType) {
+				builder.Append(&quot; As &quot;);
+				builder.Append(Convert(e.ReturnType));
+			}
+			
+			return builder.ToString();
+		}
+		
+		public override string Convert(IIndexer m)
+		{
+			StringBuilder builder = new StringBuilder();
+			builder.Append(Convert(m.Modifiers));
+			
+			if (ShowModifiers) {
+				if (m.IsStatic) {
+					builder.Append(&quot;Shared &quot;);
+				}
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;b&gt;&quot;);
+			}
+			
+			if (UseFullyQualifiedMemberNames) {
+				builder.Append(m.FullyQualifiedName);
+			} else {
+				builder.Append(m.Name);
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/b&gt;&quot;);
+			}
+			
+			builder.Append(&quot;Item(&quot;);
+			if (IncludeHTMLMarkup) builder.Append(&quot;&lt;br&gt;&quot;);
+
+			for (int i = 0; i &lt; m.Parameters.Count; ++i) {
+				if (IncludeHTMLMarkup) builder.Append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);
+				builder.Append(Convert(m.Parameters[i]));
+				if (i + 1 &lt; m.Parameters.Count) {
+					builder.Append(&quot;, &quot;);
+				}
+				if (IncludeHTMLMarkup) builder.Append(&quot;&lt;br&gt;&quot;);
+			}
+			
+			builder.Append(&quot;)&quot;);
+			
+			if (m.ReturnType != null &amp;&amp; ShowReturnType) {
+				builder.Append(&quot; As &quot;);
+				builder.Append(Convert(m.ReturnType));
+			}			
+			
+			return builder.ToString();
+		}
+		
+		public override string Convert(IMethod m)
+		{
+			StringBuilder builder = new StringBuilder();
+			builder.Append(Convert(m.Modifiers));
+			
+			if (ShowModifiers) {
+				builder.Append(GetModifier(m));
+			}
+			if (ShowReturnType) {
+				if (m.ReturnType == null || m.ReturnType.FullyQualifiedName == &quot;System.Void&quot;) {
+					builder.Append(&quot;Sub &quot;);
+				} else {
+					builder.Append(&quot;Function &quot;);
+				}
+			}
+
+			string dispName = UseFullyQualifiedMemberNames ? m.FullyQualifiedName : m.Name;
+			if (m.Name == &quot;ctor&quot; || m.Name == &quot;cctor&quot; || m.Name == &quot;#ctor&quot; || m.Name == &quot;#cctor&quot; || m.IsConstructor) {
+				dispName = &quot;New&quot;;
+			}
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;b&gt;&quot;);
+			}
+			
+			builder.Append(dispName);
+			
+			if (IncludeHTMLMarkup) {
+				builder.Append(&quot;&lt;/b&gt;&quot;);
+			}
+			
+			builder.Append(&quot;(&quot;);
+			if (IncludeHTMLMarkup) builder.Append(&quot;&lt;br&gt;&quot;);
+
+			for (int i = 0; i &lt; m.Parameters.Count; ++i) {
+				if (IncludeHTMLMarkup) builder.Append(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);
+				builder.Append(Convert(m.Parameters[i]));
+				if (i + 1 &lt; m.Parameters.Count) {
+					builder.Append(&quot;, &quot;);
+				}
+				if (IncludeHTMLMarkup) builder.Append(&quot;&lt;br&gt;&quot;);
+			}
+			
+			builder.Append(')');
+			
+			if (ShowReturnType &amp;&amp; m.ReturnType != null &amp;&amp; m.ReturnType.FullyQualifiedName != &quot;System.Void&quot;) {
+				builder.Append(&quot; As &quot;);
+				builder.Append(Convert(m.ReturnType));
+			}
+			
+			return builder.ToString();
+		}
+		
+		public override string ConvertEnd(IMethod m)
+		{
+			if (m.ReturnType == null || m.ReturnType.FullyQualifiedName == &quot;System.Void&quot;) {
+				return &quot;End Sub&quot;;
+			} else {
+				return &quot;End Function&quot;;
+			}
+		}
+		
+		public override string Convert(IReturnType returnType)
+		{
+			if (returnType == null) {
+				return String.Empty;
+			}
+			StringBuilder builder = new StringBuilder();
+			
+			bool linkSet = false;
+			
+			if (UseLinkArrayList) {
+				SharpAssemblyReturnType ret = returnType as SharpAssemblyReturnType;
+				if (ret != null) {
+					if (ret.UnderlyingClass != null) {
+						builder.Append(&quot;&lt;a href='<A HREF="as://&quot;">as://&quot;</A> + linkArrayList.Add(ret.UnderlyingClass) + &quot;'&gt;&quot;);
+						linkSet = true;
+					}
+				}
+			}
+			
+			if (returnType.FullyQualifiedName != null &amp;&amp; typeConversionTable[returnType.FullyQualifiedName] != null) {
+				builder.Append(typeConversionTable[returnType.FullyQualifiedName].ToString());
+			} else {
+				builder.Append(UseFullyQualifiedNames ? returnType.FullyQualifiedName : returnType.Name);
+			}
+			
+			if (linkSet) {
+				builder.Append(&quot;&lt;/a&gt;&quot;);
+			}
+
+			for (int i = 0; i &lt; returnType.PointerNestingLevel; ++i) {
+				builder.Append('*');
+			}
+			
+			for (int i = 0; i &lt; returnType.ArrayCount; ++i) {
+				builder.Append('(');
+				for (int j = 1; j &lt; returnType.ArrayDimensions[i]; ++j) {
+					builder.Append(',');
+				}
+				builder.Append(')');
+			}
+			
+			return builder.ToString();
+		}
+		
+		public override string Convert(IParameter param)
+		{
+			StringBuilder builder = new StringBuilder();
+			if (ShowParameterNames) {
+				if (IncludeHTMLMarkup) {
+					builder.Append(&quot;&lt;i&gt;&quot;);
+				}
+			
+				if (param.IsRef || param.IsOut) {
+					builder.Append(&quot;ByRef &quot;);
+				} else if (param.IsParams) {
+					builder.Append(&quot;ByVal ParamArray &quot;);
+				} else  {
+					builder.Append(&quot;ByVal &quot;);
+				}
+				if (IncludeHTMLMarkup) {
+					builder.Append(&quot;&lt;/i&gt;&quot;);
+				}
+			
+			
+				builder.Append(param.Name);
+				builder.Append(&quot; As &quot;);
+			}
+
+			builder.Append(Convert(param.ReturnType));
+
+			return builder.ToString();
+		}
+
+		public override string WrapAttribute(string attribute)
+		{
+			return &quot;&lt;&quot; + attribute + &quot;&gt;&quot;;
+		}
+		
+		public override string WrapComment(string comment)
+		{
+			return &quot;' &quot; + comment;
+		}
+		
+		public override string GetIntrinsicTypeName(string dotNetTypeName)
+		{
+			if (typeConversionTable[dotNetTypeName] != null) {
+				return (string)typeConversionTable[dotNetTypeName];
+			}
+			return dotNetTypeName;
+		}
+	}
+	
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBBindingCompilerServices.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBBindingCompilerServices.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBBindingCompilerServices.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,716 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Collections;
+using System.IO;
+using System.Diagnostics;
+using System.CodeDom.Compiler;
+using MonoDevelop.Core.Services;
+
+using MonoDevelop.Services;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+using MonoDevelop.Gui.Components;
+
+namespace VBBinding {
+	
+	/// &lt;summary&gt;
+	/// This class controls the compilation of VB.net files and VB.net projects
+	/// &lt;/summary&gt;
+	public class VBBindingCompilerServices
+	{	
+	
+		static Regex regexError = new Regex (@&quot;^(\s*(?&lt;file&gt;.*)\((?&lt;line&gt;\d*)(,(?&lt;column&gt;\d*))?\)\s+)*(?&lt;level&gt;\w+)\s*(?&lt;number&gt;.*):\s(?&lt;message&gt;.*)&quot;,
+		RegexOptions.Compiled | RegexOptions.ExplicitCapture);
+
+	
+		FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
+		PropertyService propertyService       = (PropertyService)ServiceManager.GetService(typeof(PropertyService));
+		
+		public string GetCompiledOutputName(string fileName)
+		{
+			return Path.ChangeExtension(fileName, &quot;.exe&quot;);
+		}
+		
+		public string GetCompiledOutputName(IProject project)
+		{
+			VBProject p = (VBProject)project;
+			VBCompilerParameters compilerparameters = (VBCompilerParameters)p.ActiveConfiguration;
+			/* switch(compilerparameters.CompileTarget){
+				case CompileTarget.Exe:
+					System.Console.WriteLine(&quot;EXE&quot;);
+					break;
+				case CompileTarget.Library:
+					System.Console.WriteLine(&quot;Library!&quot;);
+					break;
+				case CompileTarget.WinExe:
+					System.Console.WriteLine(&quot;WinEXE&quot;);
+					break;
+				default:
+					System.Console.WriteLine(&quot;Unknown case: &quot; + compilerparameters.CompileTarget);
+					break;
+			}
+			*/
+			return fileUtilityService.GetDirectoryNameWithSeparator(compilerparameters.OutputDirectory) + compilerparameters.OutputAssembly + (compilerparameters.CompileTarget == CompileTarget.Library ? &quot;.dll&quot; : &quot;.exe&quot;);
+		}
+		
+		public bool CanCompile(string fileName)
+		{
+			return Path.GetExtension(fileName) == &quot;.vb&quot;;
+		}
+		
+		string GetCompilerName(string compilerVersion)
+		{
+			//string runtimeDirectory = Path.Combine(fileUtilityService.NETFrameworkInstallRoot, compilerVersion);
+			//if (compilerVersion.Length == 0 || compilerVersion == &quot;Standard&quot; || !Directory.Exists(runtimeDirectory)) {
+			//	runtimeDirectory = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory();
+			//}
+			//return String.Concat('&quot;', Path.Combine(runtimeDirectory, &quot;vbc.exe&quot;), '&quot;');
+			return &quot;mbas&quot;;
+		}
+		
+		string GenerateOptions(VBCompilerParameters compilerparameters, string outputFileName)
+		{
+			StringBuilder sb = new StringBuilder();
+			
+			sb.Append(&quot;-out:&quot;);sb.Append(outputFileName);/*sb.Append('&quot;');*/sb.Append(Environment.NewLine);
+			
+			sb.Append(&quot;-nologo&quot;);sb.Append(Environment.NewLine);
+			sb.Append(&quot;-utf8output&quot;);sb.Append(Environment.NewLine);
+			
+//			if (compilerparameters.Debugmode) {
+//				sb.Append(&quot;--debug+&quot;);sb.Append(Environment.NewLine);
+//				sb.Append(&quot;--debug:full&quot;);sb.Append(Environment.NewLine);
+//			}
+			
+			//if (compilerparameters.Optimize) {
+			//	sb.Append(&quot;-optimize&quot;);sb.Append(Environment.NewLine);
+			//}
+			
+			//if (compilerparameters.OptionStrict) {
+			//	sb.Append(&quot;-optionstrict&quot;);sb.Append(Environment.NewLine);
+			//}
+			
+			//if (compilerparameters.OptionExplicit) {
+			//	sb.Append(&quot;-optionexplicit&quot;);sb.Append(Environment.NewLine);
+			//}// else {
+			//	sb.Append(&quot;--optionexplicit-&quot;);sb.Append(Environment.NewLine);
+			//}
+			
+			if (compilerparameters.Win32Icon != null &amp;&amp; compilerparameters.Win32Icon.Length &gt; 0 &amp;&amp; File.Exists(compilerparameters.Win32Icon)) {
+				sb.Append(&quot;-win32icon:&quot;);sb.Append('&quot;');sb.Append(compilerparameters.Win32Icon);sb.Append('&quot;');sb.Append(Environment.NewLine);
+			}
+			
+			if (compilerparameters.RootNamespace!= null &amp;&amp; compilerparameters.RootNamespace.Length &gt; 0) {
+				sb.Append(&quot;-rootnamespace:&quot;);sb.Append('&quot;');sb.Append(compilerparameters.RootNamespace);sb.Append('&quot;');sb.Append(Environment.NewLine);
+			}
+			
+			if (compilerparameters.DefineSymbols.Length &gt; 0) {
+				sb.Append(&quot;-define:&quot;);sb.Append('&quot;');sb.Append(compilerparameters.DefineSymbols);sb.Append('&quot;');sb.Append(Environment.NewLine);
+			}
+			
+			if (compilerparameters.MainClass != null &amp;&amp; compilerparameters.MainClass.Length &gt; 0) {
+				sb.Append(&quot;-main:&quot;);sb.Append(compilerparameters.MainClass);sb.Append(Environment.NewLine);
+			}
+			
+			if(compilerparameters.Imports.Length &gt; 0) {
+				sb.Append(&quot;-imports:&quot;);sb.Append(compilerparameters.Imports);sb.Append(Environment.NewLine);
+			}
+			
+			switch (compilerparameters.CompileTarget) {
+				case CompileTarget.Exe:
+					sb.Append(&quot;-target:exe&quot;);
+					break;
+				case CompileTarget.WinExe:
+					sb.Append(&quot;-target:winexe&quot;);
+					break;
+				case CompileTarget.Library:
+					sb.Append(&quot;-target:library&quot;);
+					break;
+				case CompileTarget.Module:
+					sb.Append(&quot;-target:module&quot;);
+					break;
+				default:
+					throw new NotSupportedException(&quot;unknown compile target:&quot; + compilerparameters.CompileTarget);
+			}
+			sb.Append(Environment.NewLine);
+			return sb.ToString();
+		}
+		
+		public ICompilerResult CompileFile(string filename)
+		{
+			//System.Console.WriteLine(&quot;CompileFile &quot; + filename);
+			string output = &quot;&quot;;
+			string error  = &quot;&quot;;
+			string exe = Path.ChangeExtension(filename, &quot;.exe&quot;);
+			VBCompilerParameters compilerparameters = new VBCompilerParameters();
+			string stdResponseFileName = propertyService.DataDirectory + Path.DirectorySeparatorChar + &quot;vb.rsp&quot;;
+			
+			string responseFileName = Path.GetTempFileName();
+			
+			StreamWriter writer = new StreamWriter(responseFileName);
+			writer.WriteLine(GenerateOptions(compilerparameters, exe));
+			writer.WriteLine(String.Concat('&quot;', filename, '&quot;'));
+			writer.Close();
+			
+			string compilerName = GetCompilerName(compilerparameters.VBCompilerVersion);
+			string outstr = String.Concat(compilerName, &quot; @&quot;, responseFileName); //, &quot; @&quot;, stdResponseFileName);
+			
+			TempFileCollection  tf = new TempFileCollection ();
+			//Executor.ExecWaitWithCapture(outstr, tf, ref output, ref error);
+			DoCompilation(outstr,tf,ref output, ref error);
+			
+			ICompilerResult result = ParseOutput(tf, output);
+			
+			File.Delete(responseFileName);
+			File.Delete(output);
+			File.Delete(error);
+			WriteManifestFile(exe);
+			return result;
+		}
+		
+		public ICompilerResult CompileProject(IProject project)
+		{
+			//System.Console.WriteLine(&quot;CompileProject &quot;);
+			VBProject p = (VBProject)project;
+			VBCompilerParameters compilerparameters = (VBCompilerParameters)p.ActiveConfiguration;
+			string exe       = fileUtilityService.GetDirectoryNameWithSeparator(compilerparameters.OutputDirectory) + compilerparameters.OutputAssembly + (compilerparameters.CompileTarget == CompileTarget.Library ? &quot;.dll&quot; : &quot;.exe&quot;);
+			string responseFileName = Path.GetTempFileName();
+			string stdResponseFileName = String.Concat(propertyService.DataDirectory, Path.DirectorySeparatorChar, &quot;vb.rsp&quot;);
+			StreamWriter writer = new StreamWriter(responseFileName);
+			
+			//Console.WriteLine(GenerateOptions(compilerparameters,exe));	
+			writer.WriteLine(GenerateOptions(compilerparameters, exe));
+			
+			foreach (ProjectReference lib in p.ProjectReferences) {
+				string fileName = lib.GetReferencedFileName(p);
+				//Console.WriteLine(String.Concat(&quot;-r:&quot;,fileName));
+				writer.WriteLine(String.Concat(&quot;-r:&quot;, fileName));
+			}
+			
+			// write source files and embedded resources
+			foreach (ProjectFile finfo in p.ProjectFiles) {
+				if (finfo.Subtype != Subtype.Directory) {
+					switch (finfo.BuildAction) {
+						case BuildAction.Compile:
+							//Console.WriteLine(finfo.Name);
+							writer.WriteLine(finfo.Name);
+						break;
+						
+						case BuildAction.EmbedAsResource:
+							//Console.WriteLine(String.Concat(&quot;-resource:&quot;, finfo.Name));
+							writer.WriteLine(String.Concat(&quot;-resource:&quot;, finfo.Name));
+						break;
+					}
+				}
+			}
+			
+			TempFileCollection tf = new TempFileCollection ();
+			writer.Close();
+			
+			string output = &quot;&quot;;
+			string error  = &quot;&quot;;
+			string compilerName = GetCompilerName(compilerparameters.VBCompilerVersion);
+			string outstr = String.Concat(compilerName, &quot; @&quot;, responseFileName); //, &quot; @&quot;, stdResponseFileName);
+			
+			//Console.WriteLine(&quot;Attempting to run: &quot;+outstr);
+			
+			//Executor.ExecWaitWithCapture(outstr, tf, ref output, ref error);
+			DoCompilation(outstr,tf,ref output,ref error);
+			
+			//Console.WriteLine(&quot;Output: &quot;+output);
+			//Console.WriteLine(&quot;Error: &quot;+error);
+			
+			
+			ICompilerResult result = ParseOutput(tf, output);
+			ParseOutput(tf,error);
+			
+			project.CopyReferencesToOutputPath(false);
+			
+			File.Delete(responseFileName);
+			File.Delete(output);
+			File.Delete(error);
+			if (compilerparameters.CompileTarget != CompileTarget.Library) {
+				WriteManifestFile(exe);
+			}
+			return result;
+		}
+		
+		// code duplication: see C# backend : CSharpBindingCompilerManager
+		void WriteManifestFile(string fileName)
+		{
+			string manifestFile = String.Concat(fileName, &quot;.manifest&quot;);
+			if (File.Exists(manifestFile)) {
+				return;
+			}
+			StreamWriter sw = new StreamWriter(manifestFile);
+			sw.WriteLine(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; standalone=\&quot;yes\&quot;?&gt;&quot;);
+			sw.WriteLine(&quot;&quot;);
+			sw.WriteLine(&quot;&lt;assembly xmlns=\&quot;urn:schemas-microsoft-com:asm.v1\&quot; manifestVersion=\&quot;1.0\&quot;&gt;&quot;);
+			sw.WriteLine(&quot;	&lt;dependency&gt;&quot;);
+			sw.WriteLine(&quot;		&lt;dependentAssembly&gt;&quot;);
+			sw.WriteLine(&quot;			&lt;assemblyIdentity&quot;);
+			sw.WriteLine(&quot;				type=\&quot;win32\&quot;&quot;);
+			sw.WriteLine(&quot;				name=\&quot;Microsoft.Windows.Common-Controls\&quot;&quot;);
+			sw.WriteLine(&quot;				version=\&quot;6.0.0.0\&quot;&quot;);
+			sw.WriteLine(&quot;				processorArchitecture=\&quot;X86\&quot;&quot;);
+			sw.WriteLine(&quot;				publicKeyToken=\&quot;6595b64144ccf1df\&quot;&quot;);
+			sw.WriteLine(&quot;				language=\&quot;*\&quot;&quot;);
+			sw.WriteLine(&quot;			/&gt;&quot;);
+			sw.WriteLine(&quot;		&lt;/dependentAssembly&gt;&quot;);
+			sw.WriteLine(&quot;	&lt;/dependency&gt;&quot;);
+			sw.WriteLine(&quot;&lt;/assembly&gt;&quot;);
+			sw.Close();
+		}
+		
+/***** Legacy #D code, will remove if replacement code tests OK *****
+
+		CompilerResult ParseOutput(TempFileCollection tf, string file)
+		{
+			StringBuilder compilerOutput = new StringBuilder();
+			
+			StreamReader sr = File.OpenText(file);
+			
+			// skip fist whitespace line
+			sr.ReadLine();
+			
+			CompilerResults cr = new CompilerResults(tf);
+			
+			while (true) {
+				string next = sr.ReadLine();
+				compilerOutput.Append(next);compilerOutput.Append(Environment.NewLine);
+				if (next == null) {
+					break;
+				}
+				CompilerError error = new CompilerError();
+				
+				int index           = next.IndexOf(&quot;: &quot;);
+				if (index &lt; 0) {
+					continue;
+				}
+				
+				string description  = null;
+				string errorwarning = null;
+				string location     = null;
+				
+				string s1 = next.Substring(0, index);
+				string s2 = next.Substring(index + 2);
+				index  = s2.IndexOf(&quot;: &quot;);
+				
+				if (index == -1) {
+					errorwarning = s1;
+					description = s2;
+				} else {
+					location = s1;
+					s1 = s2.Substring(0, index);
+					s2 = s2.Substring(index + 2);
+					errorwarning = s1;
+					description = s2;
+				}
+				
+				if (location != null) {
+					int idx1 = location.LastIndexOf('(');
+					int idx2 = location.LastIndexOf(')');
+					if (idx1 &gt;= 0 &amp;&amp;  idx2 &gt;= 0) {
+						string filename = location.Substring(0, idx1);
+						error.Line = Int32.Parse(location.Substring(idx1 + 1, idx2 - idx1 - 1));
+						error.FileName = Path.GetFullPath(filename.Trim()); // + &quot;\\&quot; + Path.GetFileName(filename);
+					}
+				}
+				
+				string[] what = errorwarning.Split(' ');
+				Console.WriteLine(&quot;Error is: &quot;+what[0]);
+				error.IsWarning   = (what[0] == &quot;warning&quot; || what[0]==&quot;MonoBASIC&quot;);
+				error.ErrorNumber = what[what.Length - 1];
+				
+				error.ErrorText = description;
+				
+				cr.Errors.Add(error);
+			}
+			sr.Close();
+			Console.WriteLine(compilerOutput.ToString());
+			return new DefaultCompilerResult(cr, compilerOutput.ToString());
+		}
+*/
+		
+		ICompilerResult ParseOutput(TempFileCollection tf, string file)
+		{
+			StringBuilder compilerOutput = new StringBuilder();
+			
+			StreamReader sr = File.OpenText(file);
+			
+			// skip fist whitespace line
+			//sr.ReadLine();
+			
+			CompilerResults cr = new CompilerResults(tf);
+			
+			// we have 2 formats for the error output the csc gives :
+			Regex normalError  = new Regex(@&quot;(?&lt;file&gt;.*)\((?&lt;line&gt;\d+),(?&lt;column&gt;\d+)\):\s+(?&lt;error&gt;\w+)\s+(?&lt;number&gt;[\d\w]+):\s+(?&lt;message&gt;.*)&quot;, RegexOptions.Compiled);
+			Regex generalError = new Regex(@&quot;(?&lt;error&gt;.+)\s+(?&lt;number&gt;[\d\w]+):\s+(?&lt;message&gt;.*)&quot;, RegexOptions.Compiled);
+			
+			while (true) {
+				string curLine = sr.ReadLine();
+				compilerOutput.Append(curLine);
+				compilerOutput.Append('\n');
+				if (curLine == null) {
+					break;
+				}
+				curLine = curLine.Trim();
+				if (curLine.Length == 0) {
+					continue;
+				}
+				
+				CompilerError error = CreateErrorFromString (curLine);
+				
+				if (error != null)
+					cr.Errors.Add (error);
+			}
+			sr.Close();
+			return new DefaultCompilerResult(cr, compilerOutput.ToString());
+		}
+		
+		
+		private static CompilerError CreateErrorFromString(string error_string)
+		{
+			// When IncludeDebugInformation is true, prevents the debug symbols stats from braeking this.
+			if (error_string.StartsWith (&quot;WROTE SYMFILE&quot;) ||
+			    error_string.StartsWith (&quot;OffsetTable&quot;) ||
+			    error_string.StartsWith (&quot;Compilation succeeded&quot;) ||
+			    error_string.StartsWith (&quot;Compilation failed&quot;) || 
+			    error_string.StartsWith(&quot;MonoBASIC&quot;) || 
+			    error_string.StartsWith(&quot;Type:&quot;))
+				return null;
+
+			CompilerError error = new CompilerError();
+
+			Match match=regexError.Match(error_string);
+			if (!match.Success) return null;
+			if (String.Empty != match.Result(&quot;${file}&quot;))
+				error.FileName=match.Result(&quot;${file}&quot;);
+			if (String.Empty != match.Result(&quot;${line}&quot;))
+				error.Line=Int32.Parse(match.Result(&quot;${line}&quot;));
+			if (String.Empty != match.Result(&quot;${column}&quot;))
+				error.Column=Int32.Parse(match.Result(&quot;${column}&quot;));
+			if (match.Result(&quot;${level}&quot;)==&quot;warning&quot;)
+				error.IsWarning=true;
+			error.ErrorNumber=match.Result(&quot;${number}&quot;);
+			error.ErrorText=match.Result(&quot;${message}&quot;);
+			return error;
+		}
+		
+		public void GenerateMakefile (IProject project, Combine parentCombine)
+		{
+			StreamWriter stream = new StreamWriter (Path.Combine (project.BaseDirectory, &quot;Makefile.&quot; + project.Name.Replace (&quot; &quot;, &quot;&quot;)));
+
+			VBProject p = (VBProject)project;
+			VBCompilerParameters compilerparameters = (VBCompilerParameters)p.ActiveConfiguration;
+			
+			//special case for module?
+			string outputName = compilerparameters.OutputAssembly + (compilerparameters.CompileTarget == CompileTarget.Library ? &quot;.dll&quot; : &quot;.exe&quot;);
+
+			string target = &quot;&quot;;
+			string relativeOutputDir = fileUtilityService.AbsoluteToRelativePath (project.BaseDirectory, parentCombine.OutputDirectory);
+
+			switch (compilerparameters.CompileTarget) {
+			case CompileTarget.Exe:
+				target = &quot;exe&quot;;
+				break;
+			case CompileTarget.WinExe:
+				target = &quot;winexe&quot;;
+				break;
+			case CompileTarget.Library:
+				target = &quot;library&quot;;
+				break;
+			//no module yet
+			}			
+			
+			ArrayList compile_files = new ArrayList ();
+			ArrayList pkg_references = new ArrayList ();
+			ArrayList assembly_references = new ArrayList ();
+			ArrayList project_references = new ArrayList ();
+			ArrayList system_references = new ArrayList ();
+			ArrayList resources = new ArrayList ();
+			
+			foreach (ProjectFile finfo in project.ProjectFiles) {
+				if (finfo.Subtype != Subtype.Directory) {
+					switch (finfo.BuildAction) {
+					case BuildAction.Compile:
+						string rel_path = fileUtilityService.AbsoluteToRelativePath (project.BaseDirectory, Path.GetDirectoryName (finfo.Name));
+						if (CanCompile (finfo.Name));
+						compile_files.Add (Path.Combine (rel_path, Path.GetFileName (finfo.Name)));
+						break;
+						
+					case BuildAction.EmbedAsResource:
+						string resource_rel_path = fileUtilityService.AbsoluteToRelativePath (project.BaseDirectory, Path.GetDirectoryName (finfo.Name));
+						resources.Add (Path.Combine (resource_rel_path, Path.GetFileName (finfo.Name)));
+						break;
+					}
+				}
+			}
+
+			SystemAssemblyService sas = (SystemAssemblyService)ServiceManager.GetService (typeof (SystemAssemblyService));
+			foreach (ProjectReference lib in project.ProjectReferences) {
+				switch (lib.ReferenceType) {
+				case ReferenceType.Gac:
+					string pkg = sas.GetPackageFromFullName (lib.Reference);
+					if (pkg == &quot;MONO-SYSTEM&quot;) {
+						system_references.Add (Path.GetFileName (lib.GetReferencedFileName (project)));
+					} else if (!pkg_references.Contains (pkg)) {
+						pkg_references.Add (pkg);
+					}
+					break;
+				case ReferenceType.Assembly:
+					string assembly_fileName = lib.GetReferencedFileName (project);
+					string rel_path_to = fileUtilityService.AbsoluteToRelativePath (project.BaseDirectory, Path.GetDirectoryName (assembly_fileName));
+					assembly_references.Add (Path.Combine (rel_path_to, Path.GetFileName (assembly_fileName)));
+					break;
+				case ReferenceType.Project:
+					string project_fileName = lib.GetReferencedFileName (project);
+					IProjectService prjService = (IProjectService)ServiceManager.GetService (typeof (IProjectService));
+					ArrayList allProjects = Combine.GetAllProjects(prjService.CurrentOpenCombine);
+					
+					foreach (ProjectCombineEntry projectEntry in allProjects) {
+						if (projectEntry.Project.Name == lib.Reference) {
+							string project_base_dir = fileUtilityService.AbsoluteToRelativePath (project.BaseDirectory, projectEntry.Project.BaseDirectory);
+							
+							string project_output_fileName = prjService.GetOutputAssemblyName (projectEntry.Project);
+							project_references.Add (Path.Combine (project_base_dir, Path.GetFileName (project_output_fileName)));
+						}
+					}
+					break;
+				}
+			}
+
+			stream.WriteLine (&quot;# This makefile is autogenerated by MonoDevelop&quot;);
+			stream.WriteLine (&quot;# Do not modify this file&quot;);
+			stream.WriteLine ();
+			stream.WriteLine (&quot;SOURCES = \\&quot;);
+			for (int i = 0; i &lt; compile_files.Count; i++) {
+				stream.Write (((string)compile_files[i]).Replace (&quot; &quot;, &quot;\\ &quot;));
+				if (i != compile_files.Count - 1)
+					stream.WriteLine (&quot; \\&quot;);
+				else
+					stream.WriteLine ();
+			}
+			stream.WriteLine ();
+
+			if (resources.Count &gt; 0) {
+				stream.WriteLine (&quot;RESOURCES = \\&quot;);
+				for (int i = 0; i &lt; resources.Count; i++) {
+					stream.Write (((string)resources[i]).Replace (&quot; &quot;, &quot;\\ &quot;));
+					if (i != resources.Count - 1)
+						stream.WriteLine (&quot; \\&quot;);
+					else
+						stream.WriteLine ();
+				}
+				stream.WriteLine ();
+				stream.WriteLine (&quot;RESOURCES_BUILD = $(foreach res,$(RESOURCES), $(addprefix -resource:,$(res)),$(notdir $(res)))&quot;);
+				stream.WriteLine ();
+			}
+
+			if (pkg_references.Count &gt; 0) {
+				stream.WriteLine (&quot;PKG_REFERENCES = \\&quot;);
+				for (int i = 0; i &lt; pkg_references.Count; i++) {
+					stream.Write (pkg_references[i]);
+					if (i != pkg_references.Count - 1)
+						stream.WriteLine (&quot; \\&quot;);
+					else
+						stream.WriteLine ();
+				}
+				
+				stream.WriteLine ();
+				stream.WriteLine (&quot;PKG_REFERENCES_BUILD = $(addprefix -pkg:, $(PKG_REFERENCES))&quot;);
+				stream.WriteLine ();
+				stream.WriteLine (&quot;PKG_REFERENCES_CHECK = $(addsuffix .pkgcheck, $(PKG_REFERENCES))&quot;);
+				stream.WriteLine ();
+			}
+			
+			if (system_references.Count &gt; 0) {
+				stream.WriteLine (&quot;SYSTEM_REFERENCES = \\&quot;);
+				for (int i = 0; i &lt; system_references.Count; i++) {
+					stream.Write (system_references[i]);
+					if (i != system_references.Count - 1)
+						stream.WriteLine (&quot; \\&quot;);
+					else
+						stream.WriteLine ();
+				}
+				stream.WriteLine ();
+				stream.WriteLine (&quot;SYSTEM_REFERENCES_BUILD = $(addprefix -r:, $(SYSTEM_REFERENCES))&quot;);
+				stream.WriteLine ();
+				stream.WriteLine (&quot;SYSTEM_REFERENCES_CHECK = $(addsuffix .check, $(SYSTEM_REFERENCES))&quot;);
+				stream.WriteLine ();
+			}
+
+			if (assembly_references.Count &gt; 0) {
+				stream.WriteLine (&quot;ASSEMBLY_REFERENCES = \\&quot;);
+				for (int i = 0; i &lt; assembly_references.Count; i++) {
+					stream.Write (&quot;\&quot;&quot; + assembly_references[i] + &quot;\&quot;&quot;);
+					if (i != assembly_references.Count - 1)
+						stream.WriteLine (&quot; \\&quot;);
+					else
+						stream.WriteLine ();
+				}
+				
+				stream.WriteLine ();
+				stream.WriteLine (&quot;ASSEMBLY_REFERENCES_BUILD = $(addprefix -r:, $(ASSEMBLY_REFERENCES))&quot;);
+				stream.WriteLine ();
+			}
+
+			if (project_references.Count &gt; 0) {
+				stream.WriteLine (&quot;PROJECT_REFERENCES = \\&quot;);
+				for (int i = 0; i &lt; project_references.Count; i++) {
+					stream.Write (&quot;\&quot;&quot; + project_references[i] + &quot;\&quot;&quot;);
+					if (i != project_references.Count - 1)
+						stream.WriteLine (&quot; \\&quot;);
+					else
+						stream.WriteLine ();
+				}
+				
+				stream.WriteLine ();
+				stream.WriteLine (&quot;PROJECT_REFERENCES_BUILD = $(addprefix -r:, $(PROJECT_REFERENCES))&quot;);
+				stream.WriteLine ();
+			}
+
+			stream.Write (&quot;MBAS_OPTIONS = &quot;);
+			if (compilerparameters.UnsafeCode) {
+				stream.Write (&quot;-unsafe &quot;);
+			}
+			if (compilerparameters.DefineSymbols != null &amp;&amp; compilerparameters.DefineSymbols.Length &gt; 0) {
+				stream.Write (&quot;-define:&quot; + '&quot;' + compilerparameters.DefineSymbols + '&quot;' + &quot; &quot;);
+			}
+			if (compilerparameters.MainClass != null &amp;&amp; compilerparameters.MainClass.Length &gt; 0) {
+				stream.Write (&quot;-main:&quot; + compilerparameters.MainClass + &quot; &quot;);
+			}
+			stream.WriteLine ();
+			stream.WriteLine ();
+
+			stream.WriteLine (&quot;all: &quot; + outputName);
+			stream.WriteLine ();
+			
+			stream.Write (outputName + &quot;: $(SOURCES)&quot;);
+			if (resources.Count &gt; 0) {
+				stream.WriteLine (&quot; $(RESOURCES)&quot;);
+			} else {
+				stream.WriteLine ();
+			}
+			
+			stream.Write (&quot;\tmbas $(MBAS_OPTIONS) -target:{0} -out:\&quot;{1}\&quot;&quot;, target, outputName);
+			if (resources.Count &gt; 0) {
+				stream.Write (&quot; $(RESOURCES_BUILD)&quot;);
+			}
+			if (pkg_references.Count &gt; 0) {
+				stream.Write (&quot; $(PKG_REFERENCES_BUILD)&quot;);
+			}
+			if (assembly_references.Count &gt; 0) {
+				stream.Write (&quot; $(ASSEMBLY_REFERENCES_BUILD)&quot;);
+			}
+			if (project_references.Count &gt; 0) {
+				stream.Write (&quot; $(PROJECT_REFERENCES_BUILD)&quot;);
+			}
+			if (system_references.Count &gt; 0) {
+				stream.Write (&quot; $(SYSTEM_REFERENCES_BUILD)&quot;);
+			}
+			stream.WriteLine (&quot; $(SOURCES) \\&quot;);
+			stream.WriteLine (&quot;\t&amp;&amp; cp \&quot;{0}\&quot; {1}/.&quot;, outputName, relativeOutputDir);
+			
+			stream.WriteLine ();
+			stream.WriteLine (&quot;clean:&quot;);
+			stream.WriteLine (&quot;\trm -f {0}&quot;, outputName);
+			stream.WriteLine ();
+			
+			stream.Write (&quot;depcheck: &quot;);
+			if (pkg_references.Count &gt; 0) {
+				stream.Write (&quot;PKG_depcheck &quot;);
+			}
+			if (system_references.Count &gt; 0) {
+				stream.Write (&quot;SYSTEM_depcheck&quot;);
+			}
+			stream.WriteLine ();
+			stream.WriteLine ();
+			if (pkg_references.Count &gt; 0) {
+				stream.WriteLine (&quot;PKG_depcheck: $(PKG_REFERENCES_CHECK)&quot;);
+				stream.WriteLine ();
+				stream.WriteLine (&quot;%.pkgcheck:&quot;);
+				stream.WriteLine (&quot;\<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">t at echo</A> -n Checking for package $(subst .pkgcheck,,$@)...&quot;);
+				stream.WriteLine (&quot;\<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">t at if</A> pkg-config --libs $(subst .pkgcheck,,$@) &amp;&gt; /dev/null; then \\&quot;);
+				stream.WriteLine (&quot;\t\techo yes; \\&quot;);
+				stream.WriteLine (&quot;\telse \\&quot;);
+				stream.WriteLine (&quot;\t\techo no; \\&quot;);
+				stream.WriteLine (&quot;\t\texit 1; \\&quot;);
+				stream.WriteLine (&quot;\tfi&quot;);
+				stream.WriteLine ();
+			}
+
+			if (system_references.Count &gt; 0) {
+				stream.WriteLine (&quot;SYSTEM_depcheck: $(SYSTEM_REFERENCES_CHECK)&quot;);
+				stream.WriteLine ();
+				stream.WriteLine (&quot;%.check:&quot;);
+				stream.WriteLine (&quot;\<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">t at echo</A> -n Checking for $(subst .check,,$@)...&quot;);
+				stream.WriteLine (&quot;\<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">t at if</A> [ ! -e `pkg-config --variable=libdir mono`/mono/1.0/$(subst .check,,$@) ]; then \\&quot;);
+				stream.WriteLine (&quot;\t\techo no; \\&quot;);
+				stream.WriteLine (&quot;\t\texit 1; \\&quot;);
+				stream.WriteLine (&quot;\telse \\&quot;);
+				stream.WriteLine (&quot;\t\techo yes; \\&quot;);
+				stream.WriteLine (&quot;\tfi&quot;);
+			}
+			
+			stream.Flush ();
+			stream.Close ();
+		}
+		
+		private void DoCompilation(string outstr, TempFileCollection tf, ref string output, ref string error) {
+			output = Path.GetTempFileName();
+			error = Path.GetTempFileName();
+			
+			string arguments = outstr + &quot; &gt; &quot; + output + &quot; 2&gt; &quot; + error;
+			string command = arguments;
+			ProcessStartInfo si = new ProcessStartInfo(&quot;/bin/sh&quot;,&quot;-c \&quot;&quot; + command + &quot;\&quot;&quot;);
+			si.RedirectStandardOutput = true;
+			si.RedirectStandardError = true;
+			si.UseShellExecute = false;
+			Process p = new Process();
+			p.StartInfo = si;
+			p.Start();
+			//FIXME: The glib.idle stuff is here because this *SHOULD* be
+			//a background thread calling back to the main thread.
+			//GLib.Idle.Add (new GLib.IdleHandler (setmsg));
+			setmsg ();
+			while (!p.HasExited) {
+				//GLib.Idle.Add (new GLib.IdleHandler (pulse));
+				pulse ();
+				System.Threading.Thread.Sleep (100);
+			}
+			//GLib.Idle.Add (new GLib.IdleHandler (done));
+			done ();
+		}
+		
+		bool setmsg ()
+		{
+			((IStatusBarService)ServiceManager.GetService (typeof (IStatusBarService))).SetMessage (&quot;Compiling...&quot;);
+			return false;
+		}
+
+		bool done ()
+		{
+			((SdStatusBar)((IStatusBarService)ServiceManager.GetService (typeof (IStatusBarService))).ProgressMonitor).Done ();
+			return false;
+		}
+
+		bool pulse () 
+		{
+			((SdStatusBar)((IStatusBarService)ServiceManager.GetService (typeof (IStatusBarService))).ProgressMonitor).Pulse ();
+			while (Gtk.Application.EventsPending ())
+				Gtk.Application.RunIteration ();
+			return false;
+		}
+		
+	}
+}
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBBindingExecutionServices.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBBindingExecutionServices.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBBindingExecutionServices.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,110 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Diagnostics;
+using System.Collections;
+using System.Reflection;
+using System.Resources;
+
+using System.Xml;
+using System.CodeDom.Compiler;
+using System.Threading;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+using MonoDevelop.Services;
+using MonoDevelop.Core.Services;
+
+//using CSharpBinding;
+
+namespace VBBinding
+{
+	/// &lt;summary&gt;
+	/// This class controls the compilation of C Sharp files and C Sharp projects
+	/// &lt;/summary&gt;
+	public class VBBindingExecutionServices //: CSharpBindingExecutionManager
+	{	
+		public void Debug (IProject project)
+		{
+			FileUtilityService fileUtilityService = (FileUtilityService) ServiceManager.GetService (typeof (FileUtilityService));
+			string directory = fileUtilityService.GetDirectoryNameWithSeparator(((VBCompilerParameters)project.ActiveConfiguration).OutputDirectory);
+			string exe = ((VBCompilerParameters)project.ActiveConfiguration).OutputAssembly + &quot;.exe&quot;;
+
+			IDebuggingService dbgr = (IDebuggingService) ServiceManager.GetService (typeof (IDebuggingService));
+			if (dbgr != null)
+				dbgr.Run (new string[] { Path.Combine (directory, exe) } );
+		}
+
+		public void Execute(string filename)
+		{
+			string exe = Path.ChangeExtension(filename, &quot;.exe&quot;);
+			
+			ProcessStartInfo psi = new ProcessStartInfo(&quot;/usr/bin/mono &quot; + exe);
+			psi.WorkingDirectory = Path.GetDirectoryName(exe);
+			psi.UseShellExecute = false;
+			try {
+				Process p = new Process();
+				p.StartInfo = psi;
+				p.Start();
+			} catch (Exception) {
+				throw new ApplicationException(&quot;Can not execute &quot; + &quot;\&quot;&quot; + exe + &quot;\&quot;\n(Try restarting MonoDevelop or start your app manually)&quot;);
+			}
+		}
+		
+		public void Execute(IProject project)
+		{
+			VBCompilerParameters parameters = (VBCompilerParameters)project.ActiveConfiguration;
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
+			
+			string directory = fileUtilityService.GetDirectoryNameWithSeparator(((VBCompilerParameters)project.ActiveConfiguration).OutputDirectory);
+			string exe = ((VBCompilerParameters)project.ActiveConfiguration).OutputAssembly + &quot;.exe&quot;;
+			string args = ((VBCompilerParameters)project.ActiveConfiguration).CommandLineParameters;
+			
+			ProcessStartInfo psi;
+			if (parameters.ExecuteScript != null &amp;&amp; parameters.ExecuteScript.Length &gt; 0) {
+				//Console.WriteLine(&quot;EXECUTE SCRIPT!!!!!!&quot;);
+				psi = new ProcessStartInfo(&quot;\&quot;&quot; + parameters.ExecuteScript + &quot;\&quot;&quot;);
+				psi.UseShellExecute = false;
+			} else {
+				string runtimeStarter = &quot;mono --debug &quot;;
+				
+				switch (parameters.NetRuntime) {
+					case NetRuntime.Mono:
+						runtimeStarter = &quot;mono --debug &quot;;
+						break;
+					case NetRuntime.MonoInterpreter:
+						runtimeStarter = &quot;mint &quot;;
+						break;
+				}
+				
+				string additionalCommands = &quot;&quot;;
+				if (parameters.PauseConsoleOutput)
+					additionalCommands = @&quot;echo; read -p 'press any key to continue...' -n1;&quot;;
+
+				psi = new ProcessStartInfo(&quot;xterm&quot;,
+					string.Format (
+					@&quot;-e &quot;&quot;{0} '{1}{2}' {3} ; {4}&quot;&quot;&quot;,
+					runtimeStarter, directory, exe, args, additionalCommands));
+				psi.UseShellExecute = false;
+			}
+			
+			try {
+				psi.WorkingDirectory = Path.GetDirectoryName(directory);
+				psi.UseShellExecute  =  false;
+				
+				Process p = new Process();
+				p.StartInfo = psi;
+				p.Start();
+			} catch (Exception) {
+				throw new ApplicationException(&quot;Can not execute &quot; + &quot;\&quot;&quot; + directory + exe + &quot;\&quot;\n(Try restarting MonoDevelop or start your app manually)&quot;);
+			}
+		}
+
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,103 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Windows.Forms;
+using System.Reflection;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.Core.Services;
+
+using ICSharpCode.Core.AddIns;
+using ICSharpCode.Core.AddIns.Codons;
+
+using ICSharpCode.SharpDevelop.Internal.Project;
+using ICSharpCode.SharpDevelop.Services;
+
+namespace VBBinding
+{
+	////&lt;summary&gt;
+	/// Provides functions to run VB.DOC and to read the configuration of VB.DOC.
+	/// &lt;/summary&gt;
+	public class VBDOCCommand : AbstractMenuCommand
+	{
+		///&lt;summary&gt;
+		/// Runs VB.DOC for the given project
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			IProjectService projectService = (IProjectService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			VBProject project = (VBProject)projectService.CurrentSelectedProject;
+			VBCompilerParameters compilerParameters = (VBCompilerParameters)project.ActiveConfiguration;
+			
+			Options options = new Options();
+			string extension = compilerParameters.CompileTarget == CompileTarget.Exe ? &quot;.dll&quot; : &quot;.exe&quot;;
+			options.AssemblyFile = Path.Combine(compilerParameters.OutputDirectory, compilerParameters.OutputAssembly) + extension;
+			
+			ArrayList files = new ArrayList();
+			foreach(ProjectFile file in project.ProjectFiles) {
+				if(VBDOCConfigurationPanel.IsFileIncluded(file.Name, project)) {
+					files.Add(file.Name);
+				}
+			}
+			
+			options.Files = (string[])files.ToArray(typeof(string));
+			options.GlobalImports = compilerParameters.Imports.Split(',');
+			options.OutputXML = compilerParameters.VBDOCOutputFile;
+			options.Prefix = compilerParameters.VBDOCCommentPrefix;
+			options.RootNamespace = compilerParameters.RootNamespace;
+			
+			ArrayList referenceDirs = new ArrayList();
+			string mainDirectory = Path.GetDirectoryName(options.AssemblyFile);
+			
+			foreach(ProjectReference projectFile in project.ProjectReferences) {
+				if(projectFile.ReferenceType == ReferenceType.Assembly) {
+					string referenceDir = Path.GetDirectoryName(projectFile.Reference);
+					if(referenceDir.ToLower() != mainDirectory.ToLower() &amp;&amp; referenceDirs.Contains(referenceDir) == false) {
+						referenceDirs.Add(referenceDir);
+					}
+				}
+			}
+			
+			StringCollection errors = options.Validate();
+		
+			if(errors.Count &gt; 0) {
+				string message = &quot;&quot;;
+				foreach(string description in errors) {
+					message += description + &quot;\n&quot;;
+				}
+				MessageBox.Show(message, &quot;Invalid VB.DOC options&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
+				return;
+			}
+			
+			VBDOCRunner runner = new VBDOCRunner();
+			AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(resolve);
+			GuiMessageRecipient messageRecipient = new GuiMessageRecipient();
+			
+			try {
+				runner.RunVBDOC(options, messageRecipient);
+			} catch(Exception ex) {
+				MessageBox.Show(&quot;Documentation generation failed:\n&quot; + ex.Message);
+			} finally {
+				messageRecipient.Finished();
+				AppDomain.CurrentDomain.AssemblyResolve -= new ResolveEventHandler(resolve);
+			}
+			
+		}
+		
+		Assembly resolve(object sender, ResolveEventArgs e)
+		{
+			if(e.Name.StartsWith(&quot;CommentExtractor&quot;)) {
+				return Assembly.GetAssembly(typeof(VBDOCRunner));
+			}
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBLanguageBinding.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBLanguageBinding.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBLanguageBinding.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,116 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Diagnostics;
+using System.Xml;
+
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Templates;
+//using CSharpBinding;
+
+namespace VBBinding
+{
+	public class VBLanguageBinding : ILanguageBinding
+	//public class VBLanguageBinding : CSharpLanguageBinding
+	{
+		public const string LanguageName = &quot;VBNet&quot;;
+		
+		VBBindingCompilerServices   compilerServices  = new VBBindingCompilerServices();
+		VBBindingExecutionServices  executionServices = new VBBindingExecutionServices();
+		
+		public string Language {
+			get {
+				return LanguageName;
+			}
+		}
+		
+		public void Execute(string filename, bool debug)
+		{
+			Debug.Assert(executionServices != null);
+			executionServices.Execute(filename);
+		}
+		
+		public void Execute(IProject project, bool debug)
+		{
+			Debug.Assert(executionServices != null);
+			if(debug){
+				executionServices.Debug(project);
+			}else{
+				executionServices.Execute(project);
+			}//if
+			
+		}
+		
+		public string GetCompiledOutputName(string fileName)
+		{
+			Debug.Assert(compilerServices != null);
+			return compilerServices.GetCompiledOutputName(fileName);
+		}
+		
+		public string GetCompiledOutputName(IProject project)
+		{
+			Debug.Assert(compilerServices != null);
+			return compilerServices.GetCompiledOutputName(project);
+		}
+		
+		public bool CanCompile(string fileName)
+		{
+			Debug.Assert(compilerServices != null);
+			return compilerServices.CanCompile(fileName);
+		}
+		
+		public ICompilerResult CompileFile(string fileName)
+		{
+			Debug.Assert(compilerServices != null);
+			return compilerServices.CompileFile(fileName);
+		}
+		
+		public ICompilerResult CompileProject(IProject project)
+		{
+			Debug.Assert(compilerServices != null);
+			return compilerServices.CompileProject(project);
+		}
+		
+		public ICompilerResult RecompileProject(IProject project)
+		{
+			return CompileProject(project);
+		}
+		
+		public IProject CreateProject(ProjectCreateInformation info, XmlElement projectOptions)
+		{
+			return new VBProject(info, projectOptions);
+		}
+		
+		public virtual void Execute(string filename)
+		{
+			Debug.Assert(executionServices != null);
+			executionServices.Execute(filename);
+		}
+		
+		public virtual void Execute(IProject project)
+		{
+			Debug.Assert(executionServices != null);
+			executionServices.Execute(project);
+		}
+
+		
+		public void DebugProject (IProject project)
+		{
+			executionServices.Debug (project);
+		}
+		
+		public void GenerateMakefile (IProject project, Combine parentCombine)
+		{
+			compilerServices.GenerateMakefile (project, parentCombine);
+		}
+
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.cmbx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.cmbx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.cmbx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,20 @@
+&lt;Combine fileversion=&quot;1.0&quot; name=&quot;VBNetBinding&quot; description=&quot;&quot;&gt;
+  &lt;StartMode startupentry=&quot;VBNetBinding&quot; single=&quot;True&quot;&gt;
+    &lt;Execute entry=&quot;VBNetBinding&quot; type=&quot;None&quot; /&gt;
+    &lt;Execute entry=&quot;SharpRefactoryVB&quot; type=&quot;None&quot; /&gt;
+  &lt;/StartMode&gt;
+  &lt;Entries&gt;
+    &lt;Entry filename=&quot;./VBNetBinding.prjx&quot; /&gt;
+    &lt;Entry filename=&quot;./SharpRefactoryVB/src/SharpRefactoryVB.prjx&quot; /&gt;
+  &lt;/Entries&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration name=&quot;Release&quot;&gt;
+      &lt;Entry name=&quot;VBNetBinding&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+      &lt;Entry name=&quot;SharpRefactoryVB&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration name=&quot;Debug&quot;&gt;
+      &lt;Entry name=&quot;VBNetBinding&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+      &lt;Entry name=&quot;SharpRefactoryVB&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Combine&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.mdsx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.mdsx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.mdsx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,3 @@
+&lt;MonoDevelopSolution fileversion=&quot;1.0&quot;&gt;
+  &lt;RelativeOutputPath&gt;./build/bin&lt;/RelativeOutputPath&gt;
+&lt;/MonoDevelopSolution&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.prjx
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.prjx	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.prjx	2004-11-10 18:03:32 UTC (rev 2023)
@@ -0,0 +1,62 @@
+&lt;Project name=&quot;VBNetBinding&quot; description=&quot;&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
+  &lt;Contents&gt;
+    &lt;File name=&quot;./AssemblyInfo.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./VBAmbience.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./VBBindingCompilerServices.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./VBBindingExecutionServices.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./VBLanguageBinding.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./VBNetBinding.addin.xml&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/CodeGenerationPanel.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/OutputOptionsPanel.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/ExpressionFinder.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/Parser.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/Resolver.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/TypeVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/VBNetVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/AttributeSection.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/Class.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/CompilationUnit.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/Constructor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/Event.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/Field.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/Indexer.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/Method.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/Parameter.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/Property.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Parser/SharpDevelopTree/ReturnType.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Project/VBCompilerParameters.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Project/VBProject.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./VB.glade&quot; subtype=&quot;Code&quot; buildaction=&quot;EmbedAsResource&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+  &lt;/Contents&gt;
+  &lt;References&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;Mono.GetOptions, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Project&quot; refto=&quot;SharpRefactoryVB&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../Core/build/bin/ICSharpCode.SharpAssembly.dll&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../Core/build/bin/ICSharpCode.SharpRefactory.dll&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../Core/build/bin/MonoDevelop.Base.dll&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../Core/build/bin/MonoDevelop.Core.dll&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../Core/build/bin/MonoDevelop.SourceEditor.dll&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;glade-sharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;gtk-sharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../Core/build/bin/MonoDevelop.Gui.Widgets.dll&quot; localcopy=&quot;True&quot; /&gt;
+  &lt;/References&gt;
+  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
+  &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;False&quot; /&gt;
+    &lt;Output directory=&quot;./bin/Debug&quot; assembly=&quot;VBNetBinding&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+  &lt;/Configuration&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;False&quot; /&gt;
+      &lt;Output directory=&quot;./bin/Debug&quot; assembly=&quot;VBNetBinding&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;False&quot; /&gt;
+      &lt;Output directory=&quot;./bin/Release&quot; assembly=&quot;VBNetBinding&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Project&gt;
\ No newline at end of file

Modified: trunk/MonoDevelop/Core/src/Main/Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/ChangeLog	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/Main/Base/ChangeLog	2004-11-10 18:03:32 UTC (rev 2023)
@@ -1,3 +1,10 @@
+2004-11-05  Levi Bard  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">taktaktaktaktaktaktaktaktaktak at gmail.com</A>&gt;
+
+	* src/Main/Base/Internal/Parser/IParser.cs: Added
+	HandlesFileExtension() for selection among multiple parsers
+	* src/Main/Base/Services/ParserService/DefaultParserService.cs: Added
+	parser selection using IParser.HandlesFileExtension()
+
 2004-11-02  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
 
 	* Services/File/RecentOpen.cs: use simpler RecentFiles AddWithLimit

Modified: trunk/MonoDevelop/Core/src/Main/Base/Internal/Parser/IParser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Internal/Parser/IParser.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/Main/Base/Internal/Parser/IParser.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -126,6 +126,7 @@
 		
 		ICompilationUnitBase Parse(string fileName);
 		ICompilationUnitBase Parse(string fileName, string fileContent);
+		bool HandlesFileExtension(string fileExtension);
 		
 		/// &lt;summary&gt;
 		/// Resolves an expression.

Modified: trunk/MonoDevelop/Core/src/Main/Base/Services/ParserService/DefaultParserService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/ParserService/DefaultParserService.cs	2004-11-10 02:31:03 UTC (rev 2022)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/ParserService/DefaultParserService.cs	2004-11-10 18:03:32 UTC (rev 2023)
@@ -1150,13 +1150,13 @@
 		public virtual IParser GetParser(string fileName)
 		{
 			// HACK: I'm too lazy to do it 'right'
+			// HACK: Still a hack, but extensible
 			if (fileName != null) {
-				if (Path.GetExtension(fileName).ToUpper() == &quot;.CS&quot;) {
-					return parser[0];
+				foreach(IParser p in parser){
+					if(p.HandlesFileExtension(Path.GetExtension(fileName))){
+						return p;
+					}
 				}
-				//if (Path.GetExtension(fileName).ToUpper() == &quot;.VB&quot;) {
-				//	return parser[1];
-				//}
 			}
 			return null;
 		}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001626.html">[Monodevelop-patches-list] r2022 - trunk/md-website/include
</A></li>
	<LI>Next message: <A HREF="001628.html">[Monodevelop-patches-list] r2024 - in trunk/MonoDevelop/Core: . src/Main/Base src/Main/Base/Internal/Project/Combine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1627">[ date ]</a>
              <a href="thread.html#1627">[ thread ]</a>
              <a href="subject.html#1627">[ subject ]</a>
              <a href="author.html#1627">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
