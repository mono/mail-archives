<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2597 - in	trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: .	src/Parser/generated
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2597%20-%20in%0A%09trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory%3A%20.%0A%09src/Parser/generated&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002196.html">
   <LINK REL="Next"  HREF="002198.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2597 - in	trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: .	src/Parser/generated</H1>
    <B>Jacob Ils&#248; Christensen &lt;jacobilsoe@gmail.com&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2597%20-%20in%0A%09trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory%3A%20.%0A%09src/Parser/generated&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2597 - in	trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: .	src/Parser/generated">jacobilsoe at mono-cvs.ximian.com
       </A><BR>
    <I>Mon Jun 13 10:54:44 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002196.html">[Monodevelop-patches-list] r2596 - in	trunk/MonoDevelop/Extras/JavaBinding: . Gui
</A></li>
        <LI>Next message: <A HREF="002198.html">[Monodevelop-patches-list] r2598 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: .	Gui/Dialogs/ReferenceDialog Services/Project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2197">[ date ]</a>
              <a href="thread.html#2197">[ thread ]</a>
              <a href="subject.html#2197">[ subject ]</a>
              <a href="author.html#2197">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jacobilsoe
Date: 2005-06-13 10:54:44 -0400 (Mon, 13 Jun 2005)
New Revision: 2597

Modified:
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/ChangeLog
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/Parser.cs
   trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG
Log:
Fixed location of get/set regions of properties

Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/ChangeLog	2005-06-11 12:25:16 UTC (rev 2596)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/ChangeLog	2005-06-13 14:54:44 UTC (rev 2597)
@@ -1,3 +1,9 @@
+2005-06-13  Jacob Ils&#248; Christensen  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jacobilsoe at gmail.com</A>&gt;
+
+	* src/Parser/generated/cs.ATG:
+	* src/Parser/generated/Parser.cs: Make sure that properties
+	have the location of their get/set regions set correctly.
+
 2005-04-17  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
 
 	* Makefile.am: fix distcheck

Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/Parser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/Parser.cs	2005-06-11 12:25:16 UTC (rev 2596)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/Parser.cs	2005-06-13 14:54:44 UTC (rev 2597)
@@ -772,43 +772,43 @@
 	}
 
 	void Expr(
-#line  1759 &quot;cs.ATG&quot; 
+#line  1767 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1760 &quot;cs.ATG&quot; 
+#line  1768 &quot;cs.ATG&quot; 
 		expr = null; Expression expr1 = null, expr2 = null; 
 		UnaryExpr(
-#line  1762 &quot;cs.ATG&quot; 
+#line  1770 &quot;cs.ATG&quot; 
 out expr);
 		if (StartOf(5)) {
 			ConditionalOrExpr(
-#line  1765 &quot;cs.ATG&quot; 
+#line  1773 &quot;cs.ATG&quot; 
 ref expr);
 			if (la.kind == 11) {
 				lexer.NextToken();
 				Expr(
-#line  1765 &quot;cs.ATG&quot; 
+#line  1773 &quot;cs.ATG&quot; 
 out expr1);
 				Expect(9);
 				Expr(
-#line  1765 &quot;cs.ATG&quot; 
+#line  1773 &quot;cs.ATG&quot; 
 out expr2);
 
-#line  1765 &quot;cs.ATG&quot; 
+#line  1773 &quot;cs.ATG&quot; 
 				expr = new ConditionalExpression(expr, expr1, expr2);  
 			}
 		} else if (StartOf(6)) {
 
-#line  1767 &quot;cs.ATG&quot; 
+#line  1775 &quot;cs.ATG&quot; 
 			AssignmentOperatorType op; Expression val; 
 			AssignmentOperator(
-#line  1767 &quot;cs.ATG&quot; 
+#line  1775 &quot;cs.ATG&quot; 
 out op);
 			Expr(
-#line  1767 &quot;cs.ATG&quot; 
+#line  1775 &quot;cs.ATG&quot; 
 out val);
 
-#line  1767 &quot;cs.ATG&quot; 
+#line  1775 &quot;cs.ATG&quot; 
 			expr = new AssignmentExpression(expr, op, val); 
 		} else SynErr(128);
 	}
@@ -2540,11 +2540,11 @@
 	}
 
 	void Block(
-#line  1404 &quot;cs.ATG&quot; 
+#line  1412 &quot;cs.ATG&quot; 
 out Statement stmt) {
 		Expect(14);
 
-#line  1406 &quot;cs.ATG&quot; 
+#line  1414 &quot;cs.ATG&quot; 
 		BlockStatement blockStmt = new BlockStatement();
 		blockStmt.StartLocation = t.Location;
 		compilationUnit.BlockStart(blockStmt);
@@ -2554,7 +2554,7 @@
 		}
 		Expect(15);
 
-#line  1411 &quot;cs.ATG&quot; 
+#line  1419 &quot;cs.ATG&quot; 
 		stmt = blockStmt;
 		blockStmt.EndLocation = t.EndLocation;
 		compilationUnit.BlockEnd();
@@ -2562,34 +2562,34 @@
 	}
 
 	void VariableDeclarator(
-#line  1397 &quot;cs.ATG&quot; 
+#line  1405 &quot;cs.ATG&quot; 
 ArrayList fieldDeclaration) {
 
-#line  1398 &quot;cs.ATG&quot; 
+#line  1406 &quot;cs.ATG&quot; 
 		Expression expr = null; 
 		Expect(1);
 
-#line  1400 &quot;cs.ATG&quot; 
+#line  1408 &quot;cs.ATG&quot; 
 		VariableDeclaration f = new VariableDeclaration(t.val); 
 		if (la.kind == 3) {
 			lexer.NextToken();
 			VariableInitializer(
-#line  1401 &quot;cs.ATG&quot; 
+#line  1409 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1401 &quot;cs.ATG&quot; 
+#line  1409 &quot;cs.ATG&quot; 
 			f.Initializer = expr; 
 		}
 
-#line  1401 &quot;cs.ATG&quot; 
+#line  1409 &quot;cs.ATG&quot; 
 		fieldDeclaration.Add(f); 
 	}
 
 	void EventAccessorDecls(
-#line  1346 &quot;cs.ATG&quot; 
+#line  1354 &quot;cs.ATG&quot; 
 out EventAddRegion addBlock, out EventRemoveRegion removeBlock) {
 
-#line  1347 &quot;cs.ATG&quot; 
+#line  1355 &quot;cs.ATG&quot; 
 		AttributeSection section;
 		ArrayList attributes = new ArrayList();
 		Statement stmt;
@@ -2598,102 +2598,102 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1354 &quot;cs.ATG&quot; 
+#line  1362 &quot;cs.ATG&quot; 
 out section);
 
-#line  1354 &quot;cs.ATG&quot; 
+#line  1362 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (
-#line  1356 &quot;cs.ATG&quot; 
+#line  1364 &quot;cs.ATG&quot; 
 IdentIsAdd()) {
 
-#line  1356 &quot;cs.ATG&quot; 
+#line  1364 &quot;cs.ATG&quot; 
 			addBlock = new EventAddRegion(attributes); 
 			AddAccessorDecl(
-#line  1357 &quot;cs.ATG&quot; 
+#line  1365 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1357 &quot;cs.ATG&quot; 
+#line  1365 &quot;cs.ATG&quot; 
 			attributes = new ArrayList(); addBlock.Block = (BlockStatement)stmt; 
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1358 &quot;cs.ATG&quot; 
+#line  1366 &quot;cs.ATG&quot; 
 out section);
 
-#line  1358 &quot;cs.ATG&quot; 
+#line  1366 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			RemoveAccessorDecl(
-#line  1359 &quot;cs.ATG&quot; 
+#line  1367 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1359 &quot;cs.ATG&quot; 
+#line  1367 &quot;cs.ATG&quot; 
 			removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; 
 		} else if (
-#line  1360 &quot;cs.ATG&quot; 
+#line  1368 &quot;cs.ATG&quot; 
 IdentIsRemove()) {
 			RemoveAccessorDecl(
-#line  1361 &quot;cs.ATG&quot; 
+#line  1369 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1361 &quot;cs.ATG&quot; 
+#line  1369 &quot;cs.ATG&quot; 
 			removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new ArrayList(); 
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1362 &quot;cs.ATG&quot; 
+#line  1370 &quot;cs.ATG&quot; 
 out section);
 
-#line  1362 &quot;cs.ATG&quot; 
+#line  1370 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			AddAccessorDecl(
-#line  1363 &quot;cs.ATG&quot; 
+#line  1371 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1363 &quot;cs.ATG&quot; 
+#line  1371 &quot;cs.ATG&quot; 
 			addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; 
 		} else if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1364 &quot;cs.ATG&quot; 
+#line  1372 &quot;cs.ATG&quot; 
 			Error(&quot;add or remove accessor declaration expected&quot;); 
 		} else SynErr(157);
 	}
 
 	void ConstructorInitializer(
-#line  1433 &quot;cs.ATG&quot; 
+#line  1441 &quot;cs.ATG&quot; 
 out ConstructorInitializer ci) {
 
-#line  1434 &quot;cs.ATG&quot; 
+#line  1442 &quot;cs.ATG&quot; 
 		Expression expr; ci = new ConstructorInitializer(); 
 		Expect(9);
 		if (la.kind == 50) {
 			lexer.NextToken();
 
-#line  1438 &quot;cs.ATG&quot; 
+#line  1446 &quot;cs.ATG&quot; 
 			ci.ConstructorInitializerType = ConstructorInitializerType.Base; 
 		} else if (la.kind == 110) {
 			lexer.NextToken();
 
-#line  1439 &quot;cs.ATG&quot; 
+#line  1447 &quot;cs.ATG&quot; 
 			ci.ConstructorInitializerType = ConstructorInitializerType.This; 
 		} else SynErr(158);
 		Expect(18);
 		if (StartOf(21)) {
 			Argument(
-#line  1442 &quot;cs.ATG&quot; 
+#line  1450 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1442 &quot;cs.ATG&quot; 
+#line  1450 &quot;cs.ATG&quot; 
 			ci.Arguments.Add(expr); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Argument(
-#line  1442 &quot;cs.ATG&quot; 
+#line  1450 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1442 &quot;cs.ATG&quot; 
+#line  1450 &quot;cs.ATG&quot; 
 				ci.Arguments.Add(expr); 
 			}
 		}
@@ -2701,7 +2701,7 @@
 	}
 
 	void OverloadableOperator(
-#line  1454 &quot;cs.ATG&quot; 
+#line  1462 &quot;cs.ATG&quot; 
 out Token op) {
 		switch (la.kind) {
 		case 4: {
@@ -2795,7 +2795,7 @@
 		default: SynErr(159); break;
 		}
 
-#line  1463 &quot;cs.ATG&quot; 
+#line  1471 &quot;cs.ATG&quot; 
 		op = t; 
 	}
 
@@ -2886,77 +2886,77 @@
 	}
 
 	void InterfaceAccessors(
-#line  1368 &quot;cs.ATG&quot; 
+#line  1376 &quot;cs.ATG&quot; 
 out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
 
-#line  1370 &quot;cs.ATG&quot; 
+#line  1378 &quot;cs.ATG&quot; 
 		AttributeSection section;
 		ArrayList attributes = new ArrayList();
 		getBlock = null; setBlock = null;
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1375 &quot;cs.ATG&quot; 
+#line  1383 &quot;cs.ATG&quot; 
 out section);
 
-#line  1375 &quot;cs.ATG&quot; 
+#line  1383 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (
-#line  1377 &quot;cs.ATG&quot; 
+#line  1385 &quot;cs.ATG&quot; 
 IdentIsGet()) {
 			Expect(1);
 
-#line  1377 &quot;cs.ATG&quot; 
+#line  1385 &quot;cs.ATG&quot; 
 			getBlock = new PropertyGetRegion(null, attributes); 
 		} else if (
-#line  1378 &quot;cs.ATG&quot; 
+#line  1386 &quot;cs.ATG&quot; 
 IdentIsSet()) {
 			Expect(1);
 
-#line  1378 &quot;cs.ATG&quot; 
+#line  1386 &quot;cs.ATG&quot; 
 			setBlock = new PropertySetRegion(null, attributes); 
 		} else if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1379 &quot;cs.ATG&quot; 
+#line  1387 &quot;cs.ATG&quot; 
 			Error(&quot;set or get expected&quot;); 
 		} else SynErr(161);
 		Expect(10);
 
-#line  1381 &quot;cs.ATG&quot; 
+#line  1389 &quot;cs.ATG&quot; 
 		attributes = new ArrayList(); 
 		if (la.kind == 1 || la.kind == 16) {
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1383 &quot;cs.ATG&quot; 
+#line  1391 &quot;cs.ATG&quot; 
 out section);
 
-#line  1383 &quot;cs.ATG&quot; 
+#line  1391 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			if (
-#line  1385 &quot;cs.ATG&quot; 
+#line  1393 &quot;cs.ATG&quot; 
 IdentIsGet()) {
 				Expect(1);
 
-#line  1385 &quot;cs.ATG&quot; 
+#line  1393 &quot;cs.ATG&quot; 
 				if (getBlock != null) Error(&quot;get already declared&quot;);
 				else getBlock = new PropertyGetRegion(null, attributes);
 				
 			} else if (
-#line  1388 &quot;cs.ATG&quot; 
+#line  1396 &quot;cs.ATG&quot; 
 IdentIsSet()) {
 				Expect(1);
 
-#line  1388 &quot;cs.ATG&quot; 
+#line  1396 &quot;cs.ATG&quot; 
 				if (setBlock != null) Error(&quot;set already declared&quot;);
 				else setBlock = new PropertySetRegion(null, attributes);
 				
 			} else if (la.kind == 1) {
 				lexer.NextToken();
 
-#line  1391 &quot;cs.ATG&quot; 
+#line  1399 &quot;cs.ATG&quot; 
 				Error(&quot;set or get expected&quot;); 
 			} else SynErr(162);
 			Expect(10);
@@ -2972,179 +2972,197 @@
 		Expect(1);
 
 #line  1334 &quot;cs.ATG&quot; 
+		Point startLocation = t.Location; 
+
+#line  1335 &quot;cs.ATG&quot; 
 		if (t.val != &quot;get&quot;) Error(&quot;get expected&quot;); 
 		if (la.kind == 14) {
 			Block(
-#line  1335 &quot;cs.ATG&quot; 
+#line  1336 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 		} else SynErr(163);
 
-#line  1335 &quot;cs.ATG&quot; 
+#line  1337 &quot;cs.ATG&quot; 
 		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes, m); 
+
+#line  1338 &quot;cs.ATG&quot; 
+		getBlock.StartLocation = startLocation; 
+
+#line  1339 &quot;cs.ATG&quot; 
+		getBlock.EndLocation = t.Location; 
 	}
 
 	void SetAccessorDecl(
-#line  1338 &quot;cs.ATG&quot; 
+#line  1342 &quot;cs.ATG&quot; 
 out PropertySetRegion setBlock, ArrayList attributes, Modifier m) {
 
-#line  1339 &quot;cs.ATG&quot; 
+#line  1343 &quot;cs.ATG&quot; 
 		Statement stmt = null; 
 		Expect(1);
 
-#line  1342 &quot;cs.ATG&quot; 
+#line  1346 &quot;cs.ATG&quot; 
+		Point startLocation = t.Location; 
+
+#line  1347 &quot;cs.ATG&quot; 
 		if (t.val != &quot;set&quot;) Error(&quot;set expected&quot;); 
 		if (la.kind == 14) {
 			Block(
-#line  1343 &quot;cs.ATG&quot; 
+#line  1348 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 		} else SynErr(164);
 
-#line  1343 &quot;cs.ATG&quot; 
+#line  1349 &quot;cs.ATG&quot; 
 		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes, m); 
+
+#line  1350 &quot;cs.ATG&quot; 
+		setBlock.StartLocation = startLocation; 
+
+#line  1351 &quot;cs.ATG&quot; 
+		setBlock.EndLocation = t.Location; 
 	}
 
 	void AddAccessorDecl(
-#line  1417 &quot;cs.ATG&quot; 
+#line  1425 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1418 &quot;cs.ATG&quot; 
+#line  1426 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expect(1);
 
-#line  1421 &quot;cs.ATG&quot; 
+#line  1429 &quot;cs.ATG&quot; 
 		if (t.val != &quot;add&quot;) Error(&quot;add expected&quot;); 
 		Block(
-#line  1422 &quot;cs.ATG&quot; 
+#line  1430 &quot;cs.ATG&quot; 
 out stmt);
 	}
 
 	void RemoveAccessorDecl(
-#line  1425 &quot;cs.ATG&quot; 
+#line  1433 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1426 &quot;cs.ATG&quot; 
+#line  1434 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expect(1);
 
-#line  1429 &quot;cs.ATG&quot; 
+#line  1437 &quot;cs.ATG&quot; 
 		if (t.val != &quot;remove&quot;) Error(&quot;remove expected&quot;); 
 		Block(
-#line  1430 &quot;cs.ATG&quot; 
+#line  1438 &quot;cs.ATG&quot; 
 out stmt);
 	}
 
 	void VariableInitializer(
-#line  1446 &quot;cs.ATG&quot; 
+#line  1454 &quot;cs.ATG&quot; 
 out Expression initializerExpression) {
 
-#line  1447 &quot;cs.ATG&quot; 
+#line  1455 &quot;cs.ATG&quot; 
 		TypeReference type = null; Expression expr = null; initializerExpression = null; 
 		if (StartOf(4)) {
 			Expr(
-#line  1449 &quot;cs.ATG&quot; 
+#line  1457 &quot;cs.ATG&quot; 
 out initializerExpression);
 		} else if (la.kind == 14) {
 			ArrayInitializer(
-#line  1450 &quot;cs.ATG&quot; 
+#line  1458 &quot;cs.ATG&quot; 
 out initializerExpression);
 		} else if (la.kind == 105) {
 			lexer.NextToken();
 			Type(
-#line  1451 &quot;cs.ATG&quot; 
+#line  1459 &quot;cs.ATG&quot; 
 out type);
 			Expect(16);
 			Expr(
-#line  1451 &quot;cs.ATG&quot; 
+#line  1459 &quot;cs.ATG&quot; 
 out expr);
 			Expect(17);
 
-#line  1451 &quot;cs.ATG&quot; 
+#line  1459 &quot;cs.ATG&quot; 
 			initializerExpression = new StackAllocExpression(type, expr); 
 		} else SynErr(165);
 	}
 
 	void Statement() {
 
-#line  1534 &quot;cs.ATG&quot; 
+#line  1542 &quot;cs.ATG&quot; 
 		TypeReference type;
 		Expression expr;
 		Statement stmt;
 		
 		if (
-#line  1540 &quot;cs.ATG&quot; 
+#line  1548 &quot;cs.ATG&quot; 
 IsLabel()) {
 			Expect(1);
 
-#line  1540 &quot;cs.ATG&quot; 
+#line  1548 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(new LabelStatement(t.val)); 
 			Expect(9);
 			Statement();
 		} else if (la.kind == 59) {
 			lexer.NextToken();
 			Type(
-#line  1543 &quot;cs.ATG&quot; 
+#line  1551 &quot;cs.ATG&quot; 
 out type);
 
-#line  1543 &quot;cs.ATG&quot; 
+#line  1551 &quot;cs.ATG&quot; 
 			LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifier.Const); string ident = null; var.StartLocation = t.Location; 
 			Expect(1);
 
-#line  1544 &quot;cs.ATG&quot; 
+#line  1552 &quot;cs.ATG&quot; 
 			ident = t.val; 
 			Expect(3);
 			Expr(
-#line  1545 &quot;cs.ATG&quot; 
+#line  1553 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1545 &quot;cs.ATG&quot; 
+#line  1553 &quot;cs.ATG&quot; 
 			var.Variables.Add(new VariableDeclaration(ident, expr)); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1546 &quot;cs.ATG&quot; 
+#line  1554 &quot;cs.ATG&quot; 
 				ident = t.val; 
 				Expect(3);
 				Expr(
-#line  1546 &quot;cs.ATG&quot; 
+#line  1554 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1546 &quot;cs.ATG&quot; 
+#line  1554 &quot;cs.ATG&quot; 
 				var.Variables.Add(new VariableDeclaration(ident, expr)); 
 			}
 			Expect(10);
 
-#line  1547 &quot;cs.ATG&quot; 
+#line  1555 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(var); 
 		} else if (
-#line  1549 &quot;cs.ATG&quot; 
+#line  1557 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1549 &quot;cs.ATG&quot; 
+#line  1557 &quot;cs.ATG&quot; 
 out stmt);
 			Expect(10);
 
-#line  1549 &quot;cs.ATG&quot; 
+#line  1557 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(stmt); 
 		} else if (StartOf(24)) {
 			EmbeddedStatement(
-#line  1550 &quot;cs.ATG&quot; 
+#line  1558 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1550 &quot;cs.ATG&quot; 
+#line  1558 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(stmt); 
 		} else SynErr(166);
 	}
 
 	void Argument(
-#line  1466 &quot;cs.ATG&quot; 
+#line  1474 &quot;cs.ATG&quot; 
 out Expression argumentexpr) {
 
-#line  1468 &quot;cs.ATG&quot; 
+#line  1476 &quot;cs.ATG&quot; 
 		Expression expr;
 		FieldDirection fd = FieldDirection.None;
 		
@@ -3152,48 +3170,48 @@
 			if (la.kind == 99) {
 				lexer.NextToken();
 
-#line  1473 &quot;cs.ATG&quot; 
+#line  1481 &quot;cs.ATG&quot; 
 				fd = FieldDirection.Ref; 
 			} else {
 				lexer.NextToken();
 
-#line  1474 &quot;cs.ATG&quot; 
+#line  1482 &quot;cs.ATG&quot; 
 				fd = FieldDirection.Out; 
 			}
 		}
 		Expr(
-#line  1476 &quot;cs.ATG&quot; 
+#line  1484 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1476 &quot;cs.ATG&quot; 
+#line  1484 &quot;cs.ATG&quot; 
 		argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; 
 	}
 
 	void ArrayInitializer(
-#line  1495 &quot;cs.ATG&quot; 
+#line  1503 &quot;cs.ATG&quot; 
 out Expression outExpr) {
 
-#line  1497 &quot;cs.ATG&quot; 
+#line  1505 &quot;cs.ATG&quot; 
 		Expression expr = null;
 		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
 		
 		Expect(14);
 		if (StartOf(25)) {
 			VariableInitializer(
-#line  1502 &quot;cs.ATG&quot; 
+#line  1510 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1502 &quot;cs.ATG&quot; 
+#line  1510 &quot;cs.ATG&quot; 
 			initializer.CreateExpressions.Add(expr); 
 			while (
-#line  1502 &quot;cs.ATG&quot; 
+#line  1510 &quot;cs.ATG&quot; 
 NotFinalComma()) {
 				Expect(12);
 				VariableInitializer(
-#line  1502 &quot;cs.ATG&quot; 
+#line  1510 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1502 &quot;cs.ATG&quot; 
+#line  1510 &quot;cs.ATG&quot; 
 				initializer.CreateExpressions.Add(expr); 
 			}
 			if (la.kind == 12) {
@@ -3202,91 +3220,91 @@
 		}
 		Expect(15);
 
-#line  1503 &quot;cs.ATG&quot; 
+#line  1511 &quot;cs.ATG&quot; 
 		outExpr = initializer; 
 	}
 
 	void AssignmentOperator(
-#line  1479 &quot;cs.ATG&quot; 
+#line  1487 &quot;cs.ATG&quot; 
 out AssignmentOperatorType op) {
 
-#line  1480 &quot;cs.ATG&quot; 
+#line  1488 &quot;cs.ATG&quot; 
 		op = AssignmentOperatorType.None; 
 		switch (la.kind) {
 		case 3: {
 			lexer.NextToken();
 
-#line  1482 &quot;cs.ATG&quot; 
+#line  1490 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Assign; 
 			break;
 		}
 		case 37: {
 			lexer.NextToken();
 
-#line  1483 &quot;cs.ATG&quot; 
+#line  1491 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Add; 
 			break;
 		}
 		case 38: {
 			lexer.NextToken();
 
-#line  1484 &quot;cs.ATG&quot; 
+#line  1492 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Subtract; 
 			break;
 		}
 		case 39: {
 			lexer.NextToken();
 
-#line  1485 &quot;cs.ATG&quot; 
+#line  1493 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Multiply; 
 			break;
 		}
 		case 40: {
 			lexer.NextToken();
 
-#line  1486 &quot;cs.ATG&quot; 
+#line  1494 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Divide; 
 			break;
 		}
 		case 41: {
 			lexer.NextToken();
 
-#line  1487 &quot;cs.ATG&quot; 
+#line  1495 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Modulus; 
 			break;
 		}
 		case 42: {
 			lexer.NextToken();
 
-#line  1488 &quot;cs.ATG&quot; 
+#line  1496 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.BitwiseAnd; 
 			break;
 		}
 		case 43: {
 			lexer.NextToken();
 
-#line  1489 &quot;cs.ATG&quot; 
+#line  1497 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.BitwiseOr; 
 			break;
 		}
 		case 44: {
 			lexer.NextToken();
 
-#line  1490 &quot;cs.ATG&quot; 
+#line  1498 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ExclusiveOr; 
 			break;
 		}
 		case 45: {
 			lexer.NextToken();
 
-#line  1491 &quot;cs.ATG&quot; 
+#line  1499 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ShiftLeft; 
 			break;
 		}
 		case 46: {
 			lexer.NextToken();
 
-#line  1492 &quot;cs.ATG&quot; 
+#line  1500 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ShiftRight; 
 			break;
 		}
@@ -3295,83 +3313,83 @@
 	}
 
 	void LocalVariableDecl(
-#line  1506 &quot;cs.ATG&quot; 
+#line  1514 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1508 &quot;cs.ATG&quot; 
+#line  1516 &quot;cs.ATG&quot; 
 		TypeReference type;
 		VariableDeclaration      var = null;
 		LocalVariableDeclaration localVariableDeclaration; 
 		
 		Type(
-#line  1513 &quot;cs.ATG&quot; 
+#line  1521 &quot;cs.ATG&quot; 
 out type);
 
-#line  1513 &quot;cs.ATG&quot; 
+#line  1521 &quot;cs.ATG&quot; 
 		localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; 
 		LocalVariableDeclarator(
-#line  1514 &quot;cs.ATG&quot; 
+#line  1522 &quot;cs.ATG&quot; 
 out var);
 
-#line  1514 &quot;cs.ATG&quot; 
+#line  1522 &quot;cs.ATG&quot; 
 		localVariableDeclaration.Variables.Add(var); 
 		while (la.kind == 12) {
 			lexer.NextToken();
 			LocalVariableDeclarator(
-#line  1515 &quot;cs.ATG&quot; 
+#line  1523 &quot;cs.ATG&quot; 
 out var);
 
-#line  1515 &quot;cs.ATG&quot; 
+#line  1523 &quot;cs.ATG&quot; 
 			localVariableDeclaration.Variables.Add(var); 
 		}
 
-#line  1516 &quot;cs.ATG&quot; 
+#line  1524 &quot;cs.ATG&quot; 
 		stmt = localVariableDeclaration; 
 	}
 
 	void LocalVariableDeclarator(
-#line  1519 &quot;cs.ATG&quot; 
+#line  1527 &quot;cs.ATG&quot; 
 out VariableDeclaration var) {
 
-#line  1520 &quot;cs.ATG&quot; 
+#line  1528 &quot;cs.ATG&quot; 
 		Expression expr = null; 
 		Expect(1);
 
-#line  1522 &quot;cs.ATG&quot; 
+#line  1530 &quot;cs.ATG&quot; 
 		var = new VariableDeclaration(t.val); 
 		if (la.kind == 3) {
 			lexer.NextToken();
 			LocalVariableInitializer(
-#line  1522 &quot;cs.ATG&quot; 
+#line  1530 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1522 &quot;cs.ATG&quot; 
+#line  1530 &quot;cs.ATG&quot; 
 			var.Initializer = expr; 
 		}
 	}
 
 	void LocalVariableInitializer(
-#line  1525 &quot;cs.ATG&quot; 
+#line  1533 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1526 &quot;cs.ATG&quot; 
+#line  1534 &quot;cs.ATG&quot; 
 		expr = null; 
 		if (StartOf(4)) {
 			Expr(
-#line  1528 &quot;cs.ATG&quot; 
+#line  1536 &quot;cs.ATG&quot; 
 out expr);
 		} else if (la.kind == 14) {
 			ArrayInitializer(
-#line  1529 &quot;cs.ATG&quot; 
+#line  1537 &quot;cs.ATG&quot; 
 out expr);
 		} else SynErr(168);
 	}
 
 	void EmbeddedStatement(
-#line  1556 &quot;cs.ATG&quot; 
+#line  1564 &quot;cs.ATG&quot; 
 out Statement statement) {
 
-#line  1558 &quot;cs.ATG&quot; 
+#line  1566 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		Expression expr = null;
 		Statement embeddedStatement = null;
@@ -3379,177 +3397,177 @@
 		
 		if (la.kind == 14) {
 			Block(
-#line  1564 &quot;cs.ATG&quot; 
+#line  1572 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 
-#line  1566 &quot;cs.ATG&quot; 
+#line  1574 &quot;cs.ATG&quot; 
 			statement = new EmptyStatement(); 
 		} else if (
-#line  1568 &quot;cs.ATG&quot; 
+#line  1576 &quot;cs.ATG&quot; 
 IdentIsYield ()) {
 			Expect(1);
 			if (la.kind == 100) {
 				lexer.NextToken();
 				Expr(
-#line  1569 &quot;cs.ATG&quot; 
+#line  1577 &quot;cs.ATG&quot; 
 out expr);
 			} else if (la.kind == 52) {
 				lexer.NextToken();
 			} else SynErr(169);
 			Expect(10);
 
-#line  1569 &quot;cs.ATG&quot; 
+#line  1577 &quot;cs.ATG&quot; 
 			statement = new YieldStatement(expr); 
 		} else if (
-#line  1571 &quot;cs.ATG&quot; 
+#line  1579 &quot;cs.ATG&quot; 
 UnCheckedAndLBrace()) {
 
-#line  1571 &quot;cs.ATG&quot; 
+#line  1579 &quot;cs.ATG&quot; 
 			Statement block; bool isChecked = true; 
 			if (la.kind == 57) {
 				lexer.NextToken();
 			} else if (la.kind == 117) {
 				lexer.NextToken();
 
-#line  1572 &quot;cs.ATG&quot; 
+#line  1580 &quot;cs.ATG&quot; 
 				isChecked = false;
 			} else SynErr(170);
 			Block(
-#line  1573 &quot;cs.ATG&quot; 
+#line  1581 &quot;cs.ATG&quot; 
 out block);
 
-#line  1573 &quot;cs.ATG&quot; 
+#line  1581 &quot;cs.ATG&quot; 
 			statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); 
 		} else if (StartOf(4)) {
 			StatementExpr(
-#line  1575 &quot;cs.ATG&quot; 
+#line  1583 &quot;cs.ATG&quot; 
 out statement);
 			Expect(10);
 		} else if (la.kind == 78) {
 			lexer.NextToken();
 
-#line  1577 &quot;cs.ATG&quot; 
+#line  1585 &quot;cs.ATG&quot; 
 			Statement elseStatement = null; 
 			Expect(18);
 			Expr(
-#line  1578 &quot;cs.ATG&quot; 
+#line  1586 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1579 &quot;cs.ATG&quot; 
+#line  1587 &quot;cs.ATG&quot; 
 out embeddedStatement);
 			if (la.kind == 66) {
 				lexer.NextToken();
 				EmbeddedStatement(
-#line  1580 &quot;cs.ATG&quot; 
+#line  1588 &quot;cs.ATG&quot; 
 out elseStatement);
 			}
 
-#line  1581 &quot;cs.ATG&quot; 
+#line  1589 &quot;cs.ATG&quot; 
 			statement = elseStatement != null ? (Statement)new IfElseStatement(expr, embeddedStatement, elseStatement) :  (Statement)new IfStatement(expr, embeddedStatement); 
 		} else if (la.kind == 109) {
 			lexer.NextToken();
 
-#line  1582 &quot;cs.ATG&quot; 
+#line  1590 &quot;cs.ATG&quot; 
 			ArrayList switchSections = new ArrayList(); 
 			Expect(18);
 			Expr(
-#line  1583 &quot;cs.ATG&quot; 
+#line  1591 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			Expect(14);
 			while (la.kind == 54 || la.kind == 62) {
 				SwitchSection(
-#line  1584 &quot;cs.ATG&quot; 
+#line  1592 &quot;cs.ATG&quot; 
 out statement);
 
-#line  1584 &quot;cs.ATG&quot; 
+#line  1592 &quot;cs.ATG&quot; 
 				switchSections.Add(statement); 
 			}
 			Expect(15);
 
-#line  1585 &quot;cs.ATG&quot; 
+#line  1593 &quot;cs.ATG&quot; 
 			statement = new SwitchStatement(expr, switchSections); 
 		} else if (la.kind == 124) {
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1587 &quot;cs.ATG&quot; 
+#line  1595 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1588 &quot;cs.ATG&quot; 
+#line  1596 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1588 &quot;cs.ATG&quot; 
+#line  1596 &quot;cs.ATG&quot; 
 			statement = new WhileStatement(expr, embeddedStatement); 
 		} else if (la.kind == 64) {
 			lexer.NextToken();
 			EmbeddedStatement(
-#line  1589 &quot;cs.ATG&quot; 
+#line  1597 &quot;cs.ATG&quot; 
 out embeddedStatement);
 			Expect(124);
 			Expect(18);
 			Expr(
-#line  1590 &quot;cs.ATG&quot; 
+#line  1598 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			Expect(10);
 
-#line  1590 &quot;cs.ATG&quot; 
+#line  1598 &quot;cs.ATG&quot; 
 			statement = new DoWhileStatement(expr, embeddedStatement); 
 		} else if (la.kind == 75) {
 			lexer.NextToken();
 
-#line  1591 &quot;cs.ATG&quot; 
+#line  1599 &quot;cs.ATG&quot; 
 			ArrayList initializer = null, iterator = null; 
 			Expect(18);
 			if (StartOf(4)) {
 				ForInitializer(
-#line  1592 &quot;cs.ATG&quot; 
+#line  1600 &quot;cs.ATG&quot; 
 out initializer);
 			}
 			Expect(10);
 			if (StartOf(4)) {
 				Expr(
-#line  1593 &quot;cs.ATG&quot; 
+#line  1601 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 			if (StartOf(4)) {
 				ForIterator(
-#line  1594 &quot;cs.ATG&quot; 
+#line  1602 &quot;cs.ATG&quot; 
 out iterator);
 			}
 			Expect(19);
 			EmbeddedStatement(
-#line  1595 &quot;cs.ATG&quot; 
+#line  1603 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1595 &quot;cs.ATG&quot; 
+#line  1603 &quot;cs.ATG&quot; 
 			statement = new ForStatement(initializer, expr, iterator, embeddedStatement); 
 		} else if (la.kind == 76) {
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1596 &quot;cs.ATG&quot; 
+#line  1604 &quot;cs.ATG&quot; 
 out type);
 			Expect(1);
 
-#line  1596 &quot;cs.ATG&quot; 
+#line  1604 &quot;cs.ATG&quot; 
 			string varName = t.val; 
 			Expect(80);
 			Expr(
-#line  1597 &quot;cs.ATG&quot; 
+#line  1605 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1598 &quot;cs.ATG&quot; 
+#line  1606 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1598 &quot;cs.ATG&quot; 
+#line  1606 &quot;cs.ATG&quot; 
 			statement = new ForeachStatement(type, varName , expr, embeddedStatement); 
 			statement.EndLocation = t.EndLocation;
 			
@@ -3557,363 +3575,363 @@
 			lexer.NextToken();
 			Expect(10);
 
-#line  1602 &quot;cs.ATG&quot; 
+#line  1610 &quot;cs.ATG&quot; 
 			statement = new BreakStatement(); 
 		} else if (la.kind == 60) {
 			lexer.NextToken();
 			Expect(10);
 
-#line  1603 &quot;cs.ATG&quot; 
+#line  1611 &quot;cs.ATG&quot; 
 			statement = new ContinueStatement(); 
 		} else if (la.kind == 77) {
 			GotoStatement(
-#line  1604 &quot;cs.ATG&quot; 
+#line  1612 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 100) {
 			lexer.NextToken();
 			if (StartOf(4)) {
 				Expr(
-#line  1605 &quot;cs.ATG&quot; 
+#line  1613 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 
-#line  1605 &quot;cs.ATG&quot; 
+#line  1613 &quot;cs.ATG&quot; 
 			statement = new ReturnStatement(expr); 
 		} else if (la.kind == 111) {
 			lexer.NextToken();
 			if (StartOf(4)) {
 				Expr(
-#line  1606 &quot;cs.ATG&quot; 
+#line  1614 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 
-#line  1606 &quot;cs.ATG&quot; 
+#line  1614 &quot;cs.ATG&quot; 
 			statement = new ThrowStatement(expr); 
 		} else if (la.kind == 113) {
 			TryStatement(
-#line  1609 &quot;cs.ATG&quot; 
+#line  1617 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 85) {
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1611 &quot;cs.ATG&quot; 
+#line  1619 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1612 &quot;cs.ATG&quot; 
+#line  1620 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1612 &quot;cs.ATG&quot; 
+#line  1620 &quot;cs.ATG&quot; 
 			statement = new LockStatement(expr, embeddedStatement); 
 		} else if (la.kind == 120) {
 
-#line  1614 &quot;cs.ATG&quot; 
+#line  1622 &quot;cs.ATG&quot; 
 			Statement resourceAcquisitionStmt = null; 
 			lexer.NextToken();
 			Expect(18);
 			ResourceAcquisition(
-#line  1616 &quot;cs.ATG&quot; 
+#line  1624 &quot;cs.ATG&quot; 
 out resourceAcquisitionStmt);
 			Expect(19);
 			EmbeddedStatement(
-#line  1617 &quot;cs.ATG&quot; 
+#line  1625 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1617 &quot;cs.ATG&quot; 
+#line  1625 &quot;cs.ATG&quot; 
 			statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); 
 		} else if (la.kind == 118) {
 			lexer.NextToken();
 			Block(
-#line  1619 &quot;cs.ATG&quot; 
+#line  1627 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1619 &quot;cs.ATG&quot; 
+#line  1627 &quot;cs.ATG&quot; 
 			statement = new UnsafeStatement(embeddedStatement); 
 		} else if (la.kind == 73) {
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1622 &quot;cs.ATG&quot; 
+#line  1630 &quot;cs.ATG&quot; 
 out type);
 
-#line  1622 &quot;cs.ATG&quot; 
+#line  1630 &quot;cs.ATG&quot; 
 			if (type.PointerNestingLevel == 0) Error(&quot;can only fix pointer types&quot;);
 			FixedStatement fxStmt = new FixedStatement(type);
 			string identifier = null;
 			
 			Expect(1);
 
-#line  1626 &quot;cs.ATG&quot; 
+#line  1634 &quot;cs.ATG&quot; 
 			identifier = t.val; 
 			Expect(3);
 			Expr(
-#line  1627 &quot;cs.ATG&quot; 
+#line  1635 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1627 &quot;cs.ATG&quot; 
+#line  1635 &quot;cs.ATG&quot; 
 			fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1629 &quot;cs.ATG&quot; 
+#line  1637 &quot;cs.ATG&quot; 
 				identifier = t.val; 
 				Expect(3);
 				Expr(
-#line  1630 &quot;cs.ATG&quot; 
+#line  1638 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1630 &quot;cs.ATG&quot; 
+#line  1638 &quot;cs.ATG&quot; 
 				fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); 
 			}
 			Expect(19);
 			EmbeddedStatement(
-#line  1632 &quot;cs.ATG&quot; 
+#line  1640 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1632 &quot;cs.ATG&quot; 
+#line  1640 &quot;cs.ATG&quot; 
 			fxStmt.EmbeddedStatement = embeddedStatement; statement = fxStmt;
 		} else SynErr(171);
 	}
 
 	void StatementExpr(
-#line  1740 &quot;cs.ATG&quot; 
+#line  1748 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1745 &quot;cs.ATG&quot; 
+#line  1753 &quot;cs.ATG&quot; 
 		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
 		                       la.kind == Tokens.Not   || la.kind == Tokens.BitwiseComplement ||
 		                       la.kind == Tokens.Times || la.kind == Tokens.BitwiseAnd   || IsTypeCast();
 		Expression expr = null;
 		
 		UnaryExpr(
-#line  1751 &quot;cs.ATG&quot; 
+#line  1759 &quot;cs.ATG&quot; 
 out expr);
 		if (StartOf(6)) {
 
-#line  1754 &quot;cs.ATG&quot; 
+#line  1762 &quot;cs.ATG&quot; 
 			AssignmentOperatorType op; Expression val; 
 			AssignmentOperator(
-#line  1754 &quot;cs.ATG&quot; 
+#line  1762 &quot;cs.ATG&quot; 
 out op);
 			Expr(
-#line  1754 &quot;cs.ATG&quot; 
+#line  1762 &quot;cs.ATG&quot; 
 out val);
 
-#line  1754 &quot;cs.ATG&quot; 
+#line  1762 &quot;cs.ATG&quot; 
 			expr = new AssignmentExpression(expr, op, val); 
 		} else if (la.kind == 10 || la.kind == 12 || la.kind == 19) {
 
-#line  1755 &quot;cs.ATG&quot; 
+#line  1763 &quot;cs.ATG&quot; 
 			if (mustBeAssignment) Error(&quot;error in assignment.&quot;); 
 		} else SynErr(172);
 
-#line  1756 &quot;cs.ATG&quot; 
+#line  1764 &quot;cs.ATG&quot; 
 		stmt = new StatementExpression(expr); 
 	}
 
 	void SwitchSection(
-#line  1654 &quot;cs.ATG&quot; 
+#line  1662 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1656 &quot;cs.ATG&quot; 
+#line  1664 &quot;cs.ATG&quot; 
 		SwitchSection switchSection = new SwitchSection();
 		Expression expr;
 		
 		SwitchLabel(
-#line  1660 &quot;cs.ATG&quot; 
+#line  1668 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1660 &quot;cs.ATG&quot; 
+#line  1668 &quot;cs.ATG&quot; 
 		switchSection.SwitchLabels.Add(expr); 
 		while (la.kind == 54 || la.kind == 62) {
 			SwitchLabel(
-#line  1660 &quot;cs.ATG&quot; 
+#line  1668 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1660 &quot;cs.ATG&quot; 
+#line  1668 &quot;cs.ATG&quot; 
 			switchSection.SwitchLabels.Add(expr); 
 		}
 
-#line  1661 &quot;cs.ATG&quot; 
+#line  1669 &quot;cs.ATG&quot; 
 		compilationUnit.BlockStart(switchSection); 
 		Statement();
 		while (StartOf(20)) {
 			Statement();
 		}
 
-#line  1664 &quot;cs.ATG&quot; 
+#line  1672 &quot;cs.ATG&quot; 
 		compilationUnit.BlockEnd();
 		stmt = switchSection;
 		
 	}
 
 	void ForInitializer(
-#line  1635 &quot;cs.ATG&quot; 
+#line  1643 &quot;cs.ATG&quot; 
 out ArrayList initializer) {
 
-#line  1637 &quot;cs.ATG&quot; 
+#line  1645 &quot;cs.ATG&quot; 
 		Statement stmt; 
 		initializer = new ArrayList();
 		
 		if (
-#line  1641 &quot;cs.ATG&quot; 
+#line  1649 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1641 &quot;cs.ATG&quot; 
+#line  1649 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1641 &quot;cs.ATG&quot; 
+#line  1649 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
 		} else if (StartOf(4)) {
 			StatementExpr(
-#line  1642 &quot;cs.ATG&quot; 
+#line  1650 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1642 &quot;cs.ATG&quot; 
+#line  1650 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
 			while (la.kind == 12) {
 				lexer.NextToken();
 				StatementExpr(
-#line  1642 &quot;cs.ATG&quot; 
+#line  1650 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1642 &quot;cs.ATG&quot; 
+#line  1650 &quot;cs.ATG&quot; 
 				initializer.Add(stmt);
 			}
 
-#line  1642 &quot;cs.ATG&quot; 
+#line  1650 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
 		} else SynErr(173);
 	}
 
 	void ForIterator(
-#line  1645 &quot;cs.ATG&quot; 
+#line  1653 &quot;cs.ATG&quot; 
 out ArrayList iterator) {
 
-#line  1647 &quot;cs.ATG&quot; 
+#line  1655 &quot;cs.ATG&quot; 
 		Statement stmt; 
 		iterator = new ArrayList();
 		
 		StatementExpr(
-#line  1651 &quot;cs.ATG&quot; 
+#line  1659 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1651 &quot;cs.ATG&quot; 
+#line  1659 &quot;cs.ATG&quot; 
 		iterator.Add(stmt);
 		while (la.kind == 12) {
 			lexer.NextToken();
 			StatementExpr(
-#line  1651 &quot;cs.ATG&quot; 
+#line  1659 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1651 &quot;cs.ATG&quot; 
+#line  1659 &quot;cs.ATG&quot; 
 			iterator.Add(stmt); 
 		}
 	}
 
 	void GotoStatement(
-#line  1713 &quot;cs.ATG&quot; 
+#line  1721 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1714 &quot;cs.ATG&quot; 
+#line  1722 &quot;cs.ATG&quot; 
 		Expression expr; stmt = null; 
 		Expect(77);
 		if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1718 &quot;cs.ATG&quot; 
+#line  1726 &quot;cs.ATG&quot; 
 			stmt = new GotoStatement(t.val); 
 			Expect(10);
 		} else if (la.kind == 54) {
 			lexer.NextToken();
 			Expr(
-#line  1719 &quot;cs.ATG&quot; 
+#line  1727 &quot;cs.ATG&quot; 
 out expr);
 			Expect(10);
 
-#line  1719 &quot;cs.ATG&quot; 
+#line  1727 &quot;cs.ATG&quot; 
 			stmt = new GotoCaseStatement(expr); 
 		} else if (la.kind == 62) {
 			lexer.NextToken();
 			Expect(10);
 
-#line  1720 &quot;cs.ATG&quot; 
+#line  1728 &quot;cs.ATG&quot; 
 			stmt = new GotoCaseStatement(null); 
 		} else SynErr(174);
 	}
 
 	void TryStatement(
-#line  1676 &quot;cs.ATG&quot; 
+#line  1684 &quot;cs.ATG&quot; 
 out Statement tryStatement) {
 
-#line  1678 &quot;cs.ATG&quot; 
+#line  1686 &quot;cs.ATG&quot; 
 		Statement blockStmt = null, finallyStmt = null;
 		ArrayList catchClauses = null;
 		
 		Expect(113);
 		Block(
-#line  1682 &quot;cs.ATG&quot; 
+#line  1690 &quot;cs.ATG&quot; 
 out blockStmt);
 		if (la.kind == 55) {
 			CatchClauses(
-#line  1684 &quot;cs.ATG&quot; 
+#line  1692 &quot;cs.ATG&quot; 
 out catchClauses);
 			if (la.kind == 72) {
 				lexer.NextToken();
 				Block(
-#line  1684 &quot;cs.ATG&quot; 
+#line  1692 &quot;cs.ATG&quot; 
 out finallyStmt);
 			}
 		} else if (la.kind == 72) {
 			lexer.NextToken();
 			Block(
-#line  1685 &quot;cs.ATG&quot; 
+#line  1693 &quot;cs.ATG&quot; 
 out finallyStmt);
 		} else SynErr(175);
 
-#line  1688 &quot;cs.ATG&quot; 
+#line  1696 &quot;cs.ATG&quot; 
 		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
 		
 	}
 
 	void ResourceAcquisition(
-#line  1724 &quot;cs.ATG&quot; 
+#line  1732 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1726 &quot;cs.ATG&quot; 
+#line  1734 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expression expr;
 		
 		if (
-#line  1731 &quot;cs.ATG&quot; 
+#line  1739 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1731 &quot;cs.ATG&quot; 
+#line  1739 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (StartOf(4)) {
 			Expr(
-#line  1732 &quot;cs.ATG&quot; 
+#line  1740 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1736 &quot;cs.ATG&quot; 
+#line  1744 &quot;cs.ATG&quot; 
 			stmt = new StatementExpression(expr); 
 		} else SynErr(176);
 	}
 
 	void SwitchLabel(
-#line  1669 &quot;cs.ATG&quot; 
+#line  1677 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1670 &quot;cs.ATG&quot; 
+#line  1678 &quot;cs.ATG&quot; 
 		expr = null; 
 		if (la.kind == 54) {
 			lexer.NextToken();
 			Expr(
-#line  1672 &quot;cs.ATG&quot; 
+#line  1680 &quot;cs.ATG&quot; 
 out expr);
 			Expect(9);
 		} else if (la.kind == 62) {
@@ -3923,153 +3941,153 @@
 	}
 
 	void CatchClauses(
-#line  1693 &quot;cs.ATG&quot; 
+#line  1701 &quot;cs.ATG&quot; 
 out ArrayList catchClauses) {
 
-#line  1695 &quot;cs.ATG&quot; 
+#line  1703 &quot;cs.ATG&quot; 
 		catchClauses = new ArrayList();
 		
 		Expect(55);
 
-#line  1698 &quot;cs.ATG&quot; 
+#line  1706 &quot;cs.ATG&quot; 
 		string name;
 		string identifier;
 		Statement stmt; 
 		
 		if (la.kind == 14) {
 			Block(
-#line  1704 &quot;cs.ATG&quot; 
+#line  1712 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1704 &quot;cs.ATG&quot; 
+#line  1712 &quot;cs.ATG&quot; 
 			catchClauses.Add(new CatchClause(stmt)); 
 		} else if (la.kind == 18) {
 			lexer.NextToken();
 			ClassType(
-#line  1706 &quot;cs.ATG&quot; 
+#line  1714 &quot;cs.ATG&quot; 
 out name);
 
-#line  1706 &quot;cs.ATG&quot; 
+#line  1714 &quot;cs.ATG&quot; 
 			identifier = null; 
 			if (la.kind == 1) {
 				lexer.NextToken();
 
-#line  1706 &quot;cs.ATG&quot; 
+#line  1714 &quot;cs.ATG&quot; 
 				identifier = t.val; 
 			}
 			Expect(19);
 			Block(
-#line  1706 &quot;cs.ATG&quot; 
+#line  1714 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1706 &quot;cs.ATG&quot; 
+#line  1714 &quot;cs.ATG&quot; 
 			catchClauses.Add(new CatchClause(name, identifier, stmt)); 
 			while (
-#line  1707 &quot;cs.ATG&quot; 
+#line  1715 &quot;cs.ATG&quot; 
 IsTypedCatch()) {
 				Expect(55);
 				Expect(18);
 				ClassType(
-#line  1707 &quot;cs.ATG&quot; 
+#line  1715 &quot;cs.ATG&quot; 
 out name);
 
-#line  1707 &quot;cs.ATG&quot; 
+#line  1715 &quot;cs.ATG&quot; 
 				identifier = null; 
 				if (la.kind == 1) {
 					lexer.NextToken();
 
-#line  1707 &quot;cs.ATG&quot; 
+#line  1715 &quot;cs.ATG&quot; 
 					identifier = t.val; 
 				}
 				Expect(19);
 				Block(
-#line  1707 &quot;cs.ATG&quot; 
+#line  1715 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1707 &quot;cs.ATG&quot; 
+#line  1715 &quot;cs.ATG&quot; 
 				catchClauses.Add(new CatchClause(name, identifier, stmt)); 
 			}
 			if (la.kind == 55) {
 				lexer.NextToken();
 				Block(
-#line  1709 &quot;cs.ATG&quot; 
+#line  1717 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1709 &quot;cs.ATG&quot; 
+#line  1717 &quot;cs.ATG&quot; 
 				catchClauses.Add(new CatchClause(stmt)); 
 			}
 		} else SynErr(178);
 	}
 
 	void UnaryExpr(
-#line  1772 &quot;cs.ATG&quot; 
+#line  1780 &quot;cs.ATG&quot; 
 out Expression uExpr) {
 
-#line  1774 &quot;cs.ATG&quot; 
+#line  1782 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		Expression expr;
 		ArrayList  expressions = new ArrayList();
 		uExpr = null;
 		
 		while (StartOf(26) || 
-#line  1796 &quot;cs.ATG&quot; 
+#line  1804 &quot;cs.ATG&quot; 
 IsTypeCast()) {
 			if (la.kind == 4) {
 				lexer.NextToken();
 
-#line  1781 &quot;cs.ATG&quot; 
+#line  1789 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); 
 			} else if (la.kind == 5) {
 				lexer.NextToken();
 
-#line  1782 &quot;cs.ATG&quot; 
+#line  1790 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); 
 			} else if (la.kind == 22) {
 				lexer.NextToken();
 
-#line  1783 &quot;cs.ATG&quot; 
+#line  1791 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); 
 			} else if (la.kind == 25) {
 				lexer.NextToken();
 
-#line  1784 &quot;cs.ATG&quot; 
+#line  1792 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); 
 			} else if (la.kind == 6) {
 				lexer.NextToken();
 
-#line  1785 &quot;cs.ATG&quot; 
+#line  1793 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); 
 			} else if (la.kind == 29) {
 				lexer.NextToken();
 
-#line  1786 &quot;cs.ATG&quot; 
+#line  1794 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); 
 			} else if (la.kind == 30) {
 				lexer.NextToken();
 
-#line  1787 &quot;cs.ATG&quot; 
+#line  1795 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); 
 			} else if (la.kind == 26) {
 				lexer.NextToken();
 
-#line  1788 &quot;cs.ATG&quot; 
+#line  1796 &quot;cs.ATG&quot; 
 				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); 
 			} else {
 				Expect(18);
 				Type(
-#line  1796 &quot;cs.ATG&quot; 
+#line  1804 &quot;cs.ATG&quot; 
 out type);
 				Expect(19);
 
-#line  1796 &quot;cs.ATG&quot; 
+#line  1804 &quot;cs.ATG&quot; 
 				expressions.Add(new CastExpression(type)); 
 			}
 		}
 		PrimaryExpr(
-#line  1799 &quot;cs.ATG&quot; 
+#line  1807 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1799 &quot;cs.ATG&quot; 
+#line  1807 &quot;cs.ATG&quot; 
 		for (int i = 0; i &lt; expressions.Count; ++i) {
 		Expression nextExpression = i + 1 &lt; expressions.Count ? (Expression)expressions[i + 1] : expr;
 		if (expressions[i] is CastExpression) {
@@ -4087,33 +4105,33 @@
 	}
 
 	void ConditionalOrExpr(
-#line  1901 &quot;cs.ATG&quot; 
+#line  1909 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1902 &quot;cs.ATG&quot; 
+#line  1910 &quot;cs.ATG&quot; 
 		Expression expr;   
 		ConditionalAndExpr(
-#line  1904 &quot;cs.ATG&quot; 
+#line  1912 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 24) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1904 &quot;cs.ATG&quot; 
+#line  1912 &quot;cs.ATG&quot; 
 out expr);
 			ConditionalAndExpr(
-#line  1904 &quot;cs.ATG&quot; 
+#line  1912 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1904 &quot;cs.ATG&quot; 
+#line  1912 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  
 		}
 	}
 
 	void PrimaryExpr(
-#line  1816 &quot;cs.ATG&quot; 
+#line  1824 &quot;cs.ATG&quot; 
 out Expression pexpr) {
 
-#line  1818 &quot;cs.ATG&quot; 
+#line  1826 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		bool isArrayCreation = false;
 		Expression expr;
@@ -4123,46 +4141,46 @@
 		case 112: {
 			lexer.NextToken();
 
-#line  1825 &quot;cs.ATG&quot; 
+#line  1833 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(true, &quot;true&quot;);  
 			break;
 		}
 		case 71: {
 			lexer.NextToken();
 
-#line  1826 &quot;cs.ATG&quot; 
+#line  1834 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(false, &quot;false&quot;); 
 			break;
 		}
 		case 89: {
 			lexer.NextToken();
 
-#line  1827 &quot;cs.ATG&quot; 
+#line  1835 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(null, &quot;null&quot;);  
 			break;
 		}
 		case 2: {
 			lexer.NextToken();
 
-#line  1828 &quot;cs.ATG&quot; 
+#line  1836 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(t.literalValue, t.val);  
 			break;
 		}
 		case 1: {
 			lexer.NextToken();
 
-#line  1830 &quot;cs.ATG&quot; 
+#line  1838 &quot;cs.ATG&quot; 
 			pexpr = new IdentifierExpression(t.val); 
 			break;
 		}
 		case 18: {
 			lexer.NextToken();
 			Expr(
-#line  1832 &quot;cs.ATG&quot; 
+#line  1840 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1832 &quot;cs.ATG&quot; 
+#line  1840 &quot;cs.ATG&quot; 
 			pexpr = new ParenthesizedExpression(expr); 
 			break;
 		}
@@ -4230,185 +4248,185 @@
 			}
 			}
 
-#line  1838 &quot;cs.ATG&quot; 
+#line  1846 &quot;cs.ATG&quot; 
 			string val = t.val; t.val = &quot;&quot;; 
 			Expect(13);
 			Expect(1);
 
-#line  1838 &quot;cs.ATG&quot; 
+#line  1846 &quot;cs.ATG&quot; 
 			pexpr = new FieldReferenceExpression(new TypeReferenceExpression(val), t.val); 
 			break;
 		}
 		case 110: {
 			lexer.NextToken();
 
-#line  1840 &quot;cs.ATG&quot; 
+#line  1848 &quot;cs.ATG&quot; 
 			pexpr = new ThisReferenceExpression(); 
 			break;
 		}
 		case 50: {
 			lexer.NextToken();
 
-#line  1842 &quot;cs.ATG&quot; 
+#line  1850 &quot;cs.ATG&quot; 
 			Expression retExpr = new BaseReferenceExpression(); 
 			if (la.kind == 13) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1844 &quot;cs.ATG&quot; 
+#line  1852 &quot;cs.ATG&quot; 
 				retExpr = new FieldReferenceExpression(retExpr, t.val); 
 			} else if (la.kind == 16) {
 				lexer.NextToken();
 				Expr(
-#line  1845 &quot;cs.ATG&quot; 
+#line  1853 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1845 &quot;cs.ATG&quot; 
+#line  1853 &quot;cs.ATG&quot; 
 				ArrayList indices = new ArrayList(); indices.Add(expr); 
 				while (la.kind == 12) {
 					lexer.NextToken();
 					Expr(
-#line  1846 &quot;cs.ATG&quot; 
+#line  1854 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1846 &quot;cs.ATG&quot; 
+#line  1854 &quot;cs.ATG&quot; 
 					indices.Add(expr); 
 				}
 				Expect(17);
 
-#line  1847 &quot;cs.ATG&quot; 
+#line  1855 &quot;cs.ATG&quot; 
 				retExpr = new IndexerExpression(retExpr, indices); 
 			} else SynErr(179);
 
-#line  1848 &quot;cs.ATG&quot; 
+#line  1856 &quot;cs.ATG&quot; 
 			pexpr = retExpr; 
 			break;
 		}
 		case 88: {
 			lexer.NextToken();
 			NonArrayType(
-#line  1849 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 out type);
 
-#line  1849 &quot;cs.ATG&quot; 
+#line  1857 &quot;cs.ATG&quot; 
 			ArrayList parameters = new ArrayList(); 
 			if (la.kind == 18) {
 				lexer.NextToken();
 
-#line  1854 &quot;cs.ATG&quot; 
+#line  1862 &quot;cs.ATG&quot; 
 				ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); 
 				if (StartOf(21)) {
 					Argument(
-#line  1854 &quot;cs.ATG&quot; 
+#line  1862 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1854 &quot;cs.ATG&quot; 
+#line  1862 &quot;cs.ATG&quot; 
 					parameters.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Argument(
-#line  1855 &quot;cs.ATG&quot; 
+#line  1863 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1855 &quot;cs.ATG&quot; 
+#line  1863 &quot;cs.ATG&quot; 
 						parameters.Add(expr); 
 					}
 				}
 				Expect(19);
 
-#line  1855 &quot;cs.ATG&quot; 
+#line  1863 &quot;cs.ATG&quot; 
 				pexpr = oce; 
 			} else if (la.kind == 16) {
 
-#line  1857 &quot;cs.ATG&quot; 
+#line  1865 &quot;cs.ATG&quot; 
 				isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type); pexpr = ace; 
 				lexer.NextToken();
 
-#line  1858 &quot;cs.ATG&quot; 
+#line  1866 &quot;cs.ATG&quot; 
 				int dims = 0; ArrayList rank = new ArrayList(); ArrayList parameterExpression = new ArrayList(); 
 				if (StartOf(4)) {
 					Expr(
-#line  1860 &quot;cs.ATG&quot; 
+#line  1868 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1860 &quot;cs.ATG&quot; 
+#line  1868 &quot;cs.ATG&quot; 
 					parameterExpression.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Expr(
-#line  1860 &quot;cs.ATG&quot; 
+#line  1868 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1860 &quot;cs.ATG&quot; 
+#line  1868 &quot;cs.ATG&quot; 
 						parameterExpression.Add(expr); 
 					}
 					Expect(17);
 
-#line  1860 &quot;cs.ATG&quot; 
+#line  1868 &quot;cs.ATG&quot; 
 					parameters.Add(new ArrayCreationParameter(parameterExpression)); ace.Parameters = parameters; 
 					while (
-#line  1861 &quot;cs.ATG&quot; 
+#line  1869 &quot;cs.ATG&quot; 
 IsDims()) {
 						Expect(16);
 
-#line  1861 &quot;cs.ATG&quot; 
+#line  1869 &quot;cs.ATG&quot; 
 						dims =0;
 						while (la.kind == 12) {
 							lexer.NextToken();
 
-#line  1861 &quot;cs.ATG&quot; 
+#line  1869 &quot;cs.ATG&quot; 
 							dims++;
 						}
 
-#line  1861 &quot;cs.ATG&quot; 
+#line  1869 &quot;cs.ATG&quot; 
 						rank.Add(dims); parameters.Add(new ArrayCreationParameter(dims)); 
 						Expect(17);
 					}
 
-#line  1862 &quot;cs.ATG&quot; 
+#line  1870 &quot;cs.ATG&quot; 
 					if (rank.Count &gt; 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } 
 					if (la.kind == 14) {
 						ArrayInitializer(
-#line  1863 &quot;cs.ATG&quot; 
+#line  1871 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1863 &quot;cs.ATG&quot; 
+#line  1871 &quot;cs.ATG&quot; 
 						ace.ArrayInitializer = (ArrayInitializerExpression)expr; 
 					}
 				} else if (la.kind == 12 || la.kind == 17) {
 					while (la.kind == 12) {
 						lexer.NextToken();
 
-#line  1865 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 						dims++;
 					}
 
-#line  1865 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 					parameters.Add(new ArrayCreationParameter(dims)); 
 					Expect(17);
 					while (
-#line  1865 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 IsDims()) {
 						Expect(16);
 
-#line  1865 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 						dims =0;
 						while (la.kind == 12) {
 							lexer.NextToken();
 
-#line  1865 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 							dims++;
 						}
 
-#line  1865 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 						parameters.Add(new ArrayCreationParameter(dims)); 
 						Expect(17);
 					}
 					ArrayInitializer(
-#line  1865 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1865 &quot;cs.ATG&quot; 
+#line  1873 &quot;cs.ATG&quot; 
 					ace.ArrayInitializer = (ArrayInitializerExpression)expr; ace.Parameters = parameters; 
 				} else SynErr(180);
 			} else SynErr(181);
@@ -4418,20 +4436,20 @@
 			lexer.NextToken();
 			Expect(18);
 			if (
-#line  1871 &quot;cs.ATG&quot; 
+#line  1879 &quot;cs.ATG&quot; 
 NotVoidPointer()) {
 				Expect(122);
 
-#line  1871 &quot;cs.ATG&quot; 
+#line  1879 &quot;cs.ATG&quot; 
 				type = new TypeReference(&quot;void&quot;); 
 			} else if (StartOf(8)) {
 				Type(
-#line  1872 &quot;cs.ATG&quot; 
+#line  1880 &quot;cs.ATG&quot; 
 out type);
 			} else SynErr(182);
 			Expect(19);
 
-#line  1873 &quot;cs.ATG&quot; 
+#line  1881 &quot;cs.ATG&quot; 
 			pexpr = new TypeOfExpression(type); 
 			break;
 		}
@@ -4439,11 +4457,11 @@
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1874 &quot;cs.ATG&quot; 
+#line  1882 &quot;cs.ATG&quot; 
 out type);
 			Expect(19);
 
-#line  1874 &quot;cs.ATG&quot; 
+#line  1882 &quot;cs.ATG&quot; 
 			pexpr = new SizeOfExpression(type); 
 			break;
 		}
@@ -4451,11 +4469,11 @@
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1875 &quot;cs.ATG&quot; 
+#line  1883 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1875 &quot;cs.ATG&quot; 
+#line  1883 &quot;cs.ATG&quot; 
 			pexpr = new CheckedExpression(expr); 
 			break;
 		}
@@ -4463,11 +4481,11 @@
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1876 &quot;cs.ATG&quot; 
+#line  1884 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1876 &quot;cs.ATG&quot; 
+#line  1884 &quot;cs.ATG&quot; 
 			pexpr = new CheckedExpression(expr); 
 			break;
 		}
@@ -4478,350 +4496,350 @@
 				if (la.kind == 29) {
 					lexer.NextToken();
 
-#line  1880 &quot;cs.ATG&quot; 
+#line  1888 &quot;cs.ATG&quot; 
 					pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); 
 				} else if (la.kind == 30) {
 					lexer.NextToken();
 
-#line  1881 &quot;cs.ATG&quot; 
+#line  1889 &quot;cs.ATG&quot; 
 					pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); 
 				} else SynErr(184);
 			} else if (la.kind == 47) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1884 &quot;cs.ATG&quot; 
+#line  1892 &quot;cs.ATG&quot; 
 				pexpr = new PointerReferenceExpression(pexpr, t.val); 
 			} else if (la.kind == 13) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1885 &quot;cs.ATG&quot; 
+#line  1893 &quot;cs.ATG&quot; 
 				pexpr = new FieldReferenceExpression(pexpr, t.val);
 			} else if (la.kind == 18) {
 				lexer.NextToken();
 
-#line  1887 &quot;cs.ATG&quot; 
+#line  1895 &quot;cs.ATG&quot; 
 				ArrayList parameters = new ArrayList(); 
 				if (StartOf(21)) {
 					Argument(
-#line  1888 &quot;cs.ATG&quot; 
+#line  1896 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1888 &quot;cs.ATG&quot; 
+#line  1896 &quot;cs.ATG&quot; 
 					parameters.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Argument(
-#line  1889 &quot;cs.ATG&quot; 
+#line  1897 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1889 &quot;cs.ATG&quot; 
+#line  1897 &quot;cs.ATG&quot; 
 						parameters.Add(expr); 
 					}
 				}
 				Expect(19);
 
-#line  1890 &quot;cs.ATG&quot; 
+#line  1898 &quot;cs.ATG&quot; 
 				pexpr = new InvocationExpression(pexpr, parameters); 
 			} else {
 
-#line  1892 &quot;cs.ATG&quot; 
+#line  1900 &quot;cs.ATG&quot; 
 				if (isArrayCreation) Error(&quot;element access not allow on array creation&quot;);
 				ArrayList indices = new ArrayList();
 				
 				lexer.NextToken();
 				Expr(
-#line  1895 &quot;cs.ATG&quot; 
+#line  1903 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1895 &quot;cs.ATG&quot; 
+#line  1903 &quot;cs.ATG&quot; 
 				indices.Add(expr); 
 				while (la.kind == 12) {
 					lexer.NextToken();
 					Expr(
-#line  1896 &quot;cs.ATG&quot; 
+#line  1904 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1896 &quot;cs.ATG&quot; 
+#line  1904 &quot;cs.ATG&quot; 
 					indices.Add(expr); 
 				}
 				Expect(17);
 
-#line  1897 &quot;cs.ATG&quot; 
+#line  1905 &quot;cs.ATG&quot; 
 				pexpr = new IndexerExpression(pexpr, indices); 
 			}
 		}
 	}
 
 	void ConditionalAndExpr(
-#line  1907 &quot;cs.ATG&quot; 
+#line  1915 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1908 &quot;cs.ATG&quot; 
+#line  1916 &quot;cs.ATG&quot; 
 		Expression expr; 
 		InclusiveOrExpr(
-#line  1910 &quot;cs.ATG&quot; 
+#line  1918 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 23) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1910 &quot;cs.ATG&quot; 
+#line  1918 &quot;cs.ATG&quot; 
 out expr);
 			InclusiveOrExpr(
-#line  1910 &quot;cs.ATG&quot; 
+#line  1918 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1910 &quot;cs.ATG&quot; 
+#line  1918 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  
 		}
 	}
 
 	void InclusiveOrExpr(
-#line  1913 &quot;cs.ATG&quot; 
+#line  1921 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1914 &quot;cs.ATG&quot; 
+#line  1922 &quot;cs.ATG&quot; 
 		Expression expr; 
 		ExclusiveOrExpr(
-#line  1916 &quot;cs.ATG&quot; 
+#line  1924 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 27) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1916 &quot;cs.ATG&quot; 
+#line  1924 &quot;cs.ATG&quot; 
 out expr);
 			ExclusiveOrExpr(
-#line  1916 &quot;cs.ATG&quot; 
+#line  1924 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1916 &quot;cs.ATG&quot; 
+#line  1924 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  
 		}
 	}
 
 	void ExclusiveOrExpr(
-#line  1919 &quot;cs.ATG&quot; 
+#line  1927 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1920 &quot;cs.ATG&quot; 
+#line  1928 &quot;cs.ATG&quot; 
 		Expression expr; 
 		AndExpr(
-#line  1922 &quot;cs.ATG&quot; 
+#line  1930 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 28) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1922 &quot;cs.ATG&quot; 
+#line  1930 &quot;cs.ATG&quot; 
 out expr);
 			AndExpr(
-#line  1922 &quot;cs.ATG&quot; 
+#line  1930 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1922 &quot;cs.ATG&quot; 
+#line  1930 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  
 		}
 	}
 
 	void AndExpr(
-#line  1925 &quot;cs.ATG&quot; 
+#line  1933 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1926 &quot;cs.ATG&quot; 
+#line  1934 &quot;cs.ATG&quot; 
 		Expression expr; 
 		EqualityExpr(
-#line  1928 &quot;cs.ATG&quot; 
+#line  1936 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 26) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1928 &quot;cs.ATG&quot; 
+#line  1936 &quot;cs.ATG&quot; 
 out expr);
 			EqualityExpr(
-#line  1928 &quot;cs.ATG&quot; 
+#line  1936 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1928 &quot;cs.ATG&quot; 
+#line  1936 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  
 		}
 	}
 
 	void EqualityExpr(
-#line  1931 &quot;cs.ATG&quot; 
+#line  1939 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1933 &quot;cs.ATG&quot; 
+#line  1941 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		RelationalExpr(
-#line  1937 &quot;cs.ATG&quot; 
+#line  1945 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 31 || la.kind == 32) {
 			if (la.kind == 32) {
 				lexer.NextToken();
 
-#line  1940 &quot;cs.ATG&quot; 
+#line  1948 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.InEquality; 
 			} else {
 				lexer.NextToken();
 
-#line  1941 &quot;cs.ATG&quot; 
+#line  1949 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Equality; 
 			}
 			UnaryExpr(
-#line  1943 &quot;cs.ATG&quot; 
+#line  1951 &quot;cs.ATG&quot; 
 out expr);
 			RelationalExpr(
-#line  1943 &quot;cs.ATG&quot; 
+#line  1951 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1943 &quot;cs.ATG&quot; 
+#line  1951 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void RelationalExpr(
-#line  1947 &quot;cs.ATG&quot; 
+#line  1955 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1949 &quot;cs.ATG&quot; 
+#line  1957 &quot;cs.ATG&quot; 
 		TypeReference type;
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		ShiftExpr(
-#line  1954 &quot;cs.ATG&quot; 
+#line  1962 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (StartOf(28)) {
 			if (StartOf(29)) {
 				if (la.kind == 21) {
 					lexer.NextToken();
 
-#line  1957 &quot;cs.ATG&quot; 
+#line  1965 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.LessThan; 
 				} else if (la.kind == 20) {
 					lexer.NextToken();
 
-#line  1958 &quot;cs.ATG&quot; 
+#line  1966 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.GreaterThan; 
 				} else if (la.kind == 34) {
 					lexer.NextToken();
 
-#line  1959 &quot;cs.ATG&quot; 
+#line  1967 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.LessThanOrEqual; 
 				} else if (la.kind == 33) {
 					lexer.NextToken();
 
-#line  1960 &quot;cs.ATG&quot; 
+#line  1968 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.GreaterThanOrEqual; 
 				} else SynErr(185);
 				UnaryExpr(
-#line  1962 &quot;cs.ATG&quot; 
+#line  1970 &quot;cs.ATG&quot; 
 out expr);
 				ShiftExpr(
-#line  1962 &quot;cs.ATG&quot; 
+#line  1970 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1962 &quot;cs.ATG&quot; 
+#line  1970 &quot;cs.ATG&quot; 
 				outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 			} else {
 				if (la.kind == 84) {
 					lexer.NextToken();
 
-#line  1965 &quot;cs.ATG&quot; 
+#line  1973 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.IS; 
 				} else if (la.kind == 49) {
 					lexer.NextToken();
 
-#line  1966 &quot;cs.ATG&quot; 
+#line  1974 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.AS; 
 				} else SynErr(186);
 				Type(
-#line  1968 &quot;cs.ATG&quot; 
+#line  1976 &quot;cs.ATG&quot; 
 out type);
 
-#line  1968 &quot;cs.ATG&quot; 
+#line  1976 &quot;cs.ATG&quot; 
 				outExpr = new BinaryOperatorExpression(outExpr, op, new TypeReferenceExpression(type)); 
 			}
 		}
 	}
 
 	void ShiftExpr(
-#line  1972 &quot;cs.ATG&quot; 
+#line  1980 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1974 &quot;cs.ATG&quot; 
+#line  1982 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		AdditiveExpr(
-#line  1978 &quot;cs.ATG&quot; 
+#line  1986 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 35 || la.kind == 36) {
 			if (la.kind == 35) {
 				lexer.NextToken();
 
-#line  1981 &quot;cs.ATG&quot; 
+#line  1989 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.ShiftLeft; 
 			} else {
 				lexer.NextToken();
 
-#line  1982 &quot;cs.ATG&quot; 
+#line  1990 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.ShiftRight; 
 			}
 			UnaryExpr(
-#line  1984 &quot;cs.ATG&quot; 
+#line  1992 &quot;cs.ATG&quot; 
 out expr);
 			AdditiveExpr(
-#line  1984 &quot;cs.ATG&quot; 
+#line  1992 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1984 &quot;cs.ATG&quot; 
+#line  1992 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void AdditiveExpr(
-#line  1988 &quot;cs.ATG&quot; 
+#line  1996 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1990 &quot;cs.ATG&quot; 
+#line  1998 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		MultiplicativeExpr(
-#line  1994 &quot;cs.ATG&quot; 
+#line  2002 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 4 || la.kind == 5) {
 			if (la.kind == 4) {
 				lexer.NextToken();
 
-#line  1997 &quot;cs.ATG&quot; 
+#line  2005 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Add; 
 			} else {
 				lexer.NextToken();
 
-#line  1998 &quot;cs.ATG&quot; 
+#line  2006 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Subtract; 
 			}
 			UnaryExpr(
-#line  2000 &quot;cs.ATG&quot; 
+#line  2008 &quot;cs.ATG&quot; 
 out expr);
 			MultiplicativeExpr(
-#line  2000 &quot;cs.ATG&quot; 
+#line  2008 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  2000 &quot;cs.ATG&quot; 
+#line  2008 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void MultiplicativeExpr(
-#line  2004 &quot;cs.ATG&quot; 
+#line  2012 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  2006 &quot;cs.ATG&quot; 
+#line  2014 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
@@ -4829,24 +4847,24 @@
 			if (la.kind == 6) {
 				lexer.NextToken();
 
-#line  2012 &quot;cs.ATG&quot; 
+#line  2020 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Multiply; 
 			} else if (la.kind == 7) {
 				lexer.NextToken();
 
-#line  2013 &quot;cs.ATG&quot; 
+#line  2021 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Divide; 
 			} else {
 				lexer.NextToken();
 
-#line  2014 &quot;cs.ATG&quot; 
+#line  2022 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Modulus; 
 			}
 			UnaryExpr(
-#line  2016 &quot;cs.ATG&quot; 
+#line  2024 &quot;cs.ATG&quot; 
 out expr);
 
-#line  2016 &quot;cs.ATG&quot; 
+#line  2024 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
 		}
 	}

Modified: trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG
===================================================================
--- trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG	2005-06-11 12:25:16 UTC (rev 2596)
+++ trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated/cs.ATG	2005-06-13 14:54:44 UTC (rev 2597)
@@ -1331,16 +1331,24 @@
 (. Statement stmt = null; .)
 =
 	ident /* &quot;get&quot; is not a keyword */
+	(. Point startLocation = t.Location; .)
 	(. if (t.val != &quot;get&quot;) Error(&quot;get expected&quot;); .)
-	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes, m); .)
+	( Block&lt;out stmt&gt; | &quot;;&quot; )
+	(. getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes, m); .)
+	(. getBlock.StartLocation = startLocation; .)
+	(. getBlock.EndLocation = t.Location; .)
 .
 
 SetAccessorDecl&lt;out PropertySetRegion setBlock, ArrayList attributes, Modifier m&gt;
 (. Statement stmt = null; .)
 =
 	ident /* &quot;set&quot; is not a keyword */
+	(. Point startLocation = t.Location; .)	
 	(. if (t.val != &quot;set&quot;) Error(&quot;set expected&quot;); .)
-	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. setBlock = new PropertySetRegion((BlockStatement)stmt, attributes, m); .)
+	( Block&lt;out stmt&gt; | &quot;;&quot; )
+	(. setBlock = new PropertySetRegion((BlockStatement)stmt, attributes, m); .)
+	(. setBlock.StartLocation = startLocation; .)
+	(. setBlock.EndLocation = t.Location; .)
 .
 
 EventAccessorDecls&lt;out EventAddRegion addBlock, out EventRemoveRegion removeBlock&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002196.html">[Monodevelop-patches-list] r2596 - in	trunk/MonoDevelop/Extras/JavaBinding: . Gui
</A></li>
	<LI>Next message: <A HREF="002198.html">[Monodevelop-patches-list] r2598 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: .	Gui/Dialogs/ReferenceDialog Services/Project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2197">[ date ]</a>
              <a href="thread.html#2197">[ thread ]</a>
              <a href="subject.html#2197">[ subject ]</a>
              <a href="author.html#2197">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
