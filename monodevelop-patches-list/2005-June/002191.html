<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2591 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets: .	Commands DockToolbars
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2591%20-%20in%0A%09trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets%3A%20.%0A%09Commands%20DockToolbars&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002190.html">
   <LINK REL="Next"  HREF="002192.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2591 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets: .	Commands DockToolbars</H1>
    <B>Lluis Sanchez &lt;lluis@ximian.com&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2591%20-%20in%0A%09trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets%3A%20.%0A%09Commands%20DockToolbars&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2591 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets: .	Commands DockToolbars">lluis at mono-cvs.ximian.com
       </A><BR>
    <I>Thu Jun  9 11:58:16 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002190.html">[Monodevelop-patches-list] r2590 - trunk/MonoDevelop
</A></li>
        <LI>Next message: <A HREF="002192.html">[Monodevelop-patches-list] r2592 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Commands Gui	Gui/Workbench Gui/Workbench/Layouts Internal/Codons/Commands
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2191">[ date ]</a>
              <a href="thread.html#2191">[ thread ]</a>
              <a href="subject.html#2191">[ subject ]</a>
              <a href="author.html#2191">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lluis
Date: 2005-06-09 11:58:16 -0400 (Thu, 09 Jun 2005)
New Revision: 2591

Added:
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandFrame.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandSystemCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/ArrowWindow.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockGrip.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbar.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrame.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrameLayout.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrameStatus.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarPanel.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarPosition.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarStatus.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockedPosition.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FixedPanel.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FloatingDock.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FloatingPosition.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/IDockBar.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/PlaceholderWindow.cs
Modified:
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/ChangeLog
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/Command.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandManager.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandToolbar.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Makefile.am
Log:
2005-06-09  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;

	* DockToolbars/*: Docking toolbars!
	
	* Commands/Command.cs: Command should be abstract.
	* Commands/CommandToolbar.cs: This now is a dockable toolbar.
	* Commands/CommandManager.cs: Register commands from CommandSystemCommands.
	* Commands/CommandFrame.cs: A frame to use as main container for windows
	that use commands in dockable toolbars.
	* Commands/CommandSystemCommands.cs: Some configuration commands.



Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/ChangeLog	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/ChangeLog	2005-06-09 15:58:16 UTC (rev 2591)
@@ -1,3 +1,14 @@
+2005-06-09  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;
+
+	* DockToolbars/*: Docking toolbars!
+	
+	* Commands/Command.cs: Command should be abstract.
+	* Commands/CommandToolbar.cs: This now is a dockable toolbar.
+	* Commands/CommandManager.cs: Register commands from CommandSystemCommands.
+	* Commands/CommandFrame.cs: A frame to use as main container for windows
+	that use commands in dockable toolbars.
+	* Commands/CommandSystemCommands.cs: Some configuration commands.
+
 2005-06-01  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
 
 	* Makefile.am: remove Dock/*

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/Command.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/Command.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/Command.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -30,7 +30,7 @@
 
 namespace MonoDevelop.Commands
 {
-	public class Command
+	public abstract class Command
 	{
 		public static readonly object Separator = new Object ();
 		

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandFrame.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandFrame.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandFrame.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,72 @@
+//
+// CommandFrame.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using MonoDevelop.Gui.Widgets;
+
+namespace MonoDevelop.Commands
+{
+	public class CommandFrame: DockToolbarFrame
+	{
+		CommandManager manager;
+		
+		public CommandFrame (CommandManager manager)
+		{
+			this.manager = manager;
+			manager.RegisterGlobalHandler (this);
+		}
+		
+		[CommandHandler (CommandSystemCommands.ToolbarList)]
+		protected void OnViewToolbar (object ob)
+		{
+			IDockToolbar bar = (IDockToolbar) ob;
+			bar.Visible = !bar.Visible;
+		}
+		
+		[CommandUpdateHandler (CommandSystemCommands.ToolbarList)]
+		protected void OnUpdateViewToolbar (CommandArrayInfo info)
+		{
+			foreach (IDockToolbar bar in Toolbars) {
+				CommandInfo cmd = new CommandInfo (bar.Title);
+				cmd.Checked = bar.Visible;
+				info.Add (cmd, bar);
+			}
+		}
+		
+		protected override void OnPanelClick (Gdk.EventButton e, Placement placement)
+		{
+			if (e.Button == 3) {
+				CommandEntrySet opset = new CommandEntrySet ();
+				opset.AddItem (CommandSystemCommands.ToolbarList);
+				Gtk.Menu menu = manager.CreateMenu (opset);
+				menu.Popup (null, null, null, IntPtr.Zero, 0, e.Time);
+			}
+			base.OnPanelClick (e, placement);
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandManager.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandManager.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandManager.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -47,6 +47,9 @@
 		
 		public CommandManager ()
 		{
+			ActionCommand c = new ActionCommand (CommandSystemCommands.ToolbarList, &quot;Toolbar List&quot;, null, null, ActionType.Check);
+			c.CommandArray = true;
+			RegisterCommand (c, &quot;&quot;);
 			GLib.Timeout.Add (500, new GLib.TimeoutHandler (UpdateStatus));
 		}
 		
@@ -99,12 +102,12 @@
 			return topMenu;
 		}
 		
-		public Gtk.Toolbar CreateToolbar (string name, CommandEntrySet entrySet)
+/*		public Gtk.Toolbar CreateToolbar (CommandEntrySet entrySet)
 		{
-			return CreateToolbar (entrySet);
+			return CreateToolbar (&quot;&quot;, entrySet);
 		}
 		
-		public Gtk.Menu CreateMenu (CommandEntrySet entrySet)
+*/		public Gtk.Menu CreateMenu (CommandEntrySet entrySet)
 		{
 			CommandMenu menu = new CommandMenu (this);
 			foreach (CommandEntry entry in entrySet)
@@ -112,9 +115,9 @@
 			return menu;
 		}
 		
-		public Gtk.Toolbar CreateToolbar (CommandEntrySet entrySet)
+		public Gtk.Toolbar CreateToolbar (string id, CommandEntrySet entrySet)
 		{
-			CommandToolbar toolbar = new CommandToolbar (this);
+			CommandToolbar toolbar = new CommandToolbar (this, id, entrySet.Name);
 			foreach (CommandEntry entry in entrySet)
 				toolbar.Add (entry.CreateToolItem (this));
 			return toolbar;

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandSystemCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandSystemCommands.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandSystemCommands.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,38 @@
+//
+// CommandSystemCommands.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Commands
+{
+	public enum CommandSystemCommands
+	{
+		ToolbarList
+	}
+}
+

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandToolbar.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandToolbar.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Commands/CommandToolbar.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -27,23 +27,17 @@
 //
 
 using System;
+using MonoDevelop.Gui.Widgets;
 
 namespace MonoDevelop.Commands
 {
-	public class CommandToolbar: Gtk.Toolbar
+	public class CommandToolbar: DockToolbar
 	{
-		CommandManager manager;
-		
-		public CommandToolbar (CommandManager manager)
+		public CommandToolbar (CommandManager manager, string id, string title): base (id, title)
 		{
-			this.manager = manager;
 			manager.RegisterToolbar (this);
 		}
 		
-		internal CommandManager CommandManager {
-			get { return manager; }
-		}
-		
 		protected override void OnShown ()
 		{
 			base.OnShown ();

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/ArrowWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/ArrowWindow.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/ArrowWindow.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,136 @@
+//
+// ArrowWindow.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using Gdk;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	internal class ArrowWindow: Gtk.Window
+	{
+		const int LineWidth = 3;
+		const int LineLength = 9;
+		const int PointerWidth = 13;
+		const int PointerLength = 6;
+		
+		Direction direction;
+		Point[] arrow;
+		int width, height;
+		
+		Gdk.GC redgc;
+		
+		// Where does the arrow point to
+		public enum Direction {
+			Up, Down, Left, Right
+		}
+		
+		public ArrowWindow (DockToolbarFrame frame, Direction dir): base (Gtk.WindowType.Popup)
+		{
+			SkipTaskbarHint = true;
+			Decorated = false;
+			TransientFor = frame.TopWindow;
+
+			direction = dir;
+			arrow = CreateArrow ();
+			if (direction == Direction.Up || direction == Direction.Down) {
+				 width = PointerWidth;
+				 height = LineLength + PointerLength + 1;
+			} else {
+				 height = PointerWidth;
+				 width = LineLength + PointerLength + 1;
+			}
+			
+			// Create the mask for the arrow
+			
+			Gdk.Color black, white;
+			black = new Gdk.Color (0, 0, 0);
+			black.Pixel = 1;
+			white = new Gdk.Color (255, 255, 255);
+			white.Pixel = 0;
+			
+			Gdk.Pixmap pm = new Pixmap (this.GdkWindow, width, height, 1);
+			Gdk.GC gc = new Gdk.GC (pm);
+			gc.Background = white;
+			gc.Foreground = white;
+			pm.DrawRectangle (gc, true, 0, 0, width, height);
+			
+			gc.Foreground = black;
+			pm.DrawPolygon (gc, false, arrow);
+			pm.DrawPolygon (gc, true, arrow);
+			
+			this.ShapeCombineMask (pm, 0, 0);
+			
+			Realize ();
+			
+			redgc = new Gdk.GC (GdkWindow);
+	   		redgc.RgbFgColor = new Gdk.Color (255, 0, 0);
+			
+			Resize (width, height);
+		}
+		
+		public int Width {
+			get { return width; }
+		}
+		
+		public int Height {
+			get { return height; }
+		}
+		
+		Point[] CreateArrow ()
+		{
+			Point[] ps = new Point [8];
+			ps [0] = GetPoint (0, (PointerWidth/2) - (LineWidth/2));
+			ps [1] = GetPoint (LineLength, (PointerWidth/2) - (LineWidth/2));
+			ps [2] = GetPoint (LineLength, 0);
+			ps [3] = GetPoint (PointerLength + LineLength, (PointerWidth/2));
+			ps [4] = GetPoint (LineLength, PointerWidth - 1);
+			ps [5] = GetPoint (LineLength, (PointerWidth/2) + (LineWidth/2));
+			ps [6] = GetPoint (0, (PointerWidth/2) + (LineWidth/2));
+			ps [7] = ps [0];
+			return ps;
+		}
+		
+		Point GetPoint (int x, int y)
+		{
+			switch (direction) {
+				case Direction.Right: return new Point (x, y);
+				case Direction.Left: return new Point ((PointerLength + LineLength) - x, y);
+				case Direction.Down: return new Point (y, x);
+				default: return new Point (y, (PointerLength + LineLength) - x);
+			}
+		}
+		
+		protected override bool OnExposeEvent (Gdk.EventExpose args)
+		{
+			GdkWindow.DrawPolygon (redgc, false, arrow);
+			GdkWindow.DrawPolygon (redgc, true, arrow);
+			return true;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockGrip.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockGrip.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockGrip.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,71 @@
+//
+// DockGrip.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using Gdk;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	internal class DockGrip: ToolItem
+	{
+		const int GripSize = 6;
+		const int MarginLeft = 1;
+		const int MarginRight = 3;
+		
+		public DockGrip ()
+		{
+		}
+		
+		protected override void OnSizeRequested (ref Requisition req)
+		{
+			if (Orientation == Orientation.Horizontal) {
+				req.Width = GripSize + MarginLeft + MarginRight;
+				req.Height = 0;
+			} else {
+				req.Width = 0;
+				req.Height = GripSize + MarginLeft + MarginRight;
+			}
+		}
+		
+		protected override bool OnExposeEvent (Gdk.EventExpose args)
+		{
+			Rectangle rect = Allocation;
+			if (Orientation == Orientation.Horizontal) {
+				rect.Width = GripSize;
+				rect.X += MarginLeft;
+			} else {
+				rect.Height = GripSize;
+				rect.Y += MarginLeft;
+			}
+			
+			Gtk.Style.PaintHandle (this.Style, this.ParentWindow, this.State, Gtk.ShadowType.None, args.Area, this, &quot;grip&quot;, rect.X, rect.Y, rect.Width, rect.Height, Orientation);
+			return true;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbar.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbar.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbar.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,333 @@
+//
+// DockToolbar.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using Gdk;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	public class DockToolbar: Toolbar, IDockToolbar
+	{
+		DockGrip grip;
+		DockToolbarFrame parentFrame;
+		bool dragging;
+		FloatingDock floatingDock;
+		string id;
+		string title;
+		
+		int row;
+		int offset;
+		int shiftOffset = -1;
+		
+		// Offset requested by the user. It is used to know where the
+		// toolbar is expected to move when the window is expanded.
+		int anchorOffset;	
+		
+		Animation animation;
+		DockToolbarPosition lastPosition;
+		DockToolbarStatus defaultStatus;
+		
+		int defaultSize;
+		int defaultHeight;
+		bool gotSize = false;
+		
+		public DockToolbar (string id, string title)
+		{
+			grip = new DockGrip ();
+			Add (grip);
+			this.id = id;
+			this.title = title;
+			ShowArrow = false;
+		}
+		
+		internal void SetParentFrame (DockToolbarFrame frame)
+		{
+			parentFrame = frame;
+		}
+		
+		public string Id {
+			get { return id; }
+		}
+		
+		public string Title {
+			get { return title; }
+		}
+		
+		public bool Floating {
+			get { return floatingDock != null; }
+		}
+		
+		bool IDockToolbar.Visible {
+			get { return Parent != null; }
+			set {
+				if (value == ((IDockToolbar)this).Visible)
+					return;
+					
+				if (value) {
+					if (lastPosition != null)
+						lastPosition.RestorePosition (parentFrame, this);
+					else
+						defaultStatus.Position.RestorePosition (parentFrame, this);
+				} else {
+					lastPosition = DockToolbarPosition.Create (this);
+					if (Floating) {
+						FloatingDock win = FloatingDock;
+						win.Detach ();
+						win.Destroy ();
+					}
+					else
+						DockPanel.RemoveBar (this);
+				}
+			}
+		}
+		
+		internal DockToolbarPosition Position {
+			get {
+				if (((IDockToolbar)this).Visible) return DockToolbarPosition.Create (this);
+				else if (lastPosition != null) return lastPosition;
+				else return defaultStatus.Position;
+			}
+		}
+		
+		internal DockToolbarStatus Status {
+			get {
+				return new DockToolbarStatus (id, ((IDockToolbar)this).Visible, Position);
+			}
+			set {
+				if (value.Visible) {
+					((IDockToolbar)this).Visible = false;
+					lastPosition = value.Position;
+					((IDockToolbar)this).Visible = true;
+				} else {
+					((IDockToolbar)this).Visible = false;
+					lastPosition = value.Position;
+				}
+			}
+			
+		}
+		
+		internal DockToolbarStatus DefaultStatus {
+			get { return defaultStatus; }
+			set { defaultStatus = value; }
+		}
+		
+		internal int DockRow {
+			get { return row; }
+			set { row = value; }
+		}
+		
+		internal int DockOffset {
+			get { return offset; }
+			set { offset = value; }
+		}
+		
+		internal int DockShiftOffset {
+			get { return shiftOffset; }
+			set { shiftOffset = value; }
+		}
+		
+		internal int AnchorOffset {
+			get { return anchorOffset; }
+			set { anchorOffset = value; }
+		}
+		
+		internal int DefaultSize {
+			get {
+				if (!gotSize) CalcSizes ();
+				return defaultSize;
+			}
+		}
+		
+		public int DefaultHeight {
+			get {
+				if (!gotSize) CalcSizes ();
+				return defaultHeight;
+			}
+		}
+		
+		internal void CalcSizes ()
+		{
+			// Calculates the real size of the toolbar. ShowArrow=false is
+			// needed, since SizeRequest reports 0 size requested if not.
+			
+			bool olda = ShowArrow;
+			ShowArrow = false;
+			Requisition r = SizeRequest ();
+			if (Orientation == Orientation.Horizontal) {
+				defaultSize = r.Width;
+				defaultHeight = r.Height;
+			}
+			else {
+				defaultSize = r.Height;
+				defaultHeight = r.Width;
+			}
+			
+			ShowArrow = olda;
+			gotSize = true;
+		}
+		
+		internal bool CanDockTo (DockToolbarPanel panel)
+		{
+			return true;
+		}
+		
+		internal FloatingDock FloatingDock {
+			get { return floatingDock; }
+			set { floatingDock = value; }
+		}
+		
+		internal DockToolbarPanel DockPanel {
+			get { return Parent as DockToolbarPanel; }
+		}
+		
+		internal Animation Animation {
+			get { return animation; }
+			set { animation = value; }
+		}
+		
+		protected override bool OnButtonPressEvent (EventButton e)
+		{
+			if (e.Button == 1) {
+				if (Orientation == Orientation.Horizontal &amp;&amp; e.X &lt;= 10) {
+					dragging = true;
+					parentFrame.StartDragBar (this, (int)e.X, (int)e.Y, e.Time);
+					return true;
+				}
+				else if (Orientation == Orientation.Vertical &amp;&amp; e.Y &lt;= 10) {
+					dragging = true;
+					parentFrame.StartDragBar (this, (int)e.X, (int)e.Y, e.Time);
+					return true;
+				}
+			}
+			return base.OnButtonPressEvent (e);
+		}
+		
+		protected override bool OnButtonReleaseEvent (EventButton e)
+		{
+			if (e.Button == 1 &amp;&amp; dragging) {
+				dragging = false;
+				parentFrame.EndDragBar (this, e.Time);
+			}
+			return base.OnButtonReleaseEvent (e);
+		}
+		
+		internal void ResetSize ()
+		{
+			WidthRequest = -1;
+			HeightRequest = -1;
+			ShowArrow = false;
+		}
+		
+		public int Size {
+			set {
+				if (Orientation == Orientation.Horizontal) {
+					if (value &gt;= DefaultSize)
+						WidthRequest = -1;
+					else
+						WidthRequest = value;
+				}
+				else {
+					if (value &gt;= DefaultSize)
+						HeightRequest = -1;
+					else
+						HeightRequest = value;
+					HeightRequest = value;
+				}
+			}
+			get {
+				if (Orientation == Orientation.Horizontal)
+					return SizeRequest ().Width;
+				else
+					return SizeRequest ().Height;
+			}
+		}
+		
+		public new Orientation Orientation {
+			get {
+				return base.Orientation;
+			}
+			set {
+				if (value == base.Orientation)
+					return;
+				
+				if (FloatingDock != null) {
+					// I create a new dock window because resizing the
+					// current one has lots of issues (mainly synchronization
+					// problems between the size change of the window and
+					// the toolbar).
+					
+					int x,y;
+					FloatingDock w = FloatingDock;
+					w.GetPosition (out x, out y);
+					w.Detach ();
+					
+					base.Orientation = value;
+					
+					FloatingDock fdock = new FloatingDock (parentFrame);
+					fdock.Move (x, y);
+					fdock.Attach (this);
+					w.Destroy ();
+				} else
+					base.Orientation = value;
+				gotSize = false;
+			}
+		}
+		
+		protected override void OnAdded (Widget w)
+		{
+			base.OnAdded (w);
+			gotSize = false;
+			if (DefaultSizeChanged != null)
+				DefaultSizeChanged (this, EventArgs.Empty);
+			w.Shown += new EventHandler (OnItemChange);
+			w.Hidden += new EventHandler (OnItemChange);
+		}
+		
+		protected override void OnRemoved (Widget w)
+		{
+			base.OnRemoved (w);
+			gotSize = false;
+			if (DefaultSizeChanged != null)
+				DefaultSizeChanged (this, EventArgs.Empty);
+			w.Shown -= new EventHandler (OnItemChange);
+			w.Hidden -= new EventHandler (OnItemChange);
+		}
+		
+		void OnItemChange (object o, EventArgs args)
+		{
+			// This notifies changes in the size of the toolbar
+			gotSize = false;
+			if (DefaultSizeChanged != null)
+				DefaultSizeChanged (this, EventArgs.Empty);
+		}
+		
+		internal event EventHandler DefaultSizeChanged;
+	}
+}
+

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrame.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrame.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrame.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,322 @@
+//
+// DockToolbarFrame.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using Gdk;
+using System.Collections;
+using System.Xml;
+using System.Xml.Serialization;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	public class DockToolbarFrame: EventBox
+	{
+		DockToolbarPanel[] panels;
+		DockToolbarPanel targetPanel;
+		VBox vbox;
+		VBox contentBox;
+		DockToolbar dragBar;
+		int xDragDif, yDragDif;
+		ArrayList bars = new ArrayList ();
+		
+		Hashtable layouts = new Hashtable ();
+		string currentLayout = &quot;&quot;;
+		
+		public DockToolbarFrame ()
+		{
+			vbox = new VBox ();
+			Add (vbox);
+			
+			DockToolbarPanel topPanel = new DockToolbarPanel (this, Placement.Top);
+			DockToolbarPanel bottomPanel = new DockToolbarPanel (this, Placement.Bottom);
+			DockToolbarPanel leftPanel = new DockToolbarPanel (this, Placement.Left);
+			DockToolbarPanel rightPanel = new DockToolbarPanel (this, Placement.Right);
+
+			panels = new DockToolbarPanel [4];
+			panels [(int)Placement.Top] = topPanel;
+			panels [(int)Placement.Bottom] = bottomPanel;
+			panels [(int)Placement.Left] = leftPanel;
+			panels [(int)Placement.Right] = rightPanel;
+		
+			vbox.PackStart (topPanel, false, false, 0);
+			
+			HBox hbox = new HBox ();
+			contentBox = new VBox ();
+
+			hbox.PackStart (leftPanel, false, false, 0);
+			hbox.PackStart (contentBox, true, true, 0);
+			hbox.PackStart (rightPanel, false, false, 0);
+			
+			vbox.PackStart (hbox, true, true, 0);
+			vbox.PackStart (bottomPanel, false, false, 0);
+			
+			this.Events = EventMask.ButtonPressMask | EventMask.ButtonReleaseMask | EventMask.PointerMotionMask; 
+			ShowAll ();
+		}
+		
+		public void AddContent (Widget w)
+		{
+			contentBox.PackStart (w, true, true, 0);
+		}
+		
+		public string CurrentLayout {
+			get { return currentLayout; }
+			set {
+				if (value != currentLayout) {
+					SaveCurrentLayout ();
+					RestoreLayout (value);
+				}
+			}
+		}
+		
+		public DockToolbarFrameStatus GetStatus ()
+		{
+			SaveCurrentLayout ();
+			DockToolbarFrameStatus col = new DockToolbarFrameStatus ();
+			foreach (DictionaryEntry e in layouts) {
+				DockToolbarFrameLayout ctx = new DockToolbarFrameLayout ();
+				ctx.Id = (string)e.Key;
+				ctx.Bars = (DockToolbarStatus[]) e.Value;
+				col.Status.Add (ctx);
+			}
+			return col;
+		}
+		
+		public void SetStatus (DockToolbarFrameStatus status)
+		{
+			layouts.Clear ();
+			if (status != null &amp;&amp; status.Status != null) {
+				foreach (DockToolbarFrameLayout c in status.Status)
+					layouts [c.Id] = c.Bars;
+			}
+			RestoreLayout (&quot;&quot;);
+		}
+		
+		public void SaveStatus (XmlWriter writer)
+		{
+			XmlSerializer ser = new XmlSerializer (typeof(DockToolbarFrameStatus));
+			ser.Serialize (writer, GetStatus ());
+		}
+		
+		public void LoadStatus (XmlReader reader)
+		{
+			layouts.Clear ();
+			XmlSerializer ser = new XmlSerializer (typeof(DockToolbarFrameStatus));
+			DockToolbarFrameStatus col = (DockToolbarFrameStatus) ser.Deserialize (reader);
+			SetStatus (col);
+		} 
+		
+		public IDockToolbar AddBar (DockToolbar bar)
+		{
+			return AddBar (bar, Placement.Top, true);
+		}
+		
+		public IDockToolbar AddBar (DockToolbar bar, Placement defaultPanel, bool defaultVisible)
+		{
+			bar.SetParentFrame (this);
+			bars.Add (bar);
+			
+			DockToolbarPosition pos = new DockedPosition (defaultPanel);
+			DockToolbarStatus s = new DockToolbarStatus (bar.Id, defaultVisible, pos);
+			bar.DefaultStatus = s;
+			bar.Status = s;
+			
+			return bar;
+		}
+		
+		public IDockToolbar GetBar (string id)
+		{
+			foreach (DockToolbar bar in bars)
+				if (bar.Id == id) return bar;
+			return null;
+		}
+		
+		public ICollection Toolbars {
+			get { return bars; }
+		}
+		
+		void SaveCurrentLayout ()
+		{
+			DockToolbarStatus[] status = SaveStatus ();
+			layouts [currentLayout] = status;
+		}
+		
+		void RestoreLayout (string layout)
+		{
+			DockToolbarStatus[] status = (DockToolbarStatus[]) layouts [layout];
+			RestoreStatus (status);
+			currentLayout = layout;
+		}
+		
+		DockToolbarStatus[] SaveStatus ()
+		{
+			DockToolbarStatus[] status = new DockToolbarStatus [bars.Count];
+			for (int n=0; n&lt;bars.Count; n++) {
+				DockToolbar bar = (DockToolbar) bars [n];
+				status [n] = bar.Status;
+			}
+			return status;
+		}
+		
+		void RestoreStatus (DockToolbarStatus[] status)
+		{
+			foreach (IDockToolbar b in bars)
+				b.Visible = false;
+			
+			if (status == null) {
+				foreach (DockToolbar bar in bars)
+					bar.Status = bar.DefaultStatus;
+			} else {
+				foreach (DockToolbarStatus s in status) {
+					DockToolbar bar = (DockToolbar) GetBar (s.BarId);
+					if (bar != null)
+						bar.Status = s;
+				}
+			}
+		}
+		
+		internal int DockMargin {
+			get { return 7; }
+		}
+		
+		internal void DockToolbar (DockToolbar bar, Placement placement, int offset, int row)
+		{
+			DockToolbarPanel p = GetPanel (placement);
+			if (row != -1)
+				p.AddDockToolbar (bar, offset, row);
+			else
+				p.AddDockToolbar (bar);
+		}
+		
+		internal void FloatBar (DockToolbar bar, Orientation orientation, int x, int y)
+		{
+			FloatingDock fdock = new FloatingDock (this);
+			fdock.Move (x, y);
+			bar.ResetSize ();
+			fdock.Attach (bar);
+			bar.Orientation = orientation;
+		}
+		
+		internal Gtk.Window TopWindow {
+			get {
+				Widget w = Parent;
+				while (w != null &amp;&amp; !(w is Gtk.Window))
+					w = w.Parent;
+				return (Gtk.Window) w;
+			}
+		}
+		
+		DockToolbarPanel GetPanel (Placement o)
+		{
+			return panels [(int)o];
+		}
+		
+		protected override bool OnMotionNotifyEvent (EventMotion e)
+		{
+			if (dragBar != null) {
+				int sx,sy;
+				this.GdkWindow.GetOrigin (out sx, out sy);
+				int rx = (int)e.XRoot - sx;
+				int ry = (int)e.YRoot - sy;
+				
+				if (dragBar.Floating) {
+					bool foundPanel = false;
+					dragBar.FloatingDock.Move ((int)e.XRoot + xDragDif, (int)e.YRoot + yDragDif);
+					Rectangle barRect = new Rectangle (rx + xDragDif, ry + yDragDif, dragBar.Allocation.Width, dragBar.DefaultHeight);
+					foreach (DockToolbarPanel p in panels) {
+						if (p.Allocation.IntersectsWith (barRect)) {
+							if (targetPanel != null &amp;&amp; targetPanel != p)
+								targetPanel.EndDragBar (dragBar);
+							p.Reposition (dragBar, rx, ry, xDragDif, yDragDif);
+							targetPanel = p;
+							foundPanel = true;
+							break;
+						}
+					}
+					if (!foundPanel &amp;&amp; targetPanel != null)
+						targetPanel.EndDragBar (dragBar);
+				} else {
+					DockToolbarPanel panel = (DockToolbarPanel) dragBar.Parent;
+					panel.Reposition (dragBar, rx, ry, xDragDif, yDragDif);
+				}
+			}
+			return base.OnMotionNotifyEvent (e);
+		}
+		
+		internal void StartDragBar (DockToolbar bar, int x, int y, uint time)
+		{
+			dragBar = bar;
+			xDragDif = -x;
+			yDragDif = -y;
+			Pointer.Grab (this.GdkWindow, false, EventMask.ButtonPressMask | EventMask.ButtonReleaseMask | EventMask.PointerMotionMask, null, new Cursor (CursorType.Hand2), time);
+			if (!bar.Floating) {
+				DockToolbarPanel panel = (DockToolbarPanel) dragBar.Parent;
+				panel.StartDragBar (bar);
+			}
+		}
+		
+		internal void EndDragBar (DockToolbar bar, uint time)
+		{
+			Pointer.Ungrab (time);
+			if (targetPanel != null) {
+				targetPanel.DropDragBar (bar);
+				targetPanel.EndDragBar (bar);
+			}
+			dragBar = null;
+		}
+		
+		protected override bool OnButtonReleaseEvent (EventButton e)
+		{
+			if (dragBar != null)
+				EndDragBar (dragBar, e.Time);
+
+			return base.OnButtonReleaseEvent (e);
+		}
+		
+		protected override bool OnButtonPressEvent (Gdk.EventButton e)
+		{
+			if (e.Button == 3) {
+				int sx,sy;
+				this.GdkWindow.GetOrigin (out sx, out sy);
+				int rx = (int)e.XRoot - sx;
+				int ry = (int)e.YRoot - sy;
+				
+				foreach (DockToolbarPanel p in panels) {
+					if (p.Allocation.Contains (rx, ry))
+						OnPanelClick (e, p.Placement);
+				}
+			}
+			return base.OnButtonPressEvent (e);
+		}
+		
+		protected virtual void OnPanelClick (Gdk.EventButton e, Placement placement)
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrameLayout.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrameLayout.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrameLayout.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,42 @@
+//
+// DockToolbarFrameLayout.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml.Serialization;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	public class DockToolbarFrameLayout
+	{
+		[XmlAttribute (&quot;id&quot;)]
+		public string Id;
+		
+		[XmlElement (&quot;dockbar&quot;)]
+		public DockToolbarStatus[] Bars;
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrameStatus.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrameStatus.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarFrameStatus.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,40 @@
+//
+// DockToolbarFrameStatus.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.Xml.Serialization;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	public class DockToolbarFrameStatus
+	{
+		[XmlElement (&quot;layout&quot;, typeof(DockToolbarFrameLayout))]
+		public ArrayList Status = new ArrayList ();
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarPanel.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarPanel.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,924 @@
+//
+// DockToolbarPanel.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using Gdk;
+using System.Collections;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	internal class DockToolbarPanel: FixedPanel
+	{
+		DockToolbarFrame parentFrame;
+		ArrayList bars = new ArrayList ();
+		Orientation orientation;
+		
+		ArrowWindow placeholderArrow1;
+		ArrowWindow placeholderArrow2;
+		PlaceholderWindow placeholder;
+		bool currentPlaceholderHorz;
+		
+		int dropOffset;
+		int dropRow = -1;
+		bool dropNewRow;
+		bool enableAnimations = true;
+		
+		public DockToolbarPanel (DockToolbarFrame parentFrame, Placement placement)
+		{
+	//		ResizeMode = ResizeMode.Immediate;
+			Placement = placement;
+			switch (placement) {
+				case Placement.Top:
+					this.orientation = Orientation.Horizontal;
+					break;
+				case Placement.Bottom:
+					this.orientation = Orientation.Horizontal;
+					break;
+				case Placement.Left:
+					this.orientation = Orientation.Vertical;
+					break;
+				case Placement.Right:
+					this.orientation = Orientation.Vertical;
+					break;
+			}
+			
+			this.parentFrame = parentFrame;
+		}
+		
+		public Orientation Orientation {
+			get { return orientation; }
+		}
+		
+		public void AddDockToolbar (DockToolbar bar)
+		{
+			bool ea = EnableAnimation (false);
+
+			Put (bar, 0, 0);
+			bar.Orientation = orientation;
+			
+			if (bars.Count &gt; 0 &amp;&amp; IsRealized) {
+				DockToolbar last = (DockToolbar) bars [bars.Count - 1];
+				int width = bar.DefaultSize;
+				int lastx = last.DockOffset + last.DefaultSize;
+				
+				if (lastx + width &lt;= PanelWidth)
+					MoveBar (bar, lastx, last.DockRow, false);
+				else
+					MoveBar (bar, 0, last.DockRow + 1, false);
+				bar.AnchorOffset = bar.DockOffset;
+				InternalAdd (bar);
+				SortBars ();
+			} else {
+				MoveBar (bar, 0, 0);
+				bar.AnchorOffset = bar.DockOffset;
+				InternalAdd (bar);
+			}
+
+			EnableAnimation (ea);
+		}
+		
+		public void AddDockToolbar (DockToolbar bar, int offset, int row)
+		{
+			bool ea = EnableAnimation (false);
+			InternalAdd (bar);
+			Put (bar, 0, 0);
+			bar.Orientation = orientation;
+			MoveBar (bar, offset, row, false);
+			bar.AnchorOffset = offset;
+			SortBars ();
+			PackBars ();
+			EnableAnimation (ea);
+		}
+		
+		void InternalAdd (DockToolbar bar)
+		{
+			bars.Add (bar);
+			bar.DefaultSizeChanged += new EventHandler (OnBarSizeChanged);
+		}
+		
+		public void RemoveBar (DockToolbar bar)
+		{
+			if (IsSingleBarRow (bar))
+				RemoveRow (bar.DockRow);
+		
+			Remove (bar);
+			bars.Remove (bar);
+			bar.DefaultSizeChanged -= new EventHandler (OnBarSizeChanged);
+			
+			UpdateRowHeight (bar.DockRow);
+			PackBars ();
+		}
+		
+		protected override void OnRealized ()
+		{
+			base.OnRealized ();
+			bool ea = EnableAnimation (false);
+			ResetBarPositions ();
+			EnableAnimation (ea);
+		}
+
+		public void ResetBarPositions ()
+		{
+			int x=0, row=0;
+			int width = PanelWidth;
+			
+			foreach (DockToolbar b in bars) {
+				int barw = GetChildWidth (b);
+				if (x + barw &lt; width)
+					MoveBar (b, x, row);
+				else {
+					row++;
+					x = 0;
+					MoveBar (b, 0, row);
+				}
+				x += barw;
+			}
+			SortBars ();
+
+		}
+		
+		void SetPlaceholder (DockToolbar bar, int offset, int row)
+		{
+			if (dropRow != row &amp;&amp; dropRow != -1)
+				RestoreShiftedBars (dropRow);
+
+			ShowPlaceholder (bar, false, offset, GetRowTop (row), GetChildWidth (bar), GetRowSize (row));
+
+			dropOffset = offset;
+			dropRow = row;
+			dropNewRow = false;
+		}
+		
+		void SetNewRowPlaceholder (DockToolbar bar, int offset, int toprow)
+		{
+			if (dropRow != -1)
+				RestoreShiftedBars (dropRow);
+			
+			int y = GetRowTop (toprow) - parentFrame.DockMargin;
+			int h = parentFrame.DockMargin * 2;
+			ShowPlaceholder (bar, true, offset, y, GetChildWidth (bar), h);
+			
+			dropOffset = offset;
+			dropRow = toprow;
+			dropNewRow = true;
+		}
+		
+		void ShowPlaceholder (DockToolbar bar, bool horz, int x, int y, int w, int h)
+		{
+			if (orientation != Orientation.Horizontal)
+				horz = !horz;
+			
+			PanelToWindow (x, y, w, h, out x, out y, out w, out h);
+			
+			bool created = false;
+			
+			if (placeholder == null || horz != currentPlaceholderHorz) {
+				HidePlaceholder ();
+				placeholder = new PlaceholderWindow (parentFrame);
+				placeholderArrow1 = new ArrowWindow (parentFrame, horz ? ArrowWindow.Direction.Right : ArrowWindow.Direction.Down);
+				placeholderArrow2 = new ArrowWindow (parentFrame, horz ? ArrowWindow.Direction.Left : ArrowWindow.Direction.Up);
+				currentPlaceholderHorz = horz;
+				created = true;
+			}
+			
+			int sx, sy;
+			this.GdkWindow.GetOrigin (out sx, out sy);
+			sx += x;
+			sy += y;
+			
+			int mg = -4;
+			placeholder.Move (sx - mg, sy - mg);
+			placeholder.Resize (w + mg*2, h + mg * 2);
+			
+			if (horz) {
+				placeholderArrow1.Move (sx - placeholderArrow1.Width, sy + (h/2) - placeholderArrow1.Height/2);
+				placeholderArrow2.Move (sx + w, sy + (h/2) - placeholderArrow1.Height/2);
+			} else {
+				int px = sx + w/2 - placeholderArrow1.Width/2;
+				if (px &lt; 0) px = 0;
+				placeholderArrow1.Move (px, sy - placeholderArrow1.Height);
+				placeholderArrow2.Move (px, sy + h);
+			}
+			
+			if (created) {
+				placeholder.Show ();
+				placeholder.Present ();
+				if (bar.FloatingDock != null)
+					bar.FloatingDock.Present ();
+				placeholderArrow1.Present ();
+				placeholderArrow2.Present ();
+			}
+		}
+		
+		void HidePlaceholder ()
+		{
+			if (placeholder == null) return;
+			placeholder.Destroy ();
+			placeholder = null;
+			placeholderArrow1.Destroy ();
+			placeholderArrow1 = null;
+			placeholderArrow2.Destroy ();
+			placeholderArrow2 = null;
+
+			if (dropRow != -1 &amp;&amp; !dropNewRow) {
+				RestoreShiftedBars (dropRow);
+				dropRow = -1;
+			}
+		}
+		
+		bool IsPlaceHolderVisible {
+			get { return placeholder != null; }
+		}
+		
+		public void StartDragBar (DockToolbar bar)
+		{
+		}
+		
+		public void DropDragBar (DockToolbar bar)
+		{
+			if (!IsPlaceHolderVisible) return;
+			
+			foreach (DockToolbar b in bars) {
+				if (b.DockRow == dropRow &amp;&amp; b.DockShiftOffset != -1) {
+					b.DockShiftOffset = -1;
+					b.AnchorOffset = b.DockRow;
+				}
+			}
+			
+			if (dropRow != -1) {
+				if (dropNewRow)
+					InsertRow (bar, dropOffset, dropRow);
+				else {
+					MoveBar (bar, dropOffset, dropRow);
+					UpdateRowHeight (dropRow);
+				}
+				SortBars ();
+				dropRow = -1;
+			}
+		}
+		
+		public void EndDragBar (DockToolbar bar)
+		{
+			if (IsPlaceHolderVisible) {
+				HidePlaceholder ();
+			}
+		}
+		
+		void RestoreShiftedBars (int row)
+		{
+			foreach (DockToolbar b in bars) {
+				if (b.DockRow == row &amp;&amp; b.DockShiftOffset != -1) {
+					MoveBar (b, b.DockShiftOffset, b.DockRow, false);
+					b.DockShiftOffset = -1;
+				}
+			}
+		}
+		
+		public void Reposition (DockToolbar bar, int xcursor, int ycursor, int difx, int dify)
+		{
+			if (!bar.CanDockTo (this))
+				return;
+
+			bar.Orientation = orientation;
+			
+			int x, y;
+			WindowToPanel (xcursor + difx, ycursor + dify, bar.Allocation.Width, bar.Allocation.Height, out x, out y);
+			WindowToPanel (xcursor, ycursor, 0, 0, out xcursor, out ycursor);
+			
+			RepositionInternal (bar, x, y, xcursor, ycursor);
+		}
+		
+		void RepositionInternal (DockToolbar bar, int x, int y, int xcursor, int ycursor)
+		{
+			int width = GetChildWidth (bar);
+			
+			ycursor = y + bar.DefaultHeight / 2;
+			
+			if (bars.Count == 0 &amp;&amp; bar.Floating) {
+				SetNewRowPlaceholder (bar, x, 0);
+				return;
+			}
+			
+			int dx = (x + width) - PanelWidth;
+			if (dx &gt; parentFrame.DockMargin &amp;&amp; !bar.Floating) {
+				HidePlaceholder ();
+				FloatBar (bar, x, y);
+				return;
+			}
+			else if (dx &gt; 0)
+				x -= dx;
+			else if (x &lt; -parentFrame.DockMargin &amp;&amp; !bar.Floating) {
+				HidePlaceholder ();
+				FloatBar (bar, x, y);
+				return;
+			}
+			else if (x &lt; 0)
+				x = 0;
+
+			int nx = x;
+			int row = -1;
+			
+			// Get the old bar y position
+			 
+			int panelBottom = GetPanelBottom ();
+				
+			if (ycursor &lt; - parentFrame.DockMargin || ycursor &gt; panelBottom + parentFrame.DockMargin) {
+				HidePlaceholder ();
+				FloatBar (bar, x, y);
+				return;
+			}
+			
+			int rtop = 0;
+			int prevtop = 0;
+			row = 0;
+			while (ycursor &gt;= rtop) {
+				prevtop = rtop;
+				row++;
+				if (rtop &gt;= panelBottom) break;
+				rtop += GetRowSize (row - 1);
+			}
+			
+			row--;
+			int ry = ycursor - prevtop;
+			
+			if (ry &lt;= parentFrame.DockMargin &amp;&amp; ry &gt;= 0) {
+				SetNewRowPlaceholder (bar, x, row);
+				FloatBar (bar, x, y);
+				return;
+			} else if (ry &gt;= (GetRowSize(row) - parentFrame.DockMargin) || (ry &lt; 0 &amp;&amp; -ry &lt; parentFrame.DockMargin)) {
+				SetNewRowPlaceholder (bar, x, row + 1);
+				FloatBar (bar, x, y);
+				return;
+			}
+			
+			// Can't create a new row. Try to fit the bar in the current row
+			// Find the first bar in the row:
+			
+			int ns = -1;
+			for (int n=0; n&lt;bars.Count; n++) {
+				DockToolbar b = (DockToolbar)bars[n];
+				
+				// Ignore the bar being moved
+				if (b == bar) continue;
+				
+				if (b.DockRow == row) {
+					ns = n;
+					break;
+				}
+			}
+			
+			if (ns == -1) {
+				// There are no other bars, no problem then
+				if (bar.Floating) {
+					SetPlaceholder (bar, nx, row);
+					return;
+				}
+
+				if ((nx == bar.DockOffset &amp;&amp; row == bar.DockRow) || (row != bar.DockRow)) {
+					SetPlaceholder (bar, nx, row);
+					FloatBar (bar, x, y);
+					return;
+				}
+				
+				HidePlaceholder ();
+				MoveBar (bar, nx, row);
+				return;
+			}
+			
+			// Compute the available space, and find the bars at the
+			// left and the right of the bar being moved
+			
+			int gapsTotal = 0;
+			int lastx = 0;
+			int leftIndex=-1, rightIndex = -1;
+			int gapsLeft = 0, gapsRight = 0;
+			
+			for (int n=ns; n&lt;bars.Count; n++) {
+				DockToolbar b = (DockToolbar)bars[n];
+				
+				// Ignore the bar being moved
+				if (b == bar) continue;
+
+				if (b.DockRow != row) break;
+				int bx = b.DockOffset;
+				
+				if (bx &gt; x &amp;&amp; (rightIndex == -1))
+					rightIndex = n;
+				else if (bx &lt;= x)
+					leftIndex = n;
+				
+				if (bx &lt; x)
+					gapsLeft += bx - lastx;
+				else {
+					if (lastx &lt; x) {
+						gapsLeft += x - lastx;
+						gapsRight += bx - x;
+					} else
+						gapsRight += bx - lastx;
+				}
+				
+				gapsTotal += bx - lastx;
+				lastx = GetChildRightOffset (b); 
+			}
+
+			if (lastx &lt; x) {
+				gapsLeft += x - lastx;
+				gapsRight += PanelWidth - x;
+			} else {
+				gapsRight += PanelWidth - lastx;
+			}
+			
+			gapsTotal += PanelWidth - lastx;
+			
+			// Is there room for the bar? 
+			if (gapsTotal &lt; width) {
+				HidePlaceholder ();
+				FloatBar (bar, x, y);
+				return;
+			}
+			
+			// Shift the bars at the left and the right
+			
+			int oversizeLeft = 0;
+			int oversizeRight = 0;
+			
+			if (leftIndex != -1) {
+				int r = GetChildRightOffset ((DockToolbar) bars [leftIndex]);
+				oversizeLeft = r - nx;
+			}
+			
+			if (rightIndex != -1) {
+				int r = ((DockToolbar) bars [rightIndex]).DockOffset;
+				oversizeRight = (nx + width) - r;
+			}
+			
+			if (oversizeLeft &gt; gapsLeft)
+				oversizeRight += (oversizeLeft - gapsLeft);
+			else if (oversizeRight &gt; gapsRight)
+				oversizeLeft += (oversizeRight - gapsRight);
+			
+			if (leftIndex != -1 &amp;&amp; oversizeLeft &gt; 0) {
+				ShiftBar (leftIndex, -oversizeLeft);
+				nx = GetChildRightOffset ((DockToolbar) bars [leftIndex]);
+			}
+			
+			if (rightIndex != -1 &amp;&amp; oversizeRight &gt; 0) {
+				ShiftBar (rightIndex, oversizeRight);
+				nx = ((DockToolbar) bars [rightIndex]).DockOffset - width;
+			}
+			
+			
+			if (bar.Floating) {
+				SetPlaceholder (bar, nx, row);
+				return;
+			}
+
+			if ((nx == bar.DockOffset &amp;&amp; row == bar.DockRow) || (row != bar.DockRow)) {
+				if (bar.Floating) {
+					SetPlaceholder (bar, nx, row);
+					FloatBar (bar, x, y);
+				}
+				return;
+			}
+			
+			HidePlaceholder ();
+			MoveBar (bar, nx, row);
+		}
+		
+		void FloatBar (DockToolbar bar, int x, int y)
+		{
+			if (bar.Floating) return;
+			
+			int wx,wy,w,h;
+			PanelToWindow (x, y, GetChildWidth (bar), bar.DefaultHeight, out x, out y, out w, out h);
+				
+			this.GdkWindow.GetOrigin (out wx, out wy);
+			RemoveBar (bar);
+			parentFrame.FloatBar (bar, orientation, wx + x, wy + y);
+		}
+		
+		void ShiftBar (int index, int size)
+		{
+			DockToolbar bar = (DockToolbar) bars [index];
+			if (bar.DockShiftOffset == -1)
+				bar.DockShiftOffset = bar.DockOffset;
+			
+			if (size &gt; 0) {
+				int rp = GetChildRightOffset (bar);
+				int gap = PanelWidth - rp;
+				if (index + 1 &lt; bars.Count) {
+					DockToolbar obar = (DockToolbar) bars [index + 1];
+					if (bar.DockRow == obar.DockRow) {
+						gap = obar.DockOffset - rp;
+						if (gap &lt; size) {
+							ShiftBar (index + 1, size - gap);
+							gap = obar.DockOffset - rp;
+						}
+					}
+				}
+				if (gap &gt; size)
+					gap = size;
+				if (gap &gt; 0)
+					MoveBar (bar, bar.DockOffset + gap, bar.DockRow, false);
+			} else {
+				size = -size;
+				int lp = bar.DockOffset;
+				int gap = lp;
+				if (index &gt; 0) {
+					DockToolbar obar = (DockToolbar) bars [index - 1];
+					if (bar.DockRow == obar.DockRow) {
+						gap = lp - GetChildRightOffset (obar);
+						if (gap &lt; size) {
+							ShiftBar (index - 1, gap - size);
+							gap = lp - GetChildRightOffset (obar);
+						}
+					}
+				}
+				
+				if (gap &gt; size)
+					gap = size;
+				if (gap &gt; 0)
+					MoveBar (bar, bar.DockOffset - gap, bar.DockRow, false);
+			}
+		}
+		
+		void MoveBar (DockToolbar bar, int x, int row)
+		{
+			MoveBar (bar, x, row, true);
+		}
+		
+		void MoveBar (DockToolbar bar, int x, int row, bool setAnchorOffset)
+		{
+			int rt = GetRowTop (row);
+
+			bar.DockRow = row;
+			bar.DockOffset = x;
+			
+			if (bar.Floating) {
+				FloatingDock win = bar.FloatingDock;
+				win.Detach ();
+				win.Destroy ();
+				
+				InternalAdd (bar);
+				Put (bar, x, rt);
+				SortBars ();
+				ResetAnchorOffsets (row);
+				
+			} else {
+				if (setAnchorOffset)
+					ResetAnchorOffsets (row);
+
+				InternalMove (bar, x, rt, true);
+			}
+		}
+		
+		void ResetAnchorOffsets (int row)
+		{
+			for (int n=0; n&lt;bars.Count; n++) {
+				DockToolbar b = (DockToolbar) bars [n];
+				if (b.DockRow &lt; row) continue;
+				if (b.DockRow &gt; row) return;
+				b.AnchorOffset = b.DockOffset;
+			}
+		}
+		
+		void UpdateRowHeight (int row)
+		{
+			int nr = row + 1;
+			bool ea = EnableAnimation (false);
+			for (int n=0; n&lt;bars.Count; n++) {
+				DockToolbar b = (DockToolbar) bars [n];
+				if (b.DockRow &lt; nr) continue;
+				MoveBar (b, b.DockOffset, b.DockRow);
+			}
+			EnableAnimation (ea);
+		}
+		
+		void OnBarSizeChanged (object s, EventArgs e)
+		{
+			UpdateRowSizes (((DockToolbar)s).DockRow);
+		}
+		
+		void UpdateRowSizes (int row)
+		{
+			int lastx = 0;
+			for (int n=0; n&lt;bars.Count; n++) {
+				DockToolbar b = (DockToolbar) bars [n];
+				if (b.DockRow &lt; row) continue;
+				if (b.DockRow &gt; row) break;
+				if (b.AnchorOffset &lt; lastx)
+					b.AnchorOffset = lastx;
+				lastx = b.AnchorOffset + b.DefaultSize;
+			}
+			PackBars ();
+		}
+		
+		protected override void OnSizeAllocated (Rectangle rect)
+		{
+			Rectangle oldRect = Allocation;
+			base.OnSizeAllocated (rect);
+			
+			if (!rect.Equals (oldRect))
+				PackBars ();
+		}
+		
+		void PackBars ()
+		{
+			bool ea = EnableAnimation (false);
+			int n=0;
+			while (n &lt; bars.Count)
+				n = PackRow (n);
+			EnableAnimation (ea);
+		}
+		
+		int PackRow (int sn)
+		{
+			int n = sn;
+			int row = ((DockToolbar)bars[n]).DockRow;
+			int lastx = 0;
+			int gaps = 0;
+
+			while (n &lt; bars.Count) {
+				DockToolbar bar = (DockToolbar) bars [n];
+				if (bar.DockRow != row) break;
+				
+				if (bar.AnchorOffset &gt; lastx)
+					gaps += bar.AnchorOffset - lastx;
+				
+				lastx = bar.AnchorOffset + bar.DefaultSize;
+				n++;
+			}
+
+			if (lastx &lt;= PanelWidth) {
+				for (int i=sn; i&lt;n; i++) {
+					DockToolbar b = (DockToolbar) bars[i];
+					if (b.AnchorOffset != b.DockOffset)
+						MoveBar (b, b.AnchorOffset, b.DockRow, false);
+					if (b.Size != b.DefaultSize) {
+						b.ShowArrow = false;
+						b.Size = b.DefaultSize;
+					}
+				}
+				return n;
+			}
+			
+			int barsSize = lastx - gaps;
+			double barShrink = 1;
+			double gapShrink = 0;
+			
+			if (barsSize &gt; PanelWidth)
+				barShrink = (double)PanelWidth / (double)barsSize;
+			else
+				gapShrink = ((double)(PanelWidth - barsSize)) / (double)gaps;
+			
+			lastx = 0;
+			int newlastx = 0;
+			for (int i=sn; i &lt; n; i++) {
+				DockToolbar bar = (DockToolbar) bars [i];
+				int gap = bar.AnchorOffset - lastx;
+				lastx = bar.AnchorOffset + bar.DefaultSize;
+				
+				int nx = (int)(newlastx + ((double)gap * gapShrink));
+				if (nx != bar.DockOffset)
+					MoveBar (bar, nx, bar.DockRow, false);
+				
+				int nw = (int)((double)bar.DefaultSize * barShrink);
+				if (nw != bar.Size) {
+					bar.ShowArrow = nw != bar.DefaultSize;
+					bar.Size = nw;
+				}
+				newlastx = bar.DockOffset + nw;
+			}
+			
+			return n;
+		}
+		
+		int GetPanelBottom ()
+		{
+			if (bars.Count &gt; 0) {
+				DockToolbar bar = (DockToolbar) bars [bars.Count - 1];
+				return GetRowTop (bar.DockRow + 1);
+			}
+			else
+				return 0;
+		} 
+		
+		bool IsSingleBarRow (DockToolbar bar)
+		{
+			int row = bar.DockRow;
+			foreach (DockToolbar b in bars) {
+				if (bar != b &amp;&amp; b.DockRow == row)
+					return false;
+			}
+			return true;
+		}
+		
+		void InsertRow (DockToolbar ibar, int offset, int row)
+		{
+			MoveBar (ibar, offset, row);
+			foreach (DockToolbar bar in bars) {
+				if (ibar != bar &amp;&amp; bar.DockRow &gt;= row)
+					bar.DockRow++;
+			}
+			SortBars ();
+			UpdateRowHeight (row);
+		}
+		
+		void RemoveRow (int row)
+		{
+			foreach (DockToolbar bar in bars) {
+				if (bar.DockRow &gt;= row)
+					MoveBar (bar, bar.DockOffset, bar.DockRow - 1, false);
+			}
+		}
+		
+		int GetChildRightOffset (DockToolbar bar)
+		{
+			return bar.DockOffset + bar.Size;
+		}
+		
+		int GetRowSize (int row)
+		{
+			int max = 0;
+			for (int n=0; n&lt;bars.Count; n++) {
+				DockToolbar b = (DockToolbar) bars [n];
+				if (b.DockRow &lt; row) continue;
+				if (b.DockRow &gt; row) return max;
+				if (b.DefaultHeight &gt; max)
+					max = b.DefaultHeight;
+			}
+			return max;
+		}
+		
+		int GetRowTop (int row)
+		{
+			int t = 0;
+			for (int n=0; n &lt; row; n++)
+				t += GetRowSize (n);
+			return t;
+		}
+		
+		void SortBars ()
+		{
+			bars.Sort (DocBarComparer.Instance);
+		}
+		
+		void InternalMove (DockToolbar bar, int x, int y, bool animate)
+		{
+			if (bar.Animation != null) {
+				bar.Animation.Cancel ();
+				bar.Animation = null;
+			}
+			
+			if (animate &amp;&amp; enableAnimations) {
+				bar.Animation = new MoveAnimation (this, bar, x, y);
+				bar.Animation.Start ();
+			}
+			else
+				Move (bar, x, y);
+		}
+		
+		bool EnableAnimation (bool enable)
+		{
+			bool r = enableAnimations;
+			enableAnimations = enable;
+			return r;
+		}
+	}
+
+
+	internal class DocBarComparer: IComparer
+	{
+		internal static DocBarComparer Instance = new DocBarComparer (); 
+		
+		public int Compare (object a, object b)
+		{
+			DockToolbar b1 = (DockToolbar) a;
+			DockToolbar b2 = (DockToolbar) b;
+
+			if (b1.DockRow &lt; b2.DockRow) return -1;
+			else if (b1.DockRow &gt; b2.DockRow) return 1;
+			else if (b1.DockOffset &lt; b2.DockOffset) return -1;
+			else if (b1.DockOffset &gt; b2.DockOffset) return 1;
+			else return 0;
+		} 
+	}
+
+	internal abstract class AnimationManager
+	{
+		static ArrayList anims = new ArrayList ();
+		static int s = 0;
+		
+		public static void Animate (Animation a)
+		{
+			if (anims.Count == 0)
+				GLib.Timeout.Add (10, new GLib.TimeoutHandler (Animate));
+			anims.Add (a);
+		}
+		
+		public static void CancelAnimation (Animation a)
+		{
+			anims.Remove (a);
+		}
+		
+		public static bool Animate ()
+		{
+			s++;
+			ArrayList toDelete = new ArrayList ();
+			foreach (Animation a in anims)
+				if (!a.Run ())
+					toDelete.Add (a);
+			
+			foreach (object ob in toDelete)
+				anims.Remove (ob);
+
+			return anims.Count != 0;
+		}
+	}
+
+	internal abstract class Animation
+	{
+		protected Widget widget;
+		
+		public Animation (Widget w)
+		{
+			widget = w;
+		}
+		
+		public void Start ()
+		{
+			AnimationManager.Animate (this);
+		}
+		
+		public void Cancel ()
+		{
+			AnimationManager.CancelAnimation (this);
+		}
+		
+		internal protected abstract bool Run ();
+	}
+
+	internal class MoveAnimation: Animation
+	{
+		FixedPanel panel;
+		float destx, desty;
+		float curx, cury;
+		
+		public MoveAnimation (FixedPanel f, Widget w, int destx, int desty): base (w)
+		{
+			panel = f;
+			int x, y;
+			f.GetPosition (w, out x, out y);
+			curx = (float)x;
+			cury = (float)y;
+			this.destx = (float) destx;
+			this.desty = (float) desty;
+		}
+		
+		internal protected override bool Run ()
+		{
+			float dx = destx - curx;
+			float dy = desty - cury;
+			
+			dx = dx / 4;
+			dy = dy / 4;
+			
+			curx += dx;
+			cury += dy;
+			
+			panel.Move (widget, (int)curx, (int)cury);
+			
+			if(Math.Abs (dx) &lt; 0.1 &amp;&amp; Math.Abs (dy) &lt; 0.1) {
+				panel.Move (widget, (int)destx, (int)desty);
+				return false;
+			} else
+				return true;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarPosition.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarPosition.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarPosition.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,52 @@
+//
+// DockToolbarPosition.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using Gdk;
+using System.Collections;
+using System.Xml;
+using System.Xml.Serialization;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	[XmlInclude (typeof(DockedPosition))]
+	[XmlInclude (typeof(FloatingPosition))]
+	public class DockToolbarPosition
+	{
+		internal virtual void RestorePosition (DockToolbarFrame frame, DockToolbar bar) {}
+		
+		internal static DockToolbarPosition Create (DockToolbar bar)
+		{
+			if (bar.Floating)
+				return new FloatingPosition (bar);
+			else
+				return new DockedPosition (bar);
+		} 
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarStatus.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarStatus.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockToolbarStatus.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,71 @@
+//
+// DockToolbarStatus.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml.Serialization;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	[XmlType (&quot;dockBar&quot;)]
+	public class DockToolbarStatus
+	{
+		bool visible;
+		DockToolbarPosition position;
+		string id;
+		
+		public DockToolbarStatus ()
+		{
+		}
+		
+		public DockToolbarStatus (string id, bool visible, DockToolbarPosition position)
+		{
+			this.visible = visible;
+			this.position = position;
+			this.id = id;
+		}
+		
+		[XmlAttribute (&quot;id&quot;)]
+		public string BarId {
+			get { return id; }
+			set { id = value; }
+		}
+
+		[XmlElement (&quot;visible&quot;)]
+		public bool Visible {
+			get { return visible; }
+			set { visible = value; }
+		}
+		
+		[XmlElement (&quot;dockedPosition&quot;, typeof(DockedPosition))]
+		[XmlElement (&quot;floatingPosition&quot;, typeof(FloatingPosition))]
+		public DockToolbarPosition Position {
+			get { return position; }
+			set { position = value; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockedPosition.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockedPosition.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/DockedPosition.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,81 @@
+//
+// DockedPosition.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml.Serialization;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	[XmlType (&quot;dockedPosition&quot;)]
+	public class DockedPosition: DockToolbarPosition
+	{
+		Placement placement;
+		int dockOffset;
+		int dockRow;
+		
+		public DockedPosition ()
+		{
+		}
+		
+		internal DockedPosition (DockToolbar bar)
+		{
+			dockOffset = bar.AnchorOffset;
+			dockRow = bar.DockRow;
+			placement = ((DockToolbarPanel)bar.Parent).Placement;
+		}
+		
+		internal DockedPosition (Placement placement)
+		{
+			this.placement = placement;
+			dockRow = -1;
+		}
+		
+		[XmlAttribute (&quot;offset&quot;)]
+		public int DockOffset {
+			get { return dockOffset; }
+			set { dockOffset = value; }
+		}
+		
+		[XmlAttribute (&quot;row&quot;)]
+		public int DockRow {
+			get { return dockRow; }
+			set { dockRow = value; }
+		}
+		
+		[XmlAttribute (&quot;placement&quot;)]
+		public Placement Placement {
+			get { return placement; }
+			set { placement = value; }
+		}
+		
+		internal override void RestorePosition (DockToolbarFrame frame, DockToolbar bar)
+		{
+			frame.DockToolbar (bar, placement, dockOffset, dockRow);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FixedPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FixedPanel.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FixedPanel.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,262 @@
+//
+// FixedPanel.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using Gtk;
+using Gdk;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	public enum Placement
+	{
+		Top, Bottom, Left, Right
+	}
+
+	public class FixedPanel: Container
+	{
+		ArrayList widgets = new ArrayList ();
+		Placement placement = Placement.Top;
+		
+		public FixedPanel ()
+		{
+			WidgetFlags |= WidgetFlags.NoWindow;
+		}
+		
+		public Placement Placement {
+			get { return placement; }
+			set { placement = value; }
+		}
+		
+		public override GLib.GType ChildType ()
+		{
+			return Widget.GType;
+		}
+		
+		public void Put (Widget w, int x, int y)
+		{
+			WidgetPosition wpos = new WidgetPosition ();
+			wpos.X = x;
+			wpos.Y = y;
+			wpos.Widget = w;
+			widgets.Add (wpos);
+			w.Parent = this;
+			QueueResize ();
+		}
+		
+		public void Move (Widget w, int x, int y)
+		{
+			int n = GetWidgetPosition (w);
+			if (n != -1) {
+				WidgetPosition wpos = (WidgetPosition) widgets [n];
+				if (wpos.X == x &amp;&amp; wpos.Y == y) return; 
+				wpos.X = x;
+				wpos.Y = y;
+				QueueResize ();
+			}
+		}
+		
+		public bool GetPosition (Widget w, out int x, out int y)
+		{
+			int n = GetWidgetPosition (w);
+			if (n != -1) {
+				WidgetPosition wpos = (WidgetPosition) widgets [n];
+				x = wpos.X;
+				y = wpos.Y;
+				return true;
+			}
+			x = y = 0;
+			return false;
+		}
+		
+		public int GetChildWidth (Widget w)
+		{
+	//		ResizeChildren ();
+			if (placement == Placement.Top || placement == Placement.Bottom)
+				return w.Allocation.Width;
+			else
+				return w.Allocation.Height;
+		}
+		
+		public int GetChildHeight (Widget w)
+		{
+			if (placement == Placement.Top || placement == Placement.Bottom)
+				return w.Allocation.Height;
+			else
+				return w.Allocation.Width;
+		}
+		
+		public int PanelWidth {
+			get {
+				if (placement == Placement.Top || placement == Placement.Bottom)
+					return Allocation.Width;
+				else
+					return Allocation.Height;
+			}
+		}
+		
+		public void WindowToPanel (int x, int y, int w, int h, out int rx, out int ry)
+		{
+			switch (placement) {
+				case Placement.Top:
+					rx = x - Allocation.X;
+					ry = y - Allocation.Y;
+					break;
+				case Placement.Bottom:
+					rx = x - Allocation.X;
+					ry = Allocation.Bottom - y - h - 1;
+					break;
+				case Placement.Left:
+					rx = y - Allocation.Y;
+					ry = x - Allocation.X;
+					break;
+				default:
+					rx = y - Allocation.Y;
+					ry = Allocation.Right - x - w - 1;
+					break;
+			}
+		}
+		
+		public void PanelToWindow (int x, int y, int w, int h, out int rx, out int ry, out int rw, out int rh)
+		{
+			switch (placement) {
+				case Placement.Top:
+					rx = x + Allocation.X;
+					ry = y + Allocation.Y;
+					rw = w;
+					rh = h;
+					break;
+				case Placement.Bottom:
+					rx = x + Allocation.X;
+					ry = Allocation.Bottom - y - h - 1;
+					rw = w;
+					rh = h;
+					break;
+				case Placement.Left:
+					rx = y + Allocation.X;
+					ry = x + Allocation.Y;
+					rw = h;
+					rh = w;
+					break;
+				default:
+					rx = Allocation.Right - y - h - 1;
+					ry = x + Allocation.Y;
+					rw = h;
+					rh = w;
+					break;
+			}
+		}
+		
+		protected override void OnAdded (Widget w)
+		{
+			Put (w, 0, 0);
+		}
+		
+		protected override void OnRemoved (Widget w)
+		{
+			int i = GetWidgetPosition (w);
+			if (i != -1) {
+				widgets.RemoveAt (i);
+				w.Unparent ();
+				QueueResize ();
+			}
+		}
+		
+		int GetWidgetPosition (Widget w)
+		{
+			for (int n=0; n&lt;widgets.Count; n++)
+				if (((WidgetPosition)widgets[n]).Widget == w)
+					return n;
+			return -1;
+		}
+		
+		protected override void OnSizeRequested (ref Requisition req)
+		{
+			req.Width = req.Height = 0;
+			foreach (WidgetPosition pos in widgets) {
+				Requisition wreq = pos.Widget.SizeRequest ();
+				if (placement == Placement.Top || placement == Placement.Bottom) {
+					if (pos.X + wreq.Width &gt; req.Width)
+						req.Width = pos.X + wreq.Width;
+					if (pos.Y + wreq.Height &gt; req.Height)
+						req.Height = pos.Y + wreq.Height;
+				} else {
+					if (pos.Y + wreq.Width &gt; req.Width)
+						req.Width = pos.Y + wreq.Width;
+					if (pos.X + wreq.Height &gt; req.Height)
+						req.Height = pos.X + wreq.Height;
+				}
+			}
+			if (placement == Placement.Top || placement == Placement.Bottom)
+				req.Width = 0;
+			else
+				req.Height = 0;
+		}
+
+		protected override void OnSizeAllocated (Gdk.Rectangle rect)
+		{
+			base.OnSizeAllocated (rect);
+			foreach (WidgetPosition pos in widgets) {
+				Requisition req = pos.Widget.ChildRequisition;
+				Rectangle crect = new Rectangle (pos.X, pos.Y, req.Width, req.Height);
+				switch (placement) {
+					case Placement.Top:
+						break;
+					case Placement.Bottom:
+						crect.Y = Allocation.Height - crect.Y - crect.Height;
+						break;
+					case Placement.Left: {
+						int t = crect.X; crect.X=crect.Y; crect.Y=t;
+						break;
+						}
+					case Placement.Right: {
+						int t = crect.X; crect.X=crect.Y; crect.Y=t;
+						crect.X = Allocation.Width - crect.X - crect.Width;
+						break;
+						}
+				}
+				crect.X += Allocation.X;
+				crect.Y += Allocation.Y;
+				pos.Widget.SizeAllocate (crect);
+			}
+		}
+		
+		protected override void ForAll (bool include_internals, Gtk.Callback callback)
+		{
+			foreach (WidgetPosition pos in widgets)
+				callback (pos.Widget);
+		}
+	}
+
+	class WidgetPosition
+	{
+		public int X;
+		public int Y;
+		public Widget Widget;
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FloatingDock.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FloatingDock.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FloatingDock.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,65 @@
+//
+// FloatingDock.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using Gdk;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	internal class FloatingDock: Gtk.Window
+	{
+		DockToolbar bar;
+		
+		public FloatingDock (DockToolbarFrame frame): base (Gtk.WindowType.Toplevel)
+		{
+			SkipTaskbarHint = true;
+			Decorated = false;
+			TransientFor = frame.TopWindow;
+		}
+		
+		public void Attach (DockToolbar bar)
+		{
+			this.bar = bar;
+			bar.FloatingDock = this;
+			Frame f = new Frame ();
+			f.Shadow = ShadowType.Out;
+			f.Add (bar);
+			Add (f);
+			f.Show ();
+			bar.Show ();
+			Show ();
+		}
+		
+		public void Detach ()
+		{
+			bar.FloatingDock = null;
+			((Frame)bar.Parent).Remove (bar);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FloatingPosition.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FloatingPosition.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/FloatingPosition.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,75 @@
+//
+// FloatingPosition.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using System.Xml.Serialization;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	[XmlType (&quot;floatingPosition&quot;)]
+	public class FloatingPosition: DockToolbarPosition
+	{
+		Orientation orientation;
+		int x;
+		int y;
+		
+		public FloatingPosition ()
+		{
+		}
+		
+		internal FloatingPosition (DockToolbar bar)
+		{
+			orientation = bar.Orientation;
+			bar.FloatingDock.GetPosition (out x, out y);
+		}
+		
+		[XmlAttribute (&quot;x&quot;)]
+		public int X {
+			get { return x; }
+			set { x = value; }
+		}
+		
+		[XmlAttribute (&quot;y&quot;)]
+		public int Y {
+			get { return y; }
+			set { y = value; }
+		}
+		
+		[XmlAttribute (&quot;orientation&quot;)]
+		public Orientation Orientation {
+			get { return orientation; }
+			set { orientation = value; }
+		}
+		
+		internal override void RestorePosition (DockToolbarFrame frame, DockToolbar bar)
+		{
+			frame.FloatBar (bar, orientation, x, y);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/IDockBar.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/IDockBar.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/IDockBar.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,37 @@
+//
+// IDockToolbar.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+namespace MonoDevelop.Gui.Widgets
+{
+	public interface IDockToolbar
+	{
+		string Id { get; }
+		string Title { get; }
+		bool Visible { get; set; }
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/PlaceholderWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/PlaceholderWindow.cs	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/DockToolbars/PlaceholderWindow.cs	2005-06-09 15:58:16 UTC (rev 2591)
@@ -0,0 +1,55 @@
+//
+// PlaceholderWindow.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+namespace MonoDevelop.Gui.Widgets
+{
+	internal class PlaceholderWindow: Gtk.Window
+	{
+		Gdk.GC redgc;
+		
+		public PlaceholderWindow (DockToolbarFrame frame): base (Gtk.WindowType.Toplevel)
+		{
+			SkipTaskbarHint = true;
+			Decorated = false;
+			TransientFor = frame.TopWindow;
+			Realize ();
+			redgc = new Gdk.GC (GdkWindow);
+	   		redgc.RgbFgColor = new Gdk.Color (255, 0, 0);
+		}
+		
+		protected override bool OnExposeEvent (Gdk.EventExpose args)
+		{
+			base.OnExposeEvent (args);
+			int w, h;
+			this.GetSize (out w, out h);
+			this.GdkWindow.DrawRectangle (redgc, false, 0, 0, w-1, h-1);
+	  		return true;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Makefile.am	2005-06-08 19:16:59 UTC (rev 2590)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Gui.Widgets/Makefile.am	2005-06-09 15:58:16 UTC (rev 2591)
@@ -32,6 +32,7 @@
 Commands/Command.cs \
 Commands/CommandEntry.cs \
 Commands/CommandEntrySet.cs \
+Commands/CommandFrame.cs \
 Commands/CommandErrorHandler.cs \
 Commands/CommandHandlerAttribute.cs \
 Commands/CommandHandler.cs \
@@ -40,6 +41,7 @@
 Commands/CommandMenuBar.cs \
 Commands/CommandMenu.cs \
 Commands/CommandMenuItem.cs \
+Commands/CommandSystemCommands.cs \
 Commands/CommandToggleToolButton.cs \
 Commands/CommandToolbar.cs \
 Commands/CommandToolButton.cs \
@@ -49,8 +51,24 @@
 Commands/ICommandRouter.cs \
 Commands/ICommandUserItem.cs \
 Commands/LinkCommandEntry.cs \
-Commands/MenuToolButton.cs
+Commands/MenuToolButton.cs \
+DockToolbars/ArrowWindow.cs \
+DockToolbars/DockGrip.cs \
+DockToolbars/DockToolbar.cs \
+DockToolbars/DockToolbarFrame.cs \
+DockToolbars/DockToolbarFrameLayout.cs \
+DockToolbars/DockToolbarFrameStatus.cs \
+DockToolbars/DockToolbarPanel.cs \
+DockToolbars/DockToolbarPosition.cs \
+DockToolbars/DockToolbarStatus.cs \
+DockToolbars/DockedPosition.cs \
+DockToolbars/FixedPanel.cs \
+DockToolbars/FloatingDock.cs \
+DockToolbars/FloatingPosition.cs \
+DockToolbars/IDockBar.cs \
+DockToolbars/PlaceholderWindow.cs
 
+
 all: $(DLL)
 
 $(DLL): $(build_sources)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002190.html">[Monodevelop-patches-list] r2590 - trunk/MonoDevelop
</A></li>
	<LI>Next message: <A HREF="002192.html">[Monodevelop-patches-list] r2592 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Commands Gui	Gui/Workbench Gui/Workbench/Layouts Internal/Codons/Commands
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2191">[ date ]</a>
              <a href="thread.html#2191">[ thread ]</a>
              <a href="subject.html#2191">[ subject ]</a>
              <a href="author.html#2191">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
