<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2528 - in	trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding:	. Gui Parser Parser/SharpDevelopTree SharpRefactoryVB	SharpRefactoryVB/src SharpRefactoryVB/src/CSharpConverter	SharpRefactoryVB/src/Lexer SharpRefactoryVB/src/Lexer/Reader	SharpRefactoryVB/src/Lexer/Specials SharpRefactoryVB/src/Parser/AST	SharpRefactoryVB/src/Parser/AST/Expressions	SharpRefactoryVB/src/Parser/AST/GlobalScope	SharpRefactoryVB/src/Parser/AST/Statements	SharpRefactoryVB/src/Parser/AST/TypeLevel	SharpRefactoryVB/src/Parser/generated	SharpRefactoryVB/src/Parser/generated/keywordlist templates
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2528%20-%20in%0A%09trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding%3A%0A%09.%20Gui%20Parser%20Parser/SharpDevelopTree%20SharpRefactoryVB%0A%09SharpRefactoryVB/src%20SharpRefactoryVB/src/CSharpConverter%0A%09SharpRefactoryVB/src/Lexer%20SharpRefactoryVB/src/Lexer/Reader%0A%09SharpRefactoryVB/src/Lexer/Specials%20SharpRefactoryVB/src/Parser/AST%0A%09SharpRefactoryVB/src/Parser/AST/Expressions%0A%09SharpRefactoryVB/src/Parser/AST/GlobalScope%0A%09SharpRefactoryVB/src/Parser/AST/Statements%0A%09SharpRefactoryVB/src/Parser/AST/TypeLevel%0A%09SharpRefactoryVB/src/Parser/generated%0A%09SharpRefactoryVB/src/Parser/generated/keywordlist%20templates&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002127.html">
   <LINK REL="Next"  HREF="002129.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2528 - in	trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding:	. Gui Parser Parser/SharpDevelopTree SharpRefactoryVB	SharpRefactoryVB/src SharpRefactoryVB/src/CSharpConverter	SharpRefactoryVB/src/Lexer SharpRefactoryVB/src/Lexer/Reader	SharpRefactoryVB/src/Lexer/Specials SharpRefactoryVB/src/Parser/AST	SharpRefactoryVB/src/Parser/AST/Expressions	SharpRefactoryVB/src/Parser/AST/GlobalScope	SharpRefactoryVB/src/Parser/AST/Statements	SharpRefactoryVB/src/Parser/AST/TypeLevel	SharpRefactoryVB/src/Parser/generated	SharpRefactoryVB/src/Parser/generated/keywordlist templates</H1>
    <B>John Luke &lt;jluke@cfl.rr.com&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2528%20-%20in%0A%09trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding%3A%0A%09.%20Gui%20Parser%20Parser/SharpDevelopTree%20SharpRefactoryVB%0A%09SharpRefactoryVB/src%20SharpRefactoryVB/src/CSharpConverter%0A%09SharpRefactoryVB/src/Lexer%20SharpRefactoryVB/src/Lexer/Reader%0A%09SharpRefactoryVB/src/Lexer/Specials%20SharpRefactoryVB/src/Parser/AST%0A%09SharpRefactoryVB/src/Parser/AST/Expressions%0A%09SharpRefactoryVB/src/Parser/AST/GlobalScope%0A%09SharpRefactoryVB/src/Parser/AST/Statements%0A%09SharpRefactoryVB/src/Parser/AST/TypeLevel%0A%09SharpRefactoryVB/src/Parser/generated%0A%09SharpRefactoryVB/src/Parser/generated/keywordlist%20templates&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2528 - in	trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding:	. Gui Parser Parser/SharpDevelopTree SharpRefactoryVB	SharpRefactoryVB/src SharpRefactoryVB/src/CSharpConverter	SharpRefactoryVB/src/Lexer SharpRefactoryVB/src/Lexer/Reader	SharpRefactoryVB/src/Lexer/Specials SharpRefactoryVB/src/Parser/AST	SharpRefactoryVB/src/Parser/AST/Expressions	SharpRefactoryVB/src/Parser/AST/GlobalScope	SharpRefactoryVB/src/Parser/AST/Statements	SharpRefactoryVB/src/Parser/AST/TypeLevel	SharpRefactoryVB/src/Parser/generated	SharpRefactoryVB/src/Parser/generated/keywordlist templates">jluke at mono-cvs.ximian.com
       </A><BR>
    <I>Fri May 13 19:13:06 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002127.html">[Monodevelop-patches-list] r2527 - in trunk/MonoDevelop/Extras/BooBinding: . Gui
</A></li>
        <LI>Next message: <A HREF="002129.html">[Monodevelop-patches-list] r2529 - in trunk/MonoDevelop: .	Core/src/AddIns/BackendBindings/CSharpBinding	Core/src/AddIns/BackendBindings/ILAsmBinding	Core/src/AddIns/BackendBindings/NemerleBinding	Core/src/AddIns/BackendBindings/VBNetBinding	Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB	Core/src/AddIns/DebuggerAddIn	Core/src/AddIns/DisplayBindings/SourceEditor	Core/src/AddIns/prj2make-sharp-lib	Core/src/ICSharpCode.SharpAssembly	Core/src/ICSharpCode.SharpRefactory Core/src/MonoDevelop.Base	Core/src/MonoDevelop.Core Core/src/MonoDevelop.Dock	Core/src/MonoDevelop.Gui.Utils	Core/src/MonoDevelop.Gui.Widgets Core/src/MonoDevelop.Startup	Core/src/Tools/dbgen Core/src/Tools/mdhost Extras/BooBinding	Extras/JavaBinding Extras/MonoDeveloperExtensions	Extras/MonoQuery Unused/AddInManager build/data/resources/css	build/data/resources/icons contrib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2128">[ date ]</a>
              <a href="thread.html#2128">[ thread ]</a>
              <a href="subject.html#2128">[ subject ]</a>
              <a href="author.html#2128">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2005-05-13 19:13:05 -0400 (Fri, 13 May 2005)
New Revision: 2528

Modified:
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/ChooseRuntimePanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/CodeGenerationPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Makefile.am
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ProjectNodeBuilder.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/Makefile.am
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Makefile
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VB.glade
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.addin.xml
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/EmptyVBFile.xft.xml
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/EmptyVBProject.xpt.xml
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/VBConsoleApplicationProject.xpt.xml
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/VBGtkSharp2Project.xpt.xml
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/VBGtkSharpProject.xpt.xml
Log:
eol-style native


Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,32 +1,32 @@
-using System.Reflection;
-using System.Runtime.CompilerServices;
-
-// Information about this assembly is defined by the following
-// attributes.
-//
-// change them to the information which is associated with the assembly
-// you compile.
-
-[assembly: AssemblyTitle(&quot;VB.NET Binding&quot;)]
-[assembly: AssemblyDescription(&quot;VB.NET language binding for monodevelop&quot;)]
-[assembly: AssemblyConfiguration(&quot;&quot;)]
-[assembly: AssemblyCompany(&quot;www.monodevelop.com&quot;)]
-[assembly: AssemblyProduct(&quot;&quot;)]
-[assembly: AssemblyCopyright(&quot;(c) 2004 Markus Palme, MonoDevelop team, Levi Bard&quot;)]
-[assembly: AssemblyTrademark(&quot;&quot;)]
-[assembly: AssemblyCulture(&quot;&quot;)]
-
-// The assembly version has following format :
-//
-// Major.Minor.Build.Revision
-//
-// You can specify all values by your own or you can build default build and revision
-// numbers with the '*' character (the default):
-
-[assembly: AssemblyVersion(&quot;1.0.1.1649&quot;)]
-
-// The following attributes specify the key for the sign of your assembly. See the
-// .NET Framework documentation for more information about signing.
-// This is not required, if you don't want signing let these attributes like they're.
-[assembly: AssemblyDelaySign(false)]
-[assembly: AssemblyKeyFile(&quot;&quot;)]
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+
+[assembly: AssemblyTitle(&quot;VB.NET Binding&quot;)]
+[assembly: AssemblyDescription(&quot;VB.NET language binding for monodevelop&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;www.monodevelop.com&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;(c) 2004 Markus Palme, MonoDevelop team, Levi Bard&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.1.1649&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/AssemblyInfo.cs
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/ChooseRuntimePanel.cs
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/CodeGenerationPanel.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,66 +1,66 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Windows.Forms;
-
-namespace VBBinding
-{
-	[Serializable()]
-	class GuiMessageRecipient : IMessageRecipient
-	{
-		class StatusForm : Form
-		{
-			Label statusLabel;
-			
-			public StatusForm()
-			{
-				this.Text = &quot;VB.DOC status&quot;;
-				this.ControlBox = false;
-				this.StartPosition = FormStartPosition.CenterScreen;
-				this.ShowInTaskbar = false;
-				
-				this.Size = new System.Drawing.Size(400, 50);
-				
-				statusLabel = new Label();
-				statusLabel.Dock = DockStyle.Fill;
-				statusLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
-				Controls.Add(statusLabel);
-			}
-			
-			public void Status(string statusMessage)
-			{
-				statusLabel.Text = statusMessage;
-				Application.DoEvents();
-			}
-		}
-		
-		StatusForm messageForm;
-		
-		public GuiMessageRecipient()
-		{
-			messageForm = new StatusForm();
-			messageForm.Show();
-		}
-		
-		public void Finished()
-		{
-			messageForm.Close();
-		}
-		
-		public void DisplayStatusMessage(string message)
-		{
-			messageForm.Status(message);
-		}
-		
-		public void DisplayErrorMessage(string message)
-		{
-			// message doesn't work in this app domain
-			System.Windows.Forms.MessageBox.Show(message);
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Windows.Forms;
+
+namespace VBBinding
+{
+	[Serializable()]
+	class GuiMessageRecipient : IMessageRecipient
+	{
+		class StatusForm : Form
+		{
+			Label statusLabel;
+			
+			public StatusForm()
+			{
+				this.Text = &quot;VB.DOC status&quot;;
+				this.ControlBox = false;
+				this.StartPosition = FormStartPosition.CenterScreen;
+				this.ShowInTaskbar = false;
+				
+				this.Size = new System.Drawing.Size(400, 50);
+				
+				statusLabel = new Label();
+				statusLabel.Dock = DockStyle.Fill;
+				statusLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
+				Controls.Add(statusLabel);
+			}
+			
+			public void Status(string statusMessage)
+			{
+				statusLabel.Text = statusMessage;
+				Application.DoEvents();
+			}
+		}
+		
+		StatusForm messageForm;
+		
+		public GuiMessageRecipient()
+		{
+			messageForm = new StatusForm();
+			messageForm.Show();
+		}
+		
+		public void Finished()
+		{
+			messageForm.Close();
+		}
+		
+		public void DisplayStatusMessage(string message)
+		{
+			messageForm.Status(message);
+		}
+		
+		public void DisplayErrorMessage(string message)
+		{
+			// message doesn't work in this app domain
+			System.Windows.Forms.MessageBox.Show(message);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/GuiMessageRecipient.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,39 +1,39 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-using System.Drawing;
-
-using MonoDevelop.Internal.Project;
-using MonoDevelop.Internal.ExternalTool;
-using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Core.Services;
-using MonoDevelop.Core.Properties;
-using MonoDevelop.Core.AddIns.Codons;
-
-namespace VBBinding
-{
-	public class TextEditorOptionsPanel : AbstractOptionPanel
-	{
-		public override void LoadPanelContents()
-		{
-			SetupFromXml(Path.Combine(PropertyService.DataDirectory, 
-			                          @&quot;resources\panels\VBSpecificTextEditorOptions.xfrm&quot;));
-			((CheckBox)ControlDictionary[&quot;enableEndConstructsCheckBox&quot;]).Checked   = PropertyService.GetProperty(&quot;VBBinding.TextEditor.EnableEndConstructs&quot;, true);
-			((CheckBox)ControlDictionary[&quot;enableCasingCheckBox&quot;]).Checked = PropertyService.GetProperty(&quot;VBBinding.TextEditor.EnableCasing&quot;, true);
-		}
-		
-		public override bool StorePanelContents()
-		{
-			PropertyService.SetProperty(&quot;VBBinding.TextEditor.EnableEndConstructs&quot;, ((CheckBox)ControlDictionary[&quot;enableEndConstructsCheckBox&quot;]).Checked);
-			PropertyService.SetProperty(&quot;VBBinding.TextEditor.EnableCasing&quot;, ((CheckBox)ControlDictionary[&quot;enableCasingCheckBox&quot;]).Checked);
-			
-			return true;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.ExternalTool;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.AddIns.Codons;
+
+namespace VBBinding
+{
+	public class TextEditorOptionsPanel : AbstractOptionPanel
+	{
+		public override void LoadPanelContents()
+		{
+			SetupFromXml(Path.Combine(PropertyService.DataDirectory, 
+			                          @&quot;resources\panels\VBSpecificTextEditorOptions.xfrm&quot;));
+			((CheckBox)ControlDictionary[&quot;enableEndConstructsCheckBox&quot;]).Checked   = PropertyService.GetProperty(&quot;VBBinding.TextEditor.EnableEndConstructs&quot;, true);
+			((CheckBox)ControlDictionary[&quot;enableCasingCheckBox&quot;]).Checked = PropertyService.GetProperty(&quot;VBBinding.TextEditor.EnableCasing&quot;, true);
+		}
+		
+		public override bool StorePanelContents()
+		{
+			PropertyService.SetProperty(&quot;VBBinding.TextEditor.EnableEndConstructs&quot;, ((CheckBox)ControlDictionary[&quot;enableEndConstructsCheckBox&quot;]).Checked);
+			PropertyService.SetProperty(&quot;VBBinding.TextEditor.EnableCasing&quot;, ((CheckBox)ControlDictionary[&quot;enableCasingCheckBox&quot;]).Checked);
+			
+			return true;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/TextEditorOptionsPanel.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,50 +1,50 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-using System.Drawing;
-using System.Collections;
-using System.ComponentModel;
-
-using MonoDevelop.Internal.Project;
-using MonoDevelop.Core.Properties;
-
-using MonoDevelop.Core.AddIns.Codons;
-using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Core.Services;
-
-namespace VBBinding
-{
-	public class VBCompilerPanel : AbstractOptionPanel
-	{
-		VBCompilerParameters config = null;
-		
-		public override void LoadPanelContents()
-		{
-			SetupFromXml(Path.Combine(PropertyService.DataDirectory, 
-			                          @&quot;resources\panels\VBCompilerPanel.xfrm&quot;));
-			
-			DotNetProjectConfiguration cfg = (DotNetProjectConfiguration)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
-			config = (VBCompilerParameters) cfg.CompilationParameters;
-			
-			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-			((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Items.Add(&quot;Standard&quot;);
-			foreach (string runtime in fileUtilityService.GetAvaiableRuntimeVersions()) {
-				((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Items.Add(runtime);
-			}
-			
-			((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Text = config.VBCompilerVersion.Length == 0 ? &quot;Standard&quot; : config.VBCompilerVersion;
-		}
-
-		public override bool StorePanelContents()
-		{
-			config.VBCompilerVersion = ControlDictionary[&quot;compilerVersionComboBox&quot;].Text;
-			return true;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+using System.Collections;
+using System.ComponentModel;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Core.Properties;
+
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.Services;
+
+namespace VBBinding
+{
+	public class VBCompilerPanel : AbstractOptionPanel
+	{
+		VBCompilerParameters config = null;
+		
+		public override void LoadPanelContents()
+		{
+			SetupFromXml(Path.Combine(PropertyService.DataDirectory, 
+			                          @&quot;resources\panels\VBCompilerPanel.xfrm&quot;));
+			
+			DotNetProjectConfiguration cfg = (DotNetProjectConfiguration)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+			config = (VBCompilerParameters) cfg.CompilationParameters;
+			
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+			((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Items.Add(&quot;Standard&quot;);
+			foreach (string runtime in fileUtilityService.GetAvaiableRuntimeVersions()) {
+				((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Items.Add(runtime);
+			}
+			
+			((ComboBox)ControlDictionary[&quot;compilerVersionComboBox&quot;]).Text = config.VBCompilerVersion.Length == 0 ? &quot;Standard&quot; : config.VBCompilerVersion;
+		}
+
+		public override bool StorePanelContents()
+		{
+			config.VBCompilerVersion = ControlDictionary[&quot;compilerVersionComboBox&quot;].Text;
+			return true;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBCompilerPanel.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,92 +1,92 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Drawing;
-
-using MonoDevelop.Internal.Project;
-using MonoDevelop.Internal.ExternalTool;
-using MonoDevelop.Gui.Dialogs;
-using MonoDevelop.Core.AddIns.Codons;
-
-using MonoDevelop.Core.Services;
-using MonoDevelop.Core.Properties;
-
-namespace VBBinding
-{
-	public class VBDOCConfigurationPanel  : AbstractOptionPanel
-	{
-		VBCompilerParameters compilerParameters = null;
-		VBProject project = null;
-		ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
-		static FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
-		
-		///&lt;summary&gt;
-		/// Returns if the filename will be parsed when running VB.DOC.
-		/// &lt;/summary&gt;
-		public static bool IsFileIncluded(string filename, VBProject project)
-		{
-			DotNetProjectConfiguration config = (DotNetProjectConfiguration) project.ActiveConfiguration;
-			VBCompilerParameters compilerparameters = (VBCompilerParameters) config.CompilationParameters;
-			return Array.IndexOf(compilerparameters.VBDOCFiles, filename) == -1;
-		}
-		
-		
-		public VBDOCConfigurationPanel() : base(propertyService.DataDirectory + @&quot;\resources\panels\ProjectOptions\VBDOCConfigurationPanel.xfrm&quot;)
-		{
-			CustomizationObjectChanged += new EventHandler(SetValues);
-			ControlDictionary[&quot;BrowseOutputFileButton&quot;].Click += new EventHandler(BrowseOutputFileButton_Click);
-		}
-		
-		private void BrowseOutputFileButton_Click(object sender, EventArgs e) {
-			SaveFileDialog dialog = new SaveFileDialog();
-			dialog.Filter = &quot;XML files (*.xml)|*.xml&quot;;
-			if(dialog.ShowDialog() == DialogResult.OK) {
-				((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text = dialog.FileName;
-			}
-		}
-		
-		public override bool ReceiveDialogMessage(DialogMessage message)
-		{
-			if (message == DialogMessage.OK) {
-				if (compilerParameters == null) {
-					return true;
-				}
-				
-				compilerParameters.VBDOCOutputFile = ((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text;
-				compilerParameters.VBDOCCommentPrefix = ((TextBox)ControlDictionary[&quot;CommentPrefixTextBox&quot;]).Text;
-				
-				string[] files = new string[((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Count - ((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).CheckedIndices.Count];
-				int count = 0;
-				for(int index = 0; index &lt; ((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Count; index++) {
-					if(((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).GetItemChecked(index) == false) {
-						files[count] = (string)((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items[index];
-						count++;
-					}
-				}
-				compilerParameters.VBDOCFiles = files;
-			}
-			return true;
-		}
-		
-		void SetValues(object sender, EventArgs e)
-		{
-			DotNetProjectConfiguration config = (DotNetProjectConfiguration) ((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
-			compilerParameters = (VBCompilerParameters) config.CompilationParameters;
-			project = (VBProject)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);
-			
-			((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text = compilerParameters.VBDOCOutputFile;
-			((TextBox)ControlDictionary[&quot;CommentPrefixTextBox&quot;]). Text = compilerParameters.VBDOCCommentPrefix;
-			
-			foreach(ProjectFile pfile in project.ProjectFiles) {
-				bool included = IsFileIncluded(pfile.Name, project);
-				((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Add(pfile.Name, included);
-			}
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.ExternalTool;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Core.AddIns.Codons;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.Properties;
+
+namespace VBBinding
+{
+	public class VBDOCConfigurationPanel  : AbstractOptionPanel
+	{
+		VBCompilerParameters compilerParameters = null;
+		VBProject project = null;
+		ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+		static FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		
+		///&lt;summary&gt;
+		/// Returns if the filename will be parsed when running VB.DOC.
+		/// &lt;/summary&gt;
+		public static bool IsFileIncluded(string filename, VBProject project)
+		{
+			DotNetProjectConfiguration config = (DotNetProjectConfiguration) project.ActiveConfiguration;
+			VBCompilerParameters compilerparameters = (VBCompilerParameters) config.CompilationParameters;
+			return Array.IndexOf(compilerparameters.VBDOCFiles, filename) == -1;
+		}
+		
+		
+		public VBDOCConfigurationPanel() : base(propertyService.DataDirectory + @&quot;\resources\panels\ProjectOptions\VBDOCConfigurationPanel.xfrm&quot;)
+		{
+			CustomizationObjectChanged += new EventHandler(SetValues);
+			ControlDictionary[&quot;BrowseOutputFileButton&quot;].Click += new EventHandler(BrowseOutputFileButton_Click);
+		}
+		
+		private void BrowseOutputFileButton_Click(object sender, EventArgs e) {
+			SaveFileDialog dialog = new SaveFileDialog();
+			dialog.Filter = &quot;XML files (*.xml)|*.xml&quot;;
+			if(dialog.ShowDialog() == DialogResult.OK) {
+				((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text = dialog.FileName;
+			}
+		}
+		
+		public override bool ReceiveDialogMessage(DialogMessage message)
+		{
+			if (message == DialogMessage.OK) {
+				if (compilerParameters == null) {
+					return true;
+				}
+				
+				compilerParameters.VBDOCOutputFile = ((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text;
+				compilerParameters.VBDOCCommentPrefix = ((TextBox)ControlDictionary[&quot;CommentPrefixTextBox&quot;]).Text;
+				
+				string[] files = new string[((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Count - ((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).CheckedIndices.Count];
+				int count = 0;
+				for(int index = 0; index &lt; ((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Count; index++) {
+					if(((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).GetItemChecked(index) == false) {
+						files[count] = (string)((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items[index];
+						count++;
+					}
+				}
+				compilerParameters.VBDOCFiles = files;
+			}
+			return true;
+		}
+		
+		void SetValues(object sender, EventArgs e)
+		{
+			DotNetProjectConfiguration config = (DotNetProjectConfiguration) ((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+			compilerParameters = (VBCompilerParameters) config.CompilationParameters;
+			project = (VBProject)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);
+			
+			((TextBox)ControlDictionary[&quot;OutputFileTextBox&quot;]).Text = compilerParameters.VBDOCOutputFile;
+			((TextBox)ControlDictionary[&quot;CommentPrefixTextBox&quot;]). Text = compilerParameters.VBDOCCommentPrefix;
+			
+			foreach(ProjectFile pfile in project.ProjectFiles) {
+				bool included = IsFileIncluded(pfile.Name, project);
+				((CheckedListBox)ControlDictionary[&quot;FileListBox&quot;]).Items.Add(pfile.Name, included);
+			}
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Gui/VBDocConfigurationPanel.cs
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,371 +1,371 @@
-using System;
-using System.Text;
-using MonoDevelop.Internal.Parser;
-
-namespace VBBinding.Parser
-{
-	/// &lt;summary&gt;
-	/// Description of ExpressionFinder.	
-	/// &lt;/summary&gt;
-	public class ExpressionFinder  : IExpressionFinder
-	{
-		public string FindExpression(string inText, int offset)
-		{
-			this.text = FilterComments(inText, ref offset);
-			this.text   = text;
-			this.offset = this.lastAccept = offset;
-			this.state  = START;
-			if (this.text == null) {
-				return null;
-			}
-			while (state != ERROR) {
-				ReadNextToken();
-				//Console.WriteLine(&quot;cur state {0} got token {1}/{3} going to {2}&quot;, GetStateName(state), GetTokenName(curTokenType), GetStateName(stateTable[state, curTokenType]), curTokenType);
-				state = stateTable[state, curTokenType];
-				
-				if (state == ACCEPT || state == ACCEPT2) {
-					lastAccept = this.offset;
-				}
-				if (state == ACCEPTNOMORE) {
-					return this.text.Substring(this.offset + 1, offset - this.offset);
-				}
-			}
-			return this.text.Substring(this.lastAccept + 1, offset - this.lastAccept);
-		}
-		
-		#region Comment Filter and 'inside string watcher'
-		int initialOffset;
-		public string FilterComments(string text, ref int offset)
-		{
-			this.initialOffset = offset;
-			StringBuilder outText = new StringBuilder();
-			int curOffset = 0;
-			while (curOffset &lt;= initialOffset) {
-				char ch = text[curOffset];
-				
-				switch (ch) {
-					case '@':
-						if (curOffset + 1 &lt; text.Length &amp;&amp; text[curOffset + 1] == '&quot;') {
-							outText.Append(text[curOffset++]); // @
-							outText.Append(text[curOffset++]); // &quot;
-							if (!ReadVerbatimString(outText, text, ref curOffset)) {
-								return null;
-							}
-						}else{
-							outText.Append(ch);
-							++curOffset;
-						}
-						break;
-					case '&quot;':
-						outText.Append(ch);
-						curOffset++;
-						if (!ReadString(outText, text, ref curOffset)) {
-							return null;
-						}
-						break;
-					case '\'':
-						offset    -= 1;
-						curOffset += 1;
-						if (!ReadToEOL(text, ref curOffset, ref offset)) {
-							return null;
-						}
-						break;
-					default:
-						outText.Append(ch);
-						++curOffset;
-						break;
-				}
-			}
-			
-			return outText.ToString();
-		}
-		
-		bool ReadToEOL(string text, ref int curOffset, ref int offset)
-		{
-			while (curOffset &lt;= initialOffset) {
-				char ch = text[curOffset++];
-				--offset;
-				if (ch == '\n') {
-					return true;
-				}
-			}
-			return false;
-		}
-		
-		bool ReadString(StringBuilder outText, string text, ref int curOffset)
-		{
-			while (curOffset &lt;= initialOffset) {
-				char ch = text[curOffset++];
-				outText.Append(ch);
-				if (ch == '&quot;') {
-					return true;
-				}
-			}
-			return false;
-		}
-		
-		bool ReadVerbatimString(StringBuilder outText, string text, ref int curOffset)
-		{
-			while (curOffset &lt;= initialOffset) {
-				char ch = text[curOffset++];
-				outText.Append(ch);
-				if (ch == '&quot;') {
-					if (curOffset &lt; text.Length &amp;&amp; text[curOffset] == '&quot;') {
-						outText.Append(text[curOffset++]);
-					} else {
-						return true;
-					}
-				}
-			}
-			return false;
-		}
-		
-		bool ReadMultiLineComment(string text, ref int curOffset, ref int offset)
-		{
-			while (curOffset &lt;= initialOffset) {
-				char ch = text[curOffset++];
-				--offset;
-				if (ch == '*') {
-					if (curOffset &lt; text.Length &amp;&amp; text[curOffset] == '/') {
-						++curOffset;
-						--offset;
-						return true;
-					}
-				}
-			}
-			return false;
-		}
-		#endregion
-		
-		#region mini backward lexer
-		string text;
-		int    offset;
-		
-		char GetNext()
-		{
-			if (offset &gt;= 0) {
-				return text[offset--];
-			}
-			return '\0';
-		}
-		
-		char Peek()
-		{
-			if (offset &gt;= 0) {
-				return text[offset];
-			}
-			return '\0';
-		}
-		
-		void UnGet()
-		{
-			++offset;
-		}
-		
-		// tokens for our lexer
-		static int Err     = 0;
-		static int Dot     = 1;
-		static int StrLit  = 2;
-		static int Ident   = 3;
-		static int New     = 4;
-//		static int Bracket = 5;
-		static int Parent  = 6;
-		static int Curly   = 7;
-		static int Using   = 8;
-		int curTokenType;
-		
-		readonly static string[] tokenStateName = new string[] {
-			&quot;Err&quot;, &quot;Dot&quot;, &quot;StrLit&quot;, &quot;Ident&quot;, &quot;New&quot;, &quot;Bracket&quot;, &quot;Paren&quot;, &quot;Curly&quot;, &quot;Using&quot;
-		};
-		string GetTokenName(int state)
-		{
-			return tokenStateName[state];
-		}
-		
-		void ReadNextToken()
-		{
-			char ch = GetNext();
-				
-			curTokenType = Err;
-			if (ch == '\0' || ch == '\n' || ch == '\r') {
-				return;
-			}
-			while (Char.IsWhiteSpace(ch)) {
-				ch = GetNext();
-				if (ch == '\n' || ch == '\r') {
-					return;
-				}
-			}
-			
-			switch (ch) {
-				case '}':
-					if (ReadBracket('{', '}')) {
-						curTokenType = Curly;
-					}
-					break;
-				case ')':
-					if (ReadBracket('(', ')')) {
-						curTokenType = Parent;
-					}
-					break;
-				case ']':
-					if (ReadBracket('[', ']')) {
-						curTokenType = Ident;
-					}
-					break;
-				case '.':
-					curTokenType = Dot;
-					break;
-				case '\'':
-				case '&quot;':
-					if (ReadStringLiteral(ch)) {
-						curTokenType = StrLit;
-					}
-					break;
-				default:
-					if (IsIdentifierPart(ch)) {
-						string ident = ReadIdentifier(ch);
-						if (ident != null) {
-							switch (ident.ToLower()) {
-								case &quot;new&quot;:
-									curTokenType = New;
-									break;
-								case &quot;imports&quot;:
-									curTokenType = Using;
-									break;
-								default:
-									curTokenType = Ident;
-									break;
-							}
-						}
-					}
-					break;
-			}
-		}
-		
-		bool ReadStringLiteral(char litStart)
-		{
-			while (true) {
-				char ch = GetNext();
-				if (ch == '\0') {
-					return false;
-				}
-				if (ch == litStart) {
-					if (Peek() == '@' &amp;&amp; litStart == '&quot;') {
-						GetNext();
-					}
-					return true;
-				}
-			}
-		}
-		
-		bool ReadBracket(char openBracket, char closingBracket)
-		{
-			int curlyBraceLevel    = 0;
-			int squareBracketLevel = 0;
-			int parenthesisLevel   = 0;
-			switch (openBracket) {
-				case '(':
-					parenthesisLevel++;
-					break;
-				case '[':
-					squareBracketLevel++;
-					break;
-				case '{':
-					curlyBraceLevel++;
-					break;
-			}
-			
-			while (parenthesisLevel != 0 || squareBracketLevel != 0 || curlyBraceLevel != 0) {
-				char ch = GetNext();
-				if (ch == '\0') {
-					return false;
-				}
-				switch (ch) {
-					case '(':
-						parenthesisLevel--;
-						break;
-					case '[':
-						squareBracketLevel--;
-						break;
-					case '{':
-						curlyBraceLevel--;
-						break;
-					case ')':
-						parenthesisLevel++;
-						break;
-					case ']':
-						squareBracketLevel++;
-						break;
-					case '}':
-						curlyBraceLevel++;
-						break;
-				}
-			}
-			return true;
-		}
-		
-		string ReadIdentifier(char ch)
-		{
-			string identifier = ch.ToString();
-			while (IsIdentifierPart(Peek())) {
-				identifier = GetNext() + identifier;
-			}
-			return identifier;
-		}
-		
-		bool IsIdentifierPart(char ch)
-		{
-			return Char.IsLetterOrDigit(ch) || ch == '_';
-		}
-		#endregion
-		
-		#region finite state machine 
-		readonly static int ERROR  = 0;
-		readonly static int START  = 1;
-		readonly static int DOT    = 2;
-		readonly static int MORE   = 3;
-		readonly static int CURLY  = 4;
-		readonly static int CURLY2 = 5;
-		readonly static int CURLY3 = 6;
-		
-		readonly static int ACCEPT = 7;
-		readonly static int ACCEPTNOMORE = 8;
-		readonly static int ACCEPT2 = 9;
-		
-		readonly static string[] stateName = new string[] {
-			&quot;ERROR&quot;,
-			&quot;START&quot;,
-			&quot;DOT&quot;,
-			&quot;MORE&quot;,
-			&quot;CURLY&quot;,
-			&quot;CURLY2&quot;,
-			&quot;CURLY3&quot;,
-			&quot;ACCEPT&quot;,
-			&quot;ACCEPTNOMORE&quot;,
-			&quot;ACCEPT2&quot;
-		};
-			
-		string GetStateName(int state)
-		{
-			return stateName[state];
-		}
-		
-		int state = 0;
-		int lastAccept = 0;
-		static int[,] stateTable = new int[,] {
-			//                   Err,     Dot,     Str,      ID,         New,     Brk,     Par,     Cur,   Using
-			/*ERROR*/        { ERROR,   ERROR,   ERROR,   ERROR,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
-			/*START*/        { ERROR,     DOT,  ACCEPT,  ACCEPT,        ERROR,   MORE, ACCEPT2,   CURLY,   ACCEPTNOMORE},
-			/*DOT*/          { ERROR,   ERROR,  ACCEPT,  ACCEPT,        ERROR,   MORE,  ACCEPT,   CURLY,   ERROR},
-			/*MORE*/         { ERROR,   ERROR,  ACCEPT,  ACCEPT,        ERROR,   MORE, ACCEPT2,   CURLY,   ERROR},
-			/*CURLY*/        { ERROR,   ERROR,   ERROR,   ERROR,        ERROR, CURLY2,   ERROR,   ERROR,   ERROR},
-			/*CURLY2*/       { ERROR,   ERROR,   ERROR,  CURLY3,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
-			/*CURLY3*/       { ERROR,   ERROR,   ERROR,   ERROR, ACCEPTNOMORE,  ERROR,   ERROR,   ERROR,   ERROR},
-			/*ACCEPT*/       { ERROR,    MORE,   ERROR,   ERROR,       ACCEPT,  ERROR,   ERROR,   ERROR,   ACCEPTNOMORE},
-			/*ACCEPTNOMORE*/ { ERROR,   ERROR,   ERROR,   ERROR,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
-			/*ACCEPT2*/      { ERROR,    MORE,   ERROR,  ACCEPT,       ACCEPT,  ERROR,   ERROR,   ERROR,   ERROR},
-		};
-		#endregion 
-	}
-}
+using System;
+using System.Text;
+using MonoDevelop.Internal.Parser;
+
+namespace VBBinding.Parser
+{
+	/// &lt;summary&gt;
+	/// Description of ExpressionFinder.	
+	/// &lt;/summary&gt;
+	public class ExpressionFinder  : IExpressionFinder
+	{
+		public string FindExpression(string inText, int offset)
+		{
+			this.text = FilterComments(inText, ref offset);
+			this.text   = text;
+			this.offset = this.lastAccept = offset;
+			this.state  = START;
+			if (this.text == null) {
+				return null;
+			}
+			while (state != ERROR) {
+				ReadNextToken();
+				//Console.WriteLine(&quot;cur state {0} got token {1}/{3} going to {2}&quot;, GetStateName(state), GetTokenName(curTokenType), GetStateName(stateTable[state, curTokenType]), curTokenType);
+				state = stateTable[state, curTokenType];
+				
+				if (state == ACCEPT || state == ACCEPT2) {
+					lastAccept = this.offset;
+				}
+				if (state == ACCEPTNOMORE) {
+					return this.text.Substring(this.offset + 1, offset - this.offset);
+				}
+			}
+			return this.text.Substring(this.lastAccept + 1, offset - this.lastAccept);
+		}
+		
+		#region Comment Filter and 'inside string watcher'
+		int initialOffset;
+		public string FilterComments(string text, ref int offset)
+		{
+			this.initialOffset = offset;
+			StringBuilder outText = new StringBuilder();
+			int curOffset = 0;
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset];
+				
+				switch (ch) {
+					case '@':
+						if (curOffset + 1 &lt; text.Length &amp;&amp; text[curOffset + 1] == '&quot;') {
+							outText.Append(text[curOffset++]); // @
+							outText.Append(text[curOffset++]); // &quot;
+							if (!ReadVerbatimString(outText, text, ref curOffset)) {
+								return null;
+							}
+						}else{
+							outText.Append(ch);
+							++curOffset;
+						}
+						break;
+					case '&quot;':
+						outText.Append(ch);
+						curOffset++;
+						if (!ReadString(outText, text, ref curOffset)) {
+							return null;
+						}
+						break;
+					case '\'':
+						offset    -= 1;
+						curOffset += 1;
+						if (!ReadToEOL(text, ref curOffset, ref offset)) {
+							return null;
+						}
+						break;
+					default:
+						outText.Append(ch);
+						++curOffset;
+						break;
+				}
+			}
+			
+			return outText.ToString();
+		}
+		
+		bool ReadToEOL(string text, ref int curOffset, ref int offset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				--offset;
+				if (ch == '\n') {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		bool ReadString(StringBuilder outText, string text, ref int curOffset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				outText.Append(ch);
+				if (ch == '&quot;') {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		bool ReadVerbatimString(StringBuilder outText, string text, ref int curOffset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				outText.Append(ch);
+				if (ch == '&quot;') {
+					if (curOffset &lt; text.Length &amp;&amp; text[curOffset] == '&quot;') {
+						outText.Append(text[curOffset++]);
+					} else {
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+		
+		bool ReadMultiLineComment(string text, ref int curOffset, ref int offset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				--offset;
+				if (ch == '*') {
+					if (curOffset &lt; text.Length &amp;&amp; text[curOffset] == '/') {
+						++curOffset;
+						--offset;
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+		#endregion
+		
+		#region mini backward lexer
+		string text;
+		int    offset;
+		
+		char GetNext()
+		{
+			if (offset &gt;= 0) {
+				return text[offset--];
+			}
+			return '\0';
+		}
+		
+		char Peek()
+		{
+			if (offset &gt;= 0) {
+				return text[offset];
+			}
+			return '\0';
+		}
+		
+		void UnGet()
+		{
+			++offset;
+		}
+		
+		// tokens for our lexer
+		static int Err     = 0;
+		static int Dot     = 1;
+		static int StrLit  = 2;
+		static int Ident   = 3;
+		static int New     = 4;
+//		static int Bracket = 5;
+		static int Parent  = 6;
+		static int Curly   = 7;
+		static int Using   = 8;
+		int curTokenType;
+		
+		readonly static string[] tokenStateName = new string[] {
+			&quot;Err&quot;, &quot;Dot&quot;, &quot;StrLit&quot;, &quot;Ident&quot;, &quot;New&quot;, &quot;Bracket&quot;, &quot;Paren&quot;, &quot;Curly&quot;, &quot;Using&quot;
+		};
+		string GetTokenName(int state)
+		{
+			return tokenStateName[state];
+		}
+		
+		void ReadNextToken()
+		{
+			char ch = GetNext();
+				
+			curTokenType = Err;
+			if (ch == '\0' || ch == '\n' || ch == '\r') {
+				return;
+			}
+			while (Char.IsWhiteSpace(ch)) {
+				ch = GetNext();
+				if (ch == '\n' || ch == '\r') {
+					return;
+				}
+			}
+			
+			switch (ch) {
+				case '}':
+					if (ReadBracket('{', '}')) {
+						curTokenType = Curly;
+					}
+					break;
+				case ')':
+					if (ReadBracket('(', ')')) {
+						curTokenType = Parent;
+					}
+					break;
+				case ']':
+					if (ReadBracket('[', ']')) {
+						curTokenType = Ident;
+					}
+					break;
+				case '.':
+					curTokenType = Dot;
+					break;
+				case '\'':
+				case '&quot;':
+					if (ReadStringLiteral(ch)) {
+						curTokenType = StrLit;
+					}
+					break;
+				default:
+					if (IsIdentifierPart(ch)) {
+						string ident = ReadIdentifier(ch);
+						if (ident != null) {
+							switch (ident.ToLower()) {
+								case &quot;new&quot;:
+									curTokenType = New;
+									break;
+								case &quot;imports&quot;:
+									curTokenType = Using;
+									break;
+								default:
+									curTokenType = Ident;
+									break;
+							}
+						}
+					}
+					break;
+			}
+		}
+		
+		bool ReadStringLiteral(char litStart)
+		{
+			while (true) {
+				char ch = GetNext();
+				if (ch == '\0') {
+					return false;
+				}
+				if (ch == litStart) {
+					if (Peek() == '@' &amp;&amp; litStart == '&quot;') {
+						GetNext();
+					}
+					return true;
+				}
+			}
+		}
+		
+		bool ReadBracket(char openBracket, char closingBracket)
+		{
+			int curlyBraceLevel    = 0;
+			int squareBracketLevel = 0;
+			int parenthesisLevel   = 0;
+			switch (openBracket) {
+				case '(':
+					parenthesisLevel++;
+					break;
+				case '[':
+					squareBracketLevel++;
+					break;
+				case '{':
+					curlyBraceLevel++;
+					break;
+			}
+			
+			while (parenthesisLevel != 0 || squareBracketLevel != 0 || curlyBraceLevel != 0) {
+				char ch = GetNext();
+				if (ch == '\0') {
+					return false;
+				}
+				switch (ch) {
+					case '(':
+						parenthesisLevel--;
+						break;
+					case '[':
+						squareBracketLevel--;
+						break;
+					case '{':
+						curlyBraceLevel--;
+						break;
+					case ')':
+						parenthesisLevel++;
+						break;
+					case ']':
+						squareBracketLevel++;
+						break;
+					case '}':
+						curlyBraceLevel++;
+						break;
+				}
+			}
+			return true;
+		}
+		
+		string ReadIdentifier(char ch)
+		{
+			string identifier = ch.ToString();
+			while (IsIdentifierPart(Peek())) {
+				identifier = GetNext() + identifier;
+			}
+			return identifier;
+		}
+		
+		bool IsIdentifierPart(char ch)
+		{
+			return Char.IsLetterOrDigit(ch) || ch == '_';
+		}
+		#endregion
+		
+		#region finite state machine 
+		readonly static int ERROR  = 0;
+		readonly static int START  = 1;
+		readonly static int DOT    = 2;
+		readonly static int MORE   = 3;
+		readonly static int CURLY  = 4;
+		readonly static int CURLY2 = 5;
+		readonly static int CURLY3 = 6;
+		
+		readonly static int ACCEPT = 7;
+		readonly static int ACCEPTNOMORE = 8;
+		readonly static int ACCEPT2 = 9;
+		
+		readonly static string[] stateName = new string[] {
+			&quot;ERROR&quot;,
+			&quot;START&quot;,
+			&quot;DOT&quot;,
+			&quot;MORE&quot;,
+			&quot;CURLY&quot;,
+			&quot;CURLY2&quot;,
+			&quot;CURLY3&quot;,
+			&quot;ACCEPT&quot;,
+			&quot;ACCEPTNOMORE&quot;,
+			&quot;ACCEPT2&quot;
+		};
+			
+		string GetStateName(int state)
+		{
+			return stateName[state];
+		}
+		
+		int state = 0;
+		int lastAccept = 0;
+		static int[,] stateTable = new int[,] {
+			//                   Err,     Dot,     Str,      ID,         New,     Brk,     Par,     Cur,   Using
+			/*ERROR*/        { ERROR,   ERROR,   ERROR,   ERROR,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*START*/        { ERROR,     DOT,  ACCEPT,  ACCEPT,        ERROR,   MORE, ACCEPT2,   CURLY,   ACCEPTNOMORE},
+			/*DOT*/          { ERROR,   ERROR,  ACCEPT,  ACCEPT,        ERROR,   MORE,  ACCEPT,   CURLY,   ERROR},
+			/*MORE*/         { ERROR,   ERROR,  ACCEPT,  ACCEPT,        ERROR,   MORE, ACCEPT2,   CURLY,   ERROR},
+			/*CURLY*/        { ERROR,   ERROR,   ERROR,   ERROR,        ERROR, CURLY2,   ERROR,   ERROR,   ERROR},
+			/*CURLY2*/       { ERROR,   ERROR,   ERROR,  CURLY3,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*CURLY3*/       { ERROR,   ERROR,   ERROR,   ERROR, ACCEPTNOMORE,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*ACCEPT*/       { ERROR,    MORE,   ERROR,   ERROR,       ACCEPT,  ERROR,   ERROR,   ERROR,   ACCEPTNOMORE},
+			/*ACCEPTNOMORE*/ { ERROR,   ERROR,   ERROR,   ERROR,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*ACCEPT2*/      { ERROR,    MORE,   ERROR,  ACCEPT,       ACCEPT,  ERROR,   ERROR,   ERROR,   ERROR},
+		};
+		#endregion 
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/ExpressionFinder.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,65 +1,65 @@
-// created on 06.08.2003 at 12:37
-
-using System.Diagnostics;
-
-using MonoDevelop.Internal.Parser;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class Class : AbstractClass
-	{
-		ICompilationUnit cu;
-		
-		public Class(CompilationUnit cu, ClassType t, Modifier m, IRegion region)
-		{
-			this.cu = cu;
-			classType = t;
-			this.region = region;
-			modifiers = (ModifierEnum)m;
-		}
-		
-		public void UpdateModifier()
-		{
-			if (classType == ClassType.Enum) {
-				foreach (Field f in Fields) {
-					f.AddModifier(ModifierEnum.Public);
-				}
-				return;
-			}
-			if (classType != ClassType.Interface) {
-				return;
-			}
-			foreach (Class c in InnerClasses) {
-				c.modifiers = c.modifiers | ModifierEnum.Public;
-			}
-			foreach (IMethod m in Methods) {
-				if (m is Constructor) {
-					((Constructor)m).AddModifier(ModifierEnum.Public);
-				} else if (m is Method) {
-					((Method)m).AddModifier(ModifierEnum.Public);
-				} else {
-					Debug.Assert(false, &quot;Unexpected type in method of interface. Can not set modifier to public!&quot;);
-				}
-			}
-			foreach (Event e in Events) {
-				e.AddModifier(ModifierEnum.Public);
-			}
-			foreach (Field f in Fields) {
-				f.AddModifier(ModifierEnum.Public);
-			}
-			foreach (Indexer i in Indexer) {
-				i.AddModifier(ModifierEnum.Public);
-			}
-			foreach (Property p in Properties) {
-				p.AddModifier(ModifierEnum.Public);
-			}
-			
-		}
-		public override ICompilationUnit CompilationUnit {
-			get {
-				return cu;
-			}
-		}
-	}
-}
+// created on 06.08.2003 at 12:37
+
+using System.Diagnostics;
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Class : AbstractClass
+	{
+		ICompilationUnit cu;
+		
+		public Class(CompilationUnit cu, ClassType t, Modifier m, IRegion region)
+		{
+			this.cu = cu;
+			classType = t;
+			this.region = region;
+			modifiers = (ModifierEnum)m;
+		}
+		
+		public void UpdateModifier()
+		{
+			if (classType == ClassType.Enum) {
+				foreach (Field f in Fields) {
+					f.AddModifier(ModifierEnum.Public);
+				}
+				return;
+			}
+			if (classType != ClassType.Interface) {
+				return;
+			}
+			foreach (Class c in InnerClasses) {
+				c.modifiers = c.modifiers | ModifierEnum.Public;
+			}
+			foreach (IMethod m in Methods) {
+				if (m is Constructor) {
+					((Constructor)m).AddModifier(ModifierEnum.Public);
+				} else if (m is Method) {
+					((Method)m).AddModifier(ModifierEnum.Public);
+				} else {
+					Debug.Assert(false, &quot;Unexpected type in method of interface. Can not set modifier to public!&quot;);
+				}
+			}
+			foreach (Event e in Events) {
+				e.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Field f in Fields) {
+				f.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Indexer i in Indexer) {
+				i.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Property p in Properties) {
+				p.AddModifier(ModifierEnum.Public);
+			}
+			
+		}
+		public override ICompilationUnit CompilationUnit {
+			get {
+				return cu;
+			}
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Class.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,23 +1,23 @@
-// created on 06.08.2003 at 12:35
-
-using MonoDevelop.Internal.Parser;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class Constructor : AbstractMethod
-	{
-		public void AddModifier(ModifierEnum m)
-		{
-			modifiers = modifiers | m;
-		}
-		
-		public Constructor(Modifier m, IRegion region, IRegion bodyRegion)
-		{
-			FullyQualifiedName = &quot;#ctor&quot;;
-			this.region     = region;
-			this.bodyRegion = bodyRegion;
-			modifiers = (ModifierEnum)m;
-		}
-	}
-}
+// created on 06.08.2003 at 12:35
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Constructor : AbstractMethod
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Constructor(Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = &quot;#ctor&quot;;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Constructor.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,24 +1,24 @@
-// created on 06.08.2003 at 12:30
-
-using MonoDevelop.Internal.Parser;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class Event : AbstractEvent
-	{
-		public void AddModifier(ModifierEnum m)
-		{
-			modifiers = modifiers | m;
-		}
-		
-		public Event(string name, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
-		{
-			FullyQualifiedName = name;
-			returnType         = type;
-			this.region        = region;
-			this.bodyRegion    = bodyRegion;
-			modifiers          = (ModifierEnum)m;
-		}
-	}
-}
+// created on 06.08.2003 at 12:30
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Event : AbstractEvent
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Event(string name, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = name;
+			returnType         = type;
+			this.region        = region;
+			this.bodyRegion    = bodyRegion;
+			modifiers          = (ModifierEnum)m;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Event.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,29 +1,29 @@
-// created on 04.08.2003 at 18:06
-using System;
-using MonoDevelop.Internal.Parser;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class Field : AbstractField
-	{
-		public void AddModifier(ModifierEnum m)
-		{
-			modifiers = modifiers | m;
-		}
-		
-		public Field(ReturnType type, string fullyQualifiedName, Modifier m, IRegion region)
-		{
-			this.returnType = type;
-			this.FullyQualifiedName = fullyQualifiedName;
-			this.region = region;
-			modifiers = (ModifierEnum)m;
-//			Console.WriteLine(&quot;modifiers for field {0} are {1} were {2}&quot;, fullyQualifiedName, modifiers, m);
-		}
-		
-		public void SetModifiers(ModifierEnum m)
-		{
-			modifiers = m;
-		}
-	}
-}
+// created on 04.08.2003 at 18:06
+using System;
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Field : AbstractField
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Field(ReturnType type, string fullyQualifiedName, Modifier m, IRegion region)
+		{
+			this.returnType = type;
+			this.FullyQualifiedName = fullyQualifiedName;
+			this.region = region;
+			modifiers = (ModifierEnum)m;
+//			Console.WriteLine(&quot;modifiers for field {0} are {1} were {2}&quot;, fullyQualifiedName, modifiers, m);
+		}
+		
+		public void SetModifiers(ModifierEnum m)
+		{
+			modifiers = m;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Field.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,24 +1,24 @@
-// created on 06.08.2003 at 12:34
-
-using MonoDevelop.Internal.Parser;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class Indexer : AbstractIndexer
-	{
-		public void AddModifier(ModifierEnum m)
-		{
-			modifiers = modifiers | m;
-		}
-		
-		public Indexer(ReturnType type, ParameterCollection parameters, Modifier m, IRegion region, IRegion bodyRegion)
-		{
-			returnType      = type;
-			this.parameters = parameters;
-			this.region     = region;
-			this.bodyRegion = bodyRegion;
-			modifiers = (ModifierEnum)m;
-		}
-	}
-}
+// created on 06.08.2003 at 12:34
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Indexer : AbstractIndexer
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Indexer(ReturnType type, ParameterCollection parameters, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			returnType      = type;
+			this.parameters = parameters;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Indexer.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,24 +1,24 @@
-// created on 06.08.2003 at 12:35
-using System;
-using MonoDevelop.Internal.Parser;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class Method : AbstractMethod
-	{
-		public void AddModifier(ModifierEnum m)
-		{
-			modifiers = modifiers | m;
-		}
-		
-		public Method(string name, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
-		{
-			FullyQualifiedName = name;
-			returnType = type;
-			this.region     = region;
-			this.bodyRegion = bodyRegion;
-			modifiers = (ModifierEnum)m;
-		}
-	}
-}
+// created on 06.08.2003 at 12:35
+using System;
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Method : AbstractMethod
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Method(string name, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = name;
+			returnType = type;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Method.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,15 +1,15 @@
-// created on 07.08.2003 at 20:12
-
-using MonoDevelop.Internal.Parser;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class Parameter : AbstractParameter
-	{
-		public Parameter(string name, ReturnType type)
-		{
-			Name = name;
-			returnType = type;
-		}
-	}
-}
+// created on 07.08.2003 at 20:12
+
+using MonoDevelop.Internal.Parser;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Parameter : AbstractParameter
+	{
+		public Parameter(string name, ReturnType type)
+		{
+			Name = name;
+			returnType = type;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Parameter.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,24 +1,24 @@
-// created on 06.08.2003 at 12:36
-
-using MonoDevelop.Internal.Parser;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class Property : AbstractProperty
-	{
-		public void AddModifier(ModifierEnum m)
-		{
-			modifiers = modifiers | m;
-		}
-		
-		public Property(string fullyQualifiedName, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
-		{
-			this.FullyQualifiedName = fullyQualifiedName;
-			returnType = type;
-			this.region = region;
-			this.bodyRegion = bodyRegion;
-			modifiers = (ModifierEnum)m;
-		}
-	}
-}
+// created on 06.08.2003 at 12:36
+
+using MonoDevelop.Internal.Parser;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class Property : AbstractProperty
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Property(string fullyQualifiedName, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			this.FullyQualifiedName = fullyQualifiedName;
+			returnType = type;
+			this.region = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/Property.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,52 +1,52 @@
-// created on 04.08.2003 at 18:08
-using System;
-using MonoDevelop.Internal.Parser;
-
-namespace VBBinding.Parser.SharpDevelopTree
-{
-	public class ReturnType : AbstractReturnType
-	{
-		public new int PointerNestingLevel {
-			get {
-				return base.pointerNestingLevel;
-			}
-			set {
-				base.pointerNestingLevel = value;
-			}
-		}
-		
-		public new int[] ArrayDimensions {
-			get {
-				return base.arrayDimensions;
-			}
-			set {
-				base.arrayDimensions = value;
-			}
-		}
-		
-		public ReturnType(string fullyQualifiedName)
-		{
-			base.FullyQualifiedName = fullyQualifiedName;
-//			Console.WriteLine(&quot;NEW RETURN TYPE WITH : &quot; + fullyQualifiedName);
-		}
-		
-		public ReturnType(string fullyQualifiedName, int[] arrayDimensions, int pointerNestingLevel)
-		{
-			this.FullyQualifiedName  = fullyQualifiedName;
-			this.arrayDimensions     = arrayDimensions;
-			this.pointerNestingLevel = pointerNestingLevel;
-		}
-		
-		public ReturnType(ICSharpCode.SharpRefactory.Parser.AST.VB.TypeReference type)
-		{
-			base.FullyQualifiedName  = type.SystemType == null ? type.Type : type.SystemType;
-			base.arrayDimensions     = type.RankSpecifier == null ? new int[] { } : (int[])type.RankSpecifier.ToArray(typeof(int));
-			base.pointerNestingLevel = 0;
-		}
-		
-		public ReturnType Clone()
-		{
-			return new ReturnType(FullyQualifiedName, arrayDimensions, pointerNestingLevel);
-		}
-	}
-}
+// created on 04.08.2003 at 18:08
+using System;
+using MonoDevelop.Internal.Parser;
+
+namespace VBBinding.Parser.SharpDevelopTree
+{
+	public class ReturnType : AbstractReturnType
+	{
+		public new int PointerNestingLevel {
+			get {
+				return base.pointerNestingLevel;
+			}
+			set {
+				base.pointerNestingLevel = value;
+			}
+		}
+		
+		public new int[] ArrayDimensions {
+			get {
+				return base.arrayDimensions;
+			}
+			set {
+				base.arrayDimensions = value;
+			}
+		}
+		
+		public ReturnType(string fullyQualifiedName)
+		{
+			base.FullyQualifiedName = fullyQualifiedName;
+//			Console.WriteLine(&quot;NEW RETURN TYPE WITH : &quot; + fullyQualifiedName);
+		}
+		
+		public ReturnType(string fullyQualifiedName, int[] arrayDimensions, int pointerNestingLevel)
+		{
+			this.FullyQualifiedName  = fullyQualifiedName;
+			this.arrayDimensions     = arrayDimensions;
+			this.pointerNestingLevel = pointerNestingLevel;
+		}
+		
+		public ReturnType(ICSharpCode.SharpRefactory.Parser.AST.VB.TypeReference type)
+		{
+			base.FullyQualifiedName  = type.SystemType == null ? type.Type : type.SystemType;
+			base.arrayDimensions     = type.RankSpecifier == null ? new int[] { } : (int[])type.RankSpecifier.ToArray(typeof(int));
+			base.pointerNestingLevel = 0;
+		}
+		
+		public ReturnType Clone()
+		{
+			return new ReturnType(FullyQualifiedName, arrayDimensions, pointerNestingLevel);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/Parser/SharpDevelopTree/ReturnType.cs
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ProjectNodeBuilder.cs
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,33 +1,33 @@
-using System.Reflection;
-using System.Runtime.CompilerServices;
-
-[assembly: System.CLSCompliantAttribute(true)]
-
-// Information about this assembly is defined by the following
-// attributes.
-//
-// change them to the information which is associated with the assembly
-// you compile.
-[assembly: AssemblyTitle(&quot;SharpRefactoryVB&quot;)]
-[assembly: AssemblyDescription(&quot;Parser for VB.NET&quot;)]
-[assembly: AssemblyConfiguration(&quot;&quot;)]
-[assembly: AssemblyCompany(&quot;&quot;)]
-[assembly: AssemblyProduct(&quot;&quot;)]
-[assembly: AssemblyCopyright(&quot;Markus Palme, Andrea Paatz, Mike Krueger, Levi Bard&quot;)]
-[assembly: AssemblyTrademark(&quot;&quot;)]
-[assembly: AssemblyCulture(&quot;&quot;)]
-
-// The assembly version has following format :
-//
-// Major.Minor.Build.Revision
-//
-// You can specify all values by your own or you can build default build and revision
-// numbers with the '*' character (the default):
-
-[assembly: AssemblyVersion(&quot;1.0.1.1649&quot;)]
-
-// The following attributes specify the key for the sign of your assembly. See the
-// .NET Framework documentation for more information about signing.
-// This is not required, if you don't want signing let these attributes like they're.
-[assembly: AssemblyDelaySign(false)]
-[assembly: AssemblyKeyFile(&quot;&quot;)]
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+[assembly: System.CLSCompliantAttribute(true)]
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+[assembly: AssemblyTitle(&quot;SharpRefactoryVB&quot;)]
+[assembly: AssemblyDescription(&quot;Parser for VB.NET&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;Markus Palme, Andrea Paatz, Mike Krueger, Levi Bard&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.1.1649&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/AssemblyInfo.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,1861 +1,1861 @@
-// CSharpVisitor.cs
-// Copyright (C) 2004 Markus Palme (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">markuspalme at gmx.de</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Reflection;
-using System.CodeDom;
-using System.Text;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-
-namespace ICSharpCode.SharpRefactory.PrettyPrinter.VB
-{
-	public class CSharpVisitor : IASTVisitor
-	{
-		readonly string newLineSep  = Environment.NewLine;
-		StringBuilder   sourceText  = new StringBuilder();
-		int             indentLevel = 0;
-		Errors          errors      = new Errors();
-		TypeDeclaration currentType = null;		
-		Stack   withExpressionStack = new Stack();
-		
-		public StringBuilder SourceText {
-			get {
-				return sourceText;
-			}
-		}
-		
-		public void AppendIndentation()
-		{
-			for (int i = 0; i &lt; indentLevel; ++i) {
-				sourceText.Append(&quot;\t&quot;);
-			}
-		}
-		
-		public void AppendNewLine()
-		{
-			sourceText.Append(newLineSep);
-		}
-		
-		public void AppendStatementEnd()
-		{
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-		}
-		
-		void DebugOutput(object o)
-		{
-//			Console.WriteLine(o.ToString());
-		}
-		
-		#region ICSharpCode.SharpRefactory.Parser.VB.IASTVisitor interface implementation
-		public object Visit(INode node, object data)
-		{
-			AppendIndentation();
-			sourceText.Append(&quot;// warning visited unknown node :&quot;);
-			sourceText.Append(node);
-			AppendNewLine();
-			return String.Empty;
-		}
-		
-		public object Visit(CompilationUnit compilationUnit, object data)
-		{
-			DebugOutput(compilationUnit);
-			compilationUnit.AcceptChildren(this, data);
-			return null;
-		}
-		
-#region GlobalScope
-		public object Visit(NamespaceDeclaration namespaceDeclaration, object data)
-		{
-			DebugOutput(namespaceDeclaration);
-			AppendIndentation();
-			sourceText.Append(&quot;namespace &quot;);
-			sourceText.Append(namespaceDeclaration.NameSpace);
-			AppendNewLine();
-			sourceText.Append(&quot;{&quot;);
-			AppendNewLine();
-			++indentLevel;
-			namespaceDeclaration.AcceptChildren(this, data);
-			--indentLevel;
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(ImportsStatement importsStatement, object data)
-		{
-			foreach (INode node in importsStatement.ImportClauses) {
-				node.AcceptVisitor(this, data);
-			}
-			return null;
-		}
-		
-		
-		public object Visit(ImportsDeclaration importsDeclaration, object data)
-		{
-			DebugOutput(importsDeclaration);
-			AppendIndentation();
-			sourceText.Append(&quot;using &quot;);
-			sourceText.Append(importsDeclaration.Namespace);
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data)
-		{
-			DebugOutput(importsAliasDeclaration);
-			AppendIndentation();
-			sourceText.Append(&quot;using &quot;);
-			sourceText.Append(importsAliasDeclaration.Alias);
-			sourceText.Append(&quot; = &quot;);
-			sourceText.Append(importsAliasDeclaration.Namespace);
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		
-		public object Visit(TypeDeclaration typeDeclaration, object data)
-		{
-			DebugOutput(typeDeclaration);
-			AppendAttributes(typeDeclaration.Attributes);
-			string modifier =  GetModifier(typeDeclaration.Modifier);
-			string type = String.Empty;
-			
-			switch (typeDeclaration.Type) {
-				case Types.Class:
-					type = &quot;class &quot;;
-					break;
-				case Types.Enum:
-					type = &quot;enum &quot;;
-					break;
-				case Types.Interface:
-					type = &quot;interface &quot;;
-					break;
-				case Types.Module:
-				case Types.Structure:
-					type = &quot;struct &quot;;
-					break;
-			}
-			AppendIndentation();
-			sourceText.Append(modifier);
-			sourceText.Append(type);
-			sourceText.Append(typeDeclaration.Name);
-			
-			bool hasBaseType = typeDeclaration.BaseType != null;
-			if (hasBaseType) {
-				sourceText.Append(&quot; : &quot;); 
-				sourceText.Append(ConvertTypeString(typeDeclaration.BaseType)); 
-			}
-			
-			if (typeDeclaration.BaseInterfaces != null &amp;&amp; typeDeclaration.BaseInterfaces.Count &gt; 0) {
-				if (!hasBaseType) {
-					sourceText.Append(&quot; : &quot;); 
-				} else {
-					sourceText.Append(&quot;, &quot;); 
-				}
-				for (int i = 0; i &lt; typeDeclaration.BaseInterfaces.Count; ++i) {
-					if (typeDeclaration.BaseInterfaces[i] is TypeReference) {
-						sourceText.Append((typeDeclaration.BaseInterfaces[i] as TypeReference).Type);
-					} else {
-						sourceText.Append(typeDeclaration.BaseInterfaces[i].ToString());
-					}
-					if (i + 1 &lt; typeDeclaration.BaseInterfaces.Count) {
-						sourceText.Append(&quot;, &quot;); 
-					}
-				}
-			}
-			AppendNewLine();
-			AppendIndentation();
-			sourceText.Append(&quot;{&quot;);
-			AppendNewLine();
-			++indentLevel;
-			TypeDeclaration oldType = currentType;
-			currentType = typeDeclaration;
-			typeDeclaration.AcceptChildren(this, data);
-			currentType = oldType;
-			--indentLevel;
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(DelegateDeclaration delegateDeclaration, object data)
-		{
-			DebugOutput(delegateDeclaration);
-			AppendAttributes(delegateDeclaration.Attributes);
-			AppendIndentation();
-			sourceText.Append(GetModifier(delegateDeclaration.Modifier));
-			sourceText.Append(&quot;delegate &quot;);
-			sourceText.Append(GetTypeString(delegateDeclaration.ReturnType));
-			sourceText.Append(&quot; &quot;);
-			sourceText.Append(delegateDeclaration.Name);
-			sourceText.Append(&quot;(&quot;);
-			AppendParameters(delegateDeclaration.Parameters);
-			sourceText.Append(&quot;);&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(EventDeclaration eventDeclaration, object data)
-		{
-			DebugOutput(eventDeclaration);
-			AppendAttributes(eventDeclaration.Attributes);
-			AppendIndentation();
-			sourceText.Append(GetModifier(eventDeclaration.Modifier));
-			sourceText.Append(&quot;event &quot;);
-			
-			if (eventDeclaration.TypeReference == null) {
-				sourceText.Append(eventDeclaration.Name);
-				sourceText.Append(&quot;EventHandler&quot;);
-			} else {
-				sourceText.Append(GetTypeString(eventDeclaration.TypeReference));
-			}
-			sourceText.Append(&quot; &quot;);
-			sourceText.Append(eventDeclaration.Name);
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			return null;
-		}
-#endregion
-
-#region TypeLevel
-		public object Visit(VariableDeclaration variableDeclaration, object data)
-		{
-			// called inside ENUMS
-//			AppendAttributes(field.Attributes);
-			AppendIndentation();
-			sourceText.Append(variableDeclaration.Name);
-			if (variableDeclaration.Initializer != null) {
-				sourceText.Append(&quot; = &quot;);
-				sourceText.Append(variableDeclaration.Initializer.AcceptVisitor(this, data));
-			}
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(FieldDeclaration fieldDeclaration, object data)
-		{
-			DebugOutput(fieldDeclaration);
-			
-			foreach (VariableDeclaration field in fieldDeclaration.Fields) {
-				AppendAttributes(fieldDeclaration.Attributes);
-				AppendIndentation();
-				if (currentType.Type == Types.Enum) {
-					if (fieldDeclaration.Fields.IndexOf(field) &gt; 0) {
-						sourceText.Append(&quot;, &quot;);
-					}
-					sourceText.Append(field.Name);
-					if (field.Initializer != null) {
-						sourceText.Append(&quot; = &quot;);
-						sourceText.Append(field.Initializer.AcceptVisitor(this, data).ToString());
-					}
-				} else {
-					if (fieldDeclaration.Modifier == Modifier.None) {
-						sourceText.Append(&quot; private &quot;);
-					} else {
-						sourceText.Append(GetModifier(fieldDeclaration.Modifier));
-					}
-					if (field.Type == null)
-						sourceText.Append(&quot;object&quot;);
-					else	
-						sourceText.Append(GetTypeString(field.Type));
-					sourceText.Append(&quot; &quot;);
-					sourceText.Append(field.Name);
-					if (field.Initializer != null) {
-						sourceText.Append(&quot; = &quot;);
-						sourceText.Append(field.Initializer.AcceptVisitor(this, data).ToString());
-					} else {
-						if (field.Type != null &amp;&amp; field.Type.Dimension != null) {
-							sourceText.Append(&quot; = new &quot;);
-							sourceText.Append(ConvertTypeString(field.Type.Type));
-							sourceText.Append(&quot;[&quot;);
-							sourceText.Append(GetExpressionList(field.Type.Dimension));
-							sourceText.Append(&quot;]&quot;);
-						}
-					}
-					sourceText.Append(&quot;;&quot;);
-					AppendNewLine();
-				}
-			}
-			
-			// if that's not the last enum member, add a comma
-			if (currentType.Type == Types.Enum) {
-				int pos = currentType.Children.IndexOf(fieldDeclaration);
-				if (pos &gt;= 0) {
-					for (int i = pos+1; i &lt; currentType.Children.Count; i++) {
-						if (currentType.Children[i] is FieldDeclaration) {
-							sourceText.Append(&quot;,&quot;);
-							break;
-						}
-					}
-				}
-				AppendNewLine();
-			}
-			return null;
-		}
-		
-		public object Visit(MethodDeclaration methodDeclaration, object data)
-		{
-			DebugOutput(methodDeclaration);
-			exitConstructStack.Push(new DictionaryEntry(typeof(MethodDeclaration), null));
-			
-			AppendNewLine();
-			AppendAttributes(methodDeclaration.Attributes);
-			AppendIndentation();
-			sourceText.Append(GetModifier(methodDeclaration.Modifier));
-			sourceText.Append(GetTypeString(methodDeclaration.TypeReference));
-			sourceText.Append(&quot; &quot;);
-			sourceText.Append(methodDeclaration.Name);
-			sourceText.Append(&quot;(&quot;);
-			AppendParameters(methodDeclaration.Parameters);
-			sourceText.Append(&quot;)&quot;);
-			
-			if (currentType.Type != Types.Interface &amp;&amp;
-				(methodDeclaration.Modifier &amp; Modifier.MustOverride) != Modifier.MustOverride)
-			{
-				AppendNewLine();
-				AppendIndentation();
-				sourceText.Append(&quot;{&quot;);
-				AppendNewLine();
-				if (methodDeclaration.Body != null) {
-					++indentLevel;
-					methodDeclaration.Body.AcceptVisitor(this, data);
-					GenerateExitConstructLabel();
-					--indentLevel;
-				}
-				AppendIndentation();
-				sourceText.Append(&quot;}&quot;);
-			} else {
-				sourceText.Append(&quot;;&quot;);
-			}
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(ConstructorDeclaration constructorDeclaration, object data)
-		{
-			DebugOutput(constructorDeclaration);
-			exitConstructStack.Push(new DictionaryEntry(typeof(MethodDeclaration), null));
-			AppendNewLine();
-			AppendAttributes(constructorDeclaration.Attributes);
-			AppendIndentation();
-			sourceText.Append(GetModifier(constructorDeclaration.Modifier));
-			sourceText.Append(this.currentType.Name);
-			sourceText.Append(&quot;(&quot;);
-			AppendParameters(constructorDeclaration.Parameters);
-			sourceText.Append(&quot;)&quot;);
-			
-			AppendNewLine();
-			AppendIndentation();
-			sourceText.Append(&quot;{&quot;);
-			AppendNewLine();
-			if (constructorDeclaration.Body != null) {
-				++indentLevel;
-				constructorDeclaration.Body.AcceptVisitor(this, data);
-				GenerateExitConstructLabel();
-				--indentLevel;
-			}
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(DeclareDeclaration declareDeclaration, object data)
-		{
-			DebugOutput(declareDeclaration);
-			AppendAttributes(declareDeclaration.Attributes);
-			AppendIndentation();
-			sourceText.Append(String.Format(&quot;[System.Runtime.InteropServices.DllImport({0}&quot;, declareDeclaration.Library));
-			if (declareDeclaration.Alias != null) {
-				sourceText.Append(String.Format(&quot;, EntryPoint={0}&quot;, declareDeclaration.Alias));
-			}
-			
-			switch (declareDeclaration.Charset) {
-				case CharsetModifier.ANSI:
-					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Ansi&quot;);
-					break;
-				case CharsetModifier.Unicode:
-					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Unicode&quot;);
-					break;
-				case CharsetModifier.Auto:
-					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Auto&quot;);
-					break;
-			}
-			
-			sourceText.Append(&quot;)]&quot;);
-			AppendNewLine();
-			AppendIndentation();
-			sourceText.Append(GetModifier(declareDeclaration.Modifier));
-			sourceText.Append(&quot;static extern &quot;);
-			sourceText.Append(GetTypeString(declareDeclaration.ReturnType));
-			sourceText.Append(&quot; &quot;);
-			sourceText.Append(declareDeclaration.Name);
-			sourceText.Append(&quot;(&quot;);
-			AppendParameters(declareDeclaration.Parameters);
-			sourceText.Append(&quot;);&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(PropertyDeclaration propertyDeclaration, object data)
-		{
-			DebugOutput(propertyDeclaration);
-			AppendNewLine();
-			AppendAttributes(propertyDeclaration.Attributes);
-			AppendIndentation();
-			sourceText.Append(GetModifier(propertyDeclaration.Modifier &amp; ~Modifier.ReadOnly));
-			
-			sourceText.Append(GetTypeString(propertyDeclaration.TypeReference));
-			sourceText.Append(&quot; &quot;);
-			sourceText.Append(propertyDeclaration.Name);
-			sourceText.Append(&quot; {&quot;);
-			AppendNewLine();
-			
-			if (currentType.Type != Types.Interface) {
-				if (propertyDeclaration.GetRegion != null) {
-					++indentLevel;
-					propertyDeclaration.GetRegion.AcceptVisitor(this, data);
-					--indentLevel;
-				}
-				
-				if (propertyDeclaration.SetRegion != null) {
-					++indentLevel;
-					propertyDeclaration.SetRegion.AcceptVisitor(this, data);
-					--indentLevel;
-				}
-				
-			}
-			// if abstract, add default get/set
-			if ((propertyDeclaration.Modifier &amp; Modifier.MustOverride) == Modifier.MustOverride &amp;&amp;
-			    propertyDeclaration.GetRegion == null &amp;&amp;
-			    propertyDeclaration.SetRegion == null) {
-				AppendIndentation();
-				sourceText.Append(&quot;get;&quot;);
-				AppendNewLine();
-				AppendIndentation();
-				sourceText.Append(&quot;set;&quot;);
-				AppendNewLine();
-			}			
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(PropertyGetRegion propertyGetRegion, object data)
-		{
-			DebugOutput(propertyGetRegion);
-			exitConstructStack.Push(new DictionaryEntry(typeof(PropertyDeclaration), null));
-			AppendAttributes(propertyGetRegion.Attributes);
-			AppendIndentation();
-			sourceText.Append(&quot;get {&quot;);
-			AppendNewLine();
-			if (propertyGetRegion.Block != null) {
-				++indentLevel;
-				propertyGetRegion.Block.AcceptVisitor(this, data);
-				--indentLevel;
-			} 
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			GenerateExitConstructLabel();
-			return null;
-		}
-		
-		public object Visit(PropertySetRegion propertySetRegion, object data)
-		{
-			DebugOutput(propertySetRegion);
-			exitConstructStack.Push(new DictionaryEntry(typeof(PropertyDeclaration), null));
-			AppendAttributes(propertySetRegion.Attributes);
-			AppendIndentation();
-			sourceText.Append(&quot;set {&quot;);
-			AppendNewLine();
-			if (propertySetRegion.Block != null) {
-				++indentLevel;
-				propertySetRegion.Block.AcceptVisitor(this, data);
-				--indentLevel;
-			}
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			GenerateExitConstructLabel();
-			return null;
-		}
-		
-		public object Visit(TypeReference typeReference, object data)
-		{
-			return ConvertTypeString(typeReference.Type);
-		}
-#endregion
-
-#region Statements
-		public object Visit(Statement statement, object data)
-		{
-			AppendIndentation();
-			sourceText.Append(&quot;// warning visited unknown statment :&quot;);
-			sourceText.Append(statement);
-			AppendNewLine();
-			return String.Empty;
-		}
-		
-		public object Visit(BlockStatement blockStatement, object data)
-		{
-			DebugOutput(blockStatement);
-			blockStatement.AcceptChildren(this, data);
-			return null;
-		}
-		
-		public object Visit(StatementExpression statementExpression, object data)
-		{
-			DebugOutput(statementExpression);
-			AppendIndentation();
-			if (statementExpression.Expression == null) {
-				sourceText.Append(&quot;// warning got empty statement expression :&quot;);
-				sourceText.Append(statementExpression);
-			} else {
-				sourceText.Append(statementExpression.Expression.AcceptVisitor(this, data).ToString());
-				sourceText.Append(&quot;;&quot;);
-			}
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
-		{
-			DebugOutput(localVariableDeclaration);
-			for (int i = 0; i &lt; localVariableDeclaration.Variables.Count; ++i) {
-				VariableDeclaration localVar = (VariableDeclaration)localVariableDeclaration.Variables[i];
-				AppendIndentation();
-				sourceText.Append(GetModifier(localVariableDeclaration.Modifier));
-				ArrayCreateExpression ace = localVar.Initializer as ArrayCreateExpression;
-				if (ace != null &amp;&amp; (ace.ArrayInitializer == null || ace.ArrayInitializer.CreateExpressions == null)) {
-					sourceText.Append(ConvertTypeString(ace.CreateType.Type));
-					sourceText.Append(&quot; &quot;);
-					sourceText.Append(localVar.Name);
-					sourceText.Append(&quot;[&quot;);
-					sourceText.Append(GetExpressionList(ace.Parameters));
-					sourceText.Append(&quot;]&quot;);
-					
-				} else {
-					if (localVar.Type == null) {
-						bool foundType = false;
-						for (int j = i + 1; j &lt; localVariableDeclaration.Variables.Count; ++j) {
-							VariableDeclaration nextLocalVar = (VariableDeclaration)localVariableDeclaration.Variables[j];
-							if (nextLocalVar.Type != null) {
-								sourceText.Append(GetTypeString(nextLocalVar.Type));
-								foundType = true;
-								break;
-							}
-						}
-						if (!foundType) {
-							sourceText.Append(&quot;object&quot;);
-						}
-					} else {
-						sourceText.Append(GetTypeString(localVar.Type));
-					}
-					sourceText.Append(&quot; &quot;);
-					sourceText.Append(localVar.Name);
-					if (localVar.Initializer != null) {
-						sourceText.Append(&quot; = &quot;);
-						sourceText.Append(localVar.Initializer.AcceptVisitor(this, data).ToString());
-					} else {
-						if (localVar.Type != null &amp;&amp; localVar.Type.Dimension != null) {
-							sourceText.Append(&quot; = new &quot;);
-							sourceText.Append(ConvertTypeString(localVar.Type.Type));
-							sourceText.Append(&quot;[&quot;);
-							sourceText.Append(GetExpressionList(localVar.Type.Dimension));
-							sourceText.Append(&quot;]&quot;);
-						}
-					}
-				}
-				sourceText.Append(&quot;;&quot;);
-				AppendNewLine();
-			}
-			return null;
-		}
-		
-		public object Visit(SimpleIfStatement ifStatement, object data)
-		{
-			AppendIndentation();
-			sourceText.Append(&quot;if (&quot;);
-			sourceText.Append(ifStatement.Condition.AcceptVisitor(this, data).ToString());
-			sourceText.Append(&quot;) {&quot;);
-			AppendNewLine();
-			++indentLevel;
-			foreach(Statement statement in ifStatement.Statements) {
-				statement.AcceptVisitor(this, data);
-			}
-			--indentLevel;
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			
-			if(ifStatement.ElseStatements != null &amp;&amp; ifStatement.ElseStatements.Count &gt; 0) {
-				sourceText.Append(&quot; else {&quot;);
-				AppendNewLine();
-				++indentLevel;
-				foreach(Statement statement in ifStatement.ElseStatements) {
-					statement.AcceptVisitor(this, data);
-				}
-				--indentLevel;
-				AppendIndentation();
-				sourceText.Append(&quot;}&quot;);
-			}
-			
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(IfStatement ifStatement, object data)
-		{
-			DebugOutput(ifStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;if (&quot;);
-			sourceText.Append(ifStatement.Condition.AcceptVisitor(this, data).ToString());
-			sourceText.Append(&quot;) {&quot;);
-			AppendNewLine();
-			++indentLevel;
-			ifStatement.EmbeddedStatement.AcceptVisitor(this, data);
-			--indentLevel;
-			
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			
-			if (ifStatement.ElseIfStatements != null) {
-				foreach (ElseIfSection elseIfSection in ifStatement.ElseIfStatements) {
-					sourceText.Append(&quot; else if (&quot;);
-					sourceText.Append(elseIfSection.Condition.AcceptVisitor(this, data).ToString());
-					sourceText.Append(&quot;) {&quot;);
-					AppendNewLine();
-					++indentLevel;
-					elseIfSection.EmbeddedStatement.AcceptVisitor(this, data);
-					--indentLevel;
-					AppendIndentation();
-					sourceText.Append(&quot;}&quot;);
-				}
-			}
-			
-			if (ifStatement.EmbeddedElseStatement != null) {
-				sourceText.Append(&quot; else {&quot;);
-				AppendNewLine();
-				++indentLevel;
-				ifStatement.EmbeddedElseStatement.AcceptVisitor(this, data);
-				--indentLevel;
-				AppendIndentation();
-				sourceText.Append(&quot;}&quot;);
-			}
-			
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(LabelStatement labelStatement, object data)
-		{
-			DebugOutput(labelStatement);
-			AppendIndentation();
-			sourceText.Append(labelStatement.Label);
-			sourceText.Append(&quot;:&quot;);
-			AppendNewLine();
-			if (labelStatement.EmbeddedStatement != null) {
-				labelStatement.EmbeddedStatement.AcceptVisitor(this, data);
-			}
-			return null;
-		}
-		
-		public object Visit(GoToStatement goToStatement, object data)
-		{
-			DebugOutput(goToStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;goto&quot;);
-			sourceText.Append(goToStatement.LabelName);
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(SelectStatement selectStatement, object data)
-		{
-			DebugOutput(selectStatement);
-			exitConstructStack.Push(new DictionaryEntry(typeof(SelectStatement), null));
-			string selectExpression = selectStatement.SelectExpression.AcceptVisitor(this, data).ToString();
-			AppendIndentation();
-			for (int j = 0; j &lt; selectStatement.SelectSections.Count; ++j) {
-				SelectSection selectSection = (SelectSection)selectStatement.SelectSections[j];
-				if (selectSection.CaseClauses.Count == 1 &amp;&amp; ((CaseClause)selectSection.CaseClauses[0]).IsDefaultCase) {
-					sourceText.Append(&quot;{&quot;);
-				} else {
-					sourceText.Append(&quot;if (&quot;);
-					for (int i = 0; i &lt; selectSection.CaseClauses.Count; ++i) {
-						CaseClause caseClause = (CaseClause)selectSection.CaseClauses[i];
-						if (caseClause.BoundaryExpression != null) {
-							sourceText.Append(caseClause.ComparisonExpression.AcceptVisitor(this, data));
-							sourceText.Append(&quot; &lt;= &quot;);
-							sourceText.Append(selectExpression);
-							sourceText.Append(&quot; &amp;&amp; &quot;);
-							sourceText.Append(selectExpression);
-							sourceText.Append(&quot; &lt;= &quot;);
-							sourceText.Append(caseClause.BoundaryExpression.AcceptVisitor(this, data));
-						} else {
-							if (caseClause.ComparisonExpression != null) {
-								sourceText.Append(selectExpression);
-								sourceText.Append(&quot; == &quot;);
-								sourceText.Append(caseClause.ComparisonExpression.AcceptVisitor(this, data));
-							} else {
-								// dummy default should never evaluate (only for default case)
-								sourceText.Append(&quot; true &quot;);
-							}
-						}
-						if (i + 1 &lt; selectSection.CaseClauses.Count) {
-							sourceText.Append(&quot; || &quot;);
-						}
-					}
-					sourceText.Append(&quot;) {&quot;);
-				}
-				AppendNewLine();
-				++indentLevel;
-				selectSection.EmbeddedStatement.AcceptChildren(this, data);
-				--indentLevel;
-				AppendIndentation();
-				sourceText.Append(&quot;}&quot;);
-				if (j + 1 &lt; selectStatement.SelectSections.Count) {
-					sourceText.Append(&quot; else &quot;);
-				} 
-			}
-			AppendNewLine();
-			GenerateExitConstructLabel();
-			return null;
-		}
-		
-		public object Visit(StopStatement stopStatement, object data)
-		{
-			DebugOutput(stopStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;Debugger.Break();&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(ResumeStatement resumeStatement, object data)
-		{
-			DebugOutput(resumeStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
-			sourceText.Append(resumeStatement);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(EraseStatement eraseStatement, object data)
-		{
-			DebugOutput(eraseStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
-			sourceText.Append(eraseStatement);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(ErrorStatement errorStatement, object data)
-		{
-			DebugOutput(errorStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
-			sourceText.Append(errorStatement);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(OnErrorStatement onErrorStatement, object data)
-		{
-			DebugOutput(onErrorStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
-			sourceText.Append(onErrorStatement);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(ReDimStatement reDimStatement, object data)
-		{
-			DebugOutput(reDimStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
-			sourceText.Append(reDimStatement);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(AddHandlerStatement addHandlerStatement, object data)
-		{
-			DebugOutput(addHandlerStatement);
-			AppendIndentation();
-			sourceText.Append(addHandlerStatement.EventExpression.AcceptVisitor(this, data));
-			sourceText.Append(&quot; += &quot;);
-			sourceText.Append(addHandlerStatement.HandlerExpression.AcceptVisitor(this, data));
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(RemoveHandlerStatement removeHandlerStatement, object data)
-		{
-			DebugOutput(removeHandlerStatement);
-			AppendIndentation();
-			sourceText.Append(removeHandlerStatement.EventExpression.AcceptVisitor(this, data));
-			sourceText.Append(&quot; -= &quot;);
-			sourceText.Append(removeHandlerStatement.HandlerExpression.AcceptVisitor(this, data));
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(DoLoopStatement doLoopStatement, object data)
-		{
-			DebugOutput(doLoopStatement);
-			exitConstructStack.Push(new DictionaryEntry(typeof(DoLoopStatement), null));
-			if (doLoopStatement.ConditionPosition == ConditionPosition.Start) {
-				AppendIndentation();
-				sourceText.Append(&quot;while (&quot;);
-				if (doLoopStatement.ConditionType == ConditionType.Until) {
-					sourceText.Append(&quot;!(&quot;);
-				}
-				sourceText.Append(doLoopStatement.Condition.AcceptVisitor(this, data).ToString());
-				if (doLoopStatement.ConditionType == ConditionType.Until) {
-					sourceText.Append(&quot;)&quot;);
-				}
-				sourceText.Append(&quot;) {&quot;);
-				
-				AppendNewLine();
-				
-				++indentLevel;
-				doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
-				--indentLevel;
-				
-				AppendIndentation();
-				sourceText.Append(&quot;}&quot;);
-				AppendNewLine();
-			} else {
-				AppendIndentation();
-				sourceText.Append(&quot;do {&quot;);
-				AppendNewLine();
-				
-				++indentLevel;
-				doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
-				--indentLevel;
-				
-				AppendIndentation();
-				sourceText.Append(&quot;} while (&quot;);
-				if (doLoopStatement.Condition == null) {
-					sourceText.Append(&quot;true&quot;);
-				} else {
-					if (doLoopStatement.ConditionType == ConditionType.Until) {
-						sourceText.Append(&quot;!(&quot;);
-					}
-					sourceText.Append(doLoopStatement.Condition.AcceptVisitor(this, data).ToString());
-					if (doLoopStatement.ConditionType == ConditionType.Until) {
-						sourceText.Append(&quot;)&quot;);
-					}
-				}
-				sourceText.Append(&quot;);&quot;);
-				AppendNewLine();
-			}
-			GenerateExitConstructLabel();
-			return null;
-		}
-		
-		public object Visit(EndStatement endStatement, object data)
-		{
-			DebugOutput(endStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;System.Environment.Exit(0);&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		Stack exitConstructStack = new Stack();
-		int   exitLabelCount     = 0;
-		public string AddExitOnConstructStack(Type exitType)
-		{
-			string labelName = String.Concat(&quot;exit&quot; + exitType.Name, exitLabelCount++);
-			if (exitConstructStack.Count &gt; 0) {
-				object[] exitArray = exitConstructStack.ToArray();
-				for (int i = exitArray.Length - 1; i &gt;= 0; --i) {
-					if ((Type)((DictionaryEntry)exitArray[i]).Key == exitType) {
-						exitArray[i] = new DictionaryEntry(((DictionaryEntry)exitArray[i]).Key, labelName);
-					}
-				}
-				Array.Reverse(exitArray);
-				exitConstructStack = new Stack(exitArray);
-			}
-			return String.Concat(labelName);
-		}
-		
-		public void GenerateExitConstructLabel()
-		{
-			if (exitConstructStack.Count &gt; 0) {
-				DictionaryEntry entry = (DictionaryEntry)exitConstructStack.Pop();
-				if (entry.Value != null) {
-					AppendIndentation();
-					sourceText.Append(entry.Value.ToString());
-					sourceText.Append(&quot;: ;&quot;);
-					AppendNewLine();
-				}
-			}
-		}
-		
-		public object Visit(ExitStatement exitStatement, object data)
-		{
-			DebugOutput(exitStatement);
-			Type   exitType  = null;
-			switch (exitStatement.ExitType) {
-				case ExitType.Sub:
-					sourceText.Append(&quot;return;&quot;);
-					AppendNewLine();
-					return null;
-				case ExitType.Function:
-					sourceText.Append(&quot;return null;&quot;);
-					AppendNewLine();
-					return null;
-				case ExitType.Property:
-					exitType = typeof(PropertyDeclaration);
-					break;
-				case ExitType.Do:
-					exitType = typeof(DoLoopStatement);
-					break;
-				case ExitType.For:
-					exitType = typeof(ForStatement);
-					break;
-				case ExitType.While:
-					exitType = typeof(WhileStatement);
-					break;
-				case ExitType.Select:
-					exitType = typeof(SelectStatement);
-					break;
-				case ExitType.Try:
-					exitType = typeof(TryCatchStatement);
-					break;
-			}
-			if (exitType != null) {
-				AppendIndentation();
-				sourceText.Append(&quot;goto &quot;);
-				sourceText.Append(AddExitOnConstructStack(exitType));
-				sourceText.Append(&quot;;&quot;);
-				AppendNewLine();
-			} else {
-				AppendIndentation();
-				sourceText.Append(&quot;ERROR IN GENERATION: EXIT TO &quot;);
-				sourceText.Append(exitStatement.ExitType);
-				sourceText.Append(&quot; FAILED!!!&quot;);
-				AppendNewLine();
-			}
-			return null;
-		}
-		
-		public object Visit(ForeachStatement foreachStatement, object data)
-		{
-			DebugOutput(foreachStatement);
-			exitConstructStack.Push(new DictionaryEntry(typeof(ForStatement), null));
-			
-			AppendIndentation();
-			sourceText.Append(&quot;foreach (&quot;);
-			if (foreachStatement.LoopControlVariable.Type != null) {
-				sourceText.Append(this.GetTypeString(foreachStatement.LoopControlVariable.Type));
-				sourceText.Append(&quot; &quot;);
-			}
-			sourceText.Append(foreachStatement.LoopControlVariable.Name);
-			sourceText.Append(&quot; in &quot;);
-			sourceText.Append(foreachStatement.Expression.AcceptVisitor(this, data));
-			sourceText.Append(&quot;) {&quot;);
-			AppendNewLine();
-			
-			++indentLevel;
-			foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
-			--indentLevel;
-			
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			GenerateExitConstructLabel();
-			return null;
-		}
-		
-		public object Visit(ForStatement forStatement, object data)
-		{
-			DebugOutput(forStatement);
-			exitConstructStack.Push(new DictionaryEntry(typeof(ForStatement), null));
-			bool   stepIsNegative = false;
-			string step           = null;
-			if (forStatement.Step != null) {
-				step = forStatement.Step.AcceptVisitor(this, data).ToString();
-				stepIsNegative = step.StartsWith(&quot;-&quot;);
-			}
-			
-			AppendIndentation();
-			sourceText.Append(&quot;for (&quot;);
-			
-			
-			if (forStatement.LoopControlVariable.Type != null) {
-				sourceText.Append(this.GetTypeString(forStatement.LoopControlVariable.Type));
-				sourceText.Append(&quot; &quot;);
-			}
-			sourceText.Append(forStatement.LoopControlVariable.Name);
-			sourceText.Append(&quot; = &quot;);
-			
-			sourceText.Append(forStatement.Start.AcceptVisitor(this, data));
-			sourceText.Append(&quot;; &quot;);
-			sourceText.Append(forStatement.LoopControlVariable.Name);
-			sourceText.Append(stepIsNegative ? &quot; &gt;= &quot; : &quot; &lt;= &quot;);
-			sourceText.Append(forStatement.End.AcceptVisitor(this, data));
-			sourceText.Append(&quot;; &quot;);
-			if (forStatement.Step == null) {
-				sourceText.Append(forStatement.LoopControlVariable.Name);
-				sourceText.Append(&quot;++&quot;);
-			} else {
-				sourceText.Append(forStatement.LoopControlVariable.Name);
-				if (stepIsNegative) {
-					if (step == &quot;-1&quot;) {
-						sourceText.Append(&quot;--&quot;);
-					} else {
-						sourceText.Append(&quot; -= &quot;);
-						sourceText.Append(step.Substring(1));
-					}
-				} else {
-					sourceText.Append(&quot; += &quot;);
-					sourceText.Append(step);
-				}
-			}
-			sourceText.Append(&quot;) {&quot;);
-			AppendNewLine();
-			
-			++indentLevel;
-			forStatement.EmbeddedStatement.AcceptVisitor(this, data);
-			--indentLevel;
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			GenerateExitConstructLabel();
-			
-			return null;
-		}
-		
-		public object Visit(LockStatement lockStatement, object data)
-		{
-			DebugOutput(lockStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;lock (&quot;);
-			sourceText.Append(lockStatement.LockExpression.AcceptVisitor(this, data));
-			sourceText.Append(&quot;) {&quot;);
-			AppendNewLine();
-			
-			++indentLevel;
-			lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
-			--indentLevel;
-			
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(RaiseEventStatement raiseEventStatement, object data)
-		{
-			DebugOutput(raiseEventStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;if (&quot;);
-			sourceText.Append(raiseEventStatement.EventName);
-			sourceText.Append(&quot; != null) {&quot;);
-			AppendNewLine();
-			
-			++indentLevel;
-			AppendIndentation();
-			sourceText.Append(raiseEventStatement.EventName);
-			sourceText.Append(GetParameters(raiseEventStatement.Parameters));
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			--indentLevel;
-			
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		
-		public object Visit(ReturnStatement returnStatement, object data)
-		{
-			DebugOutput(returnStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;return&quot;);
-			if (returnStatement.ReturnExpression != null) {
-				sourceText.Append(&quot; &quot;);
-				sourceText.Append(returnStatement.ReturnExpression.AcceptVisitor(this,data));
-			}
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(ThrowStatement throwStatement, object data)
-		{
-			DebugOutput(throwStatement);
-			AppendIndentation();
-			sourceText.Append(&quot;throw&quot;);
-			if (throwStatement.ThrowExpression != null) {
-				sourceText.Append(&quot; &quot;);
-				sourceText.Append(throwStatement.ThrowExpression.AcceptVisitor(this, data).ToString());
-			}
-			sourceText.Append(&quot;;&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(TryCatchStatement tryCatchStatement, object data)
-		{
-			DebugOutput(tryCatchStatement);
-			exitConstructStack.Push(new DictionaryEntry(typeof(TryCatchStatement), null));
-			AppendIndentation();
-			sourceText.Append(&quot;try {&quot;);
-			AppendNewLine();
-			
-			++indentLevel;
-			tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
-			--indentLevel;
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			if (tryCatchStatement.CatchClauses != null) {
-				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
-					sourceText.Append(&quot; catch &quot;);
-					if (catchClause.Type != null) {
-						sourceText.Append(&quot;(&quot;);
-						sourceText.Append(GetTypeString(catchClause.Type));
-						if (catchClause.VariableName != null) {
-							sourceText.Append(&quot; &quot;);
-							sourceText.Append(catchClause.VariableName);
-						}
-						sourceText.Append(&quot;) &quot;);
-					}
-					sourceText.Append(&quot;{&quot;);
-					AppendNewLine();
-					++indentLevel;
-					if (catchClause.Condition != null) {
-						AppendIndentation();
-						sourceText.Append(&quot;//TODO: review the original conditional catch clause&quot;);
-						AppendNewLine();
-						AppendIndentation();
-						sourceText.Append(&quot;if (&quot;);
-						sourceText.Append(catchClause.Condition.AcceptVisitor(this, data));
-						sourceText.Append(&quot;) {&quot;);
-						AppendNewLine();
-						++indentLevel;
-						catchClause.StatementBlock.AcceptVisitor(this, data);
-						--indentLevel;
-						AppendIndentation();
-						sourceText.Append(&quot;}&quot;);
-						AppendNewLine();
-					} else {
-						catchClause.StatementBlock.AcceptVisitor(this, data);
-					}
-					--indentLevel;
-					AppendIndentation();
-					sourceText.Append(&quot;}&quot;);
-				}
-			}
-			
-			if (tryCatchStatement.FinallyBlock != null) {
-				sourceText.Append(&quot; finally {&quot;);
-				AppendNewLine();
-				
-				++indentLevel;
-				tryCatchStatement.FinallyBlock.AcceptVisitor(this, data);
-				--indentLevel;
-				AppendIndentation();
-				sourceText.Append(&quot;}&quot;);
-			}
-			AppendNewLine();
-			GenerateExitConstructLabel();
-			return null;
-		}
-		
-		public object Visit(WhileStatement whileStatement, object data)
-		{
-			DebugOutput(whileStatement);
-			exitConstructStack.Push(new DictionaryEntry(typeof(WhileStatement), null));
-			AppendIndentation();
-			sourceText.Append(&quot;while (&quot;);
-			sourceText.Append(whileStatement.Condition.AcceptVisitor(this, data).ToString());
-			sourceText.Append(&quot;) {&quot;);
-			AppendNewLine();
-			
-			++indentLevel;
-			whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
-			--indentLevel;
-			
-			AppendIndentation();
-			sourceText.Append(&quot;}&quot;);
-			AppendNewLine();
-			GenerateExitConstructLabel();
-			return null;
-		}
-		
-		public object Visit(WithStatement withStatement, object data)
-		{
-			DebugOutput(withStatement);
-			withExpressionStack.Push(withStatement.WithExpression);
-			withStatement.Body.AcceptVisitor(this, data);
-			withExpressionStack.Pop();
-			return null;
-		}
-		
-		public object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data)
-		{
-			DebugOutput(attribute);
-			AppendIndentation();
-			sourceText.Append(&quot;// Should never happen (this is handled in AttributeSection) attribute was:&quot;);
-			sourceText.Append(attribute);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(AttributeSection attributeSection, object data)
-		{
-			DebugOutput(attributeSection);
-			AppendIndentation();
-			sourceText.Append(&quot;[&quot;);
-			if (attributeSection.AttributeTarget != null &amp;&amp; attributeSection.AttributeTarget.Length &gt; 0) {
-				sourceText.Append(attributeSection.AttributeTarget);
-				sourceText.Append(&quot;: &quot;);
-			}
-			for (int j = 0; j &lt; attributeSection.Attributes.Count; ++j) {
-				ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attr = (ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute)attributeSection.Attributes[j];
-				
-				sourceText.Append(attr.Name);
-				sourceText.Append(&quot;(&quot;);
-				for (int i = 0; i &lt; attr.PositionalArguments.Count; ++i) {
-					Expression expr = (Expression)attr.PositionalArguments[i];
-					sourceText.Append(expr.AcceptVisitor(this, data).ToString());
-					if (i + 1 &lt; attr.PositionalArguments.Count | attr.NamedArguments.Count &gt; 0) { 
-						sourceText.Append(&quot;, &quot;);
-					}
-				}
-
-				for (int i = 0; i &lt; attr.NamedArguments.Count; ++i) {
-					NamedArgumentExpression named = (NamedArgumentExpression)attr.NamedArguments[i];
-					sourceText.Append(named.AcceptVisitor(this, data).ToString());
-					if (i + 1 &lt; attr.NamedArguments.Count) { 
-						sourceText.Append(&quot;, &quot;);
-					}
-				}
-				sourceText.Append(&quot;)&quot;);
-				if (j + 1 &lt; attributeSection.Attributes.Count) {
-					sourceText.Append(&quot;, &quot;);
-				}
-			}
-			sourceText.Append(&quot;]&quot;);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(OptionCompareDeclaration optionCompareDeclaration, object data)
-		{
-			DebugOutput(optionCompareDeclaration);
-			AppendIndentation();
-			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
-			sourceText.Append(optionCompareDeclaration);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data)
-		{
-			DebugOutput(optionExplicitDeclaration);
-			AppendIndentation();
-			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
-			sourceText.Append(optionExplicitDeclaration);
-			AppendNewLine();
-			return null;
-		}
-		
-		public object Visit(OptionStrictDeclaration optionStrictDeclaration, object data)
-		{
-			DebugOutput(optionStrictDeclaration);
-			AppendIndentation();
-			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
-			sourceText.Append(optionStrictDeclaration);
-			AppendNewLine();
-			return null;
-		}
-#endregion
-
-#region Expressions
-		public object Visit(PrimitiveExpression primitiveExpression, object data)
-		{
-			DebugOutput(primitiveExpression);
-			if (primitiveExpression.Value == null) {
-				return &quot;null&quot;;
-			}
-			if (primitiveExpression.Value is bool) {
-				if ((bool)primitiveExpression.Value) {
-					return &quot;true&quot;;
-				}
-				return &quot;false&quot;;
-			}
-			
-			if (primitiveExpression.Value is string) {
-				string s = primitiveExpression.Value.ToString();
-				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
-				s = s.Replace(&quot;\&quot;&quot;,&quot;\\\&quot;&quot;);
-				return String.Concat('&quot;', s, '&quot;');
-			}
-			
-			if (primitiveExpression.Value is char) {
-				string s = primitiveExpression.Value.ToString();
-				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
-				s = s.Replace(&quot;\'&quot;,&quot;\\\'&quot;);
-				return String.Concat(&quot;'&quot;, s, &quot;'&quot;);
-			}
-			
-			if (primitiveExpression.Value is System.DateTime) {
-				string s = primitiveExpression.StringValue;
-				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
-				s = s.Replace(&quot;\&quot;&quot;,&quot;\\\&quot;&quot;);
-				return String.Concat(&quot;System.DateTime.Parse(\&quot;&quot;, s, &quot;\&quot;)&quot;);
-			}
-
-			return primitiveExpression.Value;
-		}
-		
-		public object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
-		{
-			DebugOutput(binaryOperatorExpression);
-			string op   = null;
-			string left = binaryOperatorExpression.Left.AcceptVisitor(this, data).ToString();
-			string right = binaryOperatorExpression.Right.AcceptVisitor(this, data).ToString();
-			
-			switch (binaryOperatorExpression.Op) {
-				case BinaryOperatorType.Concat:
-					op = &quot; + &quot;;
-					break;
-				
-				case BinaryOperatorType.Add:
-					op = &quot; + &quot;;
-					break;
-				
-				case BinaryOperatorType.Subtract:
-					op = &quot; - &quot;;
-					break;
-				
-				case BinaryOperatorType.Multiply:
-					op = &quot; * &quot;;
-					break;
-				
-				case BinaryOperatorType.DivideInteger:
-				case BinaryOperatorType.Divide:
-					op = &quot; / &quot;;
-					break;
-				
-				case BinaryOperatorType.Modulus:
-					op = &quot; % &quot;;
-					break;
-				
-				case BinaryOperatorType.ShiftLeft:
-					op = &quot; &lt;&lt; &quot;;
-					break;
-				
-				case BinaryOperatorType.ShiftRight:
-					op = &quot; &gt;&gt; &quot;;
-					break;
-				
-				case BinaryOperatorType.BitwiseAnd:
-					op = &quot; &amp; &quot;;
-					break;
-				case BinaryOperatorType.BitwiseOr:
-					op = &quot; | &quot;;
-					break;
-				case BinaryOperatorType.ExclusiveOr:
-					op = &quot; ^ &quot;;
-					break;
-				
-				case BinaryOperatorType.BooleanAnd:
-					op = &quot; &amp;&amp; &quot;;
-					break;
-				case BinaryOperatorType.BooleanOr:
-					op = &quot; || &quot;;
-					break;
-				
-				case BinaryOperatorType.Equality:
-					op = &quot; == &quot;;
-					break;
-				case BinaryOperatorType.GreaterThan:
-					op = &quot; &gt; &quot;;
-					break;
-				case BinaryOperatorType.GreaterThanOrEqual:
-					op = &quot; &gt;= &quot;;
-					break;
-				case BinaryOperatorType.InEquality:
-					op = &quot; != &quot;;
-					break;
-				case BinaryOperatorType.LessThan:
-					op = &quot; &lt; &quot;;
-					break;
-				case BinaryOperatorType.IS:
-					op = &quot; == &quot;;
-					break;
-				case BinaryOperatorType.LessThanOrEqual:
-					op = &quot; &lt;= &quot;;
-					break;
-				case BinaryOperatorType.Power:
-					return &quot;Math.Pow(&quot; + left + &quot;, &quot; + right + &quot;)&quot;;
-				default:
-					throw new Exception(&quot;Unknown binary operator:&quot; + binaryOperatorExpression.Op);
-			}
-			
-			return String.Concat(left,
-			                     op,
-			                     right);
-		}
-		
-		public object Visit(ParenthesizedExpression parenthesizedExpression, object data)
-		{
-			DebugOutput(parenthesizedExpression);
-			string innerExpr = parenthesizedExpression.Expression.AcceptVisitor(this, data).ToString();
-			return String.Concat(&quot;(&quot;, innerExpr, &quot;)&quot;);
-		}
-		
-		public object Visit(InvocationExpression invocationExpression, object data)
-		{
-			DebugOutput(invocationExpression);
-			return String.Concat(invocationExpression.TargetObject.AcceptVisitor(this, data),
-			                     GetParameters(invocationExpression.Parameters)
-			                     );
-		}
-		
-		public object Visit(IdentifierExpression identifierExpression, object data)
-		{
-			DebugOutput(identifierExpression);
-			return identifierExpression.Identifier;
-		}
-		
-		public object Visit(TypeReferenceExpression typeReferenceExpression, object data)
-		{
-			DebugOutput(typeReferenceExpression);
-			return GetTypeString(typeReferenceExpression.TypeReference);
-		}
-		
-		public object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
-		{
-			DebugOutput(unaryOperatorExpression);
-			switch (unaryOperatorExpression.Op) {
-				case UnaryOperatorType.BitNot:
-					return String.Concat(&quot;~&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
-				case UnaryOperatorType.Decrement:
-					return String.Concat(&quot;--&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
-				case UnaryOperatorType.Increment:
-					return String.Concat(&quot;++&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
-				case UnaryOperatorType.Minus:
-					return String.Concat(&quot;-&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
-				case UnaryOperatorType.Not:
-					return String.Concat(&quot;!(&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
-				case UnaryOperatorType.Plus:
-					return String.Concat(&quot;+&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
-				case UnaryOperatorType.PostDecrement:
-					return String.Concat(unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;--&quot;);
-				case UnaryOperatorType.PostIncrement:
-					return String.Concat(unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;++&quot;);
-			}
-			throw new System.NotSupportedException();
-		}
-		
-		public object Visit(AssignmentExpression assignmentExpression, object data)
-		{
-			DebugOutput(assignmentExpression);
-			string op    = null;
-			string left  = assignmentExpression.Left.AcceptVisitor(this, data).ToString();
-			string right = assignmentExpression.Right.AcceptVisitor(this, data).ToString();
-			
-			switch (assignmentExpression.Op) {
-				case AssignmentOperatorType.Assign:
-					op = &quot; = &quot;;
-					break;
-				case AssignmentOperatorType.ConcatString:
-				case AssignmentOperatorType.Add:
-					op = &quot; += &quot;;
-					break;
-				case AssignmentOperatorType.Subtract:
-					op = &quot; -= &quot;;
-					break;
-				case AssignmentOperatorType.Multiply:
-					op = &quot; *= &quot;;
-					break;
-				case AssignmentOperatorType.Divide:
-					op = &quot; /= &quot;;
-					break;
-				case AssignmentOperatorType.ShiftLeft:
-					op = &quot; &lt;&lt;= &quot;;
-					break;
-				case AssignmentOperatorType.ShiftRight:
-					op = &quot; &gt;&gt;= &quot;;
-					break;
-				
-				case AssignmentOperatorType.ExclusiveOr:
-					op = &quot; ^= &quot;;
-					break;
-				case AssignmentOperatorType.Modulus:
-					op = &quot; %= &quot;;
-					break;
-				case AssignmentOperatorType.BitwiseAnd:
-					op = &quot; &amp;= &quot;;
-					break;
-				case AssignmentOperatorType.BitwiseOr:
-					op = &quot; |= &quot;;
-					break;
-			}
-			return String.Concat(left,
-			                     op,
-			                     right);
-		}
-		
-		public object Visit(CastExpression castExpression, object data)
-		{
-			DebugOutput(castExpression);
-			string type     = ConvertTypeString(castExpression.CastTo.Type);
-			string castExpr = castExpression.Expression.AcceptVisitor(this, data).ToString();
-			
-			if (castExpression.IsSpecializedCast) {
-				switch (type) {
-					case &quot;System.Object&quot;:
-						break;
-					default:
-						string convToType = type.Substring(&quot;System.&quot;.Length);
-						return String.Format(&quot;System.Convert.To{0}({1})&quot;, convToType, castExpr);
-				}
-			}
-			return String.Format(&quot;(({0})({1}))&quot;, type, castExpr);
-		}
-		
-		public object Visit(ThisReferenceExpression thisReferenceExpression, object data)
-		{
-			DebugOutput(thisReferenceExpression);
-			return &quot;this&quot;;
-		}
-		
-		public object Visit(BaseReferenceExpression baseReferenceExpression, object data)
-		{
-			DebugOutput(baseReferenceExpression);
-			return &quot;base&quot;;
-		}
-		
-		public object Visit(ObjectCreateExpression objectCreateExpression, object data)
-		{
-			return String.Format(&quot;new {0}{1}&quot;,
-			                     GetTypeString(objectCreateExpression.CreateType),
-			                     GetParameters(objectCreateExpression.Parameters)
-			                     );
-		}
-		
-		public object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
-		{
-			DebugOutput(parameterDeclarationExpression);
-			// Is handled in the AppendParameters method
-			return &quot;// should never happen&quot; + parameterDeclarationExpression;
-		}
-		
-		public object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data)
-		{
-			DebugOutput(fieldReferenceOrInvocationExpression);
-			INode target = fieldReferenceOrInvocationExpression.TargetObject;
-			if (target == null &amp;&amp; withExpressionStack.Count &gt; 0) {
-				target = withExpressionStack.Peek() as INode;
-			}
-			return String.Concat(target.AcceptVisitor(this, data),
-			                     '.',
-			                     fieldReferenceOrInvocationExpression.FieldName);
-		}
-		
-		public object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
-		{
-			DebugOutput(arrayInitializerExpression);
-			if (arrayInitializerExpression.CreateExpressions.Count &gt; 0) {
-				return String.Concat(&quot;{&quot;,
-				                     GetExpressionList(arrayInitializerExpression.CreateExpressions),
-				                     &quot;}&quot;);
-			}
-			return String.Empty;
-		}
-		
-		public object Visit(GetTypeExpression getTypeExpression, object data)
-		{
-			DebugOutput(getTypeExpression);
-			return String.Concat(&quot;typeof(&quot;,
-			                     this.GetTypeString(getTypeExpression.Type),
-			                     &quot;)&quot;);
-		}
-		
-		public object Visit(ClassReferenceExpression classReferenceExpression, object data)
-		{
-			// ALMOST THE SAME AS '.this' but ignores all overridings from virtual
-			// members. How can this done in C# ?
-			DebugOutput(classReferenceExpression);
-			return &quot;TODO : &quot; + classReferenceExpression;
-		}
-		
-		public object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
-		{
-			// I think the LoopControlVariableExpression is only used in the for statement
-			// and there it is handled
-			DebugOutput(loopControlVariableExpression);
-			return &quot;Should Never happen : &quot; + loopControlVariableExpression;
-		}
-		
-		public object Visit(NamedArgumentExpression namedArgumentExpression, object data)
-		{
-			return String.Concat(namedArgumentExpression.Parametername,
-			                     &quot;=&quot;,
-			                    namedArgumentExpression.Expression.AcceptVisitor(this, data));
-		}
-		
-		public object Visit(AddressOfExpression addressOfExpression, object data)
-		{
-			DebugOutput(addressOfExpression);
-			string procedureName    = addressOfExpression.Procedure.AcceptVisitor(this, data).ToString();
-			string eventHandlerType = &quot;EventHandler&quot;;
-			bool   foundEventHandler = false;
-			// try to resolve the type of the eventhandler using a little trick :)
-			foreach (INode node in currentType.Children) {
-				MethodDeclaration md = node as MethodDeclaration;
-				if (md != null &amp;&amp; md.Parameters != null &amp;&amp; md.Parameters.Count &gt; 0) {
-					if (procedureName == md.Name || procedureName.EndsWith(&quot;.&quot; + md.Name)) {
-						ParameterDeclarationExpression pde = (ParameterDeclarationExpression)md.Parameters[md.Parameters.Count - 1];
-						string typeName = GetTypeString(pde.TypeReference);
-						if (typeName.EndsWith(&quot;Args&quot;)) {
-							eventHandlerType = typeName.Substring(0, typeName.Length - &quot;Args&quot;.Length) + &quot;Handler&quot;;
-							foundEventHandler = true;
-						}
-					}
-				}
-			}
-			return String.Concat(foundEventHandler ? &quot;new &quot; : &quot;/* might be wrong, please check */ new &quot;,
-			                     eventHandlerType,
-			                     &quot;(&quot;,
-			                     procedureName,
-			                     &quot;)&quot;);
-		}
-		
-		public object Visit(TypeOfExpression typeOfExpression, object data)
-		{
-			DebugOutput(typeOfExpression);
-			return String.Concat(typeOfExpression.Expression.AcceptVisitor(this, data),
-			                     &quot; is &quot;,
-			                     GetTypeString(typeOfExpression.Type));
-		}
-		
-		public object Visit(ArrayCreateExpression ace, object data)
-		{
-			DebugOutput(ace);
-			
-			return String.Concat(&quot;new &quot;,
-			                     GetTypeString(ace.CreateType),
-			                     &quot;[&quot;,
-			                     GetExpressionList(ace.Parameters),
-			                     &quot;]&quot;,
-			                     ace.ArrayInitializer.AcceptVisitor(this, data));
-		}
-#endregion
-#endregion
-		
-		public void AppendAttributes(ArrayList attr)
-		{
-			if (attr != null) {
-				foreach (AttributeSection section in attr) {
-					section.AcceptVisitor(this, null);
-				}
-			}
-		}
-		
-		public void AppendParameters(ArrayList parameters)
-		{
-			if (parameters == null) {
-				return;
-			}
-			for (int i = 0; i &lt; parameters.Count; ++i) {
-				ParameterDeclarationExpression pde = (ParameterDeclarationExpression)parameters[i];
-				AppendAttributes(pde.Attributes);
-				
-				if ((pde.ParamModifiers.Modifier &amp; ParamModifier.ByRef) == ParamModifier.ByRef) {
-					sourceText.Append(&quot;ref &quot;);
-				} else if ((pde.ParamModifiers.Modifier &amp; ParamModifier.ParamArray) == ParamModifier.ParamArray) {
-					sourceText.Append(&quot;params &quot;);
-				}
-				
-				sourceText.Append(GetTypeString(pde.TypeReference));
-				sourceText.Append(&quot; &quot;);
-				sourceText.Append(pde.ParameterName);
-				if (i + 1 &lt; parameters.Count) {
-					sourceText.Append(&quot;, &quot;);
-				}
-			}
-		}
-		
-		string ConvertTypeString(string typeString)
-		{
-			switch (typeString.ToLower()) {
-				case &quot;boolean&quot;:
-					return &quot;bool&quot;;
-				case &quot;string&quot;:
-					return &quot;string&quot;;
-				case &quot;char&quot;:
-					return &quot;char&quot;;
-				case &quot;double&quot;:
-					return &quot;double&quot;;
-				case &quot;single&quot;:
-					return &quot;float&quot;;
-				case &quot;decimal&quot;:
-					return &quot;decimal&quot;;
-				case &quot;date&quot;:
-					return &quot;System.DateTime&quot;;
-				case &quot;long&quot;:
-					return &quot;long&quot;;
-				case &quot;integer&quot;:
-					return &quot;int&quot;;
-				case &quot;short&quot;:
-					return &quot;short&quot;;
-				case &quot;byte&quot;:
-					return &quot;byte&quot;;
-				case &quot;void&quot;:
-					return &quot;void&quot;;
-				case &quot;system.object&quot;:
-				case &quot;object&quot;:
-					return &quot;object&quot;;
-				case &quot;system.uint64&quot;:
-					return &quot;ulong&quot;;
-				case &quot;system.uint32&quot;:
-					return &quot;uint&quot;;
-				case &quot;system.uint16&quot;:
-					return &quot;ushort&quot;;
-			}
-			return typeString;
-		}
-		
-		string GetTypeString(TypeReference typeRef)
-		{
-			if (typeRef == null) {
-				return &quot;void&quot;;
-			}
-			
-			string typeStr = ConvertTypeString(typeRef.Type);
-		
-			StringBuilder arrays = new StringBuilder();
-
-			if (typeRef.RankSpecifier != null) {
-				for (int i = 0; i &lt; typeRef.RankSpecifier.Count; ++i) {
-					arrays.Append(&quot;[&quot;);
-					arrays.Append(new String(',', (int)typeRef.RankSpecifier[i]));
-					arrays.Append(&quot;]&quot;);
-				}
-			} else {
-				if (typeRef.Dimension != null) {
-					arrays.Append(&quot;[&quot;);
-					if (typeRef.Dimension.Count &gt; 0) {
-						arrays.Append(new String(',', typeRef.Dimension.Count - 1));
-					}
-					arrays.Append(&quot;]&quot;);
-				}
-			}
-			
-			return typeStr + arrays.ToString();
-		}
-		
-		string GetModifier(Modifier modifier)
-		{
-			StringBuilder builder = new StringBuilder();
-			
-			if ((modifier &amp; Modifier.Public) == Modifier.Public) {
-				builder.Append(&quot;public &quot;);
-			} else if ((modifier &amp; Modifier.Private) == Modifier.Private) {
-				builder.Append(&quot;private &quot;);
-			} else if ((modifier &amp; (Modifier.Protected | Modifier.Friend)) == (Modifier.Protected | Modifier.Friend)) {
-				builder.Append(&quot;protected internal &quot;);
-			} else if ((modifier &amp; Modifier.Friend) == Modifier.Friend) {
-				builder.Append(&quot;internal &quot;);
-			} else if ((modifier &amp; Modifier.Protected) == Modifier.Protected) {
-				builder.Append(&quot;protected &quot;);
-			}
-			
-			if ((modifier &amp; Modifier.MustInherit) == Modifier.MustInherit) {
-				builder.Append(&quot;abstract &quot;);
-			}
-			if ((modifier &amp; Modifier.Shared) == Modifier.Shared) {
-				builder.Append(&quot;static &quot;);
-			}
-			if ((modifier &amp; Modifier.Overridable) == Modifier.Overridable) {
-				builder.Append(&quot;virtual &quot;);
-			}
-			if ((modifier &amp; Modifier.MustOverride) == Modifier.MustOverride) {
-				builder.Append(&quot;abstract &quot;);
-			}
-			if ((modifier &amp; Modifier.Overrides) == Modifier.Overrides) {
-				builder.Append(&quot;override &quot;);
-			}
-			if ((modifier &amp; Modifier.Shadows) == Modifier.Shadows) {
-				builder.Append(&quot;new &quot;);
-			}
-			
-			if ((modifier &amp; Modifier.NotInheritable) == Modifier.NotInheritable) {
-				builder.Append(&quot;sealed &quot;);
-			}
-			
-			if ((modifier &amp; Modifier.Constant) == Modifier.Constant) {
-				builder.Append(&quot;const &quot;);
-			}
-			if ((modifier &amp; Modifier.ReadOnly) == Modifier.ReadOnly) {
-				builder.Append(&quot;readonly &quot;);
-			}
-			return builder.ToString();
-		}
-
-		string GetParameters(ArrayList list)
-		{
-			return String.Concat(&quot;(&quot;,
-			                     GetExpressionList(list),
-			                     &quot;)&quot;);
-		}
-		
-		string GetExpressionList(ArrayList list)
-		{
-			StringBuilder sb = new StringBuilder();
-			if (list != null) {
-				for (int i = 0; i &lt; list.Count; ++i) {
-					Expression exp = (Expression)list[i];
-					if (exp != null) {
-						sb.Append(exp.AcceptVisitor(this, null));
-						if (i + 1 &lt; list.Count) {
-							sb.Append(&quot;, &quot;);
-						}
-					}
-				}
-			}
-			return sb.ToString();
-		}
-		
-	}
-}	
+// CSharpVisitor.cs
+// Copyright (C) 2004 Markus Palme (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">markuspalme at gmx.de</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Reflection;
+using System.CodeDom;
+using System.Text;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter.VB
+{
+	public class CSharpVisitor : IASTVisitor
+	{
+		readonly string newLineSep  = Environment.NewLine;
+		StringBuilder   sourceText  = new StringBuilder();
+		int             indentLevel = 0;
+		Errors          errors      = new Errors();
+		TypeDeclaration currentType = null;		
+		Stack   withExpressionStack = new Stack();
+		
+		public StringBuilder SourceText {
+			get {
+				return sourceText;
+			}
+		}
+		
+		public void AppendIndentation()
+		{
+			for (int i = 0; i &lt; indentLevel; ++i) {
+				sourceText.Append(&quot;\t&quot;);
+			}
+		}
+		
+		public void AppendNewLine()
+		{
+			sourceText.Append(newLineSep);
+		}
+		
+		public void AppendStatementEnd()
+		{
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+		}
+		
+		void DebugOutput(object o)
+		{
+//			Console.WriteLine(o.ToString());
+		}
+		
+		#region ICSharpCode.SharpRefactory.Parser.VB.IASTVisitor interface implementation
+		public object Visit(INode node, object data)
+		{
+			AppendIndentation();
+			sourceText.Append(&quot;// warning visited unknown node :&quot;);
+			sourceText.Append(node);
+			AppendNewLine();
+			return String.Empty;
+		}
+		
+		public object Visit(CompilationUnit compilationUnit, object data)
+		{
+			DebugOutput(compilationUnit);
+			compilationUnit.AcceptChildren(this, data);
+			return null;
+		}
+		
+#region GlobalScope
+		public object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			DebugOutput(namespaceDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;namespace &quot;);
+			sourceText.Append(namespaceDeclaration.NameSpace);
+			AppendNewLine();
+			sourceText.Append(&quot;{&quot;);
+			AppendNewLine();
+			++indentLevel;
+			namespaceDeclaration.AcceptChildren(this, data);
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ImportsStatement importsStatement, object data)
+		{
+			foreach (INode node in importsStatement.ImportClauses) {
+				node.AcceptVisitor(this, data);
+			}
+			return null;
+		}
+		
+		
+		public object Visit(ImportsDeclaration importsDeclaration, object data)
+		{
+			DebugOutput(importsDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;using &quot;);
+			sourceText.Append(importsDeclaration.Namespace);
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data)
+		{
+			DebugOutput(importsAliasDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;using &quot;);
+			sourceText.Append(importsAliasDeclaration.Alias);
+			sourceText.Append(&quot; = &quot;);
+			sourceText.Append(importsAliasDeclaration.Namespace);
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		
+		public object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			DebugOutput(typeDeclaration);
+			AppendAttributes(typeDeclaration.Attributes);
+			string modifier =  GetModifier(typeDeclaration.Modifier);
+			string type = String.Empty;
+			
+			switch (typeDeclaration.Type) {
+				case Types.Class:
+					type = &quot;class &quot;;
+					break;
+				case Types.Enum:
+					type = &quot;enum &quot;;
+					break;
+				case Types.Interface:
+					type = &quot;interface &quot;;
+					break;
+				case Types.Module:
+				case Types.Structure:
+					type = &quot;struct &quot;;
+					break;
+			}
+			AppendIndentation();
+			sourceText.Append(modifier);
+			sourceText.Append(type);
+			sourceText.Append(typeDeclaration.Name);
+			
+			bool hasBaseType = typeDeclaration.BaseType != null;
+			if (hasBaseType) {
+				sourceText.Append(&quot; : &quot;); 
+				sourceText.Append(ConvertTypeString(typeDeclaration.BaseType)); 
+			}
+			
+			if (typeDeclaration.BaseInterfaces != null &amp;&amp; typeDeclaration.BaseInterfaces.Count &gt; 0) {
+				if (!hasBaseType) {
+					sourceText.Append(&quot; : &quot;); 
+				} else {
+					sourceText.Append(&quot;, &quot;); 
+				}
+				for (int i = 0; i &lt; typeDeclaration.BaseInterfaces.Count; ++i) {
+					if (typeDeclaration.BaseInterfaces[i] is TypeReference) {
+						sourceText.Append((typeDeclaration.BaseInterfaces[i] as TypeReference).Type);
+					} else {
+						sourceText.Append(typeDeclaration.BaseInterfaces[i].ToString());
+					}
+					if (i + 1 &lt; typeDeclaration.BaseInterfaces.Count) {
+						sourceText.Append(&quot;, &quot;); 
+					}
+				}
+			}
+			AppendNewLine();
+			AppendIndentation();
+			sourceText.Append(&quot;{&quot;);
+			AppendNewLine();
+			++indentLevel;
+			TypeDeclaration oldType = currentType;
+			currentType = typeDeclaration;
+			typeDeclaration.AcceptChildren(this, data);
+			currentType = oldType;
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+			DebugOutput(delegateDeclaration);
+			AppendAttributes(delegateDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(delegateDeclaration.Modifier));
+			sourceText.Append(&quot;delegate &quot;);
+			sourceText.Append(GetTypeString(delegateDeclaration.ReturnType));
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(delegateDeclaration.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(delegateDeclaration.Parameters);
+			sourceText.Append(&quot;);&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			DebugOutput(eventDeclaration);
+			AppendAttributes(eventDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(eventDeclaration.Modifier));
+			sourceText.Append(&quot;event &quot;);
+			
+			if (eventDeclaration.TypeReference == null) {
+				sourceText.Append(eventDeclaration.Name);
+				sourceText.Append(&quot;EventHandler&quot;);
+			} else {
+				sourceText.Append(GetTypeString(eventDeclaration.TypeReference));
+			}
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(eventDeclaration.Name);
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+#endregion
+
+#region TypeLevel
+		public object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			// called inside ENUMS
+//			AppendAttributes(field.Attributes);
+			AppendIndentation();
+			sourceText.Append(variableDeclaration.Name);
+			if (variableDeclaration.Initializer != null) {
+				sourceText.Append(&quot; = &quot;);
+				sourceText.Append(variableDeclaration.Initializer.AcceptVisitor(this, data));
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			DebugOutput(fieldDeclaration);
+			
+			foreach (VariableDeclaration field in fieldDeclaration.Fields) {
+				AppendAttributes(fieldDeclaration.Attributes);
+				AppendIndentation();
+				if (currentType.Type == Types.Enum) {
+					if (fieldDeclaration.Fields.IndexOf(field) &gt; 0) {
+						sourceText.Append(&quot;, &quot;);
+					}
+					sourceText.Append(field.Name);
+					if (field.Initializer != null) {
+						sourceText.Append(&quot; = &quot;);
+						sourceText.Append(field.Initializer.AcceptVisitor(this, data).ToString());
+					}
+				} else {
+					if (fieldDeclaration.Modifier == Modifier.None) {
+						sourceText.Append(&quot; private &quot;);
+					} else {
+						sourceText.Append(GetModifier(fieldDeclaration.Modifier));
+					}
+					if (field.Type == null)
+						sourceText.Append(&quot;object&quot;);
+					else	
+						sourceText.Append(GetTypeString(field.Type));
+					sourceText.Append(&quot; &quot;);
+					sourceText.Append(field.Name);
+					if (field.Initializer != null) {
+						sourceText.Append(&quot; = &quot;);
+						sourceText.Append(field.Initializer.AcceptVisitor(this, data).ToString());
+					} else {
+						if (field.Type != null &amp;&amp; field.Type.Dimension != null) {
+							sourceText.Append(&quot; = new &quot;);
+							sourceText.Append(ConvertTypeString(field.Type.Type));
+							sourceText.Append(&quot;[&quot;);
+							sourceText.Append(GetExpressionList(field.Type.Dimension));
+							sourceText.Append(&quot;]&quot;);
+						}
+					}
+					sourceText.Append(&quot;;&quot;);
+					AppendNewLine();
+				}
+			}
+			
+			// if that's not the last enum member, add a comma
+			if (currentType.Type == Types.Enum) {
+				int pos = currentType.Children.IndexOf(fieldDeclaration);
+				if (pos &gt;= 0) {
+					for (int i = pos+1; i &lt; currentType.Children.Count; i++) {
+						if (currentType.Children[i] is FieldDeclaration) {
+							sourceText.Append(&quot;,&quot;);
+							break;
+						}
+					}
+				}
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			DebugOutput(methodDeclaration);
+			exitConstructStack.Push(new DictionaryEntry(typeof(MethodDeclaration), null));
+			
+			AppendNewLine();
+			AppendAttributes(methodDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(methodDeclaration.Modifier));
+			sourceText.Append(GetTypeString(methodDeclaration.TypeReference));
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(methodDeclaration.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(methodDeclaration.Parameters);
+			sourceText.Append(&quot;)&quot;);
+			
+			if (currentType.Type != Types.Interface &amp;&amp;
+				(methodDeclaration.Modifier &amp; Modifier.MustOverride) != Modifier.MustOverride)
+			{
+				AppendNewLine();
+				AppendIndentation();
+				sourceText.Append(&quot;{&quot;);
+				AppendNewLine();
+				if (methodDeclaration.Body != null) {
+					++indentLevel;
+					methodDeclaration.Body.AcceptVisitor(this, data);
+					GenerateExitConstructLabel();
+					--indentLevel;
+				}
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+			} else {
+				sourceText.Append(&quot;;&quot;);
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			DebugOutput(constructorDeclaration);
+			exitConstructStack.Push(new DictionaryEntry(typeof(MethodDeclaration), null));
+			AppendNewLine();
+			AppendAttributes(constructorDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(constructorDeclaration.Modifier));
+			sourceText.Append(this.currentType.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(constructorDeclaration.Parameters);
+			sourceText.Append(&quot;)&quot;);
+			
+			AppendNewLine();
+			AppendIndentation();
+			sourceText.Append(&quot;{&quot;);
+			AppendNewLine();
+			if (constructorDeclaration.Body != null) {
+				++indentLevel;
+				constructorDeclaration.Body.AcceptVisitor(this, data);
+				GenerateExitConstructLabel();
+				--indentLevel;
+			}
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(DeclareDeclaration declareDeclaration, object data)
+		{
+			DebugOutput(declareDeclaration);
+			AppendAttributes(declareDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(String.Format(&quot;[System.Runtime.InteropServices.DllImport({0}&quot;, declareDeclaration.Library));
+			if (declareDeclaration.Alias != null) {
+				sourceText.Append(String.Format(&quot;, EntryPoint={0}&quot;, declareDeclaration.Alias));
+			}
+			
+			switch (declareDeclaration.Charset) {
+				case CharsetModifier.ANSI:
+					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Ansi&quot;);
+					break;
+				case CharsetModifier.Unicode:
+					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Unicode&quot;);
+					break;
+				case CharsetModifier.Auto:
+					sourceText.Append(&quot;, CharSet=System.Runtime.InteropServices.CharSet.Auto&quot;);
+					break;
+			}
+			
+			sourceText.Append(&quot;)]&quot;);
+			AppendNewLine();
+			AppendIndentation();
+			sourceText.Append(GetModifier(declareDeclaration.Modifier));
+			sourceText.Append(&quot;static extern &quot;);
+			sourceText.Append(GetTypeString(declareDeclaration.ReturnType));
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(declareDeclaration.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(declareDeclaration.Parameters);
+			sourceText.Append(&quot;);&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			DebugOutput(propertyDeclaration);
+			AppendNewLine();
+			AppendAttributes(propertyDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(propertyDeclaration.Modifier &amp; ~Modifier.ReadOnly));
+			
+			sourceText.Append(GetTypeString(propertyDeclaration.TypeReference));
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(propertyDeclaration.Name);
+			sourceText.Append(&quot; {&quot;);
+			AppendNewLine();
+			
+			if (currentType.Type != Types.Interface) {
+				if (propertyDeclaration.GetRegion != null) {
+					++indentLevel;
+					propertyDeclaration.GetRegion.AcceptVisitor(this, data);
+					--indentLevel;
+				}
+				
+				if (propertyDeclaration.SetRegion != null) {
+					++indentLevel;
+					propertyDeclaration.SetRegion.AcceptVisitor(this, data);
+					--indentLevel;
+				}
+				
+			}
+			// if abstract, add default get/set
+			if ((propertyDeclaration.Modifier &amp; Modifier.MustOverride) == Modifier.MustOverride &amp;&amp;
+			    propertyDeclaration.GetRegion == null &amp;&amp;
+			    propertyDeclaration.SetRegion == null) {
+				AppendIndentation();
+				sourceText.Append(&quot;get;&quot;);
+				AppendNewLine();
+				AppendIndentation();
+				sourceText.Append(&quot;set;&quot;);
+				AppendNewLine();
+			}			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			DebugOutput(propertyGetRegion);
+			exitConstructStack.Push(new DictionaryEntry(typeof(PropertyDeclaration), null));
+			AppendAttributes(propertyGetRegion.Attributes);
+			AppendIndentation();
+			sourceText.Append(&quot;get {&quot;);
+			AppendNewLine();
+			if (propertyGetRegion.Block != null) {
+				++indentLevel;
+				propertyGetRegion.Block.AcceptVisitor(this, data);
+				--indentLevel;
+			} 
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(PropertySetRegion propertySetRegion, object data)
+		{
+			DebugOutput(propertySetRegion);
+			exitConstructStack.Push(new DictionaryEntry(typeof(PropertyDeclaration), null));
+			AppendAttributes(propertySetRegion.Attributes);
+			AppendIndentation();
+			sourceText.Append(&quot;set {&quot;);
+			AppendNewLine();
+			if (propertySetRegion.Block != null) {
+				++indentLevel;
+				propertySetRegion.Block.AcceptVisitor(this, data);
+				--indentLevel;
+			}
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(TypeReference typeReference, object data)
+		{
+			return ConvertTypeString(typeReference.Type);
+		}
+#endregion
+
+#region Statements
+		public object Visit(Statement statement, object data)
+		{
+			AppendIndentation();
+			sourceText.Append(&quot;// warning visited unknown statment :&quot;);
+			sourceText.Append(statement);
+			AppendNewLine();
+			return String.Empty;
+		}
+		
+		public object Visit(BlockStatement blockStatement, object data)
+		{
+			DebugOutput(blockStatement);
+			blockStatement.AcceptChildren(this, data);
+			return null;
+		}
+		
+		public object Visit(StatementExpression statementExpression, object data)
+		{
+			DebugOutput(statementExpression);
+			AppendIndentation();
+			if (statementExpression.Expression == null) {
+				sourceText.Append(&quot;// warning got empty statement expression :&quot;);
+				sourceText.Append(statementExpression);
+			} else {
+				sourceText.Append(statementExpression.Expression.AcceptVisitor(this, data).ToString());
+				sourceText.Append(&quot;;&quot;);
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			DebugOutput(localVariableDeclaration);
+			for (int i = 0; i &lt; localVariableDeclaration.Variables.Count; ++i) {
+				VariableDeclaration localVar = (VariableDeclaration)localVariableDeclaration.Variables[i];
+				AppendIndentation();
+				sourceText.Append(GetModifier(localVariableDeclaration.Modifier));
+				ArrayCreateExpression ace = localVar.Initializer as ArrayCreateExpression;
+				if (ace != null &amp;&amp; (ace.ArrayInitializer == null || ace.ArrayInitializer.CreateExpressions == null)) {
+					sourceText.Append(ConvertTypeString(ace.CreateType.Type));
+					sourceText.Append(&quot; &quot;);
+					sourceText.Append(localVar.Name);
+					sourceText.Append(&quot;[&quot;);
+					sourceText.Append(GetExpressionList(ace.Parameters));
+					sourceText.Append(&quot;]&quot;);
+					
+				} else {
+					if (localVar.Type == null) {
+						bool foundType = false;
+						for (int j = i + 1; j &lt; localVariableDeclaration.Variables.Count; ++j) {
+							VariableDeclaration nextLocalVar = (VariableDeclaration)localVariableDeclaration.Variables[j];
+							if (nextLocalVar.Type != null) {
+								sourceText.Append(GetTypeString(nextLocalVar.Type));
+								foundType = true;
+								break;
+							}
+						}
+						if (!foundType) {
+							sourceText.Append(&quot;object&quot;);
+						}
+					} else {
+						sourceText.Append(GetTypeString(localVar.Type));
+					}
+					sourceText.Append(&quot; &quot;);
+					sourceText.Append(localVar.Name);
+					if (localVar.Initializer != null) {
+						sourceText.Append(&quot; = &quot;);
+						sourceText.Append(localVar.Initializer.AcceptVisitor(this, data).ToString());
+					} else {
+						if (localVar.Type != null &amp;&amp; localVar.Type.Dimension != null) {
+							sourceText.Append(&quot; = new &quot;);
+							sourceText.Append(ConvertTypeString(localVar.Type.Type));
+							sourceText.Append(&quot;[&quot;);
+							sourceText.Append(GetExpressionList(localVar.Type.Dimension));
+							sourceText.Append(&quot;]&quot;);
+						}
+					}
+				}
+				sourceText.Append(&quot;;&quot;);
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public object Visit(SimpleIfStatement ifStatement, object data)
+		{
+			AppendIndentation();
+			sourceText.Append(&quot;if (&quot;);
+			sourceText.Append(ifStatement.Condition.AcceptVisitor(this, data).ToString());
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			++indentLevel;
+			foreach(Statement statement in ifStatement.Statements) {
+				statement.AcceptVisitor(this, data);
+			}
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			
+			if(ifStatement.ElseStatements != null &amp;&amp; ifStatement.ElseStatements.Count &gt; 0) {
+				sourceText.Append(&quot; else {&quot;);
+				AppendNewLine();
+				++indentLevel;
+				foreach(Statement statement in ifStatement.ElseStatements) {
+					statement.AcceptVisitor(this, data);
+				}
+				--indentLevel;
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+			}
+			
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(IfStatement ifStatement, object data)
+		{
+			DebugOutput(ifStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;if (&quot;);
+			sourceText.Append(ifStatement.Condition.AcceptVisitor(this, data).ToString());
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			++indentLevel;
+			ifStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			
+			if (ifStatement.ElseIfStatements != null) {
+				foreach (ElseIfSection elseIfSection in ifStatement.ElseIfStatements) {
+					sourceText.Append(&quot; else if (&quot;);
+					sourceText.Append(elseIfSection.Condition.AcceptVisitor(this, data).ToString());
+					sourceText.Append(&quot;) {&quot;);
+					AppendNewLine();
+					++indentLevel;
+					elseIfSection.EmbeddedStatement.AcceptVisitor(this, data);
+					--indentLevel;
+					AppendIndentation();
+					sourceText.Append(&quot;}&quot;);
+				}
+			}
+			
+			if (ifStatement.EmbeddedElseStatement != null) {
+				sourceText.Append(&quot; else {&quot;);
+				AppendNewLine();
+				++indentLevel;
+				ifStatement.EmbeddedElseStatement.AcceptVisitor(this, data);
+				--indentLevel;
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+			}
+			
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(LabelStatement labelStatement, object data)
+		{
+			DebugOutput(labelStatement);
+			AppendIndentation();
+			sourceText.Append(labelStatement.Label);
+			sourceText.Append(&quot;:&quot;);
+			AppendNewLine();
+			if (labelStatement.EmbeddedStatement != null) {
+				labelStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			return null;
+		}
+		
+		public object Visit(GoToStatement goToStatement, object data)
+		{
+			DebugOutput(goToStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;goto&quot;);
+			sourceText.Append(goToStatement.LabelName);
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(SelectStatement selectStatement, object data)
+		{
+			DebugOutput(selectStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(SelectStatement), null));
+			string selectExpression = selectStatement.SelectExpression.AcceptVisitor(this, data).ToString();
+			AppendIndentation();
+			for (int j = 0; j &lt; selectStatement.SelectSections.Count; ++j) {
+				SelectSection selectSection = (SelectSection)selectStatement.SelectSections[j];
+				if (selectSection.CaseClauses.Count == 1 &amp;&amp; ((CaseClause)selectSection.CaseClauses[0]).IsDefaultCase) {
+					sourceText.Append(&quot;{&quot;);
+				} else {
+					sourceText.Append(&quot;if (&quot;);
+					for (int i = 0; i &lt; selectSection.CaseClauses.Count; ++i) {
+						CaseClause caseClause = (CaseClause)selectSection.CaseClauses[i];
+						if (caseClause.BoundaryExpression != null) {
+							sourceText.Append(caseClause.ComparisonExpression.AcceptVisitor(this, data));
+							sourceText.Append(&quot; &lt;= &quot;);
+							sourceText.Append(selectExpression);
+							sourceText.Append(&quot; &amp;&amp; &quot;);
+							sourceText.Append(selectExpression);
+							sourceText.Append(&quot; &lt;= &quot;);
+							sourceText.Append(caseClause.BoundaryExpression.AcceptVisitor(this, data));
+						} else {
+							if (caseClause.ComparisonExpression != null) {
+								sourceText.Append(selectExpression);
+								sourceText.Append(&quot; == &quot;);
+								sourceText.Append(caseClause.ComparisonExpression.AcceptVisitor(this, data));
+							} else {
+								// dummy default should never evaluate (only for default case)
+								sourceText.Append(&quot; true &quot;);
+							}
+						}
+						if (i + 1 &lt; selectSection.CaseClauses.Count) {
+							sourceText.Append(&quot; || &quot;);
+						}
+					}
+					sourceText.Append(&quot;) {&quot;);
+				}
+				AppendNewLine();
+				++indentLevel;
+				selectSection.EmbeddedStatement.AcceptChildren(this, data);
+				--indentLevel;
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+				if (j + 1 &lt; selectStatement.SelectSections.Count) {
+					sourceText.Append(&quot; else &quot;);
+				} 
+			}
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(StopStatement stopStatement, object data)
+		{
+			DebugOutput(stopStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;Debugger.Break();&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ResumeStatement resumeStatement, object data)
+		{
+			DebugOutput(resumeStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(resumeStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(EraseStatement eraseStatement, object data)
+		{
+			DebugOutput(eraseStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(eraseStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ErrorStatement errorStatement, object data)
+		{
+			DebugOutput(errorStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(errorStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(OnErrorStatement onErrorStatement, object data)
+		{
+			DebugOutput(onErrorStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(onErrorStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ReDimStatement reDimStatement, object data)
+		{
+			DebugOutput(reDimStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(reDimStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(AddHandlerStatement addHandlerStatement, object data)
+		{
+			DebugOutput(addHandlerStatement);
+			AppendIndentation();
+			sourceText.Append(addHandlerStatement.EventExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot; += &quot;);
+			sourceText.Append(addHandlerStatement.HandlerExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(RemoveHandlerStatement removeHandlerStatement, object data)
+		{
+			DebugOutput(removeHandlerStatement);
+			AppendIndentation();
+			sourceText.Append(removeHandlerStatement.EventExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot; -= &quot;);
+			sourceText.Append(removeHandlerStatement.HandlerExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(DoLoopStatement doLoopStatement, object data)
+		{
+			DebugOutput(doLoopStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(DoLoopStatement), null));
+			if (doLoopStatement.ConditionPosition == ConditionPosition.Start) {
+				AppendIndentation();
+				sourceText.Append(&quot;while (&quot;);
+				if (doLoopStatement.ConditionType == ConditionType.Until) {
+					sourceText.Append(&quot;!(&quot;);
+				}
+				sourceText.Append(doLoopStatement.Condition.AcceptVisitor(this, data).ToString());
+				if (doLoopStatement.ConditionType == ConditionType.Until) {
+					sourceText.Append(&quot;)&quot;);
+				}
+				sourceText.Append(&quot;) {&quot;);
+				
+				AppendNewLine();
+				
+				++indentLevel;
+				doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
+				--indentLevel;
+				
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+				AppendNewLine();
+			} else {
+				AppendIndentation();
+				sourceText.Append(&quot;do {&quot;);
+				AppendNewLine();
+				
+				++indentLevel;
+				doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
+				--indentLevel;
+				
+				AppendIndentation();
+				sourceText.Append(&quot;} while (&quot;);
+				if (doLoopStatement.Condition == null) {
+					sourceText.Append(&quot;true&quot;);
+				} else {
+					if (doLoopStatement.ConditionType == ConditionType.Until) {
+						sourceText.Append(&quot;!(&quot;);
+					}
+					sourceText.Append(doLoopStatement.Condition.AcceptVisitor(this, data).ToString());
+					if (doLoopStatement.ConditionType == ConditionType.Until) {
+						sourceText.Append(&quot;)&quot;);
+					}
+				}
+				sourceText.Append(&quot;);&quot;);
+				AppendNewLine();
+			}
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(EndStatement endStatement, object data)
+		{
+			DebugOutput(endStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;System.Environment.Exit(0);&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		Stack exitConstructStack = new Stack();
+		int   exitLabelCount     = 0;
+		public string AddExitOnConstructStack(Type exitType)
+		{
+			string labelName = String.Concat(&quot;exit&quot; + exitType.Name, exitLabelCount++);
+			if (exitConstructStack.Count &gt; 0) {
+				object[] exitArray = exitConstructStack.ToArray();
+				for (int i = exitArray.Length - 1; i &gt;= 0; --i) {
+					if ((Type)((DictionaryEntry)exitArray[i]).Key == exitType) {
+						exitArray[i] = new DictionaryEntry(((DictionaryEntry)exitArray[i]).Key, labelName);
+					}
+				}
+				Array.Reverse(exitArray);
+				exitConstructStack = new Stack(exitArray);
+			}
+			return String.Concat(labelName);
+		}
+		
+		public void GenerateExitConstructLabel()
+		{
+			if (exitConstructStack.Count &gt; 0) {
+				DictionaryEntry entry = (DictionaryEntry)exitConstructStack.Pop();
+				if (entry.Value != null) {
+					AppendIndentation();
+					sourceText.Append(entry.Value.ToString());
+					sourceText.Append(&quot;: ;&quot;);
+					AppendNewLine();
+				}
+			}
+		}
+		
+		public object Visit(ExitStatement exitStatement, object data)
+		{
+			DebugOutput(exitStatement);
+			Type   exitType  = null;
+			switch (exitStatement.ExitType) {
+				case ExitType.Sub:
+					sourceText.Append(&quot;return;&quot;);
+					AppendNewLine();
+					return null;
+				case ExitType.Function:
+					sourceText.Append(&quot;return null;&quot;);
+					AppendNewLine();
+					return null;
+				case ExitType.Property:
+					exitType = typeof(PropertyDeclaration);
+					break;
+				case ExitType.Do:
+					exitType = typeof(DoLoopStatement);
+					break;
+				case ExitType.For:
+					exitType = typeof(ForStatement);
+					break;
+				case ExitType.While:
+					exitType = typeof(WhileStatement);
+					break;
+				case ExitType.Select:
+					exitType = typeof(SelectStatement);
+					break;
+				case ExitType.Try:
+					exitType = typeof(TryCatchStatement);
+					break;
+			}
+			if (exitType != null) {
+				AppendIndentation();
+				sourceText.Append(&quot;goto &quot;);
+				sourceText.Append(AddExitOnConstructStack(exitType));
+				sourceText.Append(&quot;;&quot;);
+				AppendNewLine();
+			} else {
+				AppendIndentation();
+				sourceText.Append(&quot;ERROR IN GENERATION: EXIT TO &quot;);
+				sourceText.Append(exitStatement.ExitType);
+				sourceText.Append(&quot; FAILED!!!&quot;);
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public object Visit(ForeachStatement foreachStatement, object data)
+		{
+			DebugOutput(foreachStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(ForStatement), null));
+			
+			AppendIndentation();
+			sourceText.Append(&quot;foreach (&quot;);
+			if (foreachStatement.LoopControlVariable.Type != null) {
+				sourceText.Append(this.GetTypeString(foreachStatement.LoopControlVariable.Type));
+				sourceText.Append(&quot; &quot;);
+			}
+			sourceText.Append(foreachStatement.LoopControlVariable.Name);
+			sourceText.Append(&quot; in &quot;);
+			sourceText.Append(foreachStatement.Expression.AcceptVisitor(this, data));
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(ForStatement forStatement, object data)
+		{
+			DebugOutput(forStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(ForStatement), null));
+			bool   stepIsNegative = false;
+			string step           = null;
+			if (forStatement.Step != null) {
+				step = forStatement.Step.AcceptVisitor(this, data).ToString();
+				stepIsNegative = step.StartsWith(&quot;-&quot;);
+			}
+			
+			AppendIndentation();
+			sourceText.Append(&quot;for (&quot;);
+			
+			
+			if (forStatement.LoopControlVariable.Type != null) {
+				sourceText.Append(this.GetTypeString(forStatement.LoopControlVariable.Type));
+				sourceText.Append(&quot; &quot;);
+			}
+			sourceText.Append(forStatement.LoopControlVariable.Name);
+			sourceText.Append(&quot; = &quot;);
+			
+			sourceText.Append(forStatement.Start.AcceptVisitor(this, data));
+			sourceText.Append(&quot;; &quot;);
+			sourceText.Append(forStatement.LoopControlVariable.Name);
+			sourceText.Append(stepIsNegative ? &quot; &gt;= &quot; : &quot; &lt;= &quot;);
+			sourceText.Append(forStatement.End.AcceptVisitor(this, data));
+			sourceText.Append(&quot;; &quot;);
+			if (forStatement.Step == null) {
+				sourceText.Append(forStatement.LoopControlVariable.Name);
+				sourceText.Append(&quot;++&quot;);
+			} else {
+				sourceText.Append(forStatement.LoopControlVariable.Name);
+				if (stepIsNegative) {
+					if (step == &quot;-1&quot;) {
+						sourceText.Append(&quot;--&quot;);
+					} else {
+						sourceText.Append(&quot; -= &quot;);
+						sourceText.Append(step.Substring(1));
+					}
+				} else {
+					sourceText.Append(&quot; += &quot;);
+					sourceText.Append(step);
+				}
+			}
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			
+			return null;
+		}
+		
+		public object Visit(LockStatement lockStatement, object data)
+		{
+			DebugOutput(lockStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;lock (&quot;);
+			sourceText.Append(lockStatement.LockExpression.AcceptVisitor(this, data));
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(RaiseEventStatement raiseEventStatement, object data)
+		{
+			DebugOutput(raiseEventStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;if (&quot;);
+			sourceText.Append(raiseEventStatement.EventName);
+			sourceText.Append(&quot; != null) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			AppendIndentation();
+			sourceText.Append(raiseEventStatement.EventName);
+			sourceText.Append(GetParameters(raiseEventStatement.Parameters));
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		
+		public object Visit(ReturnStatement returnStatement, object data)
+		{
+			DebugOutput(returnStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;return&quot;);
+			if (returnStatement.ReturnExpression != null) {
+				sourceText.Append(&quot; &quot;);
+				sourceText.Append(returnStatement.ReturnExpression.AcceptVisitor(this,data));
+			}
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(ThrowStatement throwStatement, object data)
+		{
+			DebugOutput(throwStatement);
+			AppendIndentation();
+			sourceText.Append(&quot;throw&quot;);
+			if (throwStatement.ThrowExpression != null) {
+				sourceText.Append(&quot; &quot;);
+				sourceText.Append(throwStatement.ThrowExpression.AcceptVisitor(this, data).ToString());
+			}
+			sourceText.Append(&quot;;&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			DebugOutput(tryCatchStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(TryCatchStatement), null));
+			AppendIndentation();
+			sourceText.Append(&quot;try {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
+			--indentLevel;
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			if (tryCatchStatement.CatchClauses != null) {
+				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
+					sourceText.Append(&quot; catch &quot;);
+					if (catchClause.Type != null) {
+						sourceText.Append(&quot;(&quot;);
+						sourceText.Append(GetTypeString(catchClause.Type));
+						if (catchClause.VariableName != null) {
+							sourceText.Append(&quot; &quot;);
+							sourceText.Append(catchClause.VariableName);
+						}
+						sourceText.Append(&quot;) &quot;);
+					}
+					sourceText.Append(&quot;{&quot;);
+					AppendNewLine();
+					++indentLevel;
+					if (catchClause.Condition != null) {
+						AppendIndentation();
+						sourceText.Append(&quot;//TODO: review the original conditional catch clause&quot;);
+						AppendNewLine();
+						AppendIndentation();
+						sourceText.Append(&quot;if (&quot;);
+						sourceText.Append(catchClause.Condition.AcceptVisitor(this, data));
+						sourceText.Append(&quot;) {&quot;);
+						AppendNewLine();
+						++indentLevel;
+						catchClause.StatementBlock.AcceptVisitor(this, data);
+						--indentLevel;
+						AppendIndentation();
+						sourceText.Append(&quot;}&quot;);
+						AppendNewLine();
+					} else {
+						catchClause.StatementBlock.AcceptVisitor(this, data);
+					}
+					--indentLevel;
+					AppendIndentation();
+					sourceText.Append(&quot;}&quot;);
+				}
+			}
+			
+			if (tryCatchStatement.FinallyBlock != null) {
+				sourceText.Append(&quot; finally {&quot;);
+				AppendNewLine();
+				
+				++indentLevel;
+				tryCatchStatement.FinallyBlock.AcceptVisitor(this, data);
+				--indentLevel;
+				AppendIndentation();
+				sourceText.Append(&quot;}&quot;);
+			}
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(WhileStatement whileStatement, object data)
+		{
+			DebugOutput(whileStatement);
+			exitConstructStack.Push(new DictionaryEntry(typeof(WhileStatement), null));
+			AppendIndentation();
+			sourceText.Append(&quot;while (&quot;);
+			sourceText.Append(whileStatement.Condition.AcceptVisitor(this, data).ToString());
+			sourceText.Append(&quot;) {&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();
+			sourceText.Append(&quot;}&quot;);
+			AppendNewLine();
+			GenerateExitConstructLabel();
+			return null;
+		}
+		
+		public object Visit(WithStatement withStatement, object data)
+		{
+			DebugOutput(withStatement);
+			withExpressionStack.Push(withStatement.WithExpression);
+			withStatement.Body.AcceptVisitor(this, data);
+			withExpressionStack.Pop();
+			return null;
+		}
+		
+		public object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data)
+		{
+			DebugOutput(attribute);
+			AppendIndentation();
+			sourceText.Append(&quot;// Should never happen (this is handled in AttributeSection) attribute was:&quot;);
+			sourceText.Append(attribute);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(AttributeSection attributeSection, object data)
+		{
+			DebugOutput(attributeSection);
+			AppendIndentation();
+			sourceText.Append(&quot;[&quot;);
+			if (attributeSection.AttributeTarget != null &amp;&amp; attributeSection.AttributeTarget.Length &gt; 0) {
+				sourceText.Append(attributeSection.AttributeTarget);
+				sourceText.Append(&quot;: &quot;);
+			}
+			for (int j = 0; j &lt; attributeSection.Attributes.Count; ++j) {
+				ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attr = (ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute)attributeSection.Attributes[j];
+				
+				sourceText.Append(attr.Name);
+				sourceText.Append(&quot;(&quot;);
+				for (int i = 0; i &lt; attr.PositionalArguments.Count; ++i) {
+					Expression expr = (Expression)attr.PositionalArguments[i];
+					sourceText.Append(expr.AcceptVisitor(this, data).ToString());
+					if (i + 1 &lt; attr.PositionalArguments.Count | attr.NamedArguments.Count &gt; 0) { 
+						sourceText.Append(&quot;, &quot;);
+					}
+				}
+
+				for (int i = 0; i &lt; attr.NamedArguments.Count; ++i) {
+					NamedArgumentExpression named = (NamedArgumentExpression)attr.NamedArguments[i];
+					sourceText.Append(named.AcceptVisitor(this, data).ToString());
+					if (i + 1 &lt; attr.NamedArguments.Count) { 
+						sourceText.Append(&quot;, &quot;);
+					}
+				}
+				sourceText.Append(&quot;)&quot;);
+				if (j + 1 &lt; attributeSection.Attributes.Count) {
+					sourceText.Append(&quot;, &quot;);
+				}
+			}
+			sourceText.Append(&quot;]&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(OptionCompareDeclaration optionCompareDeclaration, object data)
+		{
+			DebugOutput(optionCompareDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(optionCompareDeclaration);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data)
+		{
+			DebugOutput(optionExplicitDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(optionExplicitDeclaration);
+			AppendNewLine();
+			return null;
+		}
+		
+		public object Visit(OptionStrictDeclaration optionStrictDeclaration, object data)
+		{
+			DebugOutput(optionStrictDeclaration);
+			AppendIndentation();
+			sourceText.Append(&quot;// TODO: NotImplemented statement: &quot;);
+			sourceText.Append(optionStrictDeclaration);
+			AppendNewLine();
+			return null;
+		}
+#endregion
+
+#region Expressions
+		public object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			DebugOutput(primitiveExpression);
+			if (primitiveExpression.Value == null) {
+				return &quot;null&quot;;
+			}
+			if (primitiveExpression.Value is bool) {
+				if ((bool)primitiveExpression.Value) {
+					return &quot;true&quot;;
+				}
+				return &quot;false&quot;;
+			}
+			
+			if (primitiveExpression.Value is string) {
+				string s = primitiveExpression.Value.ToString();
+				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
+				s = s.Replace(&quot;\&quot;&quot;,&quot;\\\&quot;&quot;);
+				return String.Concat('&quot;', s, '&quot;');
+			}
+			
+			if (primitiveExpression.Value is char) {
+				string s = primitiveExpression.Value.ToString();
+				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
+				s = s.Replace(&quot;\'&quot;,&quot;\\\'&quot;);
+				return String.Concat(&quot;'&quot;, s, &quot;'&quot;);
+			}
+			
+			if (primitiveExpression.Value is System.DateTime) {
+				string s = primitiveExpression.StringValue;
+				s = s.Replace(&quot;\\&quot;,&quot;\\\\&quot;);
+				s = s.Replace(&quot;\&quot;&quot;,&quot;\\\&quot;&quot;);
+				return String.Concat(&quot;System.DateTime.Parse(\&quot;&quot;, s, &quot;\&quot;)&quot;);
+			}
+
+			return primitiveExpression.Value;
+		}
+		
+		public object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			DebugOutput(binaryOperatorExpression);
+			string op   = null;
+			string left = binaryOperatorExpression.Left.AcceptVisitor(this, data).ToString();
+			string right = binaryOperatorExpression.Right.AcceptVisitor(this, data).ToString();
+			
+			switch (binaryOperatorExpression.Op) {
+				case BinaryOperatorType.Concat:
+					op = &quot; + &quot;;
+					break;
+				
+				case BinaryOperatorType.Add:
+					op = &quot; + &quot;;
+					break;
+				
+				case BinaryOperatorType.Subtract:
+					op = &quot; - &quot;;
+					break;
+				
+				case BinaryOperatorType.Multiply:
+					op = &quot; * &quot;;
+					break;
+				
+				case BinaryOperatorType.DivideInteger:
+				case BinaryOperatorType.Divide:
+					op = &quot; / &quot;;
+					break;
+				
+				case BinaryOperatorType.Modulus:
+					op = &quot; % &quot;;
+					break;
+				
+				case BinaryOperatorType.ShiftLeft:
+					op = &quot; &lt;&lt; &quot;;
+					break;
+				
+				case BinaryOperatorType.ShiftRight:
+					op = &quot; &gt;&gt; &quot;;
+					break;
+				
+				case BinaryOperatorType.BitwiseAnd:
+					op = &quot; &amp; &quot;;
+					break;
+				case BinaryOperatorType.BitwiseOr:
+					op = &quot; | &quot;;
+					break;
+				case BinaryOperatorType.ExclusiveOr:
+					op = &quot; ^ &quot;;
+					break;
+				
+				case BinaryOperatorType.BooleanAnd:
+					op = &quot; &amp;&amp; &quot;;
+					break;
+				case BinaryOperatorType.BooleanOr:
+					op = &quot; || &quot;;
+					break;
+				
+				case BinaryOperatorType.Equality:
+					op = &quot; == &quot;;
+					break;
+				case BinaryOperatorType.GreaterThan:
+					op = &quot; &gt; &quot;;
+					break;
+				case BinaryOperatorType.GreaterThanOrEqual:
+					op = &quot; &gt;= &quot;;
+					break;
+				case BinaryOperatorType.InEquality:
+					op = &quot; != &quot;;
+					break;
+				case BinaryOperatorType.LessThan:
+					op = &quot; &lt; &quot;;
+					break;
+				case BinaryOperatorType.IS:
+					op = &quot; == &quot;;
+					break;
+				case BinaryOperatorType.LessThanOrEqual:
+					op = &quot; &lt;= &quot;;
+					break;
+				case BinaryOperatorType.Power:
+					return &quot;Math.Pow(&quot; + left + &quot;, &quot; + right + &quot;)&quot;;
+				default:
+					throw new Exception(&quot;Unknown binary operator:&quot; + binaryOperatorExpression.Op);
+			}
+			
+			return String.Concat(left,
+			                     op,
+			                     right);
+		}
+		
+		public object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			DebugOutput(parenthesizedExpression);
+			string innerExpr = parenthesizedExpression.Expression.AcceptVisitor(this, data).ToString();
+			return String.Concat(&quot;(&quot;, innerExpr, &quot;)&quot;);
+		}
+		
+		public object Visit(InvocationExpression invocationExpression, object data)
+		{
+			DebugOutput(invocationExpression);
+			return String.Concat(invocationExpression.TargetObject.AcceptVisitor(this, data),
+			                     GetParameters(invocationExpression.Parameters)
+			                     );
+		}
+		
+		public object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			DebugOutput(identifierExpression);
+			return identifierExpression.Identifier;
+		}
+		
+		public object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			DebugOutput(typeReferenceExpression);
+			return GetTypeString(typeReferenceExpression.TypeReference);
+		}
+		
+		public object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			DebugOutput(unaryOperatorExpression);
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.BitNot:
+					return String.Concat(&quot;~&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Decrement:
+					return String.Concat(&quot;--&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Increment:
+					return String.Concat(&quot;++&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Minus:
+					return String.Concat(&quot;-&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Not:
+					return String.Concat(&quot;!(&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Plus:
+					return String.Concat(&quot;+&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.PostDecrement:
+					return String.Concat(unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;--&quot;);
+				case UnaryOperatorType.PostIncrement:
+					return String.Concat(unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;++&quot;);
+			}
+			throw new System.NotSupportedException();
+		}
+		
+		public object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			DebugOutput(assignmentExpression);
+			string op    = null;
+			string left  = assignmentExpression.Left.AcceptVisitor(this, data).ToString();
+			string right = assignmentExpression.Right.AcceptVisitor(this, data).ToString();
+			
+			switch (assignmentExpression.Op) {
+				case AssignmentOperatorType.Assign:
+					op = &quot; = &quot;;
+					break;
+				case AssignmentOperatorType.ConcatString:
+				case AssignmentOperatorType.Add:
+					op = &quot; += &quot;;
+					break;
+				case AssignmentOperatorType.Subtract:
+					op = &quot; -= &quot;;
+					break;
+				case AssignmentOperatorType.Multiply:
+					op = &quot; *= &quot;;
+					break;
+				case AssignmentOperatorType.Divide:
+					op = &quot; /= &quot;;
+					break;
+				case AssignmentOperatorType.ShiftLeft:
+					op = &quot; &lt;&lt;= &quot;;
+					break;
+				case AssignmentOperatorType.ShiftRight:
+					op = &quot; &gt;&gt;= &quot;;
+					break;
+				
+				case AssignmentOperatorType.ExclusiveOr:
+					op = &quot; ^= &quot;;
+					break;
+				case AssignmentOperatorType.Modulus:
+					op = &quot; %= &quot;;
+					break;
+				case AssignmentOperatorType.BitwiseAnd:
+					op = &quot; &amp;= &quot;;
+					break;
+				case AssignmentOperatorType.BitwiseOr:
+					op = &quot; |= &quot;;
+					break;
+			}
+			return String.Concat(left,
+			                     op,
+			                     right);
+		}
+		
+		public object Visit(CastExpression castExpression, object data)
+		{
+			DebugOutput(castExpression);
+			string type     = ConvertTypeString(castExpression.CastTo.Type);
+			string castExpr = castExpression.Expression.AcceptVisitor(this, data).ToString();
+			
+			if (castExpression.IsSpecializedCast) {
+				switch (type) {
+					case &quot;System.Object&quot;:
+						break;
+					default:
+						string convToType = type.Substring(&quot;System.&quot;.Length);
+						return String.Format(&quot;System.Convert.To{0}({1})&quot;, convToType, castExpr);
+				}
+			}
+			return String.Format(&quot;(({0})({1}))&quot;, type, castExpr);
+		}
+		
+		public object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			DebugOutput(thisReferenceExpression);
+			return &quot;this&quot;;
+		}
+		
+		public object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			DebugOutput(baseReferenceExpression);
+			return &quot;base&quot;;
+		}
+		
+		public object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			return String.Format(&quot;new {0}{1}&quot;,
+			                     GetTypeString(objectCreateExpression.CreateType),
+			                     GetParameters(objectCreateExpression.Parameters)
+			                     );
+		}
+		
+		public object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			DebugOutput(parameterDeclarationExpression);
+			// Is handled in the AppendParameters method
+			return &quot;// should never happen&quot; + parameterDeclarationExpression;
+		}
+		
+		public object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data)
+		{
+			DebugOutput(fieldReferenceOrInvocationExpression);
+			INode target = fieldReferenceOrInvocationExpression.TargetObject;
+			if (target == null &amp;&amp; withExpressionStack.Count &gt; 0) {
+				target = withExpressionStack.Peek() as INode;
+			}
+			return String.Concat(target.AcceptVisitor(this, data),
+			                     '.',
+			                     fieldReferenceOrInvocationExpression.FieldName);
+		}
+		
+		public object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			DebugOutput(arrayInitializerExpression);
+			if (arrayInitializerExpression.CreateExpressions.Count &gt; 0) {
+				return String.Concat(&quot;{&quot;,
+				                     GetExpressionList(arrayInitializerExpression.CreateExpressions),
+				                     &quot;}&quot;);
+			}
+			return String.Empty;
+		}
+		
+		public object Visit(GetTypeExpression getTypeExpression, object data)
+		{
+			DebugOutput(getTypeExpression);
+			return String.Concat(&quot;typeof(&quot;,
+			                     this.GetTypeString(getTypeExpression.Type),
+			                     &quot;)&quot;);
+		}
+		
+		public object Visit(ClassReferenceExpression classReferenceExpression, object data)
+		{
+			// ALMOST THE SAME AS '.this' but ignores all overridings from virtual
+			// members. How can this done in C# ?
+			DebugOutput(classReferenceExpression);
+			return &quot;TODO : &quot; + classReferenceExpression;
+		}
+		
+		public object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
+		{
+			// I think the LoopControlVariableExpression is only used in the for statement
+			// and there it is handled
+			DebugOutput(loopControlVariableExpression);
+			return &quot;Should Never happen : &quot; + loopControlVariableExpression;
+		}
+		
+		public object Visit(NamedArgumentExpression namedArgumentExpression, object data)
+		{
+			return String.Concat(namedArgumentExpression.Parametername,
+			                     &quot;=&quot;,
+			                    namedArgumentExpression.Expression.AcceptVisitor(this, data));
+		}
+		
+		public object Visit(AddressOfExpression addressOfExpression, object data)
+		{
+			DebugOutput(addressOfExpression);
+			string procedureName    = addressOfExpression.Procedure.AcceptVisitor(this, data).ToString();
+			string eventHandlerType = &quot;EventHandler&quot;;
+			bool   foundEventHandler = false;
+			// try to resolve the type of the eventhandler using a little trick :)
+			foreach (INode node in currentType.Children) {
+				MethodDeclaration md = node as MethodDeclaration;
+				if (md != null &amp;&amp; md.Parameters != null &amp;&amp; md.Parameters.Count &gt; 0) {
+					if (procedureName == md.Name || procedureName.EndsWith(&quot;.&quot; + md.Name)) {
+						ParameterDeclarationExpression pde = (ParameterDeclarationExpression)md.Parameters[md.Parameters.Count - 1];
+						string typeName = GetTypeString(pde.TypeReference);
+						if (typeName.EndsWith(&quot;Args&quot;)) {
+							eventHandlerType = typeName.Substring(0, typeName.Length - &quot;Args&quot;.Length) + &quot;Handler&quot;;
+							foundEventHandler = true;
+						}
+					}
+				}
+			}
+			return String.Concat(foundEventHandler ? &quot;new &quot; : &quot;/* might be wrong, please check */ new &quot;,
+			                     eventHandlerType,
+			                     &quot;(&quot;,
+			                     procedureName,
+			                     &quot;)&quot;);
+		}
+		
+		public object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			DebugOutput(typeOfExpression);
+			return String.Concat(typeOfExpression.Expression.AcceptVisitor(this, data),
+			                     &quot; is &quot;,
+			                     GetTypeString(typeOfExpression.Type));
+		}
+		
+		public object Visit(ArrayCreateExpression ace, object data)
+		{
+			DebugOutput(ace);
+			
+			return String.Concat(&quot;new &quot;,
+			                     GetTypeString(ace.CreateType),
+			                     &quot;[&quot;,
+			                     GetExpressionList(ace.Parameters),
+			                     &quot;]&quot;,
+			                     ace.ArrayInitializer.AcceptVisitor(this, data));
+		}
+#endregion
+#endregion
+		
+		public void AppendAttributes(ArrayList attr)
+		{
+			if (attr != null) {
+				foreach (AttributeSection section in attr) {
+					section.AcceptVisitor(this, null);
+				}
+			}
+		}
+		
+		public void AppendParameters(ArrayList parameters)
+		{
+			if (parameters == null) {
+				return;
+			}
+			for (int i = 0; i &lt; parameters.Count; ++i) {
+				ParameterDeclarationExpression pde = (ParameterDeclarationExpression)parameters[i];
+				AppendAttributes(pde.Attributes);
+				
+				if ((pde.ParamModifiers.Modifier &amp; ParamModifier.ByRef) == ParamModifier.ByRef) {
+					sourceText.Append(&quot;ref &quot;);
+				} else if ((pde.ParamModifiers.Modifier &amp; ParamModifier.ParamArray) == ParamModifier.ParamArray) {
+					sourceText.Append(&quot;params &quot;);
+				}
+				
+				sourceText.Append(GetTypeString(pde.TypeReference));
+				sourceText.Append(&quot; &quot;);
+				sourceText.Append(pde.ParameterName);
+				if (i + 1 &lt; parameters.Count) {
+					sourceText.Append(&quot;, &quot;);
+				}
+			}
+		}
+		
+		string ConvertTypeString(string typeString)
+		{
+			switch (typeString.ToLower()) {
+				case &quot;boolean&quot;:
+					return &quot;bool&quot;;
+				case &quot;string&quot;:
+					return &quot;string&quot;;
+				case &quot;char&quot;:
+					return &quot;char&quot;;
+				case &quot;double&quot;:
+					return &quot;double&quot;;
+				case &quot;single&quot;:
+					return &quot;float&quot;;
+				case &quot;decimal&quot;:
+					return &quot;decimal&quot;;
+				case &quot;date&quot;:
+					return &quot;System.DateTime&quot;;
+				case &quot;long&quot;:
+					return &quot;long&quot;;
+				case &quot;integer&quot;:
+					return &quot;int&quot;;
+				case &quot;short&quot;:
+					return &quot;short&quot;;
+				case &quot;byte&quot;:
+					return &quot;byte&quot;;
+				case &quot;void&quot;:
+					return &quot;void&quot;;
+				case &quot;system.object&quot;:
+				case &quot;object&quot;:
+					return &quot;object&quot;;
+				case &quot;system.uint64&quot;:
+					return &quot;ulong&quot;;
+				case &quot;system.uint32&quot;:
+					return &quot;uint&quot;;
+				case &quot;system.uint16&quot;:
+					return &quot;ushort&quot;;
+			}
+			return typeString;
+		}
+		
+		string GetTypeString(TypeReference typeRef)
+		{
+			if (typeRef == null) {
+				return &quot;void&quot;;
+			}
+			
+			string typeStr = ConvertTypeString(typeRef.Type);
+		
+			StringBuilder arrays = new StringBuilder();
+
+			if (typeRef.RankSpecifier != null) {
+				for (int i = 0; i &lt; typeRef.RankSpecifier.Count; ++i) {
+					arrays.Append(&quot;[&quot;);
+					arrays.Append(new String(',', (int)typeRef.RankSpecifier[i]));
+					arrays.Append(&quot;]&quot;);
+				}
+			} else {
+				if (typeRef.Dimension != null) {
+					arrays.Append(&quot;[&quot;);
+					if (typeRef.Dimension.Count &gt; 0) {
+						arrays.Append(new String(',', typeRef.Dimension.Count - 1));
+					}
+					arrays.Append(&quot;]&quot;);
+				}
+			}
+			
+			return typeStr + arrays.ToString();
+		}
+		
+		string GetModifier(Modifier modifier)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			if ((modifier &amp; Modifier.Public) == Modifier.Public) {
+				builder.Append(&quot;public &quot;);
+			} else if ((modifier &amp; Modifier.Private) == Modifier.Private) {
+				builder.Append(&quot;private &quot;);
+			} else if ((modifier &amp; (Modifier.Protected | Modifier.Friend)) == (Modifier.Protected | Modifier.Friend)) {
+				builder.Append(&quot;protected internal &quot;);
+			} else if ((modifier &amp; Modifier.Friend) == Modifier.Friend) {
+				builder.Append(&quot;internal &quot;);
+			} else if ((modifier &amp; Modifier.Protected) == Modifier.Protected) {
+				builder.Append(&quot;protected &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.MustInherit) == Modifier.MustInherit) {
+				builder.Append(&quot;abstract &quot;);
+			}
+			if ((modifier &amp; Modifier.Shared) == Modifier.Shared) {
+				builder.Append(&quot;static &quot;);
+			}
+			if ((modifier &amp; Modifier.Overridable) == Modifier.Overridable) {
+				builder.Append(&quot;virtual &quot;);
+			}
+			if ((modifier &amp; Modifier.MustOverride) == Modifier.MustOverride) {
+				builder.Append(&quot;abstract &quot;);
+			}
+			if ((modifier &amp; Modifier.Overrides) == Modifier.Overrides) {
+				builder.Append(&quot;override &quot;);
+			}
+			if ((modifier &amp; Modifier.Shadows) == Modifier.Shadows) {
+				builder.Append(&quot;new &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.NotInheritable) == Modifier.NotInheritable) {
+				builder.Append(&quot;sealed &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.Constant) == Modifier.Constant) {
+				builder.Append(&quot;const &quot;);
+			}
+			if ((modifier &amp; Modifier.ReadOnly) == Modifier.ReadOnly) {
+				builder.Append(&quot;readonly &quot;);
+			}
+			return builder.ToString();
+		}
+
+		string GetParameters(ArrayList list)
+		{
+			return String.Concat(&quot;(&quot;,
+			                     GetExpressionList(list),
+			                     &quot;)&quot;);
+		}
+		
+		string GetExpressionList(ArrayList list)
+		{
+			StringBuilder sb = new StringBuilder();
+			if (list != null) {
+				for (int i = 0; i &lt; list.Count; ++i) {
+					Expression exp = (Expression)list[i];
+					if (exp != null) {
+						sb.Append(exp.AcceptVisitor(this, null));
+						if (i + 1 &lt; list.Count) {
+							sb.Append(&quot;, &quot;);
+						}
+					}
+				}
+			}
+			return sb.ToString();
+		}
+		
+	}
+}	


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/CSharpConverter/CSharpVisitor.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,885 +1,885 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-using System.Drawing;
-using System.Diagnostics;
-using System.Globalization;
-using System.Text;
-using ICSharpCode.SharpRefactory.Parser;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class Token
-	{
-		public int kind;
-		
-		public int col;
-		public int line;
-		
-		public object    literalValue = null;
-		public string    val;
-		public Token     next;
-		public ArrayList specials;
-		
-		public Point EndLocation {
-			get {
-				return new Point(col + val.Length - 1, line);
-			}
-		}
-		
-		public Point Location {
-			get {
-				return new Point(col, line);
-			}
-		}
-		
-		public Token()
-		{
-		}
-		
-		public Token(int kind)
-		{
-			this.kind = kind;
-		}
-		
-		public Token(int kind, int col, int line, string val)
-		{
-			this.kind = kind;
-			this.col  = col;
-			this.line = line;
-			this.val  = val;
-		}
-		
-		public Token(int kind, int col, int line, string val, object literalValue)
-		{
-			this.kind         = kind;
-			this.col          = col;
-			this.line         = line;
-			this.val          = val;
-			this.literalValue = literalValue;
-		}
-	}
-	
-	public class Lexer
-	{
-		IReader reader;
-		static  Hashtable keywords = new Hashtable();
-		
-		int col  = 1;
-		int line = 1;
-		
-		bool lineEnd = false;
-		
-		Errors errors   = new Errors();
-		
-		SpecialTracker specialTracker = new SpecialTracker();
-		
-		Token lastToken = null;
-		Token curToken  = null;
-		Token peekToken = null;
-		
-		string[]       specialCommentTags = null;
-		Hashtable      specialCommentHash = null;
-		ArrayList      tagComments = new ArrayList();
-		
-		public ArrayList TagComments
-		{
-			get {
-				return tagComments;
-			}
-		}
-		
-		public string[] SpecialCommentTags
-		{
-			get {
-				return specialCommentTags;
-			}
-			set {
-				specialCommentTags = value;
-				specialCommentHash = new Hashtable();
-				if (specialCommentTags != null) {
-					foreach (string str in specialCommentTags) {
-						specialCommentHash[str] = 0;
-					}
-				}
-			}
-		}
-		
-		public SpecialTracker SpecialTracker
-		{
-			get {
-				return specialTracker;
-			}
-		}
-		
-		public Errors Errors
-		{
-			get {
-				return errors;
-			}
-		}
-		
-		public Token Token
-		{
-			get {
-				return lastToken;
-			}
-		}
-		
-		public Token LookAhead
-		{
-			get {
-				return curToken;
-			}
-		}
-		
-		public void StartPeek()
-		{
-			peekToken = curToken;
-		}
-		
-		public Token Peek()
-		{
-			if (peekToken.next == null) {
-				peekToken.next = Next();
-				specialTracker.InformToken(peekToken.next.kind);
-			}
-			peekToken = peekToken.next;
-			return peekToken;
-		}
-		
-		public Token NextToken()
-		{
-			if (curToken == null) { // first call of NextToken()
-				curToken = Next();
-				specialTracker.InformToken(curToken.kind);
-				return curToken;
-			}
-			
-			lastToken = curToken;
-			
-			if (curToken.next == null) {
-				curToken.next = Next();
-				specialTracker.InformToken(curToken.next.kind);
-			}
-			
-			curToken = curToken.next;
-			
-			if (curToken.kind == Tokens.EOF &amp;&amp; !(lastToken.kind == Tokens.EOL)) { // be sure that before EOF there is an EOL token
-				curToken = new Token(Tokens.EOL, curToken.col, curToken.line, &quot;\n&quot;);
-				curToken.next = new Token(Tokens.EOF, curToken.col, curToken.line, &quot;\n&quot;);
-				specialTracker.InformToken(curToken.next.kind);
-			}
-			
-			return curToken;
-		}
-		
-		public ArrayList RetriveComments()
-		{
-			return specialTracker.RetrieveSpecials();
-		}
-		
-//		public ArrayList RetrieveSpecials()
-//		{
-//			if (lastToken == null) {
-//				return this.specialTracker.RetrieveSpecials();
-//			}
-//			
-//			Debug.Assert(lastToken.specials != null);
-//			
-//			ArrayList tmp = lastToken.specials;
-//			lastToken.specials = null;
-//			return tmp;
-//		}
-//		
-		public Lexer(IReader reader)
-		{
-			this.reader = reader;
-		}
-		
-		public Token Next()
-		{
-			while (!reader.Eos()) {
-
-				char ch = reader.GetNext();
-		
-				++col;
-				if (Char.IsWhiteSpace(ch)) {
-				
-					if (ch == '\n') {
-						int x = col - 1;
-						int y = line;
-						++line;
-						col = 1;
-						if (reader.Peek() == '\r') {
-							reader.GetNext();
-							if (!lineEnd) {
-								lineEnd = true;
-								return new Token(Tokens.EOL, x -1 , y, &quot;\n\r&quot;);
-							}
-						}
-						if (!lineEnd) {
-							lineEnd = true;
-							return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
-						}
-					}
-					continue;
-
-				}
-				if (ch == '_') {
-					if (reader.Eos()) {
-						errors.Error(line, col, String.Format(&quot;No EOF expected after _&quot;));
-					}
-					ch = reader.GetNext();
-					++col;
-					if (!Char.IsWhiteSpace(ch)) {
-						reader.UnGet();
-						--col;
-						int x = col;
-						int y = line;
-						string s = ReadIdent('_');
-						lineEnd = false;
-
-						return new Token(Tokens.Identifier, x, y, s);
-					}
-					while (Char.IsWhiteSpace(ch)) {
-						if (ch == '\n') {
-							++line;
-							col = 0;
-							break;
-						}
-						if (!reader.Eos()) {
-							ch = reader.GetNext();
-							++col;
-						}
-					}
-					if (ch != '\n') {
-						errors.Error(line, col, String.Format(&quot;Return expected&quot;));
-					}
-					continue;
-				}
-				
-				if (ch == '#') {
-					while (Char.IsWhiteSpace(reader.Peek())) {
-						++col;
-						reader.GetNext();
-					}
-					if (Char.IsDigit(reader.Peek())) {
-						int x = col;
-						int y = line;
-						string s = ReadDate();
-						DateTime time = DateTime.Now;
-						try {
-							time = System.DateTime.Parse(s, System.Globalization.CultureInfo.InvariantCulture);
-						} catch (Exception e) {
-							errors.Error(line, col, String.Format(&quot;Invalid date time {0}&quot;, e));
-						}
-						return new Token(Tokens.LiteralDate, x, y, s, time);
-					} else {
-						ReadPreprocessorDirective();
-						continue;
-					}
-				}
-				
-				if (ch == '[') { // Identifier
-					lineEnd = false;
-					if (reader.Eos()) {
-						errors.Error(line, col, String.Format(&quot;Identifier expected&quot;));
-					}
-					ch = reader.GetNext();
-					++col;
-					if (ch == ']' || Char.IsWhiteSpace(ch)) {
-						errors.Error(line, col, String.Format(&quot;Identifier expected&quot;));
-					}
-					int x = col - 1;
-					int y = line;
-					string s = ReadIdent(ch);
-					if (reader.Eos()) {
-						errors.Error(line, col, String.Format(&quot;']' expected&quot;));
-					}
-					ch = reader.GetNext();
-					++col;
-					if (!(ch == ']')) {
-						errors.Error(line, col, String.Format(&quot;']' expected&quot;));
-					}
-//					Console.WriteLine(&quot;&gt;&quot; + s + &quot;&lt;&quot;);
-					return new Token(Tokens.Identifier, x, y, s);
-				}
-				if (Char.IsLetter(ch)) {
-					int x = col - 1;
-					int y = line;
-					string s = ReadIdent(ch);
-					if (Keywords.IsKeyword(s)) {
-						lineEnd = false;
-						return new Token(Keywords.GetToken(s), x, y, s);
-					}
-					
-					// handle 'REM' comments 
-					if (s.ToUpper() == &quot;REM&quot;) {
-						ReadComment();
-						if (!lineEnd) {
-							lineEnd = true;
-							return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
-						}
-						continue;
-					}
-						
-					lineEnd = false;
-					return new Token(Tokens.Identifier, x, y, s);
-				
-				}
-				if (Char.IsDigit(ch)) {
-					lineEnd = false;
-					return ReadDigit(ch, col);
-				}
-				if (ch == '&amp;') {
-					lineEnd = false;
-					if (reader.Eos()) {
-						return ReadOperator('&amp;');
-					}
-					ch = reader.GetNext();
-					++col;
-					if (Char.ToUpper(ch) == 'H' || Char.ToUpper(ch) == 'O') {
-						reader.UnGet();
-						--col;
-						return ReadDigit('&amp;', col);
-					} else {
-						reader.UnGet();
-						return ReadOperator('&amp;');
-					}
-				}
-				if (ch == '\'') {
-					int x = col - 1;
-					int y = line;
-					ReadComment();
-					if (!lineEnd) {
-						lineEnd = true;
-						return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
-					}
-					continue;
-				}
-				if (ch == '&quot;') {
-					lineEnd = false;
-					int x = col - 1;
-					int y = line;
-					string s = ReadString();
-					if (!reader.Eos() &amp;&amp; (reader.Peek() == 'C' || reader.Peek() == 'c')) {
-						reader.GetNext();
-						++col;
-						if (s.Length != 1) {
-							errors.Error(line, col, String.Format(&quot;Chars can only have Length 1 &quot;));
-						}
-						return new Token(Tokens.LiteralCharacter, x, y, String.Concat('&quot;', s , &quot;\&quot;C&quot;) , s[0]);
-					}
-					return new Token(Tokens.LiteralString, x, y,  String.Concat('&quot;', s , '&quot;'), s);
-				}
-				Token token = ReadOperator(ch);
-				if (token != null) {
-					lineEnd = false;
-					return token;
-				}
-				errors.Error(line, col, String.Format(&quot;Unknown char({0}) which can't be read&quot;, ch));
-			}
-			
-			return new Token(Tokens.EOF);
-		}
-		
-		string ReadIdent(char ch) 
-		{
-			StringBuilder s = new StringBuilder(ch.ToString());
-			while (!reader.Eos() &amp;&amp; (Char.IsLetterOrDigit(ch = reader.GetNext()) || ch == '_')) {
-				++col;
-				s.Append(ch.ToString());
-			}
-			++col;
-			if (reader.Eos()) {
-				--col;
-				return s.ToString();
-			}
-			reader.UnGet();
-			--col;
-			if (!reader.Eos() &amp;&amp; &quot;%&amp;@!#$&quot;.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
-				reader.GetNext();
-				++col;
-			}
-			return s.ToString();
-		}
-		
-		Token ReadDigit(char ch, int x)
-		{
-			StringBuilder sb = new StringBuilder(ch.ToString());
-			int y = line;
-			string digit = &quot;&quot;;
-			if (ch != '&amp;') {
-				digit += ch;
-			}
-			
-			bool ishex      = false;
-			bool isokt      = false;
-			bool issingle   = false;
-			bool isdouble   = false;
-			bool isdecimal  = false;
-			
-			if (reader.Eos()) {
-				if (ch == '&amp;') {
-					errors.Error(line, col, String.Format(&quot;digit expected&quot;));
-				}
-				return new Token(Tokens.LiteralInteger, x, y, sb.ToString() ,ch - '0');
-			}
-			if (ch == '&amp;' &amp;&amp; Char.ToUpper(reader.Peek()) == 'H') {
-				const string hex = &quot;0123456789ABCDEF&quot;;
-				sb.Append(reader.GetNext()); // skip 'H'
-				++col;
-				while (!reader.Eos() &amp;&amp; hex.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
-					ch = reader.GetNext();
-					sb.Append(ch); 
-					digit += Char.ToUpper(ch);
-					++col;
-				}
-				ishex = true;
-			} else if (!reader.Eos() &amp;&amp; ch == '&amp;' &amp;&amp; Char.ToUpper(reader.Peek()) == 'O') {
-				const string okt = &quot;01234567&quot;;
-				sb.Append(reader.GetNext()); // skip 'O'
-				++col;
-				while (!reader.Eos() &amp;&amp; okt.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
-					ch = reader.GetNext();
-					sb.Append(ch); 
-					digit += Char.ToUpper(ch);
-					++col;
-				}
-				isokt = true;
-			} else {
-				while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())) {
-					ch = reader.GetNext();;
-					digit += ch;
-					sb.Append(ch);
-					++col;
-				}
-			}
-			if (!reader.Eos() &amp;&amp; &quot;%&amp;SIL&quot;.IndexOf(Char.ToUpper(reader.Peek())) != -1 || ishex || isokt) {
-				ch = reader.GetNext();
-				sb.Append(ch); 
-				ch = Char.ToUpper(ch);
-				++col;
-				if (isokt) {
-					long number = 0L;
-					for (int i = 0; i &lt; digit.Length; ++i) {
-						number = number * 8 + digit[i] - '0';
-					}
-					if (ch == 'S') {
-						return new Token(Tokens.LiteralSingle, x, y, sb.ToString(), (short)number);
-					} else if (ch == '%' || ch == 'I') {
-						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
-					} else if (ch == '&amp;' || ch == 'L') {
-						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (long)number);
-					} else {
-						if (number &gt; int.MaxValue || number &lt; int.MinValue) {
-							return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (long)number);
-						} else {
-							return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
-						}
-					}
-				}
-				if (ch == 'S') {
-					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int16.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
-				} else if (ch == '%' || ch == 'I') {
-					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
-				} else if (ch == '&amp;' || ch == 'L') {
-					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
-				} else if (ishex) {
-					reader.UnGet();
-					--col;
-					long number = Int64.Parse(digit, NumberStyles.HexNumber);
-					if (number &gt; int.MaxValue || number &lt; int.MinValue) {
-						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), number);
-					} else {
-						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
-					}
-				}
-			}
-			if (!reader.Eos() &amp;&amp; reader.Peek() == '.') { // read floating point number
-				reader.GetNext();
-				if (!Char.IsDigit(reader.Peek())) {
-					reader.UnGet();
-				} else {
-					isdouble = true; // double is default
-					if (ishex || isokt) {
-						errors.Error(line, col, String.Format(&quot;No hexadecimal or oktadecimal floating point values allowed&quot;));
-					}
-					digit += '.';
-					++col;
-					while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())){ // read decimal digits beyond the dot
-						digit += reader.GetNext();
-						++col;
-					}
-				}
-			}
-			
-			if (!reader.Eos() &amp;&amp; Char.ToUpper(reader.Peek()) == 'E') { // read exponent
-				isdouble = true;
-				digit +=  reader.GetNext();
-				++col;
-				if (!reader.Eos() &amp;&amp; (reader.Peek() == '-' || reader.Peek() == '+')) {
-					digit += reader.GetNext();
-					++col;
-				}
-				while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())) { // read exponent value
-					digit += reader.GetNext();
-					++col;
-				}
-			}
-			
-			if (!reader.Eos()) {
-				if (Char.ToUpper(reader.Peek()) == 'R' || Char.ToUpper(reader.Peek()) == '#') { // double type suffix (obsolete, double is default)
-					reader.GetNext();
-					++col;
-					isdouble = true;
-				} else if (Char.ToUpper(reader.Peek()) == 'D' || Char.ToUpper(reader.Peek()) == '@') { // decimal value
-					reader.GetNext();
-					++col;
-					isdecimal = true;
-				} else if (Char.ToUpper(reader.Peek()) == 'F' || Char.ToUpper(reader.Peek()) == '!') { // decimal value
-					reader.GetNext();
-					++col;
-					issingle = true;
-				}
-			}
-			
-			if (issingle) {
-				NumberFormatInfo mi = new NumberFormatInfo();
-				mi.CurrencyDecimalSeparator = &quot;.&quot;;
-				return new Token(Tokens.LiteralSingle, x, y, sb.ToString(), Single.Parse(digit, mi));
-			}
-			if (isdecimal) {
-				NumberFormatInfo mi = new NumberFormatInfo();
-				mi.CurrencyDecimalSeparator = &quot;.&quot;;
-				return new Token(Tokens.LiteralDecimal, x, y, sb.ToString(), Decimal.Parse(digit, mi));
-			}
-			if (isdouble) {
-				NumberFormatInfo mi = new NumberFormatInfo();
-				mi.CurrencyDecimalSeparator = &quot;.&quot;;
-				return new Token(Tokens.LiteralDouble, x, y, sb.ToString(), Double.Parse(digit, mi));
-			}
-			try {
-				return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
-			} catch (Exception) {
-				try {
-					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
-				} catch (Exception) {
-					errors.Error(line, col, String.Format(&quot;{0} is not a parseable number (too long?)&quot;, sb.ToString()));
-					// fallback, when nothing helps :)
-					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), 0);
-				}
-			}
-		}
-		
-		void ReadPreprocessorDirective()
-		{
-			Point start = new Point(col - 1, line);
-			string directive = ReadIdent('#');
-			string argument  = ReadToEOL();
-			this.specialTracker.AddPreProcessingDirective(directive, argument.Trim(), start, new Point(start.X + directive.Length + argument.Length, start.Y));
-		}
-		
-		string ReadToEOL()
-		{
-			StringBuilder sb = new StringBuilder();
-			if (!reader.Eos()) {
-				char ch = reader.GetNext();
-				while (!reader.Eos()) {
-					if (ch == '\r') {
-						if (reader.Peek() == '\n') {
-							ch = reader.GetNext();
-						}
-					}
-					if (ch == '\n') {
-						++line;
-						col = 1;
-						return sb.ToString();
-					} else {
-						sb.Append(ch);
-					}
-					ch = reader.GetNext();
-					++col;
-				}
-			}
-			return sb.ToString();
-		}
-		
-		string ReadDate()
-		{
-			char ch = '\0';
-			StringBuilder sb = new StringBuilder();
-			while (!reader.Eos()) {
-				ch = reader.GetNext();
-				++col;
-				if (ch == '#') {
-					break;
-				} else if (ch == '\n') {
-					errors.Error(line, col, String.Format(&quot;No return allowed inside Date literal&quot;));
-				} else {
-					sb.Append(ch);
-				}
-			}
-			if (ch != '#') {
-				errors.Error(line, col, String.Format(&quot;End of File reached before Date literal terminated&quot;));
-			}
-			return sb.ToString();
-		}
-		
-		string ReadString()
-		{
-			char ch = '\0';
-			StringBuilder s = new StringBuilder();
-			while (!reader.Eos()) {
-				ch = reader.GetNext();
-				++col;
-				if (ch == '&quot;') {
-					if (!reader.Eos() &amp;&amp; reader.Peek() == '&quot;') {
-						s.Append('&quot;');
-						reader.GetNext();
-						++col;
-					} else {
-						break;
-					}
-				} else if (ch == '\n') {
-					errors.Error(line, col, String.Format(&quot;No return allowed inside String literal&quot;));
-				} else {
-					s.Append(ch);
-				}
-			}
-			if (ch != '&quot;') {
-				errors.Error(line, col, String.Format(&quot;End of File reached before String terminated &quot;));
-			}
-			return s.ToString();
-		}
-		
-		protected bool HandleLineEnd(char ch)
-		{
-			if (WasLineEnd(ch)) {
-				++line;
-				col = 1;
-				return true;
-			}
-			return false;
-		}
-		
-		protected bool WasLineEnd(char ch)
-		{
-			// Handle MS-DOS or MacOS line ends.
-			if (ch == '\r') {
-				if (reader.Peek() == '\n') { // MS-DOS line end '\r\n'
-					ch = (char)reader.GetNext();
-				} else { // assume MacOS line end which is '\r'
-					ch = '\n';
-				}
-			}
-			return ch == '\n';
-		}
-		
-		void ReadComment()
-		{
-			StringBuilder curWord = new StringBuilder();
-			StringBuilder comment = new StringBuilder();
-			
-			int nextChar;
-			while ((nextChar = reader.GetNext()) != -1) {
-				char ch = (char)nextChar;
-				comment.Append(ch);
-				++col;
-				if (HandleLineEnd(ch) || nextChar == 0) {
-					specialTracker.StartComment(CommentType.SingleLine, new Point(col, line));
-					specialTracker.AddString(comment.ToString());
-					specialTracker.FinishComment();
-					return;
-				}
-				
-				if (Char.IsLetter(ch)) {
-					curWord.Append(ch);
-				} else {
-					string tag = curWord.ToString();
-					curWord = new StringBuilder();
-					if (specialCommentHash != null &amp;&amp; specialCommentHash[tag] != null) {
-						Point p = new Point(col, line);
-						string commentStr = ReadToEOL();
-						tagComments.Add(new TagComment(tag, commentStr, p));
-						return;
-					}
-				}
-			}
-		}
-		
-		Token ReadOperator(char ch)
-		{
-			int x = col;
-			int y = line;
-			switch(ch) {
-				case '+':
-					if (!reader.Eos()) {
-						switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.PlusAssign, x, y, &quot;+=&quot;);
-							default:
-								reader.UnGet();
-								break;
-						}
-					}
-					return new Token(Tokens.Plus, x, y, &quot;+&quot;);
-				case '-':
-					if (!reader.Eos()) {
-						switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.MinusAssign, x, y, &quot;-=&quot;);
-							default:
-								reader.UnGet();
-								break;
-						}
-					}
-					return new Token(Tokens.Minus, x, y, &quot;-&quot;);
-				case '*':
-					if (!reader.Eos()) {
-						switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.TimesAssign, x, y, &quot;*=&quot;);
-							default:
-								reader.UnGet();
-								break;
-						}
-					}
-					return new Token(Tokens.Times, x, y, &quot;*&quot;);
-				case '/':
-					if (!reader.Eos()) {
-						switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.DivAssign, x, y, &quot;/=&quot;);
-							default:
-								reader.UnGet();
-								break;
-						}
-					}
-					return new Token(Tokens.Div, x, y, &quot;/&quot;);
-				case '\\':
-					switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.DivIntegerAssign, x, y, &quot;\\=&quot;);
-							default:
-								reader.UnGet();
-								break;
-						}
-					return new Token(Tokens.DivInteger, x, y, &quot;\\&quot;);
-				case '&amp;':
-					if (!reader.Eos()) {
-						switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.ConcatStringAssign, x, y, &quot;&amp;=&quot;);
-							default:
-								reader.UnGet();
-								break;
-						}
-					}
-					return new Token(Tokens.ConcatString, x, y, &quot;&amp;&quot;);
-				case '^':
-					switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.PowerAssign, x, y, &quot;^=&quot;);
-							default:
-								reader.UnGet();
-								break;
-						}
-					return new Token(Tokens.Power, x, y, &quot;^&quot;);
-				case ':':
-					return new Token(Tokens.Colon, x, y, &quot;:&quot;);
-				case '=':
-					return new Token(Tokens.Assign, x, y, &quot;=&quot;);
-				case '&lt;':
-					if (!reader.Eos()) {
-						switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.LessEqual, x, y, &quot;&lt;=&quot;);
-							case '&gt;':
-								++col;
-								return new Token(Tokens.NotEqual, x, y, &quot;&lt;&gt;&quot;);
-							case '&lt;':
-								if (!reader.Eos()) {
-									switch (reader.GetNext()) {
-										case '=':
-											col += 2;
-											return new Token(Tokens.ShiftLeftAssign, x, y, &quot;&lt;&lt;=&quot;);
-										default:
-											++col;
-											reader.UnGet();
-											break;
-									}
-								}
-								return new Token(Tokens.ShiftLeft, x, y, &quot;&lt;&lt;&quot;);
-							default:
-								reader.UnGet();
-								return new Token(Tokens.LessThan, x, y, &quot;&lt;&quot;);
-						}
-					}
-					return new Token(Tokens.LessThan, x, y, &quot;&lt;&quot;);
-				case '&gt;':
-					if (!reader.Eos()) {
-						switch (reader.GetNext()) {
-							case '=':
-								++col;
-								return new Token(Tokens.GreaterEqual, x, y, &quot;&gt;=&quot;);
-							case '&gt;':
-								if (!reader.Eos()) {
-									switch (reader.GetNext()) {
-										case '=':
-											col += 2;
-											return new Token(Tokens.ShiftRightAssign, x, y, &quot;&gt;&gt;=&quot;);
-										default:
-											++col;
-											reader.UnGet();
-											break;
-									}
-								}
-								return new Token(Tokens.ShiftRight, x, y, &quot;&gt;&gt;&quot;);
-							default:
-								reader.UnGet();
-								return new Token(Tokens.GreaterThan, x, y, &quot;&gt;&quot;);
-						}
-					}
-					return new Token(Tokens.GreaterThan, x, y, &quot;&lt;=&quot;);
-				case ',':
-					return new Token(Tokens.Comma, x, y, &quot;,&quot;);
-				case '.':
-					if (Char.IsDigit(reader.Peek())) {
-						 reader.UnGet();
-						 --col;
-						 return ReadDigit('0', col);
-					}
-					return new Token(Tokens.Dot, x, y, &quot;.&quot;);
-				case '(':
-					return new Token(Tokens.OpenParenthesis, x, y, &quot;(&quot;);
-				case ')':
-					return new Token(Tokens.CloseParenthesis, x, y, &quot;)&quot;);
-				case '{':
-					return new Token(Tokens.OpenCurlyBrace, x, y, &quot;{&quot;);
-				case '}':
-					return new Token(Tokens.CloseCurlyBrace, x, y, &quot;}&quot;);
-				case '[':
-					return new Token(Tokens.OpenSquareBracket, x, y, &quot;[&quot;);
-				case ']':
-					return new Token(Tokens.CloseSquareBracket, x, y, &quot;]&quot;);
-			}
-			return null;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Drawing;
+using System.Diagnostics;
+using System.Globalization;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class Token
+	{
+		public int kind;
+		
+		public int col;
+		public int line;
+		
+		public object    literalValue = null;
+		public string    val;
+		public Token     next;
+		public ArrayList specials;
+		
+		public Point EndLocation {
+			get {
+				return new Point(col + val.Length - 1, line);
+			}
+		}
+		
+		public Point Location {
+			get {
+				return new Point(col, line);
+			}
+		}
+		
+		public Token()
+		{
+		}
+		
+		public Token(int kind)
+		{
+			this.kind = kind;
+		}
+		
+		public Token(int kind, int col, int line, string val)
+		{
+			this.kind = kind;
+			this.col  = col;
+			this.line = line;
+			this.val  = val;
+		}
+		
+		public Token(int kind, int col, int line, string val, object literalValue)
+		{
+			this.kind         = kind;
+			this.col          = col;
+			this.line         = line;
+			this.val          = val;
+			this.literalValue = literalValue;
+		}
+	}
+	
+	public class Lexer
+	{
+		IReader reader;
+		static  Hashtable keywords = new Hashtable();
+		
+		int col  = 1;
+		int line = 1;
+		
+		bool lineEnd = false;
+		
+		Errors errors   = new Errors();
+		
+		SpecialTracker specialTracker = new SpecialTracker();
+		
+		Token lastToken = null;
+		Token curToken  = null;
+		Token peekToken = null;
+		
+		string[]       specialCommentTags = null;
+		Hashtable      specialCommentHash = null;
+		ArrayList      tagComments = new ArrayList();
+		
+		public ArrayList TagComments
+		{
+			get {
+				return tagComments;
+			}
+		}
+		
+		public string[] SpecialCommentTags
+		{
+			get {
+				return specialCommentTags;
+			}
+			set {
+				specialCommentTags = value;
+				specialCommentHash = new Hashtable();
+				if (specialCommentTags != null) {
+					foreach (string str in specialCommentTags) {
+						specialCommentHash[str] = 0;
+					}
+				}
+			}
+		}
+		
+		public SpecialTracker SpecialTracker
+		{
+			get {
+				return specialTracker;
+			}
+		}
+		
+		public Errors Errors
+		{
+			get {
+				return errors;
+			}
+		}
+		
+		public Token Token
+		{
+			get {
+				return lastToken;
+			}
+		}
+		
+		public Token LookAhead
+		{
+			get {
+				return curToken;
+			}
+		}
+		
+		public void StartPeek()
+		{
+			peekToken = curToken;
+		}
+		
+		public Token Peek()
+		{
+			if (peekToken.next == null) {
+				peekToken.next = Next();
+				specialTracker.InformToken(peekToken.next.kind);
+			}
+			peekToken = peekToken.next;
+			return peekToken;
+		}
+		
+		public Token NextToken()
+		{
+			if (curToken == null) { // first call of NextToken()
+				curToken = Next();
+				specialTracker.InformToken(curToken.kind);
+				return curToken;
+			}
+			
+			lastToken = curToken;
+			
+			if (curToken.next == null) {
+				curToken.next = Next();
+				specialTracker.InformToken(curToken.next.kind);
+			}
+			
+			curToken = curToken.next;
+			
+			if (curToken.kind == Tokens.EOF &amp;&amp; !(lastToken.kind == Tokens.EOL)) { // be sure that before EOF there is an EOL token
+				curToken = new Token(Tokens.EOL, curToken.col, curToken.line, &quot;\n&quot;);
+				curToken.next = new Token(Tokens.EOF, curToken.col, curToken.line, &quot;\n&quot;);
+				specialTracker.InformToken(curToken.next.kind);
+			}
+			
+			return curToken;
+		}
+		
+		public ArrayList RetriveComments()
+		{
+			return specialTracker.RetrieveSpecials();
+		}
+		
+//		public ArrayList RetrieveSpecials()
+//		{
+//			if (lastToken == null) {
+//				return this.specialTracker.RetrieveSpecials();
+//			}
+//			
+//			Debug.Assert(lastToken.specials != null);
+//			
+//			ArrayList tmp = lastToken.specials;
+//			lastToken.specials = null;
+//			return tmp;
+//		}
+//		
+		public Lexer(IReader reader)
+		{
+			this.reader = reader;
+		}
+		
+		public Token Next()
+		{
+			while (!reader.Eos()) {
+
+				char ch = reader.GetNext();
+		
+				++col;
+				if (Char.IsWhiteSpace(ch)) {
+				
+					if (ch == '\n') {
+						int x = col - 1;
+						int y = line;
+						++line;
+						col = 1;
+						if (reader.Peek() == '\r') {
+							reader.GetNext();
+							if (!lineEnd) {
+								lineEnd = true;
+								return new Token(Tokens.EOL, x -1 , y, &quot;\n\r&quot;);
+							}
+						}
+						if (!lineEnd) {
+							lineEnd = true;
+							return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
+						}
+					}
+					continue;
+
+				}
+				if (ch == '_') {
+					if (reader.Eos()) {
+						errors.Error(line, col, String.Format(&quot;No EOF expected after _&quot;));
+					}
+					ch = reader.GetNext();
+					++col;
+					if (!Char.IsWhiteSpace(ch)) {
+						reader.UnGet();
+						--col;
+						int x = col;
+						int y = line;
+						string s = ReadIdent('_');
+						lineEnd = false;
+
+						return new Token(Tokens.Identifier, x, y, s);
+					}
+					while (Char.IsWhiteSpace(ch)) {
+						if (ch == '\n') {
+							++line;
+							col = 0;
+							break;
+						}
+						if (!reader.Eos()) {
+							ch = reader.GetNext();
+							++col;
+						}
+					}
+					if (ch != '\n') {
+						errors.Error(line, col, String.Format(&quot;Return expected&quot;));
+					}
+					continue;
+				}
+				
+				if (ch == '#') {
+					while (Char.IsWhiteSpace(reader.Peek())) {
+						++col;
+						reader.GetNext();
+					}
+					if (Char.IsDigit(reader.Peek())) {
+						int x = col;
+						int y = line;
+						string s = ReadDate();
+						DateTime time = DateTime.Now;
+						try {
+							time = System.DateTime.Parse(s, System.Globalization.CultureInfo.InvariantCulture);
+						} catch (Exception e) {
+							errors.Error(line, col, String.Format(&quot;Invalid date time {0}&quot;, e));
+						}
+						return new Token(Tokens.LiteralDate, x, y, s, time);
+					} else {
+						ReadPreprocessorDirective();
+						continue;
+					}
+				}
+				
+				if (ch == '[') { // Identifier
+					lineEnd = false;
+					if (reader.Eos()) {
+						errors.Error(line, col, String.Format(&quot;Identifier expected&quot;));
+					}
+					ch = reader.GetNext();
+					++col;
+					if (ch == ']' || Char.IsWhiteSpace(ch)) {
+						errors.Error(line, col, String.Format(&quot;Identifier expected&quot;));
+					}
+					int x = col - 1;
+					int y = line;
+					string s = ReadIdent(ch);
+					if (reader.Eos()) {
+						errors.Error(line, col, String.Format(&quot;']' expected&quot;));
+					}
+					ch = reader.GetNext();
+					++col;
+					if (!(ch == ']')) {
+						errors.Error(line, col, String.Format(&quot;']' expected&quot;));
+					}
+//					Console.WriteLine(&quot;&gt;&quot; + s + &quot;&lt;&quot;);
+					return new Token(Tokens.Identifier, x, y, s);
+				}
+				if (Char.IsLetter(ch)) {
+					int x = col - 1;
+					int y = line;
+					string s = ReadIdent(ch);
+					if (Keywords.IsKeyword(s)) {
+						lineEnd = false;
+						return new Token(Keywords.GetToken(s), x, y, s);
+					}
+					
+					// handle 'REM' comments 
+					if (s.ToUpper() == &quot;REM&quot;) {
+						ReadComment();
+						if (!lineEnd) {
+							lineEnd = true;
+							return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
+						}
+						continue;
+					}
+						
+					lineEnd = false;
+					return new Token(Tokens.Identifier, x, y, s);
+				
+				}
+				if (Char.IsDigit(ch)) {
+					lineEnd = false;
+					return ReadDigit(ch, col);
+				}
+				if (ch == '&amp;') {
+					lineEnd = false;
+					if (reader.Eos()) {
+						return ReadOperator('&amp;');
+					}
+					ch = reader.GetNext();
+					++col;
+					if (Char.ToUpper(ch) == 'H' || Char.ToUpper(ch) == 'O') {
+						reader.UnGet();
+						--col;
+						return ReadDigit('&amp;', col);
+					} else {
+						reader.UnGet();
+						return ReadOperator('&amp;');
+					}
+				}
+				if (ch == '\'') {
+					int x = col - 1;
+					int y = line;
+					ReadComment();
+					if (!lineEnd) {
+						lineEnd = true;
+						return new Token(Tokens.EOL, x, y, &quot;\n&quot;);
+					}
+					continue;
+				}
+				if (ch == '&quot;') {
+					lineEnd = false;
+					int x = col - 1;
+					int y = line;
+					string s = ReadString();
+					if (!reader.Eos() &amp;&amp; (reader.Peek() == 'C' || reader.Peek() == 'c')) {
+						reader.GetNext();
+						++col;
+						if (s.Length != 1) {
+							errors.Error(line, col, String.Format(&quot;Chars can only have Length 1 &quot;));
+						}
+						return new Token(Tokens.LiteralCharacter, x, y, String.Concat('&quot;', s , &quot;\&quot;C&quot;) , s[0]);
+					}
+					return new Token(Tokens.LiteralString, x, y,  String.Concat('&quot;', s , '&quot;'), s);
+				}
+				Token token = ReadOperator(ch);
+				if (token != null) {
+					lineEnd = false;
+					return token;
+				}
+				errors.Error(line, col, String.Format(&quot;Unknown char({0}) which can't be read&quot;, ch));
+			}
+			
+			return new Token(Tokens.EOF);
+		}
+		
+		string ReadIdent(char ch) 
+		{
+			StringBuilder s = new StringBuilder(ch.ToString());
+			while (!reader.Eos() &amp;&amp; (Char.IsLetterOrDigit(ch = reader.GetNext()) || ch == '_')) {
+				++col;
+				s.Append(ch.ToString());
+			}
+			++col;
+			if (reader.Eos()) {
+				--col;
+				return s.ToString();
+			}
+			reader.UnGet();
+			--col;
+			if (!reader.Eos() &amp;&amp; &quot;%&amp;@!#$&quot;.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
+				reader.GetNext();
+				++col;
+			}
+			return s.ToString();
+		}
+		
+		Token ReadDigit(char ch, int x)
+		{
+			StringBuilder sb = new StringBuilder(ch.ToString());
+			int y = line;
+			string digit = &quot;&quot;;
+			if (ch != '&amp;') {
+				digit += ch;
+			}
+			
+			bool ishex      = false;
+			bool isokt      = false;
+			bool issingle   = false;
+			bool isdouble   = false;
+			bool isdecimal  = false;
+			
+			if (reader.Eos()) {
+				if (ch == '&amp;') {
+					errors.Error(line, col, String.Format(&quot;digit expected&quot;));
+				}
+				return new Token(Tokens.LiteralInteger, x, y, sb.ToString() ,ch - '0');
+			}
+			if (ch == '&amp;' &amp;&amp; Char.ToUpper(reader.Peek()) == 'H') {
+				const string hex = &quot;0123456789ABCDEF&quot;;
+				sb.Append(reader.GetNext()); // skip 'H'
+				++col;
+				while (!reader.Eos() &amp;&amp; hex.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
+					ch = reader.GetNext();
+					sb.Append(ch); 
+					digit += Char.ToUpper(ch);
+					++col;
+				}
+				ishex = true;
+			} else if (!reader.Eos() &amp;&amp; ch == '&amp;' &amp;&amp; Char.ToUpper(reader.Peek()) == 'O') {
+				const string okt = &quot;01234567&quot;;
+				sb.Append(reader.GetNext()); // skip 'O'
+				++col;
+				while (!reader.Eos() &amp;&amp; okt.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
+					ch = reader.GetNext();
+					sb.Append(ch); 
+					digit += Char.ToUpper(ch);
+					++col;
+				}
+				isokt = true;
+			} else {
+				while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())) {
+					ch = reader.GetNext();;
+					digit += ch;
+					sb.Append(ch);
+					++col;
+				}
+			}
+			if (!reader.Eos() &amp;&amp; &quot;%&amp;SIL&quot;.IndexOf(Char.ToUpper(reader.Peek())) != -1 || ishex || isokt) {
+				ch = reader.GetNext();
+				sb.Append(ch); 
+				ch = Char.ToUpper(ch);
+				++col;
+				if (isokt) {
+					long number = 0L;
+					for (int i = 0; i &lt; digit.Length; ++i) {
+						number = number * 8 + digit[i] - '0';
+					}
+					if (ch == 'S') {
+						return new Token(Tokens.LiteralSingle, x, y, sb.ToString(), (short)number);
+					} else if (ch == '%' || ch == 'I') {
+						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
+					} else if (ch == '&amp;' || ch == 'L') {
+						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (long)number);
+					} else {
+						if (number &gt; int.MaxValue || number &lt; int.MinValue) {
+							return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (long)number);
+						} else {
+							return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
+						}
+					}
+				}
+				if (ch == 'S') {
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int16.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+				} else if (ch == '%' || ch == 'I') {
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+				} else if (ch == '&amp;' || ch == 'L') {
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+				} else if (ishex) {
+					reader.UnGet();
+					--col;
+					long number = Int64.Parse(digit, NumberStyles.HexNumber);
+					if (number &gt; int.MaxValue || number &lt; int.MinValue) {
+						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), number);
+					} else {
+						return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), (int)number);
+					}
+				}
+			}
+			if (!reader.Eos() &amp;&amp; reader.Peek() == '.') { // read floating point number
+				reader.GetNext();
+				if (!Char.IsDigit(reader.Peek())) {
+					reader.UnGet();
+				} else {
+					isdouble = true; // double is default
+					if (ishex || isokt) {
+						errors.Error(line, col, String.Format(&quot;No hexadecimal or oktadecimal floating point values allowed&quot;));
+					}
+					digit += '.';
+					++col;
+					while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())){ // read decimal digits beyond the dot
+						digit += reader.GetNext();
+						++col;
+					}
+				}
+			}
+			
+			if (!reader.Eos() &amp;&amp; Char.ToUpper(reader.Peek()) == 'E') { // read exponent
+				isdouble = true;
+				digit +=  reader.GetNext();
+				++col;
+				if (!reader.Eos() &amp;&amp; (reader.Peek() == '-' || reader.Peek() == '+')) {
+					digit += reader.GetNext();
+					++col;
+				}
+				while (!reader.Eos() &amp;&amp; Char.IsDigit(reader.Peek())) { // read exponent value
+					digit += reader.GetNext();
+					++col;
+				}
+			}
+			
+			if (!reader.Eos()) {
+				if (Char.ToUpper(reader.Peek()) == 'R' || Char.ToUpper(reader.Peek()) == '#') { // double type suffix (obsolete, double is default)
+					reader.GetNext();
+					++col;
+					isdouble = true;
+				} else if (Char.ToUpper(reader.Peek()) == 'D' || Char.ToUpper(reader.Peek()) == '@') { // decimal value
+					reader.GetNext();
+					++col;
+					isdecimal = true;
+				} else if (Char.ToUpper(reader.Peek()) == 'F' || Char.ToUpper(reader.Peek()) == '!') { // decimal value
+					reader.GetNext();
+					++col;
+					issingle = true;
+				}
+			}
+			
+			if (issingle) {
+				NumberFormatInfo mi = new NumberFormatInfo();
+				mi.CurrencyDecimalSeparator = &quot;.&quot;;
+				return new Token(Tokens.LiteralSingle, x, y, sb.ToString(), Single.Parse(digit, mi));
+			}
+			if (isdecimal) {
+				NumberFormatInfo mi = new NumberFormatInfo();
+				mi.CurrencyDecimalSeparator = &quot;.&quot;;
+				return new Token(Tokens.LiteralDecimal, x, y, sb.ToString(), Decimal.Parse(digit, mi));
+			}
+			if (isdouble) {
+				NumberFormatInfo mi = new NumberFormatInfo();
+				mi.CurrencyDecimalSeparator = &quot;.&quot;;
+				return new Token(Tokens.LiteralDouble, x, y, sb.ToString(), Double.Parse(digit, mi));
+			}
+			try {
+				return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+			} catch (Exception) {
+				try {
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+				} catch (Exception) {
+					errors.Error(line, col, String.Format(&quot;{0} is not a parseable number (too long?)&quot;, sb.ToString()));
+					// fallback, when nothing helps :)
+					return new Token(Tokens.LiteralInteger, x, y, sb.ToString(), 0);
+				}
+			}
+		}
+		
+		void ReadPreprocessorDirective()
+		{
+			Point start = new Point(col - 1, line);
+			string directive = ReadIdent('#');
+			string argument  = ReadToEOL();
+			this.specialTracker.AddPreProcessingDirective(directive, argument.Trim(), start, new Point(start.X + directive.Length + argument.Length, start.Y));
+		}
+		
+		string ReadToEOL()
+		{
+			StringBuilder sb = new StringBuilder();
+			if (!reader.Eos()) {
+				char ch = reader.GetNext();
+				while (!reader.Eos()) {
+					if (ch == '\r') {
+						if (reader.Peek() == '\n') {
+							ch = reader.GetNext();
+						}
+					}
+					if (ch == '\n') {
+						++line;
+						col = 1;
+						return sb.ToString();
+					} else {
+						sb.Append(ch);
+					}
+					ch = reader.GetNext();
+					++col;
+				}
+			}
+			return sb.ToString();
+		}
+		
+		string ReadDate()
+		{
+			char ch = '\0';
+			StringBuilder sb = new StringBuilder();
+			while (!reader.Eos()) {
+				ch = reader.GetNext();
+				++col;
+				if (ch == '#') {
+					break;
+				} else if (ch == '\n') {
+					errors.Error(line, col, String.Format(&quot;No return allowed inside Date literal&quot;));
+				} else {
+					sb.Append(ch);
+				}
+			}
+			if (ch != '#') {
+				errors.Error(line, col, String.Format(&quot;End of File reached before Date literal terminated&quot;));
+			}
+			return sb.ToString();
+		}
+		
+		string ReadString()
+		{
+			char ch = '\0';
+			StringBuilder s = new StringBuilder();
+			while (!reader.Eos()) {
+				ch = reader.GetNext();
+				++col;
+				if (ch == '&quot;') {
+					if (!reader.Eos() &amp;&amp; reader.Peek() == '&quot;') {
+						s.Append('&quot;');
+						reader.GetNext();
+						++col;
+					} else {
+						break;
+					}
+				} else if (ch == '\n') {
+					errors.Error(line, col, String.Format(&quot;No return allowed inside String literal&quot;));
+				} else {
+					s.Append(ch);
+				}
+			}
+			if (ch != '&quot;') {
+				errors.Error(line, col, String.Format(&quot;End of File reached before String terminated &quot;));
+			}
+			return s.ToString();
+		}
+		
+		protected bool HandleLineEnd(char ch)
+		{
+			if (WasLineEnd(ch)) {
+				++line;
+				col = 1;
+				return true;
+			}
+			return false;
+		}
+		
+		protected bool WasLineEnd(char ch)
+		{
+			// Handle MS-DOS or MacOS line ends.
+			if (ch == '\r') {
+				if (reader.Peek() == '\n') { // MS-DOS line end '\r\n'
+					ch = (char)reader.GetNext();
+				} else { // assume MacOS line end which is '\r'
+					ch = '\n';
+				}
+			}
+			return ch == '\n';
+		}
+		
+		void ReadComment()
+		{
+			StringBuilder curWord = new StringBuilder();
+			StringBuilder comment = new StringBuilder();
+			
+			int nextChar;
+			while ((nextChar = reader.GetNext()) != -1) {
+				char ch = (char)nextChar;
+				comment.Append(ch);
+				++col;
+				if (HandleLineEnd(ch) || nextChar == 0) {
+					specialTracker.StartComment(CommentType.SingleLine, new Point(col, line));
+					specialTracker.AddString(comment.ToString());
+					specialTracker.FinishComment();
+					return;
+				}
+				
+				if (Char.IsLetter(ch)) {
+					curWord.Append(ch);
+				} else {
+					string tag = curWord.ToString();
+					curWord = new StringBuilder();
+					if (specialCommentHash != null &amp;&amp; specialCommentHash[tag] != null) {
+						Point p = new Point(col, line);
+						string commentStr = ReadToEOL();
+						tagComments.Add(new TagComment(tag, commentStr, p));
+						return;
+					}
+				}
+			}
+		}
+		
+		Token ReadOperator(char ch)
+		{
+			int x = col;
+			int y = line;
+			switch(ch) {
+				case '+':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.PlusAssign, x, y, &quot;+=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Plus, x, y, &quot;+&quot;);
+				case '-':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.MinusAssign, x, y, &quot;-=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Minus, x, y, &quot;-&quot;);
+				case '*':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.TimesAssign, x, y, &quot;*=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Times, x, y, &quot;*&quot;);
+				case '/':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.DivAssign, x, y, &quot;/=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Div, x, y, &quot;/&quot;);
+				case '\\':
+					switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.DivIntegerAssign, x, y, &quot;\\=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					return new Token(Tokens.DivInteger, x, y, &quot;\\&quot;);
+				case '&amp;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.ConcatStringAssign, x, y, &quot;&amp;=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.ConcatString, x, y, &quot;&amp;&quot;);
+				case '^':
+					switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.PowerAssign, x, y, &quot;^=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					return new Token(Tokens.Power, x, y, &quot;^&quot;);
+				case ':':
+					return new Token(Tokens.Colon, x, y, &quot;:&quot;);
+				case '=':
+					return new Token(Tokens.Assign, x, y, &quot;=&quot;);
+				case '&lt;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.LessEqual, x, y, &quot;&lt;=&quot;);
+							case '&gt;':
+								++col;
+								return new Token(Tokens.NotEqual, x, y, &quot;&lt;&gt;&quot;);
+							case '&lt;':
+								if (!reader.Eos()) {
+									switch (reader.GetNext()) {
+										case '=':
+											col += 2;
+											return new Token(Tokens.ShiftLeftAssign, x, y, &quot;&lt;&lt;=&quot;);
+										default:
+											++col;
+											reader.UnGet();
+											break;
+									}
+								}
+								return new Token(Tokens.ShiftLeft, x, y, &quot;&lt;&lt;&quot;);
+							default:
+								reader.UnGet();
+								return new Token(Tokens.LessThan, x, y, &quot;&lt;&quot;);
+						}
+					}
+					return new Token(Tokens.LessThan, x, y, &quot;&lt;&quot;);
+				case '&gt;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.GreaterEqual, x, y, &quot;&gt;=&quot;);
+							case '&gt;':
+								if (!reader.Eos()) {
+									switch (reader.GetNext()) {
+										case '=':
+											col += 2;
+											return new Token(Tokens.ShiftRightAssign, x, y, &quot;&gt;&gt;=&quot;);
+										default:
+											++col;
+											reader.UnGet();
+											break;
+									}
+								}
+								return new Token(Tokens.ShiftRight, x, y, &quot;&gt;&gt;&quot;);
+							default:
+								reader.UnGet();
+								return new Token(Tokens.GreaterThan, x, y, &quot;&gt;&quot;);
+						}
+					}
+					return new Token(Tokens.GreaterThan, x, y, &quot;&lt;=&quot;);
+				case ',':
+					return new Token(Tokens.Comma, x, y, &quot;,&quot;);
+				case '.':
+					if (Char.IsDigit(reader.Peek())) {
+						 reader.UnGet();
+						 --col;
+						 return ReadDigit('0', col);
+					}
+					return new Token(Tokens.Dot, x, y, &quot;.&quot;);
+				case '(':
+					return new Token(Tokens.OpenParenthesis, x, y, &quot;(&quot;);
+				case ')':
+					return new Token(Tokens.CloseParenthesis, x, y, &quot;)&quot;);
+				case '{':
+					return new Token(Tokens.OpenCurlyBrace, x, y, &quot;{&quot;);
+				case '}':
+					return new Token(Tokens.CloseCurlyBrace, x, y, &quot;}&quot;);
+				case '[':
+					return new Token(Tokens.OpenSquareBracket, x, y, &quot;[&quot;);
+				case ']':
+					return new Token(Tokens.CloseSquareBracket, x, y, &quot;]&quot;);
+			}
+			return null;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,53 +1,53 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class FileReader : IReader
-	{
-		string file = null;
-		int    ptr  = 0;
-		
-		public FileReader(string filename)
-		{
-			StreamReader sreader = File.OpenText(filename);
-			file = sreader.ReadToEnd();
-			sreader.Close();
-		}
-		
-		public char GetNext()
-		{
-			if (Eos()) {
-				return '\0';
-//				throw new ParserException(&quot;warning : FileReader.GetNext : Read char over eos.&quot;, 0, 0);
-			}
-			return file[ptr++];
-		}
-		
-		public char Peek()
-		{
-			if (Eos()) {
-				return '\0';
-//				throw new ParserException(&quot;warning : FileReader.Peek : Read char over eos.&quot;, 0, 0);
-			}
-			return file[ptr];
-		}
-		
-		public void UnGet()
-		{
-			ptr = Math.Max(0, ptr -1);
-		}
-		
-		public bool Eos()
-		{
-			return ptr &gt;= file.Length;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class FileReader : IReader
+	{
+		string file = null;
+		int    ptr  = 0;
+		
+		public FileReader(string filename)
+		{
+			StreamReader sreader = File.OpenText(filename);
+			file = sreader.ReadToEnd();
+			sreader.Close();
+		}
+		
+		public char GetNext()
+		{
+			if (Eos()) {
+				return '\0';
+//				throw new ParserException(&quot;warning : FileReader.GetNext : Read char over eos.&quot;, 0, 0);
+			}
+			return file[ptr++];
+		}
+		
+		public char Peek()
+		{
+			if (Eos()) {
+				return '\0';
+//				throw new ParserException(&quot;warning : FileReader.Peek : Read char over eos.&quot;, 0, 0);
+			}
+			return file[ptr];
+		}
+		
+		public void UnGet()
+		{
+			ptr = Math.Max(0, ptr -1);
+		}
+		
+		public bool Eos()
+		{
+			return ptr &gt;= file.Length;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/FileReader.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,19 +1,19 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public interface IReader
-	{
-		char GetNext();
-		char Peek();
-		
-		void UnGet();
-		
-		bool Eos();
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public interface IReader
+	{
+		char GetNext();
+		char Peek();
+		
+		void UnGet();
+		
+		bool Eos();
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/IReader.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,49 +1,49 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class StringReader : IReader
-	{
-		string data = null;
-		int    ptr  = 0;
-		
-		public StringReader(string data)
-		{
-			this.data = data;
-		}
-		
-		public char GetNext()
-		{
-			if (Eos()) {
-				return '\n';
-			}
-			return data[ptr++];
-		}
-		
-		public char Peek()
-		{
-			if (Eos()) {
-				return '\n';
-			}
-			return data[ptr];
-		}
-		
-		public void UnGet()
-		{
-			ptr = Math.Max(0, ptr -1);
-		}
-		
-		public bool Eos()
-		{
-			return ptr &gt;= data.Length;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class StringReader : IReader
+	{
+		string data = null;
+		int    ptr  = 0;
+		
+		public StringReader(string data)
+		{
+			this.data = data;
+		}
+		
+		public char GetNext()
+		{
+			if (Eos()) {
+				return '\n';
+			}
+			return data[ptr++];
+		}
+		
+		public char Peek()
+		{
+			if (Eos()) {
+				return '\n';
+			}
+			return data[ptr];
+		}
+		
+		public void UnGet()
+		{
+			ptr = Math.Max(0, ptr -1);
+		}
+		
+		public bool Eos()
+		{
+			return ptr &gt;= data.Length;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Reader/StringReader.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,49 +1,49 @@
-using System;
-using System.Text;
-using System.CodeDom;
-using System.Collections;
-using System.Drawing;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class Comment
-	{
-		CommentType   commentType;
-		string        comment;
-		Point         startPosition;
-		
-		public CommentType CommentType {
-			get {
-				return commentType;
-			}
-			set {
-				commentType = value;
-			}
-		}
-		
-		public string CommentText {
-			get {
-				return comment;
-			}
-			set {
-				comment = value;
-			}
-		}
-		
-		public Point StartPosition {
-			get {
-				return startPosition;
-			}
-			set {
-				startPosition = value;
-			}
-		}
-		
-		public Comment(CommentType commentType, string comment, Point startPosition)
-		{
-			this.commentType   = commentType;
-			this.comment       = comment;
-			this.startPosition = startPosition;
-		}
-	}
-}
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+using System.Drawing;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class Comment
+	{
+		CommentType   commentType;
+		string        comment;
+		Point         startPosition;
+		
+		public CommentType CommentType {
+			get {
+				return commentType;
+			}
+			set {
+				commentType = value;
+			}
+		}
+		
+		public string CommentText {
+			get {
+				return comment;
+			}
+			set {
+				comment = value;
+			}
+		}
+		
+		public Point StartPosition {
+			get {
+				return startPosition;
+			}
+			set {
+				startPosition = value;
+			}
+		}
+		
+		public Comment(CommentType commentType, string comment, Point startPosition)
+		{
+			this.commentType   = commentType;
+			this.comment       = comment;
+			this.startPosition = startPosition;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/Comment.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,13 +1,13 @@
-using System;
-using System.Text;
-using System.CodeDom;
-using System.Collections;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public enum CommentType
-	{
-		REM,
-		SingleLine
-	}
-}
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public enum CommentType
+	{
+		REM,
+		SingleLine
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/CommentType.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,14 +1,14 @@
-using System;
-using System.Text;
-using System.CodeDom;
-using System.Collections;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class NewLine
-	{
-		public NewLine()
-		{
-		}
-	}
-}
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class NewLine
+	{
+		public NewLine()
+		{
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/NewLine.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,61 +1,61 @@
-using System;
-using System.Drawing;
-using System.Text;
-using System.CodeDom;
-using System.Collections;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class PreProcessingDirective
-	{
-		string cmd;
-		string arg;
-		Point  start;
-		Point  end;
-		
-		public Point Start {
-			get {
-				return start;
-			}
-			set {
-				start = value;
-			}
-		}
-		
-		public Point End {
-			get {
-				return end;
-			}
-			set {
-				end = value;
-			}
-		}
-		
-		public string Cmd {
-			get {
-				return cmd;
-			}
-			set {
-				cmd = value;
-			}
-		}
-		
-		public string Arg {
-			get {
-				return arg;
-			}
-			set {
-				arg = value;
-			}
-		}
-		
-		public PreProcessingDirective(string cmd, string arg, Point start, Point end)
-		{
-			this.cmd = cmd;
-			this.arg = arg;
-			this.start = start;
-			this.end = end;
-		}
-	}
-}
-
+using System;
+using System.Drawing;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class PreProcessingDirective
+	{
+		string cmd;
+		string arg;
+		Point  start;
+		Point  end;
+		
+		public Point Start {
+			get {
+				return start;
+			}
+			set {
+				start = value;
+			}
+		}
+		
+		public Point End {
+			get {
+				return end;
+			}
+			set {
+				end = value;
+			}
+		}
+		
+		public string Cmd {
+			get {
+				return cmd;
+			}
+			set {
+				cmd = value;
+			}
+		}
+		
+		public string Arg {
+			get {
+				return arg;
+			}
+			set {
+				arg = value;
+			}
+		}
+		
+		public PreProcessingDirective(string cmd, string arg, Point start, Point end)
+		{
+			this.cmd = cmd;
+			this.arg = arg;
+			this.start = start;
+			this.end = end;
+		}
+	}
+}
+


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/PreProcessingDirective.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,79 +1,79 @@
-using System;
-using System.Text;
-using System.CodeDom;
-using System.Collections;
-using System.Drawing;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class SpecialTracker
-	{
-		ArrayList currentSpecials = new ArrayList();
-		ArrayList tempComments = new ArrayList();
-		
-		CommentType currentCommentType;
-		StringBuilder sb = new StringBuilder();
-		Point startPosition;
-		
-		public ArrayList CurrentSpecials
-		{
-			get {
-				return currentSpecials;
-			}
-		}
-		
-		public void InformToken(int kind)
-		{
-			currentSpecials.Add(kind);
-		}
-		
-		public ArrayList RetrieveSpecials()
-		{
-			ArrayList tmp = currentSpecials;
-			currentSpecials = new ArrayList();
-			return tmp;
-		}
-		
-		public ArrayList RetreiveComments()
-		{
-			ArrayList tmp = tempComments;
-			tempComments = new ArrayList();
-			return tmp;
-		}
-		
-		public void AddEndOfLine()
-		{
-			currentSpecials.Add(new NewLine());
-		}
-		
-		public void AddPreProcessingDirective(string cmd, string arg, Point start, Point end)
-		{
-			currentSpecials.Add(new PreProcessingDirective(cmd, arg, start, end));
-		}
-		
-		// used for comment tracking
-		public void StartComment(CommentType commentType, Point startPosition)
-		{
-			this.currentCommentType = commentType;
-			this.startPosition      = startPosition;
-			this.sb.Length          = 0; 
-		}
-		
-		public void AddChar(char c)
-		{
-			sb.Append(c);
-		}
-		
-		public void AddString(string s)
-		{
-			sb.Append(s);
-		}
-		
-		public void FinishComment()
-		{
-			Comment comment = new Comment(currentCommentType, sb.ToString(), startPosition);
-			currentSpecials.Add(comment);
-			tempComments.Add(comment);
-		}
-	}
-}
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+using System.Drawing;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class SpecialTracker
+	{
+		ArrayList currentSpecials = new ArrayList();
+		ArrayList tempComments = new ArrayList();
+		
+		CommentType currentCommentType;
+		StringBuilder sb = new StringBuilder();
+		Point startPosition;
+		
+		public ArrayList CurrentSpecials
+		{
+			get {
+				return currentSpecials;
+			}
+		}
+		
+		public void InformToken(int kind)
+		{
+			currentSpecials.Add(kind);
+		}
+		
+		public ArrayList RetrieveSpecials()
+		{
+			ArrayList tmp = currentSpecials;
+			currentSpecials = new ArrayList();
+			return tmp;
+		}
+		
+		public ArrayList RetreiveComments()
+		{
+			ArrayList tmp = tempComments;
+			tempComments = new ArrayList();
+			return tmp;
+		}
+		
+		public void AddEndOfLine()
+		{
+			currentSpecials.Add(new NewLine());
+		}
+		
+		public void AddPreProcessingDirective(string cmd, string arg, Point start, Point end)
+		{
+			currentSpecials.Add(new PreProcessingDirective(cmd, arg, start, end));
+		}
+		
+		// used for comment tracking
+		public void StartComment(CommentType commentType, Point startPosition)
+		{
+			this.currentCommentType = commentType;
+			this.startPosition      = startPosition;
+			this.sb.Length          = 0; 
+		}
+		
+		public void AddChar(char c)
+		{
+			sb.Append(c);
+		}
+		
+		public void AddString(string s)
+		{
+			sb.Append(s);
+		}
+		
+		public void FinishComment()
+		{
+			Comment comment = new Comment(currentCommentType, sb.ToString(), startPosition);
+			currentSpecials.Add(comment);
+			tempComments.Add(comment);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/SpecialTracker.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,30 +1,30 @@
-using System;
-using System.Text;
-using System.CodeDom;
-using System.Collections;
-using System.Drawing;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	/// &lt;summary&gt;
-	/// Description of TagComment.	
-	/// &lt;/summary&gt;
-	public class TagComment : Comment
-	{
-		string tag;
-		
-		public string Tag {
-			get {
-				return tag;
-			}
-			set {
-				tag = value;
-			}
-		}
-		
-		public TagComment(string tag, string comment, Point startPosition) : base(CommentType.SingleLine, comment, startPosition)
-		{
-			this.tag = tag;
-		}
-	}
-}
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+using System.Drawing;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	/// &lt;summary&gt;
+	/// Description of TagComment.	
+	/// &lt;/summary&gt;
+	public class TagComment : Comment
+	{
+		string tag;
+		
+		public string Tag {
+			get {
+				return tag;
+			}
+			set {
+				tag = value;
+			}
+		}
+		
+		public TagComment(string tag, string comment, Point startPosition) : base(CommentType.SingleLine, comment, startPosition)
+		{
+			this.tag = tag;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Specials/TagComment.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,41 +1,41 @@
-/*using System;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-class MainClass
-{
-	public static void Main (string[] args) {
-		
-		string fileName = args[0];
-		
-		Console.WriteLine(&quot;Parsing source file {0}&quot;, fileName);
-		IReader reader = new FileReader(fileName);
-		Lexer lexer = new Lexer(reader);
-		
-//		while(true)
-//		{
-//			Token t = lexer.NextToken();
-//			if(t.kind == Tokens.EOF) break;
-//			
-//			System.Console.WriteLine(t.val + &quot;\t&quot; + t.kind);
-//		}
-		
-		Parser p = new Parser();
-		p.Parse(lexer);
-		if(p.Errors.count == 0) {
-//			p.compilationUnit.AcceptVisitor(new DebugVisitor(), null);
-		}
-		
-		System.Console.WriteLine(&quot;=======================&quot;);
-		if (p.Errors.count == 1)
-			Console.WriteLine(&quot;1 error dectected&quot;);
-		else {
-			Console.WriteLine(&quot;{0} errors dectected&quot;, p.Errors.count);
-		}
-		
-		if(p.Errors.count != 0) {
-			System.Console.WriteLine(p.Errors.ErrorOutput);
-		}
-		System.Console.WriteLine(&quot;=======================&quot;);
-	}
-}*/
+/*using System;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+class MainClass
+{
+	public static void Main (string[] args) {
+		
+		string fileName = args[0];
+		
+		Console.WriteLine(&quot;Parsing source file {0}&quot;, fileName);
+		IReader reader = new FileReader(fileName);
+		Lexer lexer = new Lexer(reader);
+		
+//		while(true)
+//		{
+//			Token t = lexer.NextToken();
+//			if(t.kind == Tokens.EOF) break;
+//			
+//			System.Console.WriteLine(t.val + &quot;\t&quot; + t.kind);
+//		}
+		
+		Parser p = new Parser();
+		p.Parse(lexer);
+		if(p.Errors.count == 0) {
+//			p.compilationUnit.AcceptVisitor(new DebugVisitor(), null);
+		}
+		
+		System.Console.WriteLine(&quot;=======================&quot;);
+		if (p.Errors.count == 1)
+			Console.WriteLine(&quot;1 error dectected&quot;);
+		else {
+			Console.WriteLine(&quot;{0} errors dectected&quot;, p.Errors.count);
+		}
+		
+		if(p.Errors.count != 0) {
+			System.Console.WriteLine(p.Errors.ErrorOutput);
+		}
+		System.Console.WriteLine(&quot;=======================&quot;);
+	}
+}*/


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Main.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,678 +1,678 @@
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public abstract class AbstractASTVisitor : IASTVisitor
-	{
-		protected Stack blockStack = new Stack();
-		
-		public BlockStatement CurrentBlock {
-			get {
-				if (blockStack.Count == 0) {
-					return null;
-				}
-				return (BlockStatement)blockStack.Peek();
-			}
-		}
-		
-		public virtual object Visit(INode node, object data)
-		{
-			Console.WriteLine(&quot;Warning, INode visited!&quot;);
-			Console.WriteLine(&quot;Type is &quot; + node.GetType());
-			Console.WriteLine(&quot;Visitor is &quot; + this.GetType());
-			return node.AcceptChildren(this, data);
-		}
-		
-		public virtual object Visit(CompilationUnit compilationUnit, object data)
-		{
-			if (compilationUnit == null) {
-				return data;
-			}
-			return compilationUnit.AcceptChildren(this, data);
-		}
-		
-		public virtual object Visit(NamespaceDeclaration namespaceDeclaration, object data)
-		{
-			return namespaceDeclaration.AcceptChildren(this, data);
-		}
-		
-		public virtual object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(OptionStrictDeclaration optionStrictDeclaration, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(OptionCompareDeclaration optionCompareDeclaration, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(ImportsStatement importsStatement, object data)
-		{
-			object ret = data;
-			foreach (INode n in importsStatement.ImportClauses) {
-				ret = n.AcceptVisitor(this, data);
-			}
-			return ret;
-		}
-		
-		public virtual object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(ImportsDeclaration importsDeclaration, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(AttributeSection attributeSection, object data)
-		{
-			object ret = data;
-			foreach (ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute a in attributeSection.Attributes) {
-				ret = a.AcceptVisitor(this, data);
-			}
-			return ret;
-		}
-		
-		public virtual object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data)
-		{
-			object ret = data;
-			foreach (Expression e in attribute.PositionalArguments) {
-				ret = e.AcceptVisitor(this, data);
-			}
-			foreach (NamedArgumentExpression n in attribute.NamedArguments) {
-				ret = n.AcceptVisitor(this, data);
-			}
-			return ret;
-		}
-		
-		public virtual object Visit(NamedArgumentExpression namedArgumentExpression, object data)
-		{
-			return namedArgumentExpression.Expression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(TypeReference typeReference, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(TypeDeclaration typeDeclaration, object data)
-		{
-			foreach (AttributeSection a in typeDeclaration.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			return typeDeclaration.AcceptChildren(this, data);
-		}
-		
-		public virtual object Visit(DelegateDeclaration delegateDeclaration, object data)
-		{
-			foreach (AttributeSection a in delegateDeclaration.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			if (delegateDeclaration.Parameters != null) {
-				foreach (ParameterDeclarationExpression p in delegateDeclaration.Parameters) {
-					p.AcceptVisitor(this, data);
-				}
-			}
-			if (delegateDeclaration.ReturnType == null) {
-				return data;
-			}
-			return delegateDeclaration.ReturnType.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(FieldDeclaration fieldDeclaration, object data)
-		{
-			foreach (AttributeSection a in fieldDeclaration.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			if (fieldDeclaration.Fields != null) {
-				foreach (VariableDeclaration v in fieldDeclaration.Fields) {
-					v.AcceptVisitor(this, data);
-				}
-			}
-			if (fieldDeclaration.TypeReference == null) {
-				return data;
-			}
-			return fieldDeclaration.TypeReference.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(VariableDeclaration variableDeclaration, object data)
-		{
-			if (variableDeclaration.Initializer == null) {
-				return data;
-			}
-			return variableDeclaration.Initializer.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
-		{
-			object ret = data;
-			foreach (AttributeSection a in parameterDeclarationExpression.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			ret = parameterDeclarationExpression.TypeReference.AcceptVisitor(this, data);
-			if (parameterDeclarationExpression.DefaultValue != null) {
-				ret = parameterDeclarationExpression.DefaultValue.AcceptVisitor(this, data);
-			}
-			return ret;
-		}
-		
-		public virtual object Visit(ConstructorDeclaration constructorDeclaration, object data)
-		{
-			blockStack.Push(constructorDeclaration.Body);
-			foreach (AttributeSection a in constructorDeclaration.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			if (constructorDeclaration.Parameters != null) {
-				foreach (ParameterDeclarationExpression p in constructorDeclaration.Parameters) {
-					p.AcceptVisitor(this, data);
-				}
-			}
-			object ret = null;
-			if (constructorDeclaration.Body != null) {
-				ret = constructorDeclaration.Body.AcceptChildren(this, data);
-			}
-			blockStack.Pop();
-			return ret;
-		}
-		
-		public virtual object Visit(MethodDeclaration methodDeclaration, object data)
-		{
-			blockStack.Push(methodDeclaration.Body);
-			foreach (AttributeSection a in methodDeclaration.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			if (methodDeclaration.TypeReference != null) {
-				methodDeclaration.TypeReference.AcceptVisitor(this, data);
-			}
-			
-			if (methodDeclaration.Parameters != null) {
-				foreach (ParameterDeclarationExpression p in methodDeclaration.Parameters) {
-					p.AcceptVisitor(this, data);
-				}
-			}
-			
-			if (methodDeclaration.HandlesClause != null) {
-				methodDeclaration.HandlesClause.AcceptVisitor(this, data);
-			}
-			if (methodDeclaration.ImplementsClause != null) {
-				methodDeclaration.ImplementsClause.AcceptVisitor(this, data);
-			}
-			object ret = null;
-			if (methodDeclaration.Body != null) {
-				methodDeclaration.Body.AcceptChildren(this, data);
-			}
-			blockStack.Pop();
-			return ret;
-		}
-		
-		public virtual object Visit(DeclareDeclaration declareDeclaration, object data)
-		{
-			if (declareDeclaration != null) {
-				if (declareDeclaration.Attributes != null) {
-					foreach (AttributeSection a in declareDeclaration.Attributes) {
-						a.AcceptVisitor(this, data);
-					}
-				}
-				
-				if (declareDeclaration.ReturnType != null) {
-					declareDeclaration.ReturnType.AcceptVisitor(this, data);
-				}
-				
-				if (declareDeclaration.Parameters != null) {
-					foreach (ParameterDeclarationExpression p in declareDeclaration.Parameters) {
-						p.AcceptVisitor(this, data);
-					}
-				}
-			}
-			return data;
-		}
-		
-		public virtual object Visit(PropertyDeclaration propertyDeclaration, object data)
-		{
-			foreach (AttributeSection a in propertyDeclaration.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			propertyDeclaration.TypeReference.AcceptVisitor(this, data);
-			if (propertyDeclaration.Parameters != null) {
-				foreach (ParameterDeclarationExpression p in propertyDeclaration.Parameters) {
-					p.AcceptVisitor(this, data);
-				}
-			}
-			if (propertyDeclaration.ImplementsClause != null) {
-				propertyDeclaration.ImplementsClause.AcceptVisitor(this, data);
-			}
-			if (propertyDeclaration.HasGetRegion) {
-				propertyDeclaration.GetRegion.AcceptVisitor(this, data);
-			}
-			if (propertyDeclaration.HasSetRegion) {
-				propertyDeclaration.SetRegion.AcceptVisitor(this, data);
-			}
-			return data;
-		}
-		
-		public virtual object Visit(PropertyGetRegion propertyGetRegion, object data)
-		{
-			blockStack.Push(propertyGetRegion.Block);
-			foreach (AttributeSection a in propertyGetRegion.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			object ret = null;
-			if (propertyGetRegion.Block != null) {
-				ret = propertyGetRegion.Block.AcceptChildren(this, data);
-			}
-			blockStack.Pop();
-			return ret;
-		}
-		
-		public virtual object Visit(PropertySetRegion propertySetRegion, object data)
-		{
-			blockStack.Push(propertySetRegion.Block);
-			foreach (AttributeSection a in propertySetRegion.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			object ret = null;
-			if (propertySetRegion.Block != null) {
-				ret = propertySetRegion.Block.AcceptChildren(this, data);
-			}
-			blockStack.Pop();
-			return ret;
-		}
-		
-		public virtual object Visit(EventDeclaration eventDeclaration, object data)
-		{
-			foreach (AttributeSection a in eventDeclaration.Attributes) {
-				a.AcceptVisitor(this, data);
-			}
-			eventDeclaration.TypeReference.AcceptVisitor(this, data);
-			if (eventDeclaration.Parameters != null) {
-				foreach (ParameterDeclarationExpression p in eventDeclaration.Parameters) {
-					p.AcceptVisitor(this, data);
-				}
-			}
-			if (eventDeclaration.ImplementsClause != null) {
-				eventDeclaration.ImplementsClause.AcceptVisitor(this, data);
-			}
-			return data;
-		}
-		
-		public virtual object Visit(BlockStatement blockStatement, object data)
-		{
-			if (blockStatement == null) {
-				return null;
-			}
-			blockStack.Push(blockStatement);
-			object ret = blockStatement.AcceptChildren(this, data);
-			blockStack.Pop();
-			return ret;
-		}
-		
-		public virtual object Visit(Statement statement, object data)
-		{
-			Console.WriteLine(&quot;Warning, visited Statement!&quot;);
-			return data;
-		}
-		
-		public virtual object Visit(StatementExpression statementExpression, object data)
-		{
-			if (statementExpression.Expression == null) {
-				return data;
-			}
-			return statementExpression.Expression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
-		{
-			object ret = data;
-			if (localVariableDeclaration.Variables != null) {
-				foreach (VariableDeclaration v in localVariableDeclaration.Variables) {
-					ret = v.AcceptVisitor(this, data);
-				}
-			}
-			return ret;
-		}
-		
-		public virtual object Visit(SimpleIfStatement ifStatement, object data)
-		{
-			object ret = ifStatement.Condition.AcceptVisitor(this, data);
-			if(ifStatement.Statements != null) {
-				foreach (Statement s in ifStatement.Statements) {
-					ret = s.AcceptVisitor(this, data);
-				}
-			}
-			if(ifStatement.ElseStatements != null) {
-				foreach (Statement s in ifStatement.ElseStatements) {
-					ret = s.AcceptVisitor(this, data);
-				}
-			}
-			return ret;
-		}
-		
-		public virtual object Visit(IfStatement ifStatement, object data)
-		{
-			object ret = ifStatement.Condition.AcceptVisitor(this, data);
-			if(ifStatement.ElseIfStatements != null) {
-				foreach (Statement s in ifStatement.ElseIfStatements) {
-					ret = s.AcceptVisitor(this, data);
-				}
-			}
-			if (ifStatement.EmbeddedElseStatement != null) {
-				ret = ifStatement.EmbeddedElseStatement.AcceptVisitor(this, data);
-			}
-			return ret;
-		}
-		
-		public virtual object Visit(LabelStatement labelStatement, object data)
-		{
-			if (labelStatement.EmbeddedStatement == null) {
-				return null;
-			}
-			return labelStatement.EmbeddedStatement.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(GoToStatement goToStatement, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(SelectStatement selectStatement, object data)
-		{
-			selectStatement.SelectExpression.AcceptVisitor(this, data);
-			if (selectStatement.SelectSections != null) {
-				foreach (SelectSection s in selectStatement.SelectSections) {
-					s.AcceptVisitor(this, data);
-				}
-			}
-			return data;
-		}
-		
-		public virtual object Visit(SelectSection selectSection, object data)
-		{
-			if (selectSection.CaseClauses != null) {
-				foreach (CaseClause c in selectSection.CaseClauses) {
-					c.AcceptVisitor(this, data);
-				}
-			}
-			return data;
-		}
-		
-		public virtual object Visit(CaseClause caseClause, object data)
-		{
-			caseClause.ComparisonExpression.AcceptVisitor(this, data);
-			return caseClause.BoundaryExpression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(ExitStatement exitStatement, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(EndStatement endStatement, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(StopStatement stopStatement, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(ResumeStatement resumeStatement, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(ErrorStatement errorStatement, object data)
-		{
-			return errorStatement.Expression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(OnErrorStatement onErrorStatement, object data)
-		{
-			return onErrorStatement.EmbeddedStatement.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(EraseStatement eraseStatement, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(ReDimStatement reDimStatement, object data)
-		{
-			return data;
-		}
-		
-		public virtual object Visit(AddHandlerStatement addHandlerStatement, object data)
-		{
-			addHandlerStatement.EventExpression.AcceptVisitor(this, data);
-			addHandlerStatement.HandlerExpression.AcceptVisitor(this, data);
-			return data;
-		}
-		
-		public virtual object Visit(RemoveHandlerStatement removeHandlerStatement, object data)
-		{
-			removeHandlerStatement.EventExpression.AcceptVisitor(this, data);
-			removeHandlerStatement.HandlerExpression.AcceptVisitor(this, data);
-			return data;
-		}
-		
-		public virtual object Visit(ReturnStatement returnStatement, object data)
-		{
-			return returnStatement.ReturnExpression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(RaiseEventStatement raiseEventStatement, object data)
-		{
-			if (raiseEventStatement.Parameters != null) {
-				foreach (INode node in raiseEventStatement.Parameters) {
-					node.AcceptVisitor(this, data);
-				}
-			}
-			return data;
-		}
-		
-		public virtual object Visit(WhileStatement whileStatement, object data)
-		{
-			if (whileStatement.EmbeddedStatement == null) {
-				return null;
-			}
-			return whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(WithStatement withStatement, object data)
-		{
-			if (withStatement.WithExpression != null) {
-				withStatement.WithExpression.AcceptVisitor(this, data);
-			}
-			
-			if (withStatement.Body == null) {
-				return null;
-			}
-			return withStatement.Body.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(DoLoopStatement doLoopStatement, object data)
-		{
-			if (doLoopStatement.EmbeddedStatement == null) {
-				return null;
-			}
-			return doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
-		}
-		public virtual object Visit(ForStatement forStatement, object data)
-		{
-			if (forStatement.EmbeddedStatement == null) {
-				return null;
-			}
-			return forStatement.EmbeddedStatement.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(ForeachStatement foreachStatement, object data)
-		{
-			if (foreachStatement.EmbeddedStatement == null) {
-				return null;
-			}
-			return foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
-		}
-		public virtual object Visit(LockStatement lockStatement, object data)
-		{
-			if (lockStatement.EmbeddedStatement == null) {
-				return null;
-			}
-			return lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(TryCatchStatement tryCatchStatement, object data)
-		{
-			if (tryCatchStatement.StatementBlock == null) {
-				return null;
-			}
-			return tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
-		}
-		public virtual object Visit(ThrowStatement throwStatement, object data)
-		{
-			if (throwStatement.ThrowExpression == null) {
-				return null;
-			}
-			return throwStatement.ThrowExpression.AcceptVisitor(this, data);
-		}
-		
-#region Expressions
-		public virtual object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data)
-		{
-			if (fieldReferenceOrInvocationExpression.TargetObject == null) {
-				return null;
-			}
-			return fieldReferenceOrInvocationExpression.TargetObject.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(PrimitiveExpression primitiveExpression, object data)
-		{
-			// nothing to visit
-			return data;
-		}
-		
-		public virtual object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
-		{
-			// visit but can't give back 2 values
-			binaryOperatorExpression.Left.AcceptVisitor(this, data);
-			binaryOperatorExpression.Right.AcceptVisitor(this, data);
-			
-			return data;
-		}
-		public virtual object Visit(ParenthesizedExpression parenthesizedExpression, object data)
-		{
-			return parenthesizedExpression.Expression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(InvocationExpression invocationExpression, object data)
-		{
-			if (invocationExpression.TargetObject == null) {
-				return data;
-			}
-			return invocationExpression.TargetObject.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(IdentifierExpression identifierExpression, object data)
-		{
-			// nothing to visit
-			return data;
-		}
-		
-		public virtual object Visit(TypeReferenceExpression typeReferenceExpression, object data)
-		{
-			// nothing to visit
-			return data;
-		}
-		
-		public virtual object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
-		{
-			return unaryOperatorExpression.Expression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(AssignmentExpression assignmentExpression, object data)
-		{
-			// visit but can't give back 2 values
-			assignmentExpression.Left.AcceptVisitor(this, data);
-			assignmentExpression.Right.AcceptVisitor(this, data);
-			
-			return data;
-		}
-		
-		public virtual object Visit(CastExpression castExpression, object data)
-		{
-			return castExpression.Expression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(ThisReferenceExpression thisReferenceExpression, object data)
-		{
-			// nothing to visit
-			return data;
-		}
-		
-		public virtual object Visit(BaseReferenceExpression baseReferenceExpression, object data)
-		{
-			// nothing to visit
-			return data;
-		}
-		
-		public virtual object Visit(ObjectCreateExpression objectCreateExpression, object data)
-		{
-			// nothing to visit
-			return data;
-		}
-		
-		public virtual object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
-		{
-			if (arrayInitializerExpression.CreateExpressions != null) {
-				foreach (INode node in arrayInitializerExpression.CreateExpressions) {
-					node.AcceptVisitor(this, data);
-				}
-			}
-			
-			return data;
-		}
-		
-		public virtual object Visit(GetTypeExpression getTypeExpression, object data)
-		{
-			// nothing to visit
-			return data;
-		}
-		
-		public virtual object Visit(ClassReferenceExpression classReferenceExpression, object data)
-		{
-			// nothing to visit
-			return data;
-		}
-		
-		public virtual object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
-		{
-			return loopControlVariableExpression.Expression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(AddressOfExpression addressOfExpression, object data)
-		{
-			return addressOfExpression.Procedure.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(TypeOfExpression typeOfExpression, object data)
-		{
-			return typeOfExpression.Expression.AcceptVisitor(this, data);
-		}
-		
-		public virtual object Visit(ArrayCreateExpression arrayCreateExpression, object data)
-		{
-			if (arrayCreateExpression.ArrayInitializer == null) {
-				return data;
-			}
-			return arrayCreateExpression.ArrayInitializer.AcceptVisitor(this, data);
-		}
-#endregion
-	}
-}
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public abstract class AbstractASTVisitor : IASTVisitor
+	{
+		protected Stack blockStack = new Stack();
+		
+		public BlockStatement CurrentBlock {
+			get {
+				if (blockStack.Count == 0) {
+					return null;
+				}
+				return (BlockStatement)blockStack.Peek();
+			}
+		}
+		
+		public virtual object Visit(INode node, object data)
+		{
+			Console.WriteLine(&quot;Warning, INode visited!&quot;);
+			Console.WriteLine(&quot;Type is &quot; + node.GetType());
+			Console.WriteLine(&quot;Visitor is &quot; + this.GetType());
+			return node.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(CompilationUnit compilationUnit, object data)
+		{
+			if (compilationUnit == null) {
+				return data;
+			}
+			return compilationUnit.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			return namespaceDeclaration.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(OptionStrictDeclaration optionStrictDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(OptionCompareDeclaration optionCompareDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ImportsStatement importsStatement, object data)
+		{
+			object ret = data;
+			foreach (INode n in importsStatement.ImportClauses) {
+				ret = n.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ImportsDeclaration importsDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(AttributeSection attributeSection, object data)
+		{
+			object ret = data;
+			foreach (ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute a in attributeSection.Attributes) {
+				ret = a.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data)
+		{
+			object ret = data;
+			foreach (Expression e in attribute.PositionalArguments) {
+				ret = e.AcceptVisitor(this, data);
+			}
+			foreach (NamedArgumentExpression n in attribute.NamedArguments) {
+				ret = n.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(NamedArgumentExpression namedArgumentExpression, object data)
+		{
+			return namedArgumentExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(TypeReference typeReference, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			foreach (AttributeSection a in typeDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			return typeDeclaration.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+			foreach (AttributeSection a in delegateDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			if (delegateDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in delegateDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			if (delegateDeclaration.ReturnType == null) {
+				return data;
+			}
+			return delegateDeclaration.ReturnType.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			foreach (AttributeSection a in fieldDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			if (fieldDeclaration.Fields != null) {
+				foreach (VariableDeclaration v in fieldDeclaration.Fields) {
+					v.AcceptVisitor(this, data);
+				}
+			}
+			if (fieldDeclaration.TypeReference == null) {
+				return data;
+			}
+			return fieldDeclaration.TypeReference.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			if (variableDeclaration.Initializer == null) {
+				return data;
+			}
+			return variableDeclaration.Initializer.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			object ret = data;
+			foreach (AttributeSection a in parameterDeclarationExpression.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			ret = parameterDeclarationExpression.TypeReference.AcceptVisitor(this, data);
+			if (parameterDeclarationExpression.DefaultValue != null) {
+				ret = parameterDeclarationExpression.DefaultValue.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			blockStack.Push(constructorDeclaration.Body);
+			foreach (AttributeSection a in constructorDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			if (constructorDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in constructorDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			object ret = null;
+			if (constructorDeclaration.Body != null) {
+				ret = constructorDeclaration.Body.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			blockStack.Push(methodDeclaration.Body);
+			foreach (AttributeSection a in methodDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			if (methodDeclaration.TypeReference != null) {
+				methodDeclaration.TypeReference.AcceptVisitor(this, data);
+			}
+			
+			if (methodDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in methodDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			
+			if (methodDeclaration.HandlesClause != null) {
+				methodDeclaration.HandlesClause.AcceptVisitor(this, data);
+			}
+			if (methodDeclaration.ImplementsClause != null) {
+				methodDeclaration.ImplementsClause.AcceptVisitor(this, data);
+			}
+			object ret = null;
+			if (methodDeclaration.Body != null) {
+				methodDeclaration.Body.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(DeclareDeclaration declareDeclaration, object data)
+		{
+			if (declareDeclaration != null) {
+				if (declareDeclaration.Attributes != null) {
+					foreach (AttributeSection a in declareDeclaration.Attributes) {
+						a.AcceptVisitor(this, data);
+					}
+				}
+				
+				if (declareDeclaration.ReturnType != null) {
+					declareDeclaration.ReturnType.AcceptVisitor(this, data);
+				}
+				
+				if (declareDeclaration.Parameters != null) {
+					foreach (ParameterDeclarationExpression p in declareDeclaration.Parameters) {
+						p.AcceptVisitor(this, data);
+					}
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			foreach (AttributeSection a in propertyDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			propertyDeclaration.TypeReference.AcceptVisitor(this, data);
+			if (propertyDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in propertyDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			if (propertyDeclaration.ImplementsClause != null) {
+				propertyDeclaration.ImplementsClause.AcceptVisitor(this, data);
+			}
+			if (propertyDeclaration.HasGetRegion) {
+				propertyDeclaration.GetRegion.AcceptVisitor(this, data);
+			}
+			if (propertyDeclaration.HasSetRegion) {
+				propertyDeclaration.SetRegion.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			blockStack.Push(propertyGetRegion.Block);
+			foreach (AttributeSection a in propertyGetRegion.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			object ret = null;
+			if (propertyGetRegion.Block != null) {
+				ret = propertyGetRegion.Block.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(PropertySetRegion propertySetRegion, object data)
+		{
+			blockStack.Push(propertySetRegion.Block);
+			foreach (AttributeSection a in propertySetRegion.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			object ret = null;
+			if (propertySetRegion.Block != null) {
+				ret = propertySetRegion.Block.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			foreach (AttributeSection a in eventDeclaration.Attributes) {
+				a.AcceptVisitor(this, data);
+			}
+			eventDeclaration.TypeReference.AcceptVisitor(this, data);
+			if (eventDeclaration.Parameters != null) {
+				foreach (ParameterDeclarationExpression p in eventDeclaration.Parameters) {
+					p.AcceptVisitor(this, data);
+				}
+			}
+			if (eventDeclaration.ImplementsClause != null) {
+				eventDeclaration.ImplementsClause.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(BlockStatement blockStatement, object data)
+		{
+			if (blockStatement == null) {
+				return null;
+			}
+			blockStack.Push(blockStatement);
+			object ret = blockStatement.AcceptChildren(this, data);
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(Statement statement, object data)
+		{
+			Console.WriteLine(&quot;Warning, visited Statement!&quot;);
+			return data;
+		}
+		
+		public virtual object Visit(StatementExpression statementExpression, object data)
+		{
+			if (statementExpression.Expression == null) {
+				return data;
+			}
+			return statementExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			object ret = data;
+			if (localVariableDeclaration.Variables != null) {
+				foreach (VariableDeclaration v in localVariableDeclaration.Variables) {
+					ret = v.AcceptVisitor(this, data);
+				}
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(SimpleIfStatement ifStatement, object data)
+		{
+			object ret = ifStatement.Condition.AcceptVisitor(this, data);
+			if(ifStatement.Statements != null) {
+				foreach (Statement s in ifStatement.Statements) {
+					ret = s.AcceptVisitor(this, data);
+				}
+			}
+			if(ifStatement.ElseStatements != null) {
+				foreach (Statement s in ifStatement.ElseStatements) {
+					ret = s.AcceptVisitor(this, data);
+				}
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(IfStatement ifStatement, object data)
+		{
+			object ret = ifStatement.Condition.AcceptVisitor(this, data);
+			if(ifStatement.ElseIfStatements != null) {
+				foreach (Statement s in ifStatement.ElseIfStatements) {
+					ret = s.AcceptVisitor(this, data);
+				}
+			}
+			if (ifStatement.EmbeddedElseStatement != null) {
+				ret = ifStatement.EmbeddedElseStatement.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(LabelStatement labelStatement, object data)
+		{
+			if (labelStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return labelStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(GoToStatement goToStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(SelectStatement selectStatement, object data)
+		{
+			selectStatement.SelectExpression.AcceptVisitor(this, data);
+			if (selectStatement.SelectSections != null) {
+				foreach (SelectSection s in selectStatement.SelectSections) {
+					s.AcceptVisitor(this, data);
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(SelectSection selectSection, object data)
+		{
+			if (selectSection.CaseClauses != null) {
+				foreach (CaseClause c in selectSection.CaseClauses) {
+					c.AcceptVisitor(this, data);
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(CaseClause caseClause, object data)
+		{
+			caseClause.ComparisonExpression.AcceptVisitor(this, data);
+			return caseClause.BoundaryExpression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ExitStatement exitStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(EndStatement endStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(StopStatement stopStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ResumeStatement resumeStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ErrorStatement errorStatement, object data)
+		{
+			return errorStatement.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(OnErrorStatement onErrorStatement, object data)
+		{
+			return onErrorStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(EraseStatement eraseStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(ReDimStatement reDimStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(AddHandlerStatement addHandlerStatement, object data)
+		{
+			addHandlerStatement.EventExpression.AcceptVisitor(this, data);
+			addHandlerStatement.HandlerExpression.AcceptVisitor(this, data);
+			return data;
+		}
+		
+		public virtual object Visit(RemoveHandlerStatement removeHandlerStatement, object data)
+		{
+			removeHandlerStatement.EventExpression.AcceptVisitor(this, data);
+			removeHandlerStatement.HandlerExpression.AcceptVisitor(this, data);
+			return data;
+		}
+		
+		public virtual object Visit(ReturnStatement returnStatement, object data)
+		{
+			return returnStatement.ReturnExpression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(RaiseEventStatement raiseEventStatement, object data)
+		{
+			if (raiseEventStatement.Parameters != null) {
+				foreach (INode node in raiseEventStatement.Parameters) {
+					node.AcceptVisitor(this, data);
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(WhileStatement whileStatement, object data)
+		{
+			if (whileStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(WithStatement withStatement, object data)
+		{
+			if (withStatement.WithExpression != null) {
+				withStatement.WithExpression.AcceptVisitor(this, data);
+			}
+			
+			if (withStatement.Body == null) {
+				return null;
+			}
+			return withStatement.Body.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(DoLoopStatement doLoopStatement, object data)
+		{
+			if (doLoopStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return doLoopStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ForStatement forStatement, object data)
+		{
+			if (forStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ForeachStatement foreachStatement, object data)
+		{
+			if (foreachStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(LockStatement lockStatement, object data)
+		{
+			if (lockStatement.EmbeddedStatement == null) {
+				return null;
+			}
+			return lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			if (tryCatchStatement.StatementBlock == null) {
+				return null;
+			}
+			return tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ThrowStatement throwStatement, object data)
+		{
+			if (throwStatement.ThrowExpression == null) {
+				return null;
+			}
+			return throwStatement.ThrowExpression.AcceptVisitor(this, data);
+		}
+		
+#region Expressions
+		public virtual object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data)
+		{
+			if (fieldReferenceOrInvocationExpression.TargetObject == null) {
+				return null;
+			}
+			return fieldReferenceOrInvocationExpression.TargetObject.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			// visit but can't give back 2 values
+			binaryOperatorExpression.Left.AcceptVisitor(this, data);
+			binaryOperatorExpression.Right.AcceptVisitor(this, data);
+			
+			return data;
+		}
+		public virtual object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			return parenthesizedExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(InvocationExpression invocationExpression, object data)
+		{
+			if (invocationExpression.TargetObject == null) {
+				return data;
+			}
+			return invocationExpression.TargetObject.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			return unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			// visit but can't give back 2 values
+			assignmentExpression.Left.AcceptVisitor(this, data);
+			assignmentExpression.Right.AcceptVisitor(this, data);
+			
+			return data;
+		}
+		
+		public virtual object Visit(CastExpression castExpression, object data)
+		{
+			return castExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			if (arrayInitializerExpression.CreateExpressions != null) {
+				foreach (INode node in arrayInitializerExpression.CreateExpressions) {
+					node.AcceptVisitor(this, data);
+				}
+			}
+			
+			return data;
+		}
+		
+		public virtual object Visit(GetTypeExpression getTypeExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(ClassReferenceExpression classReferenceExpression, object data)
+		{
+			// nothing to visit
+			return data;
+		}
+		
+		public virtual object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
+		{
+			return loopControlVariableExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(AddressOfExpression addressOfExpression, object data)
+		{
+			return addressOfExpression.Procedure.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			return typeOfExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			if (arrayCreateExpression.ArrayInitializer == null) {
+				return data;
+			}
+			return arrayCreateExpression.ArrayInitializer.AcceptVisitor(this, data);
+		}
+#endregion
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractASTVisitor.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,125 +1,125 @@
-// AbstractNode.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Drawing;
-using System.Text;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public abstract class AbstractNode : INode
-	{
-		INode     parent;
-		ArrayList children = new ArrayList();
-		Hashtable specials = new Hashtable();
-		Point     startLocation;
-		Point     endLocation;
-		
-		public INode Parent {
-			get	{
-				return parent;
-			}
-			set {
-				parent = value;
-			}
-		}
-		
-		public Point StartLocation {
-			get {
-				return startLocation;
-			}
-			set {
-				startLocation = value;
-			}
-		}
-		
-		public Point EndLocation {
-			get {
-				return endLocation;
-			}
-			set {
-				endLocation = value;
-			}
-		}
-		
-		public Hashtable Specials {
-			get {
-				return specials;
-			}
-		}
-		
-		public ArrayList Children {
-			get {
-				return children;
-			}
-		}
-		
-		public virtual void AddChild(INode childNode)
-		{
-			children.Add(childNode);
-		}
-		
-		public virtual object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public object AcceptChildren(IASTVisitor visitor, object data)
-		{
-			foreach (INode child in children) {
-				if (child != null) {
-					child.AcceptVisitor(visitor, data);
-				}
-			}
-			return data;
-		}
-		
-		public static string GetCollectionString(ICollection collection)
-		{
-			if (collection == null) {
-				return &quot;null&quot;;
-			}
-			StringBuilder output = new StringBuilder();
-			output.Append('{');
-			
-			if (collection != null) {
-				IEnumerator en = collection.GetEnumerator();
-				bool isFirst = true;
-				while (en.MoveNext()) {
-					if (!isFirst) {
-						output.Append(&quot;, &quot;);
-					} else {
-						isFirst = false;
-					}
-					if (en.Current == null) {
-						output.Append(&quot;null&quot;);
-					} else {
-						output.Append(en.Current.ToString());
-					}
-				}
-			} else {
-				return &quot;null&quot;;
-			}
-			
-			output.Append('}');
-			return output.ToString();
-		}
-	}
-}
+// AbstractNode.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Text;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public abstract class AbstractNode : INode
+	{
+		INode     parent;
+		ArrayList children = new ArrayList();
+		Hashtable specials = new Hashtable();
+		Point     startLocation;
+		Point     endLocation;
+		
+		public INode Parent {
+			get	{
+				return parent;
+			}
+			set {
+				parent = value;
+			}
+		}
+		
+		public Point StartLocation {
+			get {
+				return startLocation;
+			}
+			set {
+				startLocation = value;
+			}
+		}
+		
+		public Point EndLocation {
+			get {
+				return endLocation;
+			}
+			set {
+				endLocation = value;
+			}
+		}
+		
+		public Hashtable Specials {
+			get {
+				return specials;
+			}
+		}
+		
+		public ArrayList Children {
+			get {
+				return children;
+			}
+		}
+		
+		public virtual void AddChild(INode childNode)
+		{
+			children.Add(childNode);
+		}
+		
+		public virtual object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public object AcceptChildren(IASTVisitor visitor, object data)
+		{
+			foreach (INode child in children) {
+				if (child != null) {
+					child.AcceptVisitor(visitor, data);
+				}
+			}
+			return data;
+		}
+		
+		public static string GetCollectionString(ICollection collection)
+		{
+			if (collection == null) {
+				return &quot;null&quot;;
+			}
+			StringBuilder output = new StringBuilder();
+			output.Append('{');
+			
+			if (collection != null) {
+				IEnumerator en = collection.GetEnumerator();
+				bool isFirst = true;
+				while (en.MoveNext()) {
+					if (!isFirst) {
+						output.Append(&quot;, &quot;);
+					} else {
+						isFirst = false;
+					}
+					if (en.Current == null) {
+						output.Append(&quot;null&quot;);
+					} else {
+						output.Append(en.Current.ToString());
+					}
+				}
+			} else {
+				return &quot;null&quot;;
+			}
+			
+			output.Append('}');
+			return output.ToString();
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/AbstractNode.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,81 +1,81 @@
-// CompilationUnit.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class CompilationUnit : AbstractNode
-	{
-		Stack blockStack = new Stack();
-		INode lastChild = null;
-		
-		public CompilationUnit()
-		{
-			blockStack.Push(this);
-		}
-		
-		public void BlockStart(INode block)
-		{
-			blockStack.Push(block);
-		}
-		
-		public void BlockEnd()
-		{
-			lastChild = (INode)blockStack.Pop();
-		}
-		
-		public INode TakeBlock()
-		{
-			return (INode)blockStack.Pop();
-		}
-		
-		public override void AddChild(INode childNode)
-		{
-			if (childNode != null) {
-				INode parent = (INode)blockStack.Peek();
-				parent.Children.Add(childNode);
-				childNode.Parent = parent;
-				lastChild = childNode;
-			}
-		}
-		
-		ArrayList specials = new ArrayList();
-		public void AddSpecial(string key, object val)
-		{
-			specials.Add(new DictionaryEntry(key, val));
-		}
-		
-		public void CommitSpecials()
-		{
-			if (lastChild == null) {
-				return;
-			}
-			foreach (DictionaryEntry entry in specials) {
-				lastChild.Specials[entry.Key] = entry.Value;
-			}
-			specials.Clear();
-		}
-			
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// CompilationUnit.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class CompilationUnit : AbstractNode
+	{
+		Stack blockStack = new Stack();
+		INode lastChild = null;
+		
+		public CompilationUnit()
+		{
+			blockStack.Push(this);
+		}
+		
+		public void BlockStart(INode block)
+		{
+			blockStack.Push(block);
+		}
+		
+		public void BlockEnd()
+		{
+			lastChild = (INode)blockStack.Pop();
+		}
+		
+		public INode TakeBlock()
+		{
+			return (INode)blockStack.Pop();
+		}
+		
+		public override void AddChild(INode childNode)
+		{
+			if (childNode != null) {
+				INode parent = (INode)blockStack.Peek();
+				parent.Children.Add(childNode);
+				childNode.Parent = parent;
+				lastChild = childNode;
+			}
+		}
+		
+		ArrayList specials = new ArrayList();
+		public void AddSpecial(string key, object val)
+		{
+			specials.Add(new DictionaryEntry(key, val));
+		}
+		
+		public void CommitSpecials()
+		{
+			if (lastChild == null) {
+				return;
+			}
+			foreach (DictionaryEntry entry in specials) {
+				lastChild.Specials[entry.Key] = entry.Value;
+			}
+			specials.Clear();
+		}
+			
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/CompilationUnit.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,160 +1,160 @@
-using System;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	/// &lt;summary&gt;
-	/// The type of a type declaration.
-	/// &lt;/summary&gt;
-	public enum Types
-	{
-		Class,
-		Interface,
-		Structure,
-		Module,
-		Enum
-	}
-	
-	///&lt;summary&gt;
-	/// Compare type, used in the &lt;c&gt;Option Compare&lt;/c&gt;
-	/// pragma.
-	///&lt;/summary&gt;
-	public enum CompareType
-	{
-		Binary,
-		Text
-	}
-	
-	///&lt;summary&gt;
-	/// Charset types, used in external mehtods
-	/// declarations.
-	///&lt;/summary&gt;
-	public enum CharsetModifier
-	{
-		None,
-		Auto,
-		Unicode,
-		ANSI
-	}
-	
-	public enum ParentType
-	{
-		ClassOrStruct,
-		InterfaceOrEnum,
-		Namespace,
-		Unknown
-	}
-	
-	public enum Members
-	{
-		Constant,
-		Field,
-		Method,
-		Property,
-		Event,
-		Constructor,
-		StaticConstructor,
-		NestedType
-	}
-	
-	///&lt;summary&gt;
-	/// Used at the exit statement.
-	///&lt;/summary&gt;
-	public enum ExitType
-	{
-		None,
-		Sub,
-		Function,
-		Property,
-		Do,
-		For,
-		While,
-		Select,
-		Try
-	}
-	
-	public enum ConditionType
-	{
-		None,
-		Until,
-		While
-	}
-	
-	public enum ConditionPosition
-	{
-		None,
-		Start,
-		End
-	}
-	
-	public enum UnaryOperatorType
-	{
-		None,
-		Not,
-		BitNot,
-		
-		Minus,
-		Plus,
-		
-		Increment,
-		Decrement,
-		
-		PostIncrement,
-		PostDecrement,
-		
-		Star,
-		BitWiseAnd
-	}
-	
-	public enum AssignmentOperatorType
-	{
-		None,
-		Assign,
-		
-		Add,
-		Subtract,
-		Multiply,
-		Divide,
-		Modulus,
-		
-		ConcatString,
-		
-		ShiftLeft,
-		ShiftRight,
-		
-		BitwiseAnd,
-		BitwiseOr,
-		ExclusiveOr,
-		Power,
-		DivideInteger
-	}
-	
-	public enum BinaryOperatorType
-	{
-		None,
-		Add,
-		Concat,
-		BitwiseAnd,
-		BitwiseOr,
-		BooleanAnd,
-		BooleanOr,
-		Divide,
-		GreaterThan,
-		GreaterThanOrEqual,
-		Equality,
-		InEquality,
-		LessThan,
-		LessThanOrEqual,
-		Modulus,
-		Multiply,
-		Subtract,
-		DivideInteger,
-		Power,
-		
-		// additional
-		ShiftLeft,
-		ShiftRight,
-		IS,
-		ExclusiveOr,
-		Like,
-	}
-}
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	/// &lt;summary&gt;
+	/// The type of a type declaration.
+	/// &lt;/summary&gt;
+	public enum Types
+	{
+		Class,
+		Interface,
+		Structure,
+		Module,
+		Enum
+	}
+	
+	///&lt;summary&gt;
+	/// Compare type, used in the &lt;c&gt;Option Compare&lt;/c&gt;
+	/// pragma.
+	///&lt;/summary&gt;
+	public enum CompareType
+	{
+		Binary,
+		Text
+	}
+	
+	///&lt;summary&gt;
+	/// Charset types, used in external mehtods
+	/// declarations.
+	///&lt;/summary&gt;
+	public enum CharsetModifier
+	{
+		None,
+		Auto,
+		Unicode,
+		ANSI
+	}
+	
+	public enum ParentType
+	{
+		ClassOrStruct,
+		InterfaceOrEnum,
+		Namespace,
+		Unknown
+	}
+	
+	public enum Members
+	{
+		Constant,
+		Field,
+		Method,
+		Property,
+		Event,
+		Constructor,
+		StaticConstructor,
+		NestedType
+	}
+	
+	///&lt;summary&gt;
+	/// Used at the exit statement.
+	///&lt;/summary&gt;
+	public enum ExitType
+	{
+		None,
+		Sub,
+		Function,
+		Property,
+		Do,
+		For,
+		While,
+		Select,
+		Try
+	}
+	
+	public enum ConditionType
+	{
+		None,
+		Until,
+		While
+	}
+	
+	public enum ConditionPosition
+	{
+		None,
+		Start,
+		End
+	}
+	
+	public enum UnaryOperatorType
+	{
+		None,
+		Not,
+		BitNot,
+		
+		Minus,
+		Plus,
+		
+		Increment,
+		Decrement,
+		
+		PostIncrement,
+		PostDecrement,
+		
+		Star,
+		BitWiseAnd
+	}
+	
+	public enum AssignmentOperatorType
+	{
+		None,
+		Assign,
+		
+		Add,
+		Subtract,
+		Multiply,
+		Divide,
+		Modulus,
+		
+		ConcatString,
+		
+		ShiftLeft,
+		ShiftRight,
+		
+		BitwiseAnd,
+		BitwiseOr,
+		ExclusiveOr,
+		Power,
+		DivideInteger
+	}
+	
+	public enum BinaryOperatorType
+	{
+		None,
+		Add,
+		Concat,
+		BitwiseAnd,
+		BitwiseOr,
+		BooleanAnd,
+		BooleanOr,
+		Divide,
+		GreaterThan,
+		GreaterThanOrEqual,
+		Equality,
+		InEquality,
+		LessThan,
+		LessThanOrEqual,
+		Modulus,
+		Multiply,
+		Subtract,
+		DivideInteger,
+		Power,
+		
+		// additional
+		ShiftLeft,
+		ShiftRight,
+		IS,
+		ExclusiveOr,
+		Like,
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Enums.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,31 +1,31 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class AddressOfExpression : Expression
-	{
-		Expression procedure;
-		
-		public Expression Procedure {
-			get {
-				return procedure;
-			}
-			set {
-				procedure = value;
-			}
-		}
-		
-		public AddressOfExpression(Expression Procedure)
-		{
-			this.Procedure = Procedure;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class AddressOfExpression : Expression
+	{
+		Expression procedure;
+		
+		public Expression Procedure {
+			get {
+				return procedure;
+			}
+			set {
+				procedure = value;
+			}
+		}
+		
+		public AddressOfExpression(Expression Procedure)
+		{
+			this.Procedure = Procedure;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AddressOfExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,60 +1,60 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ArrayCreateExpression : Expression
-	{
-		TypeReference              createType       = null;
-		ArrayList                  parameters       = null; // Expressions
-		ArrayInitializerExpression arrayInitializer = null; // Array Initializer OR NULL
-		
-		public TypeReference CreateType {
-			get {
-				return createType;
-			}
-			set {
-				createType = value;
-			}
-		}
-		
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public ArrayInitializerExpression ArrayInitializer
-		{
-			get {
-				return arrayInitializer;
-			}
-			set {
-				arrayInitializer = value;
-			}
-		}
-		
-		public ArrayCreateExpression(TypeReference createType, ArrayList parameters)
-		{
-			this.createType = createType;
-			this.parameters = parameters;
-		}
-		
-		public ArrayCreateExpression(TypeReference createType, ArrayInitializerExpression arrayInitializer)
-		{
-			this.createType = createType;
-			this.arrayInitializer = arrayInitializer;
-		}
-		
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ArrayCreateExpression : Expression
+	{
+		TypeReference              createType       = null;
+		ArrayList                  parameters       = null; // Expressions
+		ArrayInitializerExpression arrayInitializer = null; // Array Initializer OR NULL
+		
+		public TypeReference CreateType {
+			get {
+				return createType;
+			}
+			set {
+				createType = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayInitializerExpression ArrayInitializer
+		{
+			get {
+				return arrayInitializer;
+			}
+			set {
+				arrayInitializer = value;
+			}
+		}
+		
+		public ArrayCreateExpression(TypeReference createType, ArrayList parameters)
+		{
+			this.createType = createType;
+			this.parameters = parameters;
+		}
+		
+		public ArrayCreateExpression(TypeReference createType, ArrayInitializerExpression arrayInitializer)
+		{
+			this.createType = createType;
+			this.arrayInitializer = arrayInitializer;
+		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayCreateExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,33 +1,33 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ArrayInitializerExpression : Expression
-	{
-		ArrayList     createExpressions = new ArrayList();
-		
-		public ArrayList CreateExpressions {
-			get {
-				return createExpressions;
-			}
-			set {
-				createExpressions = value;
-			}
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ArrayInitializerExpression: CreateExpressions={0}]&quot;, 
-			                     GetCollectionString(createExpressions));
-		}
-		
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ArrayInitializerExpression : Expression
+	{
+		ArrayList     createExpressions = new ArrayList();
+		
+		public ArrayList CreateExpressions {
+			get {
+				return createExpressions;
+			}
+			set {
+				createExpressions = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ArrayInitializerExpression: CreateExpressions={0}]&quot;, 
+			                     GetCollectionString(createExpressions));
+		}
+		
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ArrayInitializerExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,60 +1,60 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class AssignmentExpression : Expression
-	{
-		Expression left;
-		AssignmentOperatorType op;
-		Expression right;
-		
-		public Expression Left {
-			get {
-				return left;
-			}
-			set {
-				left = value;
-			}
-		}
-		
-		public AssignmentOperatorType Op {
-			get {
-				return op;
-			}
-			set {
-				op = value;
-			}
-		}
-		
-		public Expression Right {
-			get {
-				return right;
-			}
-			set {
-				right = value;
-			}
-		}
-		
-		public AssignmentExpression(Expression left, AssignmentOperatorType op, Expression right)
-		{
-			this.left  = left;
-			this.op    = op;
-			this.right = right;
-		}
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[AssignmentExpression: Op={0}, Left={1}, Right={2}]&quot;,
-			                     op,
-			                     left,
-			                     right);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class AssignmentExpression : Expression
+	{
+		Expression left;
+		AssignmentOperatorType op;
+		Expression right;
+		
+		public Expression Left {
+			get {
+				return left;
+			}
+			set {
+				left = value;
+			}
+		}
+		
+		public AssignmentOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public Expression Right {
+			get {
+				return right;
+			}
+			set {
+				right = value;
+			}
+		}
+		
+		public AssignmentExpression(Expression left, AssignmentOperatorType op, Expression right)
+		{
+			this.left  = left;
+			this.op    = op;
+			this.right = right;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[AssignmentExpression: Op={0}, Left={1}, Right={2}]&quot;,
+			                     op,
+			                     left,
+			                     right);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/AssignmentExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,20 +1,20 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class BaseReferenceExpression : Expression
-	{
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[BaseReferenceExpression]&quot;);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class BaseReferenceExpression : Expression
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BaseReferenceExpression]&quot;);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BaseReferenceExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,61 +1,61 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class BinaryOperatorExpression : Expression
-	{
-		Expression left;
-		BinaryOperatorType op;
-		Expression right;
-		
-		public Expression Left {
-			get {
-				return left;
-			}
-			set {
-				left = value;
-			}
-		}
-		
-		public BinaryOperatorType Op {
-			get {
-				return op;
-			}
-			set {
-				op = value;
-			}
-		}
-		
-		public Expression Right {
-			get {
-				return right;
-			}
-			set {
-				right = value;
-			}
-		}
-		
-		public BinaryOperatorExpression(Expression left, BinaryOperatorType op, Expression right)
-		{
-			this.left  = left;
-			this.op    = op;
-			this.right = right;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[BinaryOperatorExpression: Op={0}, Left={1}, Right={2}]&quot;,
-			                     op,
-			                     left,
-			                     right);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class BinaryOperatorExpression : Expression
+	{
+		Expression left;
+		BinaryOperatorType op;
+		Expression right;
+		
+		public Expression Left {
+			get {
+				return left;
+			}
+			set {
+				left = value;
+			}
+		}
+		
+		public BinaryOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public Expression Right {
+			get {
+				return right;
+			}
+			set {
+				right = value;
+			}
+		}
+		
+		public BinaryOperatorExpression(Expression left, BinaryOperatorType op, Expression right)
+		{
+			this.left  = left;
+			this.op    = op;
+			this.right = right;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BinaryOperatorExpression: Op={0}, Left={1}, Right={2}]&quot;,
+			                     op,
+			                     left,
+			                     right);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/BinaryOperatorExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,68 +1,68 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class CastExpression : Expression
-	{
-		TypeReference castTo;
-		Expression expression;
-		bool       isSpecializedCast = false;
-		
-		
-		public TypeReference CastTo {
-			get {
-				return castTo;
-			}
-			set {
-				castTo = value;
-			}
-		}
-		
-		public Expression Expression {
-			get {
-				return expression;
-			}
-			set {
-				expression = value;
-			}
-		}
-		
-		public bool IsSpecializedCast {
-			get {
-				return isSpecializedCast;
-			}
-			set {
-				isSpecializedCast = value;
-			}
-		}
-		
-		
-		public CastExpression(TypeReference castTo, Expression expression)
-		{
-			this.castTo = castTo;
-			this.expression = expression;
-		}
-		
-		public CastExpression(TypeReference castTo, Expression expression, bool isSpecializedCast)
-		{
-			this.castTo = castTo;
-			this.expression = expression;
-			this.isSpecializedCast = isSpecializedCast;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[CastExpression: CastTo={0}, Expression={1}]&quot;,
-			                     castTo,
-			                     expression);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class CastExpression : Expression
+	{
+		TypeReference castTo;
+		Expression expression;
+		bool       isSpecializedCast = false;
+		
+		
+		public TypeReference CastTo {
+			get {
+				return castTo;
+			}
+			set {
+				castTo = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public bool IsSpecializedCast {
+			get {
+				return isSpecializedCast;
+			}
+			set {
+				isSpecializedCast = value;
+			}
+		}
+		
+		
+		public CastExpression(TypeReference castTo, Expression expression)
+		{
+			this.castTo = castTo;
+			this.expression = expression;
+		}
+		
+		public CastExpression(TypeReference castTo, Expression expression, bool isSpecializedCast)
+		{
+			this.castTo = castTo;
+			this.expression = expression;
+			this.isSpecializedCast = isSpecializedCast;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[CastExpression: CastTo={0}, Expression={1}]&quot;,
+			                     castTo,
+			                     expression);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/CastExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,20 +1,20 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ClassReferenceExpression : Expression
-	{
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ClassReferenceExpression]&quot;);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ClassReferenceExpression : Expression
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ClassReferenceExpression]&quot;);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ClassReferenceExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,29 +1,29 @@
-// Expression.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB 
-{
-	public class Expression : AbstractNode
-	{
-		public Expression()
-		{
-		}
-	}
-}
+// Expression.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB 
+{
+	public class Expression : AbstractNode
+	{
+		public Expression()
+		{
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/Expression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,31 +1,31 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class GetTypeExpression : Expression
-	{
-		TypeReference type;
-		
-		public TypeReference Type {
-			get {
-				return type;
-			}
-			set {
-				type = value;
-			}
-		}
-		
-		public GetTypeExpression(TypeReference type)
-		{
-			this.type = type;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class GetTypeExpression : Expression
+	{
+		TypeReference type;
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public GetTypeExpression(TypeReference type)
+		{
+			this.type = type;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/GetTypeExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,38 +1,38 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class IdentifierExpression : Expression
-	{
-		string identifier;
-		
-		public string Identifier {
-			get {
-				return identifier;
-			}
-			set {
-				identifier = value;
-			}
-		}
-		
-		public IdentifierExpression(string identifier)
-		{
-			this.identifier = identifier;
-		}
-		
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[IdentifierExpression: Identifier={0}]&quot;,
-			                     identifier);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class IdentifierExpression : Expression
+	{
+		string identifier;
+		
+		public string Identifier {
+			get {
+				return identifier;
+			}
+			set {
+				identifier = value;
+			}
+		}
+		
+		public IdentifierExpression(string identifier)
+		{
+			this.identifier = identifier;
+		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[IdentifierExpression: Identifier={0}]&quot;,
+			                     identifier);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/IdentifierExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,49 +1,49 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class InvocationExpression : Expression
-	{
-		Expression  targetObject;
-		ArrayList   parameters; // Expression list
-		
-		public Expression TargetObject {
-			get {
-				return targetObject;
-			}
-			set {
-				targetObject = value;
-			}
-		}
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public InvocationExpression(Expression targetObject, ArrayList parameters)
-		{
-			this.targetObject = targetObject;
-			this.parameters = parameters;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[InvocationExpression: TargetObject={0}, parameters={1}]&quot;,
-			                     targetObject,
-			                     GetCollectionString(parameters));
-		}
-	}
-}
-
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class InvocationExpression : Expression
+	{
+		Expression  targetObject;
+		ArrayList   parameters; // Expression list
+		
+		public Expression TargetObject {
+			get {
+				return targetObject;
+			}
+			set {
+				targetObject = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public InvocationExpression(Expression targetObject, ArrayList parameters)
+		{
+			this.targetObject = targetObject;
+			this.parameters = parameters;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[InvocationExpression: TargetObject={0}, parameters={1}]&quot;,
+			                     targetObject,
+			                     GetCollectionString(parameters));
+		}
+	}
+}
+


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/InvocationExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,60 +1,60 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class LoopControlVariableExpression : Expression
-	{
-		Expression expression = null;
-		string name;
-		TypeReference type;
-		
-		public LoopControlVariableExpression(string name, TypeReference type)
-		{
-			this.name = name;
-			this.type = type;
-		}
-		
-		public LoopControlVariableExpression(Expression expression)
-		{
-			this.expression = expression;
-		}
-		
-		public string Name
-		{
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		
-		public TypeReference Type
-		{
-			get {
-				return type;
-			}
-			set {
-				type = value;
-			}
-		}
-		
-		public Expression Expression
-		{
-			get {
-				return expression;
-			}
-			set {
-				expression = value;
-			}
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class LoopControlVariableExpression : Expression
+	{
+		Expression expression = null;
+		string name;
+		TypeReference type;
+		
+		public LoopControlVariableExpression(string name, TypeReference type)
+		{
+			this.name = name;
+			this.type = type;
+		}
+		
+		public LoopControlVariableExpression(Expression expression)
+		{
+			this.expression = expression;
+		}
+		
+		public string Name
+		{
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public TypeReference Type
+		{
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public Expression Expression
+		{
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/LoopControlVariableExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,44 +1,44 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB {
-	
-	public class NamedArgumentExpression : Expression
-	{
-		string parametername;
-		Expression     expression;
-		
-		public string Parametername {
-			get {
-				return parametername;
-			}
-			set {
-				parametername = value;
-			}
-		}
-		
-		public Expression Expression {
-			get {
-				return expression;
-			}
-			set {
-				expression = value;
-			}
-		}
-		
-		public NamedArgumentExpression(string parametername, Expression expression)
-		{
-			this.parametername = parametername;
-			this.expression = expression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
-
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB {
+	
+	public class NamedArgumentExpression : Expression
+	{
+		string parametername;
+		Expression     expression;
+		
+		public string Parametername {
+			get {
+				return parametername;
+			}
+			set {
+				parametername = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public NamedArgumentExpression(string parametername, Expression expression)
+		{
+			this.parametername = parametername;
+			this.expression = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}
+


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/NamedArgumentExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ObjectCreateExpression : Expression
-	{
-		TypeReference createType;
-		ArrayList     parameters;
-		
-		public TypeReference CreateType {
-			get {
-				return createType;
-			}
-			set {
-				createType = value;
-			}
-		}
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public ObjectCreateExpression(TypeReference createType, ArrayList parameters)
-		{
-			this.createType = createType;
-			this.parameters = parameters;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ObjectCreateExpression: CreateType={0}, Parameters={1}]&quot;,
-			                     createType,
-			                     GetCollectionString(parameters));
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ObjectCreateExpression : Expression
+	{
+		TypeReference createType;
+		ArrayList     parameters;
+		
+		public TypeReference CreateType {
+			get {
+				return createType;
+			}
+			set {
+				createType = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ObjectCreateExpression(TypeReference createType, ArrayList parameters)
+		{
+			this.createType = createType;
+			this.parameters = parameters;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ObjectCreateExpression: CreateType={0}, Parameters={1}]&quot;,
+			                     createType,
+			                     GetCollectionString(parameters));
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ObjectCreateExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,90 +1,90 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB {
-	
-	public class ParameterDeclarationExpression : Expression
-	{
-		TypeReference  typeReference;
-		string         parameterName;
-		ParamModifiers paramModifiers;
-		ArrayList      attributes = new ArrayList();
-		Expression	   defaultValue;
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ParameterDeclarationExpression: DefaultValue={0}, TypeReference={1}, ParameterName={2}, ParamModifiers={3}, Attributes=TODO]&quot;,
-			                     defaultValue,
-			                     typeReference,
-			                     parameterName,
-			                     paramModifiers);
-		}
-		
-		public Expression DefaultValue {
-			get {
-				return defaultValue;
-			}
-			set {
-				defaultValue = value;
-			}
-		}
-		
-		public TypeReference TypeReference {
-			get {
-				return typeReference;
-			}
-			set {
-				typeReference = value;
-			}
-		}
-		
-		public string ParameterName {
-			get {
-				return parameterName;
-			}
-			set {
-				parameterName = value;
-			}
-		}
-		
-		public ParamModifiers ParamModifiers {
-			get {
-				return paramModifiers;
-			}
-			set {
-				paramModifiers = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public ParameterDeclarationExpression(TypeReference typeReference, string parameterName, ParamModifiers paramModifiers, Expression defaultValue)
-		{
-			this.typeReference = typeReference;
-			this.parameterName = parameterName;
-			this.paramModifiers = paramModifiers;
-			this.attributes = attributes;
-			this.defaultValue = defaultValue;
-		}
-		
-		public ParameterDeclarationExpression(TypeReference typeReference, string parameterName, ParamModifiers paramModifiers)
-		{
-			this.typeReference  = typeReference;
-			this.parameterName  = parameterName;
-			this.paramModifiers = paramModifiers;
-		}
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB {
+	
+	public class ParameterDeclarationExpression : Expression
+	{
+		TypeReference  typeReference;
+		string         parameterName;
+		ParamModifiers paramModifiers;
+		ArrayList      attributes = new ArrayList();
+		Expression	   defaultValue;
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ParameterDeclarationExpression: DefaultValue={0}, TypeReference={1}, ParameterName={2}, ParamModifiers={3}, Attributes=TODO]&quot;,
+			                     defaultValue,
+			                     typeReference,
+			                     parameterName,
+			                     paramModifiers);
+		}
+		
+		public Expression DefaultValue {
+			get {
+				return defaultValue;
+			}
+			set {
+				defaultValue = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public string ParameterName {
+			get {
+				return parameterName;
+			}
+			set {
+				parameterName = value;
+			}
+		}
+		
+		public ParamModifiers ParamModifiers {
+			get {
+				return paramModifiers;
+			}
+			set {
+				paramModifiers = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public ParameterDeclarationExpression(TypeReference typeReference, string parameterName, ParamModifiers paramModifiers, Expression defaultValue)
+		{
+			this.typeReference = typeReference;
+			this.parameterName = parameterName;
+			this.paramModifiers = paramModifiers;
+			this.attributes = attributes;
+			this.defaultValue = defaultValue;
+		}
+		
+		public ParameterDeclarationExpression(TypeReference typeReference, string parameterName, ParamModifiers paramModifiers)
+		{
+			this.typeReference  = typeReference;
+			this.parameterName  = parameterName;
+			this.paramModifiers = paramModifiers;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParameterDeclarationExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,37 +1,37 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ParenthesizedExpression : Expression
-	{
-		Expression expression;
-		
-		public Expression Expression {
-			get {
-				return expression;
-			}
-			set {
-				expression = value;
-			}
-		}
-		
-		public ParenthesizedExpression(Expression expression)
-		{
-			this.expression  = expression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ParenthesizedExpression: Expression={0}]&quot;,
-			                     expression);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ParenthesizedExpression : Expression
+	{
+		Expression expression;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public ParenthesizedExpression(Expression expression)
+		{
+			this.expression  = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ParenthesizedExpression: Expression={0}]&quot;,
+			                     expression);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ParenthesizedExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,51 +1,51 @@
-using System;
-using System.Collections;
-using System.Globalization;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class PrimitiveExpression : Expression
-	{
-		object val;
-		string stringValue;
-		
-		public object Value {
-			get {
-				return val;
-			}
-			set {
-				val = value;
-			}
-		}
-		
-		public string StringValue {
-			get {
-				return stringValue;
-			}
-			set {
-				stringValue = value;
-			}
-		}
-		
-		public PrimitiveExpression(object val, string stringValue)
-		{
-			this.val = val;
-			this.stringValue = stringValue;
-		}
-		
-		static NumberFormatInfo nfi = new CultureInfo( &quot;en-US&quot;, false ).NumberFormat;
-
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[PrimitiveExpression: StringValue={0}]&quot;,
-			                     stringValue);
-		}
-	}
-}
+using System;
+using System.Collections;
+using System.Globalization;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class PrimitiveExpression : Expression
+	{
+		object val;
+		string stringValue;
+		
+		public object Value {
+			get {
+				return val;
+			}
+			set {
+				val = value;
+			}
+		}
+		
+		public string StringValue {
+			get {
+				return stringValue;
+			}
+			set {
+				stringValue = value;
+			}
+		}
+		
+		public PrimitiveExpression(object val, string stringValue)
+		{
+			this.val = val;
+			this.stringValue = stringValue;
+		}
+		
+		static NumberFormatInfo nfi = new CultureInfo( &quot;en-US&quot;, false ).NumberFormat;
+
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[PrimitiveExpression: StringValue={0}]&quot;,
+			                     stringValue);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/PrimitiveExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,54 +1,54 @@
-// StatementExpression.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class StatementExpression : Statement
-	{
-		Expression expression;
-		
-		public Expression Expression
-		{
-			get {
-				return expression;
-			}
-			set {
-				expression = value;
-			}
-		}
-		
-		public StatementExpression(Expression expression)
-		{
-			this.expression = expression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[StatementExpression: Expression={0}]&quot;, expression);
-		}
-	}
-}
+// StatementExpression.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class StatementExpression : Statement
+	{
+		Expression expression;
+		
+		public Expression Expression
+		{
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public StatementExpression(Expression expression)
+		{
+			this.expression = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[StatementExpression: Expression={0}]&quot;, expression);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/StatementExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,21 +1,21 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ThisReferenceExpression : Expression
-	{
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ThisReferenceExpression]&quot;);
-		}
-
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ThisReferenceExpression : Expression
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ThisReferenceExpression]&quot;);
+		}
+
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/ThisReferenceExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,43 +1,43 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class TypeOfExpression : Expression
-	{
-		TypeReference type;
-		
-		Expression expression;
-		
-		public Expression Expression {
-			get {
-				return expression;
-			}
-			set {
-				expression = value;
-			}
-		}
-		
-		public TypeReference Type {
-			get {
-				return type;
-			}
-			set {
-				type = value;
-			}
-		}
-		
-		public TypeOfExpression(Expression expression, TypeReference type)
-		{
-			this.type = type;
-			this.expression = expression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TypeOfExpression : Expression
+	{
+		TypeReference type;
+		
+		Expression expression;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public TypeOfExpression(Expression expression, TypeReference type)
+		{
+			this.type = type;
+			this.expression = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeOfExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,41 +1,41 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class TypeReferenceExpression : Expression
-	{
-		TypeReference  typeReference;
-		
-		public TypeReference TypeReference {
-			get {
-				return typeReference;
-			}
-			set {
-				typeReference = value;
-			}
-		}
-		
-		public TypeReferenceExpression(string type)
-		{
-			this.typeReference = new TypeReference(type);
-		}
-		public TypeReferenceExpression(TypeReference  typeReference)
-		{
-			this.typeReference = typeReference;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[TypeReferenceExpression: TypeReference={0}]&quot;, 
-			                     typeReference);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TypeReferenceExpression : Expression
+	{
+		TypeReference  typeReference;
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public TypeReferenceExpression(string type)
+		{
+			this.typeReference = new TypeReference(type);
+		}
+		public TypeReferenceExpression(TypeReference  typeReference)
+		{
+			this.typeReference = typeReference;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeReferenceExpression: TypeReference={0}]&quot;, 
+			                     typeReference);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/TypeReferenceExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class UnaryOperatorExpression : Expression
-	{
-		Expression        expression;
-		UnaryOperatorType op;
-		
-		public Expression Expression {
-			get {
-				return expression;
-			}
-			set {
-				expression = value;
-			}
-		}
-		public UnaryOperatorType Op {
-			get {
-				return op;
-			}
-			set {
-				op = value;
-			}
-		}
-		
-		public UnaryOperatorExpression(Expression expression, UnaryOperatorType op)
-		{
-			this.expression  = expression;
-			this.op    = op;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[UnaryOperatorExpression: Op={0}, Expression={1}]&quot;,
-			                     op,
-			                     expression);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class UnaryOperatorExpression : Expression
+	{
+		Expression        expression;
+		UnaryOperatorType op;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		public UnaryOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public UnaryOperatorExpression(Expression expression, UnaryOperatorType op)
+		{
+			this.expression  = expression;
+			this.op    = op;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UnaryOperatorExpression: Op={0}, Expression={1}]&quot;,
+			                     op,
+			                     expression);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Expressions/UnaryOperatorExpression.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,93 +1,93 @@
-// AttributeDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class Attribute : AbstractNode
-	{
-		string name;
-		ArrayList positionalArguments; // [Expression]
-		ArrayList namedArguments; // [NamedArgumentExpression]
-		
-		public Attribute(string name, ArrayList positionalArguments, ArrayList namedArguments)
-		{
-			this.name = name;
-			this.positionalArguments = positionalArguments;
-			this.namedArguments = namedArguments;
-		}
-		
-		public string Name {
-			get {
-				return name;
-			}
-		}
-		public ArrayList PositionalArguments {
-			get {
-				return positionalArguments;
-			}
-		}
-		public ArrayList NamedArguments {
-			get {
-				return namedArguments;
-			}
-		}
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-	
-	public class AttributeSection : AbstractNode
-	{
-		string    attributeTarget;
-		ArrayList attributes; // [Attribute]
-		
-		public string AttributeTarget {
-			get {
-				return attributeTarget;
-			}
-			set {
-				attributeTarget = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public AttributeSection(string attributeTarget, ArrayList attributes)
-		{
-			this.attributeTarget = attributeTarget;
-			this.attributes = attributes;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// AttributeDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class Attribute : AbstractNode
+	{
+		string name;
+		ArrayList positionalArguments; // [Expression]
+		ArrayList namedArguments; // [NamedArgumentExpression]
+		
+		public Attribute(string name, ArrayList positionalArguments, ArrayList namedArguments)
+		{
+			this.name = name;
+			this.positionalArguments = positionalArguments;
+			this.namedArguments = namedArguments;
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+		}
+		public ArrayList PositionalArguments {
+			get {
+				return positionalArguments;
+			}
+		}
+		public ArrayList NamedArguments {
+			get {
+				return namedArguments;
+			}
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class AttributeSection : AbstractNode
+	{
+		string    attributeTarget;
+		ArrayList attributes; // [Attribute]
+		
+		public string AttributeTarget {
+			get {
+				return attributeTarget;
+			}
+			set {
+				attributeTarget = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public AttributeSection(string attributeTarget, ArrayList attributes)
+		{
+			this.attributeTarget = attributeTarget;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/AttributeDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,102 +1,102 @@
-// DelegateDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class DelegateDeclaration : AbstractNode
-	{
-		string          name;
-		Modifier modifier;
-		TypeReference   returnType;
-		ArrayList       parameters; // [ParameterDeclarationExpression]
-		ArrayList       attributes;
-		
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		
-		public TypeReference ReturnType {
-			get {
-				return returnType;
-			}
-			set {
-				returnType = value;
-			}
-		}
-		
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-//		public DelegateDeclaration(string name, Modifier modifier, TypeReference returnType, ArrayList parameters, ArrayList attributes)
-//		{
-//			this.name = name;
-//			this.modifier = modifier;
-//			this.returnType = returnType;
-//			this.parameters = parameters;
-//			this.attributes = attributes;
-//		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[DelegateDeclaration: Name={0}, Modifier={1}, ReturnType={2}, parameters={3}, attributes={4}]&quot;,
-			                     name,
-			                     modifier,
-			                     returnType,
-			                     GetCollectionString(parameters),
-			                     GetCollectionString(attributes));
-		}
-	}
-}
+// DelegateDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class DelegateDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		TypeReference   returnType;
+		ArrayList       parameters; // [ParameterDeclarationExpression]
+		ArrayList       attributes;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference ReturnType {
+			get {
+				return returnType;
+			}
+			set {
+				returnType = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+//		public DelegateDeclaration(string name, Modifier modifier, TypeReference returnType, ArrayList parameters, ArrayList attributes)
+//		{
+//			this.name = name;
+//			this.modifier = modifier;
+//			this.returnType = returnType;
+//			this.parameters = parameters;
+//			this.attributes = attributes;
+//		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[DelegateDeclaration: Name={0}, Modifier={1}, ReturnType={2}, parameters={3}, attributes={4}]&quot;,
+			                     name,
+			                     modifier,
+			                     returnType,
+			                     GetCollectionString(parameters),
+			                     GetCollectionString(attributes));
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/DelegateDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,59 +1,59 @@
-// UsingAliasDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ImportsAliasDeclaration : AbstractNode
-	{
-		string    alias;
-		string    nameSpace;
-		
-		public string Alias {
-			get {
-				return alias;
-			}
-			set {
-				alias = value;
-			}
-		}
-		
-		public string Namespace {
-			get {
-				return nameSpace;
-			}
-			set {
-				nameSpace = value;
-			}
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public ImportsAliasDeclaration(string alias, string nameSpace)
-		{
-			this.alias     = alias;
-			this.nameSpace = nameSpace;
-		}
-	}
-}
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ImportsAliasDeclaration : AbstractNode
+	{
+		string    alias;
+		string    nameSpace;
+		
+		public string Alias {
+			get {
+				return alias;
+			}
+			set {
+				alias = value;
+			}
+		}
+		
+		public string Namespace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public ImportsAliasDeclaration(string alias, string nameSpace)
+		{
+			this.alias     = alias;
+			this.nameSpace = nameSpace;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsAliasDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-// UsingDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ImportsDeclaration : AbstractNode
-	{
-		string nameSpace;
-		
-		public string Namespace {
-			get {
-				return nameSpace;
-			}
-			set {
-				nameSpace = value;
-			}
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public ImportsDeclaration(string nameSpace)
-		{
-			this.nameSpace = nameSpace;
-		}
-	}
-}
+// UsingDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ImportsDeclaration : AbstractNode
+	{
+		string nameSpace;
+		
+		public string Namespace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public ImportsDeclaration(string nameSpace)
+		{
+			this.nameSpace = nameSpace;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-// UsingDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ImportsStatement : AbstractNode
-	{
-		ArrayList importClauses;
-		
-		public ArrayList ImportClauses {
-			get {
-				return importClauses;
-			}
-			set {
-				importClauses = value;
-			}
-		}
-		
-		public ImportsStatement(ArrayList importClauses)
-		{
-			this.importClauses = importClauses;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// UsingDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ImportsStatement : AbstractNode
+	{
+		ArrayList importClauses;
+		
+		public ArrayList ImportClauses {
+			get {
+				return importClauses;
+			}
+			set {
+				importClauses = value;
+			}
+		}
+		
+		public ImportsStatement(ArrayList importClauses)
+		{
+			this.importClauses = importClauses;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/ImportsStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,47 +1,47 @@
-// NamespaceDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class NamespaceDeclaration : AbstractNode
-	{
-		string    nameSpace;
-		
-		public string NameSpace {
-			get {
-				return nameSpace;
-			}
-			set {
-				nameSpace = value;
-			}
-		}
-		
-		public NamespaceDeclaration(string nameSpace)
-		{
-			this.nameSpace = nameSpace;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// NamespaceDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class NamespaceDeclaration : AbstractNode
+	{
+		string    nameSpace;
+		
+		public string NameSpace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public NamespaceDeclaration(string nameSpace)
+		{
+			this.nameSpace = nameSpace;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,57 +1,57 @@
-// UsingAliasDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class OptionCompareDeclaration : AbstractNode
-	{
-		CompareType compareType;
-		bool optionvalue;
-		
-		public CompareType CompareType {
-			get {
-				return compareType;
-			}
-			set {
-				compareType = value;
-			}
-		}
-		
-		public bool OptionValue {
-			get {
-				return optionvalue;
-			}
-			set {
-				optionvalue = value;
-			}
-		}
-		
-		public OptionCompareDeclaration(CompareType compareType)
-		{
-			this.compareType = compareType;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class OptionCompareDeclaration : AbstractNode
+	{
+		CompareType compareType;
+		bool optionvalue;
+		
+		public CompareType CompareType {
+			get {
+				return compareType;
+			}
+			set {
+				compareType = value;
+			}
+		}
+		
+		public bool OptionValue {
+			get {
+				return optionvalue;
+			}
+			set {
+				optionvalue = value;
+			}
+		}
+		
+		public OptionCompareDeclaration(CompareType compareType)
+		{
+			this.compareType = compareType;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionCompareDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-// UsingAliasDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class OptionExplicitDeclaration : AbstractNode
-	{
-		bool optionvalue;
-		
-		public bool OptionValue {
-			get {
-				return optionvalue;
-			}
-			set {
-				optionvalue = value;
-			}
-		}
-		
-		public OptionExplicitDeclaration(bool optionvalue)
-		{
-			this.optionvalue = optionvalue;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class OptionExplicitDeclaration : AbstractNode
+	{
+		bool optionvalue;
+		
+		public bool OptionValue {
+			get {
+				return optionvalue;
+			}
+			set {
+				optionvalue = value;
+			}
+		}
+		
+		public OptionExplicitDeclaration(bool optionvalue)
+		{
+			this.optionvalue = optionvalue;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionExplicitDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-// UsingAliasDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class OptionStrictDeclaration : AbstractNode
-	{
-		bool optionvalue;
-		
-		public bool OptionValue {
-			get {
-				return optionvalue;
-			}
-			set {
-				optionvalue = value;
-			}
-		}
-		
-		public OptionStrictDeclaration(bool optionvalue)
-		{
-			this.optionvalue = optionvalue;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class OptionStrictDeclaration : AbstractNode
+	{
+		bool optionvalue;
+		
+		public bool OptionValue {
+			get {
+				return optionvalue;
+			}
+			set {
+				optionvalue = value;
+			}
+		}
+		
+		public OptionStrictDeclaration(bool optionvalue)
+		{
+			this.optionvalue = optionvalue;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/OptionStrictDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,112 +1,112 @@
-// TypeDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using System.Collections.Specialized;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class TypeDeclaration : AbstractNode
-	{
-		// Children of Enum : [Field]
-		string name;
-		Modifier modifier;
-		Types type; // Class | Interface | Structure | Enum | Module
-		string baseType = null;
-		ArrayList attributes;
-		ArrayList baseInterfaces;
-		
-		public string BaseType {
-			get {
-				return baseType;
-			}
-			set {
-				baseType = value;
-			}
-		}
-		
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		public Types Type {
-			get {
-				return type;
-			}
-			set {
-				type = value;
-			}
-		}
-		public ArrayList BaseInterfaces  {
-			get {
-				return baseInterfaces;
-			}
-			set {
-				baseInterfaces = value;
-			}
-		}
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-//		public TypeDeclaration(string name, Modifier modifier, Types type, StringCollection bases, ArrayList attributes)
-//		{
-//			this.name = name;
-//			this.modifier = modifier;
-//			this.type = type;
-//			this.bases = bases;
-//			this.attributes = attributes;
-//		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[TypeDeclaration: Name={0}, Modifier={1}, Type={2}, BaseType={3}]&quot;,
-			                     name,
-			                     modifier,
-			                     type,
-			                     baseType
-//			                     ,GetCollectionString(bases)
-			                     );
-		}
-		
-	}
-}
+// TypeDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TypeDeclaration : AbstractNode
+	{
+		// Children of Enum : [Field]
+		string name;
+		Modifier modifier;
+		Types type; // Class | Interface | Structure | Enum | Module
+		string baseType = null;
+		ArrayList attributes;
+		ArrayList baseInterfaces;
+		
+		public string BaseType {
+			get {
+				return baseType;
+			}
+			set {
+				baseType = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		public Types Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		public ArrayList BaseInterfaces  {
+			get {
+				return baseInterfaces;
+			}
+			set {
+				baseInterfaces = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+//		public TypeDeclaration(string name, Modifier modifier, Types type, StringCollection bases, ArrayList attributes)
+//		{
+//			this.name = name;
+//			this.modifier = modifier;
+//			this.type = type;
+//			this.bases = bases;
+//			this.attributes = attributes;
+//		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeDeclaration: Name={0}, Modifier={1}, Type={2}, BaseType={3}]&quot;,
+			                     name,
+			                     modifier,
+			                     type,
+			                     baseType
+//			                     ,GetCollectionString(bases)
+			                     );
+		}
+		
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/GlobalScope/TypeDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,94 +1,94 @@
-using System;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public interface IASTVisitor
-	{
-		// Abstract
-		object Visit(INode node, object data);
-		object Visit(CompilationUnit compilationUnit, object data);
-		
-		// Statements
-		object Visit(Statement statement, object data);
-		object Visit(StatementExpression statementExpression, object data);
-		object Visit(LocalVariableDeclaration localVariableDeclaration, object data);
-		object Visit(SimpleIfStatement ifStatement, object data);
-		object Visit(IfStatement ifStatement, object data);
-		object Visit(LabelStatement labelStatement, object data);
-		object Visit(GoToStatement goToStatement, object data);
-		object Visit(SelectStatement selectStatement, object data);
-		object Visit(StopStatement stopStatement, object data);
-		object Visit(ResumeStatement resumeStatement, object data);
-		object Visit(EraseStatement eraseStatement, object data);
-		object Visit(ErrorStatement errorStatement, object data);
-		object Visit(OnErrorStatement onErrorStatement, object data);
-		object Visit(ReDimStatement reDimStatement, object data);
-		object Visit(AddHandlerStatement addHandlerStatement, object data);
-		object Visit(BlockStatement blockStatement, object data);
-		object Visit(DoLoopStatement doLoopStatement, object data);
-		object Visit(EndStatement endStatement, object data);
-		object Visit(ExitStatement exitStatement, object data);
-		object Visit(ForeachStatement foreachStatement, object data);
-		object Visit(ForStatement forStatement, object data);
-		object Visit(LockStatement lockStatement, object data);
-		object Visit(RaiseEventStatement raiseEventStatement, object data);
-		object Visit(RemoveHandlerStatement removeHandlerStatement, object data);
-		object Visit(ReturnStatement returnStatement, object data);
-		object Visit(ThrowStatement throwStatement, object data);
-		object Visit(TryCatchStatement tryCatchStatement, object data);
-		object Visit(WhileStatement whileStatement, object data);
-		object Visit(WithStatement withStatement, object data);
-		
-		// Declarations
-		object Visit(VariableDeclaration variableDeclaration, object data);
-		object Visit(FieldDeclaration    fieldDeclaration, object data);
-		
-		object Visit(MethodDeclaration methodDeclaration, object data);
-		object Visit(ConstructorDeclaration constructorDeclaration, object data);
-		object Visit(DeclareDeclaration declareDeclaration, object data);
-		object Visit(PropertyDeclaration propertyDeclaration, object data);
-		object Visit(PropertyGetRegion propertyGetRegion, object data);
-		object Visit(PropertySetRegion PropertySetRegion, object data);
-		object Visit(EventDeclaration eventDeclaration, object data);
-		
-		// Global scope
-		object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data);
-		object Visit(AttributeSection attributeDeclaration, object data);
-		object Visit(DelegateDeclaration delegateDeclaration, object data);
-		object Visit(ImportsDeclaration importsAliasDeclaration, object data);
-		object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data);
-		object Visit(ImportsStatement importsStatement, object data);
-		object Visit(NamespaceDeclaration namespaceDeclaration, object data);
-		object Visit(OptionCompareDeclaration optionCompareDeclaration, object data);
-		object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data);
-		object Visit(OptionStrictDeclaration optionStrictDeclaration, object data);
-		object Visit(TypeDeclaration typeDeclaration, object data);
-		object Visit(TypeReference typeReference, object data);
-		
-		// Expressions
-		object Visit(PrimitiveExpression      primitiveExpression, object data);
-		object Visit(BinaryOperatorExpression binaryOperatorExpression, object data);
-		object Visit(ParenthesizedExpression parenthesizedExpression, object data);
-		object Visit(InvocationExpression invocationExpression, object data);
-		object Visit(IdentifierExpression identifierExpression, object data);
-		object Visit(TypeReferenceExpression typeReferenceExpression, object data);
-		object Visit(UnaryOperatorExpression unaryOperatorExpression, object data);
-		object Visit(AssignmentExpression assignmentExpression, object data);
-		object Visit(CastExpression castExpression, object data);
-		object Visit(ThisReferenceExpression thisReferenceExpression, object data);
-		object Visit(BaseReferenceExpression baseReferenceExpression, object data);
-		object Visit(ObjectCreateExpression objectCreateExpression, object data);
-		object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data);
-		object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data);
-		object Visit(ArrayInitializerExpression arrayInitializerExpression, object data);
-		object Visit(GetTypeExpression getTypeExpression, object data);
-		object Visit(ClassReferenceExpression classReferenceExpression, object data);
-		object Visit(LoopControlVariableExpression loopControlVariableExpression, object data);
-		object Visit(NamedArgumentExpression namedArgumentExpression, object data);
-		object Visit(AddressOfExpression addressOfExpression, object data);
-		object Visit(TypeOfExpression typeOfExpression, object data);
-		object Visit(ArrayCreateExpression arrayCreateExpression, object data);
-		
-	}
-}
+using System;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public interface IASTVisitor
+	{
+		// Abstract
+		object Visit(INode node, object data);
+		object Visit(CompilationUnit compilationUnit, object data);
+		
+		// Statements
+		object Visit(Statement statement, object data);
+		object Visit(StatementExpression statementExpression, object data);
+		object Visit(LocalVariableDeclaration localVariableDeclaration, object data);
+		object Visit(SimpleIfStatement ifStatement, object data);
+		object Visit(IfStatement ifStatement, object data);
+		object Visit(LabelStatement labelStatement, object data);
+		object Visit(GoToStatement goToStatement, object data);
+		object Visit(SelectStatement selectStatement, object data);
+		object Visit(StopStatement stopStatement, object data);
+		object Visit(ResumeStatement resumeStatement, object data);
+		object Visit(EraseStatement eraseStatement, object data);
+		object Visit(ErrorStatement errorStatement, object data);
+		object Visit(OnErrorStatement onErrorStatement, object data);
+		object Visit(ReDimStatement reDimStatement, object data);
+		object Visit(AddHandlerStatement addHandlerStatement, object data);
+		object Visit(BlockStatement blockStatement, object data);
+		object Visit(DoLoopStatement doLoopStatement, object data);
+		object Visit(EndStatement endStatement, object data);
+		object Visit(ExitStatement exitStatement, object data);
+		object Visit(ForeachStatement foreachStatement, object data);
+		object Visit(ForStatement forStatement, object data);
+		object Visit(LockStatement lockStatement, object data);
+		object Visit(RaiseEventStatement raiseEventStatement, object data);
+		object Visit(RemoveHandlerStatement removeHandlerStatement, object data);
+		object Visit(ReturnStatement returnStatement, object data);
+		object Visit(ThrowStatement throwStatement, object data);
+		object Visit(TryCatchStatement tryCatchStatement, object data);
+		object Visit(WhileStatement whileStatement, object data);
+		object Visit(WithStatement withStatement, object data);
+		
+		// Declarations
+		object Visit(VariableDeclaration variableDeclaration, object data);
+		object Visit(FieldDeclaration    fieldDeclaration, object data);
+		
+		object Visit(MethodDeclaration methodDeclaration, object data);
+		object Visit(ConstructorDeclaration constructorDeclaration, object data);
+		object Visit(DeclareDeclaration declareDeclaration, object data);
+		object Visit(PropertyDeclaration propertyDeclaration, object data);
+		object Visit(PropertyGetRegion propertyGetRegion, object data);
+		object Visit(PropertySetRegion PropertySetRegion, object data);
+		object Visit(EventDeclaration eventDeclaration, object data);
+		
+		// Global scope
+		object Visit(ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute, object data);
+		object Visit(AttributeSection attributeDeclaration, object data);
+		object Visit(DelegateDeclaration delegateDeclaration, object data);
+		object Visit(ImportsDeclaration importsAliasDeclaration, object data);
+		object Visit(ImportsAliasDeclaration importsAliasDeclaration, object data);
+		object Visit(ImportsStatement importsStatement, object data);
+		object Visit(NamespaceDeclaration namespaceDeclaration, object data);
+		object Visit(OptionCompareDeclaration optionCompareDeclaration, object data);
+		object Visit(OptionExplicitDeclaration optionExplicitDeclaration, object data);
+		object Visit(OptionStrictDeclaration optionStrictDeclaration, object data);
+		object Visit(TypeDeclaration typeDeclaration, object data);
+		object Visit(TypeReference typeReference, object data);
+		
+		// Expressions
+		object Visit(PrimitiveExpression      primitiveExpression, object data);
+		object Visit(BinaryOperatorExpression binaryOperatorExpression, object data);
+		object Visit(ParenthesizedExpression parenthesizedExpression, object data);
+		object Visit(InvocationExpression invocationExpression, object data);
+		object Visit(IdentifierExpression identifierExpression, object data);
+		object Visit(TypeReferenceExpression typeReferenceExpression, object data);
+		object Visit(UnaryOperatorExpression unaryOperatorExpression, object data);
+		object Visit(AssignmentExpression assignmentExpression, object data);
+		object Visit(CastExpression castExpression, object data);
+		object Visit(ThisReferenceExpression thisReferenceExpression, object data);
+		object Visit(BaseReferenceExpression baseReferenceExpression, object data);
+		object Visit(ObjectCreateExpression objectCreateExpression, object data);
+		object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data);
+		object Visit(FieldReferenceOrInvocationExpression fieldReferenceOrInvocationExpression, object data);
+		object Visit(ArrayInitializerExpression arrayInitializerExpression, object data);
+		object Visit(GetTypeExpression getTypeExpression, object data);
+		object Visit(ClassReferenceExpression classReferenceExpression, object data);
+		object Visit(LoopControlVariableExpression loopControlVariableExpression, object data);
+		object Visit(NamedArgumentExpression namedArgumentExpression, object data);
+		object Visit(AddressOfExpression addressOfExpression, object data);
+		object Visit(TypeOfExpression typeOfExpression, object data);
+		object Visit(ArrayCreateExpression arrayCreateExpression, object data);
+		
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/IASTVisitor.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,67 +1,67 @@
-// INode.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Drawing;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public interface INode
-	{
-		INode Parent { 
-			get;
-			set;
-		}
-		
-		Hashtable Specials {
-			get;
-		}
-		
-		ArrayList Children {
-			get;
-		}
-		
-		Point StartLocation {
-			get;
-			set;
-		}
-		
-		Point EndLocation {
-			get;
-			set;
-		}
-		
-		/// &lt;summary&gt;
-		/// Visits all children
-		/// &lt;/summary&gt;
-		/// &lt;param name=&quot;visitor&quot;&gt;The visitor to accept&lt;/param&gt;
-		/// &lt;param name=&quot;data&quot;&gt;Additional data for the visitor&lt;/param&gt;
-		/// &lt;returns&gt;The paremeter &lt;paramref name=&quot;data&quot;/&gt;&lt;/returns&gt;
-		object AcceptChildren(IASTVisitor visitor, object data);
-		
-		/// &lt;summary&gt;
-		/// Accept the visitor
-		/// &lt;/summary&gt;
-		/// &lt;param name=&quot;visitor&quot;&gt;The visitor to accept&lt;/param&gt;
-		/// &lt;param name=&quot;data&quot;&gt;Additional data for the visitor&lt;/param&gt;
-		/// &lt;returns&gt;The value the visitor returns after the visit&lt;/returns&gt;
-		object AcceptVisitor(IASTVisitor visitor, object data);
-	}
-}
+// INode.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public interface INode
+	{
+		INode Parent { 
+			get;
+			set;
+		}
+		
+		Hashtable Specials {
+			get;
+		}
+		
+		ArrayList Children {
+			get;
+		}
+		
+		Point StartLocation {
+			get;
+			set;
+		}
+		
+		Point EndLocation {
+			get;
+			set;
+		}
+		
+		/// &lt;summary&gt;
+		/// Visits all children
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;visitor&quot;&gt;The visitor to accept&lt;/param&gt;
+		/// &lt;param name=&quot;data&quot;&gt;Additional data for the visitor&lt;/param&gt;
+		/// &lt;returns&gt;The paremeter &lt;paramref name=&quot;data&quot;/&gt;&lt;/returns&gt;
+		object AcceptChildren(IASTVisitor visitor, object data);
+		
+		/// &lt;summary&gt;
+		/// Accept the visitor
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;visitor&quot;&gt;The visitor to accept&lt;/param&gt;
+		/// &lt;param name=&quot;data&quot;&gt;Additional data for the visitor&lt;/param&gt;
+		/// &lt;returns&gt;The value the visitor returns after the visit&lt;/returns&gt;
+		object AcceptVisitor(IASTVisitor visitor, object data);
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/INode.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,98 +1,98 @@
-using System;
-using System.Drawing;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class LocalLookupVariable
-	{
-		TypeReference typeRef;
-		Point         startPos;
-		Point         endPos;
-		
-		public TypeReference TypeRef {
-			get {
-				return typeRef;
-			}
-		}
-		public Point StartPos {
-			get {
-				return startPos;
-			}
-		}
-		public Point EndPos {
-			get {
-				return endPos;
-			}
-		}
-		
-		public LocalLookupVariable(TypeReference typeRef, Point startPos, Point endPos)
-		{
-			this.typeRef = typeRef;
-			this.startPos = startPos;
-			this.endPos = endPos;
-		}
-	}
-	
-	public class LookupTableVisitor : AbstractASTVisitor
-	{
-		Hashtable variables      = new Hashtable();
-		ArrayList withStatements = new ArrayList();
-		
-		public Hashtable Variables {
-			get {
-				return variables;
-			}
-		}
-		
-		public ArrayList WithStatements {
-			get {
-				return withStatements;
-			}
-		}
-		
-		public void AddVariable(TypeReference typeRef, string name, Point startPos, Point endPos)
-		{
-			if (name == null || name.Length == 0) {
-				return;
-			}
-			name = name.ToLower();
-			ArrayList list;
-			if (variables[name] == null) {
-				variables[name] = list = new ArrayList();
-			} else {
-				list = (ArrayList)variables[name];
-			}
-			list.Add(new LocalLookupVariable(typeRef, startPos, endPos));
-		}
-		
-		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
-		{
-			foreach (VariableDeclaration varDecl in localVariableDeclaration.Variables) {
-				AddVariable(varDecl.Type, 
-				            varDecl.Name,
-				            localVariableDeclaration.StartLocation,
-				            CurrentBlock == null ? new Point(-1, -1) : CurrentBlock.EndLocation);
-			}
-			return data;
-		}
-		
-		public override object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
-		{
-			AddVariable(loopControlVariableExpression.Type, 
-			            loopControlVariableExpression.Name,
-			            loopControlVariableExpression.StartLocation,
-			            CurrentBlock == null ? new Point(-1, -1) : CurrentBlock.EndLocation);
-			return data;
-		}
-		
-		public override object Visit(WithStatement withStatement, object data)
-		{
-			withStatements.Add(withStatement);
-			return base.Visit(withStatement, data);
-		}
-		
-	}
-}
+using System;
+using System.Drawing;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class LocalLookupVariable
+	{
+		TypeReference typeRef;
+		Point         startPos;
+		Point         endPos;
+		
+		public TypeReference TypeRef {
+			get {
+				return typeRef;
+			}
+		}
+		public Point StartPos {
+			get {
+				return startPos;
+			}
+		}
+		public Point EndPos {
+			get {
+				return endPos;
+			}
+		}
+		
+		public LocalLookupVariable(TypeReference typeRef, Point startPos, Point endPos)
+		{
+			this.typeRef = typeRef;
+			this.startPos = startPos;
+			this.endPos = endPos;
+		}
+	}
+	
+	public class LookupTableVisitor : AbstractASTVisitor
+	{
+		Hashtable variables      = new Hashtable();
+		ArrayList withStatements = new ArrayList();
+		
+		public Hashtable Variables {
+			get {
+				return variables;
+			}
+		}
+		
+		public ArrayList WithStatements {
+			get {
+				return withStatements;
+			}
+		}
+		
+		public void AddVariable(TypeReference typeRef, string name, Point startPos, Point endPos)
+		{
+			if (name == null || name.Length == 0) {
+				return;
+			}
+			name = name.ToLower();
+			ArrayList list;
+			if (variables[name] == null) {
+				variables[name] = list = new ArrayList();
+			} else {
+				list = (ArrayList)variables[name];
+			}
+			list.Add(new LocalLookupVariable(typeRef, startPos, endPos));
+		}
+		
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			foreach (VariableDeclaration varDecl in localVariableDeclaration.Variables) {
+				AddVariable(varDecl.Type, 
+				            varDecl.Name,
+				            localVariableDeclaration.StartLocation,
+				            CurrentBlock == null ? new Point(-1, -1) : CurrentBlock.EndLocation);
+			}
+			return data;
+		}
+		
+		public override object Visit(LoopControlVariableExpression loopControlVariableExpression, object data)
+		{
+			AddVariable(loopControlVariableExpression.Type, 
+			            loopControlVariableExpression.Name,
+			            loopControlVariableExpression.StartLocation,
+			            CurrentBlock == null ? new Point(-1, -1) : CurrentBlock.EndLocation);
+			return data;
+		}
+		
+		public override object Visit(WithStatement withStatement, object data)
+		{
+			withStatements.Add(withStatement);
+			return base.Visit(withStatement, data);
+		}
+		
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/LookupTableVisitor.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,74 +1,74 @@
-using System;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-
-	[Flags()]
-	public enum ParamModifier
-	{
-		None						= 0x0000,	// 0
-		ByVal						= 0x0001,	// 1
-		ByRef						= 0x0002,	// 2
-		ParamArray					= 0x0004,	// 4
-		Optional					= 0x0008,	// 8
-		All							= ByVal | ByRef | ParamArray | Optional
-	}
-
-	[Flags()]
-	public enum Modifier
-	{
-		None						= 0x0000,	// 0
-		
-		// Access
-		Private						= 0x0001,	// 1
-		Friend						= 0x0002,	// 2
-		Protected					= 0x0004,	// 4
-		Public						= 0x0008,	// 8
-		Dim							= 0x0010,	// 16
-		
-		// Scope
-		Shadows						= 0x000020,	// 32
-		Overloads					= 0x000040,	// 64
-		Overrides					= 0x000080,	// 128
-		NotOverridable				= 0x000100,	// 256
-		MustOverride				= 0x000200,	// 512
-		MustInherit					= 0x000400,	// 1024
-		NotInheritable				= 0x000800,	// 2048
-		Shared						= 0x001000,	// 4096
-		Overridable					= 0x002000,	// 8192
-		Constant					= 0x004000,
-		// Methods and properties
-		WithEvents					= 0x008000,
-		ReadOnly					= 0x010000,
-		WriteOnly					= 0x020000,
-		Default						= 0x040000,
-		
-		// local variables
-		Static						= 0x100000,
-		
-		All							= Private | Public | Protected  | Friend | Shadows | Constant |
-									  Overloads | Overrides | NotOverridable | MustOverride |
-									  MustInherit | NotInheritable | Shared | Overridable |
-									  WithEvents | ReadOnly | WriteOnly | Default | Dim,
-		
-		Classes						= Private | Public | Protected | Friend | Shadows | MustInherit | NotInheritable,
-		Structures					= Private | Public | Protected | Friend | Shadows,
-		Enums						= Private | Public | Protected | Friend | Shadows,
-		Modules						= Private | Public | Protected | Friend,
-		Interfaces					= Private | Public | Protected | Friend | Shadows,
-		Delegates					= Private | Public | Protected | Friend | Shadows,
-		Methods						= Private | Public | Protected | Friend | Shadows | Shared | Overridable | NotOverridable | MustOverride | Overrides | Overloads,
-		ExternalMethods				= Private | Public | Protected | Friend | Shadows | Overloads,
-		Constructors				= Private | Public | Protected | Friend | Shared,
-		Events						= Private | Public | Protected | Friend | Shadows | Shared,
-		Constants					= Private | Public | Protected | Friend | Shadows,
-		Fields						= Private | Public | Protected | Friend | Shadows | Shared | ReadOnly | WithEvents | Dim ,
-		Properties					= Private | Public | Protected | Friend | Shadows | Shared | Overridable | NotOverridable | MustOverride | Overrides | Overloads | Default | ReadOnly | WriteOnly,
-		
-		// this is not documented in the spec
-		InterfaceEvents				= Shadows,
-		InterfaceMethods			= Shadows | Overloads,
-		InterfaceProperties			= Shadows | Overloads | ReadOnly | WriteOnly | Default,
-		InterfaceEnums				= Shadows,
-	}
-}
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+
+	[Flags()]
+	public enum ParamModifier
+	{
+		None						= 0x0000,	// 0
+		ByVal						= 0x0001,	// 1
+		ByRef						= 0x0002,	// 2
+		ParamArray					= 0x0004,	// 4
+		Optional					= 0x0008,	// 8
+		All							= ByVal | ByRef | ParamArray | Optional
+	}
+
+	[Flags()]
+	public enum Modifier
+	{
+		None						= 0x0000,	// 0
+		
+		// Access
+		Private						= 0x0001,	// 1
+		Friend						= 0x0002,	// 2
+		Protected					= 0x0004,	// 4
+		Public						= 0x0008,	// 8
+		Dim							= 0x0010,	// 16
+		
+		// Scope
+		Shadows						= 0x000020,	// 32
+		Overloads					= 0x000040,	// 64
+		Overrides					= 0x000080,	// 128
+		NotOverridable				= 0x000100,	// 256
+		MustOverride				= 0x000200,	// 512
+		MustInherit					= 0x000400,	// 1024
+		NotInheritable				= 0x000800,	// 2048
+		Shared						= 0x001000,	// 4096
+		Overridable					= 0x002000,	// 8192
+		Constant					= 0x004000,
+		// Methods and properties
+		WithEvents					= 0x008000,
+		ReadOnly					= 0x010000,
+		WriteOnly					= 0x020000,
+		Default						= 0x040000,
+		
+		// local variables
+		Static						= 0x100000,
+		
+		All							= Private | Public | Protected  | Friend | Shadows | Constant |
+									  Overloads | Overrides | NotOverridable | MustOverride |
+									  MustInherit | NotInheritable | Shared | Overridable |
+									  WithEvents | ReadOnly | WriteOnly | Default | Dim,
+		
+		Classes						= Private | Public | Protected | Friend | Shadows | MustInherit | NotInheritable,
+		Structures					= Private | Public | Protected | Friend | Shadows,
+		Enums						= Private | Public | Protected | Friend | Shadows,
+		Modules						= Private | Public | Protected | Friend,
+		Interfaces					= Private | Public | Protected | Friend | Shadows,
+		Delegates					= Private | Public | Protected | Friend | Shadows,
+		Methods						= Private | Public | Protected | Friend | Shadows | Shared | Overridable | NotOverridable | MustOverride | Overrides | Overloads,
+		ExternalMethods				= Private | Public | Protected | Friend | Shadows | Overloads,
+		Constructors				= Private | Public | Protected | Friend | Shared,
+		Events						= Private | Public | Protected | Friend | Shadows | Shared,
+		Constants					= Private | Public | Protected | Friend | Shadows,
+		Fields						= Private | Public | Protected | Friend | Shadows | Shared | ReadOnly | WithEvents | Dim ,
+		Properties					= Private | Public | Protected | Friend | Shadows | Shared | Overridable | NotOverridable | MustOverride | Overrides | Overloads | Default | ReadOnly | WriteOnly,
+		
+		// this is not documented in the spec
+		InterfaceEvents				= Shadows,
+		InterfaceMethods			= Shadows | Overloads,
+		InterfaceProperties			= Shadows | Overloads | ReadOnly | WriteOnly | Default,
+		InterfaceEnums				= Shadows,
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Modifier.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,41 +1,41 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class AddHandlerStatement : Statement
-	{
-		Expression eventExpression;
-		Expression handlerExpression;
-		
-		public Expression EventExpression {
-			get {
-				return eventExpression;
-			}
-			set {
-				eventExpression = value;
-			}
-		}
-		public Expression HandlerExpression {
-			get {
-				return handlerExpression;
-			}
-			set {
-				handlerExpression = value;
-			}
-		}
-		
-		public AddHandlerStatement(Expression eventExpression, Expression handlerExpression)
-		{
-			this.eventExpression = eventExpression;
-			this.handlerExpression = handlerExpression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class AddHandlerStatement : Statement
+	{
+		Expression eventExpression;
+		Expression handlerExpression;
+		
+		public Expression EventExpression {
+			get {
+				return eventExpression;
+			}
+			set {
+				eventExpression = value;
+			}
+		}
+		public Expression HandlerExpression {
+			get {
+				return handlerExpression;
+			}
+			set {
+				handlerExpression = value;
+			}
+		}
+		
+		public AddHandlerStatement(Expression eventExpression, Expression handlerExpression)
+		{
+			this.eventExpression = eventExpression;
+			this.handlerExpression = handlerExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/AddHandlerStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,21 +1,21 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class BlockStatement : Statement
-	{
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[BlockStatement: Children={0}]&quot;, 
-			                     GetCollectionString(base.Children));
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class BlockStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BlockStatement: Children={0}]&quot;, 
+			                     GetCollectionString(base.Children));
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/BlockStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,64 +1,64 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class DoLoopStatement : Statement
-	{
-		Expression condition;
-		Statement  embeddedStatement;
-		ConditionType conditionType;
-		ConditionPosition conditionPosition;
-		
-		public ConditionPosition ConditionPosition {
-			get {
-				return conditionPosition;
-			}
-			set {
-				conditionPosition = value;
-			}
-		}
-		
-		public ConditionType ConditionType {
-			get {
-				return conditionType;
-			}
-			set {
-				conditionType = value;
-			}
-		}
-		
-		public Expression Condition {
-			get {
-				return condition;
-			}
-			set {
-				condition = value;
-			}
-		}
-		
-		public Statement EmbeddedStatement {
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public DoLoopStatement(Expression condition, Statement embeddedStatement, ConditionType conditionType, ConditionPosition conditionPosition)
-		{
-			this.condition = condition;
-			this.embeddedStatement = embeddedStatement;
-			this.conditionType = conditionType;
-			this.conditionPosition = conditionPosition;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class DoLoopStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		ConditionType conditionType;
+		ConditionPosition conditionPosition;
+		
+		public ConditionPosition ConditionPosition {
+			get {
+				return conditionPosition;
+			}
+			set {
+				conditionPosition = value;
+			}
+		}
+		
+		public ConditionType ConditionType {
+			get {
+				return conditionType;
+			}
+			set {
+				conditionType = value;
+			}
+		}
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public DoLoopStatement(Expression condition, Statement embeddedStatement, ConditionType conditionType, ConditionPosition conditionPosition)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+			this.conditionType = conditionType;
+			this.conditionPosition = conditionPosition;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/DoLoopStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,20 +1,20 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class EndStatement : Statement
-	{
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[EndStatement]&quot;);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class EndStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[EndStatement]&quot;);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EndStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,31 +1,31 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class EraseStatement : Statement
-	{
-		ArrayList expressions;
-		
-		public ArrayList Expressions
-		{
-			get {
-				return expressions;
-			} set {
-				expressions = value;
-			}
-		}
-		
-		public EraseStatement(ArrayList expressions)
-		{
-			this.expressions = expressions;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class EraseStatement : Statement
+	{
+		ArrayList expressions;
+		
+		public ArrayList Expressions
+		{
+			get {
+				return expressions;
+			} set {
+				expressions = value;
+			}
+		}
+		
+		public EraseStatement(ArrayList expressions)
+		{
+			this.expressions = expressions;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/EraseStatements.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,31 +1,31 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ErrorStatement : Statement
-	{
-		Expression expression;
-		
-		public ErrorStatement(Expression expression)
-		{
-			this.expression = expression;
-		}
-		
-		public Expression Expression
-		{
-			get {
-				return expression;
-			}set {
-				expression = value;
-			}
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ErrorStatement : Statement
+	{
+		Expression expression;
+		
+		public ErrorStatement(Expression expression)
+		{
+			this.expression = expression;
+		}
+		
+		public Expression Expression
+		{
+			get {
+				return expression;
+			}set {
+				expression = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ErrorStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,36 +1,36 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ExitStatement : Statement
-	{
-		ExitType exitType;
-		
-		public ExitType ExitType {
-			get {
-				return exitType;
-			}
-			set {
-				exitType = value;
-			}
-		}
-		
-		public ExitStatement(ExitType exitType)
-		{
-			this.exitType = exitType;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ExitStatement]&quot;);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ExitStatement : Statement
+	{
+		ExitType exitType;
+		
+		public ExitType ExitType {
+			get {
+				return exitType;
+			}
+			set {
+				exitType = value;
+			}
+		}
+		
+		public ExitStatement(ExitType exitType)
+		{
+			this.exitType = exitType;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ExitStatement]&quot;);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ExitStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,92 +1,92 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ForStatement : Statement
-	{
-		Expression start;
-		Expression end;
-		Expression step;
-		Statement embeddedStatement;
-		ArrayList nextExpressions;
-		LoopControlVariableExpression loopControlVariable;
-		
-		public LoopControlVariableExpression LoopControlVariable
-		{
-			get {
-				return loopControlVariable;
-			}
-			set {
-				loopControlVariable = value;
-			}
-		}
-		
-		public ArrayList NextExpressions
-		{
-			get {
-				return nextExpressions;
-			}
-			set {
-				nextExpressions = value;
-			}
-		}
-		
-		public Expression Start
-		{
-			get {
-				return start;
-			}
-			set {
-				start = value;
-			}
-		}
-		
-		public Expression End
-		{
-			get {
-				return end;
-			}
-			set {
-				end = value;
-			}
-		}
-		
-		public Expression Step
-		{
-			get {
-				return step;
-			}
-			set {
-				step = value;
-			}
-		}
-		
-		public Statement EmbeddedStatement
-		{
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public ForStatement(LoopControlVariableExpression loopControlVariable, Expression start, Expression end, Expression step, Statement embeddedStatement, ArrayList nextExpressions)
-		{
-			this.start = start;
-			this.nextExpressions = nextExpressions;
-			this.end = end;
-			this.step = step;
-			this.embeddedStatement = embeddedStatement;
-			this.loopControlVariable = loopControlVariable;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ForStatement : Statement
+	{
+		Expression start;
+		Expression end;
+		Expression step;
+		Statement embeddedStatement;
+		ArrayList nextExpressions;
+		LoopControlVariableExpression loopControlVariable;
+		
+		public LoopControlVariableExpression LoopControlVariable
+		{
+			get {
+				return loopControlVariable;
+			}
+			set {
+				loopControlVariable = value;
+			}
+		}
+		
+		public ArrayList NextExpressions
+		{
+			get {
+				return nextExpressions;
+			}
+			set {
+				nextExpressions = value;
+			}
+		}
+		
+		public Expression Start
+		{
+			get {
+				return start;
+			}
+			set {
+				start = value;
+			}
+		}
+		
+		public Expression End
+		{
+			get {
+				return end;
+			}
+			set {
+				end = value;
+			}
+		}
+		
+		public Expression Step
+		{
+			get {
+				return step;
+			}
+			set {
+				step = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public ForStatement(LoopControlVariableExpression loopControlVariable, Expression start, Expression end, Expression step, Statement embeddedStatement, ArrayList nextExpressions)
+		{
+			this.start = start;
+			this.nextExpressions = nextExpressions;
+			this.end = end;
+			this.step = step;
+			this.embeddedStatement = embeddedStatement;
+			this.loopControlVariable = loopControlVariable;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,64 +1,64 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ForeachStatement : Statement
-	{
-		LoopControlVariableExpression loopControlVariable;
-		Expression    expression;
-		Statement     embeddedStatement;
-		Expression    element;
-		
-		public LoopControlVariableExpression LoopControlVariable
-		{
-			get {
-				return loopControlVariable;
-			}
-			set {
-				loopControlVariable = value;
-			}
-		}
-		
-		public Expression Element {
-			get {
-				return element;
-			}
-			set {
-				element = value;
-			}
-		}
-		
-		public Expression Expression {
-			get {
-				return expression;
-			}
-			set {
-				expression = value;
-			}
-		}
-		
-		public Statement EmbeddedStatement {
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public ForeachStatement(LoopControlVariableExpression loopControlVariable , Expression expression, Statement embeddedStatement, Expression element)
-		{
-			this.loopControlVariable = loopControlVariable;
-			this.expression        = expression;
-			this.embeddedStatement = embeddedStatement;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ForeachStatement : Statement
+	{
+		LoopControlVariableExpression loopControlVariable;
+		Expression    expression;
+		Statement     embeddedStatement;
+		Expression    element;
+		
+		public LoopControlVariableExpression LoopControlVariable
+		{
+			get {
+				return loopControlVariable;
+			}
+			set {
+				loopControlVariable = value;
+			}
+		}
+		
+		public Expression Element {
+			get {
+				return element;
+			}
+			set {
+				element = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public ForeachStatement(LoopControlVariableExpression loopControlVariable , Expression expression, Statement embeddedStatement, Expression element)
+		{
+			this.loopControlVariable = loopControlVariable;
+			this.expression        = expression;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ForeachStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,32 +1,32 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class GoToStatement : Statement
-	{
-		string labelName;
-		
-		public string LabelName
-		{
-			get {
-				return labelName;
-			}
-			set {
-				labelName = value;
-			}
-		}
-		
-		public GoToStatement(string labelName)
-		{
-			this.labelName = labelName;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class GoToStatement : Statement
+	{
+		string labelName;
+		
+		public string LabelName
+		{
+			get {
+				return labelName;
+			}
+			set {
+				labelName = value;
+			}
+		}
+		
+		public GoToStatement(string labelName)
+		{
+			this.labelName = labelName;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/GoToStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,147 +1,147 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB 
-{
-	public class IfStatement : Statement
-	{
-		Expression condition;
-		Statement  embeddedElseStatement;
-		Statement  embeddedStatement;
-		ArrayList elseIfStatements;
-		
-		public ArrayList ElseIfStatements
-		{
-			get {
-				return elseIfStatements;
-			}
-			set {
-				elseIfStatements = value;
-			}
-		}
-		
-		public Statement EmbeddedElseStatement
-		{
-			get {
-				return embeddedElseStatement;
-			}
-			set {
-				embeddedElseStatement = value;
-			}
-		}
-		
-		public Expression Condition
-		{
-			get {
-				return condition;
-			}
-			set {
-				condition = value;
-			}
-		}
-		
-		public Statement EmbeddedStatement
-		{
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public IfStatement(Expression condition, Statement embeddedStatement)
-		{
-			this.condition = condition;
-			this.embeddedStatement = embeddedStatement;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-	
-	public class ElseIfSection : Statement
-	{
-		Expression condition;
-		Statement  embeddedStatement;
-		
-		public Expression Condition
-		{
-			get {
-				return condition;
-			}
-			set {
-				condition = value;
-			}
-		}
-		public Statement EmbeddedStatement
-		{
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public ElseIfSection(Expression condition, Statement embeddedStatement)
-		{
-			this.condition = condition;
-			this.embeddedStatement = embeddedStatement;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-	
-	public class SimpleIfStatement : Statement
-	{
-		Expression condition;
-		ArrayList statements;
-		ArrayList elseStatements;
-		
-		public ArrayList ElseStatements
-		{
-			get {
-				return elseStatements;
-			}
-			set {
-				elseStatements = value;
-			}
-		}
-		
-		public Expression Condition {
-			get {
-				return condition;
-			}
-			set {
-				condition = value;
-			}
-		}
-		public ArrayList Statements {
-			get {
-				return statements;
-			}
-			set {
-				statements = value;
-			}
-		}
-		
-		public SimpleIfStatement(Expression condition)
-		{
-			this.condition = condition;
-		}
-	
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
-
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB 
+{
+	public class IfStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedElseStatement;
+		Statement  embeddedStatement;
+		ArrayList elseIfStatements;
+		
+		public ArrayList ElseIfStatements
+		{
+			get {
+				return elseIfStatements;
+			}
+			set {
+				elseIfStatements = value;
+			}
+		}
+		
+		public Statement EmbeddedElseStatement
+		{
+			get {
+				return embeddedElseStatement;
+			}
+			set {
+				embeddedElseStatement = value;
+			}
+		}
+		
+		public Expression Condition
+		{
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public IfStatement(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class ElseIfSection : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		
+		public Expression Condition
+		{
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public ElseIfSection(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class SimpleIfStatement : Statement
+	{
+		Expression condition;
+		ArrayList statements;
+		ArrayList elseStatements;
+		
+		public ArrayList ElseStatements
+		{
+			get {
+				return elseStatements;
+			}
+			set {
+				elseStatements = value;
+			}
+		}
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		public ArrayList Statements {
+			get {
+				return statements;
+			}
+			set {
+				statements = value;
+			}
+		}
+		
+		public SimpleIfStatement(Expression condition)
+		{
+			this.condition = condition;
+		}
+	
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}
+


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/IfStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class LabelStatement : Statement
-	{
-		string label;
-		Statement embeddedStatement;
-		
-		public Statement EmbeddedStatement
-		{
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public string Label {
-			get {
-				return label;
-			}
-			set {
-				label = value;
-			}
-		}
-		
-		public LabelStatement(string label)
-		{
-			this.label = label;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[LabelStatement: Label={0}]&quot;,
-			                     label);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class LabelStatement : Statement
+	{
+		string label;
+		Statement embeddedStatement;
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public string Label {
+			get {
+				return label;
+			}
+			set {
+				label = value;
+			}
+		}
+		
+		public LabelStatement(string label)
+		{
+			this.label = label;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LabelStatement: Label={0}]&quot;,
+			                     label);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LabelStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,67 +1,67 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class LocalVariableDeclaration : Statement
-	{
-		Modifier      modifier = Modifier.None;
-		ArrayList     variables = new ArrayList(); // [VariableDeclaration]
-		INode block;
-		
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		
-		public ArrayList Variables {
-			get {
-				return variables;
-			} set {
-				variables = value;
-			}
-		}
-		
-		public INode Block {
-			get {
-				return block;
-			}
-			set {
-				block = value;
-			}
-		}
-		
-		public LocalVariableDeclaration(Modifier modifier)
-		{
-			this.modifier = modifier;
-		}
-		
-		public VariableDeclaration GetVariableDeclaration(string variableName)
-		{
-			foreach (VariableDeclaration variableDeclaration in variables) {
-				if (variableDeclaration.Name == variableName) {
-					return variableDeclaration;
-				}
-			}
-			return null;
-		}
-				
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[LocalVariableDeclaration: Modifier ={0} Variables={1}]&quot;, 
-			                     modifier, 
-			                     GetCollectionString(variables));
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class LocalVariableDeclaration : Statement
+	{
+		Modifier      modifier = Modifier.None;
+		ArrayList     variables = new ArrayList(); // [VariableDeclaration]
+		INode block;
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Variables {
+			get {
+				return variables;
+			} set {
+				variables = value;
+			}
+		}
+		
+		public INode Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public LocalVariableDeclaration(Modifier modifier)
+		{
+			this.modifier = modifier;
+		}
+		
+		public VariableDeclaration GetVariableDeclaration(string variableName)
+		{
+			foreach (VariableDeclaration variableDeclaration in variables) {
+				if (variableDeclaration.Name == variableName) {
+					return variableDeclaration;
+				}
+			}
+			return null;
+		}
+				
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LocalVariableDeclaration: Modifier ={0} Variables={1}]&quot;, 
+			                     modifier, 
+			                     GetCollectionString(variables));
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LocalVariableDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,46 +1,46 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class LockStatement : Statement
-	{
-		Expression lockExpression;
-		Statement  embeddedStatement;
-		
-		public Expression LockExpression {
-			get {
-				return lockExpression;
-			}
-			set {
-				lockExpression = value;
-			}
-		}
-		public Statement EmbeddedStatement {
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		public LockStatement(Expression lockExpression, Statement embeddedStatement)
-		{
-			this.lockExpression = lockExpression;
-			this.embeddedStatement = embeddedStatement;
-		}
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[LockStatement: LockExpression={0}, EmbeddedStatement={1}]&quot;, 
-			                     lockExpression,
-			                     embeddedStatement);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class LockStatement : Statement
+	{
+		Expression lockExpression;
+		Statement  embeddedStatement;
+		
+		public Expression LockExpression {
+			get {
+				return lockExpression;
+			}
+			set {
+				lockExpression = value;
+			}
+		}
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		public LockStatement(Expression lockExpression, Statement embeddedStatement)
+		{
+			this.lockExpression = lockExpression;
+			this.embeddedStatement = embeddedStatement;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LockStatement: LockExpression={0}, EmbeddedStatement={1}]&quot;, 
+			                     lockExpression,
+			                     embeddedStatement);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/LockStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,32 +1,32 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class OnErrorStatement : Statement
-	{
-		Statement embeddedStatement;
-		
-		public Statement EmbeddedStatement
-		{
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public OnErrorStatement(Statement embeddedStatement)
-		{
-			this.embeddedStatement = embeddedStatement;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class OnErrorStatement : Statement
+	{
+		Statement embeddedStatement;
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public OnErrorStatement(Statement embeddedStatement)
+		{
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/OnErrorStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,47 +1,47 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class RaiseEventStatement : Statement
-	{
-		string eventName;
-		ArrayList parameters;
-		
-		public string EventName {
-			get {
-				return eventName;
-			}
-			set {
-				eventName = value;
-			}
-		}
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public RaiseEventStatement(string eventName, ArrayList parameters)
-		{
-			this.eventName = eventName;
-			this.parameters = parameters;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return  String.Format(&quot;[RaiseEventStatement: EventName={0}]&quot;, 
-			                     EventName);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class RaiseEventStatement : Statement
+	{
+		string eventName;
+		ArrayList parameters;
+		
+		public string EventName {
+			get {
+				return eventName;
+			}
+			set {
+				eventName = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public RaiseEventStatement(string eventName, ArrayList parameters)
+		{
+			this.eventName = eventName;
+			this.parameters = parameters;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return  String.Format(&quot;[RaiseEventStatement: EventName={0}]&quot;, 
+			                     EventName);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RaiseEventStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,31 +1,31 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ReDimStatement : Statement
-	{
-		ArrayList reDimClauses;
-		
-		public ArrayList ReDimClauses
-		{
-			get {
-				return reDimClauses;
-			} set {
-				reDimClauses = value;
-			}
-		}
-		
-		public ReDimStatement(ArrayList reDimClauses)
-		{
-			this.reDimClauses = reDimClauses;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ReDimStatement : Statement
+	{
+		ArrayList reDimClauses;
+		
+		public ArrayList ReDimClauses
+		{
+			get {
+				return reDimClauses;
+			} set {
+				reDimClauses = value;
+			}
+		}
+		
+		public ReDimStatement(ArrayList reDimClauses)
+		{
+			this.reDimClauses = reDimClauses;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReDimStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,41 +1,41 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class RemoveHandlerStatement : Statement
-	{
-		Expression eventExpression;
-		Expression handlerExpression;
-		
-		public Expression EventExpression {
-			get {
-				return eventExpression;
-			}
-			set {
-				eventExpression = value;
-			}
-		}
-		public Expression HandlerExpression {
-			get {
-				return handlerExpression;
-			}
-			set {
-				handlerExpression = value;
-			}
-		}
-		
-		public RemoveHandlerStatement(Expression eventExpression, Expression handlerExpression)
-		{
-			this.eventExpression = eventExpression;
-			this.handlerExpression = handlerExpression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class RemoveHandlerStatement : Statement
+	{
+		Expression eventExpression;
+		Expression handlerExpression;
+		
+		public Expression EventExpression {
+			get {
+				return eventExpression;
+			}
+			set {
+				eventExpression = value;
+			}
+		}
+		public Expression HandlerExpression {
+			get {
+				return handlerExpression;
+			}
+			set {
+				handlerExpression = value;
+			}
+		}
+		
+		public RemoveHandlerStatement(Expression eventExpression, Expression handlerExpression)
+		{
+			this.eventExpression = eventExpression;
+			this.handlerExpression = handlerExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/RemoveHandlerStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ResumeStatement : Statement
-	{
-		string labelName;
-		bool next;
-		
-		public string LabelName
-		{
-			get {
-				return labelName;
-			}
-			set {
-				labelName = value;
-			}
-		}
-		
-		public bool Next
-		{
-			get {
-				return next;
-			}
-			set {
-				next = value;
-			}
-		}
-		
-		public ResumeStatement(bool next)
-		{
-			this.next = next;
-		}
-		
-		public ResumeStatement(string labelName)
-		{
-			this.labelName = labelName;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ResumeStatement : Statement
+	{
+		string labelName;
+		bool next;
+		
+		public string LabelName
+		{
+			get {
+				return labelName;
+			}
+			set {
+				labelName = value;
+			}
+		}
+		
+		public bool Next
+		{
+			get {
+				return next;
+			}
+			set {
+				next = value;
+			}
+		}
+		
+		public ResumeStatement(bool next)
+		{
+			this.next = next;
+		}
+		
+		public ResumeStatement(string labelName)
+		{
+			this.labelName = labelName;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ResumeStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,37 +1,37 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ReturnStatement : Statement
-	{
-		Expression returnExpression;
-		
-		public Expression ReturnExpression {
-			get {
-				return returnExpression;
-			}
-			set {
-				returnExpression = value;
-			}
-		}
-		
-		public ReturnStatement(Expression returnExpression)
-		{
-			this.returnExpression = returnExpression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ReturnStatement: ReturnExpression={0}]&quot;, 
-			                     returnExpression);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ReturnStatement : Statement
+	{
+		Expression returnExpression;
+		
+		public Expression ReturnExpression {
+			get {
+				return returnExpression;
+			}
+			set {
+				returnExpression = value;
+			}
+		}
+		
+		public ReturnStatement(Expression returnExpression)
+		{
+			this.returnExpression = returnExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ReturnStatement: ReturnExpression={0}]&quot;, 
+			                     returnExpression);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ReturnStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,144 +1,144 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class SelectStatement : Statement
-	{
-		Expression selectExpression;
-		ArrayList  selectSections  = new ArrayList();
-		
-		public Expression SelectExpression {
-			get {
-				return selectExpression;
-			}
-			set {
-				selectExpression = value;
-			}
-		}
-		
-		public ArrayList SelectSections
-		{
-			get {
-				return selectSections;
-			}
-			set {
-				selectSections = value;
-			}
-		}
-		
-		public SelectStatement(Expression selectExpression, ArrayList selectSections)
-		{
-			this.selectExpression = selectExpression;
-			this.selectSections = selectSections;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-	
-	public class SelectSection : Statement
-	{
-		ArrayList caseClauses = new ArrayList();
-		Statement embeddedStatement;
-		
-		public ArrayList CaseClauses
-		{
-			get {
-				return caseClauses;
-			}
-			set {
-				caseClauses = value;
-			}
-		}
-		
-		public Statement EmbeddedStatement
-		{
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-	
-	public class CaseClause : AbstractNode
-	{
-		BinaryOperatorType comparisonOperator = BinaryOperatorType.None;
-		Expression comparisonExpression;
-		Expression boundaryExpression;
-		bool isDefaultCase = false;
-		
-		public bool IsDefaultCase
-		{
-			get {
-				return isDefaultCase;
-			}
-			set {
-				isDefaultCase = value;
-			}
-		}
-		
-		public BinaryOperatorType ComparisonOperator
-		{
-			get {
-				return comparisonOperator;
-			}
-			set {
-				comparisonOperator = value;
-			}
-		}
-		
-		public Expression ComparisonExpression
-		{
-			get {
-				return comparisonExpression;
-			}
-			set {
-				comparisonExpression = value;
-			}
-		}
-		
-		public Expression BoundaryExpression
-		{
-			get {
-				return boundaryExpression;
-			}
-			set {
-				boundaryExpression = value;
-			}
-		}
-		
-		public CaseClause(bool isDefaultCase)
-		{
-			this.isDefaultCase = isDefaultCase;
-		}
-		
-		public CaseClause(Expression comparisonExpression, Expression boundaryExpression)
-		{
-			this.boundaryExpression = boundaryExpression;
-			this.comparisonExpression = comparisonExpression;
-		}
-		
-		public CaseClause(BinaryOperatorType comparisonOperator, Expression comparisonExpression)
-		{
-			this.comparisonOperator = comparisonOperator;
-			this.comparisonExpression = comparisonExpression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class SelectStatement : Statement
+	{
+		Expression selectExpression;
+		ArrayList  selectSections  = new ArrayList();
+		
+		public Expression SelectExpression {
+			get {
+				return selectExpression;
+			}
+			set {
+				selectExpression = value;
+			}
+		}
+		
+		public ArrayList SelectSections
+		{
+			get {
+				return selectSections;
+			}
+			set {
+				selectSections = value;
+			}
+		}
+		
+		public SelectStatement(Expression selectExpression, ArrayList selectSections)
+		{
+			this.selectExpression = selectExpression;
+			this.selectSections = selectSections;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class SelectSection : Statement
+	{
+		ArrayList caseClauses = new ArrayList();
+		Statement embeddedStatement;
+		
+		public ArrayList CaseClauses
+		{
+			get {
+				return caseClauses;
+			}
+			set {
+				caseClauses = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement
+		{
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class CaseClause : AbstractNode
+	{
+		BinaryOperatorType comparisonOperator = BinaryOperatorType.None;
+		Expression comparisonExpression;
+		Expression boundaryExpression;
+		bool isDefaultCase = false;
+		
+		public bool IsDefaultCase
+		{
+			get {
+				return isDefaultCase;
+			}
+			set {
+				isDefaultCase = value;
+			}
+		}
+		
+		public BinaryOperatorType ComparisonOperator
+		{
+			get {
+				return comparisonOperator;
+			}
+			set {
+				comparisonOperator = value;
+			}
+		}
+		
+		public Expression ComparisonExpression
+		{
+			get {
+				return comparisonExpression;
+			}
+			set {
+				comparisonExpression = value;
+			}
+		}
+		
+		public Expression BoundaryExpression
+		{
+			get {
+				return boundaryExpression;
+			}
+			set {
+				boundaryExpression = value;
+			}
+		}
+		
+		public CaseClause(bool isDefaultCase)
+		{
+			this.isDefaultCase = isDefaultCase;
+		}
+		
+		public CaseClause(Expression comparisonExpression, Expression boundaryExpression)
+		{
+			this.boundaryExpression = boundaryExpression;
+			this.comparisonExpression = comparisonExpression;
+		}
+		
+		public CaseClause(BinaryOperatorType comparisonOperator, Expression comparisonExpression)
+		{
+			this.comparisonOperator = comparisonOperator;
+			this.comparisonExpression = comparisonExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/SelectStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,28 +1,28 @@
-// Statement.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class Statement : AbstractNode
-	{
-	}
-}
+// Statement.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class Statement : AbstractNode
+	{
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/Statement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,20 +1,20 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class StopStatement : Statement
-	{
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[StopStatement]&quot;);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class StopStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[StopStatement]&quot;);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/StopStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,37 +1,37 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ThrowStatement : Statement
-	{
-		Expression throwExpression;
-		
-		public Expression ThrowExpression {
-			get {
-				return throwExpression;
-			}
-			set {
-				throwExpression = value;
-			}
-		}
-		
-		public ThrowStatement(Expression throwExpression)
-		{
-			this.throwExpression = throwExpression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[ThrowStatement: ThrowExpression={0}]&quot;, 
-			                     throwExpression);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ThrowStatement : Statement
+	{
+		Expression throwExpression;
+		
+		public Expression ThrowExpression {
+			get {
+				return throwExpression;
+			}
+			set {
+				throwExpression = value;
+			}
+		}
+		
+		public ThrowStatement(Expression throwExpression)
+		{
+			this.throwExpression = throwExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ThrowStatement: ThrowExpression={0}]&quot;, 
+			                     throwExpression);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/ThrowStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,135 +1,135 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class TryCatchStatement : Statement
-	{
-		Statement statementBlock;
-		ArrayList catchClauses;
-		Statement finallyBlock;
-		
-		public Statement StatementBlock {
-			get {
-				return statementBlock;
-			}
-			set {
-				statementBlock = value;
-			}
-		}
-		
-		public ArrayList CatchClauses {
-			get {
-				return catchClauses;
-			}
-			set {
-				catchClauses = value;
-			}
-		}
-		
-		public Statement FinallyBlock {
-			get {
-				return finallyBlock;
-			}
-			set {
-				finallyBlock = value;
-			}
-		}
-		
-		public TryCatchStatement(Statement statementBlock, ArrayList catchClauses, Statement finallyBlock)
-		{
-			this.statementBlock = statementBlock;
-			this.catchClauses = catchClauses;
-			this.finallyBlock = finallyBlock;
-		}
-		
-		public TryCatchStatement(Statement statementBlock, ArrayList catchClauses)
-		{
-			this.statementBlock = statementBlock;
-			this.catchClauses = catchClauses;
-			this.finallyBlock = null;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[TryCatchStatement: StatementBlock={0}, CatchClauses={1}, FinallyBlock={2}]&quot;,
-			                     statementBlock,
-			                     GetCollectionString(catchClauses),
-			                     finallyBlock);
-		}
-	}
-	
-	public class CatchClause
-	{
-		TypeReference type;
-		string variableName;
-		Statement       statementBlock;
-		Expression condition;
-		
-		public Expression Condition {
-			get {
-				return condition;
-			}
-			set {
-				condition = value;
-			}
-		}
-		
-		public TypeReference Type {
-			get {
-				return type;
-			}
-			set {
-				type = value;
-			}
-		}
-		
-		public string VariableName {
-			get {
-				return variableName;
-			}
-			set {
-				variableName = value;
-			}
-		}
-		
-		public Statement StatementBlock {
-			get {
-				return statementBlock;
-			}
-			set {
-				statementBlock = value;
-			}
-		}
-		
-		public CatchClause(TypeReference type, string variableName, Statement statementBlock, Expression condition)
-		{
-			this.type = type;
-			this.variableName = variableName;
-			this.statementBlock = statementBlock;
-			this.condition = condition;
-		}
-		
-		public CatchClause(Statement statementBlock)
-		{
-			this.type         = null;
-			this.variableName = null;
-			this.statementBlock = statementBlock;
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[CatchClause: Type={0}, VariableName={1}, StatementBlock={2}]&quot;, 
-			                     type,
-			                     variableName,
-			                     statementBlock);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TryCatchStatement : Statement
+	{
+		Statement statementBlock;
+		ArrayList catchClauses;
+		Statement finallyBlock;
+		
+		public Statement StatementBlock {
+			get {
+				return statementBlock;
+			}
+			set {
+				statementBlock = value;
+			}
+		}
+		
+		public ArrayList CatchClauses {
+			get {
+				return catchClauses;
+			}
+			set {
+				catchClauses = value;
+			}
+		}
+		
+		public Statement FinallyBlock {
+			get {
+				return finallyBlock;
+			}
+			set {
+				finallyBlock = value;
+			}
+		}
+		
+		public TryCatchStatement(Statement statementBlock, ArrayList catchClauses, Statement finallyBlock)
+		{
+			this.statementBlock = statementBlock;
+			this.catchClauses = catchClauses;
+			this.finallyBlock = finallyBlock;
+		}
+		
+		public TryCatchStatement(Statement statementBlock, ArrayList catchClauses)
+		{
+			this.statementBlock = statementBlock;
+			this.catchClauses = catchClauses;
+			this.finallyBlock = null;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TryCatchStatement: StatementBlock={0}, CatchClauses={1}, FinallyBlock={2}]&quot;,
+			                     statementBlock,
+			                     GetCollectionString(catchClauses),
+			                     finallyBlock);
+		}
+	}
+	
+	public class CatchClause
+	{
+		TypeReference type;
+		string variableName;
+		Statement       statementBlock;
+		Expression condition;
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public string VariableName {
+			get {
+				return variableName;
+			}
+			set {
+				variableName = value;
+			}
+		}
+		
+		public Statement StatementBlock {
+			get {
+				return statementBlock;
+			}
+			set {
+				statementBlock = value;
+			}
+		}
+		
+		public CatchClause(TypeReference type, string variableName, Statement statementBlock, Expression condition)
+		{
+			this.type = type;
+			this.variableName = variableName;
+			this.statementBlock = statementBlock;
+			this.condition = condition;
+		}
+		
+		public CatchClause(Statement statementBlock)
+		{
+			this.type         = null;
+			this.variableName = null;
+			this.statementBlock = statementBlock;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[CatchClause: Type={0}, VariableName={1}, StatementBlock={2}]&quot;, 
+			                     type,
+			                     variableName,
+			                     statementBlock);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/TryCatchStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,49 +1,49 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class WhileStatement : Statement
-	{
-		Expression condition;
-		Statement  embeddedStatement;
-		
-		public Expression Condition {
-			get {
-				return condition;
-			}
-			set {
-				condition = value;
-			}
-		}
-		
-		public Statement EmbeddedStatement {
-			get {
-				return embeddedStatement;
-			}
-			set {
-				embeddedStatement = value;
-			}
-		}
-		
-		public WhileStatement(Expression condition, Statement embeddedStatement)
-		{
-			this.condition = condition;
-			this.embeddedStatement = embeddedStatement;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[WhileStatement: Condition={0}, EmbeddedStatement={1}]&quot;, 
-			                     condition,
-			                     embeddedStatement);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class WhileStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public WhileStatement(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[WhileStatement: Condition={0}, EmbeddedStatement={1}]&quot;, 
+			                     condition,
+			                     embeddedStatement);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WhileStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,44 +1,44 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class WithStatement : Statement
-	{
-		Expression withExpression;
-		BlockStatement body = null;
-		
-		public Expression WithExpression {
-			get {
-				return withExpression;
-			}
-		}
-		
-		public BlockStatement Body {
-			get {
-				return body;
-			}
-			set {
-				body = value;
-			}
-		}
-		
-		public WithStatement(Expression withExpression)
-		{
-			this.withExpression = withExpression;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		public override string ToString()
-		{
-			return String.Format(&quot;[WithStatment: WidthExpression={0}, Body={1}]&quot;, 
-			                     withExpression,
-			                     body);
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class WithStatement : Statement
+	{
+		Expression withExpression;
+		BlockStatement body = null;
+		
+		public Expression WithExpression {
+			get {
+				return withExpression;
+			}
+		}
+		
+		public BlockStatement Body {
+			get {
+				return body;
+			}
+			set {
+				body = value;
+			}
+		}
+		
+		public WithStatement(Expression withExpression)
+		{
+			this.withExpression = withExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		public override string ToString()
+		{
+			return String.Format(&quot;[WithStatment: WidthExpression={0}, Body={1}]&quot;, 
+			                     withExpression,
+			                     body);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/Statements/WithStatement.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,92 +1,92 @@
-// ConstructorDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ConstructorDeclaration : AbstractNode
-	{
-		string          name;
-		Modifier modifier;
-		ArrayList       parameters = new ArrayList(); // [ParameterDeclarationExpression]
-		ArrayList       attributes = new ArrayList();
-		BlockStatement  blockStatement = null;
-		
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public BlockStatement Body {
-			get {
-				return blockStatement;
-			}
-			set {
-				blockStatement = value;
-			}
-		}
-		
-		public ConstructorDeclaration(string name, Modifier modifier, ArrayList parameters, ArrayList attributes)
-		{
-			this.name     = name;
-			this.modifier = modifier;
-			this.parameters = parameters;
-			this.attributes = attributes;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
-
+// ConstructorDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ConstructorDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		ArrayList       parameters = new ArrayList(); // [ParameterDeclarationExpression]
+		ArrayList       attributes = new ArrayList();
+		BlockStatement  blockStatement = null;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public BlockStatement Body {
+			get {
+				return blockStatement;
+			}
+			set {
+				blockStatement = value;
+			}
+		}
+		
+		public ConstructorDeclaration(string name, Modifier modifier, ArrayList parameters, ArrayList attributes)
+		{
+			this.name     = name;
+			this.modifier = modifier;
+			this.parameters = parameters;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}
+


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,127 +1,127 @@
-// DeclareDeclaration.cs
-// Copyright (C) 2003 Markus Palme (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">markuspalme at gmx.de</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class DeclareDeclaration : AbstractNode
-	{
-		string          name;
-		string          alias;
-		string          library;
-		CharsetModifier charset = CharsetModifier.None;
-		Modifier modifier;
-		TypeReference   returnType;
-		ArrayList       parameters;
-		ArrayList       attributes;
-		
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		
-		public TypeReference ReturnType {
-			get {
-				return returnType;
-			}
-			set {
-				returnType = value;
-			}
-		}
-		
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public CharsetModifier Charset
-		{
-			get {
-				return charset;
-			}
-			set {
-				charset = value;
-			}
-		}
-		
-		public string Alias
-		{
-			get {
-				return alias;
-			}
-			set {
-				alias = value;
-			}
-		}
-		
-		public string Library
-		{
-			get {
-				return library;
-			}
-			set {
-				library = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public DeclareDeclaration(string name, Modifier modifier, TypeReference returnType, ArrayList parameters, ArrayList attributes, string library, string alias, CharsetModifier charset)
-		{
-			this.name = name;
-			this.modifier = modifier;
-			this.returnType = returnType;
-			this.parameters = parameters;
-			this.attributes = attributes;
-			this.library = library;
-			this.alias = alias;
-			this.charset = charset;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// DeclareDeclaration.cs
+// Copyright (C) 2003 Markus Palme (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">markuspalme at gmx.de</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class DeclareDeclaration : AbstractNode
+	{
+		string          name;
+		string          alias;
+		string          library;
+		CharsetModifier charset = CharsetModifier.None;
+		Modifier modifier;
+		TypeReference   returnType;
+		ArrayList       parameters;
+		ArrayList       attributes;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference ReturnType {
+			get {
+				return returnType;
+			}
+			set {
+				returnType = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public CharsetModifier Charset
+		{
+			get {
+				return charset;
+			}
+			set {
+				charset = value;
+			}
+		}
+		
+		public string Alias
+		{
+			get {
+				return alias;
+			}
+			set {
+				alias = value;
+			}
+		}
+		
+		public string Library
+		{
+			get {
+				return library;
+			}
+			set {
+				library = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public DeclareDeclaration(string name, Modifier modifier, TypeReference returnType, ArrayList parameters, ArrayList attributes, string library, string alias, CharsetModifier charset)
+		{
+			this.name = name;
+			this.modifier = modifier;
+			this.returnType = returnType;
+			this.parameters = parameters;
+			this.attributes = attributes;
+			this.library = library;
+			this.alias = alias;
+			this.charset = charset;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/DeclareDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,117 +1,117 @@
-// EventDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Drawing;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class EventDeclaration : AbstractNode
-	{
-		TypeReference typeReference;
-		Modifier modifier;
-		ArrayList parameters;
-		ArrayList attributes;
-		string name;
-		ImplementsClause implementsClause;
-		
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		public ImplementsClause ImplementsClause {
-			get {
-				return implementsClause;
-			}
-			set {
-				implementsClause = value;
-			}
-		}
-		
-		public TypeReference TypeReference {
-			get {
-				return typeReference;
-			}
-			set {
-				typeReference = value;
-			}
-		}
-		
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		
-		
-		
-		public EventDeclaration(TypeReference typeReference, Modifier modifier, ArrayList parameters, ArrayList attributes, string name, ImplementsClause implementsClause)
-		{
-			this.typeReference = typeReference;
-			this.modifier = modifier;
-			this.parameters = parameters;
-			this.attributes = attributes;
-			this.name = name;
-			this.implementsClause = implementsClause;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[EventDeclaration: typeReference = {0}, modifier = {1}, parameters = {2}, attributes = {3}, name = {4}, implementsClause = {5}]&quot;,
-			                     typeReference,
-			                     modifier,
-			                     parameters,
-			                     attributes,
-			                     name,
-			                     implementsClause);
-		}
-		
-	}
-}
+// EventDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class EventDeclaration : AbstractNode
+	{
+		TypeReference typeReference;
+		Modifier modifier;
+		ArrayList parameters;
+		ArrayList attributes;
+		string name;
+		ImplementsClause implementsClause;
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		public ImplementsClause ImplementsClause {
+			get {
+				return implementsClause;
+			}
+			set {
+				implementsClause = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		
+		
+		public EventDeclaration(TypeReference typeReference, Modifier modifier, ArrayList parameters, ArrayList attributes, string name, ImplementsClause implementsClause)
+		{
+			this.typeReference = typeReference;
+			this.modifier = modifier;
+			this.parameters = parameters;
+			this.attributes = attributes;
+			this.name = name;
+			this.implementsClause = implementsClause;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[EventDeclaration: typeReference = {0}, modifier = {1}, parameters = {2}, attributes = {3}, name = {4}, implementsClause = {5}]&quot;,
+			                     typeReference,
+			                     modifier,
+			                     parameters,
+			                     attributes,
+			                     name,
+			                     implementsClause);
+		}
+		
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/EventDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,104 +1,104 @@
-// FieldDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class FieldDeclaration : AbstractNode
-	{
-		ArrayList       attributes = null;
-		TypeReference   typeReference = null;
-		Modifier        modifier;
-		ArrayList       fields = new ArrayList(); // [VariableDeclaration]
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		public TypeReference TypeReference {
-			get {
-				return typeReference;
-			}
-			set {
-				typeReference = value;
-			}
-		}
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		public ArrayList Fields {
-			get {
-				return fields;
-			}
-			set {
-				fields = value;
-			}
-		}
-		
-		// for enum members
-		public FieldDeclaration(ArrayList attributes)
-		{
-			this.attributes = attributes;
-		}
-		
-		// for all other cases
-		public FieldDeclaration(ArrayList attributes, TypeReference typeReference, Modifier modifier)
-		{
-			this.attributes    = attributes;
-			this.typeReference = typeReference;
-			this.modifier      = modifier;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public VariableDeclaration GetVariableDeclaration(string variableName)
-		{
-			foreach (VariableDeclaration variableDeclaration in Fields) {
-				if (variableDeclaration.Name == variableName) {
-					return variableDeclaration;
-				}
-			}
-			return null;
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[FieldDeclaration: attributes = {0}, typeReference = {1}, modifier = {2}, fields = {3}]&quot;,
-			                     attributes,
-			                     typeReference,
-			                     modifier,
-			                     GetCollectionString(fields));		
-		}
-		
-	}
-}
+// FieldDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class FieldDeclaration : AbstractNode
+	{
+		ArrayList       attributes = null;
+		TypeReference   typeReference = null;
+		Modifier        modifier;
+		ArrayList       fields = new ArrayList(); // [VariableDeclaration]
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		public ArrayList Fields {
+			get {
+				return fields;
+			}
+			set {
+				fields = value;
+			}
+		}
+		
+		// for enum members
+		public FieldDeclaration(ArrayList attributes)
+		{
+			this.attributes = attributes;
+		}
+		
+		// for all other cases
+		public FieldDeclaration(ArrayList attributes, TypeReference typeReference, Modifier modifier)
+		{
+			this.attributes    = attributes;
+			this.typeReference = typeReference;
+			this.modifier      = modifier;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public VariableDeclaration GetVariableDeclaration(string variableName)
+		{
+			foreach (VariableDeclaration variableDeclaration in Fields) {
+				if (variableDeclaration.Name == variableName) {
+					return variableDeclaration;
+				}
+			}
+			return null;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[FieldDeclaration: attributes = {0}, typeReference = {1}, modifier = {2}, fields = {3}]&quot;,
+			                     attributes,
+			                     typeReference,
+			                     modifier,
+			                     GetCollectionString(fields));		
+		}
+		
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/FieldDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,27 +1,27 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class HandlesClause : AbstractNode
-	{
-		ArrayList eventNames;
-		
-		public HandlesClause()
-		{
-			this.eventNames = new ArrayList();
-		}
-		
-		public ArrayList EventNames {
-			get {
-				return eventNames;
-			}
-			set {
-				eventNames = value;
-			}
-		}
-		
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class HandlesClause : AbstractNode
+	{
+		ArrayList eventNames;
+		
+		public HandlesClause()
+		{
+			this.eventNames = new ArrayList();
+		}
+		
+		public ArrayList EventNames {
+			get {
+				return eventNames;
+			}
+			set {
+				eventNames = value;
+			}
+		}
+		
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/HandlesClause.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,27 +1,27 @@
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class ImplementsClause : AbstractNode
-	{
-		ArrayList baseMembers;
-		
-		public ImplementsClause()
-		{
-			this.baseMembers = new ArrayList();
-		}
-		
-		public ArrayList BaseMembers
-		{
-			get {
-				return baseMembers;
-			}
-			set {
-				baseMembers = value;
-			}
-		}
-	}
-}
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class ImplementsClause : AbstractNode
+	{
+		ArrayList baseMembers;
+		
+		public ImplementsClause()
+		{
+			this.baseMembers = new ArrayList();
+		}
+		
+		public ArrayList BaseMembers
+		{
+			get {
+				return baseMembers;
+			}
+			set {
+				baseMembers = value;
+			}
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/ImplementsClause.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,127 +1,127 @@
-// MethodDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class MethodDeclaration : AbstractNode
-	{
-		string          name;
-		Modifier modifier;
-		TypeReference   typeReference;
-		ArrayList       parameters; // [ParameterDeclarationExpression]
-		ArrayList       attributes;
-		BlockStatement  body;
-		HandlesClause   handlesClause;
-		ImplementsClause implementsClause;
-		
-		public ImplementsClause ImplementsClause {
-			get {
-				return implementsClause;
-			}
-			set {
-				implementsClause = value;
-			}
-		}
-		
-		public HandlesClause HandlesClause {
-			get {
-				return handlesClause;
-			}
-			set {
-				handlesClause = value;
-			}
-		}
-		
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		
-		public BlockStatement Body {
-			get {
-				return body;
-			}
-			set {
-				body = value;
-			}
-		}
-		
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		
-		public TypeReference TypeReference {
-			get {
-				return typeReference;
-			}
-			set {
-				typeReference = value;
-			}
-		}
-		
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public MethodDeclaration(string name, Modifier modifier, TypeReference typeReference, ArrayList parameters, ArrayList attributes)
-		{
-			this.name = name;
-			this.modifier = modifier;
-			this.typeReference = typeReference;
-			this.parameters = parameters;
-			this.attributes = attributes;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[MethodDeclaration: Name={0}, Modifier={1}, TypeReference={2}]&quot;, name, modifier, typeReference);
-		}
-	}
-}
+// MethodDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class MethodDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		TypeReference   typeReference;
+		ArrayList       parameters; // [ParameterDeclarationExpression]
+		ArrayList       attributes;
+		BlockStatement  body;
+		HandlesClause   handlesClause;
+		ImplementsClause implementsClause;
+		
+		public ImplementsClause ImplementsClause {
+			get {
+				return implementsClause;
+			}
+			set {
+				implementsClause = value;
+			}
+		}
+		
+		public HandlesClause HandlesClause {
+			get {
+				return handlesClause;
+			}
+			set {
+				handlesClause = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public BlockStatement Body {
+			get {
+				return body;
+			}
+			set {
+				body = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public MethodDeclaration(string name, Modifier modifier, TypeReference typeReference, ArrayList parameters, ArrayList attributes)
+		{
+			this.name = name;
+			this.modifier = modifier;
+			this.typeReference = typeReference;
+			this.parameters = parameters;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[MethodDeclaration: Name={0}, Modifier={1}, TypeReference={2}]&quot;, name, modifier, typeReference);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/MethodDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,167 +1,167 @@
-// PropertyDeclaration.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Drawing;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class PropertyDeclaration : AbstractNode
-	{
-		string          name;
-		Modifier        modifier;
-		TypeReference   typeReference;
-		ArrayList       attributes;
-		ArrayList       parameters;
-		Point           bodyStart;
-		Point           bodyEnd;
-		ImplementsClause implementsClause;
-		
-		PropertyGetRegion  propertyGetRegion = null;
-		PropertySetRegion  propertySetRegion = null;
-		
-		public ImplementsClause ImplementsClause {
-			get {
-				return implementsClause;
-			}
-			set {
-				implementsClause = value;
-			}
-		}
-		
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		
-		public Modifier Modifier {
-			get {
-				return modifier;
-			}
-			set {
-				modifier = value;
-			}
-		}
-		
-		public TypeReference TypeReference {
-			get {
-				return typeReference;
-			}
-			set {
-				typeReference = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public PropertyGetRegion GetRegion {
-			get {
-				return propertyGetRegion;
-			}
-			set {
-				propertyGetRegion = value;
-			}
-		}
-		public PropertySetRegion SetRegion {
-			get {
-				return propertySetRegion;
-			}
-			set {
-				propertySetRegion = value;
-			}
-		}
-		
-		public bool HasGetRegion {
-			get {
-				return propertyGetRegion != null;
-			}
-		}
-		
-		public bool HasSetRegion {
-			get {
-				return propertySetRegion != null;
-			}
-		}
-		
-		public bool IsReadOnly {
-			get {
-				return HasGetRegion &amp;&amp; !HasSetRegion;
-			}
-		}
-		
-		public bool IsWriteOnly {
-			get {
-				return !HasGetRegion &amp;&amp; HasSetRegion;
-			}
-		}
-		
-		
-		public Point BodyStart {
-			get {
-				return bodyStart;
-			}
-			set {
-				bodyStart = value;
-			}
-		}
-		
-		public Point BodyEnd {
-			get {
-				return bodyEnd;
-			}
-			set {
-				bodyEnd = value;
-			}
-		}
-		
-		public PropertyDeclaration(string name, TypeReference typeReference, Modifier modifier, ArrayList attributes)
-		{
-			this.name = name;
-			this.typeReference = typeReference;
-			this.modifier = modifier;
-			this.attributes = attributes;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// PropertyDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class PropertyDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier        modifier;
+		TypeReference   typeReference;
+		ArrayList       attributes;
+		ArrayList       parameters;
+		Point           bodyStart;
+		Point           bodyEnd;
+		ImplementsClause implementsClause;
+		
+		PropertyGetRegion  propertyGetRegion = null;
+		PropertySetRegion  propertySetRegion = null;
+		
+		public ImplementsClause ImplementsClause {
+			get {
+				return implementsClause;
+			}
+			set {
+				implementsClause = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public PropertyGetRegion GetRegion {
+			get {
+				return propertyGetRegion;
+			}
+			set {
+				propertyGetRegion = value;
+			}
+		}
+		public PropertySetRegion SetRegion {
+			get {
+				return propertySetRegion;
+			}
+			set {
+				propertySetRegion = value;
+			}
+		}
+		
+		public bool HasGetRegion {
+			get {
+				return propertyGetRegion != null;
+			}
+		}
+		
+		public bool HasSetRegion {
+			get {
+				return propertySetRegion != null;
+			}
+		}
+		
+		public bool IsReadOnly {
+			get {
+				return HasGetRegion &amp;&amp; !HasSetRegion;
+			}
+		}
+		
+		public bool IsWriteOnly {
+			get {
+				return !HasGetRegion &amp;&amp; HasSetRegion;
+			}
+		}
+		
+		
+		public Point BodyStart {
+			get {
+				return bodyStart;
+			}
+			set {
+				bodyStart = value;
+			}
+		}
+		
+		public Point BodyEnd {
+			get {
+				return bodyEnd;
+			}
+			set {
+				bodyEnd = value;
+			}
+		}
+		
+		public PropertyDeclaration(string name, TypeReference typeReference, Modifier modifier, ArrayList attributes)
+		{
+			this.name = name;
+			this.typeReference = typeReference;
+			this.modifier = modifier;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,58 +1,58 @@
-// PropertyGetRegion.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class PropertyGetRegion : AbstractNode
-	{
-		BlockStatement block;
-		ArrayList      attributes;
-		
-		public BlockStatement Block {
-			get {
-				return block;
-			}
-			set {
-				block = value;
-			}
-		}
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public PropertyGetRegion(BlockStatement block, ArrayList attributes)
-		{
-			this.block = block;
-			this.attributes = attributes;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// PropertyGetRegion.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class PropertyGetRegion : AbstractNode
+	{
+		BlockStatement block;
+		ArrayList      attributes;
+		
+		public BlockStatement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public PropertyGetRegion(BlockStatement block, ArrayList attributes)
+		{
+			this.block = block;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertyGetRegion.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,69 +1,69 @@
-// PropertySetRegion.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class PropertySetRegion : AbstractNode
-	{
-		BlockStatement block;
-		ArrayList      attributes;
-		ArrayList       parameters;
-		
-		public BlockStatement Block {
-			get {
-				return block;
-			}
-			set {
-				block = value;
-			}
-		}
-		
-		public ArrayList Parameters {
-			get {
-				return parameters;
-			}
-			set {
-				parameters = value;
-			}
-		}
-		
-		public ArrayList Attributes {
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-			
-		public PropertySetRegion(BlockStatement block, ArrayList attributes)
-		{
-			this.block = block;
-			this.attributes = attributes;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-	}
-}
+// PropertySetRegion.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class PropertySetRegion : AbstractNode
+	{
+		BlockStatement block;
+		ArrayList      attributes;
+		ArrayList       parameters;
+		
+		public BlockStatement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+			
+		public PropertySetRegion(BlockStatement block, ArrayList attributes)
+		{
+			this.block = block;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/PropertySetRegion.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,139 +1,139 @@
-// TypeReference.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-using System.Text;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class TypeReference : AbstractNode
-	{
-		string type;
-		string systemType;
-		ArrayList rankSpecifier;
-		ArrayList dimension;
-		AttributeSection attributes = null;
-		
-		static Hashtable types = new Hashtable();
-		static TypeReference()
-		{
-			types.Add(&quot;boolean&quot;, &quot;System.Boolean&quot;);
-			types.Add(&quot;byte&quot;,    &quot;System.Byte&quot;);
-			types.Add(&quot;date&quot;,	 &quot;System.DateTime&quot;);
-			types.Add(&quot;char&quot;,    &quot;System.Char&quot;);
-			types.Add(&quot;decimal&quot;, &quot;System.Decimal&quot;);
-			types.Add(&quot;double&quot;,  &quot;System.Double&quot;);
-			types.Add(&quot;single&quot;,  &quot;System.Single&quot;);
-			types.Add(&quot;integer&quot;, &quot;System.Int32&quot;);
-			types.Add(&quot;long&quot;,    &quot;System.Int64&quot;);
-			types.Add(&quot;object&quot;,  &quot;System.Object&quot;);
-			types.Add(&quot;short&quot;,   &quot;System.Int16&quot;);
-			types.Add(&quot;string&quot;,  &quot;System.String&quot;);
-		}
-		
-		public AttributeSection Attributes
-		{
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
-		}
-		
-		public static ICollection PrimitiveTypes
-		{
-			get {
-				return types.Keys;
-			}
-		}
-		
-		public string Type
-		{
-			get {
-				return type;
-			}
-			set {
-				type = value;
-			}
-		}
-		
-		public string SystemType
-		{
-			get {
-				return systemType;
-			}
-		}
-		
-		public ArrayList RankSpecifier
-		{
-			get {
-				return rankSpecifier;
-			}
-			set {
-				rankSpecifier = value;
-			}
-		}
-		
-		public bool IsArrayType
-		{
-			get {
-				return rankSpecifier != null &amp;&amp; rankSpecifier.Count&gt; 0;
-			}
-		}
-		
-		public ArrayList Dimension
-		{
-			get {
-				return dimension;
-			}
-			set {
-				dimension = value;
-			}
-		}
-		
-		string GetSystemType(string type)
-		{
-			return (string)types[type.ToLower()];
-		}
-		
-		public TypeReference(string type)
-		{
-			this.systemType = GetSystemType(type);
-			this.type = type;
-		}
-		
-		public TypeReference(string type, ArrayList rankSpecifier)
-		{
-			this.type = type;
-			this.systemType = GetSystemType(type);
-			this.rankSpecifier = rankSpecifier;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[TypeReference: Type={0}, RankSpeifier={1}]&quot;, type, AbstractNode.GetCollectionString(rankSpecifier));
-		}
-	}
-}
+// TypeReference.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class TypeReference : AbstractNode
+	{
+		string type;
+		string systemType;
+		ArrayList rankSpecifier;
+		ArrayList dimension;
+		AttributeSection attributes = null;
+		
+		static Hashtable types = new Hashtable();
+		static TypeReference()
+		{
+			types.Add(&quot;boolean&quot;, &quot;System.Boolean&quot;);
+			types.Add(&quot;byte&quot;,    &quot;System.Byte&quot;);
+			types.Add(&quot;date&quot;,	 &quot;System.DateTime&quot;);
+			types.Add(&quot;char&quot;,    &quot;System.Char&quot;);
+			types.Add(&quot;decimal&quot;, &quot;System.Decimal&quot;);
+			types.Add(&quot;double&quot;,  &quot;System.Double&quot;);
+			types.Add(&quot;single&quot;,  &quot;System.Single&quot;);
+			types.Add(&quot;integer&quot;, &quot;System.Int32&quot;);
+			types.Add(&quot;long&quot;,    &quot;System.Int64&quot;);
+			types.Add(&quot;object&quot;,  &quot;System.Object&quot;);
+			types.Add(&quot;short&quot;,   &quot;System.Int16&quot;);
+			types.Add(&quot;string&quot;,  &quot;System.String&quot;);
+		}
+		
+		public AttributeSection Attributes
+		{
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public static ICollection PrimitiveTypes
+		{
+			get {
+				return types.Keys;
+			}
+		}
+		
+		public string Type
+		{
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public string SystemType
+		{
+			get {
+				return systemType;
+			}
+		}
+		
+		public ArrayList RankSpecifier
+		{
+			get {
+				return rankSpecifier;
+			}
+			set {
+				rankSpecifier = value;
+			}
+		}
+		
+		public bool IsArrayType
+		{
+			get {
+				return rankSpecifier != null &amp;&amp; rankSpecifier.Count&gt; 0;
+			}
+		}
+		
+		public ArrayList Dimension
+		{
+			get {
+				return dimension;
+			}
+			set {
+				dimension = value;
+			}
+		}
+		
+		string GetSystemType(string type)
+		{
+			return (string)types[type.ToLower()];
+		}
+		
+		public TypeReference(string type)
+		{
+			this.systemType = GetSystemType(type);
+			this.type = type;
+		}
+		
+		public TypeReference(string type, ArrayList rankSpecifier)
+		{
+			this.type = type;
+			this.systemType = GetSystemType(type);
+			this.rankSpecifier = rankSpecifier;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeReference: Type={0}, RankSpeifier={1}]&quot;, type, AbstractNode.GetCollectionString(rankSpecifier));
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/TypeReference.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,79 +1,79 @@
-// Field.cs
-// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
-// 
-// This program is free software; you can redistribute it and/or
-// modify it under the terms of the GNU General Public License
-// as published by the Free Software Foundation; either version 2
-// of the License, or (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-using System;
-using System.Collections;
-
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.AST.VB
-{
-	public class VariableDeclaration : AbstractNode
-	{
-		string     name;
-		Expression initializer = null;
-		TypeReference type;
-		
-		public TypeReference Type {
-			get {
-				return type;
-			}
-			set {
-				type = value;
-			}
-		}
-		
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
-		}
-		
-		public Expression Initializer {
-			get {
-				return initializer;
-			}
-			set {
-				initializer = value;
-			}
-		}
-		
-		public VariableDeclaration(string name)
-		{
-			this.name = name;
-		}
-		
-		public VariableDeclaration(string name, Expression initializer)
-		{
-			this.name = name;
-			this.initializer = initializer;
-		}
-		
-		public override object AcceptVisitor(IASTVisitor visitor, object data)
-		{
-			return visitor.Visit(this, data);
-		}
-		
-		public override string ToString()
-		{
-			return String.Format(&quot;[VariableDeclaration: Name={0}, Initializer={1}]&quot;, name, initializer);
-		}
-	}
-}
+// Field.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST.VB
+{
+	public class VariableDeclaration : AbstractNode
+	{
+		string     name;
+		Expression initializer = null;
+		TypeReference type;
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Expression Initializer {
+			get {
+				return initializer;
+			}
+			set {
+				initializer = value;
+			}
+		}
+		
+		public VariableDeclaration(string name)
+		{
+			this.name = name;
+		}
+		
+		public VariableDeclaration(string name, Expression initializer)
+		{
+			this.name = name;
+			this.initializer = initializer;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[VariableDeclaration: Name={0}, Initializer={1}]&quot;, name, initializer);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/AST/TypeLevel/VariableDeclaration.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,48 +1,48 @@
-using System;
-using System.Text;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public delegate void ErrorCodeProc(int line, int col, int n);
-	public delegate void ErrorMsgProc(int line, int col, string msg);
-	
-	public class Errors
-	{
-		public int count = 0;                                               // number of errors detected
-		public ErrorCodeProc SynErr;
-		public ErrorCodeProc SemErr;
-		public ErrorMsgProc  Error;
-		StringBuilder errorText = new StringBuilder();
-		
-		public string ErrorOutput {
-			get {
-				return errorText.ToString();
-			}
-		}
-		public Errors()
-		{
-			SynErr = new ErrorCodeProc(DefaultCodeError);  // syntactic errors
-			SemErr = new ErrorCodeProc(DefaultCodeError);  // semantic errors
-			Error  = new ErrorMsgProc(DefaultMsgError);    // user defined string based errors
-		}
-		
-	//	public void Exception (string s)
-	//	{
-	//		Console.WriteLine(s); 
-	//		System.Environment.Exit(0);
-	//	}
-	
-		void DefaultCodeError (int line, int col, int n)
-		{
-			errorText.Append(String.Format(&quot;-- line {0} col {1}: error {2}&quot;, line, col, n));
-			errorText.Append(&quot;\n&quot;);
-			count++;
-		}
-	
-		void DefaultMsgError (int line, int col, string s) {
-			errorText.Append(String.Format(&quot;-- line {0} col {1}: {2}&quot;, line, col, s));
-			errorText.Append(&quot;\n&quot;);
-			count++;
-		}
-	} // Errors
-}
+using System;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public delegate void ErrorCodeProc(int line, int col, int n);
+	public delegate void ErrorMsgProc(int line, int col, string msg);
+	
+	public class Errors
+	{
+		public int count = 0;                                               // number of errors detected
+		public ErrorCodeProc SynErr;
+		public ErrorCodeProc SemErr;
+		public ErrorMsgProc  Error;
+		StringBuilder errorText = new StringBuilder();
+		
+		public string ErrorOutput {
+			get {
+				return errorText.ToString();
+			}
+		}
+		public Errors()
+		{
+			SynErr = new ErrorCodeProc(DefaultCodeError);  // syntactic errors
+			SemErr = new ErrorCodeProc(DefaultCodeError);  // semantic errors
+			Error  = new ErrorMsgProc(DefaultMsgError);    // user defined string based errors
+		}
+		
+	//	public void Exception (string s)
+	//	{
+	//		Console.WriteLine(s); 
+	//		System.Environment.Exit(0);
+	//	}
+	
+		void DefaultCodeError (int line, int col, int n)
+		{
+			errorText.Append(String.Format(&quot;-- line {0} col {1}: error {2}&quot;, line, col, n));
+			errorText.Append(&quot;\n&quot;);
+			count++;
+		}
+	
+		void DefaultMsgError (int line, int col, string s) {
+			errorText.Append(String.Format(&quot;-- line {0} col {1}: {2}&quot;, line, col, s));
+			errorText.Append(&quot;\n&quot;);
+			count++;
+		}
+	} // Errors
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Errors.cs
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Makefile
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,51 +1,51 @@
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class Modifiers
-	{
-		Modifier cur;
-		Parser   parser;
-		
-		public Modifier Modifier {
-			get {
-				return cur;
-			}
-		}
-		
-		public Modifiers(Parser parser)
-		{
-			this.parser = parser;
-			cur         = Modifier.None;
-		}
-		
-		public bool isNone { get { return cur == Modifier.None; } }
-		
-		public bool Contains(Modifier m)
-		{
-			return ((cur &amp; m) != 0);
-		}
-		
-		public void Add(Modifier m) 
-		{
-			if ((cur &amp; m) == 0) {
-				cur |= m;
-			} else {
-				parser.Error(&quot;modifier &quot; + m + &quot; already defined&quot;);
-			}
-		}
-		
-		public void Add(Modifiers m)
-		{
-			Add(m.cur);
-		}
-		
-		public void Check(Modifier allowed)
-		{
-			Modifier wrong = cur &amp; (allowed ^ Modifier.All);
-			if (wrong != Modifier.None) {
-				parser.Error(&quot;modifier(s) &quot; + wrong + &quot; not allowed here&quot;);
-			}
-		}
-	}
-}
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class Modifiers
+	{
+		Modifier cur;
+		Parser   parser;
+		
+		public Modifier Modifier {
+			get {
+				return cur;
+			}
+		}
+		
+		public Modifiers(Parser parser)
+		{
+			this.parser = parser;
+			cur         = Modifier.None;
+		}
+		
+		public bool isNone { get { return cur == Modifier.None; } }
+		
+		public bool Contains(Modifier m)
+		{
+			return ((cur &amp; m) != 0);
+		}
+		
+		public void Add(Modifier m) 
+		{
+			if ((cur &amp; m) == 0) {
+				cur |= m;
+			} else {
+				parser.Error(&quot;modifier &quot; + m + &quot; already defined&quot;);
+			}
+		}
+		
+		public void Add(Modifiers m)
+		{
+			Add(m.cur);
+		}
+		
+		public void Check(Modifier allowed)
+		{
+			Modifier wrong = cur &amp; (allowed ^ Modifier.All);
+			if (wrong != Modifier.None) {
+				parser.Error(&quot;modifier(s) &quot; + wrong + &quot; not allowed here&quot;);
+			}
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Modifiers.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,46 +1,46 @@
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class ParamModifiers
-	{
-		ParamModifier cur;
-		Parser   parser;
-		
-		public ParamModifier Modifier {
-			get {
-				return cur;
-			}
-		}
-		
-		public ParamModifiers(Parser parser)
-		{
-			this.parser = parser;
-			cur         = ParamModifier.None;
-		}
-		
-		public bool isNone { get { return cur == ParamModifier.None; } }
-		
-		public void Add(ParamModifier m) 
-		{
-			if ((cur &amp; m) == 0) {
-				cur |= m;
-			} else {
-				parser.Error(&quot;param modifier &quot; + m + &quot; already defined&quot;);
-			}
-		}
-		
-		public void Add(ParamModifiers m)
-		{
-			Add(m.cur);
-		}
-		
-		public void Check()
-		{
-			if((cur &amp; ParamModifier.ByVal) != 0 &amp;&amp; (cur &amp; ParamModifier.ByRef) != 0) {
-				parser.Error(&quot;ByRef and ByVal are not allowed at the same time.&quot;);
-			}
-		}
-	}
-}
-
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class ParamModifiers
+	{
+		ParamModifier cur;
+		Parser   parser;
+		
+		public ParamModifier Modifier {
+			get {
+				return cur;
+			}
+		}
+		
+		public ParamModifiers(Parser parser)
+		{
+			this.parser = parser;
+			cur         = ParamModifier.None;
+		}
+		
+		public bool isNone { get { return cur == ParamModifier.None; } }
+		
+		public void Add(ParamModifier m) 
+		{
+			if ((cur &amp; m) == 0) {
+				cur |= m;
+			} else {
+				parser.Error(&quot;param modifier &quot; + m + &quot; already defined&quot;);
+			}
+		}
+		
+		public void Add(ParamModifiers m)
+		{
+			Add(m.cur);
+		}
+		
+		public void Check()
+		{
+			if((cur &amp; ParamModifier.ByVal) != 0 &amp;&amp; (cur &amp; ParamModifier.ByRef) != 0) {
+				parser.Error(&quot;ByRef and ByVal are not allowed at the same time.&quot;);
+			}
+		}
+	}
+}
+


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/ParamModifiers.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,120 +1,120 @@
-using System;
-using System.Reflection;
-
---&gt;namespace
-
---&gt;tokens
-
-public class Parser
-{
---&gt;constants
-	const  bool   T            = true;
-	const  bool   x            = false;
-	const  int    minErrDist   = 2;
-	const  string errMsgFormat = &quot;-- line {0} col {1}: {2}&quot;;  // 0=line, 1=column, 2=text
-	int    errDist             = minErrDist;
-	Errors errors;
-	Lexer  lexer;
-
-	public Errors Errors {
-		get {
-			return errors;
-		}
-	}
-
---&gt;declarations
-
-/*
---&gt;pragmas
-*/
-	void SynErr(int n)
-	{
-		if (errDist &gt;= minErrDist) {
-			errors.SynErr(lexer.LookAhead.line, lexer.LookAhead.col, n);
-		}
-		errDist = 0;
-	}
-
-	public void SemErr(string msg)
-	{
-		if (errDist &gt;= minErrDist) {
-			errors.Error(lexer.Token.line, lexer.Token.col, msg);
-		}
-		errDist = 0;
-	}
-	
-	void Expect(int n)
-	{
-		if (lexer.LookAhead.kind == n) {
-			lexer.NextToken();
-		} else {
-			SynErr(n);
-		}
-	}
-	
-	bool StartOf(int s)
-	{
-		return set[s, lexer.LookAhead.kind];
-	}
-	
-	void ExpectWeak(int n, int follow)
-	{
-		if (lexer.LookAhead.kind == n) {
-			lexer.NextToken();
-		} else {
-			SynErr(n);
-			while (!StartOf(follow)) {
-				lexer.NextToken();
-			}
-		}
-	}
-	
-	bool WeakSeparator(int n, int syFol, int repFol)
-	{
-		bool[] s = new bool[maxT + 1];
-		
-		if (lexer.LookAhead.kind == n) {
-			lexer.NextToken();
-			return true; 
-		} else if (StartOf(repFol)) {
-			return false;
-		} else {
-			for (int i = 0; i &lt;= maxT; i++) {
-				s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
-			}
-			SynErr(n);
-			while (!s[lexer.LookAhead.kind]) {
-				lexer.NextToken();
-			}
-			return StartOf(syFol);
-		}
-	}
-	
---&gt;productions
-
-	public void Parse(Lexer lexer)
-	{
-		this.errors = lexer.Errors;
-		this.lexer = lexer;
-		errors.SynErr = new ErrorCodeProc(SynErr);
-		lexer.NextToken();
---&gt;parseRoot
-	}
-
-	void SynErr(int line, int col, int errorNumber)
-	{
-		errors.count++; 
-		string s;
-		switch (errorNumber) {
---&gt;errors
-			default: s = &quot;error &quot; + errorNumber; break;
-		}
-		errors.Error(line, col, s);
-	}
-
-	static bool[,] set = {
---&gt;initialization
-	};
-} // end Parser
-
-$$$
+using System;
+using System.Reflection;
+
+--&gt;namespace
+
+--&gt;tokens
+
+public class Parser
+{
+--&gt;constants
+	const  bool   T            = true;
+	const  bool   x            = false;
+	const  int    minErrDist   = 2;
+	const  string errMsgFormat = &quot;-- line {0} col {1}: {2}&quot;;  // 0=line, 1=column, 2=text
+	int    errDist             = minErrDist;
+	Errors errors;
+	Lexer  lexer;
+
+	public Errors Errors {
+		get {
+			return errors;
+		}
+	}
+
+--&gt;declarations
+
+/*
+--&gt;pragmas
+*/
+	void SynErr(int n)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.SynErr(lexer.LookAhead.line, lexer.LookAhead.col, n);
+		}
+		errDist = 0;
+	}
+
+	public void SemErr(string msg)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.Error(lexer.Token.line, lexer.Token.col, msg);
+		}
+		errDist = 0;
+	}
+	
+	void Expect(int n)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+		}
+	}
+	
+	bool StartOf(int s)
+	{
+		return set[s, lexer.LookAhead.kind];
+	}
+	
+	void ExpectWeak(int n, int follow)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+			while (!StartOf(follow)) {
+				lexer.NextToken();
+			}
+		}
+	}
+	
+	bool WeakSeparator(int n, int syFol, int repFol)
+	{
+		bool[] s = new bool[maxT + 1];
+		
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+			return true; 
+		} else if (StartOf(repFol)) {
+			return false;
+		} else {
+			for (int i = 0; i &lt;= maxT; i++) {
+				s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
+			}
+			SynErr(n);
+			while (!s[lexer.LookAhead.kind]) {
+				lexer.NextToken();
+			}
+			return StartOf(syFol);
+		}
+	}
+	
+--&gt;productions
+
+	public void Parse(Lexer lexer)
+	{
+		this.errors = lexer.Errors;
+		this.lexer = lexer;
+		errors.SynErr = new ErrorCodeProc(SynErr);
+		lexer.NextToken();
+--&gt;parseRoot
+	}
+
+	void SynErr(int line, int col, int errorNumber)
+	{
+		errors.count++; 
+		string s;
+		switch (errorNumber) {
+--&gt;errors
+			default: s = &quot;error &quot; + errorNumber; break;
+		}
+		errors.Error(line, col, s);
+	}
+
+	static bool[,] set = {
+--&gt;initialization
+	};
+} // end Parser
+
+$$$


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.frame
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,222 +1,222 @@
-using System;
-using System.Drawing;
-using System.IO;
-using System.Collections;
-using System.Text;
-
---&gt;namespace
-
-public class Token {
-	public int kind;    // token kind
-	public int pos;     // token position in the source text (starting at 0)
-	public int col;     // token column (starting at 0)
-	public int line;    // token line (starting at 1)
-	public string val;  // token value
-	public Token next;  // AW 2003-03-07 Tokens are kept in linked list
-	
-	public Point Location {
-		get {
-			return new Point(line, col);
-		}
-	}
-
-	public Token () { }
-	public Token (int kind) { this.kind = kind; }
-}
-
-public class Buffer {
-	public const int eof = '\uffff';
-
-	static byte[] buf;
-	static int bufLen;
-	static int pos;
-	
-	public static void Fill (string fileName) {
-		FileStream s = null;
-		try {
-			s = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
-			Fill(s);
-		} catch (IOException) {
-			Console.WriteLine(&quot;--- Cannot open file {0}&quot;, fileName);
-			System.Environment.Exit(0);
-		} finally {
-			if (s != null) s.Close();
-		}
-	}
-	
-	public static void Fill (Stream s) {
-		bufLen = (int) s.Length;
-		buf = new byte[bufLen];
-		s.Read(buf, 0, bufLen); 
-		pos = 0;
-	}
-		
-	public static int Read () {
-		if (pos &lt; bufLen) return buf[pos++];
-		else return 0;
-	}
-
-	public static int Peek () {
-		if (pos &lt; bufLen) return buf[pos];
-		else return 0;
-	}
-	
-	/* AW 2003-03-10 moved this from ParserGen.cs */
-	public static string GetString (int beg, int end) {
-		StringBuilder s = new StringBuilder(64);
-		int oldPos = Buffer.Pos;
-		Buffer.Pos = beg;
-		while (beg &lt; end) { s.Append((char)Buffer.Read()); beg++; }
-		Buffer.Pos = oldPos;
-		return s.ToString();
-	}
-
-	public static int Pos {
-		get { return pos; }
-		set {
-			if (value &lt; 0) pos = 0; 
-			else if (value &gt;= bufLen) pos = bufLen; 
-			else pos = value;
-		}
-	}
-}
-
-public class Scanner {
-	const char EOF = '\0';
-	const char EOL = '\n';
-	const char CR  = '\n';
-
---&gt;constants
-	
---&gt;declarations
-
-	static Token t;          // current token
-	static char ch;          // current input character
-	static int pos;          // column number of current character
-	static int line;         // line number of current character
-	static int lineStart;    // start position of current line
-	static int oldEols;    // EOLs that appeared in a comment;
-	static BitArray ignore;  // set of characters to be ignored by the scanner
-
-	/* ML ----- begin */
-	static Token tokens;  // the complete input token stream
-	static Token pt;      // current peek token
-	
-	static int peekCount = 0;
-	
-	public static int PeekCount { get { return peekCount; } }
-	
-	static void Init()
-	{
-		pos = -1; line = 1; lineStart = 0;
-		oldEols = 0;
-		NextCh();
---&gt;initialization
-
-		/* AW 2003-03-07 fill token list */
-		tokens = new Token();  // first token is a dummy
-		Token node = tokens;
-		do {
-			node.next = NextToken();
-			node = node.next;
-		} while (node.kind != 0);	/* AW: 0 =&gt; EOF */
-		t = pt = tokens;
-	}
-
-	public static void Init(String fileName) {
-		Buffer.Fill(fileName);
-		Init();
-	}
-	
-	public static void Init(Stream s) {
-		Buffer.Fill(s);
-		Init();
-	}
-
-	static void NextCh() {
-		if (oldEols &gt; 0) { ch = EOL; oldEols--; } 
-		else {
-			ch = (char)Buffer.Read(); pos++;
-			// replace isolated '\r' by '\n' in order to make
-			// eol handling uniform across Windows, Unix and Mac
-			if (ch == '\r' &amp;&amp; Buffer.Peek() != '\n') ch = EOL;
-			else if (ch &gt; '\u007f') ch = '?';
-			if (ch == EOL) { line++; lineStart = pos + 1; }
-		}
-	}
-	
---&gt;comment
-	
-	static void CheckLiteral() {
-		switch (t.val) {
---&gt;literals
-		}
-	}
-
-	/* AW Scan() renamed to NextToken() */
-	static Token NextToken() {
-		while (ignore[ch]) NextCh();
---&gt;scan1
-		t = new Token();
-		t.pos = pos; t.col = pos - lineStart + 1; t.line = line; 
-		int state = start[ch];
-		StringBuilder buf = new StringBuilder(16);
-		buf.Append(ch); NextCh();
-		
-		switch (state) {
-			case 0: { t.kind = noSym; goto done; }  // NextCh already done
---&gt;scan2
-		}
-		done: 
-		t.val = buf.ToString();
-		return t;
-	}
-	
-	/* AW 2003-03-07 get the next token, move on and synch peek token with current */
-	public static Token Scan () {
-		t = pt = t.next;
-		return t;
-	}
-
-	/* AW 2003-03-07 get the next token, ignore pragmas */
-	public static Token Peek () {
-		do {                      // skip pragmas while peeking
-			pt = pt.next;
-		} while (pt != null &amp;&amp; pt.kind &gt; maxT);
-		return pt;
-	}
-	
-	/* AW 2003-03-11 to make sure peek start at current scan position */
-	public static void StartPeek () { pt = t; }
-} // end Scanner
-
-
-public delegate void ErrorCodeProc (int line, int col, int n);
-public delegate void ErrorMsgProc (int line, int col, string msg);
-
-public class Errors {
-	public static int count = 0;                                               // number of errors detected
-	public static ErrorCodeProc SynErr = new ErrorCodeProc(DefaultCodeError);  // syntactic errors
-	public static ErrorCodeProc SemErr = new ErrorCodeProc(DefaultCodeError);  // semantic errors
-	public static ErrorMsgProc Error = new ErrorMsgProc(DefaultMsgError);      // user defined string based errors
-	public static StringBuilder errorText = new StringBuilder();
-	
-	public static void Exception (string s) {
-		Console.WriteLine(s); 
-		System.Environment.Exit(0);
-	}
-
-	static void DefaultCodeError (int line, int col, int n) {
-		errorText.Append(String.Format(&quot;-- line {0} col {1}: error {2}&quot;, line, col, n));
-		errorText.Append(&quot;\n&quot;);
-		count++;
-	}
-
-	static void DefaultMsgError (int line, int col, string s) {
-		errorText.Append(String.Format(&quot;-- line {0} col {1}: {2}&quot;, line, col, s));
-		errorText.Append(&quot;\n&quot;);
-		count++;
-	}
-} // Errors
-
-$$$
+using System;
+using System.Drawing;
+using System.IO;
+using System.Collections;
+using System.Text;
+
+--&gt;namespace
+
+public class Token {
+	public int kind;    // token kind
+	public int pos;     // token position in the source text (starting at 0)
+	public int col;     // token column (starting at 0)
+	public int line;    // token line (starting at 1)
+	public string val;  // token value
+	public Token next;  // AW 2003-03-07 Tokens are kept in linked list
+	
+	public Point Location {
+		get {
+			return new Point(line, col);
+		}
+	}
+
+	public Token () { }
+	public Token (int kind) { this.kind = kind; }
+}
+
+public class Buffer {
+	public const int eof = '\uffff';
+
+	static byte[] buf;
+	static int bufLen;
+	static int pos;
+	
+	public static void Fill (string fileName) {
+		FileStream s = null;
+		try {
+			s = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
+			Fill(s);
+		} catch (IOException) {
+			Console.WriteLine(&quot;--- Cannot open file {0}&quot;, fileName);
+			System.Environment.Exit(0);
+		} finally {
+			if (s != null) s.Close();
+		}
+	}
+	
+	public static void Fill (Stream s) {
+		bufLen = (int) s.Length;
+		buf = new byte[bufLen];
+		s.Read(buf, 0, bufLen); 
+		pos = 0;
+	}
+		
+	public static int Read () {
+		if (pos &lt; bufLen) return buf[pos++];
+		else return 0;
+	}
+
+	public static int Peek () {
+		if (pos &lt; bufLen) return buf[pos];
+		else return 0;
+	}
+	
+	/* AW 2003-03-10 moved this from ParserGen.cs */
+	public static string GetString (int beg, int end) {
+		StringBuilder s = new StringBuilder(64);
+		int oldPos = Buffer.Pos;
+		Buffer.Pos = beg;
+		while (beg &lt; end) { s.Append((char)Buffer.Read()); beg++; }
+		Buffer.Pos = oldPos;
+		return s.ToString();
+	}
+
+	public static int Pos {
+		get { return pos; }
+		set {
+			if (value &lt; 0) pos = 0; 
+			else if (value &gt;= bufLen) pos = bufLen; 
+			else pos = value;
+		}
+	}
+}
+
+public class Scanner {
+	const char EOF = '\0';
+	const char EOL = '\n';
+	const char CR  = '\n';
+
+--&gt;constants
+	
+--&gt;declarations
+
+	static Token t;          // current token
+	static char ch;          // current input character
+	static int pos;          // column number of current character
+	static int line;         // line number of current character
+	static int lineStart;    // start position of current line
+	static int oldEols;    // EOLs that appeared in a comment;
+	static BitArray ignore;  // set of characters to be ignored by the scanner
+
+	/* ML ----- begin */
+	static Token tokens;  // the complete input token stream
+	static Token pt;      // current peek token
+	
+	static int peekCount = 0;
+	
+	public static int PeekCount { get { return peekCount; } }
+	
+	static void Init()
+	{
+		pos = -1; line = 1; lineStart = 0;
+		oldEols = 0;
+		NextCh();
+--&gt;initialization
+
+		/* AW 2003-03-07 fill token list */
+		tokens = new Token();  // first token is a dummy
+		Token node = tokens;
+		do {
+			node.next = NextToken();
+			node = node.next;
+		} while (node.kind != 0);	/* AW: 0 =&gt; EOF */
+		t = pt = tokens;
+	}
+
+	public static void Init(String fileName) {
+		Buffer.Fill(fileName);
+		Init();
+	}
+	
+	public static void Init(Stream s) {
+		Buffer.Fill(s);
+		Init();
+	}
+
+	static void NextCh() {
+		if (oldEols &gt; 0) { ch = EOL; oldEols--; } 
+		else {
+			ch = (char)Buffer.Read(); pos++;
+			// replace isolated '\r' by '\n' in order to make
+			// eol handling uniform across Windows, Unix and Mac
+			if (ch == '\r' &amp;&amp; Buffer.Peek() != '\n') ch = EOL;
+			else if (ch &gt; '\u007f') ch = '?';
+			if (ch == EOL) { line++; lineStart = pos + 1; }
+		}
+	}
+	
+--&gt;comment
+	
+	static void CheckLiteral() {
+		switch (t.val) {
+--&gt;literals
+		}
+	}
+
+	/* AW Scan() renamed to NextToken() */
+	static Token NextToken() {
+		while (ignore[ch]) NextCh();
+--&gt;scan1
+		t = new Token();
+		t.pos = pos; t.col = pos - lineStart + 1; t.line = line; 
+		int state = start[ch];
+		StringBuilder buf = new StringBuilder(16);
+		buf.Append(ch); NextCh();
+		
+		switch (state) {
+			case 0: { t.kind = noSym; goto done; }  // NextCh already done
+--&gt;scan2
+		}
+		done: 
+		t.val = buf.ToString();
+		return t;
+	}
+	
+	/* AW 2003-03-07 get the next token, move on and synch peek token with current */
+	public static Token Scan () {
+		t = pt = t.next;
+		return t;
+	}
+
+	/* AW 2003-03-07 get the next token, ignore pragmas */
+	public static Token Peek () {
+		do {                      // skip pragmas while peeking
+			pt = pt.next;
+		} while (pt != null &amp;&amp; pt.kind &gt; maxT);
+		return pt;
+	}
+	
+	/* AW 2003-03-11 to make sure peek start at current scan position */
+	public static void StartPeek () { pt = t; }
+} // end Scanner
+
+
+public delegate void ErrorCodeProc (int line, int col, int n);
+public delegate void ErrorMsgProc (int line, int col, string msg);
+
+public class Errors {
+	public static int count = 0;                                               // number of errors detected
+	public static ErrorCodeProc SynErr = new ErrorCodeProc(DefaultCodeError);  // syntactic errors
+	public static ErrorCodeProc SemErr = new ErrorCodeProc(DefaultCodeError);  // semantic errors
+	public static ErrorMsgProc Error = new ErrorMsgProc(DefaultMsgError);      // user defined string based errors
+	public static StringBuilder errorText = new StringBuilder();
+	
+	public static void Exception (string s) {
+		Console.WriteLine(s); 
+		System.Environment.Exit(0);
+	}
+
+	static void DefaultCodeError (int line, int col, int n) {
+		errorText.Append(String.Format(&quot;-- line {0} col {1}: error {2}&quot;, line, col, n));
+		errorText.Append(&quot;\n&quot;);
+		count++;
+	}
+
+	static void DefaultMsgError (int line, int col, string s) {
+		errorText.Append(String.Format(&quot;-- line {0} col {1}: {2}&quot;, line, col, s));
+		errorText.Append(&quot;\n&quot;);
+		count++;
+	}
+} // Errors
+
+$$$


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Scanner.frame
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,2747 +1,2747 @@
-using System.Drawing;
-using System.Collections;
-using System.Collections.Specialized;
-using System.Text;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
-
-COMPILER VBNET
-
-private string assemblyName = null;
-public CompilationUnit compilationUnit;
-private ArrayList importedNamespaces = null;
-private Stack withStatements;
-private bool isLabel = false;
-private LabelStatement labelStatement = null;
-
-public string ContainingAssembly
-{
-	set { assemblyName = value; }
-}
-
-Token t
-{
-	get {
-		return lexer.Token;
-	}
-}
-Token la
-{
-	get {
-		return lexer.LookAhead;
-	}
-}
-
-void updateLabelStatement(Statement stmt)
-{
-	if(isLabel) {
-		labelStatement.EmbeddedStatement = stmt;
-		isLabel = false;
-	} else {
-		compilationUnit.AddChild(stmt);
-	}
-}
-
-/* Return the n-th token after the current lookahead token */
-void StartPeek()
-{
-	lexer.StartPeek();
-}
-
-Token Peek()
-{
-	return lexer.Peek();
-}
-
-Token Peek (int n)
-{
-	lexer.StartPeek();
-	Token x = la;
-	while (n &gt; 0) {
-		x = lexer.Peek();
-		n--;
-	}
-	return x;
-}
-
-public void Error(string s)
-{
-	if (errDist &gt;= minErrDist) {
-		errors.Error(la.line, la.col, s);
-	}
-	errDist = 0;
-}
-
-public Expression ParseExpression(Lexer lexer)
-{
-	this.errors = lexer.Errors;
-	this.lexer = lexer;
-	errors.SynErr = new ErrorCodeProc(SynErr);
-	lexer.NextToken();
-	Expression expr;
-	Expr(out expr);
-	return expr;
-}
-
-bool IsEndStmtAhead()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.End &amp;&amp; (peek == Tokens.EOL || peek == Tokens.Colon);
-}
-
-bool IsNotClosingParenthesis() {
-	return la.kind != Tokens.CloseParenthesis;
-}
-
-/*
-	True, if ident is followed by &quot;=&quot;
-*/
-bool IdentAndAsgn () {
-	if(la.kind == Tokens.Identifier) {
-		if(Peek(1).kind == Tokens.Assign) return true;
-		if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
-	}
-	return false;
-}
-
-/*
-	True, if ident is followed by &quot;=&quot; or by &quot;:&quot; and &quot;=&quot;
-*/
-bool IsNamedAssign() {
-//	if(Peek(1).kind == Tokens.Assign) return true; // removed: not in the lang spec
-	if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
-	return false;
-}
-
-bool IsObjectCreation() {
-	return la.kind == Tokens.As &amp;&amp; Peek(1).kind == Tokens.New;
-}
-
-/*
-	True, if &quot;&lt;&quot; is followed by the ident &quot;assembly&quot; or &quot;module&quot;
-*/
-bool IsGlobalAttrTarget () {
-	Token pt = Peek(1);
-	return la.kind == Tokens.LessThan &amp;&amp; ( pt.val.ToLower() == &quot;assembly&quot; || pt.val.ToLower() == &quot;module&quot;);
-}
-
-/*
-	True if the next token is a &quot;(&quot; and is followed by &quot;,&quot; or &quot;)&quot;
-*/
-bool IsRank()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.OpenParenthesis
-						&amp;&amp; (peek == Tokens.Comma || peek == Tokens.CloseParenthesis);
-}
-
-bool IsDims()
-{
-	int peek = Peek(1).kind;
-	int peek_n = Peek(2).kind;
-	return la.kind == Tokens.OpenParenthesis
-						&amp;&amp; (peek == Tokens.LiteralInteger &amp;&amp; peek_n == Tokens.CloseParenthesis);
-}
-
-bool IsSize()
-{
-	return la.kind == Tokens.OpenParenthesis;
-}
-
-/*
-	True, if the comma is not a trailing one,
-	like the last one in: a, b, c,
-*/
-bool NotFinalComma() {
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.Comma &amp;&amp;
-		   peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
-}
-
-/*
-	True, if the next token is &quot;Else&quot; and this one
-	if followed by &quot;If&quot;
-*/
-bool IsElseIf()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.Else &amp;&amp; peek == Tokens.If;
-}
-
-/*
-	True if the next token is goto and this one is
-	followed by minus (&quot;-&quot;) (this is allowd in in
-	error clauses)
-*/
-bool IsNegativeLabelName()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.GoTo &amp;&amp; peek == Tokens.Minus;
-}
-
-/*
-	True if the next statement is a &quot;Resume next&quot; statement
-*/
-bool IsResumeNext()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.Resume &amp;&amp; peek == Tokens.Next;
-}
-
-/*
-	True, if ident/literal integer is followed by &quot;:&quot;
-*/
-bool IsLabel()
-{
-	return (la.kind == Tokens.Identifier || la.kind == Tokens.LiteralInteger)
-			&amp;&amp; Peek(1).kind == Tokens.Colon;
-}
-
-bool IsNotStatementSeparator()
-{
-	return la.kind == Tokens.Colon &amp;&amp; Peek(1).kind == Tokens.EOL;
-}
-
-bool IsAssignment ()
-{
-	return IdentAndAsgn();
-}
-
-bool IsMustOverride(Modifiers m)
-{
-	return m.Contains(Modifier.MustOverride);
-}
-
-/*
-	True, if lookahead is a local attribute target specifier,
-	i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,
-	&quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;
-*/
-bool IsLocalAttrTarget() {
-	// TODO
-	return false;
-}
-
-TOKENS
-	/*----- terminal classes -----*/
-	/* EOF is 0 */
-	EOL
-	ident
-	LiteralString
-	LiteralCharacter
-	LiteralInteger
-	LiteralDouble
-	LiteralSingle
-	LiteralDecimal
-	LiteralDate
-	
-	/*----- special character -----*/
-	&quot;.&quot;
-	&quot;=&quot;
-	&quot;,&quot;
-	&quot;:&quot;
-	&quot;+&quot;
-	&quot;-&quot;
-	&quot;*&quot;
-	&quot;/&quot;
-	&quot;\\&quot;
-	&quot;&amp;&quot;
-	&quot;^&quot;
-	
-	&quot;{&quot;
-	&quot;}&quot;
-	
-	&quot;[&quot;
-	&quot;]&quot;
-	
-	&quot;(&quot;
-	&quot;)&quot;
-	
-	&quot;&gt;&quot;
-	&quot;&lt;&quot;
-	
-	&quot;&lt;&gt;&quot;
-	&quot;&gt;=&quot;
-	&quot;&lt;=&quot;
-	
-	&quot;&lt;&lt;&quot;
-	&quot;&gt;&gt;&quot;
-	
-	&quot;+=&quot;
-	&quot;^=&quot;
-	&quot;-=&quot;
-	&quot;*=&quot;
-	&quot;/=&quot;
-	&quot;\\=&quot;
-	&quot;&lt;&lt;=&quot;
-	&quot;&gt;&gt;=&quot;
-	&quot;&amp;=&quot;
-	
-	/*----- VB.NET keywords -----*/
-	&quot;AddHandler&quot;
-	&quot;AddressOf&quot;
-	&quot;Alias&quot;
-	&quot;And&quot;
-	&quot;AndAlso&quot;
-	&quot;Ansi&quot;
-	&quot;As&quot;
-	&quot;Assembly&quot;
-	&quot;Auto&quot;
-	&quot;Binary&quot;
-	&quot;Boolean&quot;
-	&quot;ByRef&quot;
-	&quot;Byte&quot;
-	&quot;ByVal&quot;
-	&quot;Call&quot;
-	&quot;Case&quot;
-	&quot;Catch&quot;
-	&quot;CBool&quot;
-	&quot;CByte&quot;
-	&quot;CChar&quot;
-	&quot;CDate&quot;
-	&quot;CDbl&quot;
-	&quot;CDec&quot;
-	&quot;Char&quot;
-	&quot;CInt&quot;
-	&quot;Class&quot;
-	&quot;CLng&quot;
-	&quot;CObj&quot;
-	&quot;Compare&quot;
-	&quot;Const&quot;
-	&quot;CShort&quot;
-	&quot;CSng&quot;
-	&quot;CStr&quot;
-	&quot;CType&quot;
-	&quot;Date&quot;
-	&quot;Decimal&quot;
-	&quot;Declare&quot;
-	&quot;Default&quot;
-	&quot;Delegate&quot;
-	&quot;Dim&quot;
-	&quot;DirectCast&quot;
-	&quot;Do&quot;
-	&quot;Double&quot;
-	&quot;Each&quot;
-	&quot;Else&quot;
-	&quot;ElseIf&quot;
-	&quot;End&quot;
-	&quot;EndIf&quot;
-	&quot;Enum&quot;
-	&quot;Erase&quot;
-	&quot;Error&quot;
-	&quot;Event&quot;
-	&quot;Exit&quot;
-	&quot;Explicit&quot;
-	&quot;False&quot;
-	&quot;Finally&quot;
-	&quot;For&quot;
-	&quot;Friend&quot;
-	&quot;Function&quot;
-	&quot;Get&quot;
-	&quot;GetType&quot;
-	&quot;GoSub&quot;
-	&quot;GoTo&quot;
-	&quot;Handles&quot;
-	&quot;If&quot;
-	&quot;Implements&quot;
-	&quot;Imports&quot;
-	&quot;In&quot;
-	&quot;Inherits&quot;
-	&quot;Integer&quot;
-	&quot;Interface&quot;
-	&quot;Is&quot;
-	&quot;Let&quot;
-	&quot;Lib&quot;
-	&quot;Like&quot;
-	&quot;Long&quot;
-	&quot;Loop&quot;
-	&quot;Me&quot;
-	&quot;Mod&quot;
-	&quot;Module&quot;
-	&quot;MustInherit&quot;
-	&quot;MustOverride&quot;
-	&quot;MyBase&quot;
-	&quot;MyClass&quot;
-	&quot;Namespace&quot;
-	&quot;New&quot;
-	&quot;Next&quot;
-	&quot;Not&quot;
-	&quot;Nothing&quot;
-	&quot;NotInheritable&quot;
-	&quot;NotOverridable&quot;
-	&quot;Object&quot;
-	&quot;Off&quot;
-	&quot;On&quot;
-	&quot;Option&quot;
-	&quot;Optional&quot;
-	&quot;Or&quot;
-	&quot;OrElse&quot;
-	&quot;Overloads&quot;
-	&quot;Overridable&quot;
-	&quot;Override&quot;
-	&quot;Overrides&quot;
-	&quot;ParamArray&quot;
-	&quot;Preserve&quot;
-	&quot;Private&quot;
-	&quot;Property&quot;
-	&quot;Protected&quot;
-	&quot;Public&quot;
-	&quot;RaiseEvent&quot;
-	&quot;ReadOnly&quot;
-	&quot;ReDim&quot;
-	&quot;RemoveHandler&quot;
-	&quot;Resume&quot;
-	&quot;Return&quot;
-	&quot;Select&quot;
-	&quot;Set&quot;
-	&quot;Shadows&quot;
-	&quot;Shared&quot;
-	&quot;Short&quot;
-	&quot;Single&quot;
-	&quot;Static&quot;
-	&quot;Step&quot;
-	&quot;Stop&quot;
-	&quot;Strict&quot;
-	&quot;String&quot;
-	&quot;Structure&quot;
-	&quot;Sub&quot;
-	&quot;SyncLock&quot;
-	&quot;Text&quot;
-	&quot;Then&quot;
-	&quot;Throw&quot;
-	&quot;To&quot;
-	&quot;True&quot;
-	&quot;Try&quot;
-	&quot;TypeOf&quot;
-	&quot;Unicode&quot;
-	&quot;Until&quot;
-	&quot;Variant&quot;
-	&quot;Wend&quot;
-	&quot;When&quot;
-	&quot;While&quot;
-	&quot;With&quot;
-	&quot;WithEvents&quot;
-	&quot;WriteOnly&quot;
-	&quot;Xor&quot;
-	
-PRODUCTIONS
-
-VBNET
-	(.
-		compilationUnit = new CompilationUnit();
-		withStatements = new Stack();
-	.) =
-	{ EOL }
-	{ OptionStmt }
-	{ ImportsStmt}
-	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
-	{ NamespaceMemberDecl }
-	EOF
-	.
-
-OptionStmt (. INode node = null; bool val = true; .) =
-	&quot;Option&quot; (. Point startPos = t.Location; .)
-	(
-		&quot;Explicit&quot; [ OptionValue&lt;ref val&gt; ]
-		(. node = new OptionExplicitDeclaration(val); .)
-		|
-		&quot;Strict&quot; [ OptionValue&lt;ref val&gt; ]
-		(. node = new OptionStrictDeclaration(val); .)
-		|
-		&quot;Compare&quot; ( &quot;Binary&quot; (. node = new OptionCompareDeclaration(CompareType.Binary); .)
-				  | &quot;Text&quot; (. node = new OptionCompareDeclaration(CompareType.Text); .)
-				  )
-	)
-	EndOfStmt
-	(.
-		node.StartLocation = startPos;
-		node.EndLocation   = t.Location;
-		compilationUnit.AddChild(node);
-	.)
-	.
-
-OptionValue&lt;ref bool val&gt; =
-	(
-		&quot;On&quot; (. val = true; .)
-	|
-		&quot;Off&quot; (. val = true; .)
-	)
-	.
-
-EndOfStmt =
-	(
-		EOL
-	|
-		&quot;:&quot;
-	)
-	.
-
-ImportsStmt
-	(.
-		ArrayList importClauses = new ArrayList();
-		importedNamespaces = new ArrayList();
-		object importClause;
-	.) =
-	&quot;Imports&quot;
-	(.
-		Point startPos = t.Location;
-		ImportsStatement importsStatement = new ImportsStatement(null);
-	.)
-	ImportClause&lt;out importClause&gt; (. importClauses.Add(importClause); .)
-	{
-		&quot;,&quot; ImportClause&lt;out importClause&gt; (. importClauses.Add(importClause); .)
-	}
-	EndOfStmt
-	(.
-		importsStatement.ImportClauses = importClauses;
-		importsStatement.StartLocation = startPos;
-		importsStatement.EndLocation   = t.Location;
-		compilationUnit.AddChild(importsStatement);
-	.)
-	.
-
-ImportClause&lt;out object importClause&gt;
-	(.
-		string qualident = null;
-		string aliasident = null;
-		importClause = null;
-	.) =
-	[ IF (IsAssignment()) Identifier (. aliasident = t.val;  .) &quot;=&quot; ]
-	Qualident&lt;out qualident&gt;
-	(.
-		if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
-			if (aliasident != null) {
-				importClause = new ImportsAliasDeclaration(aliasident, qualident);
-			} else {
-				importedNamespaces.Add(qualident);
-				importClause = new ImportsDeclaration(qualident);
-			}
-		}
-	.)
-	.
-
-/* 6.4.2 */
-NamespaceMemberDecl
-	(.
-		Modifiers m = new Modifiers(this);
-		AttributeSection section;
-		ArrayList attributes = new ArrayList();
-		string qualident;
-	.) =
-	&quot;Namespace&quot;
-	(.
-		Point startPos = t.Location;
-	.)
-	Qualident&lt;out qualident&gt;
-	(.
-		INode node =  new NamespaceDeclaration(qualident);
-		node.StartLocation = startPos;
-		compilationUnit.AddChild(node);
-		compilationUnit.BlockStart(node);
-	.)
-	EOL
-	NamespaceBody
-	(.
-		node.EndLocation = t.Location;
-		compilationUnit.BlockEnd();
-	.)
-	|
-	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-	{ TypeModifier&lt;m&gt; } NonModuleDeclaration&lt;m, attributes&gt;
-	.
-
-/* 6.4.2 */
-NonModuleDeclaration&lt;Modifiers m, ArrayList attributes&gt;
-			(.
-				string name = String.Empty;
-				ArrayList names = null;
-			.) =
-	(. m.Check(Modifier.Classes); .)
-	/* Spec, 7.5 */
-	&quot;Class&quot;
-					(. TypeDeclaration newType = new TypeDeclaration();
-						compilationUnit.AddChild(newType);
-						compilationUnit.BlockStart(newType);
-						newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-						newType.Type = Types.Class;
-						newType.Modifier = m.Modifier;
-						newType.Attributes = attributes;
-					.)
-	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
-	EndOfStmt
-	[ ClassBaseType&lt;out name&gt; (. newType.BaseType = name; .) ]
-	{ TypeImplementsClause&lt;out names&gt; (. newType.BaseInterfaces = names; .) }
-	ClassBody&lt;newType&gt;
-	(.
-		compilationUnit.BlockEnd();
-	.)
-	| &quot;Module&quot;
-		(.
-			m.Check(Modifier.Modules);
-			TypeDeclaration newType = new TypeDeclaration();
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			newType.StartLocation = t.Location;
-			newType.Type = Types.Module;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-		.)
-	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation;  .) 
-	EOL
-	ModuleBody&lt;newType&gt;
-	(.
-		newType.EndLocation = t.Location;
-		compilationUnit.BlockEnd();
-	.)
-	| &quot;Structure&quot;
-		(.
-			m.Check(Modifier.Structures);
-			TypeDeclaration newType = new TypeDeclaration();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			newType.StartLocation = t.Location;
-			newType.Type = Types.Structure;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-			ArrayList baseInterfaces = new ArrayList();
-		.)
-	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
-	EOL { TypeImplementsClause&lt;out baseInterfaces&gt; }
-	StructureBody&lt;newType&gt;
-	(.
-		newType.EndLocation = t.Location;
-		compilationUnit.BlockEnd();
-	.)
-	| /* 7.4 */
-	&quot;Enum&quot;
-		(.
-			m.Check(Modifier.Enums);
-			TypeDeclaration newType = new TypeDeclaration();
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			
-			newType.Type = Types.Enum;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-		.)
-	Identifier
-	(. newType.Name = t.val; newType.StartLocation = t.EndLocation; .)
-	[ &quot;As&quot; PrimitiveTypeName&lt;out name&gt; (. newType.BaseType = name; .) ]
-	EOL
-	EnumBody&lt;newType&gt;
-	(.
-		newType.EndLocation = t.Location;
-		compilationUnit.BlockEnd();
-	.)
-	| /* 7.8 */
-	&quot;Interface&quot;
-		(.
-			m.Check(Modifier.Interfaces);
-			TypeDeclaration newType = new TypeDeclaration();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			
-			newType.Type = Types.Interface;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-			ArrayList baseInterfaces = new ArrayList();
-		.)
-	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
-	EndOfStmt { InterfaceBase&lt;out baseInterfaces&gt; (. newType.BaseInterfaces = baseInterfaces; .) }
-	InterfaceBody&lt;newType&gt;
-	(.
-		newType.EndLocation = t.Location;
-		compilationUnit.BlockEnd();
-	.)
-	| /* 7.10 */
-	&quot;Delegate&quot;
-	(.
-		m.Check(Modifier.Delegates);
-		DelegateDeclaration delegateDeclr = new DelegateDeclaration();
-		ArrayList p = null;
-		TypeReference type = null;
-		delegateDeclr.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-		delegateDeclr.StartLocation = t.Location;
-		delegateDeclr.Modifier = m.Modifier;
-		delegateDeclr.Attributes = attributes;
-	.)
-	(
-		&quot;Sub&quot; Identifier (. delegateDeclr.Name = t.val; .)
-		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. delegateDeclr.Parameters = p; .) ]
-		|
-		&quot;Function&quot; Identifier (. delegateDeclr.Name = t.val; .)
-		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. delegateDeclr.Parameters = p; .) ]
-		[ &quot;As&quot; TypeName&lt;out type&gt; (. delegateDeclr.ReturnType = type; .)]
-	)
-	(. 		delegateDeclr.EndLocation = t.EndLocation; .)
-	EOL
-	(.
-		compilationUnit.AddChild(delegateDeclr);
-	.)
-	.
-
-NamespaceBody =
-	{ NamespaceMemberDecl }
-	&quot;End&quot; &quot;Namespace&quot;
-	EOL
-	.
-
-ClassBody&lt;TypeDeclaration newType&gt;
-	(. AttributeSection section; .) =
-	{
-		(.
-			ArrayList attributes = new ArrayList();
-			Modifiers m = new Modifiers(this);
-		.)
-		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-		{ MemberModifier&lt;m&gt; }
-		ClassMemberDecl&lt;m, attributes&gt;
-	}
-	&quot;End&quot; &quot;Class&quot; (. newType.EndLocation = t.EndLocation; .)
-	EOL
-	.
-
-StructureBody&lt;TypeDeclaration newType&gt;
-	(. AttributeSection section; .) =
-	{
-		(.
-			ArrayList attributes = new ArrayList();
-			Modifiers m = new Modifiers(this);
-		.)
-		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-		{ MemberModifier&lt;m&gt; }
-		StructureMemberDecl&lt;m, attributes&gt;
-	}
-	&quot;End&quot; &quot;Structure&quot; (. newType.EndLocation = t.EndLocation; .)
-	EOL
-	.
-
-/* 7.7.1 */
-ModuleBody&lt;TypeDeclaration newType&gt;
-	(. AttributeSection section; .) =
-	{
-		(.
-			ArrayList attributes = new ArrayList();
-			Modifiers m = new Modifiers(this);
-		.)
-		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-		{ MemberModifier&lt;m&gt; }
-		ClassMemberDecl&lt;m, attributes&gt;
-	}
-	&quot;End&quot; &quot;Module&quot; (. newType.EndLocation = t.EndLocation; .)
-	EOL
-	.
-
-EnumBody&lt;TypeDeclaration newType&gt;
-	(. FieldDeclaration f; .) =
-	{
-		EnumMemberDecl&lt;out f&gt; (. compilationUnit.AddChild(f); .)
-	}
-	&quot;End&quot; &quot;Enum&quot; (. newType.EndLocation = t.EndLocation; .)
-	EOL
-	.
-
-InterfaceBody&lt;TypeDeclaration newType&gt; =
-	{ InterfaceMemberDecl }
-	&quot;End&quot; &quot;Interface&quot; (. newType.EndLocation = t.EndLocation; .)
-	EOL
-	.
-
-/*
-	The information provided in the spec about
-	interface declarations is wrong
-*/
-InterfaceMemberDecl
-	(.
-		TypeReference type =null;
-		ArrayList p = null;
-		AttributeSection section;
-		Modifiers mod = new Modifiers(this);
-		ArrayList attributes = new ArrayList();
-		/*ArrayList parameters = new ArrayList();*/
-		string name;
-	.) =
-	{ AttributeSection&lt;out section&gt;			(. attributes.Add(section); .) }
-	/* this is different to c#: not only the Shadows modifier is allowed,
-	   also member modifiers like overloads etc.
-	*/
-	{ MemberModifier&lt;mod&gt; }
-	(
-		&quot;Event&quot;
-		(. mod.Check(Modifier.InterfaceEvents); .)
-		Identifier (. name = t.val; .)
-		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-		[ &quot;As&quot; TypeName&lt;out type&gt; ]
-		EOL
-		(.
-			EventDeclaration ed = new EventDeclaration(type, mod.Modifier, p, attributes, name, null);
-			ed.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			compilationUnit.AddChild(ed);
-			ed.EndLocation = t.EndLocation;
-		.)
-		|
-		&quot;Sub&quot;
-		(.
-			mod.Check(Modifier.InterfaceMethods);
-			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-		.)
-		Identifier (. name = t.val; .)
-		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-		EOL
-		(.
-			MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, null, p, attributes);
-			md.Specials[&quot;before&quot;] = comments;
-			md.EndLocation = t.EndLocation;
-			compilationUnit.AddChild(md);
-		.)
-		|
-		&quot;Function&quot;
-		(.
-			mod.Check(Modifier.InterfaceMethods);
-			AttributeSection attributeSection = null;
-		.)
-		Identifier (. name = t.val; .)
-		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-		[ &quot;As&quot; [AttributeSection&lt;out attributeSection&gt; ] TypeName&lt;out type&gt; ]
-		(.
-			if(type == null) {
-				type = new TypeReference(&quot;System.Object&quot;);
-			}
-			type.Attributes = attributeSection;
-			MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, type, p, attributes);
-			md.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			md.EndLocation = t.EndLocation;
-			compilationUnit.AddChild(md);
-		.)
-		EOL
-		|
-		&quot;Property&quot;
-		(.
-			mod.Check(Modifier.InterfaceProperties);
-			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-		.)
-		Identifier	(. name = t.val;  .)
-		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-		[ &quot;As&quot; TypeName&lt;out type&gt; ]
-		(.
-			if(type == null) {
-				type = new TypeReference(&quot;System.Object&quot;);
-			}
-		.)
-		EOL
-		(.
-			PropertyDeclaration pd = new PropertyDeclaration(name, type, mod.Modifier, attributes);
-			pd.Parameters = p;
-			pd.Specials[&quot;before&quot;] = comments;
-			pd.EndLocation = t.EndLocation;
-			compilationUnit.AddChild(pd);
-		.)
-	)
-	| /* inner type declarations */
-	NonModuleDeclaration&lt;mod, attributes&gt;
-	.
-
-/* 7.4.1 */
-EnumMemberDecl&lt;out FieldDeclaration f&gt;
-	(.
-		Expression expr = null;
-		ArrayList attributes = new ArrayList();
-		AttributeSection section = null;
-		VariableDeclaration varDecl = null;
-	.) =
-	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-	Identifier
-	(.
-		f = new FieldDeclaration(attributes);
-		varDecl = new VariableDeclaration(t.val);
-		varDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-		f.Fields.Add(varDecl);
-		f.StartLocation = t.Location;
-	.)
-	[ &quot;=&quot; Expr&lt;out expr&gt; (. varDecl.Initializer = expr; .) ]
-	EOL
-	.
-
-ClassMemberDecl&lt;Modifiers m, ArrayList attributes&gt; =
-	StructureMemberDecl&lt;m, attributes&gt;
-	.
-
-ClassBaseType&lt;out string name&gt;
-	(.
-		TypeReference type;
-		name = String.Empty;
-	.) =
-	&quot;Inherits&quot;
-	TypeName&lt;out type&gt; (. name = type.Type; .)
-	EndOfStmt
-	.
-
-/* 7.6.1 */
-StructureMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
-	(.
-		TypeReference type = null;
-		ArrayList p = null;
-		Statement stmt = null;
-		ArrayList variableDeclarators = new ArrayList();
-	.)=
-	NonModuleDeclaration&lt;m, attributes&gt;
-	| /* 9.2.1 */
-	&quot;Sub&quot;
-	(.
-		Point startPos = t.Location;
-		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-	.)
-	(
-		(.
-			string name = String.Empty;
-			MethodDeclaration methodDeclaration;
-			HandlesClause handlesClause = null;
-			ImplementsClause implementsClause = null;
-		.)
-		Identifier
-		(.
-			name = t.val;
-			m.Check(Modifier.Methods);
-		.)
-		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-		[
-			(
-				ImplementsClause&lt;out implementsClause&gt;
-				|
-				HandlesClause&lt;out handlesClause&gt;
-			)
-		]
-		(. Point endLocation = t.EndLocation; .)
-		EOL
-		(
-			/* abstract methods without a body */
-			IF(IsMustOverride(m))
-			(.
-				methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
-				methodDeclaration.Specials[&quot;before&quot;] = comments;
-				methodDeclaration.StartLocation = startPos;
-				methodDeclaration.EndLocation   = endLocation;
-				
-				methodDeclaration.HandlesClause = handlesClause;
-				methodDeclaration.ImplementsClause = implementsClause;
-				
-				compilationUnit.AddChild(methodDeclaration);
-			.)
-		|
-			(.
-				methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
-				methodDeclaration.Specials[&quot;before&quot;] = comments;
-				methodDeclaration.StartLocation = startPos;
-				methodDeclaration.EndLocation   = endLocation;
-				
-				methodDeclaration.HandlesClause = handlesClause;
-				methodDeclaration.ImplementsClause = implementsClause;
-				
-				compilationUnit.AddChild(methodDeclaration);
-				compilationUnit.BlockStart(methodDeclaration);
-			.)
-			Block&lt;out stmt&gt;
-			(.
-				compilationUnit.BlockEnd();
-				methodDeclaration.Body  = (BlockStatement)stmt;
-			.)
-			&quot;End&quot; &quot;Sub&quot; (. methodDeclaration.Body.EndLocation = t.EndLocation; .) EOL 
-		)
-		/* 9.3 */
-		| &quot;New&quot; [ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-		(. m.Check(Modifier.Constructors); .)
-		(. Point constructorEndLocation = t.EndLocation; .)
-		EOL
-		Block&lt;out stmt&gt;
-		&quot;End&quot; &quot;Sub&quot; (. Point endLocation = t.EndLocation; .) EOL
-		(.
-			ConstructorDeclaration cd = new ConstructorDeclaration(&quot;New&quot;, m.Modifier, p, attributes); 
-			cd.StartLocation = startPos;
-			cd.Specials[&quot;before&quot;] = comments;
-			cd.EndLocation   = constructorEndLocation;
-			cd.Body = (BlockStatement)stmt;
-			cd.Body.EndLocation   = endLocation;
-			compilationUnit.AddChild(cd);
-		.)
-	)
-	|
-	/* 9.2.1 */
-	&quot;Function&quot;
-	(.
-		m.Check(Modifier.Methods);
-		string name = String.Empty;
-		Point startPos = t.Location;
-		MethodDeclaration methodDeclaration;
-		HandlesClause handlesClause = null;
-		ImplementsClause implementsClause = null;
-		AttributeSection attributeSection = null;
-	.)
-	Identifier			(. name = t.val; .)
-	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-	[&quot;As&quot; [AttributeSection&lt;out attributeSection&gt;] TypeName&lt;out type&gt; ]
-	(.
-		if(type == null) {
-			type = new TypeReference(&quot;System.Object&quot;);
-		}
-		type.Attributes = attributeSection;
-	.)
-	[
-		(
-			ImplementsClause&lt;out implementsClause&gt;
-			|
-			HandlesClause&lt;out handlesClause&gt;
-		)
-	]
-	EOL
-	(
-		/* abstract methods without a body */
-		IF(IsMustOverride(m))
-			(.
-				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
-				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				methodDeclaration.StartLocation = startPos;
-				methodDeclaration.EndLocation   = t.EndLocation;
-				methodDeclaration.HandlesClause = handlesClause;
-				methodDeclaration.ImplementsClause = implementsClause;
-				compilationUnit.AddChild(methodDeclaration);
-			.)
-		|
-			(.
-				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
-				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				methodDeclaration.StartLocation = startPos;
-				methodDeclaration.EndLocation   = t.EndLocation;
-				
-				methodDeclaration.HandlesClause = handlesClause;
-				methodDeclaration.ImplementsClause = implementsClause;
-				
-				compilationUnit.AddChild(methodDeclaration);
-				compilationUnit.BlockStart(methodDeclaration);
-			.)
-			Block&lt;out stmt&gt;
-			(.
-				compilationUnit.BlockEnd();
-				methodDeclaration.Body  = (BlockStatement)stmt;
-			.)
-			&quot;End&quot; &quot;Function&quot; 
-			(.
-				methodDeclaration.Body.StartLocation = methodDeclaration.EndLocation;
-				methodDeclaration.Body.EndLocation   = t.EndLocation;
-			.)
-			EOL
-	)
-	|
-	/* 9.2.2. */
-	&quot;Declare&quot;
-	(.
-		m.Check(Modifier.ExternalMethods);
-		Point startPos = t.Location;
-		CharsetModifier charsetModifer = CharsetModifier.None;
-		string library = String.Empty;
-		string alias = null;
-		string name = String.Empty;
-	.)
-	[Charset&lt;out charsetModifer&gt; ]
-	(
-			&quot;Sub&quot;
-			Identifier				(. name = t.val; .)
-			&quot;Lib&quot; LiteralString		(. library = t.val; .)
-			[&quot;Alias&quot; LiteralString	(. alias = t.val; .)]
-			[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-			EOL
-			(.
-				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, null, p, attributes, library, alias, charsetModifer);
-				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				declareDeclaration.StartLocation = startPos;
-				declareDeclaration.EndLocation   = t.EndLocation;
-				compilationUnit.AddChild(declareDeclaration);
-			.)
-		|
-			&quot;Function&quot; 
-			Identifier					(. name = t.val; .)
-			&quot;Lib&quot; LiteralString		(. library = t.val; .)
-			[&quot;Alias&quot; LiteralString	(. alias = t.val; .)]
-			[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-			[&quot;As&quot; TypeName&lt;out type&gt; ]
-			EOL
-			(.
-				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, type, p, attributes, library, alias, charsetModifer);
-				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				declareDeclaration.StartLocation = startPos;
-				declareDeclaration.EndLocation   = t.EndLocation;
-				compilationUnit.AddChild(declareDeclaration);
-			.)
-		)
-	|
-	/* 9. 4 */
-	&quot;Event&quot;
-	(.
-		m.Check(Modifier.Events);
-		Point startPos = t.Location;
-		EventDeclaration eventDeclaration;
-		string name = String.Empty;
-		ImplementsClause implementsClause = null;
-	.)
-	Identifier (. name= t.val; .)
-	(
-		&quot;As&quot; TypeName&lt;out type&gt;
-		|
-		[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-	)
-	[ ImplementsClause&lt;out implementsClause&gt; ]
-	(.
-		eventDeclaration = new EventDeclaration(type, m.Modifier, p, attributes, name, implementsClause);
-		eventDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-		eventDeclaration.StartLocation = startPos;
-		eventDeclaration.EndLocation = t.EndLocation;
-		compilationUnit.AddChild(eventDeclaration);
-	.)
-	EOL
-	| /* 9.6 */
-	(. Point startPos = t.Location; .)
-	(.
-		m.Check(Modifier.Fields);
-		FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
-		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-		fd.StartLocation = startPos;
-	.)
-	VariableDeclarator&lt;variableDeclarators&gt;
-	(.
-		((INode)variableDeclarators[0]).Specials[&quot;before&quot;] = comments;
-	.)
-	{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; }
-	EOL
-	(.
-		fd.EndLocation = t.EndLocation;
-		fd.Fields = variableDeclarators;
-		compilationUnit.AddChild(fd);
-	.)
-	| /* 9.4 */
-	(. m.Check(Modifier.Fields); .)
-	&quot;Const&quot; (.  m.Add(Modifier.Constant);  .)
-	(.
-		FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
-		fd.StartLocation = t.Location;
-		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-		ArrayList constantDeclarators = new ArrayList();
-	.)
-	ConstantDeclarator&lt;constantDeclarators&gt;
-	(.
-		((INode)constantDeclarators[0]).Specials[&quot;before&quot;] = comments;
-	.)
-	{ &quot;,&quot; ConstantDeclarator&lt;constantDeclarators&gt; }
-	(.
-		fd.Fields = constantDeclarators;
-		fd.EndLocation = t.Location;
-	.)
-	EOL
-	(.
-		fd.EndLocation = t.EndLocation;
-		compilationUnit.AddChild(fd);
-	.)
-	| /* 9.7 */
-	&quot;Property&quot;
-	(.
-		m.Check(Modifier.Properties);
-		Point startPos = t.Location;
-		ImplementsClause implementsClause = null;
-	.)
-	Identifier (. string propertyName = t.val; .)
-	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-	[ &quot;As&quot; TypeName&lt;out type&gt; ]
-	(.
-		if(type == null) {
-			type = new TypeReference(&quot;System.Object&quot;);
-		}
-	.)
-	[ ImplementsClause&lt;out implementsClause&gt; ]
-	EOL
-	(
-	/* abstract properties without a body */
-	IF(IsMustOverride(m))
-		(.
-			PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
-			pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			pDecl.StartLocation = startPos;
-			pDecl.EndLocation   = t.Location;
-			pDecl.TypeReference = type;
-			pDecl.ImplementsClause = implementsClause;
-			pDecl.Parameters = p;
-			compilationUnit.AddChild(pDecl);
-		.)
-	|
-		(.
-			PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
-			pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			pDecl.StartLocation = startPos;
-			pDecl.EndLocation   = t.Location;
-			pDecl.BodyStart   = t.Location;
-			pDecl.TypeReference = type;
-			pDecl.ImplementsClause = implementsClause;
-			pDecl.Parameters = p;
-			PropertyGetRegion getRegion;
-			PropertySetRegion setRegion;
-		.)
-		AccessorDecls&lt;out getRegion, out setRegion&gt; 
-		&quot;End&quot; &quot;Property&quot;
-		EOL
-		(.
-			pDecl.GetRegion = getRegion;
-			pDecl.SetRegion = setRegion;
-			pDecl.BodyEnd = t.EndLocation;
-			compilationUnit.AddChild(pDecl);
-		.)
-	)
-	.
-
-/* 9.7 */
-AccessorDecls&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
-	(.
-		ArrayList attributes = new ArrayList(); 
-		AttributeSection section;
-		getBlock = null;
-		setBlock = null; 
-	.) =
-	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-	(
-		GetAccessorDecl&lt;out getBlock, attributes&gt;
-		[
-			(. attributes = new ArrayList(); .)
-			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-			SetAccessorDecl&lt;out setBlock, attributes&gt;
-		]
-		|
-		SetAccessorDecl&lt;out setBlock, attributes&gt;
-		[
-			(. attributes = new ArrayList(); .)
-			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
-			GetAccessorDecl&lt;out getBlock, attributes&gt;
-		]
-	)
-	.
-
-/* 9.7.1 */
-GetAccessorDecl&lt;out PropertyGetRegion getBlock, ArrayList attributes&gt;
-	(. Statement stmt = null; .) =
-	&quot;Get&quot;
-	EOL
-	Block&lt;out stmt&gt;
-	(.
-		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes);
-	.)
-	&quot;End&quot; &quot;Get&quot;
-	EOL
-	.
-
-/* 9.7.2 */
-SetAccessorDecl&lt;out PropertySetRegion setBlock, ArrayList attributes&gt;
-	(.
-		Statement stmt = null;
-		ArrayList p = null;
-	.) =
-	&quot;Set&quot;
-	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
-	EOL
-	Block&lt;out stmt&gt;
-	(.
-		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes);
-		setBlock.Parameters = p;
-	.)
-	&quot;End&quot; &quot;Set&quot;
-	EOL
-	.
-
-/* 9.5 */
-ConstantDeclarator&lt;ArrayList constantDeclaration&gt;
-	(.
-		Expression expr = null;
-		TypeReference type = null;
-		string name = String.Empty;
-	.) =
-	Identifier				(. name = t.val; .)
-	[&quot;As&quot; TypeName&lt;out type&gt; ]
-	&quot;=&quot; Expr&lt;out expr&gt;
-	(.
-		VariableDeclaration f = new VariableDeclaration(name, expr);
-		f.Type = type;
-		constantDeclaration.Add(f);
-	.)
-	.
-
-/* 9.6 */
-VariableDeclarator&lt;ArrayList fieldDeclaration&gt;
-	(.
-		Expression expr = null;
-		TypeReference type = null;
-		ObjectCreateExpression oce = null;
-		ArrayCreateExpression ace = null;
-		ArrayList rank = null;
-		ArrayList dimension = null;
-	.) =
-	Identifier
-	(.
-		VariableDeclaration f = new VariableDeclaration(t.val);
-	.)
-	[ IF(IsRank()) ArrayTypeModifiers&lt;out rank&gt; ]
-	[ IF(IsSize()) ArrayInitializationModifier&lt;out dimension&gt; ]
-	(
-			IF(IsObjectCreation()) &quot;As&quot; ObjectCreateExpression&lt;out expr&gt;
-			(.
-				if(expr is ArrayCreateExpression) {
-					ace = expr as ArrayCreateExpression;
-					f.Initializer = ace.ArrayInitializer;
-					
-				} else {
-					oce = expr as ObjectCreateExpression;
-					f.Initializer = oce;
-					if(oce.CreateType != null) {
-						f.Type = oce.CreateType;
-					}
-				}
-			.)
-		|
-			[ &quot;As&quot; TypeName&lt;out type&gt; ]
-			(.
-				if(type != null) {
-					type.Dimension = dimension;
-				}
-				f.Type = type;
-				if (type != null &amp;&amp; rank != null) {
-					if(type.RankSpecifier != null) {
-						Error(&quot;array rank only allowed one time&quot;);
-					} else {
-						type.RankSpecifier = rank;
-					}
-				}
-			.)
-			[ &quot;=&quot; VariableInitializer&lt;out expr&gt; (. f.Initializer = expr; .) ]
-	)
-	(. fieldDeclaration.Add(f); .)
-	.
-
-/* 6.8 */
-ArrayInitializationModifier&lt;out ArrayList arrayModifiers&gt;
-	(.
-		arrayModifiers = null;
-	.) =
-	&quot;(&quot; InitializationRankList&lt;out arrayModifiers&gt; &quot;)&quot;
-	.
-
-/* 7.5.4.3 */
-InitializationRankList&lt;out ArrayList rank&gt;
-	(.
-		rank = null;
-		Expression expr = null;
-	.) =
-	Expr&lt;out expr&gt;	(. rank = new ArrayList(); rank.Add(expr); .)
-	{
-		&quot;,&quot; Expr&lt;out expr&gt;		(. rank.Add(expr); .)
-	}
-	.
-
-/* 9.6.3 */
-VariableInitializer&lt;out Expression initializerExpression&gt;
-	(.
-		initializerExpression = null;
-	.) =
-	Expr&lt;out initializerExpression&gt;
-	| ArrayInitializer&lt;out initializerExpression&gt;
-	.
-
-/* 9.6.3.4 */
-ArrayInitializer&lt;out Expression outExpr&gt;
-	(.
-		Expression expr = null;
-		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
-	.) =
-	&quot;{&quot;
-	[
-		VariableInitializer&lt;out expr&gt;
-		(.
-			initializer.CreateExpressions.Add(expr);
-		.)
-		{
-			IF (NotFinalComma()) &quot;,&quot; VariableInitializer&lt;out expr&gt;
-			(. initializer.CreateExpressions.Add(expr); .)
-		}
-	]
-	&quot;}&quot; (. outExpr = initializer; .)
-	.
-
-Charset&lt;out CharsetModifier charsetModifier&gt;
-	(. charsetModifier = CharsetModifier.None; .) =
-	| &quot;Ansi&quot;		(. charsetModifier = CharsetModifier.ANSI; .)
-	| &quot;Auto&quot;		(. charsetModifier = CharsetModifier.Auto; .)
-	| &quot;Unicode&quot;		(. charsetModifier = CharsetModifier.Unicode; .)
-	.
-
-/* 9.2.6 */
-HandlesClause&lt;out HandlesClause handlesClause&gt;
-	(.
-		handlesClause = new HandlesClause();
-		string name;
-	.) =
-	&quot;Handles&quot; EventMemberSpecifier&lt;out name&gt;	(. handlesClause.EventNames.Add(name); .)
-	{ &quot;,&quot; EventMemberSpecifier&lt;out name&gt;		(. handlesClause.EventNames.Add(name); .) }
-	.
-
-/* 7.8. */
-InterfaceBase &lt;out ArrayList bases&gt;
-	(.
-		TypeReference type;
-		bases = new ArrayList();
-	.) =
-	&quot;Inherits&quot;
-	TypeName&lt;out type&gt; (. bases.Add(type); .)
-	{
-		&quot;,&quot;
-		TypeName&lt;out type&gt; (. bases.Add(type); .)
-	}
-	EOL
-	.
-
-/* 7.2 */
-TypeImplementsClause&lt;out ArrayList baseInterfaces&gt;
-	(.
-		baseInterfaces = new ArrayList();
-		TypeReference type = null;
-	.) =
-	&quot;Implements&quot; TypeName&lt;out type&gt;
-	(.
-		baseInterfaces.Add(type);
-	.)
-	{
-		&quot;,&quot; TypeName&lt;out type&gt;
-		(. baseInterfaces.Add(type); .)
-	}
-	EndOfStmt
-	.
-
-/* 9.1 */
-ImplementsClause&lt;out ImplementsClause clause&gt;
-	(.
-		clause = new ImplementsClause();
-		string typename = String.Empty;
-		string first;
-	.) =
-	&quot;Implements&quot; Identifier (. first = t.val; .) &quot;.&quot; Qualident&lt;out typename&gt; (. ((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); .)
-	{ &quot;,&quot; Identifier (. first = t.val; .) &quot;.&quot; Qualident&lt;out typename&gt; (. ((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); .) }
-		.
-
-EventMemberSpecifier&lt;out string name&gt;
-	(. string type; name = String.Empty; .) =
-	Identifier (. type = t.val; .)
-	&quot;.&quot;
-	Identifier (. name = type + &quot;.&quot; + t.val; .)
-	| &quot;MyBase&quot; &quot;.&quot;
-	(
-		Identifier (. name = &quot;MyBase.&quot; + t.val; .)
-		| &quot;Error&quot;  (. name = &quot;MyBase.Error&quot;; .)
-	)
-	.
-
-Expr&lt;out Expression expr&gt;
-	(. expr = new Expression(); .) =
-	ConditionalOrExpr&lt;out expr&gt;
-	{
-		/*ConditionalOrExpr&lt;out expr&gt;	|*/
-		(. AssignmentOperatorType op; Expression val; .)
-		AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
-	}
-	.
-
-UnaryExpr&lt;out Expression uExpr&gt; 
-	(.
-		Expression expr;
-		UnaryOperatorType uop = UnaryOperatorType.None;
-		bool isUOp = false;
-	.) =
-	{ 	&quot;+&quot; 		(. uop = UnaryOperatorType.Plus; isUOp = true; .)
-		| &quot;-&quot; 		(. uop = UnaryOperatorType.Minus; isUOp = true; .)
-/*		| &quot;Not&quot;		(. uop = UnaryOperatorType.Not;  isUOp = true;.) */
-		| &quot;*&quot; 		(. uop = UnaryOperatorType.Star;  isUOp = true;.)
-	}
-	SimpleExpr&lt;out expr&gt;
-		(.
-			if (isUOp) {
-				uExpr = new UnaryOperatorExpression(expr, uop);
-			} else {
-				uExpr = expr;
-			}
-		.)
-	.
-
-AssignmentOperator&lt;out AssignmentOperatorType op&gt;
-	(. op = AssignmentOperatorType.None; .) =
-	&quot;=&quot;		(. op = AssignmentOperatorType.Assign; .)
-	| &quot;&amp;=&quot;	(. op = AssignmentOperatorType.ConcatString; .)
-	| &quot;+=&quot;	(. op = AssignmentOperatorType.Add; .)
-	| &quot;-=&quot;	(. op = AssignmentOperatorType.Subtract; .)
-	| &quot;*=&quot;	(. op = AssignmentOperatorType.Multiply; .)
-	| &quot;/=&quot;	(. op = AssignmentOperatorType.Divide; .)
-	| &quot;\\=&quot;	(. op = AssignmentOperatorType.DivideInteger; .)
-	| &quot;^=&quot;	(. op = AssignmentOperatorType.Power; .)
-	| &quot;&lt;&lt;=&quot;	(. op = AssignmentOperatorType.ShiftLeft; .)
-	| &quot;&gt;&gt;=&quot;	(. op = AssignmentOperatorType.ShiftRight; .)
-	.
-
-/* 11.4 */
-SimpleExpr&lt;out Expression pexpr&gt;
-	(.
-		Expression expr;
-		TypeReference type = null;
-		string name = String.Empty;
-		pexpr = null;
-	.) =
-	(
-		(
-			/* 11.4.1 */ 
-			LiteralString							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
-			| LiteralCharacter						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
-			| LiteralSingle							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
-			| LiteralDouble							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
-			| LiteralInteger						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
-			| LiteralDate							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
-			| LiteralDecimal						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
-			/* True, False and Nothing are handled as literals in the spec */
-			| &quot;True&quot;											(.pexpr = new PrimitiveExpression(true, &quot;true&quot;);  .)
-			| &quot;False&quot;											(.pexpr = new PrimitiveExpression(false, &quot;false&quot;); .)
-			| &quot;Nothing&quot;											(.pexpr = new PrimitiveExpression(null, &quot;null&quot;);  .)
-			| /* 11.4.2 */ &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; 				(. pexpr = new ParenthesizedExpression(expr); .)
-			| /* 11.4.4 */ Identifier					(. pexpr = new IdentifierExpression(t.val); .)
-			| (. string val = String.Empty; .) PrimitiveTypeName&lt;out val&gt;
-			&quot;.&quot; Identifier	(. pexpr = new FieldReferenceOrInvocationExpression(new TypeReferenceExpression(val), t.val); .)
-			| &quot;Me&quot;												(. pexpr = new ThisReferenceExpression(); .)
-			| (. Expression retExpr = null; .)
-				( &quot;MyBase&quot;										(. retExpr = new BaseReferenceExpression(); .)
-				| &quot;MyClass&quot;										(. retExpr = new ClassReferenceExpression(); .)
-				)
-				&quot;.&quot; IdentifierOrKeyword&lt;out name&gt;				(. pexpr = new FieldReferenceOrInvocationExpression(retExpr, name); .)
-			| ObjectCreateExpression&lt;out expr&gt;					(. pexpr = expr; .)
-			| /* 11.11 */ ( &quot;DirectCast&quot; | &quot;CType&quot; ) &quot;(&quot; Expr&lt;out expr&gt; &quot;,&quot; TypeName&lt;out type&gt; &quot;)&quot;	(. pexpr = new CastExpression(type, expr); .)
-			| /* 11.11 */ CastTarget&lt;out type&gt; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;	(. pexpr = new CastExpression(type, expr, true); .)
-			| /* 11.4.5 */ &quot;AddressOf&quot; Expr&lt;out expr&gt;			(. pexpr = new AddressOfExpression(expr); .)
-			| /* 11.5.1 */ &quot;GetType&quot; &quot;(&quot; TypeName&lt;out type&gt; &quot;)&quot;	(. pexpr = new GetTypeExpression(type); .)
-			| /* 11.5.2 */ &quot;TypeOf&quot; SimpleExpr&lt;out expr&gt; &quot;Is&quot; TypeName&lt;out type&gt; (. pexpr = new TypeOfExpression(expr, type); .)
-		)
-		{
-			&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); .)
-			| &quot;(&quot;	(. ArrayList parameters = new ArrayList(); .)
-				[
-					(. expr = null; .) [ Argument&lt;out expr&gt;]	(. parameters.Add(expr); .)
-					{
-						&quot;,&quot; (. expr = null; .)
-						[ Argument&lt;out expr&gt;  ] (. parameters.Add(expr); .)
-					}
-				]
-			&quot;)&quot;		(. pexpr = new InvocationExpression(pexpr, parameters); .)
-		}
-	|
-	/* this form only occurs in with statements*/
-	&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name);.)
-	{
-		&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); .)
-		| &quot;(&quot;	(. ArrayList parameters = new ArrayList(); .)
-			[
-				(. expr = null; .) [ Argument&lt;out expr&gt;]	(. parameters.Add(expr); .)
-				{
-					&quot;,&quot; (. expr = null; .)
-					[ Argument&lt;out expr&gt;  ] (. parameters.Add(expr); .)
-				}
-			]
-		&quot;)&quot;		(. pexpr = new InvocationExpression(pexpr, parameters); .)
-	}
-	)
-	.
-
-/* 11.11 */
-
-CastTarget&lt;out TypeReference type&gt;
-	(.
-		type = null;
-	.) =
-	&quot;CBool&quot;		(. type = new TypeReference(&quot;System.Boolean&quot;); .)
-	| &quot;CByte&quot;	(. type = new TypeReference(&quot;System.Byte&quot;); .)
-	| &quot;CChar&quot;	(. type = new TypeReference(&quot;System.Char&quot;); .)
-	| &quot;CDate&quot;	(. type = new TypeReference(&quot;System.DateTime&quot;); .)
-	| &quot;CDec&quot;	(. type = new TypeReference(&quot;System.Decimal&quot;); .)
-	| &quot;CDbl&quot;	(. type = new TypeReference(&quot;System.Double&quot;); .)
-	| &quot;CInt&quot;	(. type = new TypeReference(&quot;System.Int32&quot;); .)
-	| &quot;CLng&quot;	(. type = new TypeReference(&quot;System.Int64&quot;); .)
-	| &quot;CObj&quot;	(. type = new TypeReference(&quot;System.Object&quot;); .)
-	| &quot;CShort&quot;	(. type = new TypeReference(&quot;System.Int16&quot;); .)
-	| &quot;CSng&quot;	(. type = new TypeReference(&quot;System.Single&quot;); .)
-	| &quot;CStr&quot;	(. type = new TypeReference(&quot;System.String&quot;); .)
-	.
-
-ConditionalOrExpr&lt;out Expression outExpr&gt;
-	(. Expression expr; .) =
-	ConditionalAndExpr&lt;out outExpr&gt;  { &quot;OrElse&quot; ConditionalAndExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanOr, expr);  .) }
-	.
-
-ConditionalAndExpr&lt;out Expression outExpr&gt;
-	(. Expression expr; .) =
-	InclusiveOrExpr&lt;out outExpr&gt;  { &quot;AndAlso&quot; InclusiveOrExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanAnd, expr);  .) }
-	.
-
-InclusiveOrExpr&lt;out Expression outExpr&gt;
-	(. Expression expr; .) =
-	ExclusiveOrExpr&lt;out outExpr&gt;  { &quot;Xor&quot; ExclusiveOrExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  .) }
-	.
-
-ExclusiveOrExpr&lt;out Expression outExpr&gt;
-	(. Expression expr; .) =
-	AndExpr&lt;out outExpr&gt;  { &quot;Or&quot; AndExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  .) }
-	.
-
-AndExpr&lt;out Expression outExpr&gt;
-	(. Expression expr; .) =
-	NotExpr&lt;out outExpr&gt; { &quot;And&quot; NotExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  .) }
-	.
-
-NotExpr&lt;out Expression outExpr&gt; 
-	(. UnaryOperatorType uop = UnaryOperatorType.None; .) =
-	{	&quot;Not&quot; (. uop = UnaryOperatorType.Not; .) }
-	EqualityExpr&lt;out outExpr&gt;
-                (. if (uop != UnaryOperatorType.None)
-	                   outExpr = new UnaryOperatorExpression(outExpr, uop);
-                .)
-	.
-
-EqualityExpr&lt;out Expression outExpr&gt;
-	(.
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-	.) =
-	RelationalExpr&lt;out outExpr&gt;
-	{
-		(
-			&quot;&lt;&gt;&quot;		(. op = BinaryOperatorType.InEquality; .)
-			| &quot;=&quot; 		(. op = BinaryOperatorType.Equality; .)
-			| &quot;Like&quot;	(. op = BinaryOperatorType.Like; .)
-		)
-		RelationalExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
-	}
-	.
-
-RelationalExpr&lt;out Expression outExpr&gt;
-	(.
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-	.) =
-	ShiftExpr&lt;out outExpr&gt;
-	{
-		(
-			&quot;&lt;&quot;    (. op = BinaryOperatorType.LessThan; .)
-			| &quot;&gt;&quot;  (. op = BinaryOperatorType.GreaterThan; .)
-			| &quot;&lt;=&quot; (. op = BinaryOperatorType.LessThanOrEqual; .)
-			| &quot;&gt;=&quot; (. op = BinaryOperatorType.GreaterThanOrEqual; .)
-		)
-		ShiftExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
-		|
-		/* 11.5.3 */
-		&quot;Is&quot; (. op = BinaryOperatorType.IS; .)
-		Expr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr); .)
-	}
-	.
-
-ShiftExpr&lt;out Expression outExpr&gt;
-	(.
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-	.) =
-	AdditiveExpr&lt;out outExpr&gt; 
-	{
-		(
-			&quot;&lt;&lt;&quot;   (. op = BinaryOperatorType.ShiftLeft; .)
-			| &quot;&gt;&gt;&quot; (. op = BinaryOperatorType.ShiftRight; .)
-		)
-		AdditiveExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
-	}
-	.
-
-AdditiveExpr&lt;out Expression outExpr&gt;
-	(.
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-	.) =
-	MultiplicativeExpr&lt;out outExpr&gt;
-	{
-		(
-			&quot;+&quot;   (. op = BinaryOperatorType.Add; .)
-			| &quot;-&quot; (. op = BinaryOperatorType.Subtract; .)
-			| &quot;&amp;&quot; (. op = BinaryOperatorType.Concat; .)
-		)
-		MultiplicativeExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
-	}
-	.
-
-MultiplicativeExpr&lt;out Expression outExpr&gt;
-	(.
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-	.) =
-    UnaryExpr&lt;out outExpr&gt;
-	{
-		(
-			&quot;*&quot;   (. op = BinaryOperatorType.Multiply; .)
-			| &quot;/&quot; (. op = BinaryOperatorType.Divide; .)
-			| &quot;\\&quot; (. op = BinaryOperatorType.DivideInteger; .)
-			| &quot;Mod&quot; (. op = BinaryOperatorType.Modulus; .)
-			| &quot;^&quot;	(. op = BinaryOperatorType.Power; .)
-		) 
-		UnaryExpr&lt;out expr&gt; (. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .) 
-	}
-	.
-	
-ObjectCreateExpression&lt;out Expression oce&gt;
-	(.
-		TypeReference type = null;
-		Expression initializer = null;
-		ArrayList arguments = null;
-		oce = null;
-	.) =
-	&quot;New&quot; ArrayTypeName&lt;out type&gt;
-	[&quot;(&quot;
-		[ ArgumentList&lt;out arguments&gt; ]
-	&quot;)&quot;
-	]
-	[
-		ArrayInitializer&lt;out initializer&gt;
-	]
-	(.
-		if(initializer == null) {
-			oce = new ObjectCreateExpression(type, arguments);
-		} else {
-			ArrayCreateExpression ace = new ArrayCreateExpression(type, initializer as ArrayInitializerExpression);
-			ace.Parameters = arguments;
-			oce = ace;
-		}
-	.)
-	.
-
-/* 9.3.2 */
-ArgumentList&lt;out ArrayList arguments&gt;
-	(.
-		arguments = new ArrayList();
-		Expression expr = null;
-	.) =
-	[
-		Argument&lt;out expr&gt;			(. arguments.Add(expr); .)
-		{
-			&quot;,&quot;
-			Argument&lt;out expr&gt;		(. arguments.Add(expr); .)
-		}
-	]
-	.
-
-/* Spec, 11.8 */
-Argument&lt;out Expression argumentexpr&gt;
-	(.
-		Expression expr;
-		argumentexpr = null;
-		string name;
-	.) =
-	IF(IsNamedAssign()) Identifier (. name = t.val;  .) &quot;:&quot; &quot;=&quot; Expr&lt;out expr&gt;
-	(.
-		argumentexpr = new NamedArgumentExpression(name, expr);
-	.)
-	|
-	Expr&lt;out argumentexpr&gt;
-	.
-
-/* 7.1. */
-TypeName&lt;out TypeReference typeref&gt;
-	(.
-		ArrayList rank = null;
-	.) =
-	NonArrayTypeName&lt;out typeref&gt;
-	ArrayTypeModifiers&lt;out rank&gt;
-	(.
-		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
-	.)
-	.
-	
-
-ArrayTypeName&lt;out TypeReference typeref&gt;
-	(.
-		ArrayList rank = null;
-	.) =
-	NonArrayTypeName&lt;out typeref&gt;
-	ArrayInitializationModifiers&lt;out rank&gt;
-	(.
-		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
-	.)
-	.
-
-/* 7.1 */
-NonArrayTypeName&lt;out TypeReference typeref&gt;
-	(.
-		string name;
-		typeref = null;
-	.) =
-	Qualident&lt;out name&gt; (. typeref = new TypeReference(name); .)
-	| &quot;Object&quot; (. typeref = new TypeReference(&quot;System.Object&quot;); .)
-	| PrimitiveTypeName&lt;out name&gt; (. typeref = new TypeReference(name); .)
-	.
-
-ArrayInitializationModifiers&lt;out ArrayList arrayModifiers&gt;
-	(.
-		arrayModifiers = new ArrayList();
-		ArrayList dim = new ArrayList();
-	.) =
-	{	
-		IF (IsDims()) &quot;(&quot;
-		[ InitializationRankList &lt;out dim&gt;]
-		(.
-			arrayModifiers.Add(dim);
-		.)
-		&quot;)&quot;
-	}
-	(.
-		if(arrayModifiers.Count == 0) {
-			 arrayModifiers = null;
-		}
-	.)
-	.
-
-/* 7.9 */
-ArrayTypeModifiers&lt;out ArrayList arrayModifiers&gt;
-	(.
-		arrayModifiers = new ArrayList();
-		int i = 0;
-	.) =
-	{	IF (IsRank())
-		&quot;(&quot;
-		[ RankList &lt;out i&gt;]
-		(.
-			arrayModifiers.Add(i);
-		.)
-		&quot;)&quot;
-	}
-	(.
-		if(arrayModifiers.Count == 0) {
-			 arrayModifiers = null;
-		}
-	.)
-	.
-
-/* 7.9 */
-RankList&lt;out int i&gt;
-	(. i = 0; .) =
-	{ &quot;,&quot; (. ++i; .) }
-	.
-
-GlobalAttributeSection =
-	(. Point startPos = t.Location; .)
-	&quot;&lt;&quot; (&quot;Assembly&quot; | &quot;Module&quot;)
-		(.
-			string attributeTarget = t.val.ToLower();
-			ArrayList attributes = new ArrayList();
-			ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
-		.)
-	&quot;:&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)
-	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
-	[ &quot;,&quot; ]
-	&quot;&gt;&quot;
-	EndOfStmt
-		(.
-			AttributeSection section = new AttributeSection(attributeTarget, attributes);
-			section.StartLocation = startPos;
-			section.EndLocation = t.EndLocation;
-			compilationUnit.AddChild(section);
-		.)
-	.
-
-/* Spec, 5. */
-Attribute&lt;out ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute&gt;
-	(. string qualident; .) =
-	Qualident&lt;out qualident&gt;
-		(.
-			ArrayList positional = new ArrayList();
-			ArrayList named      = new ArrayList();
-			string name = qualident;
-		.)
-	[ AttributeArguments&lt;ref positional, ref named&gt; ]
-	(.
-		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute(name, positional, named);
-	.)
-	.
-
-/* Spec, 5.2.2 */
-AttributeArguments&lt;ref ArrayList positional, ref ArrayList named&gt;
-	(.
-		bool nameFound = false;
-		string name = &quot;&quot;;
-		Expression expr;
-	.) =
-	&quot;(&quot;
-	[
-		IF (IsNotClosingParenthesis()) ( 
-			[
-				IF (IsNamedAssign()) (. nameFound = true; .)
-				IdentifierOrKeyword&lt;out name&gt;
-				[&quot;:&quot;] &quot;=&quot;
-			] Expr&lt;out expr&gt;
-				(.
-					if(name == &quot;&quot;) positional.Add(expr);
-					else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
-				.)
-			{
-				&quot;,&quot;
-					(
-						IF (IsNamedAssign())	(. nameFound = true; .)
-						IdentifierOrKeyword&lt;out name&gt;
-						[ &quot;:&quot; ] &quot;=&quot;
-						| (. if (nameFound) Error(&quot;no positional argument after named argument&quot;); .)
-					) Expr&lt;out expr&gt;	(. 	if(name == &quot;&quot;) positional.Add(expr);
-											else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
-										.)
-			}
-		)
-	]
-	&quot;)&quot;
-	.
-
-/* Spec, 5. */
-AttributeSection&lt;out AttributeSection section&gt;
-	(.
-		string attributeTarget = &quot;&quot;;
-		ArrayList attributes = new ArrayList();
-		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
-		
-	.) =
-	&quot;&lt;&quot; (. Point startPos = t.Location; .)
-	[ IF (IsLocalAttrTarget())
-		( &quot;Event&quot;		(. attributeTarget = &quot;event&quot;;.)
-		| &quot;Return&quot;		(. attributeTarget = &quot;return&quot;;.)
-		| Identifier
-			(.
-				string val = t.val.ToLower();
-				if (val != &quot;field&quot;	|| val != &quot;method&quot; ||
-					val != &quot;module&quot; || val != &quot;param&quot;  ||
-					val != &quot;property&quot; || val != &quot;type&quot;)
-				Error(&quot;attribute target specifier (event, return, field,&quot; +
-						&quot;method, module, param, property, or type) expected&quot;);
-				attributeTarget = t.val;
-			.)
-		) &quot;:&quot; 
-	]
-	Attribute&lt;out attribute&gt;	(. attributes.Add(attribute); .)
-	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .) }
-	[ &quot;,&quot; ]
-	&quot;&gt;&quot;
-		(.
-			section = new AttributeSection(attributeTarget, attributes);
-			section.StartLocation = startPos;
-			section.EndLocation = t.EndLocation;
-		.)
-	.
-
-/* 9.2.5 */
-FormalParameterList&lt;out ArrayList parameter&gt;
-	(.
-		parameter = new ArrayList();
-		ParameterDeclarationExpression p;
-		AttributeSection section;
-		ArrayList attributes = new ArrayList();
-	.) =
-	{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
-	(
-		FormalParameter&lt;out p&gt;
-		(.
-			bool paramsFound = false;
-			p.Attributes = attributes;
-			parameter.Add(p);
-		.)
-		{
-			&quot;,&quot;	(. attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); .)
-			{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
-			(
-				FormalParameter &lt;out p&gt;	(. p.Attributes = attributes; parameter.Add(p); .)
-			)
-		}
-	)
-	.
-/* 9.2.5 */
-FormalParameter&lt;out ParameterDeclarationExpression p&gt;
-	(.
-		TypeReference type = null;
-		ParamModifiers mod = new ParamModifiers(this);
-		Expression expr = null;
-		p = null;
-		ArrayList arrayModifiers = null;
-	.) =
-	{ ParameterModifier&lt;mod&gt; }
-	Identifier (. string parameterName = t.val; .)
-	[ IF(IsRank()) ArrayTypeModifiers&lt;out arrayModifiers&gt; ]
-	[ &quot;As&quot; TypeName&lt;out type&gt; ]
-	(.
-		if(type != null) {
-			if (arrayModifiers != null) {
-				if (type.RankSpecifier != null) {
-					Error(&quot;array rank only allowed one time&quot;);
-				} else {
-					type.RankSpecifier = arrayModifiers;
-				}
-			}
-		} else {
-			type = new TypeReference(&quot;System.Object&quot;, arrayModifiers);
-		}
-	.)
-	[ &quot;=&quot; Expr&lt;out expr&gt; ]
-	(.
-		mod.Check();
-		p = new ParameterDeclarationExpression(type, parameterName, mod, expr);
-	.)
-	.
-
-/* 10.1 */
-Block&lt;out Statement stmt&gt;
-	=
-	(.
-		BlockStatement blockStmt = new BlockStatement();
-		blockStmt.StartLocation = t.Location;
-		compilationUnit.BlockStart(blockStmt);
-	.)
-	{ Statement EndOfStmt |
-	  IF (IsEndStmtAhead()) &quot;End&quot; EndOfStmt (. compilationUnit.AddChild(new EndStatement()); .) 
-	}
-	(.
-		stmt = blockStmt;
-		blockStmt.EndLocation = t.EndLocation;
-		compilationUnit.BlockEnd();
-	.)
-	.
-
-Statement
-	(.
-		Statement stmt;
-		string label = String.Empty;
-		
-	.) =
-	IF (IsLabel()) LabelName&lt;out label&gt;
-	(.
-		labelStatement = new LabelStatement(t.val);
-		compilationUnit.AddChild(labelStatement);
-	.)
-	&quot;:&quot; [ (. isLabel = true; .) Statement ]
-	| EmbeddedStatement&lt;out stmt&gt;			(. updateLabelStatement(stmt); .)
-	| LocalDeclarationStatement&lt;out stmt&gt;	(. updateLabelStatement(stmt); .)
-	.
-
-/* 10.2 */
-LocalDeclarationStatement&lt;out Statement statement&gt;
-	(.
-		Modifiers m = new Modifiers(this);
-		ArrayList vars = new ArrayList();
-		LocalVariableDeclaration localVariableDeclaration;
-		bool dimfound = false;
-	.) =
-	/* this differs from the spec: dim static x	compiles with vbc. */
-	{
-		&quot;Const&quot; 	(. m.Add(Modifier.Constant); .)
-		| &quot;Static&quot;	(. m.Add(Modifier.Static); .)
-		| &quot;Dim&quot;		(. dimfound = true; .)
-	}
-	(.
-		if(dimfound &amp;&amp; (m.Modifier &amp; Modifier.Constant) != 0) {
-			Error(&quot;Dim is not allowed on constants.&quot;);
-		}
-		
-		if(m.isNone &amp;&amp; dimfound == false) {
-			Error(&quot;Const, Dim or Static expected&quot;);
-		}
-		
-		localVariableDeclaration = new LocalVariableDeclaration(m.Modifier);
-		localVariableDeclaration.StartLocation = t.Location;
-	.)
-	VariableDeclarator&lt;vars&gt;
-	{ &quot;,&quot; VariableDeclarator&lt;vars&gt; }
-	(.
-		localVariableDeclaration.Variables = vars;
-		statement = localVariableDeclaration;
-	.)
-	.
-
-EmbeddedStatement&lt;out Statement statement&gt;
-	(.
-		Statement embeddedStatement = null;
-		statement = null;
-		Expression expr = null;
-		string name = String.Empty;
-		ArrayList p = null;
-	.) =
-		&quot;Exit&quot;				(. ExitType exitType = ExitType.None; .)
-		(
-		&quot;Sub&quot;				(. exitType = ExitType.Sub; .)
-		|
-		&quot;Function&quot;			(. exitType = ExitType.Function; .)
-		|
-		&quot;Property&quot;			(. exitType = ExitType.Property; .)
-		|
-		&quot;Do&quot;				(. exitType = ExitType.Do; .)
-		|
-		&quot;For&quot;				(. exitType = ExitType.For; .)
-		|
-		&quot;Try&quot;				(. exitType = ExitType.Try; .)
-		|
-		&quot;While&quot;				(. exitType = ExitType.While; .)
-		|
-		&quot;Select&quot;			(. exitType = ExitType.Select; .)
-		)
-	(. statement = new ExitStatement(exitType); .)
-	| TryStatement&lt;out statement&gt;
-	| /* 10.10.1.3 */
-	&quot;Throw&quot; [ Expr&lt;out expr&gt; ]				(. statement = new ThrowStatement(expr); .)
-	| /* 10.11 */
-	&quot;Return&quot; [ Expr&lt;out expr&gt; ] 			(. statement = new ReturnStatement(expr); .)
-	| /* 10.4 */
-	&quot;SyncLock&quot; Expr&lt;out expr&gt; EndOfStmt Block&lt;out embeddedStatement&gt;
-	&quot;End&quot; &quot;SyncLock&quot; 						(. statement = new LockStatement(expr, embeddedStatement); .)
-	| /* 10.5.1 */
-	&quot;RaiseEvent&quot; Identifier (. name = t.val; .)
-	[ &quot;(&quot; [ ArgumentList&lt;out p&gt; ] &quot;)&quot; ]
-	(. statement = new RaiseEventStatement(name, p); .)
-	| /* 10.3 */
-	WithStatement&lt;out statement&gt;
-	| /* 10.5.2 */
-	&quot;AddHandler&quot; (. Expression handlerExpr = null; .)
-	Expr&lt;out expr&gt; &quot;,&quot; Expr&lt;out handlerExpr&gt;
-	(.
-		statement = new AddHandlerStatement(expr, handlerExpr);
-	.)
-	| /* 10.5.2 */
-	&quot;RemoveHandler&quot; (. Expression handlerExpr = null; .)
-	Expr&lt;out expr&gt; &quot;,&quot; Expr&lt;out handlerExpr&gt;
-	(.
-		statement = new RemoveHandlerStatement(expr, handlerExpr);
-	.)
-	| /* 10.9.1 */
-	&quot;While&quot; Expr&lt;out expr&gt; EndOfStmt
-	Block&lt;out embeddedStatement&gt; &quot;End&quot; &quot;While&quot;
-	(.
-		statement = new WhileStatement(expr, embeddedStatement);
-	.)
-	| /* 10.9.1 */
-	&quot;Do&quot;
-	(.
-		ConditionType conditionType = ConditionType.None;
-	.)
-	(
-		WhileOrUntil&lt;out conditionType&gt; Expr&lt;out expr&gt; EndOfStmt
-		Block&lt;out embeddedStatement&gt;
-		&quot;Loop&quot;
-		(.
-			statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.Start);
-		.)
-		|
-		EndOfStmt
-		Block&lt;out embeddedStatement&gt;
-		&quot;Loop&quot; [WhileOrUntil&lt;out conditionType&gt; Expr&lt;out expr&gt;]
-		(.
-			statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.End);
-		.)
-	)
-	| &quot;For&quot;
-	(.
-			Expression group = null;
-			LoopControlVariableExpression loopControlExpr = null;
-	.)
-	(
-		/* 10.9.3  */
- 		&quot;Each&quot; LoopControlVariable&lt;out loopControlExpr&gt;
-		&quot;In&quot; Expr&lt;out group&gt; EndOfStmt
-		Block&lt;out embeddedStatement&gt;
-		&quot;Next&quot; [ Expr&lt;out expr&gt; ]
-		(.
-			statement = new ForeachStatement(loopControlExpr, group, embeddedStatement, expr);
-		.)
-		| /* 10.9.2 */
-		(.
-			Expression start = null;
-			Expression end = null;
-			Expression step = null;
-			Expression nextExpr = null;
-			ArrayList nextExpressions = null;
-		.)
-		LoopControlVariable&lt;out loopControlExpr&gt;
-		&quot;=&quot; Expr&lt;out start&gt; &quot;To&quot; Expr&lt;out end&gt; [ &quot;Step&quot; Expr&lt;out step&gt; ]
-		EndOfStmt Block&lt;out embeddedStatement&gt;
-		&quot;Next&quot;
-		[
-			Expr&lt;out nextExpr&gt; (. nextExpressions = new ArrayList(); nextExpressions.Add(nextExpr); .) 
-			{ &quot;,&quot; Expr&lt;out nextExpr&gt; (. nextExpressions.Add(nextExpr); .) }
-		]
-		(.
-			statement = new ForStatement(loopControlExpr, start, end, step, embeddedStatement, nextExpressions);
-		.)
-	)
-	| /* 10.10.2.1 */
-	&quot;Error&quot; Expr&lt;out expr&gt; 				(. statement = new ErrorStatement(expr); .)
-	| /* 10.12.1 */
-	&quot;ReDim&quot; (. Expression clause = null; .) [ &quot;Preserve&quot; ]
-	Expr&lt;out clause&gt;
-	(.
-		ArrayList clauses = new ArrayList();
-		clauses.Add(clause);
-		/*ReDimStatement reDimStatement = new ReDimStatement(clauses);*/
-	.)
-	{ &quot;,&quot; Expr&lt;out clause&gt; (. clauses.Add(clause); .) }
-	| /* 10.12.2 */
-	&quot;Erase&quot;	
-	Expr&lt;out expr&gt;
-	(.
-		ArrayList arrays = new ArrayList();
-		arrays.Add(expr);
-		EraseStatement eraseStatement = new EraseStatement(arrays);
-		
-	.)
-	{ &quot;,&quot; Expr&lt;out expr&gt; (. arrays.Add(expr); .) }
-	(. statement = eraseStatement; .)
-	| /* 10.11 */
-	&quot;Stop&quot; (. statement = new StopStatement(); .)
-	| /* 10.8.1 */
-	&quot;If&quot; Expr&lt;out expr&gt; [ &quot;Then&quot; ] 
-	(	
-		IF (IsEndStmtAhead()) &quot;End&quot; (. statement = new IfStatement(expr, new EndStatement()); .) 
-		|
-		/* multiline if statement */
-		EndOfStmt Block&lt;out embeddedStatement&gt;
-		(.
-			ArrayList elseIfSections = new ArrayList();
-			IfStatement ifStatement = new IfStatement(expr, embeddedStatement);
-		.)
-		{
-			(
-				IF(IsElseIf()) &quot;Else&quot; &quot;If&quot;
-				| &quot;ElseIf&quot;
-			)
-			(. Expression condition = null; Statement block = null; .)
-			Expr&lt;out condition&gt; [ &quot;Then&quot;] EndOfStmt
-			Block&lt;out block&gt;
-			(.
-				ElseIfSection elseIfSection = new ElseIfSection(condition, block);
-				elseIfSections.Add(elseIfSection);
-			.)
-		}
-		[
-			&quot;Else&quot; EndOfStmt
-			Block&lt;out embeddedStatement&gt;
-			(.
-				ifStatement.EmbeddedElseStatement = embeddedStatement;
-			.)
-		] &quot;End&quot; &quot;If&quot;
-		(.
-			ifStatement.ElseIfStatements = elseIfSections;
-			statement = ifStatement;
-		.)
-		| /* singleline if statement */
-		EmbeddedStatement&lt;out embeddedStatement&gt;
-		(.
-			SimpleIfStatement ifStatement = new SimpleIfStatement(expr);
-			ArrayList statements = new ArrayList();
-			statements.Add(embeddedStatement);
-			ifStatement.Statements = statements;
-		.)
-		{ &quot;:&quot; EmbeddedStatement&lt;out embeddedStatement&gt; (. statements.Add(embeddedStatement); .) }
-		[
-			&quot;Else&quot; [ EmbeddedStatement&lt;out embeddedStatement&gt; ]
-			(.
-				ArrayList elseStatements = new ArrayList();
-				elseStatements.Add(embeddedStatement);
-				ifStatement.ElseStatements = elseStatements;
-			.)
-			{
-				&quot;:&quot; EmbeddedStatement&lt;out embeddedStatement&gt;
-				(. elseStatements.Add(embeddedStatement); .)
-			}
-		]
-		(. statement = ifStatement; .)
-	)
-	| /* 10.8.2 */
-	&quot;Select&quot; [ &quot;Case&quot; ] Expr&lt;out expr&gt; EndOfStmt
-	(.
-		ArrayList selectSections = new ArrayList();
-		Statement block = null;
-	.)
-	{
-		(. ArrayList caseClauses = null; .)
-		&quot;Case&quot; CaseClauses&lt;out caseClauses&gt; [ IF(IsNotStatementSeparator()) &quot;:&quot; ] EndOfStmt
-		(.
-			SelectSection selectSection = new SelectSection();
-			selectSection.CaseClauses = caseClauses;
-			compilationUnit.BlockStart(selectSection);
-		.)
-		Block&lt;out block&gt;
-		(.
-			selectSection.EmbeddedStatement = block;
-			compilationUnit.BlockEnd();
-			selectSections.Add(selectSection);
-		.)
-	}
-	(. statement = new SelectStatement(expr, selectSections); .)
-	&quot;End&quot; &quot;Select&quot;
-	| (. OnErrorStatement onErrorStatement = null; .)
-	OnErrorStatement&lt;out onErrorStatement&gt; (. statement = onErrorStatement; .)
-	| (. GoToStatement goToStatement = null; .)
-	GoToStatement&lt;out goToStatement&gt; (. statement = goToStatement; .)
-	| (. ResumeStatement resumeStatement = null; .)
-	ResumeStatement&lt;out resumeStatement&gt; (. statement = resumeStatement; .)
-	|/* Statement expression (invocation and assignment) 10.6.1, 10.6.2, 10.6.3 */
-	(.
-		Expression val = null;
-		AssignmentOperatorType op;
-		
-		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
-		                        la.kind == Tokens.Not   || la.kind == Tokens.Times;
-	.)
-	UnaryExpr&lt;out expr&gt;
-		(
-		AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt;	(. expr = new AssignmentExpression(expr, op, val); .)
-		| (. if (mustBeAssignment) Error(&quot;error in assignment.&quot;); .)
-		)
-		(.
-			// a field reference expression that stands alone is a
-			// invocation expression without parantheses and arguments
-			if(expr is FieldReferenceOrInvocationExpression) {
-				expr = new InvocationExpression(expr, new ArrayList());
-			}
-			statement = new StatementExpression(expr);
-		.)
-	| &quot;Call&quot; UnaryExpr&lt;out expr&gt; (. statement = new StatementExpression(expr); .)
-	.
-
-/* 10.9.2 */
-LoopControlVariable&lt;out LoopControlVariableExpression loopExpr&gt;
-	(.
-		loopExpr = null;
-		//Expression expr = null;
-		TypeReference type = null;
-		ArrayList arrayModifiers = null;
-		string name;
-	.) =
-	Qualident&lt;out name&gt;
-	[ IF(IsRank()) ArrayTypeModifiers&lt;out arrayModifiers&gt; ]
-	[ &quot;As&quot; TypeName&lt;out type&gt; (. if (name.IndexOf('.') &gt; 0) { Error(&quot;No type def for 'for each' member indexer allowed.&quot;); } .) ]
-	(.
-		if(type != null) {
-			if(type.RankSpecifier != null &amp;&amp; arrayModifiers != null) {
-				Error(&quot;array rank only allowed one time&quot;);
-			} else {
-				type.RankSpecifier = arrayModifiers;
-			}
-		} else {
-			type = new TypeReference(&quot;Integer&quot;, arrayModifiers);
-		}
-		loopExpr = new LoopControlVariableExpression(name, type);
-	.)
-	.
-
-/* 10.2.2 */
-OnErrorStatement&lt;out OnErrorStatement stmt&gt;
-	(.
-		stmt = null;
-		GoToStatement goToStatement = null;
-	.)
-	=
-	&quot;On&quot; &quot;Error&quot;
-	(
-		IF(IsNegativeLabelName())&quot;GoTo&quot; &quot;-&quot; LiteralInteger
-		(.
-			long intLabel = Int64.Parse(t.val);
-			if(intLabel != 1) {
-				Error(&quot;invalid label in on error statement.&quot;);
-			}
-			stmt = new OnErrorStatement(new GoToStatement((intLabel * -1).ToString()));
-		.)
-		| GoToStatement&lt;out goToStatement&gt;
-		(.
-			string val = goToStatement.LabelName;
-			
-			// if value is numeric, make sure that is 0
-			try {
-				long intLabel = Int64.Parse(val);
-				if(intLabel != 0) {
-					Error(&quot;invalid label in on error statement.&quot;);
-				}
-			} catch {
-			}
-			stmt = new OnErrorStatement(goToStatement);
-		.)
-		| &quot;Resume&quot; &quot;Next&quot;
-		(.
-			stmt = new OnErrorStatement(new ResumeStatement(true));
-		.)
-	)
-	.
-
-/* 10.11 */
-GoToStatement&lt;out GoToStatement goToStatement&gt;
-	(.
-		string label = String.Empty;
-	.)
-	=
-	&quot;GoTo&quot; LabelName&lt;out label&gt;
-	(.
-		goToStatement = new GoToStatement(label);
-	.)
-	.
-
-/* 10.1 */
-LabelName&lt;out string name&gt;
-	(.
-		name = String.Empty;
-	.) =
-	Identifier 				(. name = t.val; .)
-	| LiteralInteger	(. name = t.val; .)
-	.
-
-/* 10.10.2.3 */
-ResumeStatement&lt;out ResumeStatement resumeStatement&gt;
-	(.
-		resumeStatement = null;
-		string label = String.Empty;
-	.) =
-	IF(IsResumeNext())
-	&quot;Resume&quot; &quot;Next&quot; 					(. resumeStatement = new ResumeStatement(true); .)
-	| &quot;Resume&quot; [ LabelName&lt;out label&gt; ]	(. resumeStatement = new ResumeStatement(label); .)
-	.
-
-/* 18.8.2 */
-CaseClauses&lt;out ArrayList caseClauses&gt;
-	(.
-		caseClauses = null;
-		CaseClause caseClause = null;
-	.) =
-	CaseClause&lt;out caseClause&gt;
-	(.
-		caseClauses = new ArrayList();
-		caseClauses.Add(caseClause);
-	.)
-	{ &quot;,&quot; CaseClause&lt;out caseClause&gt; (. caseClauses.Add(caseClause); .) }
-	.
-
-/* 19.8.2 */
-CaseClause&lt;out CaseClause caseClause&gt;
-	(.
-		Expression expr = null;
-		Expression sexpr = null;
-		BinaryOperatorType op = BinaryOperatorType.None;
-		caseClause = null;
-	.) =
-	&quot;Else&quot;
-	(. caseClause = new CaseClause(true); .)
-	|
-	[ &quot;Is&quot; ] 
-	(
-		&quot;&lt;&quot;		(. op = BinaryOperatorType.LessThan; .)
-		| &quot;&gt;&quot;	(. op = BinaryOperatorType.GreaterThan; .)
-		| &quot;&lt;=&quot;	(. op = BinaryOperatorType.LessThanOrEqual; .)
-		| &quot;&gt;=&quot;	(. op = BinaryOperatorType.GreaterThanOrEqual; .)
-		| &quot;=&quot;	(. op = BinaryOperatorType.Equality; .)
-		| &quot;&lt;&gt;&quot;	(. op = BinaryOperatorType.InEquality; .)
-	)
-	Expr&lt;out expr&gt;
-	(.
-		caseClause = new CaseClause(op, expr);
-	.)
-	| Expr&lt;out expr&gt; [ &quot;To&quot; Expr&lt;out sexpr&gt; ]
-	(.
-		caseClause = new CaseClause(expr, sexpr);
-	.)
-	.
-
-/* 10.9.1 */
-WhileOrUntil&lt;out ConditionType conditionType&gt;
-	(. conditionType = ConditionType.None; .) =
-	&quot;While&quot;		(. conditionType = ConditionType.While; .)
-	| &quot;Until&quot;	(. conditionType = ConditionType.Until; .)
-	.
-
-/* 10.3 */
-WithStatement&lt;out Statement withStatement&gt;
-	(.
-		Statement blockStmt = null;
-		Expression expr = null;
-	.) =
-	&quot;With&quot; (. Point start = t.Location; .)
-	Expr&lt;out expr&gt; EndOfStmt
-	(.
-		withStatement = new WithStatement(expr);
-		withStatement.StartLocation = start;
-		withStatements.Push(withStatement);
-	.)
-	Block&lt;out blockStmt&gt;
-	(.
-		((WithStatement)withStatement).Body = (BlockStatement)blockStmt;
-		withStatements.Pop();
-	.)
-	&quot;End&quot; &quot;With&quot;
-	(. withStatement.EndLocation = t.Location; .)
-	.
-	
-/* 10.10.1 */
-TryStatement&lt;out Statement tryStatement&gt;
-	(.
-		Statement blockStmt = null, finallyStmt = null;
-		ArrayList catchClauses = null;
-	.) =
-	&quot;Try&quot; EndOfStmt
-	Block&lt;out blockStmt&gt;
-	(
-		CatchClauses&lt;out catchClauses&gt;
-		[ &quot;Finally&quot; EndOfStmt Block&lt;out finallyStmt&gt; ]
-		| &quot;Finally&quot; EndOfStmt Block&lt;out finallyStmt&gt;
-	)
-	&quot;End&quot; &quot;Try&quot;
-	(.
-		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
-	.)
-	.
-
-/* 10.10.1.2 */
-CatchClauses&lt;out ArrayList catchClauses&gt;
-	(.
-		catchClauses = new ArrayList();
-		TypeReference type = null;
-		Statement blockStmt = null;
-		Expression expr = null;
-		string name = String.Empty;
-	.) =
-	{
-		&quot;Catch&quot;
-		[ Identifier (. name = t.val; .) [&quot;As&quot; TypeName&lt;out type&gt;] ]
-		[ &quot;When&quot; Expr&lt;out expr&gt; ]
-		EndOfStmt
-		Block&lt;out blockStmt&gt;
-		(. catchClauses.Add(new CatchClause(type, name, blockStmt, expr)); .)
-	}
-	.
-
-/* 4.7 */
-Qualident&lt;out string qualident&gt;
-	(. string name = String.Empty; .) =
-	Identifier	(. StringBuilder qualidentBuilder = new StringBuilder(t.val); .)
-	{
-		&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. qualidentBuilder.Append('.');
-	                                         qualidentBuilder.Append(name); 
-	                                       .)
-	}
-	(. qualident = qualidentBuilder.ToString(); .)
-	.
-
-/* This production handles pseudo keywords that are needed in the grammar */
-Identifier	=
-	ident
-	| &quot;Text&quot;
-	| &quot;Binary&quot;
-	| &quot;Compare&quot;
-	.
-
-/* 2.2 */
-IdentifierOrKeyword&lt;out string name&gt;
-	(.
-		name = String.Empty;
-	.) =
-	Identifier		(. name = t.val; .)
-	| &quot;AddHandler&quot;		(. name = t.val; .)
-	| &quot;AddressOf&quot;		(. name = t.val; .)
-	| &quot;Alias&quot;			(. name = t.val; .)
-	| &quot;And&quot;				(. name = t.val; .)
-	| &quot;AndAlso&quot;			(. name = t.val; .)
-	| &quot;Ansi&quot;			(. name = t.val; .)
-	| &quot;As&quot;				(. name = t.val; .)
-	| &quot;Assembly&quot;		(. name = t.val; .)
-	| &quot;Auto&quot;			(. name = t.val; .)
-	| &quot;Boolean&quot;			(. name = t.val; .)
-	| &quot;ByRef&quot;			(. name = t.val; .)
-	| &quot;Byte&quot;			(. name = t.val; .)
-	| &quot;ByVal&quot;			(. name = t.val; .)
-	| &quot;Call&quot;			(. name = t.val; .)
-	| &quot;Case&quot;			(. name = t.val; .)
-	| &quot;Catch&quot;			(. name = t.val; .)
-	| &quot;CBool&quot;			(. name = t.val; .)
-	| &quot;CByte&quot;			(. name = t.val; .)
-	| &quot;CChar&quot;			(. name = t.val; .)
-	| &quot;CDate&quot;			(. name = t.val; .)
-	| &quot;CDbl&quot;			(. name = t.val; .)
-	| &quot;CDec&quot;			(. name = t.val; .)
-	| &quot;Char&quot;			(. name = t.val; .)
-	| &quot;CInt&quot;			(. name = t.val; .)
-	| &quot;Class&quot;			(. name = t.val; .)
-	| &quot;CLng&quot;			(. name = t.val; .)
-	| &quot;CObj&quot;			(. name = t.val; .)
-	| &quot;Const&quot;			(. name = t.val; .)
-	| &quot;CShort&quot;			(. name = t.val; .)
-	| &quot;CSng&quot;			(. name = t.val; .)
-	| &quot;CStr&quot;			(. name = t.val; .)
-	| &quot;CType&quot;			(. name = t.val; .)
-	| &quot;Date&quot;			(. name = t.val; .)
-	| &quot;Decimal&quot;			(. name = t.val; .)
-	| &quot;Declare&quot;			(. name = t.val; .)
-	| &quot;Default&quot;			(. name = t.val; .)
-	| &quot;Delegate&quot;		(. name = t.val; .)
-	| &quot;Dim&quot;				(. name = t.val; .)
-	| &quot;DirectCast&quot;		(. name = t.val; .)
-	| &quot;Do&quot;				(. name = t.val; .)
-	| &quot;Double&quot;			(. name = t.val; .)
-	| &quot;Each&quot;			(. name = t.val; .)
-	| &quot;Else&quot;			(. name = t.val; .)
-	| &quot;ElseIf&quot;			(. name = t.val; .)
-	| &quot;End&quot;				(. name = t.val; .)
-	| &quot;EndIf&quot;			(. name = t.val; .)
-	| &quot;Enum&quot;			(. name = t.val; .)
-	| &quot;Erase&quot;			(. name = t.val; .)
-	| &quot;Error&quot;			(. name = t.val; .)
-	| &quot;Event&quot;			(. name = t.val; .)
-	| &quot;Exit&quot;			(. name = t.val; .)
-	| &quot;False&quot;			(. name = t.val; .)
-	| &quot;Finally&quot;			(. name = t.val; .)
-	| &quot;For&quot;				(. name = t.val; .)
-	| &quot;Friend&quot;			(. name = t.val; .)
-	| &quot;Function&quot;		(. name = t.val; .)
-	| &quot;Get&quot;				(. name = t.val; .)
-	| &quot;GetType&quot;			(. name = t.val; .)
-	| &quot;GoSub&quot;			(. name = t.val; .)
-	| &quot;GoTo&quot;			(. name = t.val; .)
-	| &quot;Handles&quot;			(. name = t.val; .)
-	| &quot;If&quot;				(. name = t.val; .)
-	| &quot;Implements&quot;		(. name = t.val; .)
-	| &quot;Imports&quot;			(. name = t.val; .)
-	| &quot;In&quot;				(. name = t.val; .)
-	| &quot;Inherits&quot;		(. name = t.val; .)
-	| &quot;Integer&quot;			(. name = t.val; .)
-	| &quot;Interface&quot;		(. name = t.val; .)
-	| &quot;Is&quot;				(. name = t.val; .)
-	| &quot;Let&quot;				(. name = t.val; .)
-	| &quot;Lib&quot;				(. name = t.val; .)
-	| &quot;Like&quot;			(. name = t.val; .)
-	| &quot;Long&quot;			(. name = t.val; .)
-	| &quot;Loop&quot;			(. name = t.val; .)
-	| &quot;Me&quot;				(. name = t.val; .)
-	| &quot;Mod&quot;				(. name = t.val; .)
-	| &quot;Module&quot;			(. name = t.val; .)
-	| &quot;MustInherit&quot;		(. name = t.val; .)
-	| &quot;MustOverride&quot;	(. name = t.val; .)
-	| &quot;MyBase&quot;			(. name = t.val; .)
-	| &quot;MyClass&quot;			(. name = t.val; .)
-	| &quot;Namespace&quot;		(. name = t.val; .)
-	| &quot;New&quot;				(. name = t.val; .)
-	| &quot;Next&quot;			(. name = t.val; .)
-	| &quot;Not&quot;				(. name = t.val; .)
-	| &quot;Nothing&quot;			(. name = t.val; .)
-	| &quot;NotInheritable&quot;	(. name = t.val; .)
-	| &quot;NotOverridable&quot;	(. name = t.val; .)
-	| &quot;Object&quot;			(. name = t.val; .)
-	| &quot;On&quot;				(. name = t.val; .)
-	| &quot;Option&quot;			(. name = t.val; .)
-	| &quot;Optional&quot;		(. name = t.val; .)
-	| &quot;Or&quot;				(. name = t.val; .)
-	| &quot;OrElse&quot;			(. name = t.val; .)
-	| &quot;Overloads&quot;		(. name = t.val; .)
-	| &quot;Overridable&quot;		(. name = t.val; .)
-	| &quot;Overrides&quot;		(. name = t.val; .)
-	| &quot;ParamArray&quot;		(. name = t.val; .)
-	| &quot;Preserve&quot;		(. name = t.val; .)
-	| &quot;Private&quot;			(. name = t.val; .)
-	| &quot;Property&quot;		(. name = t.val; .)
-	| &quot;Protected&quot;		(. name = t.val; .)
-	| &quot;Public&quot;			(. name = t.val; .)
-	| &quot;RaiseEvent&quot;		(. name = t.val; .)
-	| &quot;ReadOnly&quot;		(. name = t.val; .)
-	| &quot;ReDim&quot;			(. name = t.val; .)
-	| &quot;RemoveHandler&quot;	(. name = t.val; .)
-	| &quot;Resume&quot;			(. name = t.val; .)
-	| &quot;Return&quot;			(. name = t.val; .)
-	| &quot;Select&quot;			(. name = t.val; .)
-	| &quot;Set&quot;				(. name = t.val; .)
-	| &quot;Shadows&quot;			(. name = t.val; .)
-	| &quot;Shared&quot;			(. name = t.val; .)
-	| &quot;Short&quot;			(. name = t.val; .)
-	| &quot;Single&quot;			(. name = t.val; .)
-	| &quot;Static&quot;			(. name = t.val; .)
-	| &quot;Step&quot;			(. name = t.val; .)
-	| &quot;Stop&quot;			(. name = t.val; .)
-	| &quot;String&quot;			(. name = t.val; .)
-	| &quot;Structure&quot;		(. name = t.val; .)
-	| &quot;Sub&quot;				(. name = t.val; .)
-	| &quot;SyncLock&quot;		(. name = t.val; .)
-	| &quot;Then&quot;			(. name = t.val; .)
-	| &quot;Throw&quot;			(. name = t.val; .)
-	| &quot;To&quot;				(. name = t.val; .)
-	| &quot;True&quot;			(. name = t.val; .)
-	| &quot;Try&quot;				(. name = t.val; .)
-	| &quot;TypeOf&quot;			(. name = t.val; .)
-	| &quot;Unicode&quot;			(. name = t.val; .)
-	| &quot;Until&quot;			(. name = t.val; .)
-	| &quot;Variant&quot;			(. name = t.val; .)
-	| &quot;Wend&quot;			(. name = t.val; .)
-	| &quot;When&quot;			(. name = t.val; .)
-	| &quot;While&quot;			(. name = t.val; .)
-	| &quot;With&quot;			(. name = t.val; .)
-	| &quot;WithEvents&quot;		(. name = t.val; .)
-	| &quot;WriteOnly&quot;		(. name = t.val; .)
-	| &quot;Xor&quot;				(. name = t.val; .)
-	.
-
-/* 7.3 */
-PrimitiveTypeName&lt;out string type&gt;
-	(. type = String.Empty; .) =
-	&quot;Boolean&quot;		(. type = &quot;Boolean&quot;; .)
-	| &quot;Date&quot;		(. type = &quot;Date&quot;; .)
-	| &quot;Char&quot;		(. type = &quot;Char&quot;; .)
-	| &quot;String&quot;		(. type = &quot;String&quot;; .)
-	| &quot;Decimal&quot;		(. type = &quot;Decimal&quot;; .)
-	| &quot;Byte&quot;		(. type = &quot;Byte&quot;; .)
-	| &quot;Short&quot;		(. type = &quot;Short&quot;; .)
-	| &quot;Integer&quot;		(. type = &quot;Integer&quot;; .)
-	| &quot;Long&quot;		(. type = &quot;Long&quot;; .)
-	| &quot;Single&quot;		(. type = &quot;Single&quot;; .)
-	| &quot;Double&quot;		(. type = &quot;Double&quot;; .)
-	.
-
-ParameterModifier&lt;ParamModifiers m&gt;
-	= &quot;ByVal&quot;			(. m.Add(ParamModifier.ByVal); .)
-	| &quot;ByRef&quot;			(. m.Add(ParamModifier.ByRef); .)
-	| &quot;Optional&quot;		(. m.Add(ParamModifier.Optional); .)
-	| &quot;ParamArray&quot;		(. m.Add(ParamModifier.ParamArray); .)
-	.
-
-TypeModifier&lt;Modifiers m&gt;
-	= &quot;Public&quot;			(. m.Add(Modifier.Public); .)
-	| &quot;Protected&quot;		(. m.Add(Modifier.Protected); .)
-	| &quot;Friend&quot;			(. m.Add(Modifier.Friend); .)
-	| &quot;Private&quot;			(. m.Add(Modifier.Private); .)
-	| &quot;Shared&quot;			(. m.Add(Modifier.Shared); .)
-	| &quot;Shadows&quot;			(. m.Add(Modifier.Shadows); .)
-	| &quot;MustInherit&quot;		(. m.Add(Modifier.MustInherit); .)
-	| &quot;NotInheritable&quot;	(. m.Add(Modifier.NotInheritable); .)
-	.
-
-MemberModifier&lt;Modifiers m&gt; =
-	&quot;MustInherit&quot;		(.m.Add(Modifier.MustInherit);.)
-	|&quot;Default&quot;			(.m.Add(Modifier.Default);.)
-	|&quot;Friend&quot;			(.m.Add(Modifier.Friend);.)
-	|&quot;Shadows&quot;			(.m.Add(Modifier.Shadows);.)
-	|&quot;Overrides&quot;		(.m.Add(Modifier.Overrides);.)
-	|&quot;MustOverride&quot;		(.m.Add(Modifier.MustOverride);.)
-	|&quot;Private&quot;			(.m.Add(Modifier.Private);.)
-	|&quot;Protected&quot;		(.m.Add(Modifier.Protected);.)
-	|&quot;Public&quot;			(.m.Add(Modifier.Public);.)
-	|&quot;NotInheritable&quot;	(.m.Add(Modifier.NotInheritable);.)
-	|&quot;NotOverridable&quot;	(.m.Add(Modifier.NotOverridable);.)
-	|&quot;Shared&quot;			(.m.Add(Modifier.Shared);.)
-	|&quot;Overridable&quot;		(.m.Add(Modifier.Overridable);.)
-	|&quot;Overloads&quot;		(.m.Add(Modifier.Overloads);.)
-	| &quot;ReadOnly&quot;		(.m.Add(Modifier.ReadOnly);.)
-	| &quot;WriteOnly&quot;		(.m.Add(Modifier.WriteOnly);.)
-	| &quot;WithEvents&quot;		(.m.Add(Modifier.WithEvents);.)
-	| &quot;Dim&quot;				(.m.Add(Modifier.Dim);.)
-	.
-
-END VBNET.
+using System.Drawing;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
+
+COMPILER VBNET
+
+private string assemblyName = null;
+public CompilationUnit compilationUnit;
+private ArrayList importedNamespaces = null;
+private Stack withStatements;
+private bool isLabel = false;
+private LabelStatement labelStatement = null;
+
+public string ContainingAssembly
+{
+	set { assemblyName = value; }
+}
+
+Token t
+{
+	get {
+		return lexer.Token;
+	}
+}
+Token la
+{
+	get {
+		return lexer.LookAhead;
+	}
+}
+
+void updateLabelStatement(Statement stmt)
+{
+	if(isLabel) {
+		labelStatement.EmbeddedStatement = stmt;
+		isLabel = false;
+	} else {
+		compilationUnit.AddChild(stmt);
+	}
+}
+
+/* Return the n-th token after the current lookahead token */
+void StartPeek()
+{
+	lexer.StartPeek();
+}
+
+Token Peek()
+{
+	return lexer.Peek();
+}
+
+Token Peek (int n)
+{
+	lexer.StartPeek();
+	Token x = la;
+	while (n &gt; 0) {
+		x = lexer.Peek();
+		n--;
+	}
+	return x;
+}
+
+public void Error(string s)
+{
+	if (errDist &gt;= minErrDist) {
+		errors.Error(la.line, la.col, s);
+	}
+	errDist = 0;
+}
+
+public Expression ParseExpression(Lexer lexer)
+{
+	this.errors = lexer.Errors;
+	this.lexer = lexer;
+	errors.SynErr = new ErrorCodeProc(SynErr);
+	lexer.NextToken();
+	Expression expr;
+	Expr(out expr);
+	return expr;
+}
+
+bool IsEndStmtAhead()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.End &amp;&amp; (peek == Tokens.EOL || peek == Tokens.Colon);
+}
+
+bool IsNotClosingParenthesis() {
+	return la.kind != Tokens.CloseParenthesis;
+}
+
+/*
+	True, if ident is followed by &quot;=&quot;
+*/
+bool IdentAndAsgn () {
+	if(la.kind == Tokens.Identifier) {
+		if(Peek(1).kind == Tokens.Assign) return true;
+		if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
+	}
+	return false;
+}
+
+/*
+	True, if ident is followed by &quot;=&quot; or by &quot;:&quot; and &quot;=&quot;
+*/
+bool IsNamedAssign() {
+//	if(Peek(1).kind == Tokens.Assign) return true; // removed: not in the lang spec
+	if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
+	return false;
+}
+
+bool IsObjectCreation() {
+	return la.kind == Tokens.As &amp;&amp; Peek(1).kind == Tokens.New;
+}
+
+/*
+	True, if &quot;&lt;&quot; is followed by the ident &quot;assembly&quot; or &quot;module&quot;
+*/
+bool IsGlobalAttrTarget () {
+	Token pt = Peek(1);
+	return la.kind == Tokens.LessThan &amp;&amp; ( pt.val.ToLower() == &quot;assembly&quot; || pt.val.ToLower() == &quot;module&quot;);
+}
+
+/*
+	True if the next token is a &quot;(&quot; and is followed by &quot;,&quot; or &quot;)&quot;
+*/
+bool IsRank()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.OpenParenthesis
+						&amp;&amp; (peek == Tokens.Comma || peek == Tokens.CloseParenthesis);
+}
+
+bool IsDims()
+{
+	int peek = Peek(1).kind;
+	int peek_n = Peek(2).kind;
+	return la.kind == Tokens.OpenParenthesis
+						&amp;&amp; (peek == Tokens.LiteralInteger &amp;&amp; peek_n == Tokens.CloseParenthesis);
+}
+
+bool IsSize()
+{
+	return la.kind == Tokens.OpenParenthesis;
+}
+
+/*
+	True, if the comma is not a trailing one,
+	like the last one in: a, b, c,
+*/
+bool NotFinalComma() {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Comma &amp;&amp;
+		   peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
+}
+
+/*
+	True, if the next token is &quot;Else&quot; and this one
+	if followed by &quot;If&quot;
+*/
+bool IsElseIf()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Else &amp;&amp; peek == Tokens.If;
+}
+
+/*
+	True if the next token is goto and this one is
+	followed by minus (&quot;-&quot;) (this is allowd in in
+	error clauses)
+*/
+bool IsNegativeLabelName()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.GoTo &amp;&amp; peek == Tokens.Minus;
+}
+
+/*
+	True if the next statement is a &quot;Resume next&quot; statement
+*/
+bool IsResumeNext()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Resume &amp;&amp; peek == Tokens.Next;
+}
+
+/*
+	True, if ident/literal integer is followed by &quot;:&quot;
+*/
+bool IsLabel()
+{
+	return (la.kind == Tokens.Identifier || la.kind == Tokens.LiteralInteger)
+			&amp;&amp; Peek(1).kind == Tokens.Colon;
+}
+
+bool IsNotStatementSeparator()
+{
+	return la.kind == Tokens.Colon &amp;&amp; Peek(1).kind == Tokens.EOL;
+}
+
+bool IsAssignment ()
+{
+	return IdentAndAsgn();
+}
+
+bool IsMustOverride(Modifiers m)
+{
+	return m.Contains(Modifier.MustOverride);
+}
+
+/*
+	True, if lookahead is a local attribute target specifier,
+	i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,
+	&quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;
+*/
+bool IsLocalAttrTarget() {
+	// TODO
+	return false;
+}
+
+TOKENS
+	/*----- terminal classes -----*/
+	/* EOF is 0 */
+	EOL
+	ident
+	LiteralString
+	LiteralCharacter
+	LiteralInteger
+	LiteralDouble
+	LiteralSingle
+	LiteralDecimal
+	LiteralDate
+	
+	/*----- special character -----*/
+	&quot;.&quot;
+	&quot;=&quot;
+	&quot;,&quot;
+	&quot;:&quot;
+	&quot;+&quot;
+	&quot;-&quot;
+	&quot;*&quot;
+	&quot;/&quot;
+	&quot;\\&quot;
+	&quot;&amp;&quot;
+	&quot;^&quot;
+	
+	&quot;{&quot;
+	&quot;}&quot;
+	
+	&quot;[&quot;
+	&quot;]&quot;
+	
+	&quot;(&quot;
+	&quot;)&quot;
+	
+	&quot;&gt;&quot;
+	&quot;&lt;&quot;
+	
+	&quot;&lt;&gt;&quot;
+	&quot;&gt;=&quot;
+	&quot;&lt;=&quot;
+	
+	&quot;&lt;&lt;&quot;
+	&quot;&gt;&gt;&quot;
+	
+	&quot;+=&quot;
+	&quot;^=&quot;
+	&quot;-=&quot;
+	&quot;*=&quot;
+	&quot;/=&quot;
+	&quot;\\=&quot;
+	&quot;&lt;&lt;=&quot;
+	&quot;&gt;&gt;=&quot;
+	&quot;&amp;=&quot;
+	
+	/*----- VB.NET keywords -----*/
+	&quot;AddHandler&quot;
+	&quot;AddressOf&quot;
+	&quot;Alias&quot;
+	&quot;And&quot;
+	&quot;AndAlso&quot;
+	&quot;Ansi&quot;
+	&quot;As&quot;
+	&quot;Assembly&quot;
+	&quot;Auto&quot;
+	&quot;Binary&quot;
+	&quot;Boolean&quot;
+	&quot;ByRef&quot;
+	&quot;Byte&quot;
+	&quot;ByVal&quot;
+	&quot;Call&quot;
+	&quot;Case&quot;
+	&quot;Catch&quot;
+	&quot;CBool&quot;
+	&quot;CByte&quot;
+	&quot;CChar&quot;
+	&quot;CDate&quot;
+	&quot;CDbl&quot;
+	&quot;CDec&quot;
+	&quot;Char&quot;
+	&quot;CInt&quot;
+	&quot;Class&quot;
+	&quot;CLng&quot;
+	&quot;CObj&quot;
+	&quot;Compare&quot;
+	&quot;Const&quot;
+	&quot;CShort&quot;
+	&quot;CSng&quot;
+	&quot;CStr&quot;
+	&quot;CType&quot;
+	&quot;Date&quot;
+	&quot;Decimal&quot;
+	&quot;Declare&quot;
+	&quot;Default&quot;
+	&quot;Delegate&quot;
+	&quot;Dim&quot;
+	&quot;DirectCast&quot;
+	&quot;Do&quot;
+	&quot;Double&quot;
+	&quot;Each&quot;
+	&quot;Else&quot;
+	&quot;ElseIf&quot;
+	&quot;End&quot;
+	&quot;EndIf&quot;
+	&quot;Enum&quot;
+	&quot;Erase&quot;
+	&quot;Error&quot;
+	&quot;Event&quot;
+	&quot;Exit&quot;
+	&quot;Explicit&quot;
+	&quot;False&quot;
+	&quot;Finally&quot;
+	&quot;For&quot;
+	&quot;Friend&quot;
+	&quot;Function&quot;
+	&quot;Get&quot;
+	&quot;GetType&quot;
+	&quot;GoSub&quot;
+	&quot;GoTo&quot;
+	&quot;Handles&quot;
+	&quot;If&quot;
+	&quot;Implements&quot;
+	&quot;Imports&quot;
+	&quot;In&quot;
+	&quot;Inherits&quot;
+	&quot;Integer&quot;
+	&quot;Interface&quot;
+	&quot;Is&quot;
+	&quot;Let&quot;
+	&quot;Lib&quot;
+	&quot;Like&quot;
+	&quot;Long&quot;
+	&quot;Loop&quot;
+	&quot;Me&quot;
+	&quot;Mod&quot;
+	&quot;Module&quot;
+	&quot;MustInherit&quot;
+	&quot;MustOverride&quot;
+	&quot;MyBase&quot;
+	&quot;MyClass&quot;
+	&quot;Namespace&quot;
+	&quot;New&quot;
+	&quot;Next&quot;
+	&quot;Not&quot;
+	&quot;Nothing&quot;
+	&quot;NotInheritable&quot;
+	&quot;NotOverridable&quot;
+	&quot;Object&quot;
+	&quot;Off&quot;
+	&quot;On&quot;
+	&quot;Option&quot;
+	&quot;Optional&quot;
+	&quot;Or&quot;
+	&quot;OrElse&quot;
+	&quot;Overloads&quot;
+	&quot;Overridable&quot;
+	&quot;Override&quot;
+	&quot;Overrides&quot;
+	&quot;ParamArray&quot;
+	&quot;Preserve&quot;
+	&quot;Private&quot;
+	&quot;Property&quot;
+	&quot;Protected&quot;
+	&quot;Public&quot;
+	&quot;RaiseEvent&quot;
+	&quot;ReadOnly&quot;
+	&quot;ReDim&quot;
+	&quot;RemoveHandler&quot;
+	&quot;Resume&quot;
+	&quot;Return&quot;
+	&quot;Select&quot;
+	&quot;Set&quot;
+	&quot;Shadows&quot;
+	&quot;Shared&quot;
+	&quot;Short&quot;
+	&quot;Single&quot;
+	&quot;Static&quot;
+	&quot;Step&quot;
+	&quot;Stop&quot;
+	&quot;Strict&quot;
+	&quot;String&quot;
+	&quot;Structure&quot;
+	&quot;Sub&quot;
+	&quot;SyncLock&quot;
+	&quot;Text&quot;
+	&quot;Then&quot;
+	&quot;Throw&quot;
+	&quot;To&quot;
+	&quot;True&quot;
+	&quot;Try&quot;
+	&quot;TypeOf&quot;
+	&quot;Unicode&quot;
+	&quot;Until&quot;
+	&quot;Variant&quot;
+	&quot;Wend&quot;
+	&quot;When&quot;
+	&quot;While&quot;
+	&quot;With&quot;
+	&quot;WithEvents&quot;
+	&quot;WriteOnly&quot;
+	&quot;Xor&quot;
+	
+PRODUCTIONS
+
+VBNET
+	(.
+		compilationUnit = new CompilationUnit();
+		withStatements = new Stack();
+	.) =
+	{ EOL }
+	{ OptionStmt }
+	{ ImportsStmt}
+	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
+	{ NamespaceMemberDecl }
+	EOF
+	.
+
+OptionStmt (. INode node = null; bool val = true; .) =
+	&quot;Option&quot; (. Point startPos = t.Location; .)
+	(
+		&quot;Explicit&quot; [ OptionValue&lt;ref val&gt; ]
+		(. node = new OptionExplicitDeclaration(val); .)
+		|
+		&quot;Strict&quot; [ OptionValue&lt;ref val&gt; ]
+		(. node = new OptionStrictDeclaration(val); .)
+		|
+		&quot;Compare&quot; ( &quot;Binary&quot; (. node = new OptionCompareDeclaration(CompareType.Binary); .)
+				  | &quot;Text&quot; (. node = new OptionCompareDeclaration(CompareType.Text); .)
+				  )
+	)
+	EndOfStmt
+	(.
+		node.StartLocation = startPos;
+		node.EndLocation   = t.Location;
+		compilationUnit.AddChild(node);
+	.)
+	.
+
+OptionValue&lt;ref bool val&gt; =
+	(
+		&quot;On&quot; (. val = true; .)
+	|
+		&quot;Off&quot; (. val = true; .)
+	)
+	.
+
+EndOfStmt =
+	(
+		EOL
+	|
+		&quot;:&quot;
+	)
+	.
+
+ImportsStmt
+	(.
+		ArrayList importClauses = new ArrayList();
+		importedNamespaces = new ArrayList();
+		object importClause;
+	.) =
+	&quot;Imports&quot;
+	(.
+		Point startPos = t.Location;
+		ImportsStatement importsStatement = new ImportsStatement(null);
+	.)
+	ImportClause&lt;out importClause&gt; (. importClauses.Add(importClause); .)
+	{
+		&quot;,&quot; ImportClause&lt;out importClause&gt; (. importClauses.Add(importClause); .)
+	}
+	EndOfStmt
+	(.
+		importsStatement.ImportClauses = importClauses;
+		importsStatement.StartLocation = startPos;
+		importsStatement.EndLocation   = t.Location;
+		compilationUnit.AddChild(importsStatement);
+	.)
+	.
+
+ImportClause&lt;out object importClause&gt;
+	(.
+		string qualident = null;
+		string aliasident = null;
+		importClause = null;
+	.) =
+	[ IF (IsAssignment()) Identifier (. aliasident = t.val;  .) &quot;=&quot; ]
+	Qualident&lt;out qualident&gt;
+	(.
+		if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
+			if (aliasident != null) {
+				importClause = new ImportsAliasDeclaration(aliasident, qualident);
+			} else {
+				importedNamespaces.Add(qualident);
+				importClause = new ImportsDeclaration(qualident);
+			}
+		}
+	.)
+	.
+
+/* 6.4.2 */
+NamespaceMemberDecl
+	(.
+		Modifiers m = new Modifiers(this);
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		string qualident;
+	.) =
+	&quot;Namespace&quot;
+	(.
+		Point startPos = t.Location;
+	.)
+	Qualident&lt;out qualident&gt;
+	(.
+		INode node =  new NamespaceDeclaration(qualident);
+		node.StartLocation = startPos;
+		compilationUnit.AddChild(node);
+		compilationUnit.BlockStart(node);
+	.)
+	EOL
+	NamespaceBody
+	(.
+		node.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	|
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	{ TypeModifier&lt;m&gt; } NonModuleDeclaration&lt;m, attributes&gt;
+	.
+
+/* 6.4.2 */
+NonModuleDeclaration&lt;Modifiers m, ArrayList attributes&gt;
+			(.
+				string name = String.Empty;
+				ArrayList names = null;
+			.) =
+	(. m.Check(Modifier.Classes); .)
+	/* Spec, 7.5 */
+	&quot;Class&quot;
+					(. TypeDeclaration newType = new TypeDeclaration();
+						compilationUnit.AddChild(newType);
+						compilationUnit.BlockStart(newType);
+						newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+						newType.Type = Types.Class;
+						newType.Modifier = m.Modifier;
+						newType.Attributes = attributes;
+					.)
+	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
+	EndOfStmt
+	[ ClassBaseType&lt;out name&gt; (. newType.BaseType = name; .) ]
+	{ TypeImplementsClause&lt;out names&gt; (. newType.BaseInterfaces = names; .) }
+	ClassBody&lt;newType&gt;
+	(.
+		compilationUnit.BlockEnd();
+	.)
+	| &quot;Module&quot;
+		(.
+			m.Check(Modifier.Modules);
+			TypeDeclaration newType = new TypeDeclaration();
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.StartLocation = t.Location;
+			newType.Type = Types.Module;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+		.)
+	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation;  .) 
+	EOL
+	ModuleBody&lt;newType&gt;
+	(.
+		newType.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	| &quot;Structure&quot;
+		(.
+			m.Check(Modifier.Structures);
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			newType.StartLocation = t.Location;
+			newType.Type = Types.Structure;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			ArrayList baseInterfaces = new ArrayList();
+		.)
+	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
+	EOL { TypeImplementsClause&lt;out baseInterfaces&gt; }
+	StructureBody&lt;newType&gt;
+	(.
+		newType.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	| /* 7.4 */
+	&quot;Enum&quot;
+		(.
+			m.Check(Modifier.Enums);
+			TypeDeclaration newType = new TypeDeclaration();
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			
+			newType.Type = Types.Enum;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+		.)
+	Identifier
+	(. newType.Name = t.val; newType.StartLocation = t.EndLocation; .)
+	[ &quot;As&quot; PrimitiveTypeName&lt;out name&gt; (. newType.BaseType = name; .) ]
+	EOL
+	EnumBody&lt;newType&gt;
+	(.
+		newType.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	| /* 7.8 */
+	&quot;Interface&quot;
+		(.
+			m.Check(Modifier.Interfaces);
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			
+			newType.Type = Types.Interface;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			ArrayList baseInterfaces = new ArrayList();
+		.)
+	Identifier			 (. newType.Name = t.val; newType.StartLocation = t.EndLocation; .) 
+	EndOfStmt { InterfaceBase&lt;out baseInterfaces&gt; (. newType.BaseInterfaces = baseInterfaces; .) }
+	InterfaceBody&lt;newType&gt;
+	(.
+		newType.EndLocation = t.Location;
+		compilationUnit.BlockEnd();
+	.)
+	| /* 7.10 */
+	&quot;Delegate&quot;
+	(.
+		m.Check(Modifier.Delegates);
+		DelegateDeclaration delegateDeclr = new DelegateDeclaration();
+		ArrayList p = null;
+		TypeReference type = null;
+		delegateDeclr.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+		delegateDeclr.StartLocation = t.Location;
+		delegateDeclr.Modifier = m.Modifier;
+		delegateDeclr.Attributes = attributes;
+	.)
+	(
+		&quot;Sub&quot; Identifier (. delegateDeclr.Name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. delegateDeclr.Parameters = p; .) ]
+		|
+		&quot;Function&quot; Identifier (. delegateDeclr.Name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. delegateDeclr.Parameters = p; .) ]
+		[ &quot;As&quot; TypeName&lt;out type&gt; (. delegateDeclr.ReturnType = type; .)]
+	)
+	(. 		delegateDeclr.EndLocation = t.EndLocation; .)
+	EOL
+	(.
+		compilationUnit.AddChild(delegateDeclr);
+	.)
+	.
+
+NamespaceBody =
+	{ NamespaceMemberDecl }
+	&quot;End&quot; &quot;Namespace&quot;
+	EOL
+	.
+
+ClassBody&lt;TypeDeclaration newType&gt;
+	(. AttributeSection section; .) =
+	{
+		(.
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+		.)
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; }
+		ClassMemberDecl&lt;m, attributes&gt;
+	}
+	&quot;End&quot; &quot;Class&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+StructureBody&lt;TypeDeclaration newType&gt;
+	(. AttributeSection section; .) =
+	{
+		(.
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+		.)
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; }
+		StructureMemberDecl&lt;m, attributes&gt;
+	}
+	&quot;End&quot; &quot;Structure&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+/* 7.7.1 */
+ModuleBody&lt;TypeDeclaration newType&gt;
+	(. AttributeSection section; .) =
+	{
+		(.
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+		.)
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; }
+		ClassMemberDecl&lt;m, attributes&gt;
+	}
+	&quot;End&quot; &quot;Module&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+EnumBody&lt;TypeDeclaration newType&gt;
+	(. FieldDeclaration f; .) =
+	{
+		EnumMemberDecl&lt;out f&gt; (. compilationUnit.AddChild(f); .)
+	}
+	&quot;End&quot; &quot;Enum&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+InterfaceBody&lt;TypeDeclaration newType&gt; =
+	{ InterfaceMemberDecl }
+	&quot;End&quot; &quot;Interface&quot; (. newType.EndLocation = t.EndLocation; .)
+	EOL
+	.
+
+/*
+	The information provided in the spec about
+	interface declarations is wrong
+*/
+InterfaceMemberDecl
+	(.
+		TypeReference type =null;
+		ArrayList p = null;
+		AttributeSection section;
+		Modifiers mod = new Modifiers(this);
+		ArrayList attributes = new ArrayList();
+		/*ArrayList parameters = new ArrayList();*/
+		string name;
+	.) =
+	{ AttributeSection&lt;out section&gt;			(. attributes.Add(section); .) }
+	/* this is different to c#: not only the Shadows modifier is allowed,
+	   also member modifiers like overloads etc.
+	*/
+	{ MemberModifier&lt;mod&gt; }
+	(
+		&quot;Event&quot;
+		(. mod.Check(Modifier.InterfaceEvents); .)
+		Identifier (. name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		[ &quot;As&quot; TypeName&lt;out type&gt; ]
+		EOL
+		(.
+			EventDeclaration ed = new EventDeclaration(type, mod.Modifier, p, attributes, name, null);
+			ed.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(ed);
+			ed.EndLocation = t.EndLocation;
+		.)
+		|
+		&quot;Sub&quot;
+		(.
+			mod.Check(Modifier.InterfaceMethods);
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+		.)
+		Identifier (. name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		EOL
+		(.
+			MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, null, p, attributes);
+			md.Specials[&quot;before&quot;] = comments;
+			md.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(md);
+		.)
+		|
+		&quot;Function&quot;
+		(.
+			mod.Check(Modifier.InterfaceMethods);
+			AttributeSection attributeSection = null;
+		.)
+		Identifier (. name = t.val; .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		[ &quot;As&quot; [AttributeSection&lt;out attributeSection&gt; ] TypeName&lt;out type&gt; ]
+		(.
+			if(type == null) {
+				type = new TypeReference(&quot;System.Object&quot;);
+			}
+			type.Attributes = attributeSection;
+			MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, type, p, attributes);
+			md.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			md.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(md);
+		.)
+		EOL
+		|
+		&quot;Property&quot;
+		(.
+			mod.Check(Modifier.InterfaceProperties);
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+		.)
+		Identifier	(. name = t.val;  .)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		[ &quot;As&quot; TypeName&lt;out type&gt; ]
+		(.
+			if(type == null) {
+				type = new TypeReference(&quot;System.Object&quot;);
+			}
+		.)
+		EOL
+		(.
+			PropertyDeclaration pd = new PropertyDeclaration(name, type, mod.Modifier, attributes);
+			pd.Parameters = p;
+			pd.Specials[&quot;before&quot;] = comments;
+			pd.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(pd);
+		.)
+	)
+	| /* inner type declarations */
+	NonModuleDeclaration&lt;mod, attributes&gt;
+	.
+
+/* 7.4.1 */
+EnumMemberDecl&lt;out FieldDeclaration f&gt;
+	(.
+		Expression expr = null;
+		ArrayList attributes = new ArrayList();
+		AttributeSection section = null;
+		VariableDeclaration varDecl = null;
+	.) =
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	Identifier
+	(.
+		f = new FieldDeclaration(attributes);
+		varDecl = new VariableDeclaration(t.val);
+		varDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+		f.Fields.Add(varDecl);
+		f.StartLocation = t.Location;
+	.)
+	[ &quot;=&quot; Expr&lt;out expr&gt; (. varDecl.Initializer = expr; .) ]
+	EOL
+	.
+
+ClassMemberDecl&lt;Modifiers m, ArrayList attributes&gt; =
+	StructureMemberDecl&lt;m, attributes&gt;
+	.
+
+ClassBaseType&lt;out string name&gt;
+	(.
+		TypeReference type;
+		name = String.Empty;
+	.) =
+	&quot;Inherits&quot;
+	TypeName&lt;out type&gt; (. name = type.Type; .)
+	EndOfStmt
+	.
+
+/* 7.6.1 */
+StructureMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
+	(.
+		TypeReference type = null;
+		ArrayList p = null;
+		Statement stmt = null;
+		ArrayList variableDeclarators = new ArrayList();
+	.)=
+	NonModuleDeclaration&lt;m, attributes&gt;
+	| /* 9.2.1 */
+	&quot;Sub&quot;
+	(.
+		Point startPos = t.Location;
+		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+	.)
+	(
+		(.
+			string name = String.Empty;
+			MethodDeclaration methodDeclaration;
+			HandlesClause handlesClause = null;
+			ImplementsClause implementsClause = null;
+		.)
+		Identifier
+		(.
+			name = t.val;
+			m.Check(Modifier.Methods);
+		.)
+		[ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		[
+			(
+				ImplementsClause&lt;out implementsClause&gt;
+				|
+				HandlesClause&lt;out handlesClause&gt;
+			)
+		]
+		(. Point endLocation = t.EndLocation; .)
+		EOL
+		(
+			/* abstract methods without a body */
+			IF(IsMustOverride(m))
+			(.
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = comments;
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = endLocation;
+				
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				
+				compilationUnit.AddChild(methodDeclaration);
+			.)
+		|
+			(.
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = comments;
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = endLocation;
+				
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				
+				compilationUnit.AddChild(methodDeclaration);
+				compilationUnit.BlockStart(methodDeclaration);
+			.)
+			Block&lt;out stmt&gt;
+			(.
+				compilationUnit.BlockEnd();
+				methodDeclaration.Body  = (BlockStatement)stmt;
+			.)
+			&quot;End&quot; &quot;Sub&quot; (. methodDeclaration.Body.EndLocation = t.EndLocation; .) EOL 
+		)
+		/* 9.3 */
+		| &quot;New&quot; [ &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+		(. m.Check(Modifier.Constructors); .)
+		(. Point constructorEndLocation = t.EndLocation; .)
+		EOL
+		Block&lt;out stmt&gt;
+		&quot;End&quot; &quot;Sub&quot; (. Point endLocation = t.EndLocation; .) EOL
+		(.
+			ConstructorDeclaration cd = new ConstructorDeclaration(&quot;New&quot;, m.Modifier, p, attributes); 
+			cd.StartLocation = startPos;
+			cd.Specials[&quot;before&quot;] = comments;
+			cd.EndLocation   = constructorEndLocation;
+			cd.Body = (BlockStatement)stmt;
+			cd.Body.EndLocation   = endLocation;
+			compilationUnit.AddChild(cd);
+		.)
+	)
+	|
+	/* 9.2.1 */
+	&quot;Function&quot;
+	(.
+		m.Check(Modifier.Methods);
+		string name = String.Empty;
+		Point startPos = t.Location;
+		MethodDeclaration methodDeclaration;
+		HandlesClause handlesClause = null;
+		ImplementsClause implementsClause = null;
+		AttributeSection attributeSection = null;
+	.)
+	Identifier			(. name = t.val; .)
+	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+	[&quot;As&quot; [AttributeSection&lt;out attributeSection&gt;] TypeName&lt;out type&gt; ]
+	(.
+		if(type == null) {
+			type = new TypeReference(&quot;System.Object&quot;);
+		}
+		type.Attributes = attributeSection;
+	.)
+	[
+		(
+			ImplementsClause&lt;out implementsClause&gt;
+			|
+			HandlesClause&lt;out handlesClause&gt;
+		)
+	]
+	EOL
+	(
+		/* abstract methods without a body */
+		IF(IsMustOverride(m))
+			(.
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = t.EndLocation;
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				compilationUnit.AddChild(methodDeclaration);
+			.)
+		|
+			(.
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = t.EndLocation;
+				
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				
+				compilationUnit.AddChild(methodDeclaration);
+				compilationUnit.BlockStart(methodDeclaration);
+			.)
+			Block&lt;out stmt&gt;
+			(.
+				compilationUnit.BlockEnd();
+				methodDeclaration.Body  = (BlockStatement)stmt;
+			.)
+			&quot;End&quot; &quot;Function&quot; 
+			(.
+				methodDeclaration.Body.StartLocation = methodDeclaration.EndLocation;
+				methodDeclaration.Body.EndLocation   = t.EndLocation;
+			.)
+			EOL
+	)
+	|
+	/* 9.2.2. */
+	&quot;Declare&quot;
+	(.
+		m.Check(Modifier.ExternalMethods);
+		Point startPos = t.Location;
+		CharsetModifier charsetModifer = CharsetModifier.None;
+		string library = String.Empty;
+		string alias = null;
+		string name = String.Empty;
+	.)
+	[Charset&lt;out charsetModifer&gt; ]
+	(
+			&quot;Sub&quot;
+			Identifier				(. name = t.val; .)
+			&quot;Lib&quot; LiteralString		(. library = t.val; .)
+			[&quot;Alias&quot; LiteralString	(. alias = t.val; .)]
+			[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+			EOL
+			(.
+				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, null, p, attributes, library, alias, charsetModifer);
+				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				declareDeclaration.StartLocation = startPos;
+				declareDeclaration.EndLocation   = t.EndLocation;
+				compilationUnit.AddChild(declareDeclaration);
+			.)
+		|
+			&quot;Function&quot; 
+			Identifier					(. name = t.val; .)
+			&quot;Lib&quot; LiteralString		(. library = t.val; .)
+			[&quot;Alias&quot; LiteralString	(. alias = t.val; .)]
+			[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+			[&quot;As&quot; TypeName&lt;out type&gt; ]
+			EOL
+			(.
+				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, type, p, attributes, library, alias, charsetModifer);
+				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				declareDeclaration.StartLocation = startPos;
+				declareDeclaration.EndLocation   = t.EndLocation;
+				compilationUnit.AddChild(declareDeclaration);
+			.)
+		)
+	|
+	/* 9. 4 */
+	&quot;Event&quot;
+	(.
+		m.Check(Modifier.Events);
+		Point startPos = t.Location;
+		EventDeclaration eventDeclaration;
+		string name = String.Empty;
+		ImplementsClause implementsClause = null;
+	.)
+	Identifier (. name= t.val; .)
+	(
+		&quot;As&quot; TypeName&lt;out type&gt;
+		|
+		[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+	)
+	[ ImplementsClause&lt;out implementsClause&gt; ]
+	(.
+		eventDeclaration = new EventDeclaration(type, m.Modifier, p, attributes, name, implementsClause);
+		eventDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+		eventDeclaration.StartLocation = startPos;
+		eventDeclaration.EndLocation = t.EndLocation;
+		compilationUnit.AddChild(eventDeclaration);
+	.)
+	EOL
+	| /* 9.6 */
+	(. Point startPos = t.Location; .)
+	(.
+		m.Check(Modifier.Fields);
+		FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+		fd.StartLocation = startPos;
+	.)
+	VariableDeclarator&lt;variableDeclarators&gt;
+	(.
+		((INode)variableDeclarators[0]).Specials[&quot;before&quot;] = comments;
+	.)
+	{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; }
+	EOL
+	(.
+		fd.EndLocation = t.EndLocation;
+		fd.Fields = variableDeclarators;
+		compilationUnit.AddChild(fd);
+	.)
+	| /* 9.4 */
+	(. m.Check(Modifier.Fields); .)
+	&quot;Const&quot; (.  m.Add(Modifier.Constant);  .)
+	(.
+		FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+		fd.StartLocation = t.Location;
+		ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+		ArrayList constantDeclarators = new ArrayList();
+	.)
+	ConstantDeclarator&lt;constantDeclarators&gt;
+	(.
+		((INode)constantDeclarators[0]).Specials[&quot;before&quot;] = comments;
+	.)
+	{ &quot;,&quot; ConstantDeclarator&lt;constantDeclarators&gt; }
+	(.
+		fd.Fields = constantDeclarators;
+		fd.EndLocation = t.Location;
+	.)
+	EOL
+	(.
+		fd.EndLocation = t.EndLocation;
+		compilationUnit.AddChild(fd);
+	.)
+	| /* 9.7 */
+	&quot;Property&quot;
+	(.
+		m.Check(Modifier.Properties);
+		Point startPos = t.Location;
+		ImplementsClause implementsClause = null;
+	.)
+	Identifier (. string propertyName = t.val; .)
+	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+	[ &quot;As&quot; TypeName&lt;out type&gt; ]
+	(.
+		if(type == null) {
+			type = new TypeReference(&quot;System.Object&quot;);
+		}
+	.)
+	[ ImplementsClause&lt;out implementsClause&gt; ]
+	EOL
+	(
+	/* abstract properties without a body */
+	IF(IsMustOverride(m))
+		(.
+			PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
+			pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			pDecl.StartLocation = startPos;
+			pDecl.EndLocation   = t.Location;
+			pDecl.TypeReference = type;
+			pDecl.ImplementsClause = implementsClause;
+			pDecl.Parameters = p;
+			compilationUnit.AddChild(pDecl);
+		.)
+	|
+		(.
+			PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
+			pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			pDecl.StartLocation = startPos;
+			pDecl.EndLocation   = t.Location;
+			pDecl.BodyStart   = t.Location;
+			pDecl.TypeReference = type;
+			pDecl.ImplementsClause = implementsClause;
+			pDecl.Parameters = p;
+			PropertyGetRegion getRegion;
+			PropertySetRegion setRegion;
+		.)
+		AccessorDecls&lt;out getRegion, out setRegion&gt; 
+		&quot;End&quot; &quot;Property&quot;
+		EOL
+		(.
+			pDecl.GetRegion = getRegion;
+			pDecl.SetRegion = setRegion;
+			pDecl.BodyEnd = t.EndLocation;
+			compilationUnit.AddChild(pDecl);
+		.)
+	)
+	.
+
+/* 9.7 */
+AccessorDecls&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
+	(.
+		ArrayList attributes = new ArrayList(); 
+		AttributeSection section;
+		getBlock = null;
+		setBlock = null; 
+	.) =
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	(
+		GetAccessorDecl&lt;out getBlock, attributes&gt;
+		[
+			(. attributes = new ArrayList(); .)
+			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+			SetAccessorDecl&lt;out setBlock, attributes&gt;
+		]
+		|
+		SetAccessorDecl&lt;out setBlock, attributes&gt;
+		[
+			(. attributes = new ArrayList(); .)
+			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+			GetAccessorDecl&lt;out getBlock, attributes&gt;
+		]
+	)
+	.
+
+/* 9.7.1 */
+GetAccessorDecl&lt;out PropertyGetRegion getBlock, ArrayList attributes&gt;
+	(. Statement stmt = null; .) =
+	&quot;Get&quot;
+	EOL
+	Block&lt;out stmt&gt;
+	(.
+		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes);
+	.)
+	&quot;End&quot; &quot;Get&quot;
+	EOL
+	.
+
+/* 9.7.2 */
+SetAccessorDecl&lt;out PropertySetRegion setBlock, ArrayList attributes&gt;
+	(.
+		Statement stmt = null;
+		ArrayList p = null;
+	.) =
+	&quot;Set&quot;
+	[ &quot;(&quot;	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot; ]
+	EOL
+	Block&lt;out stmt&gt;
+	(.
+		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes);
+		setBlock.Parameters = p;
+	.)
+	&quot;End&quot; &quot;Set&quot;
+	EOL
+	.
+
+/* 9.5 */
+ConstantDeclarator&lt;ArrayList constantDeclaration&gt;
+	(.
+		Expression expr = null;
+		TypeReference type = null;
+		string name = String.Empty;
+	.) =
+	Identifier				(. name = t.val; .)
+	[&quot;As&quot; TypeName&lt;out type&gt; ]
+	&quot;=&quot; Expr&lt;out expr&gt;
+	(.
+		VariableDeclaration f = new VariableDeclaration(name, expr);
+		f.Type = type;
+		constantDeclaration.Add(f);
+	.)
+	.
+
+/* 9.6 */
+VariableDeclarator&lt;ArrayList fieldDeclaration&gt;
+	(.
+		Expression expr = null;
+		TypeReference type = null;
+		ObjectCreateExpression oce = null;
+		ArrayCreateExpression ace = null;
+		ArrayList rank = null;
+		ArrayList dimension = null;
+	.) =
+	Identifier
+	(.
+		VariableDeclaration f = new VariableDeclaration(t.val);
+	.)
+	[ IF(IsRank()) ArrayTypeModifiers&lt;out rank&gt; ]
+	[ IF(IsSize()) ArrayInitializationModifier&lt;out dimension&gt; ]
+	(
+			IF(IsObjectCreation()) &quot;As&quot; ObjectCreateExpression&lt;out expr&gt;
+			(.
+				if(expr is ArrayCreateExpression) {
+					ace = expr as ArrayCreateExpression;
+					f.Initializer = ace.ArrayInitializer;
+					
+				} else {
+					oce = expr as ObjectCreateExpression;
+					f.Initializer = oce;
+					if(oce.CreateType != null) {
+						f.Type = oce.CreateType;
+					}
+				}
+			.)
+		|
+			[ &quot;As&quot; TypeName&lt;out type&gt; ]
+			(.
+				if(type != null) {
+					type.Dimension = dimension;
+				}
+				f.Type = type;
+				if (type != null &amp;&amp; rank != null) {
+					if(type.RankSpecifier != null) {
+						Error(&quot;array rank only allowed one time&quot;);
+					} else {
+						type.RankSpecifier = rank;
+					}
+				}
+			.)
+			[ &quot;=&quot; VariableInitializer&lt;out expr&gt; (. f.Initializer = expr; .) ]
+	)
+	(. fieldDeclaration.Add(f); .)
+	.
+
+/* 6.8 */
+ArrayInitializationModifier&lt;out ArrayList arrayModifiers&gt;
+	(.
+		arrayModifiers = null;
+	.) =
+	&quot;(&quot; InitializationRankList&lt;out arrayModifiers&gt; &quot;)&quot;
+	.
+
+/* 7.5.4.3 */
+InitializationRankList&lt;out ArrayList rank&gt;
+	(.
+		rank = null;
+		Expression expr = null;
+	.) =
+	Expr&lt;out expr&gt;	(. rank = new ArrayList(); rank.Add(expr); .)
+	{
+		&quot;,&quot; Expr&lt;out expr&gt;		(. rank.Add(expr); .)
+	}
+	.
+
+/* 9.6.3 */
+VariableInitializer&lt;out Expression initializerExpression&gt;
+	(.
+		initializerExpression = null;
+	.) =
+	Expr&lt;out initializerExpression&gt;
+	| ArrayInitializer&lt;out initializerExpression&gt;
+	.
+
+/* 9.6.3.4 */
+ArrayInitializer&lt;out Expression outExpr&gt;
+	(.
+		Expression expr = null;
+		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
+	.) =
+	&quot;{&quot;
+	[
+		VariableInitializer&lt;out expr&gt;
+		(.
+			initializer.CreateExpressions.Add(expr);
+		.)
+		{
+			IF (NotFinalComma()) &quot;,&quot; VariableInitializer&lt;out expr&gt;
+			(. initializer.CreateExpressions.Add(expr); .)
+		}
+	]
+	&quot;}&quot; (. outExpr = initializer; .)
+	.
+
+Charset&lt;out CharsetModifier charsetModifier&gt;
+	(. charsetModifier = CharsetModifier.None; .) =
+	| &quot;Ansi&quot;		(. charsetModifier = CharsetModifier.ANSI; .)
+	| &quot;Auto&quot;		(. charsetModifier = CharsetModifier.Auto; .)
+	| &quot;Unicode&quot;		(. charsetModifier = CharsetModifier.Unicode; .)
+	.
+
+/* 9.2.6 */
+HandlesClause&lt;out HandlesClause handlesClause&gt;
+	(.
+		handlesClause = new HandlesClause();
+		string name;
+	.) =
+	&quot;Handles&quot; EventMemberSpecifier&lt;out name&gt;	(. handlesClause.EventNames.Add(name); .)
+	{ &quot;,&quot; EventMemberSpecifier&lt;out name&gt;		(. handlesClause.EventNames.Add(name); .) }
+	.
+
+/* 7.8. */
+InterfaceBase &lt;out ArrayList bases&gt;
+	(.
+		TypeReference type;
+		bases = new ArrayList();
+	.) =
+	&quot;Inherits&quot;
+	TypeName&lt;out type&gt; (. bases.Add(type); .)
+	{
+		&quot;,&quot;
+		TypeName&lt;out type&gt; (. bases.Add(type); .)
+	}
+	EOL
+	.
+
+/* 7.2 */
+TypeImplementsClause&lt;out ArrayList baseInterfaces&gt;
+	(.
+		baseInterfaces = new ArrayList();
+		TypeReference type = null;
+	.) =
+	&quot;Implements&quot; TypeName&lt;out type&gt;
+	(.
+		baseInterfaces.Add(type);
+	.)
+	{
+		&quot;,&quot; TypeName&lt;out type&gt;
+		(. baseInterfaces.Add(type); .)
+	}
+	EndOfStmt
+	.
+
+/* 9.1 */
+ImplementsClause&lt;out ImplementsClause clause&gt;
+	(.
+		clause = new ImplementsClause();
+		string typename = String.Empty;
+		string first;
+	.) =
+	&quot;Implements&quot; Identifier (. first = t.val; .) &quot;.&quot; Qualident&lt;out typename&gt; (. ((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); .)
+	{ &quot;,&quot; Identifier (. first = t.val; .) &quot;.&quot; Qualident&lt;out typename&gt; (. ((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); .) }
+		.
+
+EventMemberSpecifier&lt;out string name&gt;
+	(. string type; name = String.Empty; .) =
+	Identifier (. type = t.val; .)
+	&quot;.&quot;
+	Identifier (. name = type + &quot;.&quot; + t.val; .)
+	| &quot;MyBase&quot; &quot;.&quot;
+	(
+		Identifier (. name = &quot;MyBase.&quot; + t.val; .)
+		| &quot;Error&quot;  (. name = &quot;MyBase.Error&quot;; .)
+	)
+	.
+
+Expr&lt;out Expression expr&gt;
+	(. expr = new Expression(); .) =
+	ConditionalOrExpr&lt;out expr&gt;
+	{
+		/*ConditionalOrExpr&lt;out expr&gt;	|*/
+		(. AssignmentOperatorType op; Expression val; .)
+		AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
+	}
+	.
+
+UnaryExpr&lt;out Expression uExpr&gt; 
+	(.
+		Expression expr;
+		UnaryOperatorType uop = UnaryOperatorType.None;
+		bool isUOp = false;
+	.) =
+	{ 	&quot;+&quot; 		(. uop = UnaryOperatorType.Plus; isUOp = true; .)
+		| &quot;-&quot; 		(. uop = UnaryOperatorType.Minus; isUOp = true; .)
+/*		| &quot;Not&quot;		(. uop = UnaryOperatorType.Not;  isUOp = true;.) */
+		| &quot;*&quot; 		(. uop = UnaryOperatorType.Star;  isUOp = true;.)
+	}
+	SimpleExpr&lt;out expr&gt;
+		(.
+			if (isUOp) {
+				uExpr = new UnaryOperatorExpression(expr, uop);
+			} else {
+				uExpr = expr;
+			}
+		.)
+	.
+
+AssignmentOperator&lt;out AssignmentOperatorType op&gt;
+	(. op = AssignmentOperatorType.None; .) =
+	&quot;=&quot;		(. op = AssignmentOperatorType.Assign; .)
+	| &quot;&amp;=&quot;	(. op = AssignmentOperatorType.ConcatString; .)
+	| &quot;+=&quot;	(. op = AssignmentOperatorType.Add; .)
+	| &quot;-=&quot;	(. op = AssignmentOperatorType.Subtract; .)
+	| &quot;*=&quot;	(. op = AssignmentOperatorType.Multiply; .)
+	| &quot;/=&quot;	(. op = AssignmentOperatorType.Divide; .)
+	| &quot;\\=&quot;	(. op = AssignmentOperatorType.DivideInteger; .)
+	| &quot;^=&quot;	(. op = AssignmentOperatorType.Power; .)
+	| &quot;&lt;&lt;=&quot;	(. op = AssignmentOperatorType.ShiftLeft; .)
+	| &quot;&gt;&gt;=&quot;	(. op = AssignmentOperatorType.ShiftRight; .)
+	.
+
+/* 11.4 */
+SimpleExpr&lt;out Expression pexpr&gt;
+	(.
+		Expression expr;
+		TypeReference type = null;
+		string name = String.Empty;
+		pexpr = null;
+	.) =
+	(
+		(
+			/* 11.4.1 */ 
+			LiteralString							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralCharacter						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralSingle							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralDouble							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralInteger						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralDate							(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			| LiteralDecimal						(.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+			/* True, False and Nothing are handled as literals in the spec */
+			| &quot;True&quot;											(.pexpr = new PrimitiveExpression(true, &quot;true&quot;);  .)
+			| &quot;False&quot;											(.pexpr = new PrimitiveExpression(false, &quot;false&quot;); .)
+			| &quot;Nothing&quot;											(.pexpr = new PrimitiveExpression(null, &quot;null&quot;);  .)
+			| /* 11.4.2 */ &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; 				(. pexpr = new ParenthesizedExpression(expr); .)
+			| /* 11.4.4 */ Identifier					(. pexpr = new IdentifierExpression(t.val); .)
+			| (. string val = String.Empty; .) PrimitiveTypeName&lt;out val&gt;
+			&quot;.&quot; Identifier	(. pexpr = new FieldReferenceOrInvocationExpression(new TypeReferenceExpression(val), t.val); .)
+			| &quot;Me&quot;												(. pexpr = new ThisReferenceExpression(); .)
+			| (. Expression retExpr = null; .)
+				( &quot;MyBase&quot;										(. retExpr = new BaseReferenceExpression(); .)
+				| &quot;MyClass&quot;										(. retExpr = new ClassReferenceExpression(); .)
+				)
+				&quot;.&quot; IdentifierOrKeyword&lt;out name&gt;				(. pexpr = new FieldReferenceOrInvocationExpression(retExpr, name); .)
+			| ObjectCreateExpression&lt;out expr&gt;					(. pexpr = expr; .)
+			| /* 11.11 */ ( &quot;DirectCast&quot; | &quot;CType&quot; ) &quot;(&quot; Expr&lt;out expr&gt; &quot;,&quot; TypeName&lt;out type&gt; &quot;)&quot;	(. pexpr = new CastExpression(type, expr); .)
+			| /* 11.11 */ CastTarget&lt;out type&gt; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;	(. pexpr = new CastExpression(type, expr, true); .)
+			| /* 11.4.5 */ &quot;AddressOf&quot; Expr&lt;out expr&gt;			(. pexpr = new AddressOfExpression(expr); .)
+			| /* 11.5.1 */ &quot;GetType&quot; &quot;(&quot; TypeName&lt;out type&gt; &quot;)&quot;	(. pexpr = new GetTypeExpression(type); .)
+			| /* 11.5.2 */ &quot;TypeOf&quot; SimpleExpr&lt;out expr&gt; &quot;Is&quot; TypeName&lt;out type&gt; (. pexpr = new TypeOfExpression(expr, type); .)
+		)
+		{
+			&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); .)
+			| &quot;(&quot;	(. ArrayList parameters = new ArrayList(); .)
+				[
+					(. expr = null; .) [ Argument&lt;out expr&gt;]	(. parameters.Add(expr); .)
+					{
+						&quot;,&quot; (. expr = null; .)
+						[ Argument&lt;out expr&gt;  ] (. parameters.Add(expr); .)
+					}
+				]
+			&quot;)&quot;		(. pexpr = new InvocationExpression(pexpr, parameters); .)
+		}
+	|
+	/* this form only occurs in with statements*/
+	&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name);.)
+	{
+		&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); .)
+		| &quot;(&quot;	(. ArrayList parameters = new ArrayList(); .)
+			[
+				(. expr = null; .) [ Argument&lt;out expr&gt;]	(. parameters.Add(expr); .)
+				{
+					&quot;,&quot; (. expr = null; .)
+					[ Argument&lt;out expr&gt;  ] (. parameters.Add(expr); .)
+				}
+			]
+		&quot;)&quot;		(. pexpr = new InvocationExpression(pexpr, parameters); .)
+	}
+	)
+	.
+
+/* 11.11 */
+
+CastTarget&lt;out TypeReference type&gt;
+	(.
+		type = null;
+	.) =
+	&quot;CBool&quot;		(. type = new TypeReference(&quot;System.Boolean&quot;); .)
+	| &quot;CByte&quot;	(. type = new TypeReference(&quot;System.Byte&quot;); .)
+	| &quot;CChar&quot;	(. type = new TypeReference(&quot;System.Char&quot;); .)
+	| &quot;CDate&quot;	(. type = new TypeReference(&quot;System.DateTime&quot;); .)
+	| &quot;CDec&quot;	(. type = new TypeReference(&quot;System.Decimal&quot;); .)
+	| &quot;CDbl&quot;	(. type = new TypeReference(&quot;System.Double&quot;); .)
+	| &quot;CInt&quot;	(. type = new TypeReference(&quot;System.Int32&quot;); .)
+	| &quot;CLng&quot;	(. type = new TypeReference(&quot;System.Int64&quot;); .)
+	| &quot;CObj&quot;	(. type = new TypeReference(&quot;System.Object&quot;); .)
+	| &quot;CShort&quot;	(. type = new TypeReference(&quot;System.Int16&quot;); .)
+	| &quot;CSng&quot;	(. type = new TypeReference(&quot;System.Single&quot;); .)
+	| &quot;CStr&quot;	(. type = new TypeReference(&quot;System.String&quot;); .)
+	.
+
+ConditionalOrExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	ConditionalAndExpr&lt;out outExpr&gt;  { &quot;OrElse&quot; ConditionalAndExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanOr, expr);  .) }
+	.
+
+ConditionalAndExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	InclusiveOrExpr&lt;out outExpr&gt;  { &quot;AndAlso&quot; InclusiveOrExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanAnd, expr);  .) }
+	.
+
+InclusiveOrExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	ExclusiveOrExpr&lt;out outExpr&gt;  { &quot;Xor&quot; ExclusiveOrExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  .) }
+	.
+
+ExclusiveOrExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	AndExpr&lt;out outExpr&gt;  { &quot;Or&quot; AndExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  .) }
+	.
+
+AndExpr&lt;out Expression outExpr&gt;
+	(. Expression expr; .) =
+	NotExpr&lt;out outExpr&gt; { &quot;And&quot; NotExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  .) }
+	.
+
+NotExpr&lt;out Expression outExpr&gt; 
+	(. UnaryOperatorType uop = UnaryOperatorType.None; .) =
+	{	&quot;Not&quot; (. uop = UnaryOperatorType.Not; .) }
+	EqualityExpr&lt;out outExpr&gt;
+                (. if (uop != UnaryOperatorType.None)
+	                   outExpr = new UnaryOperatorExpression(outExpr, uop);
+                .)
+	.
+
+EqualityExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+	RelationalExpr&lt;out outExpr&gt;
+	{
+		(
+			&quot;&lt;&gt;&quot;		(. op = BinaryOperatorType.InEquality; .)
+			| &quot;=&quot; 		(. op = BinaryOperatorType.Equality; .)
+			| &quot;Like&quot;	(. op = BinaryOperatorType.Like; .)
+		)
+		RelationalExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
+	}
+	.
+
+RelationalExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+	ShiftExpr&lt;out outExpr&gt;
+	{
+		(
+			&quot;&lt;&quot;    (. op = BinaryOperatorType.LessThan; .)
+			| &quot;&gt;&quot;  (. op = BinaryOperatorType.GreaterThan; .)
+			| &quot;&lt;=&quot; (. op = BinaryOperatorType.LessThanOrEqual; .)
+			| &quot;&gt;=&quot; (. op = BinaryOperatorType.GreaterThanOrEqual; .)
+		)
+		ShiftExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
+		|
+		/* 11.5.3 */
+		&quot;Is&quot; (. op = BinaryOperatorType.IS; .)
+		Expr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr); .)
+	}
+	.
+
+ShiftExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+	AdditiveExpr&lt;out outExpr&gt; 
+	{
+		(
+			&quot;&lt;&lt;&quot;   (. op = BinaryOperatorType.ShiftLeft; .)
+			| &quot;&gt;&gt;&quot; (. op = BinaryOperatorType.ShiftRight; .)
+		)
+		AdditiveExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
+	}
+	.
+
+AdditiveExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+	MultiplicativeExpr&lt;out outExpr&gt;
+	{
+		(
+			&quot;+&quot;   (. op = BinaryOperatorType.Add; .)
+			| &quot;-&quot; (. op = BinaryOperatorType.Subtract; .)
+			| &quot;&amp;&quot; (. op = BinaryOperatorType.Concat; .)
+		)
+		MultiplicativeExpr&lt;out expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
+	}
+	.
+
+MultiplicativeExpr&lt;out Expression outExpr&gt;
+	(.
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+	.) =
+    UnaryExpr&lt;out outExpr&gt;
+	{
+		(
+			&quot;*&quot;   (. op = BinaryOperatorType.Multiply; .)
+			| &quot;/&quot; (. op = BinaryOperatorType.Divide; .)
+			| &quot;\\&quot; (. op = BinaryOperatorType.DivideInteger; .)
+			| &quot;Mod&quot; (. op = BinaryOperatorType.Modulus; .)
+			| &quot;^&quot;	(. op = BinaryOperatorType.Power; .)
+		) 
+		UnaryExpr&lt;out expr&gt; (. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .) 
+	}
+	.
+	
+ObjectCreateExpression&lt;out Expression oce&gt;
+	(.
+		TypeReference type = null;
+		Expression initializer = null;
+		ArrayList arguments = null;
+		oce = null;
+	.) =
+	&quot;New&quot; ArrayTypeName&lt;out type&gt;
+	[&quot;(&quot;
+		[ ArgumentList&lt;out arguments&gt; ]
+	&quot;)&quot;
+	]
+	[
+		ArrayInitializer&lt;out initializer&gt;
+	]
+	(.
+		if(initializer == null) {
+			oce = new ObjectCreateExpression(type, arguments);
+		} else {
+			ArrayCreateExpression ace = new ArrayCreateExpression(type, initializer as ArrayInitializerExpression);
+			ace.Parameters = arguments;
+			oce = ace;
+		}
+	.)
+	.
+
+/* 9.3.2 */
+ArgumentList&lt;out ArrayList arguments&gt;
+	(.
+		arguments = new ArrayList();
+		Expression expr = null;
+	.) =
+	[
+		Argument&lt;out expr&gt;			(. arguments.Add(expr); .)
+		{
+			&quot;,&quot;
+			Argument&lt;out expr&gt;		(. arguments.Add(expr); .)
+		}
+	]
+	.
+
+/* Spec, 11.8 */
+Argument&lt;out Expression argumentexpr&gt;
+	(.
+		Expression expr;
+		argumentexpr = null;
+		string name;
+	.) =
+	IF(IsNamedAssign()) Identifier (. name = t.val;  .) &quot;:&quot; &quot;=&quot; Expr&lt;out expr&gt;
+	(.
+		argumentexpr = new NamedArgumentExpression(name, expr);
+	.)
+	|
+	Expr&lt;out argumentexpr&gt;
+	.
+
+/* 7.1. */
+TypeName&lt;out TypeReference typeref&gt;
+	(.
+		ArrayList rank = null;
+	.) =
+	NonArrayTypeName&lt;out typeref&gt;
+	ArrayTypeModifiers&lt;out rank&gt;
+	(.
+		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
+	.)
+	.
+	
+
+ArrayTypeName&lt;out TypeReference typeref&gt;
+	(.
+		ArrayList rank = null;
+	.) =
+	NonArrayTypeName&lt;out typeref&gt;
+	ArrayInitializationModifiers&lt;out rank&gt;
+	(.
+		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
+	.)
+	.
+
+/* 7.1 */
+NonArrayTypeName&lt;out TypeReference typeref&gt;
+	(.
+		string name;
+		typeref = null;
+	.) =
+	Qualident&lt;out name&gt; (. typeref = new TypeReference(name); .)
+	| &quot;Object&quot; (. typeref = new TypeReference(&quot;System.Object&quot;); .)
+	| PrimitiveTypeName&lt;out name&gt; (. typeref = new TypeReference(name); .)
+	.
+
+ArrayInitializationModifiers&lt;out ArrayList arrayModifiers&gt;
+	(.
+		arrayModifiers = new ArrayList();
+		ArrayList dim = new ArrayList();
+	.) =
+	{	
+		IF (IsDims()) &quot;(&quot;
+		[ InitializationRankList &lt;out dim&gt;]
+		(.
+			arrayModifiers.Add(dim);
+		.)
+		&quot;)&quot;
+	}
+	(.
+		if(arrayModifiers.Count == 0) {
+			 arrayModifiers = null;
+		}
+	.)
+	.
+
+/* 7.9 */
+ArrayTypeModifiers&lt;out ArrayList arrayModifiers&gt;
+	(.
+		arrayModifiers = new ArrayList();
+		int i = 0;
+	.) =
+	{	IF (IsRank())
+		&quot;(&quot;
+		[ RankList &lt;out i&gt;]
+		(.
+			arrayModifiers.Add(i);
+		.)
+		&quot;)&quot;
+	}
+	(.
+		if(arrayModifiers.Count == 0) {
+			 arrayModifiers = null;
+		}
+	.)
+	.
+
+/* 7.9 */
+RankList&lt;out int i&gt;
+	(. i = 0; .) =
+	{ &quot;,&quot; (. ++i; .) }
+	.
+
+GlobalAttributeSection =
+	(. Point startPos = t.Location; .)
+	&quot;&lt;&quot; (&quot;Assembly&quot; | &quot;Module&quot;)
+		(.
+			string attributeTarget = t.val.ToLower();
+			ArrayList attributes = new ArrayList();
+			ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
+		.)
+	&quot;:&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)
+	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
+	[ &quot;,&quot; ]
+	&quot;&gt;&quot;
+	EndOfStmt
+		(.
+			AttributeSection section = new AttributeSection(attributeTarget, attributes);
+			section.StartLocation = startPos;
+			section.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(section);
+		.)
+	.
+
+/* Spec, 5. */
+Attribute&lt;out ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute&gt;
+	(. string qualident; .) =
+	Qualident&lt;out qualident&gt;
+		(.
+			ArrayList positional = new ArrayList();
+			ArrayList named      = new ArrayList();
+			string name = qualident;
+		.)
+	[ AttributeArguments&lt;ref positional, ref named&gt; ]
+	(.
+		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute(name, positional, named);
+	.)
+	.
+
+/* Spec, 5.2.2 */
+AttributeArguments&lt;ref ArrayList positional, ref ArrayList named&gt;
+	(.
+		bool nameFound = false;
+		string name = &quot;&quot;;
+		Expression expr;
+	.) =
+	&quot;(&quot;
+	[
+		IF (IsNotClosingParenthesis()) ( 
+			[
+				IF (IsNamedAssign()) (. nameFound = true; .)
+				IdentifierOrKeyword&lt;out name&gt;
+				[&quot;:&quot;] &quot;=&quot;
+			] Expr&lt;out expr&gt;
+				(.
+					if(name == &quot;&quot;) positional.Add(expr);
+					else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
+				.)
+			{
+				&quot;,&quot;
+					(
+						IF (IsNamedAssign())	(. nameFound = true; .)
+						IdentifierOrKeyword&lt;out name&gt;
+						[ &quot;:&quot; ] &quot;=&quot;
+						| (. if (nameFound) Error(&quot;no positional argument after named argument&quot;); .)
+					) Expr&lt;out expr&gt;	(. 	if(name == &quot;&quot;) positional.Add(expr);
+											else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
+										.)
+			}
+		)
+	]
+	&quot;)&quot;
+	.
+
+/* Spec, 5. */
+AttributeSection&lt;out AttributeSection section&gt;
+	(.
+		string attributeTarget = &quot;&quot;;
+		ArrayList attributes = new ArrayList();
+		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
+		
+	.) =
+	&quot;&lt;&quot; (. Point startPos = t.Location; .)
+	[ IF (IsLocalAttrTarget())
+		( &quot;Event&quot;		(. attributeTarget = &quot;event&quot;;.)
+		| &quot;Return&quot;		(. attributeTarget = &quot;return&quot;;.)
+		| Identifier
+			(.
+				string val = t.val.ToLower();
+				if (val != &quot;field&quot;	|| val != &quot;method&quot; ||
+					val != &quot;module&quot; || val != &quot;param&quot;  ||
+					val != &quot;property&quot; || val != &quot;type&quot;)
+				Error(&quot;attribute target specifier (event, return, field,&quot; +
+						&quot;method, module, param, property, or type) expected&quot;);
+				attributeTarget = t.val;
+			.)
+		) &quot;:&quot; 
+	]
+	Attribute&lt;out attribute&gt;	(. attributes.Add(attribute); .)
+	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .) }
+	[ &quot;,&quot; ]
+	&quot;&gt;&quot;
+		(.
+			section = new AttributeSection(attributeTarget, attributes);
+			section.StartLocation = startPos;
+			section.EndLocation = t.EndLocation;
+		.)
+	.
+
+/* 9.2.5 */
+FormalParameterList&lt;out ArrayList parameter&gt;
+	(.
+		parameter = new ArrayList();
+		ParameterDeclarationExpression p;
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+	.) =
+	{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
+	(
+		FormalParameter&lt;out p&gt;
+		(.
+			bool paramsFound = false;
+			p.Attributes = attributes;
+			parameter.Add(p);
+		.)
+		{
+			&quot;,&quot;	(. attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); .)
+			{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
+			(
+				FormalParameter &lt;out p&gt;	(. p.Attributes = attributes; parameter.Add(p); .)
+			)
+		}
+	)
+	.
+/* 9.2.5 */
+FormalParameter&lt;out ParameterDeclarationExpression p&gt;
+	(.
+		TypeReference type = null;
+		ParamModifiers mod = new ParamModifiers(this);
+		Expression expr = null;
+		p = null;
+		ArrayList arrayModifiers = null;
+	.) =
+	{ ParameterModifier&lt;mod&gt; }
+	Identifier (. string parameterName = t.val; .)
+	[ IF(IsRank()) ArrayTypeModifiers&lt;out arrayModifiers&gt; ]
+	[ &quot;As&quot; TypeName&lt;out type&gt; ]
+	(.
+		if(type != null) {
+			if (arrayModifiers != null) {
+				if (type.RankSpecifier != null) {
+					Error(&quot;array rank only allowed one time&quot;);
+				} else {
+					type.RankSpecifier = arrayModifiers;
+				}
+			}
+		} else {
+			type = new TypeReference(&quot;System.Object&quot;, arrayModifiers);
+		}
+	.)
+	[ &quot;=&quot; Expr&lt;out expr&gt; ]
+	(.
+		mod.Check();
+		p = new ParameterDeclarationExpression(type, parameterName, mod, expr);
+	.)
+	.
+
+/* 10.1 */
+Block&lt;out Statement stmt&gt;
+	=
+	(.
+		BlockStatement blockStmt = new BlockStatement();
+		blockStmt.StartLocation = t.Location;
+		compilationUnit.BlockStart(blockStmt);
+	.)
+	{ Statement EndOfStmt |
+	  IF (IsEndStmtAhead()) &quot;End&quot; EndOfStmt (. compilationUnit.AddChild(new EndStatement()); .) 
+	}
+	(.
+		stmt = blockStmt;
+		blockStmt.EndLocation = t.EndLocation;
+		compilationUnit.BlockEnd();
+	.)
+	.
+
+Statement
+	(.
+		Statement stmt;
+		string label = String.Empty;
+		
+	.) =
+	IF (IsLabel()) LabelName&lt;out label&gt;
+	(.
+		labelStatement = new LabelStatement(t.val);
+		compilationUnit.AddChild(labelStatement);
+	.)
+	&quot;:&quot; [ (. isLabel = true; .) Statement ]
+	| EmbeddedStatement&lt;out stmt&gt;			(. updateLabelStatement(stmt); .)
+	| LocalDeclarationStatement&lt;out stmt&gt;	(. updateLabelStatement(stmt); .)
+	.
+
+/* 10.2 */
+LocalDeclarationStatement&lt;out Statement statement&gt;
+	(.
+		Modifiers m = new Modifiers(this);
+		ArrayList vars = new ArrayList();
+		LocalVariableDeclaration localVariableDeclaration;
+		bool dimfound = false;
+	.) =
+	/* this differs from the spec: dim static x	compiles with vbc. */
+	{
+		&quot;Const&quot; 	(. m.Add(Modifier.Constant); .)
+		| &quot;Static&quot;	(. m.Add(Modifier.Static); .)
+		| &quot;Dim&quot;		(. dimfound = true; .)
+	}
+	(.
+		if(dimfound &amp;&amp; (m.Modifier &amp; Modifier.Constant) != 0) {
+			Error(&quot;Dim is not allowed on constants.&quot;);
+		}
+		
+		if(m.isNone &amp;&amp; dimfound == false) {
+			Error(&quot;Const, Dim or Static expected&quot;);
+		}
+		
+		localVariableDeclaration = new LocalVariableDeclaration(m.Modifier);
+		localVariableDeclaration.StartLocation = t.Location;
+	.)
+	VariableDeclarator&lt;vars&gt;
+	{ &quot;,&quot; VariableDeclarator&lt;vars&gt; }
+	(.
+		localVariableDeclaration.Variables = vars;
+		statement = localVariableDeclaration;
+	.)
+	.
+
+EmbeddedStatement&lt;out Statement statement&gt;
+	(.
+		Statement embeddedStatement = null;
+		statement = null;
+		Expression expr = null;
+		string name = String.Empty;
+		ArrayList p = null;
+	.) =
+		&quot;Exit&quot;				(. ExitType exitType = ExitType.None; .)
+		(
+		&quot;Sub&quot;				(. exitType = ExitType.Sub; .)
+		|
+		&quot;Function&quot;			(. exitType = ExitType.Function; .)
+		|
+		&quot;Property&quot;			(. exitType = ExitType.Property; .)
+		|
+		&quot;Do&quot;				(. exitType = ExitType.Do; .)
+		|
+		&quot;For&quot;				(. exitType = ExitType.For; .)
+		|
+		&quot;Try&quot;				(. exitType = ExitType.Try; .)
+		|
+		&quot;While&quot;				(. exitType = ExitType.While; .)
+		|
+		&quot;Select&quot;			(. exitType = ExitType.Select; .)
+		)
+	(. statement = new ExitStatement(exitType); .)
+	| TryStatement&lt;out statement&gt;
+	| /* 10.10.1.3 */
+	&quot;Throw&quot; [ Expr&lt;out expr&gt; ]				(. statement = new ThrowStatement(expr); .)
+	| /* 10.11 */
+	&quot;Return&quot; [ Expr&lt;out expr&gt; ] 			(. statement = new ReturnStatement(expr); .)
+	| /* 10.4 */
+	&quot;SyncLock&quot; Expr&lt;out expr&gt; EndOfStmt Block&lt;out embeddedStatement&gt;
+	&quot;End&quot; &quot;SyncLock&quot; 						(. statement = new LockStatement(expr, embeddedStatement); .)
+	| /* 10.5.1 */
+	&quot;RaiseEvent&quot; Identifier (. name = t.val; .)
+	[ &quot;(&quot; [ ArgumentList&lt;out p&gt; ] &quot;)&quot; ]
+	(. statement = new RaiseEventStatement(name, p); .)
+	| /* 10.3 */
+	WithStatement&lt;out statement&gt;
+	| /* 10.5.2 */
+	&quot;AddHandler&quot; (. Expression handlerExpr = null; .)
+	Expr&lt;out expr&gt; &quot;,&quot; Expr&lt;out handlerExpr&gt;
+	(.
+		statement = new AddHandlerStatement(expr, handlerExpr);
+	.)
+	| /* 10.5.2 */
+	&quot;RemoveHandler&quot; (. Expression handlerExpr = null; .)
+	Expr&lt;out expr&gt; &quot;,&quot; Expr&lt;out handlerExpr&gt;
+	(.
+		statement = new RemoveHandlerStatement(expr, handlerExpr);
+	.)
+	| /* 10.9.1 */
+	&quot;While&quot; Expr&lt;out expr&gt; EndOfStmt
+	Block&lt;out embeddedStatement&gt; &quot;End&quot; &quot;While&quot;
+	(.
+		statement = new WhileStatement(expr, embeddedStatement);
+	.)
+	| /* 10.9.1 */
+	&quot;Do&quot;
+	(.
+		ConditionType conditionType = ConditionType.None;
+	.)
+	(
+		WhileOrUntil&lt;out conditionType&gt; Expr&lt;out expr&gt; EndOfStmt
+		Block&lt;out embeddedStatement&gt;
+		&quot;Loop&quot;
+		(.
+			statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.Start);
+		.)
+		|
+		EndOfStmt
+		Block&lt;out embeddedStatement&gt;
+		&quot;Loop&quot; [WhileOrUntil&lt;out conditionType&gt; Expr&lt;out expr&gt;]
+		(.
+			statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.End);
+		.)
+	)
+	| &quot;For&quot;
+	(.
+			Expression group = null;
+			LoopControlVariableExpression loopControlExpr = null;
+	.)
+	(
+		/* 10.9.3  */
+ 		&quot;Each&quot; LoopControlVariable&lt;out loopControlExpr&gt;
+		&quot;In&quot; Expr&lt;out group&gt; EndOfStmt
+		Block&lt;out embeddedStatement&gt;
+		&quot;Next&quot; [ Expr&lt;out expr&gt; ]
+		(.
+			statement = new ForeachStatement(loopControlExpr, group, embeddedStatement, expr);
+		.)
+		| /* 10.9.2 */
+		(.
+			Expression start = null;
+			Expression end = null;
+			Expression step = null;
+			Expression nextExpr = null;
+			ArrayList nextExpressions = null;
+		.)
+		LoopControlVariable&lt;out loopControlExpr&gt;
+		&quot;=&quot; Expr&lt;out start&gt; &quot;To&quot; Expr&lt;out end&gt; [ &quot;Step&quot; Expr&lt;out step&gt; ]
+		EndOfStmt Block&lt;out embeddedStatement&gt;
+		&quot;Next&quot;
+		[
+			Expr&lt;out nextExpr&gt; (. nextExpressions = new ArrayList(); nextExpressions.Add(nextExpr); .) 
+			{ &quot;,&quot; Expr&lt;out nextExpr&gt; (. nextExpressions.Add(nextExpr); .) }
+		]
+		(.
+			statement = new ForStatement(loopControlExpr, start, end, step, embeddedStatement, nextExpressions);
+		.)
+	)
+	| /* 10.10.2.1 */
+	&quot;Error&quot; Expr&lt;out expr&gt; 				(. statement = new ErrorStatement(expr); .)
+	| /* 10.12.1 */
+	&quot;ReDim&quot; (. Expression clause = null; .) [ &quot;Preserve&quot; ]
+	Expr&lt;out clause&gt;
+	(.
+		ArrayList clauses = new ArrayList();
+		clauses.Add(clause);
+		/*ReDimStatement reDimStatement = new ReDimStatement(clauses);*/
+	.)
+	{ &quot;,&quot; Expr&lt;out clause&gt; (. clauses.Add(clause); .) }
+	| /* 10.12.2 */
+	&quot;Erase&quot;	
+	Expr&lt;out expr&gt;
+	(.
+		ArrayList arrays = new ArrayList();
+		arrays.Add(expr);
+		EraseStatement eraseStatement = new EraseStatement(arrays);
+		
+	.)
+	{ &quot;,&quot; Expr&lt;out expr&gt; (. arrays.Add(expr); .) }
+	(. statement = eraseStatement; .)
+	| /* 10.11 */
+	&quot;Stop&quot; (. statement = new StopStatement(); .)
+	| /* 10.8.1 */
+	&quot;If&quot; Expr&lt;out expr&gt; [ &quot;Then&quot; ] 
+	(	
+		IF (IsEndStmtAhead()) &quot;End&quot; (. statement = new IfStatement(expr, new EndStatement()); .) 
+		|
+		/* multiline if statement */
+		EndOfStmt Block&lt;out embeddedStatement&gt;
+		(.
+			ArrayList elseIfSections = new ArrayList();
+			IfStatement ifStatement = new IfStatement(expr, embeddedStatement);
+		.)
+		{
+			(
+				IF(IsElseIf()) &quot;Else&quot; &quot;If&quot;
+				| &quot;ElseIf&quot;
+			)
+			(. Expression condition = null; Statement block = null; .)
+			Expr&lt;out condition&gt; [ &quot;Then&quot;] EndOfStmt
+			Block&lt;out block&gt;
+			(.
+				ElseIfSection elseIfSection = new ElseIfSection(condition, block);
+				elseIfSections.Add(elseIfSection);
+			.)
+		}
+		[
+			&quot;Else&quot; EndOfStmt
+			Block&lt;out embeddedStatement&gt;
+			(.
+				ifStatement.EmbeddedElseStatement = embeddedStatement;
+			.)
+		] &quot;End&quot; &quot;If&quot;
+		(.
+			ifStatement.ElseIfStatements = elseIfSections;
+			statement = ifStatement;
+		.)
+		| /* singleline if statement */
+		EmbeddedStatement&lt;out embeddedStatement&gt;
+		(.
+			SimpleIfStatement ifStatement = new SimpleIfStatement(expr);
+			ArrayList statements = new ArrayList();
+			statements.Add(embeddedStatement);
+			ifStatement.Statements = statements;
+		.)
+		{ &quot;:&quot; EmbeddedStatement&lt;out embeddedStatement&gt; (. statements.Add(embeddedStatement); .) }
+		[
+			&quot;Else&quot; [ EmbeddedStatement&lt;out embeddedStatement&gt; ]
+			(.
+				ArrayList elseStatements = new ArrayList();
+				elseStatements.Add(embeddedStatement);
+				ifStatement.ElseStatements = elseStatements;
+			.)
+			{
+				&quot;:&quot; EmbeddedStatement&lt;out embeddedStatement&gt;
+				(. elseStatements.Add(embeddedStatement); .)
+			}
+		]
+		(. statement = ifStatement; .)
+	)
+	| /* 10.8.2 */
+	&quot;Select&quot; [ &quot;Case&quot; ] Expr&lt;out expr&gt; EndOfStmt
+	(.
+		ArrayList selectSections = new ArrayList();
+		Statement block = null;
+	.)
+	{
+		(. ArrayList caseClauses = null; .)
+		&quot;Case&quot; CaseClauses&lt;out caseClauses&gt; [ IF(IsNotStatementSeparator()) &quot;:&quot; ] EndOfStmt
+		(.
+			SelectSection selectSection = new SelectSection();
+			selectSection.CaseClauses = caseClauses;
+			compilationUnit.BlockStart(selectSection);
+		.)
+		Block&lt;out block&gt;
+		(.
+			selectSection.EmbeddedStatement = block;
+			compilationUnit.BlockEnd();
+			selectSections.Add(selectSection);
+		.)
+	}
+	(. statement = new SelectStatement(expr, selectSections); .)
+	&quot;End&quot; &quot;Select&quot;
+	| (. OnErrorStatement onErrorStatement = null; .)
+	OnErrorStatement&lt;out onErrorStatement&gt; (. statement = onErrorStatement; .)
+	| (. GoToStatement goToStatement = null; .)
+	GoToStatement&lt;out goToStatement&gt; (. statement = goToStatement; .)
+	| (. ResumeStatement resumeStatement = null; .)
+	ResumeStatement&lt;out resumeStatement&gt; (. statement = resumeStatement; .)
+	|/* Statement expression (invocation and assignment) 10.6.1, 10.6.2, 10.6.3 */
+	(.
+		Expression val = null;
+		AssignmentOperatorType op;
+		
+		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
+		                        la.kind == Tokens.Not   || la.kind == Tokens.Times;
+	.)
+	UnaryExpr&lt;out expr&gt;
+		(
+		AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt;	(. expr = new AssignmentExpression(expr, op, val); .)
+		| (. if (mustBeAssignment) Error(&quot;error in assignment.&quot;); .)
+		)
+		(.
+			// a field reference expression that stands alone is a
+			// invocation expression without parantheses and arguments
+			if(expr is FieldReferenceOrInvocationExpression) {
+				expr = new InvocationExpression(expr, new ArrayList());
+			}
+			statement = new StatementExpression(expr);
+		.)
+	| &quot;Call&quot; UnaryExpr&lt;out expr&gt; (. statement = new StatementExpression(expr); .)
+	.
+
+/* 10.9.2 */
+LoopControlVariable&lt;out LoopControlVariableExpression loopExpr&gt;
+	(.
+		loopExpr = null;
+		//Expression expr = null;
+		TypeReference type = null;
+		ArrayList arrayModifiers = null;
+		string name;
+	.) =
+	Qualident&lt;out name&gt;
+	[ IF(IsRank()) ArrayTypeModifiers&lt;out arrayModifiers&gt; ]
+	[ &quot;As&quot; TypeName&lt;out type&gt; (. if (name.IndexOf('.') &gt; 0) { Error(&quot;No type def for 'for each' member indexer allowed.&quot;); } .) ]
+	(.
+		if(type != null) {
+			if(type.RankSpecifier != null &amp;&amp; arrayModifiers != null) {
+				Error(&quot;array rank only allowed one time&quot;);
+			} else {
+				type.RankSpecifier = arrayModifiers;
+			}
+		} else {
+			type = new TypeReference(&quot;Integer&quot;, arrayModifiers);
+		}
+		loopExpr = new LoopControlVariableExpression(name, type);
+	.)
+	.
+
+/* 10.2.2 */
+OnErrorStatement&lt;out OnErrorStatement stmt&gt;
+	(.
+		stmt = null;
+		GoToStatement goToStatement = null;
+	.)
+	=
+	&quot;On&quot; &quot;Error&quot;
+	(
+		IF(IsNegativeLabelName())&quot;GoTo&quot; &quot;-&quot; LiteralInteger
+		(.
+			long intLabel = Int64.Parse(t.val);
+			if(intLabel != 1) {
+				Error(&quot;invalid label in on error statement.&quot;);
+			}
+			stmt = new OnErrorStatement(new GoToStatement((intLabel * -1).ToString()));
+		.)
+		| GoToStatement&lt;out goToStatement&gt;
+		(.
+			string val = goToStatement.LabelName;
+			
+			// if value is numeric, make sure that is 0
+			try {
+				long intLabel = Int64.Parse(val);
+				if(intLabel != 0) {
+					Error(&quot;invalid label in on error statement.&quot;);
+				}
+			} catch {
+			}
+			stmt = new OnErrorStatement(goToStatement);
+		.)
+		| &quot;Resume&quot; &quot;Next&quot;
+		(.
+			stmt = new OnErrorStatement(new ResumeStatement(true));
+		.)
+	)
+	.
+
+/* 10.11 */
+GoToStatement&lt;out GoToStatement goToStatement&gt;
+	(.
+		string label = String.Empty;
+	.)
+	=
+	&quot;GoTo&quot; LabelName&lt;out label&gt;
+	(.
+		goToStatement = new GoToStatement(label);
+	.)
+	.
+
+/* 10.1 */
+LabelName&lt;out string name&gt;
+	(.
+		name = String.Empty;
+	.) =
+	Identifier 				(. name = t.val; .)
+	| LiteralInteger	(. name = t.val; .)
+	.
+
+/* 10.10.2.3 */
+ResumeStatement&lt;out ResumeStatement resumeStatement&gt;
+	(.
+		resumeStatement = null;
+		string label = String.Empty;
+	.) =
+	IF(IsResumeNext())
+	&quot;Resume&quot; &quot;Next&quot; 					(. resumeStatement = new ResumeStatement(true); .)
+	| &quot;Resume&quot; [ LabelName&lt;out label&gt; ]	(. resumeStatement = new ResumeStatement(label); .)
+	.
+
+/* 18.8.2 */
+CaseClauses&lt;out ArrayList caseClauses&gt;
+	(.
+		caseClauses = null;
+		CaseClause caseClause = null;
+	.) =
+	CaseClause&lt;out caseClause&gt;
+	(.
+		caseClauses = new ArrayList();
+		caseClauses.Add(caseClause);
+	.)
+	{ &quot;,&quot; CaseClause&lt;out caseClause&gt; (. caseClauses.Add(caseClause); .) }
+	.
+
+/* 19.8.2 */
+CaseClause&lt;out CaseClause caseClause&gt;
+	(.
+		Expression expr = null;
+		Expression sexpr = null;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		caseClause = null;
+	.) =
+	&quot;Else&quot;
+	(. caseClause = new CaseClause(true); .)
+	|
+	[ &quot;Is&quot; ] 
+	(
+		&quot;&lt;&quot;		(. op = BinaryOperatorType.LessThan; .)
+		| &quot;&gt;&quot;	(. op = BinaryOperatorType.GreaterThan; .)
+		| &quot;&lt;=&quot;	(. op = BinaryOperatorType.LessThanOrEqual; .)
+		| &quot;&gt;=&quot;	(. op = BinaryOperatorType.GreaterThanOrEqual; .)
+		| &quot;=&quot;	(. op = BinaryOperatorType.Equality; .)
+		| &quot;&lt;&gt;&quot;	(. op = BinaryOperatorType.InEquality; .)
+	)
+	Expr&lt;out expr&gt;
+	(.
+		caseClause = new CaseClause(op, expr);
+	.)
+	| Expr&lt;out expr&gt; [ &quot;To&quot; Expr&lt;out sexpr&gt; ]
+	(.
+		caseClause = new CaseClause(expr, sexpr);
+	.)
+	.
+
+/* 10.9.1 */
+WhileOrUntil&lt;out ConditionType conditionType&gt;
+	(. conditionType = ConditionType.None; .) =
+	&quot;While&quot;		(. conditionType = ConditionType.While; .)
+	| &quot;Until&quot;	(. conditionType = ConditionType.Until; .)
+	.
+
+/* 10.3 */
+WithStatement&lt;out Statement withStatement&gt;
+	(.
+		Statement blockStmt = null;
+		Expression expr = null;
+	.) =
+	&quot;With&quot; (. Point start = t.Location; .)
+	Expr&lt;out expr&gt; EndOfStmt
+	(.
+		withStatement = new WithStatement(expr);
+		withStatement.StartLocation = start;
+		withStatements.Push(withStatement);
+	.)
+	Block&lt;out blockStmt&gt;
+	(.
+		((WithStatement)withStatement).Body = (BlockStatement)blockStmt;
+		withStatements.Pop();
+	.)
+	&quot;End&quot; &quot;With&quot;
+	(. withStatement.EndLocation = t.Location; .)
+	.
+	
+/* 10.10.1 */
+TryStatement&lt;out Statement tryStatement&gt;
+	(.
+		Statement blockStmt = null, finallyStmt = null;
+		ArrayList catchClauses = null;
+	.) =
+	&quot;Try&quot; EndOfStmt
+	Block&lt;out blockStmt&gt;
+	(
+		CatchClauses&lt;out catchClauses&gt;
+		[ &quot;Finally&quot; EndOfStmt Block&lt;out finallyStmt&gt; ]
+		| &quot;Finally&quot; EndOfStmt Block&lt;out finallyStmt&gt;
+	)
+	&quot;End&quot; &quot;Try&quot;
+	(.
+		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
+	.)
+	.
+
+/* 10.10.1.2 */
+CatchClauses&lt;out ArrayList catchClauses&gt;
+	(.
+		catchClauses = new ArrayList();
+		TypeReference type = null;
+		Statement blockStmt = null;
+		Expression expr = null;
+		string name = String.Empty;
+	.) =
+	{
+		&quot;Catch&quot;
+		[ Identifier (. name = t.val; .) [&quot;As&quot; TypeName&lt;out type&gt;] ]
+		[ &quot;When&quot; Expr&lt;out expr&gt; ]
+		EndOfStmt
+		Block&lt;out blockStmt&gt;
+		(. catchClauses.Add(new CatchClause(type, name, blockStmt, expr)); .)
+	}
+	.
+
+/* 4.7 */
+Qualident&lt;out string qualident&gt;
+	(. string name = String.Empty; .) =
+	Identifier	(. StringBuilder qualidentBuilder = new StringBuilder(t.val); .)
+	{
+		&quot;.&quot; IdentifierOrKeyword&lt;out name&gt; (. qualidentBuilder.Append('.');
+	                                         qualidentBuilder.Append(name); 
+	                                       .)
+	}
+	(. qualident = qualidentBuilder.ToString(); .)
+	.
+
+/* This production handles pseudo keywords that are needed in the grammar */
+Identifier	=
+	ident
+	| &quot;Text&quot;
+	| &quot;Binary&quot;
+	| &quot;Compare&quot;
+	.
+
+/* 2.2 */
+IdentifierOrKeyword&lt;out string name&gt;
+	(.
+		name = String.Empty;
+	.) =
+	Identifier		(. name = t.val; .)
+	| &quot;AddHandler&quot;		(. name = t.val; .)
+	| &quot;AddressOf&quot;		(. name = t.val; .)
+	| &quot;Alias&quot;			(. name = t.val; .)
+	| &quot;And&quot;				(. name = t.val; .)
+	| &quot;AndAlso&quot;			(. name = t.val; .)
+	| &quot;Ansi&quot;			(. name = t.val; .)
+	| &quot;As&quot;				(. name = t.val; .)
+	| &quot;Assembly&quot;		(. name = t.val; .)
+	| &quot;Auto&quot;			(. name = t.val; .)
+	| &quot;Boolean&quot;			(. name = t.val; .)
+	| &quot;ByRef&quot;			(. name = t.val; .)
+	| &quot;Byte&quot;			(. name = t.val; .)
+	| &quot;ByVal&quot;			(. name = t.val; .)
+	| &quot;Call&quot;			(. name = t.val; .)
+	| &quot;Case&quot;			(. name = t.val; .)
+	| &quot;Catch&quot;			(. name = t.val; .)
+	| &quot;CBool&quot;			(. name = t.val; .)
+	| &quot;CByte&quot;			(. name = t.val; .)
+	| &quot;CChar&quot;			(. name = t.val; .)
+	| &quot;CDate&quot;			(. name = t.val; .)
+	| &quot;CDbl&quot;			(. name = t.val; .)
+	| &quot;CDec&quot;			(. name = t.val; .)
+	| &quot;Char&quot;			(. name = t.val; .)
+	| &quot;CInt&quot;			(. name = t.val; .)
+	| &quot;Class&quot;			(. name = t.val; .)
+	| &quot;CLng&quot;			(. name = t.val; .)
+	| &quot;CObj&quot;			(. name = t.val; .)
+	| &quot;Const&quot;			(. name = t.val; .)
+	| &quot;CShort&quot;			(. name = t.val; .)
+	| &quot;CSng&quot;			(. name = t.val; .)
+	| &quot;CStr&quot;			(. name = t.val; .)
+	| &quot;CType&quot;			(. name = t.val; .)
+	| &quot;Date&quot;			(. name = t.val; .)
+	| &quot;Decimal&quot;			(. name = t.val; .)
+	| &quot;Declare&quot;			(. name = t.val; .)
+	| &quot;Default&quot;			(. name = t.val; .)
+	| &quot;Delegate&quot;		(. name = t.val; .)
+	| &quot;Dim&quot;				(. name = t.val; .)
+	| &quot;DirectCast&quot;		(. name = t.val; .)
+	| &quot;Do&quot;				(. name = t.val; .)
+	| &quot;Double&quot;			(. name = t.val; .)
+	| &quot;Each&quot;			(. name = t.val; .)
+	| &quot;Else&quot;			(. name = t.val; .)
+	| &quot;ElseIf&quot;			(. name = t.val; .)
+	| &quot;End&quot;				(. name = t.val; .)
+	| &quot;EndIf&quot;			(. name = t.val; .)
+	| &quot;Enum&quot;			(. name = t.val; .)
+	| &quot;Erase&quot;			(. name = t.val; .)
+	| &quot;Error&quot;			(. name = t.val; .)
+	| &quot;Event&quot;			(. name = t.val; .)
+	| &quot;Exit&quot;			(. name = t.val; .)
+	| &quot;False&quot;			(. name = t.val; .)
+	| &quot;Finally&quot;			(. name = t.val; .)
+	| &quot;For&quot;				(. name = t.val; .)
+	| &quot;Friend&quot;			(. name = t.val; .)
+	| &quot;Function&quot;		(. name = t.val; .)
+	| &quot;Get&quot;				(. name = t.val; .)
+	| &quot;GetType&quot;			(. name = t.val; .)
+	| &quot;GoSub&quot;			(. name = t.val; .)
+	| &quot;GoTo&quot;			(. name = t.val; .)
+	| &quot;Handles&quot;			(. name = t.val; .)
+	| &quot;If&quot;				(. name = t.val; .)
+	| &quot;Implements&quot;		(. name = t.val; .)
+	| &quot;Imports&quot;			(. name = t.val; .)
+	| &quot;In&quot;				(. name = t.val; .)
+	| &quot;Inherits&quot;		(. name = t.val; .)
+	| &quot;Integer&quot;			(. name = t.val; .)
+	| &quot;Interface&quot;		(. name = t.val; .)
+	| &quot;Is&quot;				(. name = t.val; .)
+	| &quot;Let&quot;				(. name = t.val; .)
+	| &quot;Lib&quot;				(. name = t.val; .)
+	| &quot;Like&quot;			(. name = t.val; .)
+	| &quot;Long&quot;			(. name = t.val; .)
+	| &quot;Loop&quot;			(. name = t.val; .)
+	| &quot;Me&quot;				(. name = t.val; .)
+	| &quot;Mod&quot;				(. name = t.val; .)
+	| &quot;Module&quot;			(. name = t.val; .)
+	| &quot;MustInherit&quot;		(. name = t.val; .)
+	| &quot;MustOverride&quot;	(. name = t.val; .)
+	| &quot;MyBase&quot;			(. name = t.val; .)
+	| &quot;MyClass&quot;			(. name = t.val; .)
+	| &quot;Namespace&quot;		(. name = t.val; .)
+	| &quot;New&quot;				(. name = t.val; .)
+	| &quot;Next&quot;			(. name = t.val; .)
+	| &quot;Not&quot;				(. name = t.val; .)
+	| &quot;Nothing&quot;			(. name = t.val; .)
+	| &quot;NotInheritable&quot;	(. name = t.val; .)
+	| &quot;NotOverridable&quot;	(. name = t.val; .)
+	| &quot;Object&quot;			(. name = t.val; .)
+	| &quot;On&quot;				(. name = t.val; .)
+	| &quot;Option&quot;			(. name = t.val; .)
+	| &quot;Optional&quot;		(. name = t.val; .)
+	| &quot;Or&quot;				(. name = t.val; .)
+	| &quot;OrElse&quot;			(. name = t.val; .)
+	| &quot;Overloads&quot;		(. name = t.val; .)
+	| &quot;Overridable&quot;		(. name = t.val; .)
+	| &quot;Overrides&quot;		(. name = t.val; .)
+	| &quot;ParamArray&quot;		(. name = t.val; .)
+	| &quot;Preserve&quot;		(. name = t.val; .)
+	| &quot;Private&quot;			(. name = t.val; .)
+	| &quot;Property&quot;		(. name = t.val; .)
+	| &quot;Protected&quot;		(. name = t.val; .)
+	| &quot;Public&quot;			(. name = t.val; .)
+	| &quot;RaiseEvent&quot;		(. name = t.val; .)
+	| &quot;ReadOnly&quot;		(. name = t.val; .)
+	| &quot;ReDim&quot;			(. name = t.val; .)
+	| &quot;RemoveHandler&quot;	(. name = t.val; .)
+	| &quot;Resume&quot;			(. name = t.val; .)
+	| &quot;Return&quot;			(. name = t.val; .)
+	| &quot;Select&quot;			(. name = t.val; .)
+	| &quot;Set&quot;				(. name = t.val; .)
+	| &quot;Shadows&quot;			(. name = t.val; .)
+	| &quot;Shared&quot;			(. name = t.val; .)
+	| &quot;Short&quot;			(. name = t.val; .)
+	| &quot;Single&quot;			(. name = t.val; .)
+	| &quot;Static&quot;			(. name = t.val; .)
+	| &quot;Step&quot;			(. name = t.val; .)
+	| &quot;Stop&quot;			(. name = t.val; .)
+	| &quot;String&quot;			(. name = t.val; .)
+	| &quot;Structure&quot;		(. name = t.val; .)
+	| &quot;Sub&quot;				(. name = t.val; .)
+	| &quot;SyncLock&quot;		(. name = t.val; .)
+	| &quot;Then&quot;			(. name = t.val; .)
+	| &quot;Throw&quot;			(. name = t.val; .)
+	| &quot;To&quot;				(. name = t.val; .)
+	| &quot;True&quot;			(. name = t.val; .)
+	| &quot;Try&quot;				(. name = t.val; .)
+	| &quot;TypeOf&quot;			(. name = t.val; .)
+	| &quot;Unicode&quot;			(. name = t.val; .)
+	| &quot;Until&quot;			(. name = t.val; .)
+	| &quot;Variant&quot;			(. name = t.val; .)
+	| &quot;Wend&quot;			(. name = t.val; .)
+	| &quot;When&quot;			(. name = t.val; .)
+	| &quot;While&quot;			(. name = t.val; .)
+	| &quot;With&quot;			(. name = t.val; .)
+	| &quot;WithEvents&quot;		(. name = t.val; .)
+	| &quot;WriteOnly&quot;		(. name = t.val; .)
+	| &quot;Xor&quot;				(. name = t.val; .)
+	.
+
+/* 7.3 */
+PrimitiveTypeName&lt;out string type&gt;
+	(. type = String.Empty; .) =
+	&quot;Boolean&quot;		(. type = &quot;Boolean&quot;; .)
+	| &quot;Date&quot;		(. type = &quot;Date&quot;; .)
+	| &quot;Char&quot;		(. type = &quot;Char&quot;; .)
+	| &quot;String&quot;		(. type = &quot;String&quot;; .)
+	| &quot;Decimal&quot;		(. type = &quot;Decimal&quot;; .)
+	| &quot;Byte&quot;		(. type = &quot;Byte&quot;; .)
+	| &quot;Short&quot;		(. type = &quot;Short&quot;; .)
+	| &quot;Integer&quot;		(. type = &quot;Integer&quot;; .)
+	| &quot;Long&quot;		(. type = &quot;Long&quot;; .)
+	| &quot;Single&quot;		(. type = &quot;Single&quot;; .)
+	| &quot;Double&quot;		(. type = &quot;Double&quot;; .)
+	.
+
+ParameterModifier&lt;ParamModifiers m&gt;
+	= &quot;ByVal&quot;			(. m.Add(ParamModifier.ByVal); .)
+	| &quot;ByRef&quot;			(. m.Add(ParamModifier.ByRef); .)
+	| &quot;Optional&quot;		(. m.Add(ParamModifier.Optional); .)
+	| &quot;ParamArray&quot;		(. m.Add(ParamModifier.ParamArray); .)
+	.
+
+TypeModifier&lt;Modifiers m&gt;
+	= &quot;Public&quot;			(. m.Add(Modifier.Public); .)
+	| &quot;Protected&quot;		(. m.Add(Modifier.Protected); .)
+	| &quot;Friend&quot;			(. m.Add(Modifier.Friend); .)
+	| &quot;Private&quot;			(. m.Add(Modifier.Private); .)
+	| &quot;Shared&quot;			(. m.Add(Modifier.Shared); .)
+	| &quot;Shadows&quot;			(. m.Add(Modifier.Shadows); .)
+	| &quot;MustInherit&quot;		(. m.Add(Modifier.MustInherit); .)
+	| &quot;NotInheritable&quot;	(. m.Add(Modifier.NotInheritable); .)
+	.
+
+MemberModifier&lt;Modifiers m&gt; =
+	&quot;MustInherit&quot;		(.m.Add(Modifier.MustInherit);.)
+	|&quot;Default&quot;			(.m.Add(Modifier.Default);.)
+	|&quot;Friend&quot;			(.m.Add(Modifier.Friend);.)
+	|&quot;Shadows&quot;			(.m.Add(Modifier.Shadows);.)
+	|&quot;Overrides&quot;		(.m.Add(Modifier.Overrides);.)
+	|&quot;MustOverride&quot;		(.m.Add(Modifier.MustOverride);.)
+	|&quot;Private&quot;			(.m.Add(Modifier.Private);.)
+	|&quot;Protected&quot;		(.m.Add(Modifier.Protected);.)
+	|&quot;Public&quot;			(.m.Add(Modifier.Public);.)
+	|&quot;NotInheritable&quot;	(.m.Add(Modifier.NotInheritable);.)
+	|&quot;NotOverridable&quot;	(.m.Add(Modifier.NotOverridable);.)
+	|&quot;Shared&quot;			(.m.Add(Modifier.Shared);.)
+	|&quot;Overridable&quot;		(.m.Add(Modifier.Overridable);.)
+	|&quot;Overloads&quot;		(.m.Add(Modifier.Overloads);.)
+	| &quot;ReadOnly&quot;		(.m.Add(Modifier.ReadOnly);.)
+	| &quot;WriteOnly&quot;		(.m.Add(Modifier.WriteOnly);.)
+	| &quot;WithEvents&quot;		(.m.Add(Modifier.WithEvents);.)
+	| &quot;Dim&quot;				(.m.Add(Modifier.Dim);.)
+	.
+
+END VBNET.


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,4 +1,4 @@
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">- at echo</A> off
-SharpCoco -namespace ICSharpCode.SharpRefactory.Parser.VB VBNET.ATG
-del Parser.old.cs
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">+ at echo</A> off
+SharpCoco -namespace ICSharpCode.SharpRefactory.Parser.VB VBNET.ATG
+del Parser.old.cs
 pause
\ No newline at end of file


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/buildparser.cmd
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,222 +1,222 @@
-#!/bin/perl
-
-# File names
-$keyword_file     = &quot;KeywordList.txt&quot;;
-$keywords_outfile = &quot;Keywords.cs&quot;;
-$tokens_outfile   = &quot;Tokens.cs&quot;;
-$ATGTokensSection = &quot;ATGTokensSection.gen&quot;;
-
-#read infile
-print &quot;\n&quot;;
-print &quot;Reading keyword definition from '$keyword_file'.\n&quot;;
-open(DAT, $keyword_file) || die(&quot;Could not open file!&quot;);
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">- at raw_data</A>=&lt;DAT&gt;;
-close(DAT);
-print &quot;done.\n&quot;;
-
-#analyse infile
-print &quot;starting analysation ... this could take a few minutes.\n&quot;;
-
-foreach (@raw_data) {
-	if ($_=~/\A\s*\$(\w+)\s*=\s*(\S+)/) {
-		#properties form: $PROPERTY = &quot;VALUE&quot;
-		$properties{$1} = $2;
-	} elsif  ($_=~/\A\s*(\w+)\s*=\s*(\S+)/) {
-		#special characters form: name = &quot;VALUE&quot;
-		$special_chars[$#special_chars + 1] = $1;
-		$special_values[$#special_values + 1] = $2;
-	} elsif  ($_=~/\A\s*\&quot;(\S+)\s*\&quot;/) {
-		#special keywords form: &quot;VALUE&quot;
-		$keywords[$#keywords + 1] = $1
-	} elsif  ($_=~/\A\s*(\w+)\s*/) {
-		#special terminal classes form: name
-		$terminals[$#terminals + 1] = $1
-	}
-}
-
-for ($i=0; $i &lt;= $#keywords; $i++) {
-	$upperKeywords[$i] = uc $keywords[$i];
-}
-sort (ascend @upperKeywords);
-
-
-sort (ascend @keywords);
-print &quot;done.\n&quot;;
-
-#write output
-print &quot;writing output files.\nIf your computer doesn&#146;t respond, then press \&quot;Ctrl-Alt-Delete\&quot;\n&quot;;
-print &quot;\n&quot;;
-&amp;write_keywordfile;
-print &quot;\n&quot;;
-&amp;write_tokensfile;
-print &quot;\n&quot;;
-&amp;write_atgtokensfile;
-print &quot;\n&quot;;
-print &quot;finished.\n&quot;;
-
-sub write_keywordfile {
-	print &quot;  -&gt;Generating Keywords class to file '$keywords_outfile'\n&quot;;
-	open(DAT,&quot;&gt;$keywords_outfile&quot;) || die(&quot;Cannot Open File&quot;);
-	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
-	print DAT &quot;using System;\n&quot;;
-	print DAT &quot;using System.Collections;\n&quot;;
-	print DAT &quot;using System.Text;\n&quot;;
-	print DAT &quot;\n&quot;;
-	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
-	print DAT &quot;{\n&quot;;
-	print DAT &quot;	public class Keywords\n&quot;;
-	print DAT &quot;	{\n&quot;;
-	print DAT &quot;		static readonly string[] keywordList = {\n&quot;;
-	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
-		for ($i=0; $i &lt;= $#upperKeywords; $i++) {
-			print DAT &quot;			\&quot;$upperKeywords[$i]\&quot;&quot;;
-			if ($i + 1 &lt;= $#upperKeywords) {
-				print DAT &quot;,&quot;;
-			}
-			print DAT &quot;\n&quot;;
-		}
-	} else {
-		for ($i=0; $i &lt;= $#keywords; $i++) {
-			print DAT &quot;			\&quot;$keywords[$i]\&quot;&quot;;
-			if ($i + 1 &lt;= $#keywords) {
-				print DAT &quot;,&quot;;
-			}
-			print DAT &quot;\n&quot;;
-		}
-	}
-	
-	print DAT &quot;		};\n&quot;;
-	print DAT &quot;		\n&quot;;
-	print DAT &quot;		static Hashtable keywords = new Hashtable();\n&quot;;
-	print DAT &quot;		\n&quot;;
-	print DAT &quot;		static Keywords()\n&quot;;
-	print DAT &quot;		{\n&quot;;
-	print DAT &quot;			for (int i = 0; i &lt; keywordList.Length; ++i) {\n&quot;;
-	print DAT &quot;				keywords.Add(keywordList[i], i + Tokens.$keywords[0]);\n&quot;;
-	print DAT &quot;			}\n&quot;;
-	print DAT &quot;		}\n&quot;;
-	print DAT &quot;		\n&quot;;
-	print DAT &quot;		public static bool IsKeyword(string identifier)\n&quot;;
-	print DAT &quot;		{\n&quot;;
-	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
-		print DAT &quot;			return keywords[identifier.ToUpper()] != null;\n&quot;;
-	} else {
-		print DAT &quot;			return keywords[identifier] != null;\n&quot;;
-	}
-	print DAT &quot;		}\n&quot;;
-	print DAT &quot;		\n&quot;;
-	print DAT &quot;		public static int GetToken(string keyword)\n&quot;;
-	print DAT &quot;		{\n&quot;;
-	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
-		print DAT &quot;			return (int)keywords[keyword.ToUpper()];\n&quot;;
-	} else {
-		print DAT &quot;			return (int)keywords[keyword];\n&quot;;
-	}
-	print DAT &quot;		}\n&quot;;
-	print DAT &quot;	}\n&quot;;
-	print DAT &quot;}\n&quot;;
-	
-	close(DAT);
-	print &quot;  -&gt;done.\n&quot;;
-}
-
-sub write_token {
-	$formattedString = sprintf(&quot;%-20s&quot;, $tokenName);
-	if ($tokenName eq &quot;GetType&quot;) {
-		print DAT &quot;		new public const int $formattedString = $tokenValue;\n&quot;;
-	} else {
-		print DAT &quot;		public const int $formattedString = $tokenValue;\n&quot;;
-	}
-	$tokenValue++;
-	
-}
-
-sub write_tokensfile {
-	print &quot;  -&gt;Generating Tokens class to file '$tokens_outfile'\n&quot;;
-	open(DAT,&quot;&gt;$tokens_outfile&quot;) || die(&quot;Cannot Open File&quot;);
-	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
-	print DAT &quot;using System;\n&quot;;
-	print DAT &quot;\n&quot;;
-	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
-	print DAT &quot;{\n&quot;;
-	print DAT &quot;	public sealed class Tokens\n&quot;;
-	print DAT &quot;	{\n&quot;;
-	$tokenValue = 0;
-	
-	print DAT &quot;		// ----- terminal classes -----\n&quot;;
-	foreach (@terminals) {
-		$tokenName = $_;
-		write_token();
-	}
-	print DAT &quot;\n&quot;;
-	print DAT &quot;		// ----- special character -----\n&quot;;
-	foreach (@special_chars) {
-		$tokenName = $_;
-		write_token();
-	}
-	print DAT &quot;\n&quot;;
-	print DAT &quot;		// ----- keywords -----\n&quot;;
-	foreach (@keywords) {
-		$tokenName = $_;
-		write_token();
-	}
-	print DAT &quot;\n&quot;;
-	
-	print DAT &quot;		public static string GetTokenString(int token)\n&quot;;
-	print DAT &quot;		{\n&quot;;
-	print DAT &quot;			switch (token) {\n&quot;;
-	for ($i = 0; $i &lt;= $#special_chars; $i++) {
-		print DAT &quot;				case $special_chars[$i]:\n&quot;;
-		print DAT &quot;					return $special_values[$i];\n&quot;;
-	}
-	foreach (@keywords) {
-		print DAT &quot;				case $_:\n&quot;;
-		print DAT &quot;					return \&quot;$_\&quot;;\n&quot;;
-	}
-	
-	print DAT &quot;			}\n&quot;;
-	print DAT &quot;			throw new System.NotSupportedException(\&quot;Unknown token:\&quot; + token);\n&quot;;
-	print DAT &quot;		}\n&quot;;
-	print DAT &quot;	}\n&quot;;
-	
-	
-	
-	print DAT &quot;}\n&quot;;
-	close(DAT);
-	print &quot;  -&gt;done.\n&quot;;
-}
-
-sub write_atgtokensfile {
-	print &quot;  -&gt;Generating ATG TOKENS section and writing it to file '$ATGTokensSection'\n&quot;;
-	open(DAT,&quot;&gt;$ATGTokensSection&quot;) || die(&quot;Cannot Open File&quot;);
-	print DAT &quot;/* START AUTOGENERATED TOKENS SECTION */\n&quot;;
-	print DAT &quot;TOKENS\n&quot;;
-
-	print DAT &quot;	/* ----- terminal classes ----- */\n&quot;;
-	print DAT &quot;	/* EOF is 0 */\n&quot;;
-	foreach $term (@terminals) {
-		if ($term eq &quot;EOF&quot;) {
-		} elsif ($term eq &quot;Identifier&quot;) {
-			print DAT &quot;\tident\n&quot;;
-		} else {
-			print DAT &quot;\t$term\n&quot;;
-		}
-			
-	}
-	
-	print DAT &quot;\n&quot;;
-	print DAT &quot;	/* ----- special character ----- */\n&quot;;
-	foreach (@special_values) {
-		print DAT &quot;\t$_\n&quot;;
-	}
-	print DAT &quot;\n&quot;;
-	print DAT &quot;	/* ----- keywords ----- */\n&quot;;
-	foreach (@keywords) {
-		print DAT &quot;\t\&quot;$_\&quot;\n&quot;;
-	}
-
-	print DAT &quot;/* END AUTOGENERATED TOKENS SECTION */\n&quot;;
-	close(DAT);
-	print &quot;  -&gt;done.\n&quot;;
-}
-
+#!/bin/perl
+
+# File names
+$keyword_file     = &quot;KeywordList.txt&quot;;
+$keywords_outfile = &quot;Keywords.cs&quot;;
+$tokens_outfile   = &quot;Tokens.cs&quot;;
+$ATGTokensSection = &quot;ATGTokensSection.gen&quot;;
+
+#read infile
+print &quot;\n&quot;;
+print &quot;Reading keyword definition from '$keyword_file'.\n&quot;;
+open(DAT, $keyword_file) || die(&quot;Could not open file!&quot;);
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">+ at raw_data</A>=&lt;DAT&gt;;
+close(DAT);
+print &quot;done.\n&quot;;
+
+#analyse infile
+print &quot;starting analysation ... this could take a few minutes.\n&quot;;
+
+foreach (@raw_data) {
+	if ($_=~/\A\s*\$(\w+)\s*=\s*(\S+)/) {
+		#properties form: $PROPERTY = &quot;VALUE&quot;
+		$properties{$1} = $2;
+	} elsif  ($_=~/\A\s*(\w+)\s*=\s*(\S+)/) {
+		#special characters form: name = &quot;VALUE&quot;
+		$special_chars[$#special_chars + 1] = $1;
+		$special_values[$#special_values + 1] = $2;
+	} elsif  ($_=~/\A\s*\&quot;(\S+)\s*\&quot;/) {
+		#special keywords form: &quot;VALUE&quot;
+		$keywords[$#keywords + 1] = $1
+	} elsif  ($_=~/\A\s*(\w+)\s*/) {
+		#special terminal classes form: name
+		$terminals[$#terminals + 1] = $1
+	}
+}
+
+for ($i=0; $i &lt;= $#keywords; $i++) {
+	$upperKeywords[$i] = uc $keywords[$i];
+}
+sort (ascend @upperKeywords);
+
+
+sort (ascend @keywords);
+print &quot;done.\n&quot;;
+
+#write output
+print &quot;writing output files.\nIf your computer doesn&#146;t respond, then press \&quot;Ctrl-Alt-Delete\&quot;\n&quot;;
+print &quot;\n&quot;;
+&amp;write_keywordfile;
+print &quot;\n&quot;;
+&amp;write_tokensfile;
+print &quot;\n&quot;;
+&amp;write_atgtokensfile;
+print &quot;\n&quot;;
+print &quot;finished.\n&quot;;
+
+sub write_keywordfile {
+	print &quot;  -&gt;Generating Keywords class to file '$keywords_outfile'\n&quot;;
+	open(DAT,&quot;&gt;$keywords_outfile&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
+	print DAT &quot;using System;\n&quot;;
+	print DAT &quot;using System.Collections;\n&quot;;
+	print DAT &quot;using System.Text;\n&quot;;
+	print DAT &quot;\n&quot;;
+	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
+	print DAT &quot;{\n&quot;;
+	print DAT &quot;	public class Keywords\n&quot;;
+	print DAT &quot;	{\n&quot;;
+	print DAT &quot;		static readonly string[] keywordList = {\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		for ($i=0; $i &lt;= $#upperKeywords; $i++) {
+			print DAT &quot;			\&quot;$upperKeywords[$i]\&quot;&quot;;
+			if ($i + 1 &lt;= $#upperKeywords) {
+				print DAT &quot;,&quot;;
+			}
+			print DAT &quot;\n&quot;;
+		}
+	} else {
+		for ($i=0; $i &lt;= $#keywords; $i++) {
+			print DAT &quot;			\&quot;$keywords[$i]\&quot;&quot;;
+			if ($i + 1 &lt;= $#keywords) {
+				print DAT &quot;,&quot;;
+			}
+			print DAT &quot;\n&quot;;
+		}
+	}
+	
+	print DAT &quot;		};\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		static Hashtable keywords = new Hashtable();\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		static Keywords()\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	print DAT &quot;			for (int i = 0; i &lt; keywordList.Length; ++i) {\n&quot;;
+	print DAT &quot;				keywords.Add(keywordList[i], i + Tokens.$keywords[0]);\n&quot;;
+	print DAT &quot;			}\n&quot;;
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		public static bool IsKeyword(string identifier)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		print DAT &quot;			return keywords[identifier.ToUpper()] != null;\n&quot;;
+	} else {
+		print DAT &quot;			return keywords[identifier] != null;\n&quot;;
+	}
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		public static int GetToken(string keyword)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		print DAT &quot;			return (int)keywords[keyword.ToUpper()];\n&quot;;
+	} else {
+		print DAT &quot;			return (int)keywords[keyword];\n&quot;;
+	}
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;	}\n&quot;;
+	print DAT &quot;}\n&quot;;
+	
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+
+sub write_token {
+	$formattedString = sprintf(&quot;%-20s&quot;, $tokenName);
+	if ($tokenName eq &quot;GetType&quot;) {
+		print DAT &quot;		new public const int $formattedString = $tokenValue;\n&quot;;
+	} else {
+		print DAT &quot;		public const int $formattedString = $tokenValue;\n&quot;;
+	}
+	$tokenValue++;
+	
+}
+
+sub write_tokensfile {
+	print &quot;  -&gt;Generating Tokens class to file '$tokens_outfile'\n&quot;;
+	open(DAT,&quot;&gt;$tokens_outfile&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
+	print DAT &quot;using System;\n&quot;;
+	print DAT &quot;\n&quot;;
+	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
+	print DAT &quot;{\n&quot;;
+	print DAT &quot;	public sealed class Tokens\n&quot;;
+	print DAT &quot;	{\n&quot;;
+	$tokenValue = 0;
+	
+	print DAT &quot;		// ----- terminal classes -----\n&quot;;
+	foreach (@terminals) {
+		$tokenName = $_;
+		write_token();
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;		// ----- special character -----\n&quot;;
+	foreach (@special_chars) {
+		$tokenName = $_;
+		write_token();
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;		// ----- keywords -----\n&quot;;
+	foreach (@keywords) {
+		$tokenName = $_;
+		write_token();
+	}
+	print DAT &quot;\n&quot;;
+	
+	print DAT &quot;		public static string GetTokenString(int token)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	print DAT &quot;			switch (token) {\n&quot;;
+	for ($i = 0; $i &lt;= $#special_chars; $i++) {
+		print DAT &quot;				case $special_chars[$i]:\n&quot;;
+		print DAT &quot;					return $special_values[$i];\n&quot;;
+	}
+	foreach (@keywords) {
+		print DAT &quot;				case $_:\n&quot;;
+		print DAT &quot;					return \&quot;$_\&quot;;\n&quot;;
+	}
+	
+	print DAT &quot;			}\n&quot;;
+	print DAT &quot;			throw new System.NotSupportedException(\&quot;Unknown token:\&quot; + token);\n&quot;;
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;	}\n&quot;;
+	
+	
+	
+	print DAT &quot;}\n&quot;;
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+
+sub write_atgtokensfile {
+	print &quot;  -&gt;Generating ATG TOKENS section and writing it to file '$ATGTokensSection'\n&quot;;
+	open(DAT,&quot;&gt;$ATGTokensSection&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;/* START AUTOGENERATED TOKENS SECTION */\n&quot;;
+	print DAT &quot;TOKENS\n&quot;;
+
+	print DAT &quot;	/* ----- terminal classes ----- */\n&quot;;
+	print DAT &quot;	/* EOF is 0 */\n&quot;;
+	foreach $term (@terminals) {
+		if ($term eq &quot;EOF&quot;) {
+		} elsif ($term eq &quot;Identifier&quot;) {
+			print DAT &quot;\tident\n&quot;;
+		} else {
+			print DAT &quot;\t$term\n&quot;;
+		}
+			
+	}
+	
+	print DAT &quot;\n&quot;;
+	print DAT &quot;	/* ----- special character ----- */\n&quot;;
+	foreach (@special_values) {
+		print DAT &quot;\t$_\n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;	/* ----- keywords ----- */\n&quot;;
+	foreach (@keywords) {
+		print DAT &quot;\t\&quot;$_\&quot;\n&quot;;
+	}
+
+	print DAT &quot;/* END AUTOGENERATED TOKENS SECTION */\n&quot;;
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/BuildKeywords.pl
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,211 +1,211 @@
-# this list is used for autogeneration of:
-# - Keywords.cs
-# - Tokens.cs
-# - ATGTokensSection.txt - the TOKENS section of the ATG file
-
-# use BuildKeywords to generate the different lists.
-
-$Namespace=ICSharpCode.SharpRefactory.Parser.VB
-$UpperCaseKeywords=True
-
-# TERMINAL_CLASSES
-EOF
-EOL
-Identifier
-LiteralString
-LiteralCharacter
-LiteralInteger
-LiteralDouble
-LiteralSingle
-LiteralDecimal
-LiteralDate
-
-# SPECIAL_CHARACTERS
-Dot = &quot;.&quot;
-Assign = &quot;=&quot;
-Comma = &quot;,&quot;
-Colon =&quot;:&quot;
-Plus = &quot;+&quot;
-Minus = &quot;-&quot;
-Times = &quot;*&quot;
-Div =&quot;/&quot;
-DivInteger = &quot;\\&quot;
-ConcatString = &quot;&amp;&quot;
-Power = &quot;^&quot;
-	
-OpenCurlyBrace = &quot;{&quot;
-CloseCurlyBrace = &quot;}&quot;
-	
-OpenSquareBracket = &quot;[&quot;
-CloseSquareBracket =&quot;]&quot;
-	
-OpenParenthesis = &quot;(&quot;
-CloseParenthesis = &quot;)&quot;
-	
-GreaterThan = &quot;&gt;&quot;
-LessThan = &quot;&lt;&quot;
-	
-NotEqual = &quot;&lt;&gt;&quot;
-GreaterEqual = &quot;&gt;=&quot;
-LessEqual = &quot;&lt;=&quot;
-	
-ShiftLeft = &quot;&lt;&lt;&quot;
-ShiftRight = &quot;&gt;&gt;&quot;
-	
-PlusAssign = &quot;+=&quot;
-PowerAssign = &quot;^=&quot;
-MinusAssign = &quot;-=&quot;
-TimesAssign = &quot;*=&quot;
-DivAssign = &quot;/=&quot;
-DivIntegerAssign = &quot;\\=&quot;
-ShiftLeftAssign = &quot;&lt;&lt;=&quot;
-ShiftRightAssign = &quot;&gt;&gt;=&quot;
-ConcatStringAssign = &quot;&amp;=&quot;
-
-# keywords according to the spec:
-# Keywordlist
-&quot;AddHandler&quot;
-&quot;AddressOf&quot;
-&quot;Alias&quot;
-&quot;And&quot;
-&quot;AndAlso&quot;
-&quot;Ansi&quot;
-&quot;As&quot;
-&quot;Assembly&quot;
-&quot;Auto&quot;
-&quot;Binary&quot;
-&quot;Boolean&quot;
-&quot;ByRef&quot;
-&quot;Byte&quot;
-&quot;ByVal&quot;
-&quot;Call&quot;
-&quot;Case&quot;
-&quot;Catch&quot;
-&quot;CBool&quot;
-&quot;CByte&quot;
-&quot;CChar&quot;
-&quot;CDate&quot;
-&quot;CDbl&quot;
-&quot;CDec&quot;
-&quot;Char&quot;
-&quot;CInt&quot;
-&quot;Class&quot;
-&quot;CLng&quot;
-&quot;CObj&quot;
-&quot;Compare&quot;
-&quot;Const&quot;
-&quot;CShort&quot;
-&quot;CSng&quot;
-&quot;CStr&quot;
-&quot;CType&quot;
-&quot;Date&quot;
-&quot;Decimal&quot;
-&quot;Declare&quot;
-&quot;Default&quot;
-&quot;Delegate&quot;
-&quot;Dim&quot;
-&quot;DirectCast&quot;
-&quot;Do&quot;
-&quot;Double&quot;
-&quot;Each&quot;
-&quot;Else&quot;
-&quot;ElseIf&quot;
-&quot;End&quot;
-&quot;EndIf&quot;
-&quot;Enum&quot;
-&quot;Erase&quot;
-&quot;Error&quot;
-&quot;Event&quot;
-&quot;Exit&quot;
-&quot;Explicit&quot;
-&quot;False&quot;
-&quot;Finally&quot;
-&quot;For&quot;
-&quot;Friend&quot;
-&quot;Function&quot;
-&quot;Get&quot;
-&quot;GetType&quot;
-&quot;GoSub&quot;
-&quot;GoTo&quot;
-&quot;Handles&quot;
-&quot;If&quot;
-&quot;Implements&quot;
-&quot;Imports&quot;
-&quot;In&quot;
-&quot;Inherits&quot;
-&quot;Integer&quot;
-&quot;Interface&quot;
-&quot;Is&quot;
-&quot;Let&quot;
-&quot;Lib&quot;
-&quot;Like&quot;
-&quot;Long&quot;
-&quot;Loop&quot;
-&quot;Me&quot;
-&quot;Mod&quot;
-&quot;Module&quot;
-&quot;MustInherit&quot;
-&quot;MustOverride&quot;
-&quot;MyBase&quot;
-&quot;MyClass&quot;
-&quot;Namespace&quot;
-&quot;New&quot;
-&quot;Next&quot;
-&quot;Not&quot;
-&quot;Nothing&quot;
-&quot;NotInheritable&quot;
-&quot;NotOverridable&quot;
-&quot;Object&quot;
-&quot;Off&quot;
-&quot;On&quot;
-&quot;Option&quot;
-&quot;Optional&quot;
-&quot;Or&quot;
-&quot;OrElse&quot;
-&quot;Overloads&quot;
-&quot;Overridable&quot;
-&quot;Override&quot;
-&quot;Overrides&quot;
-&quot;ParamArray&quot;
-&quot;Preserve&quot;
-&quot;Private&quot;
-&quot;Property&quot;
-&quot;Protected&quot;
-&quot;Public&quot;
-&quot;RaiseEvent&quot;
-&quot;ReadOnly&quot;
-&quot;ReDim&quot;
-&quot;RemoveHandler&quot;
-&quot;Resume&quot;
-&quot;Return&quot;
-&quot;Select&quot;
-&quot;Set&quot;
-&quot;Shadows&quot;
-&quot;Shared&quot;
-&quot;Short&quot;
-&quot;Single&quot;
-&quot;Static&quot;
-&quot;Step&quot;
-&quot;Stop&quot;
-&quot;Strict&quot;
-&quot;String&quot;
-&quot;Structure&quot;
-&quot;Sub&quot;
-&quot;SyncLock&quot;
-&quot;Text&quot;
-&quot;Then&quot;
-&quot;Throw&quot;
-&quot;To&quot;
-&quot;True&quot;
-&quot;Try&quot;
-&quot;TypeOf&quot;
-&quot;Unicode&quot;
-&quot;Until&quot;
-&quot;Variant&quot;
-&quot;Wend&quot;
-&quot;When&quot;
-&quot;While&quot;
-&quot;With&quot;
-&quot;WithEvents&quot;
-&quot;WriteOnly&quot;
-&quot;Xor&quot;
+# this list is used for autogeneration of:
+# - Keywords.cs
+# - Tokens.cs
+# - ATGTokensSection.txt - the TOKENS section of the ATG file
+
+# use BuildKeywords to generate the different lists.
+
+$Namespace=ICSharpCode.SharpRefactory.Parser.VB
+$UpperCaseKeywords=True
+
+# TERMINAL_CLASSES
+EOF
+EOL
+Identifier
+LiteralString
+LiteralCharacter
+LiteralInteger
+LiteralDouble
+LiteralSingle
+LiteralDecimal
+LiteralDate
+
+# SPECIAL_CHARACTERS
+Dot = &quot;.&quot;
+Assign = &quot;=&quot;
+Comma = &quot;,&quot;
+Colon =&quot;:&quot;
+Plus = &quot;+&quot;
+Minus = &quot;-&quot;
+Times = &quot;*&quot;
+Div =&quot;/&quot;
+DivInteger = &quot;\\&quot;
+ConcatString = &quot;&amp;&quot;
+Power = &quot;^&quot;
+	
+OpenCurlyBrace = &quot;{&quot;
+CloseCurlyBrace = &quot;}&quot;
+	
+OpenSquareBracket = &quot;[&quot;
+CloseSquareBracket =&quot;]&quot;
+	
+OpenParenthesis = &quot;(&quot;
+CloseParenthesis = &quot;)&quot;
+	
+GreaterThan = &quot;&gt;&quot;
+LessThan = &quot;&lt;&quot;
+	
+NotEqual = &quot;&lt;&gt;&quot;
+GreaterEqual = &quot;&gt;=&quot;
+LessEqual = &quot;&lt;=&quot;
+	
+ShiftLeft = &quot;&lt;&lt;&quot;
+ShiftRight = &quot;&gt;&gt;&quot;
+	
+PlusAssign = &quot;+=&quot;
+PowerAssign = &quot;^=&quot;
+MinusAssign = &quot;-=&quot;
+TimesAssign = &quot;*=&quot;
+DivAssign = &quot;/=&quot;
+DivIntegerAssign = &quot;\\=&quot;
+ShiftLeftAssign = &quot;&lt;&lt;=&quot;
+ShiftRightAssign = &quot;&gt;&gt;=&quot;
+ConcatStringAssign = &quot;&amp;=&quot;
+
+# keywords according to the spec:
+# Keywordlist
+&quot;AddHandler&quot;
+&quot;AddressOf&quot;
+&quot;Alias&quot;
+&quot;And&quot;
+&quot;AndAlso&quot;
+&quot;Ansi&quot;
+&quot;As&quot;
+&quot;Assembly&quot;
+&quot;Auto&quot;
+&quot;Binary&quot;
+&quot;Boolean&quot;
+&quot;ByRef&quot;
+&quot;Byte&quot;
+&quot;ByVal&quot;
+&quot;Call&quot;
+&quot;Case&quot;
+&quot;Catch&quot;
+&quot;CBool&quot;
+&quot;CByte&quot;
+&quot;CChar&quot;
+&quot;CDate&quot;
+&quot;CDbl&quot;
+&quot;CDec&quot;
+&quot;Char&quot;
+&quot;CInt&quot;
+&quot;Class&quot;
+&quot;CLng&quot;
+&quot;CObj&quot;
+&quot;Compare&quot;
+&quot;Const&quot;
+&quot;CShort&quot;
+&quot;CSng&quot;
+&quot;CStr&quot;
+&quot;CType&quot;
+&quot;Date&quot;
+&quot;Decimal&quot;
+&quot;Declare&quot;
+&quot;Default&quot;
+&quot;Delegate&quot;
+&quot;Dim&quot;
+&quot;DirectCast&quot;
+&quot;Do&quot;
+&quot;Double&quot;
+&quot;Each&quot;
+&quot;Else&quot;
+&quot;ElseIf&quot;
+&quot;End&quot;
+&quot;EndIf&quot;
+&quot;Enum&quot;
+&quot;Erase&quot;
+&quot;Error&quot;
+&quot;Event&quot;
+&quot;Exit&quot;
+&quot;Explicit&quot;
+&quot;False&quot;
+&quot;Finally&quot;
+&quot;For&quot;
+&quot;Friend&quot;
+&quot;Function&quot;
+&quot;Get&quot;
+&quot;GetType&quot;
+&quot;GoSub&quot;
+&quot;GoTo&quot;
+&quot;Handles&quot;
+&quot;If&quot;
+&quot;Implements&quot;
+&quot;Imports&quot;
+&quot;In&quot;
+&quot;Inherits&quot;
+&quot;Integer&quot;
+&quot;Interface&quot;
+&quot;Is&quot;
+&quot;Let&quot;
+&quot;Lib&quot;
+&quot;Like&quot;
+&quot;Long&quot;
+&quot;Loop&quot;
+&quot;Me&quot;
+&quot;Mod&quot;
+&quot;Module&quot;
+&quot;MustInherit&quot;
+&quot;MustOverride&quot;
+&quot;MyBase&quot;
+&quot;MyClass&quot;
+&quot;Namespace&quot;
+&quot;New&quot;
+&quot;Next&quot;
+&quot;Not&quot;
+&quot;Nothing&quot;
+&quot;NotInheritable&quot;
+&quot;NotOverridable&quot;
+&quot;Object&quot;
+&quot;Off&quot;
+&quot;On&quot;
+&quot;Option&quot;
+&quot;Optional&quot;
+&quot;Or&quot;
+&quot;OrElse&quot;
+&quot;Overloads&quot;
+&quot;Overridable&quot;
+&quot;Override&quot;
+&quot;Overrides&quot;
+&quot;ParamArray&quot;
+&quot;Preserve&quot;
+&quot;Private&quot;
+&quot;Property&quot;
+&quot;Protected&quot;
+&quot;Public&quot;
+&quot;RaiseEvent&quot;
+&quot;ReadOnly&quot;
+&quot;ReDim&quot;
+&quot;RemoveHandler&quot;
+&quot;Resume&quot;
+&quot;Return&quot;
+&quot;Select&quot;
+&quot;Set&quot;
+&quot;Shadows&quot;
+&quot;Shared&quot;
+&quot;Short&quot;
+&quot;Single&quot;
+&quot;Static&quot;
+&quot;Step&quot;
+&quot;Stop&quot;
+&quot;Strict&quot;
+&quot;String&quot;
+&quot;Structure&quot;
+&quot;Sub&quot;
+&quot;SyncLock&quot;
+&quot;Text&quot;
+&quot;Then&quot;
+&quot;Throw&quot;
+&quot;To&quot;
+&quot;True&quot;
+&quot;Try&quot;
+&quot;TypeOf&quot;
+&quot;Unicode&quot;
+&quot;Until&quot;
+&quot;Variant&quot;
+&quot;Wend&quot;
+&quot;When&quot;
+&quot;While&quot;
+&quot;With&quot;
+&quot;WithEvents&quot;
+&quot;WriteOnly&quot;
+&quot;Xor&quot;


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/KeywordList.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,177 +1,177 @@
-// this file was autogenerated by a tool.
-using System;
-using System.Collections;
-using System.Text;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public class Keywords
-	{
-		static readonly string[] keywordList = {
-			&quot;ADDHANDLER&quot;,
-			&quot;ADDRESSOF&quot;,
-			&quot;ALIAS&quot;,
-			&quot;AND&quot;,
-			&quot;ANDALSO&quot;,
-			&quot;ANSI&quot;,
-			&quot;AS&quot;,
-			&quot;ASSEMBLY&quot;,
-			&quot;AUTO&quot;,
-			&quot;BINARY&quot;,
-			&quot;BOOLEAN&quot;,
-			&quot;BYREF&quot;,
-			&quot;BYTE&quot;,
-			&quot;BYVAL&quot;,
-			&quot;CALL&quot;,
-			&quot;CASE&quot;,
-			&quot;CATCH&quot;,
-			&quot;CBOOL&quot;,
-			&quot;CBYTE&quot;,
-			&quot;CCHAR&quot;,
-			&quot;CDATE&quot;,
-			&quot;CDBL&quot;,
-			&quot;CDEC&quot;,
-			&quot;CHAR&quot;,
-			&quot;CINT&quot;,
-			&quot;CLASS&quot;,
-			&quot;CLNG&quot;,
-			&quot;COBJ&quot;,
-			&quot;COMPARE&quot;,
-			&quot;CONST&quot;,
-			&quot;CSHORT&quot;,
-			&quot;CSNG&quot;,
-			&quot;CSTR&quot;,
-			&quot;CTYPE&quot;,
-			&quot;DATE&quot;,
-			&quot;DECIMAL&quot;,
-			&quot;DECLARE&quot;,
-			&quot;DEFAULT&quot;,
-			&quot;DELEGATE&quot;,
-			&quot;DIM&quot;,
-			&quot;DIRECTCAST&quot;,
-			&quot;DO&quot;,
-			&quot;DOUBLE&quot;,
-			&quot;EACH&quot;,
-			&quot;ELSE&quot;,
-			&quot;ELSEIF&quot;,
-			&quot;END&quot;,
-			&quot;ENDIF&quot;,
-			&quot;ENUM&quot;,
-			&quot;ERASE&quot;,
-			&quot;ERROR&quot;,
-			&quot;EVENT&quot;,
-			&quot;EXIT&quot;,
-			&quot;EXPLICIT&quot;,
-			&quot;FALSE&quot;,
-			&quot;FINALLY&quot;,
-			&quot;FOR&quot;,
-			&quot;FRIEND&quot;,
-			&quot;FUNCTION&quot;,
-			&quot;GET&quot;,
-			&quot;GETTYPE&quot;,
-			&quot;GOSUB&quot;,
-			&quot;GOTO&quot;,
-			&quot;HANDLES&quot;,
-			&quot;IF&quot;,
-			&quot;IMPLEMENTS&quot;,
-			&quot;IMPORTS&quot;,
-			&quot;IN&quot;,
-			&quot;INHERITS&quot;,
-			&quot;INTEGER&quot;,
-			&quot;INTERFACE&quot;,
-			&quot;IS&quot;,
-			&quot;LET&quot;,
-			&quot;LIB&quot;,
-			&quot;LIKE&quot;,
-			&quot;LONG&quot;,
-			&quot;LOOP&quot;,
-			&quot;ME&quot;,
-			&quot;MOD&quot;,
-			&quot;MODULE&quot;,
-			&quot;MUSTINHERIT&quot;,
-			&quot;MUSTOVERRIDE&quot;,
-			&quot;MYBASE&quot;,
-			&quot;MYCLASS&quot;,
-			&quot;NAMESPACE&quot;,
-			&quot;NEW&quot;,
-			&quot;NEXT&quot;,
-			&quot;NOT&quot;,
-			&quot;NOTHING&quot;,
-			&quot;NOTINHERITABLE&quot;,
-			&quot;NOTOVERRIDABLE&quot;,
-			&quot;OBJECT&quot;,
-			&quot;OFF&quot;,
-			&quot;ON&quot;,
-			&quot;OPTION&quot;,
-			&quot;OPTIONAL&quot;,
-			&quot;OR&quot;,
-			&quot;ORELSE&quot;,
-			&quot;OVERLOADS&quot;,
-			&quot;OVERRIDABLE&quot;,
-			&quot;OVERRIDE&quot;,
-			&quot;OVERRIDES&quot;,
-			&quot;PARAMARRAY&quot;,
-			&quot;PRESERVE&quot;,
-			&quot;PRIVATE&quot;,
-			&quot;PROPERTY&quot;,
-			&quot;PROTECTED&quot;,
-			&quot;PUBLIC&quot;,
-			&quot;RAISEEVENT&quot;,
-			&quot;READONLY&quot;,
-			&quot;REDIM&quot;,
-			&quot;REMOVEHANDLER&quot;,
-			&quot;RESUME&quot;,
-			&quot;RETURN&quot;,
-			&quot;SELECT&quot;,
-			&quot;SET&quot;,
-			&quot;SHADOWS&quot;,
-			&quot;SHARED&quot;,
-			&quot;SHORT&quot;,
-			&quot;SINGLE&quot;,
-			&quot;STATIC&quot;,
-			&quot;STEP&quot;,
-			&quot;STOP&quot;,
-			&quot;STRICT&quot;,
-			&quot;STRING&quot;,
-			&quot;STRUCTURE&quot;,
-			&quot;SUB&quot;,
-			&quot;SYNCLOCK&quot;,
-			&quot;TEXT&quot;,
-			&quot;THEN&quot;,
-			&quot;THROW&quot;,
-			&quot;TO&quot;,
-			&quot;TRUE&quot;,
-			&quot;TRY&quot;,
-			&quot;TYPEOF&quot;,
-			&quot;UNICODE&quot;,
-			&quot;UNTIL&quot;,
-			&quot;VARIANT&quot;,
-			&quot;WEND&quot;,
-			&quot;WHEN&quot;,
-			&quot;WHILE&quot;,
-			&quot;WITH&quot;,
-			&quot;WITHEVENTS&quot;,
-			&quot;WRITEONLY&quot;,
-			&quot;XOR&quot;
-		};
-		
-		static Hashtable keywords = new Hashtable();
-		
-		static Keywords()
-		{
-			for (int i = 0; i &lt; keywordList.Length; ++i) {
-				keywords.Add(keywordList[i], i + Tokens.AddHandler);
-			}
-		}
-		
-		public static bool IsKeyword(string identifier)
-		{
-			return keywords[identifier.ToUpper()] != null;
-		}
-		
-		public static int GetToken(string keyword)
-		{
-			return (int)keywords[keyword.ToUpper()];
-		}
-	}
-}
+// this file was autogenerated by a tool.
+using System;
+using System.Collections;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public class Keywords
+	{
+		static readonly string[] keywordList = {
+			&quot;ADDHANDLER&quot;,
+			&quot;ADDRESSOF&quot;,
+			&quot;ALIAS&quot;,
+			&quot;AND&quot;,
+			&quot;ANDALSO&quot;,
+			&quot;ANSI&quot;,
+			&quot;AS&quot;,
+			&quot;ASSEMBLY&quot;,
+			&quot;AUTO&quot;,
+			&quot;BINARY&quot;,
+			&quot;BOOLEAN&quot;,
+			&quot;BYREF&quot;,
+			&quot;BYTE&quot;,
+			&quot;BYVAL&quot;,
+			&quot;CALL&quot;,
+			&quot;CASE&quot;,
+			&quot;CATCH&quot;,
+			&quot;CBOOL&quot;,
+			&quot;CBYTE&quot;,
+			&quot;CCHAR&quot;,
+			&quot;CDATE&quot;,
+			&quot;CDBL&quot;,
+			&quot;CDEC&quot;,
+			&quot;CHAR&quot;,
+			&quot;CINT&quot;,
+			&quot;CLASS&quot;,
+			&quot;CLNG&quot;,
+			&quot;COBJ&quot;,
+			&quot;COMPARE&quot;,
+			&quot;CONST&quot;,
+			&quot;CSHORT&quot;,
+			&quot;CSNG&quot;,
+			&quot;CSTR&quot;,
+			&quot;CTYPE&quot;,
+			&quot;DATE&quot;,
+			&quot;DECIMAL&quot;,
+			&quot;DECLARE&quot;,
+			&quot;DEFAULT&quot;,
+			&quot;DELEGATE&quot;,
+			&quot;DIM&quot;,
+			&quot;DIRECTCAST&quot;,
+			&quot;DO&quot;,
+			&quot;DOUBLE&quot;,
+			&quot;EACH&quot;,
+			&quot;ELSE&quot;,
+			&quot;ELSEIF&quot;,
+			&quot;END&quot;,
+			&quot;ENDIF&quot;,
+			&quot;ENUM&quot;,
+			&quot;ERASE&quot;,
+			&quot;ERROR&quot;,
+			&quot;EVENT&quot;,
+			&quot;EXIT&quot;,
+			&quot;EXPLICIT&quot;,
+			&quot;FALSE&quot;,
+			&quot;FINALLY&quot;,
+			&quot;FOR&quot;,
+			&quot;FRIEND&quot;,
+			&quot;FUNCTION&quot;,
+			&quot;GET&quot;,
+			&quot;GETTYPE&quot;,
+			&quot;GOSUB&quot;,
+			&quot;GOTO&quot;,
+			&quot;HANDLES&quot;,
+			&quot;IF&quot;,
+			&quot;IMPLEMENTS&quot;,
+			&quot;IMPORTS&quot;,
+			&quot;IN&quot;,
+			&quot;INHERITS&quot;,
+			&quot;INTEGER&quot;,
+			&quot;INTERFACE&quot;,
+			&quot;IS&quot;,
+			&quot;LET&quot;,
+			&quot;LIB&quot;,
+			&quot;LIKE&quot;,
+			&quot;LONG&quot;,
+			&quot;LOOP&quot;,
+			&quot;ME&quot;,
+			&quot;MOD&quot;,
+			&quot;MODULE&quot;,
+			&quot;MUSTINHERIT&quot;,
+			&quot;MUSTOVERRIDE&quot;,
+			&quot;MYBASE&quot;,
+			&quot;MYCLASS&quot;,
+			&quot;NAMESPACE&quot;,
+			&quot;NEW&quot;,
+			&quot;NEXT&quot;,
+			&quot;NOT&quot;,
+			&quot;NOTHING&quot;,
+			&quot;NOTINHERITABLE&quot;,
+			&quot;NOTOVERRIDABLE&quot;,
+			&quot;OBJECT&quot;,
+			&quot;OFF&quot;,
+			&quot;ON&quot;,
+			&quot;OPTION&quot;,
+			&quot;OPTIONAL&quot;,
+			&quot;OR&quot;,
+			&quot;ORELSE&quot;,
+			&quot;OVERLOADS&quot;,
+			&quot;OVERRIDABLE&quot;,
+			&quot;OVERRIDE&quot;,
+			&quot;OVERRIDES&quot;,
+			&quot;PARAMARRAY&quot;,
+			&quot;PRESERVE&quot;,
+			&quot;PRIVATE&quot;,
+			&quot;PROPERTY&quot;,
+			&quot;PROTECTED&quot;,
+			&quot;PUBLIC&quot;,
+			&quot;RAISEEVENT&quot;,
+			&quot;READONLY&quot;,
+			&quot;REDIM&quot;,
+			&quot;REMOVEHANDLER&quot;,
+			&quot;RESUME&quot;,
+			&quot;RETURN&quot;,
+			&quot;SELECT&quot;,
+			&quot;SET&quot;,
+			&quot;SHADOWS&quot;,
+			&quot;SHARED&quot;,
+			&quot;SHORT&quot;,
+			&quot;SINGLE&quot;,
+			&quot;STATIC&quot;,
+			&quot;STEP&quot;,
+			&quot;STOP&quot;,
+			&quot;STRICT&quot;,
+			&quot;STRING&quot;,
+			&quot;STRUCTURE&quot;,
+			&quot;SUB&quot;,
+			&quot;SYNCLOCK&quot;,
+			&quot;TEXT&quot;,
+			&quot;THEN&quot;,
+			&quot;THROW&quot;,
+			&quot;TO&quot;,
+			&quot;TRUE&quot;,
+			&quot;TRY&quot;,
+			&quot;TYPEOF&quot;,
+			&quot;UNICODE&quot;,
+			&quot;UNTIL&quot;,
+			&quot;VARIANT&quot;,
+			&quot;WEND&quot;,
+			&quot;WHEN&quot;,
+			&quot;WHILE&quot;,
+			&quot;WITH&quot;,
+			&quot;WITHEVENTS&quot;,
+			&quot;WRITEONLY&quot;,
+			&quot;XOR&quot;
+		};
+		
+		static Hashtable keywords = new Hashtable();
+		
+		static Keywords()
+		{
+			for (int i = 0; i &lt; keywordList.Length; ++i) {
+				keywords.Add(keywordList[i], i + Tokens.AddHandler);
+			}
+		}
+		
+		public static bool IsKeyword(string identifier)
+		{
+			return keywords[identifier.ToUpper()] != null;
+		}
+		
+		public static int GetToken(string keyword)
+		{
+			return (int)keywords[keyword.ToUpper()];
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Keywords.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,565 +1,565 @@
-// this file was autogenerated by a tool.
-using System;
-
-namespace ICSharpCode.SharpRefactory.Parser.VB
-{
-	public sealed class Tokens
-	{
-		// ----- terminal classes -----
-		public const int EOF                  = 0;
-		public const int EOL                  = 1;
-		public const int Identifier           = 2;
-		public const int LiteralString        = 3;
-		public const int LiteralCharacter     = 4;
-		public const int LiteralInteger       = 5;
-		public const int LiteralDouble        = 6;
-		public const int LiteralSingle        = 7;
-		public const int LiteralDecimal       = 8;
-		public const int LiteralDate          = 9;
-
-		// ----- special character -----
-		public const int Dot                  = 10;
-		public const int Assign               = 11;
-		public const int Comma                = 12;
-		public const int Colon                = 13;
-		public const int Plus                 = 14;
-		public const int Minus                = 15;
-		public const int Times                = 16;
-		public const int Div                  = 17;
-		public const int DivInteger           = 18;
-		public const int ConcatString         = 19;
-		public const int Power                = 20;
-		public const int OpenCurlyBrace       = 21;
-		public const int CloseCurlyBrace      = 22;
-		public const int OpenSquareBracket    = 23;
-		public const int CloseSquareBracket   = 24;
-		public const int OpenParenthesis      = 25;
-		public const int CloseParenthesis     = 26;
-		public const int GreaterThan          = 27;
-		public const int LessThan             = 28;
-		public const int NotEqual             = 29;
-		public const int GreaterEqual         = 30;
-		public const int LessEqual            = 31;
-		public const int ShiftLeft            = 32;
-		public const int ShiftRight           = 33;
-		public const int PlusAssign           = 34;
-		public const int PowerAssign          = 35;
-		public const int MinusAssign          = 36;
-		public const int TimesAssign          = 37;
-		public const int DivAssign            = 38;
-		public const int DivIntegerAssign     = 39;
-		public const int ShiftLeftAssign      = 40;
-		public const int ShiftRightAssign     = 41;
-		public const int ConcatStringAssign   = 42;
-
-		// ----- keywords -----
-		public const int AddHandler           = 43;
-		public const int AddressOf            = 44;
-		public const int Alias                = 45;
-		public const int And                  = 46;
-		public const int AndAlso              = 47;
-		public const int Ansi                 = 48;
-		public const int As                   = 49;
-		public const int Assembly             = 50;
-		public const int Auto                 = 51;
-		public const int Binary               = 52;
-		public const int Boolean              = 53;
-		public const int ByRef                = 54;
-		public const int Byte                 = 55;
-		public const int ByVal                = 56;
-		public const int Call                 = 57;
-		public const int Case                 = 58;
-		public const int Catch                = 59;
-		public const int CBool                = 60;
-		public const int CByte                = 61;
-		public const int CChar                = 62;
-		public const int CDate                = 63;
-		public const int CDbl                 = 64;
-		public const int CDec                 = 65;
-		public const int Char                 = 66;
-		public const int CInt                 = 67;
-		public const int Class                = 68;
-		public const int CLng                 = 69;
-		public const int CObj                 = 70;
-		public const int Compare              = 71;
-		public const int Const                = 72;
-		public const int CShort               = 73;
-		public const int CSng                 = 74;
-		public const int CStr                 = 75;
-		public const int CType                = 76;
-		public const int Date                 = 77;
-		public const int Decimal              = 78;
-		public const int Declare              = 79;
-		public const int Default              = 80;
-		public const int Delegate             = 81;
-		public const int Dim                  = 82;
-		public const int DirectCast           = 83;
-		public const int Do                   = 84;
-		public const int Double               = 85;
-		public const int Each                 = 86;
-		public const int Else                 = 87;
-		public const int ElseIf               = 88;
-		public const int End                  = 89;
-		public const int EndIf                = 90;
-		public const int Enum                 = 91;
-		public const int Erase                = 92;
-		public const int Error                = 93;
-		public const int Event                = 94;
-		public const int Exit                 = 95;
-		public const int Explicit             = 96;
-		public const int False                = 97;
-		public const int Finally              = 98;
-		public const int For                  = 99;
-		public const int Friend               = 100;
-		public const int Function             = 101;
-		public const int Get                  = 102;
-		new public const int GetType              = 103;
-		public const int GoSub                = 104;
-		public const int GoTo                 = 105;
-		public const int Handles              = 106;
-		public const int If                   = 107;
-		public const int Implements           = 108;
-		public const int Imports              = 109;
-		public const int In                   = 110;
-		public const int Inherits             = 111;
-		public const int Integer              = 112;
-		public const int Interface            = 113;
-		public const int Is                   = 114;
-		public const int Let                  = 115;
-		public const int Lib                  = 116;
-		public const int Like                 = 117;
-		public const int Long                 = 118;
-		public const int Loop                 = 119;
-		public const int Me                   = 120;
-		public const int Mod                  = 121;
-		public const int Module               = 122;
-		public const int MustInherit          = 123;
-		public const int MustOverride         = 124;
-		public const int MyBase               = 125;
-		public const int MyClass              = 126;
-		public const int Namespace            = 127;
-		public const int New                  = 128;
-		public const int Next                 = 129;
-		public const int Not                  = 130;
-		public const int Nothing              = 131;
-		public const int NotInheritable       = 132;
-		public const int NotOverridable       = 133;
-		public const int Object               = 134;
-		public const int Off                  = 135;
-		public const int On                   = 136;
-		public const int Option               = 137;
-		public const int Optional             = 138;
-		public const int Or                   = 139;
-		public const int OrElse               = 140;
-		public const int Overloads            = 141;
-		public const int Overridable          = 142;
-		public const int Override             = 143;
-		public const int Overrides            = 144;
-		public const int ParamArray           = 145;
-		public const int Preserve             = 146;
-		public const int Private              = 147;
-		public const int Property             = 148;
-		public const int Protected            = 149;
-		public const int Public               = 150;
-		public const int RaiseEvent           = 151;
-		public const int ReadOnly             = 152;
-		public const int ReDim                = 153;
-		public const int RemoveHandler        = 154;
-		public const int Resume               = 155;
-		public const int Return               = 156;
-		public const int Select               = 157;
-		public const int Set                  = 158;
-		public const int Shadows              = 159;
-		public const int Shared               = 160;
-		public const int Short                = 161;
-		public const int Single               = 162;
-		public const int Static               = 163;
-		public const int Step                 = 164;
-		public const int Stop                 = 165;
-		public const int Strict               = 166;
-		public const int String               = 167;
-		public const int Structure            = 168;
-		public const int Sub                  = 169;
-		public const int SyncLock             = 170;
-		public const int Text                 = 171;
-		public const int Then                 = 172;
-		public const int Throw                = 173;
-		public const int To                   = 174;
-		public const int True                 = 175;
-		public const int Try                  = 176;
-		public const int TypeOf               = 177;
-		public const int Unicode              = 178;
-		public const int Until                = 179;
-		public const int Variant              = 180;
-		public const int Wend                 = 181;
-		public const int When                 = 182;
-		public const int While                = 183;
-		public const int With                 = 184;
-		public const int WithEvents           = 185;
-		public const int WriteOnly            = 186;
-		public const int Xor                  = 187;
-
-		string GetTokenString(int token)
-		{
-			switch (token) {
-				case Dot:
-					return &quot;.&quot;;
-				case Assign:
-					return &quot;=&quot;;
-				case Comma:
-					return &quot;,&quot;;
-				case Colon:
-					return &quot;:&quot;;
-				case Plus:
-					return &quot;+&quot;;
-				case Minus:
-					return &quot;-&quot;;
-				case Times:
-					return &quot;*&quot;;
-				case Div:
-					return &quot;/&quot;;
-				case DivInteger:
-					return &quot;\\&quot;;
-				case ConcatString:
-					return &quot;&amp;&quot;;
-				case Power:
-					return &quot;^&quot;;
-				case OpenCurlyBrace:
-					return &quot;{&quot;;
-				case CloseCurlyBrace:
-					return &quot;}&quot;;
-				case OpenSquareBracket:
-					return &quot;[&quot;;
-				case CloseSquareBracket:
-					return &quot;]&quot;;
-				case OpenParenthesis:
-					return &quot;(&quot;;
-				case CloseParenthesis:
-					return &quot;)&quot;;
-				case GreaterThan:
-					return &quot;&gt;&quot;;
-				case LessThan:
-					return &quot;&lt;&quot;;
-				case NotEqual:
-					return &quot;&lt;&gt;&quot;;
-				case GreaterEqual:
-					return &quot;&gt;=&quot;;
-				case LessEqual:
-					return &quot;&lt;=&quot;;
-				case ShiftLeft:
-					return &quot;&lt;&lt;&quot;;
-				case ShiftRight:
-					return &quot;&gt;&gt;&quot;;
-				case PlusAssign:
-					return &quot;+=&quot;;
-				case PowerAssign:
-					return &quot;^=&quot;;
-				case MinusAssign:
-					return &quot;-=&quot;;
-				case TimesAssign:
-					return &quot;*=&quot;;
-				case DivAssign:
-					return &quot;/=&quot;;
-				case DivIntegerAssign:
-					return &quot;\\=&quot;;
-				case ShiftLeftAssign:
-					return &quot;&lt;&lt;=&quot;;
-				case ShiftRightAssign:
-					return &quot;&gt;&gt;=&quot;;
-				case ConcatStringAssign:
-					return &quot;&amp;=&quot;;
-				case AddHandler:
-					return &quot;AddHandler&quot;;
-				case AddressOf:
-					return &quot;AddressOf&quot;;
-				case Alias:
-					return &quot;Alias&quot;;
-				case And:
-					return &quot;And&quot;;
-				case AndAlso:
-					return &quot;AndAlso&quot;;
-				case Ansi:
-					return &quot;Ansi&quot;;
-				case As:
-					return &quot;As&quot;;
-				case Assembly:
-					return &quot;Assembly&quot;;
-				case Auto:
-					return &quot;Auto&quot;;
-				case Binary:
-					return &quot;Binary&quot;;
-				case Boolean:
-					return &quot;Boolean&quot;;
-				case ByRef:
-					return &quot;ByRef&quot;;
-				case Byte:
-					return &quot;Byte&quot;;
-				case ByVal:
-					return &quot;ByVal&quot;;
-				case Call:
-					return &quot;Call&quot;;
-				case Case:
-					return &quot;Case&quot;;
-				case Catch:
-					return &quot;Catch&quot;;
-				case CBool:
-					return &quot;CBool&quot;;
-				case CByte:
-					return &quot;CByte&quot;;
-				case CChar:
-					return &quot;CChar&quot;;
-				case CDate:
-					return &quot;CDate&quot;;
-				case CDbl:
-					return &quot;CDbl&quot;;
-				case CDec:
-					return &quot;CDec&quot;;
-				case Char:
-					return &quot;Char&quot;;
-				case CInt:
-					return &quot;CInt&quot;;
-				case Class:
-					return &quot;Class&quot;;
-				case CLng:
-					return &quot;CLng&quot;;
-				case CObj:
-					return &quot;CObj&quot;;
-				case Compare:
-					return &quot;Compare&quot;;
-				case Const:
-					return &quot;Const&quot;;
-				case CShort:
-					return &quot;CShort&quot;;
-				case CSng:
-					return &quot;CSng&quot;;
-				case CStr:
-					return &quot;CStr&quot;;
-				case CType:
-					return &quot;CType&quot;;
-				case Date:
-					return &quot;Date&quot;;
-				case Decimal:
-					return &quot;Decimal&quot;;
-				case Declare:
-					return &quot;Declare&quot;;
-				case Default:
-					return &quot;Default&quot;;
-				case Delegate:
-					return &quot;Delegate&quot;;
-				case Dim:
-					return &quot;Dim&quot;;
-				case DirectCast:
-					return &quot;DirectCast&quot;;
-				case Do:
-					return &quot;Do&quot;;
-				case Double:
-					return &quot;Double&quot;;
-				case Each:
-					return &quot;Each&quot;;
-				case Else:
-					return &quot;Else&quot;;
-				case ElseIf:
-					return &quot;ElseIf&quot;;
-				case End:
-					return &quot;End&quot;;
-				case EndIf:
-					return &quot;EndIf&quot;;
-				case Enum:
-					return &quot;Enum&quot;;
-				case Erase:
-					return &quot;Erase&quot;;
-				case Error:
-					return &quot;Error&quot;;
-				case Event:
-					return &quot;Event&quot;;
-				case Exit:
-					return &quot;Exit&quot;;
-				case Explicit:
-					return &quot;Explicit&quot;;
-				case False:
-					return &quot;False&quot;;
-				case Finally:
-					return &quot;Finally&quot;;
-				case For:
-					return &quot;For&quot;;
-				case Friend:
-					return &quot;Friend&quot;;
-				case Function:
-					return &quot;Function&quot;;
-				case Get:
-					return &quot;Get&quot;;
-				case GetType:
-					return &quot;GetType&quot;;
-				case GoSub:
-					return &quot;GoSub&quot;;
-				case GoTo:
-					return &quot;GoTo&quot;;
-				case Handles:
-					return &quot;Handles&quot;;
-				case If:
-					return &quot;If&quot;;
-				case Implements:
-					return &quot;Implements&quot;;
-				case Imports:
-					return &quot;Imports&quot;;
-				case In:
-					return &quot;In&quot;;
-				case Inherits:
-					return &quot;Inherits&quot;;
-				case Integer:
-					return &quot;Integer&quot;;
-				case Interface:
-					return &quot;Interface&quot;;
-				case Is:
-					return &quot;Is&quot;;
-				case Let:
-					return &quot;Let&quot;;
-				case Lib:
-					return &quot;Lib&quot;;
-				case Like:
-					return &quot;Like&quot;;
-				case Long:
-					return &quot;Long&quot;;
-				case Loop:
-					return &quot;Loop&quot;;
-				case Me:
-					return &quot;Me&quot;;
-				case Mod:
-					return &quot;Mod&quot;;
-				case Module:
-					return &quot;Module&quot;;
-				case MustInherit:
-					return &quot;MustInherit&quot;;
-				case MustOverride:
-					return &quot;MustOverride&quot;;
-				case MyBase:
-					return &quot;MyBase&quot;;
-				case MyClass:
-					return &quot;MyClass&quot;;
-				case Namespace:
-					return &quot;Namespace&quot;;
-				case New:
-					return &quot;New&quot;;
-				case Next:
-					return &quot;Next&quot;;
-				case Not:
-					return &quot;Not&quot;;
-				case Nothing:
-					return &quot;Nothing&quot;;
-				case NotInheritable:
-					return &quot;NotInheritable&quot;;
-				case NotOverridable:
-					return &quot;NotOverridable&quot;;
-				case Object:
-					return &quot;Object&quot;;
-				case Off:
-					return &quot;Off&quot;;
-				case On:
-					return &quot;On&quot;;
-				case Option:
-					return &quot;Option&quot;;
-				case Optional:
-					return &quot;Optional&quot;;
-				case Or:
-					return &quot;Or&quot;;
-				case OrElse:
-					return &quot;OrElse&quot;;
-				case Overloads:
-					return &quot;Overloads&quot;;
-				case Overridable:
-					return &quot;Overridable&quot;;
-				case Override:
-					return &quot;Override&quot;;
-				case Overrides:
-					return &quot;Overrides&quot;;
-				case ParamArray:
-					return &quot;ParamArray&quot;;
-				case Preserve:
-					return &quot;Preserve&quot;;
-				case Private:
-					return &quot;Private&quot;;
-				case Property:
-					return &quot;Property&quot;;
-				case Protected:
-					return &quot;Protected&quot;;
-				case Public:
-					return &quot;Public&quot;;
-				case RaiseEvent:
-					return &quot;RaiseEvent&quot;;
-				case ReadOnly:
-					return &quot;ReadOnly&quot;;
-				case ReDim:
-					return &quot;ReDim&quot;;
-				case RemoveHandler:
-					return &quot;RemoveHandler&quot;;
-				case Resume:
-					return &quot;Resume&quot;;
-				case Return:
-					return &quot;Return&quot;;
-				case Select:
-					return &quot;Select&quot;;
-				case Set:
-					return &quot;Set&quot;;
-				case Shadows:
-					return &quot;Shadows&quot;;
-				case Shared:
-					return &quot;Shared&quot;;
-				case Short:
-					return &quot;Short&quot;;
-				case Single:
-					return &quot;Single&quot;;
-				case Static:
-					return &quot;Static&quot;;
-				case Step:
-					return &quot;Step&quot;;
-				case Stop:
-					return &quot;Stop&quot;;
-				case Strict:
-					return &quot;Strict&quot;;
-				case String:
-					return &quot;String&quot;;
-				case Structure:
-					return &quot;Structure&quot;;
-				case Sub:
-					return &quot;Sub&quot;;
-				case SyncLock:
-					return &quot;SyncLock&quot;;
-				case Text:
-					return &quot;Text&quot;;
-				case Then:
-					return &quot;Then&quot;;
-				case Throw:
-					return &quot;Throw&quot;;
-				case To:
-					return &quot;To&quot;;
-				case True:
-					return &quot;True&quot;;
-				case Try:
-					return &quot;Try&quot;;
-				case TypeOf:
-					return &quot;TypeOf&quot;;
-				case Unicode:
-					return &quot;Unicode&quot;;
-				case Until:
-					return &quot;Until&quot;;
-				case Variant:
-					return &quot;Variant&quot;;
-				case Wend:
-					return &quot;Wend&quot;;
-				case When:
-					return &quot;When&quot;;
-				case While:
-					return &quot;While&quot;;
-				case With:
-					return &quot;With&quot;;
-				case WithEvents:
-					return &quot;WithEvents&quot;;
-				case WriteOnly:
-					return &quot;WriteOnly&quot;;
-				case Xor:
-					return &quot;Xor&quot;;
-			}
-			throw new System.NotSupportedException(&quot;Unknown token:&quot; + token);
-		}
-	}
-}
+// this file was autogenerated by a tool.
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser.VB
+{
+	public sealed class Tokens
+	{
+		// ----- terminal classes -----
+		public const int EOF                  = 0;
+		public const int EOL                  = 1;
+		public const int Identifier           = 2;
+		public const int LiteralString        = 3;
+		public const int LiteralCharacter     = 4;
+		public const int LiteralInteger       = 5;
+		public const int LiteralDouble        = 6;
+		public const int LiteralSingle        = 7;
+		public const int LiteralDecimal       = 8;
+		public const int LiteralDate          = 9;
+
+		// ----- special character -----
+		public const int Dot                  = 10;
+		public const int Assign               = 11;
+		public const int Comma                = 12;
+		public const int Colon                = 13;
+		public const int Plus                 = 14;
+		public const int Minus                = 15;
+		public const int Times                = 16;
+		public const int Div                  = 17;
+		public const int DivInteger           = 18;
+		public const int ConcatString         = 19;
+		public const int Power                = 20;
+		public const int OpenCurlyBrace       = 21;
+		public const int CloseCurlyBrace      = 22;
+		public const int OpenSquareBracket    = 23;
+		public const int CloseSquareBracket   = 24;
+		public const int OpenParenthesis      = 25;
+		public const int CloseParenthesis     = 26;
+		public const int GreaterThan          = 27;
+		public const int LessThan             = 28;
+		public const int NotEqual             = 29;
+		public const int GreaterEqual         = 30;
+		public const int LessEqual            = 31;
+		public const int ShiftLeft            = 32;
+		public const int ShiftRight           = 33;
+		public const int PlusAssign           = 34;
+		public const int PowerAssign          = 35;
+		public const int MinusAssign          = 36;
+		public const int TimesAssign          = 37;
+		public const int DivAssign            = 38;
+		public const int DivIntegerAssign     = 39;
+		public const int ShiftLeftAssign      = 40;
+		public const int ShiftRightAssign     = 41;
+		public const int ConcatStringAssign   = 42;
+
+		// ----- keywords -----
+		public const int AddHandler           = 43;
+		public const int AddressOf            = 44;
+		public const int Alias                = 45;
+		public const int And                  = 46;
+		public const int AndAlso              = 47;
+		public const int Ansi                 = 48;
+		public const int As                   = 49;
+		public const int Assembly             = 50;
+		public const int Auto                 = 51;
+		public const int Binary               = 52;
+		public const int Boolean              = 53;
+		public const int ByRef                = 54;
+		public const int Byte                 = 55;
+		public const int ByVal                = 56;
+		public const int Call                 = 57;
+		public const int Case                 = 58;
+		public const int Catch                = 59;
+		public const int CBool                = 60;
+		public const int CByte                = 61;
+		public const int CChar                = 62;
+		public const int CDate                = 63;
+		public const int CDbl                 = 64;
+		public const int CDec                 = 65;
+		public const int Char                 = 66;
+		public const int CInt                 = 67;
+		public const int Class                = 68;
+		public const int CLng                 = 69;
+		public const int CObj                 = 70;
+		public const int Compare              = 71;
+		public const int Const                = 72;
+		public const int CShort               = 73;
+		public const int CSng                 = 74;
+		public const int CStr                 = 75;
+		public const int CType                = 76;
+		public const int Date                 = 77;
+		public const int Decimal              = 78;
+		public const int Declare              = 79;
+		public const int Default              = 80;
+		public const int Delegate             = 81;
+		public const int Dim                  = 82;
+		public const int DirectCast           = 83;
+		public const int Do                   = 84;
+		public const int Double               = 85;
+		public const int Each                 = 86;
+		public const int Else                 = 87;
+		public const int ElseIf               = 88;
+		public const int End                  = 89;
+		public const int EndIf                = 90;
+		public const int Enum                 = 91;
+		public const int Erase                = 92;
+		public const int Error                = 93;
+		public const int Event                = 94;
+		public const int Exit                 = 95;
+		public const int Explicit             = 96;
+		public const int False                = 97;
+		public const int Finally              = 98;
+		public const int For                  = 99;
+		public const int Friend               = 100;
+		public const int Function             = 101;
+		public const int Get                  = 102;
+		new public const int GetType              = 103;
+		public const int GoSub                = 104;
+		public const int GoTo                 = 105;
+		public const int Handles              = 106;
+		public const int If                   = 107;
+		public const int Implements           = 108;
+		public const int Imports              = 109;
+		public const int In                   = 110;
+		public const int Inherits             = 111;
+		public const int Integer              = 112;
+		public const int Interface            = 113;
+		public const int Is                   = 114;
+		public const int Let                  = 115;
+		public const int Lib                  = 116;
+		public const int Like                 = 117;
+		public const int Long                 = 118;
+		public const int Loop                 = 119;
+		public const int Me                   = 120;
+		public const int Mod                  = 121;
+		public const int Module               = 122;
+		public const int MustInherit          = 123;
+		public const int MustOverride         = 124;
+		public const int MyBase               = 125;
+		public const int MyClass              = 126;
+		public const int Namespace            = 127;
+		public const int New                  = 128;
+		public const int Next                 = 129;
+		public const int Not                  = 130;
+		public const int Nothing              = 131;
+		public const int NotInheritable       = 132;
+		public const int NotOverridable       = 133;
+		public const int Object               = 134;
+		public const int Off                  = 135;
+		public const int On                   = 136;
+		public const int Option               = 137;
+		public const int Optional             = 138;
+		public const int Or                   = 139;
+		public const int OrElse               = 140;
+		public const int Overloads            = 141;
+		public const int Overridable          = 142;
+		public const int Override             = 143;
+		public const int Overrides            = 144;
+		public const int ParamArray           = 145;
+		public const int Preserve             = 146;
+		public const int Private              = 147;
+		public const int Property             = 148;
+		public const int Protected            = 149;
+		public const int Public               = 150;
+		public const int RaiseEvent           = 151;
+		public const int ReadOnly             = 152;
+		public const int ReDim                = 153;
+		public const int RemoveHandler        = 154;
+		public const int Resume               = 155;
+		public const int Return               = 156;
+		public const int Select               = 157;
+		public const int Set                  = 158;
+		public const int Shadows              = 159;
+		public const int Shared               = 160;
+		public const int Short                = 161;
+		public const int Single               = 162;
+		public const int Static               = 163;
+		public const int Step                 = 164;
+		public const int Stop                 = 165;
+		public const int Strict               = 166;
+		public const int String               = 167;
+		public const int Structure            = 168;
+		public const int Sub                  = 169;
+		public const int SyncLock             = 170;
+		public const int Text                 = 171;
+		public const int Then                 = 172;
+		public const int Throw                = 173;
+		public const int To                   = 174;
+		public const int True                 = 175;
+		public const int Try                  = 176;
+		public const int TypeOf               = 177;
+		public const int Unicode              = 178;
+		public const int Until                = 179;
+		public const int Variant              = 180;
+		public const int Wend                 = 181;
+		public const int When                 = 182;
+		public const int While                = 183;
+		public const int With                 = 184;
+		public const int WithEvents           = 185;
+		public const int WriteOnly            = 186;
+		public const int Xor                  = 187;
+
+		string GetTokenString(int token)
+		{
+			switch (token) {
+				case Dot:
+					return &quot;.&quot;;
+				case Assign:
+					return &quot;=&quot;;
+				case Comma:
+					return &quot;,&quot;;
+				case Colon:
+					return &quot;:&quot;;
+				case Plus:
+					return &quot;+&quot;;
+				case Minus:
+					return &quot;-&quot;;
+				case Times:
+					return &quot;*&quot;;
+				case Div:
+					return &quot;/&quot;;
+				case DivInteger:
+					return &quot;\\&quot;;
+				case ConcatString:
+					return &quot;&amp;&quot;;
+				case Power:
+					return &quot;^&quot;;
+				case OpenCurlyBrace:
+					return &quot;{&quot;;
+				case CloseCurlyBrace:
+					return &quot;}&quot;;
+				case OpenSquareBracket:
+					return &quot;[&quot;;
+				case CloseSquareBracket:
+					return &quot;]&quot;;
+				case OpenParenthesis:
+					return &quot;(&quot;;
+				case CloseParenthesis:
+					return &quot;)&quot;;
+				case GreaterThan:
+					return &quot;&gt;&quot;;
+				case LessThan:
+					return &quot;&lt;&quot;;
+				case NotEqual:
+					return &quot;&lt;&gt;&quot;;
+				case GreaterEqual:
+					return &quot;&gt;=&quot;;
+				case LessEqual:
+					return &quot;&lt;=&quot;;
+				case ShiftLeft:
+					return &quot;&lt;&lt;&quot;;
+				case ShiftRight:
+					return &quot;&gt;&gt;&quot;;
+				case PlusAssign:
+					return &quot;+=&quot;;
+				case PowerAssign:
+					return &quot;^=&quot;;
+				case MinusAssign:
+					return &quot;-=&quot;;
+				case TimesAssign:
+					return &quot;*=&quot;;
+				case DivAssign:
+					return &quot;/=&quot;;
+				case DivIntegerAssign:
+					return &quot;\\=&quot;;
+				case ShiftLeftAssign:
+					return &quot;&lt;&lt;=&quot;;
+				case ShiftRightAssign:
+					return &quot;&gt;&gt;=&quot;;
+				case ConcatStringAssign:
+					return &quot;&amp;=&quot;;
+				case AddHandler:
+					return &quot;AddHandler&quot;;
+				case AddressOf:
+					return &quot;AddressOf&quot;;
+				case Alias:
+					return &quot;Alias&quot;;
+				case And:
+					return &quot;And&quot;;
+				case AndAlso:
+					return &quot;AndAlso&quot;;
+				case Ansi:
+					return &quot;Ansi&quot;;
+				case As:
+					return &quot;As&quot;;
+				case Assembly:
+					return &quot;Assembly&quot;;
+				case Auto:
+					return &quot;Auto&quot;;
+				case Binary:
+					return &quot;Binary&quot;;
+				case Boolean:
+					return &quot;Boolean&quot;;
+				case ByRef:
+					return &quot;ByRef&quot;;
+				case Byte:
+					return &quot;Byte&quot;;
+				case ByVal:
+					return &quot;ByVal&quot;;
+				case Call:
+					return &quot;Call&quot;;
+				case Case:
+					return &quot;Case&quot;;
+				case Catch:
+					return &quot;Catch&quot;;
+				case CBool:
+					return &quot;CBool&quot;;
+				case CByte:
+					return &quot;CByte&quot;;
+				case CChar:
+					return &quot;CChar&quot;;
+				case CDate:
+					return &quot;CDate&quot;;
+				case CDbl:
+					return &quot;CDbl&quot;;
+				case CDec:
+					return &quot;CDec&quot;;
+				case Char:
+					return &quot;Char&quot;;
+				case CInt:
+					return &quot;CInt&quot;;
+				case Class:
+					return &quot;Class&quot;;
+				case CLng:
+					return &quot;CLng&quot;;
+				case CObj:
+					return &quot;CObj&quot;;
+				case Compare:
+					return &quot;Compare&quot;;
+				case Const:
+					return &quot;Const&quot;;
+				case CShort:
+					return &quot;CShort&quot;;
+				case CSng:
+					return &quot;CSng&quot;;
+				case CStr:
+					return &quot;CStr&quot;;
+				case CType:
+					return &quot;CType&quot;;
+				case Date:
+					return &quot;Date&quot;;
+				case Decimal:
+					return &quot;Decimal&quot;;
+				case Declare:
+					return &quot;Declare&quot;;
+				case Default:
+					return &quot;Default&quot;;
+				case Delegate:
+					return &quot;Delegate&quot;;
+				case Dim:
+					return &quot;Dim&quot;;
+				case DirectCast:
+					return &quot;DirectCast&quot;;
+				case Do:
+					return &quot;Do&quot;;
+				case Double:
+					return &quot;Double&quot;;
+				case Each:
+					return &quot;Each&quot;;
+				case Else:
+					return &quot;Else&quot;;
+				case ElseIf:
+					return &quot;ElseIf&quot;;
+				case End:
+					return &quot;End&quot;;
+				case EndIf:
+					return &quot;EndIf&quot;;
+				case Enum:
+					return &quot;Enum&quot;;
+				case Erase:
+					return &quot;Erase&quot;;
+				case Error:
+					return &quot;Error&quot;;
+				case Event:
+					return &quot;Event&quot;;
+				case Exit:
+					return &quot;Exit&quot;;
+				case Explicit:
+					return &quot;Explicit&quot;;
+				case False:
+					return &quot;False&quot;;
+				case Finally:
+					return &quot;Finally&quot;;
+				case For:
+					return &quot;For&quot;;
+				case Friend:
+					return &quot;Friend&quot;;
+				case Function:
+					return &quot;Function&quot;;
+				case Get:
+					return &quot;Get&quot;;
+				case GetType:
+					return &quot;GetType&quot;;
+				case GoSub:
+					return &quot;GoSub&quot;;
+				case GoTo:
+					return &quot;GoTo&quot;;
+				case Handles:
+					return &quot;Handles&quot;;
+				case If:
+					return &quot;If&quot;;
+				case Implements:
+					return &quot;Implements&quot;;
+				case Imports:
+					return &quot;Imports&quot;;
+				case In:
+					return &quot;In&quot;;
+				case Inherits:
+					return &quot;Inherits&quot;;
+				case Integer:
+					return &quot;Integer&quot;;
+				case Interface:
+					return &quot;Interface&quot;;
+				case Is:
+					return &quot;Is&quot;;
+				case Let:
+					return &quot;Let&quot;;
+				case Lib:
+					return &quot;Lib&quot;;
+				case Like:
+					return &quot;Like&quot;;
+				case Long:
+					return &quot;Long&quot;;
+				case Loop:
+					return &quot;Loop&quot;;
+				case Me:
+					return &quot;Me&quot;;
+				case Mod:
+					return &quot;Mod&quot;;
+				case Module:
+					return &quot;Module&quot;;
+				case MustInherit:
+					return &quot;MustInherit&quot;;
+				case MustOverride:
+					return &quot;MustOverride&quot;;
+				case MyBase:
+					return &quot;MyBase&quot;;
+				case MyClass:
+					return &quot;MyClass&quot;;
+				case Namespace:
+					return &quot;Namespace&quot;;
+				case New:
+					return &quot;New&quot;;
+				case Next:
+					return &quot;Next&quot;;
+				case Not:
+					return &quot;Not&quot;;
+				case Nothing:
+					return &quot;Nothing&quot;;
+				case NotInheritable:
+					return &quot;NotInheritable&quot;;
+				case NotOverridable:
+					return &quot;NotOverridable&quot;;
+				case Object:
+					return &quot;Object&quot;;
+				case Off:
+					return &quot;Off&quot;;
+				case On:
+					return &quot;On&quot;;
+				case Option:
+					return &quot;Option&quot;;
+				case Optional:
+					return &quot;Optional&quot;;
+				case Or:
+					return &quot;Or&quot;;
+				case OrElse:
+					return &quot;OrElse&quot;;
+				case Overloads:
+					return &quot;Overloads&quot;;
+				case Overridable:
+					return &quot;Overridable&quot;;
+				case Override:
+					return &quot;Override&quot;;
+				case Overrides:
+					return &quot;Overrides&quot;;
+				case ParamArray:
+					return &quot;ParamArray&quot;;
+				case Preserve:
+					return &quot;Preserve&quot;;
+				case Private:
+					return &quot;Private&quot;;
+				case Property:
+					return &quot;Property&quot;;
+				case Protected:
+					return &quot;Protected&quot;;
+				case Public:
+					return &quot;Public&quot;;
+				case RaiseEvent:
+					return &quot;RaiseEvent&quot;;
+				case ReadOnly:
+					return &quot;ReadOnly&quot;;
+				case ReDim:
+					return &quot;ReDim&quot;;
+				case RemoveHandler:
+					return &quot;RemoveHandler&quot;;
+				case Resume:
+					return &quot;Resume&quot;;
+				case Return:
+					return &quot;Return&quot;;
+				case Select:
+					return &quot;Select&quot;;
+				case Set:
+					return &quot;Set&quot;;
+				case Shadows:
+					return &quot;Shadows&quot;;
+				case Shared:
+					return &quot;Shared&quot;;
+				case Short:
+					return &quot;Short&quot;;
+				case Single:
+					return &quot;Single&quot;;
+				case Static:
+					return &quot;Static&quot;;
+				case Step:
+					return &quot;Step&quot;;
+				case Stop:
+					return &quot;Stop&quot;;
+				case Strict:
+					return &quot;Strict&quot;;
+				case String:
+					return &quot;String&quot;;
+				case Structure:
+					return &quot;Structure&quot;;
+				case Sub:
+					return &quot;Sub&quot;;
+				case SyncLock:
+					return &quot;SyncLock&quot;;
+				case Text:
+					return &quot;Text&quot;;
+				case Then:
+					return &quot;Then&quot;;
+				case Throw:
+					return &quot;Throw&quot;;
+				case To:
+					return &quot;To&quot;;
+				case True:
+					return &quot;True&quot;;
+				case Try:
+					return &quot;Try&quot;;
+				case TypeOf:
+					return &quot;TypeOf&quot;;
+				case Unicode:
+					return &quot;Unicode&quot;;
+				case Until:
+					return &quot;Until&quot;;
+				case Variant:
+					return &quot;Variant&quot;;
+				case Wend:
+					return &quot;Wend&quot;;
+				case When:
+					return &quot;When&quot;;
+				case While:
+					return &quot;While&quot;;
+				case With:
+					return &quot;With&quot;;
+				case WithEvents:
+					return &quot;WithEvents&quot;;
+				case WriteOnly:
+					return &quot;WriteOnly&quot;;
+				case Xor:
+					return &quot;Xor&quot;;
+			}
+			throw new System.NotSupportedException(&quot;Unknown token:&quot; + token);
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/keywordlist/Tokens.cs
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VB.glade
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs	2005-05-11 02:36:30 UTC (rev 2527)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs	2005-05-13 23:13:05 UTC (rev 2528)
@@ -1,103 +1,103 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-using System.Collections;
-using System.Collections.Specialized;
-using System.Windows.Forms;
-using System.Reflection;
-
-using ICSharpCode.Core.Properties;
-using ICSharpCode.Core.Services;
-
-using ICSharpCode.Core.AddIns;
-using ICSharpCode.Core.AddIns.Codons;
-
-using ICSharpCode.SharpDevelop.Internal.Project;
-using ICSharpCode.SharpDevelop.Services;
-
-namespace VBBinding
-{
-	////&lt;summary&gt;
-	/// Provides functions to run VB.DOC and to read the configuration of VB.DOC.
-	/// &lt;/summary&gt;
-	public class VBDOCCommand : AbstractMenuCommand
-	{
-		///&lt;summary&gt;
-		/// Runs VB.DOC for the given project
-		/// &lt;/summary&gt;
-		public override void Run()
-		{
-			IProjectService projectService = (IProjectService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
-			VBProject project = (VBProject)projectService.CurrentSelectedProject;
-			VBCompilerParameters compilerParameters = (VBCompilerParameters)project.ActiveConfiguration;
-			
-			Options options = new Options();
-			string extension = compilerParameters.CompileTarget == CompileTarget.Exe ? &quot;.dll&quot; : &quot;.exe&quot;;
-			options.AssemblyFile = Path.Combine(compilerParameters.OutputDirectory, compilerParameters.OutputAssembly) + extension;
-			
-			ArrayList files = new ArrayList();
-			foreach(ProjectFile file in project.ProjectFiles) {
-				if(VBDOCConfigurationPanel.IsFileIncluded(file.Name, project)) {
-					files.Add(file.Name);
-				}
-			}
-			
-			options.Files = (string[])files.ToArray(typeof(string));
-			options.GlobalImports = compilerParameters.Imports.Split(',');
-			options.OutputXML = compilerParameters.VBDOCOutputFile;
-			options.Prefix = compilerParameters.VBDOCCommentPrefix;
-			options.RootNamespace = compilerParameters.RootNamespace;
-			
-			ArrayList referenceDirs = new ArrayList();
-			string mainDirectory = Path.GetDirectoryName(options.AssemblyFile);
-			
-			foreach(ProjectReference projectFile in project.ProjectReferences) {
-				if(projectFile.ReferenceType == ReferenceType.Assembly) {
-					string referenceDir = Path.GetDirectoryName(projectFile.Reference);
-					if(referenceDir.ToLower() != mainDirectory.ToLower() &amp;&amp; referenceDirs.Contains(referenceDir) == false) {
-						referenceDirs.Add(referenceDir);
-					}
-				}
-			}
-			
-			StringCollection errors = options.Validate();
-		
-			if(errors.Count &gt; 0) {
-				string message = &quot;&quot;;
-				foreach(string description in errors) {
-					message += description + &quot;\n&quot;;
-				}
-				MessageBox.Show(message, &quot;Invalid VB.DOC options&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
-				return;
-			}
-			
-			VBDOCRunner runner = new VBDOCRunner();
-			AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(resolve);
-			GuiMessageRecipient messageRecipient = new GuiMessageRecipient();
-			
-			try {
-				runner.RunVBDOC(options, messageRecipient);
-			} catch(Exception ex) {
-				MessageBox.Show(&quot;Documentation generation failed:\n&quot; + ex.Message);
-			} finally {
-				messageRecipient.Finished();
-				AppDomain.CurrentDomain.AssemblyResolve -= new ResolveEventHandler(resolve);
-			}
-			
-		}
-		
-		Assembly resolve(object sender, ResolveEventArgs e)
-		{
-			if(e.Name.StartsWith(&quot;CommentExtractor&quot;)) {
-				return Assembly.GetAssembly(typeof(VBDOCRunner));
-			}
-			return null;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Windows.Forms;
+using System.Reflection;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.Core.Services;
+
+using ICSharpCode.Core.AddIns;
+using ICSharpCode.Core.AddIns.Codons;
+
+using ICSharpCode.SharpDevelop.Internal.Project;
+using ICSharpCode.SharpDevelop.Services;
+
+namespace VBBinding
+{
+	////&lt;summary&gt;
+	/// Provides functions to run VB.DOC and to read the configuration of VB.DOC.
+	/// &lt;/summary&gt;
+	public class VBDOCCommand : AbstractMenuCommand
+	{
+		///&lt;summary&gt;
+		/// Runs VB.DOC for the given project
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			IProjectService projectService = (IProjectService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			VBProject project = (VBProject)projectService.CurrentSelectedProject;
+			VBCompilerParameters compilerParameters = (VBCompilerParameters)project.ActiveConfiguration;
+			
+			Options options = new Options();
+			string extension = compilerParameters.CompileTarget == CompileTarget.Exe ? &quot;.dll&quot; : &quot;.exe&quot;;
+			options.AssemblyFile = Path.Combine(compilerParameters.OutputDirectory, compilerParameters.OutputAssembly) + extension;
+			
+			ArrayList files = new ArrayList();
+			foreach(ProjectFile file in project.ProjectFiles) {
+				if(VBDOCConfigurationPanel.IsFileIncluded(file.Name, project)) {
+					files.Add(file.Name);
+				}
+			}
+			
+			options.Files = (string[])files.ToArray(typeof(string));
+			options.GlobalImports = compilerParameters.Imports.Split(',');
+			options.OutputXML = compilerParameters.VBDOCOutputFile;
+			options.Prefix = compilerParameters.VBDOCCommentPrefix;
+			options.RootNamespace = compilerParameters.RootNamespace;
+			
+			ArrayList referenceDirs = new ArrayList();
+			string mainDirectory = Path.GetDirectoryName(options.AssemblyFile);
+			
+			foreach(ProjectReference projectFile in project.ProjectReferences) {
+				if(projectFile.ReferenceType == ReferenceType.Assembly) {
+					string referenceDir = Path.GetDirectoryName(projectFile.Reference);
+					if(referenceDir.ToLower() != mainDirectory.ToLower() &amp;&amp; referenceDirs.Contains(referenceDir) == false) {
+						referenceDirs.Add(referenceDir);
+					}
+				}
+			}
+			
+			StringCollection errors = options.Validate();
+		
+			if(errors.Count &gt; 0) {
+				string message = &quot;&quot;;
+				foreach(string description in errors) {
+					message += description + &quot;\n&quot;;
+				}
+				MessageBox.Show(message, &quot;Invalid VB.DOC options&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
+				return;
+			}
+			
+			VBDOCRunner runner = new VBDOCRunner();
+			AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(resolve);
+			GuiMessageRecipient messageRecipient = new GuiMessageRecipient();
+			
+			try {
+				runner.RunVBDOC(options, messageRecipient);
+			} catch(Exception ex) {
+				MessageBox.Show(&quot;Documentation generation failed:\n&quot; + ex.Message);
+			} finally {
+				messageRecipient.Finished();
+				AppDomain.CurrentDomain.AssemblyResolve -= new ResolveEventHandler(resolve);
+			}
+			
+		}
+		
+		Assembly resolve(object sender, ResolveEventArgs e)
+		{
+			if(e.Name.StartsWith(&quot;CommentExtractor&quot;)) {
+				return Assembly.GetAssembly(typeof(VBDOCRunner));
+			}
+			return null;
+		}
+	}
+}


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBDOCCommand.cs
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/VBNetBinding.addin.xml
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/EmptyVBFile.xft.xml
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/EmptyVBProject.xpt.xml
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/VBConsoleApplicationProject.xpt.xml
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/VBGtkSharp2Project.xpt.xml
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/templates/VBGtkSharpProject.xpt.xml
___________________________________________________________________
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002127.html">[Monodevelop-patches-list] r2527 - in trunk/MonoDevelop/Extras/BooBinding: . Gui
</A></li>
	<LI>Next message: <A HREF="002129.html">[Monodevelop-patches-list] r2529 - in trunk/MonoDevelop: .	Core/src/AddIns/BackendBindings/CSharpBinding	Core/src/AddIns/BackendBindings/ILAsmBinding	Core/src/AddIns/BackendBindings/NemerleBinding	Core/src/AddIns/BackendBindings/VBNetBinding	Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB	Core/src/AddIns/DebuggerAddIn	Core/src/AddIns/DisplayBindings/SourceEditor	Core/src/AddIns/prj2make-sharp-lib	Core/src/ICSharpCode.SharpAssembly	Core/src/ICSharpCode.SharpRefactory Core/src/MonoDevelop.Base	Core/src/MonoDevelop.Core Core/src/MonoDevelop.Dock	Core/src/MonoDevelop.Gui.Utils	Core/src/MonoDevelop.Gui.Widgets Core/src/MonoDevelop.Startup	Core/src/Tools/dbgen Core/src/Tools/mdhost Extras/BooBinding	Extras/JavaBinding Extras/MonoDeveloperExtensions	Extras/MonoQuery Unused/AddInManager build/data/resources/css	build/data/resources/icons contrib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2128">[ date ]</a>
              <a href="thread.html#2128">[ thread ]</a>
              <a href="subject.html#2128">[ subject ]</a>
              <a href="author.html#2128">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
