<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1997 - in trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser: . ICSharpCode.AssemblyAnalyzer/Engine ICSharpCode.AssemblyAnalyzer/Rules ICSharpCode.AssemblyAnalyzer/Rules/DesignRules ICSharpCode.AssemblyAnalyzer/Rules/NamingRules ICSharpCode.AssemblyAnalyzer.AddIn ICSharpCode.AssemblyAnalyzer.AddIn/Gui ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1997%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser%3A%20.%20ICSharpCode.AssemblyAnalyzer/Engine%20ICSharpCode.AssemblyAnalyzer/Rules%20ICSharpCode.AssemblyAnalyzer/Rules/DesignRules%20ICSharpCode.AssemblyAnalyzer/Rules/NamingRules%20ICSharpCode.AssemblyAnalyzer.AddIn%20ICSharpCode.AssemblyAnalyzer.AddIn/Gui%20ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001600.html">
   <LINK REL="Next"  HREF="001602.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1997 - in trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser: . ICSharpCode.AssemblyAnalyzer/Engine ICSharpCode.AssemblyAnalyzer/Rules ICSharpCode.AssemblyAnalyzer/Rules/DesignRules ICSharpCode.AssemblyAnalyzer/Rules/NamingRules ICSharpCode.AssemblyAnalyzer.AddIn ICSharpCode.AssemblyAnalyzer.AddIn/Gui ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1997%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser%3A%20.%20ICSharpCode.AssemblyAnalyzer/Engine%20ICSharpCode.AssemblyAnalyzer/Rules%20ICSharpCode.AssemblyAnalyzer/Rules/DesignRules%20ICSharpCode.AssemblyAnalyzer/Rules/NamingRules%20ICSharpCode.AssemblyAnalyzer.AddIn%20ICSharpCode.AssemblyAnalyzer.AddIn/Gui%20ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1997 - in trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser: . ICSharpCode.AssemblyAnalyzer/Engine ICSharpCode.AssemblyAnalyzer/Rules ICSharpCode.AssemblyAnalyzer/Rules/DesignRules ICSharpCode.AssemblyAnalyzer/Rules/NamingRules ICSharpCode.AssemblyAnalyzer.AddIn ICSharpCode.AssemblyAnalyzer.AddIn/Gui ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Mon Oct 25 23:51:03 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001600.html">[Monodevelop-patches-list] r1996 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui
</A></li>
        <LI>Next message: <A HREF="001602.html">[Monodevelop-patches-list] r1998 - in trunk/MonoDevelop/Core/src: Libraries/MonoDevelop.Gui.Widgets/DragNotebook Main/Base/Gui/Workbench/Layouts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1601">[ date ]</a>
              <a href="thread.html#1601">[ thread ]</a>
              <a href="subject.html#1601">[ subject ]</a>
              <a href="author.html#1601">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2004-10-25 23:51:03 -0400 (Mon, 25 Oct 2004)
New Revision: 1997

Added:
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ChangeLog
Modified:
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Commands.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserControl.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserView.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyTreeControl.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultDetailsView.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultListControl.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/AssemblyAnalyser.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/Resolution.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractReflectionRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyClsCompliantRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyStrongNameRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyVersionNumberRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AvoidNamespacesWithFewMembers.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventFirstParameterIsObjectRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventHandlersReturnVoidRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventsHaveTwoParametersRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/InterfaceNotEmptyRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesShouldBeInNamespacesRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IAssemblyRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IConstructorRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IEventRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IFieldRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMemberRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodBaseRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IModuleRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/INamespaceRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IParameterRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IPropertyRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IReflectionRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ITypeRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/AttributeSuffixIsAttributeRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/CheckCollectionSuffix.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EnumsHaveNoEnumSuffix.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventFirstParameterNameIsSender.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventSecondParameterNameIsE.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/FlagEnumerationsArePlural.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/InterfacesPrefixIsI.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersArePascalCased.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersDoNotContainUnderscores.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesArePascalCased.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesDoNotContainUnderscores.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParametersAreCamelCased.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/PermissionSuffixIsPermissionRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/StreamSuffixIsStreamRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesArePascalCased.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingUtilities.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/PriorityLevel.cs
   trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ProtectionLevels.cs
Log:
update


Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ChangeLog	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ChangeLog	2004-10-26 03:51:03 UTC (rev 1997)
@@ -0,0 +1,5 @@
+2004-10-26  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
+
+	* re-update the non-gui parts from SD svn and use it (mostly)
+	un-modified, only resources/I18N stuff should be different
+	update the Gui stuff to compile with ICSharpCode namespaces

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/AssemblyAnalyser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/AssemblyAnalyser.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/AssemblyAnalyser.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,217 +1,210 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-using System.Reflection;
-using MonoDevelop.AssemblyAnalyser.Rules;
-
-namespace MonoDevelop.AssemblyAnalyser
-{
-	public class AssemblyAnalyser : System.MarshalByRefObject
-	{
-		ArrayList assemblyRules    = new ArrayList ();
-		ArrayList moduleRules      = new ArrayList ();
-		ArrayList typeRules        = new ArrayList ();
-		ArrayList namespaceRules   = new ArrayList ();
-		ArrayList memberRules      = new ArrayList ();
-		ArrayList methodBaseRules  = new ArrayList ();
-		ArrayList constructorRules = new ArrayList ();
-		ArrayList eventRules       = new ArrayList ();
-		ArrayList fieldRules       = new ArrayList ();
-		ArrayList methodRules      = new ArrayList ();
-		ArrayList parameterRules   = new ArrayList ();
-		ArrayList propertyRules    = new ArrayList ();
-		
-		ArrayList resolutions      = new ArrayList ();
-		
-		Hashtable namespaces       = new Hashtable ();
-		
-		public ArrayList Resolutions {
-			get {
-				return resolutions;
-			}
-		}
-		
-		public AssemblyAnalyser()
-		{
-			Type[] types = typeof (AssemblyAnalyser).Assembly.GetTypes ();
-			foreach (Type type in types) {
-				if (!type.IsAbstract &amp;&amp; type.IsClass) {
-					if (type.GetInterface(typeof(IAssemblyRule).FullName) != null) {
- 						assemblyRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IConstructorRule).FullName) != null) {
-						constructorRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IEventRule).FullName) != null) {
-						eventRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IFieldRule).FullName) != null) {
-						fieldRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IMemberRule).FullName) != null) {
-						memberRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IMethodBaseRule).FullName) != null) {
-						methodBaseRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IMethodRule).FullName) != null) {
-						methodRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IModuleRule).FullName) != null) {
-						moduleRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (INamespaceRule).FullName) != null) {
-						namespaceRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IParameterRule).FullName) != null) {
-						parameterRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (IPropertyRule).FullName) != null) {
-						propertyRules.Add(type.Assembly.CreateInstance(type.FullName));
-					} else if (type.GetInterface (typeof (ITypeRule).FullName) != null) {
-						typeRules.Add(type.Assembly.CreateInstance (type.FullName));
-					}
-				}
-			}
-		}
-		
-		void AddResolutions (Resolution resolution)
-		{
-			if (resolution != null) {
-				resolutions.Add (resolution);
-			}
-		}
-		
-		public void Analyse (string fileName)
-		{
-			Assembly assembly = null;
-			
-			try {
-				assembly = Assembly.LoadFrom (fileName);
-			} catch (Exception e) {
-				resolutions.Add (new Resolution (new CustomRule (&quot;Assembly cannot be loaded.&quot;,
-				                                              &quot;Assembly cannot be loaded details. &quot;, PriorityLevel.CriticalError, 100), 
-				                               &quot;Assembly cannot be loaded resolution.&quot;,
-				                               fileName,
-				                               new string[,] { { &quot;FileName&quot;, fileName }, {&quot;ExceptionMessage&quot;, e.Message}}));
-				return;
-			}
-			
-			Analyse (assembly);
-		}
-		
-		public void Analyse (Module module, Type type)
-		{
-			if (type.IsSpecialName || !(Char.IsLetter (type.Name[0]) || type.Name[0] == '_')) {
-				return;
-			}
-			
-			string ns = type.Namespace == null ? &quot;&quot; : type.Namespace;
-			
-			if (namespaces[ns] == null) {
-				namespaces[ns] = new ArrayList();
-			}
-			
-			((ArrayList) namespaces[ns]).Add (type);
-			
-			foreach (ITypeRule typeRule in typeRules) {
-				AddResolutions (typeRule.Check (type));
-			}
-			
-			foreach (Type nestedType in type.GetNestedTypes ()) {
-				Analyse (module, nestedType);
-			}
-			
-			BindingFlags bf = BindingFlags.DeclaredOnly |
-			                  BindingFlags.Public |
-			                  BindingFlags.NonPublic |
-			                  BindingFlags.Static |
-			                  BindingFlags.Instance;
-			
-			
-			foreach (MemberInfo memberInfo in type.GetMembers(bf)) {
-				foreach (IMemberRule memberRule in memberRules) {
-					AddResolutions (memberRule.Check (module, memberInfo));
-				}
-			}
-			
-			foreach (ConstructorInfo constructorInfo in type.GetConstructors(bf)) {
-				if (!constructorInfo.IsSpecialName) {
-					// search parameters
-					foreach (ParameterInfo parameter in constructorInfo.GetParameters ()) {
-						foreach (IParameterRule parameterRule in parameterRules) {
-							AddResolutions (parameterRule.Check (module, parameter));
-						}
-					}
-					
-					foreach (IConstructorRule constructorRule in constructorRules) {
-						AddResolutions (constructorRule.Check (constructorInfo));
-					}
-				}
-			}
-			
-			foreach (EventInfo eventInfo in type.GetEvents (bf)) {
-				if (!eventInfo.IsSpecialName) {
-					foreach (IEventRule eventRule in eventRules) {
-						AddResolutions (eventRule.Check (eventInfo));
-					}
-				}
-			}
-			
-			foreach (FieldInfo fieldInfo in type.GetFields (bf)) {
-				if (!fieldInfo.IsSpecialName) {
-					foreach (IFieldRule fieldRule in fieldRules) {
-						AddResolutions (fieldRule.Check (module, fieldInfo));
-					}
-				}
-			}
-			
-			// TODO: IMethodBaseRule
-			foreach (MethodInfo methodInfo in type.GetMethods(bf)) {
-				if (!methodInfo.IsSpecialName) {
-					//Console.WriteLine (methodInfo.Attributes);
-				
-					// search parameters
-					foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
-						foreach (IParameterRule parameterRule in parameterRules) {
-							AddResolutions (parameterRule.Check (module, parameter));
-						}
-					}
-					
-					foreach (IMethodRule methodRule in methodRules) {
-						AddResolutions (methodRule.Check (module, methodInfo));
-					}
-				}
-			}
-			
-			foreach (PropertyInfo propertyInfo in type.GetProperties(bf)) {
-				if (!propertyInfo.IsSpecialName) {
-					foreach (IPropertyRule propertyRule in propertyRules) {
-						AddResolutions (propertyRule.Check (propertyInfo));
-					}
-				}
-			}
-		}
-		
-		public void Analyse (Assembly assembly)
-		{
-			namespaces = new Hashtable ();
-			resolutions = new ArrayList ();
-			
-			foreach (IAssemblyRule assemblyRule in assemblyRules) {
-				AddResolutions (assemblyRule.Check (assembly));
-			}
-			
-			foreach (Module module in assembly.GetModules ()) {
-				foreach (IModuleRule moduleRule in moduleRules) {
-					AddResolutions (moduleRule.Check (module));
-				}
-				foreach (Type type in module.GetTypes ()) {
-					Analyse (module, type);
-				}
-			}
-			
-			foreach (DictionaryEntry namespaceEntry in namespaces) {
-				foreach (INamespaceRule namespaceRule in namespaceRules) {
-					AddResolutions (namespaceRule.Check (namespaceEntry.Key.ToString (), (ArrayList) namespaceEntry.Value));
-				}
-			}
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+using ICSharpCode.AssemblyAnalyser.Rules;
+
+namespace ICSharpCode.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyAnalyser.	
+	/// &lt;/summary&gt;
+	public class AssemblyAnalyser : System.MarshalByRefObject
+	{
+		ArrayList assemblyRules    = new ArrayList();
+		ArrayList moduleRules      = new ArrayList();
+		ArrayList typeRules        = new ArrayList();
+		ArrayList namespaceRules   = new ArrayList();
+		ArrayList memberRules      = new ArrayList();
+		ArrayList methodBaseRules  = new ArrayList();
+		ArrayList constructorRules = new ArrayList();
+		ArrayList eventRules       = new ArrayList();
+		ArrayList fieldRules       = new ArrayList();
+		ArrayList methodRules      = new ArrayList();
+		ArrayList parameterRules   = new ArrayList();
+		ArrayList propertyRules    = new ArrayList();
+		
+		ArrayList resolutions      = new ArrayList();
+		
+		Hashtable namespaces       = new Hashtable();
+		
+		public ArrayList Resolutions {
+			get {
+				return resolutions;
+			}
+		}
+		
+		public AssemblyAnalyser()
+		{
+			
+			Type[] types = typeof(AssemblyAnalyser).Assembly.GetTypes();
+			foreach (Type type in types) {
+				if (!type.IsAbstract &amp;&amp; type.IsClass) {
+					if (type.GetInterface(typeof(IAssemblyRule).FullName) != null) {
+ 						assemblyRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IConstructorRule).FullName) != null) {
+						constructorRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IEventRule).FullName) != null) {
+						eventRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IFieldRule).FullName) != null) {
+						fieldRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IMemberRule).FullName) != null) {
+						memberRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IMethodBaseRule).FullName) != null) {
+						methodBaseRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IMethodRule).FullName) != null) {
+						methodRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IModuleRule).FullName) != null) {
+						moduleRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(INamespaceRule).FullName) != null) {
+						namespaceRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IParameterRule).FullName) != null) {
+						parameterRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IPropertyRule).FullName) != null) {
+						propertyRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(ITypeRule).FullName) != null) {
+						typeRules.Add(type.Assembly.CreateInstance(type.FullName));
+					}
+				}
+			}
+		}
+		
+		void AddResolutions(Resolution resolution)
+		{
+			if (resolution != null) {
+				resolutions.Add(resolution);
+			}
+		}
+		
+		public void Analyse(string fileName)
+		{
+			Assembly assembly = null;
+			try {
+				assembly = Assembly.LoadFrom(fileName);
+			} catch (Exception e) {
+				// FIXME: I18N
+				resolutions.Add (new Resolution (new CustomRule (&quot;Assembly cannot be loaded&quot;, &quot;When an assembly cannot be loaded it indicates that the format is corrupt. This means that the .dll or .exe might not be in a managed .NET format or that the file was altered (in this case recompiling might help).&quot;, PriorityLevel.CriticalError, 100), String.Format (&quot;Recompile {0}. Exception was: {1}&quot;, fileName, e.Message), fileName));
+				return;
+			}
+			Analyse(assembly);
+		}
+		
+		public void Analyse(Module module, Type type)
+		{
+			if (type.IsSpecialName || !(Char.IsLetter(type.Name[0]) || type.Name[0] == '_')) {
+				return;
+			}
+			string ns = type.Namespace == null ? &quot;&quot; : type.Namespace;
+			if (namespaces[ns] == null) {
+				namespaces[ns] = new ArrayList();
+			}
+			((ArrayList)namespaces[ns]).Add(type);
+			
+			foreach (ITypeRule typeRule in typeRules) {
+				AddResolutions(typeRule.Check(type));
+			}
+			
+			foreach (Type nestedType in type.GetNestedTypes()) {
+				Analyse(module, nestedType);
+			}
+			BindingFlags bf = BindingFlags.DeclaredOnly |
+			                  BindingFlags.Public |
+			                  BindingFlags.NonPublic |
+			                  BindingFlags.Static |
+			                  BindingFlags.Instance;
+			
+			
+			foreach (MemberInfo memberInfo in type.GetMembers(bf)) {
+				foreach (IMemberRule memberRule in memberRules) {
+					AddResolutions(memberRule.Check(module, memberInfo));
+				}
+			}
+			
+			foreach (ConstructorInfo constructorInfo in type.GetConstructors(bf)) {
+				if (!constructorInfo.IsSpecialName) {
+					// search parameters
+					foreach (ParameterInfo parameter in constructorInfo.GetParameters()) {
+						foreach (IParameterRule parameterRule in parameterRules) {
+							AddResolutions(parameterRule.Check(module, parameter));
+						}
+					}
+					
+					foreach (IConstructorRule constructorRule in constructorRules) {
+						AddResolutions(constructorRule.Check(constructorInfo));
+					}
+				}
+			}
+			
+			foreach (EventInfo eventInfo in type.GetEvents(bf)) {
+				if (!eventInfo.IsSpecialName) {
+					foreach (IEventRule eventRule in eventRules) {
+						AddResolutions(eventRule.Check(eventInfo));
+					}
+				}
+			}
+			
+			foreach (FieldInfo fieldInfo in type.GetFields(bf)) {
+				if (!fieldInfo.IsSpecialName) {
+					foreach (IFieldRule fieldRule in fieldRules) {
+						AddResolutions(fieldRule.Check(module, fieldInfo));
+					}
+				}
+			}
+			
+			// TODO: IMethodBaseRule
+			foreach (MethodInfo methodInfo in type.GetMethods(bf)) {
+				if (!methodInfo.IsSpecialName) {
+					//Console.WriteLine(methodInfo.Attributes);
+				
+					// search parameters
+					foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
+						foreach (IParameterRule parameterRule in parameterRules) {
+							AddResolutions(parameterRule.Check(module, parameter));
+						}
+					}
+					
+					foreach (IMethodRule methodRule in methodRules) {
+						AddResolutions(methodRule.Check(module, methodInfo));
+					}
+				}
+			}
+			
+			foreach (PropertyInfo propertyInfo in type.GetProperties(bf)) {
+				if (!propertyInfo.IsSpecialName) {
+					foreach (IPropertyRule propertyRule in propertyRules) {
+						AddResolutions(propertyRule.Check(propertyInfo));
+					}
+				}
+			}
+		}
+		public void Analyse(Assembly assembly)
+		{
+			namespaces = new Hashtable();
+			resolutions = new ArrayList();
+			foreach (IAssemblyRule assemblyRule in assemblyRules) {
+				AddResolutions(assemblyRule.Check(assembly));
+			}
+			
+			foreach (Module module in assembly.GetModules()) {
+				foreach (IModuleRule moduleRule in moduleRules) {
+					AddResolutions(moduleRule.Check(module));
+				}
+				foreach (Type type in module.GetTypes()) {
+					Analyse(module, type);
+				}
+			}
+			
+			foreach (DictionaryEntry namespaceEntry in namespaces) {
+				foreach (INamespaceRule namespaceRule in namespaceRules) {
+					AddResolutions(namespaceRule.Check(namespaceEntry.Key.ToString(), (ArrayList)namespaceEntry.Value));
+				}
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/ChangeLog	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/ChangeLog	2004-10-26 03:51:03 UTC (rev 1997)
@@ -0,0 +1,5 @@
+2004-10-25  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
+
+	* AssemblyAnalzer.cs: comment Console.WriteLine
+	* Resolution.cs: remove Variables stuff for string substitution
+	the Rules can just pass in the final text.

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/Resolution.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/Resolution.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/Resolution.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,56 +1,47 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using MonoDevelop.AssemblyAnalyser.Rules;
-
-namespace MonoDevelop.AssemblyAnalyser
-{	
-	public class Resolution : System.MarshalByRefObject
-	{
-		IRule  failedRule;
-		string text;
-		string item;
-		string[,] variables;
-		
-		public IRule FailedRule {
-			get {
-				return failedRule;
-			}
-		}
-		public string Text {
-			get {
-				return text;
-			}
-		}
-		public string Item {
-			get {
-				return item;
-			}
-		}
-		public string[,] Variables {
-			get {
-				return variables;
-			}
-		}
-		
-		public Resolution (IRule failedRule, string text, string item)
-		{
-			this.failedRule = failedRule;
-			this.text = text;
-			this.item = item;
-		}
-		
-		public Resolution (IRule failedRule, string text, string item, string[,] variables)
-		{
-			this.failedRule = failedRule;
-			this.text = text;
-			this.item = item;
-			this.variables = variables;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using ICSharpCode.AssemblyAnalyser.Rules;
+
+namespace ICSharpCode.AssemblyAnalyser
+{
+	/// &lt;/summary&gt;
+	/// &lt;summary&gt;
+	/// Description of Resolution.	
+	public class Resolution : System.MarshalByRefObject
+	{
+		IRule  failedRule;
+		string text;
+		string item;
+		
+		public IRule FailedRule {
+			get {
+				return failedRule;
+			}
+		}
+		public string Text {
+			get {
+				return text;
+			}
+		}
+		public string Item {
+			get {
+				return item;
+			}
+		}
+		
+		// instead of the SD substitution, Rules are expected to
+		// pass in the final text, hint use String.Format ()
+		public Resolution(IRule failedRule, string text, string item)
+		{
+			this.failedRule = failedRule;
+			this.text = text;
+			this.item = item;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractReflectionRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractReflectionRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractReflectionRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,41 +1,41 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AbstractReflectionRule.	
-	/// &lt;/summary&gt;
-	public abstract class AbstractReflectionRule : AbstractRule, MonoDevelop.AssemblyAnalyser.Rules.IReflectionRule
-	{
-		protected ProtectionLevels memberProtectionLevel     = ProtectionLevels.All;
-		protected ProtectionLevels nestedTypeProtectionLevel = ProtectionLevels.All;
-		protected ProtectionLevels typeProtectionLevel       = ProtectionLevels.All;
-		
-		#region MonoDevelop.AssemblyAnalyser.Rules.IReflectionRule interface implementation
-		public virtual ProtectionLevels MemberProtectionLevel {
-			get {
-				return memberProtectionLevel;
-			}
-		}
-		
-		public virtual ProtectionLevels NestedTypeProtectionLevel {
-			get {
-				return nestedTypeProtectionLevel;
-			}
-		}
-		
-		public virtual ProtectionLevels TypeProtectionLevel {
-			get {
-				return typeProtectionLevel;
-			}
-		}
-		#endregion
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AbstractReflectionRule.	
+	/// &lt;/summary&gt;
+	public abstract class AbstractReflectionRule : AbstractRule, IReflectionRule
+	{
+		protected ProtectionLevels memberProtectionLevel     = ProtectionLevels.All;
+		protected ProtectionLevels nestedTypeProtectionLevel = ProtectionLevels.All;
+		protected ProtectionLevels typeProtectionLevel       = ProtectionLevels.All;
+		
+		#region ICSharpCode.AssemblyAnalyser.Rules.IReflectionRule interface implementation
+		public virtual ProtectionLevels MemberProtectionLevel {
+			get {
+				return memberProtectionLevel;
+			}
+		}
+		
+		public virtual ProtectionLevels NestedTypeProtectionLevel {
+			get {
+				return nestedTypeProtectionLevel;
+			}
+		}
+		
+		public virtual ProtectionLevels TypeProtectionLevel {
+			get {
+				return typeProtectionLevel;
+			}
+		}
+		#endregion
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,82 +1,82 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AbstractRule.	
-	/// &lt;/summary&gt;
-	public abstract class AbstractRule : System.MarshalByRefObject, IRule
-	{
-		protected PriorityLevel priorityLevel = PriorityLevel.Error;
-		protected int certainty = 99;
-		
-		#region MonoDevelop.AssemblyAnalyser.Rules.IRule interface implementation
-		public PriorityLevel PriorityLevel {
-			get {
-				return priorityLevel;
-			}
-		}
-		
-		public int Certainty {
-			get {
-				return certainty;
-			}
-		}
-		
-		public abstract string Description {
-			get;
-		}
-		
-		public abstract string Details {
-			get;
-		}
-		
-		public virtual void EndAnalysis()
-		{
-		}
-		
-		public virtual void StartAnalysis()
-		{
-		}
-		#endregion
-	}
-	
-	public class CustomRule : AbstractRule
-	{
-		string description;
-		string details;
-		
-		public override string Description {
-			get {
-				return description;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return details;
-			}
-		}
-		
-		public CustomRule(string description, string details)
-		{
-			this.description = description;
-			this.details = details;
-		}
-		public CustomRule(string description, string details, PriorityLevel priorityLevel, int certainty)
-		{
-			this.description = description;
-			this.details = details;
-			this.priorityLevel = priorityLevel;
-			this.certainty = certainty;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AbstractRule.	
+	/// &lt;/summary&gt;
+	public abstract class AbstractRule : System.MarshalByRefObject, IRule
+	{
+		protected PriorityLevel priorityLevel = PriorityLevel.Error;
+		protected int certainty = 99;
+		
+		#region ICSharpCode.AssemblyAnalyser.Rules.IRule interface implementation
+		public PriorityLevel PriorityLevel {
+			get {
+				return priorityLevel;
+			}
+		}
+		
+		public int Certainty {
+			get {
+				return certainty;
+			}
+		}
+		
+		public abstract string Description {
+			get;
+		}
+		
+		public abstract string Details {
+			get;
+		}
+		
+		public virtual void EndAnalysis()
+		{
+		}
+		
+		public virtual void StartAnalysis()
+		{
+		}
+		#endregion
+	}
+	
+	public class CustomRule : AbstractRule
+	{
+		string description;
+		string details;
+		
+		public override string Description {
+			get {
+				return description;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return details;
+			}
+		}
+		
+		public CustomRule(string description, string details)
+		{
+			this.description = description;
+			this.details = details;
+		}
+		public CustomRule(string description, string details, PriorityLevel priorityLevel, int certainty)
+		{
+			this.description = description;
+			this.details = details;
+			this.priorityLevel = priorityLevel;
+			this.certainty = certainty;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ChangeLog	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ChangeLog	2004-10-26 03:51:03 UTC (rev 1997)
@@ -0,0 +1,5 @@
+2004-10-25  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
+
+	* All Rules: add the Description, Details, and Resoltion text into the rule
+	I18N will be done in another way, don't use contractions in text,
+	fix some typos spelling

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,102 +1,103 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AssemblyStrongName.	
-	/// &lt;/summary&gt;
-	public class AbstractTypesPublicConstructorsRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AbstractTypesPublicConstructors.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AbstractTypesPublicConstructors.Details}&quot;;
-			}
-		}
-		
-		public AbstractTypesPublicConstructorsRule()
-		{
-			priorityLevel = PriorityLevel.CriticalWarning;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (type.IsAbstract) {
-				foreach (ConstructorInfo info in type.GetConstructors()) {
-					if (info.IsPublic) {
- 						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AbstractTypesPublicConstructors.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-					}
-				}
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class AbstractTypesPublicConstructorsRuleTest
-	{
-		abstract class AbstractClassPublic1 {
-			public AbstractClassPublic1()
-			{
-			}
-		}
-		abstract class AbstractClassPublic2 {
-			protected AbstractClassPublic2()
-			{
-			}
-			public AbstractClassPublic2(int x, int y)
-			{
-			}
-		}
-		[Test]
-		public void TestAbstractTypesWithPublicConstructor()
-		{
-			AbstractTypesPublicConstructorsRule rule = new AbstractTypesPublicConstructorsRule();
-			Assertion.AssertNotNull(rule.Check(typeof(AbstractClassPublic1)));
-			Assertion.AssertNotNull(rule.Check(typeof(AbstractClassPublic2)));
-		}
-		
-		abstract class AbstractClass1 {
-			protected AbstractClass1()
-			{
-			}
-		}
-		abstract class AbstractClass2 {
-			protected AbstractClass2(int x, int y)
-			{
-			}
-		}
-		
-		[Test]
-		public void TestAbstractTypesWithoutPublicConstructor()
-		{
-			AbstractTypesPublicConstructorsRule rule = new AbstractTypesPublicConstructorsRule();
-			Assertion.AssertNull(rule.Check(typeof(AbstractClass1)));
-			Assertion.AssertNull(rule.Check(typeof(AbstractClass2)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyStrongName.	
+	/// &lt;/summary&gt;
+	public class AbstractTypesPublicConstructorsRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Abstract types should not have public constructors&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;You cannot create abstract types therefore public constructors do not make any sense.&quot;;
+			}
+		}
+		
+		public AbstractTypesPublicConstructorsRule()
+		{
+			priorityLevel = PriorityLevel.CriticalWarning;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsAbstract) {
+				foreach (ConstructorInfo info in type.GetConstructors()) {
+					if (info.IsPublic) {
+						// FIXME: I18N
+ 						return new Resolution (this, String.Format (&quot;Change all constructors access levels in &lt;code&gt;{0}&lt;/code&gt; to &lt;code&gt;protected&lt;/code&gt;.&quot;, type.FullName), type.FullName);
+					}
+				}
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class AbstractTypesPublicConstructorsRuleTest
+	{
+		abstract class AbstractClassPublic1 {
+			public AbstractClassPublic1()
+			{
+			}
+		}
+		abstract class AbstractClassPublic2 {
+			protected AbstractClassPublic2()
+			{
+			}
+			public AbstractClassPublic2(int x, int y)
+			{
+			}
+		}
+		[Test]
+		public void TestAbstractTypesWithPublicConstructor()
+		{
+			AbstractTypesPublicConstructorsRule rule = new AbstractTypesPublicConstructorsRule();
+			Assertion.AssertNotNull(rule.Check(typeof(AbstractClassPublic1)));
+			Assertion.AssertNotNull(rule.Check(typeof(AbstractClassPublic2)));
+		}
+		
+		abstract class AbstractClass1 {
+			protected AbstractClass1()
+			{
+			}
+		}
+		abstract class AbstractClass2 {
+			protected AbstractClass2(int x, int y)
+			{
+			}
+		}
+		
+		[Test]
+		public void TestAbstractTypesWithoutPublicConstructor()
+		{
+			AbstractTypesPublicConstructorsRule rule = new AbstractTypesPublicConstructorsRule();
+			Assertion.AssertNull(rule.Check(typeof(AbstractClass1)));
+			Assertion.AssertNull(rule.Check(typeof(AbstractClass2)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyClsCompliantRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyClsCompliantRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyClsCompliantRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,51 +1,55 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AssemblyStrongName.	
-	/// &lt;/summary&gt;
-	public class AssemblyClsCompliantRule : AbstractReflectionRule, IAssemblyRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyClsCompliantRule.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyClsCompliantRule.Details}&quot;;
-			}
-		}
-		
-		public AssemblyClsCompliantRule()
-		{
-			certainty = 99;
-		}
-		
-		public Resolution Check(Assembly assembly)
-		{
-			object[] attributes = assembly.GetCustomAttributes(typeof(System.CLSCompliantAttribute), true);
-			if (attributes == null || attributes.Length == 0) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyClsCompliantRule.Resolution1}&quot;, assembly.Location, new string[,] { {&quot;AssemblyName&quot;, Path.GetFileName(assembly.Location)} });
-			} else {
-				foreach (CLSCompliantAttribute attr in attributes) {
-					if (!attr.IsCompliant) {
-						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyClsCompliantRule.Resolution2}&quot;, assembly.Location, new string[,] { {&quot;AssemblyName&quot;, Path.GetFileName(assembly.Location)} });
-					}
-				}
-			}
-			return null;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyStrongName.	
+	/// &lt;/summary&gt;
+	public class AssemblyClsCompliantRule : AbstractReflectionRule, IAssemblyRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Assemblies should be marked CLSCompliant&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Assemblies should be marked CLS (Common Language Specification) compliant using the &lt;code&gt;&lt;a href='<A HREF="help://types/System.CLSCompliantAttribute'">help://types/System.CLSCompliantAttribute'</A>&gt;CLSCompliantAttribute&lt;/a&gt;&lt;/code&gt; assemblies without this attribute are not CLS compliant. It is possible to have non-CLS compliant parts in a CLS compliant assembly. In this case all non-compliant members must have the CLSCompliant attribute set to &lt;code&gt;false&lt;/code&gt;. You should supply for each non-CLS compliant member a CLS compliant alternative.&quot;;
+			}
+		}
+		
+		public AssemblyClsCompliantRule()
+		{
+			certainty = 99;
+		}
+		
+		public Resolution Check(Assembly assembly)
+		{
+			object[] attributes = assembly.GetCustomAttributes(typeof(System.CLSCompliantAttribute), true);
+			if (attributes == null || attributes.Length == 0) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Declare a &lt;code&gt;&lt;a href='<A HREF="help://types/System.CLSCompliantAttribute'">help://types/System.CLSCompliantAttribute'</A>&gt;CLSCompliantAttribute&lt;/a&gt;&lt;/code&gt; in the assembly &lt;code&gt;{0}&lt;/code&gt; and its value should be &lt;code&gt;true&lt;/code&gt;.&quot;, Path.GetFileName (assembly.Location)), assembly.Location);
+			} else {
+				foreach (CLSCompliantAttribute attr in attributes) {
+					if (!attr.IsCompliant) {
+						// FIXME: I18N
+						return new Resolution (this, String.Format (&quot;Set the &lt;code&gt;&lt;a href='<A HREF="help://types/System.CLSCompliantAttribute'">help://types/System.CLSCompliantAttribute'</A>&gt;CLSCompliantAttribute&lt;/a&gt;&lt;/code&gt; in the assembly &lt;code&gt;{0}&lt;/code&gt; to &lt;code&gt;true&lt;code&gt;.&quot;, Path.GetFileName (assembly.Location)), assembly.Location);
+					}
+				}
+			}
+			return null;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyStrongNameRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyStrongNameRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyStrongNameRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,45 +1,48 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AssemblyStrongName.	
-	/// &lt;/summary&gt;
-	public class AssemblyStrongNameRule : AbstractReflectionRule, IAssemblyRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyStrongName.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyStrongName.Details}&quot;;
-			}
-		}
-		
-		public AssemblyStrongNameRule()
-		{
-			certainty = 95;
-		}
-		
-		public Resolution Check(Assembly assembly)
-		{
-			byte[] publicKeyToken = assembly.GetName().GetPublicKeyToken();
-			if (publicKeyToken == null || publicKeyToken.Length == 0) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyStrongName.Resolution}&quot;, assembly.Location, new string[,] { {&quot;AssemblyName&quot;, Path.GetFileName(assembly.Location)} });
-			}
-			return null;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyStrongName.	
+	/// &lt;/summary&gt;
+	public class AssemblyStrongNameRule : AbstractReflectionRule, IAssemblyRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Assemblies should be strong named&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Assemblies with a strong name can be placed in the GAC. Furthermore only strong named assemblies can be referenced by a strong named assembly (Your assembly cannot be used by a strong named assembly if you do not sign it).&quot;;
+			}
+		}
+		
+		public AssemblyStrongNameRule()
+		{
+			certainty = 95;
+		}
+		
+		public Resolution Check(Assembly assembly)
+		{
+			byte[] publicKeyToken = assembly.GetName().GetPublicKeyToken();
+			// FIXME: I18N
+			if (publicKeyToken == null || publicKeyToken.Length == 0) {
+				return new Resolution (this, String.Format (&quot;Sign the assembly {0} with a strong name.&quot;, Path.GetFileName (assembly.Location)), assembly.Location);
+			}
+			return null;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyVersionNumberRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyVersionNumberRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyVersionNumberRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,45 +1,48 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-using System.Reflection;
-using MonoDevelop.AssemblyAnalyser.Rules;
-
-namespace MonoDevelop.AssemblyAnalyser
-{
-	/// &lt;summary&gt;
-	/// Description of AssemblyVersionNumber.	
-	/// &lt;/summary&gt;
-	public class AssemblyVersionNumberRule : AbstractReflectionRule, IAssemblyRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyVersionNumber.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyVersionNumber.Details}&quot;;
-			}
-		}
-		
-		public AssemblyVersionNumberRule()
-		{
-			certainty = 95;
-		}
-		
-		public Resolution Check(Assembly assembly)
-		{
-			if (assembly.GetName().Version == new Version(0, 0, 0, 0)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyVersionNumber.Resolution}&quot;, assembly.Location, new string[,] { {&quot;AssemblyName&quot;, Path.GetFileName(assembly.Location)} });
-			}
-			return null;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Reflection;
+using ICSharpCode.AssemblyAnalyser.Rules;
+
+namespace ICSharpCode.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyVersionNumberRule.
+	/// &lt;/summary&gt;
+	public class AssemblyVersionNumberRule : AbstractReflectionRule, IAssemblyRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Assemblies should have version numbers&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;The Version number is part of the assembly identity. Use the &lt;code&gt;&lt;a href='<A HREF="help://types/System.Reflection.AssemblyVersionAttribute'">help://types/System.Reflection.AssemblyVersionAttribute'</A>&gt;AssemblyVersion&lt;/a&gt;&lt;/code&gt; attribute to assign a version number.&quot;;
+			}
+		}
+		
+		public AssemblyVersionNumberRule()
+		{
+			certainty = 95;
+		}
+		
+		public Resolution Check(Assembly assembly)
+		{
+			if (assembly.GetName().Version == new Version(0, 0, 0, 0)) {
+				// FIXME: I18N
+				return new Resolution(this, String.Format (&quot;Add an &lt;code&gt;&lt;a href='<A HREF="help://types/System.Reflection.AssemblyVersionAttribute'">help://types/System.Reflection.AssemblyVersionAttribute'</A>&gt;AssemblyVersion&lt;/a&gt;&lt;/code&gt; attribute to the assembly {0}.&quot;, Path.GetFileName (assembly.Location)), assembly.Location);
+			}
+			return null;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AvoidNamespacesWithFewMembers.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AvoidNamespacesWithFewMembers.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AvoidNamespacesWithFewMembers.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,77 +1,78 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AvoidNamespacesWithFewMembers.	
-	/// &lt;/summary&gt;
-	public class AvoidNamespacesWithFewMembers : AbstractReflectionRule, INamespaceRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AvoidNamespacesWithFewMembers.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AvoidNamespacesWithFewMembers.Details}&quot;;
-			}
-		}
-		
-		public AvoidNamespacesWithFewMembers()
-		{
-			base.certainty     = 50;
-			base.priorityLevel = PriorityLevel.Warning;
-		}
-		
-		public Resolution Check(string namespaceName, ICollection types)
-		{
-			if (namespaceName != null &amp;&amp; namespaceName.Length &gt; 0 &amp;&amp; types.Count &lt; 5) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AvoidNamespacesWithFewMembers.Resolution}&quot;, namespaceName, new string[,]{{&quot;NamespaceName&quot;, namespaceName}});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class AvoidNamespacesWithFewMembersTest
-	{
-		[Test]
-		public void TestCorrectNamespaces()
-		{
-			AvoidNamespacesWithFewMembers rule = new AvoidNamespacesWithFewMembers();
-			Assertion.AssertNull(rule.Check(&quot;MyNamespace&quot;, new Type[] {typeof(System.Object),
-			                                                             typeof(System.Object),
-			                                                             typeof(System.Object),
-			                                                             typeof(System.Object),
-			                                                             typeof(System.Object),
-			                                                             typeof(System.Object)}));
-		}
-		
-		[Test]
-		public void TestIncorrectAttribute()
-		{
-			AvoidNamespacesWithFewMembers rule = new AvoidNamespacesWithFewMembers();
-			Assertion.AssertNotNull(rule.Check(&quot;a&quot;, new Type[] {}));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AvoidNamespacesWithFewMembers.	
+	/// &lt;/summary&gt;
+	public class AvoidNamespacesWithFewMembers : AbstractReflectionRule, INamespaceRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Avoid having namespaces with few type members&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot; A namespace should generally contain a minimum of five types.&quot;;
+			}
+		}
+		
+		public AvoidNamespacesWithFewMembers()
+		{
+			base.certainty     = 50;
+			base.priorityLevel = PriorityLevel.Warning;
+		}
+		
+		public Resolution Check(string namespaceName, ICollection types)
+		{
+			if (namespaceName != null &amp;&amp; namespaceName.Length &gt; 0 &amp;&amp; types.Count &lt; 5) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Consider merging the types inside namespace &lt;code&gt;{0}&lt;/code&gt; with another namespace.&quot;, namespaceName), namespaceName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class AvoidNamespacesWithFewMembersTest
+	{
+		[Test]
+		public void TestCorrectNamespaces()
+		{
+			AvoidNamespacesWithFewMembers rule = new AvoidNamespacesWithFewMembers();
+			Assertion.AssertNull(rule.Check(&quot;MyNamespace&quot;, new Type[] {typeof(System.Object),
+			                                                             typeof(System.Object),
+			                                                             typeof(System.Object),
+			                                                             typeof(System.Object),
+			                                                             typeof(System.Object),
+			                                                             typeof(System.Object)}));
+		}
+		
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			AvoidNamespacesWithFewMembers rule = new AvoidNamespacesWithFewMembers();
+			Assertion.AssertNotNull(rule.Check(&quot;a&quot;, new Type[] {}));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventFirstParameterIsObjectRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventFirstParameterIsObjectRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventFirstParameterIsObjectRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,92 +1,93 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of EventFirstParameterIsObject.	
-	/// &lt;/summary&gt;
-	public class EventFirstParameterIsObjectRule : AbstractReflectionRule, IEventRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterIsObject.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterIsObject.Details}&quot;;
-			}
-		}
-		
-		public EventFirstParameterIsObjectRule()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(EventInfo evnt)
-		{
-			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
-			ParameterInfo[] parameters = invokeMethod.GetParameters();
-
-			if (parameters.Length &gt; 0 &amp;&amp; parameters[0].ParameterType != typeof(System.Object)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterIsObject.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, { &quot;OldParameterType&quot;, parameters[0].ParameterType.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventFirstParameterIsObjectRuleTest
-	{
-		public delegate void CorrectEventHandler(object sender, EventArgs e);
-		public event CorrectEventHandler CorrectEvent;
-		protected virtual void OnCorrectEvent(EventArgs e)
-		{
-			if (CorrectEvent != null) {
-				CorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestCorrectEventHandler()
-		{
-			EventFirstParameterIsObjectRule rule = new EventFirstParameterIsObjectRule();
-			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
-		}
-		
-		public delegate void IncorrectEventHandler(int sender, EventArgs e);
-		public event IncorrectEventHandler IncorrectEvent;
-		protected virtual void OnIncorrectEvent(EventArgs e)
-		{
-			if (IncorrectEvent != null) {
-				IncorrectEvent(6, e);
-			}
-		}
-		
-		[Test]
-		public void TestIncorrectEventHandler()
-		{
-			EventFirstParameterIsObjectRule rule = new EventFirstParameterIsObjectRule();
-			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventFirstParameterIsObject.	
+	/// &lt;/summary&gt;
+	public class EventFirstParameterIsObjectRule : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;The first parameter of an event is from type System.Object&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;As a convention in .NET events have two parameters a sender and an event data object. The sender must always be from the type &lt;code&gt;&lt;a href='<A HREF="help://types/System.Object'">help://types/System.Object'</A>&gt;object&lt;/a&gt;&lt;/code&gt; and never a specialized type.&lt;BR&gt;For example: &lt;code&gt;void MouseEventHandler(object sender, MouseEventArgs e);&lt;/code&gt;&quot;;
+			}
+		}
+		
+		public EventFirstParameterIsObjectRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length &gt; 0 &amp;&amp; parameters[0].ParameterType != typeof(System.Object)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the first parameter of &lt;code&gt;{0}&lt;/code&gt; from the type &lt;code&gt;{1}&lt;/code&gt; to the type &lt;code&gt;&lt;a href='<A HREF="help://types/System.Object'">help://types/System.Object'</A>&gt;object&lt;/a&gt;&lt;/code&gt;.&quot;, evnt.EventHandlerType.FullName, parameters[0].ParameterType.FullName), evnt.EventHandlerType.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventFirstParameterIsObjectRuleTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventFirstParameterIsObjectRule rule = new EventFirstParameterIsObjectRule();
+			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(int sender, EventArgs e);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(6, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventFirstParameterIsObjectRule rule = new EventFirstParameterIsObjectRule();
+			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventHandlersReturnVoidRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventHandlersReturnVoidRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventHandlersReturnVoidRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,90 +1,91 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of EventFirstParameterNameIsSender.	
-	/// &lt;/summary&gt;
-	public class EventHandlersReturnVoidRule : AbstractReflectionRule, IEventRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlersReturnVoid.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlersReturnVoid.Details}&quot;;
-			}
-		}
-		
-		public EventHandlersReturnVoidRule()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(EventInfo evnt)
-		{
-			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
-			if (invokeMethod.ReturnType != typeof(void)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlersReturnVoid.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, {&quot;OldReturnType&quot;, invokeMethod.ReturnType.FullName}});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventHandlersReturnVoidRuleTest
-	{
-		public delegate void CorrectEventHandler(object sender, EventArgs e);
-		public event CorrectEventHandler CorrectEvent;
-		protected virtual void OnCorrectEvent(EventArgs e)
-		{
-			if (CorrectEvent != null) {
-				CorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestCorrectEventHandler()
-		{
-			EventHandlersReturnVoidRule rule = new EventHandlersReturnVoidRule();
-			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
-		}
-		
-		public delegate int IncorrectEventHandler(object sender, EventArgs e);
-		public event IncorrectEventHandler IncorrectEvent;
-		protected virtual void OnIncorrectEvent(EventArgs e)
-		{
-			if (IncorrectEvent != null) {
-				IncorrectEvent(this, e);
-			}
-		}
-		
-		[Test]
-		public void TestIncorrectEventHandler()
-		{
-			EventHandlersReturnVoidRule rule = new EventHandlersReturnVoidRule();
-			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventFirstParameterNameIsSender.	
+	/// &lt;/summary&gt;
+	public class EventHandlersReturnVoidRule : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Event handlers return void&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Event handlers return &lt;code&gt;void&lt;/code&gt; because they can send event to multiple target methods. Any return value would get lost.&quot;;
+			}
+		}
+		
+		public EventHandlersReturnVoidRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			if (invokeMethod.ReturnType != typeof(void)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change &lt;code&gt;{0}&lt;/code&gt; so that it returns &lt;code&gt;void&lt;/code&gt; instead of &lt;code&gt;{1}&lt;/code&gt;.&quot;, evnt.EventHandlerType.FullName, invokeMethod.ReturnType.FullName), evnt.EventHandlerType.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventHandlersReturnVoidRuleTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventHandlersReturnVoidRule rule = new EventHandlersReturnVoidRule();
+			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate int IncorrectEventHandler(object sender, EventArgs e);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventHandlersReturnVoidRule rule = new EventHandlersReturnVoidRule();
+			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,92 +1,93 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of EventFirstParameterIsObject.	
-	/// &lt;/summary&gt;
-	public class EventSecondParameterIsEventArgsRule : AbstractReflectionRule, IEventRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterIsEventArgs.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterIsEventArgs.Details}&quot;;
-			}
-		}
-		
-		public EventSecondParameterIsEventArgsRule()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(EventInfo evnt)
-		{
-			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
-			ParameterInfo[] parameters = invokeMethod.GetParameters();
-
-			if (parameters.Length &gt; 1 &amp;&amp; !typeof(System.EventArgs).IsAssignableFrom(parameters[1].ParameterType)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterIsEventArgs.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, { &quot;OldParameterType&quot;, parameters[1].ParameterType.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventSecondParameterIsEventArgsRuleTest
-	{
-		public delegate void CorrectEventHandler(object sender, EventArgs e);
-		public event CorrectEventHandler CorrectEvent;
-		protected virtual void OnCorrectEvent(EventArgs e)
-		{
-			if (CorrectEvent != null) {
-				CorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestCorrectEventHandler()
-		{
-			EventSecondParameterIsEventArgsRule rule = new EventSecondParameterIsEventArgsRule();
-			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
-		}
-		
-		public delegate void IncorrectEventHandler(object sender, int e);
-		public event IncorrectEventHandler IncorrectEvent;
-		protected virtual void OnIncorrectEvent(int e)
-		{
-			if (IncorrectEvent != null) {
-				IncorrectEvent(this, e);
-			}
-		}
-		
-		[Test]
-		public void TestIncorrectEventHandler()
-		{
-			EventSecondParameterIsEventArgsRule rule = new EventSecondParameterIsEventArgsRule();
-			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventSecondParameterIsEventArgsRule.	
+	/// &lt;/summary&gt;
+	public class EventSecondParameterIsEventArgsRule : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Second parameter type in events is a System.EventArgs type&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;As a convention in .NET events have two parameters a sender and an event data object. The event data must always extend from the type &lt;code&gt;&lt;a href='<A HREF="help://types/System.EventArgs'">help://types/System.EventArgs'</A>&gt;System.EventArgs&lt;/a&gt;&lt;/code&gt; .&lt;BR&gt;For example: &lt;code&gt;void MouseEventHandler(object sender, MouseEventArgs e);&lt;/code&gt; where &lt;code&gt;MouseEventArgs&lt;/code&gt; extends &lt;code&gt;&lt;a href='<A HREF="help://types/System.EventArgs'">help://types/System.EventArgs'</A>&gt;System.EventArgs&lt;/a&gt;&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public EventSecondParameterIsEventArgsRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length &gt; 1 &amp;&amp; !typeof(System.EventArgs).IsAssignableFrom(parameters[1].ParameterType)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the second parameter of the event &lt;code&gt;{0}&lt;/code&gt; from &lt;code&gt;{1}&lt;/code&gt; so that it is from the type &lt;code&gt;&lt;a href='<A HREF="help://types/System.EventArgs'">help://types/System.EventArgs'</A>&gt;EventArgs&lt;/a&gt;&lt;/code&gt; or any more specialized type.&quot;, evnt.EventHandlerType.FullName, parameters[1].ParameterType.FullName), evnt.EventHandlerType.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventSecondParameterIsEventArgsRuleTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventSecondParameterIsEventArgsRule rule = new EventSecondParameterIsEventArgsRule();
+			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(object sender, int e);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(int e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventSecondParameterIsEventArgsRule rule = new EventSecondParameterIsEventArgsRule();
+			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventsHaveTwoParametersRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventsHaveTwoParametersRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventsHaveTwoParametersRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,92 +1,93 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of EventsHaveTwoParameters.	
-	/// &lt;/summary&gt;
-	public class EventsHaveTwoParametersRule : AbstractReflectionRule, IEventRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsHaveTwoParameters.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsHaveTwoParameters.Details}&quot;;
-			}
-		}
-		
-		public EventsHaveTwoParametersRule()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(EventInfo evnt)
-		{
-			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
-			ParameterInfo[] parameters = invokeMethod.GetParameters();
-
-			if (parameters.Length != 2) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsHaveTwoParameters.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventsHaveTwoParametersTest
-	{
-		public delegate void CorrectEventHandler(object sender, EventArgs e);
-		public event CorrectEventHandler CorrectEvent;
-		protected virtual void OnCorrectEvent(EventArgs e)
-		{
-			if (CorrectEvent != null) {
-				CorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestCorrectEventHandler()
-		{
-			EventsHaveTwoParametersRule rule = new EventsHaveTwoParametersRule();
-			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
-		}
-		
-		public delegate void IncorrectEventHandler(object sender, EventArgs e, int i);
-		public event IncorrectEventHandler IncorrectEvent;
-		protected virtual void OnIncorrectEvent(EventArgs e)
-		{
-			if (IncorrectEvent != null) {
-				IncorrectEvent(this, e, 5);
-			}
-		}
-		
-		[Test]
-		public void TestIncorrectEventHandler()
-		{
-			EventsHaveTwoParametersRule rule = new EventsHaveTwoParametersRule();
-			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventsHaveTwoParameters.	
+	/// &lt;/summary&gt;
+	public class EventsHaveTwoParametersRule : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Events have two parameters&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;As a convention in .NET events have two parameters a sender and an event data object. &lt;BR&gt;For example: &lt;code&gt;void MouseEventHandler(object sender, MouseEventArgs e);&lt;/code&gt;&quot;;
+			}
+		}
+		
+		public EventsHaveTwoParametersRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length != 2) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change &lt;code&gt;{0}&lt;/code&gt; so that it has only two parameters. A sender and an event data object.&quot;, evnt.EventHandlerType.FullName), evnt.EventHandlerType.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventsHaveTwoParametersTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventsHaveTwoParametersRule rule = new EventsHaveTwoParametersRule();
+			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(object sender, EventArgs e, int i);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e, 5);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventsHaveTwoParametersRule rule = new EventsHaveTwoParametersRule();
+			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/InterfaceNotEmptyRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/InterfaceNotEmptyRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/InterfaceNotEmptyRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,86 +1,87 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of InterfaceNotEmpty.	
-	/// &lt;/summary&gt;
-	public class InterfaceNotEmptyRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfaceNotEmpty.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfaceNotEmpty.Details}&quot;;
-			}
-		}
-		public Resolution Check(Type type)
-		{
-			if (type.IsInterface &amp;&amp; type.GetMembers().Length == 0) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfaceNotEmpty.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class InterfaceNotEmptyRuleTests
-	{
-		interface NonEmptyInterface1
-		{
-			void A();
-		}
-		interface NonEmptyInterface2
-		{
-			event EventHandler TestEvent;
-		}
-		interface NonEmptyInterface3
-		{
-			int MyProperty {
-				get;
-			}
-		}
-		[Test]
-		public void TestNonEmptyInterface()
-		{
-			InterfaceNotEmptyRule rule = new InterfaceNotEmptyRule();
-			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface1)));
-			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface2)));
-			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface3)));
-		}
-		
-		interface EmptyInterface
-		{
-		}
-		
-		[Test]
-		public void TestEmptyInterface()
-		{
-			InterfaceNotEmptyRule rule = new InterfaceNotEmptyRule();
-			Assertion.AssertNotNull(rule.Check(typeof(EmptyInterface)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of InterfaceNotEmpty.	
+	/// &lt;/summary&gt;
+	public class InterfaceNotEmptyRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Interfaces should not be empty&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Interfaces should specify behaviour. To mark classes use Attributes instead of empty interfaces.&quot;;
+			}
+		}
+		public Resolution Check(Type type)
+		{
+			if (type.IsInterface &amp;&amp; type.GetMembers().Length == 0) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Use a custom attribute to replace the empty interface &lt;code&gt;{0}&lt;/code&gt;. Or specify behaviour for this interface.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class InterfaceNotEmptyRuleTests
+	{
+		interface NonEmptyInterface1
+		{
+			void A();
+		}
+		interface NonEmptyInterface2
+		{
+			event EventHandler TestEvent;
+		}
+		interface NonEmptyInterface3
+		{
+			int MyProperty {
+				get;
+			}
+		}
+		[Test]
+		public void TestNonEmptyInterface()
+		{
+			InterfaceNotEmptyRule rule = new InterfaceNotEmptyRule();
+			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface1)));
+			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface2)));
+			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface3)));
+		}
+		
+		interface EmptyInterface
+		{
+		}
+		
+		[Test]
+		public void TestEmptyInterface()
+		{
+			InterfaceNotEmptyRule rule = new InterfaceNotEmptyRule();
+			Assertion.AssertNotNull(rule.Check(typeof(EmptyInterface)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,101 +1,96 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of PropertiesShouldNotHaveSetOnly.	
-	/// &lt;/summary&gt;
-	public class PropertiesShouldNotHaveSetOnly : AbstractReflectionRule, IPropertyRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PropertiesShouldNotHaveSetOnly.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PropertiesShouldNotHaveSetOnly.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(PropertyInfo property)
-		{
-			if (!property.CanRead &amp;&amp; property.CanWrite) {
-				return new Resolution(this, 
-				                      &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PropertiesShouldNotHaveSetOnly.Resolution}&quot;,
-				                      NamingUtilities.Combine(property.DeclaringType.FullName, property.Name),
-				                      new string[,] { 
-				                      	{&quot;PropertyName&quot;, property.Name}, 
-				                      	{&quot;DeclaringType&quot;, property.DeclaringType.FullName}, 
-				                      });
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class PropertiesShouldNotHaveSetOnlyTest
-	{
-		class A {
-			public int Inta {
-				get {
-					return 5;
-				}
-				set {
-					
-				}
-			}
-			public string StrB {
-				get {
-					return &quot;&quot;;
-				}
-			}
-		}
-		[Test]
-		public void TestCorrectProperties()
-		{
-			PropertiesShouldNotHaveSetOnly rule = new PropertiesShouldNotHaveSetOnly();
-			Assertion.AssertNull(rule.Check(typeof(A).GetProperty(&quot;Inta&quot;)));
-			Assertion.AssertNull(rule.Check(typeof(A).GetProperty(&quot;StrB&quot;)));
-		}
-		
-		class B {
-			public int Inta {
-				set {
-				}
-			}
-			public string StrB {
-				set {
-				}
-			}
-		}
-		
-		[Test]
-		public void TestIncorrectProperties()
-		{
-			PropertiesShouldNotHaveSetOnly rule = new PropertiesShouldNotHaveSetOnly();
-			Assertion.AssertNotNull(rule.Check(typeof(B).GetProperty(&quot;Inta&quot;)));
-			Assertion.AssertNotNull(rule.Check(typeof(B).GetProperty(&quot;StrB&quot;)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of PropertiesShouldNotHaveSetOnly.	
+	/// &lt;/summary&gt;
+	public class PropertiesShouldNotHaveSetOnly : AbstractReflectionRule, IPropertyRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Properties should not be write only&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Write only properties generally indicate a design flaw and should be avoided.&quot;;
+			}
+		}
+		
+		public Resolution Check(PropertyInfo property)
+		{
+			if (!property.CanRead &amp;&amp; property.CanWrite) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Add a getter to the property &lt;code&gt;{0}&lt;/code&gt; in the type &lt;code&gt;{1}&lt;/code&gt;.&quot;, property.Name, property.DeclaringType.FullName), NamingUtilities.Combine(property.DeclaringType.FullName, property.Name));
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class PropertiesShouldNotHaveSetOnlyTest
+	{
+		class A {
+			public int Inta {
+				get {
+					return 5;
+				}
+				set {
+					
+				}
+			}
+			public string StrB {
+				get {
+					return &quot;&quot;;
+				}
+			}
+		}
+		[Test]
+		public void TestCorrectProperties()
+		{
+			PropertiesShouldNotHaveSetOnly rule = new PropertiesShouldNotHaveSetOnly();
+			Assertion.AssertNull(rule.Check(typeof(A).GetProperty(&quot;Inta&quot;)));
+			Assertion.AssertNull(rule.Check(typeof(A).GetProperty(&quot;StrB&quot;)));
+		}
+		
+		class B {
+			public int Inta {
+				set {
+				}
+			}
+			public string StrB {
+				set {
+				}
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectProperties()
+		{
+			PropertiesShouldNotHaveSetOnly rule = new PropertiesShouldNotHaveSetOnly();
+			Assertion.AssertNotNull(rule.Check(typeof(B).GetProperty(&quot;Inta&quot;)));
+			Assertion.AssertNotNull(rule.Check(typeof(B).GetProperty(&quot;StrB&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,107 +1,102 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of PropertiesShouldNotHaveSetOnly.	
-	/// &lt;/summary&gt;
-	public class TypesHaveNoPublicInstanceFields : AbstractReflectionRule, IFieldRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesHaveNoPublicInstanceFields.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesHaveNoPublicInstanceFields.Details}&quot;;
-			}
-		}
-		
-		public TypesHaveNoPublicInstanceFields()
-		{
-			base.certainty = 90;
-		}
-		
-		public Resolution Check(Module module, FieldInfo field)
-		{
-			if (!field.IsStatic &amp;&amp; (field.IsPublic || field.IsAssembly)) {
-				return new Resolution(this, 
-				                      &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesHaveNoPublicInstanceFields.Resolution}&quot;,
-				                      NamingUtilities.Combine(field.DeclaringType.FullName, field.Name),
-				                      new string[,] {
-				                      	{&quot;FieldName&quot;, field.Name}, 
-				                      	{&quot;DeclaringType&quot;, field.DeclaringType.FullName}, 
-				                      });
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class TypesHaveNoPublicInstanceFieldsTest
-	{
-		class A {
-			int a;
-			protected string b;
-			public static int c = 12;
-			public int AA {
-				get {
-					return a;
-				}
-				set {
-					a = value;
-				}
-			}
-			public string B {
-				get {
-					return b;
-				}
-				set {
-					b = value;
-				}
-			}
-		}
-		[Test]
-		public void TestCorrectFields()
-		{
-			TypesHaveNoPublicInstanceFields rule = new TypesHaveNoPublicInstanceFields();
-			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;a&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
-			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;b&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
-			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;c&quot;, BindingFlags.Public | BindingFlags.Static)));
-		}
-		
-		class B {
-			public int a = 5;
-			internal string b =&quot;&quot;;
-		}
-		
-		[Test]
-		public void TestIncorrectFields()
-		{
-			TypesHaveNoPublicInstanceFields rule = new TypesHaveNoPublicInstanceFields();
-			Assertion.AssertNotNull(rule.Check(null, typeof(B).GetField(&quot;a&quot;, BindingFlags.Public | BindingFlags.Instance)));
-			Assertion.AssertNotNull(rule.Check(null, typeof(B).GetField(&quot;b&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of TypesHaveNoPublicInstanceFields
+	/// &lt;/summary&gt;
+	public class TypesHaveNoPublicInstanceFields : AbstractReflectionRule, IFieldRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Types do not have externally visible instance fields&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Public or internal instance fields are a design flaw and should be avoided. Use properties instead. They are more flexible and hide the implementation details of the underlying data. Furthermore, properties do not have a performance penalty.&quot;;
+			}
+		}
+		
+		public TypesHaveNoPublicInstanceFields()
+		{
+			base.certainty = 90;
+		}
+		
+		public Resolution Check(Module module, FieldInfo field)
+		{
+			if (!field.IsStatic &amp;&amp; (field.IsPublic || field.IsAssembly)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Make the field &lt;code&gt;{0}&lt;/code&gt; in the type &lt;code&gt;{1}&lt;/code&gt; private or protected. Provide a public or internal property if the field should be accessed from outside.&quot;, field.Name, field.DeclaringType.FullName), NamingUtilities.Combine (field.DeclaringType.FullName, field.Name));
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypesHaveNoPublicInstanceFieldsTest
+	{
+		class A {
+			int a;
+			protected string b;
+			public static int c = 12;
+			public int AA {
+				get {
+					return a;
+				}
+				set {
+					a = value;
+				}
+			}
+			public string B {
+				get {
+					return b;
+				}
+				set {
+					b = value;
+				}
+			}
+		}
+		[Test]
+		public void TestCorrectFields()
+		{
+			TypesHaveNoPublicInstanceFields rule = new TypesHaveNoPublicInstanceFields();
+			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;a&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
+			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;b&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
+			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;c&quot;, BindingFlags.Public | BindingFlags.Static)));
+		}
+		
+		class B {
+			public int a = 5;
+			internal string b =&quot;&quot;;
+		}
+		
+		[Test]
+		public void TestIncorrectFields()
+		{
+			TypesHaveNoPublicInstanceFields rule = new TypesHaveNoPublicInstanceFields();
+			Assertion.AssertNotNull(rule.Check(null, typeof(B).GetField(&quot;a&quot;, BindingFlags.Public | BindingFlags.Instance)));
+			Assertion.AssertNotNull(rule.Check(null, typeof(B).GetField(&quot;b&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesShouldBeInNamespacesRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesShouldBeInNamespacesRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesShouldBeInNamespacesRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,76 +1,77 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of TypesShouldBeInNamespaces.	
-	/// &lt;/summary&gt;
-	public class TypesShouldBeInNamespacesRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesShouldBeInNamespaces.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesShouldBeInNamespaces.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (type.Namespace == null || type.Namespace.Length == 0) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesShouldBeInNamespaces.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-class OutsideNamespace
-{
-	
-}
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class TypesShouldBeInNamespacesRuleTest
-	{
-		interface ICorrectInterface
-		{
-		}
-		[Test]
-		public void TestCorrectAttribute()
-		{
-			TypesShouldBeInNamespacesRule rule = new TypesShouldBeInNamespacesRule();
-			Assertion.AssertNull(rule.Check(typeof(System.ICloneable)));
-			Assertion.AssertNull(rule.Check(typeof(TypesShouldBeInNamespacesRuleTest)));
-			Assertion.AssertNull(rule.Check(typeof(ICorrectInterface)));
-		}
-		
-		[Test]
-		public void TestIncorrectAttribute()
-		{
-			TypesShouldBeInNamespacesRule rule = new TypesShouldBeInNamespacesRule();
-			Assertion.AssertNotNull(rule.Check(typeof(OutsideNamespace)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of TypesShouldBeInNamespaces.	
+	/// &lt;/summary&gt;
+	public class TypesShouldBeInNamespacesRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Types should be defined in namespaces&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type should always be defined inside a namespace to avoid naming collisions.&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.Namespace == null || type.Namespace.Length == 0) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Declare &lt;code&gt;{0}&lt;/code&gt; inside a namespace.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+class OutsideNamespace
+{
+	
+}
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypesShouldBeInNamespacesRuleTest
+	{
+		interface ICorrectInterface
+		{
+		}
+		[Test]
+		public void TestCorrectAttribute()
+		{
+			TypesShouldBeInNamespacesRule rule = new TypesShouldBeInNamespacesRule();
+			Assertion.AssertNull(rule.Check(typeof(System.ICloneable)));
+			Assertion.AssertNull(rule.Check(typeof(TypesShouldBeInNamespacesRuleTest)));
+			Assertion.AssertNull(rule.Check(typeof(ICorrectInterface)));
+		}
+		
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			TypesShouldBeInNamespacesRule rule = new TypesShouldBeInNamespacesRule();
+			Assertion.AssertNotNull(rule.Check(typeof(OutsideNamespace)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IAssemblyRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IAssemblyRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IAssemblyRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IAssemblyRule.	
-	/// &lt;/summary&gt;
-	public interface IAssemblyRule : IReflectionRule
-	{
-		Resolution Check(Assembly assembly);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IAssemblyRule.	
+	/// &lt;/summary&gt;
+	public interface IAssemblyRule : IReflectionRule
+	{
+		Resolution Check(Assembly assembly);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IConstructorRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IConstructorRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IConstructorRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IConstructorRule.	
-	/// &lt;/summary&gt;
-	public interface IConstructorRule : IReflectionRule
-	{
-		Resolution Check(ConstructorInfo constructor);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IConstructorRule.	
+	/// &lt;/summary&gt;
+	public interface IConstructorRule : IReflectionRule
+	{
+		Resolution Check(ConstructorInfo constructor);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IEventRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IEventRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IEventRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IEventRule.	
-	/// &lt;/summary&gt;
-	public interface IEventRule : IReflectionRule
-	{
-		Resolution Check(EventInfo evnt);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IEventRule.	
+	/// &lt;/summary&gt;
+	public interface IEventRule : IReflectionRule
+	{
+		Resolution Check(EventInfo evnt);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IFieldRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IFieldRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IFieldRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IFieldRule.	
-	/// &lt;/summary&gt;
-	public interface IFieldRule : IReflectionRule
-	{
-		Resolution Check(Module module, FieldInfo field);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IFieldRule.	
+	/// &lt;/summary&gt;
+	public interface IFieldRule : IReflectionRule
+	{
+		Resolution Check(Module module, FieldInfo field);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMemberRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMemberRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMemberRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IMemberRule.	
-	/// &lt;/summary&gt;
-	public interface IMemberRule : IReflectionRule
-	{
-		 Resolution Check(Module module, MemberInfo member);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IMemberRule.	
+	/// &lt;/summary&gt;
+	public interface IMemberRule : IReflectionRule
+	{
+		 Resolution Check(Module module, MemberInfo member);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodBaseRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodBaseRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodBaseRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IMethodBaseRule.	
-	/// &lt;/summary&gt;
-	public interface IMethodBaseRule : IReflectionRule
-	{
-		Resolution Check(Module module, MethodBase methodBase);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IMethodBaseRule.	
+	/// &lt;/summary&gt;
+	public interface IMethodBaseRule : IReflectionRule
+	{
+		Resolution Check(Module module, MethodBase methodBase);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IMethodRule.	
-	/// &lt;/summary&gt;
-	public interface IMethodRule : IReflectionRule
-	{
-		Resolution Check(Module module, MethodInfo method);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IMethodRule.	
+	/// &lt;/summary&gt;
+	public interface IMethodRule : IReflectionRule
+	{
+		Resolution Check(Module module, MethodInfo method);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IModuleRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IModuleRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IModuleRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IModuleRule.	
-	/// &lt;/summary&gt;
-	public interface IModuleRule : IReflectionRule
-	{
-		Resolution Check(Module module);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IModuleRule.	
+	/// &lt;/summary&gt;
+	public interface IModuleRule : IReflectionRule
+	{
+		Resolution Check(Module module);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/INamespaceRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/INamespaceRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/INamespaceRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,21 +1,21 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of INamespaceRule.	
-	/// &lt;/summary&gt;
-	public interface INamespaceRule : IReflectionRule
-	{
-		Resolution Check(string namespaceName, ICollection types);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of INamespaceRule.	
+	/// &lt;/summary&gt;
+	public interface INamespaceRule : IReflectionRule
+	{
+		Resolution Check(string namespaceName, ICollection types);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IParameterRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IParameterRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IParameterRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IParameterRule.	
-	/// &lt;/summary&gt;
-	public interface IParameterRule : IReflectionRule
-	{
-		Resolution Check(Module module, ParameterInfo param);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IParameterRule.	
+	/// &lt;/summary&gt;
+	public interface IParameterRule : IReflectionRule
+	{
+		Resolution Check(Module module, ParameterInfo param);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IPropertyRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IPropertyRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IPropertyRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IPropertyRule.	
-	/// &lt;/summary&gt;
-	public interface IPropertyRule : IReflectionRule
-	{
-		Resolution Check(PropertyInfo property);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IPropertyRule.	
+	/// &lt;/summary&gt;
+	public interface IPropertyRule : IReflectionRule
+	{
+		Resolution Check(PropertyInfo property);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IReflectionRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IReflectionRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IReflectionRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,31 +1,31 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IAssemblyRule.	
-	/// &lt;/summary&gt;
-	public interface IReflectionRule : IRule
-	{
-		ProtectionLevels MemberProtectionLevel {
-			get;
-		}
-		
-		ProtectionLevels NestedTypeProtectionLevel {
-			get;
-		}
-		
-		ProtectionLevels TypeProtectionLevel {
-			get;
-		}
-		
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IAssemblyRule.	
+	/// &lt;/summary&gt;
+	public interface IReflectionRule : IRule
+	{
+		ProtectionLevels MemberProtectionLevel {
+			get;
+		}
+		
+		ProtectionLevels NestedTypeProtectionLevel {
+			get;
+		}
+		
+		ProtectionLevels TypeProtectionLevel {
+			get;
+		}
+		
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,37 +1,37 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IRule.	
-	/// &lt;/summary&gt;
-	public interface IRule
-	{
-		void EndAnalysis();
-		void StartAnalysis();
-		
-		PriorityLevel PriorityLevel {
-			get;
-		}
-		
-		int Certainty {
-			get;
-		}
-		
-		string Description {
-			get;
-		}
-		
-		string Details {
-			get;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IRule.	
+	/// &lt;/summary&gt;
+	public interface IRule
+	{
+		void EndAnalysis();
+		void StartAnalysis();
+		
+		PriorityLevel PriorityLevel {
+			get;
+		}
+		
+		int Certainty {
+			get;
+		}
+		
+		string Description {
+			get;
+		}
+		
+		string Details {
+			get;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ITypeRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ITypeRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ITypeRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,20 +1,20 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of ITypeRule.	
-	/// &lt;/summary&gt;
-	public interface ITypeRule : IReflectionRule
-	{
-		Resolution Check(Type type);
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of ITypeRule.	
+	/// &lt;/summary&gt;
+	public interface ITypeRule : IReflectionRule
+	{
+		Resolution Check(Type type);
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/AttributeSuffixIsAttributeRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/AttributeSuffixIsAttributeRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/AttributeSuffixIsAttributeRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,73 +1,74 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class AttributeSuffixIsAttributeRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AttributeSuffixIsAttribute.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AttributeSuffixIsAttribute.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (type.IsSubclassOf(typeof(System.Attribute)) &amp;&amp; !type.Name.EndsWith(&quot;Attribute&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AttributeSuffixIsAttribute.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class AttributeSuffixIsAttributeRuleTest
-	{
-		class MyAttribute : System.Attribute
-		{
-		}
-		[Test]
-		public void TestCorrectAttribute()
-		{
-			AttributeSuffixIsAttributeRule rule = new AttributeSuffixIsAttributeRule();
-			Assertion.AssertNull(rule.Check(typeof(MyAttribute)));
-		}
-		
-		class MyAttr : System.Attribute
-		{
-		}
-		[Test]
-		public void TestIncorrectAttribute()
-		{
-			AttributeSuffixIsAttributeRule rule = new AttributeSuffixIsAttributeRule();
-			Assertion.AssertNotNull(rule.Check(typeof(MyAttr)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class AttributeSuffixIsAttributeRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Attribute names have the suffix 'Attribute'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that extends &lt;code&gt;&lt;a href='<A HREF="help://types/System.Attribute'">help://types/System.Attribute'</A>&gt;Attribute&lt;/a&gt;&lt;/code&gt; is an attribute and its name should always end with &lt;i&gt;Attribute&lt;/i&gt; like in &lt;code&gt;CategoryAttribute&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsSubclassOf(typeof(System.Attribute)) &amp;&amp; !type.Name.EndsWith(&quot;Attribute&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;I&gt;Attribute&lt;/I&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class AttributeSuffixIsAttributeRuleTest
+	{
+		class MyAttribute : System.Attribute
+		{
+		}
+		[Test]
+		public void TestCorrectAttribute()
+		{
+			AttributeSuffixIsAttributeRule rule = new AttributeSuffixIsAttributeRule();
+			Assertion.AssertNull(rule.Check(typeof(MyAttribute)));
+		}
+		
+		class MyAttr : System.Attribute
+		{
+		}
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			AttributeSuffixIsAttributeRule rule = new AttributeSuffixIsAttributeRule();
+			Assertion.AssertNotNull(rule.Check(typeof(MyAttr)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/CheckCollectionSuffix.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/CheckCollectionSuffix.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/CheckCollectionSuffix.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,140 +1,143 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of CheckCollectionSuffix.	
-	/// &lt;/summary&gt;
-	public class CheckCollectionSuffix : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Details}&quot;;
-			}
-		}
-		
-		public CheckCollectionSuffix()
-		{
-			base.certainty = 90;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if ((typeof(ICollection).IsAssignableFrom(type) || typeof(IEnumerable).IsAssignableFrom(type)) &amp;&amp; !typeof(System.Collections.IDictionary).IsAssignableFrom(type)) {
-				if (typeof(Queue).IsAssignableFrom(type)) {
-					if (!type.Name.EndsWith(&quot;Queue&quot;)) {
-						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Resolution1}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }} );
-					}
-				} else if (typeof(Stack).IsAssignableFrom(type)) {
-					if (!type.Name.EndsWith(&quot;Stack&quot;)) {
-						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Resolution2}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-					}
-				} else {
-					if (!type.Name.EndsWith(&quot;Collection&quot;)) {
-						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Resolution3}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-					}
-				}
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class CheckCollectionSuffixTest
-	{
-		#region Collection suffix tests
-		class MyCollection : System.Collections.ArrayList
-		{
-		}
-		class MyDictionary : System.Collections.Hashtable
-		{
-		}
-		[Test]
-		public void TestCorrectCollection()
-		{
-			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
-			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyCollection)));
-			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyDictionary)));
-			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(CheckCollectionSuffixTest)));
-		}
-		
-		class MyColl : System.Collections.ArrayList
-		{
-		}
-		[Test]
-		public void TestIncorrectCollection()
-		{
-			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
-			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MyColl)));
-		}
-		#endregion
-		
-		#region Queue suffix tests
-		class MyQueue : System.Collections.Queue
-		{
-		}
-		[Test]
-		public void TestCorrectQueue()
-		{
-			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
-			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyQueue)));
-		}
-		
-		class MyQWEQWEQ : System.Collections.Queue
-		{
-		}
-		[Test]
-		public void TestIncorrectQueue()
-		{
-			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
-			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MyQWEQWEQ)));
-		}
-		#endregion 
-		
-		#region Stack suffix tests
-		class MyStack : System.Collections.Stack
-		{
-		}
-		[Test]
-		public void TestCorrectStack()
-		{
-			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
-			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyStack)));
-		}
-		class MySfwefew : System.Collections.Stack
-		{
-		}
-		[Test]
-		public void TestIncorrectStack()
-		{
-			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
-			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MySfwefew)));
-		}
-		#endregion
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of CheckCollectionSuffix.	
+	/// &lt;/summary&gt;
+	public class CheckCollectionSuffix : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Collections names have the suffix 'Collection', 'Queue' or 'Stack'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that implements &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.ICollection'">help://types/System.Collections.ICollection'</A>&gt;ICollection&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.IEnumerable'">help://types/System.Collections.IEnumerable'</A>&gt;IEnumerable&lt;/a&gt;&lt;/code&gt; is a collection and its name should use the suffix &lt;i&gt;Collection&lt;/i&gt;.&lt;BR&gt;An exception to this rule are queues (extend &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.Queue'">help://types/System.Collections.Queue'</A>&gt;Queue&lt;/a&gt;&lt;/code&gt;) which should use the suffix &lt;i&gt;Queue&lt;/i&gt; and stacks (extend &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.Stack'">help://types/System.Collections.Stack'</A>&gt;Stack&lt;/a&gt;&lt;/code&gt;) that should use the &lt;i&gt;Stack&lt;/i&gt; suffix. &lt;BR&gt;For example: &lt;code&gt;StringCollection&lt;/code&gt;, &lt;code&gt;StateStack&lt;/code&gt; or &lt;code&gt;EventQueue&lt;/code&gt; are valid names.&quot;;
+			}
+		}
+		
+		public CheckCollectionSuffix()
+		{
+			base.certainty = 90;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if ((typeof(ICollection).IsAssignableFrom(type) || typeof(IEnumerable).IsAssignableFrom(type)) &amp;&amp; !typeof(System.Collections.IDictionary).IsAssignableFrom(type)) {
+				if (typeof(Queue).IsAssignableFrom(type)) {
+					if (!type.Name.EndsWith(&quot;Queue&quot;)) {
+						// FIXME: I18N
+						return new Resolution (this, String.Format (&quot;Change the name of the queue &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;i&gt;Queue&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+					}
+				} else if (typeof(Stack).IsAssignableFrom(type)) {
+					if (!type.Name.EndsWith(&quot;Stack&quot;)) {
+						// FIXME: I18N
+						return new Resolution (this, String.Format (&quot;Change the name of the queue &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;i&gt;Stack&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+					}
+				} else {
+					if (!type.Name.EndsWith(&quot;Collection&quot;)) {
+						// FIXME: I18N
+						return new Resolution (this, String.Format (&quot;Change the name of the queue &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;i&gt;Collection&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+					}
+				}
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class CheckCollectionSuffixTest
+	{
+		#region Collection suffix tests
+		class MyCollection : System.Collections.ArrayList
+		{
+		}
+		class MyDictionary : System.Collections.Hashtable
+		{
+		}
+		[Test]
+		public void TestCorrectCollection()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyCollection)));
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyDictionary)));
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(CheckCollectionSuffixTest)));
+		}
+		
+		class MyColl : System.Collections.ArrayList
+		{
+		}
+		[Test]
+		public void TestIncorrectCollection()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MyColl)));
+		}
+		#endregion
+		
+		#region Queue suffix tests
+		class MyQueue : System.Collections.Queue
+		{
+		}
+		[Test]
+		public void TestCorrectQueue()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyQueue)));
+		}
+		
+		class MyQWEQWEQ : System.Collections.Queue
+		{
+		}
+		[Test]
+		public void TestIncorrectQueue()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MyQWEQWEQ)));
+		}
+		#endregion 
+		
+		#region Stack suffix tests
+		class MyStack : System.Collections.Stack
+		{
+		}
+		[Test]
+		public void TestCorrectStack()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyStack)));
+		}
+		class MySfwefew : System.Collections.Stack
+		{
+		}
+		[Test]
+		public void TestIncorrectStack()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MySfwefew)));
+		}
+		#endregion
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,73 +1,74 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of DelegatesHaveNoDelegateSuffix.	
-	/// &lt;/summary&gt;
-	public class DelegatesHaveNoDelegateSuffix : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DelegatesHaveNoDelegateSuffix.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DelegatesHaveNoDelegateSuffix.Details}&quot;;
-			}
-		}
-		
-		public DelegatesHaveNoDelegateSuffix()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (type.IsSubclassOf(typeof(System.Delegate)) &amp;&amp; type.Name.EndsWith(&quot;Delegate&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DelegatesHaveNoDelegateSuffix.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class DelegatesHaveNoDelegateSuffixTest
-	{
-		delegate void MyDelegateWithoutDelegateSuffix();
-		[Test]
-		public void TestCorrectDelegate()
-		{
-			DelegatesHaveNoDelegateSuffix delegatesHaveNoDelegateSuffix = new DelegatesHaveNoDelegateSuffix();
-			Assertion.AssertNull(delegatesHaveNoDelegateSuffix.Check(typeof(MyDelegateWithoutDelegateSuffix)));
-		}
-		
-		delegate void MyDelegateWithDelegateSuffixDelegate();
-		[Test]
-		public void TestIncorrectDelegate()
-		{
-			DelegatesHaveNoDelegateSuffix delegatesHaveNoDelegateSuffix = new DelegatesHaveNoDelegateSuffix();
-			Assertion.AssertNotNull(delegatesHaveNoDelegateSuffix.Check(typeof(MyDelegateWithDelegateSuffixDelegate)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of DelegatesHaveNoDelegateSuffix.	
+	/// &lt;/summary&gt;
+	public class DelegatesHaveNoDelegateSuffix : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Delegate names do not have the suffix 'Delegate'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Do not use the &lt;i&gt;Delegate&lt;/i&gt; suffix for delegate names. You may consider using a callback instead.&quot;;
+			}
+		}
+		
+		public DelegatesHaveNoDelegateSuffix()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsSubclassOf(typeof(System.Delegate)) &amp;&amp; type.Name.EndsWith(&quot;Delegate&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Rename the delegate &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Delegate&lt;/i&gt;. Or replace it with a callback.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class DelegatesHaveNoDelegateSuffixTest
+	{
+		delegate void MyDelegateWithoutDelegateSuffix();
+		[Test]
+		public void TestCorrectDelegate()
+		{
+			DelegatesHaveNoDelegateSuffix delegatesHaveNoDelegateSuffix = new DelegatesHaveNoDelegateSuffix();
+			Assertion.AssertNull(delegatesHaveNoDelegateSuffix.Check(typeof(MyDelegateWithoutDelegateSuffix)));
+		}
+		
+		delegate void MyDelegateWithDelegateSuffixDelegate();
+		[Test]
+		public void TestIncorrectDelegate()
+		{
+			DelegatesHaveNoDelegateSuffix delegatesHaveNoDelegateSuffix = new DelegatesHaveNoDelegateSuffix();
+			Assertion.AssertNotNull(delegatesHaveNoDelegateSuffix.Check(typeof(MyDelegateWithDelegateSuffixDelegate)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,74 +1,75 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of DelegatesHaveNoDelegateSuffix.	
-	/// &lt;/summary&gt;
-	public class DictionaryTypeSuffixIsDictionary : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DictionaryTypeSuffixIsDictionary.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DictionaryTypeSuffixIsDictionary.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (typeof(System.Collections.IDictionary).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Dictionary&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DictionaryTypeSuffixIsDictionary.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class DictionaryTypeSuffixIsDictionaryTest
-	{
-		class CorrectDictionary : System.Collections.Hashtable
-		{
-		}
-		[Test]
-		public void TestCorrectDictionary()
-		{
-			DictionaryTypeSuffixIsDictionary dictionaryTypeSuffixIsDictionary = new DictionaryTypeSuffixIsDictionary();
-			Assertion.AssertNull(dictionaryTypeSuffixIsDictionary.Check(typeof(CorrectDictionary)));
-		}
-		
-		class IncorrectDictionaryWrongSuffix : System.Collections.Hashtable
-		{
-		}
-		[Test]
-		public void TestIncorrectDictionary()
-		{
-			DictionaryTypeSuffixIsDictionary dictionaryTypeSuffixIsDictionary = new DictionaryTypeSuffixIsDictionary();
-			Assertion.AssertNotNull(dictionaryTypeSuffixIsDictionary.Check(typeof(IncorrectDictionaryWrongSuffix)));
-		}
-		
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of DictionaryTypeSuffixIsDictionary.	
+	/// &lt;/summary&gt;
+	public class DictionaryTypeSuffixIsDictionary : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Dictionary names have the suffix 'Dictionary'.&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that implements &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.IDictionary'">help://types/System.Collections.IDictionary'</A>&gt;IDictionary&lt;/a&gt;&lt;/code&gt; is a dictonary and should use the suffix &lt;i&gt;Dictionary&lt;/i&gt; like in &lt;code&gt;HybridDictionary&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.Collections.IDictionary).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Dictionary&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the dictionary &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;i&gt;Dictionary&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class DictionaryTypeSuffixIsDictionaryTest
+	{
+		class CorrectDictionary : System.Collections.Hashtable
+		{
+		}
+		[Test]
+		public void TestCorrectDictionary()
+		{
+			DictionaryTypeSuffixIsDictionary dictionaryTypeSuffixIsDictionary = new DictionaryTypeSuffixIsDictionary();
+			Assertion.AssertNull(dictionaryTypeSuffixIsDictionary.Check(typeof(CorrectDictionary)));
+		}
+		
+		class IncorrectDictionaryWrongSuffix : System.Collections.Hashtable
+		{
+		}
+		[Test]
+		public void TestIncorrectDictionary()
+		{
+			DictionaryTypeSuffixIsDictionary dictionaryTypeSuffixIsDictionary = new DictionaryTypeSuffixIsDictionary();
+			Assertion.AssertNotNull(dictionaryTypeSuffixIsDictionary.Check(typeof(IncorrectDictionaryWrongSuffix)));
+		}
+		
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EnumsHaveNoEnumSuffix.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EnumsHaveNoEnumSuffix.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EnumsHaveNoEnumSuffix.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,80 +1,81 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of DelegatesHaveNoDelegateSuffix.	
-	/// &lt;/summary&gt;
-	public class EnumsHaveNoEnumSuffix : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EnumsHaveNoEnumSuffix.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EnumsHaveNoEnumSuffix.Details}&quot;;
-			}
-		}
-		
-		public EnumsHaveNoEnumSuffix()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (type.IsSubclassOf(typeof(System.Enum)) &amp;&amp; type.Name.EndsWith(&quot;Enum&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EnumsHaveNoEnumSuffix.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EnumsHaveNoEnumSuffixTest
-	{
-		enum CorrectEnumWithAnotherSuffix
-		{
-			A, B, C
-		}
-		[Test]
-		public void TestCorrectEnum()
-		{
-			EnumsHaveNoEnumSuffix enumsHaveNoEnumSuffix = new EnumsHaveNoEnumSuffix();
-			Assertion.AssertNull(enumsHaveNoEnumSuffix.Check(typeof(CorrectEnumWithAnotherSuffix)));
-		}
-		
-		enum IncorrectEnum
-		{
-			A, B, C
-		}
-		[Test]
-		public void TestIncorrectDictionary()
-		{
-			EnumsHaveNoEnumSuffix enumsHaveNoEnumSuffix = new EnumsHaveNoEnumSuffix();
-			Assertion.AssertNotNull(enumsHaveNoEnumSuffix.Check(typeof(IncorrectEnum)));
-		}
-		
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EnumsHaveNoEnumSuffix.	
+	/// &lt;/summary&gt;
+	public class EnumsHaveNoEnumSuffix : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Enumeration names do not have the suffix 'Enum'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Do not use the &lt;i&gt;Enum&lt;/i&gt; suffix for enumeration names.&quot;;
+			}
+		}
+		
+		public EnumsHaveNoEnumSuffix()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsSubclassOf(typeof(System.Enum)) &amp;&amp; type.Name.EndsWith(&quot;Enum&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Rename the enumeration &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Enum&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EnumsHaveNoEnumSuffixTest
+	{
+		enum CorrectEnumWithAnotherSuffix
+		{
+			A, B, C
+		}
+		[Test]
+		public void TestCorrectEnum()
+		{
+			EnumsHaveNoEnumSuffix enumsHaveNoEnumSuffix = new EnumsHaveNoEnumSuffix();
+			Assertion.AssertNull(enumsHaveNoEnumSuffix.Check(typeof(CorrectEnumWithAnotherSuffix)));
+		}
+		
+		enum IncorrectEnum
+		{
+			A, B, C
+		}
+		[Test]
+		public void TestIncorrectDictionary()
+		{
+			EnumsHaveNoEnumSuffix enumsHaveNoEnumSuffix = new EnumsHaveNoEnumSuffix();
+			Assertion.AssertNotNull(enumsHaveNoEnumSuffix.Check(typeof(IncorrectEnum)));
+		}
+		
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,74 +1,75 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class EventArgsSuffixIsEventArgsRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventArgsSuffixIsEventArgs.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventArgsSuffixIsEventArgs.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (typeof(System.EventArgs).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;EventArgs&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventArgsSuffixIsEventArgs.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventArgsSuffixIsEventArgsRuleTest
-	{
-		class CorrectEventArgs : System.EventArgs
-		{
-		}
-		[Test]
-		public void TestCorrectEventArgs()
-		{
-			EventArgsSuffixIsEventArgsRule rule = new EventArgsSuffixIsEventArgsRule();
-			Assertion.AssertNull(rule.Check(typeof(CorrectEventArgs)));
-		}
-		
-		class IncorrectEventArgsWithWrongSuffix : System.EventArgs
-		{
-		}
-		[Test]
-		public void TestIncorrectEventArgs()
-		{
-			EventArgsSuffixIsEventArgsRule rule = new EventArgsSuffixIsEventArgsRule();
-			Assertion.AssertNotNull(rule.Check(typeof(IncorrectEventArgsWithWrongSuffix)));
-		}
-		
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventArgsSuffixIsEventArgs
+	/// &lt;/summary&gt;
+	public class EventArgsSuffixIsEventArgsRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;EventArgs names have the suffix 'EventArgs'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that extends &lt;code&gt;&lt;a href='<A HREF="help://types/System.EventArgs'">help://types/System.EventArgs'</A>&gt;EventArgs&lt;/a&gt;&lt;/code&gt; is an event argument and should use the suffix &lt;i&gt;EventArgs&lt;/i&gt; like in &lt;code&gt;MouseEventArgs&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.EventArgs).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;EventArgs&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Rename the event argument &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;i&gt;EventArgs&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventArgsSuffixIsEventArgsRuleTest
+	{
+		class CorrectEventArgs : System.EventArgs
+		{
+		}
+		[Test]
+		public void TestCorrectEventArgs()
+		{
+			EventArgsSuffixIsEventArgsRule rule = new EventArgsSuffixIsEventArgsRule();
+			Assertion.AssertNull(rule.Check(typeof(CorrectEventArgs)));
+		}
+		
+		class IncorrectEventArgsWithWrongSuffix : System.EventArgs
+		{
+		}
+		[Test]
+		public void TestIncorrectEventArgs()
+		{
+			EventArgsSuffixIsEventArgsRule rule = new EventArgsSuffixIsEventArgsRule();
+			Assertion.AssertNotNull(rule.Check(typeof(IncorrectEventArgsWithWrongSuffix)));
+		}
+		
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventFirstParameterNameIsSender.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventFirstParameterNameIsSender.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventFirstParameterNameIsSender.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,92 +1,93 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of EventFirstParameterNameIsSender.	
-	/// &lt;/summary&gt;
-	public class EventFirstParameterNameIsSender : AbstractReflectionRule, IEventRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterNameIsSender.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterNameIsSender.Details}&quot;;
-			}
-		}
-		
-		public EventFirstParameterNameIsSender()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(EventInfo evnt)
-		{
-			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
-			ParameterInfo[] parameters = invokeMethod.GetParameters();
-
-			if (parameters.Length &gt; 0 &amp;&amp; parameters[0].Name != &quot;sender&quot;) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterNameIsSender.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, { &quot;OldParameterName&quot;, parameters[0].Name }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventFirstParameterNameIsSenderTest
-	{
-		public delegate void CorrectEventHandler(object sender, EventArgs e);
-		public event CorrectEventHandler CorrectEvent;
-		protected virtual void OnCorrectEvent(EventArgs e)
-		{
-			if (CorrectEvent != null) {
-				CorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestCorrectEventHandler()
-		{
-			EventFirstParameterNameIsSender eventFirstParameterNameIsSender = new EventFirstParameterNameIsSender();
-			Assertion.AssertNull(eventFirstParameterNameIsSender.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
-		}
-		
-		public delegate void IncorrectEventHandler(object s, EventArgs e);
-		public event IncorrectEventHandler IncorrectEvent;
-		protected virtual void OnIncorrectEvent(EventArgs e)
-		{
-			if (IncorrectEvent != null) {
-				IncorrectEvent(this, e);
-			}
-		}
-		
-		[Test]
-		public void TestIncorrectEventHandler()
-		{
-			EventFirstParameterNameIsSender eventFirstParameterNameIsSender = new EventFirstParameterNameIsSender();
-			Assertion.AssertNotNull(eventFirstParameterNameIsSender.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventFirstParameterNameIsSender.	
+	/// &lt;/summary&gt;
+	public class EventFirstParameterNameIsSender : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;First parameter in events is named 'sender'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;As a convention in .NET events have two parameters a sender which must be called &lt;i&gt;sender&lt;/i&gt; and an event data object. The sender must always be from the type &lt;code&gt;&lt;a href='<A HREF="help://types/System.Object'">help://types/System.Object'</A>&gt;object&lt;/a&gt;&lt;/code&gt; and never a specialized type.&lt;BR&gt;For example: &lt;code&gt;void MouseEventHandler(object sender, MouseEventArgs e);&lt;/code&gt;&quot;;
+			}
+		}
+		
+		public EventFirstParameterNameIsSender()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length &gt; 0 &amp;&amp; parameters[0].Name != &quot;sender&quot;) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Rename the first parameter name of the event &lt;code&gt;{0}&lt;/code&gt; from &lt;i&gt;{1}&lt;/i&gt; to &lt;i&gt;sender&lt;/i&gt;.&quot;, evnt.EventHandlerType.FullName, parameters[0].Name), evnt.EventHandlerType.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventFirstParameterNameIsSenderTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventFirstParameterNameIsSender eventFirstParameterNameIsSender = new EventFirstParameterNameIsSender();
+			Assertion.AssertNull(eventFirstParameterNameIsSender.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(object s, EventArgs e);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventFirstParameterNameIsSender eventFirstParameterNameIsSender = new EventFirstParameterNameIsSender();
+			Assertion.AssertNotNull(eventFirstParameterNameIsSender.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,95 +1,96 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of EventHandlerSuffixIsEventHandler.	
-	/// &lt;/summary&gt;
-	public class EventHandlerSuffixIsEventHandler : AbstractReflectionRule, IEventRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlerSuffixIsEventHandler.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlerSuffixIsEventHandler.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(EventInfo evnt)
-		{
-			if (!evnt.EventHandlerType.Name.EndsWith(&quot;EventHandler&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlerSuffixIsEventHandler.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventsDoNotHaveBeforeOrAfterPrefixTest
-	{
-		public event EventHandler CorrectEvent;
-		protected virtual void OnCorrectEvent(EventArgs e)
-		{
-			if (CorrectEvent != null) {
-				CorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestCorrectEventHandler()
-		{
-			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
-			Assertion.AssertNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
-		}
-
-		public event EventHandler BeforeIncorrectEvent;
-		protected virtual void OnBeforeIncorrectEvent(EventArgs e)
-		{
-			if (BeforeIncorrectEvent != null) {
-				BeforeIncorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestIncorrectEventHandler1()
-		{
-			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
-			Assertion.AssertNotNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;BeforeIncorrectEvent&quot;)));
-		}
-		
-		public event EventHandler AfterIncorrectEvent;
-		protected virtual void OnAfterIncorrectEvent(EventArgs e)
-		{
-			if (AfterIncorrectEvent != null) {
-				AfterIncorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestIncorrectEventHandler2()
-		{
-			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
-			Assertion.AssertNotNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;AfterIncorrectEvent&quot;)));
-		}
-		
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventHandlerSuffixIsEventHandler.	
+	/// &lt;/summary&gt;
+	public class EventHandlerSuffixIsEventHandler : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Event handler names have the suffix 'EventHandler'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;An event handler delegate name should use the suffix &lt;i&gt;EventHandler&lt;/i&gt; like in &lt;code&gt;DragAndDropEventHandler&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			if (!evnt.EventHandlerType.Name.EndsWith(&quot;EventHandler&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the member &lt;code&gt;{0}&lt;/code&gt; in the type &lt;code&gt;{1}&lt;/code&gt; so that it does not end with &lt;i&gt;EventHandler&lt;/i&gt;.&quot;, evnt.EventHandlerType.FullName, evnt.DeclaringType.FullName), evnt.EventHandlerType.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventsDoNotHaveBeforeOrAfterPrefixTest
+	{
+		public event EventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
+			Assertion.AssertNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+
+		public event EventHandler BeforeIncorrectEvent;
+		protected virtual void OnBeforeIncorrectEvent(EventArgs e)
+		{
+			if (BeforeIncorrectEvent != null) {
+				BeforeIncorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestIncorrectEventHandler1()
+		{
+			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
+			Assertion.AssertNotNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;BeforeIncorrectEvent&quot;)));
+		}
+		
+		public event EventHandler AfterIncorrectEvent;
+		protected virtual void OnAfterIncorrectEvent(EventArgs e)
+		{
+			if (AfterIncorrectEvent != null) {
+				AfterIncorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestIncorrectEventHandler2()
+		{
+			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
+			Assertion.AssertNotNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;AfterIncorrectEvent&quot;)));
+		}
+		
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventSecondParameterNameIsE.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventSecondParameterNameIsE.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventSecondParameterNameIsE.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,91 +1,92 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of EventFirstParameterNameIsSender.	
-	/// &lt;/summary&gt;
-	public class EventSecondParameterNameIsE : AbstractReflectionRule, IEventRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterNameIsE.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterNameIsE.Details}&quot;;
-			}
-		}
-		
-		public EventSecondParameterNameIsE()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(EventInfo evnt)
-		{
-			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
-			ParameterInfo[] parameters = invokeMethod.GetParameters();
-
-			if (parameters.Length &gt; 1 &amp;&amp; parameters[1].Name != &quot;e&quot;) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterNameIsE.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, { &quot;OldParameterName&quot;, parameters[1].Name }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventSecondParameterNameIsETest
-	{
-		public delegate void CorrectEventHandler(object sender, EventArgs e);
-		public event CorrectEventHandler CorrectEvent;
-		protected virtual void OnCorrectEvent(EventArgs e)
-		{
-			if (CorrectEvent != null) {
-				CorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestCorrectEventHandler()
-		{
-			EventSecondParameterNameIsE eventSecondParameterNameIsE = new EventSecondParameterNameIsE();
-			Assertion.AssertNull(eventSecondParameterNameIsE.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
-		}
-		
-		public delegate void IncorrectEventHandler(object sender, EventArgs notE);
-		public event IncorrectEventHandler IncorrectEvent;
-		protected virtual void OnIncorrectEvent(EventArgs e)
-		{
-			if (IncorrectEvent != null) {
-				IncorrectEvent(this, e);
-			}
-		}
-		
-		[Test]
-		public void TestIncorrectEventHandler()
-		{
-			EventSecondParameterNameIsE eventSecondParameterNameIsE = new EventSecondParameterNameIsE();
-			Assertion.AssertNotNull(eventSecondParameterNameIsE.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventSecondParameterNameIsE	
+	/// &lt;/summary&gt;
+	public class EventSecondParameterNameIsE : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Second parameter in events is named 'e'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;As a convention in .NET events have two parameters a sender and an event data object which is called &lt;i&gt;e&lt;/i&gt;. The event data object must be extend from the type &lt;code&gt;&lt;a href='<A HREF="help://types/System.EventArgs'">help://types/System.EventArgs'</A>&gt;EventArgs&lt;/a&gt;&lt;/code&gt;.&lt;BR&gt;For example: &lt;code&gt;void MouseEventHandler(object sender, MouseEventArgs e);&lt;/code&gt;&quot;;
+			}
+		}
+		
+		public EventSecondParameterNameIsE()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length &gt; 1 &amp;&amp; parameters[1].Name != &quot;e&quot;) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Rename the second parameter name in the event &lt;code&gt;{0}&lt;/code&gt; from &lt;i&gt;{1}&lt;/i&gt; to &lt;i&gt;e&lt;/i&gt;.&quot;, evnt.EventHandlerType.FullName, parameters[1].Name), evnt.EventHandlerType.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventSecondParameterNameIsETest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventSecondParameterNameIsE eventSecondParameterNameIsE = new EventSecondParameterNameIsE();
+			Assertion.AssertNull(eventSecondParameterNameIsE.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(object sender, EventArgs notE);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventSecondParameterNameIsE eventSecondParameterNameIsE = new EventSecondParameterNameIsE();
+			Assertion.AssertNotNull(eventSecondParameterNameIsE.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,91 +1,93 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of EventsDoNotHaveBeforeOrAfterPrefix.	
-	/// &lt;/summary&gt;
-	public class EventsDoNotHaveBeforeOrAfterPrefix : AbstractReflectionRule, IEventRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsDoNotHaveBeforeOrAfterPrefix.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsDoNotHaveBeforeOrAfterPrefix.Details}&quot;;
-			}
-		}
-		
-		public EventsDoNotHaveBeforeOrAfterPrefix()
-		{
-			base.certainty = 90;
-		}
-		
-		public Resolution Check(EventInfo evnt)
-		{
-			if (evnt.Name.StartsWith(&quot;Before&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsDoNotHaveBeforeOrAfterPrefix.Resolution1}&quot;, NamingUtilities.Combine(evnt.ReflectedType.FullName, evnt.Name), new string[,] { { &quot;EventName&quot;, evnt.Name }, { &quot;ReflectedType&quot;, evnt.ReflectedType.FullName }});
-			} else if (evnt.Name.StartsWith(&quot;After&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsDoNotHaveBeforeOrAfterPrefix.Resolution2}&quot;, NamingUtilities.Combine(evnt.ReflectedType.FullName, evnt.Name), new string[,] { { &quot;EventName&quot;, evnt.Name }, { &quot;ReflectedType&quot;, evnt.ReflectedType.FullName }});	
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class EventHandlerSuffixIsEventHandlerTest
-	{
-		public delegate void CorrectEventHandler(object sender, EventArgs e);
-		public event CorrectEventHandler CorrectEvent;
-		protected virtual void OnCorrectEvent(EventArgs e)
-		{
-			if (CorrectEvent != null) {
-				CorrectEvent(this, e);
-			}
-		}
-		[Test]
-		public void TestCorrectEventHandler()
-		{
-			EventHandlerSuffixIsEventHandler eventHandlerSuffixIsEventHandler = new EventHandlerSuffixIsEventHandler();
-			Assertion.AssertNull(eventHandlerSuffixIsEventHandler.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
-		}
-		
-		public delegate void IncorrectEventHandlerWithWrongSuffix(object sender, EventArgs e);
-		public event IncorrectEventHandlerWithWrongSuffix IncorrectEvent;
-		protected virtual void OnIncorrectEvent(EventArgs e)
-		{
-			if (IncorrectEvent != null) {
-				IncorrectEvent(this, e);
-			}
-		}
-		
-		[Test]
-		public void TestIncorrectEventHandler()
-		{
-			EventHandlerSuffixIsEventHandler eventHandlerSuffixIsEventHandler = new EventHandlerSuffixIsEventHandler();
-			EventInfo evnt = this.GetType().GetEvent(&quot;IncorrectEvent&quot;);
-			Assertion.AssertNotNull(&quot;Type name is &gt;&quot; + evnt.EventHandlerType.FullName + &quot;&lt;&quot;, eventHandlerSuffixIsEventHandler.Check(evnt));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventsDoNotHaveBeforeOrAfterPrefix.	
+	/// &lt;/summary&gt;
+	public class EventsDoNotHaveBeforeOrAfterPrefix : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Event names do not have a 'Before' or 'After' prefix&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Use present or past tense for pre/post events instead using &lt;i&gt;Before&lt;/i&gt; or &lt;i&gt;After&lt;/i&gt; prefix.&quot;;
+			}
+		}
+		
+		public EventsDoNotHaveBeforeOrAfterPrefix()
+		{
+			base.certainty = 90;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			if (evnt.Name.StartsWith(&quot;Before&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change event name &lt;code&gt;{0}&lt;/code&gt; in &lt;code&gt;{1}&lt;/code&gt; so that it does not use the &lt;i&gt;Before&lt;/i&gt; prefix.&quot;, evnt.Name, evnt.ReflectedType.FullName), NamingUtilities.Combine (evnt.ReflectedType.FullName, evnt.Name));
+			} else if (evnt.Name.StartsWith(&quot;After&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change event name &lt;code&gt;{0}&lt;/code&gt; in &lt;code&gt;{1}&lt;/code&gt; so that it does not use the &lt;i&gt;After&lt;/i&gt; prefix.&quot;, evnt.Name, evnt.ReflectedType.FullName), NamingUtilities.Combine (evnt.ReflectedType.FullName, evnt.Name));
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventHandlerSuffixIsEventHandlerTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventHandlerSuffixIsEventHandler eventHandlerSuffixIsEventHandler = new EventHandlerSuffixIsEventHandler();
+			Assertion.AssertNull(eventHandlerSuffixIsEventHandler.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandlerWithWrongSuffix(object sender, EventArgs e);
+		public event IncorrectEventHandlerWithWrongSuffix IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventHandlerSuffixIsEventHandler eventHandlerSuffixIsEventHandler = new EventHandlerSuffixIsEventHandler();
+			EventInfo evnt = this.GetType().GetEvent(&quot;IncorrectEvent&quot;);
+			Assertion.AssertNotNull(&quot;Type name is &gt;&quot; + evnt.EventHandlerType.FullName + &quot;&lt;&quot;, eventHandlerSuffixIsEventHandler.Check(evnt));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,77 +1,78 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of ExceptionSuffixIsException.	
-	/// &lt;/summary&gt;
-	public class ExceptionSuffixIsExceptionRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ExceptionSuffixIsException.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ExceptionSuffixIsException.Details}&quot;;
-			}
-		}
-		
-		public ExceptionSuffixIsExceptionRule()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (typeof(System.Exception).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Exception&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ExceptionSuffixIsException.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class ExceptionSuffixIsExceptionRuleTest
-	{
-		class MyException : System.Exception
-		{
-		}
-		[Test]
-		public void TestCorrectException()
-		{
-			ExceptionSuffixIsExceptionRule rule = new ExceptionSuffixIsExceptionRule();
-			Assertion.AssertNull(rule.Check(typeof(MyException)));
-		}
-		
-		class MyExcpt : System.Exception
-		{
-		}
-		[Test]
-		public void TestIncorrectException()
-		{
-			ExceptionSuffixIsExceptionRule rule = new ExceptionSuffixIsExceptionRule();
-			Assertion.AssertNotNull(rule.Check(typeof(MyExcpt)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of ExceptionSuffixIsException.	
+	/// &lt;/summary&gt;
+	public class ExceptionSuffixIsExceptionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Exception names have the suffix 'Exception'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that extends &lt;code&gt;&lt;a href='<A HREF="help://types/System.Exception'">help://types/System.Exception'</A>&gt;Exception&lt;/a&gt;&lt;/code&gt; is an exception and should always use the suffix &lt;i&gt;Exception&lt;/i&gt; like in &lt;code&gt;ArgumentNullException&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public ExceptionSuffixIsExceptionRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.Exception).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Exception&quot;)) {
+				// FIXME: I18M
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;i&gt;Exception&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class ExceptionSuffixIsExceptionRuleTest
+	{
+		class MyException : System.Exception
+		{
+		}
+		[Test]
+		public void TestCorrectException()
+		{
+			ExceptionSuffixIsExceptionRule rule = new ExceptionSuffixIsExceptionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyException)));
+		}
+		
+		class MyExcpt : System.Exception
+		{
+		}
+		[Test]
+		public void TestIncorrectException()
+		{
+			ExceptionSuffixIsExceptionRule rule = new ExceptionSuffixIsExceptionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(MyExcpt)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/FlagEnumerationsArePlural.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/FlagEnumerationsArePlural.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/FlagEnumerationsArePlural.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,85 +1,86 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class FlagEnumerationsArePlural : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.FlagEnumerationsArePlural.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.FlagEnumerationsArePlural.Details}&quot;;
-			}
-		}
-		
-		public FlagEnumerationsArePlural()
-		{
-			base.certainty = 75;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (type.IsSubclassOf(typeof(System.Enum)) &amp;&amp; type.IsDefined(typeof(System.FlagsAttribute), true)) {
-				if (!type.Name.EndsWith(&quot;s&quot;) &amp;&amp; !type.Name.EndsWith(&quot;ae&quot;) &amp;&amp; !type.Name.EndsWith(&quot;i&quot;)) {
- 					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.FlagEnumerationsArePlural.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-				}
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class FlagEnumerationsArePluralTest
-	{
-		[Flags()]
-		enum CorrectFlags { a, b, c}
-		[Flags()]
-		enum CorrectNovae { Type1, Type2}
-		[Flags()]
-		enum CorrectSpaghetti { Bolognese, Napoli}
-		
-		[Test]
-		public void TestCorrectPluralEnums()
-		{
-			FlagEnumerationsArePlural elagEnumerationsArePlural = new FlagEnumerationsArePlural();
-			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectFlags)));
-			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectNovae)));
-			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectSpaghetti)));
-		}
-		
-		[Flags()]
-		enum SomeFlag { Bolognese, Napoli}
-		
-		[Test]
-		public void TestIncorrectPluralEnums()
-		{
-			FlagEnumerationsArePlural elagEnumerationsArePlural = new FlagEnumerationsArePlural();
-			Assertion.AssertNotNull(elagEnumerationsArePlural.Check(typeof(SomeFlag)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of FlagEnumerationsArePlural.	
+	/// &lt;/summary&gt;
+	public class FlagEnumerationsArePlural : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Flag enumeration names should be pluralized&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;An enumeration with the &lt;code&gt;&lt;a href='<A HREF="help://types/System.FlagsAttribute'">help://types/System.FlagsAttribute'</A>&gt;FlagsAttribute&lt;/a&gt;&lt;/code&gt;  should have a plural name like in &lt;code&gt;Modifiers&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public FlagEnumerationsArePlural()
+		{
+			base.certainty = 75;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsSubclassOf(typeof(System.Enum)) &amp;&amp; type.IsDefined(typeof(System.FlagsAttribute), true)) {
+				if (!type.Name.EndsWith(&quot;s&quot;) &amp;&amp; !type.Name.EndsWith(&quot;ae&quot;) &amp;&amp; !type.Name.EndsWith(&quot;i&quot;)) {
+					// FIXME: I18N
+ 					return new Resolution (this, String.Format (&quot;Change the type name of the enumeration &lt;code&gt;{0}&lt;/code&gt; to plural.&quot;, type.FullName), type.FullName);
+				}
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class FlagEnumerationsArePluralTest
+	{
+		[Flags()]
+		enum CorrectFlags { a, b, c}
+		[Flags()]
+		enum CorrectNovae { Type1, Type2}
+		[Flags()]
+		enum CorrectSpaghetti { Bolognese, Napoli}
+		
+		[Test]
+		public void TestCorrectPluralEnums()
+		{
+			FlagEnumerationsArePlural elagEnumerationsArePlural = new FlagEnumerationsArePlural();
+			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectFlags)));
+			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectNovae)));
+			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectSpaghetti)));
+		}
+		
+		[Flags()]
+		enum SomeFlag { Bolognese, Napoli}
+		
+		[Test]
+		public void TestIncorrectPluralEnums()
+		{
+			FlagEnumerationsArePlural elagEnumerationsArePlural = new FlagEnumerationsArePlural();
+			Assertion.AssertNotNull(elagEnumerationsArePlural.Check(typeof(SomeFlag)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/InterfacesPrefixIsI.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/InterfacesPrefixIsI.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/InterfacesPrefixIsI.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,80 +1,81 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class InterfacesPrefixIsI : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfacesPrefixIsI.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfacesPrefixIsI.Details}&quot;;
-			}
-		}
-		
-		public InterfacesPrefixIsI()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (type.IsInterface &amp;&amp; !type.Name.StartsWith(&quot;I&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfacesPrefixIsI.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class InterfacesPrefixIsITest
-	{
-		interface ICorrectInterface
-		{
-		}
-		[Test]
-		public void TestCorrectAttribute()
-		{
-			InterfacesPrefixIsI interfacesPrefixIsI = new InterfacesPrefixIsI();
-			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(System.ICloneable)));
-			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(System.IComparable)));
-			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(ICorrectInterface)));
-		}
-		
-		interface WrongInterface
-		{
-		}
-		[Test]
-		public void TestIncorrectAttribute()
-		{
-			InterfacesPrefixIsI interfacesPrefixIsI = new InterfacesPrefixIsI();
-			Assertion.AssertNotNull(interfacesPrefixIsI.Check(typeof(WrongInterface)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of InterfacesPrefixIsI.	
+	/// &lt;/summary&gt;
+	public class InterfacesPrefixIsI : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Interface names have the Prefix 'I'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;An interface name should always start with &lt;i&gt;I&lt;/i&gt; like in &lt;code&gt;IComparable&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public InterfacesPrefixIsI()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsInterface &amp;&amp; !type.Name.StartsWith(&quot;I&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the interface &lt;code&gt;{0}&lt;/code&gt; so that it starts with &lt;i&gt;I&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class InterfacesPrefixIsITest
+	{
+		interface ICorrectInterface
+		{
+		}
+		[Test]
+		public void TestCorrectAttribute()
+		{
+			InterfacesPrefixIsI interfacesPrefixIsI = new InterfacesPrefixIsI();
+			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(System.ICloneable)));
+			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(System.IComparable)));
+			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(ICorrectInterface)));
+		}
+		
+		interface WrongInterface
+		{
+		}
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			InterfacesPrefixIsI interfacesPrefixIsI = new InterfacesPrefixIsI();
+			Assertion.AssertNotNull(interfacesPrefixIsI.Check(typeof(WrongInterface)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersArePascalCased.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersArePascalCased.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersArePascalCased.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,59 +1,56 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class MembersArePascalCased : AbstractReflectionRule, IMemberRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersArePascalCased.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersArePascalCased.Details}&quot;;
-			}
-		}
-		
-		public MembersArePascalCased()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Module module, MemberInfo member)
-		{
-			if (member is FieldInfo || member is ConstructorInfo) {
-				return null;
-			}
-			if (member is MethodInfo) {
-				MethodInfo mi = (MethodInfo)member;
-				if (mi.IsSpecialName) {
-					return null;
-				}
-			}
-			
-			if (!NamingUtilities.IsPascalCase(member.Name)) {
-				return new Resolution(this, 
-				                      &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersArePascalCased.Resolution}&quot;,
-				                      NamingUtilities.Combine(member.DeclaringType.FullName, member.Name),
-				                      new string[,] { 
-				                      	{&quot;MemberName&quot;, member.Name}, 
-				                      	{&quot;DeclaringType&quot;, member.DeclaringType.FullName}, 
-				                      	{&quot;AlternateName&quot;, NamingUtilities.PascalCase(member.Name)}});
-			}
-			return null;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of MembersArePascalCased.	
+	/// &lt;/summary&gt;
+	public class MembersArePascalCased : AbstractReflectionRule, IMemberRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Member names should be pascal cased&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Pascal casing capitalized the first letter like in &lt;code&gt;&lt;b&gt;W&lt;/b&gt;riteLine&lt;/code&gt;. Use pascal casing for all public identifiers that consist of compound words.&quot;;
+			}
+		}
+		
+		public MembersArePascalCased()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Module module, MemberInfo member)
+		{
+			if (member is FieldInfo || member is ConstructorInfo) {
+				return null;
+			}
+			if (member is MethodInfo) {
+				MethodInfo mi = (MethodInfo)member;
+				if (mi.IsSpecialName) {
+					return null;
+				}
+			}
+			
+			if (!NamingUtilities.IsPascalCase(member.Name)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Use pascal casing for &lt;code&gt;{0}&lt;/code&gt; in &lt;code&gt;{1}&lt;/code&gt;.&lt;BR&gt;For example : &lt;code&gt;${2}&lt;/code&gt;.&quot;, member.Name, member.DeclaringType, NamingUtilities.PascalCase (member.Name)), NamingUtilities.Combine(member.DeclaringType.FullName, member.Name));
+			}
+			return null;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersDoNotContainUnderscores.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersDoNotContainUnderscores.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersDoNotContainUnderscores.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,54 +1,57 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class MembersDoNotContainUnderscores : AbstractReflectionRule, IMemberRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersDoNotContainUnderscores.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersDoNotContainUnderscores.Details}&quot;;
-			}
-		}
-		
-		public MembersDoNotContainUnderscores()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Module module, MemberInfo member)
-		{
-			if (member is FieldInfo || member is ConstructorInfo) {
-				return null;
-			}
-			if (member is MethodInfo) {
-				MethodInfo mi = (MethodInfo)member;
-				if (mi.IsSpecialName) {
-					return null;
-				}
-			}
-			
-			if (NamingUtilities.ContainsUnderscore(member.Name)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersDoNotContainUnderscores.Resolution}&quot;, NamingUtilities.Combine(member.ReflectedType.FullName, member.Name), new string[,] { {&quot;MemberName&quot;, member.Name}, {&quot;DeclaringType&quot;, member.DeclaringType.FullName} });
-			}
-			
-			return null;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of MembersDoNotContainUnderscores.	
+	/// &lt;/summary&gt;
+	public class MembersDoNotContainUnderscores : AbstractReflectionRule, IMemberRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Member names do not contain underscores '_'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Underscores should never be used inside public members.&quot;;
+			}
+		}
+		
+		public MembersDoNotContainUnderscores()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Module module, MemberInfo member)
+		{
+			if (member is FieldInfo || member is ConstructorInfo) {
+				return null;
+			}
+			if (member is MethodInfo) {
+				MethodInfo mi = (MethodInfo)member;
+				if (mi.IsSpecialName) {
+					return null;
+				}
+			}
+			
+			if (NamingUtilities.ContainsUnderscore(member.Name)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Remove all underscores in member name &lt;code&gt;{0}&lt;/code&gt; in the type &lt;code&gt;{1}&lt;/code&gt;.&quot;, member.Name, member.DeclaringType.FullName), NamingUtilities.Combine(member.ReflectedType.FullName, member.Name));
+			}
+			
+			return null;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,112 +1,113 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class MembershipConditionNamesSuffixIsMembershipCondition : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembershipConditionNamesSuffixIsMembershipCondition.Description}&quot;;
-			}
-		}
-		
-		// System.Attribute
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembershipConditionNamesSuffixIsMembershipCondition.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (typeof(System.Security.Policy.IMembershipCondition).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;MembershipCondition&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembershipConditionNamesSuffixIsMembershipCondition.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class MembershipConditionNamesSuffixIsMembershipConditionTest
-	{
-		class MyClass 
-		{
-		}
-		[Test]
-		public void TestCorrectMembershipCondition()
-		{
-			MembershipConditionNamesSuffixIsMembershipCondition membershipConditionNamesSuffixIsMembershipCondition = new MembershipConditionNamesSuffixIsMembershipCondition();
-			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(System.Security.Policy.AllMembershipCondition)));
-			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(System.Security.Policy.ZoneMembershipCondition)));
-			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(MyClass)));
-		}
-		
-		class MyClass2 : System.Security.Policy.IMembershipCondition
-		{
-			#region System.Security.ISecurityEncodable interface implementation
-			public void FromXml(System.Security.SecurityElement e)
-			{
-				
-			}
-			
-			public System.Security.SecurityElement ToXml()
-			{
-				return null;
-			}
-			#endregion
-			
-			#region System.Security.ISecurityPolicyEncodable interface implementation
-			public void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level)
-			{
-				
-			}
-			
-			public System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level)
-			{
-				return null;
-			}
-			#endregion
-			
-			#region System.Security.Policy.IMembershipCondition interface implementation
-			public System.Security.Policy.IMembershipCondition Copy()
-			{
-				return null;
-			}
-			
-			public bool Check(System.Security.Policy.Evidence evidence)
-			{
-				return false;
-			}
-			#endregion
-		}
-		
-		[Test]
-		public void TestIncorrectAttribute()
-		{
-			MembershipConditionNamesSuffixIsMembershipCondition membershipConditionNamesSuffixIsMembershipCondition = new MembershipConditionNamesSuffixIsMembershipCondition();
-			Assertion.AssertNotNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(MyClass2)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of MembershipConditionNamesSuffixIsMembershipCondition
+	/// &lt;/summary&gt;
+	public class MembershipConditionNamesSuffixIsMembershipCondition : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;MembershipCondition names have the suffix 'MembershipCondition'&quot;;
+			}
+		}
+		
+		// System.Attribute
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot; A type that implements &lt;code&gt;&lt;a href='<A HREF="help://types/System.Security.Policy.IMembershipCondition'">help://types/System.Security.Policy.IMembershipCondition'</A>&gt;IMembershipCondition&lt;/a&gt;&lt;/code&gt; is a condition and its name should always end with &lt;i&gt;MembershipCondition&lt;/i&gt; like in &lt;code&gt;UrlMembershipCondition&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.Security.Policy.IMembershipCondition).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;MembershipCondition&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;I&gt;MembershipCondition&lt;/I&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class MembershipConditionNamesSuffixIsMembershipConditionTest
+	{
+		class MyClass 
+		{
+		}
+		[Test]
+		public void TestCorrectMembershipCondition()
+		{
+			MembershipConditionNamesSuffixIsMembershipCondition membershipConditionNamesSuffixIsMembershipCondition = new MembershipConditionNamesSuffixIsMembershipCondition();
+			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(System.Security.Policy.AllMembershipCondition)));
+			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(System.Security.Policy.ZoneMembershipCondition)));
+			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(MyClass)));
+		}
+		
+		class MyClass2 : System.Security.Policy.IMembershipCondition
+		{
+			#region System.Security.ISecurityEncodable interface implementation
+			public void FromXml(System.Security.SecurityElement e)
+			{
+				
+			}
+			
+			public System.Security.SecurityElement ToXml()
+			{
+				return null;
+			}
+			#endregion
+			
+			#region System.Security.ISecurityPolicyEncodable interface implementation
+			public void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level)
+			{
+				
+			}
+			
+			public System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level)
+			{
+				return null;
+			}
+			#endregion
+			
+			#region System.Security.Policy.IMembershipCondition interface implementation
+			public System.Security.Policy.IMembershipCondition Copy()
+			{
+				return null;
+			}
+			
+			public bool Check(System.Security.Policy.Evidence evidence)
+			{
+				return false;
+			}
+			#endregion
+		}
+		
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			MembershipConditionNamesSuffixIsMembershipCondition membershipConditionNamesSuffixIsMembershipCondition = new MembershipConditionNamesSuffixIsMembershipCondition();
+			Assertion.AssertNotNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(MyClass2)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesArePascalCased.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesArePascalCased.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesArePascalCased.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,81 +1,82 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of NamespacesArePascalCased.	
-	/// &lt;/summary&gt;
-	public class NamespacesArePascalCased : AbstractReflectionRule, INamespaceRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesArePascalCased.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesArePascalCased.Details}&quot;;
-			}
-		}
-		
-		public NamespacesArePascalCased()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(string namespaceName, ICollection types)
-		{
-			string[] namespaces = namespaceName.Split('.');
-			foreach (string name in namespaces) {
-				if (!NamingUtilities.IsPascalCase(name)) {
-					for (int i = 0; i &lt; namespaces.Length; ++i) {
-						namespaces[i] = NamingUtilities.PascalCase(namespaces[i]);
-					}
-					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesArePascalCased.Resolution}&quot;, namespaceName, new string[,]{{&quot;NamespaceName&quot;, namespaceName}, {&quot;AlternateName&quot;, String.Join(&quot;.&quot;, namespaces) }});
-				}
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class NamespacesArePascalCasedTest
-	{
-		[Test]
-		public void TestCorrectNamespaces()
-		{
-			NamespacesArePascalCased namespacesArePascalCased = new NamespacesArePascalCased();
-			Assertion.AssertNull(&quot;Empty Namespace&quot;, namespacesArePascalCased.Check(&quot;&quot;, null));
-			Assertion.AssertNull(&quot;Single Namespace&quot;, namespacesArePascalCased.Check(&quot;MyNamespace&quot;, null));
-			Assertion.AssertNull(&quot;Complex Namespace&quot;, namespacesArePascalCased.Check(&quot;System.Windows.Form&quot;, null));
-		}
-		
-		[Test]
-		public void TestIncorrectAttribute()
-		{
-			NamespacesArePascalCased namespacesArePascalCased = new NamespacesArePascalCased();
-			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;a&quot;, null));
-			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;A.Namespace.isWrong&quot;, null));
-			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;System.windows.Form&quot;, null));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of NamespacesArePascalCased.	
+	/// &lt;/summary&gt;
+	public class NamespacesArePascalCased : AbstractReflectionRule, INamespaceRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Namespace names should be pascal cased&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Pascal casing capitalized the first letter like in &lt;code&gt;&lt;b&gt;S&lt;/b&gt;ystem.&lt;b&gt;C&lt;/b&gt;omponentModel.&lt;b&gt;D&lt;/b&gt;esign&lt;/code&gt;. Use pascal casing for all namespaces.&quot;;
+			}
+		}
+		
+		public NamespacesArePascalCased()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(string namespaceName, ICollection types)
+		{
+			string[] namespaces = namespaceName.Split('.');
+			foreach (string name in namespaces) {
+				if (!NamingUtilities.IsPascalCase(name)) {
+					for (int i = 0; i &lt; namespaces.Length; ++i) {
+						namespaces[i] = NamingUtilities.PascalCase(namespaces[i]);
+					}
+					// FIXME: I18N
+					return new Resolution (this, String.Format (&quot;Use pascal casing for the namespace &lt;code&gt;{0}&lt;/code&gt;.&lt;BR&gt;For example: &lt;code&gt;{1}&lt;/code&gt;.&quot;, namespaceName, String.Join (&quot;.&quot;, namespaces)), namespaceName);
+				}
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class NamespacesArePascalCasedTest
+	{
+		[Test]
+		public void TestCorrectNamespaces()
+		{
+			NamespacesArePascalCased namespacesArePascalCased = new NamespacesArePascalCased();
+			Assertion.AssertNull(&quot;Empty Namespace&quot;, namespacesArePascalCased.Check(&quot;&quot;, null));
+			Assertion.AssertNull(&quot;Single Namespace&quot;, namespacesArePascalCased.Check(&quot;MyNamespace&quot;, null));
+			Assertion.AssertNull(&quot;Complex Namespace&quot;, namespacesArePascalCased.Check(&quot;System.Windows.Form&quot;, null));
+		}
+		
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			NamespacesArePascalCased namespacesArePascalCased = new NamespacesArePascalCased();
+			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;a&quot;, null));
+			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;A.Namespace.isWrong&quot;, null));
+			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;System.windows.Form&quot;, null));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesDoNotContainUnderscores.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesDoNotContainUnderscores.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesDoNotContainUnderscores.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,75 +1,76 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of NamespacesArePascalCased.	
-	/// &lt;/summary&gt;
-	public class NamespacesDoNotContainUnderscores : AbstractReflectionRule, INamespaceRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesDoNotContainUnderscores.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesDoNotContainUnderscores.Details}&quot;;
-			}
-		}
-		
-		public NamespacesDoNotContainUnderscores()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(string namespaceName, ICollection types)
-		{
-			if (NamingUtilities.ContainsUnderscore(namespaceName)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesDoNotContainUnderscores.Resolution}&quot;, namespaceName, new string[,]{{&quot;NamespaceName&quot;, namespaceName}});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class NamespacesDoNotContainUnderscoresTest
-	{
-		[Test]
-		public void TestCorrectNamespaces()
-		{
-			NamespacesDoNotContainUnderscores rule = new NamespacesDoNotContainUnderscores();
-			Assertion.AssertNull(&quot;Empty Namespace&quot;, rule.Check(&quot;&quot;, null));
-			Assertion.AssertNull(&quot;Single Namespace&quot;, rule.Check(&quot;MyNamespace&quot;, null));
-			Assertion.AssertNull(&quot;Complex Namespace&quot;, rule.Check(&quot;System.Windows.Form&quot;, null));
-		}
-		
-		[Test]
-		public void TestIncorrectNamespaces()
-		{
-			NamespacesDoNotContainUnderscores rule = new NamespacesDoNotContainUnderscores();
-			Assertion.AssertNotNull(rule.Check(&quot;_&quot;, null));
-			Assertion.AssertNotNull(rule.Check(&quot;A.Namespace.isWrong_&quot;, null));
-			Assertion.AssertNotNull(rule.Check(&quot;System._Windows.Form&quot;, null));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of NamespacesDoNotContainUnderScores
+	/// &lt;/summary&gt;
+	public class NamespacesDoNotContainUnderscores : AbstractReflectionRule, INamespaceRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Namespace names do not contain underscores '_'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Underscores should never be used inside namespace names.&quot;;
+			}
+		}
+		
+		public NamespacesDoNotContainUnderscores()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(string namespaceName, ICollection types)
+		{
+			if (NamingUtilities.ContainsUnderscore(namespaceName)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Remove all underscores in namespace &lt;code&gt;{0}&lt;/code&gt;.&quot;, namespaceName), namespaceName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class NamespacesDoNotContainUnderscoresTest
+	{
+		[Test]
+		public void TestCorrectNamespaces()
+		{
+			NamespacesDoNotContainUnderscores rule = new NamespacesDoNotContainUnderscores();
+			Assertion.AssertNull(&quot;Empty Namespace&quot;, rule.Check(&quot;&quot;, null));
+			Assertion.AssertNull(&quot;Single Namespace&quot;, rule.Check(&quot;MyNamespace&quot;, null));
+			Assertion.AssertNull(&quot;Complex Namespace&quot;, rule.Check(&quot;System.Windows.Form&quot;, null));
+		}
+		
+		[Test]
+		public void TestIncorrectNamespaces()
+		{
+			NamespacesDoNotContainUnderscores rule = new NamespacesDoNotContainUnderscores();
+			Assertion.AssertNotNull(rule.Check(&quot;_&quot;, null));
+			Assertion.AssertNotNull(rule.Check(&quot;A.Namespace.isWrong_&quot;, null));
+			Assertion.AssertNotNull(rule.Check(&quot;System._Windows.Form&quot;, null));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,82 +1,83 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of OnlyAttributesSuffixAttribute.	
-	/// &lt;/summary&gt;
-	public class OnlyAttributesSuffixAttributeRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyAttributesSuffixAttribute.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyAttributesSuffixAttribute.Details}&quot;;
-			}
-		}
-		
-		public OnlyAttributesSuffixAttributeRule()
-		{
-			base.certainty = 99;
-			base.priorityLevel = PriorityLevel.CriticalError;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (!type.IsSubclassOf(typeof(System.Attribute)) &amp;&amp; type.Name.EndsWith(&quot;Attribute&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyAttributesSuffixAttribute.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class OnlyAttributesSuffixAttributeTest
-	{
-		class MyOtherClass
-		{
-		}
-		class RealAttribute : System.Attribute
-		{
-		}
-		[Test]
-		public void TestCorrectAttribute()
-		{
-			OnlyAttributesSuffixAttributeRule rule = new OnlyAttributesSuffixAttributeRule();
-			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
-			Assertion.AssertNull(rule.Check(typeof(RealAttribute)));
-		}
-		
-		class MyAttribute
-		{
-		}
-		[Test]
-		public void TestIncorrectAttribute()
-		{
-			OnlyAttributesSuffixAttributeRule rule = new OnlyAttributesSuffixAttributeRule();
-			Assertion.AssertNotNull(rule.Check(typeof(MyAttribute)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyAttributesSuffixAttribute.	
+	/// &lt;/summary&gt;
+	public class OnlyAttributesSuffixAttributeRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Only attribute names have the suffix 'Attribute'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that does not extend from &lt;code&gt;&lt;a href='<A HREF="help://types/System.Attribute'">help://types/System.Attribute'</A>&gt;Attribute&lt;/a&gt;&lt;/code&gt; should never have the suffix &lt;i&gt;Attribute&lt;/i&gt;.&quot;;
+			}
+		}
+		
+		public OnlyAttributesSuffixAttributeRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!type.IsSubclassOf(typeof(System.Attribute)) &amp;&amp; type.Name.EndsWith(&quot;Attribute&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Attribute&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyAttributesSuffixAttributeTest
+	{
+		class MyOtherClass
+		{
+		}
+		class RealAttribute : System.Attribute
+		{
+		}
+		[Test]
+		public void TestCorrectAttribute()
+		{
+			OnlyAttributesSuffixAttributeRule rule = new OnlyAttributesSuffixAttributeRule();
+			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
+			Assertion.AssertNull(rule.Check(typeof(RealAttribute)));
+		}
+		
+		class MyAttribute
+		{
+		}
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			OnlyAttributesSuffixAttributeRule rule = new OnlyAttributesSuffixAttributeRule();
+			Assertion.AssertNotNull(rule.Check(typeof(MyAttribute)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,135 +1,136 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of CheckCollectionSuffix.	
-	/// &lt;/summary&gt;
-	public class OnlyCollectionsSuffixCollectionRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Details}&quot;;
-			}
-		}
-		
-		public OnlyCollectionsSuffixCollectionRule()
-		{
-			base.certainty = 99;
-			base.priorityLevel = PriorityLevel.CriticalError;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (!typeof(ICollection).IsAssignableFrom(type) &amp;&amp; !typeof(IEnumerable).IsAssignableFrom(type)) {
-				if (!typeof(Queue).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Queue&quot;)) {
-					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Resolution1}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-				} else if (!typeof(Stack).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Stack&quot;)) {
-					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Resolution2}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-				} else if (type.Name.EndsWith(&quot;Collection&quot;)) {
-					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Resolution3}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-				}
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class OnlyCollectionsSuffixCollectionRuleTest
-	{
-		#region Collection suffix tests
-		class MyCollection : System.Collections.ArrayList
-		{
-		}
-		class OtherClass 
-		{
-		}
-		[Test]
-		public void TestCorrectCollection()
-		{
-			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
-			Assertion.AssertNull(rule.Check(typeof(MyCollection)));
-			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
-		}
-		
-		class My2Collection
-		{
-		}
-		[Test]
-		public void TestIncorrectCollection()
-		{
-			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
-			Assertion.AssertNotNull(rule.Check(typeof(My2Collection)));
-		}
-		#endregion
-		
-		#region Queue suffix tests
-		class MyQueue : System.Collections.Queue
-		{
-		}
-		[Test]
-		public void TestCorrectQueue()
-		{
-			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
-			Assertion.AssertNull(rule.Check(typeof(MyQueue)));
-		}
-		
-		class My2Queue
-		{
-		}
-		[Test]
-		public void TestIncorrectQueue()
-		{
-			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
-			Assertion.AssertNotNull(rule.Check(typeof(My2Queue)));
-		}
-		#endregion 
-		
-		#region Stack suffix tests
-		class MyStack : System.Collections.Stack
-		{
-		}
-		[Test]
-		public void TestCorrectStack()
-		{
-			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
-			Assertion.AssertNull(rule.Check(typeof(MyStack)));
-		}
-		
-		class My2Stack
-		{
-		}
-		[Test]
-		public void TestIncorrectStack()
-		{
-			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
-			Assertion.AssertNotNull(rule.Check(typeof(My2Stack)));
-		}
-		#endregion
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyCollectionsSuffixCollectionRule.	
+	/// &lt;/summary&gt;
+	public class OnlyCollectionsSuffixCollectionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Only collection names should have the suffix 'Collection', 'Queue' or 'Stack'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that does not implement &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.ICollection'">help://types/System.Collections.ICollection'</A>&gt;ICollection&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.IEnumerable'">help://types/System.Collections.IEnumerable'</A>&gt;IEnumerable&lt;/a&gt;&lt;/code&gt; should never have the suffix &lt;i&gt;Collection&lt;/i&gt;.&lt;BR&gt;A type that doesn't extend &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.Queue'">help://types/System.Collections.Queue'</A>&gt;Queue&lt;/a&gt;&lt;/code&gt; should never have the suffix &lt;i&gt;Queue&lt;/i&gt; and a type that doesn't extend &lt;code&gt;&lt;a href='<A HREF="help://types/System.Collections.Stack'">help://types/System.Collections.Stack'</A>&gt;Stack&lt;/a&gt;&lt;/code&gt; should never have a &lt;i&gt;Stack&lt;/i&gt; suffix.&quot;;
+			}
+		}
+		
+		public OnlyCollectionsSuffixCollectionRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(ICollection).IsAssignableFrom(type) &amp;&amp; !typeof(IEnumerable).IsAssignableFrom(type)) {
+				// FIXME: I18N
+				if (!typeof(Queue).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Queue&quot;)) {
+					return new Resolution (this, String.Format (&quot;Change the name of &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Queue&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+				} else if (!typeof(Stack).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Stack&quot;)) {
+					return new Resolution (this, String.Format (&quot;Change the name of &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Stack&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+				} else if (type.Name.EndsWith(&quot;Collection&quot;)) {
+					return new Resolution (this, String.Format (&quot;Change the name of &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Collection&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+				}
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyCollectionsSuffixCollectionRuleTest
+	{
+		#region Collection suffix tests
+		class MyCollection : System.Collections.ArrayList
+		{
+		}
+		class OtherClass 
+		{
+		}
+		[Test]
+		public void TestCorrectCollection()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyCollection)));
+			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
+		}
+		
+		class My2Collection
+		{
+		}
+		[Test]
+		public void TestIncorrectCollection()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(My2Collection)));
+		}
+		#endregion
+		
+		#region Queue suffix tests
+		class MyQueue : System.Collections.Queue
+		{
+		}
+		[Test]
+		public void TestCorrectQueue()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyQueue)));
+		}
+		
+		class My2Queue
+		{
+		}
+		[Test]
+		public void TestIncorrectQueue()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(My2Queue)));
+		}
+		#endregion 
+		
+		#region Stack suffix tests
+		class MyStack : System.Collections.Stack
+		{
+		}
+		[Test]
+		public void TestCorrectStack()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyStack)));
+		}
+		
+		class My2Stack
+		{
+		}
+		[Test]
+		public void TestIncorrectStack()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(My2Stack)));
+		}
+		#endregion
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,87 +1,88 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of OnlyEventArgsSuffixEventArgsRule.	
-	/// &lt;/summary&gt;
-	public class OnlyEventArgsSuffixEventArgsRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventArgsSuffixEventArgs.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventArgsSuffixEventArgs.Details}&quot;;
-			}
-		}
-		
-		public OnlyEventArgsSuffixEventArgsRule()
-		{
-			base.certainty = 99;
-			base.priorityLevel = PriorityLevel.CriticalError;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (!typeof(System.EventArgs).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;EventArgs&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventArgsSuffixEventArgs.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class OnlyEventArgsSuffixEventArgsRuleTest
-	{
-		class CorrectEventArgs : System.EventArgs
-		{
-		}
-		class OtherClass
-		{
-		}
-		class MyEventArgs : CorrectEventArgs
-		{
-		}
-		[Test]
-		public void TestCorrectEventArgs()
-		{
-			OnlyEventArgsSuffixEventArgsRule rule = new OnlyEventArgsSuffixEventArgsRule();
-			Assertion.AssertNull(rule.Check(typeof(CorrectEventArgs)));
-			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
-			Assertion.AssertNull(rule.Check(typeof(MyEventArgs)));
-		}
-		
-		class IncorrectEventArgs
-		{
-		}
-		[Test]
-		public void TestIncorrectEventArgs()
-		{
-			OnlyEventArgsSuffixEventArgsRule rule = new OnlyEventArgsSuffixEventArgsRule();
-			Assertion.AssertNotNull(rule.Check(typeof(IncorrectEventArgs)));
-		}
-		
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyEventArgsSuffixEventArgsRule.	
+	/// &lt;/summary&gt;
+	public class OnlyEventArgsSuffixEventArgsRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Only event argument names have the suffix 'EventArgs'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that does not extend from &lt;code&gt;&lt;a href='<A HREF="help://types/System.EventArgs'">help://types/System.EventArgs'</A>&gt;EventArgs&lt;/a&gt;&lt;/code&gt; should never have the suffix &lt;i&gt;EventArgs&lt;/i&gt;.&quot;;
+			}
+		}
+		
+		public OnlyEventArgsSuffixEventArgsRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(System.EventArgs).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;EventArgs&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;EventArgs&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyEventArgsSuffixEventArgsRuleTest
+	{
+		class CorrectEventArgs : System.EventArgs
+		{
+		}
+		class OtherClass
+		{
+		}
+		class MyEventArgs : CorrectEventArgs
+		{
+		}
+		[Test]
+		public void TestCorrectEventArgs()
+		{
+			OnlyEventArgsSuffixEventArgsRule rule = new OnlyEventArgsSuffixEventArgsRule();
+			Assertion.AssertNull(rule.Check(typeof(CorrectEventArgs)));
+			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
+			Assertion.AssertNull(rule.Check(typeof(MyEventArgs)));
+		}
+		
+		class IncorrectEventArgs
+		{
+		}
+		[Test]
+		public void TestIncorrectEventArgs()
+		{
+			OnlyEventArgsSuffixEventArgsRule rule = new OnlyEventArgsSuffixEventArgsRule();
+			Assertion.AssertNotNull(rule.Check(typeof(IncorrectEventArgs)));
+		}
+		
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,50 +1,53 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of OnlyEventHandlerSuffixIsEventHandlerRule.	
-	/// &lt;/summary&gt;
-	public class OnlyEventHandlerSuffixIsEventHandlerRule : AbstractReflectionRule, IMemberRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventHandlerSuffixIsEventHandler.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventHandlerSuffixIsEventHandler.Details}&quot;;
-			}
-		}
-		
-		public OnlyEventHandlerSuffixIsEventHandlerRule()
-		{
-			base.certainty = 99;
-			base.priorityLevel = PriorityLevel.CriticalError;
-		}
-		
-		public Resolution Check(Module module, MemberInfo member)
-		{
-			if (member is MethodInfo) {
-				MethodInfo mi = (MethodInfo)member;
-				if (mi.IsSpecialName) {
-					return null;
-				}
-			}
-			if (member.Name.EndsWith(&quot;EventHandler&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventHandlerSuffixIsEventHandler.Resolution}&quot;, NamingUtilities.Combine(member.ReflectedType.FullName, member.Name), new string[,] { {&quot;MemberName&quot;, member.Name}, {&quot;DeclaringType&quot;, member.DeclaringType.FullName} });
-			}
-			return null;
-		}
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyEventHandlerSuffixIsEventHandlerRule.	
+	/// &lt;/summary&gt;
+	public class OnlyEventHandlerSuffixIsEventHandlerRule : AbstractReflectionRule, IMemberRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Only event handler names have the suffix 'EventHandler'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Only delegates that get used in events have the suffix &lt;i&gt;EventHandler&lt;/i&gt;.&quot;;
+			}
+		}
+		
+		public OnlyEventHandlerSuffixIsEventHandlerRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Module module, MemberInfo member)
+		{
+			if (member is MethodInfo) {
+				MethodInfo mi = (MethodInfo)member;
+				if (mi.IsSpecialName) {
+					return null;
+				}
+			}
+			if (member.Name.EndsWith(&quot;EventHandler&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;&quot;, member.Name, member.DeclaringType.FullName), NamingUtilities.Combine (member.ReflectedType.FullName, member.Name));
+			}
+			return null;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,82 +1,83 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of OnlyExceptionsSuffixExceptionRule.	
-	/// &lt;/summary&gt;
-	public class OnlyExceptionsSuffixExceptionRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyExceptionsSuffixException.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyExceptionsSuffixException.Details}&quot;;
-			}
-		}
-		
-		public OnlyExceptionsSuffixExceptionRule()
-		{
-			base.certainty = 99;
-			base.priorityLevel = PriorityLevel.CriticalError;
-		}
-		
-		
-		public Resolution Check(Type type)
-		{
-			if (!typeof(System.Exception).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Exception&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyExceptionsSuffixException.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class OnlyExceptionsSuffixExceptionRuleTest
-	{
-		class MyException : System.Exception
-		{
-		}
-		class OtherClass
-		{}
-		[Test]
-		public void TestCorrectException()
-		{
-			OnlyExceptionsSuffixExceptionRule rule = new OnlyExceptionsSuffixExceptionRule();
-			Assertion.AssertNull(rule.Check(typeof(MyException)));
-			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
-		}
-		
-		class NotAnException
-		{
-		}
-		[Test]
-		public void TestIncorrectException()
-		{
-			OnlyExceptionsSuffixExceptionRule rule = new OnlyExceptionsSuffixExceptionRule();
-			Assertion.AssertNotNull(rule.Check(typeof(NotAnException)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyExceptionsSuffixExceptionRule.	
+	/// &lt;/summary&gt;
+	public class OnlyExceptionsSuffixExceptionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Only exception names have the suffix 'Exception'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that does not extend from &lt;code&gt;&lt;a href='<A HREF="help://types/System.Exception'">help://types/System.Exception'</A>&gt;Exception&lt;/a&gt;&lt;/code&gt; should never have the suffix &lt;i&gt;Exception&lt;/i&gt;.&quot;;
+			}
+		}
+		
+		public OnlyExceptionsSuffixExceptionRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(System.Exception).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Exception&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it doesn't end with &lt;i&gt;Exception&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyExceptionsSuffixExceptionRuleTest
+	{
+		class MyException : System.Exception
+		{
+		}
+		class OtherClass
+		{}
+		[Test]
+		public void TestCorrectException()
+		{
+			OnlyExceptionsSuffixExceptionRule rule = new OnlyExceptionsSuffixExceptionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyException)));
+			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
+		}
+		
+		class NotAnException
+		{
+		}
+		[Test]
+		public void TestIncorrectException()
+		{
+			OnlyExceptionsSuffixExceptionRule rule = new OnlyExceptionsSuffixExceptionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(NotAnException)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,79 +1,80 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of OnlyExceptionsSuffixException.	
-	/// &lt;/summary&gt;
-	public class OnlyPermissionsSuffixPermissionRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyPermissionsSuffixPermission.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyPermissionsSuffixPermission.Details}&quot;;
-			}
-		}
-		
-		public OnlyPermissionsSuffixPermissionRule()
-		{
-			base.certainty = 99;
-			base.priorityLevel = PriorityLevel.CriticalError;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (!typeof(System.Security.IPermission).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Permission&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyPermissionsSuffixPermission.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class OnlyPermissionsSuffixPermissionRuleTest
-	{
-		class OtherClass
-		{}
-		[Test]
-		public void TestCorrectPermission()
-		{
-			OnlyPermissionsSuffixPermissionRule rule = new OnlyPermissionsSuffixPermissionRule();
-			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.EnvironmentPermission)));
-			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.FileIOPermission)));
-			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
-		}
-		
-		class NotAnPermission
-		{
-		}
-		[Test]
-		public void TestIncorrectPermission()
-		{
-			OnlyPermissionsSuffixPermissionRule rule = new OnlyPermissionsSuffixPermissionRule();
-			Assertion.AssertNotNull(rule.Check(typeof(NotAnPermission)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyPermissionSuffixPermissionRule.	
+	/// &lt;/summary&gt;
+	public class OnlyPermissionsSuffixPermissionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Only permission names have the suffix 'Permission'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that does not implement &lt;code&gt;&lt;a href='<A HREF="help://types/System.Security.IPermission'">help://types/System.Security.IPermission'</A>&gt;IPermission&lt;/a&gt;&lt;/code&gt; should never have the suffix &lt;i&gt;Permission&lt;/i&gt;.&quot;;
+			}
+		}
+		
+		public OnlyPermissionsSuffixPermissionRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(System.Security.IPermission).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Permission&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Permission&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyPermissionsSuffixPermissionRuleTest
+	{
+		class OtherClass
+		{}
+		[Test]
+		public void TestCorrectPermission()
+		{
+			OnlyPermissionsSuffixPermissionRule rule = new OnlyPermissionsSuffixPermissionRule();
+			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.EnvironmentPermission)));
+			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.FileIOPermission)));
+			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
+		}
+		
+		class NotAnPermission
+		{
+		}
+		[Test]
+		public void TestIncorrectPermission()
+		{
+			OnlyPermissionsSuffixPermissionRule rule = new OnlyPermissionsSuffixPermissionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(NotAnPermission)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,86 +1,87 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of OnlyStreamsSuffixStreamRule.	
-	/// &lt;/summary&gt;
-	public class OnlyStreamsSuffixStreamRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyStreamsSuffixStream.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyStreamsSuffixStream.Details}&quot;;
-			}
-		}
-		
-		public OnlyStreamsSuffixStreamRule()
-		{
-			base.certainty = 99;
-			base.priorityLevel = PriorityLevel.CriticalError;
-		}
-		
-		
-		public Resolution Check(Type type)
-		{
-			if (!typeof(System.IO.Stream).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Stream&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyStreamsSuffixStream.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using System.IO;
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class OnlyStreamsSuffixStreamRuleTest
-	{
-		class MyOtherClass
-		{
-		}
-		class RealStream : System.IO.FileStream  
-		{
-			public RealStream(string path,FileMode mode) : base(path, mode)
-			{}
-		}
-		[Test]
-		public void TestCorrectStream()
-		{
-			OnlyStreamsSuffixStreamRule rule = new OnlyStreamsSuffixStreamRule();
-			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
-			Assertion.AssertNull(rule.Check(typeof(RealStream)));
-		}
-		
-		class MyStream
-		{
-		}
-		[Test]
-		public void TestIncorrectStream()
-		{
-			OnlyStreamsSuffixStreamRule rule = new OnlyStreamsSuffixStreamRule();
-			Assertion.AssertNotNull(rule.Check(typeof(MyStream)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyStreamsSuffixStreamRule.	
+	/// &lt;/summary&gt;
+	public class OnlyStreamsSuffixStreamRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Only stream names have the suffix 'Stream'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that does not extend from &lt;code&gt;&lt;a href='<A HREF="help://types/System.IO.Stream'">help://types/System.IO.Stream'</A>&gt;Stream&lt;/a&gt;&lt;/code&gt; should never have the suffix &lt;i&gt;Stream&lt;/i&gt;.&quot;;
+			}
+		}
+		
+		public OnlyStreamsSuffixStreamRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(System.IO.Stream).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Stream&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Stream&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using System.IO;
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyStreamsSuffixStreamRuleTest
+	{
+		class MyOtherClass
+		{
+		}
+		class RealStream : System.IO.FileStream  
+		{
+			public RealStream(string path,FileMode mode) : base(path, mode)
+			{}
+		}
+		[Test]
+		public void TestCorrectStream()
+		{
+			OnlyStreamsSuffixStreamRule rule = new OnlyStreamsSuffixStreamRule();
+			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
+			Assertion.AssertNull(rule.Check(typeof(RealStream)));
+		}
+		
+		class MyStream
+		{
+		}
+		[Test]
+		public void TestIncorrectStream()
+		{
+			OnlyStreamsSuffixStreamRule rule = new OnlyStreamsSuffixStreamRule();
+			Assertion.AssertNotNull(rule.Check(typeof(MyStream)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,100 +1,101 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-using System.Collections;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of ParameterNamesDoNotHaveUnderscores.	
-	/// &lt;/summary&gt;
-	public class ParameterNamesDoNotHaveUnderscores : AbstractReflectionRule, IParameterRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParameterNamesDoNotHaveUnderscores.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParameterNamesDoNotHaveUnderscores.Details}&quot;;
-			}
-		}
-		
-		public ParameterNamesDoNotHaveUnderscores()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Module module, ParameterInfo param)
-		{
-			if (param.Name != null &amp;&amp; param.Name.IndexOf('_') &gt;= 0) {
-				string memberName = NamingUtilities.Combine(param.Member.DeclaringType.FullName, param.Member.Name);
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParameterNamesDoNotHaveUnderscores.Resolution}&quot;, memberName, new string[,] {{&quot;ParameterName&quot;, param.Name}, {&quot;MemberName&quot;, memberName}});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class ParameterNamesDoNotHaveUnderscoresTest
-	{
-		public class A {
-			public void TestMethod1(int right)
-			{
-			}
-			public void TestMethod2(int a, int b, int c, int d)
-			{
-			}
-			public void TestMethod3(int wrong_)
-			{
-			}
-			public void TestMethod4(int _a, int b_c, int ____, int wrong_)
-			{
-			}
-			public static void TestMethod(MethodInfo methodInfo, bool isNull)
-			{
-				ParameterNamesDoNotHaveUnderscores parameterNamesDoNotHaveUnderscores = new ParameterNamesDoNotHaveUnderscores();
-				foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
-					if (isNull) {
-						Assertion.AssertNull(parameterNamesDoNotHaveUnderscores.Check(null, parameter));
-					} else {
-						Assertion.AssertNotNull(parameterNamesDoNotHaveUnderscores.Check(null, parameter));
-					}
-				}
-			}
-		}
-		
-		
-		[Test]
-		public void TestCorrectParameters()
-		{
-			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod1&quot;), true);
-			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod2&quot;), true);
-		}
-		
-		[Test]
-		public void TestIncorrectParameters()
-		{
-			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod3&quot;), false);
-			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod4&quot;), false);
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+using System.Collections;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of ParameterNamesDoNotHaveUnderscores.	
+	/// &lt;/summary&gt;
+	public class ParameterNamesDoNotHaveUnderscores : AbstractReflectionRule, IParameterRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Parameter names do not contain underscores '_'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Underscores should never be used inside parameter names.&quot;;
+			}
+		}
+		
+		public ParameterNamesDoNotHaveUnderscores()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Module module, ParameterInfo param)
+		{
+			if (param.Name != null &amp;&amp; param.Name.IndexOf('_') &gt;= 0) {
+				string memberName = NamingUtilities.Combine(param.Member.DeclaringType.FullName, param.Member.Name);
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Remove all underscores in parameter &lt;code&gt;{0}&lt;/code&gt; inside member &lt;code&gt;{1}&lt;/code&gt;.&quot;, param.Name, memberName), memberName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class ParameterNamesDoNotHaveUnderscoresTest
+	{
+		public class A {
+			public void TestMethod1(int right)
+			{
+			}
+			public void TestMethod2(int a, int b, int c, int d)
+			{
+			}
+			public void TestMethod3(int wrong_)
+			{
+			}
+			public void TestMethod4(int _a, int b_c, int ____, int wrong_)
+			{
+			}
+			public static void TestMethod(MethodInfo methodInfo, bool isNull)
+			{
+				ParameterNamesDoNotHaveUnderscores parameterNamesDoNotHaveUnderscores = new ParameterNamesDoNotHaveUnderscores();
+				foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
+					if (isNull) {
+						Assertion.AssertNull(parameterNamesDoNotHaveUnderscores.Check(null, parameter));
+					} else {
+						Assertion.AssertNotNull(parameterNamesDoNotHaveUnderscores.Check(null, parameter));
+					}
+				}
+			}
+		}
+		
+		
+		[Test]
+		public void TestCorrectParameters()
+		{
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod1&quot;), true);
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod2&quot;), true);
+		}
+		
+		[Test]
+		public void TestIncorrectParameters()
+		{
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod3&quot;), false);
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod4&quot;), false);
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParametersAreCamelCased.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParametersAreCamelCased.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParametersAreCamelCased.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,100 +1,101 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-using System.Collections;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of NamespacesArePascalCased.	
-	/// &lt;/summary&gt;
-	public class ParametersAreCamelCased : AbstractReflectionRule, IParameterRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParametersAreCamelCased.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParametersAreCamelCased.Details}&quot;;
-			}
-		}
-		
-		public ParametersAreCamelCased()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Module module, ParameterInfo param)
-		{
-			if (!NamingUtilities.IsCamelCase(param.Name)) {
-				string memberName = NamingUtilities.Combine(param.Member.DeclaringType.FullName, param.Member.Name);
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParametersAreCamelCased.Resolution}&quot;, memberName, new string[,] {{&quot;ParameterName&quot;, param.Name}, {&quot;MemberName&quot;, memberName}, {&quot;AlternateName&quot;, NamingUtilities.CamelCase(param.Name)}});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class ParametersAreCamelCasedTest
-	{
-		public class A {
-			public void TestMethod1(int right)
-			{
-			}
-			public void TestMethod2(int a, int b, int c, int d)
-			{
-			}
-			public void TestMethod3(int Wrong)
-			{
-			}
-			public void TestMethod4(int A, int B, int C, int D)
-			{
-			}
-			public static void TestMethod(MethodInfo methodInfo, bool isNull)
-			{
-				ParametersAreCamelCased parametersAreCamelCased = new ParametersAreCamelCased();
-				foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
-					if (isNull) {
-						Assertion.AssertNull(parametersAreCamelCased.Check(null, parameter));
-					} else {
-						Assertion.AssertNotNull(parametersAreCamelCased.Check(null, parameter));
-					}
-				}
-			}
-		}
-		
-		
-		[Test]
-		public void TestCorrectParameters()
-		{
-			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod1&quot;), true);
-			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod2&quot;), true);
-		}
-		
-		[Test]
-		public void TestIncorrectParameters()
-		{
-			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod3&quot;), false);
-			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod4&quot;), false);
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+using System.Collections;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of ParametersArePascalCased.	
+	/// &lt;/summary&gt;
+	public class ParametersAreCamelCased : AbstractReflectionRule, IParameterRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Parameter names should be camel cased&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Camel casing lowercase the first letter like in &lt;code&gt;&lt;b&gt;m&lt;/b&gt;ousePosition&lt;/code&gt; but the starting letters of all subsequent words are capitalized. Use camel casing for all parameters.&quot;;
+			}
+		}
+		
+		public ParametersAreCamelCased()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Module module, ParameterInfo param)
+		{
+			if (!NamingUtilities.IsCamelCase(param.Name)) {
+				string memberName = NamingUtilities.Combine(param.Member.DeclaringType.FullName, param.Member.Name);
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Use camel casing for the parameter &lt;code&gt;{0}&lt;/code&gt; inside member &lt;code&gt;{1}&lt;/code&gt;.&lt;BR&gt;For example: &lt;code&gt;{2}&lt;/code&gt;.&quot;, param.Name, memberName, NamingUtilities.CamelCase (param.Name)), memberName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class ParametersAreCamelCasedTest
+	{
+		public class A {
+			public void TestMethod1(int right)
+			{
+			}
+			public void TestMethod2(int a, int b, int c, int d)
+			{
+			}
+			public void TestMethod3(int Wrong)
+			{
+			}
+			public void TestMethod4(int A, int B, int C, int D)
+			{
+			}
+			public static void TestMethod(MethodInfo methodInfo, bool isNull)
+			{
+				ParametersAreCamelCased parametersAreCamelCased = new ParametersAreCamelCased();
+				foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
+					if (isNull) {
+						Assertion.AssertNull(parametersAreCamelCased.Check(null, parameter));
+					} else {
+						Assertion.AssertNotNull(parametersAreCamelCased.Check(null, parameter));
+					}
+				}
+			}
+		}
+		
+		
+		[Test]
+		public void TestCorrectParameters()
+		{
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod1&quot;), true);
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod2&quot;), true);
+		}
+		
+		[Test]
+		public void TestIncorrectParameters()
+		{
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod3&quot;), false);
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod4&quot;), false);
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/PermissionSuffixIsPermissionRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/PermissionSuffixIsPermissionRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/PermissionSuffixIsPermissionRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,64 +1,65 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of PermissionSuffixIsPermissionRule.	
-	/// &lt;/summary&gt;
-	public class PermissionSuffixIsPermissionRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PermissionSuffixIsPermission.Description}&quot;;
-			}
-		}
-		
-		// System.Attribute
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PermissionSuffixIsPermission.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (typeof(System.Security.IPermission).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Permission&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PermissionSuffixIsPermission.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class PermissionSuffixIsPermissionRuleTest
-	{
-		[Test]
-		public void TestCorrectPermission()
-		{
-			PermissionSuffixIsPermissionRule rule = new PermissionSuffixIsPermissionRule();
-			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.EnvironmentPermission)));
-			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.FileIOPermission)));
-			Assertion.AssertNull(rule.Check(typeof(PermissionSuffixIsPermissionRuleTest)));
-		}
-		
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of PermissionSuffixIsPermissionRule.	
+	/// &lt;/summary&gt;
+	public class PermissionSuffixIsPermissionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Permission names have the suffix 'Permission'&quot;;
+			}
+		}
+		
+		// System.Attribute
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that extends &lt;code&gt;&lt;a href='<A HREF="help://types/System.Security.IPermission'">help://types/System.Security.IPermission'</A>&gt;IPermission&lt;/a&gt;&lt;/code&gt; is a permission and its name should always end with &lt;i&gt;Permission&lt;/i&gt; like in &lt;code&gt;FileIOPermission&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.Security.IPermission).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Permission&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;I&gt;Permission&lt;/I&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class PermissionSuffixIsPermissionRuleTest
+	{
+		[Test]
+		public void TestCorrectPermission()
+		{
+			PermissionSuffixIsPermissionRule rule = new PermissionSuffixIsPermissionRule();
+			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.EnvironmentPermission)));
+			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.FileIOPermission)));
+			Assertion.AssertNull(rule.Check(typeof(PermissionSuffixIsPermissionRuleTest)));
+		}
+		
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/StreamSuffixIsStreamRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/StreamSuffixIsStreamRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/StreamSuffixIsStreamRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,86 +1,87 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of StreamSuffixIsStreamRule.	
-	/// &lt;/summary&gt;
-	public class StreamSuffixIsStreamRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.StreamSuffixIsStream.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.StreamSuffixIsStream.Details}&quot;;
-			}
-		}
-		
-		public StreamSuffixIsStreamRule()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (typeof(System.IO.Stream).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Stream&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.StreamSuffixIsStream.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using System.IO;
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class StreamSuffixIsStreamRuleTest
-	{
-		class MyOtherClass
-		{
-		}
-		class RealStream : System.IO.FileStream  
-		{
-			public RealStream(string path,FileMode mode) : base(path, mode)
-			{}
-		}
-		[Test]
-		public void TestCorrectStream()
-		{
-			StreamSuffixIsStreamRule rule = new StreamSuffixIsStreamRule();
-			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
-			Assertion.AssertNull(rule.Check(typeof(RealStream)));
-		}
-		
-		class WrongStrm : System.IO.FileStream  
-		{
-			public WrongStrm(string path,FileMode mode) : base(path, mode)
-			{}
-		}
-		[Test]
-		public void TestIncorrectStream()
-		{
-			StreamSuffixIsStreamRule rule = new StreamSuffixIsStreamRule();
-			Assertion.AssertNotNull(rule.Check(typeof(WrongStrm)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of StreamSuffixIsStreamRule.	
+	/// &lt;/summary&gt;
+	public class StreamSuffixIsStreamRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Stream names have the suffix 'Stream'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;A type that extends &lt;code&gt;&lt;a href='<A HREF="help://types/System.IO.Stream'">help://types/System.IO.Stream'</A>&gt;Stream&lt;/a&gt;&lt;/code&gt; is a stream and its name should always end with &lt;i&gt;Stream&lt;/i&gt; like in &lt;code&gt;FileStream&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public StreamSuffixIsStreamRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.IO.Stream).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Stream&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it ends with &lt;I&gt;Stream&lt;/I&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using System.IO;
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class StreamSuffixIsStreamRuleTest
+	{
+		class MyOtherClass
+		{
+		}
+		class RealStream : System.IO.FileStream  
+		{
+			public RealStream(string path,FileMode mode) : base(path, mode)
+			{}
+		}
+		[Test]
+		public void TestCorrectStream()
+		{
+			StreamSuffixIsStreamRule rule = new StreamSuffixIsStreamRule();
+			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
+			Assertion.AssertNull(rule.Check(typeof(RealStream)));
+		}
+		
+		class WrongStrm : System.IO.FileStream  
+		{
+			public WrongStrm(string path,FileMode mode) : base(path, mode)
+			{}
+		}
+		[Test]
+		public void TestIncorrectStream()
+		{
+			StreamSuffixIsStreamRule rule = new StreamSuffixIsStreamRule();
+			Assertion.AssertNotNull(rule.Check(typeof(WrongStrm)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,77 +1,78 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class TypeNamesDoNotContainUnderscores : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypeNamesDoNotContainUnderscores.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypeNamesDoNotContainUnderscores.Details}&quot;;
-			}
-		}
-		
-		public TypeNamesDoNotContainUnderscores()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (NamingUtilities.ContainsUnderscore(type.Name)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypeNamesDoNotContainUnderscores.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class TypeNamesDoNotContainUnderscoresTest
-	{
-		interface ICorrectInterface
-		{
-		}
-		[Test]
-		public void TestCorrectTypenames()
-		{
-			TypeNamesDoNotContainUnderscores typeNamesDoNotContainUnderscores = new TypeNamesDoNotContainUnderscores();
-			Assertion.AssertNull(typeNamesDoNotContainUnderscores.Check(typeof(ICorrectInterface)));
-		}
-		
-		class Wrong_Class
-		{
-		}
-		[Test]
-		public void TestIncorrectTypenames()
-		{
-			TypeNamesDoNotContainUnderscores typeNamesDoNotContainUnderscores = new TypeNamesDoNotContainUnderscores();
-			Assertion.AssertNotNull(typeNamesDoNotContainUnderscores.Check(typeof(Wrong_Class)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of TypeNamesDoNotContainUnderscores.
+	/// &lt;/summary&gt;
+	public class TypeNamesDoNotContainUnderscores : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Type names do not contain underscores '_'&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Underscores should never be used inside type names.&quot;;
+			}
+		}
+		
+		public TypeNamesDoNotContainUnderscores()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (NamingUtilities.ContainsUnderscore(type.Name)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Remove all underscores in the type name &lt;code&gt;{0}&lt;/code&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypeNamesDoNotContainUnderscoresTest
+	{
+		interface ICorrectInterface
+		{
+		}
+		[Test]
+		public void TestCorrectTypenames()
+		{
+			TypeNamesDoNotContainUnderscores typeNamesDoNotContainUnderscores = new TypeNamesDoNotContainUnderscores();
+			Assertion.AssertNull(typeNamesDoNotContainUnderscores.Check(typeof(ICorrectInterface)));
+		}
+		
+		class Wrong_Class
+		{
+		}
+		[Test]
+		public void TestIncorrectTypenames()
+		{
+			TypeNamesDoNotContainUnderscores typeNamesDoNotContainUnderscores = new TypeNamesDoNotContainUnderscores();
+			Assertion.AssertNotNull(typeNamesDoNotContainUnderscores.Check(typeof(Wrong_Class)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesArePascalCased.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesArePascalCased.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesArePascalCased.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,83 +1,84 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of AttributeSuffixIsAttribute.	
-	/// &lt;/summary&gt;
-	public class TypesArePascalCased : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesArePascalCased.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesArePascalCased.Details}&quot;;
-			}
-		}
-		
-		public TypesArePascalCased()
-		{
-			base.certainty = 99;
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (!NamingUtilities.IsPascalCase(type.Name)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesArePascalCased.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }, {&quot;AlternateName&quot;, NamingUtilities.PascalCase(type.Name)}});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class TypesArePascalCasedTest
-	{
-		interface IInterface
-		{
-		}
-		class AClassImplTest
-		{
-			
-		}
-		[Test]
-		public void TestCorrectTypenames()
-		{
-			TypesArePascalCased typesArePascalCased = new TypesArePascalCased();
-			Assertion.AssertNull(typesArePascalCased.Check(typeof(IInterface)));
-			Assertion.AssertNull(typesArePascalCased.Check(typeof(AClassImplTest)));
-		}
-		
-		class wrong
-		{
-			
-		}
-		[Test]
-		public void TestIncorrectTypenames()
-		{
-			TypesArePascalCased typesArePascalCased = new TypesArePascalCased();
-			Assertion.AssertNotNull(typesArePascalCased.Check(typeof(wrong)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of TypesArePascalCased.	
+	/// &lt;/summary&gt;
+	public class TypesArePascalCased : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Type names should be pascal cased&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Pascal casing capitalized the first letter like in &lt;code&gt;&lt;b&gt;A&lt;/b&gt;ppDomain&lt;/code&gt;. Use pascal casing for all type names.&quot;;
+			}
+		}
+		
+		public TypesArePascalCased()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!NamingUtilities.IsPascalCase(type.Name)) {
+				// FIXME: I18N
+				return new Resolution(this, String.Format (&quot;Use pascal casing for the type &lt;code&gt;{0}&lt;/code&gt;.&lt;BR&gt;For example: &lt;code&gt;{1}&lt;/code&gt;.&quot;, type.FullName, NamingUtilities.PascalCase (type.FullName)),  type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypesArePascalCasedTest
+	{
+		interface IInterface
+		{
+		}
+		class AClassImplTest
+		{
+			
+		}
+		[Test]
+		public void TestCorrectTypenames()
+		{
+			TypesArePascalCased typesArePascalCased = new TypesArePascalCased();
+			Assertion.AssertNull(typesArePascalCased.Check(typeof(IInterface)));
+			Assertion.AssertNull(typesArePascalCased.Check(typeof(AClassImplTest)));
+		}
+		
+		class wrong
+		{
+			
+		}
+		[Test]
+		public void TestIncorrectTypenames()
+		{
+			TypesArePascalCased typesArePascalCased = new TypesArePascalCased();
+			Assertion.AssertNotNull(typesArePascalCased.Check(typeof(wrong)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,77 +1,78 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of TypesImplementingInterfacesHaveNoSuffixImplRule.	
-	/// &lt;/summary&gt;
-	public class TypesImplementingInterfacesHaveNoSuffixImplRule : AbstractReflectionRule, ITypeRule
-	{
-		public override string Description {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesImplementingInterfacesHaveNoSuffixImpl.Description}&quot;;
-			}
-		}
-		
-		public override string Details {
-			get {
-				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesImplementingInterfacesHaveNoSuffixImpl.Details}&quot;;
-			}
-		}
-		
-		public Resolution Check(Type type)
-		{
-			if (type.GetInterfaces().Length &gt; 0 &amp;&amp; type.Name.EndsWith(&quot;Impl&quot;)) {
-				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesImplementingInterfacesHaveNoSuffixImpl.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
-			}
-			return null;
-		}
-	}
-}
-#region Unit Test
-#if TEST
-/*
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	using NUnit.Framework;
-
-	[TestFixture]
-	public class TypesImplementingInterfacesHaveNoSuffixImplRuleTest
-	{
-		interface IInterface
-		{
-		}
-		class AClassImplTest : IInterface
-		{
-			
-		}
-		[Test]
-		public void TestCorrectTypenames()
-		{
-			TypesImplementingInterfacesHaveNoSuffixImplRule rule = new TypesImplementingInterfacesHaveNoSuffixImplRule();
-			Assertion.AssertNull(rule.Check(typeof(AClassImplTest)));
-		}
-		
-		class BImpl : IInterface
-		{
-			
-		}
-		[Test]
-		public void TestIncorrectTypenames()
-		{
-			TypesImplementingInterfacesHaveNoSuffixImplRule rule = new TypesImplementingInterfacesHaveNoSuffixImplRule();
-			Assertion.AssertNotNull(rule.Check(typeof(BImpl)));
-		}
-	}
-}
-*/
-#endif
-#endregion
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of TypesImplementingInterfacesHaveNoSuffixImplRule.	
+	/// &lt;/summary&gt;
+	public class TypesImplementingInterfacesHaveNoSuffixImplRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				// FIXME: I18N
+				return &quot;Types that implement interfaces have no 'Impl' suffix&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				// FIXME: I18N
+				return &quot;Do not use the &lt;i&gt;Impl&lt;/i&gt; suffix for providing an interface implementation. Consider using the interface name without the &lt;i&gt;I&lt;/i&gt; like &lt;code&gt;Component&lt;/code&gt; that implements &lt;code&gt;IComponent&lt;/code&gt;.&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.GetInterfaces().Length &gt; 0 &amp;&amp; type.Name.EndsWith(&quot;Impl&quot;)) {
+				// FIXME: I18N
+				return new Resolution (this, String.Format (&quot;Change the name of the type &lt;code&gt;{0}&lt;/code&gt; so that it does not end with &lt;i&gt;Impl&lt;/i&gt;.&quot;, type.FullName), type.FullName);
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypesImplementingInterfacesHaveNoSuffixImplRuleTest
+	{
+		interface IInterface
+		{
+		}
+		class AClassImplTest : IInterface
+		{
+			
+		}
+		[Test]
+		public void TestCorrectTypenames()
+		{
+			TypesImplementingInterfacesHaveNoSuffixImplRule rule = new TypesImplementingInterfacesHaveNoSuffixImplRule();
+			Assertion.AssertNull(rule.Check(typeof(AClassImplTest)));
+		}
+		
+		class BImpl : IInterface
+		{
+			
+		}
+		[Test]
+		public void TestIncorrectTypenames()
+		{
+			TypesImplementingInterfacesHaveNoSuffixImplRule rule = new TypesImplementingInterfacesHaveNoSuffixImplRule();
+			Assertion.AssertNotNull(rule.Check(typeof(BImpl)));
+		}
+	}
+}
+#endif
+#endregion

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingUtilities.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingUtilities.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingUtilities.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,73 +1,73 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of NamingUtilities.	
-	/// &lt;/summary&gt;
-	public sealed class NamingUtilities
-	{
-		/// &lt;summary&gt;
-		/// Pascal casing is like 'PascalCase'
-		/// &lt;/summary&gt;
-		public static bool IsPascalCase(string name)
-		{
-			if (name == null || name.Length == 0) {
-				return true;
-			}
-			return Char.IsUpper(name[0]);
-		}
-		
-		public static string PascalCase(string name)
-		{
-			if (name == null || name.Length == 0) {
-				return name;
-			}
-			return Char.ToUpper(name[0]) + name.Substring(1);
-		}
-		
-		
-		/// &lt;summary&gt;
-		/// Camel casing is like 'camelCase'
-		/// &lt;/summary&gt;
-		public static bool IsCamelCase(string name)
-		{
-			if (name == null || name.Length == 0) {
-				return true;
-			}
-			return Char.IsLower(name[0]);
-		}
-		
-		
-		public static string CamelCase(string name)
-		{
-			if (name == null || name.Length == 0) {
-				return name;
-			}
-			return Char.ToLower(name[0]) + name.Substring(1);
-		}
-		
-		public static bool ContainsUnderscore(string name)
-		{
-			if (name == null || name.Length == 0) {
-				return false;
-			}
-			return name.IndexOf('_') &gt;= 0;
-		}
-		
-		public static string Combine(string typeName, string memberName)
-		{
-			return String.Concat(typeName, 
-			                     '.',
-			                     memberName);
-		}
-		
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of NamingUtilities.	
+	/// &lt;/summary&gt;
+	public sealed class NamingUtilities
+	{
+		/// &lt;summary&gt;
+		/// Pascal casing is like 'PascalCase'
+		/// &lt;/summary&gt;
+		public static bool IsPascalCase(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return true;
+			}
+			return Char.IsUpper(name[0]);
+		}
+		
+		public static string PascalCase(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return name;
+			}
+			return Char.ToUpper(name[0]) + name.Substring(1);
+		}
+		
+		
+		/// &lt;summary&gt;
+		/// Camel casing is like 'camelCase'
+		/// &lt;/summary&gt;
+		public static bool IsCamelCase(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return true;
+			}
+			return Char.IsLower(name[0]);
+		}
+		
+		
+		public static string CamelCase(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return name;
+			}
+			return Char.ToLower(name[0]) + name.Substring(1);
+		}
+		
+		public static bool ContainsUnderscore(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return false;
+			}
+			return name.IndexOf('_') &gt;= 0;
+		}
+		
+		public static string Combine(string typeName, string memberName)
+		{
+			return String.Concat(typeName, 
+			                     '.',
+			                     memberName);
+		}
+		
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/PriorityLevel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/PriorityLevel.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/PriorityLevel.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,24 +1,24 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	/// &lt;summary&gt;
-	/// Description of IAssemblyRule.	
-	/// &lt;/summary&gt;
-	public enum PriorityLevel
-	{
-		Information,
-		Warning,
-		CriticalWarning,
-		Error,
-		CriticalError
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IAssemblyRule.	
+	/// &lt;/summary&gt;
+	public enum PriorityLevel
+	{
+		Information,
+		Warning,
+		CriticalWarning,
+		Error,
+		CriticalError
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ProtectionLevels.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ProtectionLevels.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ProtectionLevels.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -1,35 +1,35 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Reflection;
-
-namespace MonoDevelop.AssemblyAnalyser.Rules
-{
-	[Flags]
-	public enum ProtectionLevels
-	{
-		None = 0,
-		
-		Public   = 1,
-		Family   = 2,
-		Private  = 4,
-		Assembly = 8,
-		FamilyAndAssembly = 16,
-		FamilyOrAssembly  = 32,
-		
-		NestedPublic   = 64,
-		NestedFamily   = 128,
-		NestedPrivate  = 256,
-		NestedAssembly = 512,
-		NestedFamilyAndAssembly = 1024,
-		NestedFamilyOrAssembly = 2048,
-		
-		All = Public | Family | Private | Assembly | FamilyAndAssembly | FamilyOrAssembly |
-		      NestedPublic | NestedFamily | NestedPrivate | NestedAssembly | NestedFamilyAndAssembly | NestedFamilyOrAssembly,
-	}
-}
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.AssemblyAnalyser.Rules
+{
+	[Flags]
+	public enum ProtectionLevels
+	{
+		None = 0,
+		
+		Public   = 1,
+		Family   = 2,
+		Private  = 4,
+		Assembly = 8,
+		FamilyAndAssembly = 16,
+		FamilyOrAssembly  = 32,
+		
+		NestedPublic   = 64,
+		NestedFamily   = 128,
+		NestedPrivate  = 256,
+		NestedAssembly = 512,
+		NestedFamilyAndAssembly = 1024,
+		NestedFamilyOrAssembly = 2048,
+		
+		All = Public | Family | Private | Assembly | FamilyAndAssembly | FamilyOrAssembly |
+		      NestedPublic | NestedFamily | NestedPrivate | NestedAssembly | NestedFamilyAndAssembly | NestedFamilyOrAssembly,
+	}
+}

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Commands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Commands.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Commands.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -7,10 +7,11 @@
 using System;
 using System.Reflection;
 
-using MonoDevelop.AssemblyAnalyser.Rules;
 using MonoDevelop.Core.AddIns.Codons;
 using MonoDevelop.Gui;
 
+using ICSharpCode.AssemblyAnalyser.Rules;
+
 namespace MonoDevelop.AssemblyAnalyser
 {
 	public class ShowAssemblyAnalyser : AbstractMenuCommand

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserControl.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserControl.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserControl.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -11,6 +11,8 @@
 using System.Reflection;
 using Gtk;
 
+using AssemblyAnalyser = ICSharpCode.AssemblyAnalyser.AssemblyAnalyser;
+
 namespace MonoDevelop.AssemblyAnalyser
 {
 	public class AssemblyAnalyserControl : Frame

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserView.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserView.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserView.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -19,6 +19,8 @@
 using MonoDevelop.Core.Services;
 using MonoDevelop.Internal.Project;
 
+using AssemblyAnalyser = ICSharpCode.AssemblyAnalyser.AssemblyAnalyser;
+
 namespace MonoDevelop.AssemblyAnalyser
 {
 	public class AssemblyAnalyserView : AbstractViewContent

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyTreeControl.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyTreeControl.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyTreeControl.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -15,6 +15,8 @@
 using MonoDevelop.Core.Services;
 using MonoDevelop.Services;
 
+using AssemblyAnalyser = ICSharpCode.AssemblyAnalyser.AssemblyAnalyser;
+
 namespace MonoDevelop.AssemblyAnalyser
 {
 	public class AssemblyTreeControl : TreeView

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultDetailsView.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultDetailsView.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultDetailsView.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -15,9 +15,12 @@
 using MonoDevelop.Core;
 using MonoDevelop.Services;
 using MonoDevelop.Core.Services;
-using MonoDevelop.AssemblyAnalyser.Rules;
 using MonoDevelop.Gui.Pads;
 
+using AssemblyAnalyser = ICSharpCode.AssemblyAnalyser.AssemblyAnalyser;
+using Resolution = ICSharpCode.AssemblyAnalyser.Resolution;
+using ICSharpCode.AssemblyAnalyser.Rules;
+
 namespace MonoDevelop.AssemblyAnalyser
 {
 	public class ResultDetailsView : Frame

Modified: trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultListControl.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultListControl.cs	2004-10-24 02:16:32 UTC (rev 1996)
+++ trunk/MonoDevelop/Core/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultListControl.cs	2004-10-26 03:51:03 UTC (rev 1997)
@@ -12,9 +12,12 @@
 using Gtk;
 
 using MonoDevelop.Core.Services;
-using MonoDevelop.AssemblyAnalyser.Rules;
 using MonoDevelop.Services;
 
+using AssemblyAnalyser = ICSharpCode.AssemblyAnalyser.AssemblyAnalyser;
+using Resolution = ICSharpCode.AssemblyAnalyser.Resolution;
+using ICSharpCode.AssemblyAnalyser.Rules;
+
 namespace MonoDevelop.AssemblyAnalyser
 {
 	public class ResultListControl : TreeView


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001600.html">[Monodevelop-patches-list] r1996 - in trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn: . Gui
</A></li>
	<LI>Next message: <A HREF="001602.html">[Monodevelop-patches-list] r1998 - in trunk/MonoDevelop/Core/src: Libraries/MonoDevelop.Gui.Widgets/DragNotebook Main/Base/Gui/Workbench/Layouts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1601">[ date ]</a>
              <a href="thread.html#1601">[ thread ]</a>
              <a href="subject.html#1601">[ subject ]</a>
              <a href="author.html#1601">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
