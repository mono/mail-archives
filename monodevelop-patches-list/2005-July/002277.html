<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2677 - in trunk/MonoDevelop:	Core/src/AddIns/DisplayBindings/SourceEditor	Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion	Core/src/AddIns/DisplayBindings/SourceEditor/Gui	Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow	Core/src/MonoDevelop.Base Core/src/MonoDevelop.Base/Gui	Core/src/MonoDevelop.Base/Gui/Completion	Core/src/MonoDevelop.Base/Services/ParserService	Extras/BooBinding Extras/BooBinding/BooShell	Extras/BooBinding/Gui Extras/BooBinding/Gui/OptionPanels	Extras/BooBinding/Parser Extras/BooBinding/Properties
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2677%20-%20in%20trunk/MonoDevelop%3A%0A%09Core/src/AddIns/DisplayBindings/SourceEditor%0A%09Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion%0A%09Core/src/AddIns/DisplayBindings/SourceEditor/Gui%0A%09Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow%0A%09Core/src/MonoDevelop.Base%20Core/src/MonoDevelop.Base/Gui%0A%09Core/src/MonoDevelop.Base/Gui/Completion%0A%09Core/src/MonoDevelop.Base/Services/ParserService%0A%09Extras/BooBinding%20Extras/BooBinding/BooShell%0A%09Extras/BooBinding/Gui%20Extras/BooBinding/Gui/OptionPanels%0A%09Extras/BooBinding/Parser%20Extras/BooBinding/Properties&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002276.html">
   <LINK REL="Next"  HREF="002278.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2677 - in trunk/MonoDevelop:	Core/src/AddIns/DisplayBindings/SourceEditor	Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion	Core/src/AddIns/DisplayBindings/SourceEditor/Gui	Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow	Core/src/MonoDevelop.Base Core/src/MonoDevelop.Base/Gui	Core/src/MonoDevelop.Base/Gui/Completion	Core/src/MonoDevelop.Base/Services/ParserService	Extras/BooBinding Extras/BooBinding/BooShell	Extras/BooBinding/Gui Extras/BooBinding/Gui/OptionPanels	Extras/BooBinding/Parser Extras/BooBinding/Properties</H1>
    <B>Peter Johanson &lt;latexer@gentoo.org&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2677%20-%20in%20trunk/MonoDevelop%3A%0A%09Core/src/AddIns/DisplayBindings/SourceEditor%0A%09Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion%0A%09Core/src/AddIns/DisplayBindings/SourceEditor/Gui%0A%09Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow%0A%09Core/src/MonoDevelop.Base%20Core/src/MonoDevelop.Base/Gui%0A%09Core/src/MonoDevelop.Base/Gui/Completion%0A%09Core/src/MonoDevelop.Base/Services/ParserService%0A%09Extras/BooBinding%20Extras/BooBinding/BooShell%0A%09Extras/BooBinding/Gui%20Extras/BooBinding/Gui/OptionPanels%0A%09Extras/BooBinding/Parser%20Extras/BooBinding/Properties&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2677 - in trunk/MonoDevelop:	Core/src/AddIns/DisplayBindings/SourceEditor	Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion	Core/src/AddIns/DisplayBindings/SourceEditor/Gui	Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow	Core/src/MonoDevelop.Base Core/src/MonoDevelop.Base/Gui	Core/src/MonoDevelop.Base/Gui/Completion	Core/src/MonoDevelop.Base/Services/ParserService	Extras/BooBinding Extras/BooBinding/BooShell	Extras/BooBinding/Gui Extras/BooBinding/Gui/OptionPanels	Extras/BooBinding/Parser Extras/BooBinding/Properties">pjohanson at mono-cvs.ximian.com
       </A><BR>
    <I>Wed Jul 20 12:12:51 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002276.html">[Monodevelop-patches-list] r2676 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Gui/Pads/ProjectPad
</A></li>
        <LI>Next message: <A HREF="002278.html">[Monodevelop-patches-list] r2678 - in	trunk/MonoDevelop/Extras/BooBinding: . Gui/OptionPanels
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2277">[ date ]</a>
              <a href="thread.html#2277">[ thread ]</a>
              <a href="subject.html#2277">[ subject ]</a>
              <a href="author.html#2277">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pjohanson
Date: 2005-07-20 12:12:50 -0400 (Wed, 20 Jul 2005)
New Revision: 2677

Added:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CodeCompletionData.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CodeCompletionDataProvider.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CommentCompletionDataProvider.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CompletionListWindow.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/DeclarationViewWindow.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionData.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionDataProvider.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionWidget.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ListWindow.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/TemplateCompletionDataProvider.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/TextUtilities.cs
Removed:
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionWindow.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs
Modified:
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/IndexerInsightDataProvider.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/InsightWindow.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/MethodInsightDataProvider.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Makefile.am
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs
   trunk/MonoDevelop/Extras/BooBinding/BooShell/BooShell.boo
   trunk/MonoDevelop/Extras/BooBinding/BooShellPadContent.boo
   trunk/MonoDevelop/Extras/BooBinding/ChangeLog
   trunk/MonoDevelop/Extras/BooBinding/Gui/BooShellModel.boo
   trunk/MonoDevelop/Extras/BooBinding/Gui/IShellModel.boo
   trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/CodeCompilationPanel.boo
   trunk/MonoDevelop/Extras/BooBinding/Gui/ShellTextView.boo
   trunk/MonoDevelop/Extras/BooBinding/Makefile.am
   trunk/MonoDevelop/Extras/BooBinding/Parser/BooParser.boo
   trunk/MonoDevelop/Extras/BooBinding/Parser/Resolver.boo
   trunk/MonoDevelop/Extras/BooBinding/Properties/ShellProperties.boo
Log:
Massive commit of code completion API changes. Code completion is now in MonoDevelop.Base instead of hiding in the SourceEditor.


Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/ChangeLog	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/ChangeLog	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,3 +1,13 @@
+2005-07-20  Peter Johanson  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>&gt;
+
+	* CodeCompletion/*: Migrated to MonoDevelop.Base assembly.
+	* Makefile.am: Remove CodeCompletion file entries.
+	* Gui/SourceEditorView.cs:
+	* InsightWindow/InsightWindow.cs:
+	* InsightWindow/IndexerInsightDataProvider.cs:
+	* InsightWindow/MethodInsightDataProvider.cs: Changed to reflect
+	completion API/location changes.
+
 2005-07-20  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt; 
 
 	* Gui/SourceEditorWidget.cs: Implemented FindPrevious command.

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,289 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#195;?&#194;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Xml;
-using System.Text;
-using System.Text.RegularExpressions;
-using System.IO;
-using System.Collections;
-
-using MonoDevelop.Internal.Parser;
-using MonoDevelop.Services;
-using MonoDevelop.Core.Services;
-using MonoDevelop.SourceEditor.Gui;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	class CodeCompletionData : ICompletionDataWithMarkup
-	{
-		IconService classBrowserIconService = (IconService) ServiceManager.GetService (typeof (IconService));
-		IParserService parserService = (IParserService) MonoDevelop.Core.Services.ServiceManager.GetService (typeof (IParserService));
-		static AmbienceService ambienceService = (AmbienceService) ServiceManager.GetService (typeof (AmbienceService));
-		
-		string image;
-		int overloads;
-		string text;
-		string description;
-		string pango_description;
-		string documentation;
-		string completionString;
-		IClass c;
-		bool convertedDocumentation = false;
-		
-		static IAmbience PangoAmbience
-		{
-			get {
-				IAmbience asvc = ambienceService.CurrentAmbience;
-				asvc.ConversionFlags |= ConversionFlags.IncludePangoMarkup;
-				return asvc;
-			}
-		}
-
-		public string CompletionString 
-		{
-			get 
-			{
-				return completionString;
-			}
-		}
-		
-		
-		public int Overloads
-		{
-			get {
-				//return overloads;
-				return overload_data.Count;
-			}
-			set {
-				overloads = value;
-			}
-		}
-		
-		public string Image
-		{
-			get {
-				return image;
-			}
-			set {
-				image = value;
-			}
-		}
-		
-		public string[] Text
-		{
-			get {
-				return new string[] { text };
-			}
-			set {
-				text = value[0];
-			}
-		}
-		public string SimpleDescription
-		{
-			get {
-				return description;
-			}
-		}
-				
-		public string Description
-		{
-			get {
-				// don't give a description string, if no documentation or description is provided
-				if (description.Length + documentation.Length == 0) {
-					return null;
-				}
-				if (!convertedDocumentation) {
-					convertedDocumentation = true;
-					try {
-						documentation = GetDocumentation(documentation);
-					} catch (Exception e) {
-						Console.WriteLine(e.ToString());
-					}
-				}
-				return (description + &quot;\n&quot; + documentation).Trim ();
-			}
-			set {
-				description = value;
-			}
-		}
-		
-		public string DescriptionPango
-		{
-			get {
-				// don't give a description string, if no documentation or description is provided
-				if (description.Length + documentation.Length == 0) {
-					return null;
-				}
-				if (!convertedDocumentation) {
-					convertedDocumentation = true;
-					try {
-						documentation = GetDocumentation(documentation);
-					} catch (Exception e) {
-						Console.WriteLine(e.ToString());
-					}
-				}
-				return (pango_description + &quot;\n&quot; + documentation).Trim ();
-			}
-			set {
-				description = value;
-			}
-		}
-
-		Hashtable overload_data = new Hashtable ();
-
-		public CodeCompletionData[] GetOverloads ()
-		{
-			return (CodeCompletionData[]) (new ArrayList (overload_data.Values)).ToArray (typeof (CodeCompletionData));
-		}
-
-		public void AddOverload (CodeCompletionData overload)
-		{
-			string desc = overload.SimpleDescription;
-
-			if (desc != description || !overload_data.Contains (desc))
-				overload_data[desc] = overload;
-		}
-		
-		public CodeCompletionData (string s, string image)
-		{
-			description = pango_description = documentation = String.Empty;
-			text = s;
-			completionString = s;
-			this.image = image;
-		}
-		
-		public CodeCompletionData (IClass c)
-		{
-			// save class (for the delegate description shortcut
-			this.c = c;
-			image = classBrowserIconService.GetIcon(c);
-			text = c.Name;
-			completionString = c.Name;
-			description = ambienceService.CurrentAmbience.Convert(c);
-			pango_description  = PangoAmbience.Convert(c);
-			documentation = c.Documentation;
-		}
-		
-		public CodeCompletionData (IMethod method)
-		{
-			image  = classBrowserIconService.GetIcon(method);
-			text        = method.Name;
-			description = ambienceService.CurrentAmbience.Convert(method);
-			pango_description  = PangoAmbience.Convert (method);
-			completionString = method.Name;
-			documentation = method.Documentation;
-		}
-		
-		public CodeCompletionData (IField field)
-		{
-			image  = classBrowserIconService.GetIcon(field);
-			text        = field.Name;
-			description = ambienceService.CurrentAmbience.Convert(field);
-			pango_description  = PangoAmbience.Convert (field);
-			completionString = field.Name;
-			documentation = field.Documentation;
-		}
-		
-		public CodeCompletionData (IProperty property)
-		{
-			image  = classBrowserIconService.GetIcon(property);
-			text        = property.Name;
-			description = ambienceService.CurrentAmbience.Convert(property);
-			pango_description  = PangoAmbience.Convert (property);
-			completionString = property.Name;
-			documentation = property.Documentation;
-		}
-		
-		public CodeCompletionData (IEvent e)
-		{
-			image  = classBrowserIconService.GetIcon(e);
-			text        = e.Name;
-			description = ambienceService.CurrentAmbience.Convert(e);
-			pango_description  = PangoAmbience.Convert (e);
-			completionString = e.Name;
-			documentation = e.Documentation;
-		}
-
-		public CodeCompletionData (IParameter o)
-		{
-			image = MonoDevelop.Gui.Stock.Field;
-			text  = o.Name;
-			description = &quot;&quot;;
-			pango_description = &quot;&quot;;
-			completionString = o.Name;
-			documentation = &quot;&quot;;
-		}
-		
-		public void InsertAction (SourceEditorView control)
-		{
-			control.Buffer.InsertAtCursor (completionString);
-		}
-
-		public static string GetDocumentation (string doc)
-		{
-			System.IO.StringReader reader = new System.IO.StringReader(&quot;&lt;docroot&gt;&quot; + doc + &quot;&lt;/docroot&gt;&quot;);
-			XmlTextReader xml   = new XmlTextReader(reader);
-			StringBuilder ret   = new StringBuilder();
-			Regex whitespace    = new Regex(@&quot;(\s|\n)+&quot;, RegexOptions.Singleline);
-			
-			try {
-				xml.Read();
-				do {
-					if (xml.NodeType == XmlNodeType.Element) {
-						string elname = xml.Name.ToLower();
-						if (elname == &quot;remarks&quot;) {
-							ret.Append(&quot;Remarks:\n&quot;);
-						} else if (elname == &quot;example&quot;) {
-							ret.Append(&quot;Example:\n&quot;);
-						} else if (elname == &quot;exception&quot;) {
-							ret.Append(&quot;Exception: &quot; + GetCref(xml[&quot;cref&quot;]) + &quot;:\n&quot;);
-						} else if (elname == &quot;returns&quot;) {
-							ret.Append(&quot;Returns: &quot;);
-						} else if (elname == &quot;see&quot;) {
-							ret.Append(GetCref(xml[&quot;cref&quot;]) + xml[&quot;langword&quot;]);
-						} else if (elname == &quot;seealso&quot;) {
-							ret.Append(&quot;See also: &quot; + GetCref(xml[&quot;cref&quot;]) + xml[&quot;langword&quot;]);
-						} else if (elname == &quot;paramref&quot;) {
-							ret.Append(xml[&quot;name&quot;]);
-						} else if (elname == &quot;param&quot;) {
-							ret.Append(xml[&quot;name&quot;].Trim() + &quot;: &quot;);
-						} else if (elname == &quot;value&quot;) {
-							ret.Append(&quot;Value: &quot;);
-						}
-					} else if (xml.NodeType == XmlNodeType.EndElement) {
-						string elname = xml.Name.ToLower();
-						if (elname == &quot;para&quot; || elname == &quot;param&quot;) {
-							ret.Append(&quot;\n&quot;);
-						}
-					} else if (xml.NodeType == XmlNodeType.Text) {
-						ret.Append(whitespace.Replace(xml.Value, &quot; &quot;));
-					}
-				} while (xml.Read ());
-			} catch {
-				Console.WriteLine (&quot;DocBoom&quot;);
-				return doc;
-			}
-			return ret.ToString ();
-		}
-		
-		static string GetCref (string cref)
-		{
-			if (cref == null)
-				return &quot;&quot;;
-			
-			if (cref.Length &lt; 2)
-				return cref;
-			
-			if (cref.Substring(1, 1) == &quot;:&quot;)
-				return cref.Substring (2, cref.Length - 2);
-			
-			return cref;
-		}
-	
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,159 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#195;?&#194;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Drawing;
-using System.Diagnostics;
-using System.Reflection;
-using System.Collections;
-using System.Collections.Specialized;
-using System.Xml;
-
-using MonoDevelop.Core.Properties;
-using MonoDevelop.Core.Services;
-using MonoDevelop.Gui;
-using MonoDevelop.Internal.Templates;
-using MonoDevelop.Services;
-using MonoDevelop.Internal.Parser;
-using MonoDevelop.Internal.Project;
-
-using MonoDevelop.SourceEditor.Gui;
-using Stock = MonoDevelop.Gui.Stock;
-
-using Gtk;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	/// &lt;summary&gt;
-	/// Data provider for code completion.
-	/// &lt;/summary&gt;
-	public class CodeCompletionDataProvider : ICompletionDataProvider
-	{
-//		static AmbienceService          ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
-		Hashtable insertedClasses = new Hashtable ();
-		Hashtable insertedElements           = new Hashtable();
-		Hashtable insertedPropertiesElements = new Hashtable();
-		Hashtable insertedEventElements      = new Hashtable();
-		
-		int caretLineNumber;
-		int caretColumn;
-		string fileName;
-		bool ctrlspace;
-
-		public CodeCompletionDataProvider() : this (false)
-		{
-		}
-			
-		public CodeCompletionDataProvider (bool ctrl) 
-		{
-			this.ctrlspace = ctrl;
-		}
-		
-		ArrayList completionData = null;
-		
-		public ICompletionData[] GenerateCompletionData(Project project, string fileName, SourceEditorView textArea, char charTyped, TextMark triggerMark)
-		{
-			completionData = new ArrayList();
-			this.fileName = fileName;
-			
-			Gtk.TextIter insertIter = textArea.Buffer.GetIterAtMark (triggerMark);
-			
-			// the parser works with 1 based coordinates
-			
-			caretLineNumber      = insertIter.Line + 1;
-			caretColumn          = insertIter.LineOffset + 1;
-			//string expression    = TextUtilities.GetExpressionBeforeOffset (textArea, insertIter.Offset);
-			ResolveResult results;
-			
-			IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.GetService(typeof(IParserService));
-			IExpressionFinder expressionFinder = parserService.GetExpressionFinder(fileName);
-			string expression    = expressionFinder == null ? TextUtilities.GetExpressionBeforeOffset(textArea, insertIter.Offset) : expressionFinder.FindExpression(textArea.Buffer.GetText(textArea.Buffer.StartIter, insertIter, true), insertIter.Offset - 2);
-			if (expression == null) return null;
-			Console.WriteLine (&quot;Expr: |{0}|&quot;, expression);
-			//FIXME: This chartyped check is a fucking *HACK*
-			if (expression == &quot;is&quot; || expression == &quot;as&quot;) {
-				string expr = expressionFinder == null ? TextUtilities.GetExpressionBeforeOffset (textArea, insertIter.Offset - 3) : expressionFinder.FindExpression (textArea.Buffer.GetText (textArea.Buffer.StartIter, insertIter, true), insertIter.Offset - 5);
-				AddResolveResults (parserService.IsAsResolve (project, expr, caretLineNumber, caretColumn, fileName, textArea.Buffer.Text));
-				return (ICompletionData[])completionData.ToArray (typeof (ICompletionData));
-			}
-			if (ctrlspace &amp;&amp; charTyped != '.') {
-				AddResolveResults (parserService.CtrlSpace (parserService, project, caretLineNumber, caretColumn, fileName));
-				return (ICompletionData[])completionData.ToArray (typeof (ICompletionData));
-			}
-			if (charTyped == ' ') {
-				if (expression == &quot;using&quot; || expression.EndsWith(&quot; using&quot;) || expression.EndsWith(&quot;\tusing&quot;)|| expression.EndsWith(&quot;\nusing&quot;)|| expression.EndsWith(&quot;\rusing&quot;)) {
-					string[] namespaces = parserService.GetNamespaceList(project, &quot;&quot;, true, true);
-					AddResolveResults(new ResolveResult(namespaces));
-				}
-			} else {
-				//FIXME: I added the null check, #D doesnt need it, why do we?
-				if (fileName != null) {
-					results = parserService.Resolve(project, expression, caretLineNumber, caretColumn, fileName, textArea.Buffer.Text);
-					AddResolveResults(results);
-				}
-			}
-			return (ICompletionData[]) completionData.ToArray (typeof (ICompletionData));
-		}
-		
-		void AddResolveResults(ICollection list) 
-		{
-			if (list == null) {
-				return;
-			}
-			completionData.Capacity += list.Count;
-			foreach (object o in list) {
-				if (o is string) {
-					completionData.Add(new CodeCompletionData(o.ToString(), Stock.NameSpace));
-				} else if (o is IClass) {
-					IClass iclass = (IClass) o;
-					if (iclass.Name != null &amp;&amp; insertedClasses[iclass.Name] == null) {
-						completionData.Add(new CodeCompletionData(iclass));
-						insertedClasses[iclass.Name] = iclass;
-					}
-				} else if (o is IProperty) {
-					IProperty property = (IProperty)o;
-					if (property.Name != null &amp;&amp; insertedPropertiesElements[property.Name] == null) {
-						completionData.Add(new CodeCompletionData(property));
-						insertedPropertiesElements[property.Name] = property;
-					}
-				} else if (o is IMethod) {
-					IMethod method = (IMethod)o;
-					
-					if (method.Name != null &amp;&amp;!method.IsConstructor) {
-						CodeCompletionData ccd = new CodeCompletionData(method);
-						if (insertedElements[method.Name] == null) {
-							completionData.Add(ccd);
-							insertedElements[method.Name] = ccd;
-						} else {
-							CodeCompletionData firstMethod = (CodeCompletionData)insertedElements[method.Name];
-							++firstMethod.Overloads;
-							firstMethod.AddOverload (ccd);
-						}
-					}
-				} else if (o is IField) {
-					completionData.Add(new CodeCompletionData((IField)o));
-				} else if (o is IEvent) {
-					IEvent e = (IEvent)o;
-					if (e.Name != null &amp;&amp; insertedEventElements[e.Name] == null) {
-						completionData.Add(new CodeCompletionData(e));
-						insertedEventElements[e.Name] = e;
-					}
-				} else if (o is IParameter) {
-					completionData.Add (new CodeCompletionData((IParameter)o));
-				}
-			}
-		}
-			
-		void AddResolveResults(ResolveResult results)
-		{
-			if (results != null) {
-				AddResolveResults(results.Namespaces);
-				AddResolveResults(results.Members);
-			}
-		}
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,129 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Drawing;
-using System.Reflection;
-using System.Collections;
-
-using MonoDevelop.Core.Properties;
-using MonoDevelop.Core.Services;
-using MonoDevelop.Gui;
-using MonoDevelop.Internal.Templates;
-using MonoDevelop.Services;
-
-using MonoDevelop.Internal.Parser;
-using MonoDevelop.Internal.Project;
-using MonoDevelop.SourceEditor.Gui;
-using Stock = MonoDevelop.Gui.Stock;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	/// &lt;summary&gt;
-	/// Data provider for code completion.
-	/// &lt;/summary&gt;
-	public class CommentCompletionDataProvider : ICompletionDataProvider
-	{
-		static IParserService           parserService           = (IParserService)MonoDevelop.Core.Services.ServiceManager.GetService(typeof(IParserService));
-		
-		int caretLineNumber;
-		int caretColumn;
-		
-		string[][] commentTags = new string[][] {
-			new string[] {&quot;c&quot;, &quot;marks text as code&quot;},
-			new string[] {&quot;code&quot;, &quot;marks text as code&quot;},
-			new string[] {&quot;example&quot;, &quot;A description of the code example\n(must have a &lt;code&gt; tag inside)&quot;},
-			new string[] {&quot;exception cref=\&quot;\&quot;&quot;, &quot;description to an exception thrown&quot;},
-			new string[] {&quot;list type=\&quot;\&quot;&quot;, &quot;A list&quot;},
-			new string[] {&quot;listheader&quot;, &quot;The header from the list&quot;},
-			new string[] {&quot;item&quot;, &quot;A list item&quot;},
-			new string[] {&quot;term&quot;, &quot;A term in a list&quot;},
-			new string[] {&quot;description&quot;, &quot;A description to a term in a list&quot;},
-			new string[] {&quot;param name=\&quot;\&quot;&quot;, &quot;A description for a parameter&quot;},
-			new string[] {&quot;paramref name=\&quot;\&quot;&quot;, &quot;A reference to a parameter&quot;},
-			new string[] {&quot;permission cref=\&quot;\&quot;&quot;, &quot;&quot;},
-			new string[] {&quot;remarks&quot;, &quot;Gives description for a member&quot;},
-			new string[] {&quot;include file=\&quot;\&quot; path=\&quot;\&quot;&quot;, &quot;Includes comments from other files&quot;},
-			new string[] {&quot;returns&quot;, &quot;Gives description for a return value&quot;},
-			new string[] {&quot;see cref=\&quot;\&quot;&quot;, &quot;A reference to a member&quot;},
-			new string[] {&quot;seealso cref=\&quot;\&quot;&quot;, &quot;A reference to a member in the seealso section&quot;},
-			new string[] {&quot;summary&quot;, &quot;A summary of the object&quot;},
-			new string[] {&quot;value&quot;, &quot;A description of a property&quot;}
-		};
-		
-		/// &lt;remarks&gt;
-		/// Returns true, if the given coordinates (row, column) are in the region.
-		/// &lt;/remarks&gt;
-		bool IsBetween (int row, int column, IRegion region)
-		{
-			return row &gt;= region.BeginLine &amp;&amp; (row &lt;= region.EndLine || region.EndLine == -1);
-		}
-		
-		public ICompletionData[] GenerateCompletionData (Project project, string fileName, SourceEditorView textArea, char charTyped, Gtk.TextMark triggerMark)
-		{
-			/*caretLineNumber = textArea.Caret.Line;
-			caretColumn     = textArea.Caret.Column;
-			LineSegment caretLine = textArea.Document.GetLineSegment(caretLineNumber);
-			string lineText = textArea.Document.GetText(caretLine.Offset, caretLine.Length);
-			if (!lineText.Trim().StartsWith(&quot;///&quot;)) {
-				return null;
-			}
-			*/
-			ArrayList completionData = new ArrayList ();
-			/*foreach (string[] tag in commentTags) {
-				completionData.Add(new CommentCompletionData(tag[0], tag[1]));
-			}*/
-			return (ICompletionData[])completionData.ToArray (typeof (ICompletionData));
-		}
-		
-		class CommentCompletionData : ICompletionData
-		{
-			string text;
-			string description;
-			
-			public string Image
-			{
-				get {
-					return Stock.Method;
-				}
-			}
-			
-			public string[] Text
-			{
-				get {
-					return new string[] { text };
-				}
-			}
-
-			public string CompletionString
-			{
-				get 
-				{
-					return &quot;&quot;;
-				}
-			}
-			
-			public string Description
-			{
-				get {
-					return description;
-				}
-			}
-			
-			public void InsertAction (SourceEditorView control)
-			{
-				//((SharpDevelopTextAreaControl)control).ActiveTextAreaControl.TextArea.InsertString(text);
-			}
-			
-			public CommentCompletionData (string text, string description) 
-			{
-				this.text = text;
-				this.description = description;
-			}
-		}
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,253 +0,0 @@
-using System;
-using System.Collections;
-
-using Gtk;
-using MonoDevelop.SourceEditor.Gui;
-using MonoDevelop.Internal.Project;
-using MonoDevelop.Gui;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	public class CompletionListWindow : ListWindow, IListDataProvider
-	{
-		string fileName;
-		Project project;
-		SourceEditorView control;
-		TextMark triggeringMark;
-		ICompletionData[] completionData;
-		DeclarationViewWindow declarationviewwindow = new DeclarationViewWindow ();
-		static DataComparer dataComparer = new DataComparer ();
-		
-		class DataComparer: IComparer
-		{
-			public int Compare (object x, object y)
-			{
-				ICompletionData d1 = x as ICompletionData;
-				ICompletionData d2 = y as ICompletionData;
-				return String.Compare (d1.Text[0], d2.Text[0], true);
-			}
-		}
-		
-		static CompletionListWindow wnd;
-		
-		static CompletionListWindow ()
-		{
-			wnd = new CompletionListWindow ();
-		}
-		
-		public CompletionListWindow ()
-		{
-			SizeAllocated += new SizeAllocatedHandler (ListSizeChanged);
-		}
-		
-		public static void ShowWindow (char firstChar, TextIter trigIter, ICompletionDataProvider provider, SourceEditorView ctrl)
-		{
-			if (!wnd.ShowListWindow (firstChar, trigIter, provider,  ctrl))
-				return;
-			
-			// makes control-space in midle of words to work
-			TextBuffer buf = wnd.control.Buffer; 
-			string text = buf.GetText (trigIter, buf.GetIterAtMark (buf.InsertMark), false);
-			if (text.Length == 0)
-				return;
-			
-			wnd.PartialWord = text; 
-			//if there is only one matching result we take it by default
-			if (wnd.IsUniqueMatch)
-			{	
-				wnd.Hide ();
-			}
-			
-			wnd.UpdateWord ();
-			
-			wnd.PartialWord = wnd.CompleteWord;		
-		}
-		
-		bool ShowListWindow (char firstChar, TextIter trigIter, ICompletionDataProvider provider, SourceEditorView ctrl)
-		{
-			this.control = ctrl;
-			this.fileName = ctrl.ParentEditor.DisplayBinding.ContentName;
-			this.project = ctrl.ParentEditor.DisplayBinding.Project;
-			triggeringMark = control.Buffer.CreateMark (null, trigIter, true);
-			
-			completionData = provider.GenerateCompletionData (project, fileName, ctrl, firstChar, triggeringMark);
-			if (completionData == null || completionData.Length == 0) return false;
-			
-			this.Style = ctrl.Style.Copy();
-			
-			Array.Sort (completionData, dataComparer);
-			
-			DataProvider = this;
-			Gdk.Rectangle rect = control.GetIterLocation (control.Buffer.GetIterAtMark (triggeringMark));
-
-			int wx, wy;
-			control.BufferToWindowCoords (Gtk.TextWindowType.Widget, rect.X /*+ rect.Width*/, rect.Y + rect.Height, out wx, out wy);
-			
-			int tx, ty;
-			control.GdkWindow.GetOrigin (out tx, out ty);
-			
-			int x = tx + wx;
-			int y = ty + wy;
-			
-			int w, h;
-			GetSize (out w, out h);
-			
-			if ((x + w) &gt; Screen.Width)
-				x = Screen.Width - w;
-			
-			if ((y + h) &gt; Screen.Height)
-				y = y - rect.Height - h;
-							
-			Move (x, y);
-			
-			Show ();
-			return true;
-		}
-		
-		public static void HideWindow ()
-		{
-			wnd.Hide ();
-		}
-		
-		public static bool ProcessKeyEvent (Gdk.EventKey e)
-		{
-			if (!wnd.Visible) return false;
-			
-			ListWindow.KeyAction ka = wnd.ProcessKey (e);
-			
-			if ((ka &amp; ListWindow.KeyAction.CloseWindow) != 0)
-				wnd.Hide ();
-				
-			if ((ka &amp; ListWindow.KeyAction.Complete) != 0) {
-				wnd.UpdateWord ();
-			}
-			
-			if ((ka &amp; ListWindow.KeyAction.Ignore) != 0)
-				return true;
-
-			if ((ka &amp; ListWindow.KeyAction.Process) != 0) {
-				if (e.Key == Gdk.Key.Left) {
-					wnd.declarationviewwindow.OverloadLeft ();
-					return true;
-				} else if (e.Key == Gdk.Key.Right) {
-					wnd.declarationviewwindow.OverloadRight ();
-					return true;
-				}
-			}
-
-			return false;
-		}
-		
-		void UpdateWord ()
-		{
-			TextIter offsetIter = wnd.control.Buffer.GetIterAtMark (wnd.triggeringMark);
-			TextIter endIter = wnd.control.Buffer.GetIterAtOffset (offsetIter.Offset + wnd.PartialWord.Length);
-			wnd.control.Buffer.MoveMark (wnd.control.Buffer.InsertMark, offsetIter);
-			wnd.control.Buffer.Delete (ref offsetIter, ref endIter);
-			wnd.control.Buffer.InsertAtCursor (wnd.CompleteWord);
-		}
-		
-		public new void Hide ()
-		{
-			base.Hide ();
-			declarationviewwindow.HideAll ();
-		}
-		
-		void ListSizeChanged (object obj, SizeAllocatedArgs args)
-		{
-			// FIXME: crashes on System.Runtime.
-			// first line array out of bounds
-			//UpdateDeclarationView ();
-		}
-
-		protected override bool OnButtonPressEvent (Gdk.EventButton evnt)
-		{
-			bool ret = base.OnButtonPressEvent (evnt);
-			if (evnt.Button == 1 &amp;&amp; evnt.Type == Gdk.EventType.TwoButtonPress) {
-				wnd.Hide ();
-				wnd.UpdateWord ();
-			}
-			return ret;
-		}
-		
-		protected override void OnSelectionChanged ()
-		{
-			base.OnSelectionChanged ();
-			UpdateDeclarationView ();
-		}
-		
-		void UpdateDeclarationView ()
-		{
-			ICompletionData data = completionData[List.Selection];
-			
-			declarationviewwindow.Hide ();
-			declarationviewwindow.Clear ();
-			
-			if (List.GdkWindow == null) return;
-			Gdk.Rectangle rect = List.GetRowArea (List.Selection);
-			int listpos_x = 0, listpos_y = 0;
-			while (listpos_x == 0 || listpos_y == 0)
-				GetPosition (out listpos_x, out listpos_y);
-			int vert = listpos_y + rect.Y;
-			
-			int lvWidth = 0, lvHeight = 0;
-			while (lvWidth == 0)
-				this.GdkWindow.GetSize (out lvWidth, out lvHeight);
-			if (vert &gt;= listpos_y + lvHeight - 2) {
-				vert = listpos_y + lvHeight - rect.Height;
-			} else if (vert &lt; listpos_y) {
-				vert = listpos_y;
-			}
-			int horiz = listpos_x + lvWidth + 2;
-
-			ICompletionDataWithMarkup datawMarkup = data as ICompletionDataWithMarkup;
-
-			string descMarkup = datawMarkup != null ? datawMarkup.DescriptionPango : data.Description;
-
-			declarationviewwindow.Realize ();
-
-			declarationviewwindow.AddOverload (descMarkup);
-
-			CodeCompletionData ccdata = (CodeCompletionData) data;
-
-			foreach (CodeCompletionData odata in ccdata.GetOverloads ()) {
-				ICompletionDataWithMarkup odatawMarkup = odata as ICompletionDataWithMarkup;
-				declarationviewwindow.AddOverload (odatawMarkup == null ? odata.Description : odatawMarkup.DescriptionPango);
-			}
-
-			if (declarationviewwindow.DescriptionMarkup.Length == 0)
-				return;
-
-			int dvwWidth, dvwHeight;
-
-			declarationviewwindow.Move (this.Screen.Width+1, vert);
-			
-			declarationviewwindow.ReshowWithInitialSize ();
-			declarationviewwindow.ShowAll ();
-			declarationviewwindow.Multiple = (ccdata.Overloads != 0);
-
-			declarationviewwindow.GdkWindow.GetSize (out dvwWidth, out dvwHeight);
-
-			if (this.Screen.Width &lt;= horiz + dvwWidth) {
-				horiz = listpos_x - dvwWidth - 10;
-			}
-			
-			declarationviewwindow.Move (horiz, vert);
-		}
-		
-		public int ItemCount 
-		{ 
-			get { return completionData.Length; } 
-		}
-		
-		public string GetText (int n)
-		{
-			return completionData[n].Text[0];
-		}
-		
-		public Gdk.Pixbuf GetIcon (int n)
-		{
-			return RenderIcon (completionData[n].Image, Gtk.IconSize.Menu, &quot;&quot;);
-		}
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionWindow.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionWindow.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,427 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Drawing;
-using System.Collections;
-
-using Gtk;
-using MonoDevelop.SourceEditor.Gui;
-using MonoDevelop.Internal.Project;
-using MonoDevelop.Gui;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	public class CompletionWindow : Window
-	{
-		const  int  DeclarationIndent  = 1;
-		TreeViewColumn complete_column;
-		
-		ICompletionDataProvider completionDataProvider;
-		SourceEditorView control;
-		TreeView listView;
-		ListStore store;
-		TextMark triggeringMark;
-		int origOffset;
-		int num_in = 0;
-		DeclarationViewWindow declarationviewwindow = new DeclarationViewWindow ();
-		string fileName;
-		Project project;
-
-		static CompletionWindow wnd;
-
-		static CompletionWindow ()
-		{
-			wnd = new CompletionWindow ();
-		}
-		
-		string GetTypedString ()
-		{
-			TextIter startIter = control.Buffer.GetIterAtMark (control.Buffer.InsertMark);
-			TextIter offsetIter = control.Buffer.GetIterAtMark (triggeringMark);
-			return control.Buffer.GetText (offsetIter, startIter, true);
-		}
-
-		int insertLength {
-			get {
-				TextIter startIter = control.Buffer.GetIterAtMark (control.Buffer.InsertMark);
-				return startIter.Offset - origOffset;
-			}
-		}
-
-		void DeleteInsertion()
-		{
-			TextIter startIter = control.Buffer.GetIterAtMark (control.Buffer.InsertMark);
-			TextIter offsetIter = control.Buffer.GetIterAtMark (triggeringMark);
-			if (startIter.Offset &gt; offsetIter.Offset) {
-				int newPos = offsetIter.Offset;
-				control.Buffer.Delete (ref offsetIter, ref startIter);
-				control.Buffer.MoveMark (control.Buffer.InsertMark, control.Buffer.GetIterAtOffset (newPos));
-			}
-		}
-
-		protected override bool OnKeyPressEvent (Gdk.EventKey e)
-		{
-			uint state = (uint)e.State;
-			state &amp;= 1101u;
-
-			switch (state) {
-			case 0: //NORMAL
-				switch ((char)e.Key) {
-				case '.':
-				case ' ':
-				case ';':
-				case '(':
-				case '[':
-				case ',':
-					control.SimulateKeyPress (ref e);
-					LostFocusListView (null, null);
-					return true;
-					
-				case (char) Gdk.Key.Return:
-				case (char) Gdk.Key.ISO_Enter:
-				case (char) Gdk.Key.Key_3270_Enter:
-				case (char) Gdk.Key.KP_Enter:
-					KeyPressEventArgs fake_args = new KeyPressEventArgs ();
-					fake_args.Args = new object[] { e };
-					ListKeypressEvent (null, fake_args);
-					return true;
-					
-				case (char) Gdk.Key.BackSpace:
-					num_in--;
-					control.SimulateKeyPress (ref e);
-					if (insertLength &lt;= -1) {
-						LostFocusListView (null, null);
-						return true;
-					}
-					RowActivated (null, null);
-					return true;
-				}
-				break;
-			case 1: //SHIFT
-				switch ((char)e.Key) {
-				case 'P':
-				case 'N':
-					KeyPressEventArgs fake_args = new KeyPressEventArgs ();
-					fake_args.Args = new object[] { e };
-					ListKeypressEvent (null, fake_args);
-					return true;
-				}
-				break;
-			}
-			return base.OnKeyPressEvent (e);
-		}
-		
-		void ListKeypressEvent (object sender, KeyPressEventArgs ex)
-		{
-			Gdk.Key key = ex.Event.Key;
-			char val = (char) key;
-			
-			switch (key) {
-				case Gdk.Key.Shift_L:
-				case Gdk.Key.Shift_R:
-				case Gdk.Key.Control_L:
-				case Gdk.Key.Control_R:
-					ex.RetVal = true;
-					return;
-					
-				case Gdk.Key.Escape:
-					LostFocusListView (null, null);
-					ex.RetVal = true;
-					return;
-
-				default:
-					if (val != '_' &amp;&amp; !Char.IsLetterOrDigit (val)) {
-						TreeModel mdl;
-						TreeIter itr;
-						if (listView.Selection.GetSelected (out mdl, out itr)) {
-							ActivateItem (null, null);
-						} else {
-							LostFocusListView (null, null);
-						}
-						
-						ex.RetVal = true;
-						return;
-					} else {
-						control.Buffer.InsertAtCursor (val.ToString ());
-					}
-					break;
-			}
-
-			num_in++;
-
-			ShuffleSelection (false);
-	
-			ex.RetVal = true;
-		}
-
-		bool ShuffleSelection (bool magic)
-		{
-			// select the current typed word
-			int lastSelected = -1;
-			int capitalizationIndex = -1;
-			int numOfHits = 0;
-			
-			string typedString = GetTypedString ();
-			TreeIter iter;
-			int i = 0;
-			store.GetIterFirst (out iter);
-			do {
-				string text = (string) store.GetValue (iter, 0);
-				
-				if (text.ToUpper ().StartsWith (typedString.ToUpper ())) {
-					int currentCapitalizationIndex = 0;
-					for (int j = 0; j &lt; typedString.Length &amp;&amp; j &lt; text.Length; ++j) {
-						if (typedString[j] == text[j]) {
-							++currentCapitalizationIndex;
-						}
-					}
-					if (currentCapitalizationIndex &gt;= capitalizationIndex) {
-						numOfHits++;
-					}
-					
-					if (currentCapitalizationIndex &gt; capitalizationIndex) {
-						lastSelected = i;
-						capitalizationIndex = currentCapitalizationIndex;
-					}
-				}
-				i++;
-			} while (store.IterNext (ref iter) == true);
-
-			if (lastSelected != -1) {
-				listView.Selection.UnselectAll ();
-				TreePath path = new TreePath (lastSelected.ToString ());
-				listView.SetCursor (path, complete_column, false);
-				listView.ScrollToCell (path, null, false, 0, 0);
-				if (magic &amp;&amp; numOfHits == 1) {
-					ActivateItem (null, null);
-					LostFocusListView (null, null);
-					return true;
-				}
-			}
-			if (numOfHits == 0) {
-				control.buf.DropCompleteAhead ();
-				listView.Selection.UnselectAll ();
-			}
-			return false;
-		}
-		
-		void InitializeControls ()
-		{
-			Decorated = false;
-			SkipPagerHint = true;
-			SkipTaskbarHint = true;
-			TypeHint = Gdk.WindowTypeHint.Dialog;
-
-			TransientFor = (Gtk.Window)WorkbenchSingleton.Workbench;
-			
-			store = new Gtk.ListStore (typeof (string), typeof (Gdk.Pixbuf), typeof(ICompletionData));
-			listView = new Gtk.TreeView (store);
-			listView.HeadersVisible = false;
-
-			complete_column = new TreeViewColumn ();
-			complete_column.Title = &quot;completion&quot;;
-
-			Gtk.CellRendererPixbuf pix_render = new Gtk.CellRendererPixbuf ();
-			complete_column.PackStart (pix_render, false);
-			complete_column.AddAttribute (pix_render, &quot;pixbuf&quot;, 1);
-			
-			Gtk.CellRendererText text_render = new Gtk.CellRendererText ();
-			complete_column.PackStart (text_render, true);
-			complete_column.AddAttribute (text_render, &quot;text&quot;, 0);
-	
-			listView.AppendColumn (complete_column);
-
-			Gtk.ScrolledWindow scroller = new Gtk.ScrolledWindow ();
-			scroller.HscrollbarPolicy = Gtk.PolicyType.Never;
-			scroller.Add (listView);
-
-			Gtk.Frame frame = new Gtk.Frame ();
-			frame.Add (scroller);
-			this.Add (frame);
-			
-			listView.KeyPressEvent += new KeyPressEventHandler (ListKeypressEvent);
-			this.FocusOutEvent += new FocusOutEventHandler (LostFocusListView);
-			this.AddEvents ((int) (Gdk.EventMask.LeaveNotifyMask));
-			listView.RowActivated += new RowActivatedHandler (ActivateItem);
-			listView.AddEvents ((int) (Gdk.EventMask.KeyPressMask));
-		}
-	
-		/// &lt;remarks&gt;
-		/// Shows the filled completion window, if it has no items it isn't shown.
-		/// &lt;/remarks&gt;
-		public static void ShowWindow (char firstChar, TextIter trigIter, bool magic, ICompletionDataProvider provider, SourceEditorView ctrl)
-		{
-			wnd.ShowCompletionWindow (firstChar, trigIter, magic, provider, ctrl);
-		}
-
-		void ShowCompletionWindow (char firstChar, TextIter trigIter, bool magic, ICompletionDataProvider provider, SourceEditorView ctrl)
-		{
-			this.completionDataProvider = provider;
-			this.control = ctrl;
-			this.fileName = ctrl.ParentEditor.DisplayBinding.ContentName;
-			this.project = ctrl.ParentEditor.DisplayBinding.Project;
-			this.store.Clear ();
-			control.buf.StartAtomicUndo ();
-			triggeringMark = control.Buffer.CreateMark (null, trigIter, true);
-			origOffset = trigIter.Offset;
-			FillList (true, firstChar);
-
-			TreeIter iter;
-			if (store.GetIterFirst (out iter) == false) {
-				listView.FocusOutEvent -= new FocusOutEventHandler (LostFocusListView);
-				control.buf.EndAtomicUndo ();
-				control.GrabFocus ();
-				return;
-			}
-
-			listView.Selection.Changed -= new EventHandler (RowActivated);
-			if (magic) {
-				if (ShuffleSelection (true))
-					return;
-			}
-
-			Gdk.Rectangle rect = control.GetIterLocation (control.Buffer.GetIterAtMark (triggeringMark));
-
-			int wx, wy;
-			control.BufferToWindowCoords (Gtk.TextWindowType.Widget, rect.X /*+ rect.Width*/, rect.Y + rect.Height, out wx, out wy);
-			
-			int tx, ty;
-			control.GdkWindow.GetOrigin (out tx, out ty);
-			
-			ShowAll ();
-			Move (tx + wx, ty + wy);
-			Present ();
-			listView.GrabFocus ();
-			listView.Selection.Changed += new EventHandler (RowActivated);
-			RowActivated (null, null);
-		}
-		
-		/// &lt;remarks&gt;
-		/// Creates a new Completion window and puts it location under the caret
-		/// &lt;/remarks&gt;
-		CompletionWindow () : base (Gtk.WindowType.Toplevel)
-		{
-			InitializeControls ();
-		}
-		
-		void ActivateItem (object sender, RowActivatedArgs e)
-		{
-			TreeModel foo;
-			TreeIter iter;
-			if (listView.Selection.GetSelected (out foo, out iter)) {
-				ICompletionData data = (ICompletionData) store.GetValue (iter, 2);
-				control.buf.DropCompleteAhead ();
-				DeleteInsertion ();
-				data.InsertAction (control);
-				LostFocusListView (null, null);
-			}
-		}
-		
-		void LostFocusListView (object sender, FocusOutEventArgs e)
-		{
-			control.buf.DropCompleteAhead ();
-			control.buf.EndAtomicUndo ();
-			listView.FocusOutEvent -= new FocusOutEventHandler (LostFocusListView);
-			control.HasFocus = true;
-			declarationviewwindow.HideAll ();
-			this.Hide ();
-		}
-		
-		void FillList (bool firstTime, char ch)
-		{
-			ICompletionData[] completionData = completionDataProvider.GenerateCompletionData(project, fileName, control, ch, triggeringMark);
-			if (completionData == null || completionData.Length == 0) {
-				return;
-			}
-			
-			foreach (ICompletionData data in completionData) {
-				store.AppendValues (data.Text[0], RenderIcon (data.Image, Gtk.IconSize.Menu, &quot;&quot;), data);
-			}
-			// sort here
-			store.SetSortColumnId (0, SortType.Ascending);
-		}
-		
-		void RowActivated (object sender, EventArgs a)
-		{
-			Gtk.TreeIter iter;
-			Gtk.TreeModel model;
-			
-			if (listView.Selection.GetSelected (out model, out iter)){
-				ICompletionData data = (ICompletionData) store.GetValue (iter, 2);
-				if (data == null)
-					return;
-				
-				int inst = insertLength;
-				if (inst == -1) {
-					LostFocusListView (null, null);
-					return;
-				}
-				if (inst &gt;= 1) {
-					DeleteInsertion ();
-					int l = inst &gt; data.CompletionString.Length ? data.CompletionString.Length : inst;
-					control.buf.InsertAtCursor (data.CompletionString.Substring (0, l));
-				}
-				control.buf.DropCompleteAhead ();
-				if (data.CompletionString.Length &gt; inst) {
-					control.buf.DropCompleteAhead ();
-					control.buf.CompleteAhead (data.CompletionString.Substring(inst));
-				}
-				// This code is for sizing the treeview properly.
-				Gtk.TreePath path = store.GetPath (iter);
-				Gdk.Rectangle backRect = listView.GetBackgroundArea (path, (Gtk.TreeViewColumn)listView.Columns[0]);
-				
-				listView.HeightRequest = (backRect.Height * 5) + 2;
-
-				// FIXME: This code is buggy, and generates a bad placement sometimes when you jump a lot.
-				// but it is better than 0,0
-				// This code is for sizing the treeview properly.
-				
-				Gdk.Rectangle rect = listView.GetCellArea (path, (Gtk.TreeViewColumn)listView.Columns[0]);
-				int listpos_x = 0, listpos_y = 0;
-				while (listpos_x == 0)
-					GetPosition (out listpos_x, out listpos_y);
-				int vert = listpos_y + rect.Y;
-				
-				int lvWidth, lvHeight;
-				listView.GdkWindow.GetSize (out lvWidth, out lvHeight);
-				if (vert &gt;= listpos_y + lvHeight - 2) {
-					vert = listpos_y + lvHeight - rect.Height;
-				} else if (vert &lt; listpos_y) {
-					vert = listpos_y;
-				}
-				// FIXME: This is a bad calc, its always on the right,
-				// it needs to test if thats too big, and if so, place on the left;
-				int horiz = listpos_x + lvWidth + 30;
-				ICompletionDataWithMarkup wMarkup = data as ICompletionDataWithMarkup;
-				declarationviewwindow.Destroy ();
-				
-				if (wMarkup != null) {
-					declarationviewwindow = new DeclarationViewWindow ();
-					declarationviewwindow.DescriptionMarkup = wMarkup.DescriptionPango;
-				} else {
-					declarationviewwindow = new DeclarationViewWindow ();
-					declarationviewwindow.DescriptionMarkup = data.Description;
-				}
-			
-				if (declarationviewwindow.DescriptionMarkup.Length == 0)
-					return;
-	
-				declarationviewwindow.ShowAll ();
-
-				int dvwWidth, dvwHeight;
-	
-				declarationviewwindow.GdkWindow.GetSize (out dvwWidth, out dvwHeight);
-				if (listView.Screen.Width &lt;= horiz + dvwWidth) {
-					horiz = listpos_x - dvwWidth - 10;
-				}
-			
-				declarationviewwindow.Move (horiz, vert);
-			}
-		}
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,162 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Drawing;
-using System.Reflection;
-using System.Collections;
-
-using Gtk;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	public class DeclarationViewWindow : Window
-	{
-		static char[] newline = {'\n'};
-		static char[] whitespace = {' '};
-
-		ArrayList overloads;
-		int current_overload;
-
-		Label headlabel, bodylabel, helplabel;
-		Arrow left, right;
-		VBox helpbox;
-		
-		public string DescriptionMarkup
-		{
-			get {
-			 	if (bodylabel.Text == &quot;&quot;)
-					return headlabel.Text;
-				else
-					return headlabel.Text + &quot;\n&quot; + bodylabel.Text;
-			}
-			
-			set {
-				if (value == null) {
-					headlabel.Markup = &quot;&quot;;
-					bodylabel.Markup = &quot;&quot;;
-					return;
-				}
-
-				string[] parts = value.Split (newline, 2);
-				headlabel.Markup = parts[0].Trim (whitespace);
-				bodylabel.Markup = (parts.Length == 2 ? parts[1].Trim (whitespace) : String.Empty);
-
-				headlabel.Visible = headlabel.Text != &quot;&quot;;
-				bodylabel.Visible = bodylabel.Text != &quot;&quot;;
-				//QueueDraw ();
-			}
-		}
-
-		public bool Multiple
-		{
-			get {
-				return left.Visible;
-			}
-
-			set {
-				left.Visible = value;
-				right.Visible = value;
-				helpbox.Visible = value;
-				
-				//this could go somewhere better, as long as it's after realization
-				headlabel.Visible = headlabel.Text != &quot;&quot;;
-				bodylabel.Visible = bodylabel.Text != &quot;&quot;;
-			}
-		}
-
-		public void AddOverload (string desc)
-		{
-			overloads.Add (desc);
-			if (overloads.Count == 2) {
-				Multiple = true;
-			}
-			ShowOverload ();
-		}
-
-		void ShowOverload ()
-		{
-			DescriptionMarkup = (string)overloads[current_overload];
-			helplabel.Markup = String.Format (&quot;&lt;small&gt;{0} of {1} overloads&lt;/small&gt;&quot;, current_overload + 1, overloads.Count);
-		}
-
-		public void OverloadLeft ()
-		{
-			if (current_overload == 0)
-				current_overload = overloads.Count - 1;
-			else
-				current_overload--;
-			ShowOverload ();
-		}
-
-		public void OverloadRight ()
-		{
-			if (current_overload == overloads.Count - 1)
-				current_overload = 0;
-			else
-				current_overload++;
-			ShowOverload ();
-		}
-
-		public void Clear ()
-		{
-			overloads.Clear ();
-			Multiple = false;
-			DescriptionMarkup = String.Empty;
-			current_overload = 0;
-		}
-
-		public DeclarationViewWindow () : base (WindowType.Popup)
-		{
-			overloads = new ArrayList ();
-			this.AllowShrink = false;
-			this.AllowGrow = false;
-
-			headlabel = new Label (&quot;&quot;);
-			headlabel.LineWrap = false;
-			headlabel.Xalign = 0;
-			
-			bodylabel = new Label (&quot;&quot;);
-			bodylabel.LineWrap = true;
-			bodylabel.Xalign = 0;
-
-			VBox vb = new VBox (false, 0);
-			vb.PackStart (headlabel, false, true, 0);
-			vb.PackStart (bodylabel, false, true, 0);
-
-			left = new Arrow (ArrowType.Left, ShadowType.None);
-			right = new Arrow (ArrowType.Right, ShadowType.None);
-
-			HBox hb = new HBox (false, 0);
-			hb.Spacing = 4;
-			hb.PackStart (left, false, true, 0);
-			hb.PackStart (vb, true, true, 0);
-			hb.PackStart (right, false, true, 0);
-
-			helplabel = new Label (&quot;&quot;);
-			helplabel.Xpad = 2;
-			helplabel.Ypad = 2;
-			helplabel.Xalign = 1;
-			helplabel.UseMarkup = true;
-			helplabel.Markup = &quot;&quot;;
-			
-			helpbox = new VBox (false, 0);
-			helpbox.PackStart (new HSeparator (), false, true, 0);
-			helpbox.PackStart (helplabel, false, true, 0);
-			
-			VBox vb2 = new VBox (false, 0);
-			vb2.Spacing = 4;
-			vb2.PackStart (hb, false, true, 0);
-			vb2.PackStart (helpbox, false, true, 0);
-
-			Frame frame = new Frame ();
-			frame.Add (vb2);
-			
-			this.Add (frame);
-		}
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,45 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Drawing;
-using System.Reflection;
-using System.Collections;
-
-using MonoDevelop.SourceEditor.Gui;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	public interface ICompletionData
-	{
-		string Image {
-			get;
-		}
-		
-		string[] Text {
-			get;
-		}
-		
-		string Description {
-			get;
-		}
-
-		string CompletionString 
-		{
-			get;
-		}
-		
-		void InsertAction(SourceEditorView control);
-	}
-	
-	public interface ICompletionDataWithMarkup : ICompletionData
-	{
-		string DescriptionPango {
-			get;
-		}
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,22 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Drawing;
-using System.Reflection;
-using System.Collections;
-using MonoDevelop.Internal.Project;
-
-using Gdk;
-
-using MonoDevelop.SourceEditor.Gui;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion {
-	public interface ICompletionDataProvider {
-		ICompletionData[] GenerateCompletionData(Project project, string fileName, SourceEditorView textArea, char charTyped, Gtk.TextMark mark);
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,477 +0,0 @@
-using Gtk;
-using Gdk;
-using Pango;
-using System;
-using System.Text;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	public class ListWindow: Gtk.Window
-	{
-		VScrollbar scrollbar;
-		ListWidget list;
-		IListDataProvider provider;
-		
-		StringBuilder word;
-		int curPos;
-		
-		[Flags]
-		public enum KeyAction { Process=1, Ignore=2, CloseWindow=4, Complete=8 } 
-
-		public ListWindow (): base (Gtk.WindowType.Popup)
-		{
-			HBox box = new HBox ();
-			
-			list = new ListWidget (this);
-			list.SelectionChanged += new EventHandler (OnSelectionChanged);
-			list.ScrollEvent += new ScrollEventHandler (OnScrolled);
-			box.PackStart (list, true, true, 0);
-			this.BorderWidth = 1;
-			
-			scrollbar = new VScrollbar (null);
-			scrollbar.ValueChanged += new EventHandler (OnScrollChanged); 
-			box.PackStart (scrollbar, false, false, 0);
-			
-			Add (box);
-			this.TypeHint = WindowTypeHint.Menu;
-		}
-		
-		public new void Show ()
-		{
-			this.ShowAll ();
-			Reset ();
-		}
-		
-		public void Reset ()
-		{
-			word = new StringBuilder ();
-			curPos = 0;
-			list.Reset ();
-
-			if (list.VisibleRows &gt;= provider.ItemCount) {
-				this.scrollbar.Hide();
-			}
-			else {
-				scrollbar.Adjustment.Lower = 0;
-				scrollbar.Adjustment.Upper = provider.ItemCount - list.VisibleRows;
-				scrollbar.Adjustment.PageIncrement = list.VisibleRows - 1;
-				scrollbar.Adjustment.StepIncrement = 1;
-			}
-
-			this.Resize(this.list.WidthRequest, this.list.HeightRequest);
-		}
-		
-		public IListDataProvider DataProvider
-		{
-			get { return provider; }
-			set { provider = value; }
-		}
-		
-		public string CompleteWord
-		{
-			get { return provider.GetText (list.Selection);	}
-		}
-		
-		public string PartialWord
-		{
-			get { return word.ToString (); }
-			set
-			{
-				string newword = value;
-				if (newword.Trim ().Length == 0)
-					return;
-				
-				word = new StringBuilder (newword);
-				curPos = newword.Length;
-				UpdateWordSelection ();
-			}
-		}
-		
-		public bool IsUniqueMatch
-		{
-			get
-			{
-				int pos = list.Selection + 1;
-				if (provider.ItemCount &gt; pos &amp;&amp; provider.GetText (pos).ToLower ().StartsWith (PartialWord.ToLower ()) || !(provider.GetText (list.Selection).ToLower ().StartsWith (PartialWord.ToLower ())))
-					return false;
-				
-				return true;	
-			}
-		}
-		
-		protected ListWidget List
-		{
-			get { return list; }
-		}
-		
-		public KeyAction ProcessKey (EventKey e)
-		{
-			switch (e.Key)
-			{
-				case Gdk.Key.Up:
-					list.Selection --;
-					return KeyAction.Ignore;
-					
-				case Gdk.Key.Down:
-					list.Selection ++;
-					return KeyAction.Ignore;
-					
-				case Gdk.Key.Page_Up:
-					list.Selection -= list.VisibleRows - 1;
-					return KeyAction.Ignore;
-					
-				case Gdk.Key.Page_Down:
-					list.Selection += list.VisibleRows - 1;
-					return KeyAction.Ignore;
-					
-				case Gdk.Key.Left:
-					//if (curPos == 0) return KeyAction.CloseWindow | KeyAction.Process;
-					//curPos--;
-					return KeyAction.Process;
-					
-				case Gdk.Key.BackSpace:
-					if (curPos == 0) return KeyAction.CloseWindow | KeyAction.Process;
-					curPos--;
-					word.Remove (curPos, 1);
-					UpdateWordSelection ();
-					return KeyAction.Process;
-					
-				case Gdk.Key.Right:
-					//if (curPos == word.Length) return KeyAction.CloseWindow | KeyAction.Process;
-					//curPos++;
-					return KeyAction.Process;
-					
-				case Gdk.Key.Tab:
-				case Gdk.Key.Return:
-				case Gdk.Key.ISO_Enter:
-				case Gdk.Key.Key_3270_Enter:
-				case Gdk.Key.KP_Enter:
-					return KeyAction.Complete | KeyAction.Ignore | KeyAction.CloseWindow;
-					
-				case Gdk.Key.Escape:
-					return KeyAction.CloseWindow | KeyAction.Ignore;
-					
-				case Gdk.Key.Home:
-				case Gdk.Key.End:
-					return KeyAction.CloseWindow | KeyAction.Process;
-					
-				case Gdk.Key.Control_L:
-				case Gdk.Key.Control_R:
-				case Gdk.Key.Alt_L:
-				case Gdk.Key.Alt_R:
-				case Gdk.Key.Shift_L:
-				case Gdk.Key.Shift_R:
-				case Gdk.Key.ISO_Level3_Shift:	// AltGr
-					return KeyAction.Process;
-			}
-			
-			char c = (char)e.KeyValue;
-			
-			if (System.Char.IsLetterOrDigit (c) || c == '_') {
-				word.Insert (curPos++, c);
-				UpdateWordSelection ();
-				return KeyAction.Process;
-			}
-			else if ((System.Char.IsPunctuation (c) || c == ' ') &amp;&amp; !list.SelectionDisabled) {
-				return KeyAction.Complete | KeyAction.Process | KeyAction.CloseWindow;
-			}
-			
-			return KeyAction.CloseWindow | KeyAction.Process;
-		}
-		
-		void UpdateWordSelection ()
-		{
-			string s = word.ToString ();
-			int max = (provider == null ? 0 : provider.ItemCount);
-			
-			int bestMatch = -1;
-			for (int n=0; n&lt;max; n++) 
-			{
-				string txt = provider.GetText (n);
-				if (txt.StartsWith (s)) {
-					list.Selection = n;
-					return;
-				}
-				else if (bestMatch == -1 &amp;&amp; txt.ToLower().StartsWith (s.ToLower()))
-					bestMatch = n;
-			}
-			
-			if (bestMatch != -1) {
-				list.Selection = bestMatch;
-				return;
-			}
-			
-			list.SelectionDisabled = true;
-		}
-		
-		void OnScrollChanged (object o, EventArgs args)
-		{
-			list.Page = (int) scrollbar.Value;
-		}
-
-		void OnScrolled (object o, ScrollEventArgs args)
-		{
-			if (args.Event.Direction == Gdk.ScrollDirection.Up)
-				scrollbar.Value --;
-			else if (args.Event.Direction == Gdk.ScrollDirection.Down)
-				scrollbar.Value ++;
-		}
-		
-		void OnSelectionChanged (object o, EventArgs args)
-		{
-			scrollbar.Value = list.Page;
-			OnSelectionChanged ();
-		}
-		
-		protected virtual void OnSelectionChanged ()
-		{
-		}
-		
-		protected override bool OnExposeEvent (Gdk.EventExpose args)
-		{
-			base.OnExposeEvent (args);
-			
-			int winWidth, winHeight;
-			this.GetSize (out winWidth, out winHeight);
-			this.GdkWindow.DrawRectangle (this.Style.ForegroundGC (StateType.Insensitive), false, 0, 0, winWidth-1, winHeight-1);
-			return false;
-		}		
-	}
-
-	public class ListWidget: Gtk.DrawingArea
-	{
-		int margin = 0;
-		int padding = 4;
-		int listWidth = 300;
-		
-		Pango.Layout layout;
-		ListWindow win;
-		int selection = 0;
-		int page = 0;
-		int visibleRows = -1;
-		int rowWidth, rowHeight;
-		bool buttonPressed;
-		bool disableSelection;
-
-		public event EventHandler SelectionChanged;
-				
-		public ListWidget (ListWindow win)
-		{
-			this.win = win;
-			this.Events = EventMask.ButtonPressMask | EventMask.ButtonReleaseMask | EventMask.PointerMotionMask; 
-		}
-		
-		public void Reset ()
-		{
-			selection = 0;
-			page = 0;
-			disableSelection = false;
-			UpdateStyle ();
-			QueueDraw ();
-			if (SelectionChanged != null) SelectionChanged (this, EventArgs.Empty);
-		}
-		
-		public int Selection
-		{
-			get {
-				return selection;
-			}
-			
-			set {
-				if (value &lt; 0)
-					value = 0;
-				else if (value &gt;= win.DataProvider.ItemCount)
-					value = win.DataProvider.ItemCount - 1;
-					
-				if (value != selection) 
-				{
-					selection = value;
-						
-					if (selection &lt; page)
-						page = selection;
-					else if (selection &gt;= page + VisibleRows) {
-						page = selection - VisibleRows + 1;
-						if (page &lt; 0) page = 0;
-					}
-					
-					if (SelectionChanged != null) SelectionChanged (this, EventArgs.Empty);
-				}
-				
-				if (disableSelection)
-					disableSelection = false;
-
-				this.QueueDraw ();
-			}
-		}
-		
-		public bool SelectionDisabled
-		{
-			get { return disableSelection; }
-			
-			set {
-				disableSelection = value; 
-				this.QueueDraw ();
-			}
-		}
-		
-		public int Page
-		{
-			get { 
-				return page; 
-			}
-			
-			set {
-				page = value;
-				this.QueueDraw ();
-			}
-		}
-		
-		protected override bool OnButtonPressEvent (EventButton e)
-		{
-			Selection = GetRowByPosition ((int) e.Y);
-			buttonPressed = true;
-			return base.OnButtonPressEvent (e);
-		}
-		
-		protected override bool OnButtonReleaseEvent (EventButton e)
-		{
-			buttonPressed = false;
-			return base.OnButtonReleaseEvent (e);
-		}
-		
-		protected override bool OnMotionNotifyEvent (EventMotion e)
-		{
-			if (!buttonPressed)
-				return base.OnMotionNotifyEvent (e);
-			
-			int winWidth, winHeight;
-			this.GdkWindow.GetSize (out winWidth, out winHeight);
-			
-	/*		int ypos = (int) e.Y;
-			if (ypos &lt; 0) {
-			}
-			else if (ypos &gt;= winHeight) {
-			}
-			else
-	*/			Selection = GetRowByPosition ((int) e.Y);
-			
-			return true;
-		}
-
-		protected override bool OnExposeEvent (Gdk.EventExpose args)
-		{
-			base.OnExposeEvent (args);
-			DrawList ();
-	  		return true;
-		}
-
-		void DrawList ()
-		{
-			int winWidth, winHeight;
-			this.GdkWindow.GetSize (out winWidth, out winHeight);
-			
-			int ypos = margin;
-			int lineWidth = winWidth - margin*2;
-			int xpos = margin + padding;
-				
-			int n = 0;
-			while (ypos &lt; winHeight - margin &amp;&amp; (page + n) &lt; win.DataProvider.ItemCount)
-			{
-				layout.SetMarkup (win.DataProvider.GetText (page + n));
-				Gdk.Pixbuf icon = win.DataProvider.GetIcon (page + n);
-				
-				int wi, he, typos, iypos;
-				layout.GetPixelSize (out wi, out he);
-				typos = he &lt; rowHeight ? ypos + (rowHeight - he) / 2 : ypos;
-				iypos = icon.Height &lt; rowHeight ? ypos + (rowHeight - icon.Height) / 2 : ypos;
-				
-				if (page + n == selection) {
-					if (!disableSelection) {
-						this.GdkWindow.DrawRectangle (this.Style.BaseGC (StateType.Selected), true, margin, ypos, lineWidth, he + padding);
-						this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Selected), xpos + icon.Width + 2, typos, layout);
-					}
-					else {
-						this.GdkWindow.DrawRectangle (this.Style.BaseGC (StateType.Selected), false, margin, ypos, lineWidth, he + padding);
-						this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Normal), xpos + icon.Width + 2, typos, layout);
-					}
-				}
-				else
-					this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Normal), xpos + icon.Width + 2, typos, layout);
-					
-				this.GdkWindow.DrawPixbuf (this.Style.ForegroundGC (StateType.Normal), icon, 0, 0, xpos, iypos, icon.Width, icon.Height, Gdk.RgbDither.None, 0, 0);
-				
-				ypos += rowHeight;
-				n++;
-			}
-		}
-		
-		int GetRowByPosition (int ypos)
-		{
-			if (visibleRows == -1) CalcVisibleRows ();
-			return page + (ypos-margin) / rowHeight;
-		}
-		
-		public Gdk.Rectangle GetRowArea (int row)
-		{
-			row -= page;
-			int winWidth, winHeight;
-			this.GdkWindow.GetSize (out winWidth, out winHeight);
-			
-			return new Gdk.Rectangle (margin, margin + rowHeight * row, winWidth, rowHeight);
-		}
-		
-		public int VisibleRows
-		{
-			get {
-				if (visibleRows == -1) CalcVisibleRows ();
-				return visibleRows;
-			}
-		}
-		
-		void CalcVisibleRows ()
-		{
-			int winHeight = 200;
-			int lvWidth, lvHeight;
-			this.GdkWindow.GetSize (out lvWidth, out lvHeight);
-
-			layout.GetPixelSize (out rowWidth, out rowHeight);
-			rowHeight += padding;
-			visibleRows = (winHeight + padding - margin * 2) / rowHeight;
-			
-			int newHeight;
-
-			if (this.win.DataProvider.ItemCount &gt; this.visibleRows)
-				newHeight = (rowHeight * visibleRows) + margin * 2;
-			else
-				newHeight = (rowHeight * this.win.DataProvider.ItemCount) + margin * 2;
-			
-			if (lvWidth != listWidth || lvHeight != newHeight)
-				this.SetSizeRequest (listWidth, newHeight);
-		} 
-
-		protected override void OnRealized ()
-		{
-			base.OnRealized ();
-			UpdateStyle ();
-		}
-		
-		void UpdateStyle ()
-		{
-			this.GdkWindow.Background = this.Style.Base (StateType.Normal);
-			layout = new Pango.Layout (this.PangoContext);
-			layout.Wrap = Pango.WrapMode.Char;
-			
-			FontDescription des = this.Style.FontDescription.Copy();
-			layout.FontDescription = des;
-			CalcVisibleRows ();
-		}
-	}
-
-	public interface IListDataProvider
-	{
-		int ItemCount { get; }
-		string GetText (int n);
-		Gdk.Pixbuf GetIcon (int n);
-	}
-}
-

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,88 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Drawing;
-using System.Reflection;
-using System.Collections;
-
-using MonoDevelop.Core.Properties;
-using MonoDevelop.Internal.Templates;
-using MonoDevelop.Internal.Project;
-using MonoDevelop.SourceEditor.Gui;
-using Stock = MonoDevelop.Gui.Stock;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	public class TemplateCompletionDataProvider : ICompletionDataProvider
-	{
-		public Gdk.Pixbuf[] ImageList
-		{
-			get {
-				return null;
-			}
-		}
-		
-		public ICompletionData[] GenerateCompletionData(Project project, string fileName, SourceEditorView textArea, char charTyped, Gtk.TextMark triggerMark)
-		{
-			CodeTemplateGroup templateGroup = CodeTemplateLoader.GetTemplateGroupPerFilename(fileName);
-			if (templateGroup == null) {
-				return null;
-			}
-			ArrayList completionData = new ArrayList();
-			foreach (CodeTemplate template in templateGroup.Templates) {
-				completionData.Add(new TemplateCompletionData(template));
-			}
-			
-			return (ICompletionData[])completionData.ToArray(typeof(ICompletionData));
-		}
-		
-		class TemplateCompletionData : ICompletionData
-		{
-			CodeTemplate template;
-			
-			public string Image
-			{
-				get {
-					return Stock.Method;
-				}
-			}
-
-			public string CompletionString
-			{
-				get 
-				{
-					return &quot;&quot;;
-				}
-			}
-			
-			public string[] Text
-			{
-				get {
-					return new string[] { template.Shortcut, template.Description };
-				}
-			}
-			
-			public string Description
-			{
-				get {
-					return template.Text;
-				}
-			}
-			
-			public void InsertAction(SourceEditorView control)
-			{
-				//((SharpDevelopTextAreaControl)control).InsertTemplate(template);
-			}
-			
-			public TemplateCompletionData(CodeTemplate template) 
-			{
-				this.template = template;
-			}
-		}
-	}
-}

Deleted: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,409 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Text;
-using System.Diagnostics;
-using MonoDevelop.SourceEditor.Gui;
-
-namespace MonoDevelop.SourceEditor.CodeCompletion
-{
-	public sealed class TextUtilities
-	{
-		
-		/// &lt;remarks&gt;
-		/// This function takes a string and converts the whitespace in front of
-		/// it to tabs. If the length of the whitespace at the start of the string
-		/// was not a whole number of tabs then there will still be some spaces just
-		/// before the text starts.
-		/// the output string will be of the form:
-		/// 1. zero or more tabs
-		/// 2. zero or more spaces (less than tabIndent)
-		/// 3. the rest of the line
-		/// &lt;/remarks&gt;
-/*		public static string LeadingWhiteSpaceToTabs(string line, int tabIndent) {
-			StringBuilder sb = new StringBuilder(line.Length);
-			int consecutiveSpaces = 0;
-			int i = 0;
-			for(i = 0; i &lt; line.Length; i++) {
-				if(line[i] == ' ') {
-					consecutiveSpaces++;
-					if(consecutiveSpaces == tabIndent) {
-						sb.Append('\t');
-						consecutiveSpaces = 0;
-					}
-				}
-				else if(line[i] == '\t') {
-					sb.Append('\t');
-					// if we had say 3 spaces then a tab and tabIndent was 4 then
-					// we would want to simply replace all of that with 1 tab
-					consecutiveSpaces = 0;					
-				}
-				else {
-					break;
-				}
-			}
-			if(i &lt; line.Length) {
-				sb.Append(line.Substring(i-consecutiveSpaces));
-			}
-			return sb.ToString();
-		}
-*/
-
-		public static bool IsLetterDigitOrUnderscore(char c)
-		{
-			if(!Char.IsLetterOrDigit(c)) {
-				return c == '_';
-			}
-			return true;
-		}
-		
-		public enum CharacterType
-		{
-			LetterDigitOrUnderscore,
-			WhiteSpace,
-			Other
-		}
-		
-		/// &lt;remarks&gt;
-		/// This method returns the expression before a specified offset.
-		/// That method is used in code completion to determine the expression given
-		/// to the parser for type resolve.
-		/// &lt;/remarks&gt;
-		public static string GetExpressionBeforeOffset(SourceEditorView textArea, int offset)
-		{
-			// FIXME: we should actually use GtkTextIter's
-			string text = textArea.Buffer.Text;
-			int origOffset = offset;
-			
-			while (offset - 1 &gt; 0) {
-				switch (text [offset - 1]) {
-					case '}':
-						goto done;
-//						offset = SearchBracketBackward(document, offset - 2, '{','}');
-//						break;
-					case ']':
-						offset = SearchBracketBackward(textArea, offset - 2, '[',']');
-						break;
-					case ')':
-						offset = SearchBracketBackward(textArea, offset - 2, '(',')');
-						break;
-					case '.':
-						--offset;
-						break;
-					case '&quot;':
-						return &quot;\&quot;\&quot;&quot;;
-					case '\'':
-						return &quot;'a'&quot;;
-					case '&gt;':
-						if (text [offset - 2] == '-') {
-							offset -= 2;
-							break;
-						}
-						goto done;
-					default:
-						if (Char.IsWhiteSpace (text [offset - 1])) {
-							--offset;
-							break;
-						}
-						int start = offset - 1;
-						if (!IsLetterDigitOrUnderscore (text [start])) {
-							goto done;
-						}
-						
-						while (start &gt; 0 &amp;&amp; IsLetterDigitOrUnderscore (text[start - 1])) {
-							--start;
-						}
-						
-						//Console.WriteLine(&quot;{0} -- {1}&quot;, offset, start);
-						Gtk.TextIter startIter = textArea.Buffer.GetIterAtOffset (start);
-						Gtk.TextIter endIter = textArea.Buffer.GetIterAtOffset (offset);
-						string word = textArea.Buffer.GetText (startIter, endIter, false).Trim();
-						//Console.WriteLine(&quot;word &gt;{0}&lt;&quot;, word);
-						switch (word) {
-							case &quot;ref&quot;:
-							case &quot;out&quot;:
-							case &quot;in&quot;:
-							case &quot;return&quot;:
-							case &quot;throw&quot;:
-							case &quot;case&quot;:
-								goto done;
-						}
-						
-						if (word.Length &gt; 0 &amp;&amp; !IsLetterDigitOrUnderscore(word[0])) {
-							goto done;
-						}
-						offset = start;
-						break;
-				}
-			}
-			done:
-//			Console.WriteLine(&quot;ofs : {0} cart:{1}&quot;, offset, document.Caret.Offset);
-//			Console.WriteLine(&quot;return:&quot; + document.GetText(offset, document.Caret.Offset - offset).Trim());
-			Gtk.TextIter start_Iter = textArea.Buffer.GetIterAtOffset (origOffset);
-			Gtk.TextIter offset_Iter = textArea.Buffer.GetIterAtOffset (offset);
-			return textArea.Buffer.GetText (start_Iter, offset_Iter, false ).Trim();
-		}
-		
-/*		
-		public static CharacterType GetCharacterType(char c) 
-		{
-			if(IsLetterDigitOrUnderscore(c))
-				return CharacterType.LetterDigitOrUnderscore;
-			if(Char.IsWhiteSpace(c))
-				return CharacterType.WhiteSpace;
-			return CharacterType.Other;
-		}
-		
-		public static int GetFirstNonWSChar(IDocument document, int offset)
-		{
-			while (offset &lt; document.TextLength &amp;&amp; Char.IsWhiteSpace(document.GetCharAt(offset))) {
-				++offset;
-			}
-			return offset;
-		}
-		
-		public static int FindWordEnd(IDocument document, int offset)
-		{
-			LineSegment line   = document.GetLineSegmentForOffset(offset);
-			int     endPos = line.Offset + line.Length;
-			while (offset &lt; endPos &amp;&amp; IsLetterDigitOrUnderscore(document.GetCharAt(offset))) {
-				++offset;
-			}
-			
-			return offset;
-		}
-		
-		public static int FindWordStart(IDocument document, int offset)
-		{
-			LineSegment line = document.GetLineSegmentForOffset(offset);
-			
-			while (offset &gt; line.Offset &amp;&amp; !IsLetterDigitOrUnderscore(document.GetCharAt(offset - 1))) {
-				--offset;
-			}
-			
-			return offset;
-		}
-		
-		// go forward to the start of the next word
-		// if the cursor is at the start or in the middle of a word we move to the end of the word
-		// and then past any whitespace that follows it
-		// if the cursor is at the start or in the middle of some whitespace we move to the start of the
-		// next word
-		public static int FindNextWordStart(IDocument document, int offset)
-		{
-			int originalOffset = offset;
-			LineSegment line   = document.GetLineSegmentForOffset(offset);
-			int     endPos = line.Offset + line.Length;
-			// lets go to the end of the word, whitespace or operator
-			CharacterType t = GetCharacterType(document.GetCharAt(offset));
-			while (offset &lt; endPos &amp;&amp; GetCharacterType(document.GetCharAt(offset)) == t) {
-				++offset;
-			}
-			
-			// now we're at the end of the word, lets find the start of the next one by skipping whitespace
-			while (offset &lt; endPos &amp;&amp; GetCharacterType(document.GetCharAt(offset)) == CharacterType.WhiteSpace) {
-				++offset;
-			}
-
-			return offset;
-		}
-		
-		// go back to the start of the word we are on
-		// if we are already at the start of a word or if we are in whitespace, then go back
-		// to the start of the previous word
-		public static int FindPrevWordStart(IDocument document, int offset)
-		{
-			int originalOffset = offset;
-			LineSegment line = document.GetLineSegmentForOffset(offset);
-			if (offset &gt; 0) {
-				CharacterType t = GetCharacterType(document.GetCharAt(offset - 1));
-				while (offset &gt; line.Offset &amp;&amp; GetCharacterType(document.GetCharAt(offset - 1)) == t) {
-					--offset;
-				}
-				
-				// if we were in whitespace, and now we're at the end of a word or operator, go back to the beginning of it
-				if(t == CharacterType.WhiteSpace &amp;&amp; offset &gt; line.Offset) {
-					t = GetCharacterType(document.GetCharAt(offset - 1));
-					while (offset &gt; line.Offset &amp;&amp; GetCharacterType(document.GetCharAt(offset - 1)) == t) {
-						--offset;
-					}
-				}
-			}
-			
-			return offset;
-		}
-		
-		public static string GetLineAsString(IDocument document, int lineNumber)
-		{
-			LineSegment line = document.GetLineSegment(lineNumber);
-			return document.GetText(line.Offset, line.Length);
-		}
-*/
-		static bool ScanLineComment(SourceEditorView document, int offset)
-		{
-			// FIXME: use iters
-			string text = document.Buffer.Text;
-			while (offset &gt; 0 &amp;&amp; offset &lt; text.Length) {
-				char ch = text [offset];
-				switch (ch) {
-					case '\r':
-					case '\n':
-						return false;
-					case '/':
-						if (text[offset + 1] == '/') {
-							return true;
-						}
-						break;
-				}
-				--offset;
-			}
-			return false;
-		}
-		
-		public static int SearchBracketBackward(SourceEditorView document, int offset, char openBracket, char closingBracket)
-		{
-			// FIXME: use iters
-			string text = document.Buffer.Text;			
-			int brackets = -1;		
-			bool inString = false;
-			bool inChar   = false;	
-			bool blockComment = false;
-			
-			while (offset &gt;= 0 &amp;&amp; offset &lt; text.Length) {
-				char ch = text [offset];
-				switch (ch) {
-					case '/':
-						if (blockComment) {
-							if (text [offset + 1]== '*') {
-								blockComment = false;
-							}
-						}
-						if (!inString &amp;&amp; !inChar &amp;&amp; offset + 1 &lt; text.Length) {
-							if (offset &gt; 0 &amp;&amp; text [offset - 1] == '*') {
-								blockComment = true;
-							}
-						}
-						break;
-					case '&quot;':
-						if (!inChar &amp;&amp; !blockComment &amp;&amp; !ScanLineComment(document, offset)) {
-							inString = !inString;
-						}
-						break;
-					case '\'':
-						if (!inString &amp;&amp; !blockComment &amp;&amp; !ScanLineComment(document, offset)) {
-							inChar = !inChar;
-						}
-						break;
-					default :
-						if (ch == closingBracket) {
-							if (!(inString || inChar || blockComment) &amp;&amp; !ScanLineComment(document, offset)) {
-								--brackets;
-							}
-						} else if (ch == openBracket) {
-							if (!(inString || inChar || blockComment) &amp;&amp; !ScanLineComment(document, offset)) {
-								++brackets;
-								if (brackets == 0) {
-									return offset;
-								}
-							}
-						}
-						break;
-				}
-				--offset;
-			}
-			return - 1;
-		}
-/*
-		public static int SearchBracketForward(IDocument document, int offset, char openBracket, char closingBracket)
-		{
-			int brackets = 1;
-			
-			bool inString = false;
-			bool inChar   = false;
-			
-			bool lineComment  = false;
-			bool blockComment = false;
-			
-			if (offset &gt;= 0) {
-				while (offset &lt; document.TextLength) {
-					char ch = document.GetCharAt(offset);
-					switch (ch) {
-						case '\r':
-						case '\n':
-							lineComment = false;
-							break;
-						case '/':
-							if (blockComment) {
-								Debug.Assert(offset &gt; 0);
-								if (document.GetCharAt(offset - 1) == '*') {
-									blockComment = false;
-								}
-							}
-							if (!inString &amp;&amp; !inChar &amp;&amp; offset + 1 &lt; document.TextLength) {
-								if (!blockComment &amp;&amp; document.GetCharAt(offset + 1) == '/') {
-									lineComment = true;
-								}
-								if (!lineComment &amp;&amp; document.GetCharAt(offset + 1) == '*') {
-									blockComment = true;
-								}
-							}
-							break;
-						case '&quot;':
-							if (!(inChar || lineComment || blockComment)) {
-								inString = !inString;
-							}
-							break;
-						case '\'':
-							if (!(inString || lineComment || blockComment)) {
-								inChar = !inChar;
-							}
-							break;
-						default :
-							if (ch == openBracket) {
-								if (!(inString || inChar || lineComment || blockComment)) {
-									++brackets;
-								}
-							} else if (ch == closingBracket) {
-								if (!(inString || inChar || lineComment || blockComment)) {
-									--brackets;
-									if (brackets == 0) {
-										return offset;
-									}
-								}
-							}
-							break;
-					}
-					++offset;
-				}
-			}
-			return -1;
-		}
-		
-		/// &lt;remarks&gt;
-		/// Returns true, if the line lineNumber is empty or filled with whitespaces.
-		/// &lt;/remarks&gt;
-		public static bool IsEmptyLine(IDocument document, int lineNumber)
-		{
-			return IsEmptyLine(document, document.GetLineSegment(lineNumber));
-		}
-
-		/// &lt;remarks&gt;
-		/// Returns true, if the line lineNumber is empty or filled with whitespaces.
-		/// &lt;/remarks&gt;
-		public static bool IsEmptyLine(IDocument document, LineSegment line)
-		{
-			for (int i = line.Offset; i &lt; line.Offset + line.Length; ++i) {
-				char ch = document.GetCharAt(i);
-				if (!Char.IsWhiteSpace(ch)) {
-					return false;
-				}
-			}
-			return true;
-		}*/
-	}
-}

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -10,13 +10,14 @@
 using MonoDevelop.Core.AddIns;
 using MonoDevelop.Internal.Templates;
 using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
 using MonoDevelop.Core.Services;
-using MonoDevelop.SourceEditor.CodeCompletion;
 using MonoDevelop.SourceEditor.InsightWindow;
 using MonoDevelop.EditorBindings.Properties;
 using MonoDevelop.EditorBindings.FormattingStrategy;
 using MonoDevelop.Gui.Utils;
 using MonoDevelop.Gui;
+using MonoDevelop.Gui.Completion;
 using MonoDevelop.Services;
 using MonoDevelop.Commands;
 using MonoDevelop.DefaultEditor;
@@ -25,7 +26,7 @@
 
 namespace MonoDevelop.SourceEditor.Gui
 {
-	public class SourceEditorView : SourceView, IFormattableDocument
+	public class SourceEditorView : SourceView, IFormattableDocument, ICompletionWidget
 	{	
 		public readonly SourceEditor ParentEditor;
 		internal IFormattingStrategy fmtr;
@@ -194,8 +195,8 @@
 				return;
 			triggerIter.ForwardChar ();
 			
-//			CompletionWindow.ShowWindow (triggerChar, triggerIter, true, new CodeCompletionDataProvider (true), this);
-			CompletionListWindow.ShowWindow (triggerChar, triggerIter, new CodeCompletionDataProvider (true), this);
+			PrepareCompletionDetails(triggerIter);
+			CompletionListWindow.ShowWindow (triggerChar, new CodeCompletionDataProvider (true), this, this.ParentEditor.DisplayBinding.Project, this.ParentEditor.DisplayBinding.ContentName);
 		}
 
 		bool MonodocResolver ()
@@ -375,8 +376,8 @@
 			case '.':
 				bool retval = base.OnKeyPressEvent (evnt);
 				if (EnableCodeCompletion &amp;&amp; PeekCharIsWhitespace ()) {
-//					CompletionWindow.ShowWindow ((char)key, buf.GetIterAtMark (buf.InsertMark), false, new CodeCompletionDataProvider (), this);
-					CompletionListWindow.ShowWindow ((char)key, buf.GetIterAtMark (buf.InsertMark), new CodeCompletionDataProvider (), this);
+					PrepareCompletionDetails(buf.GetIterAtMark (buf.InsertMark));
+					CompletionListWindow.ShowWindow ((char)key, new CodeCompletionDataProvider (), this, this.ParentEditor.DisplayBinding.Project, this.ParentEditor.DisplayBinding.ContentName);
 				}
 				return retval;
 				/*case '(':
@@ -582,6 +583,20 @@
 			end.ForwardToLineEnd ();
 			Buffer.MoveMark (&quot;selection_bound&quot;, end);
 		}
+
+		void PrepareCompletionDetails(TextIter iter)
+		{
+			Gdk.Rectangle rect = GetIterLocation (Buffer.GetIterAtMark (Buffer.InsertMark));
+			int wx, wy;
+			BufferToWindowCoords (Gtk.TextWindowType.Widget, rect.X, rect.Y + rect.Height, out wx, out wy);
+			int tx, ty;
+			GdkWindow.GetOrigin (out tx, out ty);
+
+			this.completionX = tx + wx;
+			this.completionY = ty + wy;
+			this.textHeight = rect.Height;
+			this.triggerMark = buf.CreateMark (null, iter, true);
+		}
 #endregion
 
 #region IFormattableDocument
@@ -648,7 +663,7 @@
 		
 		int IFormattableDocument.GetClosingBraceForLine (int ln, out int openingLine)
 		{
-			int offset = MonoDevelop.SourceEditor.CodeCompletion.TextUtilities.SearchBracketBackward
+			int offset = MonoDevelop.Gui.Completion.TextUtilities.SearchBracketBackward
 				(this, Buffer.GetIterAtLine (ln).Offset - 1, '{', '}');
 			
 			openingLine = offset == -1 ? -1 : Buffer.GetIterAtOffset (offset).Line;
@@ -661,7 +676,118 @@
 			offset = begin.Offset;
 			len = begin.CharsInLine;
 		}
+#endregion
 
+#region ICompletionWidget
+
+		private int completionX;
+		int ICompletionWidget.TriggerXCoord
+		{
+			get
+			{
+				return completionX;
+			}
+		}
+
+		private int completionY;
+		int ICompletionWidget.TriggerYCoord
+		{
+			get
+			{
+				return completionY;
+			}
+		}
+
+		private int textHeight;
+		int ICompletionWidget.TriggerTextHeight
+		{
+			get
+			{
+				return textHeight;
+			}
+		}
+
+		string ICompletionWidget.CompletionText
+		{
+			get
+			{
+				return Buffer.GetText (Buffer.GetIterAtMark (triggerMark), Buffer.GetIterAtMark (Buffer.InsertMark), false);
+			}
+		}
+
+		void ICompletionWidget.SetCompletionText (string partial_word, string complete_word)
+		{
+			TextIter offsetIter = buf.GetIterAtMark(triggerMark);
+                        TextIter endIter = buf.GetIterAtOffset (offsetIter.Offset + partial_word.Length);
+                        buf.MoveMark (buf.InsertMark, offsetIter);
+                        buf.Delete (ref offsetIter, ref endIter);
+                        buf.InsertAtCursor (complete_word);
+		}
+
+		void ICompletionWidget.InsertAtCursor (string text)
+		{
+			buf.InsertAtCursor (text);
+		}
+		
+		string ICompletionWidget.Text
+		{
+			get
+			{
+				return buf.Text;
+			}
+		}
+
+		int ICompletionWidget.TextLength
+		{
+			get
+			{
+				return buf.EndIter.Offset + 1;
+			}
+		}
+
+		char ICompletionWidget.GetChar (int offset)
+		{
+			return buf.GetIterAtOffset (offset).Char[0];
+		}
+
+		string ICompletionWidget.GetText (int startOffset, int endOffset)
+		{
+			return buf.GetText(buf.GetIterAtOffset (startOffset), buf.GetIterAtOffset(endOffset), true);
+		}
+
+		private TextMark triggerMark;
+		int ICompletionWidget.TriggerOffset
+		{
+			get
+			{
+				return buf.GetIterAtMark (triggerMark).Offset;
+			}
+		}
+
+		int ICompletionWidget.TriggerLine
+		{
+			get
+			{
+				return buf.GetIterAtMark (triggerMark).Line;
+			}
+		}
+
+		int ICompletionWidget.TriggerLineOffset
+		{
+			get
+			{
+				return buf.GetIterAtMark (triggerMark).LineOffset;
+			}
+		}
+
+		Gtk.Style ICompletionWidget.GtkStyle
+		{
+			get
+			{
+				return Style.Copy();
+			}
+		}
+
 		bool PeekCharIsWhitespace ()
 		{
 			TextIter start = buf.GetIterAtMark (buf.InsertMark);

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/IndexerInsightDataProvider.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/IndexerInsightDataProvider.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/IndexerInsightDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -17,8 +17,9 @@
 using MonoDevelop.Internal.Parser;
 using MonoDevelop.Internal.Project;
 
+using MonoDevelop.Gui.Completion;
+
 using MonoDevelop.SourceEditor.Gui;
-using MonoDevelop.SourceEditor.CodeCompletion;
 
 namespace MonoDevelop.SourceEditor.InsightWindow
 {

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/InsightWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/InsightWindow.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/InsightWindow.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -14,7 +14,6 @@
 using GtkSharp;
 
 using MonoDevelop.SourceEditor.Gui;
-using MonoDevelop.SourceEditor.CodeCompletion;
 using MonoDevelop.Internal.Project;
 
 namespace MonoDevelop.SourceEditor.InsightWindow

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/MethodInsightDataProvider.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/MethodInsightDataProvider.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/InsightWindow/MethodInsightDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -16,9 +16,9 @@
 using MonoDevelop.Services;
 using MonoDevelop.Internal.Parser;
 using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui.Completion;
 
 using MonoDevelop.SourceEditor.Gui;
-using MonoDevelop.SourceEditor.CodeCompletion;
 
 namespace MonoDevelop.SourceEditor.InsightWindow 
 {

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Makefile.am	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Makefile.am	2005-07-20 16:12:50 UTC (rev 2677)
@@ -3,17 +3,6 @@
 DLL = $(top_builddir)/build/bin/$(DLLNAME)
 
 FILES = \
-CodeCompletion/CodeCompletionData.cs \
-CodeCompletion/ICompletionData.cs \
-CodeCompletion/CompletionWindow.cs \
-CodeCompletion/CompletionListWindow.cs \
-CodeCompletion/ListWindow.cs \
-CodeCompletion/TextUtilities.cs \
-CodeCompletion/TemplateCompletionDataProvider.cs \
-CodeCompletion/CommentCompletionDataProvider.cs \
-CodeCompletion/ICompletionDataProvider.cs \
-CodeCompletion/DeclarationViewWindow.cs \
-CodeCompletion/CodeCompletionDataProvider.cs \
 Gui/SourceEditorWidget.cs \
 Gui/SourceEditorBuffer.cs \
 Gui/SourceEditorView.cs \

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,3 +1,11 @@
+2005-07-20  Peter Johanson  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>&gt;
+
+	* Gui/Completion/*.cs: Migrated here from MonoDevelop.SourceEditor.
+	Includes new ICompletionWidget API for completing arbitrary widgets.
+	* Makefile.am: Changes for imported completion files.
+	* Services/ParserService/DefaultParserService.cs: Connect to events
+	for individual Projects, rather than using the project service events.
+
 2005-07-20  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;
 
 	* Gui/Pads/ProjectPad/ProjectFolderNodeBuilder.cs: When a folder is

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CodeCompletionData.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CodeCompletionData.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,288 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;?&#194;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Xml;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.IO;
+using System.Collections;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Services;
+using MonoDevelop.Core.Services;
+
+namespace MonoDevelop.Gui.Completion
+{
+	class CodeCompletionData : ICompletionDataWithMarkup
+	{
+		IconService classBrowserIconService = (IconService) ServiceManager.GetService (typeof (IconService));
+		IParserService parserService = (IParserService) MonoDevelop.Core.Services.ServiceManager.GetService (typeof (IParserService));
+		static AmbienceService ambienceService = (AmbienceService) ServiceManager.GetService (typeof (AmbienceService));
+		
+		string image;
+		int overloads;
+		string text;
+		string description;
+		string pango_description;
+		string documentation;
+		string completionString;
+		IClass c;
+		bool convertedDocumentation = false;
+		
+		static IAmbience PangoAmbience
+		{
+			get {
+				IAmbience asvc = ambienceService.CurrentAmbience;
+				asvc.ConversionFlags |= ConversionFlags.IncludePangoMarkup;
+				return asvc;
+			}
+		}
+
+		public string CompletionString 
+		{
+			get 
+			{
+				return completionString;
+			}
+		}
+		
+		
+		public int Overloads
+		{
+			get {
+				//return overloads;
+				return overload_data.Count;
+			}
+			set {
+				overloads = value;
+			}
+		}
+		
+		public string Image
+		{
+			get {
+				return image;
+			}
+			set {
+				image = value;
+			}
+		}
+		
+		public string[] Text
+		{
+			get {
+				return new string[] { text };
+			}
+			set {
+				text = value[0];
+			}
+		}
+		public string SimpleDescription
+		{
+			get {
+				return description;
+			}
+		}
+				
+		public string Description
+		{
+			get {
+				// don't give a description string, if no documentation or description is provided
+				if (description.Length + documentation.Length == 0) {
+					return null;
+				}
+				if (!convertedDocumentation) {
+					convertedDocumentation = true;
+					try {
+						documentation = GetDocumentation(documentation);
+					} catch (Exception e) {
+						Console.WriteLine(e.ToString());
+					}
+				}
+				return (description + &quot;\n&quot; + documentation).Trim ();
+			}
+			set {
+				description = value;
+			}
+		}
+		
+		public string DescriptionPango
+		{
+			get {
+				// don't give a description string, if no documentation or description is provided
+				if (description.Length + documentation.Length == 0) {
+					return null;
+				}
+				if (!convertedDocumentation) {
+					convertedDocumentation = true;
+					try {
+						documentation = GetDocumentation(documentation);
+					} catch (Exception e) {
+						Console.WriteLine(e.ToString());
+					}
+				}
+				return (pango_description + &quot;\n&quot; + documentation).Trim ();
+			}
+			set {
+				description = value;
+			}
+		}
+
+		Hashtable overload_data = new Hashtable ();
+
+		public CodeCompletionData[] GetOverloads ()
+		{
+			return (CodeCompletionData[]) (new ArrayList (overload_data.Values)).ToArray (typeof (CodeCompletionData));
+		}
+
+		public void AddOverload (CodeCompletionData overload)
+		{
+			string desc = overload.SimpleDescription;
+
+			if (desc != description || !overload_data.Contains (desc))
+				overload_data[desc] = overload;
+		}
+		
+		public CodeCompletionData (string s, string image)
+		{
+			description = pango_description = documentation = String.Empty;
+			text = s;
+			completionString = s;
+			this.image = image;
+		}
+		
+		public CodeCompletionData (IClass c)
+		{
+			// save class (for the delegate description shortcut
+			this.c = c;
+			image = classBrowserIconService.GetIcon(c);
+			text = c.Name;
+			completionString = c.Name;
+			description = ambienceService.CurrentAmbience.Convert(c);
+			pango_description  = PangoAmbience.Convert(c);
+			documentation = c.Documentation;
+		}
+		
+		public CodeCompletionData (IMethod method)
+		{
+			image  = classBrowserIconService.GetIcon(method);
+			text        = method.Name;
+			description = ambienceService.CurrentAmbience.Convert(method);
+			pango_description  = PangoAmbience.Convert (method);
+			completionString = method.Name;
+			documentation = method.Documentation;
+		}
+		
+		public CodeCompletionData (IField field)
+		{
+			image  = classBrowserIconService.GetIcon(field);
+			text        = field.Name;
+			description = ambienceService.CurrentAmbience.Convert(field);
+			pango_description  = PangoAmbience.Convert (field);
+			completionString = field.Name;
+			documentation = field.Documentation;
+		}
+		
+		public CodeCompletionData (IProperty property)
+		{
+			image  = classBrowserIconService.GetIcon(property);
+			text        = property.Name;
+			description = ambienceService.CurrentAmbience.Convert(property);
+			pango_description  = PangoAmbience.Convert (property);
+			completionString = property.Name;
+			documentation = property.Documentation;
+		}
+		
+		public CodeCompletionData (IEvent e)
+		{
+			image  = classBrowserIconService.GetIcon(e);
+			text        = e.Name;
+			description = ambienceService.CurrentAmbience.Convert(e);
+			pango_description  = PangoAmbience.Convert (e);
+			completionString = e.Name;
+			documentation = e.Documentation;
+		}
+
+		public CodeCompletionData (IParameter o)
+		{
+			image = MonoDevelop.Gui.Stock.Field;
+			text  = o.Name;
+			description = &quot;&quot;;
+			pango_description = &quot;&quot;;
+			completionString = o.Name;
+			documentation = &quot;&quot;;
+		}
+		
+		public void InsertAction (ICompletionWidget widget)
+		{
+			widget.InsertAtCursor (completionString);
+		}
+
+		public static string GetDocumentation (string doc)
+		{
+			System.IO.StringReader reader = new System.IO.StringReader(&quot;&lt;docroot&gt;&quot; + doc + &quot;&lt;/docroot&gt;&quot;);
+			XmlTextReader xml   = new XmlTextReader(reader);
+			StringBuilder ret   = new StringBuilder();
+			Regex whitespace    = new Regex(@&quot;(\s|\n)+&quot;, RegexOptions.Singleline);
+			
+			try {
+				xml.Read();
+				do {
+					if (xml.NodeType == XmlNodeType.Element) {
+						string elname = xml.Name.ToLower();
+						if (elname == &quot;remarks&quot;) {
+							ret.Append(&quot;Remarks:\n&quot;);
+						} else if (elname == &quot;example&quot;) {
+							ret.Append(&quot;Example:\n&quot;);
+						} else if (elname == &quot;exception&quot;) {
+							ret.Append(&quot;Exception: &quot; + GetCref(xml[&quot;cref&quot;]) + &quot;:\n&quot;);
+						} else if (elname == &quot;returns&quot;) {
+							ret.Append(&quot;Returns: &quot;);
+						} else if (elname == &quot;see&quot;) {
+							ret.Append(GetCref(xml[&quot;cref&quot;]) + xml[&quot;langword&quot;]);
+						} else if (elname == &quot;seealso&quot;) {
+							ret.Append(&quot;See also: &quot; + GetCref(xml[&quot;cref&quot;]) + xml[&quot;langword&quot;]);
+						} else if (elname == &quot;paramref&quot;) {
+							ret.Append(xml[&quot;name&quot;]);
+						} else if (elname == &quot;param&quot;) {
+							ret.Append(xml[&quot;name&quot;].Trim() + &quot;: &quot;);
+						} else if (elname == &quot;value&quot;) {
+							ret.Append(&quot;Value: &quot;);
+						}
+					} else if (xml.NodeType == XmlNodeType.EndElement) {
+						string elname = xml.Name.ToLower();
+						if (elname == &quot;para&quot; || elname == &quot;param&quot;) {
+							ret.Append(&quot;\n&quot;);
+						}
+					} else if (xml.NodeType == XmlNodeType.Text) {
+						ret.Append(whitespace.Replace(xml.Value, &quot; &quot;));
+					}
+				} while (xml.Read ());
+			} catch {
+				Console.WriteLine (&quot;DocBoom&quot;);
+				return doc;
+			}
+			return ret.ToString ();
+		}
+		
+		static string GetCref (string cref)
+		{
+			if (cref == null)
+				return &quot;&quot;;
+			
+			if (cref.Length &lt; 2)
+				return cref;
+			
+			if (cref.Substring(1, 1) == &quot;:&quot;)
+				return cref.Substring (2, cref.Length - 2);
+			
+			return cref;
+		}
+	
+	}
+}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CodeCompletionDataProvider.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CodeCompletionDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,155 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;?&#194;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Diagnostics;
+using System.Reflection;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Xml;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Templates;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+
+using Stock = MonoDevelop.Gui.Stock;
+
+using Gtk;
+
+namespace MonoDevelop.Gui.Completion
+{
+	/// &lt;summary&gt;
+	/// Data provider for code completion.
+	/// &lt;/summary&gt;
+	public class CodeCompletionDataProvider : ICompletionDataProvider
+	{
+//		static AmbienceService          ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
+		Hashtable insertedClasses = new Hashtable ();
+		Hashtable insertedElements           = new Hashtable();
+		Hashtable insertedPropertiesElements = new Hashtable();
+		Hashtable insertedEventElements      = new Hashtable();
+		
+		int caretLineNumber;
+		int caretColumn;
+		string fileName;
+		bool ctrlspace;
+
+		public CodeCompletionDataProvider() : this (false)
+		{
+		}
+			
+		public CodeCompletionDataProvider (bool ctrl) 
+		{
+			this.ctrlspace = ctrl;
+		}
+		
+		ArrayList completionData = null;
+		
+		public ICompletionData[] GenerateCompletionData(Project project, string fileName, ICompletionWidget widget, char charTyped)
+		{
+			completionData = new ArrayList();
+			this.fileName = fileName;
+			
+			// the parser works with 1 based coordinates
+			caretLineNumber      = widget.TriggerLine + 1;
+			caretColumn          = widget.TriggerLineOffset + 1;
+			//string expression    = TextUtilities.GetExpressionBeforeOffset (textArea, insertIter.Offset);
+			ResolveResult results;
+			
+			IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.GetService(typeof(IParserService));
+			IExpressionFinder expressionFinder = parserService.GetExpressionFinder(fileName);
+			string expression    = expressionFinder == null ? TextUtilities.GetExpressionBeforeOffset(widget, widget.TriggerOffset) : expressionFinder.FindExpression(widget.GetText (0, widget.TriggerOffset), widget.TriggerOffset - 2);
+			if (expression == null) return null;
+			Console.WriteLine (&quot;Expr: |{0}|&quot;, expression);
+			//FIXME: This chartyped check is a fucking *HACK*
+			if (expression == &quot;is&quot; || expression == &quot;as&quot;) {
+				string expr = expressionFinder == null ? TextUtilities.GetExpressionBeforeOffset (widget, widget.TriggerOffset - 3) : expressionFinder.FindExpression (widget.GetText (0, widget.TriggerOffset), widget.TriggerOffset - 5);
+				AddResolveResults (parserService.IsAsResolve (project, expr, caretLineNumber, caretColumn, fileName, widget.GetText (0, widget.TextLength)));
+				return (ICompletionData[])completionData.ToArray (typeof (ICompletionData));
+			}
+			if (ctrlspace &amp;&amp; charTyped != '.') {
+				AddResolveResults (parserService.CtrlSpace (parserService, project, caretLineNumber, caretColumn, fileName));
+				return (ICompletionData[])completionData.ToArray (typeof (ICompletionData));
+			}
+			if (charTyped == ' ') {
+				if (expression == &quot;using&quot; || expression.EndsWith(&quot; using&quot;) || expression.EndsWith(&quot;\tusing&quot;)|| expression.EndsWith(&quot;\nusing&quot;)|| expression.EndsWith(&quot;\rusing&quot;)) {
+					string[] namespaces = parserService.GetNamespaceList(project, &quot;&quot;, true, true);
+					AddResolveResults(new ResolveResult(namespaces));
+				}
+			} else {
+				//FIXME: I added the null check, #D doesnt need it, why do we?
+				if (fileName != null) {
+					results = parserService.Resolve(project, expression, caretLineNumber, caretColumn, fileName, widget.GetText (0, widget.TextLength));
+					AddResolveResults(results);
+				}
+			}
+			return (ICompletionData[]) completionData.ToArray (typeof (ICompletionData));
+		}
+		
+		void AddResolveResults(ICollection list) 
+		{
+			if (list == null) {
+				return;
+			}
+			completionData.Capacity += list.Count;
+			foreach (object o in list) {
+				if (o is string) {
+					completionData.Add(new CodeCompletionData(o.ToString(), Stock.NameSpace));
+				} else if (o is IClass) {
+					IClass iclass = (IClass) o;
+					if (iclass.Name != null &amp;&amp; insertedClasses[iclass.Name] == null) {
+						completionData.Add(new CodeCompletionData(iclass));
+						insertedClasses[iclass.Name] = iclass;
+					}
+				} else if (o is IProperty) {
+					IProperty property = (IProperty)o;
+					if (property.Name != null &amp;&amp; insertedPropertiesElements[property.Name] == null) {
+						completionData.Add(new CodeCompletionData(property));
+						insertedPropertiesElements[property.Name] = property;
+					}
+				} else if (o is IMethod) {
+					IMethod method = (IMethod)o;
+					
+					if (method.Name != null &amp;&amp;!method.IsConstructor) {
+						CodeCompletionData ccd = new CodeCompletionData(method);
+						if (insertedElements[method.Name] == null) {
+							completionData.Add(ccd);
+							insertedElements[method.Name] = ccd;
+						} else {
+							CodeCompletionData firstMethod = (CodeCompletionData)insertedElements[method.Name];
+							++firstMethod.Overloads;
+							firstMethod.AddOverload (ccd);
+						}
+					}
+				} else if (o is IField) {
+					completionData.Add(new CodeCompletionData((IField)o));
+				} else if (o is IEvent) {
+					IEvent e = (IEvent)o;
+					if (e.Name != null &amp;&amp; insertedEventElements[e.Name] == null) {
+						completionData.Add(new CodeCompletionData(e));
+						insertedEventElements[e.Name] = e;
+					}
+				} else if (o is IParameter) {
+					completionData.Add (new CodeCompletionData((IParameter)o));
+				}
+			}
+		}
+			
+		void AddResolveResults(ResolveResult results)
+		{
+			if (results != null) {
+				AddResolveResults(results.Namespaces);
+				AddResolveResults(results.Members);
+			}
+		}
+	}
+}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CommentCompletionDataProvider.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CommentCompletionDataProvider.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CommentCompletionDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,128 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Templates;
+using MonoDevelop.Services;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+using Stock = MonoDevelop.Gui.Stock;
+
+namespace MonoDevelop.Gui.Completion
+{
+	/// &lt;summary&gt;
+	/// Data provider for code completion.
+	/// &lt;/summary&gt;
+	public class CommentCompletionDataProvider : ICompletionDataProvider
+	{
+		static IParserService           parserService           = (IParserService)MonoDevelop.Core.Services.ServiceManager.GetService(typeof(IParserService));
+		
+		int caretLineNumber;
+		int caretColumn;
+		
+		string[][] commentTags = new string[][] {
+			new string[] {&quot;c&quot;, &quot;marks text as code&quot;},
+			new string[] {&quot;code&quot;, &quot;marks text as code&quot;},
+			new string[] {&quot;example&quot;, &quot;A description of the code example\n(must have a &lt;code&gt; tag inside)&quot;},
+			new string[] {&quot;exception cref=\&quot;\&quot;&quot;, &quot;description to an exception thrown&quot;},
+			new string[] {&quot;list type=\&quot;\&quot;&quot;, &quot;A list&quot;},
+			new string[] {&quot;listheader&quot;, &quot;The header from the list&quot;},
+			new string[] {&quot;item&quot;, &quot;A list item&quot;},
+			new string[] {&quot;term&quot;, &quot;A term in a list&quot;},
+			new string[] {&quot;description&quot;, &quot;A description to a term in a list&quot;},
+			new string[] {&quot;param name=\&quot;\&quot;&quot;, &quot;A description for a parameter&quot;},
+			new string[] {&quot;paramref name=\&quot;\&quot;&quot;, &quot;A reference to a parameter&quot;},
+			new string[] {&quot;permission cref=\&quot;\&quot;&quot;, &quot;&quot;},
+			new string[] {&quot;remarks&quot;, &quot;Gives description for a member&quot;},
+			new string[] {&quot;include file=\&quot;\&quot; path=\&quot;\&quot;&quot;, &quot;Includes comments from other files&quot;},
+			new string[] {&quot;returns&quot;, &quot;Gives description for a return value&quot;},
+			new string[] {&quot;see cref=\&quot;\&quot;&quot;, &quot;A reference to a member&quot;},
+			new string[] {&quot;seealso cref=\&quot;\&quot;&quot;, &quot;A reference to a member in the seealso section&quot;},
+			new string[] {&quot;summary&quot;, &quot;A summary of the object&quot;},
+			new string[] {&quot;value&quot;, &quot;A description of a property&quot;}
+		};
+		
+		/// &lt;remarks&gt;
+		/// Returns true, if the given coordinates (row, column) are in the region.
+		/// &lt;/remarks&gt;
+		bool IsBetween (int row, int column, IRegion region)
+		{
+			return row &gt;= region.BeginLine &amp;&amp; (row &lt;= region.EndLine || region.EndLine == -1);
+		}
+		
+		public ICompletionData[] GenerateCompletionData (Project project, string fileName, ICompletionWidget widget, char charTyped)
+		{
+			/*caretLineNumber = textArea.Caret.Line;
+			caretColumn     = textArea.Caret.Column;
+			LineSegment caretLine = textArea.Document.GetLineSegment(caretLineNumber);
+			string lineText = textArea.Document.GetText(caretLine.Offset, caretLine.Length);
+			if (!lineText.Trim().StartsWith(&quot;///&quot;)) {
+				return null;
+			}
+			*/
+			ArrayList completionData = new ArrayList ();
+			/*foreach (string[] tag in commentTags) {
+				completionData.Add(new CommentCompletionData(tag[0], tag[1]));
+			}*/
+			return (ICompletionData[])completionData.ToArray (typeof (ICompletionData));
+		}
+		
+		class CommentCompletionData : ICompletionData
+		{
+			string text;
+			string description;
+			
+			public string Image
+			{
+				get {
+					return Stock.Method;
+				}
+			}
+			
+			public string[] Text
+			{
+				get {
+					return new string[] { text };
+				}
+			}
+
+			public string CompletionString
+			{
+				get 
+				{
+					return &quot;&quot;;
+				}
+			}
+			
+			public string Description
+			{
+				get {
+					return description;
+				}
+			}
+			
+			public void InsertAction (ICompletionWidget widget)
+			{
+				//((SharpDevelopTextAreaControl)control).ActiveTextAreaControl.TextArea.InsertString(text);
+			}
+			
+			public CommentCompletionData (string text, string description) 
+			{
+				this.text = text;
+				this.description = description;
+			}
+		}
+	}
+}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CompletionListWindow.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/CompletionListWindow.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,241 @@
+using System;
+using System.Collections;
+
+using Gtk;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Gui.Completion
+{
+	public class CompletionListWindow : ListWindow, IListDataProvider
+	{
+		string fileName;
+		Project project;
+		ICompletionWidget completionWidget;
+		ICompletionData[] completionData;
+		DeclarationViewWindow declarationviewwindow = new DeclarationViewWindow ();
+		static DataComparer dataComparer = new DataComparer ();
+		
+		class DataComparer: IComparer
+		{
+			public int Compare (object x, object y)
+			{
+				ICompletionData d1 = x as ICompletionData;
+				ICompletionData d2 = y as ICompletionData;
+				return String.Compare (d1.Text[0], d2.Text[0], true);
+			}
+		}
+		
+		static CompletionListWindow wnd;
+		
+		static CompletionListWindow ()
+		{
+			wnd = new CompletionListWindow ();
+		}
+		
+		public CompletionListWindow ()
+		{
+			SizeAllocated += new SizeAllocatedHandler (ListSizeChanged);
+		}
+		
+		public static void ShowWindow (char firstChar, ICompletionDataProvider provider, ICompletionWidget completionWidget, Project project, string fileName)
+		{
+			if (!wnd.ShowListWindow (firstChar, provider,  completionWidget, project, fileName))
+				return;
+			
+			// makes control-space in midle of words to work
+			string text = wnd.completionWidget.CompletionText;
+			if (text.Length == 0)
+				return;
+			
+			wnd.PartialWord = text; 
+			//if there is only one matching result we take it by default
+			if (wnd.IsUniqueMatch)
+			{	
+				wnd.Hide ();
+			}
+			
+			wnd.UpdateWord ();
+			
+			wnd.PartialWord = wnd.CompleteWord;		
+		}
+		
+		bool ShowListWindow (char firstChar, ICompletionDataProvider provider, ICompletionWidget completionWidget, Project project, string fileName)
+		{
+			this.completionWidget = completionWidget;
+			this.fileName = fileName;
+			this.project = project;
+			
+			completionData = provider.GenerateCompletionData (project, fileName, completionWidget, firstChar);
+
+			if (completionData == null || completionData.Length == 0) return false;
+			
+			this.Style = completionWidget.GtkStyle;
+			
+			Array.Sort (completionData, dataComparer);
+			
+			DataProvider = this;
+
+			int x = completionWidget.TriggerXCoord;
+			int y = completionWidget.TriggerYCoord;
+			
+			int w, h;
+			GetSize (out w, out h);
+			
+			if ((x + w) &gt; Screen.Width)
+				x = Screen.Width - w;
+			
+			if ((y + h) &gt; Screen.Height)
+			{
+				y = y - completionWidget.TriggerTextHeight - h;
+			}
+
+			Move (x, y);
+			
+			Show ();
+			return true;
+		}
+		
+		public static void HideWindow ()
+		{
+			wnd.Hide ();
+		}
+		
+		public static bool ProcessKeyEvent (Gdk.EventKey e)
+		{
+			if (!wnd.Visible) return false;
+			
+			ListWindow.KeyAction ka = wnd.ProcessKey (e);
+			
+			if ((ka &amp; ListWindow.KeyAction.CloseWindow) != 0)
+				wnd.Hide ();
+				
+			if ((ka &amp; ListWindow.KeyAction.Complete) != 0) {
+				wnd.UpdateWord ();
+			}
+			
+			if ((ka &amp; ListWindow.KeyAction.Ignore) != 0)
+				return true;
+
+			if ((ka &amp; ListWindow.KeyAction.Process) != 0) {
+				if (e.Key == Gdk.Key.Left) {
+					wnd.declarationviewwindow.OverloadLeft ();
+					return true;
+				} else if (e.Key == Gdk.Key.Right) {
+					wnd.declarationviewwindow.OverloadRight ();
+					return true;
+				}
+			}
+
+			return false;
+		}
+		
+		void UpdateWord ()
+		{
+			completionWidget.SetCompletionText(wnd.PartialWord, wnd.CompleteWord);
+		}
+		
+		public new void Hide ()
+		{
+			base.Hide ();
+			declarationviewwindow.HideAll ();
+		}
+		
+		void ListSizeChanged (object obj, SizeAllocatedArgs args)
+		{
+			// FIXME: crashes on System.Runtime.
+			// first line array out of bounds
+			//UpdateDeclarationView ();
+		}
+
+		protected override bool OnButtonPressEvent (Gdk.EventButton evnt)
+		{
+			bool ret = base.OnButtonPressEvent (evnt);
+			if (evnt.Button == 1 &amp;&amp; evnt.Type == Gdk.EventType.TwoButtonPress) {
+				wnd.Hide ();
+				wnd.UpdateWord ();
+			}
+			return ret;
+		}
+		
+		protected override void OnSelectionChanged ()
+		{
+			base.OnSelectionChanged ();
+			UpdateDeclarationView ();
+		}
+		
+		void UpdateDeclarationView ()
+		{
+			ICompletionData data = completionData[List.Selection];
+			
+			declarationviewwindow.Hide ();
+			declarationviewwindow.Clear ();
+			
+			if (List.GdkWindow == null) return;
+			Gdk.Rectangle rect = List.GetRowArea (List.Selection);
+			int listpos_x = 0, listpos_y = 0;
+			while (listpos_x == 0 || listpos_y == 0)
+				GetPosition (out listpos_x, out listpos_y);
+			int vert = listpos_y + rect.Y;
+			
+			int lvWidth = 0, lvHeight = 0;
+			while (lvWidth == 0)
+				this.GdkWindow.GetSize (out lvWidth, out lvHeight);
+			if (vert &gt;= listpos_y + lvHeight - 2) {
+				vert = listpos_y + lvHeight - rect.Height;
+			} else if (vert &lt; listpos_y) {
+				vert = listpos_y;
+			}
+			int horiz = listpos_x + lvWidth + 2;
+
+			ICompletionDataWithMarkup datawMarkup = data as ICompletionDataWithMarkup;
+
+			string descMarkup = datawMarkup != null ? datawMarkup.DescriptionPango : data.Description;
+
+			declarationviewwindow.Realize ();
+
+			declarationviewwindow.AddOverload (descMarkup);
+
+			CodeCompletionData ccdata = (CodeCompletionData) data;
+
+			foreach (CodeCompletionData odata in ccdata.GetOverloads ()) {
+				ICompletionDataWithMarkup odatawMarkup = odata as ICompletionDataWithMarkup;
+				declarationviewwindow.AddOverload (odatawMarkup == null ? odata.Description : odatawMarkup.DescriptionPango);
+			}
+
+			if (declarationviewwindow.DescriptionMarkup.Length == 0)
+				return;
+
+			int dvwWidth, dvwHeight;
+
+			declarationviewwindow.Move (this.Screen.Width+1, vert);
+			
+			declarationviewwindow.ReshowWithInitialSize ();
+			declarationviewwindow.ShowAll ();
+			declarationviewwindow.Multiple = (ccdata.Overloads != 0);
+
+			declarationviewwindow.GdkWindow.GetSize (out dvwWidth, out dvwHeight);
+
+			if (this.Screen.Width &lt;= horiz + dvwWidth) {
+				horiz = listpos_x - dvwWidth - 10;
+			}
+			
+			declarationviewwindow.Move (horiz, vert);
+		}
+		
+		public int ItemCount 
+		{ 
+			get { return completionData.Length; } 
+		}
+		
+		public string GetText (int n)
+		{
+			return completionData[n].Text[0];
+		}
+		
+		public Gdk.Pixbuf GetIcon (int n)
+		{
+			return RenderIcon (completionData[n].Image, Gtk.IconSize.Menu, &quot;&quot;);
+		}
+	}
+}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/DeclarationViewWindow.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/DeclarationViewWindow.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/DeclarationViewWindow.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,162 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using Gtk;
+
+namespace MonoDevelop.Gui.Completion
+{
+	public class DeclarationViewWindow : Window
+	{
+		static char[] newline = {'\n'};
+		static char[] whitespace = {' '};
+
+		ArrayList overloads;
+		int current_overload;
+
+		Label headlabel, bodylabel, helplabel;
+		Arrow left, right;
+		VBox helpbox;
+		
+		public string DescriptionMarkup
+		{
+			get {
+			 	if (bodylabel.Text == &quot;&quot;)
+					return headlabel.Text;
+				else
+					return headlabel.Text + &quot;\n&quot; + bodylabel.Text;
+			}
+			
+			set {
+				if (value == null) {
+					headlabel.Markup = &quot;&quot;;
+					bodylabel.Markup = &quot;&quot;;
+					return;
+				}
+
+				string[] parts = value.Split (newline, 2);
+				headlabel.Markup = parts[0].Trim (whitespace);
+				bodylabel.Markup = (parts.Length == 2 ? parts[1].Trim (whitespace) : String.Empty);
+
+				headlabel.Visible = headlabel.Text != &quot;&quot;;
+				bodylabel.Visible = bodylabel.Text != &quot;&quot;;
+				//QueueDraw ();
+			}
+		}
+
+		public bool Multiple
+		{
+			get {
+				return left.Visible;
+			}
+
+			set {
+				left.Visible = value;
+				right.Visible = value;
+				helpbox.Visible = value;
+				
+				//this could go somewhere better, as long as it's after realization
+				headlabel.Visible = headlabel.Text != &quot;&quot;;
+				bodylabel.Visible = bodylabel.Text != &quot;&quot;;
+			}
+		}
+
+		public void AddOverload (string desc)
+		{
+			overloads.Add (desc);
+			if (overloads.Count == 2) {
+				Multiple = true;
+			}
+			ShowOverload ();
+		}
+
+		void ShowOverload ()
+		{
+			DescriptionMarkup = (string)overloads[current_overload];
+			helplabel.Markup = String.Format (&quot;&lt;small&gt;{0} of {1} overloads&lt;/small&gt;&quot;, current_overload + 1, overloads.Count);
+		}
+
+		public void OverloadLeft ()
+		{
+			if (current_overload == 0)
+				current_overload = overloads.Count - 1;
+			else
+				current_overload--;
+			ShowOverload ();
+		}
+
+		public void OverloadRight ()
+		{
+			if (current_overload == overloads.Count - 1)
+				current_overload = 0;
+			else
+				current_overload++;
+			ShowOverload ();
+		}
+
+		public void Clear ()
+		{
+			overloads.Clear ();
+			Multiple = false;
+			DescriptionMarkup = String.Empty;
+			current_overload = 0;
+		}
+
+		public DeclarationViewWindow () : base (WindowType.Popup)
+		{
+			overloads = new ArrayList ();
+			this.AllowShrink = false;
+			this.AllowGrow = false;
+
+			headlabel = new Label (&quot;&quot;);
+			headlabel.LineWrap = false;
+			headlabel.Xalign = 0;
+			
+			bodylabel = new Label (&quot;&quot;);
+			bodylabel.LineWrap = true;
+			bodylabel.Xalign = 0;
+
+			VBox vb = new VBox (false, 0);
+			vb.PackStart (headlabel, false, true, 0);
+			vb.PackStart (bodylabel, false, true, 0);
+
+			left = new Arrow (ArrowType.Left, ShadowType.None);
+			right = new Arrow (ArrowType.Right, ShadowType.None);
+
+			HBox hb = new HBox (false, 0);
+			hb.Spacing = 4;
+			hb.PackStart (left, false, true, 0);
+			hb.PackStart (vb, true, true, 0);
+			hb.PackStart (right, false, true, 0);
+
+			helplabel = new Label (&quot;&quot;);
+			helplabel.Xpad = 2;
+			helplabel.Ypad = 2;
+			helplabel.Xalign = 1;
+			helplabel.UseMarkup = true;
+			helplabel.Markup = &quot;&quot;;
+			
+			helpbox = new VBox (false, 0);
+			helpbox.PackStart (new HSeparator (), false, true, 0);
+			helpbox.PackStart (helplabel, false, true, 0);
+			
+			VBox vb2 = new VBox (false, 0);
+			vb2.Spacing = 4;
+			vb2.PackStart (hb, false, true, 0);
+			vb2.PackStart (helpbox, false, true, 0);
+
+			Frame frame = new Frame ();
+			frame.Add (vb2);
+			
+			this.Add (frame);
+		}
+	}
+}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionData.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionData.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionData.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,43 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+namespace MonoDevelop.Gui.Completion
+{
+	public interface ICompletionData
+	{
+		string Image {
+			get;
+		}
+		
+		string[] Text {
+			get;
+		}
+		
+		string Description {
+			get;
+		}
+
+		string CompletionString 
+		{
+			get;
+		}
+		
+		void InsertAction(ICompletionWidget widget);
+	}
+	
+	public interface ICompletionDataWithMarkup : ICompletionData
+	{
+		string DescriptionPango {
+			get;
+		}
+	}
+}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionDataProvider.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ICompletionDataProvider.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+using MonoDevelop.Internal.Project;
+
+using Gdk;
+
+namespace MonoDevelop.Gui.Completion {
+	public interface ICompletionDataProvider {
+		ICompletionData[] GenerateCompletionData(Project project, string fileName, ICompletionWidget widget, char charTyped);
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionWidget.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionWidget.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ICompletionWidget.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,32 @@
+
+using System;
+using MonoDevelop.Internal.Project;
+using Gtk;
+
+namespace MonoDevelop.Gui.Completion
+{
+
+	public interface ICompletionWidget
+	{
+		string Text { get; }
+		int TextLength { get; }
+		string GetText (int startOffset, int endOffset);
+		char GetChar (int offset);
+
+		string CompletionText { get; }
+
+		void SetCompletionText (string partial_word, string complete_word);
+
+		void InsertAtCursor (string text);
+
+		int TriggerOffset { get; }
+		int TriggerLine { get; }
+		int TriggerLineOffset { get; }
+
+		int TriggerXCoord { get; }
+		int TriggerYCoord { get; }
+		int TriggerTextHeight { get; }
+
+		Gtk.Style GtkStyle { get; }
+	}
+}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ListWindow.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/ListWindow.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,477 @@
+using Gtk;
+using Gdk;
+using Pango;
+using System;
+using System.Text;
+
+namespace MonoDevelop.Gui.Completion
+{
+	public class ListWindow: Gtk.Window
+	{
+		VScrollbar scrollbar;
+		ListWidget list;
+		IListDataProvider provider;
+		
+		StringBuilder word;
+		int curPos;
+		
+		[Flags]
+		public enum KeyAction { Process=1, Ignore=2, CloseWindow=4, Complete=8 } 
+
+		public ListWindow (): base (Gtk.WindowType.Popup)
+		{
+			HBox box = new HBox ();
+			
+			list = new ListWidget (this);
+			list.SelectionChanged += new EventHandler (OnSelectionChanged);
+			list.ScrollEvent += new ScrollEventHandler (OnScrolled);
+			box.PackStart (list, true, true, 0);
+			this.BorderWidth = 1;
+			
+			scrollbar = new VScrollbar (null);
+			scrollbar.ValueChanged += new EventHandler (OnScrollChanged); 
+			box.PackStart (scrollbar, false, false, 0);
+			
+			Add (box);
+			this.TypeHint = WindowTypeHint.Menu;
+		}
+		
+		public new void Show ()
+		{
+			this.ShowAll ();
+			Reset ();
+		}
+		
+		public void Reset ()
+		{
+			word = new StringBuilder ();
+			curPos = 0;
+			list.Reset ();
+
+			if (list.VisibleRows &gt;= provider.ItemCount) {
+				this.scrollbar.Hide();
+			}
+			else {
+				scrollbar.Adjustment.Lower = 0;
+				scrollbar.Adjustment.Upper = provider.ItemCount - list.VisibleRows;
+				scrollbar.Adjustment.PageIncrement = list.VisibleRows - 1;
+				scrollbar.Adjustment.StepIncrement = 1;
+			}
+
+			this.Resize(this.list.WidthRequest, this.list.HeightRequest);
+		}
+		
+		public IListDataProvider DataProvider
+		{
+			get { return provider; }
+			set { provider = value; }
+		}
+		
+		public string CompleteWord
+		{
+			get { return provider.GetText (list.Selection);	}
+		}
+		
+		public string PartialWord
+		{
+			get { return word.ToString (); }
+			set
+			{
+				string newword = value;
+				if (newword.Trim ().Length == 0)
+					return;
+				
+				word = new StringBuilder (newword);
+				curPos = newword.Length;
+				UpdateWordSelection ();
+			}
+		}
+		
+		public bool IsUniqueMatch
+		{
+			get
+			{
+				int pos = list.Selection + 1;
+				if (provider.ItemCount &gt; pos &amp;&amp; provider.GetText (pos).ToLower ().StartsWith (PartialWord.ToLower ()) || !(provider.GetText (list.Selection).ToLower ().StartsWith (PartialWord.ToLower ())))
+					return false;
+				
+				return true;	
+			}
+		}
+		
+		protected ListWidget List
+		{
+			get { return list; }
+		}
+		
+		public KeyAction ProcessKey (EventKey e)
+		{
+			switch (e.Key)
+			{
+				case Gdk.Key.Up:
+					list.Selection --;
+					return KeyAction.Ignore;
+					
+				case Gdk.Key.Down:
+					list.Selection ++;
+					return KeyAction.Ignore;
+					
+				case Gdk.Key.Page_Up:
+					list.Selection -= list.VisibleRows - 1;
+					return KeyAction.Ignore;
+					
+				case Gdk.Key.Page_Down:
+					list.Selection += list.VisibleRows - 1;
+					return KeyAction.Ignore;
+					
+				case Gdk.Key.Left:
+					//if (curPos == 0) return KeyAction.CloseWindow | KeyAction.Process;
+					//curPos--;
+					return KeyAction.Process;
+					
+				case Gdk.Key.BackSpace:
+					if (curPos == 0) return KeyAction.CloseWindow | KeyAction.Process;
+					curPos--;
+					word.Remove (curPos, 1);
+					UpdateWordSelection ();
+					return KeyAction.Process;
+					
+				case Gdk.Key.Right:
+					//if (curPos == word.Length) return KeyAction.CloseWindow | KeyAction.Process;
+					//curPos++;
+					return KeyAction.Process;
+					
+				case Gdk.Key.Tab:
+				case Gdk.Key.Return:
+				case Gdk.Key.ISO_Enter:
+				case Gdk.Key.Key_3270_Enter:
+				case Gdk.Key.KP_Enter:
+					return KeyAction.Complete | KeyAction.Ignore | KeyAction.CloseWindow;
+					
+				case Gdk.Key.Escape:
+					return KeyAction.CloseWindow | KeyAction.Ignore;
+					
+				case Gdk.Key.Home:
+				case Gdk.Key.End:
+					return KeyAction.CloseWindow | KeyAction.Process;
+					
+				case Gdk.Key.Control_L:
+				case Gdk.Key.Control_R:
+				case Gdk.Key.Alt_L:
+				case Gdk.Key.Alt_R:
+				case Gdk.Key.Shift_L:
+				case Gdk.Key.Shift_R:
+				case Gdk.Key.ISO_Level3_Shift:	// AltGr
+					return KeyAction.Process;
+			}
+			
+			char c = (char)e.KeyValue;
+			
+			if (System.Char.IsLetterOrDigit (c) || c == '_') {
+				word.Insert (curPos++, c);
+				UpdateWordSelection ();
+				return KeyAction.Process;
+			}
+			else if ((System.Char.IsPunctuation (c) || c == ' ') &amp;&amp; !list.SelectionDisabled) {
+				return KeyAction.Complete | KeyAction.Process | KeyAction.CloseWindow;
+			}
+			
+			return KeyAction.CloseWindow | KeyAction.Process;
+		}
+		
+		void UpdateWordSelection ()
+		{
+			string s = word.ToString ();
+			int max = (provider == null ? 0 : provider.ItemCount);
+			
+			int bestMatch = -1;
+			for (int n=0; n&lt;max; n++) 
+			{
+				string txt = provider.GetText (n);
+				if (txt.StartsWith (s)) {
+					list.Selection = n;
+					return;
+				}
+				else if (bestMatch == -1 &amp;&amp; txt.ToLower().StartsWith (s.ToLower()))
+					bestMatch = n;
+			}
+			
+			if (bestMatch != -1) {
+				list.Selection = bestMatch;
+				return;
+			}
+			
+			list.SelectionDisabled = true;
+		}
+		
+		void OnScrollChanged (object o, EventArgs args)
+		{
+			list.Page = (int) scrollbar.Value;
+		}
+
+		void OnScrolled (object o, ScrollEventArgs args)
+		{
+			if (args.Event.Direction == Gdk.ScrollDirection.Up)
+				scrollbar.Value --;
+			else if (args.Event.Direction == Gdk.ScrollDirection.Down)
+				scrollbar.Value ++;
+		}
+		
+		void OnSelectionChanged (object o, EventArgs args)
+		{
+			scrollbar.Value = list.Page;
+			OnSelectionChanged ();
+		}
+		
+		protected virtual void OnSelectionChanged ()
+		{
+		}
+		
+		protected override bool OnExposeEvent (Gdk.EventExpose args)
+		{
+			base.OnExposeEvent (args);
+			
+			int winWidth, winHeight;
+			this.GetSize (out winWidth, out winHeight);
+			this.GdkWindow.DrawRectangle (this.Style.ForegroundGC (StateType.Insensitive), false, 0, 0, winWidth-1, winHeight-1);
+			return false;
+		}		
+	}
+
+	public class ListWidget: Gtk.DrawingArea
+	{
+		int margin = 0;
+		int padding = 4;
+		int listWidth = 300;
+		
+		Pango.Layout layout;
+		ListWindow win;
+		int selection = 0;
+		int page = 0;
+		int visibleRows = -1;
+		int rowWidth, rowHeight;
+		bool buttonPressed;
+		bool disableSelection;
+
+		public event EventHandler SelectionChanged;
+				
+		public ListWidget (ListWindow win)
+		{
+			this.win = win;
+			this.Events = EventMask.ButtonPressMask | EventMask.ButtonReleaseMask | EventMask.PointerMotionMask; 
+		}
+		
+		public void Reset ()
+		{
+			selection = 0;
+			page = 0;
+			disableSelection = false;
+			UpdateStyle ();
+			QueueDraw ();
+			if (SelectionChanged != null) SelectionChanged (this, EventArgs.Empty);
+		}
+		
+		public int Selection
+		{
+			get {
+				return selection;
+			}
+			
+			set {
+				if (value &lt; 0)
+					value = 0;
+				else if (value &gt;= win.DataProvider.ItemCount)
+					value = win.DataProvider.ItemCount - 1;
+					
+				if (value != selection) 
+				{
+					selection = value;
+						
+					if (selection &lt; page)
+						page = selection;
+					else if (selection &gt;= page + VisibleRows) {
+						page = selection - VisibleRows + 1;
+						if (page &lt; 0) page = 0;
+					}
+					
+					if (SelectionChanged != null) SelectionChanged (this, EventArgs.Empty);
+				}
+				
+				if (disableSelection)
+					disableSelection = false;
+
+				this.QueueDraw ();
+			}
+		}
+		
+		public bool SelectionDisabled
+		{
+			get { return disableSelection; }
+			
+			set {
+				disableSelection = value; 
+				this.QueueDraw ();
+			}
+		}
+		
+		public int Page
+		{
+			get { 
+				return page; 
+			}
+			
+			set {
+				page = value;
+				this.QueueDraw ();
+			}
+		}
+		
+		protected override bool OnButtonPressEvent (EventButton e)
+		{
+			Selection = GetRowByPosition ((int) e.Y);
+			buttonPressed = true;
+			return base.OnButtonPressEvent (e);
+		}
+		
+		protected override bool OnButtonReleaseEvent (EventButton e)
+		{
+			buttonPressed = false;
+			return base.OnButtonReleaseEvent (e);
+		}
+		
+		protected override bool OnMotionNotifyEvent (EventMotion e)
+		{
+			if (!buttonPressed)
+				return base.OnMotionNotifyEvent (e);
+			
+			int winWidth, winHeight;
+			this.GdkWindow.GetSize (out winWidth, out winHeight);
+			
+	/*		int ypos = (int) e.Y;
+			if (ypos &lt; 0) {
+			}
+			else if (ypos &gt;= winHeight) {
+			}
+			else
+	*/			Selection = GetRowByPosition ((int) e.Y);
+			
+			return true;
+		}
+
+		protected override bool OnExposeEvent (Gdk.EventExpose args)
+		{
+			base.OnExposeEvent (args);
+			DrawList ();
+	  		return true;
+		}
+
+		void DrawList ()
+		{
+			int winWidth, winHeight;
+			this.GdkWindow.GetSize (out winWidth, out winHeight);
+			
+			int ypos = margin;
+			int lineWidth = winWidth - margin*2;
+			int xpos = margin + padding;
+				
+			int n = 0;
+			while (ypos &lt; winHeight - margin &amp;&amp; (page + n) &lt; win.DataProvider.ItemCount)
+			{
+				layout.SetMarkup (win.DataProvider.GetText (page + n));
+				Gdk.Pixbuf icon = win.DataProvider.GetIcon (page + n);
+				
+				int wi, he, typos, iypos;
+				layout.GetPixelSize (out wi, out he);
+				typos = he &lt; rowHeight ? ypos + (rowHeight - he) / 2 : ypos;
+				iypos = icon.Height &lt; rowHeight ? ypos + (rowHeight - icon.Height) / 2 : ypos;
+				
+				if (page + n == selection) {
+					if (!disableSelection) {
+						this.GdkWindow.DrawRectangle (this.Style.BaseGC (StateType.Selected), true, margin, ypos, lineWidth, he + padding);
+						this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Selected), xpos + icon.Width + 2, typos, layout);
+					}
+					else {
+						this.GdkWindow.DrawRectangle (this.Style.BaseGC (StateType.Selected), false, margin, ypos, lineWidth, he + padding);
+						this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Normal), xpos + icon.Width + 2, typos, layout);
+					}
+				}
+				else
+					this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Normal), xpos + icon.Width + 2, typos, layout);
+					
+				this.GdkWindow.DrawPixbuf (this.Style.ForegroundGC (StateType.Normal), icon, 0, 0, xpos, iypos, icon.Width, icon.Height, Gdk.RgbDither.None, 0, 0);
+				
+				ypos += rowHeight;
+				n++;
+			}
+		}
+		
+		int GetRowByPosition (int ypos)
+		{
+			if (visibleRows == -1) CalcVisibleRows ();
+			return page + (ypos-margin) / rowHeight;
+		}
+		
+		public Gdk.Rectangle GetRowArea (int row)
+		{
+			row -= page;
+			int winWidth, winHeight;
+			this.GdkWindow.GetSize (out winWidth, out winHeight);
+			
+			return new Gdk.Rectangle (margin, margin + rowHeight * row, winWidth, rowHeight);
+		}
+		
+		public int VisibleRows
+		{
+			get {
+				if (visibleRows == -1) CalcVisibleRows ();
+				return visibleRows;
+			}
+		}
+		
+		void CalcVisibleRows ()
+		{
+			int winHeight = 200;
+			int lvWidth, lvHeight;
+			this.GdkWindow.GetSize (out lvWidth, out lvHeight);
+
+			layout.GetPixelSize (out rowWidth, out rowHeight);
+			rowHeight += padding;
+			visibleRows = (winHeight + padding - margin * 2) / rowHeight;
+			
+			int newHeight;
+
+			if (this.win.DataProvider.ItemCount &gt; this.visibleRows)
+				newHeight = (rowHeight * visibleRows) + margin * 2;
+			else
+				newHeight = (rowHeight * this.win.DataProvider.ItemCount) + margin * 2;
+			
+			if (lvWidth != listWidth || lvHeight != newHeight)
+				this.SetSizeRequest (listWidth, newHeight);
+		} 
+
+		protected override void OnRealized ()
+		{
+			base.OnRealized ();
+			UpdateStyle ();
+		}
+		
+		void UpdateStyle ()
+		{
+			this.GdkWindow.Background = this.Style.Base (StateType.Normal);
+			layout = new Pango.Layout (this.PangoContext);
+			layout.Wrap = Pango.WrapMode.Char;
+			
+			FontDescription des = this.Style.FontDescription.Copy();
+			layout.FontDescription = des;
+			CalcVisibleRows ();
+		}
+	}
+
+	public interface IListDataProvider
+	{
+		int ItemCount { get; }
+		string GetText (int n);
+		Gdk.Pixbuf GetIcon (int n);
+	}
+}
+

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/TemplateCompletionDataProvider.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TemplateCompletionDataProvider.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/TemplateCompletionDataProvider.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,87 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Reflection;
+using System.Collections;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Internal.Templates;
+using MonoDevelop.Internal.Project;
+using Stock = MonoDevelop.Gui.Stock;
+
+namespace MonoDevelop.Gui.Completion
+{
+	public class TemplateCompletionDataProvider : ICompletionDataProvider
+	{
+		public Gdk.Pixbuf[] ImageList
+		{
+			get {
+				return null;
+			}
+		}
+		
+		public ICompletionData[] GenerateCompletionData(Project project, string fileName, ICompletionWidget widget, char charTyped)
+		{
+			CodeTemplateGroup templateGroup = CodeTemplateLoader.GetTemplateGroupPerFilename(fileName);
+			if (templateGroup == null) {
+				return null;
+			}
+			ArrayList completionData = new ArrayList();
+			foreach (CodeTemplate template in templateGroup.Templates) {
+				completionData.Add(new TemplateCompletionData(template));
+			}
+			
+			return (ICompletionData[])completionData.ToArray(typeof(ICompletionData));
+		}
+		
+		class TemplateCompletionData : ICompletionData
+		{
+			CodeTemplate template;
+			
+			public string Image
+			{
+				get {
+					return Stock.Method;
+				}
+			}
+
+			public string CompletionString
+			{
+				get 
+				{
+					return &quot;&quot;;
+				}
+			}
+			
+			public string[] Text
+			{
+				get {
+					return new string[] { template.Shortcut, template.Description };
+				}
+			}
+			
+			public string Description
+			{
+				get {
+					return template.Text;
+				}
+			}
+			
+			public void InsertAction(ICompletionWidget widget)
+			{
+				//((SharpDevelopTextAreaControl)control).InsertTemplate(template);
+			}
+			
+			public TemplateCompletionData(CodeTemplate template) 
+			{
+				this.template = template;
+			}
+		}
+	}
+}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/TextUtilities.cs (from rev 2671, trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/TextUtilities.cs	2005-07-19 02:00:39 UTC (rev 2671)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Completion/TextUtilities.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -0,0 +1,398 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Text;
+using System.Diagnostics;
+
+namespace MonoDevelop.Gui.Completion
+{
+	public sealed class TextUtilities
+	{
+		
+		/// &lt;remarks&gt;
+		/// This function takes a string and converts the whitespace in front of
+		/// it to tabs. If the length of the whitespace at the start of the string
+		/// was not a whole number of tabs then there will still be some spaces just
+		/// before the text starts.
+		/// the output string will be of the form:
+		/// 1. zero or more tabs
+		/// 2. zero or more spaces (less than tabIndent)
+		/// 3. the rest of the line
+		/// &lt;/remarks&gt;
+/*		public static string LeadingWhiteSpaceToTabs(string line, int tabIndent) {
+			StringBuilder sb = new StringBuilder(line.Length);
+			int consecutiveSpaces = 0;
+			int i = 0;
+			for(i = 0; i &lt; line.Length; i++) {
+				if(line[i] == ' ') {
+					consecutiveSpaces++;
+					if(consecutiveSpaces == tabIndent) {
+						sb.Append('\t');
+						consecutiveSpaces = 0;
+					}
+				}
+				else if(line[i] == '\t') {
+					sb.Append('\t');
+					// if we had say 3 spaces then a tab and tabIndent was 4 then
+					// we would want to simply replace all of that with 1 tab
+					consecutiveSpaces = 0;					
+				}
+				else {
+					break;
+				}
+			}
+			if(i &lt; line.Length) {
+				sb.Append(line.Substring(i-consecutiveSpaces));
+			}
+			return sb.ToString();
+		}
+*/
+
+		public static bool IsLetterDigitOrUnderscore(char c)
+		{
+			if(!Char.IsLetterOrDigit(c)) {
+				return c == '_';
+			}
+			return true;
+		}
+		
+		public enum CharacterType
+		{
+			LetterDigitOrUnderscore,
+			WhiteSpace,
+			Other
+		}
+		
+		/// &lt;remarks&gt;
+		/// This method returns the expression before a specified offset.
+		/// That method is used in code completion to determine the expression given
+		/// to the parser for type resolve.
+		/// &lt;/remarks&gt;
+		//public static string GetExpressionBeforeOffset(string text, int offset)
+		public static string GetExpressionBeforeOffset(ICompletionWidget widget, int offset)
+		{
+			int origOffset = offset;
+			
+			while (offset - 1 &gt; 0) {
+				switch (widget.GetChar (offset - 1)) {
+					case '}':
+						goto done;
+//						break;
+					case ']':
+						offset = SearchBracketBackward(widget, offset - 2, '[',']');
+						break;
+					case ')':
+						offset = SearchBracketBackward(widget, offset - 2, '(',')');
+						break;
+					case '.':
+						--offset;
+						break;
+					case '&quot;':
+						return &quot;\&quot;\&quot;&quot;;
+					case '\'':
+						return &quot;'a'&quot;;
+					case '&gt;':
+						if (widget.GetChar (offset - 2) == '-') {
+							offset -= 2;
+							break;
+						}
+						goto done;
+					default:
+						if (Char.IsWhiteSpace (widget.GetChar (offset - 1))) {
+							--offset;
+							break;
+						}
+						int start = offset - 1;
+						if (!IsLetterDigitOrUnderscore (widget.GetChar (start))) {
+							goto done;
+						}
+						
+						while (start &gt; 0 &amp;&amp; IsLetterDigitOrUnderscore (widget.GetChar(start - 1))) {
+							--start;
+						}
+						
+						Console.WriteLine(&quot;{0} -- {1}&quot;, offset, start);
+						string word = widget.GetText (start, offset);
+						Console.WriteLine(&quot;word &gt;{0}&lt;&quot;, word);
+						switch (word) {
+							case &quot;ref&quot;:
+							case &quot;out&quot;:
+							case &quot;in&quot;:
+							case &quot;return&quot;:
+							case &quot;throw&quot;:
+							case &quot;case&quot;:
+								goto done;
+						}
+						
+						if (word.Length &gt; 0 &amp;&amp; !IsLetterDigitOrUnderscore(word[0])) {
+							goto done;
+						}
+						offset = start;
+						break;
+				}
+			}
+			done:
+//			Console.WriteLine(&quot;offset : {0} origOffset: {1}&quot;, offset, origOffset);
+			return offset - origOffset &gt; 0 ? widget.GetText(origOffset, offset).Trim() : &quot;&quot;;
+		}
+		
+/*		
+		public static CharacterType GetCharacterType(char c) 
+		{
+			if(IsLetterDigitOrUnderscore(c))
+				return CharacterType.LetterDigitOrUnderscore;
+			if(Char.IsWhiteSpace(c))
+				return CharacterType.WhiteSpace;
+			return CharacterType.Other;
+		}
+		
+		public static int GetFirstNonWSChar(IDocument document, int offset)
+		{
+			while (offset &lt; document.TextLength &amp;&amp; Char.IsWhiteSpace(document.GetCharAt(offset))) {
+				++offset;
+			}
+			return offset;
+		}
+		
+		public static int FindWordEnd(IDocument document, int offset)
+		{
+			LineSegment line   = document.GetLineSegmentForOffset(offset);
+			int     endPos = line.Offset + line.Length;
+			while (offset &lt; endPos &amp;&amp; IsLetterDigitOrUnderscore(document.GetCharAt(offset))) {
+				++offset;
+			}
+			
+			return offset;
+		}
+		
+		public static int FindWordStart(IDocument document, int offset)
+		{
+			LineSegment line = document.GetLineSegmentForOffset(offset);
+			
+			while (offset &gt; line.Offset &amp;&amp; !IsLetterDigitOrUnderscore(document.GetCharAt(offset - 1))) {
+				--offset;
+			}
+			
+			return offset;
+		}
+		
+		// go forward to the start of the next word
+		// if the cursor is at the start or in the middle of a word we move to the end of the word
+		// and then past any whitespace that follows it
+		// if the cursor is at the start or in the middle of some whitespace we move to the start of the
+		// next word
+		public static int FindNextWordStart(IDocument document, int offset)
+		{
+			int originalOffset = offset;
+			LineSegment line   = document.GetLineSegmentForOffset(offset);
+			int     endPos = line.Offset + line.Length;
+			// lets go to the end of the word, whitespace or operator
+			CharacterType t = GetCharacterType(document.GetCharAt(offset));
+			while (offset &lt; endPos &amp;&amp; GetCharacterType(document.GetCharAt(offset)) == t) {
+				++offset;
+			}
+			
+			// now we're at the end of the word, lets find the start of the next one by skipping whitespace
+			while (offset &lt; endPos &amp;&amp; GetCharacterType(document.GetCharAt(offset)) == CharacterType.WhiteSpace) {
+				++offset;
+			}
+
+			return offset;
+		}
+		
+		// go back to the start of the word we are on
+		// if we are already at the start of a word or if we are in whitespace, then go back
+		// to the start of the previous word
+		public static int FindPrevWordStart(IDocument document, int offset)
+		{
+			int originalOffset = offset;
+			LineSegment line = document.GetLineSegmentForOffset(offset);
+			if (offset &gt; 0) {
+				CharacterType t = GetCharacterType(document.GetCharAt(offset - 1));
+				while (offset &gt; line.Offset &amp;&amp; GetCharacterType(document.GetCharAt(offset - 1)) == t) {
+					--offset;
+				}
+				
+				// if we were in whitespace, and now we're at the end of a word or operator, go back to the beginning of it
+				if(t == CharacterType.WhiteSpace &amp;&amp; offset &gt; line.Offset) {
+					t = GetCharacterType(document.GetCharAt(offset - 1));
+					while (offset &gt; line.Offset &amp;&amp; GetCharacterType(document.GetCharAt(offset - 1)) == t) {
+						--offset;
+					}
+				}
+			}
+			
+			return offset;
+		}
+		
+		public static string GetLineAsString(IDocument document, int lineNumber)
+		{
+			LineSegment line = document.GetLineSegment(lineNumber);
+			return document.GetText(line.Offset, line.Length);
+		}
+*/
+		static bool ScanLineComment(ICompletionWidget widget, int offset)
+		{
+			while (offset &gt; 0 &amp;&amp; offset &lt; widget.TextLength) {
+				char ch = widget.GetChar (offset);
+				switch (ch) {
+					case '\r':
+					case '\n':
+						return false;
+					case '/':
+						if (widget.GetChar (offset + 1) == '/') {
+							return true;
+						}
+						break;
+				}
+				--offset;
+			}
+			return false;
+		}
+		
+		public static int SearchBracketBackward(ICompletionWidget widget, int offset, char openBracket, char closingBracket)
+		{
+			// FIXME: use iters
+			int brackets = -1;		
+			bool inString = false;
+			bool inChar   = false;	
+			bool blockComment = false;
+			
+			while (offset &gt;= 0 &amp;&amp; offset &lt; widget.TextLength) {
+				char ch = widget.GetChar(offset);
+				switch (ch) {
+					case '/':
+						if (blockComment) {
+							if (widget.GetChar(offset + 1)== '*') {
+								blockComment = false;
+							}
+						}
+						if (!inString &amp;&amp; !inChar &amp;&amp; offset + 1 &lt; widget.TextLength) {
+							if (offset &gt; 0 &amp;&amp; widget.GetChar(offset - 1) == '*') {
+								blockComment = true;
+							}
+						}
+						break;
+					case '&quot;':
+						if (!inChar &amp;&amp; !blockComment &amp;&amp; !ScanLineComment(widget, offset)) {
+							inString = !inString;
+						}
+						break;
+					case '\'':
+						if (!inString &amp;&amp; !blockComment &amp;&amp; !ScanLineComment(widget, offset)) {
+							inChar = !inChar;
+						}
+						break;
+					default :
+						if (ch == closingBracket) {
+							if (!(inString || inChar || blockComment) &amp;&amp; !ScanLineComment(widget, offset)) {
+								--brackets;
+							}
+						} else if (ch == openBracket) {
+							if (!(inString || inChar || blockComment) &amp;&amp; !ScanLineComment(widget, offset)) {
+								++brackets;
+								if (brackets == 0) {
+									return offset;
+								}
+							}
+						}
+						break;
+				}
+				--offset;
+			}
+			return - 1;
+		}
+/*
+		public static int SearchBracketForward(IDocument document, int offset, char openBracket, char closingBracket)
+		{
+			int brackets = 1;
+			
+			bool inString = false;
+			bool inChar   = false;
+			
+			bool lineComment  = false;
+			bool blockComment = false;
+			
+			if (offset &gt;= 0) {
+				while (offset &lt; document.TextLength) {
+					char ch = document.GetCharAt(offset);
+					switch (ch) {
+						case '\r':
+						case '\n':
+							lineComment = false;
+							break;
+						case '/':
+							if (blockComment) {
+								Debug.Assert(offset &gt; 0);
+								if (document.GetCharAt(offset - 1) == '*') {
+									blockComment = false;
+								}
+							}
+							if (!inString &amp;&amp; !inChar &amp;&amp; offset + 1 &lt; document.TextLength) {
+								if (!blockComment &amp;&amp; document.GetCharAt(offset + 1) == '/') {
+									lineComment = true;
+								}
+								if (!lineComment &amp;&amp; document.GetCharAt(offset + 1) == '*') {
+									blockComment = true;
+								}
+							}
+							break;
+						case '&quot;':
+							if (!(inChar || lineComment || blockComment)) {
+								inString = !inString;
+							}
+							break;
+						case '\'':
+							if (!(inString || lineComment || blockComment)) {
+								inChar = !inChar;
+							}
+							break;
+						default :
+							if (ch == openBracket) {
+								if (!(inString || inChar || lineComment || blockComment)) {
+									++brackets;
+								}
+							} else if (ch == closingBracket) {
+								if (!(inString || inChar || lineComment || blockComment)) {
+									--brackets;
+									if (brackets == 0) {
+										return offset;
+									}
+								}
+							}
+							break;
+					}
+					++offset;
+				}
+			}
+			return -1;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns true, if the line lineNumber is empty or filled with whitespaces.
+		/// &lt;/remarks&gt;
+		public static bool IsEmptyLine(IDocument document, int lineNumber)
+		{
+			return IsEmptyLine(document, document.GetLineSegment(lineNumber));
+		}
+
+		/// &lt;remarks&gt;
+		/// Returns true, if the line lineNumber is empty or filled with whitespaces.
+		/// &lt;/remarks&gt;
+		public static bool IsEmptyLine(IDocument document, LineSegment line)
+		{
+			for (int i = line.Offset; i &lt; line.Offset + line.Length; ++i) {
+				char ch = document.GetCharAt(i);
+				if (!Char.IsWhiteSpace(ch)) {
+					return false;
+				}
+			}
+			return true;
+		}*/
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-07-20 16:12:50 UTC (rev 2677)
@@ -87,6 +87,17 @@
 Gui/Components/SdMenuCheckBox.cs \
 Gui/Components/SdMenuCommand.cs \
 Gui/Components/SdToolbarCommand.cs \
+Gui/Completion/CodeCompletionData.cs \
+Gui/Completion/CodeCompletionDataProvider.cs \
+Gui/Completion/CommentCompletionDataProvider.cs \
+Gui/Completion/CompletionListWindow.cs \
+Gui/Completion/DeclarationViewWindow.cs \
+Gui/Completion/ICompletionData.cs \
+Gui/Completion/ICompletionDataProvider.cs \
+Gui/Completion/ICompletionWidget.cs \
+Gui/Completion/ListWindow.cs \
+Gui/Completion/TemplateCompletionDataProvider.cs \
+Gui/Completion/TextUtilities.cs \
 Gui/WorkbenchWindowCollection.cs \
 Gui/WorkbenchSingleton.cs \
 Gui/IMementoCapable.cs \

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs	2005-07-20 16:12:50 UTC (rev 2677)
@@ -255,8 +255,6 @@
 			IProjectService projectService = Runtime.ProjectService;
 			projectService.CombineOpened += new CombineEventHandler(OnCombineOpened);
 			projectService.CombineClosed += new CombineEventHandler(OnCombineClosed);
-			projectService.ReferenceAddedToProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
-			projectService.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
 		}
 		
 		internal IProgressMonitor GetParseProgressMonitor ()
@@ -367,6 +365,8 @@
 					GetDatabase (re.Uri);
 
 				project.NameChanged += new CombineEntryRenamedEventHandler (OnProjectRenamed);
+				project.ReferenceAddedToProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
+				project.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
 			}
 		}
 		
@@ -389,6 +389,8 @@
 			string uri = &quot;Project:&quot; + project.Name;
 			UnloadDatabase (uri);
 			project.NameChanged -= new CombineEntryRenamedEventHandler (OnProjectRenamed);
+			project.ReferenceAddedToProject -= new ProjectReferenceEventHandler (OnProjectReferencesChanged);
+			project.ReferenceRemovedFromProject -= new ProjectReferenceEventHandler (OnProjectReferencesChanged);
 		}
 		
 		void CleanUnusedDatabases ()

Modified: trunk/MonoDevelop/Extras/BooBinding/BooShell/BooShell.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/BooShell/BooShell.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/BooShell/BooShell.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -52,6 +52,19 @@
 		EnqueueCommand (ShellCommand (ShellCommandType.Load, assemblyPath))
 		return true
 	
+	References as IList:
+		get:
+			list = []
+			Monitor.Enter (_interpreter)
+			for assembly as System.Reflection.Assembly in _interpreter.References.List:
+				try:
+					loc = assembly.Location
+					list.Add (loc)
+				except x:
+					continue
+			Monitor.Exit (_interpreter)
+			return list
+	
 	def GetOutput() as (string):
 		ret as (string)
 		try:
@@ -78,7 +91,7 @@
 		GLib.Idle.Add(ProcessCommands)
 		Application.Run()
 
-	def ProcessCommands() as bool:
+	private def ProcessCommands() as bool:
 		com as ShellCommand
 		try:
 			Monitor.Enter (_commandQueue)
@@ -89,6 +102,7 @@
 
 			com = _commandQueue.Dequeue()
 
+			Monitor.Enter(_interpreter)
 			if com.Type == ShellCommandType.Eval:
 				if com.Data is not null:
 					_interpreter.LoopEval(com.Data)
@@ -97,7 +111,9 @@
 			elif com.Type == ShellCommandType.Load:
 				if com.Data is not null:
 					_interpreter.load(com.Data)
-	
+
+			Monitor.Exit(_interpreter)
+
 			com.Type = ShellCommandType.NoOp
 	
 			if _commandQueue.Count == 0:
@@ -115,15 +131,16 @@
 
 	
 	private def kickOffGuiThread():
-		_thread = System.Threading.Thread(ThreadRun)
-		_thread.Start()
+		_start as ThreadStart = ThreadRun
+		_thread = System.Threading.Thread (_start)
+		_thread.Start ()
 	
-	def print(obj):
+	private def print(obj):
 		Monitor.Enter (_outputQueue)
 		_outputQueue.Enqueue(obj)
 		Monitor.Exit (_outputQueue)
 	
-	def EnqueueCommand (command as ShellCommand):
+	private def EnqueueCommand (command as ShellCommand):
 		if not _thread.IsAlive:
 			kickOffGuiThread()
 

Modified: trunk/MonoDevelop/Extras/BooBinding/BooShellPadContent.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/BooShellPadContent.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/BooShellPadContent.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -35,23 +35,23 @@
 
 	override Control:
 		get:
+			if _scroller is null:
+				CreateBooShell()
 			return _scroller
 	
 	def constructor():
 		super( &quot;Boo Shell&quot;, &quot;md-boo-binding-base&quot; )
-		CreateBooShell()
 	
 	def CreateBooShell():
 		_scroller = Gtk.ScrolledWindow()
-		_user = System.Environment.GetEnvironmentVariable(&quot;USER&quot;)
-		_model = BooShellModel (&quot;../AddIns/BackendBindings/BooShellServer.exe&quot;, &quot;/tmp/md-booshell-${_user}&quot;)
+		_model = BooShellModel ()
 		_shellView = ShellTextView (_model)
 		_scroller.Add(_shellView)
 		_scroller.ShowAll()
 
 	override def RedrawContent():
-		OnTitleChanged(null);
-		OnIconChanged(null);
+		OnTitleChanged(null)
+		OnIconChanged(null)
 
 	override def Dispose():
 		_shellView.Dispose()

Modified: trunk/MonoDevelop/Extras/BooBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/ChangeLog	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/ChangeLog	2005-07-20 16:12:50 UTC (rev 2677)
@@ -1,3 +1,17 @@
+2005-07-20  Peter Johanson  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>&gt;
+
+	* Gui/IShellModel.boo:
+	* Gui/ShellTextView.boo:
+	* Gui/BooShellModel.boo:
+	* Gui/OptionPanels/CodeCompilationPanel.boo:
+	* Properties/ShellProperties.boo:
+	* Parser/Resolver.boo:
+	* Parser/BooParser.boo:
+	* BooShellPadContent.boo:
+	* BooShell/BooShell.boo: Lots of cleanup, and add initial support for
+	code completion in the shell.
+	* Makefile.am: Revert makefile change that snuck in.
+
 2005-07-19  Peter Johanson  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">latexer at gentoo.org</A>&gt;
 
 	* templates/BooGtkSharpWindow.xft.xml: Fix small typo.

Modified: trunk/MonoDevelop/Extras/BooBinding/Gui/BooShellModel.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/BooShellModel.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/BooShellModel.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -49,24 +49,32 @@
 		get:
 			return &quot;text/x-boo&quot;
 
+	LanguageName as string:
+		get:
+			return &quot;Boo&quot;
+
+	MimeTypeExtension as string:
+		get:
+			return &quot;boo&quot;
+	
 	Properties as ShellProperties:
 		get:
 			return _props
 	
-	def constructor ():
-		pass
-
-	def constructor (program_path as string, socket_path as string):
-		GetRemoteShellObject ()
+	References as IList:
+		get:	
+			return _booShell.References
+	
+	def constructor():
+		getRemoteShellObject()
 		_booShell.Run ()
 
-	def GetRemoteShellObject ():
+	private def getRemoteShellObject ():
 		_procService as ProcessService = ServiceManager.GetService (typeof (ProcessService))
 		_booShell = _procService.CreateExternalProcessObject (&quot;../AddIns/BackendBindings/BooShell.dll&quot;, &quot;BooBinding.BooShell.BooShell&quot;, false)
 		if _booShell is null:
 			raise Exception (&quot;Unable to instantiate remote BooShell object&quot;)
-
-			
+	
 	def Reset () as bool:
 		_booShell.Reset()
 		return true

Modified: trunk/MonoDevelop/Extras/BooBinding/Gui/IShellModel.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/IShellModel.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/IShellModel.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -20,6 +20,7 @@
 namespace BooBinding.Gui
 
 import System
+import System.Collections
 import BooBinding.Properties
 
 interface IShellModel:
@@ -45,9 +46,16 @@
 		pass
 
 	Properties as ShellProperties:
-		get:
-			pass
+		get
 
+	LanguageName as string:
+		get
+
 	MimeType as string:
-		get:
-			pass
+		get
+	
+	MimeTypeExtension as string:
+		get
+	
+	References as IList:
+		get

Modified: trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/CodeCompilationPanel.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/CodeCompilationPanel.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/OptionPanels/CodeCompilationPanel.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -105,9 +105,7 @@
 		labelCompileTarget.Markup = String.Format (&quot;{0} :&quot;, GettextCatalog.GetString (&quot;Output Assembly&quot;))
 		
 
-		typeArray = array(System.Type, 1)
-		typeArray[0] = typeof(string)
-		store = ListStore (typeArray)
+		store = ListStore ((typeof(string),))
 
 		stringArray = array(System.String, 1)
 		stringArray[0] = GettextCatalog.GetString (&quot;Executable&quot;)

Modified: trunk/MonoDevelop/Extras/BooBinding/Gui/ShellTextView.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Gui/ShellTextView.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/Gui/ShellTextView.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -31,20 +31,19 @@
 import GtkSourceView
 
 import MonoDevelop.Gui.Widgets
+import MonoDevelop.Gui.Completion
 import MonoDevelop.Core.Services
 import MonoDevelop.Services
 import MonoDevelop.Core.Properties
 import MonoDevelop.Internal.Project
 
-
 /*
  * TODO
  * 
- * 1) Code Completion - Nice way to handle code competion for arbitrary shell?
- * 2) Don't record lines with errors in the _scriptLines buffer
+ * 1) Don't record lines with errors in the _scriptLines buffer
  */
 
-class ShellTextView (SourceView):
+class ShellTextView (SourceView, ICompletionWidget):
 	private static _promptRegular = &quot;&gt;&gt;&gt; &quot;
 	private static _promptMultiline = &quot;... &quot;
 	
@@ -68,11 +67,18 @@
 	private _proj as Project
 
 	private _assembliesLoaded as bool
+
+	private _fakeProject as DotNetProject
+	private _parserService as DefaultParserService
+	private _fakeFileName as string
+	private _fileInfo as FileStream
 	
 	def constructor(model as IShellModel):
-		service = cast(SourceViewService,ServiceManager.GetService(typeof(SourceViewService)))
-		buf = SourceBuffer(service.GetLanguageFromMimeType(model.MimeType))
+		_parserService = cast(IParserService, ServiceManager.GetService (typeof (DefaultParserService)))
 
+		manager = SourceLanguagesManager()
+		buf = SourceBuffer(manager.GetLanguageFromMimeType(model.MimeType))
+
 		// This freaks out booc for some reason.
 		//super(buf, Highlight: true)
 		super(buf)
@@ -82,6 +88,15 @@
 		self.WrapMode = Gtk.WrapMode.Word
 		self.ModifyFont(Model.Properties.Font)
 
+		# FIXME: Put the project file somewhere other than /tmp
+		monodevelopConfigDir = System.IO.Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.Personal), &quot;.config/MonoDevelop/&quot;)
+		shellProjectFile = System.IO.Path.Combine (monodevelopConfigDir, &quot;${Model.LanguageName}-shell-project.mdp&quot;)
+		_fakeFileName = System.IO.Path.Combine (monodevelopConfigDir, &quot;shell-dummy-file.${Model.MimeTypeExtension}&quot;)
+		_fileInfo  = System.IO.File.Create (_fakeFileName)
+		_fakeProject = DotNetProject(Model.LanguageName, Name: &quot;___ShellProject&quot;, FileName: shellProjectFile)
+
+		_parserService.LoadProjectDatabase(_fakeProject)
+
 		Model.Properties.InternalProperties.PropertyChanged += OnPropertyChanged
 		Model.RegisterOutputHandler (HandleOutput)
 
@@ -155,6 +170,10 @@
 			for line as string in output:
 				processOutput (line )
 		prompt (true)
+		for assembly in Model.References:
+			_fakeProject.AddReference(assembly)
+
+		GLib.Idle.Add( { _parserService.ParseFile (_fakeFileName, _scriptLines) } )
 		return false
 			
 	override def Dispose():
@@ -208,6 +227,9 @@
 		_reset.Show()
 	
 	override def OnKeyPressEvent (ev as Gdk.EventKey):
+		if CompletionListWindow.ProcessKeyEvent (ev):
+			return true
+		
 		// Short circuit to avoid getting moved back to the input line
 		// when paging up and down in the shell output
 		if ev.Key in Gdk.Key.Page_Up, Gdk.Key.Page_Down:
@@ -219,6 +241,9 @@
 			Buffer.MoveMark (Buffer.SelectionBound, InputLineEnd)
 			Buffer.MoveMark (Buffer.InsertMark, InputLineEnd)
 		
+		if (ev.State == Gdk.ModifierType.ControlMask) and ev.Key == Gdk.Key.space:
+			TriggerCodeCompletion ()
+
 		if ev.Key == Gdk.Key.Return:
 			if _inBlock:
 				if InputLine == &quot;&quot;:
@@ -237,7 +262,7 @@
 			else:
 				// Special case for start of new code block
 				if InputLine.Trim()[-1:] == &quot;:&quot;:
-					_inBlock = true;
+					_inBlock = true
 					_blockText = InputLine
 					prompt (true, true)
 					if _auto_indent:
@@ -268,7 +293,7 @@
 		elif ev.Key == Gdk.Key.Up:
 			if (not _inBlock) and _commandHistoryPast.Count &gt; 0:
 				if _commandHistoryFuture.Count == 0:
-					_commandHistoryFuture.Push(InputLine);
+					_commandHistoryFuture.Push(InputLine)
 				else:
 					if _commandHistoryPast.Count == 1:
 						return true
@@ -297,6 +322,12 @@
 				Buffer.MoveMark (Buffer.SelectionBound, InputLineBegin)
 			return true
 
+		elif ev.Key == Gdk.Key.period:
+			ret = super.OnKeyPressEvent(ev)
+			prepareCompletionDetails (Buffer.GetIterAtMark (Buffer.InsertMark))
+			CompletionListWindow.ShowWindow(char('.'), CodeCompletionDataProvider (true), self, _fakeProject, _fakeFileName)
+			return ret
+
 		// Short circuit to avoid getting moved back to the input line
 		// when paging up and down in the shell output
 		elif ev.Key in Gdk.Key.Page_Up, Gdk.Key.Page_Down:
@@ -304,8 +335,41 @@
 		
 		return super (ev)
 	
+	protected override def OnFocusOutEvent (e as EventFocus):
+		CompletionListWindow.HideWindow ()
+		return super.OnFocusOutEvent(e)
+	
 	#endregion
 
+	private def TriggerCodeCompletion():
+		iter = Cursor
+		triggerChar = char('\0')
+		triggerIter = TextIter.Zero
+		if (iter.Char != null and  iter.Char.Length &gt; 0):
+			if iter.Char[0] in (char(' '), char('\t'), char('.'), char('('), char('[')):
+				triggerIter = iter
+				triggerChar = iter.Char[0]
+
+		while iter.LineOffset &gt; 0 and triggerIter.Equals (TextIter.Zero):
+			if (iter.Char == null or iter.Char.Length == 0):
+				iter.BackwardChar ()
+				continue
+
+			if iter.Char[0] in (char(' '), char('\t'), char('.'), char('('), char('[')):
+				triggerIter = iter
+				triggerChar = iter.Char[0]
+				break
+
+			iter.BackwardChar ()
+		
+		if (triggerIter.Equals (TextIter.Zero)):
+			return
+
+		triggerIter.ForwardChar ()
+		
+		prepareCompletionDetails (triggerIter)
+		CompletionListWindow.ShowWindow (triggerChar, CodeCompletionDataProvider (true), self, _fakeProject, _fakeFileName)
+
 	// Mark to find the beginning of our next input line
 	private _endOfLastProcessing as TextMark
 
@@ -403,3 +467,76 @@
 		return
 
 	#endregion
+
+	private def prepareCompletionDetails (triggerIter as TextIter):
+		rect = GetIterLocation (Buffer.GetIterAtMark (Buffer.InsertMark))
+
+		wx as int
+		wy as int
+		BufferToWindowCoords (Gtk.TextWindowType.Widget, rect.X, rect.Y + rect.Height, wx, wy)
+
+		tx as int
+		ty as int
+		GdkWindow.GetOrigin (tx, ty)
+
+		self.completionX = tx + wx
+		self.completionY = ty + wy
+		self.textHeight = rect.Height
+		self.triggerMark = Buffer.CreateMark (null, triggerIter, true)
+
+	#region ICompletionWidget
+
+	[Getter(ICompletionWidget.TriggerXCoord)]
+	private completionX
+
+	[Getter(ICompletionWidget.TriggerYCoord)]
+	private completionY
+	
+	[Getter(ICompletionWidget.TriggerTextHeight)]
+	private textHeight as int
+	
+	ICompletionWidget.Text:
+		get:
+			return Buffer.Text
+	
+	ICompletionWidget.TextLength:
+		get:
+			return Buffer.EndIter.Offset
+	
+	def ICompletionWidget.GetChar (offset as int) as System.Char:
+		return Buffer.GetIterAtLine (offset).Char[0]
+	
+	def ICompletionWidget.GetText (startOffset as int, endOffset as int) as string:
+		return Buffer.GetText(Buffer.GetIterAtOffset (startOffset), Buffer.GetIterAtOffset(endOffset), true)
+	
+	ICompletionWidget.CompletionText:
+		get:
+			return Buffer.GetText (Buffer.GetIterAtMark (triggerMark), Buffer.GetIterAtMark (Buffer.InsertMark), false)
+	
+	def ICompletionWidget.SetCompletionText (partial_word as string, complete_word as string):
+		offsetIter = Buffer.GetIterAtMark(triggerMark)
+		endIter = Buffer.GetIterAtOffset (offsetIter.Offset + partial_word.Length)
+		Buffer.MoveMark (Buffer.InsertMark, offsetIter)
+		Buffer.Delete (offsetIter, endIter)
+		Buffer.InsertAtCursor (complete_word)
+	
+	def ICompletionWidget.InsertAtCursor (text as string):
+		Buffer.InsertAtCursor (text)
+	
+	private triggerMark as TextMark
+	ICompletionWidget.TriggerOffset:
+		get:
+			return Buffer.GetIterAtMark (triggerMark).Offset
+
+	ICompletionWidget.TriggerLine:
+		get:
+			return Buffer.GetIterAtMark (triggerMark).Line
+
+	ICompletionWidget.TriggerLineOffset:
+		get:
+			return Buffer.GetIterAtMark (triggerMark).LineOffset
+	
+	ICompletionWidget.GtkStyle:
+		get:
+			return self.Style.Copy();
+	#endregion

Modified: trunk/MonoDevelop/Extras/BooBinding/Makefile.am
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Makefile.am	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/Makefile.am	2005-07-20 16:12:50 UTC (rev 2677)
@@ -7,7 +7,6 @@
 	-r:System.Xml \
 	-r:System.Runtime.Remoting \
 	-r:$(top_builddir)/build/bin/MonoDevelop.Core.dll \
-	-r:$(top_builddir)/build/bin/MonoDevelop.SourceEditor.dll \
 	-r:$(top_builddir)/build/bin/MonoDevelop.Base.dll \
 	-r:$(top_builddir)/build/bin/ICSharpCode.SharpRefactory.dll \
 	-r:$(top_builddir)/build/bin/MonoDevelop.Gui.Widgets.dll \

Modified: trunk/MonoDevelop/Extras/BooBinding/Parser/BooParser.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/BooParser.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/BooParser.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -67,8 +67,8 @@
 	def Parse(fileName as string, fileContent as string) as ICompilationUnitBase:
 		//print &quot;Parse ${fileName} with content&quot;
 		
-		cr = '\r'[0]
-		ln = '\n'[0]
+		cr = char('\r')
+		ln = char('\n')
 		linecount = 1
 		for c as Char in fileContent:
 			linecount += 1 if c == ln
@@ -87,15 +87,20 @@
 		compiler = BooCompiler()
 		compiler.Parameters.Input.Add(StringInput(fileName, fileContent))
 		project as Project
-		for entry as Project in MonoDevelop.Services.Runtime.ProjectService.CurrentOpenCombine.GetAllProjects():
-			if entry.IsFileInProject(fileName):
-				project = entry
-				
-		return Parse(fileName, lineLength, compiler, project)
+		if MonoDevelop.Services.Runtime.ProjectService.CurrentOpenCombine is not null:
+			for entry as Project in MonoDevelop.Services.Runtime.ProjectService.CurrentOpenCombine.GetAllProjects():
+				if entry.IsFileInProject(fileName):
+					project = entry
+		
+		if project is not null and project.ProjectReferences is not null:
+			for projectRef as ProjectReference in project.ProjectReferences:
+				compiler.Parameters.References.Add(System.Reflection.Assembly.LoadFile(projectRef.GetReferencedFileName()))
+		
+		return Parse(fileName, lineLength, compiler)
 	
-	private def Parse(fileName as string, lineLength as (int), compiler as BooCompiler, project as Project):
+	private def Parse(fileName as string, lineLength as (int), compiler as BooCompiler):
 		compiler.Parameters.OutputWriter = StringWriter()
-		compiler.Parameters.TraceSwitch.Level = TraceLevel.Warning;
+		compiler.Parameters.TraceSwitch.Level = TraceLevel.Warning
 		
 		compilePipe = Compile()
 		parsingStep as Boo.Lang.Parser.BooParsingStep = compilePipe[0]
@@ -117,8 +122,6 @@
 		
 		compilePipe.BreakOnErrors = false
 		compiler.Parameters.Pipeline = compilePipe
-		for projectRef as ProjectReference in project.ProjectReferences:
-			compiler.Parameters.References.Add(System.Reflection.Assembly.LoadFile(projectRef.GetReferencedFileName()))
 		
 		try:
 			compiler.Run()

Modified: trunk/MonoDevelop/Extras/BooBinding/Parser/Resolver.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Parser/Resolver.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/Parser/Resolver.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -256,9 +256,8 @@
 			return false
 		_callingClass = GetInnermostClass(cu)
 		if _callingClass == null:
-			return false if cu.Classes.Count == 0
-			_callingClass = cu.Classes[cu.Classes.Count - 1]
-			if _callingClass.Region != null:
+			_callingClass = cu.Classes[cu.Classes.Count - 1] if cu.Classes.Count &gt; 0
+			if _callingClass != null and _callingClass.Region != null:
 				return false if _callingClass.Region.BeginLine &gt; caretLine
 
 		if _project == null:
@@ -341,10 +340,13 @@
 //			print(&quot;IsAccessible&quot;)
 			return true
 
-		if ((member.Modifiers &amp; ModifierEnum.Protected) == ModifierEnum.Protected and IsClassInInheritanceTree(c, _callingClass)):
-//			print(&quot;IsAccessible&quot;)
-			return true
+		if (member.Modifiers &amp; ModifierEnum.Protected) == ModifierEnum.Protected:
+			if _callingClass is not null and  IsClassInInheritanceTree(c, _callingClass):
+				return true
+			else:
+				return false
 
+		return false if _callingClass is null
 		return c.FullyQualifiedName == _callingClass.FullyQualifiedName
 
 	/// &lt;remarks&gt;

Modified: trunk/MonoDevelop/Extras/BooBinding/Properties/ShellProperties.boo
===================================================================
--- trunk/MonoDevelop/Extras/BooBinding/Properties/ShellProperties.boo	2005-07-20 11:06:26 UTC (rev 2676)
+++ trunk/MonoDevelop/Extras/BooBinding/Properties/ShellProperties.boo	2005-07-20 16:12:50 UTC (rev 2677)
@@ -17,7 +17,7 @@
 	private propertyService = cast (PropertyService, ServiceManager.GetService (typeof(PropertyService)))
 	private properties = cast (IProperties, propertyService.GetProperty (PropertyName, DefaultProperties()))
 
-	public virtual PropertyName as string:
+	public abstract PropertyName as string:
 		get:
 			pass
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002276.html">[Monodevelop-patches-list] r2676 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Gui/Pads/ProjectPad
</A></li>
	<LI>Next message: <A HREF="002278.html">[Monodevelop-patches-list] r2678 - in	trunk/MonoDevelop/Extras/BooBinding: . Gui/OptionPanels
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2277">[ date ]</a>
              <a href="thread.html#2277">[ thread ]</a>
              <a href="subject.html#2277">[ subject ]</a>
              <a href="author.html#2277">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
