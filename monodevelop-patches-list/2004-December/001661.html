<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2057 - in trunk/MonoDevelop/Core/src/Main/Base: . Services/DispatchService
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2057%20-%20in%20trunk/MonoDevelop/Core/src/Main/Base%3A%20.%20Services/DispatchService&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001660.html">
   <LINK REL="Next"  HREF="001662.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2057 - in trunk/MonoDevelop/Core/src/Main/Base: . Services/DispatchService</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2057%20-%20in%20trunk/MonoDevelop/Core/src/Main/Base%3A%20.%20Services/DispatchService&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2057 - in trunk/MonoDevelop/Core/src/Main/Base: . Services/DispatchService">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Mon Dec  6 15:40:46 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001660.html">[Monodevelop-patches-list] r2056 - in trunk/MonoDevelop/Core/src/Main/Base: . Commands Commands/ProjectBrowserCommands Internal/Codons Internal/Codons/LanguageBinding Internal/Codons/MenuItems Internal/Conditions Internal/ExternalTool Internal/Parser/ReflectionLayer Internal/Project/Combine Internal/Project/Project Internal/Project/Project/Deployment Internal/Templates Internal/Templates/ProjectTemplates Services Services/AmbienceService Services/MenuService Services/ParserService Services/Project Services/StatusBar Services/Tasks Services/Toolbar
</A></li>
        <LI>Next message: <A HREF="001662.html">[Monodevelop-patches-list] r2058 - in trunk/MonoDevelop/Core/src/Main/Base: . Gui/Pads Gui/Pads/ClassScout Gui/Pads/ProjectBrowser Gui/Workbench Services Services/DispatchService Services/Project Services/Tasks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1661">[ date ]</a>
              <a href="thread.html#1661">[ thread ]</a>
              <a href="subject.html#1661">[ subject ]</a>
              <a href="author.html#1661">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lluis
Date: 2004-12-06 15:40:45 -0500 (Mon, 06 Dec 2004)
New Revision: 2057

Added:
   trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/AsyncDispatchAttribute.cs
   trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/FreeDispatchAttribute.cs
   trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/GuiSyncContext.cs
   trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/GuiSyncObject.cs
   trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncContext.cs
   trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncContextAttribute.cs
   trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncObject.cs
Modified:
   trunk/MonoDevelop/Core/src/Main/Base/ChangeLog
   trunk/MonoDevelop/Core/src/Main/Base/Makefile.am
   trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/DispatchService.cs
Log:
	* Services/DispatchService/DispatchService.cs: Added support for
	synchronous dispatch to the gui thread.
	* Services/DispatchService/AsyncDispatchAttribute.cs:
	* Services/DispatchService/SyncContext.cs:
	* Services/DispatchService/SyncObject.cs:
	* Services/DispatchService/FreeDispatchAttribute.cs:
	* Services/DispatchService/SyncContextAttribute.cs:
	* Services/DispatchService/GuiSyncContext.cs:
	* Services/DispatchService/GuiSyncObject.cs: New classes that support
	some new dispatch features.

2004-12-06  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;



Modified: trunk/MonoDevelop/Core/src/Main/Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/ChangeLog	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/ChangeLog	2004-12-06 20:40:45 UTC (rev 2057)
@@ -1,5 +1,18 @@
 2004-12-06  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;
 
+	* Services/DispatchService/DispatchService.cs: Added support for
+	synchronous dispatch to the gui thread.
+	* Services/DispatchService/AsyncDispatchAttribute.cs:
+	* Services/DispatchService/SyncContext.cs:
+	* Services/DispatchService/SyncObject.cs:
+	* Services/DispatchService/FreeDispatchAttribute.cs:
+	* Services/DispatchService/SyncContextAttribute.cs:
+	* Services/DispatchService/GuiSyncContext.cs:
+	* Services/DispatchService/GuiSyncObject.cs: New classes that support
+	some new dispatch features.
+
+2004-12-06  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;
+
 	* *.cs: Removed remaining calls to ServiceManager.GetService.
 
 2004-12-06  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;

Modified: trunk/MonoDevelop/Core/src/Main/Base/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Makefile.am	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Makefile.am	2004-12-06 20:40:45 UTC (rev 2057)
@@ -209,7 +209,14 @@
 Services/MonodocService.cs \
 Services/IDebuggerService.cs \
 Services/SystemAssemblyService.cs \
+Services/DispatchService/AsyncDispatchAttribute.cs \
 Services/DispatchService/DispatchService.cs \
+Services/DispatchService/FreeDispatchAttribute.cs \
+Services/DispatchService/GuiSyncContext.cs \
+Services/DispatchService/GuiSyncObject.cs \
+Services/DispatchService/SyncContext.cs \
+Services/DispatchService/SyncContextAttribute.cs \
+Services/DispatchService/SyncObject.cs \
 Services/Runtime.cs \
 Internal/Undo/IUndoableOperation.cs \
 Internal/Undo/UndoStack.cs \

Added: trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/AsyncDispatchAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/AsyncDispatchAttribute.cs	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/AsyncDispatchAttribute.cs	2004-12-06 20:40:45 UTC (rev 2057)
@@ -0,0 +1,15 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	public class AsyncDispatchAttribute: Attribute
+	{
+	}
+}

Modified: trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/DispatchService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/DispatchService.cs	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/DispatchService.cs	2004-12-06 20:40:45 UTC (rev 2057)
@@ -13,33 +13,69 @@
 		ArrayList arrGuiQueue;
 		Thread thrBackground;
 		uint iIdle = 0;
+		GLib.IdleHandler handler;
+		static int guiThreadId;
+		static GuiSyncContext guiContext;
+		const string errormsg = &quot;An exception was thrown while dispatching a method call in the UI thread.&quot;;
+		internal static bool DispatchDebug;
 
 		public override void InitializeService ()
 		{
+			guiContext = new GuiSyncContext ();
+			SyncContext.SetContext (guiContext);
+			
+			guiThreadId = AppDomain.GetCurrentThreadId();
+			
+			handler = new GLib.IdleHandler (guiDispatcher);
 			arrBackgroundQueue = new ArrayList ();
 			arrGuiQueue = new ArrayList ();
 			thrBackground = new Thread (new ThreadStart (backgroundDispatcher));
 			thrBackground.IsBackground = true;
 			thrBackground.Priority = ThreadPriority.Lowest;
 			thrBackground.Start ();
+			DispatchDebug = Environment.GetEnvironmentVariable (&quot;MONODEVELOP_DISPATCH_DEBUG&quot;) != null;
 		}
 
 		public void GuiDispatch (MessageHandler cb)
 		{
-			arrGuiQueue.Add (new GenericMessageContainer (cb));
+			arrGuiQueue.Add (new GenericMessageContainer (cb, false));
 			UpdateIdle ();
 		}
 
 		public void GuiDispatch (StatefulMessageHandler cb, object state)
 		{
-			arrGuiQueue.Add (new StatefulMessageContainer (cb, state));
+			arrGuiQueue.Add (new StatefulMessageContainer (cb, state, false));
 			UpdateIdle ();
 		}
 
+		public void GuiSyncDispatch (MessageHandler cb)
+		{
+			GenericMessageContainer mc = new GenericMessageContainer (cb, true);
+			lock (mc) {
+				arrGuiQueue.Add (mc);
+				UpdateIdle ();
+				Monitor.Wait (mc);
+			}
+			if (mc.Exception != null)
+				throw new Exception (errormsg, mc.Exception);
+		}
+		
+		public void GuiSyncDispatch (StatefulMessageHandler cb, object state)
+		{
+			StatefulMessageContainer mc = new StatefulMessageContainer (cb, state, true);
+			lock (mc) {
+				arrGuiQueue.Add (mc);
+				UpdateIdle ();
+				Monitor.Wait (mc);
+			}
+			if (mc.Exception != null)
+				throw new Exception (errormsg, mc.Exception);
+		}
+
 		void UpdateIdle ()
 		{
 			if (iIdle == 0) {
-				iIdle = GLib.Idle.Add (new GLib.IdleHandler (guiDispatcher));
+				iIdle = GLib.Idle.Add (handler);
 				/* This code is required because for some
 				 * reason the idle handler is run once
 				 * before being set, so you get a idle
@@ -50,15 +86,31 @@
 					iIdle = 0;
 			}
 		}
-
+		
+		public static bool IsGuiThread
+		{
+			get { return guiThreadId == AppDomain.GetCurrentThreadId(); }
+		}
+		
+		public static void AssertGuiThread ()
+		{
+			if (guiThreadId != AppDomain.GetCurrentThreadId())
+				throw new InvalidOperationException (&quot;This method can only be called in the GUI thread&quot;);
+		}
+		
+		public static Delegate GuiDispatch (Delegate del)
+		{
+			return guiContext.CreateSynchronizedDelegate (del);
+		}
+		
 		public void BackgroundDispatch (MessageHandler cb)
 		{
-			arrBackgroundQueue.Add (new GenericMessageContainer (cb));
+			arrBackgroundQueue.Add (new GenericMessageContainer (cb, false));
 		}
 
 		public void BackgroundDispatch (StatefulMessageHandler cb, object state)
 		{
-			arrBackgroundQueue.Add (new StatefulMessageContainer (cb, state));
+			arrBackgroundQueue.Add (new StatefulMessageContainer (cb, state, false));
 			//thrBackground.Resume ();
 		}
 
@@ -73,8 +125,14 @@
 				msg = (GenericMessageContainer)arrGuiQueue[0];
 				arrGuiQueue.RemoveAt (0);
 			}
-			if (msg != null)
+			if (msg != null) {
 				msg.Run ();
+				if (msg.IsSynchronous)
+					lock (msg) Monitor.PulseAll (msg);
+				else if (msg.Exception != null)
+					HandlerError (msg);
+			}
+			
 			if (arrGuiQueue.Count == 0) {
 				iIdle = 0;
 				return false;
@@ -95,10 +153,25 @@
 					msg = (GenericMessageContainer)arrBackgroundQueue[0];
 					arrBackgroundQueue.RemoveAt (0);
 				}
-				if (msg != null)
+				if (msg != null) {
 					msg.Run ();
+					if (msg.Exception != null)
+						HandlerError (msg);
+				}
 			}
 		}
+		
+		private void HandlerError (GenericMessageContainer msg)
+		{
+			Console.WriteLine (errormsg);
+			Console.WriteLine (msg.Exception);
+			if (msg.CallerStack != null) {
+				Console.WriteLine (&quot;\nCaller stack:&quot;);
+				Console.WriteLine (msg.CallerStack);
+			}
+			else
+				Console.WriteLine (&quot;\n\nCaller stack not available. Define the environment variable MONODEVELOP_DISPATCH_DEBUG to enable caller stack capture.&quot;);
+		}
 	}
 
 	public delegate void MessageHandler ();
@@ -107,18 +180,43 @@
 	class GenericMessageContainer
 	{
 		MessageHandler callback;
+		protected Exception ex;
+		protected bool isSynchronous;
+		protected string callerStack;
 
 		protected GenericMessageContainer () { }
 
-		public GenericMessageContainer (MessageHandler cb)
+		public GenericMessageContainer (MessageHandler cb, bool isSynchronous)
 		{
 			callback = cb;
+			this.isSynchronous = isSynchronous;
+			if (DispatchService.DispatchDebug) callerStack = Environment.StackTrace;
 		}
 
 		public virtual void Run ()
 		{
-			callback ();
+			try {
+				callback ();
+			}
+			catch (Exception e) {
+				ex = e;
+			}
 		}
+		
+		public Exception Exception
+		{
+			get { return ex; }
+		}
+		
+		public bool IsSynchronous
+		{
+			get { return isSynchronous; }
+		}
+		
+		public string CallerStack
+		{
+			get { return callerStack; }
+		}
 	}
 
 	class StatefulMessageContainer : GenericMessageContainer
@@ -126,15 +224,23 @@
 		object data;
 		StatefulMessageHandler callback;
 
-		public StatefulMessageContainer (StatefulMessageHandler cb, object state)
+		public StatefulMessageContainer (StatefulMessageHandler cb, object state, bool isSynchronous)
 		{
 			data = state;
 			callback = cb;
+			this.isSynchronous = isSynchronous;
+			if (DispatchService.DispatchDebug) callerStack = Environment.StackTrace;
 		}
 		
 		public override void Run ()
 		{
-			callback (data);
+			try {
+				callback (data);
+			}
+			catch (Exception e) {
+				ex = e;
+			}
 		}
 	}
+
 }

Added: trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/FreeDispatchAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/FreeDispatchAttribute.cs	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/FreeDispatchAttribute.cs	2004-12-06 20:40:45 UTC (rev 2057)
@@ -0,0 +1,15 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	public class FreeDispatchAttribute: Attribute
+	{
+	}
+}

Added: trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/GuiSyncContext.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/GuiSyncContext.cs	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/GuiSyncContext.cs	2004-12-06 20:40:45 UTC (rev 2057)
@@ -0,0 +1,36 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	public class GuiSyncContext: SyncContext
+	{
+		DispatchService dispatcher;
+		
+		public override void Dispatch (StatefulMessageHandler cb, object ob)
+		{
+			if (dispatcher == null)
+				dispatcher = Runtime.DispatchService;
+				
+			if (DispatchService.IsGuiThread)
+				cb (ob);
+			else {
+				dispatcher.GuiSyncDispatch (cb, ob);
+			}
+		}
+		
+		public override void AsyncDispatch (StatefulMessageHandler cb, object ob)
+		{
+			if (dispatcher == null)
+				dispatcher = Runtime.DispatchService;
+				
+			dispatcher.GuiDispatch (cb, ob);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/GuiSyncObject.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/GuiSyncObject.cs	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/GuiSyncObject.cs	2004-12-06 20:40:45 UTC (rev 2057)
@@ -0,0 +1,16 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	[SyncContext (typeof(GuiSyncContext))]
+	public class GuiSyncObject: SyncObject
+	{
+	}
+}

Added: trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncContext.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncContext.cs	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncContext.cs	2004-12-06 20:40:45 UTC (rev 2057)
@@ -0,0 +1,188 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+
+using System;
+using System.Collections;
+using System.Reflection;
+using System.Reflection.Emit;
+using System.Runtime.Remoting.Contexts;
+using System.Runtime.Remoting.Messaging;
+using System.Runtime.Remoting.Activation;
+
+namespace MonoDevelop.Services
+{
+	public class SyncContext
+	{
+		[ThreadStatic]
+		static SyncContext context;
+		
+		static Hashtable delegateFactories = new Hashtable ();
+		static ModuleBuilder module;
+		static AssemblyBuilder asmBuilder;
+	
+		public static void SetContext (SyncContext ctx)
+		{
+			context = ctx;
+		}
+		
+		public static SyncContext GetContext ()
+		{
+			return context;
+		}
+		
+		public virtual void Dispatch (StatefulMessageHandler cb, object ob)
+		{
+			cb (ob);
+		}
+		
+		public virtual void AsyncDispatch (StatefulMessageHandler cb, object ob)
+		{
+			cb.BeginInvoke (ob, null, null);
+		}
+		
+		public Delegate CreateSynchronizedDelegate (Delegate del)
+		{
+			lock (delegateFactories.SyncRoot)
+			{
+				Type delType = del.GetType();
+				IDelegateFactory factory = delegateFactories [delType] as IDelegateFactory;
+				if (factory == null)
+				{
+					Type t = GetDelegateFactoryType (delType);
+					factory = Activator.CreateInstance (t) as IDelegateFactory;
+					delegateFactories [delType] = factory;
+				}
+				return factory.Create (del, this);
+			}
+		}
+			
+		Type GetDelegateFactoryType (Type delegateType)
+		{
+			MethodInfo invoke = delegateType.GetMethod (&quot;Invoke&quot;);
+			ModuleBuilder module = GetModuleBuilder ();
+			TypeBuilder typeBuilder = module.DefineType (&quot;__&quot; + delegateType.Name + &quot;_DelegateFactory&quot;, TypeAttributes.Public, typeof(object), new Type[] {typeof(IDelegateFactory)});
+			
+			// Context and target delegate field
+			
+			FieldBuilder contextField = typeBuilder.DefineField (&quot;context&quot;, typeof(SyncContext), FieldAttributes.Public);
+			FieldBuilder targetField = typeBuilder.DefineField (&quot;target&quot;, delegateType, FieldAttributes.Public);
+			
+			// Parameters
+			
+			ParameterInfo[] pars = invoke.GetParameters ();
+			FieldBuilder[] paramFields = new FieldBuilder [pars.Length];
+			Type[] paramTypes = new Type[pars.Length];
+			for (int n=0; n&lt;pars.Length; n++)
+			{
+				ParameterInfo pi = pars [n];
+				paramFields [n] = typeBuilder.DefineField (&quot;p&quot; + n, pi.ParameterType, FieldAttributes.Public);
+				paramTypes [n] = pi.ParameterType;
+			}
+			
+			// Return value
+			
+			FieldBuilder returnField = null;
+			if (invoke.ReturnType != typeof(void))
+				returnField = typeBuilder.DefineField (&quot;ret&quot;, invoke.ReturnType, FieldAttributes.Public);
+			
+			// Constructor
+			
+			ConstructorBuilder ctor = typeBuilder.DefineConstructor (MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
+			ConstructorInfo baseCtor = typeof(object).GetConstructor (Type.EmptyTypes);
+			ILGenerator gen = ctor.GetILGenerator();
+			gen.Emit (OpCodes.Ldarg_0);
+			gen.Emit (OpCodes.Call, baseCtor);
+			gen.Emit (OpCodes.Ret);
+			
+			// Dispatch method
+			
+			MethodBuilder methodDispatch = typeBuilder.DefineMethod (&quot;Dispatch&quot;, MethodAttributes.Public, typeof(void), new Type[] {typeof(object)});
+			gen = methodDispatch.GetILGenerator();
+			if (returnField != null)
+				gen.Emit (OpCodes.Ldarg_0);
+			gen.Emit (OpCodes.Ldarg_0);
+			gen.Emit (OpCodes.Ldfld, targetField);
+			
+			for (int n=0; n&lt;pars.Length; n++)
+			{
+				gen.Emit (OpCodes.Ldarg_0);
+				gen.Emit (OpCodes.Ldfld, paramFields[n]);
+			}
+			gen.Emit (OpCodes.Callvirt, invoke);
+			
+			if (returnField != null)
+				gen.Emit (OpCodes.Stfld, returnField);
+	
+			gen.Emit (OpCodes.Ret);
+			
+			// ProxyCall method
+			
+			MethodBuilder methodProxyCall = typeBuilder.DefineMethod (&quot;ProxyCall&quot;, MethodAttributes.Public, invoke.ReturnType, paramTypes);
+			gen = methodProxyCall.GetILGenerator();
+			for (int n=0; n&lt;paramFields.Length; n++) {
+				gen.Emit (OpCodes.Ldarg_0);
+				gen.Emit (OpCodes.Ldarg, n+1);
+				gen.Emit (OpCodes.Stfld, paramFields[n]);
+			}
+			gen.Emit (OpCodes.Ldarg_0);
+			gen.Emit (OpCodes.Ldfld, contextField);
+			gen.Emit (OpCodes.Ldarg_0);
+			gen.Emit (OpCodes.Ldftn, methodDispatch);
+			gen.Emit (OpCodes.Newobj, typeof(StatefulMessageHandler).GetConstructor (new Type[] {typeof(object), typeof(IntPtr)} ));
+			gen.Emit (OpCodes.Ldnull);
+			gen.Emit (OpCodes.Callvirt, typeof(SyncContext).GetMethod (&quot;Dispatch&quot;));
+			
+			if (returnField != null) {
+				gen.Emit (OpCodes.Ldarg_0);
+				gen.Emit (OpCodes.Ldfld, returnField);
+			}
+			gen.Emit (OpCodes.Ret);
+			
+			// Create method
+			
+			MethodBuilder methodCreate = typeBuilder.DefineMethod (&quot;Create&quot;, MethodAttributes.Public, typeof(Delegate), new Type[] {typeof(Delegate), typeof(SyncContext)});
+			gen = methodCreate.GetILGenerator();
+			LocalBuilder vthis = gen.DeclareLocal (typeBuilder);
+			gen.Emit (OpCodes.Newobj, ctor);
+			gen.Emit (OpCodes.Stloc, vthis);
+			gen.Emit (OpCodes.Ldloc, vthis);
+			gen.Emit (OpCodes.Ldarg_1);
+			gen.Emit (OpCodes.Castclass, delegateType);
+			gen.Emit (OpCodes.Stfld, targetField);
+			gen.Emit (OpCodes.Ldloc, vthis);
+			gen.Emit (OpCodes.Ldarg_2);
+			gen.Emit (OpCodes.Stfld, contextField);
+			gen.Emit (OpCodes.Ldloc, vthis);
+			gen.Emit (OpCodes.Ldftn, methodProxyCall);
+			gen.Emit (OpCodes.Newobj, delegateType.GetConstructor (new Type[] {typeof(object), typeof(IntPtr)} ));
+			gen.Emit (OpCodes.Ret);
+			typeBuilder.DefineMethodOverride (methodCreate, typeof(IDelegateFactory).GetMethod (&quot;Create&quot;));
+			
+			return typeBuilder.CreateType ();
+		}
+		
+		static ModuleBuilder GetModuleBuilder ()
+		{
+			if (module == null)
+			{
+				AppDomain myDomain = System.Threading.Thread.GetDomain();
+				AssemblyName myAsmName = new AssemblyName();
+				myAsmName.Name = &quot;MonoDevelop.DelegateGenerator.GeneratedAssembly&quot;;
+	
+				asmBuilder = myDomain.DefineDynamicAssembly (myAsmName, AssemblyBuilderAccess.RunAndSave);
+				module = asmBuilder.DefineDynamicModule (&quot;MonoDevelop.DelegateGenerator.GeneratedAssembly&quot;, &quot;MonoDevelop.DelegateGenerator.GeneratedAssembly.dll&quot;);
+			}
+			return module;
+		}
+	}
+	
+	public interface IDelegateFactory
+	{
+		Delegate Create (Delegate del, SyncContext ctx);
+	}
+}

Added: trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncContextAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncContextAttribute.cs	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncContextAttribute.cs	2004-12-06 20:40:45 UTC (rev 2057)
@@ -0,0 +1,140 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+
+using System;
+using System.Collections;
+using System.Reflection;
+using System.Reflection.Emit;
+using System.Runtime.Remoting.Contexts;
+using System.Runtime.Remoting.Messaging;
+using System.Runtime.Remoting.Activation;
+
+namespace MonoDevelop.Services
+{
+	public class SyncContextAttribute: ContextAttribute, IContributeObjectSink
+	{
+		Type contextType;
+		SyncContext syncContext;
+		
+		public SyncContextAttribute (Type contextType): base (&quot;syncContextProperty&quot;)
+		{
+			this.contextType = contextType;
+		}
+		
+		public override bool IsContextOK (Context ctx, IConstructionCallMessage msg)
+		{
+			SyncContext sctx = SyncContext.GetContext ();
+			if (sctx == null || (sctx.GetType() != contextType)) {
+				syncContext = (SyncContext) Activator.CreateInstance (contextType);
+				return false;
+			}
+			else {
+				syncContext = sctx;
+				return true;
+			}
+		}
+		
+		public IMessageSink GetObjectSink (MarshalByRefObject ob, IMessageSink nextSink)
+		{
+			return new SyncContextDispatchSink (nextSink, syncContext);
+		}
+		
+		public Type ConextType
+		{
+			get { return contextType; }
+		}
+	}
+	
+	internal class SyncContextDispatchSink: IMessageSink
+	{
+		IMessageSink nextSink;
+		SyncContext syncContext;
+		
+		class MsgData
+		{
+			public IMessage InMessage;
+			public IMessage OutMessage;
+			public IMessageSink ReplySink;
+		}
+		
+		public SyncContextDispatchSink (IMessageSink nextSink, SyncContext syncContext)
+		{
+			this.nextSink = nextSink;
+			this.syncContext = syncContext;
+		}
+		
+        public IMessage SyncProcessMessage (IMessage msg)
+		{
+			if (syncContext == null) return nextSink.SyncProcessMessage (msg);
+			
+			IMethodMessage mm = (IMethodMessage)msg;
+			if (mm.MethodBase.IsDefined (typeof(FreeDispatchAttribute), true))
+				return nextSink.SyncProcessMessage (msg);
+
+			if (mm.MethodBase.IsDefined (typeof(AsyncDispatchAttribute), true)) {
+				AsyncProcessMessage (msg, DummySink.Instance);
+				return new ReturnMessage (null, null, 0, null, (IMethodCallMessage)mm);
+			}
+
+			MsgData md = new MsgData ();
+			md.InMessage = msg;
+			syncContext.Dispatch (new StatefulMessageHandler (DispatchMessage), md);
+			return md.OutMessage;
+		}
+		
+		void DispatchMessage (object data)
+		{
+			MsgData md = (MsgData)data;
+			md.OutMessage = nextSink.SyncProcessMessage (md.InMessage);
+		}
+		
+        public IMessageCtrl AsyncProcessMessage (IMessage msg, IMessageSink replySink)
+		{
+			if (syncContext == null) return nextSink.AsyncProcessMessage (msg, replySink);
+
+			MsgData md = new MsgData ();
+			md.InMessage = msg;
+			md.ReplySink = replySink;
+			syncContext.AsyncDispatch (new StatefulMessageHandler (AsyncDispatchMessage), md);
+			return null;
+		}
+		
+		void AsyncDispatchMessage (object data)
+		{
+			MsgData md = (MsgData)data;
+			md.ReplySink.SyncProcessMessage (nextSink.SyncProcessMessage (md.InMessage));
+		}
+		
+        public IMessageSink NextSink
+		{
+			get { return nextSink; }
+		}
+	}
+	
+	internal class DummySink: IMessageSink
+	{
+		public static DummySink Instance = new DummySink();
+		
+        public IMessage SyncProcessMessage (IMessage msg)
+		{
+			// Ignore
+			return null;
+		}
+		
+        public IMessageCtrl AsyncProcessMessage (IMessage msg, IMessageSink replySink)
+		{
+			// Ignore
+			return null;
+		}
+		
+        public IMessageSink NextSink
+		{
+			get { return null; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncObject.cs
===================================================================
--- trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncObject.cs	2004-12-06 17:00:46 UTC (rev 2056)
+++ trunk/MonoDevelop/Core/src/Main/Base/Services/DispatchService/SyncObject.cs	2004-12-06 20:40:45 UTC (rev 2057)
@@ -0,0 +1,15 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	public class SyncObject: ContextBoundObject
+	{
+	}
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001660.html">[Monodevelop-patches-list] r2056 - in trunk/MonoDevelop/Core/src/Main/Base: . Commands Commands/ProjectBrowserCommands Internal/Codons Internal/Codons/LanguageBinding Internal/Codons/MenuItems Internal/Conditions Internal/ExternalTool Internal/Parser/ReflectionLayer Internal/Project/Combine Internal/Project/Project Internal/Project/Project/Deployment Internal/Templates Internal/Templates/ProjectTemplates Services Services/AmbienceService Services/MenuService Services/ParserService Services/Project Services/StatusBar Services/Tasks Services/Toolbar
</A></li>
	<LI>Next message: <A HREF="001662.html">[Monodevelop-patches-list] r2058 - in trunk/MonoDevelop/Core/src/Main/Base: . Gui/Pads Gui/Pads/ClassScout Gui/Pads/ProjectBrowser Gui/Workbench Services Services/DispatchService Services/Project Services/Tasks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1661">[ date ]</a>
              <a href="thread.html#1661">[ thread ]</a>
              <a href="subject.html#1661">[ subject ]</a>
              <a href="author.html#1661">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
