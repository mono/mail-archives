<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2126 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Commands Commands/ProjectBrowserCommands Gui Gui/Dialogs Gui/Dialogs/CombineConfiguration Gui/Dialogs/OptionPanels/ProjectOptions Gui/Dialogs/ReferenceDialog Gui/Pads/ClassScout Gui/Pads/ClassScout/NodeBuilder Gui/Pads/FileScout Gui/Pads/ProjectBrowser Gui/Pads/ProjectBrowser/BrowserNode Gui/Pads/ProjectBrowser/NodeBuilder Gui/Workbench Internal Internal/Codons Internal/Codons/LanguageBinding Internal/Codons/ProjectBinding Internal/Conditions Internal/Parser Internal/Parser/SharpAssemblyLayer Internal/Project Internal/Project/Combine Internal/Project/Project Internal/Project/Project/Collections Internal/Project/Project/Deployment Internal/Serialization Internal/Templates/ProjectTemplates Services/File Services/LanguageBinding Services/ParserService Services/Project Services/StatusBar Services/Tasks
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2126%20-%20in%20trunk/MonoDevelop/Core/src/MonoDevelop.Base%3A%20.%20Commands%20Commands/ProjectBrowserCommands%20Gui%20Gui/Dialogs%20Gui/Dialogs/CombineConfiguration%20Gui/Dialogs/OptionPanels/ProjectOptions%20Gui/Dialogs/ReferenceDialog%20Gui/Pads/ClassScout%20Gui/Pads/ClassScout/NodeBuilder%20Gui/Pads/FileScout%20Gui/Pads/ProjectBrowser%20Gui/Pads/ProjectBrowser/BrowserNode%20Gui/Pads/ProjectBrowser/NodeBuilder%20Gui/Workbench%20Internal%20Internal/Codons%20Internal/Codons/LanguageBinding%20Internal/Codons/ProjectBinding%20Internal/Conditions%20Internal/Parser%20Internal/Parser/SharpAssemblyLayer%20Internal/Project%20Internal/Project/Combine%20Internal/Project/Project%20Internal/Project/Project/Collections%20Internal/Project/Project/Deployment%20Internal/Serialization%20Internal/Templates/ProjectTemplates%20Services/File%20Services/LanguageBinding%20Services/ParserService%20Services/Project%20Services/StatusBar%20Services/Tasks&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001729.html">
   <LINK REL="Next"  HREF="001731.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2126 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Commands Commands/ProjectBrowserCommands Gui Gui/Dialogs Gui/Dialogs/CombineConfiguration Gui/Dialogs/OptionPanels/ProjectOptions Gui/Dialogs/ReferenceDialog Gui/Pads/ClassScout Gui/Pads/ClassScout/NodeBuilder Gui/Pads/FileScout Gui/Pads/ProjectBrowser Gui/Pads/ProjectBrowser/BrowserNode Gui/Pads/ProjectBrowser/NodeBuilder Gui/Workbench Internal Internal/Codons Internal/Codons/LanguageBinding Internal/Codons/ProjectBinding Internal/Conditions Internal/Parser Internal/Parser/SharpAssemblyLayer Internal/Project Internal/Project/Combine Internal/Project/Project Internal/Project/Project/Collections Internal/Project/Project/Deployment Internal/Serialization Internal/Templates/ProjectTemplates Services/File Services/LanguageBinding Services/ParserService Services/Project Services/StatusBar Services/Tasks</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2126%20-%20in%20trunk/MonoDevelop/Core/src/MonoDevelop.Base%3A%20.%20Commands%20Commands/ProjectBrowserCommands%20Gui%20Gui/Dialogs%20Gui/Dialogs/CombineConfiguration%20Gui/Dialogs/OptionPanels/ProjectOptions%20Gui/Dialogs/ReferenceDialog%20Gui/Pads/ClassScout%20Gui/Pads/ClassScout/NodeBuilder%20Gui/Pads/FileScout%20Gui/Pads/ProjectBrowser%20Gui/Pads/ProjectBrowser/BrowserNode%20Gui/Pads/ProjectBrowser/NodeBuilder%20Gui/Workbench%20Internal%20Internal/Codons%20Internal/Codons/LanguageBinding%20Internal/Codons/ProjectBinding%20Internal/Conditions%20Internal/Parser%20Internal/Parser/SharpAssemblyLayer%20Internal/Project%20Internal/Project/Combine%20Internal/Project/Project%20Internal/Project/Project/Collections%20Internal/Project/Project/Deployment%20Internal/Serialization%20Internal/Templates/ProjectTemplates%20Services/File%20Services/LanguageBinding%20Services/ParserService%20Services/Project%20Services/StatusBar%20Services/Tasks&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2126 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Commands Commands/ProjectBrowserCommands Gui Gui/Dialogs Gui/Dialogs/CombineConfiguration Gui/Dialogs/OptionPanels/ProjectOptions Gui/Dialogs/ReferenceDialog Gui/Pads/ClassScout Gui/Pads/ClassScout/NodeBuilder Gui/Pads/FileScout Gui/Pads/ProjectBrowser Gui/Pads/ProjectBrowser/BrowserNode Gui/Pads/ProjectBrowser/NodeBuilder Gui/Workbench Internal Internal/Codons Internal/Codons/LanguageBinding Internal/Codons/ProjectBinding Internal/Conditions Internal/Parser Internal/Parser/SharpAssemblyLayer Internal/Project Internal/Project/Combine Internal/Project/Project Internal/Project/Project/Collections Internal/Project/Project/Deployment Internal/Serialization Internal/Templates/ProjectTemplates Services/File Services/LanguageBinding Services/ParserService Services/Project Services/StatusBar Services/Tasks">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Thu Jan 13 19:26:36 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001729.html">[Monodevelop-patches-list] r2125 - in trunk/MonoDevelop/Core/src: AddIns/BackendBindings/CSharpBinding MonoDevelop.Gui.Utils MonoDevelop.Gui.Utils/FileIcons
</A></li>
        <LI>Next message: <A HREF="001731.html">[Monodevelop-patches-list] r2127 - in trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding: . Gui Parser Project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1730">[ date ]</a>
              <a href="thread.html#1730">[ thread ]</a>
              <a href="subject.html#1730">[ subject ]</a>
              <a href="author.html#1730">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lluis
Date: 2005-01-13 19:26:36 -0500 (Thu, 13 Jan 2005)
New Revision: 2126

Added:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/OutputOptionsPanel.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/IProjectBinding.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/ProjectBindingCodon.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/LanguageActiveCondition.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/CmbxFileFormat.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntryRenamedEventArgs.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/IFileFormat.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/PrjxFileFormat.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProject.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProjectBinding.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProjectConfiguration.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/ProjectPathItemPropertyAttribute.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ArrayHandler.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ArrayListHandler.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ClassDataType.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/CollectionDataType.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataCollection.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataContext.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataIncludeAttribute.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataItem.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataItemAttribute.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataNode.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataSerializer.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataType.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataValue.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/EnumDataType.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ExpandedCollectionAttribute.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/GenericCollectionHandler.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ICollectionHandler.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/IExtendedDataItem.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ItemProperty.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ItemPropertyAttribute.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/PrimitiveDataType.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/SerializationContext.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/XmlDataSerializer.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/FileFormatManager.cs
Removed:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Attributes/
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IProject.cs
Modified:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Base.glade
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/AutostartCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/CustomStringTagProvider.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/FileCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/CombineNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/RunCommands.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/AbstractViewContent.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/CombineConfiguration/CombineConfigurationPanel.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/NewProjectDialog.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/CompileFileProjectOptions.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/DeployFileOptions.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/GeneralProjectOptions.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ProjectOptionsDialog.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/AddWebReferenceDialog.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/ProjectReferencePanel.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/SelectReferenceDialog.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/WebReference.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/SharpDevelopAboutPanels.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/WordCountDialog.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IProgressMonitor.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IViewContent.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/ClassScout.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/FileScout/FileScout.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/AbstractBrowserNode.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/FileNode.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/ReferenceNode.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder/DefaultDotNetNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder/IProjectNodeBuilder.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/ProjectBrowserView.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/DefaultWorkbench.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/LanguageBinding/ILanguageBinding.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/ProjectActiveCondition.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/ProjectOpenCondition.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/IParser.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyAttribute.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyClass.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyEvent.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyField.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyMethod.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyParameter.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyProperty.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyReturnType.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/Combine.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineConfiguration.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntry.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntryEventArgs.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineExecuteDefinition.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractConfiguration.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractProject.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractProjectConfiguration.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Collections/ProjectFileCollection.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Collections/ProjectReferenceCollection.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/AssemblyDeploy.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/DeployInformation.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/FileDeploy.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/IDeploymentStrategy.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/ScriptDeploy.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IncludeFilesDialog.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectFile.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectFileEventArgs.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReference.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReferenceEventArgs.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/TypelibImporter.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/CombineDescriptor.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/ProjectDescriptor.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/ProjectTemplate.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/File/DefaultFileService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/LanguageBinding/LanguageBindingService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/CodeCompletionDatabase.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/IParserService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/IProjectService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectEventArgs.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectRenameEventArgs.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/StatusBar/DefaultStatusBarService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/Task.cs
Log:
2005-01-11  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;

	* Services/Project/DefaultProjectService.cs: Added support for custom
	file formats and project types.
	
	* Gui/Dialogs/OptionPanels/ProjectOptions/OutputOptionsPanel.cs:
	* Base.glade: Moved here the OutputOptionsPanel dialog from the c#
	binding.
	
	* Internal/Codons/LanguageBinding/ILanguageBinding.cs: Moved some methods
	to the new IProjectBinding interface, since they are language independent.
	Actually, ILanguageBinding is now a &quot;dot net language binding&quot;. Support for
	non-.net languages should be implemented by extending IProjectBinding.
	
	* Internal/Project/Project/AbstractProjectConfiguration.cs: Moved some
	properties to the new DotNetProjectConfiguration, and added some others
	from the language bindings.
	
	* Internal/Project/Project/AbstractProject.cs: The IProject interface
	is not used anymore. All serialization code has been removed and
	reimplemented in PrjxFileFormat. Some methods have been moved to the
	new base class CombineEntry, and some others to the DotNetProject
	subclass.
	
	* Internal/Project/Combine/Combine.cs: It is now a subclass of
	CombineEntry. All serialization code has been removed and
	reimplemented in CmbxFileFormat. The class interface has been simplified.
	
	* Internal/Project/Combine/CombineEntry.cs: It is now the base class
	for Combine and Project. Some common properties have been factorized
	here.
	
	* Internal/Templates/ProjectTemplates/ProjectTemplate.cs: LanguageName
	is optional.
	* Internal/Templates/ProjectTemplates/ProjectDescriptor.cs: Use the new
	project type model.
	* MonoDevelopCore.addin.xml: Added extension path for project types.
	
	* Services/Project/FileFormatManager.cs: New file. Class that allows
	to register new types of combine entry files.
	* Internal/Conditions/LanguageActiveCondition.cs: New file. Condition
	that checks the language of the current project.
	* Internal/Codons/ProjectBinding/IProjectBinding.cs: New file.
	Interface that represents a project binding.
	* Internal/Codons/ProjectBinding/ProjectBindingCodon.cs: new codon for
	project bindings.
	* Internal/Project/Attributes/*: Removed. Equivalent funcionality is
	now provided by MonoDevelop.Internal.Serialization.
	
	* Internal/Project/IFileFormat.cs: Base interface for file format
	implementations.
	* Internal/Project/PrjxFileFormat.cs: Implements serialization into the
	prjx file format. 
	* Internal/Project/CmbxFileFormat.cs: Implements serialization into the
	cmbx file format.
	
	* Internal/Project/Project/DotNetProject.cs: 
	* Internal/Project/Project/DotNetProjectBinding.cs:
	* Internal/Project/Project/DotNetProjectConfiguration.cs: A basic .net
	project implementation.
	
	* Internal/Project/Project/IProject.cs: Removed. Not needed anymore.
	* Internal/Project/Combine/CombineEntryRenamedEventArgs.cs: New file.
	
	* Internal/Serialization/*: A generic data serializer.
	
	* Other files: Follow architecture changes.



Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Base.glade
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Base.glade	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Base.glade	2005-01-14 00:26:36 UTC (rev 2126)
@@ -4599,4 +4599,568 @@
   &lt;/child&gt;
 &lt;/widget&gt;
 
+&lt;widget class=&quot;GtkWindow&quot; id=&quot;OutputOptionsPanel&quot;&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;OutputOptionsPanel&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+
+  &lt;child&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox66&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;12&lt;/property&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox67&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label93&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Output&amp;lt;/b&amp;gt;&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox57&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;label91&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox69&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkTable&quot; id=&quot;table10&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;n_rows&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;n_columns&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;row_spacing&quot;&gt;6&lt;/property&gt;
+		      &lt;property name=&quot;column_spacing&quot;&gt;6&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label98&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Assembly _name&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;assemblyNameEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label99&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Output _path&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;outputDirectoryEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label100&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Paramet_ers&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;mnemonic_widget&quot;&gt;parametersEntry&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;outputDirectoryEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;assemblyNameEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;parametersEntry&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkCheckButton&quot; id=&quot;pauseConsoleOutputCheckButton&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Pause _console output&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		      &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox68&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label94&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&amp;lt;b&amp;gt;Execute scripts &amp;lt;/b&amp;gt;&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox58&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;label92&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;    &lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkTable&quot; id=&quot;table9&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;n_rows&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;n_columns&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;row_spacing&quot;&gt;6&lt;/property&gt;
+		  &lt;property name=&quot;column_spacing&quot;&gt;6&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label95&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Execute Command&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label96&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_After Build&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;executeAfterEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label97&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Before build&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;mnemonic_widget&quot;&gt;executeBeforeEntry&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeScriptEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeAfterEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;executeBeforeEntry&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot; translatable=&quot;yes&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton2&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton3&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browseButton4&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
 &lt;/glade-interface&gt;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-01-14 00:26:36 UTC (rev 2126)
@@ -1,3 +1,71 @@
+2005-01-11  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt;
+
+	* Services/Project/DefaultProjectService.cs: Added support for custom
+	file formats and project types.
+	
+	* Gui/Dialogs/OptionPanels/ProjectOptions/OutputOptionsPanel.cs:
+	* Base.glade: Moved here the OutputOptionsPanel dialog from the c#
+	binding.
+	
+	* Internal/Codons/LanguageBinding/ILanguageBinding.cs: Moved some methods
+	to the new IProjectBinding interface, since they are language independent.
+	Actually, ILanguageBinding is now a &quot;dot net language binding&quot;. Support for
+	non-.net languages should be implemented by extending IProjectBinding.
+	
+	* Internal/Project/Project/AbstractProjectConfiguration.cs: Moved some
+	properties to the new DotNetProjectConfiguration, and added some others
+	from the language bindings.
+	
+	* Internal/Project/Project/AbstractProject.cs: The IProject interface
+	is not used anymore. All serialization code has been removed and
+	reimplemented in PrjxFileFormat. Some methods have been moved to the
+	new base class CombineEntry, and some others to the DotNetProject
+	subclass.
+	
+	* Internal/Project/Combine/Combine.cs: It is now a subclass of
+	CombineEntry. All serialization code has been removed and
+	reimplemented in CmbxFileFormat. The class interface has been simplified.
+	
+	* Internal/Project/Combine/CombineEntry.cs: It is now the base class
+	for Combine and Project. Some common properties have been factorized
+	here.
+	
+	* Internal/Templates/ProjectTemplates/ProjectTemplate.cs: LanguageName
+	is optional.
+	* Internal/Templates/ProjectTemplates/ProjectDescriptor.cs: Use the new
+	project type model.
+	* MonoDevelopCore.addin.xml: Added extension path for project types.
+	
+	* Services/Project/FileFormatManager.cs: New file. Class that allows
+	to register new types of combine entry files.
+	* Internal/Conditions/LanguageActiveCondition.cs: New file. Condition
+	that checks the language of the current project.
+	* Internal/Codons/ProjectBinding/IProjectBinding.cs: New file.
+	Interface that represents a project binding.
+	* Internal/Codons/ProjectBinding/ProjectBindingCodon.cs: new codon for
+	project bindings.
+	* Internal/Project/Attributes/*: Removed. Equivalent funcionality is
+	now provided by MonoDevelop.Internal.Serialization.
+	
+	* Internal/Project/IFileFormat.cs: Base interface for file format
+	implementations.
+	* Internal/Project/PrjxFileFormat.cs: Implements serialization into the
+	prjx file format. 
+	* Internal/Project/CmbxFileFormat.cs: Implements serialization into the
+	cmbx file format.
+	
+	* Internal/Project/Project/DotNetProject.cs: 
+	* Internal/Project/Project/DotNetProjectBinding.cs:
+	* Internal/Project/Project/DotNetProjectConfiguration.cs: A basic .net
+	project implementation.
+	
+	* Internal/Project/Project/IProject.cs: Removed. Not needed anymore.
+	* Internal/Project/Combine/CombineEntryRenamedEventArgs.cs: New file.
+	
+	* Internal/Serialization/*: A generic data serializer.
+	
+	* Other files: Follow architecture changes.
+
 2004-01-03  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at off.net</A>&gt;
 
 	* Commands/RunCommands.cs:

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/AutostartCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/AutostartCommands.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/AutostartCommands.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -62,24 +62,19 @@
 			
 			foreach (string file in SplashScreenForm.GetRequestedFileList()) {
 				//FIXME: use mimetypes
-				switch (System.IO.Path.GetExtension(file).ToUpper()) {
-					case &quot;.CMBX&quot;:
-					case &quot;.PRJX&quot;:
-						try {
-							Runtime.ProjectService.OpenCombine (file);
-						} catch (Exception e) {
-							CombineLoadError.HandleError(e, file);
-						}
-						
-						break;
-					default:
-						try {
-							Runtime.FileService.OpenFile (file);
-						
-						} catch (Exception e) {
-							Console.WriteLine(&quot;unable to open file {0} exception was :\n{1}&quot;, file, e.ToString());
-						}
-						break;
+				if (Runtime.ProjectService.IsCombineEntryFile (file)) {
+					try {
+						Runtime.ProjectService.OpenCombine (file);
+					} catch (Exception e) {
+						CombineLoadError.HandleError(e, file);
+					}
+				} else {
+					try {
+						Runtime.FileService.OpenFile (file);
+					
+					} catch (Exception e) {
+						Console.WriteLine(&quot;unable to open file {0} exception was :\n{1}&quot;, file, e.ToString());
+					}
 				}
 			}
 			

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/CustomStringTagProvider.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/CustomStringTagProvider.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/CustomStringTagProvider.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -23,6 +23,7 @@
 using MonoDevelop.Services;
 using MonoDevelop.Gui;
 using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Internal.Project;
 
 namespace MonoDevelop.Commands
 {
@@ -52,11 +53,12 @@
 		string GetCurrentTargetPath()
 		{
 			if (projectService.CurrentSelectedProject != null) {
-				return projectService.GetOutputAssemblyName(projectService.CurrentSelectedProject);
+				return projectService.CurrentSelectedProject.GetOutputFileName ();
 			}
 			if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null) {
 				string fileName = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName;
-				return projectService.GetOutputAssemblyName(fileName);
+				Project project = projectService.GetProject (fileName);
+				if (project != null) return project.GetOutputFileName();
 			}
 			return String.Empty;
 		}
@@ -116,22 +118,23 @@
 				
 				case &quot;PROJECTDIR&quot;:
 					if (projectService.CurrentSelectedProject != null) {
-						return projectService.GetFileName(projectService.CurrentSelectedProject);
+						return projectService.CurrentSelectedProject.BaseDirectory;
 					}
 					break;
 				case &quot;PROJECTFILENAME&quot;:
 					if (projectService.CurrentSelectedProject != null) {
 						try {
-							return Path.GetFileName(projectService.GetFileName(projectService.CurrentSelectedProject));
+							return Path.GetFileName(projectService.CurrentSelectedProject.FileName);
 						} catch (Exception) {}
 					}
 					break;
 				
 				case &quot;COMBINEDIR&quot;:
-					return Path.GetDirectoryName (projectService.GetFileName(projectService.CurrentOpenCombine));
+					return Path.GetDirectoryName (projectService.CurrentOpenCombine.FileName);
+
 				case &quot;COMBINEFILENAME&quot;:
 					try {
-						return Path.GetFileName(projectService.GetFileName(projectService.CurrentOpenCombine));
+						return Path.GetFileName(projectService.CurrentOpenCombine.FileName);
 					} catch (Exception) {}
 					break;
 				case &quot;STARTUPPATH&quot;:

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/FileCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/FileCommands.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/FileCommands.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -281,15 +281,10 @@
 				string name = fs.Filename;
 				fs.Hide ();
 				if (response == (int)Gtk.ResponseType.Ok) {
-					switch (System.IO.Path.GetExtension (name).ToUpper()) {
-					case &quot;.PRJX&quot;:
-					case &quot;.CMBX&quot;:
+					if (Runtime.ProjectService.IsCombineEntryFile (name))
 						Runtime.ProjectService.OpenCombine (name);
-						break;
-					default:
+					else
 						Runtime.FileService.OpenFile(name);
-						break;
-					}
 				}	
 			}
 		}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/CombineNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/CombineNodeCommands.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/CombineNodeCommands.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -49,7 +49,7 @@
 		{
 			try 
 			{
-				int newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((IProject)node.Combine.AddEntry(npdlg.NewProjectLocation)));
+				int newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((Project)node.Combine.AddEntry(npdlg.NewProjectLocation)));
 				Runtime.ProjectService.SaveCombine ();
 			// expand to the new node
 				node.Nodes[newNodeIndex].Expand();
@@ -111,8 +111,8 @@
 						try {
 							object obj = node.Combine.AddEntry(fdiag.Filename);
 							int newNodeIndex = -1;
-							if (obj is IProject) {
-								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((IProject)obj));
+							if (obj is Project) {
+								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((Project)obj));
 							} else {
 								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildCombineTreeNode((Combine)obj));
 							}
@@ -149,8 +149,8 @@
 						try {
 							object obj = node.Combine.AddEntry(fdiag.Filename);
 							int newNodeIndex = -1;
-							if (obj is IProject) {
-								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((IProject)obj));
+							if (obj is Project) {
+								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildProjectTreeNode((Project)obj));
 							} else {
 								newNodeIndex = node.Nodes.Add(ProjectBrowserView.BuildCombineTreeNode((Combine)obj));
 							}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -36,7 +36,7 @@
 			FolderNode         node    = browser.SelectedNode as FolderNode;
 			
 			if (node != null) {
-				IProject project = ((ProjectBrowserNode)node.Parent).Project;
+				Project project = ((ProjectBrowserNode)node.Parent).Project;
 				
 				SelectReferenceDialog selDialog = new SelectReferenceDialog(project);
 				if (selDialog.Run() == (int)Gtk.ResponseType.Ok) {
@@ -63,7 +63,7 @@
 			ProjectBrowserView browser = (ProjectBrowserView)Owner;
 			ReferenceNode   node    = browser.SelectedNode as ReferenceNode;
 			if (node != null) {				
-				IProject project = node.Project;  //((ProjectBrowserNode)node.Parent.Parent).Project;
+				Project project = node.Project;  //((ProjectBrowserNode)node.Parent.Parent).Project;
 				IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
 				
 				ProjectReference refInfo = (ProjectWebReference)node.UserData;
@@ -83,7 +83,7 @@
 			bool bInitReferences = false;
 			
 			if (node != null) {
-				IProject project = ((ProjectBrowserNode)node.Parent).Project;
+				Project project = ((ProjectBrowserNode)node.Parent).Project;
 			
 /*				using (AddWebReferenceDialog refDialog = new AddWebReferenceDialog(project)) {
 					if (refDialog.ShowDialog() == DialogResult.OK) {						

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectBrowserCommands/ResourceFolderNodeCommands.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -41,7 +41,7 @@
 			FolderNode         node    = browser.SelectedNode as FolderNode;
 			
 			if (node != null) {
-				IProject project = ((ProjectBrowserNode) node.Parent).Project;
+				Project project = ((ProjectBrowserNode) node.Parent).Project;
 				
 				show_dialog:
 									
@@ -63,7 +63,7 @@
 					}
 				
 					foreach (string fileName in files) {
-						ProjectFile fileInformation = Runtime.ProjectService.AddFileToProject(project, fileName, BuildAction.EmbedAsResource);
+						ProjectFile fileInformation = project.AddFile (fileName, BuildAction.EmbedAsResource);
 					
 						AbstractBrowserNode newResNode = new FileNode(fileInformation);
 						newResNode.Image = Stock.ResourceFileIcon;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectCommands.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/ProjectCommands.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -26,8 +26,7 @@
 		public override void Run()
 		{
 			if (Runtime.ProjectService.CurrentSelectedProject != null) {
-				ILanguageBinding csc = Runtime.Languages.GetBindingPerLanguageName (Runtime.ProjectService.CurrentSelectedProject.ProjectType);
-				string assembly = csc.GetCompiledOutputName (Runtime.ProjectService.CurrentSelectedProject);
+				string assembly = Runtime.ProjectService.CurrentSelectedProject.GetOutputFileName ();
 				
 				if (!File.Exists(assembly)) {
 					Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Assembly not Found (Compile the project first)&quot;));
@@ -47,7 +46,7 @@
 	{
 		public override void Run()
 		{
-			IProject selectedProject = Runtime.ProjectService.CurrentSelectedProject;
+			Project selectedProject = Runtime.ProjectService.CurrentSelectedProject;
 			if (selectedProject == null) {
 				return;
 			}
@@ -57,7 +56,7 @@
 			
 			ProjectOptionsDialog optionsDialog = new ProjectOptionsDialog(selectedProject, generalOptionsNode, configurationPropertiesNode);
 			if (optionsDialog.Run() == (int)Gtk.ResponseType.Ok) {
-					Runtime.ProjectService.MarkProjectDirty (selectedProject);
+					Runtime.ProjectService.CurrentSelectedProject.NeedsBuilding = true;
 			}
 			
 			Runtime.ProjectService.SaveCombine();
@@ -85,9 +84,7 @@
 		{
 			try {
 				if (Runtime.ProjectService.CurrentSelectedProject != null) {
-					ILanguageBinding csc = Runtime.Languages.GetBindingPerLanguageName (Runtime.ProjectService.CurrentSelectedProject.ProjectType);
-					
-					string assembly    = csc.GetCompiledOutputName (Runtime.ProjectService.CurrentSelectedProject);
+					string assembly    = Runtime.ProjectService.CurrentSelectedProject.GetOutputFileName ();
 					string projectFile = Path.ChangeExtension(assembly, &quot;.ndoc&quot;);
 					if (!File.Exists(projectFile)) {
 						StreamWriter sw = File.CreateText(projectFile);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/RunCommands.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/RunCommands.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Commands/RunCommands.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -60,24 +60,16 @@
 						ShowAfterCompileStatus();
 					} else {
 						if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null) {
-							ILanguageBinding binding = Runtime.Languages.GetBindingPerFileName(WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
-							
-							if (binding != null) {
-								if (binding == null || !binding.CanCompile(WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName)) {
-									Runtime.MessageService.ShowError(String.Format (GettextCatalog.GetString (&quot;Language binding {0} can't compile {1}&quot;), binding.Language, WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName));
-								} else {
-									new SaveFile().Run();
-									ICompilerResult res = binding.CompileFile(WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
-									taskService.ClearTasks ();
-									foreach (CompilerError err in res.CompilerResults.Errors) {
-										taskService.AddTask(new Task(null, err));
-									}
-									taskService.CompilerOutput = res.CompilerOutput;
-									taskService.NotifyTaskChange();
-									ShowAfterCompileStatus();
-								}
+							new SaveFile().Run();
+							Project tempProject = Runtime.ProjectService.CreateSingleFileProject (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
+							if (tempProject != null) {
+								taskService.ClearTasks ();
+								taskService.CompilerOutput = &quot;&quot;;
+								ICompilerResult res = tempProject.Compile ();
+								taskService.CompilerOutput = res.CompilerOutput;
+								ShowAfterCompileStatus();
 							} else {
-								Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;No source file for compilation found. Please save unsaved files&quot;));
+								Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;The current file can't be compiled.&quot;));
 							}
 						}
 					}
@@ -98,15 +90,12 @@
 		public override void Run()
 		{
 			lock (CompileLockObject) {
-				if (Runtime.ProjectService.CurrentOpenCombine != null) {
-					Runtime.TaskService.CompilerOutput = String.Empty;
-					Runtime.ProjectService.OnStartBuild();
-					RunWithWait();
-					//Thread t = new Thread(new ThreadStart(CompileThread));
-					//t.IsBackground  = true;
-					//t.Start();
-				}
-				
+				Runtime.TaskService.CompilerOutput = String.Empty;
+				Runtime.ProjectService.OnStartBuild();
+				RunWithWait();
+				//Thread t = new Thread(new ThreadStart(CompileThread));
+				//t.IsBackground  = true;
+				//t.Start();
 			}
 		}
 	}
@@ -126,24 +115,16 @@
 						Compile.ShowAfterCompileStatus();
 					} else {
 						if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null) {
-							ILanguageBinding binding = Runtime.Languages.GetBindingPerFileName(WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
-							
-							if (binding != null) {
-								if (binding == null || !binding.CanCompile(WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName)) {
-									Runtime.MessageService.ShowError(String.Format (GettextCatalog.GetString (&quot;Language binding {0} can't compile {1}&quot;), binding.Language, WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName));
-								} else {
-									new SaveFile().Run();
-									ICompilerResult res = binding.CompileFile(WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
-									taskService.ClearTasks();
-									foreach (CompilerError err in res.CompilerResults.Errors) {
-										taskService.AddTask(new Task(null, err));
-									}
-									taskService.CompilerOutput = res.CompilerOutput;
-									taskService.NotifyTaskChange();
-									Compile.ShowAfterCompileStatus();
-								}
+							new SaveFile().Run();
+							Project tempProject = Runtime.ProjectService.CreateSingleFileProject (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
+							if (tempProject != null) {
+								taskService.ClearTasks ();
+								taskService.CompilerOutput = &quot;&quot;;
+								ICompilerResult res = tempProject.Compile ();
+								taskService.CompilerOutput = res.CompilerOutput;
+								Compile.ShowAfterCompileStatus();
 							} else {
-								Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;No source file for compilation found. Please save unsaved files&quot;));
+								Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;The current file can't be compiled.&quot;));
 							}
 						}
 					}
@@ -197,12 +178,12 @@
 						}
 					} else {
 						if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null) {
-							new Compile().RunWithWait();
 							if (Runtime.TaskService.Errors == 0) {
-								ILanguageBinding binding = Runtime.Languages.GetBindingPerFileName(WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
-								if (binding != null) {
+								Project tempProject = Runtime.ProjectService.CreateSingleFileProject (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
+								if (tempProject != null) {
+									tempProject.Compile ();
 									projectService.OnBeforeStartProject();
-									binding.Execute(WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName);
+									tempProject.Execute ();
 								} else {
 									Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;No runnable executable found.&quot;));
 								}
@@ -210,6 +191,7 @@
 						}
 					}
 				} catch (Exception e) {
+					Console.WriteLine (e);
 					Runtime.MessageService.ShowError(e, GettextCatalog.GetString (&quot;Error while running&quot;));
 				}
 				Runtime.Gui.StatusBar.SetMessage(GettextCatalog.GetString (&quot;Ready&quot;));
@@ -219,13 +201,11 @@
 		
 		public override void Run()
 		{
-			if (Runtime.ProjectService.CurrentOpenCombine != null) {
-				RunThread(); // TODO FIXME PEDRO
-				
-				//Thread t = new Thread(new ThreadStart(RunThread));
-				//t.IsBackground  = true;
-				//t.Start();
-			}
+			RunThread(); // TODO FIXME PEDRO
+			
+			//Thread t = new Thread(new ThreadStart(RunThread));
+			//t.IsBackground  = true;
+			//t.Start();
 		}
 	}
 	
@@ -290,7 +270,7 @@
 		public override void Run () 
 		{
 			if (Runtime.ProjectService.CurrentOpenCombine != null) {
-				Runtime.ProjectService.GenerateMakefiles ();
+				Runtime.ProjectService.CurrentOpenCombine.GenerateMakefiles ();
 			}
 		}
 	}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/AbstractViewContent.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/AbstractViewContent.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/AbstractViewContent.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -17,7 +17,7 @@
 	{
 		string untitledName = &quot;&quot;;
 		string contentName  = null;
-		IProject project = null;
+		Project project = null;
 		
 		bool   isDirty  = false;
 		bool   isViewOnly = false;
@@ -106,7 +106,7 @@
 		{
 		}
 
-		public IProject Project
+		public Project Project
 		{
 			get
 			{

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/CombineConfiguration/CombineConfigurationPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/CombineConfiguration/CombineConfigurationPanel.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/CombineConfiguration/CombineConfigurationPanel.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -112,8 +112,8 @@
 			
 			CombineEntry entry = (CombineEntry)combine.Entries[combine.GetEntryNumber(item.Text)];
 			int index = 0;
-			if (entry.Entry is IProject) {
-				IProject subproject = (IProject)entry.Entry;
+			if (entry.Entry is Project) {
+				Project subproject = (Project)entry.Entry;
 				for (int i = 0; i &lt; subproject.Configurations.Count; ++i) {
 					string name = ((IConfiguration)subproject.Configurations[i]).Name;
 					if (name == item.SubItems[1].Text)

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/NewProjectDialog.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/NewProjectDialog.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/NewProjectDialog.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -160,7 +160,7 @@
 			return true;
 		}
 		
-		public void SaveFile(IProject project, string filename, string content, bool showFile)
+		public void SaveFile(Project project, string filename, string content, bool showFile)
 		{
 			project.ProjectFiles.Add (new ProjectFile(filename));
 			
@@ -206,7 +206,7 @@
 				return;
 			}
 
-			if(Runtime.ProjectService.ExistsEntryWithName(name)) {
+			if (Runtime.ProjectService.GetProject (name) != null) {
 				Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;A Project with that name is already in your Project Space&quot;));
 				dialog.Respond(Gtk.ResponseType.Reject);
 				dialog.Hide();

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/CompileFileProjectOptions.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/CompileFileProjectOptions.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/CompileFileProjectOptions.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -32,12 +32,12 @@
 			[Glade.Widget] Gtk.TreeView includeTreeView;
 			public ListStore store;
 			
-			IProject project;
+			Project project;
 
 			public CompileFileOptionsWidget (IProperties CustomizationObject) : 
 				base (&quot;Base.glade&quot;, &quot;CompileFileOptionsPanel&quot;)
 			{
-				this.project = (IProject)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);	
+				this.project = (Project)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);	
 				
 				includeLabel.UseUnderline = true;
 				store = new ListStore (typeof(bool), typeof(string));

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/DeployFileOptions.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/DeployFileOptions.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/DeployFileOptions.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -42,13 +42,13 @@
 			public ListStore store;
 
 			// Services
-			IProject project;
+			Project project;
 			static FileUtilityService fileUtilityService = Runtime.FileUtilityService;
 
 			public DeployFileOptionsWidget (IProperties CustomizationObject) : 
 				base (&quot;Base.glade&quot;, &quot;DeployFileOptionsPanel&quot;)
 			{
-				this.project = (IProject)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);
+				this.project = (Project)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);
 
   				projectFileRadioButton.Clicked += new EventHandler(RadioButtonClicked);
   				compiledAssemblyRadioButton.Clicked += new EventHandler(RadioButtonClicked);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/GeneralProjectOptions.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/GeneralProjectOptions.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/GeneralProjectOptions.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -43,13 +43,13 @@
  			[Glade.Widget] CheckButton autoInsertNewFilesCheckButton;
  			[Glade.Widget] CheckButton enableViewStateCheckButton;
 
-			IProject project;
+			Project project;
 
 
 
 			public GeneralProjectOptionsWidget (IProperties CustomizationObject) : base (&quot;Base.glade&quot;, &quot;GeneralProjectOptionsPanel&quot;)
 			{
-				this.project = (IProject)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);
+				this.project = (Project)((IProperties)CustomizationObject).GetProperty(&quot;Project&quot;);
 
 				nameLabel.UseUnderline = true;
 				

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/OutputOptionsPanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/OutputOptionsPanel.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/OptionPanels/ProjectOptions/OutputOptionsPanel.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,158 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.ExternalTool;
+using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Gui.Widgets;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Services;
+
+using Gtk;
+
+namespace MonoDevelop.Gui.Dialogs.OptionPanels
+{
+	public class OutputOptionsPanel : AbstractOptionPanel
+	{
+		class OutputOptionsPanelWidget : GladeWidgetExtract 
+		{
+			//
+			// Gtk Controls	
+			//
+			[Glade.Widget] Entry assemblyNameEntry;
+			[Glade.Widget] Entry outputDirectoryEntry;
+			[Glade.Widget] Entry parametersEntry;
+			[Glade.Widget] Entry executeBeforeEntry;
+			[Glade.Widget] Entry executeScriptEntry;
+			[Glade.Widget] Entry executeAfterEntry;
+			[Glade.Widget] CheckButton pauseConsoleOutputCheckButton;			
+			[Glade.Widget] Button browseButton;
+			[Glade.Widget] Button browseButton2;
+			[Glade.Widget] Button browseButton3;
+			[Glade.Widget] Button browseButton4;
+			
+			DotNetProjectConfiguration configuration;
+
+			public  OutputOptionsPanelWidget(IProperties CustomizationObject) : base (&quot;Base.glade&quot;, &quot;OutputOptionsPanel&quot;)
+ 			{			
+				configuration = (DotNetProjectConfiguration)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
+				browseButton.Clicked += new EventHandler (SelectFolder);
+				browseButton2.Clicked += new EventHandler (SelectFile4);
+				browseButton3.Clicked += new EventHandler (SelectFile3);
+				browseButton4.Clicked += new EventHandler (SelectFile2);
+				
+				assemblyNameEntry.Text = configuration.OutputAssembly;
+				outputDirectoryEntry.Text = configuration.OutputDirectory;
+				parametersEntry.Text      = configuration.CommandLineParameters;
+				executeScriptEntry.Text   = configuration.ExecuteScript;
+ 				executeBeforeEntry.Text   = configuration.ExecuteBeforeBuild;
+ 				executeAfterEntry.Text    = configuration.ExecuteAfterBuild;
+				
+ 				pauseConsoleOutputCheckButton.Active = configuration.PauseConsoleOutput;
+			}
+
+			public bool Store ()
+			{	
+				if (configuration == null) {
+					return true;
+				}
+				
+				if (!Runtime.FileUtilityService.IsValidFileName(assemblyNameEntry.Text)) {
+					Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Invalid assembly name specified&quot;));
+					return false;
+				}
+
+				if (!Runtime.FileUtilityService.IsValidFileName (outputDirectoryEntry.Text)) {
+					Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Invalid output directory specified&quot;));
+					return false;
+				}
+				
+				configuration.OutputAssembly = assemblyNameEntry.Text;
+				configuration.OutputDirectory = outputDirectoryEntry.Text;
+				configuration.CommandLineParameters = parametersEntry.Text;
+				configuration.ExecuteBeforeBuild = executeBeforeEntry.Text;
+				configuration.ExecuteAfterBuild = executeAfterEntry.Text;
+				configuration.ExecuteScript = executeScriptEntry.Text;
+				configuration.PauseConsoleOutput = pauseConsoleOutputCheckButton.Active;
+				return true;
+			}
+			
+			void SelectFolder(object sender, EventArgs e)
+			{
+				using (FileSelector fdiag = new FileSelector (GettextCatalog.GetString (&quot;Select the directory in which the assembly will be created&quot;))) {
+					if (fdiag.Run () == (int) ResponseType.Ok) {
+						outputDirectoryEntry.Text = fdiag.Filename;
+					}
+				
+					fdiag.Hide ();
+				}
+			}
+		
+			void SelectFile2(object sender, EventArgs e)
+			{
+				using (FileSelector fdiag = new FileSelector (&quot;&quot;)) {
+					//fdiag.Filter = StringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+					fdiag.SelectMultiple = false;
+				
+					if(fdiag.Run () == (int) ResponseType.Ok) {
+						executeBeforeEntry.Text = fdiag.Filename;
+					}
+
+					fdiag.Hide ();
+				}
+			}
+			
+			void SelectFile3(object sender, EventArgs e)
+			{
+				using (FileSelector fdiag = new FileSelector (&quot;&quot;)) {
+					//fdiag.Filter = StringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+					fdiag.SelectMultiple = false;
+				
+					if(fdiag.Run () == (int) ResponseType.Ok) {
+						executeAfterEntry.Text = fdiag.Filename;
+					}
+
+					fdiag.Hide ();
+				}
+			}
+		
+			void SelectFile4(object sender, EventArgs e)
+			{
+				using (FileSelector fdiag = new FileSelector (&quot;&quot;)) {
+					//fdiag.Filter = StringParserService.Parse(&quot;${res:SharpDevelop.FileFilter.AllFiles}|*.*&quot;);
+					fdiag.SelectMultiple = false;
+				
+					if(fdiag.Run () == (int) ResponseType.Ok) {
+						executeScriptEntry.Text = fdiag.Filename;
+					}
+
+					fdiag.Hide ();
+				}
+			}
+		}
+
+		OutputOptionsPanelWidget  widget;
+
+		public override void LoadPanelContents()
+		{
+			Add (widget = new  OutputOptionsPanelWidget ((IProperties) CustomizationObject));
+		}
+		
+		public override bool StorePanelContents()
+		{
+			bool result = true;
+			result = widget.Store ();
+ 			return result;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ProjectOptionsDialog.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ProjectOptionsDialog.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ProjectOptionsDialog.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -24,14 +24,14 @@
 	/// &lt;/summary&gt;
 	public class ProjectOptionsDialog : TreeViewOptions
 	{
-		IProject  project;
+		Project  project;
 		
 		IAddInTreeNode configurationNode;
 		Gtk.TreeIter configurationTreeNode;
 		Gtk.CellRendererText textRenderer;		// used to set an editable node
 		Gtk.TreeViewColumn textColumn;			// used to set an editable node
 	
-		public ProjectOptionsDialog(IProject project, IAddInTreeNode node, IAddInTreeNode configurationNode) : base(null, null)
+		public ProjectOptionsDialog(Project project, IAddInTreeNode node, IAddInTreeNode configurationNode) : base(null, null)
 		{
 			this.project = project;
 			this.configurationNode = configurationNode;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/AddWebReferenceDialog.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/AddWebReferenceDialog.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/AddWebReferenceDialog.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -57,7 +57,7 @@
 		/// &lt;/summary&gt;
 		private System.ComponentModel.Container components = null;
 
-		private IProject project = null;
+		private Project project = null;
 		private ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
 		private FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
 	
@@ -71,7 +71,7 @@
 			}
 		}
 
-		public AddWebReferenceDialog(IProject p)
+		public AddWebReferenceDialog(Project p)
 		{			
 			//
 			// Required for Windows Form Designer support

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/ProjectReferencePanel.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/ProjectReferencePanel.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/ProjectReferencePanel.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -27,7 +27,7 @@
 		{
 			this.selectDialog = selectDialog;
 			
-			store = new TreeStore (typeof (string), typeof (string), typeof(IProject));
+			store = new TreeStore (typeof (string), typeof (string), typeof(Project));
 			treeView = new TreeView (store);
 			treeView.AppendColumn (GettextCatalog.GetString (&quot;Project Name&quot;), new CellRendererText (), &quot;text&quot;, 0);
 			treeView.AppendColumn (GettextCatalog.GetString (&quot;Project Directory&quot;), new CellRendererText (), &quot;text&quot;, 1);
@@ -47,12 +47,10 @@
 		
 		void AddReference (TreeModel model, TreePath path, TreeIter iter)
 		{
-			IProject project = (IProject) model.GetValue (iter, 2);
-			ILanguageBinding binding = Runtime.Languages.GetBindingPerLanguageName(project.ProjectType);
-			
+			Project project = (Project) model.GetValue (iter, 2);
 			selectDialog.AddReference(ReferenceType.Project,
 						  project.Name,
-						  binding.GetCompiledOutputName(project));
+						  project.GetOutputFileName());
 		}
 		
 		public void AddReference(object sender, EventArgs e)
@@ -68,10 +66,8 @@
 				return;
 			}
 			
-			ArrayList projects = Combine.GetAllProjects(openCombine);
-			
-			foreach (ProjectCombineEntry projectEntry in projects) {
-				store.AppendValues (projectEntry.Project.Name, projectEntry.Project.BaseDirectory, projectEntry.Project);
+			foreach (Project projectEntry in openCombine.GetAllProjects()) {
+				store.AppendValues (projectEntry.Name, projectEntry.BaseDirectory, projectEntry);
 			}
 		}
 	}
@@ -105,13 +101,10 @@
 		public void AddReference(object sender, EventArgs e)
 		{
 			foreach (ListViewItem item in SelectedItems) {
-				IProject project = (IProject)item.Tag;
-				LanguageBindingService languageBindingService = (LanguageBindingService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(LanguageBindingService));
-				ILanguageBinding binding = languageBindingService.GetBindingPerLanguageName(project.ProjectType);
-				
+				Project project = (Project)item.Tag;
 				selectDialog.AddReference(ReferenceType.Project,
 				                          project.Name,
-				                          binding.GetCompiledOutputName(project));
+				                          project.GetOutputFileName());
 			}
 		}
 		

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/SelectReferenceDialog.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/SelectReferenceDialog.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/SelectReferenceDialog.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -35,7 +35,7 @@
 		[Glade.Widget] Gtk.Notebook  mainBook;
 		GacReferencePanel gacRefPanel;
 
-		IProject configureProject;
+		Project configureProject;
 		
 		public ArrayList ReferenceInformations {
 			get {
@@ -62,7 +62,7 @@
 			AddReferenceDialog.Hide ();
 		}
 		
-		public SelectReferenceDialog(IProject configureProject)
+		public SelectReferenceDialog(Project configureProject)
 		{
 			this.configureProject = configureProject;
 			
@@ -109,13 +109,13 @@
 
 		void AddNonGacReference (ProjectReference refInfo)
 		{
-			refTreeStore.AppendValues (System.IO.Path.GetFileName (refInfo.Reference), refInfo.ReferenceType.ToString (), System.IO.Path.GetFullPath (refInfo.GetReferencedFileName (configureProject)), refInfo);
+			refTreeStore.AppendValues (System.IO.Path.GetFileName (refInfo.Reference), refInfo.ReferenceType.ToString (), System.IO.Path.GetFullPath (refInfo.GetReferencedFileName ()), refInfo);
 		}
 
-		void AddGacReference (ProjectReference refInfo, IProject referencedProject)
+		void AddGacReference (ProjectReference refInfo, Project referencedProject)
 		{
 			gacRefPanel.SignalRefChange (refInfo.Reference, true);
-			refTreeStore.AppendValues (System.IO.Path.GetFileNameWithoutExtension (refInfo.GetReferencedFileName (referencedProject)), refInfo.ReferenceType.ToString (), refInfo.Reference, refInfo);
+			refTreeStore.AppendValues (System.IO.Path.GetFileNameWithoutExtension (refInfo.GetReferencedFileName ()), refInfo.ReferenceType.ToString (), refInfo.Reference, refInfo);
 		}
 
 		public void RemoveReference (ReferenceType referenceType, string referenceName, string referenceLocation)

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/WebReference.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/WebReference.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/ReferenceDialog/WebReference.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -80,7 +80,7 @@
 		}
 		
 		
-		public static ProjectReference GenerateWebProxyDLL(IProject project, ServiceDescription desc) {
+		public static ProjectReference GenerateWebProxyDLL(Project project, ServiceDescription desc) {
 			ProjectReference refInfo = null;
 			
 			string serviceName = String.Empty;
@@ -139,14 +139,14 @@
 		///
 		/// &lt;summary&gt;Generates a Web Service proxy DLL from a URI&lt;/summary&gt;
 		/// 
-		public static ProjectReference GenerateWebProxyDLL(IProject project, string url) {
+		public static ProjectReference GenerateWebProxyDLL(Project project, string url) {
 									
 			ServiceDescription desc = ReadServiceDescription(url);						
 			return GenerateWebProxyDLL(project, desc);
 									
 		}
 		
-		public static ArrayList GenerateWebProxyCode(IProject project, ServiceDescription desc) {		
+		public static ArrayList GenerateWebProxyCode(Project project, ServiceDescription desc) {		
 			ArrayList fileList = null;
 			
 			string serviceName = String.Empty;
@@ -273,7 +273,7 @@
 		///
 		/// &lt;summary&gt;Generates a Web Service proxy class from a URI&lt;/summary&gt;
 		/// 
-		public static ArrayList GenerateWebProxyCode(IProject project, string url) {
+		public static ArrayList GenerateWebProxyCode(Project project, string url) {
 			
 			
 			ServiceDescription desc = ReadServiceDescription(url);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/SharpDevelopAboutPanels.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/SharpDevelopAboutPanels.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/SharpDevelopAboutPanels.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,7 +14,6 @@
 using MonoDevelop.Gui;
 using MonoDevelop.Core.Properties;
 using MonoDevelop.Core.Services;
-using MonoDevelop.Internal.Project.Collections;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Services;
 

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/WordCountDialog.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/WordCountDialog.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Dialogs/WordCountDialog.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -153,9 +153,9 @@
 		void CountCombine(Combine combine, ref Report all)
 		{
 			foreach (CombineEntry entry in combine.Entries) {
-				if (entry.Entry is IProject) {
+				if (entry is Project) {
 					// string tmp = &quot;&quot;;
-					foreach (ProjectFile finfo in ((IProject)entry.Entry).ProjectFiles) {
+					foreach (ProjectFile finfo in ((Project)entry).ProjectFiles) {
 						if (finfo.Subtype != Subtype.Directory &amp;&amp; 
 						    finfo.BuildAction == BuildAction.Compile) {
 							Report r = GetReport(finfo.Name);
@@ -166,7 +166,7 @@
 						}
 					}
 				} else
-					CountCombine((Combine)entry.Entry, ref all);
+					CountCombine ((Combine)entry, ref all);
 			}
 		}
 		

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IProgressMonitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IProgressMonitor.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IProgressMonitor.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -17,6 +17,8 @@
 		
 		void Worked (double work, string status);
 		
+		void Pulse ();
+
 		void Done();
 		
 		bool Canceled {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IViewContent.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IViewContent.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/IViewContent.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -95,7 +95,7 @@
 		/// &lt;summary&gt;
 		/// The name of the project the content is attached to
 		/// &lt;/summary&gt;
-		IProject Project {
+		Project Project {
 			get;
 			set;
 		}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/ClassScout.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/ClassScout.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/ClassScout.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -172,14 +172,14 @@
 		protected override void OnBeforeExpand (TreeViewCancelEventArgs e)
 		{
 			TreeNode nod = e.Node;
-			if (nod.Tag == null || nod.Tag is IProject)
+			if (nod.Tag == null || nod.Tag is Project)
 			{
 				while (nod != null &amp;&amp; nod.Tag == null)
 					nod = nod.Parent;
 					
 				if (nod == null) return;
 				
-				IProject p = (IProject)nod.Tag;
+				Project p = (Project)nod.Tag;
 				foreach (IClassScoutNodeBuilder classBrowserNodeBuilder in classBrowserNodeBuilders) {
 					if (classBrowserNodeBuilder.CanBuildClassTree(p)) {
 						classBrowserNodeBuilder.ExpandNode (e.Node);
@@ -260,15 +260,15 @@
 		public void ParseCombine(Combine combine)
 		{
 			foreach (CombineEntry entry in combine.Entries) {
-				if (entry is ProjectCombineEntry) {
-					ParseProject(((ProjectCombineEntry)entry).Project);
+				if (entry is Project) {
+					ParseProject((Project)entry);
 				} else {
-					ParseCombine(((CombineCombineEntry)entry).Combine);
+					ParseCombine((Combine)entry);
 				}
 			}
 		}
 
-		void ParseProject(IProject p)
+		void ParseProject(Project p)
 		{
 			if (p.ProjectType == &quot;C#&quot;) {
 	 			foreach (ProjectFile finfo in p.ProjectFiles) {
@@ -303,10 +303,10 @@
 			
 			lock (combine.Entries) {
 				foreach (CombineEntry entry in combine.Entries) {
-					if (entry is ProjectCombineEntry) {
-						Populate(((ProjectCombineEntry)entry).Project, combineNode.Nodes);
+					if (entry is Project) {
+						Populate((Project)entry, combineNode.Nodes);
 					} else {
-						Populate(((CombineCombineEntry)entry).Combine, combineNode.Nodes);
+						Populate((Combine)entry, combineNode.Nodes);
 					}
 				}
 			}
@@ -314,7 +314,7 @@
 			nodes.Add(combineNode);
 		}
 
-		void Populate(IProject p, TreeNodeCollection nodes)
+		void Populate(Project p, TreeNodeCollection nodes)
 		{
 			// only C# is currently supported.
 			bool builderFound = false;
@@ -332,7 +332,8 @@
 			if (!builderFound) {
 				TreeNode prjNode = new TreeNode(p.Name);
 				//prjNode.SelectedImageIndex = prjNode.ImageIndex = imageIndexOffset + iconService.GetImageIndexForProjectType(p.ProjectType);
-				prjNode.Image = Runtime.Gui.Icons.GetImageForProjectType(p.ProjectType);
+				string lang = (p is DotNetProject) ? ((DotNetProject)p).LanguageName : &quot;&quot;;
+				prjNode.Image = Runtime.Gui.Icons.GetImageForProjectType(lang);
 				prjNode.Nodes.Add(new TreeNode(GettextCatalog.GetString (&quot;No class builder found&quot;)));
 				prjNode.Tag = p;
 				nodes.Add(prjNode);
@@ -343,8 +344,8 @@
 		{
 			BeginUpdate();
 			foreach (TreeNode node in nodes) {
-				if (node.Tag is IProject) {
-					IProject p = (IProject)node.Tag;
+				if (node.Tag is Project) {
+					Project p = (Project)node.Tag;
 					if (p.IsFileInProject(e.FileName)) {
 						foreach (IClassScoutNodeBuilder classBrowserNodeBuilder in classBrowserNodeBuilders) {
 							classBrowserNodeBuilder.UpdateClassTree(node, e);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/NodeBuilder/DefaultDotNetClassScoutNodeBuilder.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -34,7 +34,7 @@
 		{
 		}
 
-		public bool CanBuildClassTree(IProject project)
+		public bool CanBuildClassTree(Project project)
 		{
 			return true;
 		}
@@ -73,7 +73,7 @@
 		
 		public void UpdateClassTree(TreeNode projectNode)
 		{
-			TreeNode newNode = BuildClassTreeNode((IProject)projectNode.Tag);
+			TreeNode newNode = BuildClassTreeNode((Project)projectNode.Tag);
 			projectNode.Nodes.Clear();
 			foreach (TreeNode node in newNode.Nodes)
 				projectNode.Nodes.Add(node);
@@ -84,14 +84,15 @@
 			return (nod.Nodes.Count == 1 &amp;&amp; nod.Nodes[0].Text == &quot;&quot;);
 		}
 
-		public TreeNode BuildClassTreeNode(IProject p)
+		public TreeNode BuildClassTreeNode(Project p)
 		{
 			Type fus = typeof (FileUtilityService);
 			
 			GetCurrentAmbience();
 
 			TreeNode prjNode = new AbstractClassScoutNode(p.Name);
-			prjNode.Image = Runtime.Gui.Icons.GetImageForProjectType(p.ProjectType);
+			string lang = (p is DotNetProject) ? ((DotNetProject)p).LanguageName : &quot;&quot;;
+			prjNode.Image = Runtime.Gui.Icons.GetImageForProjectType(lang);
 			prjNode.Nodes.Add (new TreeNode (&quot;&quot;));
 			prjNode.Tag = p;
 			return prjNode;
@@ -109,17 +110,17 @@
 					nod = nod.Parent;
 				}
 
-				IProject p = (IProject)nod.Tag;
+				Project p = (Project)nod.Tag;
 				ExpandNamespaceTree (p, ns, node);
 			}
-			else if (node.Tag is IProject)
+			else if (node.Tag is Project)
 			{
-				IProject p = (IProject)node.Tag;
+				Project p = (Project)node.Tag;
 				ExpandNamespaceTree (p, &quot;&quot;, node);
 			}
 		}
 		
-		void ExpandNamespaceTree (IProject project, string ns, TreeNode node)
+		void ExpandNamespaceTree (Project project, string ns, TreeNode node)
 		{
 			if (!NeedsExpansion (node)) return;
 			node.Nodes.Clear ();
@@ -244,7 +245,7 @@
 				TreeNode node = GetNodeByPath (ns, projectNode, false);
 				if (node != null &amp;&amp; node != projectNode) {
 					if (NeedsExpansion (node)) {
-						ArrayList contents = Runtime.ParserService.GetNamespaceContents (projectNode.Tag as IProject, ns, false);
+						ArrayList contents = Runtime.ParserService.GetNamespaceContents (projectNode.Tag as Project, ns, false);
 						if (contents.Count == 0)
 							node.Remove ();
 					} else if (node.Nodes.Count == 0) {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ClassScout/NodeBuilder/IClassScoutNodeBuilder.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -21,8 +21,8 @@
 {
 	public interface IClassScoutNodeBuilder
 	{
-		bool     CanBuildClassTree(IProject project);
-		TreeNode BuildClassTreeNode(IProject project);
+		bool     CanBuildClassTree(Project project);
+		TreeNode BuildClassTreeNode(Project project);
 		void     ExpandNode (TreeNode node);
 
 		void     UpdateClassTree (TreeNode projectNode, ClassInformationEventArgs e);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/FileScout/FileScout.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/FileScout/FileScout.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/FileScout/FileScout.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -98,16 +98,10 @@
 
 				//FIXME: use mimetypes not extensions
 				// also change to Project tab when its a project
-				switch (System.IO.Path.GetExtension (item.FullName).ToUpper ()) {
-					case &quot;.cmbx&quot;:
-					case &quot;.prjx&quot;:
-						Runtime.ProjectService.OpenCombine (item.FullName);
-						break;
-					default:
-						//Console.WriteLine (item.FullName);
-						Runtime.FileService.OpenFile (item.FullName);
-						break;
-				}
+				if (Runtime.ProjectService.IsCombineEntryFile (item.FullName))
+					Runtime.ProjectService.OpenCombine (item.FullName);
+				else
+					Runtime.FileService.OpenFile (item.FullName);
 			}
 		}
 

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/AbstractBrowserNode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/AbstractBrowserNode.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/AbstractBrowserNode.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -69,7 +69,7 @@
 		/// any node is child of a project. THIS DON'T WORK ON COMBINE NODES!
 		/// (a combine node returns null)
 		/// &lt;/summary&gt;
-		public virtual IProject Project {
+		public virtual Project Project {
 			get {
 				if (Parent == null || !(Parent is AbstractBrowserNode)) {
 					return null;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/CombineBrowserNode.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -44,7 +44,7 @@
 			Image = Stock.CombineIcon;
 			
 			contextmenuAddinTreePath = defaultContextMenuPath;
-			combine.NameChanged += new EventHandler(UpdateCombineName);
+			combine.NameChanged += new CombineEntryRenamedEventHandler (UpdateCombineName);
 		}
 		
 		public override void BeforeLabelEdit()
@@ -57,7 +57,7 @@
 			if (newName != null &amp;&amp; newName.Trim().Length &gt; 0 &amp;&amp; ContainsNoInvalidChars (newName)) {
 				combine.Name = newName;
 			}
-			UpdateCombineName (null, EventArgs.Empty);
+			UpdateCombineName (null, null);
 		}
 		
 		bool ContainsNoInvalidChars (string name)
@@ -71,11 +71,11 @@
 		
 		public override void UpdateNaming()
 		{
-			UpdateCombineName(this, EventArgs.Empty);
+			UpdateCombineName(this, null);
 			base.UpdateNaming();
 		}
 		
-		public void UpdateCombineName(object sender, EventArgs e)
+		public void UpdateCombineName (object sender, CombineEntryRenamedEventArgs e)
 		{
 			switch (combine.Entries.Count) {
 				case 0:
@@ -108,25 +108,12 @@
 			if (!yes)
 				return false;
 			
-			CombineEntry removeEntry = null;
+			cmbNode.Combine.RemoveEntry (Combine);
 			
-			// remove combineentry
-			foreach (CombineEntry entry in cmbNode.Combine.Entries) {
-				if (entry is CombineCombineEntry) {
-					if (((CombineCombineEntry)entry).Combine == Combine) {
-						removeEntry = entry;
-						break;
-					}
-				}
-			}
-			
-			Debug.Assert(removeEntry != null);
-			cmbNode.Combine.RemoveEntry (removeEntry);
-			
 			// remove execute definition
 			CombineExecuteDefinition removeExDef = null;
 			foreach (CombineExecuteDefinition exDef in cmbNode.Combine.CombineExecuteDefinitions) {
-				if (exDef.Entry == removeEntry) {
+				if (exDef.Entry == Combine) {
 					removeExDef = exDef;
 				}
 			}
@@ -135,7 +122,7 @@
 			
 			// remove configuration
 			foreach (DictionaryEntry dentry in cmbNode.Combine.Configurations) {
-				((CombineConfiguration)dentry.Value).RemoveEntry(removeEntry);
+				((CombineConfiguration)dentry.Value).RemoveEntry (Combine);
 			}
 			
 			cmbNode.UpdateNaming();

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/FileNode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/FileNode.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/FileNode.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -89,7 +89,7 @@
 		public override void ActivateItem()
 		{
 			if (userData != null &amp;&amp; userData is ProjectFile)
-				Runtime.FileService.OpenFile (((ProjectFile)userData).Name);
+				Runtime.FileService.OpenFile (((ProjectFile)userData).FilePath);
 		}
 		
 		public override void AfterLabelEdit(string newName)

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/ProjectBrowserNode.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -26,9 +26,9 @@
 	public class ProjectBrowserNode : AbstractBrowserNode 
 	{
 		readonly static string defaultContextMenuPath = &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/ProjectBrowserNode&quot;;
-		IProject project;
+		Project project;
 		
-		public override IProject Project {
+		public override Project Project {
 			get {
 				return project;
 			}
@@ -67,22 +67,22 @@
 		}
 */
 		
-		public ProjectBrowserNode(IProject project)
+		public ProjectBrowserNode(Project project)
 		{
 			UserData     = project;
 			this.project = project;
 			Text         = project.Name;
 			contextmenuAddinTreePath = defaultContextMenuPath;
-			project.NameChanged += new EventHandler(ProjectNameChanged);
+			project.NameChanged += new CombineEntryRenamedEventHandler (ProjectNameChanged);
 		}
 		
 		public override void Dispose()
 		{
 			base.Dispose();
-			project.NameChanged -= new EventHandler(ProjectNameChanged);
+			project.NameChanged -= new CombineEntryRenamedEventHandler (ProjectNameChanged);
 		}
 		
-		void ProjectNameChanged(object sender, EventArgs e)
+		void ProjectNameChanged (object sender, CombineEntryRenamedEventArgs e)
 		{
 			Text = project.Name;
 		}
@@ -102,31 +102,19 @@
 		public override bool RemoveNode()
 		{
 			Combine  cmb = Combine;
-			IProject prj = project;
-			CombineEntry removeEntry = null;
+			Project prj = project;
 			
 			bool yes = Runtime.MessageService.AskQuestion (String.Format (GettextCatalog.GetString (&quot;Do you really want to remove project {0} from solution {1}&quot;), project.Name, cmb.Name));
 
 			if (!yes)
 				return false;
 			
-			// remove combineentry
-			foreach (CombineEntry entry in cmb.Entries) {
-				if (entry is ProjectCombineEntry) {
-					if (((ProjectCombineEntry)entry).Project == prj) {
-						removeEntry = entry;
-						break;
-					}
-				}
-			}
+			cmb.RemoveEntry (prj);
 			
-			Debug.Assert(removeEntry != null);
-			cmb.RemoveEntry (removeEntry);
-			
 			// remove execute definition
 			CombineExecuteDefinition removeExDef = null;
 			foreach (CombineExecuteDefinition exDef in cmb.CombineExecuteDefinitions) {
-				if (exDef.Entry == removeEntry) {
+				if (exDef.Entry == prj) {
 					removeExDef = exDef;
 				}
 			}
@@ -134,9 +122,8 @@
 			cmb.CombineExecuteDefinitions.Remove(removeExDef);
 			
 			// remove configuration
-			foreach (DictionaryEntry dentry in cmb.Configurations) {
-				((CombineConfiguration)dentry.Value).RemoveEntry(removeEntry);
-			}
+			foreach (CombineConfiguration dentry in cmb.Configurations)
+				dentry.RemoveEntry (prj);
 			
 			CombineBrowserNode cbn = ((CombineBrowserNode)Parent);
 			cbn.UpdateNaming();

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/ReferenceNode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/ReferenceNode.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/BrowserNode/ReferenceNode.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -76,7 +76,7 @@
 		public override void ActivateItem()
 		{
 			if (userData != null &amp;&amp; userData is ProjectReference)
-				Runtime.FileService.OpenFile (((ProjectReference)userData).GetReferencedFileName(Project));
+				Runtime.FileService.OpenFile (((ProjectReference)userData).GetReferencedFileName());
 		}
 		
 		/// &lt;summary&gt;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder/DefaultDotNetNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder/DefaultDotNetNodeBuilder.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder/DefaultDotNetNodeBuilder.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -24,7 +24,7 @@
 {
 	public class DefaultDotNetNodeBuilder : IProjectNodeBuilder
 	{
-		public bool CanBuildProjectTree(IProject project)
+		public bool CanBuildProjectTree(Project project)
 		{
 			return true;
 		}
@@ -42,10 +42,11 @@
 			return false;
 		}
 
-		public AbstractBrowserNode BuildProjectTreeNode(IProject project)
+		public AbstractBrowserNode BuildProjectTreeNode(Project project)
 		{
 			ProjectBrowserNode projectNode = new ProjectBrowserNode(project);
-			projectNode.Image = Runtime.Gui.Icons.GetImageForProjectType (project.ProjectType);
+			string lang = (project is DotNetProject) ? ((DotNetProject)project).LanguageName : &quot;&quot;;
+			projectNode.Image = Runtime.Gui.Icons.GetImageForProjectType (lang);
 
 			FolderNode resourceNode = new NamedFolderNode(GettextCatalog.GetString (&quot;Resource Files&quot;), 0);
 			resourceNode.ContextmenuAddinTreePath = &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/ResourceFolderNode&quot;;
@@ -198,7 +199,7 @@
 			return projectNode;
 		}
 
-		public static void AddProjectFileNode(IProject project, AbstractBrowserNode projectNode, ProjectFile projectFile) {
+		public static void AddProjectFileNode(Project project, AbstractBrowserNode projectNode, ProjectFile projectFile) {
 
 			if(projectNode.TreeView != null)
 				projectNode.TreeView.BeginUpdate();
@@ -413,7 +414,7 @@
 			return null;
 		}
 
-		public static void InitializeReferences(AbstractBrowserNode parentNode, IProject project)
+		public static void InitializeReferences(AbstractBrowserNode parentNode, Project project)
 		{
 			parentNode.Nodes.Clear();
 			foreach (ProjectReference referenceInformation in project.ProjectReferences) {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder/IProjectNodeBuilder.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder/IProjectNodeBuilder.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/NodeBuilder/IProjectNodeBuilder.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -19,7 +19,7 @@
 {
 	public interface IProjectNodeBuilder
 	{
-		bool                CanBuildProjectTree(IProject project);
-		AbstractBrowserNode BuildProjectTreeNode(IProject project);
+		bool                CanBuildProjectTree(Project project);
+		AbstractBrowserNode BuildProjectTreeNode(Project project);
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/ProjectBrowserView.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/ProjectBrowserView.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/ProjectBrowser/ProjectBrowserView.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -64,6 +64,7 @@
 
 		public void RedrawContent()
 		{
+			Runtime.DispatchService.AssertGuiThread ();
 			BeginUpdate();
 			AbstractBrowserNode.ShowExtensions = Runtime.Properties.GetProperty(&quot;MonoDevelop.Gui.ProjectBrowser.ShowExtensions&quot;, true);
 			foreach (AbstractBrowserNode node in Nodes) {
@@ -74,6 +75,7 @@
 		
 		public ProjectBrowserView() : base (true, TreeNodeComparer.GtkProjectNode)
 		{
+			Runtime.DispatchService.AssertGuiThread ();
 			WorkbenchSingleton.Workbench.ActiveWorkbenchWindowChanged += new EventHandler(ActiveWindowChanged);
 
 			Runtime.ProjectService.CombineOpened += (CombineEventHandler) Runtime.DispatchService.GuiDispatch (new CombineEventHandler (OpenCombine));
@@ -96,7 +98,7 @@
 			}
 		}
 		
-		public void RefreshTree(Combine combine)
+		void RefreshTree (Combine combine)
 		{
 			DisposeProjectNodes();
 			Nodes.Clear();
@@ -198,7 +200,7 @@
 				if (node.UserData is ProjectFile &amp;&amp; ((ProjectFile)node.UserData).Name == fileName) {
 					return node;
 				}
-				if (node.UserData is ProjectReference &amp;&amp; ((ProjectReference)node.UserData).GetReferencedFileName(node.Project) == fileName) {
+				if (node.UserData is ProjectReference &amp;&amp; ((ProjectReference)node.UserData).GetReferencedFileName() == fileName) {
 					return node;
 				}
 				
@@ -235,6 +237,7 @@
 		/// &lt;/summary&gt;
 		public void StartLabelEdit()
 		{
+			Runtime.DispatchService.AssertGuiThread ();
 			AbstractBrowserNode selectedNode = (AbstractBrowserNode)SelectedNode;
 			CombineBrowserNode cbn = SelectedNode as CombineBrowserNode;
 			if (null != cbn)
@@ -261,6 +264,7 @@
 		/// &lt;/summary&gt;
 		public void UpdateCombineTree()
 		{
+			Runtime.DispatchService.AssertGuiThread ();
 			XmlElement storedTree = new TreeViewMemento(this).ToXmlElement(new XmlDocument());
 			CloseCombine(this,new CombineEventArgs(Runtime.ProjectService.CurrentOpenCombine));
 			OpenCombine(this, new CombineEventArgs(Runtime.ProjectService.CurrentOpenCombine));
@@ -271,8 +275,9 @@
 		/// &lt;summary&gt;
 		/// This method builds a ProjectBrowserNode Tree out of a given combine.
 		/// &lt;/summary&gt;
-		public static AbstractBrowserNode BuildProjectTreeNode(IProject project)
+		public static AbstractBrowserNode BuildProjectTreeNode(Project project)
 		{
+			Runtime.DispatchService.AssertGuiThread ();
 			IProjectNodeBuilder[] nodeBuilders = (IProjectNodeBuilder[])(AddInTreeSingleton.AddInTree.GetTreeNode(nodeBuilderPath).BuildChildItems(null)).ToArray(typeof(IProjectNodeBuilder));
 			IProjectNodeBuilder   projectNodeBuilder = null;
 			foreach (IProjectNodeBuilder nodeBuilder in nodeBuilders) {
@@ -293,15 +298,16 @@
 		/// &lt;/summary&gt;
 		public static AbstractBrowserNode BuildCombineTreeNode(Combine combine)
 		{
+			Runtime.DispatchService.AssertGuiThread ();
 			CombineBrowserNode combineNode = new CombineBrowserNode(combine);
 			
 			// build subtree
 			foreach (CombineEntry entry in combine.Entries) {
 				TreeNode node = null;
-				if (entry.Entry is IProject) {
-					node = BuildProjectTreeNode((IProject)entry.Entry);
+				if (entry is Project) {
+					node = BuildProjectTreeNode((Project)entry);
 				} else {
-					node = BuildCombineTreeNode((Combine)entry.Entry);
+					node = BuildCombineTreeNode((Combine)entry);
 				}
 				combineNode.Nodes.Add (node);
 			}
@@ -498,6 +504,7 @@
 
 		public static void MoveCopyFile(string filename, AbstractBrowserNode node, bool move, bool alreadyInPlace)
 		{
+			Runtime.DispatchService.AssertGuiThread ();
 			//			FileType type      = FileUtility.GetFileType(filename);
 			bool     directory = Runtime.FileUtilityService.IsDirectory(filename);
 			if (
@@ -562,9 +569,9 @@
 			ProjectFile fInfo;
 
 			if (newparent.Project.IsCompileable(newfilename)) {
-				fInfo = Runtime.ProjectService.AddFileToProject(newparent.Project, newfilename, BuildAction.Compile);
+				fInfo = newparent.Project.AddFile (newfilename, BuildAction.Compile);
 			} else {
-				fInfo = Runtime.ProjectService.AddFileToProject(newparent.Project, newfilename, BuildAction.Nothing);
+				fInfo = newparent.Project.AddFile (newfilename, BuildAction.Nothing);
 			}
 
 			AbstractBrowserNode pbn = new FileNode(fInfo);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/DefaultWorkbench.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/DefaultWorkbench.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Workbench/DefaultWorkbench.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -172,23 +172,13 @@
 				string file = individualFile.Trim ();
 				if (file.StartsWith (&quot;<A HREF="file://&quot;">file://&quot;</A>)) {
 					file = file.Substring (7);
-					switch (System.IO.Path.GetExtension(file).ToUpper()) {
-					case &quot;.CMBX&quot;:
-					case &quot;.PRJX&quot;:
-						try {
+					try {
+						if (Runtime.ProjectService.IsCombineEntryFile (file))
 							Runtime.ProjectService.OpenCombine(file);
-						} catch (Exception e) {
-						}
-						
-						break;
-					default:
-						try {
+						else
 							Runtime.FileService.OpenFile (file);
-							
-						} catch (Exception e) {
-							Console.WriteLine(&quot;unable to open file {0} exception was :\n{1}&quot;, file, e.ToString());
-						}
-						break;
+					} catch (Exception e) {
+						Console.WriteLine(&quot;unable to open file {0} exception was :\n{1}&quot;, file, e.ToString());
 					}
 				}
 			}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/LanguageBinding/ILanguageBinding.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/LanguageBinding/ILanguageBinding.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/LanguageBinding/ILanguageBinding.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -10,6 +10,7 @@
 using System.Xml;
 
 using MonoDevelop.Internal.Templates;
+using MonoDevelop.Internal.Project;
 using MonoDevelop.Gui;
 
 namespace MonoDevelop.Internal.Project
@@ -27,45 +28,18 @@
 			get;
 		}
 		
-		/// &lt;summary&gt;
-		/// This function executes a file, the filename is given by filename,
-		/// the file was compiled by the compiler object before.
-		/// &lt;/summary&gt;
-		void Execute(string fileName);
-
-		void DebugProject (IProject project);
-		
-		/// &lt;summary&gt;
-		/// This function executes a project, the project is given as a parameter,
-		/// the project was compiled by the compiler object before.
-		/// &lt;/summary&gt;
-		void Execute(IProject project);
-		
-		string GetCompiledOutputName(string fileName);
-		
-		string GetCompiledOutputName(IProject project);
-		
 		/// &lt;returns&gt;
 		/// True, if this language binding can compile &gt;fileName&lt;
 		/// &lt;/returns&gt;
 		bool CanCompile(string fileName);
 		
-		ICompilerResult CompileFile(string fileName);
+		ICompilerResult Compile (ProjectFileCollection projectFiles, ProjectReferenceCollection references, DotNetProjectConfiguration configuration);
 		
-		ICompilerResult CompileProject(IProject project);
+		void GenerateMakefile (Project project, Combine parentCombine);
 		
-		ICompilerResult RecompileProject(IProject project);
+		object CreateCompilationParameters (XmlElement projectOptions);
 
-		void GenerateMakefile (IProject project, Combine parentCombine);
-		
 		/// &lt;summary&gt;
-		/// Creates a IProject out of the given ProjetCreateInformation object.
-		/// Each language binding must provide a representation of the project
-		/// it 'controls'.
-		/// &lt;/summary&gt;
-		IProject CreateProject(ProjectCreateInformation info, XmlElement projectOptions);
-
-		/// &lt;summary&gt;
 		/// Used by Comment and Uncomment operations and by Centaurus Addin.
 		/// &lt;/summary&gt;		
 		string CommentTag { get; }

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/IProjectBinding.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/IProjectBinding.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/IProjectBinding.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,66 @@
+//
+// IProjectBinding.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+using System.Collections;
+using System.Xml;
+
+using MonoDevelop.Internal.Templates;
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Internal.Project
+{
+	public interface IProjectBinding
+	{
+		/// &lt;remarks&gt;
+		/// Returns the project type name
+		/// &lt;/remarks&gt;
+		string Name { get; }
+		
+		/// &lt;remarks&gt;
+		/// Creates a Project out of the given ProjetCreateInformation object.
+		/// Each project binding must provide a representation of the project
+		/// it 'controls'.
+		/// &lt;/remarks&gt;
+		Project CreateProject (ProjectCreateInformation info, XmlElement projectOptions);
+		
+		/// &lt;remarks&gt;
+		/// Creates a Project for a single source file. If the file is not
+		/// valid for this project type, it must return null.
+		/// &lt;/remarks&gt;
+		Project CreateSingleFileProject (string sourceFile);
+		
+		/// &lt;remarks&gt;
+		/// Returns a list of autogenerated templates that can be used to
+		/// create projects of this type
+		/// &lt;/remarks&gt;
+		ProjectTemplate[] GetDefaultTemplates (); 
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/ProjectBindingCodon.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/ProjectBindingCodon.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Codons/ProjectBinding/ProjectBindingCodon.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,55 @@
+//
+// ProjectBindingCodon.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Core.AddIns.Conditions;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.Core.AddIns.Codons
+{
+	[CodonNameAttribute (&quot;ProjectBinding&quot;)]
+	public class ProjectBindingCodon : AbstractCodon
+	{
+		IProjectBinding projectBinding;
+		
+		public IProjectBinding ProjectBinding {
+			get { return projectBinding; }
+		}
+		
+		public override object BuildItem (object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			projectBinding = (IProjectBinding) AddIn.CreateObject (Class);
+			return this;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/LanguageActiveCondition.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/LanguageActiveCondition.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/LanguageActiveCondition.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,48 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Xml;
+
+
+using MonoDevelop.Core.AddIns.Conditions;
+using MonoDevelop.Core.Services;
+
+using MonoDevelop.Gui;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.Core.AddIns
+{
+	[ConditionAttribute()]
+	public class LanguageActiveCondition : AbstractCondition
+	{
+		[XmlMemberAttribute(&quot;activelanguage&quot;, IsRequired = true)]
+		string activelanguage;
+		
+		public string ActiveLanguage {
+			get {
+				return activelanguage;
+			}
+			set {
+				activelanguage = value;
+			}
+		}
+		
+		public override bool IsValid(object owner)
+		{
+			DotNetProject project = Runtime.ProjectService.CurrentSelectedProject as DotNetProject;
+			
+			if (activelanguage == &quot;*&quot;) {
+				return project != null;
+			}
+			return project != null &amp;&amp; project.LanguageName == activelanguage;
+		}
+	}
+
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/ProjectActiveCondition.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/ProjectActiveCondition.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/ProjectActiveCondition.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -36,7 +36,7 @@
 		
 		public override bool IsValid(object owner)
 		{
-			IProject project = Runtime.ProjectService.CurrentSelectedProject;
+			Project project = Runtime.ProjectService.CurrentSelectedProject;
 			
 			if (activeproject == &quot;*&quot;) {
 				return project != null;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/ProjectOpenCondition.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/ProjectOpenCondition.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Conditions/ProjectOpenCondition.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -36,12 +36,12 @@
 		
 		public override bool IsValid(object owner)
 		{
-			IProject project = Runtime.ProjectService.CurrentSelectedProject;
+			Project project = Runtime.ProjectService.CurrentSelectedProject;
 			
 			if (project == null &amp;&amp; Runtime.ProjectService.CurrentOpenCombine != null) {
-				ArrayList projects = Combine.GetAllProjects(Runtime.ProjectService.CurrentOpenCombine);
+				CombineEntryCollection projects = Runtime.ProjectService.CurrentOpenCombine.GetAllProjects();
 				if (projects.Count &gt; 0) {
-					project = ((ProjectCombineEntry)projects[0]).Project;
+					project = (Project)projects[0];
 				}
 			}
 			

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/IParser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/IParser.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/IParser.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -11,6 +11,7 @@
 
 using MonoDevelop.Services;
 using MonoDevelop.Internal.Project;
+using Project_ = MonoDevelop.Internal.Project.Project;
 
 namespace MonoDevelop.Internal.Parser
 {
@@ -133,17 +134,17 @@
 		/// The caretLineNumber and caretColumn is 1 based.
 		/// &lt;/summary&gt;
 		ResolveResult Resolve(IParserService parserService, 
-							  IProject project,
+							  Project_ project,
 		                      string expression, 
 		                      int caretLineNumber, 
 		                      int caretColumn, 
 		                      string fileName,
 		                      string fileContent);
 
-		string MonodocResolver (IParserService parserService, IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+		string MonodocResolver (IParserService parserService, Project_ project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
 
-		ArrayList IsAsResolve (IParserService parserService, IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+		ArrayList IsAsResolve (IParserService parserService, Project_ project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
 		
-		ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName);
+		ArrayList CtrlSpace(IParserService parserService, Project_ project, int caretLine, int caretColumn, string fileName);
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyAttribute.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyAttribute.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,7 +14,7 @@
 using MonoDevelop.SharpAssembly.Metadata.Rows;
 using MonoDevelop.SharpAssembly.Metadata;
 using MonoDevelop.SharpAssembly.PE;
-using SharpAssembly=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
+using SharpAssembly_=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
 using AssemblyReader=MonoDevelop.SharpAssembly.Assembly.AssemblyReader;
 using SharpCustomAttribute=MonoDevelop.SharpAssembly.Assembly.SharpCustomAttribute;
 
@@ -31,7 +31,7 @@
 			}
 		}
 		
-		public SharpAssemblyAttribute(SharpAssembly assembly, SharpCustomAttribute attribute)
+		public SharpAssemblyAttribute(SharpAssembly_ assembly, SharpCustomAttribute attribute)
 		{	
 			uint sigOffset = 0;
 			
@@ -242,7 +242,7 @@
 			return ret + &quot;)&quot;;
 		}
 		
-		public static AttributeCollection GetAssemblyAttributes(SharpAssembly assembly)
+		public static AttributeCollection GetAssemblyAttributes(SharpAssembly_ assembly)
 		{
 			AttributeCollection attributes = new AttributeCollection();
 			

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyClass.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyClass.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyClass.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,7 +14,7 @@
 using MonoDevelop.SharpAssembly.Metadata;
 using MonoDevelop.SharpAssembly.PE;
 using MonoDevelop.SharpAssembly.Assembly;
-using SharpAssembly = MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
+using SharpAssembly_ = MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
 
 namespace MonoDevelop.Internal.Parser {
 	
@@ -35,7 +35,7 @@
 			}
 		}
 		
-		public static string GetNestedName(SharpAssembly asm, TypeRef[] typeRefTable, uint index)
+		public static string GetNestedName(SharpAssembly_ asm, TypeRef[] typeRefTable, uint index)
 		{
 			uint val = typeRefTable[index].ResolutionScope;
 			int table = asm.Reader.GetCodedIndexTable(CodedIndex.ResolutionScope, ref val);
@@ -51,7 +51,7 @@
 			}
 		}
 		
-		public static string GetNestedName(SharpAssembly asm, TypeDef[] typeDefTable, uint index)
+		public static string GetNestedName(SharpAssembly_ asm, TypeDef[] typeDefTable, uint index)
 		{
 			uint nestedParent = asm.GetNestedTypeParent(index);
 			
@@ -66,7 +66,7 @@
 		/// Constructs a SharpAssemblyClass from an entry in the assembly's TypeRef table
 		/// by looking in the referencing assembly's TypeDef table
 		/// &lt;/summary&gt;
-		public static SharpAssemblyClass FromTypeRef(SharpAssembly referencingAssembly, uint index)
+		public static SharpAssemblyClass FromTypeRef(SharpAssembly_ referencingAssembly, uint index)
 		{
 			if (referencingAssembly.TypeRefObjects[index] as SharpAssemblyClass != null) {
 				return (SharpAssemblyClass)referencingAssembly.TypeRefObjects[index];
@@ -76,7 +76,7 @@
 			
 			string name = referencingAssembly.Reader.GetStringFromHeap(typeRefTable[index].Name);
 			
-			SharpAssembly declaringAssembly = referencingAssembly.GetRefAssemblyFor(index);
+			SharpAssembly_ declaringAssembly = referencingAssembly.GetRefAssemblyFor(index);
 			if (declaringAssembly == null) {
 				Console.Write(&quot;FromTypeRef failed for: &quot; + name + &quot; declared in assembly &quot; + referencingAssembly.Name);
 				Console.WriteLine(&quot;: Declaring assembly not found.&quot;);
@@ -112,7 +112,7 @@
 		/// Constructs a SharpAssemblyClass from an entry in the assembly's TypeDef table
 		/// Looks in the class cache for the assembly first
 		/// &lt;/summary&gt;
-		public static SharpAssemblyClass FromTypeDef(SharpAssembly assembly, uint index)
+		public static SharpAssemblyClass FromTypeDef(SharpAssembly_ assembly, uint index)
 		{
 			if (assembly.TypeDefObjects[index] as SharpAssemblyClass != null) {
 				SharpAssemblyClass exclass = (SharpAssemblyClass)assembly.TypeDefObjects[index];
@@ -127,7 +127,7 @@
 		/// The constructor is private because the only way to construct SharpAssemblyClass objects
 		/// is to call FromTypeRef/Def to make us of the cache
 		/// &lt;/summary&gt;
-		private SharpAssemblyClass(SharpAssembly assembly, TypeDef[] typeDefTable, uint index)
+		private SharpAssemblyClass(SharpAssembly_ assembly, TypeDef[] typeDefTable, uint index)
 		{
 			if (assembly == null) {
 				throw new System.ArgumentNullException(&quot;assembly&quot;);
@@ -263,7 +263,7 @@
 		{
 			if (membersLoaded) return;
 			
-			SharpAssembly assembly = (SharpAssembly)declaredIn;
+			SharpAssembly_ assembly = (SharpAssembly_)declaredIn;
 			TypeDef[] typeDefTable = assembly.Tables.TypeDef;
 			
 			AddMethods(assembly, typeDefTable, typeDefIndex);
@@ -285,7 +285,7 @@
 			return false;
 		}
 		
-		private static SharpAssemblyClass GetTypeRefOrDefClass(SharpAssembly assembly, uint cind) {
+		private static SharpAssemblyClass GetTypeRefOrDefClass(SharpAssembly_ assembly, uint cind) {
 			uint nTable = cind &amp; 0x03;
 			uint nIndex = cind &gt;&gt; 2;
 			
@@ -300,7 +300,7 @@
 			}
 		}
 		
-		void AddEvents(SharpAssembly asm, TypeDef[] typeDefTable, uint index)
+		void AddEvents(SharpAssembly_ asm, TypeDef[] typeDefTable, uint index)
 		{
 			EventMap[] eventMapTable = asm.Tables.EventMap;
 			Event[]    eventTable    = asm.Tables.Event;
@@ -334,7 +334,7 @@
 			}
 		}
 		
-		void AddProperties(SharpAssembly asm, TypeDef[] typeDefTable, uint index)
+		void AddProperties(SharpAssembly_ asm, TypeDef[] typeDefTable, uint index)
 		{
 			PropertyMap[] propertyMapTable = asm.Tables.PropertyMap;
 			Property[]    propertyTable    = asm.Tables.Property;
@@ -368,7 +368,7 @@
 			}
 		}
 		
-		void AddFields(SharpAssembly asm, TypeDef[] typeDefTable, uint index)
+		void AddFields(SharpAssembly_ asm, TypeDef[] typeDefTable, uint index)
 		{
 			Field[] fieldTable = asm.Tables.Field;
 			if (fieldTable == null) {
@@ -393,7 +393,7 @@
 			}
 		}
 		
-		void AddMethods(SharpAssembly asm, TypeDef[] typeDefTable, uint index)
+		void AddMethods(SharpAssembly_ asm, TypeDef[] typeDefTable, uint index)
 		{
 			Method[] methodDefTable = asm.Tables.Method;
 			if (methodDefTable == null) {
@@ -418,7 +418,7 @@
 			}
 		}
 		
-		public static SharpAssemblyClass[] GetAssemblyTypes(SharpAssembly assembly)
+		public static SharpAssemblyClass[] GetAssemblyTypes(SharpAssembly_ assembly)
 		{
 			
 			TypeDef[] typeDefTable = assembly.Tables.TypeDef;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyEvent.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyEvent.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyEvent.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -13,7 +13,7 @@
 using MonoDevelop.SharpAssembly.Metadata.Rows;
 using MonoDevelop.SharpAssembly.Metadata;
 using MonoDevelop.SharpAssembly.PE;
-using SharpAssembly=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
+using SharpAssembly_=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
 using AssemblyReader=MonoDevelop.SharpAssembly.Assembly.AssemblyReader;
 using SharpCustomAttribute=MonoDevelop.SharpAssembly.Assembly.SharpCustomAttribute;
 
@@ -22,7 +22,7 @@
 	[Serializable]
 	public class SharpAssemblyEvent : AbstractEvent
 	{
-		public SharpAssemblyEvent(SharpAssembly asm, Event[] eventTable, SharpAssemblyClass declaringtype, uint index)
+		public SharpAssemblyEvent(SharpAssembly_ asm, Event[] eventTable, SharpAssemblyClass declaringtype, uint index)
 		{
 			if (asm == null) {
 				throw new System.ArgumentNullException(&quot;asm&quot;);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyField.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyField.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyField.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -13,7 +13,7 @@
 using MonoDevelop.SharpAssembly.Metadata.Rows;
 using MonoDevelop.SharpAssembly.Metadata;
 using MonoDevelop.SharpAssembly.PE;
-using SharpAssembly=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
+using SharpAssembly_=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
 using SharpCustomAttribute=MonoDevelop.SharpAssembly.Assembly.SharpCustomAttribute;
 
 namespace MonoDevelop.Internal.Parser {
@@ -21,7 +21,7 @@
 	[Serializable]
 	public class SharpAssemblyField : AbstractField
 	{
-		public SharpAssemblyField(SharpAssembly assembly, Field[] fieldTable, SharpAssemblyClass declaringtype, uint index)
+		public SharpAssemblyField(SharpAssembly_ assembly, Field[] fieldTable, SharpAssemblyClass declaringtype, uint index)
 		{
 			if (assembly == null) {
 				throw new System.ArgumentNullException(&quot;assembly&quot;);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyMethod.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyMethod.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyMethod.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,7 +14,7 @@
 using MonoDevelop.SharpAssembly.Metadata.Rows;
 using MonoDevelop.SharpAssembly.Metadata;
 using MonoDevelop.SharpAssembly.PE;
-using SharpAssembly=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
+using SharpAssembly_=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
 using SharpCustomAttribute=MonoDevelop.SharpAssembly.Assembly.SharpCustomAttribute;
 using AssemblyReader=MonoDevelop.SharpAssembly.Assembly.AssemblyReader;
 
@@ -23,7 +23,7 @@
 	[Serializable]
 	public class SharpAssemblyMethod : AbstractMethod
 	{
-		public SharpAssemblyMethod(SharpAssembly asm, Method[] methodTable, SharpAssemblyClass declaringtype, uint index)
+		public SharpAssemblyMethod(SharpAssembly_ asm, Method[] methodTable, SharpAssemblyClass declaringtype, uint index)
 		{
 			if (asm == null) {
 				throw new System.ArgumentNullException(&quot;asm&quot;);
@@ -112,7 +112,7 @@
 			AddParameters(asm, methodTable, index, returnTypes);
 		}
 		
-		void AddParameters(SharpAssembly asm, Method[] methodDefTable, uint index, IReturnType[] returnTypes)
+		void AddParameters(SharpAssembly_ asm, Method[] methodDefTable, uint index, IReturnType[] returnTypes)
 		{
 			Param[] paramTable = asm.Tables.Param;
 			if (paramTable == null) return;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyParameter.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyParameter.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyParameter.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -13,7 +13,7 @@
 using MonoDevelop.SharpAssembly.Metadata.Rows;
 using MonoDevelop.SharpAssembly.Metadata;
 using MonoDevelop.SharpAssembly.PE;
-using SharpAssembly=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
+using SharpAssembly_=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
 using AssemblyReader=MonoDevelop.SharpAssembly.Assembly.AssemblyReader;
 using SharpCustomAttribute=MonoDevelop.SharpAssembly.Assembly.SharpCustomAttribute;
 
@@ -22,7 +22,7 @@
 	[Serializable]
 	public class SharpAssemblyParameter : AbstractParameter
 	{
-		public SharpAssemblyParameter(SharpAssembly asm, Param[] paramTable, uint index, IReturnType type)
+		public SharpAssemblyParameter(SharpAssembly_ asm, Param[] paramTable, uint index, IReturnType type)
 		{
 			if (asm == null) {
 				throw new System.ArgumentNullException(&quot;asm&quot;);
@@ -66,7 +66,7 @@
 			
 		}
 		
-		public SharpAssemblyParameter(SharpAssembly asm, string paramName, IReturnType type)
+		public SharpAssemblyParameter(SharpAssembly_ asm, string paramName, IReturnType type)
 		{
 			name = paramName;
 			if (type.Name.EndsWith(&quot;&amp;&quot;)) {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyProperty.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyProperty.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyProperty.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -13,7 +13,7 @@
 using MonoDevelop.SharpAssembly.Metadata.Rows;
 using MonoDevelop.SharpAssembly.Metadata;
 using MonoDevelop.SharpAssembly.PE;
-using SharpAssembly=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
+using SharpAssembly_=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
 using AssemblyReader=MonoDevelop.SharpAssembly.Assembly.AssemblyReader;
 using SharpCustomAttribute=MonoDevelop.SharpAssembly.Assembly.SharpCustomAttribute;
 
@@ -22,7 +22,7 @@
 	[Serializable]
 	public class SharpAssemblyProperty : AbstractProperty
 	{
-		public SharpAssemblyProperty(SharpAssembly asm, Property[] propertyTable, SharpAssemblyClass declaringtype, uint index)
+		public SharpAssemblyProperty(SharpAssembly_ asm, Property[] propertyTable, SharpAssemblyClass declaringtype, uint index)
 		{
 			if (asm == null) {
 				throw new System.ArgumentNullException(&quot;asm&quot;);
@@ -142,7 +142,7 @@
 			}
 		}
 		
-		void AddParameters(SharpAssembly asm, Method[] methodTable, uint index, IReturnType[] returnTypes)
+		void AddParameters(SharpAssembly_ asm, Method[] methodTable, uint index, IReturnType[] returnTypes)
 		{
 			Param[] paramTable = asm.Tables.Param;
 			if (paramTable == null) return;
@@ -167,7 +167,7 @@
 			}
 		}
 		
-		void AddParameters(SharpAssembly asm, IReturnType[] returnTypes)
+		void AddParameters(SharpAssembly_ asm, IReturnType[] returnTypes)
 		{
 			for (uint i = 0; i &lt; returnTypes.GetUpperBound(0); ++i) {
 				parameters.Add(new SharpAssemblyParameter(asm, &quot;param_&quot; + i, returnTypes[i]));

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyReturnType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyReturnType.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Parser/SharpAssemblyLayer/SharpAssemblyReturnType.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -13,7 +13,7 @@
 using MonoDevelop.SharpAssembly.Metadata.Rows;
 using MonoDevelop.SharpAssembly.Metadata;
 using MonoDevelop.SharpAssembly.PE;
-using SharpAssembly=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
+using SharpAssembly_=MonoDevelop.SharpAssembly.Assembly.SharpAssembly;
 using AssemblyReader=MonoDevelop.SharpAssembly.Assembly.AssemblyReader;
 
 namespace MonoDevelop.Internal.Parser {
@@ -31,7 +31,7 @@
 			}
 		}
 		
-		public void GetDataType(SharpAssembly asm, ref uint offset)
+		public void GetDataType(SharpAssembly_ asm, ref uint offset)
 		{
 			AssemblyReader assembly = asm.Reader;
 			string fullyQualifiedName = &quot;&quot;;
@@ -153,7 +153,7 @@
 			declaredin = null;
 		}
 		
-		public SharpAssemblyReturnType(SharpAssembly assembly, TypeDef[] typeDefTable, uint index)
+		public SharpAssemblyReturnType(SharpAssembly_ assembly, TypeDef[] typeDefTable, uint index)
 		{
 			underlyingClass = SharpAssemblyClass.FromTypeDef(assembly, index);
 			if (underlyingClass != null) {
@@ -165,7 +165,7 @@
 			declaredin = assembly;
 		}
 		
-		public SharpAssemblyReturnType(SharpAssembly assembly, TypeRef[] typeRefTable, uint index)
+		public SharpAssemblyReturnType(SharpAssembly_ assembly, TypeRef[] typeRefTable, uint index)
 		{
 			underlyingClass = SharpAssemblyClass.FromTypeRef(assembly, index);
 			if (underlyingClass != null) {
@@ -178,7 +178,7 @@
 			declaredin = assembly.GetRefAssemblyFor(index);
 		}
 		
-		public SharpAssemblyReturnType(SharpAssembly assembly, ref uint blobSignatureIndex)
+		public SharpAssemblyReturnType(SharpAssembly_ assembly, ref uint blobSignatureIndex)
 		{
 			arrayRanks = new ArrayList();
 			try {

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/CmbxFileFormat.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/CmbxFileFormat.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/CmbxFileFormat.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,235 @@
+//
+// CmbxFileFormat.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Xml;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Serialization;
+
+namespace MonoDevelop.Internal.Project
+{
+	public class CmbxFileFormat: IFileFormat
+	{
+		public string Name {
+			get { return &quot;MonoDevelop Combine&quot;; }
+		}
+		
+		public string GetValidFormatName (string fileName)
+		{
+			return Path.ChangeExtension (fileName, &quot;.cmbx&quot;);
+		}
+		
+		public bool CanReadFile (string file)
+		{
+			return string.Compare (Path.GetExtension (file), &quot;.cmbx&quot;, true) == 0;
+		}
+		
+		public bool CanWriteFile (object obj)
+		{
+			return obj is Combine;
+		}
+		
+		public void WriteFile (string file, object node)
+		{
+			Combine combine = node as Combine;
+			if (combine == null)
+				throw new InvalidOperationException (&quot;The provided object is not a Combine&quot;);
+
+			StreamWriter sw = new StreamWriter (file);
+			try {
+				XmlTextWriter tw = new XmlTextWriter (sw);
+				tw.Formatting = Formatting.Indented;
+				DataSerializer serializer = new DataSerializer (Runtime.ProjectService.DataContext, file);
+				CombineWriterV2 combineWriter = new CombineWriterV2 (serializer);
+				combineWriter.WriteCombine (tw, combine);
+			} finally {
+				sw.Close ();
+			}
+		}
+		
+		public object ReadFile (string file)
+		{
+			XmlTextReader reader = new XmlTextReader (new StreamReader (file));
+			reader.MoveToContent ();
+			
+			string version = reader.GetAttribute (&quot;version&quot;);
+			if (version == null) version = reader.GetAttribute (&quot;fileversion&quot;);
+			
+			DataSerializer serializer = new DataSerializer (Runtime.ProjectService.DataContext, file);
+			ICombineReader combineReader = null;
+			
+			if (version == &quot;1.0&quot;)
+				combineReader = new CombineReaderV1 (serializer);
+			else if (version == &quot;2.0&quot;)
+				combineReader = new CombineReaderV2 (serializer);
+			
+			try {
+				if (combineReader != null)
+					return combineReader.ReadCombine (reader);
+				else
+					throw new UnknownProjectVersionException (version);
+			} finally {
+				reader.Close ();
+			}
+		}
+	}
+	
+	interface ICombineReader {
+		Combine ReadCombine (XmlReader reader);
+	}
+	
+	class CombineReaderV1: XmlConfigurationReader, ICombineReader
+	{
+		Combine combine;
+		string file;
+		DataSerializer serializer;
+		
+		public CombineReaderV1 (DataSerializer serializer)
+		{
+			this.serializer = serializer;
+			this.file = serializer.SerializationContext.BaseFile;
+			combine = new Combine ();
+			combine.FileName = file;
+		}
+		
+		public Combine ReadCombine (XmlReader reader)
+		{
+			DataItem data = (DataItem) Read (reader);
+			serializer.Deserialize (combine, data);
+			
+			string mdCombineAddition = Path.ChangeExtension (combine.FileName, &quot;mdsx&quot;);
+			if (File.Exists (mdCombineAddition)) {
+				XmlDocument doc = new XmlDocument ();
+				doc.Load (mdCombineAddition);
+				string rop = doc.DocumentElement[&quot;RelativeOutputPath&quot;].InnerText;
+				if (rop != &quot;&quot;)
+					combine.OutputDirectory = Runtime.FileUtilityService.RelativeToAbsolutePath (combine.BaseDirectory, rop);
+			}
+			
+			return combine;
+		}
+		
+		protected override DataNode ReadChild (XmlReader reader, DataItem parent)
+		{
+			if (reader.LocalName == &quot;Entries&quot;) {
+				if (reader.IsEmptyElement) return null;
+				string basePath = Path.GetDirectoryName (file);
+				reader.ReadStartElement ();
+				while (MoveToNextElement (reader)) {
+					string nodefile = reader.GetAttribute (&quot;filename&quot;);
+					nodefile = Runtime.FileUtilityService.RelativeToAbsolutePath (basePath, nodefile);
+					combine.Entries.Add ((CombineEntry) Runtime.ProjectService.ReadFile (nodefile));
+					reader.Skip ();
+				}
+				reader.ReadEndElement ();
+				return null;
+			} else if (reader.LocalName == &quot;Configurations&quot;) {
+				DataItem item = base.ReadChild (reader, parent) as DataItem;
+				foreach (DataNode data in item.ItemData) {
+					DataItem conf = data as DataItem;
+					if (conf == null) continue;
+					Runtime.ProjectService.DataContext.SetTypeInfo (conf, typeof(CombineConfiguration));
+				}
+				return item;
+			}
+			
+			return base.ReadChild (reader, parent);
+		}
+	}
+	
+	class CombineReaderV2: XmlConfigurationReader, ICombineReader
+	{
+		DataSerializer serializer;
+		Combine combine = new Combine ();
+		
+		public CombineReaderV2 (DataSerializer serializer)
+		{
+			this.serializer = serializer;
+			combine.FileName = serializer.SerializationContext.BaseFile;
+		}
+		
+		public Combine ReadCombine (XmlReader reader)
+		{
+			DataItem data = (DataItem) Read (reader);
+			serializer.Deserialize (combine, data);
+			return combine;
+		}
+		
+		protected override DataNode ReadChild (XmlReader reader, DataItem parent)
+		{
+			if (reader.LocalName == &quot;Entries&quot;) {
+				if (reader.IsEmptyElement) return null;
+				string basePath = Path.GetDirectoryName (combine.FileName);
+				reader.ReadStartElement ();
+				while (MoveToNextElement (reader)) {
+					string nodefile = reader.GetAttribute (&quot;filename&quot;);
+					nodefile = Runtime.FileUtilityService.RelativeToAbsolutePath (basePath, nodefile);
+					combine.Entries.Add ((CombineEntry) Runtime.ProjectService.ReadFile (nodefile));
+					reader.Skip ();
+				}
+				reader.ReadEndElement ();
+				return null;
+			}
+			
+			return base.ReadChild (reader, parent);
+		}
+	}
+	
+	class CombineWriterV2: XmlConfigurationWriter
+	{
+		Combine combine;
+		DataSerializer serializer;
+		
+		public CombineWriterV2 (DataSerializer serializer)
+		{
+			this.serializer = serializer;
+		}
+
+		public void WriteCombine (XmlWriter writer, Combine combine)
+		{
+			this.combine = combine;
+			DataItem data = (DataItem) serializer.Serialize (combine, typeof(Combine));
+			Write (writer, data);
+		}
+		
+		protected override void WriteChildren (XmlWriter writer, DataItem item)
+		{
+			base.WriteChildren (writer, item);
+
+			writer.WriteStartElement (&quot;Entries&quot;);
+			foreach (CombineEntry entry in combine.Entries) {
+				writer.WriteStartElement (&quot;Entry&quot;);
+				writer.WriteAttributeString (&quot;filename&quot;, entry.RelativeFileName);
+				writer.WriteEndElement ();
+				Runtime.ProjectService.WriteFile (entry.FileName, entry);
+			}
+			writer.WriteEndElement ();
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/Combine.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/Combine.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/Combine.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -28,24 +28,31 @@
 using MonoDevelop.Services;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Core.Properties;
-using MonoDevelop.Gui;
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Gui.Widgets;
+using MonoDevelop.Internal.Serialization;
 
 namespace MonoDevelop.Internal.Project
 {
-	public class Combine : LocalizedObject, IDisposable
+	[DataInclude (typeof(CombineConfiguration))]
+	public class Combine : CombineEntry
 	{
-		string name        = null;
+		[ItemProperty (&quot;description&quot;, DefaultValue = &quot;&quot;)]
 		string description = null;
 		
-		/// &lt;summary&gt;
-		/// name of the project to startup in singlestartup mode.
-		/// &lt;/summary&gt;
+		[ItemProperty (&quot;StartMode/startupentry&quot;)]
 		string startProject  = null;
+		
+		[ItemProperty (&quot;StartMode/single&quot;)]
 		bool   singleStartup = true;
+		
+		[ExpandedCollection]
+		[ItemProperty (&quot;StartMode/Execute&quot;, ValueType = typeof(CombineExecuteDefinition))]
+		ArrayList combineExecuteDefinitions = new ArrayList();
+		
 		bool   eventsAllowed = true;
-		string path          = null;
+		
+		[ProjectPathItemProperty (&quot;outputpath&quot;)]
 		string outputdir     = null;
 		
 		ProjectFileEventHandler fileAddedToProjectHandler;
@@ -55,41 +62,12 @@
 		ProjectReferenceEventHandler referenceAddedToProjectHandler;
 		ProjectReferenceEventHandler referenceRemovedFromProjectHandler;
 		
-		CombineEntryCollection entries = new CombineEntryCollection();
+		CombineEntryCollection entries;
 		
-		CombineConfiguration activeConfiguration;
-		
-		Hashtable configurations            = new Hashtable();
-		ArrayList combineExecuteDefinitions = new ArrayList();
-		
-		[LocalizedProperty(&quot;${res:MonoDevelop.Internal.Project.Combine.ActiveConfiguration}&quot;,
-		                   Description = &quot;${res:MonoDevelop.Internal.Project.Combine.ActiveConfiguration.Description}&quot;)]
-		[TypeConverter(typeof(CombineActiveConfigurationTypeConverter))]
-		public CombineConfiguration ActiveConfiguration {
-			get {
-				return activeConfiguration;
-			}
-			set {
-				activeConfiguration = value;
-			}
-		}
-		
 		[Browsable(false)]
-		public Hashtable Configurations {
+		public CombineEntryCollection Entries {
 			get {
-				return configurations;
-			}
-		}
-		
-		[Browsable(false)]
-		public ArrayList CombineExecuteDefinitions {
-			get {
-				return combineExecuteDefinitions;
-			}
-		}
-		[Browsable(false)]
-		public ICombineEntryCollection Entries {
-			get {
+				if (entries == null) entries = new CombineEntryCollection (this);
 				return entries;
 			}
 		}
@@ -100,6 +78,7 @@
 				return startProject;
 			}
 			set {
+				if (Entries [value] == null) throw new ArgumentException (&quot;Invalid entry name&quot;);
 				startProject = value;
 				OnStartupPropertyChanged(null);
 			}
@@ -115,37 +94,32 @@
 				OnStartupPropertyChanged(null);
 			}
 		}
-
+		
+		public ArrayList CombineExecuteDefinitions {
+			get {
+				return combineExecuteDefinitions;
+			}
+		}
+		
 		public string OutputDirectory 
 		{
 			get {
-				return outputdir;
+				if (outputdir == null) return DefaultOutputDirectory;
+				else return outputdir;
 			}
 			set {
-				outputdir = value;
+				if (value == DefaultOutputDirectory) outputdir = null;
+				else outputdir = value;
 			}
 		}
 		
-		public string BaseDirectory {
+		string DefaultOutputDirectory {
 			get {
-				return path;
+				return (BaseDirectory != null) ? Path.Combine (BaseDirectory, Path.Combine (&quot;build&quot;, &quot;bin&quot;)) : null;
 			}
 		}
+
 		
-		[LocalizedProperty(&quot;${res:MonoDevelop.Internal.Project.Combine.Name}&quot;,
-		                   Description =&quot;${res:MonoDevelop.Internal.Project.Combine.Name.Description}&quot;)]
-		public string Name {
-			get {
-				return name;
-			}
-			set {
-				if (name != value &amp;&amp; value != null &amp;&amp; value.Length &gt; 0) {
-					name = value;
-					OnNameChanged(EventArgs.Empty);
-				}
-			}
-		}
-		
 		[LocalizedProperty(&quot;${res:MonoDevelop.Internal.Project.Combine.Description}&quot;,
 		                   Description =&quot;${res:MonoDevelop.Internal.Project.Combine.Description.Description}&quot;)]
 		public string Description {
@@ -159,27 +133,14 @@
 		
 		[LocalizedProperty(&quot;${res:MonoDevelop.Internal.Project.Combine.NeedsBuilding}&quot;,
 		                   Description =&quot;${res:MonoDevelop.Internal.Project.Combine.NeedsBuilding.Description}&quot;)]
-		public bool NeedsBuilding {
+		public override bool NeedsBuilding {
 			get {
-				ArrayList projects = new ArrayList();
-				GetAllProjects(projects, this);
-				foreach (ProjectCombineEntry projectEntry in projects) {
-					if (projectEntry.IsDirty) {
-						return true;
-					}
-				}
+				foreach (CombineEntry entry in Entries)
+					if (entry.NeedsBuilding) return true;
 				return false;
 			}
-		}
-		
-		public void Dispose()
-		{
-			if (entries != null) {
-				foreach (object o in entries) {
-					if (o is IDisposable) {
-						((IDisposable)o).Dispose();
-					}
-				}
+			set {
+				// Ignore
 			}
 		}
 		
@@ -192,190 +153,74 @@
 			referenceRemovedFromProjectHandler = new ProjectReferenceEventHandler (NotifyReferenceRemovedFromProject);
 		}
 		
-		public Combine(string filename)
+		internal void NotifyEntryAdded (CombineEntry entry)
 		{
-			LoadCombine(filename);
-		}
-		
-		public IProject LoadProject(string filename)
-		{
-			ILanguageBinding binding = Runtime.Languages.GetBindingPerProjectFile(filename);
-			if (binding == null) {
-				Runtime.MessageService.ShowError(String.Format (GettextCatalog.GetString (&quot;Can't find language binding for {0}&quot;), filename));
-				return null;
-			}
+			if (startProject == null)
+				startProject = entry.Name;
 			
-			IProject project = binding.CreateProject(null, null);
-			project.LoadProject(filename);
-			return project;
-		}
-		
-		public void LoadCombine(string filename)
-		{
-			XmlDocument doc = new XmlDocument();
-			doc.Load(filename);
-			path = Path.GetDirectoryName(filename);
-			
-			XmlElement root = doc.DocumentElement;
-			
-			name          = root.Attributes[&quot;name&quot;].InnerText;
-			description   = root.Attributes[&quot;description&quot;].InnerText;
-			
-			startProject   = root[&quot;StartMode&quot;].Attributes[&quot;startupentry&quot;].InnerText;
-			singleStartup  = Boolean.Parse(root[&quot;StartMode&quot;].Attributes[&quot;single&quot;].InnerText);
-			
-			XmlNodeList nodes = root[&quot;Entries&quot;].ChildNodes;
-			entries.Clear();
-			FileUtilityService fileUtilityService = Runtime.FileUtilityService;
-			eventsAllowed = false;
-			try {
-				foreach (XmlElement el in nodes) {
-					string abs_path = fileUtilityService.RelativeToAbsolutePath(path, el.Attributes[&quot;filename&quot;].InnerText);
-					AddEntry(abs_path);
+			if (Configurations.Count == 0) {
+				foreach (IConfiguration pconf in entry.Configurations) {
+					if (pconf.Name == null)
+						continue;
+					CombineConfiguration cconf = new CombineConfiguration (pconf.Name);
+					Configurations.Add (cconf);
+					if (ActiveConfiguration == null)
+						ActiveConfiguration = cconf;
 				}
 			}
-			finally {
-				eventsAllowed = true;
-			}
 			
-			nodes = root[&quot;StartMode&quot;].ChildNodes;
-			combineExecuteDefinitions.Clear();
-			foreach (XmlElement el in nodes)  {
-				if (el.Name == &quot;Execute&quot;) {
-					CombineExecuteDefinition ced = new CombineExecuteDefinition();
-					ced.Entry = GetEntry(el.Attributes[&quot;entry&quot;].InnerText);
-					ced.Type = (EntryExecuteType)Enum.Parse(typeof(EntryExecuteType), el.Attributes[&quot;type&quot;].InnerText);
-					combineExecuteDefinitions.Add(ced);
-				}
-			}
+			foreach (CombineConfiguration conf in Configurations)
+				conf.AddEntry (entry);
+
+			combineExecuteDefinitions.Add (new CombineExecuteDefinition (entry, EntryExecuteType.None));
 			
-			nodes = root[&quot;Configurations&quot;].ChildNodes;
-			configurations.Clear();
-			foreach (XmlElement el in nodes) {
-				CombineConfiguration cconf = new CombineConfiguration(el, this);
-				configurations[cconf.Name] = cconf;
-				
-				// set the active configuration, either to the first (if the active attribute is not set)
-				// or to the active configuration specified by the active attribute.
-				if ((doc.DocumentElement[&quot;Configurations&quot;].Attributes[&quot;active&quot;] == null) || cconf.Name == doc.DocumentElement[&quot;Configurations&quot;].Attributes[&quot;active&quot;].InnerText) { // ok, I know that &amp;&amp; has a higher priority than ||, but many programmers think that a bracket is easier to read ... one thing I don't find easy to read are long lines :)
-					ActiveConfiguration = cconf;
-				}
-			}
+			if (eventsAllowed)
+				OnEntryAdded (new CombineEntryEventArgs (entry));
 
-			string mdCombineAddition = Path.ChangeExtension (filename, &quot;mdsx&quot;);
-			if (File.Exists (mdCombineAddition)) {
-				doc.Load (mdCombineAddition);
-				root = doc.DocumentElement;
-				if (root[&quot;RelativeOutputPath&quot;] != null &amp;&amp; root[&quot;RelativeOutputPath&quot;].InnerText != null) {
-					outputdir = fileUtilityService.RelativeToAbsolutePath(path, root[&quot;RelativeOutputPath&quot;].InnerText);
-				} else {
-					outputdir = Path.Combine (path, Path.Combine (&quot;build&quot;, &quot;bin&quot;));
-				}
-			} else {
-				outputdir = Path.Combine (path, Path.Combine (&quot;build&quot;, &quot;bin&quot;));
+			if (entry is Project)
+			{
+				Project project = entry as Project;
+				project.FileRemovedFromProject += fileAddedToProjectHandler;
+				project.FileAddedToProject += fileRemovedFromProjectHandler;
+				project.FileChangedInProject += fileChangedInProjectHandler;
+				project.ReferenceRemovedFromProject += referenceAddedToProjectHandler;
+				project.ReferenceAddedToProject += referenceRemovedFromProjectHandler;
 			}
+			else if (entry is Combine)
+			{
+				Combine combine = entry as Combine;
+				combine.FileRemovedFromProject += fileAddedToProjectHandler;
+				combine.FileAddedToProject += fileRemovedFromProjectHandler;
+				combine.FileChangedInProject += fileChangedInProjectHandler;
+				combine.ReferenceRemovedFromProject += referenceAddedToProjectHandler;
+				combine.ReferenceAddedToProject += referenceRemovedFromProjectHandler;
+			}
 		}
 		
-		public void SaveCombine(string filename)
+		public override void Deserialize (ITypeSerializer handler, DataCollection data)
 		{
-			XmlDocument doc = new XmlDocument();
-			doc.LoadXml(&quot;&lt;Combine fileversion=\&quot;1.0\&quot;/&gt;&quot;);
-			
-			XmlAttribute combineNameAttribute = doc.CreateAttribute(&quot;name&quot;);
-			combineNameAttribute.InnerText = name;
-			doc.DocumentElement.Attributes.Append(combineNameAttribute);
-			
-			XmlAttribute combineDescriptionAttribute = doc.CreateAttribute(&quot;description&quot;);
-			combineDescriptionAttribute.InnerText = description;
-			doc.DocumentElement.Attributes.Append(combineDescriptionAttribute);
-			
-			string path = Path.GetDirectoryName(filename);
-			
-			XmlElement startupnode  = doc.CreateElement(&quot;StartMode&quot;);
-			
-			XmlAttribute single = doc.CreateAttribute(&quot;startupentry&quot;);
-			single.InnerText  = startProject;
-			startupnode.Attributes.Append(single);
-			
-			XmlAttribute activeconf = doc.CreateAttribute(&quot;single&quot;);
-			activeconf.InnerText = singleStartup.ToString();
-			startupnode.Attributes.Append(activeconf);
-			
-			foreach (CombineExecuteDefinition ced in combineExecuteDefinitions) {
-				XmlElement el = doc.CreateElement(&quot;Execute&quot;);
-				
-				XmlAttribute a1 = doc.CreateAttribute(&quot;entry&quot;);
-				CombineEntry centry = ced.Entry;
-				if (centry == null || centry.Entry == null) {
-					continue;
-				}
-				if (centry.Entry is IProject) {
-					a1.InnerText  = ((IProject)centry.Entry).Name;
-				} else {
-					a1.InnerText  = ((Combine)centry.Entry).Name;
-				}
-				el.Attributes.Append(a1);
-				
-				XmlAttribute a2 = doc.CreateAttribute(&quot;type&quot;);
-				a2.InnerText  = ced.Type.ToString();
-				el.Attributes.Append(a2);
-				
-				startupnode.AppendChild(el);
-			}
-			
-			doc.DocumentElement.AppendChild(startupnode);
-						
-			XmlElement projectsnode = doc.CreateElement(&quot;Entries&quot;);
-			FileUtilityService fileUtilityService = Runtime.FileUtilityService;
-			
-			foreach (CombineEntry entry in entries) {
-				XmlElement el = doc.CreateElement(&quot;Entry&quot;);
-	
-				XmlAttribute entrynameattr = doc.CreateAttribute(&quot;filename&quot;);
-				entrynameattr.InnerText = fileUtilityService.AbsoluteToRelativePath(path, entry.Filename);
-				el.Attributes.Append(entrynameattr);
-				
-				projectsnode.AppendChild(el);
-			}
-			doc.DocumentElement.AppendChild(projectsnode);
-			
-			XmlElement confnode = doc.CreateElement(&quot;Configurations&quot;);
-			
-			if (ActiveConfiguration != null) {
-				XmlAttribute activeconfattr = doc.CreateAttribute(&quot;active&quot;);
-				activeconfattr.InnerText = ActiveConfiguration.Name;
-				confnode.Attributes.Append(activeconfattr);
-			}
-			foreach (DictionaryEntry dentry in configurations) {
-				confnode.AppendChild(((CombineConfiguration)dentry.Value).ToXmlElement(doc));
-			}
-			doc.DocumentElement.AppendChild(confnode);
-			
-			fileUtilityService.ObservedSave(new NamedFileOperationDelegate(doc.Save),
-			                                filename,
-			                                GettextCatalog.GetString (&quot;Can't save solution\nPlease check your file and directory permissions.&quot;),
-											FileErrorPolicy.ProvideAlternative);
+			base.Deserialize (handler, data);
 
-			doc = new XmlDocument ();
-			doc.LoadXml (&quot;&lt;MonoDevelopSolution fileversion=\&quot;1.0\&quot;/&gt;&quot;);
-			XmlElement outputElement = doc.CreateElement (&quot;RelativeOutputPath&quot;);
-			outputElement.InnerText = fileUtilityService.AbsoluteToRelativePath(path, outputdir);
+			foreach (CombineExecuteDefinition ced in combineExecuteDefinitions)
+				ced.SetCombine (this);
 			
-			doc.DocumentElement.AppendChild (outputElement);
-			fileUtilityService.ObservedSave (new NamedFileOperationDelegate (doc.Save),
-											 Path.ChangeExtension (filename, &quot;mdsx&quot;),
-											 GettextCatalog.GetString (&quot;Can't save solution\nPlease check your file and directory permissions.&quot;),
-											 FileErrorPolicy.ProvideAlternative);
-			
+			foreach (CombineConfiguration conf in Configurations)
+				conf.SetCombine (this);
 		}
+
+		public override void Save ()
+		{
+			base.Save ();
+			GenerateMakefiles ();
+		}
 		
-		public void SaveCombineAs()
+		public void SaveCombineAs ()
 		{
 			using (FileSelector fdiag = new FileSelector (GettextCatalog.GetString (&quot;Save Combine As...&quot;))) {
 				//fdiag.Filename = System.Environment.GetEnvironmentVariable (&quot;HOME&quot;);
 				if (fdiag.Run() == (int)Gtk.ResponseType.Ok) {
 					string filename = fdiag.Filename;
-					SaveCombine(filename);
+					Save (filename);
 					Runtime.MessageService.ShowMessage(filename, GettextCatalog.GetString (&quot;Combine saved&quot;));
 				}
 				
@@ -383,157 +228,53 @@
 			}
 		}
 
-		public object AddEntry(string filename)
+		public CombineEntry AddEntry (string filename)
 		{
-			if (Path.GetExtension(filename).ToUpper() == &quot;.PRJX&quot;) {
-				IProject project = LoadProject(filename);
-				ProjectCombineEntry newEntry = new ProjectCombineEntry(project, filename);
-				entries.Add(newEntry);
-				combineExecuteDefinitions.Add(new CombineExecuteDefinition(newEntry, EntryExecuteType.None));
-				if (startProject == null)
-					startProject = project.Name;
-				
-				if (configurations.Count == 0) {
-					foreach (IConfiguration pconf in project.Configurations) {
-						if (pconf.Name == null)
-							continue;
-						CombineConfiguration cconf = new CombineConfiguration(pconf.Name, this);
-						configurations[pconf.Name] = cconf;
-						if (ActiveConfiguration == null)
-							ActiveConfiguration = cconf;
-					}
-				}
-				
-				foreach (DictionaryEntry entry in configurations) {
-					CombineConfiguration conf = (CombineConfiguration)entry.Value;
-					conf.AddEntry(project);
-				}
-				if (eventsAllowed)
-					OnEntryAdded (new CombineEntryEventArgs (this, newEntry));
-				
-				newEntry.Project.FileRemovedFromProject += fileAddedToProjectHandler;
-				newEntry.Project.FileAddedToProject += fileRemovedFromProjectHandler;
-				newEntry.Project.FileChangedInProject += fileChangedInProjectHandler;
-				newEntry.Project.ReferenceRemovedFromProject += referenceAddedToProjectHandler;
-				newEntry.Project.ReferenceAddedToProject += referenceRemovedFromProjectHandler;
-					
-				return project;
-			} else {
-				Combine combine = new Combine(filename);
-				CombineCombineEntry newEntry = new CombineCombineEntry(combine, filename);
-				entries.Add(newEntry);
-				combineExecuteDefinitions.Add(new CombineExecuteDefinition(newEntry, EntryExecuteType.None));
-				if (startProject == null)
-					startProject = combine.Name;
-				
-				if (configurations.Count == 0) {
-					foreach (DictionaryEntry dentry in combine.Configurations) {
-						CombineConfiguration cconf = ((CombineConfiguration)dentry.Value);
-						configurations[cconf.Name] = new CombineConfiguration(cconf.Name, this);
-						if (ActiveConfiguration == null)
-							ActiveConfiguration = cconf;
-					}
-				}
-				
-				foreach (DictionaryEntry entry in configurations) {
-					CombineConfiguration conf = (CombineConfiguration)entry.Value;
-					conf.AddEntry(combine);
-				}
-				if (eventsAllowed)
-					OnEntryAdded (new CombineEntryEventArgs (this, newEntry));
-					
-				newEntry.Combine.FileRemovedFromProject += fileAddedToProjectHandler;
-				newEntry.Combine.FileAddedToProject += fileRemovedFromProjectHandler;
-				newEntry.Combine.FileChangedInProject += fileChangedInProjectHandler;
-				newEntry.Combine.ReferenceRemovedFromProject += referenceAddedToProjectHandler;
-				newEntry.Combine.ReferenceAddedToProject += referenceRemovedFromProjectHandler;
-				
-				return combine;
-			}
+			CombineEntry entry = Runtime.ProjectService.ReadFile (filename);
+			Entries.Add (entry);
+			return entry;
 		}
-		
+
 		public void RemoveEntry (CombineEntry entry)
 		{
-			ProjectCombineEntry pce = entry as ProjectCombineEntry;
+			Project pce = entry as Project;
 			if (pce != null) {
-				pce.Project.FileRemovedFromProject -= fileAddedToProjectHandler;
-				pce.Project.FileAddedToProject -= fileRemovedFromProjectHandler;
-				pce.Project.FileChangedInProject -= fileChangedInProjectHandler;
-				pce.Project.ReferenceRemovedFromProject -= referenceAddedToProjectHandler;
-				pce.Project.ReferenceAddedToProject -= referenceRemovedFromProjectHandler;
+				pce.FileRemovedFromProject -= fileAddedToProjectHandler;
+				pce.FileAddedToProject -= fileRemovedFromProjectHandler;
+				pce.FileChangedInProject -= fileChangedInProjectHandler;
+				pce.ReferenceRemovedFromProject -= referenceAddedToProjectHandler;
+				pce.ReferenceAddedToProject -= referenceRemovedFromProjectHandler;
 			}
 			else {
-				CombineCombineEntry cce = entry as CombineCombineEntry;
+				Combine cce = entry as Combine;
 				if (cce != null) {
-					cce.Combine.FileRemovedFromProject -= fileAddedToProjectHandler;
-					cce.Combine.FileAddedToProject -= fileRemovedFromProjectHandler;
-					cce.Combine.FileChangedInProject -= fileChangedInProjectHandler;
-					cce.Combine.ReferenceRemovedFromProject -= referenceAddedToProjectHandler;
-					cce.Combine.ReferenceAddedToProject -= referenceRemovedFromProjectHandler;
+					cce.FileRemovedFromProject -= fileAddedToProjectHandler;
+					cce.FileAddedToProject -= fileRemovedFromProjectHandler;
+					cce.FileChangedInProject -= fileChangedInProjectHandler;
+					cce.ReferenceRemovedFromProject -= referenceAddedToProjectHandler;
+					cce.ReferenceAddedToProject -= referenceRemovedFromProjectHandler;
 				}
 			}
 				
-			entries.Remove (entry);
-			OnEntryRemoved (new CombineEntryEventArgs (this, entry));
+			Entries.Remove (entry);
+			OnEntryRemoved (new CombineEntryEventArgs (entry));
 		}
 		
-		public void SaveAllProjects()
+		public override void Debug ()
 		{
-			foreach (CombineEntry entry in entries) {
-				entry.Save();
-			}
-		}
-		
-		public int GetEntryNumber(string name)
-		{
-			for (int i = 0; i &lt; entries.Count; ++i) {
-				if (((CombineEntry)entries[i]).Name == name) {
-					return i;		
-				}
-			}
-			return -1;
-		}
-		
-		public CombineEntry GetEntry(string name)
-		{
-			for (int i = 0; i &lt; entries.Count; ++i) {
-				if (((CombineEntry)entries[i]).Name == name) {
-					return (CombineEntry)entries[i];
-				}
-			}
-			return null;
-		}
-		
-		void StartProject(int  nr) 
-		{
-			CombineEntry entry = (CombineEntry)entries[nr];
-			entry.Execute();
-		}
-		
-		void StartProject(string name) 
-		{
-			int entrynum = GetEntryNumber(name);
-			if (entrynum == -1) {
-				throw new NoStartupCombineDefinedException();
-			}
-			StartProject(entrynum);
-		}
-
-		public void Debug ()
-		{
-			CombineEntry entry = (CombineEntry)entries[GetEntryNumber (startProject)];
+			CombineEntry entry = Entries [startProject];
 			entry.Debug ();
 		}
 
-		public void Execute()
+		public override void Execute()
 		{
 			if (singleStartup) {
-				StartProject(startProject);
+				CombineEntry entry = (CombineEntry) Entries [startProject];
+				entry.Execute();
 			} else {
 				foreach (CombineExecuteDefinition ced in combineExecuteDefinitions) {
-					if (ced.Type == EntryExecuteType.Execute) {
-						StartProject(entries.IndexOf(ced.Entry));
-					}
+					if (ced.Type == EntryExecuteType.Execute)
+						ced.Entry.Execute ();
 				}
 			}
 		}
@@ -542,43 +283,38 @@
 		/// Returns an ArrayList containing all ProjectEntries in this combine and 
 		/// undercombines
 		/// &lt;/remarks&gt;
-		public static ArrayList GetAllProjects(Combine combine)
+		public CombineEntryCollection GetAllProjects ()
 		{
-			ArrayList list = new ArrayList();
-			GetAllProjects(list, combine);
+			CombineEntryCollection list = new CombineEntryCollection();
+			GetAllProjects (list);
 			return list;
 		}
 		
-		static void GetAllProjects(ArrayList list, Combine combine)
+		void GetAllProjects (CombineEntryCollection list)
 		{
-			if (combine != null &amp;&amp; combine.Entries != null) {
-				foreach (CombineEntry entry in combine.Entries) {
-					if (entry is ProjectCombineEntry) {
-						list.Add((ProjectCombineEntry)entry);
-					} else {
-						GetAllProjects(list, ((CombineCombineEntry)entry).Combine);
-					}
+			foreach (CombineEntry entry in Entries) {
+				if (entry is Project) {
+					list.Add (entry);
+				} else if (entry is Combine) {
+					((Combine)entry).GetAllProjects (list);
 				}
-			} else {
-				Console.WriteLine(&quot;combine or combine.Entries == null&quot;);
 			}
 		}
 		
-		public ProjectCombineEntry GetProjectEntryContaining(string fileName) 
+		public Project GetProjectEntryContaining (string fileName) 
 		{
-			ArrayList projects = new ArrayList();
-			GetAllProjects(projects, this);
-			foreach (ProjectCombineEntry projectEntry in projects) {
-				if (projectEntry.Project.IsFileInProject(fileName)) {
+			CombineEntryCollection projects = GetAllProjects ();
+			foreach (Project projectEntry in projects) {
+				if (projectEntry.IsFileInProject(fileName)) {
 					return projectEntry;
 				}
 			}
 			return null;
 		}
 		
-		ArrayList TopologicalSort(ArrayList allProjects)
+		CombineEntryCollection TopologicalSort (CombineEntryCollection allProjects)
 		{
-			ArrayList sortedEntries = new ArrayList(allProjects.Count);
+			CombineEntryCollection sortedEntries = new CombineEntryCollection ();
 			bool[]    inserted      = new bool[allProjects.Count];
 			bool[]    triedToInsert = new bool[allProjects.Count];
 			for (int i = 0; i &lt; allProjects.Count; ++i) {
@@ -592,17 +328,17 @@
 			return sortedEntries;
 		}
 		
-		void Insert(int index, ArrayList allProjects, ArrayList sortedEntries, bool[] inserted, bool[] triedToInsert)
+		void Insert(int index, CombineEntryCollection allProjects, CombineEntryCollection sortedEntries, bool[] inserted, bool[] triedToInsert)
 		{
 			if (triedToInsert[index]) {
 				throw new CyclicBuildOrderException();
 			}
 			triedToInsert[index] = true;
-			foreach (ProjectReference reference in ((ProjectCombineEntry)allProjects[index]).Project.ProjectReferences) {
+			foreach (ProjectReference reference in ((Project)allProjects[index]).ProjectReferences) {
 				if (reference.ReferenceType == ReferenceType.Project) {
 					int j = 0;
 					for (; j &lt; allProjects.Count; ++j) {
-						if (reference.Reference == ((ProjectCombineEntry)allProjects[j]).Name) {
+						if (reference.Reference == ((Project)allProjects[j]).Name) {
 							if (!inserted[j]) {
 								Insert(j, allProjects, sortedEntries, inserted, triedToInsert);
 							}
@@ -615,40 +351,55 @@
 			inserted[index] = true;
 		}
 		
-		public void Build(bool doBuildAll)
+		public override void Clean ()
 		{
-			ArrayList allProjects = GetAllProjects(this);
+			foreach (CombineEntry entry in Entries)
+				entry.Clean ();
+		}
+		
+		public override void Build ()
+		{
+			CombineEntryCollection allProjects = GetAllProjects ();
 			try {
 				allProjects = TopologicalSort(allProjects);
 			} catch (CyclicBuildOrderException) {
 				Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;Cyclic dependencies can not be built with this version.\nBut we are working on it.&quot;));
 				return;
 			}
-			foreach (ProjectCombineEntry entry in allProjects) {
-				entry.Build(doBuildAll);
+			foreach (Project entry in allProjects) {
+				entry.Build ();
 				if (Runtime.TaskService.Errors &gt; 0) {
 					break;
 				}
 			}
 		}
 
+		public override string GetOutputFileName ()
+		{
+			return String.Empty;
+		}
+		
 		public void GenerateMakefiles ()
 		{
-			ArrayList allProjects = TopologicalSort (GetAllProjects (this));
+			GenerateMakefiles (null);
+		}
+
+		public override void GenerateMakefiles (Combine parentCombine)
+		{
+			CombineEntryCollection allProjects = TopologicalSort (GetAllProjects ());
 			ArrayList projects = new ArrayList ();
 			foreach (CombineEntry entry in allProjects) {
-				if (entry is ProjectCombineEntry) {
+				if (entry is Project) {
 					entry.GenerateMakefiles (this);
-					projects.Add (((ProjectCombineEntry)entry).Project);
+					projects.Add ((Project)entry);
 				}
 				else
 					Console.WriteLine (&quot;Dont know how to generate makefiles for &quot; + entry);
 			}
 			
-			FileUtilityService fileUtilityService = Runtime.FileUtilityService;
-			string rel_outputdir = fileUtilityService.AbsoluteToRelativePath (path, outputdir);
+			string rel_outputdir = Runtime.FileUtilityService.AbsoluteToRelativePath (BaseDirectory, outputdir);
 			
-			StreamWriter buildstream = new StreamWriter (Path.Combine (path, &quot;make.sh&quot;));
+			StreamWriter buildstream = new StreamWriter (Path.Combine (BaseDirectory, &quot;make.sh&quot;));
 			buildstream.WriteLine (&quot;#!/bin/sh&quot;);
 			buildstream.WriteLine (&quot;# This file is autogenerated by MonoDevelop&quot;);
 			buildstream.WriteLine (&quot;# Do not edit it.&quot;);
@@ -657,9 +408,9 @@
 			buildstream.Flush ();
 			buildstream.Close ();
 			
-			Syscall.chmod (Path.Combine (path, &quot;make.sh&quot;), FileMode.S_IRUSR | FileMode.S_IWUSR | FileMode.S_IXUSR | FileMode.S_IRGRP | FileMode.S_IWGRP | FileMode.S_IROTH);
+			Syscall.chmod (Path.Combine (BaseDirectory, &quot;make.sh&quot;), FileMode.S_IRUSR | FileMode.S_IWUSR | FileMode.S_IXUSR | FileMode.S_IRGRP | FileMode.S_IWGRP | FileMode.S_IROTH);
 
-			StreamWriter stream = new StreamWriter (Path.Combine (path, &quot;Makefile.solution.&quot; + Name.Replace (&quot; &quot;, &quot;&quot;)));
+			StreamWriter stream = new StreamWriter (Path.Combine (BaseDirectory, &quot;Makefile.solution.&quot; + Name.Replace (&quot; &quot;, &quot;&quot;)));
 			stream.WriteLine (&quot;# This file is autogenerated by MonoDevelop&quot;);
 			stream.WriteLine (&quot;# Do not edit it.&quot;);
 			stream.WriteLine ();
@@ -669,7 +420,7 @@
 			stream.WriteLine (&quot;OUTPUTDIR := {0}&quot;, rel_outputdir);
 			stream.WriteLine ();
 			stream.Write (&quot;all: depcheck __init &quot;);
-			foreach (IProject proj in projects) {
+			foreach (Project proj in projects) {
 				stream.Write (&quot;Makefile.{0}.all &quot;, proj.Name.Replace (&quot; &quot;,&quot;&quot;));
 			}
 			stream.WriteLine ();
@@ -680,14 +431,14 @@
 			stream.WriteLine ();
 
 			stream.Write (&quot;clean: &quot;);
-			foreach (IProject proj in projects) {
+			foreach (Project proj in projects) {
 				stream.Write (&quot;Makefile.{0}.clean &quot;, proj.Name.Replace (&quot; &quot;, &quot;&quot;));
 			}
 			stream.WriteLine ();
 			stream.WriteLine ();
 
 			stream.Write (&quot;depcheck: &quot;);
-			foreach (IProject proj in projects) {
+			foreach (Project proj in projects) {
 				stream.Write (&quot;Makefile.{0}.depcheck &quot;, proj.Name.Replace (&quot; &quot;, &quot;&quot;));
 			}
 			stream.WriteLine ();
@@ -697,15 +448,15 @@
 			if (!SingleStartupProject) {
 				stream.WriteLine (&quot;\<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">t at echo</A> `run'ning multiple startup projects is not yet support&quot;);
 			} else {
-				if (SingleStartProjectName != null &amp;&amp; GetEntry (SingleStartProjectName) != null)
-					stream.WriteLine (&quot;\tcd $(OUTPUTDIR) &amp;&amp; $(RUNTIME) {0}&quot;, GetEntry (SingleStartProjectName).GetOutputName ());
+				if (SingleStartProjectName != null &amp;&amp; Entries [SingleStartProjectName] != null)
+					stream.WriteLine (&quot;\tcd $(OUTPUTDIR) &amp;&amp; $(RUNTIME) {0}&quot;, Entries [SingleStartProjectName].GetOutputFileName ());
 				else
 					stream.WriteLine (&quot;\<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">t at echo</A> No startup project defined&quot;);
 			}
 			stream.WriteLine ();
 
-			foreach (IProject proj in projects) {
-				string relativeLocation = fileUtilityService.AbsoluteToRelativePath (path, proj.BaseDirectory);
+			foreach (Project proj in projects) {
+				string relativeLocation = Runtime.FileUtilityService.AbsoluteToRelativePath (BaseDirectory, proj.BaseDirectory);
 				stream.WriteLine (&quot;Makefile.{0}.%:&quot;, proj.Name.Replace (&quot; &quot;, &quot;&quot;));
 				stream.WriteLine (&quot;\<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">t at cd</A> {0} &amp;&amp; $(MAKE) -f $(subst .$*,,$@) $*&quot;, relativeLocation);
 				stream.WriteLine ();
@@ -747,14 +498,6 @@
 			}
 		}
 			
-		
-		protected virtual void OnNameChanged(EventArgs e)
-		{
-			if (NameChanged != null) {
-				NameChanged(this, e);
-			}
-		}
-		
 		protected virtual void OnEntryAdded(CombineEntryEventArgs e)
 		{
 			if (EntryAdded != null) {
@@ -804,7 +547,6 @@
 			}
 		}
 
-		public event EventHandler NameChanged;
 		public event EventHandler StartupPropertyChanged;
 		public event CombineEntryEventHandler EntryAdded;
 		public event CombineEntryEventHandler EntryRemoved;
@@ -830,7 +572,7 @@
 		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture,  object value)
 		{
 			Combine combine = (Combine)context.Instance;
-			foreach (IConfiguration configuration in combine.Configurations.Values) {
+			foreach (IConfiguration configuration in combine.Configurations) {
 				if (configuration.Name == value.ToString()) {
 					return configuration;
 				}
@@ -860,7 +602,7 @@
 		
 		public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context)
 		{
-			return new TypeConverter.StandardValuesCollection(((Combine)context.Instance).Configurations.Values);
+			return new TypeConverter.StandardValuesCollection(((Combine)context.Instance).Configurations);
 		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineConfiguration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineConfiguration.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineConfiguration.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,80 +14,80 @@
 using System.CodeDom.Compiler;
 
 using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Serialization;
 
 using MonoDevelop.Core.Properties;
 using MonoDevelop.Gui;
 
 namespace MonoDevelop.Internal.Project
 {
-	public class CombineConfiguration : AbstractConfiguration, IXmlConvertable
+	public class CombineConfiguration : AbstractConfiguration
 	{
+		[ExpandedCollection]
+		[ItemProperty (&quot;Entry&quot;, ValueType=typeof(Config))]
 		ArrayList configurations = new ArrayList();
-		Combine combine;
 		
+		[DataItem (&quot;Entry&quot;)]
 		public class Config 
 		{
-			public CombineEntry Entry;
-			public string       ConfigurationName;
-			public bool         Build;
+			[ItemProperty (&quot;name&quot;)]
+			string entryName;
+			
+			public CombineEntry entry;
+			
+			[ItemProperty (&quot;configurationname&quot;)]
+			public string ConfigurationName;
+			
+			[ItemProperty (&quot;build&quot;)]
+			public bool Build;
+			
+			public CombineEntry Entry {
+				get { return entry; }
+				set { entry = value; if (entry != null) entryName = entry.Name; }
+			}
+			
+			internal void SetCombine (Combine combine)
+			{
+				if (entryName != null)
+					Entry = combine.Entries [entryName];
+			}
 		}
 		
-		public Config GetConfiguration(int number)
+		public CombineConfiguration ()
 		{
-			if (number &lt; configurations.Count) {
-				return (Config)configurations[number];
-			} 
-			Debug.Assert(false, &quot;Configuration number &quot; + number + &quot; not found.\n&quot; + configurations.Count + &quot; configurations avaiable.&quot;);
-			return null;
 		}
 		
-		public CombineConfiguration(string name, Combine combine)
+		public CombineConfiguration (string name)
 		{
-			this.combine = combine;
-			this.Name    = name;
+			this.Name = name;
 		}
 		
-		public CombineConfiguration(XmlElement element, Combine combine)
+		internal void SetCombine (Combine combine)
 		{
-			this.combine = combine;
-			Name        = element.Attributes[&quot;name&quot;].InnerText;
-			
-			XmlNodeList nodes = element.ChildNodes;
-			foreach (XmlElement confignode in nodes) {
-				Config config = new Config();
-				
-				config.Entry             = combine.GetEntry(confignode.Attributes[&quot;name&quot;].InnerText);
-				config.ConfigurationName = confignode.Attributes[&quot;configurationname&quot;].InnerText;
-				config.Build             = Boolean.Parse(confignode.Attributes[&quot;build&quot;].InnerText);
-					
-				configurations.Add(config);
-			}
+			foreach (Config conf in configurations)
+				conf.SetCombine (combine);
 		}
 		
-		public void AddEntry(IProject project)
+		public Config GetConfiguration(int number)
 		{
-			Config conf = new Config();
-			conf.Entry             = combine.GetEntry(project.Name);
-			conf.ConfigurationName = project.ActiveConfiguration.Name;
-			conf.Build             = false;
-			configurations.Add(conf);
+			if (number &lt; configurations.Count) {
+				return (Config)configurations[number];
+			} 
+			Debug.Assert(false, &quot;Configuration number &quot; + number + &quot; not found.\n&quot; + configurations.Count + &quot; configurations avaiable.&quot;);
+			return null;
 		}
-		public void AddEntry(Combine  combine)
+		
+		public void AddEntry (CombineEntry combine)
 		{
 			Config conf = new Config();
-			conf.Entry             = this.combine.GetEntry(combine.Name);
+			conf.Entry = combine;
 			conf.ConfigurationName = combine.ActiveConfiguration != null ? combine.ActiveConfiguration.Name : String.Empty;
-			conf.Build             = false;
+			conf.Build = false;
 			configurations.Add(conf);
 		}
 		
-		public object FromXmlElement(XmlElement element)
+		public void RemoveEntry (CombineEntry entry)
 		{
-			return null;
-		}
-		
-		public void RemoveEntry(CombineEntry entry)
-		{
 			Config removeConfig = null;
 			
 			foreach (Config config in configurations) {
@@ -100,39 +100,5 @@
 			Debug.Assert(removeConfig != null);
 			configurations.Remove(removeConfig);
 		}
-		
-		public XmlElement ToXmlElement(XmlDocument doc)
-		{
-			if (combine == null) 
-				throw new ApplicationException(&quot;combine can't be null&quot;);
-			
-			XmlElement cel = doc.CreateElement(&quot;Configuration&quot;);
-			
-			XmlAttribute nameattr = doc.CreateAttribute(&quot;name&quot;);
-			nameattr.InnerText = Name;
-			cel.Attributes.Append(nameattr);
-			
-			foreach (Config config in configurations) {
-				if (config == null || config.Entry == null) {
-					continue;
-				}
-				XmlElement el = doc.CreateElement(&quot;Entry&quot;);
-				
-				XmlAttribute attr1 = doc.CreateAttribute(&quot;name&quot;);
-				attr1.InnerText = config.Entry.Name;
-				el.Attributes.Append(attr1);
-				
-				XmlAttribute attr2 = doc.CreateAttribute(&quot;configurationname&quot;);
-				attr2.InnerText = config.ConfigurationName;
-				el.Attributes.Append(attr2);
-				
-				XmlAttribute attr3 = doc.CreateAttribute(&quot;build&quot;);
-				attr3.InnerText = config.Build.ToString();
-				el.Attributes.Append(attr3);
-				
-				cel.AppendChild(el);
-			}
-			return cel;
-		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntry.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntry.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntry.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -16,257 +16,187 @@
 using MonoDevelop.Core.Properties;
 using MonoDevelop.Core.Services;
 using MonoDevelop.Gui;
+using MonoDevelop.Gui.Components;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Services;
+using MonoDevelop.Internal.Serialization;
 
 namespace MonoDevelop.Internal.Project
 {
-	public abstract class CombineEntry : IDisposable
+	public abstract class CombineEntry : ICustomDataItem, IDisposable
 	{
 		public static int BuildProjects = 0;
 		public static int BuildErrors   = 0;
 		
-		object    entry;
+		[ItemProperty (&quot;Configurations&quot;)]
+		[ItemProperty (&quot;Configuration&quot;, ValueType=typeof(IConfiguration), Scope=1)]
+		ArrayList configurations = new ArrayList();
+
+		Combine parentCombine;
+		IConfiguration activeConfiguration;
+		string name;
+		string path;
 		
-		ArrayList dependencies = new ArrayList();
+		IFileFormat fileFormat;
 		
-		string    filename;
-		public string Filename {
+		public event CombineEntryRenamedEventHandler NameChanged;
+		
+		[ItemProperty (&quot;name&quot;)]
+		public virtual string Name {
 			get {
-				return filename;
+				return name;
 			}
 			set {
-				filename = value;
+				if (name != value &amp;&amp; value != null &amp;&amp; value.Length &gt; 0) {
+					string oldName = name;
+					name = value;
+					OnNameChanged (new CombineEntryRenamedEventArgs (this, oldName, name));
+				}
 			}
 		}
 		
-		public abstract string Name {
-			get;
-		}
-		
-		public object Entry {
+		public virtual string FileName {
 			get {
-				return entry;
+				if (parentCombine != null &amp;&amp; path != null)
+					return parentCombine.GetAbsoluteChildPath (path);
+				else
+					return path;
 			}
+			set {
+				if (parentCombine != null &amp;&amp; path != null)
+					path = parentCombine.GetRelativeChildPath (value);
+				else
+					path = value;
+			}
 		}
 		
-		public CombineEntry(object entry, string filename)
-		{
-			this.entry = entry;
-			this.filename = filename;
+		public virtual IFileFormat FileFormat {
+			get { return fileFormat; }
+			set { fileFormat = value; }
 		}
 		
-		public void Dispose()
-		{
-			if (entry is IDisposable) {
-				((IDisposable)entry).Dispose();
+		public virtual string RelativeFileName {
+			get {
+				if (path != null &amp;&amp; parentCombine != null)
+					return parentCombine.GetRelativeChildPath (path);
+				else
+					return path;
 			}
 		}
 		
-		public abstract void Build(bool doBuildAll);
-		public abstract void Execute();
-		public abstract void Save();
-		public abstract void Debug ();
-		public abstract void GenerateMakefiles (Combine parentCombine);
-		public abstract string GetOutputName ();
-	}
-	
-	public class ProjectCombineEntry : CombineEntry
-	{
-		IProject project;
-		bool     isDirty = true;
+		public string BaseDirectory {
+			get { return Path.GetDirectoryName (FileName); }
+		}
 		
-		public bool IsDirty {
-			get {
-				return isDirty;
-			}
-			set {
-				isDirty = value;
-			}
+		[ItemProperty (&quot;fileversion&quot;)]
+		protected virtual string CurrentFileVersion {
+			get { return &quot;2.0&quot;; }
+			set {}
 		}
 		
-		public IProject Project {
-			get {
-				return project;
-			}
+		public virtual void Save (string fileName)
+		{
+			FileName = fileName;
+			Save ();
 		}
 		
-		public override string Name {
-			get {
-				return project.Name;
-			}
+		public virtual void Save ()
+		{
+			Runtime.ProjectService.WriteFile (FileName, this);
 		}
 		
-		public ProjectCombineEntry(IProject project, string filename) : base(project, filename)
+		internal void SetParentCombine (Combine combine)
 		{
-			this.project = project;
+			parentCombine = combine;
 		}
 		
-				
-		public override void Build(bool doBuildAll)
-		{ // if you change something here look at the DefaultProjectService BeforeCompile method
-			if (doBuildAll || isDirty) {
-				Runtime.StringParserService.Properties[&quot;Project&quot;] = Name;
-				TaskService taskService = Runtime.TaskService;
-				
-				Runtime.Gui.StatusBar.SetMessage(String.Format (GettextCatalog.GetString (&quot;Compiling: {0}&quot;), Project.Name));
-				
-				// create output directory, if not exists
-				string outputDir = ((AbstractProjectConfiguration)project.ActiveConfiguration).OutputDirectory;
-				try {
-					DirectoryInfo directoryInfo = new DirectoryInfo(outputDir);
-					if (!directoryInfo.Exists) {
-						directoryInfo.Create();
-					}
-				} catch (Exception e) {
-					throw new ApplicationException(&quot;Can't create project output directory &quot; + outputDir + &quot; original exception:\n&quot; + e.ToString());
-				}
-				
-				ILanguageBinding csc = Runtime.Languages.GetBindingPerLanguageName(project.ProjectType);
-				
-				AbstractProjectConfiguration conf = project.ActiveConfiguration as AbstractProjectConfiguration;
-
-				taskService.CompilerOutput += String.Format (GettextCatalog.GetString (&quot;------ Build started: Project: {0} Configuration: {1} ------\n\nPerforming main compilation...\n&quot;), Project.Name, Project.ActiveConfiguration.Name);
-				
-				if (conf != null &amp;&amp; File.Exists(conf.ExecuteBeforeBuild)) {
-					taskService.CompilerOutput += String.Format (GettextCatalog.GetString (&quot;Execute : {0}&quot;), conf.ExecuteBeforeBuild);
-					ProcessStartInfo ps = new ProcessStartInfo(conf.ExecuteBeforeBuild);
-					ps.UseShellExecute = false;
-					ps.RedirectStandardOutput = true;
-					ps.WorkingDirectory = Path.GetDirectoryName(conf.ExecuteBeforeBuild);
-					Process process = new Process();
-					process.StartInfo = ps;
-					process.Start();
-					taskService.CompilerOutput += process.StandardOutput.ReadToEnd();
-				}
-				
-				ICompilerResult res = csc.CompileProject(project);
-				
-				if (conf != null &amp;&amp; File.Exists(conf.ExecuteAfterBuild)) {
-					taskService.CompilerOutput += String.Format (GettextCatalog.GetString (&quot;Execute : {0}&quot;), conf.ExecuteAfterBuild);
-					ProcessStartInfo ps = new ProcessStartInfo(conf.ExecuteAfterBuild);
-					ps.UseShellExecute = false;
-					ps.RedirectStandardOutput = true;
-					ps.WorkingDirectory = Path.GetDirectoryName(conf.ExecuteAfterBuild);
-					Process process = new Process();
-					process.StartInfo = ps;
-					process.Start();
-					taskService.CompilerOutput += process.StandardOutput.ReadToEnd();
-				}
-				
-				isDirty = false;
-				foreach (CompilerError err in res.CompilerResults.Errors) {
-					isDirty = true;
-					taskService.AddTask(new Task(project, err));
-				}
-				
-				if (taskService.Errors &gt; 0) {
-					++BuildErrors;
-				} else {
-					++BuildProjects;
-				}
-				
-				taskService.CompilerOutput += String.Format (GettextCatalog.GetString (&quot;Build complete -- {0} errors, {1} warnings\n\n&quot;), taskService.Errors.ToString (), taskService.Warnings.ToString ());
+		public ArrayList Configurations {
+			get {
+				return configurations;
 			}
 		}
 		
-		public override void Execute()
-		{
-			ILanguageBinding binding = Runtime.Languages.GetBindingPerLanguageName(project.ProjectType);
-			if (binding == null) {
-				throw new ApplicationException(&quot;can't find language binding for project &quot;);
-			}
-			
-			if (Runtime.TaskService.Errors == 0) {
-				if (Runtime.TaskService.Warnings == 0 || project.ActiveConfiguration != null &amp;&amp; ((AbstractProjectConfiguration)project.ActiveConfiguration).RunWithWarnings) {
-					project.CopyReferencesToOutputPath (true);
-					binding.Execute(project);
+		public IConfiguration ActiveConfiguration {
+			get {
+				if (activeConfiguration == null &amp;&amp; configurations.Count &gt; 0) {
+					return (IConfiguration)configurations[0];
 				}
+				return activeConfiguration;
 			}
-
+			set {
+				activeConfiguration = value;
+			}
 		}
-
-		public override void Debug ()
+		
+		public virtual DataCollection Serialize (ITypeSerializer handler)
 		{
-			ILanguageBinding binding = Runtime.Languages.GetBindingPerLanguageName (project.ProjectType);
-			if (binding == null) {
-				Console.WriteLine (&quot;Language binding unknown&quot;);
-				return;
+			DataCollection data = handler.Serialize (this);
+			if (activeConfiguration != null) {
+				DataItem confItem = data [&quot;Configurations&quot;] as DataItem;
+				confItem.UniqueNames = true;
+				if (confItem != null)
+					confItem.ItemData.Add (new DataValue (&quot;active&quot;, activeConfiguration.Name));
 			}
-			if (Runtime.TaskService.Errors == 0)
-				binding.DebugProject (project);
+			return data;
 		}
 		
-		public override void Save()
+		public virtual void Deserialize (ITypeSerializer handler, DataCollection data)
 		{
-			project.SaveProject(Filename);
+			DataValue ac = null;
+			DataItem confItem = data [&quot;Configurations&quot;] as DataItem;
+			if (confItem != null)
+				ac = (DataValue) confItem.ItemData.Extract (&quot;active&quot;);
+				
+			handler.Deserialize (this, data);
+			if (ac != null)
+				activeConfiguration = GetConfiguration (ac.Value);
 		}
-
-		public override void GenerateMakefiles (Combine parentCombine)
+		
+		public IConfiguration GetConfiguration (string name)
 		{
-			Console.WriteLine (&quot;Generating makefiles for &quot; + Name);
-			ILanguageBinding langBinding = Runtime.Languages.GetBindingPerLanguageName(project.ProjectType);
-			langBinding.GenerateMakefile (project, parentCombine);
+			if (configurations != null) {
+				foreach (IConfiguration conf in configurations)
+					if (conf.Name == name) return conf;
+			}
+			return null;
 		}
 
-		public override string GetOutputName ()
+		public string GetAbsoluteChildPath (string relPath)
 		{
-			ILanguageBinding langBinding = Runtime.Languages.GetBindingPerLanguageName (project.ProjectType);
-			return System.IO.Path.GetFileName (langBinding.GetCompiledOutputName (project));
+			if (Path.IsPathRooted (relPath))
+				return relPath;
+			else
+				return Runtime.FileUtilityService.RelativeToAbsolutePath (BaseDirectory, relPath);
 		}
-	}
-	
-	public class CombineCombineEntry : CombineEntry
-	{
-		Combine combine;
 		
-		public Combine Combine {
-			get {
-				return combine;
-			}
-		}
-		public override string Name {
-			get {
-				return combine.Name;
-			}
-		}
-		
-		public CombineCombineEntry(Combine combine, string filename) : base(combine, filename)
+		public string GetRelativeChildPath (string absPath)
 		{
-			this.combine = combine;
+			return Runtime.FileUtilityService.AbsoluteToRelativePath (BaseDirectory, absPath);
 		}
 		
-		public override void Build(bool doBuildAll)
+		public virtual void Dispose()
 		{
-			combine.Build(doBuildAll);
 		}
 		
-		public override void Execute()
+		protected virtual void OnNameChanged (CombineEntryRenamedEventArgs e)
 		{
-			combine.Execute();
+			if (NameChanged != null) {
+				NameChanged (this, e);
+			}
 		}
 		
-		public override void Save()
+		public abstract void Clean ();
+		public abstract void Build ();
+		public abstract void Execute();
+		public abstract void Debug ();
+		public abstract string GetOutputFileName ();
+		public abstract bool NeedsBuilding { get; set; }
+		
+		public virtual void GenerateMakefiles (Combine parentCombine)
 		{
-			combine.SaveCombine(System.IO.Path.GetFullPath (Filename));
-			combine.SaveAllProjects();
 		}
-
-		public override void Debug ()
-		{
-			combine.Debug ();
-		}
-
-		public override void GenerateMakefiles (Combine parentCombine)
-		{
-		}
-
-		public override string GetOutputName ()
-		{
-			return String.Empty;
-		}
+		
 	}
-
 	
 	public interface ICombineEntryCollection: IEnumerable
 	{
@@ -277,7 +207,17 @@
 	public class CombineEntryCollection: ICombineEntryCollection
 	{
 		ArrayList list = new ArrayList ();
+		Combine parentCombine;
 		
+		internal CombineEntryCollection ()
+		{
+		}
+		
+		internal CombineEntryCollection (Combine combine)
+		{
+			parentCombine = combine;
+		}
+		
 		public int Count
 		{
 			get { return list.Count; }
@@ -288,6 +228,16 @@
 			get { return (CombineEntry) list[n]; }
 		}
 		
+		public CombineEntry this [string name]
+		{
+			get {
+			for (int n=0; n&lt;list.Count; n++)
+				if (((CombineEntry)list[n]).Name == name)
+					return (CombineEntry)list[n];
+			return null;
+			}
+		}
+		
 		public IEnumerator GetEnumerator ()
 		{
 			return list.GetEnumerator ();
@@ -296,6 +246,10 @@
 		public void Add (CombineEntry entry)
 		{
 			list.Add (entry);
+			if (parentCombine != null) {
+				entry.SetParentCombine (parentCombine);
+				parentCombine.NotifyEntryAdded (entry);
+			}
 		}
 		
 		public void Remove (CombineEntry entry)
@@ -308,6 +262,14 @@
 			return list.IndexOf (entry);
 		}
 		
+		public int IndexOf (string name)
+		{
+			for (int n=0; n&lt;list.Count; n++)
+				if (((CombineEntry)list[n]).Name == name)
+					return n;
+			return -1;
+		}
+		
 		public void Clear ()
 		{
 			list.Clear ();

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntryEventArgs.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntryEventArgs.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntryEventArgs.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,24 +14,16 @@
 	
 	public class CombineEntryEventArgs : EventArgs
 	{
-		Combine combine;
 		CombineEntry entry;
 		
-		public Combine Combine {
-			get {
-				return combine;
-			}
-		}
-		
 		public CombineEntry CombineEntry {
 			get {
 				return entry;
 			}
 		}
 		
-		public CombineEntryEventArgs (Combine combine, CombineEntry entry)
+		public CombineEntryEventArgs (CombineEntry entry)
 		{
-			this.combine = combine;
 			this.entry = entry;
 		}
 	}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntryRenamedEventArgs.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntryRenamedEventArgs.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineEntryRenamedEventArgs.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,59 @@
+//
+// CombineEntryRenamedEventArgs.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Internal.Project
+{
+	public delegate void CombineEntryRenamedEventHandler (object sender, CombineEntryRenamedEventArgs e);
+	
+	public class CombineEntryRenamedEventArgs : CombineEntryEventArgs
+	{ 
+		string oldName;
+		string newName;
+		
+		public CombineEntryRenamedEventArgs (CombineEntry node, string oldName, string newName)
+		: base (node)
+		{
+			this.oldName = oldName;
+			this.newName = newName;
+		}
+		
+		public string OldName {
+			get {
+				return oldName;
+			}
+		}
+		
+		public string NewName {
+			get {
+				return newName;
+			}
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineExecuteDefinition.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineExecuteDefinition.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Combine/CombineExecuteDefinition.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -5,6 +5,8 @@
 //     &lt;version value=&quot;$version&quot;/&gt;
 // &lt;/file&gt;
 
+using MonoDevelop.Internal.Serialization;
+
 namespace MonoDevelop.Internal.Project
 {
 	public enum EntryExecuteType {
@@ -14,17 +16,40 @@
 	
 	public class CombineExecuteDefinition
 	{
-		public CombineEntry     Entry = null;
-		public EntryExecuteType Type  = EntryExecuteType.None;
+		CombineEntry combineEntry;
 		
+		[ItemProperty (&quot;type&quot;)]
+		EntryExecuteType type = EntryExecuteType.None;
+
+		[ItemProperty]
+		string entry;
+		
 		public CombineExecuteDefinition()
 		{
 		}
 		
-		public CombineExecuteDefinition(CombineEntry entry, EntryExecuteType type)
+		public CombineExecuteDefinition (CombineEntry entry, EntryExecuteType type)
 		{
-			this.Entry = entry;
-			this.Type  = type;
+			Entry = entry;
+			this.type  = type;
 		}
+		
+		internal void SetCombine (Combine cmb)
+		{
+			combineEntry = cmb.Entries [entry];
+		}
+		
+		public CombineEntry Entry {
+			get { return combineEntry; }
+			set {
+				combineEntry = value; 
+				entry = value != null ? value.Name : null;
+			}
+		}
+		
+		public EntryExecuteType Type {
+			get { return type; }
+			set { type = value; }
+		}
 	}
 }

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/IFileFormat.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/IFileFormat.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/IFileFormat.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,45 @@
+//
+// IFileFormat.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+
+using System;
+
+namespace MonoDevelop.Internal.Project
+{
+	public interface IFileFormat
+	{
+		string Name { get; }
+		string GetValidFormatName (string fileName);
+		
+		bool CanReadFile (string file);
+		bool CanWriteFile (object obj);
+		
+		void WriteFile (string file, object obj);
+		object ReadFile (string file);
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/PrjxFileFormat.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/PrjxFileFormat.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/PrjxFileFormat.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,212 @@
+//
+// FileFormatManager.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Xml;
+using MonoDevelop.Internal.Serialization;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Project
+{
+	public class PrjxFileFormat: IFileFormat
+	{
+		public string Name {
+			get { return &quot;MonoDevelop Project&quot;; }
+		}
+		
+		public string GetValidFormatName (string fileName)
+		{
+			return Path.ChangeExtension (fileName, &quot;.prjx&quot;);
+		}
+		
+		public bool CanReadFile (string file)
+		{
+			return string.Compare (Path.GetExtension (file), &quot;.prjx&quot;, true) == 0;
+		}
+		
+		public bool CanWriteFile (object obj)
+		{
+			return obj is Project;
+		}
+		
+		public void WriteFile (string file, object node)
+		{
+			Project project = node as Project;
+			if (project == null)
+				throw new InvalidOperationException (&quot;The provided object is not a Project&quot;);
+
+			StreamWriter sw = new StreamWriter (file);
+			try {
+				XmlDataSerializer ser = new XmlDataSerializer (Runtime.ProjectService.DataContext);
+				ser.SerializationContext.BaseFile = file;
+				ser.Serialize (sw, project, typeof(Project));
+			} finally {
+				sw.Close ();
+			}
+		}
+		
+		public object ReadFile (string fileName)
+		{
+			XmlTextReader reader = new XmlTextReader (new StreamReader (fileName));
+			reader.MoveToContent ();
+
+			string version = reader.GetAttribute (&quot;version&quot;);
+			if (version == null) version = reader.GetAttribute (&quot;fileversion&quot;);
+			
+			DataSerializer serializer = new DataSerializer (Runtime.ProjectService.DataContext, fileName);
+			IProjectReader projectReader = null;
+			
+			if (version == &quot;1.0&quot;) {
+				string tempFile = Path.GetTempFileName();
+				Runtime.MessageService.ShowMessage(String.Format (&quot;Old project file format found.\n It will be automatically converted to the current format&quot;));
+				
+				ConvertXml.Convert(fileName,
+				                   Runtime.Properties.DataDirectory + Path.DirectorySeparatorChar +
+				                   &quot;ConversionStyleSheets&quot; + Path.DirectorySeparatorChar +
+				                   &quot;ConvertPrjx10to11.xsl&quot;,
+				                   tempFile);
+				reader.Close ();
+				StreamReader sr = new StreamReader (tempFile);
+				string fdata = sr.ReadToEnd ();
+				sr.Close ();
+				File.Delete (tempFile);
+				reader = new XmlTextReader (new StringReader (fdata));
+				projectReader = new ProjectReaderV1 (serializer);
+			}
+			else if (version == &quot;1.1&quot;) {
+				projectReader = new ProjectReaderV1 (serializer);
+			}
+			else if (version == &quot;2.0&quot;) {
+				projectReader = new ProjectReaderV2 (serializer);
+			}
+			
+			try {
+				if (projectReader != null)
+					return projectReader.ReadProject (reader);
+				else
+					throw new UnknownProjectVersionException (version);
+			} finally {
+				reader.Close ();
+			}
+		}
+	}
+	
+	interface IProjectReader {
+		Project ReadProject (XmlReader reader);
+	}
+	
+	class ProjectReaderV1: XmlConfigurationReader, IProjectReader
+	{
+		DotNetProject project;
+		string file;
+		DataSerializer serializer;
+
+		static string [] changes = new string [] { 
+			&quot;Output/executeScript&quot;, &quot;Execution&quot;,&quot;executeScript&quot;,
+			&quot;Output/executeBeforeBuild&quot;, &quot;Build&quot;,&quot;executeBeforeBuild&quot;,
+			&quot;Output/executeAfterBuild&quot;, &quot;Build&quot;,&quot;executeAfterBuild&quot;,
+			&quot;runwithwarnings&quot;, &quot;Execution&quot;,&quot;runwithwarnings&quot;,
+			&quot;CodeGeneration/runtime&quot;, &quot;Execution&quot;,&quot;runtime&quot;,
+			&quot;CodeGeneration/includedebuginformation&quot;, &quot;Build&quot;,&quot;debugmode&quot;,
+			&quot;CodeGeneration/target&quot;, &quot;Build&quot;,&quot;target&quot;,
+			&quot;CompilerOptions/compilationTarget&quot;, &quot;Build&quot;,&quot;target&quot;,
+			&quot;CompilerOptions/includeDebugInformation&quot;, &quot;Build&quot;,&quot;debugmode&quot;
+		};
+		
+		public ProjectReaderV1 (DataSerializer serializer)
+		{
+			this.serializer = serializer;
+			this.file = serializer.SerializationContext.BaseFile;
+		}
+
+		public Project ReadProject (XmlReader reader)
+		{
+			string langName = reader.GetAttribute (&quot;projecttype&quot;);
+			project = new DotNetProject (langName);
+			project.FileName = file;
+			DataItem data = (DataItem) Read (reader);
+			serializer.Deserialize (project, data);
+			return project;
+		}
+		
+		protected override DataNode ReadChild (XmlReader reader, DataItem parent)
+		{
+			if (reader.LocalName == &quot;Configurations&quot;)
+			{
+				ILanguageBinding binding = Runtime.Languages.GetBindingPerLanguageName (project.LanguageName);
+				object confObj = binding.CreateCompilationParameters (null);
+				Type confType = confObj.GetType ();
+				DataContext prjContext = Runtime.ProjectService.DataContext;
+				
+				DataItem item = base.ReadChild (reader, parent) as DataItem;
+				foreach (DataNode data in item.ItemData) {
+					DataItem conf = data as DataItem;
+					if (conf == null) continue;
+					prjContext.SetTypeInfo (conf, typeof(DotNetProjectConfiguration));
+					DataItem codeGeneration = conf [&quot;CodeGeneration&quot;] as DataItem;
+					if (codeGeneration != null)
+						prjContext.SetTypeInfo (codeGeneration, confType);
+					Transform (conf);
+				}
+				return item;
+			}
+			return base.ReadChild (reader, parent);
+		}
+		
+		void Transform (DataItem conf)
+		{
+			for (int n=0; n&lt;changes.Length; n+=3) {
+				DataNode data = conf.ItemData.Extract (changes[n]);
+				if (data != null) {
+					data.Name = changes [n+2];
+					conf.ItemData.Add (data, changes[n+1]);
+				}
+			}
+		}
+	}
+
+
+	class ProjectReaderV2: XmlConfigurationReader, IProjectReader
+	{
+		DataSerializer serializer;
+		
+		public ProjectReaderV2 (DataSerializer serializer)
+		{
+			this.serializer = serializer;
+		}
+
+		public Project ReadProject (XmlReader reader)
+		{
+			DataNode data = Read (reader);
+			Project project = (Project) serializer.Deserialize (typeof(Project), data);
+			project.FileName = serializer.SerializationContext.BaseFile;
+			return project;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractConfiguration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractConfiguration.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractConfiguration.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -7,23 +7,23 @@
 
 using System.Xml;
 using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Serialization;
+using System.Collections;
 
 namespace MonoDevelop.Internal.Project
 {
-	public abstract class AbstractConfiguration : IConfiguration
+	public abstract class AbstractConfiguration : IConfiguration, IExtendedDataItem
 	{
-		[XmlAttribute(&quot;name&quot;)]
-		protected string name = null;
+		[ItemProperty(&quot;name&quot;)]
+		string name = null;
+
+		Hashtable properties;
 		
 		public string Name {
-			get {
-				return name;
-			}
-			set {
-				name = value;
-			}
+			get { return name; }
+			set { name = value; }
 		}
-		
+
 		public object Clone()
 		{
 			return MemberwiseClone();
@@ -33,5 +33,12 @@
 		{
 			return name;
 		}
+		
+		public IDictionary ExtendedProperties {
+			get {
+				if (properties == null) properties = new Hashtable ();
+				return properties;
+			}
+		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractProject.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractProject.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractProject.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,73 +14,58 @@
 using System.Collections.Specialized;
 using System.Reflection;
 using System.Xml;
+using System.CodeDom.Compiler;
 
 using MonoDevelop.Core.Properties;
 using MonoDevelop.Core.AddIns;
-using MonoDevelop.Internal.Project.Collections;
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Core.Services;
 using MonoDevelop.Services;
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Gui.Widgets;
+using MonoDevelop.Internal.Serialization;
 
 namespace MonoDevelop.Internal.Project
 {
+	public enum NewFileSearch {
+		None,
+		OnLoad,
+		OnLoadAutoInsert
+	}
+	
 	/// &lt;summary&gt;
 	/// External language bindings must extend this class
 	/// &lt;/summary&gt;
-	[XmlNodeName(&quot;Project&quot;)]
-	public abstract class AbstractProject : LocalizedObject, IProject
+	[DataItemAttribute (&quot;Project&quot;)]
+	[DataInclude (typeof(ProjectFile))]
+	public abstract class Project : CombineEntry
 	{
 		readonly static string currentProjectFileVersion = &quot;1.1&quot;;
 		readonly static string configurationNodeName     = &quot;Configuration&quot;;
 		
-		protected string basedirectory   = String.Empty;
-
-		[XmlAttribute(&quot;name&quot;)]
-		protected string projectname     = &quot;New Project&quot;;
-
-		[XmlAttribute(&quot;description&quot;)]
+		[ItemProperty (&quot;Description&quot;, DefaultValue=&quot;&quot;)]
 		protected string description     = &quot;&quot;;
 
-		[XmlAttribute(&quot;newfilesearch&quot;)]
+		[ItemProperty (&quot;newfilesearch&quot;, DefaultValue = NewFileSearch.None)]
 		protected NewFileSearch newFileSearch  = NewFileSearch.None;
 
-		[XmlAttribute(&quot;enableviewstate&quot;)]
-		protected bool          enableViewState = true;
+		[ItemProperty (&quot;enableviewstate&quot;, DefaultValue = true)]
+		protected bool enableViewState = true;
+		
+		ProjectFileCollection projectFiles;
 
-		[XmlSetAttribute(typeof(ProjectFile),      &quot;Contents&quot;)]
-		protected ProjectFileCollection      projectFiles       = new ProjectFileCollection();
-
-		[XmlSetAttribute(typeof(ProjectReference), &quot;References&quot;)]
+		[ItemProperty (&quot;References&quot;)]
 		protected ProjectReferenceCollection projectReferences = new ProjectReferenceCollection();
 		
+		[ItemProperty (&quot;DeploymentInformation&quot;)]
 		protected DeployInformation deployInformation = new DeployInformation();
-		FileUtilityService fileUtilityService = Runtime.FileUtilityService;
 		
-		[Browsable(false)]
-		public string BaseDirectory {
-			get {
-				return basedirectory;
-			}
-		}
+		bool isDirty = true;
 		
-		[LocalizedProperty(&quot;${res:MonoDevelop.Internal.Project.Project.Name}&quot;,
-		                   Description =&quot;${res:MonoDevelop.Internal.Project.Project.Description}&quot;)]
-		public string Name {
-			get {
-				return projectname;
-			}
-			set {
-				if (projectname != value &amp;&amp; value != null &amp;&amp; value.Length &gt; 0) {
-					if (!Runtime.ProjectService.ExistsEntryWithName(value)) {
-						string oldName = projectname;
-						projectname = value;
-						Runtime.ProjectService.OnRenameProject(new ProjectRenameEventArgs(this, oldName, value));
-						OnNameChanged(EventArgs.Empty);
-					}
-				}
-			}
+		public Project ()
+		{
+			Name = &quot;New Project&quot;;
+			projectReferences.SetProject (this);
 		}
 		
 		[LocalizedProperty(&quot;${res:MonoDevelop.Internal.Project.ProjectClass.Description}&quot;,
@@ -96,9 +81,12 @@
 		}
 		
 		[Browsable(false)]
+		[ItemProperty (&quot;Contents&quot;)]
+		[ItemProperty (&quot;File&quot;, Scope=1)]
 		public ProjectFileCollection ProjectFiles {
 			get {
-				return projectFiles;
+				if (projectFiles != null) return projectFiles;
+				return projectFiles = new ProjectFileCollection (this);
 			}
 		}
 		
@@ -109,31 +97,6 @@
 			}
 		}
 		
-		protected ArrayList configurations = new ArrayList();
-		protected IConfiguration activeConfiguration = null;
-		
-		[Browsable(false)]
-		public ArrayList Configurations {
-			get {
-				return configurations;
-			}
-		}
-		
-		[LocalizedProperty(&quot;${res:MonoDevelop.Internal.Project.Project.ActiveConfiguration}&quot;,
-		                   Description = &quot;${res:MonoDevelop.Internal.Project.Project.ActiveConfiguration.Description}&quot;)]
-		[TypeConverter(typeof(ProjectActiveConfigurationTypeConverter))]
-		public IConfiguration ActiveConfiguration {
-			get {
-				if (activeConfiguration == null &amp;&amp; configurations.Count &gt; 0) {
-					return (IConfiguration)configurations[0];
-				}
-				return activeConfiguration;
-			}
-			set {
-				activeConfiguration = value;
-			}
-		}
-		
 		[LocalizedProperty(&quot;${res:MonoDevelop.Internal.Project.Project.NewFileSearch}&quot;,
 		                   Description = &quot;${res:MonoDevelop.Internal.Project.Project.NewFileSearch.Description}&quot;)]
 		[DefaultValue(NewFileSearch.None)]
@@ -170,16 +133,10 @@
 			}
 		}
 
-		public AbstractProject()
-		{
-			projectFiles.SetProject (this);
-			projectReferences.SetProject (this);
-		}
-
 		public bool IsFileInProject(string filename)
 		{
 			if (filename == null) return false;
-			foreach (ProjectFile file in projectFiles) {
+			foreach (ProjectFile file in ProjectFiles) {
 				if (file.Name == filename) {
 					return true;
 				}
@@ -187,9 +144,9 @@
 			return false;
 		}
 
-		public bool IsCompileable(string fileName)
+		public virtual bool IsCompileable (string fileName)
 		{
-			return Runtime.Languages.GetBindingPerLanguageName (ProjectType).CanCompile(fileName);
+			return false;
 		}
 		
 		public void SearchNewFiles()
@@ -199,7 +156,7 @@
 			}
 
 			StringCollection newFiles   = new StringCollection();
-			StringCollection collection = fileUtilityService.SearchDirectory(basedirectory, &quot;*&quot;);
+			StringCollection collection = Runtime.FileUtilityService.SearchDirectory (BaseDirectory, &quot;*&quot;);
 
 			foreach (string sfile in collection) {
 				string extension = Path.GetExtension(sfile).ToUpper();
@@ -232,7 +189,7 @@
 					foreach (string file in newFiles) {
 						ProjectFile newFile = new ProjectFile(file);
 						newFile.BuildAction = IsCompileable(file) ? BuildAction.Compile : BuildAction.Nothing;
-						projectFiles.Add(newFile);
+						ProjectFiles.Add(newFile);
 					}
 				} else {
 					new IncludeFilesDialog(this, newFiles).ShowDialog();
@@ -240,273 +197,22 @@
 			}
 		}
 		
-		public virtual void LoadProject(string fileName)
+		public static Project LoadProject (string filename)
 		{
-			basedirectory = Path.GetDirectoryName(fileName);
-			XmlDocument doc = new XmlDocument();
-			doc.Load(fileName);
+			Project prj = Runtime.ProjectService.ReadFile (filename) as Project;
+			if (prj == null)
+				throw new InvalidOperationException (&quot;Invalid project file: &quot; + filename);
 			
-			string version = null;
-			if (doc.DocumentElement.Attributes[&quot;version&quot;] == null) {
-				if (doc.DocumentElement.Attributes[&quot;fileversion&quot;] != null) {
-					version = doc.DocumentElement.Attributes[&quot;fileversion&quot;].InnerText;
-				}
-			} else {
-				version = doc.DocumentElement.Attributes[&quot;version&quot;].InnerText;
-			}
-			
-			if (version != &quot;1.0&quot; &amp;&amp; version != currentProjectFileVersion) {
-				throw new UnknownProjectVersionException(version);
-			}
-			if (version == &quot;1.0&quot;) {
-				string tempFile = Path.GetTempFileName();
-				Runtime.MessageService.ShowMessage(String.Format (GettextCatalog.GetString (&quot;Old project file format found.\n It will be automatically converted to {0} information&quot;), currentProjectFileVersion));
-				
-				ConvertXml.Convert(fileName,
-				                   Runtime.Properties.DataDirectory + Path.DirectorySeparatorChar +
-				                   &quot;ConversionStyleSheets&quot; + Path.DirectorySeparatorChar +
-				                   &quot;ConvertPrjx10to11.xsl&quot;,
-				                   tempFile);
-				try {
-					File.Delete(fileName);
-					File.Copy(tempFile, fileName);
-					LoadProject(fileName);
-					File.Delete(tempFile);
-					return;
-				} catch (Exception) {
-					Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;Error writing the old project file.\nCheck if you have write permission on the project file (.prjx).\n A non persistent proxy project will be created but no changes will be saved.\nIt is better if you close MonoDevelop and correct the problem.&quot;));
-					if (File.Exists(tempFile)) {
-						doc.Load(tempFile);
-						File.Delete(tempFile);
-					} else {
-						Runtime.MessageService.ShowError(&quot;damn! (should never happen)&quot;);
-					}
-				}
-			}
-			
-			GetXmlAttributes(doc, doc.DocumentElement, this);
-			
-			// add the configurations
-			XmlNode configurationElement = doc.DocumentElement.SelectSingleNode(&quot;Configurations&quot;);
-			
-			string activeConfigurationName = configurationElement.Attributes[&quot;active&quot;].InnerText;
-			
-			foreach (XmlNode configuration in configurationElement.ChildNodes) {
-				if (configuration.Name == configurationNodeName) {
-					IConfiguration newConfiguration = CreateConfiguration();
-					GetXmlAttributes(doc, (XmlElement)configuration, newConfiguration);
-					if (newConfiguration.Name == activeConfigurationName) {
-						activeConfiguration = newConfiguration;
-					}
-					Configurations.Add(newConfiguration);
-				}
-			}
-			
-			SearchNewFiles();
-
-			projectFiles.SetProject (this);
-			projectReferences.SetProject (this);
+			return prj;
 		}
-
-		void GetXmlAttributes(XmlDocument doc, XmlElement element, object o)
-		{
-			FieldInfo[] fieldInfos = o.GetType().GetFields(BindingFlags.FlattenHierarchy |
-			                                               BindingFlags.Public           |
-			                                               BindingFlags.Instance         |
-			                                               BindingFlags.NonPublic);
-			foreach (FieldInfo fieldInfo in fieldInfos) {
-				// set the xml attributes for this object
-				XmlAttributeAttribute[]           xmlAttributes = (XmlAttributeAttribute[])fieldInfo.GetCustomAttributes(typeof(XmlAttributeAttribute), true);
-				ConvertToRelativePathAttribute[]  convertToRelPath = (ConvertToRelativePathAttribute[])fieldInfo.GetCustomAttributes(typeof(ConvertToRelativePathAttribute), true);
-				bool convertRel = convertToRelPath != null &amp;&amp; convertToRelPath.Length &gt; 0;
-				
-				if (xmlAttributes != null &amp;&amp; xmlAttributes.Length &gt; 0) {
-					if (xmlAttributes[0].Name == null) continue;
-					XmlAttribute xmlAttribute = element.Attributes[xmlAttributes[0].Name];
-					if (xmlAttribute != null) {
-						if (convertRel &amp;&amp; convertToRelPath[0].PredicatePropertyName != null &amp;&amp; convertToRelPath[0].PredicatePropertyName.Length &gt; 0) {
-							PropertyInfo myPropInfo = o.GetType().GetProperty(convertToRelPath[0].PredicatePropertyName, 
-							                                                          BindingFlags.Public |
-							                                                          BindingFlags.NonPublic |
-							                                                          BindingFlags.Instance);
-							if (myPropInfo != null) {
-								convertRel = (bool)myPropInfo.GetValue(o, null);
-							}
-						}
-						
-						string val = null;
-						if (convertRel) {
-							if (xmlAttribute.InnerText.Length == 0) {
-								val = String.Empty;
-							} else {
-								val = fileUtilityService.RelativeToAbsolutePath(basedirectory, xmlAttribute.InnerText);
-							}
-						} else {
-							val = xmlAttribute.InnerText;
-						}
-						
-						if (fieldInfo.FieldType.IsEnum) {
-							fieldInfo.SetValue(o, Enum.Parse(fieldInfo.FieldType,val));
-						} else {
-							fieldInfo.SetValue(o, Convert.ChangeType(val, fieldInfo.FieldType));
-						}
-					}
-				} else { // add sets to the xmlElement
-					XmlSetAttribute[] xmlSetAttributes = (XmlSetAttribute[])fieldInfo.GetCustomAttributes(typeof(XmlSetAttribute), true);
-					if (xmlSetAttributes != null &amp;&amp; xmlSetAttributes.Length &gt; 0) {
-						XmlElement setElement;
-						if (xmlSetAttributes[0].Name == null) {
-							setElement = element;
-						} else {
-							setElement = (XmlElement)element.SelectSingleNode(&quot;descendant::&quot; + xmlSetAttributes[0].Name);
-						}
-						
-						if (setElement != null) {
-							IList collection = (IList)fieldInfo.GetValue(o);
-							foreach (XmlNode childNode in setElement.ChildNodes) {
-								object instance = xmlSetAttributes[0].Type.Assembly.CreateInstance(xmlSetAttributes[0].Type.FullName);
-								GetXmlAttributes(doc, (XmlElement)childNode, instance);
-								collection.Add(instance);
-							}
-						}
-					} else { // finally try, if the field is from a type which has a XmlNodeName attribute attached
-						
-						XmlNodeNameAttribute[] xmlNodeNames = (XmlNodeNameAttribute[])fieldInfo.FieldType.GetCustomAttributes(typeof(XmlNodeNameAttribute), true);
-						
-						if (xmlNodeNames != null &amp;&amp; xmlNodeNames.Length == 1) {
-							XmlElement el = (XmlElement)element.SelectSingleNode(&quot;descendant::&quot; + xmlNodeNames[0].Name);
-							object instance = fieldInfo.FieldType.Assembly.CreateInstance(fieldInfo.FieldType.FullName);
-							if (el != null) {
-								GetXmlAttributes(doc, el, instance);
-							}
-							fieldInfo.SetValue(o, instance);
-						}
-					}
-				}
-			}
-		}
 		
-		void SetXmlAttributes(XmlDocument doc, XmlElement element, object o)
+		public override void Deserialize (ITypeSerializer handler, DataCollection data)
 		{
-			FieldInfo[] fieldInfos = o.GetType().GetFields(BindingFlags.FlattenHierarchy |
-			                                               BindingFlags.Public           |
-			                                               BindingFlags.Instance         |
-			                                               BindingFlags.NonPublic);
-			foreach (FieldInfo fieldInfo in fieldInfos) {
-				// set the xml attributes for this object
-				XmlAttributeAttribute[] xmlAttributes = (XmlAttributeAttribute[])fieldInfo.GetCustomAttributes(typeof(XmlAttributeAttribute), true);
-				
-				ConvertToRelativePathAttribute[]  convertToRelPath = (ConvertToRelativePathAttribute[])fieldInfo.GetCustomAttributes(typeof(ConvertToRelativePathAttribute), true);
-				bool convertRel = convertToRelPath != null &amp;&amp; convertToRelPath.Length &gt; 0;
-								
-				if (xmlAttributes != null &amp;&amp; xmlAttributes.Length &gt; 0) {
-					if (xmlAttributes[0].Name == null) continue;
-					XmlAttribute xmlAttribute = doc.CreateAttribute(xmlAttributes[0].Name);
-					object fieldValue = fieldInfo.GetValue(o);
-					
-					if (convertRel &amp;&amp; convertToRelPath[0].PredicatePropertyName != null &amp;&amp; convertToRelPath[0].PredicatePropertyName.Length &gt; 0) {
-						PropertyInfo myPropInfo = o.GetType().GetProperty(convertToRelPath[0].PredicatePropertyName,
-						                                                          BindingFlags.Public |
-						                                                          BindingFlags.NonPublic |
-						                                                          BindingFlags.Instance);
-						if (myPropInfo != null) {
-							convertRel = (bool)myPropInfo.GetValue(o, null);
-						}
-					}
-					
-					if (convertRel) {
-						string val = fieldValue == null ? String.Empty : fieldValue.ToString();
-						if (val.Length == 0) {
-							fieldValue = String.Empty;
-						} else {
-							fieldValue = fileUtilityService.AbsoluteToRelativePath(basedirectory, val);
-						}
-					}
-					xmlAttribute.InnerText = fieldValue == null ? String.Empty : fieldValue.ToString();
-					element.Attributes.Append(xmlAttribute);
-				} else { // add sets to the xmlElement
-					XmlSetAttribute[] xmlSetAttributes = (XmlSetAttribute[])fieldInfo.GetCustomAttributes(typeof(XmlSetAttribute), true);
-					if (xmlSetAttributes != null &amp;&amp; xmlSetAttributes.Length &gt; 0) {
-						XmlElement setElement;
-						if (xmlSetAttributes[0].Name == null) {
-							setElement = element;
-						} else {
-							setElement = doc.CreateElement(xmlSetAttributes[0].Name);
-						}
-
-						// A set must always be a collection
-						ICollection collection = (ICollection)fieldInfo.GetValue(o);
-						foreach (object collectionObject in collection) {
-							XmlNodeNameAttribute[] xmlNodeNames = (XmlNodeNameAttribute[])collectionObject.GetType().GetCustomAttributes(typeof(XmlNodeNameAttribute), true);
-							if (xmlNodeNames == null || xmlNodeNames.Length != 1) {
-								throw new Exception(&quot;XmlNodeNames mismatch&quot;);
-							}
-							XmlElement collectionElement = doc.CreateElement(xmlNodeNames[0].Name);
-							SetXmlAttributes(doc, collectionElement, collectionObject);
-							setElement.AppendChild(collectionElement);
-						}
-						if (element != setElement) {
-							element.AppendChild(setElement);
-						}
-					} else { // finally try, if the field is from a type which has a XmlNodeName attribute attached
-						object fieldValue = fieldInfo.GetValue(o);
-						if (fieldValue != null) {
-							XmlNodeNameAttribute[] xmlNodeNames = (XmlNodeNameAttribute[])fieldValue.GetType().GetCustomAttributes(typeof(XmlNodeNameAttribute), true);
-
-							if (xmlNodeNames != null &amp;&amp; xmlNodeNames.Length == 1) {
-								XmlElement setElement = doc.CreateElement(xmlNodeNames[0].Name);
-								SetXmlAttributes(doc, setElement, fieldValue);
-								element.AppendChild(setElement);
-							}
-						}
-					}
-				}
-			}
+			base.Deserialize (handler, data);
+			SearchNewFiles();
+			projectReferences.SetProject (this);
 		}
-		
-		public virtual void SaveProject(string fileName)
-		{
-			fileName = System.IO.Path.GetFullPath (fileName);
-			basedirectory = Path.GetDirectoryName(fileName);
-			XmlDocument doc = new XmlDocument();
-			doc.LoadXml(&quot;&lt;Project/&gt;&quot;);
 
-			SetXmlAttributes(doc, doc.DocumentElement, this);
-			
-			// set version attribute to the root node
-			XmlAttribute versionAttribute = doc.CreateAttribute(&quot;version&quot;);
-			versionAttribute.InnerText    = currentProjectFileVersion;
-			doc.DocumentElement.Attributes.Append(versionAttribute);
-			
-			
-			// set projecttype attribute to the root node
-			XmlAttribute projecttypeAttribute = doc.CreateAttribute(&quot;projecttype&quot;);
-			projecttypeAttribute.InnerText    = ProjectType;
-			doc.DocumentElement.Attributes.Append(projecttypeAttribute);
-			
-			// create the configuration nodes
-			// I choosed to add the configuration nodes 'per hand' instead of using the automated
-			// version, because it is more cleaner for the language binding implementors to just 
-			// creating a factory method for their configurations.
-			XmlElement configurationElement = doc.CreateElement(&quot;Configurations&quot;);
-			XmlAttribute activeConfigAttribute = doc.CreateAttribute(&quot;active&quot;);
-			activeConfigAttribute.InnerText = ActiveConfiguration == null ? String.Empty : ActiveConfiguration.Name;
-			configurationElement.Attributes.Append(activeConfigAttribute);
-			
-			foreach (IConfiguration configuration in Configurations) {
-				XmlElement newConfig = doc.CreateElement(configurationNodeName);
-				SetXmlAttributes(doc, newConfig, configuration);
-				configurationElement.AppendChild(newConfig);
-			}
-			
-			doc.DocumentElement.AppendChild(configurationElement);
-			
-			Runtime.FileUtilityService.ObservedSave(new NamedFileOperationDelegate(doc.Save), 
-											fileName, 
-											GettextCatalog.GetString (&quot;Can't save solution\nPlease check your file and directory permissions.&quot;), 
-											FileErrorPolicy.ProvideAlternative);
-		}
-		
 		public virtual string GetParseableFileContent(string fileName)
 		{
 			fileName = fileName.Replace('\\', '/'); // FIXME PEDRO
@@ -523,7 +229,7 @@
 
 				if (fdiag.Run() == (int)Gtk.ResponseType.Ok) {
 					string filename = fdiag.Filename;
-					SaveProject(filename);
+					Save (filename);
 					Runtime.MessageService.ShowMessage(filename, GettextCatalog.GetString (&quot;Project saved&quot;));
 				}
 				
@@ -538,32 +244,9 @@
 				return;
 			}
 			foreach (ProjectReference projectReference in ProjectReferences) {
-				if (projectReference.ReferenceType == ReferenceType.Project) {
-					ArrayList allProjects = Combine.GetAllProjects (Runtime.ProjectService.CurrentOpenCombine);
-					foreach (ProjectCombineEntry entry in allProjects)
-					{
-						IProject proj = entry.Project;
-						if (proj.Name != projectReference.Reference)
-							continue;
-						foreach (ProjectReference refrnc in proj.ProjectReferences)
-						{
-							if (refrnc.ReferenceType != ReferenceType.Gac &amp;&amp; (refrnc.LocalCopy || force)) {
-								string referenceFileName = refrnc.GetReferencedFileName (proj);
-								string destinationFileName = fileUtilityService.GetDirectoryNameWithSeparator (config.OutputDirectory) + Path.GetFileName (referenceFileName);
-								try {
-									if (destinationFileName != referenceFileName) {
-										File.Copy (referenceFileName, destinationFileName, true);
-										if (File.Exists (referenceFileName + &quot;.mdb&quot;))
-											File.Copy (referenceFileName + &quot;.mdb&quot;, destinationFileName + &quot;.mdb&quot;, true);
-									}
-								} catch { }
-							}
-						}
-					}
-				}
 				if ((projectReference.LocalCopy || force) &amp;&amp; projectReference.ReferenceType != ReferenceType.Gac) {
-					string referenceFileName   = projectReference.GetReferencedFileName(this);
-					string destinationFileName = fileUtilityService.GetDirectoryNameWithSeparator(config.OutputDirectory) + Path.GetFileName(referenceFileName);
+					string referenceFileName   = projectReference.GetReferencedFileName();
+					string destinationFileName = Runtime.FileUtilityService.GetDirectoryNameWithSeparator(config.OutputDirectory) + Path.GetFileName(referenceFileName);
 					try {
 						if (destinationFileName != referenceFileName) {
 							File.Copy(referenceFileName, destinationFileName, true);
@@ -577,23 +260,173 @@
 			}
 		}
 		
-		public virtual void Dispose()
+		public override void Dispose()
 		{
+			base.Dispose ();
 			foreach (ProjectFile file in ProjectFiles) {
 				file.Dispose ();
 			}
 		}
 		
-		public abstract IConfiguration CreateConfiguration();
+		public ProjectReference AddReference (string filename)
+		{
+			foreach (ProjectReference rInfo in ProjectReferences) {
+				if (rInfo.Reference == filename) {
+					return rInfo;
+				}
+			}
+			ProjectReference newReferenceInformation = new ProjectReference (ReferenceType.Assembly, filename);
+			ProjectReferences.Add (newReferenceInformation);
+			return newReferenceInformation;
+		}
 		
-		public virtual  IConfiguration CreateConfiguration(string name)
+		public ProjectFile AddFile (string filename, BuildAction action)
 		{
-			IConfiguration config = CreateConfiguration();
-			config.Name = name;
+			foreach (ProjectFile fInfo in ProjectFiles) {
+				if (fInfo.Name == filename) {
+					return fInfo;
+				}
+			}
+			ProjectFile newFileInformation = new ProjectFile (filename, action);
+			ProjectFiles.Add (newFileInformation);
+			return newFileInformation;
+		}
+		
+		public void AddFile (ProjectFile projectFile) {
+			ProjectFiles.Add (projectFile);
+		}
+
+		public override void Clean ()
+		{
+			isDirty = true;
+		}
+		
+		public override void Build ()
+		{
+			Compile ();
+		}
+		
+		public ICompilerResult Compile ()
+		{
+			if (isDirty) {
+				Runtime.StringParserService.Properties[&quot;Project&quot;] = Name;
+				TaskService taskService = Runtime.TaskService;
+				
+				Runtime.Gui.StatusBar.SetMessage(String.Format (GettextCatalog.GetString (&quot;Compiling: {0}&quot;), Name));
+				
+				DoPreBuild ();
+				
+				taskService.CompilerOutput += String.Format (GettextCatalog.GetString (&quot;------ Build started: Project: {0} Configuration: {1} ------\n\nPerforming main compilation...\n&quot;), Name, ActiveConfiguration.Name);
+				
+				ICompilerResult res = DoBuild ();
+				
+				DoPostBuild ();
+				
+				isDirty = false;
+				foreach (System.CodeDom.Compiler.CompilerError err in res.CompilerResults.Errors) {
+					isDirty = true;
+					taskService.AddTask(new Task(this, err));
+				}
+				
+				if (taskService.Errors &gt; 0) {
+					++CombineEntry.BuildErrors;
+				} else {
+					++CombineEntry.BuildProjects;
+				}
+				
+				taskService.CompilerOutput += String.Format (GettextCatalog.GetString (&quot;Build complete -- {0} errors, {1} warnings\n\n&quot;), taskService.Errors.ToString (), taskService.Warnings.ToString ());
+				return res;
+			}
+			return new DefaultCompilerResult (new CompilerResults (null), &quot;&quot;);
+		}
+		
+		protected virtual void DoPreBuild ()
+		{
+			AbstractProjectConfiguration conf = ActiveConfiguration as AbstractProjectConfiguration;
+				
+			// create output directory, if not exists
+			string outputDir = conf.OutputDirectory;
+			try {
+				DirectoryInfo directoryInfo = new DirectoryInfo(outputDir);
+				if (!directoryInfo.Exists) {
+					directoryInfo.Create();
+				}
+			} catch (Exception e) {
+				throw new ApplicationException(&quot;Can't create project output directory &quot; + outputDir + &quot; original exception:\n&quot; + e.ToString());
+			}
 			
-			return config;
+			if (conf != null &amp;&amp; File.Exists(conf.ExecuteBeforeBuild)) {
+				Runtime.TaskService.CompilerOutput += String.Format (GettextCatalog.GetString (&quot;Execute : {0}&quot;), conf.ExecuteBeforeBuild);
+				ProcessStartInfo ps = new ProcessStartInfo(conf.ExecuteBeforeBuild);
+				ps.UseShellExecute = false;
+				ps.RedirectStandardOutput = true;
+				ps.WorkingDirectory = Path.GetDirectoryName(conf.ExecuteBeforeBuild);
+				Process process = new Process();
+				process.StartInfo = ps;
+				process.Start();
+				Runtime.TaskService.CompilerOutput += process.StandardOutput.ReadToEnd();
+			}
 		}
 		
+		protected virtual ICompilerResult DoBuild ()
+		{
+			return new DefaultCompilerResult (new CompilerResults (null), &quot;&quot;);
+		}
+		
+		protected virtual void DoPostBuild ()
+		{
+			AbstractProjectConfiguration conf = ActiveConfiguration as AbstractProjectConfiguration;
+
+			if (conf != null &amp;&amp; File.Exists(conf.ExecuteAfterBuild)) {
+				Runtime.TaskService.CompilerOutput += String.Format (GettextCatalog.GetString (&quot;Execute : {0}&quot;), conf.ExecuteAfterBuild);
+				ProcessStartInfo ps = new ProcessStartInfo(conf.ExecuteAfterBuild);
+				ps.UseShellExecute = false;
+				ps.RedirectStandardOutput = true;
+				ps.WorkingDirectory = Path.GetDirectoryName(conf.ExecuteAfterBuild);
+				Process process = new Process();
+				process.StartInfo = ps;
+				process.Start();
+				Runtime.TaskService.CompilerOutput += process.StandardOutput.ReadToEnd();
+			}
+		}
+		
+		public override void Execute()
+		{
+			if (Runtime.TaskService.Errors != 0) return;
+			
+			AbstractProjectConfiguration configuration = (AbstractProjectConfiguration) ActiveConfiguration;
+			if (Runtime.TaskService.Warnings != 0 &amp;&amp; configuration != null &amp;&amp; !configuration.RunWithWarnings)
+				return;
+				
+			string args = configuration.CommandLineParameters;
+			
+			ProcessStartInfo psi;
+			if (configuration.ExecuteScript != null &amp;&amp; configuration.ExecuteScript.Length &gt; 0) {
+				string additionalCommands = &quot;&quot;;
+				if (configuration.PauseConsoleOutput)
+					additionalCommands = @&quot;echo; read -p 'press any key to continue...' -n1;&quot;;
+				psi = new ProcessStartInfo(&quot;xterm&quot;,
+					String.Format (@&quot;-e &quot;&quot;cd {3} ; '{0}' {1} ; {2}&quot;&quot;&quot;, configuration.ExecuteScript, args, additionalCommands, BaseDirectory));
+				psi.UseShellExecute = false;
+			} else {
+				DoExecute ();
+			}
+		}
+		
+		
+		protected virtual void DoExecute ()
+		{
+		}
+		
+		public override bool NeedsBuilding {
+			get {
+				return isDirty;
+			}
+			set {
+				isDirty = value;
+			}
+		}
+
  		internal void NotifyFileChangedInProject (ProjectFile file)
 		{
 			OnFileChangedInProject (new ProjectFileEventArgs (this, file));
@@ -619,13 +452,6 @@
 			OnReferenceAddedToProject (new ProjectReferenceEventArgs (this, reference));
 		}
 		
-		protected virtual void OnNameChanged(EventArgs e)
-		{
-			if (NameChanged != null) {
-				NameChanged(this, e);
-			}
-		}
-		
 		protected virtual void OnFileRemovedFromProject (ProjectFileEventArgs e)
 		{
 			if (FileRemovedFromProject != null) {
@@ -662,7 +488,6 @@
 		}
 		
 				
-		public event EventHandler NameChanged;
 		public event ProjectFileEventHandler FileRemovedFromProject;
 		public event ProjectFileEventHandler FileAddedToProject;
 		public event ProjectFileEventHandler FileChangedInProject;
@@ -684,7 +509,7 @@
 		
 		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture,  object value)
 		{
-			IProject project = (IProject)context.Instance;
+			Project project = (Project)context.Instance;
 			foreach (IConfiguration configuration in project.Configurations) {
 				if (configuration.Name == value.ToString()) {
 					return configuration;
@@ -714,7 +539,7 @@
 		
 		public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context)
 		{
-			return new TypeConverter.StandardValuesCollection(((IProject)context.Instance).Configurations);
+			return new TypeConverter.StandardValuesCollection(((Project)context.Instance).Configurations);
 		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractProjectConfiguration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractProjectConfiguration.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/AbstractProjectConfiguration.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -13,6 +13,7 @@
 using System.Xml;
 
 using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Serialization;
 
 namespace MonoDevelop.Internal.Project
 {
@@ -20,93 +21,75 @@
 	/// External language bindings may choose to extend this class.
 	/// It makes things a bit easier.
 	/// &lt;/summary&gt;
-	[XmlNodeNameAttribute(&quot;Configuration&quot;)]
+	[DataItemAttribute(&quot;Configuration&quot;)]
 	public abstract class AbstractProjectConfiguration : AbstractConfiguration
 	{
-		[XmlNodeName(&quot;Output&quot;)]
-		protected class OutputConfiguration
-		{
-			[XmlAttribute(&quot;directory&quot;)]
-			[ConvertToRelativePath()]
-			public string Directory = &quot;.&quot; + Path.DirectorySeparatorChar.ToString();
-			
-			[XmlAttribute(&quot;assembly&quot;)]
-			public string Assembly = &quot;a&quot;;
-			
-			[XmlAttribute(&quot;executeScript&quot;)]
-			[ConvertToRelativePath()]
-			public string ExecuteScript = String.Empty;
-			
-			[XmlAttribute(&quot;executeBeforeBuild&quot;)]
-			[ConvertToRelativePath()]
-			public string ExecuteBeforeBuild = String.Empty;
-			
-			[XmlAttribute(&quot;executeAfterBuild&quot;)]
-			[ConvertToRelativePath()]
-			public string ExecuteAfterBuild = String.Empty;
-		}
+		[ProjectPathItemProperty (&quot;Output/directory&quot;)]
+		string directory = &quot;.&quot; + Path.DirectorySeparatorChar.ToString();
 		
-		[XmlAttribute(&quot;runwithwarnings&quot;)]
+		[ProjectPathItemProperty (&quot;Build/executeBeforeBuild&quot;, DefaultValue = &quot;&quot;)]
+		string executeBeforeBuild = String.Empty;
+		
+		[ProjectPathItemProperty (&quot;Build/executeAfterBuild&quot;, DefaultValue = &quot;&quot;)]
+		string executeAfterBuild = String.Empty;
+		
+		[ItemProperty (&quot;Build/debugmode&quot;)]
+		bool debugmode = true;
+		
+		[ProjectPathItemProperty (&quot;Execution/executeScript&quot;, DefaultValue = &quot;&quot;)]
+		string executeScript = String.Empty;
+		
+		[ItemProperty (&quot;Execution/runwithwarnings&quot;)]
 		protected bool runWithWarnings = false;
 		
-		protected OutputConfiguration outputConfiguration = new OutputConfiguration();
+		[ItemProperty (&quot;Execution/commandlineparameters&quot;, DefaultValue = &quot;&quot;)]
+		public string commandLineParameters = String.Empty;
 		
-		public virtual string OutputDirectory {
-			get {
-				return outputConfiguration.Directory;
-			}
-			set {
-				outputConfiguration.Directory = value;
-			}
+		[ItemProperty (&quot;Execution/consolepause&quot;)]
+		public bool pauseconsoleoutput = true;
+
+		public AbstractProjectConfiguration()
+		{
 		}
 		
-		public virtual string OutputAssembly {
-			get {
-				return outputConfiguration.Assembly;
-			}
-			set {
-				outputConfiguration.Assembly = value;
-			}
+		public virtual string OutputDirectory {
+			get { return directory; }
+			set { directory = value; }
 		}
 		
 		public virtual string ExecuteScript {
-			get {
-				return outputConfiguration.ExecuteScript;
-			}
-			set {
-				outputConfiguration.ExecuteScript = value;
-			}
+			get { return executeScript; }
+			set { executeScript = value; }
 		}
 		
 		public virtual string ExecuteBeforeBuild {
-			get {
-				return outputConfiguration.ExecuteBeforeBuild;
-			}
-			set {
-				outputConfiguration.ExecuteBeforeBuild = value;
-			}
+			get { return executeBeforeBuild; }
+			set { executeBeforeBuild = value; }
 		}
 		
 		public virtual string ExecuteAfterBuild {
-			get {
-				return outputConfiguration.ExecuteAfterBuild;
-			}
-			set {
-				outputConfiguration.ExecuteAfterBuild = value;
-			}
+			get { return executeAfterBuild; }
+			set { executeAfterBuild = value; }
 		}
 		
 		public virtual bool RunWithWarnings {
-			get {
-				return runWithWarnings;
-			}
-			set {
-				runWithWarnings = value;
-			}
+			get { return runWithWarnings; }
+			set { runWithWarnings = value; }
 		}
 		
-		public AbstractProjectConfiguration()
-		{
+		public bool DebugMode {
+			get { return debugmode; }
+			set { debugmode = value; }
 		}
+		
+		public string CommandLineParameters {
+			get { return commandLineParameters; }
+			set { commandLineParameters = value; }
+		}
+		
+		public bool PauseConsoleOutput {
+			get { return pauseconsoleoutput; }
+			set { pauseconsoleoutput = value; }
+		}
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Collections/ProjectFileCollection.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Collections/ProjectFileCollection.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Collections/ProjectFileCollection.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -7,7 +7,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.Internal.Project.Collections
+namespace MonoDevelop.Internal.Project
 {
 	/// &lt;summary&gt;
 	///     &lt;para&gt;
@@ -18,21 +18,20 @@
 	[Serializable()]
 	public class ProjectFileCollection : CollectionBase {
 	
-		AbstractProject project;
+		Project project;
 		
 		/// &lt;summary&gt;
 		///     &lt;para&gt;
 		///       Initializes a new instance of &lt;see cref='.ProjectFileCollection'/&gt;.
 		///    &lt;/para&gt;
 		/// &lt;/summary&gt;
-		public ProjectFileCollection () {
+		public ProjectFileCollection ()
+		{
 		}
 		
-		internal void SetProject (AbstractProject project)
+		public ProjectFileCollection (Project project)
 		{
 			this.project = project;
-			foreach (ProjectFile file in List)
-				file.SetProject (project);
 		}
 		
 		/// &lt;summary&gt;
@@ -48,10 +47,15 @@
 				return ((ProjectFile)(List[index]));
 			}
 			set {
-				project.NotifyFileRemovedFromProject ((ProjectFile)List[index]);
+				if (project != null)
+					project.NotifyFileRemovedFromProject ((ProjectFile)List[index]);
+
 				List[index] = value;
-				value.SetProject (project);
-				project.NotifyFileAddedToProject (value);
+				
+				if (project != null) {
+					value.SetProject (project);
+					project.NotifyFileAddedToProject (value);
+				}
 			}
 		}
 		
@@ -66,8 +70,10 @@
 		/// &lt;seealso cref='.ProjectFileCollection.AddRange'/&gt;
 		public int Add(ProjectFile value) {
 			int i = List.Add(value);
-			value.SetProject (project);
-			project.NotifyFileAddedToProject (value);
+			if (project != null) {
+				value.SetProject (project);
+				project.NotifyFileAddedToProject (value);
+			}
 			return i;
 		}
 		
@@ -159,8 +165,10 @@
 		/// &lt;seealso cref='.ProjectFileCollection.Add'/&gt;
 		public void Insert(int index, ProjectFile value) {
 			List.Insert(index, value);
-			value.SetProject (project);
-			project.NotifyFileAddedToProject (value);
+			if (project != null) {
+				value.SetProject (project);
+				project.NotifyFileAddedToProject (value);
+			}
 		}
 		
 		/// &lt;summary&gt;
@@ -182,6 +190,8 @@
 		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
 		public void Remove(ProjectFile value) {
 			List.Remove(value);
+			if (project != null)
+				project.NotifyFileRemovedFromProject (value);
 		}
 		
 		public class ProjectFileEnumerator : object, IEnumerator {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Collections/ProjectReferenceCollection.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Collections/ProjectReferenceCollection.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Collections/ProjectReferenceCollection.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -7,7 +7,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.Internal.Project.Collections
+namespace MonoDevelop.Internal.Project
 {
 	/// &lt;summary&gt;
 	///     &lt;para&gt;
@@ -18,17 +18,17 @@
 	[Serializable()]
 	public class ProjectReferenceCollection : CollectionBase {
 		
-		AbstractProject project;
+		Project project;
 		
 		/// &lt;summary&gt;
 		///     &lt;para&gt;
 		///       Initializes a new instance of &lt;see cref='.ProjectReferenceCollection'/&gt;.
 		///    &lt;/para&gt;
 		/// &lt;/summary&gt;
-		internal ProjectReferenceCollection() {
+		public ProjectReferenceCollection() {
 		}
 		
-		internal void SetProject (AbstractProject project)
+		internal void SetProject (Project project)
 		{
 			this.project = project;
 		}
@@ -46,9 +46,9 @@
 				return ((ProjectReference)(List[index]));
 			}
 			set {
-				project.NotifyReferenceRemovedFromProject ((ProjectReference)List[index]);
+				if (project != null) project.NotifyReferenceRemovedFromProject ((ProjectReference)List[index]);
 				List[index] = value;
-				project.NotifyReferenceAddedToProject (value);
+				if (project != null) project.NotifyReferenceAddedToProject (value);
 			}
 		}
 		
@@ -63,7 +63,7 @@
 		/// &lt;seealso cref='.ProjectReferenceCollection.AddRange'/&gt;
 		public int Add(ProjectReference value) {
 			int i = List.Add(value);
-			project.NotifyReferenceAddedToProject (value);
+			if (project != null) project.NotifyReferenceAddedToProject (value);
 			return i;
 		}
 		
@@ -155,7 +155,7 @@
 		/// &lt;seealso cref='.ProjectReferenceCollection.Add'/&gt;
 		public void Insert(int index, ProjectReference value) {
 			List.Insert(index, value);
-			project.NotifyReferenceAddedToProject (value);
+			if (project != null) project.NotifyReferenceAddedToProject (value);
 		}
 		
 		/// &lt;summary&gt;
@@ -177,7 +177,7 @@
 		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
 		public void Remove(ProjectReference value) {
 			List.Remove(value);
-			project.NotifyReferenceRemovedFromProject (value);
+			if (project != null) project.NotifyReferenceRemovedFromProject (value);
 		}
 		
 		public class ProjectReferenceEnumerator : object, IEnumerator {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/AssemblyDeploy.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/AssemblyDeploy.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/AssemblyDeploy.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -21,24 +21,17 @@
 			&quot;.dll&quot;
 		};
 		
-		public void DeployProject(IProject project)
+		public void DeployProject(Project project)
 		{
 			if (project.DeployInformation.DeployTarget.Length == 0) {
 				Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;Can't deploy: no deployment target set&quot;));
 				return;
 			}
 			try {
-				AbstractProjectConfiguration config = (AbstractProjectConfiguration)project.ActiveConfiguration;
-				FileUtilityService fileUtilityService = Runtime.FileUtilityService;
-				string assembly = fileUtilityService.GetDirectoryNameWithSeparator(config.OutputDirectory) + config.OutputAssembly;
-				
-				foreach (string  ext in extensions) {
-					if (File.Exists(assembly + ext)) {
-						File.Copy(assembly + ext, fileUtilityService.GetDirectoryNameWithSeparator(project.DeployInformation.DeployTarget) + config.OutputAssembly + ext, true);
-						return;
-					}
-				}
-				throw new Exception(&quot;Assembly not found.&quot;);
+				if (File.Exists (project.GetOutputFileName ()))
+					File.Copy (project.GetOutputFileName (), Path.GetFileName (project.GetOutputFileName ()), true);
+				else
+					throw new Exception(&quot;Assembly not found.&quot;);
 			} catch (Exception e) {
 				Runtime.MessageService.ShowError(e);
 			}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/DeployInformation.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/DeployInformation.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/DeployInformation.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -10,6 +10,7 @@
 using System.IO;
 using System.Xml;
 
+using MonoDevelop.Internal.Serialization;
 using MonoDevelop.Internal.Project;
 
 namespace MonoDevelop.Internal.Project
@@ -20,14 +21,13 @@
 		File
 	}
 	
-	[XmlNodeName(&quot;DeploymentInformation&quot;)]
+	[DataItem (&quot;DeploymentInformation&quot;)]
 	public class DeployInformation
 	{
-		[XmlNodeName(&quot;Exclude&quot;)]
+		[DataItem (&quot;Exclude&quot;)]
 		class ExcludeFile 
 		{
-			[XmlAttribute(&quot;file&quot;)]
-			[ConvertToRelativePathAttribute()]
+			[ProjectPathItemProperty (&quot;file&quot;)]
 			protected string fileName;
 			
 			public string FileName {
@@ -49,16 +49,17 @@
 			}
 		}
 		
-		[XmlSetAttribute(typeof(ExcludeFile))]
+		[ItemProperty]
+		[ItemProperty (&quot;ExcludeFile&quot;, ValueType = typeof(ExcludeFile), Scope = 1)]
 		ArrayList excludeFiles = new ArrayList();
 		
-		[XmlAttribute(&quot;target&quot;)]
-		string    deployTarget = &quot;&quot;;
+		[ItemProperty (&quot;target&quot;, DefaultValue = &quot;&quot;)]
+		string deployTarget = &quot;&quot;;
 		
-		[XmlAttribute(&quot;script&quot;)]
-		string    deployScript = &quot;&quot;;
+		[ItemProperty (&quot;script&quot;, DefaultValue = &quot;&quot;)]
+		string deployScript = &quot;&quot;;
 		
-		[XmlAttribute(&quot;strategy&quot;)]
+		[ItemProperty (&quot;strategy&quot;)]
 		DeploymentStrategy deploymentStrategy = DeploymentStrategy.File;
 		
 		public DeploymentStrategy DeploymentStrategy {
@@ -131,7 +132,7 @@
 		{
 		}
 		
-		public static void Deploy(IProject project)
+		public static void Deploy(Project project)
 		{
 			switch (project.DeployInformation.DeploymentStrategy) {
 				case DeploymentStrategy.File:

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/FileDeploy.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/FileDeploy.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/FileDeploy.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -16,7 +16,7 @@
 {
 	public class FileDeploy : IDeploymentStrategy
 	{
-		public void DeployProject(IProject project)
+		public void DeployProject(Project project)
 		{
 			if (project.DeployInformation.DeployTarget.Length == 0) {
 				Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;Can't deploy: you forgot to specify a deployment script&quot;));

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/IDeploymentStrategy.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/IDeploymentStrategy.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/IDeploymentStrategy.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -9,7 +9,7 @@
 {
 	public interface IDeploymentStrategy
 	{
-		void DeployProject(IProject project);
+		void DeployProject(Project project);
 	}
 	
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/ScriptDeploy.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/ScriptDeploy.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/Deployment/ScriptDeploy.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -16,7 +16,7 @@
 {
 	public class ScriptDeploy : IDeploymentStrategy
 	{
-		public void DeployProject(IProject project)
+		public void DeployProject(Project project)
 		{
 			if (project.DeployInformation.DeployScript.Length == 0) {
 				Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;Can't deploy: you forgot to specify a deployment script&quot;));

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProject.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProject.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProject.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,185 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Diagnostics;
+using System.Xml;
+using MonoDevelop.Internal.Serialization;
+using MonoDevelop.Internal.Templates;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Project
+{
+	[DataInclude (typeof(DotNetProjectConfiguration))]
+	public class DotNetProject : Project
+	{
+		[ItemProperty]
+		string language;
+		
+		ILanguageBinding languageBinding;
+		
+		public override string ProjectType {
+			get { return &quot;DotNet&quot;; }
+		}
+		
+		public string LanguageName {
+			get { return language; }
+		}
+		
+		internal DotNetProject ()
+		{
+		}
+		
+		internal DotNetProject (string languageName)
+		{
+			language = languageName;
+			languageBinding = FindLanguage (language);
+		}
+		
+		public DotNetProject (string languageName, ProjectCreateInformation info, XmlElement projectOptions)
+		{
+			string binPath;
+			if (info != null) {
+				Name = info.ProjectName;
+				binPath = info.BinPath;
+			} else {
+				binPath = &quot;.&quot;;
+			}
+			
+			language = languageName;
+			languageBinding = FindLanguage (language);
+			
+			DotNetProjectConfiguration configuration = CreateConfiguration ();
+			configuration.Name = &quot;Debug&quot;;
+			configuration.CompilationParameters = languageBinding.CreateCompilationParameters (projectOptions);
+			Configurations.Add (configuration);
+			
+			configuration = CreateConfiguration ();
+			configuration.Name = &quot;Release&quot;;
+			configuration.CompilationParameters = languageBinding.CreateCompilationParameters (projectOptions);
+			Configurations.Add (configuration);
+			
+			foreach (DotNetProjectConfiguration parameter in Configurations) {
+				parameter.OutputDirectory = Path.Combine (binPath, parameter.Name);
+				parameter.OutputAssembly  = Name;
+				
+				if (projectOptions != null) {
+					if (projectOptions.Attributes[&quot;Target&quot;] != null) {
+						parameter.CompileTarget = (CompileTarget)Enum.Parse(typeof(CompileTarget), projectOptions.Attributes[&quot;Target&quot;].InnerText);
+					}
+					if (projectOptions.Attributes[&quot;PauseConsoleOutput&quot;] != null) {
+						parameter.PauseConsoleOutput = Boolean.Parse(projectOptions.Attributes[&quot;PauseConsoleOutput&quot;].InnerText);
+					}
+				}
+			}
+		}
+		
+		public override void Deserialize (ITypeSerializer handler, DataCollection data)
+		{
+			base.Deserialize (handler, data);
+			languageBinding = FindLanguage (language);
+		}
+		
+		ILanguageBinding FindLanguage (string name)
+		{
+			ILanguageBinding binding = Runtime.Languages.GetBindingPerLanguageName (language);
+			if (binding == null)
+				throw new InvalidOperationException (&quot;Language not supported: &quot; + language);
+			return binding;
+		}
+
+		protected virtual DotNetProjectConfiguration CreateConfiguration ()
+		{
+			return new DotNetProjectConfiguration ();
+		}
+		
+		protected override ICompilerResult DoBuild ()
+		{
+			DotNetProjectConfiguration conf = (DotNetProjectConfiguration) ActiveConfiguration;
+			foreach (ProjectFile finfo in ProjectFiles) {
+				// Treat app.config in the project root directory as the application config
+				if (Path.GetFileName (finfo.Name).ToUpper () == &quot;app.config&quot;.ToUpper() &amp;&amp;
+					Path.GetDirectoryName (finfo.Name) == BaseDirectory)
+				{
+					File.Copy (finfo.Name, conf.CompiledOutputName + &quot;.config&quot;,true);
+				}
+			}
+
+			ICompilerResult res = languageBinding.Compile (ProjectFiles, ProjectReferences, conf);
+			CopyReferencesToOutputPath (false);
+			return res;
+		}
+		
+		public override string GetOutputFileName ()
+		{
+			DotNetProjectConfiguration conf = (DotNetProjectConfiguration) ActiveConfiguration;
+			return conf.CompiledOutputName;
+		}
+		
+		public override void Debug ()
+		{
+			if (Runtime.TaskService.Errors != 0) return;
+
+			DotNetProjectConfiguration configuration = (DotNetProjectConfiguration) ActiveConfiguration;
+			if (Runtime.DebuggingService != null)
+				Runtime.DebuggingService.Run (new string[] { configuration.CompiledOutputName } );
+		}
+
+		protected override void DoExecute ()
+		{
+			CopyReferencesToOutputPath (true);
+			
+			DotNetProjectConfiguration configuration = (DotNetProjectConfiguration) ActiveConfiguration;
+			string args = configuration.CommandLineParameters;
+			
+			ProcessStartInfo psi;
+			string runtimeStarter = &quot;mono --debug &quot;;
+			
+			switch (configuration.NetRuntime) {
+				case NetRuntime.Mono:
+					runtimeStarter = &quot;mono --debug &quot;;
+					break;
+				case NetRuntime.MonoInterpreter:
+					runtimeStarter = &quot;mint &quot;;
+					break;
+			}
+			
+			string additionalCommands = &quot;&quot;;
+			if (configuration.PauseConsoleOutput)
+				additionalCommands = @&quot;echo; read -p 'press any key to continue...' -n1;&quot;;
+
+			psi = new ProcessStartInfo(&quot;xterm&quot;,
+				string.Format (
+				@&quot;-e &quot;&quot;{0} '{1}' {2} ; {3}&quot;&quot;&quot;,
+				runtimeStarter, configuration.CompiledOutputName, args, additionalCommands));
+			psi.UseShellExecute = false;
+			
+			try {
+				psi.WorkingDirectory = Path.GetDirectoryName (configuration.CompiledOutputName);
+				psi.UseShellExecute  =  false;
+				
+				Process p = new Process();
+				p.StartInfo = psi;
+				p.Start();
+			} catch (Exception) {
+				throw new ApplicationException(&quot;Can not execute &quot; + &quot;\&quot;&quot; + configuration.CompiledOutputName + &quot;\&quot;\n(Try restarting MonoDevelop or start your app manually)&quot;);
+			}
+		}
+
+		public override void GenerateMakefiles (Combine parentCombine)
+		{
+			Console.WriteLine (&quot;Generating makefiles for &quot; + Name);
+			languageBinding.GenerateMakefile (this, parentCombine);
+		}
+		
+		public override bool IsCompileable(string fileName)
+		{
+			return languageBinding.CanCompile(LanguageName);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProjectBinding.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProjectBinding.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProjectBinding.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,72 @@
+//
+// DotNetProjectBinding.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml;
+using MonoDevelop.Internal.Serialization;
+using MonoDevelop.Internal.Templates;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Project
+{
+	public class DotNetProjectBinding : IProjectBinding
+	{
+		ProjectTemplate[] defaultTemplates = new ProjectTemplate [0];
+		
+		public virtual string Name {
+			get { return &quot;DotNet&quot;; }
+		}
+		
+		public Project CreateProject (ProjectCreateInformation info, XmlElement projectOptions)
+		{
+			string lang = projectOptions.GetAttribute (&quot;language&quot;);
+			return CreateProject (lang, info, projectOptions);
+		}
+		
+		protected virtual DotNetProject CreateProject (string languageName, ProjectCreateInformation info, XmlElement projectOptions)
+		{
+			return new DotNetProject (languageName, info, projectOptions);
+		}
+		
+		public Project CreateSingleFileProject (string file)
+		{
+			ILanguageBinding binding = Runtime.Languages.GetBindingPerFileName (file);
+			if (binding != null) {
+				Project project = CreateProject (binding.Language, null, null);
+				project.ProjectFiles.Add (new ProjectFile (file));
+				return project;
+			}
+			return null;
+		}
+		
+		public ProjectTemplate[] GetDefaultTemplates ()
+		{
+			return defaultTemplates;
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProjectConfiguration.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProjectConfiguration.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/DotNetProjectConfiguration.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,86 @@
+//
+// DotNetProjectConfiguration.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using MonoDevelop.Internal.Serialization;
+
+namespace MonoDevelop.Internal.Project
+{
+	public enum NetRuntime {
+		Mono,
+		MonoInterpreter,
+		MsNet
+	};
+	
+	public enum CompileTarget {
+		Exe,
+		Library,
+		WinExe, 
+		Module
+	};
+	
+	public class DotNetProjectConfiguration: AbstractProjectConfiguration
+	{
+		[ItemProperty (&quot;Output/assembly&quot;)]
+		string assembly = &quot;a&quot;;
+		
+		[ItemProperty (&quot;Execution/runtime&quot;)]
+		NetRuntime netRuntime = NetRuntime.MsNet;
+		
+		[ItemProperty (&quot;Build/target&quot;)]
+		CompileTarget compiletarget = CompileTarget.Exe;
+		
+		[ItemProperty (&quot;CodeGeneration&quot;)]
+		object compilationParameters;
+
+		public virtual string OutputAssembly {
+			get { return assembly; }
+			set { assembly = value; }
+		}
+		
+		public NetRuntime NetRuntime {
+			get { return netRuntime; }
+			set { netRuntime = value; }
+		}
+
+		public CompileTarget CompileTarget {
+			get { return compiletarget; }
+			set { compiletarget = value; }
+		}
+		
+		public object CompilationParameters {
+			get { return compilationParameters; }
+			set { compilationParameters = value; }
+		}
+		
+		public string CompiledOutputName {
+			get { return Path.Combine (OutputDirectory, OutputAssembly) + (CompileTarget == CompileTarget.Library ? &quot;.dll&quot; : &quot;.exe&quot;); }
+		}
+	}
+}

Deleted: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IProject.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IProject.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IProject.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -1,165 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-using System.Xml;
-using MonoDevelop.Internal.Project.Collections;
-
-namespace MonoDevelop.Internal.Project
-{
-	public enum NewFileSearch {
-		None,
-		OnLoad,
-		OnLoadAutoInsert
-	}
-	
-	/// &lt;summary&gt;
-	/// This interface describes the whole functionalaty a SharpDevelop project has.
-	/// &lt;/summary&gt;
-	public interface IProject : IDisposable
-	{
-		/// &lt;summary&gt;
-		/// Returns the language codon name, which is used
-		/// to compile this project.
-		/// &lt;/summary&gt;
-		string ProjectType {
-			get;
-		}
-		
-		/// &lt;summary&gt;
-		/// Gets the directory where the projectfile is located.
-		/// &lt;/summary&gt;
-		string BaseDirectory {
-			get;
-		}
-		
-		/// &lt;summary&gt;
-		/// The name of the project.
-		/// &lt;/summary&gt;
-		string Name {
-			get;
-			set;
-		}
-		
-		/// &lt;summary&gt;
-		/// The description of the project.
-		/// &lt;/summary&gt;
-		string Description {
-			get;
-			set;
-		}
-		
-		/// &lt;summary&gt;
-		/// Gets/Sets the active configuration.
-		/// &lt;/summary&gt;
-		IConfiguration ActiveConfiguration {
-			get;
-			set;
-		}
-		
-		/// &lt;summary&gt;
-		/// Gets the arraylist which contains all project configurations.
-		/// &lt;/summary&gt;
-		ArrayList Configurations {
-			get;
-		}
-		
-		/// &lt;summary&gt;
-		/// A collection containing all files &amp; empty directories in the project.
-		/// &lt;/summary&gt;
-		ProjectFileCollection ProjectFiles {
-			get;
-		}
-		
-		/// &lt;summary&gt;
-		/// A collection containing all references in the project.
-		/// &lt;/summary&gt;
-		ProjectReferenceCollection ProjectReferences {
-			get;
-		}
-		
-		/// &lt;summary&gt;
-		/// The method on how newly found files (files which are in the project subdir
-		/// but not in the project) are handled.
-		/// &lt;/summary&gt;
-		NewFileSearch NewFileSearch {
-			get;
-			set;
-		}
-		
-		/// &lt;summary&gt;
-		/// If this property is true the state of the workbench (open files, project/class scout
-		/// state) should be made persistent
-		/// &lt;/summary&gt;
-		bool EnableViewState {
-			get;
-			set;
-		}
-		
-		
-		DeployInformation DeployInformation {
-			get;
-		}
-		
-		/// &lt;summary&gt;
-		/// Returns true, if the language module which defined this project is able
-		/// to compile the file 'fileName'. e.g. returns true, if the file fileName
-		/// could be added as compileable file to the project.
-		/// &lt;/summary&gt;
-		bool IsCompileable(string fileName);
-		
-		/// &lt;summary&gt;
-		/// Loads this Project from fileName
-		/// &lt;/summary&gt;
-		void LoadProject(string fileName);
-		
-		/// &lt;summary&gt;
-		/// Saves this Project under fileName
-		/// &lt;/summary&gt;
-		void SaveProject(string fileName);
-		
-		/// &lt;summary&gt;
-		/// Copies all references to the bin path of this project
-		/// &lt;/summary&gt;
-		/// &lt;param name=&quot;force&quot;&gt;
-		/// if set to true all files are copied, overriding the localcopy property of
-		/// the reference.
-		/// &lt;/param&gt;
-		void CopyReferencesToOutputPath(bool force);
-		
-		/// &lt;summary&gt;
-		/// Returns true, if a specific file (given by it's name) 
-		/// is inside this project.
-		/// &lt;/summary&gt;
-		bool IsFileInProject(string fileName);
-		
-		/// &lt;summary&gt;
-		/// Returns the file content as a string which can be parsed by the parser.
-		/// The fileName must be a file name in the project. This is used for files
-		/// 'behind' other files or zipped file contents etc.
-		/// &lt;/summary&gt;
-		string GetParseableFileContent(string fileName);
-		
-		/// &lt;summary&gt;
-		/// Creates a IConfiguration object which is used by this project type.
-		/// &lt;/summary&gt;
-		IConfiguration CreateConfiguration(string name);
-		
-		/// &lt;summary&gt;
-		/// Creates a IConfiguration object which is used by this project type.
-		/// &lt;/summary&gt;
-		IConfiguration CreateConfiguration();
-		
-		event EventHandler NameChanged;
-		event ProjectFileEventHandler FileRemovedFromProject;
-		event ProjectFileEventHandler FileAddedToProject;
-		event ProjectFileEventHandler FileChangedInProject;
-		event ProjectReferenceEventHandler ReferenceRemovedFromProject;
-		event ProjectReferenceEventHandler ReferenceAddedToProject;
-	}
-}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IncludeFilesDialog.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IncludeFilesDialog.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/IncludeFilesDialog.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -37,10 +37,10 @@
 		
 		// regular members
 		StringCollection newFiles;
-		IProject         project;
+		Project         project;
 		FileUtilityService fileUtilityService = Runtime.FileUtilityService;
 		
-		public IncludeFilesDialog(IProject project, StringCollection newFiles)
+		public IncludeFilesDialog(Project project, StringCollection newFiles)
 		{
 			Console.WriteLine (&quot;*** Include files dialog ***&quot;);
 			// we must do it from *here* otherwise, we get this assembly, not the caller

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectFile.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectFile.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectFile.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -11,7 +11,7 @@
 using System.ComponentModel;
 using System.Diagnostics;
 using System.Xml;
-using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Serialization;
 using MonoDevelop.Gui.Components;
 
 namespace MonoDevelop.Internal.Project
@@ -37,31 +37,48 @@
 	/// &lt;summary&gt;
 	/// This class represent a file information in an IProject object.
 	/// &lt;/summary&gt;
-	[XmlNodeName(&quot;File&quot;)]	
 	public class ProjectFile : LocalizedObject, ICloneable
 	{
-		[XmlAttribute(&quot;name&quot;),
-		 ConvertToRelativePath()]
-		string      filename;
+		[ProjectPathItemProperty(&quot;name&quot;)]
+		string filename;
 		
-		[XmlAttribute(&quot;subtype&quot;)]	
-		Subtype     subtype;
+		[ItemProperty(&quot;subtype&quot;)]	
+		Subtype subtype;
 		
-		[XmlAttribute(&quot;buildaction&quot;)]
+		[ItemProperty(&quot;buildaction&quot;)]
 		BuildAction buildaction;
 		
-		[XmlAttribute(&quot;dependson&quot;),
-		 ConvertToRelativePath()]		
-		string		dependsOn;
+		[ItemProperty(&quot;dependson&quot;, DefaultValue=&quot;&quot;)]		
+		string dependsOn;
 		
-		[XmlAttribute(&quot;data&quot;)]
-		string		data;
+		[ItemProperty(&quot;data&quot;, DefaultValue=&quot;&quot;)]
+		string data;
 		
-		[XmlAttribute(null)]
-		AbstractProject project;
+		Project project;
 		
 		private FileSystemWatcher ProjectFileWatcher;
 		
+		public ProjectFile()
+		{
+			AddFileWatch();
+		}
+		
+		public ProjectFile(string filename)
+		{
+			this.filename = filename;
+			subtype       = Subtype.Code;
+			buildaction   = BuildAction.Compile;
+			AddFileWatch();
+		}
+		
+		public ProjectFile(string filename, BuildAction buildAction)
+		{
+			this.filename = filename;
+			subtype       = Subtype.Code;
+			buildaction   = buildAction;
+			AddFileWatch();
+		}
+		
 		private void AddFileWatch()
 		{
 			ProjectFileWatcher = new FileSystemWatcher();
@@ -78,20 +95,25 @@
 		
 			if ((this.filename == null) || (this.filename.Length == 0))
 				return;				
-					
-			ProjectFileWatcher.EnableRaisingEvents = false;
-			ProjectFileWatcher.Path = Path.GetDirectoryName(filename);
-			ProjectFileWatcher.Filter = Path.GetFileName(filename);
-			ProjectFileWatcher.EnableRaisingEvents = true;
 
+			try {
+				ProjectFileWatcher.EnableRaisingEvents = false;
+				ProjectFileWatcher.Path = Path.GetDirectoryName(filename);
+				ProjectFileWatcher.Filter = Path.GetFileName(filename);
+				ProjectFileWatcher.EnableRaisingEvents = true;
+			} catch {
+				Console.WriteLine (&quot;NOT WATCHING &quot; + filename);
+			}
+
 		}
 		
 		private void OnChanged(object source, FileSystemEventArgs e)
 		{
-			project.NotifyFileChangedInProject(this);
+			if (project != null)
+				project.NotifyFileChangedInProject(this);
 		}
 
-		internal void SetProject (AbstractProject prj)
+		internal void SetProject (Project prj)
 		{
 			project = prj;
 			UpdateFileWatch();
@@ -105,14 +127,24 @@
 				return filename;
 			}
 			set {
-				project.NotifyFileRemovedFromProject (this);
+				Debug.Assert (value != null &amp;&amp; value.Length &gt; 0, &quot;name == null || name.Length == 0&quot;);
+				if (project != null) project.NotifyFileRemovedFromProject (this);
 				filename = value;
 				UpdateFileWatch();
-				Debug.Assert(filename != null &amp;&amp; filename.Length &gt; 0, &quot;name == null || name.Length == 0&quot;);
-				project.NotifyFileAddedToProject (this);
+				if (project != null) project.NotifyFileAddedToProject (this);
 			}
 		}
 		
+		public string FilePath {
+			get {
+				return filename;
+			}
+		}
+		
+		public string RelativePath {
+			get { return filename; }
+		}
+		
 		[Browsable(false)]
 		public Subtype Subtype {
 			get {
@@ -154,27 +186,6 @@
 			}
 		}
 		
-		public ProjectFile()
-		{
-			AddFileWatch();
-		}
-		
-		public ProjectFile(string filename)
-		{
-			this.filename = filename;
-			subtype       = Subtype.Code;
-			buildaction   = BuildAction.Compile;
-			AddFileWatch();
-		}
-		
-		public ProjectFile(string filename, BuildAction buildAction)
-		{
-			this.filename = filename;
-			subtype       = Subtype.Code;
-			buildaction   = buildAction;
-			AddFileWatch();
-		}
-		
 		public object Clone()
 		{
 			return MemberwiseClone();

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectFileEventArgs.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectFileEventArgs.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectFileEventArgs.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,10 +14,10 @@
 	
 	public class ProjectFileEventArgs : EventArgs
 	{
-		IProject project;
+		Project project;
 		ProjectFile file;
 		
-		public IProject Project {
+		public Project Project {
 			get {
 				return project;
 			}
@@ -29,7 +29,7 @@
 			}
 		}
 		
-		public ProjectFileEventArgs (IProject project, ProjectFile file)
+		public ProjectFileEventArgs (Project project, ProjectFile file)
 		{
 			this.project = project;
 			this.file = file;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReference.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReference.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReference.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,6 +14,7 @@
 using System.ComponentModel;
 using MonoDevelop.Gui.Components;
 using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Serialization;
 
 namespace MonoDevelop.Internal.Project
 {
@@ -25,20 +26,18 @@
 	}
 	
 	/// &lt;summary&gt;
-	/// This class represent a reference information in an IProject object.
+	/// This class represent a reference information in an Project object.
 	/// &lt;/summary&gt;
-	[XmlNodeName(&quot;Reference&quot;)]
-	public class ProjectReference : LocalizedObject, ICloneable
+	[DataItemAttribute (&quot;Reference&quot;)]
+	public class ProjectReference : LocalizedObject, ICloneable, ICustomDataItem
 	{
-		[XmlAttribute(&quot;type&quot;)]
+		[ItemProperty (&quot;type&quot;)]
 		ReferenceType referenceType;
 		
-		[XmlAttribute(&quot;refto&quot;)]
-		[ConvertToRelativePath(&quot;IsAssembly&quot;)]
-		string        reference = String.Empty;
+		string reference = String.Empty;
 		
-		[XmlAttribute(&quot;localcopy&quot;)]
-		bool          localCopy = true;
+		[ItemProperty (&quot;localcopy&quot;)]
+		bool localCopy = true;
 		
 		bool IsAssembly {
 			get {
@@ -88,7 +87,7 @@
 		/// Returns the file name to an assembly, regardless of what 
 		/// type the assembly is.
 		/// &lt;/summary&gt;
-		public string GetReferencedFileName(IProject project)
+		public string GetReferencedFileName ()
 		{
 			switch (ReferenceType) {
 				case ReferenceType.Typelib:
@@ -100,8 +99,8 @@
 					string file = Runtime.ParserService.LoadAssemblyFromGac (GetPathToGACAssembly (this));
 					return file == String.Empty ? reference : file;
 				case ReferenceType.Project:
-					string projectOutputLocation   = Runtime.ProjectService.GetOutputAssemblyName(reference);
-					return projectOutputLocation;
+					Project p = Runtime.ProjectService.GetProject (reference);
+					return p != null ? p.GetOutputFileName () : null;
 				
 				default:
 					throw new NotImplementedException(&quot;unknown reference type : &quot; + ReferenceType);
@@ -118,7 +117,31 @@
 			this.reference     = reference;
 		}
 		
+		DataCollection ICustomDataItem.Serialize (ITypeSerializer handler)
+		{
+			DataCollection data = handler.Serialize (this);
+			string refto = reference;
+			if (referenceType == ReferenceType.Assembly) {
+				string basePath = Path.GetDirectoryName (handler.SerializationContext.BaseFile);
+				refto = Runtime.FileUtilityService.AbsoluteToRelativePath (basePath, refto);
+			}
+			data.Add (new DataValue (&quot;refto&quot;, refto));
+			return data;
+		}
 		
+		void ICustomDataItem.Deserialize (ITypeSerializer handler, DataCollection data)
+		{
+			DataValue refto = data.Extract (&quot;refto&quot;) as DataValue;
+			handler.Deserialize (this, data);
+			if (refto != null) {
+				reference = refto.Value;
+				if (referenceType == ReferenceType.Assembly) {
+					string basePath = Path.GetDirectoryName (handler.SerializationContext.BaseFile);
+					reference = Runtime.FileUtilityService.RelativeToAbsolutePath (basePath, reference);
+				}
+			}
+		}
+		
 		/// &lt;summary&gt;
 		/// This method returns the absolute path to an GAC assembly.
 		/// &lt;/summary&gt;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReferenceEventArgs.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReferenceEventArgs.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/ProjectReferenceEventArgs.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,10 +14,10 @@
 	
 	public class ProjectReferenceEventArgs : EventArgs
 	{
-		IProject project;
+		Project project;
 		ProjectReference reference;
 		
-		public IProject Project {
+		public Project Project {
 			get {
 				return project;
 			}
@@ -29,7 +29,7 @@
 			}
 		}
 		
-		public ProjectReferenceEventArgs (IProject project, ProjectReference reference)
+		public ProjectReferenceEventArgs (Project project, ProjectReference reference)
 		{
 			this.project = project;
 			this.reference = reference;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/TypelibImporter.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/TypelibImporter.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/Project/TypelibImporter.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -41,7 +41,7 @@
 		{
 		}
 		
-		public string Import(ProjectReference refinfo, IProject project)
+		public string Import(ProjectReference refinfo, Project project)
 		{
 			RegistryKey root = Registry.ClassesRoot;
 			RegistryKey typelibsKey = root.OpenSubKey(&quot;TypeLib&quot;);

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/ProjectPathItemPropertyAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/ProjectPathItemPropertyAttribute.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Project/ProjectPathItemPropertyAttribute.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,71 @@
+//
+// ProjectPathItemProperty.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using MonoDevelop.Internal.Serialization;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Project
+{
+	public class ProjectPathItemProperty: ItemPropertyAttribute
+	{
+		public ProjectPathItemProperty ()
+		{
+			SerializationDataType = typeof (PathDataType);
+		}
+		
+		public ProjectPathItemProperty (string name): base (name)
+		{
+			SerializationDataType = typeof (PathDataType);
+		}
+	}
+	
+	public class PathDataType: PrimitiveDataType
+	{
+		public PathDataType (Type type): base (type)
+		{
+		}
+
+		public override DataNode Serialize (SerializationContext serCtx, object mapData, object value)
+		{
+			if (value == null || ((string)value).Length == 0) return null;
+			string basePath = Path.GetDirectoryName (serCtx.BaseFile);
+			string file = Runtime.FileUtilityService.AbsoluteToRelativePath (basePath, value.ToString ());
+			return new DataValue (Name, file);
+		}
+		
+		public override object Deserialize (SerializationContext serCtx, object mapData, DataNode data)
+		{
+			string basePath = Path.GetDirectoryName (serCtx.BaseFile);
+			return Runtime.FileUtilityService.RelativeToAbsolutePath (basePath, ((DataValue)data).Value);
+		}
+	}
+}
+
+

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ArrayHandler.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ArrayHandler.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ArrayHandler.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,120 @@
+//
+// ArrayHandler.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	internal class ArrayHandler: ICollectionHandler
+	{
+		Type _type;
+		Type _elementType;
+		
+		public ArrayHandler (Type type)
+		{
+			_type = type;
+			_elementType = type.GetElementType (); 
+		}
+		
+		public Type GetItemType ()
+		{
+			return _elementType;
+		}
+		
+		public bool CanCreateInstance {
+			get { return true; }
+		}
+		
+		public object CreateCollection (out object position, int size)
+		{
+			position = 0;
+			return Array.CreateInstance (_elementType, size != -1 ? size : 5);
+		}
+		
+		public void ResetCollection (object collection, out object position, int size)
+		{
+			throw new InvalidOperationException (&quot;Array instance could not be reused.&quot;);
+		}
+		
+		public void AddItem (ref object collection, ref object position, object item)
+		{
+			int i = (int)position;
+			Array ar = (Array) collection;
+			if (i &gt;= ar.Length) {
+				Array newArray = Array.CreateInstance (_elementType, ar.Length + 5);
+				Array.Copy (ar, newArray, ar.Length);
+				collection = newArray;
+				newArray.SetValue (item, i);
+			}
+			else
+				ar.SetValue (item, i);
+			position = i + 1;
+		}
+		
+		public void SetItem (object collection, object position, object item)
+		{
+			int i = (int)position;
+			((Array) collection).SetValue (item, i);
+		}
+		
+		public void FinishCreation (ref object collection, object position)
+		{
+			int i = (int)position;
+			Array ar = (Array) collection;
+			if (i &lt; ar.Length) {
+				Array newArray = Array.CreateInstance (_elementType, i);
+				Array.Copy (ar, newArray, i);
+				collection = newArray;
+			}
+		}
+		
+		public bool IsEmpty (object collection)
+		{
+			return collection == null || ((Array)collection).Length == 0;
+		}
+		
+		public object GetInitialPosition (object collection)
+		{
+			return -1;
+		}
+		
+		public bool MoveNextItem (object collection, ref object position)
+		{
+			int i = (int) position;
+			position = ++i;
+			Array ar = (Array) collection;
+			return i &lt; ar.Length; 
+		}
+		
+		public object GetCurrentItem (object collection, object position)
+		{
+			return ((Array)collection).GetValue ((int)position);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ArrayListHandler.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ArrayListHandler.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ArrayListHandler.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,97 @@
+//
+// ArrayListHandler.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	internal class ArrayListHandler: ICollectionHandler
+	{
+		public static ArrayListHandler Instance = new ArrayListHandler ();
+		
+		public Type GetItemType ()
+		{
+			return typeof(object);
+		}
+		
+		public bool CanCreateInstance {
+			get { return true; }
+		}
+		
+		public object CreateCollection (out object position, int size)
+		{
+			position = 0;
+			if (size != -1) return new ArrayList (size);
+			else return new ArrayList ();
+		}
+		
+		public void ResetCollection (object collection, out object position, int size)
+		{
+			position = 0;
+		}
+		
+		public void AddItem (ref object collection, ref object position, object item)
+		{
+			((ArrayList) collection).Add (item);
+			position = (int)position + 1;
+		}
+		
+		public void SetItem (object collection, object position, object item)
+		{
+			((ArrayList) collection) [(int)position] = item;
+		}
+		
+		public void FinishCreation (ref object collection, object position)
+		{
+		}
+		
+		public bool IsEmpty (object collection)
+		{
+			return collection == null || ((ArrayList)collection).Count == 0;
+		}
+		
+		public object GetInitialPosition (object collection)
+		{
+			return -1;
+		}
+		
+		public bool MoveNextItem (object collection, ref object position)
+		{
+			int i = (int) position;
+			position = ++i;
+			ArrayList ar = (ArrayList) collection;
+			return i &lt; ar.Count; 
+		}
+		
+		public object GetCurrentItem (object collection, object position)
+		{
+			return ((ArrayList)collection) [(int)position];
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ClassDataType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ClassDataType.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ClassDataType.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,369 @@
+//
+// ClassDataType.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class ClassDataType: DataType
+	{
+		Hashtable properties = new Hashtable ();
+		ArrayList sortedPoperties = new ArrayList ();
+		ArrayList subtypes;
+		
+		public ClassDataType (Type propType): base (propType)
+		{
+		}
+		
+		public override bool IsSimpleType { get { return false; } }
+		public override bool CanCreateInstance { get { return true; } }
+		public override bool CanReuseInstance { get { return true; } }
+		
+		protected override void Initialize ()
+		{
+			object[] incs = ValueType.GetCustomAttributes (typeof (DataIncludeAttribute), true);
+			foreach (DataIncludeAttribute incat in incs) {
+				Context.IncludeType (incat.Type);
+			}
+			
+			if (ValueType.BaseType != null) {
+				ClassDataType baseType = (ClassDataType) Context.GetConfigurationDataType (ValueType.BaseType);
+				baseType.AddSubtype (this); 
+				foreach (ItemProperty prop in baseType.Properties) {
+					properties.Add (prop.Name, prop);
+					sortedPoperties.Add (prop);
+				}
+			}
+
+			foreach (Type interf in ValueType.GetInterfaces ()) {
+				ClassDataType baseType = (ClassDataType) Context.GetConfigurationDataType (interf);
+				baseType.AddSubtype (this);
+			}
+			
+			MemberInfo[] members = ValueType.GetMembers (BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
+			foreach (MemberInfo member in members) {
+				if ((member is FieldInfo || member is PropertyInfo) &amp;&amp; member.DeclaringType == ValueType) {
+					object[] ats = member.GetCustomAttributes (true);
+					
+					ItemPropertyAttribute at = FindPropertyAttribute (ats, 0);
+					if (at == null) continue;
+					
+					ItemProperty prop = new ItemProperty ();
+					prop.Name = (at.Name != null) ? at.Name : member.Name;
+					prop.ExpandedCollection = member.IsDefined (typeof(ExpandedCollectionAttribute), true);
+					prop.DefaultValue = at.DefaultValue;
+					Type memberType = member is FieldInfo ? ((FieldInfo)member).FieldType : ((PropertyInfo)member).PropertyType;
+
+					if (prop.ExpandedCollection) {
+						ICollectionHandler handler = Context.GetCollectionHandler (memberType);
+						if (handler == null)
+							throw new InvalidOperationException (&quot;ExpandedCollectionAttribute can't be applied to property '&quot; + prop.Name + &quot;' in type '&quot; + ValueType + &quot;' becuase it is not a valid collection.&quot;);
+							
+						memberType = handler.GetItemType ();
+						prop.ExpandedCollectionHandler = handler;
+					}
+
+					if (at.ValueType != null)
+						prop.PropertyType = at.ValueType;
+					else
+						prop.PropertyType = memberType;
+						
+					if (at.SerializationDataType != null) {
+						try {
+							prop.DataType = (DataType) Activator.CreateInstance (at.SerializationDataType, new object[] { prop.PropertyType } );
+						} catch (MissingMethodException ex) {
+							throw new InvalidOperationException (&quot;Constructor not found for custom data type: &quot; + at.SerializationDataType.Name + &quot; (Type propertyType);&quot;, ex);
+						}
+					}
+					
+					prop.Member = member;
+					AddProperty (prop);
+					prop.Initialize (ats, 0);
+					
+					if (prop.ExpandedCollection &amp;&amp; prop.DataType.IsSimpleType)
+						throw new InvalidOperationException (&quot;ExpandedCollectionAttribute is not allowed in collections of simple types&quot;);
+				}
+			}
+		}
+		
+		private void AddSubtype (ClassDataType subtype)
+		{
+			if (subtypes == null) subtypes = new ArrayList (); 
+			subtypes.Add (subtype); 
+		}
+
+		public ICollection Properties {
+			get { return sortedPoperties; }
+		}
+		
+		public void AddProperty (ItemProperty prop)
+		{
+			if (!prop.IsNested) {
+				foreach (ItemProperty p in sortedPoperties) {
+					if (p.IsNested &amp;&amp; p.NameList[0] == prop.Name)
+						throw CreateNestedConflictException (prop, p);
+				}
+			} else {
+				ItemProperty p = properties [prop.NameList[0]] as ItemProperty;
+				if (p != null)
+					throw CreateNestedConflictException (prop, p);
+			}
+			
+			prop.SetContext (Context);
+			if (properties.ContainsKey (prop.Name))
+				throw new InvalidOperationException (&quot;Duplicate property '&quot; + prop.Name + &quot;' in class '&quot; + ValueType);
+			properties.Add (prop.Name, prop);
+			sortedPoperties.Add (prop);
+		}
+		
+		Exception CreateNestedConflictException (ItemProperty p1, ItemProperty p2)
+		{
+			return new InvalidOperationException (&quot;There is a conflict between the properties '&quot; + p1.Name + &quot;' and '&quot; + p2.Name + &quot;'. Nested element properties can't be mixed with normal element properties.&quot;);
+		}
+		
+		public override DataNode Serialize (SerializationContext serCtx, object mapData, object obj)
+		{
+			if (obj.GetType () != ValueType) {
+				DataType subtype = Context.GetConfigurationDataType (obj.GetType ());
+				DataItem it = (DataItem) subtype.Serialize (serCtx, mapData, obj);
+				it.ItemData.Add (new DataValue (&quot;ctype&quot;, subtype.Name));
+				it.Name = Name;
+				return it;
+			} 
+			
+			DataItem item = new DataItem ();
+			item.Name = Name;
+			
+			ICustomDataItem citem = obj as ICustomDataItem;
+			if (citem != null) {
+				ClassTypeHandler handler = new ClassTypeHandler (serCtx, this);
+				item.ItemData = citem.Serialize (handler);
+			}
+			else
+				item.ItemData = Serialize (serCtx, obj);
+			return item;
+		}
+		
+		internal DataCollection Serialize (SerializationContext serCtx, object obj)
+		{
+			DataCollection itemCol = new DataCollection ();
+			
+			foreach (ItemProperty prop in Properties) {
+				if (prop.ReadOnly) continue;
+				object val = GetPropValue (prop, obj);
+				if (val == null) continue;
+				if (val.Equals (prop.DefaultValue)) continue;
+				DataCollection col = itemCol;
+				if (prop.IsNested) col = GetNestedCollection (col, prop.NameList, 0);
+				
+				if (prop.ExpandedCollection) {
+					ICollectionHandler handler = prop.ExpandedCollectionHandler;
+					object pos = handler.GetInitialPosition (val);
+					while (handler.MoveNextItem (val, ref pos)) {
+						object item = handler.GetCurrentItem (val, pos);
+						if (item == null) continue;
+						DataNode data = prop.Serialize (serCtx, item);
+						data.Name = prop.SingleName;
+						col.Add (data);
+					}
+				}
+				else {
+					DataNode data = prop.Serialize (serCtx, val);
+					if (data == null) continue;
+					col.Add (data);
+				}
+			}
+			return itemCol;
+		}
+		
+		DataCollection GetNestedCollection (DataCollection col, string[] nameList, int pos)
+		{
+			if (pos == nameList.Length - 1) return col;
+
+			DataItem item = col [nameList[pos]] as DataItem;
+			if (item == null) {
+				item = new DataItem ();
+				item.Name = nameList[pos];
+				col.Add (item);
+			}
+			return GetNestedCollection (item.ItemData, nameList, pos + 1);
+		}
+		
+		public override object Deserialize (SerializationContext serCtx, object mapData, DataNode data)
+		{
+			DataItem item = data as DataItem;
+			if (item == null)
+				throw new InvalidOperationException (&quot;Invalid value found for type '&quot; + Name + &quot;'&quot;);
+				
+			DataValue ctype = item [&quot;ctype&quot;] as DataValue;
+			if (ctype != null &amp;&amp; ctype.Value != Name) {
+				DataType stype = FindDerivedType (ctype.Value);
+				if (stype != null) return stype.Deserialize (serCtx, mapData, data);
+				else throw new InvalidOperationException (&quot;Type not found: &quot; + ctype.Value);
+			}
+			
+			ConstructorInfo ctor = ValueType.GetConstructor (BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, Type.EmptyTypes, null);
+			if (ctor == null) throw new InvalidOperationException (&quot;Default constructor not found for type '&quot; + ValueType + &quot;'&quot;);
+
+			object obj = ctor.Invoke (null);
+			SetConfigurationItemData (serCtx, obj, item);
+			return obj;
+		}
+		
+		public void SetConfigurationItemData (SerializationContext serCtx, object obj, DataItem item)
+		{
+			ICustomDataItem citem = obj as ICustomDataItem;
+			if (citem != null) {
+				ClassTypeHandler handler = new ClassTypeHandler (serCtx, this);
+				citem.Deserialize (handler, item.ItemData);
+			}
+			else
+				Deserialize (serCtx, obj, item.ItemData);
+		}
+		
+		internal void Deserialize (SerializationContext serCtx, object obj, DataCollection itemData)
+		{
+			foreach (ItemProperty prop in Properties)
+				if (prop.DefaultValue != null)
+					SetPropValue (prop, obj, prop.DefaultValue);
+			
+			Deserialize (serCtx, obj, itemData, &quot;&quot;);
+		}
+		
+		void Deserialize (SerializationContext serCtx, object obj, DataCollection itemData, string baseName)
+		{
+			Hashtable expandedCollections = null;
+			
+			foreach (DataNode value in itemData) {
+				ItemProperty prop = (ItemProperty) properties [baseName + value.Name];
+				if (prop == null) {
+					if (value is DataItem)
+						Deserialize (serCtx, obj, ((DataItem)value).ItemData, baseName + value.Name + &quot;/&quot;);
+					continue;
+				}
+				if (prop.WriteOnly)
+					continue;
+				
+				try {
+					if (prop.ExpandedCollection) {
+						ICollectionHandler handler = prop.ExpandedCollectionHandler;
+						if (expandedCollections == null) expandedCollections = new Hashtable ();
+						
+						object pos, col;
+						if (!expandedCollections.ContainsKey (prop)) {
+							col = handler.CreateCollection (out pos, -1);
+						} else {
+							pos = expandedCollections [prop];
+							col = GetPropValue (prop, obj);
+						}
+						handler.AddItem (ref col, ref pos, prop.Deserialize (serCtx, value));
+						expandedCollections [prop] = pos;
+						SetPropValue (prop, obj, col);
+					}
+					else {
+						if (prop.HasSetter &amp;&amp; prop.DataType.CanCreateInstance)
+							SetPropValue (prop, obj, prop.Deserialize (serCtx, value));
+						else if (prop.DataType.CanReuseInstance) {
+							object pval = GetPropValue (prop, obj);
+							if (pval == null) {
+								if (prop.HasSetter)
+									throw new InvalidOperationException (&quot;The property is null and a new instance of '&quot; + prop.PropertyType + &quot;' can't be created.&quot;);
+								else
+									throw new InvalidOperationException (&quot;The property is null and it does not have a setter.&quot;);
+							}
+							prop.Deserialize (serCtx, value, pval);
+						} else {
+							throw new InvalidOperationException (&quot;The property does not have a setter.&quot;);
+						}
+					}
+				}
+				catch (Exception ex) {
+					throw new InvalidOperationException (&quot;Could not set property '&quot; + prop.Name + &quot;' in type '&quot; + Name + &quot;'&quot;, ex);
+				}
+			}
+		}
+		
+		void SetPropValue (ItemProperty prop, object obj, object value)
+		{
+			if (prop.Member != null)
+				prop.SetValue (obj, value);
+			else if (obj is IExtendedDataItem)
+				((IExtendedDataItem)obj).ExtendedProperties [prop.Name] = value;
+		}
+		
+		object GetPropValue (ItemProperty prop, object obj)
+		{
+			if (prop.Member != null)
+				return prop.GetValue (obj);
+			else if (obj is IExtendedDataItem)
+				return ((IExtendedDataItem)obj).ExtendedProperties [prop.Name];
+			else
+				return null;
+		}
+		
+		public DataType FindDerivedType (string name)
+		{
+			if (subtypes == null) return null;
+			
+			foreach (ClassDataType stype in subtypes) {
+				if (stype.Name == name) return stype;
+				DataType cst = stype.FindDerivedType (name);
+				if (cst != null) return cst;
+			}
+			return null;
+		}
+	}
+	
+	internal class ClassTypeHandler: ITypeSerializer
+	{
+		SerializationContext ctx;
+		ClassDataType cdt;
+		
+		internal ClassTypeHandler (SerializationContext ctx, ClassDataType cdt)
+		{
+			this.ctx = ctx;
+			this.cdt = cdt;
+		}
+		
+		public DataCollection Serialize (object instance)
+		{
+			return cdt.Serialize (ctx, instance);
+		}
+		
+		public void Deserialize (object instance, DataCollection data)
+		{
+			cdt.Deserialize (ctx, instance, data);
+		}
+		
+		public SerializationContext SerializationContext {
+			get { return ctx; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/CollectionDataType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/CollectionDataType.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/CollectionDataType.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,134 @@
+//
+// CollectionDataType.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class CollectionDataType: DataType
+	{
+		ICollectionHandler handler;
+		MapData defaultData;
+		
+		protected class MapData
+		{
+			public string ItemName;
+			public DataType ItemType;
+			public object ItemMapData;
+		}
+		
+		internal CollectionDataType (Type type, ICollectionHandler handler): base (type)
+		{
+			this.handler = handler;
+		}
+		
+		public override bool IsSimpleType { get { return false; } }
+		public override bool CanCreateInstance { get { return handler.CanCreateInstance; } }
+		public override bool CanReuseInstance { get { return true; } }
+		
+		internal protected override object GetMapData (object[] attributes, int scope)
+		{
+			DataType itemDataType = null;
+			Type itemType = null;
+			
+			ItemPropertyAttribute at = FindPropertyAttribute (attributes, scope + 1);
+			if (at != null) {
+				itemType = at.ValueType;
+				if (at.SerializationDataType != null)
+					itemDataType = (DataType) Activator.CreateInstance (at.SerializationDataType, new object[] { handler.GetItemType() });
+			}
+			
+			if (itemType == null) itemType = handler.GetItemType ();
+			if (itemDataType == null) itemDataType = Context.GetConfigurationDataType (itemType);
+
+			object itemMapData = itemDataType.GetMapData (attributes, scope + 1);
+			if (at == null &amp;&amp; itemMapData == null) return null;
+
+			MapData data = new MapData ();
+			data.ItemType = itemDataType;
+			data.ItemName = (at != null &amp;&amp; at.Name != null) ? at.Name : itemDataType.Name;
+			data.ItemMapData = itemMapData;
+			return data;
+		}
+		
+		protected virtual MapData GetDefaultData ()
+		{
+			if (defaultData != null) return defaultData;
+			defaultData = new MapData ();
+			defaultData.ItemType = Context.GetConfigurationDataType (handler.GetItemType ());
+			defaultData.ItemName = defaultData.ItemType.Name;
+			return defaultData;
+		}
+
+		public override DataNode Serialize (SerializationContext serCtx, object mdata, object collection)
+		{
+			MapData mapData = (mdata != null) ? (MapData) mdata : GetDefaultData ();
+			DataItem item = new DataItem ();
+			item.Name = Name;
+			item.UniqueNames = false;
+			object pos = handler.GetInitialPosition (collection);
+			while (handler.MoveNextItem (collection, ref pos)) {
+				object val = handler.GetCurrentItem (collection, pos);
+				if (val == null) continue;
+				DataNode data = mapData.ItemType.Serialize (serCtx, mapData.ItemMapData, val);
+				data.Name = mapData.ItemName;
+				item.ItemData.Add (data);
+			}
+			return item;
+		}
+		
+		public override object Deserialize (SerializationContext serCtx, object mdata, DataNode data)
+		{
+			DataCollection items = ((DataItem) data).ItemData;
+			object position;
+			object collectionInstance = handler.CreateCollection (out position, items.Count);
+			Deserialize (serCtx, mdata, items, collectionInstance, position);
+			return collectionInstance;
+		}
+		
+		public override void Deserialize (SerializationContext serCtx, object mdata, DataNode data, object collectionInstance)
+		{
+			DataCollection items = ((DataItem) data).ItemData;
+			object position;
+			handler.ResetCollection (collectionInstance, out position, items.Count);
+			Deserialize (serCtx, mdata, items, collectionInstance, position);
+		}
+		
+		void Deserialize (SerializationContext serCtx, object mdata, DataCollection items, object collectionInstance, object position)
+		{
+			MapData mapData = (mdata != null) ? (MapData) mdata : GetDefaultData ();
+			
+			foreach (DataNode val in items) {
+				handler.AddItem (ref collectionInstance, ref position, mapData.ItemType.Deserialize (serCtx, mapData.ItemMapData, val));
+			}
+			handler.FinishCreation (ref collectionInstance, position);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataCollection.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataCollection.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataCollection.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,174 @@
+//
+// DataCollection.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class DataCollection: IEnumerable
+	{
+		ArrayList list = new ArrayList ();
+		
+		public DataCollection ()
+		{
+		}
+		
+		protected ArrayList List {
+			get {
+				if (list == null) list = new ArrayList ();
+				return list;
+			}
+		}
+		
+		public int Count
+		{
+			get { return list == null ? 0 : list.Count; }
+		}
+		
+		public virtual DataNode this [int n]
+		{
+			get { return (DataNode) List[n]; }
+		}
+		
+		public virtual DataNode this [string name]
+		{
+			get {
+				DataCollection col;
+				int i = FindData (name, out col, false);
+				if (i != -1) return (DataNode) col.List [i];
+				else return null;
+			}
+		}
+		
+		int FindData (string name, out DataCollection colec, bool buildTree)
+		{
+			if (list == null) {
+				colec = null;
+				return -1;
+			}
+			
+			if (name.IndexOf ('/') == -1) {
+				for (int n=0; n&lt;list.Count; n++) {
+					DataNode data = (DataNode) list [n];
+					if (data.Name == name) {
+						colec = this;
+						return n;
+					}
+				}
+				colec = this;
+				return -1;
+			} else {
+				string[] names = name.Split ('/');
+				int pos = -1;
+				colec = this;
+				DataNode data = null;
+
+				for (int p=0; p&lt;names.Length; p++)
+				{
+					if (p &gt; 0) {
+						DataItem item = data as DataItem;
+						if (item != null) {
+							colec = item.ItemData;
+						} else if (buildTree) {
+							item = new DataItem ();
+							item.Name = names [p - 1];
+							colec.Add (item);
+							colec = item.ItemData;
+						} else {
+							colec = null;
+							return -1;
+						}
+					}
+					
+					pos = -1;
+					for (int n=0; n&lt;colec.List.Count; n++) {
+						data = (DataNode) colec.List [n];
+						if (data.Name == names [p]) {
+							pos = n; break;
+						}
+					}
+				}
+				return pos;
+			}
+		}
+		
+		public virtual IEnumerator GetEnumerator ()
+		{
+			return list == null ? Type.EmptyTypes.GetEnumerator() : list.GetEnumerator ();
+		}
+		
+		public virtual void Add (DataNode entry)
+		{
+			if (entry == null)
+				throw new ArgumentNullException (&quot;entry&quot;);
+				
+			List.Add (entry);
+		}
+		
+		public virtual void Add (DataNode entry, string itemPath)
+		{
+			if (entry == null)
+				throw new ArgumentNullException (&quot;entry&quot;);
+				
+			DataCollection col;
+			int i = FindData (itemPath + &quot;/&quot;, out col, true);
+			col.List.Add (entry);
+		}
+		
+		public virtual void Remove (DataNode entry)
+		{
+			if (list != null)
+				list.Remove (entry);
+		}
+		
+		public DataNode Extract (string name)
+		{
+			DataCollection col;
+			int i = FindData (name, out col, false);
+			if (i != -1) {
+				DataNode data = (DataNode) col.List [i];
+				col.list.RemoveAt (i);
+				return data;
+			}
+			return null;
+		}
+		
+		public int IndexOf (DataNode entry)
+		{
+			if (list == null) return -1;
+			return list.IndexOf (entry);
+		}
+		
+		public virtual void Clear ()
+		{
+			if (list != null)
+				list.Clear ();
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataContext.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataContext.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataContext.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,135 @@
+//
+// DataContext.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class DataContext
+	{
+		Hashtable configurationTypes = new Hashtable ();
+		object[] emptyAttributes = new object[0];
+		
+		public virtual SerializationContext CreateSerializationContext ()
+		{
+			return new SerializationContext ();
+		}
+		
+		public DataNode SaveConfigurationData (SerializationContext serCtx, object obj, Type type)
+		{
+			if (type == null) type = obj.GetType ();
+			DataType dataType = GetConfigurationDataType (type);
+			return dataType.Serialize (serCtx, null, obj);
+		}
+		
+		public object LoadConfigurationData (SerializationContext serCtx, Type type, DataNode data)
+		{
+			DataType dataType = GetConfigurationDataType (type);
+			return dataType.Deserialize (serCtx, null, data);
+		}
+		
+		public void SetConfigurationItemData (SerializationContext serCtx, object obj, DataItem data)
+		{
+			ClassDataType dataType = (ClassDataType) GetConfigurationDataType (obj.GetType ());
+			dataType.SetConfigurationItemData (serCtx, obj, data);
+		}
+		
+		public void RegisterProperty (Type targetType, string name, Type propertyType)
+		{
+			if (!typeof(IExtendedDataItem).IsAssignableFrom (targetType))
+				throw new InvalidOperationException (&quot;The type '&quot; + targetType + &quot;' does not implement the IExtendedDataItem interface and cannot be extended with new properties&quot;);
+				
+			ClassDataType ctype = (ClassDataType) GetConfigurationDataType (targetType);
+			ItemProperty prop = new ItemProperty (name, propertyType);
+			ctype.AddProperty (prop);
+		}
+		
+		public void IncludeType (Type type)
+		{
+			GetConfigurationDataType (type);
+		}
+		
+		public void SetTypeInfo (DataItem item, Type type)
+		{
+			item.ItemData.Add (new DataValue (&quot;ctype&quot;, GetConfigurationDataType (type).Name));
+		}
+		
+		public void RegisterProperty (Type targetType, ItemProperty property)
+		{
+			if (!typeof(IExtendedDataItem).IsAssignableFrom (targetType))
+				throw new InvalidOperationException (&quot;The type '&quot; + targetType + &quot;' does not implement the IExtendedDataItem interface and cannot be extended with new properties&quot;);
+				
+			ClassDataType ctype = (ClassDataType) GetConfigurationDataType (targetType);
+			ctype.AddProperty (property);
+		}
+		
+		internal protected DataType GetConfigurationDataType (Type type)
+		{
+			lock (configurationTypes) {
+				DataType itemType = (DataType) configurationTypes [type];
+				if (itemType != null) return itemType;
+				itemType = CreateConfigurationDataType (type);
+				configurationTypes [type] = itemType;
+				itemType.SetContext (this);
+				return itemType;
+			}
+		}
+		
+		protected virtual DataType CreateConfigurationDataType (Type type)
+		{
+			if (type.IsEnum)
+				return new EnumDataType (type);
+			else if (type.IsPrimitive || type == typeof(string))
+				return new PrimitiveDataType (type);
+			else {
+				ICollectionHandler handler = GetCollectionHandler (type);
+				if (handler != null)
+					return new CollectionDataType (type, handler);
+				else
+					return CreateClassDataType (type);
+			}
+		}
+		
+		protected virtual DataType CreateClassDataType (Type type)
+		{
+			return new ClassDataType (type);
+		}
+		
+		internal protected virtual ICollectionHandler GetCollectionHandler (Type type)
+		{
+			if (type.IsArray)
+				return new ArrayHandler (type);
+			else if (type == typeof(ArrayList))
+				return ArrayListHandler.Instance;
+			else
+				return GenericCollectionHandler.CreateHandler (type);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataIncludeAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataIncludeAttribute.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataIncludeAttribute.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,49 @@
+//
+// DataIncludeAttribute.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	[AttributeUsage (AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple=true)]
+	public class DataIncludeAttribute: Attribute
+	{
+		Type type;
+		
+		public DataIncludeAttribute (Type type)
+		{
+			this.type = type;
+		}
+		
+		public Type Type {
+			get { return type; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataItem.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataItem.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataItem.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,68 @@
+//
+// DataItem.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class DataItem: DataNode
+	{
+		DataCollection data;
+		bool uniqueNames = true;
+		
+		public DataCollection ItemData {
+			get {
+				if (data == null) data = new DataCollection ();
+				return data; 
+			}
+			set { data = value; }
+		}
+		
+		public bool HasItemData {
+			get { return data != null &amp;&amp; data.Count &gt; 0; }
+		}
+		
+		public bool UniqueNames {
+			get { return uniqueNames; }
+			set { uniqueNames = value; }
+		}
+		
+		public DataNode this [string name] {
+			get {
+				if (data == null) return null;
+				return data [name];
+			}
+		}
+		
+		public DataNode Extract (string name)
+		{
+			if (data == null) return null;
+			return data.Extract (name);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataItemAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataItemAttribute.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataItemAttribute.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,50 @@
+//
+// DataItemAttribute.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	[AttributeUsage (AttributeTargets.Class, AllowMultiple = false)]
+	public class DataItemAttribute: Attribute
+	{
+		string name;
+		
+		public DataItemAttribute (string name)
+		{
+			this.name = name;
+		}
+
+		public string Name {
+			get { return name; }
+			set { name = value; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataNode.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataNode.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataNode.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,42 @@
+//
+// DataNode.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class DataNode
+	{
+		string name;
+		
+		public string Name {
+			get { return name; }
+			set { name = value; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataSerializer.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataSerializer.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataSerializer.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,77 @@
+//
+// DataSerializer.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class DataSerializer
+	{
+		SerializationContext serializationContext;
+		DataContext dataContext;
+		
+		public DataSerializer (DataContext ctx)
+		{
+			dataContext = ctx;
+			serializationContext = ctx.CreateSerializationContext ();
+		}
+		
+		public DataSerializer (DataContext ctx, string baseFile)
+		{
+			dataContext = ctx;
+			serializationContext = ctx.CreateSerializationContext ();
+			serializationContext.BaseFile = baseFile;
+		}
+		
+		public SerializationContext SerializationContext {
+			get { return serializationContext; }
+		}
+		
+		public DataNode Serialize (object obj)
+		{
+			return dataContext.SaveConfigurationData (serializationContext, obj, null);
+		}
+		
+		public DataNode Serialize (object obj, Type type)
+		{
+			return dataContext.SaveConfigurationData (serializationContext, obj, type);
+		}
+		
+		public object Deserialize (Type type, DataNode data)
+		{
+			return dataContext.LoadConfigurationData (serializationContext, type, data);
+		}
+		
+		public void Deserialize (object obj, DataItem data)
+		{
+			dataContext.SetConfigurationItemData (serializationContext, obj, data);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataType.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataType.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,92 @@
+//
+// DataType.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public abstract class DataType
+	{
+		Type type;
+		DataContext ctx;
+		string name;
+		
+		public DataType (Type type)
+		{
+			this.type = type;
+			name = type.Name;
+		}
+		
+		internal void SetContext (DataContext ctx)
+		{
+			this.ctx = ctx;
+			Initialize ();
+		}
+		
+		protected ItemPropertyAttribute FindPropertyAttribute (object[] attributes, int scope)
+		{
+			foreach (object at in attributes) {
+				ItemPropertyAttribute iat = at as ItemPropertyAttribute;
+				if (iat != null &amp;&amp; iat.Scope == scope) return iat;
+			}
+			return null;
+		}
+
+		protected DataContext Context {
+			get { return ctx; }
+		}
+
+		public string Name {
+			get { return name; }
+			set { name = value; }
+		}
+		
+		public Type ValueType {
+			get { return type; }
+		}
+		
+		protected virtual void Initialize ()
+		{
+		}
+		
+		internal protected virtual object GetMapData (object[] attributes, int scope)
+		{
+			return null;
+		}
+		
+		public abstract DataNode Serialize (SerializationContext serCtx, object mapData, object value);
+		public abstract object Deserialize (SerializationContext serCtx, object mapData, DataNode data);
+		public virtual void Deserialize (SerializationContext serCtx, object mapData, DataNode data, object valueInstance)
+		{ throw new InvalidOperationException (&quot;Could not create instance for type '&quot; + ValueType + &quot;'&quot;); }
+		
+		public abstract bool IsSimpleType { get; }
+		public abstract bool CanCreateInstance { get; }
+		public abstract bool CanReuseInstance { get; }
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataValue.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataValue.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/DataValue.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,47 @@
+//
+// DataValue.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class DataValue: DataNode
+	{
+		string value;
+		
+		public DataValue (string name, string value)
+		{
+			Name = name;
+			this.value = value;
+		}
+		
+		public string Value {
+			get { return value; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/EnumDataType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/EnumDataType.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/EnumDataType.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,53 @@
+//
+// EnumDataType.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class EnumDataType: DataType
+	{
+		public EnumDataType (Type propType): base (propType)
+		{
+		}
+		
+		public override bool IsSimpleType { get { return true; } }
+		public override bool CanCreateInstance { get { return true; } }
+		public override bool CanReuseInstance { get { return false; } }
+		
+		public override DataNode Serialize (SerializationContext serCtx, object mapData, object value)
+		{
+			return new DataValue (Name, value.ToString ());
+		}
+		
+		public override object Deserialize (SerializationContext serCtx, object mapData, DataNode data)
+		{
+			return Enum.Parse (ValueType, ((DataValue)data).Value, false);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ExpandedCollectionAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ExpandedCollectionAttribute.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ExpandedCollectionAttribute.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,39 @@
+//
+// ExpandedCollectionAttribute.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	[AttributeUsage (AttributeTargets.Property | AttributeTargets.Field)]
+	public class ExpandedCollectionAttribute: Attribute
+	{
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/GenericCollectionHandler.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/GenericCollectionHandler.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/GenericCollectionHandler.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,205 @@
+//
+// GenericCollectionHandler.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	internal abstract class GenericCollectionHandler: ICollectionHandler
+	{
+		protected Type type;
+		protected Type elementType;
+		protected MethodInfo addMethod;
+		protected object[] itemParam = new object [1];
+		bool hasPublicConstructor;
+		
+		protected GenericCollectionHandler (Type type, Type elemType, MethodInfo addMethod)
+		{
+			this.type = type;
+			this.elementType = elemType;
+			this.addMethod = addMethod;
+			
+			hasPublicConstructor = (type.GetConstructor (Type.EmptyTypes) != null);
+		}
+		
+		public static ICollectionHandler CreateHandler (Type t)
+		{
+			Type elemType;
+			
+			MethodInfo addMethod = t.GetMethod (&quot;Add&quot;);
+			if (addMethod == null) return null;
+
+			ParameterInfo[] pars = addMethod.GetParameters();
+			if (pars.Length != 1) return null;
+			elemType = pars[0].ParameterType;
+
+			PropertyInfo indexerProp = null;
+			PropertyInfo countProp = null;
+			
+			PropertyInfo[] props = t.GetProperties (BindingFlags.Instance | BindingFlags.Public);
+			foreach (PropertyInfo prop in props)
+			{
+				if (!prop.CanRead) continue;
+				ParameterInfo[] pi = prop.GetIndexParameters ();
+				if (prop.CanWrite &amp;&amp; pi != null &amp;&amp; pi.Length == 1 &amp;&amp; pi[0].ParameterType == typeof(int))
+					indexerProp = prop;
+				else if (prop.Name == &quot;Count&quot; &amp;&amp; prop.PropertyType == typeof(int))
+					countProp = prop;
+			}
+			
+			if (indexerProp != null &amp;&amp; countProp != null &amp;&amp; indexerProp.PropertyType == elemType)
+				return new IndexedCollectionHandler (t, elemType, addMethod, indexerProp, countProp);
+
+			if (!typeof(IEnumerable).IsAssignableFrom (t))
+				return null;
+			
+			return new EnumerableCollectionHandler (t, elemType, addMethod, countProp);
+		}
+
+		public bool CanCreateInstance {
+			get { return hasPublicConstructor; }
+		}
+		
+		public Type GetItemType ()
+		{
+			return elementType;
+		}
+		
+		public object CreateCollection (out object position, int size)
+		{
+			position = 0;
+			return Activator.CreateInstance (type);
+		}
+		
+		public void ResetCollection (object collection, out object position, int size)
+		{
+			position = 0;
+		}
+		
+		public void AddItem (ref object collection, ref object position, object item)
+		{
+			itemParam [0] = item;
+			addMethod.Invoke (collection, itemParam);
+			position = (int)position + 1;
+		}
+		
+		public abstract void SetItem (object collection, object position, object item);
+		
+		public void FinishCreation (ref object collection, object position)
+		{
+		}
+		
+		public abstract object GetInitialPosition (object collection);
+		public abstract bool MoveNextItem (object collection, ref object position);
+		public abstract object GetCurrentItem (object collection, object position);
+		public abstract bool IsEmpty (object collection);
+	}
+	
+	internal class IndexedCollectionHandler: GenericCollectionHandler
+	{
+		PropertyInfo indexer;
+		PropertyInfo count;
+		
+		internal IndexedCollectionHandler (Type type, Type elemType, MethodInfo addMethod, PropertyInfo indexerProp, PropertyInfo countProp)
+		: base (type, elemType, addMethod)
+		{
+			indexer = indexerProp;
+			count = countProp;
+		}
+		
+		public override void SetItem (object collection, object position, object item)
+		{
+			itemParam [0] = position;
+			indexer.SetValue (collection, item, itemParam);
+		}
+		
+		public override object GetInitialPosition (object collection)
+		{
+			return -1;
+		}
+		
+		public override bool MoveNextItem (object collection, ref object position)
+		{
+			int i = ((int) position) + 1;
+			position = i;
+			return i &lt; (int) count.GetValue (collection, null); 
+		}
+		
+		public override object GetCurrentItem (object collection, object position)
+		{
+			itemParam [0] = position;
+			return indexer.GetValue (collection, itemParam);
+		}
+		
+		public override bool IsEmpty (object collection)
+		{
+			return collection == null || (int) count.GetValue (collection, null) == 0;
+		}
+	}
+	
+	internal class EnumerableCollectionHandler: GenericCollectionHandler
+	{
+		PropertyInfo count;
+		
+		internal EnumerableCollectionHandler (Type type, Type elemType, MethodInfo addMethod, PropertyInfo count)
+			: base (type, elemType, addMethod)
+		{
+			this.count = count;
+		}
+		
+		public override void SetItem (object collection, object position, object item)
+		{
+			AddItem (ref collection, ref position, item);
+		}
+		
+		public override object GetInitialPosition (object collection)
+		{
+			return ((IEnumerable)collection).GetEnumerator ();
+		}
+		
+		public override bool MoveNextItem (object collection, ref object position)
+		{
+			return ((IEnumerator)position).MoveNext ();
+		}
+		
+		public override object GetCurrentItem (object collection, object position)
+		{
+			return ((IEnumerator)position).Current;
+		}
+		
+		public override bool IsEmpty (object collection)
+		{
+			if (collection == null) return true;
+			if (count != null) return (int) count.GetValue (collection, null) == 0;
+			IEnumerator en = (IEnumerator) ((IEnumerable)collection).GetEnumerator ();
+			return !en.MoveNext ();
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ICollectionHandler.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ICollectionHandler.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ICollectionHandler.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,49 @@
+//
+// ICollectionHandler.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public interface ICollectionHandler
+	{
+		Type GetItemType ();
+		
+		bool CanCreateInstance { get; }
+		object CreateCollection (out object position, int size);
+		void ResetCollection (object collection, out object position, int size);
+		void AddItem (ref object collection, ref object position, object item);
+		void SetItem (object collection, object position, object item);
+		void FinishCreation (ref object collection, object position);
+		
+		bool IsEmpty (object collection);
+		object GetInitialPosition (object collection);
+		bool MoveNextItem (object collection, ref object position);
+		object GetCurrentItem (object collection, object position);
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/IExtendedDataItem.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/IExtendedDataItem.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/IExtendedDataItem.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,51 @@
+//
+// IExtendedDataItem.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public interface IExtendedDataItem
+	{
+		IDictionary ExtendedProperties { get; }
+	}
+	
+	public interface ICustomDataItem
+	{
+		DataCollection Serialize (ITypeSerializer handler);
+		void Deserialize (ITypeSerializer handler, DataCollection data);
+	}
+	
+	public interface ITypeSerializer
+	{
+		DataCollection Serialize (object instance);
+		void Deserialize (object instance, DataCollection data);
+		SerializationContext SerializationContext { get; }
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ItemProperty.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ItemProperty.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ItemProperty.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,194 @@
+//
+// ItemProperty.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public sealed class ItemProperty
+	{
+		string name;
+		MemberInfo member;
+		DataType dataType;
+		Type propType;
+		object defaultValue;
+		DataContext ctx;
+		object mapData;
+		bool expandedCollection;
+		ICollectionHandler expandedCollectionHandler;
+		string[] nameList;
+		bool readOnly;
+		bool writeOnly;
+		
+		public ItemProperty ()
+		{
+		}
+		
+		public ItemProperty (string name, Type propType)
+		{
+			this.name = name;
+			this.propType = propType;
+			BuildNameList ();
+		}
+		
+		void BuildNameList ()
+		{
+			if (name.IndexOf ('/') != -1) {
+				nameList = name.Split ('/');
+			}
+		}
+		
+		internal void SetContext (DataContext ctx)
+		{
+			this.ctx = ctx;
+			if (dataType == null) {
+				if (propType == null) throw new InvalidOperationException (&quot;Property type not specified&quot;);
+				dataType = ctx.GetConfigurationDataType (propType);
+			}
+		}
+		
+		internal void Initialize (object[] attributes, int scope)
+		{
+			mapData = dataType.GetMapData (attributes, scope);
+		}
+		
+		internal MemberInfo Member {
+			get { return member; }
+			set { CheckReadOnly (); member = value; }
+		}
+		
+		public string Name {
+			get { return name; }
+			set { CheckReadOnly (); name = value; BuildNameList (); }
+		}
+		
+		public object DefaultValue {
+			get { return defaultValue; }
+			set { CheckReadOnly (); defaultValue = value; }
+		}
+		
+		public Type PropertyType {
+			get { return propType; }
+			set { CheckReadOnly (); propType = value; }
+		}
+		
+		public bool ExpandedCollection {
+			get { return expandedCollection; }
+			set { expandedCollection = value; }
+		}
+		
+		internal ICollectionHandler ExpandedCollectionHandler {
+			get { return expandedCollectionHandler; }
+			set { expandedCollectionHandler = value; }
+		}
+		
+		public bool ReadOnly {
+			get { return readOnly; }
+			set { readOnly = value; }
+		}
+		
+		public bool WriteOnly {
+			get { return writeOnly; }
+			set { writeOnly = value; }
+		}
+		
+		public DataType DataType {
+			get { return dataType; }
+			set { CheckReadOnly (); dataType = value; }
+		}
+		
+		internal string[] NameList {
+			get { return nameList; }
+		}
+		
+		internal bool IsNested {
+			get { return nameList != null; }
+		}
+		
+		internal string SingleName {
+			get { return nameList != null ? nameList [nameList.Length-1] : name; }
+		}
+		
+		internal DataContext Context {
+			get { return ctx; }
+		}
+		
+		internal object GetValue (object obj)
+		{
+			if (member != null) {
+				object val;
+				FieldInfo field = member as FieldInfo;
+				if (field != null) return field.GetValue (obj);
+				else return ((PropertyInfo)member).GetValue (obj, null);
+			} else
+				throw new InvalidOperationException (&quot;Invalid object property&quot;);
+		}
+
+		internal void SetValue (object obj, object value)
+		{
+			if (member != null) {
+				FieldInfo field = member as FieldInfo;
+				if (field != null)
+					field.SetValue (obj, value);
+				else {
+					PropertyInfo pi = member as PropertyInfo;
+					pi.SetValue (obj, value, null);
+				}
+			} else
+				throw new InvalidOperationException (&quot;Invalid object property&quot;);
+		}
+		
+		internal bool HasSetter {
+			get { return (member is FieldInfo) || ((member is PropertyInfo) &amp;&amp; ((PropertyInfo)member).CanWrite); }
+		}
+
+		internal DataNode Serialize (SerializationContext serCtx, object value)
+		{
+			DataNode data = dataType.Serialize (serCtx, mapData, value);
+			if (data != null) data.Name = SingleName;
+			return data;
+		}
+		
+		internal object Deserialize (SerializationContext serCtx, DataNode data)
+		{
+			return dataType.Deserialize (serCtx, mapData, data);
+		}
+		
+		internal void Deserialize (SerializationContext serCtx, DataNode data, object valueInstance)
+		{
+			dataType.Deserialize (serCtx, mapData, data, valueInstance);
+		}
+		
+		void CheckReadOnly ()
+		{
+			if (ctx != null)
+				throw new InvalidOperationException (&quot;Property can't be modified, it is already bound to a configuration context&quot;);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ItemPropertyAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ItemPropertyAttribute.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/ItemPropertyAttribute.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,95 @@
+//
+// ItemPropertyAttribute.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Xml;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	[AttributeUsage (AttributeTargets.Property | AttributeTargets.Field, AllowMultiple=true)]
+	public class ItemPropertyAttribute: Attribute
+	{
+		Type confType;
+		object defaultValue;
+		string name;
+		int scope;
+		Type dataType;
+		bool readOnly;
+		bool writeOnly;
+		
+		public ItemPropertyAttribute ()
+		{
+		}
+		
+		public ItemPropertyAttribute (Type dataType)
+		{
+			this.dataType = dataType;
+		}
+		
+		public ItemPropertyAttribute (string name)
+		{
+			this.name = name;
+		}
+		
+		public object DefaultValue {
+			get { return defaultValue; }
+			set { defaultValue = value; }
+		}
+
+		public string Name {
+			get { return name; }
+			set { name = value; }
+		}
+		
+		public int Scope {
+			get { return scope; }
+			set { scope = value; }
+		}
+		
+		public Type SerializationDataType {
+			get { return confType; }
+			set { confType = value; }
+		}
+		
+		public Type ValueType {
+			get { return dataType; }
+			set { dataType = value; }
+		}
+		
+		public bool ReadOnly {
+			get { return readOnly; }
+			set { readOnly = value; }
+		}
+		
+		public bool WriteOnly {
+			get { return writeOnly; }
+			set { writeOnly = value; }
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/PrimitiveDataType.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/PrimitiveDataType.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/PrimitiveDataType.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,53 @@
+//
+// PrimitiveDataType.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class PrimitiveDataType: DataType
+	{
+		public PrimitiveDataType (Type propType): base (propType)
+		{
+		}
+		
+		public override bool IsSimpleType { get { return true; } }
+		public override bool CanCreateInstance { get { return true; } }
+		public override bool CanReuseInstance { get { return false; } }
+		
+		public override DataNode Serialize (SerializationContext serCtx, object mapData, object value)
+		{
+			return new DataValue (Name, value.ToString ());
+		}
+		
+		public override object Deserialize (SerializationContext serCtx, object mapData, DataNode data)
+		{
+			return Convert.ChangeType (((DataValue)data).Value, ValueType);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/SerializationContext.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/SerializationContext.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/SerializationContext.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,51 @@
+//
+// SerializationContext.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class SerializationContext: IDisposable
+	{
+		string file;
+		
+		public string BaseFile {
+			get { return file; }
+			set { file = value; }
+		}
+		
+		public virtual void Close ()
+		{
+		}
+		
+		public void Dispose ()
+		{
+			Close ();
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/XmlDataSerializer.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/XmlDataSerializer.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Serialization/XmlDataSerializer.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,202 @@
+//
+// XmlDataSerializer.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Xml;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Serialization
+{
+	public class XmlDataSerializer
+	{
+		DataSerializer serializer;
+		
+		public XmlDataSerializer (DataContext ctx)
+		{
+			serializer = new DataSerializer (ctx);
+		}
+		
+		public void Serialize (TextWriter writer, object obj)
+		{
+			Serialize (writer, obj, null);
+		}
+		
+		public void Serialize (TextWriter writer, object obj, Type type)
+		{
+			XmlTextWriter tw = new XmlTextWriter (writer);
+			tw.Formatting = Formatting.Indented;
+			Serialize (tw, obj, type);
+		}
+		
+		public void Serialize (XmlWriter writer, object obj)
+		{
+			Serialize (writer, obj, null);
+		}
+		
+		public void Serialize (XmlWriter writer, object obj, Type type)
+		{
+			DataNode data = serializer.Serialize (obj, type);
+			XmlConfigurationWriter.DefaultWriter.Write (writer, data);
+		}
+		
+		public object Deserialize (TextReader reader, Type type)
+		{
+			return Deserialize (new XmlTextReader (reader), type);
+		}
+		
+		public object Deserialize (XmlReader reader, Type type)
+		{
+			DataNode data = XmlConfigurationReader.DefaultReader.Read (reader);
+			return serializer.Deserialize (type, data);
+		}
+		
+		public SerializationContext SerializationContext {
+			get { return serializer.SerializationContext; }
+		}
+	}
+	
+	public class XmlConfigurationWriter
+	{
+		public static XmlConfigurationWriter DefaultWriter = new XmlConfigurationWriter ();
+		
+		public void Write (XmlWriter writer, DataNode data)
+		{
+			if (data is DataValue)
+				writer.WriteElementString (data.Name, ((DataValue)data).Value);
+			else if (data is DataItem) {
+				writer.WriteStartElement (data.Name);
+				WriteAttributes (writer, (DataItem) data);
+				WriteChildren (writer, (DataItem) data);
+				writer.WriteEndElement ();
+			}
+		}
+		
+		protected virtual void WriteAttributes (XmlWriter writer, DataItem item)
+		{
+			if (item.UniqueNames) {
+				foreach (DataNode data in item.ItemData) {
+					DataValue val = data as DataValue;
+					if (val != null)
+						WriteAttribute (writer, val.Name, val.Value);
+				}
+			}
+		}
+		
+		protected virtual void WriteAttribute (XmlWriter writer, string name, string value)
+		{
+			writer.WriteAttributeString (name, value);
+		}
+		
+		protected virtual void WriteChildren (XmlWriter writer, DataItem item)
+		{
+			if (item.UniqueNames) {
+				foreach (DataNode data in item.ItemData) {
+					if (!(data is DataValue))
+						WriteChild (writer, data);
+				}
+			} else {
+				foreach (DataNode data in item.ItemData)
+					WriteChild (writer, data);
+			}
+		}
+		
+		protected virtual void WriteChild (XmlWriter writer, DataNode data)
+		{
+			DefaultWriter.Write (writer, data);
+		}
+	}
+	
+	public class XmlConfigurationReader
+	{
+		public static XmlConfigurationReader DefaultReader = new XmlConfigurationReader ();
+
+		public DataNode Read (XmlReader reader)
+		{
+			DataItem item = new DataItem (); 
+			reader.MoveToContent ();
+			string name = reader.LocalName;
+			item.Name = name;
+			
+			while (reader.MoveToNextAttribute ()) {
+				DataNode data = ReadAttribute (reader.LocalName, reader.Value);
+				if (data != null) item.ItemData.Add (data);
+			}
+			
+			reader.MoveToElement ();
+			if (reader.IsEmptyElement) {
+				reader.Skip ();
+				return item;
+			}
+			
+			reader.ReadStartElement ();
+			reader.MoveToContent ();
+			
+			string text = &quot;&quot;;
+			while (reader.NodeType != XmlNodeType.EndElement) {
+				if (reader.NodeType == XmlNodeType.Element) {
+					DataNode data = ReadChild (reader, item);
+					if (data != null) item.ItemData.Add (data);
+				} else if (reader.NodeType == XmlNodeType.Text) {
+					text += reader.Value;
+					reader.Skip ();
+				} else {
+					reader.Skip ();
+				}
+			}
+			
+			reader.ReadEndElement ();
+			
+			if (!item.HasItemData &amp;&amp; text != &quot;&quot;)
+				return new DataValue (name, text); 
+
+			return item;
+		}
+		
+		protected bool MoveToNextElement (XmlReader reader)
+		{
+			reader.MoveToContent ();
+			while (reader.NodeType != XmlNodeType.EndElement) {
+				if (reader.NodeType == XmlNodeType.Element)
+					return true;
+				reader.Skip ();
+			}
+			return false;
+		}
+		
+		protected virtual DataNode ReadAttribute (string name, string value)
+		{
+			return new DataValue (name, value);
+		}
+		
+		protected virtual DataNode ReadChild (XmlReader reader, DataItem parent)
+		{
+			return DefaultReader.Read (reader);
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/CombineDescriptor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/CombineDescriptor.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/CombineDescriptor.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -91,14 +91,13 @@
 			
 			// Save combine
 			string combineLocation = Runtime.FileUtilityService.GetDirectoryNameWithSeparator(projectCreateInformation.CombinePath) + newCombineName + &quot;.cmbx&quot;;
-			newCombine.OutputDirectory = Path.Combine (Path.Combine (Path.GetDirectoryName (combineLocation), &quot;build&quot;), &quot;bin&quot;);
 			if (File.Exists(combineLocation)) {
 				IMessageService messageService =(IMessageService)ServiceManager.GetService(typeof(IMessageService));
 				if (messageService.AskQuestion(String.Format (GettextCatalog.GetString (&quot;Solution file {0} already exists, do you want to overwrite\nthe existing file ?&quot;), combineLocation))) {
-					newCombine.SaveCombine(combineLocation);
+					newCombine.Save (combineLocation);
 				}
 			} else {
-				newCombine.SaveCombine(combineLocation);
+				newCombine.Save (combineLocation);
 			}
 			newCombine.Dispose();
 			return combineLocation;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/ProjectDescriptor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/ProjectDescriptor.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/ProjectDescriptor.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -12,11 +12,13 @@
 using System.Collections.Specialized;
 using System.Diagnostics;
 using System.Reflection;
+using MonoDevelop.Internal.Project;
 using MonoDevelop.Core.Services;
 using MonoDevelop.Services;
 using MonoDevelop.Gui;
-using MonoDevelop.Internal.Project;
 
+using Project_ = MonoDevelop.Internal.Project.Project;
+
 namespace MonoDevelop.Internal.Templates
 {
 	/// &lt;summary&gt;
@@ -26,7 +28,7 @@
 	{
 		string name;
 		string relativePath;
-		string languageName = null;
+		string projectType;
 		
 		ArrayList files      = new ArrayList(); // contains FileTemplate classes
 		ArrayList references = new ArrayList(); 
@@ -35,12 +37,6 @@
 		XmlElement projectOptions = null;
 		
 		#region public properties
-		public string LanguageName {
-			get {
-				return languageName;
-			}
-		}
-
 		public ArrayList Files {
 			get {
 				return files;
@@ -77,17 +73,19 @@
 			StringParserService stringParserService = Runtime.StringParserService;
 			FileUtilityService fileUtilityService = Runtime.FileUtilityService;
 			
-			string language = languageName != null &amp;&amp; languageName.Length &gt; 0 ? languageName : defaultLanguage;
+			if (projectOptions.GetAttribute (&quot;language&quot;) == &quot;&quot;) {
+				if (defaultLanguage == null || defaultLanguage == &quot;&quot;)
+					throw new InvalidOperationException (&quot;Language not specified in template&quot;);
+				projectOptions.SetAttribute (&quot;language&quot;, defaultLanguage);
+			}
 			
-			ILanguageBinding languageinfo = Runtime.Languages.GetBindingPerLanguageName(language);
+			Project_ project = Runtime.ProjectService.CreateProject (projectType, projectCreateInformation, projectOptions);
 			
-			if (languageinfo == null) {
-				Runtime.MessageService.ShowError(String.Format (GettextCatalog.GetString (&quot;Can't create project with type : {0}&quot;), language));
+			if (project == null) {
+				Runtime.MessageService.ShowError(String.Format (GettextCatalog.GetString (&quot;Can't create project with type : {0}&quot;), projectType));
 				return String.Empty;
 			}
 			
-			IProject project = languageinfo.CreateProject(projectCreateInformation, projectOptions);
-			
 			string newProjectName = stringParserService.Parse(name, new string[,] { 
 				{&quot;ProjectName&quot;, projectCreateInformation.ProjectName}
 			});
@@ -153,10 +151,10 @@
 			
 			if (File.Exists(projectLocation)) {
 				if (Runtime.MessageService.AskQuestion(String.Format (GettextCatalog.GetString (&quot;Project file {0} already exists, do you want to overwrite\nthe existing file ?&quot;), projectLocation),  GettextCatalog.GetString (&quot;File already exists&quot;))) {
-					project.SaveProject(projectLocation);
+					project.Save (projectLocation);
 				}
 			} else {
-				project.SaveProject(projectLocation);
+				project.Save (projectLocation);
 			}
 			
 			return projectLocation;
@@ -166,10 +164,12 @@
 		{
 			ProjectDescriptor projectDescriptor = new ProjectDescriptor(element.Attributes[&quot;name&quot;].InnerText, element.Attributes[&quot;directory&quot;].InnerText);
 			
+			projectDescriptor.projectType = element.GetAttribute (&quot;type&quot;);
+			if (projectDescriptor.projectType == &quot;&quot;) projectDescriptor.projectType = &quot;DotNet&quot;;
+			
 			projectDescriptor.projectOptions = element[&quot;Options&quot;];
-			if (element.Attributes[&quot;language&quot;] != null) {
-				projectDescriptor.languageName = element.Attributes[&quot;language&quot;].InnerText;
-			}
+			if (projectDescriptor.projectOptions == null)
+				projectDescriptor.projectOptions = element.OwnerDocument.CreateElement (&quot;Options&quot;);
 			
 			if (element[&quot;Files&quot;] != null) {
 				foreach (XmlNode node in element[&quot;Files&quot;].ChildNodes) {

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/ProjectTemplate.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/ProjectTemplate.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates/ProjectTemplate.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -142,8 +142,10 @@
 			
 			name         = GettextCatalog.GetString (config[&quot;_Name&quot;].InnerText);
 			category     = config[&quot;Category&quot;].InnerText;
-			languagename = config[&quot;LanguageName&quot;].InnerText;
 			
+			if (config[&quot;LanguageName&quot;] != null)
+				languagename = config[&quot;LanguageName&quot;].InnerText;
+			
 			if (config[&quot;_Description&quot;] != null) {
 				description  = GettextCatalog.GetString (config[&quot;_Description&quot;].InnerText);
 			}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-01-14 00:26:36 UTC (rev 2126)
@@ -72,6 +72,7 @@
 Gui/Dialogs/OptionPanels/ProjectOptions/CompileFileProjectOptions.cs \
 Gui/Dialogs/OptionPanels/ProjectOptions/DeployFileOptions.cs \
 Gui/Dialogs/OptionPanels/ProjectOptions/GeneralProjectOptions.cs \
+Gui/Dialogs/OptionPanels/ProjectOptions/OutputOptionsPanel.cs \
 Gui/Dialogs/OptionPanels/IDEOptions/BuildPanel.cs \
 Gui/Dialogs/OptionPanels/IDEOptions/LoadSavePanel.cs \
 Gui/Dialogs/OptionPanels/IDEOptions/SelectStylePanel.cs \
@@ -195,6 +196,7 @@
 Services/Project/DefaultProjectService.cs \
 Services/Project/ParseInformationEventHandler.cs \
 Services/Project/CombineEventArgs.cs \
+Services/Project/FileFormatManager.cs \
 Services/IconService.cs \
 Services/StatusBar/DefaultStatusBarService.cs \
 Services/StatusBar/IStatusBarService.cs \
@@ -229,6 +231,7 @@
 Internal/Undo/IUndoableOperation.cs \
 Internal/Undo/UndoStack.cs \
 Internal/Undo/UndoQueue.cs \
+Internal/Conditions/LanguageActiveCondition.cs \
 Internal/Conditions/OwnerStateCondition.cs \
 Internal/Conditions/ProjectActiveCondition.cs \
 Internal/Conditions/WindowActiveCondition.cs \
@@ -244,6 +247,8 @@
 Internal/Codons/LanguageBinding/ILanguageBinding.cs \
 Internal/Codons/LanguageBinding/LanguageBindingCodon.cs \
 Internal/Codons/LanguageBinding/DefaultCompilerResult.cs \
+Internal/Codons/ProjectBinding/IProjectBinding.cs \
+Internal/Codons/ProjectBinding/ProjectBindingCodon.cs \
 Internal/Codons/DefaultDialogPanelDescriptor.cs \
 Internal/Codons/Toolbars/ToolbarItemCodon.cs \
 Internal/Codons/IDialogPanel.cs \
@@ -334,10 +339,10 @@
 Internal/Parser/IMethod.cs \
 Internal/Parser/IComment.cs \
 Internal/Parser/ICompilationUnit.cs \
-Internal/Project/Attributes/XmlNodeNameAttribute.cs \
-Internal/Project/Attributes/ConvertToRelativePathAttribute.cs \
-Internal/Project/Attributes/XmlSetAttribute.cs \
-Internal/Project/Attributes/XmlAttributeAttribute.cs \
+Internal/Project/PrjxFileFormat.cs \
+Internal/Project/CmbxFileFormat.cs \
+Internal/Project/IFileFormat.cs \
+Internal/Project/ProjectPathItemPropertyAttribute.cs \
 Internal/Project/Project/Deployment/DeployInformation.cs \
 Internal/Project/Project/Deployment/AssemblyDeploy.cs \
 Internal/Project/Project/Deployment/ScriptDeploy.cs \
@@ -349,6 +354,9 @@
 Internal/Project/Project/TypelibImporter.cs \
 Internal/Project/Project/AbstractProjectConfiguration.cs \
 Internal/Project/Project/AbstractProject.cs \
+Internal/Project/Project/DotNetProject.cs \
+Internal/Project/Project/DotNetProjectBinding.cs \
+Internal/Project/Project/DotNetProjectConfiguration.cs \
 Internal/Project/Project/ProjectReference.cs \
 Internal/Project/Project/ProjectReferenceEventArgs.cs \
 Internal/Project/Project/ConvertXml.cs \
@@ -358,7 +366,6 @@
 Internal/Project/Project/ProjectFile.cs \
 Internal/Project/Project/ProjectFileEventArgs.cs \
 Internal/Project/Project/AbstractConfiguration.cs \
-Internal/Project/Project/IProject.cs \
 Internal/Project/Combine/Combine.cs \
 Internal/Project/Combine/CombineExecuteDefinition.cs \
 Internal/Project/Combine/CyclicBuildOrderException.cs \
@@ -366,6 +373,7 @@
 Internal/Project/Combine/NoStartupCombineDefinedException.cs \
 Internal/Project/Combine/CombineEntry.cs \
 Internal/Project/Combine/CombineEntryEventArgs.cs \
+Internal/Project/Combine/CombineEntryRenamedEventArgs.cs \
 Internal/Templates/FileDescriptionTemplate.cs \
 Internal/Templates/CodeTemplate.cs \
 Internal/Templates/CodeTemplateGroup.cs \
@@ -383,6 +391,29 @@
 Internal/CollectionUtilities/Comparers.cs \
 Internal/ExternalTool/ToolLoader.cs \
 Internal/ExternalTool/ExternalTool.cs \
+Internal/Serialization/ArrayHandler.cs \
+Internal/Serialization/ArrayListHandler.cs \
+Internal/Serialization/ClassDataType.cs \
+Internal/Serialization/CollectionDataType.cs \
+Internal/Serialization/DataContext.cs \
+Internal/Serialization/DataNode.cs \
+Internal/Serialization/DataCollection.cs \
+Internal/Serialization/DataType.cs \
+Internal/Serialization/DataIncludeAttribute.cs \
+Internal/Serialization/DataItem.cs \
+Internal/Serialization/DataItemAttribute.cs \
+Internal/Serialization/DataValue.cs \
+Internal/Serialization/GenericCollectionHandler.cs \
+Internal/Serialization/IExtendedDataItem.cs \
+Internal/Serialization/ICollectionHandler.cs \
+Internal/Serialization/ExpandedCollectionAttribute.cs \
+Internal/Serialization/ItemProperty.cs \
+Internal/Serialization/ItemPropertyAttribute.cs \
+Internal/Serialization/SerializationContext.cs \
+Internal/Serialization/EnumDataType.cs \
+Internal/Serialization/PrimitiveDataType.cs \
+Internal/Serialization/XmlDataSerializer.cs \
+Internal/Serialization/DataSerializer.cs \
 AssemblyInfo.cs
 
 OPTIONS = \
@@ -413,7 +444,7 @@
 	cp $(srcdir)/$(ADDIN) $(ADDIN_BUILD)/.
 
 $(ASSEMBLY): $(build_sources) $(srcdir)/Base.glade
-	$(CSC) $(MONO_POSIX_OEE) -codepage:utf8 /out:$(ASSEMBLY) /target:library $(DLLS) \
+	$(CSC) $(MONO_POSIX_OEE) -g -codepage:utf8 /out:$(ASSEMBLY) /target:library $(DLLS) \
 		/resource:$(srcdir)/Base.glade,Base.glade \
 		$(monodoc_libflags) \
 		$(build_sources) \

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml	2005-01-14 00:26:36 UTC (rev 2126)
@@ -63,7 +63,12 @@
 		&lt;Class id    = &quot;ProcessService&quot;
 		       class = &quot;MonoDevelop.Services.ProcessService&quot;/&gt;
 	&lt;/Extension&gt;
-
+	
+	&lt;Extension path = &quot;/SharpDevelop/Workbench/ProjectBindings&quot;&gt;
+		&lt;ProjectBinding id = &quot;DotNet&quot;
+						class = &quot;MonoDevelop.Internal.Project.DotNetProjectBinding&quot; /&gt;
+	&lt;/Extension&gt;
+	  
 	&lt;Extension path = &quot;/SharpDevelop/Workbench/DisplayBindings&quot;&gt;
 		&lt;DisplayBinding id    = &quot;Browser&quot;
 		                supportedformats = &quot;Web Pages&quot;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/File/DefaultFileService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/File/DefaultFileService.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/File/DefaultFileService.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -51,14 +51,14 @@
 		class LoadFileWrapper
 		{
 			IDisplayBinding binding;
-			IProject project;
+			Project project;
 			
 			public LoadFileWrapper(IDisplayBinding binding)
 			{
 				this.binding = binding;
 			}
 			
-			public LoadFileWrapper(IDisplayBinding binding, IProject project)
+			public LoadFileWrapper(IDisplayBinding binding, Project project)
 			{
 				this.binding = binding;
 				this.project = project;
@@ -148,7 +148,7 @@
 			IDisplayBinding binding = Runtime.Gui.DisplayBindings.GetBindingPerFileName(fileName);
 			
 			if (binding != null) {
-				IProject project = null;
+				Project project = null;
 				Combine combine = null;
 				GetProjectAndCombineFromFile (fileName, out project, out combine);
 				
@@ -182,21 +182,17 @@
 			if(oFileInfo.OnFileOpened!=null) oFileInfo.OnFileOpened();
 		}
 		
-		protected void GetProjectAndCombineFromFile (string fileName, out IProject project, out Combine combine)
+		protected void GetProjectAndCombineFromFile (string fileName, out Project project, out Combine combine)
 		{
 			combine = Runtime.ProjectService.CurrentOpenCombine;
 			project = null;
 			
 			if (combine != null)
 			{
-				ArrayList projectslist = Combine.GetAllProjects(combine);
-
-				foreach (ProjectCombineEntry projectaux in projectslist)
+				foreach (Project projectaux in combine.GetAllProjects())
 				{
-					if (projectaux.Project.IsFileInProject (fileName))
-					{
-						project = projectaux.Project;
-					}
+					if (projectaux.IsFileInProject (fileName))
+						project = projectaux;
 				}
 			}
 		}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/LanguageBinding/LanguageBindingService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/LanguageBinding/LanguageBindingService.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/LanguageBinding/LanguageBindingService.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -69,8 +69,9 @@
 			return GetCodonPerLanguageName(doc.DocumentElement.Attributes[&quot;projecttype&quot;].InnerText);
 		}
 		
-		public LanguageBindingService()
+		public override void InitializeService ()
 		{
+			base.InitializeService ();
 			bindings = (LanguageBindingCodon[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/LanguageBindings&quot;).BuildChildItems(null)).ToArray(typeof(LanguageBindingCodon));
 		}
 	}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/CodeCompletionDatabase.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/CodeCompletionDatabase.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/CodeCompletionDatabase.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -628,9 +628,9 @@
 	
 	internal class ProjectCodeCompletionDatabase: CodeCompletionDatabase
 	{
-		IProject project;
+		Project project;
 		
-		public ProjectCodeCompletionDatabase (IProject project, DefaultParserService parserService)
+		public ProjectCodeCompletionDatabase (Project project, DefaultParserService parserService)
 		: base (parserService)
 		{
 			SetLocation (project.BaseDirectory, project.Name);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/DefaultParserService.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -60,12 +60,12 @@
 		class CompilationUnitTypeResolver: ITypeResolver
 		{
 			public IClass CallingClass;
-			IProject project;
+			Project project;
 			ICompilationUnit unit;
 			DefaultParserService parserService;
 			bool allResolved;
 			
-			public CompilationUnitTypeResolver (IProject project, ICompilationUnit unit, DefaultParserService parserService)
+			public CompilationUnitTypeResolver (Project project, ICompilationUnit unit, DefaultParserService parserService)
 			{
 				this.project = project;
 				this.unit = unit;
@@ -261,7 +261,6 @@
 			projectService.FileAddedToProject += new ProjectFileEventHandler (OnProjectFilesChanged);
 			projectService.ReferenceAddedToProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
 			projectService.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
-			projectService.ProjectRenamed += new ProjectRenameEventHandler(OnProjectRenamed);
 		}
 		
 		internal CodeCompletionDatabase GetDatabase (string uri)
@@ -269,7 +268,7 @@
 			return GetDatabase (null, uri);
 		}
 		
-		internal ProjectCodeCompletionDatabase GetProjectDatabase (IProject project)
+		internal ProjectCodeCompletionDatabase GetProjectDatabase (Project project)
 		{
 			if (project == null) return null;
 			return (ProjectCodeCompletionDatabase) GetDatabase (null, &quot;Project:&quot; + project.Name);
@@ -350,7 +349,7 @@
 			}
 		}
 		
-		void LoadProjectDatabase (IProject project)
+		void LoadProjectDatabase (Project project)
 		{
 			lock (databases)
 			{
@@ -361,9 +360,9 @@
 				databases [uri] = db;
 				
 				foreach (ReferenceEntry re in db.References)
-				{
 					GetDatabase (re.Uri);
-				}
+
+				project.NameChanged += new CombineEntryRenamedEventHandler (OnProjectRenamed);
 			}
 		}
 		
@@ -380,10 +379,11 @@
 			}
 		}
 		
-		void UnloadProjectDatabase (IProject project)
+		void UnloadProjectDatabase (Project project)
 		{
 			string uri = &quot;Project:&quot; + project.Name;
 			UnloadDatabase (uri);
+			project.NameChanged -= new CombineEntryRenamedEventHandler (OnProjectRenamed);
 		}
 		
 		void CleanUnusedDatabases ()
@@ -413,17 +413,17 @@
 		
 		public void LoadCombineDatabases (Combine combine)
 		{
-			ArrayList projects = Combine.GetAllProjects(combine);
-			foreach (ProjectCombineEntry entry in projects) {
-				LoadProjectDatabase (entry.Project);
+			CombineEntryCollection projects = combine.GetAllProjects();
+			foreach (Project entry in projects) {
+				LoadProjectDatabase (entry);
 			}
 		}
 		
 		public void UnloadCombineDatabases (Combine combine)
 		{
-			ArrayList projects = Combine.GetAllProjects(combine);
-			foreach (ProjectCombineEntry entry in projects) {
-				UnloadProjectDatabase (entry.Project);
+			CombineEntryCollection projects = combine.GetAllProjects();
+			foreach (Project entry in projects) {
+				UnloadProjectDatabase (entry);
 			}
 		}
 		
@@ -442,9 +442,9 @@
 			e.Combine.EntryRemoved -= combineEntryRemovedHandler;
 		}
 		
-		void OnProjectRenamed (object sender, ProjectRenameEventArgs args)
+		void OnProjectRenamed (object sender, CombineEntryRenamedEventArgs args)
 		{
-			ProjectCodeCompletionDatabase db = GetProjectDatabase (args.Project);
+			ProjectCodeCompletionDatabase db = GetProjectDatabase ((Project) args.CombineEntry);
 			if (db == null) return;
 			
 			db.Rename (args.NewName);
@@ -456,18 +456,18 @@
 		
 		void OnCombineEntryAdded (object sender, CombineEntryEventArgs args)
 		{
-			if (args.CombineEntry is ProjectCombineEntry)
-				LoadProjectDatabase (((ProjectCombineEntry)args.CombineEntry).Project);
-			else if (args.CombineEntry is CombineCombineEntry)
-				LoadCombineDatabases (((CombineCombineEntry)args.CombineEntry).Combine);
+			if (args.CombineEntry is Project)
+				LoadProjectDatabase ((Project)args.CombineEntry);
+			else if (args.CombineEntry is Combine)
+				LoadCombineDatabases ((Combine)args.CombineEntry);
 		}
 		
 		void OnCombineEntryRemoved (object sender, CombineEntryEventArgs args)
 		{
-			if (args.CombineEntry is ProjectCombineEntry)
-				UnloadProjectDatabase (((ProjectCombineEntry)args.CombineEntry).Project);
-			else if (args.CombineEntry is CombineCombineEntry)
-				UnloadCombineDatabases (((CombineCombineEntry)args.CombineEntry).Combine);
+			if (args.CombineEntry is Project)
+				UnloadProjectDatabase ((Project) args.CombineEntry);
+			else if (args.CombineEntry is Combine)
+				UnloadCombineDatabases ((Combine) args.CombineEntry);
 			CleanUnusedDatabases ();
 		}
 		
@@ -706,12 +706,12 @@
 		
 #region Default Parser Layer dependent functions
 
-		public IClass GetClass (IProject project, string typeName)
+		public IClass GetClass (Project project, string typeName)
 		{
 			return GetClass(project, typeName, false, true);
 		}
 		
-		public IClass GetClass (IProject project, string typeName, bool deepSearchReferences, bool caseSensitive)
+		public IClass GetClass (Project project, string typeName, bool deepSearchReferences, bool caseSensitive)
 		{
 			if (deepSearchReferences)
 				return DeepGetClass (project, typeName, caseSensitive);
@@ -719,7 +719,7 @@
 				return GetClass (project, typeName, caseSensitive);
 		}
 		
-		public IClass GetClass (IProject project, string typeName, bool caseSensitive)
+		public IClass GetClass (Project project, string typeName, bool caseSensitive)
 		{
 			CodeCompletionDatabase db = project != null ? GetProjectDatabase (project) : GetActiveFileDatabase ();
 			if (db != null) {
@@ -738,7 +738,7 @@
 			return db.GetClass (typeName, caseSensitive);
 		}
 		
-		public IClass DeepGetClass (IProject project, string typeName, bool caseSensitive)
+		public IClass DeepGetClass (Project project, string typeName, bool caseSensitive)
 		{
 			CodeCompletionDatabase db = (project != null) ? GetProjectDatabase (project) : GetActiveFileDatabase ();
 			
@@ -770,12 +770,12 @@
 			return null;
 		}
 		
-		public string[] GetNamespaceList (IProject project, string subNameSpace)
+		public string[] GetNamespaceList (Project project, string subNameSpace)
 		{
 			return GetNamespaceList (project, subNameSpace, true);
 		}
 		
-		public string[] GetNamespaceList (IProject project, string subNameSpace, bool caseSensitive)
+		public string[] GetNamespaceList (Project project, string subNameSpace, bool caseSensitive)
 		{
 			ArrayList contents = new ArrayList ();
 			
@@ -796,12 +796,12 @@
 			return (string[]) contents.ToArray (typeof(string));
 		}
 		
-		public ArrayList GetNamespaceContents (IProject project, string namspace, bool includeReferences)
+		public ArrayList GetNamespaceContents (Project project, string namspace, bool includeReferences)
 		{
 			return GetNamespaceContents (project, namspace, includeReferences, true);
 		}
 		
-		public ArrayList GetNamespaceContents (IProject project, string namspace, bool includeReferences, bool caseSensitive)
+		public ArrayList GetNamespaceContents (Project project, string namspace, bool includeReferences, bool caseSensitive)
 		{
 			ArrayList contents = new ArrayList ();
 			
@@ -826,12 +826,12 @@
 			return contents;
 		}
 		
-		public bool NamespaceExists(IProject project, string name)
+		public bool NamespaceExists(Project project, string name)
 		{
 			return NamespaceExists(project, name, true);
 		}
 		
-		public bool NamespaceExists(IProject project, string name, bool caseSensitive)
+		public bool NamespaceExists(Project project, string name, bool caseSensitive)
 		{
 			CodeCompletionDatabase db = (project != null) ? GetProjectDatabase (project) : GetActiveFileDatabase ();
 			if (db != null) {
@@ -848,12 +848,12 @@
 			return db.NamespaceExists (name, caseSensitive);
 			}
 
-		public string SearchNamespace(IProject project, IUsing usin, string partitialNamespaceName)
+		public string SearchNamespace(Project project, IUsing usin, string partitialNamespaceName)
 		{
 			return SearchNamespace(project, usin, partitialNamespaceName, true);
 		}
 		
-		public string SearchNamespace(IProject project, IUsing usin, string partitialNamespaceName, bool caseSensitive)
+		public string SearchNamespace(Project project, IUsing usin, string partitialNamespaceName, bool caseSensitive)
 		{
 //			Console.WriteLine(&quot;SearchNamespace : &gt;{0}&lt;&quot;, partitialNamespaceName);
 			if (NamespaceExists(project, partitialNamespaceName, caseSensitive)) {
@@ -896,7 +896,7 @@
 		/// &lt;remarks&gt;
 		/// use the usings and the name of the namespace to find a class
 		/// &lt;/remarks&gt;
-		public IClass SearchType (IProject project, string name, IClass callingClass, ICompilationUnit unit)
+		public IClass SearchType (Project project, string name, IClass callingClass, ICompilationUnit unit)
 		{
 			if (name == null || name == String.Empty)
 				return null;
@@ -937,12 +937,12 @@
 			return null;
 		}
 		
-		public IClass SearchType(IProject project, IUsing iusing, string partitialTypeName)
+		public IClass SearchType(Project project, IUsing iusing, string partitialTypeName)
 		{
 			return SearchType(project, iusing, partitialTypeName, true);
 		}
 		
-		public IClass SearchType(IProject project, IUsing iusing, string partitialTypeName, bool caseSensitive)
+		public IClass SearchType(Project project, IUsing iusing, string partitialTypeName, bool caseSensitive)
 		{
 //			Console.WriteLine(&quot;Search type : &gt;{0}&lt;&quot;, partitialTypeName);
 			IClass c = GetClass(project, partitialTypeName, caseSensitive);
@@ -999,7 +999,7 @@
 			return null;
 		}
 		
-		public bool ResolveTypes (IProject project, ICompilationUnit unit, ClassCollection types, out ClassCollection result)
+		public bool ResolveTypes (Project project, ICompilationUnit unit, ClassCollection types, out ClassCollection result)
 		{
 			CompilationUnitTypeResolver tr = new CompilationUnitTypeResolver (project, unit, this);
 			
@@ -1015,7 +1015,7 @@
 			return allResolved;
 		}
 		
-		public IEnumerable GetClassInheritanceTree (IProject project, IClass cls)
+		public IEnumerable GetClassInheritanceTree (Project project, IClass cls)
 		{
 			return new ClassInheritanceEnumerator (this, project, cls);
 		}
@@ -1046,10 +1046,10 @@
 			
 			if (fileContent == null) {
 				if (Runtime.ProjectService.CurrentOpenCombine != null) {
-					ArrayList projects = Combine.GetAllProjects (Runtime.ProjectService.CurrentOpenCombine);
-					foreach (ProjectCombineEntry entry in projects) {
-						if (entry.Project.IsFileInProject(fileName)) {
-							fileContent = entry.Project.GetParseableFileContent(fileName);
+					CombineEntryCollection projects = Runtime.ProjectService.CurrentOpenCombine.GetAllProjects ();
+					foreach (Project entry in projects) {
+						if (entry.IsFileInProject(fileName)) {
+							fileContent = entry.GetParseableFileContent(fileName);
 						}
 					}
 				}
@@ -1159,7 +1159,7 @@
 		
 		////////////////////////////////////
 		
-		public ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName)
+		public ArrayList CtrlSpace(IParserService parserService, Project project, int caretLine, int caretColumn, string fileName)
 		{
 			IParser parser = GetParser(fileName);
 			if (parser != null) {
@@ -1168,7 +1168,7 @@
 			return null;
 		}
 
-		public ArrayList IsAsResolve (IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		public ArrayList IsAsResolve (Project project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
 			try {
 				IParser parser = GetParser (fileName);
@@ -1181,7 +1181,7 @@
 			}
 		}
 		
-		public ResolveResult Resolve(IProject project,
+		public ResolveResult Resolve(Project project,
 									 string expression, 
 		                             int caretLineNumber,
 		                             int caretColumn,
@@ -1210,7 +1210,7 @@
 			get { return nameTable; }
 		}
 		
-		public string MonodocResolver (IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		public string MonodocResolver (Project project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
 			try {
 				IParser parser = GetParser (fileName);
@@ -1279,9 +1279,9 @@
 		IClass topLevelClass;
 		IClass currentClass  = null;
 		Queue  baseTypeQueue = new Queue();
-		IProject project;
+		Project project;
 
-		internal ClassInheritanceEnumerator(DefaultParserService parserService, IProject project, IClass topLevelClass)
+		internal ClassInheritanceEnumerator(DefaultParserService parserService, Project project, IClass topLevelClass)
 		{
 			this.parserService = parserService;
 			this.project = project;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/IParserService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/IParserService.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ParserService/IParserService.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -48,22 +48,22 @@
 		IExpressionFinder GetExpressionFinder(string fileName);
 		
 		// Default Parser Layer dependent functions
-		IClass    GetClass(IProject project, string typeName);
-		string[]  GetNamespaceList(IProject project, string subNameSpace);
-		ArrayList GetNamespaceContents(IProject project, string subNameSpace, bool includeReferences);
-		bool      NamespaceExists(IProject project, string name);
-		string    SearchNamespace(IProject project, IUsing iusing, string partitialNamespaceName);
-		IClass    SearchType(IProject project, IUsing iusing, string partitialTypeName);
+		IClass    GetClass(Project project, string typeName);
+		string[]  GetNamespaceList(Project project, string subNameSpace);
+		ArrayList GetNamespaceContents(Project project, string subNameSpace, bool includeReferences);
+		bool      NamespaceExists(Project project, string name);
+		string    SearchNamespace(Project project, IUsing iusing, string partitialNamespaceName);
+		IClass    SearchType(Project project, IUsing iusing, string partitialTypeName);
 		
-		IClass    GetClass(IProject project, string typeName, bool deepSearchReferences, bool caseSensitive);
-		string[]  GetNamespaceList(IProject project, string subNameSpace, bool caseSensitive);
-		ArrayList GetNamespaceContents(IProject project, string subNameSpace, bool includeReferences, bool caseSensitive);
-		bool      NamespaceExists(IProject project, string name, bool caseSensitive);
-		string    SearchNamespace(IProject project, IUsing iusing, string partitialNamespaceName, bool caseSensitive);
-		IClass    SearchType(IProject project, IUsing iusing, string partitialTypeName, bool caseSensitive);
-		IClass    SearchType (IProject project, string name, IClass callingClass, ICompilationUnit unit);
+		IClass    GetClass(Project project, string typeName, bool deepSearchReferences, bool caseSensitive);
+		string[]  GetNamespaceList(Project project, string subNameSpace, bool caseSensitive);
+		ArrayList GetNamespaceContents(Project project, string subNameSpace, bool includeReferences, bool caseSensitive);
+		bool      NamespaceExists(Project project, string name, bool caseSensitive);
+		string    SearchNamespace(Project project, IUsing iusing, string partitialNamespaceName, bool caseSensitive);
+		IClass    SearchType(Project project, IUsing iusing, string partitialTypeName, bool caseSensitive);
+		IClass    SearchType (Project project, string name, IClass callingClass, ICompilationUnit unit);
 		
-		IEnumerable GetClassInheritanceTree (IProject project, IClass cls);
+		IEnumerable GetClassInheritanceTree (Project project, IClass cls);
 		
 		////////////////////////////////////////////
 
@@ -71,15 +71,15 @@
 		/// Resolves an expression.
 		/// The caretLineNumber and caretColumn is 1 based.
 		/// &lt;/summary&gt;
-		ResolveResult Resolve(IProject project,
+		ResolveResult Resolve(Project project,
 							  string expression,
 		                      int caretLineNumber,
 		                      int caretColumn,
 		                      string fileName,
 		                      string fileContent);
-		string MonodocResolver (IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
-		ArrayList IsAsResolve (IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
-		ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName);
+		string MonodocResolver (Project project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+		ArrayList IsAsResolve (Project project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+		ArrayList CtrlSpace(IParserService parserService, Project project, int caretLine, int caretColumn, string fileName);
 		string LoadAssemblyFromGac (string name);
 
 		event ParseInformationEventHandler ParseInformationChanged;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,9 +14,13 @@
 
 using MonoDevelop.Gui;
 using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Serialization;
 
 using MonoDevelop.Core.Properties;
 using MonoDevelop.Core.Services;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Internal.Templates;
+using MonoDevelop.Core.AddIns;
 
 namespace MonoDevelop.Services
 {
@@ -29,13 +33,17 @@
 	
 	public class DefaultProjectService : AbstractService, IProjectService
 	{
-		IProject currentProject = null;
+		Project currentProject = null;
 		Combine  currentCombine = null;
 		Combine  openCombine    = null;
+		DataContext dataContext = new DataContext ();
+		ProjectBindingCodon[] projectBindings;
 		
-		string   openCombineFileName = null;
-		
-		public IProject CurrentSelectedProject {
+		FileFormatManager formatManager = new FileFormatManager ();
+		IFileFormat defaultProjectFormat = new PrjxFileFormat ();
+		IFileFormat defaultCombineFormat = new CmbxFileFormat ();
+			
+		public Project CurrentSelectedProject {
 			get {
 				return currentProject;
 			}
@@ -68,10 +76,10 @@
 		
 		bool IsDirtyFileInCombine {
 			get {
-				ArrayList projects = Combine.GetAllProjects(openCombine);
+				CombineEntryCollection projects = openCombine.GetAllProjects();
 				
-				foreach (ProjectCombineEntry projectEntry in projects) {
-					foreach (ProjectFile fInfo in projectEntry.Project.ProjectFiles) {
+				foreach (Project projectEntry in projects) {
+					foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
 						foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
 							if (content.IsDirty &amp;&amp; content.ContentName == fInfo.Name) {
 								return true;
@@ -92,28 +100,84 @@
 			}
 		}
 		
+		public DataContext DataContext {
+			get { return dataContext; }
+		}
+		
+		public FileFormatManager FileFormats {
+			get { return formatManager; }
+		}
+		
 		public void SaveCombinePreferences()
 		{
-			if (CurrentOpenCombine != null) {
-				SaveCombinePreferences(CurrentOpenCombine, openCombineFileName);
+			if (CurrentOpenCombine != null)
+				SaveCombinePreferences(CurrentOpenCombine);
+		}
+		
+		public CombineEntry ReadFile (string file)
+		{
+			IFileFormat format = formatManager.GetFileFormat (file);
+
+			if (format == null)
+				throw new InvalidOperationException (&quot;Unknown file format: &quot; + file);
+			
+			CombineEntry obj = format.ReadFile (file) as CombineEntry;
+			if (obj == null)
+				throw new InvalidOperationException (&quot;Invalid file format: &quot; + file);
+				
+			obj.FileFormat = format;
+			return obj;
+		}
+		
+		public void WriteFile (string file, CombineEntry entry)
+		{
+			IFileFormat format = entry.FileFormat;
+			if (format == null) {
+				if (entry is Project) format = defaultProjectFormat;
+				else if (entry is Combine) format = defaultCombineFormat;
+				else format = formatManager.GetFileFormatForObject (entry);
+				
+				if (format == null)
+					throw new InvalidOperationException (&quot;FileFormat not provided for combine entry '&quot; + entry.Name + &quot;'&quot;);
 			}
+
+			format.WriteFile (file, entry);
 		}
 		
+		public Project CreateSingleFileProject (string file)
+		{
+			foreach (ProjectBindingCodon projectBinding in projectBindings) {
+				Project project = projectBinding.ProjectBinding.CreateSingleFileProject (file);
+				if (project != null)
+					return project;
+			}
+			return null;
+		}
+		
+		public Project CreateProject (string type, ProjectCreateInformation info, XmlElement projectOptions)
+		{
+			foreach (ProjectBindingCodon projectBinding in projectBindings) {
+				if (projectBinding.ProjectBinding.Name == type) {
+					Project project = projectBinding.ProjectBinding.CreateProject (info, projectOptions);
+					return project;
+				}
+			}
+			return null;
+		}
+		
 		public void CloseCombine()
 		{
 			CloseCombine(true);
 		}
 
-		public void CloseCombine(bool saveCombinePreferencies)
+		public void CloseCombine (bool saveCombinePreferencies)
 		{
 			if (CurrentOpenCombine != null) {
 				if (saveCombinePreferencies)
-					SaveCombinePreferences(CurrentOpenCombine, openCombineFileName);
-				GenerateMakefiles ();
+					SaveCombinePreferences (CurrentOpenCombine);
 				Combine closedCombine = CurrentOpenCombine;
 				CurrentSelectedProject = null;
 				CurrentOpenCombine = CurrentSelectedCombine = null;
-				openCombineFileName = null;
 				WorkbenchSingleton.Workbench.CloseAllViews();
 				OnCombineClosed(new CombineEventArgs(closedCombine));
 				closedCombine.Dispose();
@@ -122,6 +186,15 @@
 		
 		FileUtilityService fileUtilityService = Runtime.FileUtilityService;
 		
+		public bool IsCombineEntryFile (string filename)
+		{
+			if (filename.StartsWith (&quot;<A HREF="file://&quot;">file://&quot;</A>))
+				filename = filename.Substring (7);
+				
+			IFileFormat format = formatManager.GetFileFormat (filename);
+			return format != null;
+		}
+		
 		public void OpenCombine(string filename)
 		{
 			if (openCombine != null) {
@@ -132,28 +205,10 @@
 			if (filename.StartsWith (&quot;<A HREF="file://&quot;">file://&quot;</A>))
 				filename = filename.Substring (7);
 				
-			if (!fileUtilityService.TestFileExists(filename)) {
-				return;
-			}
 			Runtime.Gui.StatusBar.SetMessage(GettextCatalog.GetString (&quot;Opening Combine...&quot;));
-				
-			if (Path.GetExtension(filename).ToUpper() == &quot;.PRJX&quot;) {
-				string validcombine = Path.ChangeExtension(filename, &quot;.cmbx&quot;);
-				if (File.Exists(validcombine)) {
-					LoadCombine(validcombine);
-				} else {
-					Combine loadingCombine = new Combine();
-					IProject project = (IProject)loadingCombine.AddEntry(filename);
-					if (project == null) {
-						return;
-					}
-					loadingCombine.Name = project.Name;
-					loadingCombine.SaveCombine(validcombine);
-					LoadCombine(validcombine);
-				}
-			} else {
-				LoadCombine(filename);
-			}
+
+			LoadCombine (filename);
+			
 			Runtime.Gui.StatusBar.SetMessage(GettextCatalog.GetString (&quot;Ready&quot;));
 		}
 		
@@ -169,11 +224,24 @@
 				return;
 			}
 			
-			Combine loadingCombine = new Combine();
-			loadingCombine.LoadCombine(filename);
-			openCombine         = loadingCombine;
-			openCombineFileName = filename;
+			string validcombine = Path.ChangeExtension (filename, &quot;.cmbx&quot;);
 			
+			if (Path.GetExtension (filename).ToLower() != &quot;.cmbx&quot;) {
+				if (File.Exists (validcombine))
+					filename = validcombine;
+			}
+			
+			CombineEntry entry = ReadFile (filename);
+			if (!(entry is Combine)) {
+				Combine loadingCombine = new Combine();
+				loadingCombine.Entries.Add (entry);
+				loadingCombine.Name = entry.Name;
+				loadingCombine.Save (validcombine);
+				entry = loadingCombine;
+			}
+		
+			openCombine = (Combine) entry;
+			
 			Runtime.FileService.RecentOpen.AddLastProject (filename, openCombine.Name);
 			
 			OnCombineOpened(new CombineEventArgs(openCombine));
@@ -183,80 +251,31 @@
 			openCombine.ReferenceAddedToProject += new ProjectReferenceEventHandler (NotifyReferenceAddedToProject);
 			openCombine.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (NotifyReferenceRemovedFromProject);
 	
-			RestoreCombinePreferences(CurrentOpenCombine, openCombineFileName);
+			RestoreCombinePreferences (CurrentOpenCombine);
 		}
 		
-		void Save(string fileName)
-		{
-			openCombineFileName = System.IO.Path.GetFullPath (fileName);
-			openCombine.SaveCombine(fileName);
-			openCombine.SaveAllProjects();
-		}
-		
-		public ProjectReference AddReferenceToProject(IProject prj, string filename)
-		{
-			foreach (ProjectReference rInfo in prj.ProjectReferences) {
-				if (rInfo.Reference == filename) {
-					return rInfo;
-				}
-			}
-			ProjectReference newReferenceInformation = new ProjectReference(ReferenceType.Assembly, filename);
-			prj.ProjectReferences.Add(newReferenceInformation);
-			return newReferenceInformation;
-		}
-		
-		public ProjectFile AddFileToProject(IProject prj, string filename, BuildAction action)
-		{
-			foreach (ProjectFile fInfo in prj.ProjectFiles) {
-				if (fInfo.Name == filename) {
-					return fInfo;
-				}
-			}
-			ProjectFile newFileInformation = new ProjectFile(filename, action);
-			prj.ProjectFiles.Add(newFileInformation);
-			return newFileInformation;
-		}
-		
-		public void AddFileToProject(IProject prj, ProjectFile projectFile) {
-			prj.ProjectFiles.Add(projectFile);
-		}
-
-		
 		public void SaveCombine()
 		{
-			Save(openCombineFileName);
+			openCombine.Save ();
 		}
 		
-		public void MarkFileDirty(string filename)
+		public void MarkFileDirty (string filename)
 		{
 			if (openCombine != null) {
-				ProjectCombineEntry entry = openCombine.GetProjectEntryContaining(filename);
+				Project entry = openCombine.GetProjectEntryContaining (filename);
 				if (entry != null) {
-					entry.IsDirty = true;
+					entry.NeedsBuilding = true;
 				}
 			}
 		}
-		
-		public void MarkProjectDirty(IProject project)
-		{
-			if (openCombine != null) {
-				ArrayList projectEntries = Combine.GetAllProjects(openCombine);
-				foreach (ProjectCombineEntry entry in projectEntries) {
-					if (entry.Project == project) {
-						entry.IsDirty = true;
-						break;
-					}
-				}
-			}
-		}
-		
+
 		public void CompileCombine()
 		{
 			if (openCombine != null) {
 				DoBeforeCompileAction();
 				Runtime.TaskService.ClearTasks();
 				
-				openCombine.Build(false);
+				openCombine.Build ();
 			}
 		}
 		
@@ -266,11 +285,12 @@
 				DoBeforeCompileAction();
 				Runtime.TaskService.ClearTasks();
 				
-				openCombine.Build(true);
+				openCombine.Clean ();
+				openCombine.Build ();
 			}
 		}
 		
-		ILanguageBinding BeforeCompile(IProject project)
+		void BeforeCompile (Project project)
 		{
 			DoBeforeCompileAction();
 			
@@ -289,11 +309,9 @@
 			} catch (Exception e) {
 				throw new ApplicationException(&quot;Can't create project output directory &quot; + outputDir + &quot; original exception:\n&quot; + e.ToString());
 			}
-			// cut&amp;paste EDND
-			return Runtime.Languages.GetBindingPerLanguageName(project.ProjectType);
 		}
 		
-		void AfterCompile(IProject project, ICompilerResult res)
+		void AfterCompile (Project project, ICompilerResult res)
 		{
 			// cut&amp;pasted from CombineEntry.cs
 			foreach (CompilerError err in res.CompilerResults.Errors) {
@@ -310,14 +328,17 @@
 			Runtime.TaskService.NotifyTaskChange();
 		}
 		
-		public void RecompileProject(IProject project)
+		public void RecompileProject(Project project)
 		{
-			AfterCompile(project, BeforeCompile(project).RecompileProject(project));
+			project.Clean ();
+			BeforeCompile (project);
+			AfterCompile(project, project.Compile ());
 		}
 		
-		public void CompileProject(IProject project)
+		public void CompileProject(Project project)
 		{
-			AfterCompile(project, BeforeCompile(project).CompileProject(project));
+			BeforeCompile (project);
+			AfterCompile(project, project.Compile ());
 		}
 		
 		void DoBeforeCompileAction()
@@ -357,35 +378,21 @@
 			}
 		}
 		
-		public ProjectFile RetrieveFileInformationForFile(string fileName)
-		{
-			ArrayList projects = Combine.GetAllProjects(openCombine);
-			
-			foreach (ProjectCombineEntry projectEntry in projects) {
-				foreach (ProjectFile fInfo in projectEntry.Project.ProjectFiles) {
-					if (fInfo.Name == fileName) {
-						return fInfo;
-					}
-				}
-			}
-			return null;
-		}
-		
 		void RemoveFileFromAllProjects(string fileName)
 		{
-			ArrayList projects = Combine.GetAllProjects(openCombine);
+			CombineEntryCollection projects = openCombine.GetAllProjects();
 			
 			restart:
-			foreach (ProjectCombineEntry projectEntry in projects) {
-				foreach (ProjectReference rInfo in projectEntry.Project.ProjectReferences) {
+			foreach (Project projectEntry in projects) {
+				foreach (ProjectReference rInfo in projectEntry.ProjectReferences) {
 					if (rInfo.ReferenceType == ReferenceType.Assembly &amp;&amp; rInfo.Reference == fileName) {
-						projectEntry.Project.ProjectReferences.Remove(rInfo);
+						projectEntry.ProjectReferences.Remove(rInfo);
 						goto restart;
 					}
 				}
-				foreach (ProjectFile fInfo in projectEntry.Project.ProjectFiles) {
+				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
 					if (fInfo.Name == fileName) {
-						projectEntry.Project.ProjectFiles.Remove(fInfo);
+						projectEntry.ProjectFiles.Remove(fInfo);
 						goto restart;
 					}
 				}
@@ -394,13 +401,13 @@
 		
 		void RemoveAllInDirectory(string dirName)
 		{
-			ArrayList projects = Combine.GetAllProjects(openCombine);
+			CombineEntryCollection projects = openCombine.GetAllProjects();
 			
 			restart:
-			foreach (ProjectCombineEntry projectEntry in projects) {
-				foreach (ProjectFile fInfo in projectEntry.Project.ProjectFiles) {
+			foreach (Project projectEntry in projects) {
+				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
 					if (fInfo.Name.StartsWith(dirName)) {
-						projectEntry.Project.ProjectFiles.Remove(fInfo);
+						projectEntry.ProjectFiles.Remove(fInfo);
 						goto restart;
 					}
 				}
@@ -420,10 +427,10 @@
 		
 		void RenameFileInAllProjects(string oldName, string newName)
 		{
-			ArrayList projects = Combine.GetAllProjects(openCombine);
+			CombineEntryCollection projects = openCombine.GetAllProjects();
 			
-			foreach (ProjectCombineEntry projectEntry in projects) {
-				foreach (ProjectFile fInfo in projectEntry.Project.ProjectFiles) {
+			foreach (Project projectEntry in projects) {
+				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
 					if (fInfo.Name == oldName) {
 						fInfo.Name = newName;
 					}
@@ -433,10 +440,10 @@
 
 		void RenameDirectoryInAllProjects(string oldName, string newName)
 		{
-			ArrayList projects = Combine.GetAllProjects(openCombine);
+			CombineEntryCollection projects = openCombine.GetAllProjects();
 			
-			foreach (ProjectCombineEntry projectEntry in projects) {
-				foreach (ProjectFile fInfo in projectEntry.Project.ProjectFiles) {
+			foreach (Project projectEntry in projects) {
+				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
 					if (fInfo.Name.StartsWith(oldName)) {
 						fInfo.Name = newName + fInfo.Name.Substring(oldName.Length);
 					}
@@ -459,8 +466,19 @@
 		public override void InitializeService()
 		{
 			base.InitializeService();
+
+			formatManager.RegisterFileFormat (defaultProjectFormat);
+			formatManager.RegisterFileFormat (defaultCombineFormat);
+			formatManager.RegisterFileFormat (new MonoMakefileFormat ());
+			
+			DataContext.IncludeType (typeof(Combine));
+			DataContext.IncludeType (typeof(Project));
+			DataContext.IncludeType (typeof(DotNetProject));
+			
 			Runtime.FileService.FileRemoved += new FileEventHandler(CheckFileRemove);
 			Runtime.FileService.FileRenamed += new FileEventHandler(CheckFileRename);
+			
+			projectBindings = (ProjectBindingCodon[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/ProjectBindings&quot;).BuildChildItems(null)).ToArray(typeof(ProjectBindingCodon));
 		}
 		
 		string MakeValidName(string str)
@@ -472,9 +490,11 @@
 			return tmp;
 		}
 		
-		void RestoreCombinePreferences(Combine combine, string combinefilename)
+		void RestoreCombinePreferences (Combine combine)
 		{
+			string combinefilename = combine.FileName;
 			string directory = Runtime.Properties.ConfigDirectory + &quot;CombinePreferences&quot;;
+
 			if (!Directory.Exists(directory)) {
 				return;
 			}
@@ -524,9 +544,11 @@
 			} 
 		}
 		
-		void SaveCombinePreferences(Combine combine, string combinefilename)
+		void SaveCombinePreferences (Combine combine)
 		{
+			string combinefilename = combine.FileName;
 			string directory = Runtime.Properties.ConfigDirectory + &quot;CombinePreferences&quot;;
+
 			if (!Directory.Exists(directory)) {
 				Directory.CreateDirectory(directory);
 			}
@@ -585,7 +607,6 @@
 		//********* own events
 		protected virtual void OnCombineOpened(CombineEventArgs e)
 		{
-			GenerateMakefiles ();
 			if (CombineOpened != null) {
 				CombineOpened(this, e);
 			}
@@ -615,39 +636,14 @@
 			}
 		}
 		
-		public virtual void OnRenameProject(ProjectRenameEventArgs e)
+		public Project GetProject (string projectName)
 		{
-			GenerateMakefiles ();
-			if (ProjectRenamed != null) {
-				ProjectRenamed(this, e);
+			if (CurrentOpenCombine == null) return null;
+			CombineEntryCollection allProjects = CurrentOpenCombine.GetAllProjects();
+			foreach (Project project in allProjects) {
+				if (project.Name == projectName)
+					return project;
 			}
-		}
-		
-		public bool ExistsEntryWithName(string name)
-		{
-			ArrayList allProjects = Combine.GetAllProjects(openCombine);
-			foreach (ProjectCombineEntry projectEntry in allProjects) {
-				if (projectEntry.Project.Name == name) {
-					return true;
-				}
-			}
-			return false;
-		}
-		
-		public string GetOutputAssemblyName(IProject project)
-		{
-			ILanguageBinding binding = Runtime.Languages.GetBindingPerLanguageName(project.ProjectType);
-			return binding.GetCompiledOutputName(project);
-		}
-		
-		public string GetOutputAssemblyName(string projectName)
-		{
-			ArrayList allProjects = Combine.GetAllProjects(CurrentOpenCombine);
-			foreach (ProjectCombineEntry projectEntry in allProjects) {
-				if (projectEntry.Project.Name == projectName) {
-					return GetOutputAssemblyName(projectEntry.Project);
-				}
-			}
 			return null;
 		}
 		
@@ -659,7 +655,6 @@
 				} else {
 					RemoveFileFromAllProjects(fileName);
 				}
-				GenerateMakefiles ();
 			}
 		}
 	
@@ -710,7 +705,6 @@
 		
 		protected virtual void OnFileRemovedFromProject (ProjectFileEventArgs e)
 		{
-			GenerateMakefiles ();
 			if (FileRemovedFromProject != null) {
 				FileRemovedFromProject(this, e);
 			}
@@ -718,7 +712,6 @@
 
 		protected virtual void OnFileAddedToProject (ProjectFileEventArgs e)
 		{
-			GenerateMakefiles ();
 			if (FileAddedToProject != null) {
 				FileAddedToProject (this, e);
 			}
@@ -733,7 +726,6 @@
 		
 		protected virtual void OnReferenceRemovedFromProject (ProjectReferenceEventArgs e)
 		{
-			GenerateMakefiles ();
 			if (ReferenceRemovedFromProject != null) {
 				ReferenceRemovedFromProject (this, e);
 			}
@@ -741,57 +733,11 @@
 		
 		protected virtual void OnReferenceAddedToProject (ProjectReferenceEventArgs e)
 		{
-			GenerateMakefiles ();
 			if (ReferenceAddedToProject != null) {
 				ReferenceAddedToProject (this, e);
 			}
 		}
 
-		public string GetFileName(IProject project)
-		{
-			if (openCombine != null) {
-				ArrayList projects = Combine.GetAllProjects(openCombine);
-				foreach (ProjectCombineEntry projectCombineEntry in projects) {
-					if (projectCombineEntry.Project == project) {
-						return projectCombineEntry.Filename;
-					}
-				}
-			}
-			return String.Empty;
-		}
-		
-		public string GetFileName(Combine combine)
-		{
-			if (combine == openCombine) {
-				return openCombineFileName;
-			}
-			Stack combines = new Stack();
-			combines.Push(openCombine);
-			while (combines.Count &gt; 0) {
-				Combine curCombine = (Combine)combines.Pop();
-				foreach (CombineEntry entry in curCombine.Entries) {
-					CombineCombineEntry combineEntry = (CombineCombineEntry)entry;
-					if (combineEntry != null) {
-						if (combineEntry.Combine == combine) {
-							return entry.Filename;
-						}
-						combines.Push(combineEntry.Combine);
-					}
-				}
-			}
-			
-			return String.Empty;
-		}
-
-		public void GenerateMakefiles ()
-		{
-			if (openCombine != null)
-				try {
-					openCombine.GenerateMakefiles ();
-				}
-				catch { }
-		}
-		
 		public event ProjectFileEventHandler FileRemovedFromProject;
 		public event ProjectFileEventHandler FileAddedToProject;
 		public event ProjectFileEventHandler FileChangedInProject;
@@ -805,7 +751,6 @@
 		public event CombineEventHandler CombineClosed;
 		public event CombineEventHandler CurrentSelectedCombineChanged;
 		
-		public event ProjectRenameEventHandler ProjectRenamed;
 		public event ProjectEventHandler       CurrentProjectChanged;
 		
 		public event ProjectReferenceEventHandler ReferenceAddedToProject;

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/FileFormatManager.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/FileFormatManager.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/FileFormatManager.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -0,0 +1,60 @@
+//
+// FileFormatManager.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.Services
+{
+	public class FileFormatManager
+	{
+		ArrayList fileFormats = new ArrayList ();
+		
+		public void RegisterFileFormat (IFileFormat format)
+		{
+			fileFormats.Add (format);
+		}
+		
+		public IFileFormat GetFileFormat (string fileName)
+		{
+			foreach (IFileFormat format in fileFormats)
+				if (format.CanReadFile (fileName))
+					return format;
+			return null;
+		}
+		
+		public IFileFormat GetFileFormatForObject (object obj)
+		{
+			foreach (IFileFormat format in fileFormats)
+				if (format.CanWriteFile (obj))
+					return format;
+			return null;
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/IProjectService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/IProjectService.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/IProjectService.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -7,9 +7,12 @@
 
 using System;
 using System.Collections;
+using System.Xml;
 
 using MonoDevelop.Gui;
 using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Serialization;
+using MonoDevelop.Internal.Templates;
 
 namespace MonoDevelop.Services
 {
@@ -23,7 +26,7 @@
 		/// Gets/Sets the current selected project. (e.g. the project
 		/// that contains the file that has the focus)
 		/// &lt;/remarks&gt;
-		IProject CurrentSelectedProject {
+		Project CurrentSelectedProject {
 			get;
 			set;
 		}
@@ -44,6 +47,8 @@
 			get;
 		}
 		
+		bool IsCombineEntryFile (string filename);
+		
 		/// &lt;remarks&gt;
 		/// Returns true, if one open project that should be compiled is dirty.
 		/// &lt;/remarks&gt;
@@ -51,6 +56,18 @@
 			get;
 		}
 		
+		DataContext DataContext {
+			get;
+		}
+		
+		FileFormatManager FileFormats {
+			get;
+		}
+		
+		CombineEntry ReadFile (string file);
+
+		void WriteFile (string file, CombineEntry entry);
+		
 		/// &lt;remarks&gt;
 		/// Closes the root combine
 		/// &lt;/remarks&gt;
@@ -62,16 +79,6 @@
 		void CloseCombine(bool saveCombinePreferencies);
 		
 		/// &lt;remarks&gt;
-		/// Gets the file name from one combine which is currently opened
-		/// &lt;/remarks&gt;
-		string GetFileName(Combine combine);
-		
-		/// &lt;remarks&gt;
-		/// Gets the file name from one project which is currently opened
-		/// &lt;/remarks&gt;
-		string GetFileName(IProject project);
-		
-		/// &lt;remarks&gt;
 		/// Compile the root combine.
 		/// &lt;/remarks&gt;
 		void CompileCombine();
@@ -85,12 +92,12 @@
 		/// Compiles a specific project, if the project isn't dirty this
 		/// method does nothing
 		/// &lt;/remarks&gt;
-		void CompileProject(IProject project);
+		void CompileProject(Project project);
 		
 		/// &lt;remarks&gt;
 		/// Compiles a specific project (forced!)
 		/// &lt;/remarks&gt;
-		void RecompileProject(IProject project);
+		void RecompileProject(Project project);
 		
 		/// &lt;remarks&gt;
 		/// Opens a new root combine, closes the old root combine automatically.
@@ -109,43 +116,12 @@
 		void SaveCombinePreferences();
 		
 		/// &lt;remarks&gt;
-		/// Add a reference to a given project (only assembly references)
-		/// &lt;/remarks&gt;
-		ProjectReference AddReferenceToProject(IProject prj, string filename);
-		
-		/// &lt;remarks&gt;
-		/// Add a file to a given project
-		/// &lt;/remarks&gt;
-		ProjectFile AddFileToProject(IProject prj, string filename, BuildAction action);
-		
-		/// &lt;remarks&gt;
-		/// Add a file to a given project
-		/// &lt;/remarks&gt;
-		void AddFileToProject(IProject prj, ProjectFile projectFile);
-		
-		/// &lt;remarks&gt;
 		/// Mark a file dirty, the project in which the file is in will be compiled
 		/// in the next compiler run.
 		/// &lt;/remarks&gt;
 		void MarkFileDirty(string filename);
 		
 		/// &lt;remarks&gt;
-		/// Mark a project dirty, the project will be compiled
-		/// in the next compiler run.
-		void MarkProjectDirty(IProject project);
-		
-		/// &lt;remarks&gt;
-		/// If the file given by fileName is inside a currently open project this method
-		/// gets the ProjectFile for this file, returns null otherwise.
-		/// &lt;/remarks&gt;
-		ProjectFile RetrieveFileInformationForFile(string fileName);
-		
-		/// &lt;summary&gt;
-		/// Returns true if a project has this name
-		/// &lt;/summary&gt;
-		bool ExistsEntryWithName(string name);
-		
-		/// &lt;remarks&gt;
 		/// Only to be called by the compile actions.
 		/// &lt;/remarks&gt;
 		void OnStartBuild();
@@ -161,29 +137,16 @@
 		void OnBeforeStartProject();
 		
 		/// &lt;remarks&gt;
-		/// Only to be called by AbstractProject
-		/// &lt;/remarks&gt;
-		void OnRenameProject(ProjectRenameEventArgs e);
-		
-		/// &lt;remarks&gt;
-		/// Gets the file name of the output assembly of a given project
-		/// (Or at least the 'main' file)
-		/// &lt;/remarks&gt;
-		string GetOutputAssemblyName(IProject project);
-		
-		/// &lt;remarks&gt;
-		/// Gets the file name of the output assembly of a given file
-		/// (Or at least the 'main' file)
-		/// &lt;/remarks&gt;
-		string GetOutputAssemblyName(string fileName);
-		
-		/// &lt;remarks&gt;
 		/// Removes a file from it's project(s)
 		/// &lt;/remarks&gt;
 		void RemoveFileFromProject(string fileName);
 
-		void GenerateMakefiles ();
+		Project CreateSingleFileProject (string file);
 		
+		Project CreateProject (string type, ProjectCreateInformation info, XmlElement projectOptions);
+		
+		Project GetProject (string projectName);
+		
 		/// &lt;remarks&gt;
 		/// Is called, when a file is removed from and added to a project.
 		/// &lt;/remarks&gt;
@@ -235,10 +198,5 @@
 		/// Called after the current selected combine has chaned
 		/// &lt;/remarks&gt;
 		event CombineEventHandler CurrentSelectedCombineChanged;
-		
-		/// &lt;remarks&gt;
-		/// Called after a project got renamed
-		/// &lt;/remarks&gt;
-		event ProjectRenameEventHandler ProjectRenamed;
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectEventArgs.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectEventArgs.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectEventArgs.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,15 +14,15 @@
 	
 	public class ProjectEventArgs : EventArgs
 	{
-		IProject project;
+		Project project;
 		
-		public IProject Project {
+		public Project Project {
 			get {
 				return project;
 			}
 		}
 		
-		public ProjectEventArgs(IProject project)
+		public ProjectEventArgs(Project project)
 		{
 			this.project = project;
 		}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectRenameEventArgs.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectRenameEventArgs.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectRenameEventArgs.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -14,11 +14,11 @@
 	
 	public class ProjectRenameEventArgs : EventArgs
 	{ 
-		IProject project;
+		Project project;
 		string   oldName;
 		string   newName;
 		
-		public IProject Project {
+		public Project Project {
 			get {
 				return project;
 			}
@@ -36,7 +36,7 @@
 			}
 		}
 		
-		public ProjectRenameEventArgs(IProject project, string oldName, string newName)
+		public ProjectRenameEventArgs(Project project, string oldName, string newName)
 		{
 			this.project = project;
 			this.oldName = oldName;

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/StatusBar/DefaultStatusBarService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/StatusBar/DefaultStatusBarService.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/StatusBar/DefaultStatusBarService.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -58,6 +58,11 @@
 			statusBar.Worked (work, status);
 		}
 		
+		void IProgressMonitor.Pulse ()
+		{
+			statusBar.Pulse ();
+		}
+		
 		void IProgressMonitor.Done()
 		{
 			statusBar.Done ();

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/Task.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/Task.cs	2005-01-13 00:12:05 UTC (rev 2125)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/Task.cs	2005-01-14 00:26:36 UTC (rev 2126)
@@ -25,7 +25,7 @@
 		string   description;
 		string   fileName;
 		TaskType type;
-		IProject project;
+		Project project;
 		int      line;
 		int      column;
 		
@@ -40,7 +40,7 @@
 			                     description);
 		}
 		
-		public IProject Project {
+		public Project Project {
 			get {
 				return project;
 			}
@@ -91,7 +91,7 @@
 			this.line        = line;
 		}
 		
-		public Task(IProject project, CompilerError error)
+		public Task(Project project, CompilerError error)
 		{
 			this.project = project;
 			type        = error.IsWarning ? error.ErrorNumber == &quot;COMMENT&quot; ? TaskType.Comment : TaskType.Warning : TaskType.Error;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001729.html">[Monodevelop-patches-list] r2125 - in trunk/MonoDevelop/Core/src: AddIns/BackendBindings/CSharpBinding MonoDevelop.Gui.Utils MonoDevelop.Gui.Utils/FileIcons
</A></li>
	<LI>Next message: <A HREF="001731.html">[Monodevelop-patches-list] r2127 - in trunk/MonoDevelop/Core/src/AddIns/BackendBindings/CSharpBinding: . Gui Parser Project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1730">[ date ]</a>
              <a href="thread.html#1730">[ thread ]</a>
              <a href="subject.html#1730">[ subject ]</a>
              <a href="author.html#1730">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
