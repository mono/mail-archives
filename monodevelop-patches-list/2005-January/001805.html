<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2201 - in trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding: . SharpRefactoryVB/src/Lexer SharpRefactoryVB/src/Parser/generated
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2201%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding%3A%20.%20SharpRefactoryVB/src/Lexer%20SharpRefactoryVB/src/Parser/generated&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001804.html">
   <LINK REL="Next"  HREF="001806.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2201 - in trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding: . SharpRefactoryVB/src/Lexer SharpRefactoryVB/src/Parser/generated</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2201%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding%3A%20.%20SharpRefactoryVB/src/Lexer%20SharpRefactoryVB/src/Parser/generated&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2201 - in trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding: . SharpRefactoryVB/src/Lexer SharpRefactoryVB/src/Parser/generated">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Mon Jan 31 14:20:09 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001804.html">[Monodevelop-patches-list] r2200 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Lexer src/Parser/generated
</A></li>
        <LI>Next message: <A HREF="001806.html">[Monodevelop-patches-list] r2202 - trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1805">[ date ]</a>
              <a href="thread.html#1805">[ thread ]</a>
              <a href="subject.html#1805">[ subject ]</a>
              <a href="author.html#1805">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2005-01-31 14:20:08 -0500 (Mon, 31 Jan 2005)
New Revision: 2201

Added:
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Makefile
Modified:
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.cs
   trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG
Log:
warning fixes for unused code


Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog	2005-01-31 18:03:07 UTC (rev 2200)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/ChangeLog	2005-01-31 19:20:08 UTC (rev 2201)
@@ -1,5 +1,14 @@
 2005-01-28  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
 
+	* SharpRefactoryVB/src/Lexer/Lexer.cs:
+	* SharpRefactoryVB/src/Parser/generated/Parser.cs:
+	* SharpRefactoryVB/src/Parser/generated/VBNET.ATG:
+	warning fixes for unused code
+	* SharpRefactoryVB/src/Parser/generated/Makefile:
+	add makefile to regen parser
+
+2005-01-28  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
+
 	* Parser/Parser.cs: update to CanParse
 
 2005-01-27  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs	2005-01-31 18:03:07 UTC (rev 2200)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Lexer/Lexer.cs	2005-01-31 19:20:08 UTC (rev 2201)
@@ -688,8 +688,6 @@
 			StringBuilder curWord = new StringBuilder();
 			StringBuilder comment = new StringBuilder();
 			
-			int x = col;
-			int y = line;
 			int nextChar;
 			while ((nextChar = reader.GetNext()) != -1) {
 				char ch = (char)nextChar;

Added: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Makefile
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Makefile	2005-01-31 18:03:07 UTC (rev 2200)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Makefile	2005-01-31 19:20:08 UTC (rev 2201)
@@ -0,0 +1,6 @@
+
+SHARPCOCO = mono ../../../../../../../Tools/SharpCoco/SharpCoco.exe
+
+all:
+	$(SHARPCOCO) -namespace ICSharpCode.SharpRefactory.Parser.VB VBNET.ATG
+	rm -f Parser.old.cs

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.cs	2005-01-31 18:03:07 UTC (rev 2200)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/Parser.cs	2005-01-31 19:20:08 UTC (rev 2201)
@@ -1,11 +1,11 @@
-
-#line  1 &quot;VBNET.ATG&quot; 
-using System.Drawing;
-using System.Collections;
-using System.Collections.Specialized;
-using System.Text;
-using ICSharpCode.SharpRefactory.Parser.AST.VB;
-using ICSharpCode.SharpRefactory.Parser.VB;
+
+#line  1 &quot;VBNET.ATG&quot; 
+using System.Drawing;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser.AST.VB;
+using ICSharpCode.SharpRefactory.Parser.VB;
 using System;
 using System.Reflection;
 
@@ -15,7 +15,7 @@
 
 public class Parser
 {
-	const int maxT = 188;
+	const int maxT = 188;
 
 	const  bool   T            = true;
 	const  bool   x            = false;
@@ -31,228 +31,228 @@
 		}
 	}
 
+
+#line  10 &quot;VBNET.ATG&quot; 
+private string assemblyName = null;
+public CompilationUnit compilationUnit;
+private ArrayList importedNamespaces = null;
+private Stack withStatements;
+private bool isLabel = false;
+private LabelStatement labelStatement = null;
+
+public string ContainingAssembly
+{
+	set { assemblyName = value; }
+}
+
+Token t
+{
+	get {
+		return lexer.Token;
+	}
+}
+Token la
+{
+	get {
+		return lexer.LookAhead;
+	}
+}
+
+void updateLabelStatement(Statement stmt)
+{
+	if(isLabel) {
+		labelStatement.EmbeddedStatement = stmt;
+		isLabel = false;
+	} else {
+		compilationUnit.AddChild(stmt);
+	}
+}
+
+/* Return the n-th token after the current lookahead token */
+void StartPeek()
+{
+	lexer.StartPeek();
+}
+
+Token Peek()
+{
+	return lexer.Peek();
+}
+
+Token Peek (int n)
+{
+	lexer.StartPeek();
+	Token x = la;
+	while (n &gt; 0) {
+		x = lexer.Peek();
+		n--;
+	}
+	return x;
+}
+
+public void Error(string s)
+{
+	if (errDist &gt;= minErrDist) {
+		errors.Error(la.line, la.col, s);
+	}
+	errDist = 0;
+}
+
+public Expression ParseExpression(Lexer lexer)
+{
+	this.errors = lexer.Errors;
+	this.lexer = lexer;
+	errors.SynErr = new ErrorCodeProc(SynErr);
+	lexer.NextToken();
+	Expression expr;
+	Expr(out expr);
+	return expr;
+}
+
+bool IsEndStmtAhead()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.End &amp;&amp; (peek == Tokens.EOL || peek == Tokens.Colon);
+}
+
+bool IsNotClosingParenthesis() {
+	return la.kind != Tokens.CloseParenthesis;
+}
+
+/*
+	True, if ident is followed by &quot;=&quot;
+*/
+bool IdentAndAsgn () {
+	if(la.kind == Tokens.Identifier) {
+		if(Peek(1).kind == Tokens.Assign) return true;
+		if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
+	}
+	return false;
+}
+
+/*
+	True, if ident is followed by &quot;=&quot; or by &quot;:&quot; and &quot;=&quot;
+*/
+bool IsNamedAssign() {
+//	if(Peek(1).kind == Tokens.Assign) return true; // removed: not in the lang spec
+	if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
+	return false;
+}
+
+bool IsObjectCreation() {
+	return la.kind == Tokens.As &amp;&amp; Peek(1).kind == Tokens.New;
+}
+
+/*
+	True, if &quot;&lt;&quot; is followed by the ident &quot;assembly&quot; or &quot;module&quot;
+*/
+bool IsGlobalAttrTarget () {
+	Token pt = Peek(1);
+	return la.kind == Tokens.LessThan &amp;&amp; ( pt.val.ToLower() == &quot;assembly&quot; || pt.val.ToLower() == &quot;module&quot;);
+}
+
+/*
+	True if the next token is a &quot;(&quot; and is followed by &quot;,&quot; or &quot;)&quot;
+*/
+bool IsRank()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.OpenParenthesis
+						&amp;&amp; (peek == Tokens.Comma || peek == Tokens.CloseParenthesis);
+}
+
+bool IsDims()
+{
+	int peek = Peek(1).kind;
+	int peek_n = Peek(2).kind;
+	return la.kind == Tokens.OpenParenthesis
+						&amp;&amp; (peek == Tokens.LiteralInteger &amp;&amp; peek_n == Tokens.CloseParenthesis);
+}
+
+bool IsSize()
+{
+	return la.kind == Tokens.OpenParenthesis;
+}
+
+/*
+	True, if the comma is not a trailing one,
+	like the last one in: a, b, c,
+*/
+bool NotFinalComma() {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Comma &amp;&amp;
+		   peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
+}
+
+/*
+	True, if the next token is &quot;Else&quot; and this one
+	if followed by &quot;If&quot;
+*/
+bool IsElseIf()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Else &amp;&amp; peek == Tokens.If;
+}
+
+/*
+	True if the next token is goto and this one is
+	followed by minus (&quot;-&quot;) (this is allowd in in
+	error clauses)
+*/
+bool IsNegativeLabelName()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.GoTo &amp;&amp; peek == Tokens.Minus;
+}
+
+/*
+	True if the next statement is a &quot;Resume next&quot; statement
+*/
+bool IsResumeNext()
+{
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Resume &amp;&amp; peek == Tokens.Next;
+}
+
+/*
+	True, if ident/literal integer is followed by &quot;:&quot;
+*/
+bool IsLabel()
+{
+	return (la.kind == Tokens.Identifier || la.kind == Tokens.LiteralInteger)
+			&amp;&amp; Peek(1).kind == Tokens.Colon;
+}
+
+bool IsNotStatementSeparator()
+{
+	return la.kind == Tokens.Colon &amp;&amp; Peek(1).kind == Tokens.EOL;
+}
+
+bool IsAssignment ()
+{
+	return IdentAndAsgn();
+}
+
+bool IsMustOverride(Modifiers m)
+{
+	return m.Contains(Modifier.MustOverride);
+}
+
+/*
+	True, if lookahead is a local attribute target specifier,
+	i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,
+	&quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;
+*/
+bool IsLocalAttrTarget() {
+	// TODO
+	return false;
+}
+
 
-#line  10 &quot;VBNET.ATG&quot; 
-private string assemblyName = null;
-public CompilationUnit compilationUnit;
-private ArrayList importedNamespaces = null;
-private Stack withStatements;
-private bool isLabel = false;
-private LabelStatement labelStatement = null;
 
-public string ContainingAssembly
-{
-	set { assemblyName = value; }
-}
-
-Token t
-{
-	get {
-		return lexer.Token;
-	}
-}
-Token la
-{
-	get {
-		return lexer.LookAhead;
-	}
-}
-
-void updateLabelStatement(Statement stmt)
-{
-	if(isLabel) {
-		labelStatement.EmbeddedStatement = stmt;
-		isLabel = false;
-	} else {
-		compilationUnit.AddChild(stmt);
-	}
-}
-
-/* Return the n-th token after the current lookahead token */
-void StartPeek()
-{
-	lexer.StartPeek();
-}
-
-Token Peek()
-{
-	return lexer.Peek();
-}
-
-Token Peek (int n)
-{
-	lexer.StartPeek();
-	Token x = la;
-	while (n &gt; 0) {
-		x = lexer.Peek();
-		n--;
-	}
-	return x;
-}
-
-public void Error(string s)
-{
-	if (errDist &gt;= minErrDist) {
-		errors.Error(la.line, la.col, s);
-	}
-	errDist = 0;
-}
-
-public Expression ParseExpression(Lexer lexer)
-{
-	this.errors = lexer.Errors;
-	this.lexer = lexer;
-	errors.SynErr = new ErrorCodeProc(SynErr);
-	lexer.NextToken();
-	Expression expr;
-	Expr(out expr);
-	return expr;
-}
-
-bool IsEndStmtAhead()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.End &amp;&amp; (peek == Tokens.EOL || peek == Tokens.Colon);
-}
-
-bool IsNotClosingParenthesis() {
-	return la.kind != Tokens.CloseParenthesis;
-}
-
 /*
-	True, if ident is followed by &quot;=&quot;
-*/
-bool IdentAndAsgn () {
-	if(la.kind == Tokens.Identifier) {
-		if(Peek(1).kind == Tokens.Assign) return true;
-		if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
-	}
-	return false;
-}
 
-/*
-	True, if ident is followed by &quot;=&quot; or by &quot;:&quot; and &quot;=&quot;
 */
-bool IsNamedAssign() {
-//	if(Peek(1).kind == Tokens.Assign) return true; // removed: not in the lang spec
-	if(Peek(1).kind == Tokens.Colon &amp;&amp; Peek(2).kind == Tokens.Assign) return true;
-	return false;
-}
-
-bool IsObjectCreation() {
-	return la.kind == Tokens.As &amp;&amp; Peek(1).kind == Tokens.New;
-}
-
-/*
-	True, if &quot;&lt;&quot; is followed by the ident &quot;assembly&quot; or &quot;module&quot;
-*/
-bool IsGlobalAttrTarget () {
-	Token pt = Peek(1);
-	return la.kind == Tokens.LessThan &amp;&amp; ( pt.val.ToLower() == &quot;assembly&quot; || pt.val.ToLower() == &quot;module&quot;);
-}
-
-/*
-	True if the next token is a &quot;(&quot; and is followed by &quot;,&quot; or &quot;)&quot;
-*/
-bool IsRank()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.OpenParenthesis
-						&amp;&amp; (peek == Tokens.Comma || peek == Tokens.CloseParenthesis);
-}
-
-bool IsDims()
-{
-	int peek = Peek(1).kind;
-	int peek_n = Peek(2).kind;
-	return la.kind == Tokens.OpenParenthesis
-						&amp;&amp; (peek == Tokens.LiteralInteger &amp;&amp; peek_n == Tokens.CloseParenthesis);
-}
-
-bool IsSize()
-{
-	return la.kind == Tokens.OpenParenthesis;
-}
-
-/*
-	True, if the comma is not a trailing one,
-	like the last one in: a, b, c,
-*/
-bool NotFinalComma() {
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.Comma &amp;&amp;
-		   peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
-}
-
-/*
-	True, if the next token is &quot;Else&quot; and this one
-	if followed by &quot;If&quot;
-*/
-bool IsElseIf()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.Else &amp;&amp; peek == Tokens.If;
-}
-
-/*
-	True if the next token is goto and this one is
-	followed by minus (&quot;-&quot;) (this is allowd in in
-	error clauses)
-*/
-bool IsNegativeLabelName()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.GoTo &amp;&amp; peek == Tokens.Minus;
-}
-
-/*
-	True if the next statement is a &quot;Resume next&quot; statement
-*/
-bool IsResumeNext()
-{
-	int peek = Peek(1).kind;
-	return la.kind == Tokens.Resume &amp;&amp; peek == Tokens.Next;
-}
-
-/*
-	True, if ident/literal integer is followed by &quot;:&quot;
-*/
-bool IsLabel()
-{
-	return (la.kind == Tokens.Identifier || la.kind == Tokens.LiteralInteger)
-			&amp;&amp; Peek(1).kind == Tokens.Colon;
-}
-
-bool IsNotStatementSeparator()
-{
-	return la.kind == Tokens.Colon &amp;&amp; Peek(1).kind == Tokens.EOL;
-}
-
-bool IsAssignment ()
-{
-	return IdentAndAsgn();
-}
-
-bool IsMustOverride(Modifiers m)
-{
-	return m.Contains(Modifier.MustOverride);
-}
-
-/*
-	True, if lookahead is a local attribute target specifier,
-	i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,
-	&quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;
-*/
-bool IsLocalAttrTarget() {
-	// TODO
-	return false;
-}
-
-
-
-/*
-
-*/
 	void SynErr(int n)
 	{
 		if (errDist &gt;= minErrDist) {
@@ -316,5967 +316,5967 @@
 		}
 	}
 	
-	void VBNET() {
+	void VBNET() {
+
+#line  431 &quot;VBNET.ATG&quot; 
+		compilationUnit = new CompilationUnit();
+		withStatements = new Stack();
+		
+		while (la.kind == 1) {
+			lexer.NextToken();
+		}
+		while (la.kind == 137) {
+			OptionStmt();
+		}
+		while (la.kind == 109) {
+			ImportsStmt();
+		}
+		while (
+#line  437 &quot;VBNET.ATG&quot; 
+IsGlobalAttrTarget()) {
+			GlobalAttributeSection();
+		}
+		while (StartOf(1)) {
+			NamespaceMemberDecl();
+		}
+		Expect(0);
+	}
+
+	void OptionStmt() {
+
+#line  442 &quot;VBNET.ATG&quot; 
+		INode node = null; bool val = true; 
+		Expect(137);
+
+#line  443 &quot;VBNET.ATG&quot; 
+		Point startPos = t.Location; 
+		if (la.kind == 96) {
+			lexer.NextToken();
+			if (la.kind == 135 || la.kind == 136) {
+				OptionValue(
+#line  445 &quot;VBNET.ATG&quot; 
+ref val);
+			}
+
+#line  446 &quot;VBNET.ATG&quot; 
+			node = new OptionExplicitDeclaration(val); 
+		} else if (la.kind == 166) {
+			lexer.NextToken();
+			if (la.kind == 135 || la.kind == 136) {
+				OptionValue(
+#line  448 &quot;VBNET.ATG&quot; 
+ref val);
+			}
+
+#line  449 &quot;VBNET.ATG&quot; 
+			node = new OptionStrictDeclaration(val); 
+		} else if (la.kind == 71) {
+			lexer.NextToken();
+			if (la.kind == 52) {
+				lexer.NextToken();
+
+#line  451 &quot;VBNET.ATG&quot; 
+				node = new OptionCompareDeclaration(CompareType.Binary); 
+			} else if (la.kind == 171) {
+				lexer.NextToken();
+
+#line  452 &quot;VBNET.ATG&quot; 
+				node = new OptionCompareDeclaration(CompareType.Text); 
+			} else SynErr(189);
+		} else SynErr(190);
+		EndOfStmt();
+
+#line  457 &quot;VBNET.ATG&quot; 
+		node.StartLocation = startPos;
+		node.EndLocation   = t.Location;
+		compilationUnit.AddChild(node);
+		
+	}
+
+	void ImportsStmt() {
+
+#line  481 &quot;VBNET.ATG&quot; 
+		ArrayList importClauses = new ArrayList();
+		importedNamespaces = new ArrayList();
+		object importClause;
+		
+		Expect(109);
+
+#line  487 &quot;VBNET.ATG&quot; 
+		Point startPos = t.Location;
+		ImportsStatement importsStatement = new ImportsStatement(null);
+		
+		ImportClause(
+#line  490 &quot;VBNET.ATG&quot; 
+out importClause);
+
+#line  490 &quot;VBNET.ATG&quot; 
+		importClauses.Add(importClause); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			ImportClause(
+#line  492 &quot;VBNET.ATG&quot; 
+out importClause);
+
+#line  492 &quot;VBNET.ATG&quot; 
+			importClauses.Add(importClause); 
+		}
+		EndOfStmt();
+
+#line  496 &quot;VBNET.ATG&quot; 
+		importsStatement.ImportClauses = importClauses;
+		importsStatement.StartLocation = startPos;
+		importsStatement.EndLocation   = t.Location;
+		compilationUnit.AddChild(importsStatement);
+		
+	}
+
+	void GlobalAttributeSection() {
+
+#line  1840 &quot;VBNET.ATG&quot; 
+		Point startPos = t.Location; 
+		Expect(28);
+		if (la.kind == 50) {
+			lexer.NextToken();
+		} else if (la.kind == 122) {
+			lexer.NextToken();
+		} else SynErr(191);
+
+#line  1843 &quot;VBNET.ATG&quot; 
+		string attributeTarget = t.val.ToLower();
+		ArrayList attributes = new ArrayList();
+		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
+		
+		Expect(13);
+		Attribute(
+#line  1847 &quot;VBNET.ATG&quot; 
+out attribute);
+
+#line  1847 &quot;VBNET.ATG&quot; 
+		attributes.Add(attribute); 
+		while (
+#line  1848 &quot;VBNET.ATG&quot; 
+NotFinalComma()) {
+			Expect(12);
+			Attribute(
+#line  1848 &quot;VBNET.ATG&quot; 
+out attribute);
+
+#line  1848 &quot;VBNET.ATG&quot; 
+			attributes.Add(attribute); 
+		}
+		if (la.kind == 12) {
+			lexer.NextToken();
+		}
+		Expect(27);
+		EndOfStmt();
+
+#line  1853 &quot;VBNET.ATG&quot; 
+		AttributeSection section = new AttributeSection(attributeTarget, attributes);
+		section.StartLocation = startPos;
+		section.EndLocation = t.EndLocation;
+		compilationUnit.AddChild(section);
+		
+	}
+
+	void NamespaceMemberDecl() {
+
+#line  526 &quot;VBNET.ATG&quot; 
+		Modifiers m = new Modifiers(this);
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		string qualident;
+		
+		if (la.kind == 127) {
+			lexer.NextToken();
+
+#line  533 &quot;VBNET.ATG&quot; 
+			Point startPos = t.Location;
+			
+			Qualident(
+#line  535 &quot;VBNET.ATG&quot; 
+out qualident);
+
+#line  537 &quot;VBNET.ATG&quot; 
+			INode node =  new NamespaceDeclaration(qualident);
+			node.StartLocation = startPos;
+			compilationUnit.AddChild(node);
+			compilationUnit.BlockStart(node);
+			
+			Expect(1);
+			NamespaceBody();
+
+#line  545 &quot;VBNET.ATG&quot; 
+			node.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+		} else if (StartOf(2)) {
+			while (la.kind == 28) {
+				AttributeSection(
+#line  549 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  549 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(3)) {
+				TypeModifier(
+#line  550 &quot;VBNET.ATG&quot; 
+m);
+			}
+			NonModuleDeclaration(
+#line  550 &quot;VBNET.ATG&quot; 
+m, attributes);
+		} else SynErr(192);
+	}
+
+	void OptionValue(
+#line  463 &quot;VBNET.ATG&quot; 
+ref bool val) {
+		if (la.kind == 136) {
+			lexer.NextToken();
+
+#line  465 &quot;VBNET.ATG&quot; 
+			val = true; 
+		} else if (la.kind == 135) {
+			lexer.NextToken();
+
+#line  467 &quot;VBNET.ATG&quot; 
+			val = true; 
+		} else SynErr(193);
+	}
+
+	void EndOfStmt() {
+		if (la.kind == 1) {
+			lexer.NextToken();
+		} else if (la.kind == 13) {
+			lexer.NextToken();
+		} else SynErr(194);
+	}
+
+	void ImportClause(
+#line  503 &quot;VBNET.ATG&quot; 
+out object importClause) {
+
+#line  505 &quot;VBNET.ATG&quot; 
+		string qualident = null;
+		string aliasident = null;
+		importClause = null;
+		
+		if (
+#line  509 &quot;VBNET.ATG&quot; 
+IsAssignment()) {
+			Identifier();
+
+#line  509 &quot;VBNET.ATG&quot; 
+			aliasident = t.val;  
+			Expect(11);
+		}
+		Qualident(
+#line  510 &quot;VBNET.ATG&quot; 
+out qualident);
+
+#line  512 &quot;VBNET.ATG&quot; 
+		if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
+		if (aliasident != null) {
+			importClause = new ImportsAliasDeclaration(aliasident, qualident);
+		} else {
+			importedNamespaces.Add(qualident);
+			importClause = new ImportsDeclaration(qualident);
+		}
+		}
+		
+	}
+
+	void Identifier() {
+		if (la.kind == 2) {
+			lexer.NextToken();
+		} else if (la.kind == 171) {
+			lexer.NextToken();
+		} else if (la.kind == 52) {
+			lexer.NextToken();
+		} else if (la.kind == 71) {
+			lexer.NextToken();
+		} else SynErr(195);
+	}
+
+	void Qualident(
+#line  2527 &quot;VBNET.ATG&quot; 
+out string qualident) {
+
+#line  2528 &quot;VBNET.ATG&quot; 
+		string name = String.Empty; 
+		Identifier();
+
+#line  2529 &quot;VBNET.ATG&quot; 
+		StringBuilder qualidentBuilder = new StringBuilder(t.val); 
+		while (la.kind == 10) {
+			lexer.NextToken();
+			IdentifierOrKeyword(
+#line  2531 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  2531 &quot;VBNET.ATG&quot; 
+			qualidentBuilder.Append('.');
+			  qualidentBuilder.Append(name); 
+			
+		}
+
+#line  2535 &quot;VBNET.ATG&quot; 
+		qualident = qualidentBuilder.ToString(); 
+	}
+
+	void NamespaceBody() {
+		while (StartOf(1)) {
+			NamespaceMemberDecl();
+		}
+		Expect(89);
+		Expect(127);
+		Expect(1);
+	}
+
+	void AttributeSection(
+#line  1911 &quot;VBNET.ATG&quot; 
+out AttributeSection section) {
+
+#line  1913 &quot;VBNET.ATG&quot; 
+		string attributeTarget = &quot;&quot;;
+		ArrayList attributes = new ArrayList();
+		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
+		
+		
+		Expect(28);
+
+#line  1918 &quot;VBNET.ATG&quot; 
+		Point startPos = t.Location; 
+		if (
+#line  1919 &quot;VBNET.ATG&quot; 
+IsLocalAttrTarget()) {
+			if (la.kind == 94) {
+				lexer.NextToken();
+
+#line  1920 &quot;VBNET.ATG&quot; 
+				attributeTarget = &quot;event&quot;;
+			} else if (la.kind == 156) {
+				lexer.NextToken();
+
+#line  1921 &quot;VBNET.ATG&quot; 
+				attributeTarget = &quot;return&quot;;
+			} else {
+				Identifier();
+
+#line  1924 &quot;VBNET.ATG&quot; 
+				string val = t.val.ToLower();
+				if (val != &quot;field&quot;	|| val != &quot;method&quot; ||
+					val != &quot;module&quot; || val != &quot;param&quot;  ||
+					val != &quot;property&quot; || val != &quot;type&quot;)
+				Error(&quot;attribute target specifier (event, return, field,&quot; +
+						&quot;method, module, param, property, or type) expected&quot;);
+				attributeTarget = t.val;
+				
+			}
+			Expect(13);
+		}
+		Attribute(
+#line  1934 &quot;VBNET.ATG&quot; 
+out attribute);
+
+#line  1934 &quot;VBNET.ATG&quot; 
+		attributes.Add(attribute); 
+		while (
+#line  1935 &quot;VBNET.ATG&quot; 
+NotFinalComma()) {
+			Expect(12);
+			Attribute(
+#line  1935 &quot;VBNET.ATG&quot; 
+out attribute);
+
+#line  1935 &quot;VBNET.ATG&quot; 
+			attributes.Add(attribute); 
+		}
+		if (la.kind == 12) {
+			lexer.NextToken();
+		}
+		Expect(27);
+
+#line  1939 &quot;VBNET.ATG&quot; 
+		section = new AttributeSection(attributeTarget, attributes);
+		section.StartLocation = startPos;
+		section.EndLocation = t.EndLocation;
+		
+	}
+
+	void TypeModifier(
+#line  2715 &quot;VBNET.ATG&quot; 
+Modifiers m) {
+		switch (la.kind) {
+		case 150: {
+			lexer.NextToken();
+
+#line  2716 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Public); 
+			break;
+		}
+		case 149: {
+			lexer.NextToken();
+
+#line  2717 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Protected); 
+			break;
+		}
+		case 100: {
+			lexer.NextToken();
+
+#line  2718 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Friend); 
+			break;
+		}
+		case 147: {
+			lexer.NextToken();
+
+#line  2719 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Private); 
+			break;
+		}
+		case 160: {
+			lexer.NextToken();
+
+#line  2720 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Shared); 
+			break;
+		}
+		case 159: {
+			lexer.NextToken();
+
+#line  2721 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Shadows); 
+			break;
+		}
+		case 123: {
+			lexer.NextToken();
+
+#line  2722 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.MustInherit); 
+			break;
+		}
+		case 132: {
+			lexer.NextToken();
+
+#line  2723 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.NotInheritable); 
+			break;
+		}
+		default: SynErr(196); break;
+		}
+	}
+
+	void NonModuleDeclaration(
+#line  554 &quot;VBNET.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+
+#line  556 &quot;VBNET.ATG&quot; 
+		string name = String.Empty;
+		ArrayList names = null;
+		
+		switch (la.kind) {
+		case 68: {
+
+#line  559 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Classes); 
+			lexer.NextToken();
+
+#line  562 &quot;VBNET.ATG&quot; 
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			newType.Type = Types.Class;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			
+			Identifier();
+
+#line  570 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
+			EndOfStmt();
+			if (la.kind == 111) {
+				ClassBaseType(
+#line  572 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  572 &quot;VBNET.ATG&quot; 
+				newType.BaseType = name; 
+			}
+			while (la.kind == 108) {
+				TypeImplementsClause(
+#line  573 &quot;VBNET.ATG&quot; 
+out names);
+
+#line  573 &quot;VBNET.ATG&quot; 
+				newType.BaseInterfaces = names; 
+			}
+			ClassBody(
+#line  574 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  576 &quot;VBNET.ATG&quot; 
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 122: {
+			lexer.NextToken();
+
+#line  580 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Modules);
+			TypeDeclaration newType = new TypeDeclaration();
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.StartLocation = t.Location;
+			newType.Type = Types.Module;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			
+			Identifier();
+
+#line  590 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation;  
+			Expect(1);
+			ModuleBody(
+#line  592 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  594 &quot;VBNET.ATG&quot; 
+			newType.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 168: {
+			lexer.NextToken();
+
+#line  599 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Structures);
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			newType.StartLocation = t.Location;
+			newType.Type = Types.Structure;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			ArrayList baseInterfaces = new ArrayList();
+			
+			Identifier();
+
+#line  610 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
+			Expect(1);
+			while (la.kind == 108) {
+				TypeImplementsClause(
+#line  611 &quot;VBNET.ATG&quot; 
+out baseInterfaces);
+			}
+			StructureBody(
+#line  612 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  614 &quot;VBNET.ATG&quot; 
+			newType.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 91: {
+			lexer.NextToken();
+
+#line  620 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Enums);
+			TypeDeclaration newType = new TypeDeclaration();
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			
+			newType.Type = Types.Enum;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			
+			Identifier();
+
+#line  631 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
+			if (la.kind == 49) {
+				lexer.NextToken();
+				PrimitiveTypeName(
+#line  632 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  632 &quot;VBNET.ATG&quot; 
+				newType.BaseType = name; 
+			}
+			Expect(1);
+			EnumBody(
+#line  634 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  636 &quot;VBNET.ATG&quot; 
+			newType.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 113: {
+			lexer.NextToken();
+
+#line  642 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Interfaces);
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			
+			newType.Type = Types.Interface;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			ArrayList baseInterfaces = new ArrayList();
+			
+			Identifier();
+
+#line  653 &quot;VBNET.ATG&quot; 
+			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
+			EndOfStmt();
+			while (la.kind == 111) {
+				InterfaceBase(
+#line  654 &quot;VBNET.ATG&quot; 
+out baseInterfaces);
+
+#line  654 &quot;VBNET.ATG&quot; 
+				newType.BaseInterfaces = baseInterfaces; 
+			}
+			InterfaceBody(
+#line  655 &quot;VBNET.ATG&quot; 
+newType);
+
+#line  657 &quot;VBNET.ATG&quot; 
+			newType.EndLocation = t.Location;
+			compilationUnit.BlockEnd();
+			
+			break;
+		}
+		case 81: {
+			lexer.NextToken();
+
+#line  663 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Delegates);
+			DelegateDeclaration delegateDeclr = new DelegateDeclaration();
+			ArrayList p = null;
+			TypeReference type = null;
+			delegateDeclr.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			delegateDeclr.StartLocation = t.Location;
+			delegateDeclr.Modifier = m.Modifier;
+			delegateDeclr.Attributes = attributes;
+			
+			if (la.kind == 169) {
+				lexer.NextToken();
+				Identifier();
+
+#line  673 &quot;VBNET.ATG&quot; 
+				delegateDeclr.Name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  674 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+
+#line  674 &quot;VBNET.ATG&quot; 
+					delegateDeclr.Parameters = p; 
+				}
+			} else if (la.kind == 101) {
+				lexer.NextToken();
+				Identifier();
+
+#line  676 &quot;VBNET.ATG&quot; 
+				delegateDeclr.Name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  677 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+
+#line  677 &quot;VBNET.ATG&quot; 
+					delegateDeclr.Parameters = p; 
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  678 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  678 &quot;VBNET.ATG&quot; 
+					delegateDeclr.ReturnType = type; 
+				}
+			} else SynErr(197);
+
+#line  680 &quot;VBNET.ATG&quot; 
+			delegateDeclr.EndLocation = t.EndLocation; 
+			Expect(1);
+
+#line  683 &quot;VBNET.ATG&quot; 
+			compilationUnit.AddChild(delegateDeclr);
+			
+			break;
+		}
+		default: SynErr(198); break;
+		}
+	}
+
+	void ClassBaseType(
+#line  873 &quot;VBNET.ATG&quot; 
+out string name) {
+
+#line  875 &quot;VBNET.ATG&quot; 
+		TypeReference type;
+		name = String.Empty;
+		
+		Expect(111);
+		TypeName(
+#line  879 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  879 &quot;VBNET.ATG&quot; 
+		name = type.Type; 
+		EndOfStmt();
+	}
+
+	void TypeImplementsClause(
+#line  1408 &quot;VBNET.ATG&quot; 
+out ArrayList baseInterfaces) {
+
+#line  1410 &quot;VBNET.ATG&quot; 
+		baseInterfaces = new ArrayList();
+		TypeReference type = null;
+		
+		Expect(108);
+		TypeName(
+#line  1413 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1415 &quot;VBNET.ATG&quot; 
+		baseInterfaces.Add(type);
+		
+		while (la.kind == 12) {
+			lexer.NextToken();
+			TypeName(
+#line  1418 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1419 &quot;VBNET.ATG&quot; 
+			baseInterfaces.Add(type); 
+		}
+		EndOfStmt();
+	}
+
+	void ClassBody(
+#line  693 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+
+#line  694 &quot;VBNET.ATG&quot; 
+		AttributeSection section; 
+		while (StartOf(5)) {
+
+#line  697 &quot;VBNET.ATG&quot; 
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+			
+			while (la.kind == 28) {
+				AttributeSection(
+#line  700 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  700 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(6)) {
+				MemberModifier(
+#line  701 &quot;VBNET.ATG&quot; 
+m);
+			}
+			ClassMemberDecl(
+#line  702 &quot;VBNET.ATG&quot; 
+m, attributes);
+		}
+		Expect(89);
+		Expect(68);
+
+#line  704 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void ModuleBody(
+#line  724 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+
+#line  725 &quot;VBNET.ATG&quot; 
+		AttributeSection section; 
+		while (StartOf(5)) {
+
+#line  728 &quot;VBNET.ATG&quot; 
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+			
+			while (la.kind == 28) {
+				AttributeSection(
+#line  731 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  731 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(6)) {
+				MemberModifier(
+#line  732 &quot;VBNET.ATG&quot; 
+m);
+			}
+			ClassMemberDecl(
+#line  733 &quot;VBNET.ATG&quot; 
+m, attributes);
+		}
+		Expect(89);
+		Expect(122);
+
+#line  735 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void StructureBody(
+#line  708 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+
+#line  709 &quot;VBNET.ATG&quot; 
+		AttributeSection section; 
+		while (StartOf(5)) {
+
+#line  712 &quot;VBNET.ATG&quot; 
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+			
+			while (la.kind == 28) {
+				AttributeSection(
+#line  715 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  715 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(6)) {
+				MemberModifier(
+#line  716 &quot;VBNET.ATG&quot; 
+m);
+			}
+			StructureMemberDecl(
+#line  717 &quot;VBNET.ATG&quot; 
+m, attributes);
+		}
+		Expect(89);
+		Expect(168);
+
+#line  719 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void PrimitiveTypeName(
+#line  2693 &quot;VBNET.ATG&quot; 
+out string type) {
+
+#line  2694 &quot;VBNET.ATG&quot; 
+		type = String.Empty; 
+		switch (la.kind) {
+		case 53: {
+			lexer.NextToken();
+
+#line  2695 &quot;VBNET.ATG&quot; 
+			type = &quot;Boolean&quot;; 
+			break;
+		}
+		case 77: {
+			lexer.NextToken();
+
+#line  2696 &quot;VBNET.ATG&quot; 
+			type = &quot;Date&quot;; 
+			break;
+		}
+		case 66: {
+			lexer.NextToken();
+
+#line  2697 &quot;VBNET.ATG&quot; 
+			type = &quot;Char&quot;; 
+			break;
+		}
+		case 167: {
+			lexer.NextToken();
+
+#line  2698 &quot;VBNET.ATG&quot; 
+			type = &quot;String&quot;; 
+			break;
+		}
+		case 78: {
+			lexer.NextToken();
+
+#line  2699 &quot;VBNET.ATG&quot; 
+			type = &quot;Decimal&quot;; 
+			break;
+		}
+		case 55: {
+			lexer.NextToken();
+
+#line  2700 &quot;VBNET.ATG&quot; 
+			type = &quot;Byte&quot;; 
+			break;
+		}
+		case 161: {
+			lexer.NextToken();
+
+#line  2701 &quot;VBNET.ATG&quot; 
+			type = &quot;Short&quot;; 
+			break;
+		}
+		case 112: {
+			lexer.NextToken();
+
+#line  2702 &quot;VBNET.ATG&quot; 
+			type = &quot;Integer&quot;; 
+			break;
+		}
+		case 118: {
+			lexer.NextToken();
+
+#line  2703 &quot;VBNET.ATG&quot; 
+			type = &quot;Long&quot;; 
+			break;
+		}
+		case 162: {
+			lexer.NextToken();
+
+#line  2704 &quot;VBNET.ATG&quot; 
+			type = &quot;Single&quot;; 
+			break;
+		}
+		case 85: {
+			lexer.NextToken();
+
+#line  2705 &quot;VBNET.ATG&quot; 
+			type = &quot;Double&quot;; 
+			break;
+		}
+		default: SynErr(199); break;
+		}
+	}
+
+	void EnumBody(
+#line  739 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+
+#line  740 &quot;VBNET.ATG&quot; 
+		FieldDeclaration f; 
+		while (StartOf(7)) {
+			EnumMemberDecl(
+#line  742 &quot;VBNET.ATG&quot; 
+out f);
+
+#line  742 &quot;VBNET.ATG&quot; 
+			compilationUnit.AddChild(f); 
+		}
+		Expect(89);
+		Expect(91);
+
+#line  744 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void InterfaceBase(
+#line  1393 &quot;VBNET.ATG&quot; 
+out ArrayList bases) {
+
+#line  1395 &quot;VBNET.ATG&quot; 
+		TypeReference type;
+		bases = new ArrayList();
+		
+		Expect(111);
+		TypeName(
+#line  1399 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1399 &quot;VBNET.ATG&quot; 
+		bases.Add(type); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			TypeName(
+#line  1402 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1402 &quot;VBNET.ATG&quot; 
+			bases.Add(type); 
+		}
+		Expect(1);
+	}
+
+	void InterfaceBody(
+#line  748 &quot;VBNET.ATG&quot; 
+TypeDeclaration newType) {
+		while (StartOf(8)) {
+			InterfaceMemberDecl();
+		}
+		Expect(89);
+		Expect(113);
+
+#line  750 &quot;VBNET.ATG&quot; 
+		newType.EndLocation = t.EndLocation; 
+		Expect(1);
+	}
+
+	void FormalParameterList(
+#line  1946 &quot;VBNET.ATG&quot; 
+out ArrayList parameter) {
+
+#line  1948 &quot;VBNET.ATG&quot; 
+		parameter = new ArrayList();
+		ParameterDeclarationExpression p;
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		
+		while (la.kind == 28) {
+			AttributeSection(
+#line  1953 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1953 &quot;VBNET.ATG&quot; 
+			attributes.Add(section); 
+		}
+		FormalParameter(
+#line  1955 &quot;VBNET.ATG&quot; 
+out p);
+
+#line  1957 &quot;VBNET.ATG&quot; 
+		bool paramsFound = false;
+		p.Attributes = attributes;
+		parameter.Add(p);
+		
+		while (la.kind == 12) {
+			lexer.NextToken();
+
+#line  1962 &quot;VBNET.ATG&quot; 
+			attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); 
+			while (la.kind == 28) {
+				AttributeSection(
+#line  1963 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1963 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			FormalParameter(
+#line  1965 &quot;VBNET.ATG&quot; 
+out p);
+
+#line  1965 &quot;VBNET.ATG&quot; 
+			p.Attributes = attributes; parameter.Add(p); 
+		}
+	}
+
+	void TypeName(
+#line  1758 &quot;VBNET.ATG&quot; 
+out TypeReference typeref) {
+
+#line  1760 &quot;VBNET.ATG&quot; 
+		ArrayList rank = null;
+		
+		NonArrayTypeName(
+#line  1762 &quot;VBNET.ATG&quot; 
+out typeref);
+		ArrayTypeModifiers(
+#line  1763 &quot;VBNET.ATG&quot; 
+out rank);
+
+#line  1765 &quot;VBNET.ATG&quot; 
+		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
+		
+	}
+
+	void MemberModifier(
+#line  2726 &quot;VBNET.ATG&quot; 
+Modifiers m) {
+		switch (la.kind) {
+		case 123: {
+			lexer.NextToken();
+
+#line  2727 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.MustInherit);
+			break;
+		}
+		case 80: {
+			lexer.NextToken();
+
+#line  2728 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Default);
+			break;
+		}
+		case 100: {
+			lexer.NextToken();
+
+#line  2729 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Friend);
+			break;
+		}
+		case 159: {
+			lexer.NextToken();
+
+#line  2730 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Shadows);
+			break;
+		}
+		case 144: {
+			lexer.NextToken();
+
+#line  2731 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Overrides);
+			break;
+		}
+		case 124: {
+			lexer.NextToken();
+
+#line  2732 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.MustOverride);
+			break;
+		}
+		case 147: {
+			lexer.NextToken();
+
+#line  2733 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Private);
+			break;
+		}
+		case 149: {
+			lexer.NextToken();
+
+#line  2734 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Protected);
+			break;
+		}
+		case 150: {
+			lexer.NextToken();
+
+#line  2735 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Public);
+			break;
+		}
+		case 132: {
+			lexer.NextToken();
+
+#line  2736 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.NotInheritable);
+			break;
+		}
+		case 133: {
+			lexer.NextToken();
+
+#line  2737 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.NotOverridable);
+			break;
+		}
+		case 160: {
+			lexer.NextToken();
+
+#line  2738 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Shared);
+			break;
+		}
+		case 142: {
+			lexer.NextToken();
+
+#line  2739 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Overridable);
+			break;
+		}
+		case 141: {
+			lexer.NextToken();
+
+#line  2740 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Overloads);
+			break;
+		}
+		case 152: {
+			lexer.NextToken();
+
+#line  2741 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.ReadOnly);
+			break;
+		}
+		case 186: {
+			lexer.NextToken();
+
+#line  2742 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.WriteOnly);
+			break;
+		}
+		case 185: {
+			lexer.NextToken();
+
+#line  2743 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.WithEvents);
+			break;
+		}
+		case 82: {
+			lexer.NextToken();
+
+#line  2744 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Dim);
+			break;
+		}
+		default: SynErr(200); break;
+		}
+	}
+
+	void ClassMemberDecl(
+#line  869 &quot;VBNET.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+		StructureMemberDecl(
+#line  870 &quot;VBNET.ATG&quot; 
+m, attributes);
+	}
+
+	void StructureMemberDecl(
+#line  884 &quot;VBNET.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+
+#line  886 &quot;VBNET.ATG&quot; 
+		TypeReference type = null;
+		ArrayList p = null;
+		Statement stmt = null;
+		ArrayList variableDeclarators = new ArrayList();
+		
+		switch (la.kind) {
+		case 68: case 81: case 91: case 113: case 122: case 168: {
+			NonModuleDeclaration(
+#line  891 &quot;VBNET.ATG&quot; 
+m, attributes);
+			break;
+		}
+		case 169: {
+			lexer.NextToken();
+
+#line  895 &quot;VBNET.ATG&quot; 
+			Point startPos = t.Location;
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+			
+			if (StartOf(9)) {
+
+#line  900 &quot;VBNET.ATG&quot; 
+				string name = String.Empty;
+				MethodDeclaration methodDeclaration;
+				HandlesClause handlesClause = null;
+				ImplementsClause implementsClause = null;
+				
+				Identifier();
+
+#line  907 &quot;VBNET.ATG&quot; 
+				name = t.val;
+				m.Check(Modifier.Methods);
+				
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  910 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 106 || la.kind == 108) {
+					if (la.kind == 108) {
+						ImplementsClause(
+#line  913 &quot;VBNET.ATG&quot; 
+out implementsClause);
+					} else {
+						HandlesClause(
+#line  915 &quot;VBNET.ATG&quot; 
+out handlesClause);
+					}
+				}
+
+#line  918 &quot;VBNET.ATG&quot; 
+				Point endLocation = t.EndLocation; 
+				Expect(1);
+				if (
+#line  922 &quot;VBNET.ATG&quot; 
+IsMustOverride(m)) {
+
+#line  924 &quot;VBNET.ATG&quot; 
+					methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
+					methodDeclaration.Specials[&quot;before&quot;] = comments;
+					methodDeclaration.StartLocation = startPos;
+					methodDeclaration.EndLocation   = endLocation;
+					
+					methodDeclaration.HandlesClause = handlesClause;
+					methodDeclaration.ImplementsClause = implementsClause;
+					
+					compilationUnit.AddChild(methodDeclaration);
+					
+				} else if (StartOf(10)) {
+
+#line  936 &quot;VBNET.ATG&quot; 
+					methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
+					methodDeclaration.Specials[&quot;before&quot;] = comments;
+					methodDeclaration.StartLocation = startPos;
+					methodDeclaration.EndLocation   = endLocation;
+					
+					methodDeclaration.HandlesClause = handlesClause;
+					methodDeclaration.ImplementsClause = implementsClause;
+					
+					compilationUnit.AddChild(methodDeclaration);
+					compilationUnit.BlockStart(methodDeclaration);
+					
+					Block(
+#line  947 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  949 &quot;VBNET.ATG&quot; 
+					compilationUnit.BlockEnd();
+					methodDeclaration.Body  = (BlockStatement)stmt;
+					
+					Expect(89);
+					Expect(169);
+
+#line  952 &quot;VBNET.ATG&quot; 
+					methodDeclaration.Body.EndLocation = t.EndLocation; 
+					Expect(1);
+				} else SynErr(201);
+			} else if (la.kind == 128) {
+				lexer.NextToken();
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  955 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+
+#line  956 &quot;VBNET.ATG&quot; 
+				m.Check(Modifier.Constructors); 
+
+#line  957 &quot;VBNET.ATG&quot; 
+				Point constructorEndLocation = t.EndLocation; 
+				Expect(1);
+				Block(
+#line  959 &quot;VBNET.ATG&quot; 
+out stmt);
+				Expect(89);
+				Expect(169);
+
+#line  960 &quot;VBNET.ATG&quot; 
+				Point endLocation = t.EndLocation; 
+				Expect(1);
+
+#line  962 &quot;VBNET.ATG&quot; 
+				ConstructorDeclaration cd = new ConstructorDeclaration(&quot;New&quot;, m.Modifier, p, attributes); 
+				cd.StartLocation = startPos;
+				cd.Specials[&quot;before&quot;] = comments;
+				cd.EndLocation   = constructorEndLocation;
+				cd.Body = (BlockStatement)stmt;
+				cd.Body.EndLocation   = endLocation;
+				compilationUnit.AddChild(cd);
+				
+			} else SynErr(202);
+			break;
+		}
+		case 101: {
+			lexer.NextToken();
+
+#line  975 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Methods);
+			string name = String.Empty;
+			Point startPos = t.Location;
+			MethodDeclaration methodDeclaration;
+			HandlesClause handlesClause = null;
+			ImplementsClause implementsClause = null;
+			AttributeSection attributeSection = null;
+			
+			Identifier();
+
+#line  983 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			if (la.kind == 25) {
+				lexer.NextToken();
+				if (StartOf(4)) {
+					FormalParameterList(
+#line  984 &quot;VBNET.ATG&quot; 
+out p);
+				}
+				Expect(26);
+			}
+			if (la.kind == 49) {
+				lexer.NextToken();
+				if (la.kind == 28) {
+					AttributeSection(
+#line  985 &quot;VBNET.ATG&quot; 
+out attributeSection);
+				}
+				TypeName(
+#line  985 &quot;VBNET.ATG&quot; 
+out type);
+			}
+
+#line  987 &quot;VBNET.ATG&quot; 
+			if(type == null) {
+			type = new TypeReference(&quot;System.Object&quot;);
+			}
+			type.Attributes = attributeSection;
+			
+			if (la.kind == 106 || la.kind == 108) {
+				if (la.kind == 108) {
+					ImplementsClause(
+#line  994 &quot;VBNET.ATG&quot; 
+out implementsClause);
+				} else {
+					HandlesClause(
+#line  996 &quot;VBNET.ATG&quot; 
+out handlesClause);
+				}
+			}
+			Expect(1);
+			if (
+#line  1002 &quot;VBNET.ATG&quot; 
+IsMustOverride(m)) {
+
+#line  1004 &quot;VBNET.ATG&quot; 
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = t.EndLocation;
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				compilationUnit.AddChild(methodDeclaration);
+				
+			} else if (StartOf(10)) {
+
+#line  1014 &quot;VBNET.ATG&quot; 
+				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
+				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				methodDeclaration.StartLocation = startPos;
+				methodDeclaration.EndLocation   = t.EndLocation;
+				
+				methodDeclaration.HandlesClause = handlesClause;
+				methodDeclaration.ImplementsClause = implementsClause;
+				
+				compilationUnit.AddChild(methodDeclaration);
+				compilationUnit.BlockStart(methodDeclaration);
+				
+				Block(
+#line  1025 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  1027 &quot;VBNET.ATG&quot; 
+				compilationUnit.BlockEnd();
+				methodDeclaration.Body  = (BlockStatement)stmt;
+				
+				Expect(89);
+				Expect(101);
+
+#line  1032 &quot;VBNET.ATG&quot; 
+				methodDeclaration.Body.StartLocation = methodDeclaration.EndLocation;
+				methodDeclaration.Body.EndLocation   = t.EndLocation;
+				
+				Expect(1);
+			} else SynErr(203);
+			break;
+		}
+		case 79: {
+			lexer.NextToken();
+
+#line  1041 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.ExternalMethods);
+			Point startPos = t.Location;
+			CharsetModifier charsetModifer = CharsetModifier.None;
+			string library = String.Empty;
+			string alias = null;
+			string name = String.Empty;
+			
+			if (StartOf(11)) {
+				Charset(
+#line  1048 &quot;VBNET.ATG&quot; 
+out charsetModifer);
+			}
+			if (la.kind == 169) {
+				lexer.NextToken();
+				Identifier();
+
+#line  1051 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				Expect(116);
+				Expect(3);
+
+#line  1052 &quot;VBNET.ATG&quot; 
+				library = t.val; 
+				if (la.kind == 45) {
+					lexer.NextToken();
+					Expect(3);
+
+#line  1053 &quot;VBNET.ATG&quot; 
+					alias = t.val; 
+				}
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  1054 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				Expect(1);
+
+#line  1057 &quot;VBNET.ATG&quot; 
+				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, null, p, attributes, library, alias, charsetModifer);
+				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				declareDeclaration.StartLocation = startPos;
+				declareDeclaration.EndLocation   = t.EndLocation;
+				compilationUnit.AddChild(declareDeclaration);
+				
+			} else if (la.kind == 101) {
+				lexer.NextToken();
+				Identifier();
+
+#line  1065 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				Expect(116);
+				Expect(3);
+
+#line  1066 &quot;VBNET.ATG&quot; 
+				library = t.val; 
+				if (la.kind == 45) {
+					lexer.NextToken();
+					Expect(3);
+
+#line  1067 &quot;VBNET.ATG&quot; 
+					alias = t.val; 
+				}
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  1068 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  1069 &quot;VBNET.ATG&quot; 
+out type);
+				}
+				Expect(1);
+
+#line  1072 &quot;VBNET.ATG&quot; 
+				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, type, p, attributes, library, alias, charsetModifer);
+				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				declareDeclaration.StartLocation = startPos;
+				declareDeclaration.EndLocation   = t.EndLocation;
+				compilationUnit.AddChild(declareDeclaration);
+				
+			} else SynErr(204);
+			break;
+		}
+		case 94: {
+			lexer.NextToken();
+
+#line  1083 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Events);
+			Point startPos = t.Location;
+			EventDeclaration eventDeclaration;
+			string name = String.Empty;
+			ImplementsClause implementsClause = null;
+			
+			Identifier();
+
+#line  1089 &quot;VBNET.ATG&quot; 
+			name= t.val; 
+			if (la.kind == 49) {
+				lexer.NextToken();
+				TypeName(
+#line  1091 &quot;VBNET.ATG&quot; 
+out type);
+			} else if (la.kind == 1 || la.kind == 25 || la.kind == 108) {
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  1093 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+			} else SynErr(205);
+			if (la.kind == 108) {
+				ImplementsClause(
+#line  1095 &quot;VBNET.ATG&quot; 
+out implementsClause);
+			}
+
+#line  1097 &quot;VBNET.ATG&quot; 
+			eventDeclaration = new EventDeclaration(type, m.Modifier, p, attributes, name, implementsClause);
+			eventDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+			eventDeclaration.StartLocation = startPos;
+			eventDeclaration.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(eventDeclaration);
+			
+			Expect(1);
+			break;
+		}
+		case 2: case 52: case 71: case 171: {
+
+#line  1105 &quot;VBNET.ATG&quot; 
+			Point startPos = t.Location; 
+
+#line  1107 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Fields);
+			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+			fd.StartLocation = startPos;
+			
+			VariableDeclarator(
+#line  1112 &quot;VBNET.ATG&quot; 
+variableDeclarators);
+
+#line  1114 &quot;VBNET.ATG&quot; 
+			((INode)variableDeclarators[0]).Specials[&quot;before&quot;] = comments;
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				VariableDeclarator(
+#line  1116 &quot;VBNET.ATG&quot; 
+variableDeclarators);
+			}
+			Expect(1);
+
+#line  1119 &quot;VBNET.ATG&quot; 
+			fd.EndLocation = t.EndLocation;
+			fd.Fields = variableDeclarators;
+			compilationUnit.AddChild(fd);
+			
+			break;
+		}
+		case 72: {
+
+#line  1124 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Fields); 
+			lexer.NextToken();
+
+#line  1125 &quot;VBNET.ATG&quot; 
+			m.Add(Modifier.Constant);  
+
+#line  1127 &quot;VBNET.ATG&quot; 
+			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+			fd.StartLocation = t.Location;
+			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+			ArrayList constantDeclarators = new ArrayList();
+			
+			ConstantDeclarator(
+#line  1132 &quot;VBNET.ATG&quot; 
+constantDeclarators);
+
+#line  1134 &quot;VBNET.ATG&quot; 
+			((INode)constantDeclarators[0]).Specials[&quot;before&quot;] = comments;
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				ConstantDeclarator(
+#line  1136 &quot;VBNET.ATG&quot; 
+constantDeclarators);
+			}
+
+#line  1138 &quot;VBNET.ATG&quot; 
+			fd.Fields = constantDeclarators;
+			fd.EndLocation = t.Location;
+			
+			Expect(1);
+
+#line  1143 &quot;VBNET.ATG&quot; 
+			fd.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(fd);
+			
+			break;
+		}
+		case 148: {
+			lexer.NextToken();
+
+#line  1149 &quot;VBNET.ATG&quot; 
+			m.Check(Modifier.Properties);
+			Point startPos = t.Location;
+			ImplementsClause implementsClause = null;
+			
+			Identifier();
+
+#line  1153 &quot;VBNET.ATG&quot; 
+			string propertyName = t.val; 
+			if (la.kind == 25) {
+				lexer.NextToken();
+				if (StartOf(4)) {
+					FormalParameterList(
+#line  1154 &quot;VBNET.ATG&quot; 
+out p);
+				}
+				Expect(26);
+			}
+			if (la.kind == 49) {
+				lexer.NextToken();
+				TypeName(
+#line  1155 &quot;VBNET.ATG&quot; 
+out type);
+			}
+
+#line  1157 &quot;VBNET.ATG&quot; 
+			if(type == null) {
+			type = new TypeReference(&quot;System.Object&quot;);
+			}
+			
+			if (la.kind == 108) {
+				ImplementsClause(
+#line  1161 &quot;VBNET.ATG&quot; 
+out implementsClause);
+			}
+			Expect(1);
+			if (
+#line  1165 &quot;VBNET.ATG&quot; 
+IsMustOverride(m)) {
+
+#line  1167 &quot;VBNET.ATG&quot; 
+				PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
+				pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				pDecl.StartLocation = startPos;
+				pDecl.EndLocation   = t.Location;
+				pDecl.TypeReference = type;
+				pDecl.ImplementsClause = implementsClause;
+				pDecl.Parameters = p;
+				compilationUnit.AddChild(pDecl);
+				
+			} else if (la.kind == 28 || la.kind == 102 || la.kind == 158) {
+
+#line  1178 &quot;VBNET.ATG&quot; 
+				PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
+				pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				pDecl.StartLocation = startPos;
+				pDecl.EndLocation   = t.Location;
+				pDecl.BodyStart   = t.Location;
+				pDecl.TypeReference = type;
+				pDecl.ImplementsClause = implementsClause;
+				pDecl.Parameters = p;
+				PropertyGetRegion getRegion;
+				PropertySetRegion setRegion;
+				
+				AccessorDecls(
+#line  1189 &quot;VBNET.ATG&quot; 
+out getRegion, out setRegion);
+				Expect(89);
+				Expect(148);
+				Expect(1);
+
+#line  1193 &quot;VBNET.ATG&quot; 
+				pDecl.GetRegion = getRegion;
+				pDecl.SetRegion = setRegion;
+				pDecl.BodyEnd = t.EndLocation;
+				compilationUnit.AddChild(pDecl);
+				
+			} else SynErr(206);
+			break;
+		}
+		default: SynErr(207); break;
+		}
+	}
+
+	void EnumMemberDecl(
+#line  849 &quot;VBNET.ATG&quot; 
+out FieldDeclaration f) {
+
+#line  851 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		ArrayList attributes = new ArrayList();
+		AttributeSection section = null;
+		VariableDeclaration varDecl = null;
+		
+		while (la.kind == 28) {
+			AttributeSection(
+#line  856 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  856 &quot;VBNET.ATG&quot; 
+			attributes.Add(section); 
+		}
+		Identifier();
+
+#line  859 &quot;VBNET.ATG&quot; 
+		f = new FieldDeclaration(attributes);
+		varDecl = new VariableDeclaration(t.val);
+		varDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+		f.Fields.Add(varDecl);
+		f.StartLocation = t.Location;
+		
+		if (la.kind == 11) {
+			lexer.NextToken();
+			Expr(
+#line  865 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  865 &quot;VBNET.ATG&quot; 
+			varDecl.Initializer = expr; 
+		}
+		Expect(1);
+	}
+
+	void InterfaceMemberDecl() {
+
+#line  760 &quot;VBNET.ATG&quot; 
+		TypeReference type =null;
+		ArrayList p = null;
+		AttributeSection section;
+		Modifiers mod = new Modifiers(this);
+		ArrayList attributes = new ArrayList();
+		/*ArrayList parameters = new ArrayList();*/
+		string name;
+		
+		if (StartOf(12)) {
+			while (la.kind == 28) {
+				AttributeSection(
+#line  768 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  768 &quot;VBNET.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(6)) {
+				MemberModifier(
+#line  772 &quot;VBNET.ATG&quot; 
+mod);
+			}
+			if (la.kind == 94) {
+				lexer.NextToken();
+
+#line  775 &quot;VBNET.ATG&quot; 
+				mod.Check(Modifier.InterfaceEvents); 
+				Identifier();
+
+#line  776 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  777 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  778 &quot;VBNET.ATG&quot; 
+out type);
+				}
+				Expect(1);
+
+#line  781 &quot;VBNET.ATG&quot; 
+				EventDeclaration ed = new EventDeclaration(type, mod.Modifier, p, attributes, name, null);
+				ed.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				compilationUnit.AddChild(ed);
+				ed.EndLocation = t.EndLocation;
+				
+			} else if (la.kind == 169) {
+				lexer.NextToken();
+
+#line  789 &quot;VBNET.ATG&quot; 
+				mod.Check(Modifier.InterfaceMethods);
+				ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+				
+				Identifier();
+
+#line  792 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  793 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				Expect(1);
+
+#line  796 &quot;VBNET.ATG&quot; 
+				MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, null, p, attributes);
+				md.Specials[&quot;before&quot;] = comments;
+				md.EndLocation = t.EndLocation;
+				compilationUnit.AddChild(md);
+				
+			} else if (la.kind == 101) {
+				lexer.NextToken();
+
+#line  804 &quot;VBNET.ATG&quot; 
+				mod.Check(Modifier.InterfaceMethods);
+				AttributeSection attributeSection = null;
+				
+				Identifier();
+
+#line  807 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  808 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					if (la.kind == 28) {
+						AttributeSection(
+#line  809 &quot;VBNET.ATG&quot; 
+out attributeSection);
+					}
+					TypeName(
+#line  809 &quot;VBNET.ATG&quot; 
+out type);
+				}
+
+#line  811 &quot;VBNET.ATG&quot; 
+				if(type == null) {
+				type = new TypeReference(&quot;System.Object&quot;);
+				}
+				type.Attributes = attributeSection;
+				MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, type, p, attributes);
+				md.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
+				md.EndLocation = t.EndLocation;
+				compilationUnit.AddChild(md);
+				
+				Expect(1);
+			} else if (la.kind == 148) {
+				lexer.NextToken();
+
+#line  824 &quot;VBNET.ATG&quot; 
+				mod.Check(Modifier.InterfaceProperties);
+				ArrayList comments = lexer.SpecialTracker.RetreiveComments();
+				
+				Identifier();
+
+#line  827 &quot;VBNET.ATG&quot; 
+				name = t.val;  
+				if (la.kind == 25) {
+					lexer.NextToken();
+					if (StartOf(4)) {
+						FormalParameterList(
+#line  828 &quot;VBNET.ATG&quot; 
+out p);
+					}
+					Expect(26);
+				}
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  829 &quot;VBNET.ATG&quot; 
+out type);
+				}
+
+#line  831 &quot;VBNET.ATG&quot; 
+				if(type == null) {
+				type = new TypeReference(&quot;System.Object&quot;);
+				}
+				
+				Expect(1);
+
+#line  837 &quot;VBNET.ATG&quot; 
+				PropertyDeclaration pd = new PropertyDeclaration(name, type, mod.Modifier, attributes);
+				pd.Parameters = p;
+				pd.Specials[&quot;before&quot;] = comments;
+				pd.EndLocation = t.EndLocation;
+				compilationUnit.AddChild(pd);
+				
+			} else SynErr(208);
+		} else if (StartOf(13)) {
+			NonModuleDeclaration(
+#line  845 &quot;VBNET.ATG&quot; 
+mod, attributes);
+		} else SynErr(209);
+	}
+
+	void Expr(
+#line  1447 &quot;VBNET.ATG&quot; 
+out Expression expr) {
+
+#line  1448 &quot;VBNET.ATG&quot; 
+		expr = new Expression(); 
+		ConditionalOrExpr(
+#line  1449 &quot;VBNET.ATG&quot; 
+out expr);
+		while (StartOf(14)) {
+
+#line  1452 &quot;VBNET.ATG&quot; 
+			AssignmentOperatorType op; Expression val; 
+			AssignmentOperator(
+#line  1453 &quot;VBNET.ATG&quot; 
+out op);
+			Expr(
+#line  1453 &quot;VBNET.ATG&quot; 
+out val);
+
+#line  1453 &quot;VBNET.ATG&quot; 
+			expr = new AssignmentExpression(expr, op, val); 
+		}
+	}
+
+	void ImplementsClause(
+#line  1425 &quot;VBNET.ATG&quot; 
+out ImplementsClause clause) {
+
+#line  1427 &quot;VBNET.ATG&quot; 
+		clause = new ImplementsClause();
+		string typename = String.Empty;
+		string first;
+		
+		Expect(108);
+		Identifier();
+
+#line  1431 &quot;VBNET.ATG&quot; 
+		first = t.val; 
+		Expect(10);
+		Qualident(
+#line  1431 &quot;VBNET.ATG&quot; 
+out typename);
+
+#line  1431 &quot;VBNET.ATG&quot; 
+		((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			Identifier();
+
+#line  1432 &quot;VBNET.ATG&quot; 
+			first = t.val; 
+			Expect(10);
+			Qualident(
+#line  1432 &quot;VBNET.ATG&quot; 
+out typename);
+
+#line  1432 &quot;VBNET.ATG&quot; 
+			((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); 
+		}
+	}
+
+	void HandlesClause(
+#line  1383 &quot;VBNET.ATG&quot; 
+out HandlesClause handlesClause) {
+
+#line  1385 &quot;VBNET.ATG&quot; 
+		handlesClause = new HandlesClause();
+		string name;
+		
+		Expect(106);
+		EventMemberSpecifier(
+#line  1388 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1388 &quot;VBNET.ATG&quot; 
+		handlesClause.EventNames.Add(name); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			EventMemberSpecifier(
+#line  1389 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1389 &quot;VBNET.ATG&quot; 
+			handlesClause.EventNames.Add(name); 
+		}
+	}
+
+	void Block(
+#line  2004 &quot;VBNET.ATG&quot; 
+out Statement stmt) {
+
+#line  2007 &quot;VBNET.ATG&quot; 
+		BlockStatement blockStmt = new BlockStatement();
+		blockStmt.StartLocation = t.Location;
+		compilationUnit.BlockStart(blockStmt);
+		
+		while (StartOf(15) || 
+#line  2012 &quot;VBNET.ATG&quot; 
+IsEndStmtAhead()) {
+			if (StartOf(15)) {
+				Statement();
+				EndOfStmt();
+			} else {
+				Expect(89);
+				EndOfStmt();
+
+#line  2012 &quot;VBNET.ATG&quot; 
+				compilationUnit.AddChild(new EndStatement()); 
+			}
+		}
+
+#line  2015 &quot;VBNET.ATG&quot; 
+		stmt = blockStmt;
+		blockStmt.EndLocation = t.EndLocation;
+		compilationUnit.BlockEnd();
+		
+	}
+
+	void Charset(
+#line  1375 &quot;VBNET.ATG&quot; 
+out CharsetModifier charsetModifier) {
+
+#line  1376 &quot;VBNET.ATG&quot; 
+		charsetModifier = CharsetModifier.None; 
+		if (la.kind == 101 || la.kind == 169) {
+		} else if (la.kind == 48) {
+			lexer.NextToken();
+
+#line  1377 &quot;VBNET.ATG&quot; 
+			charsetModifier = CharsetModifier.ANSI; 
+		} else if (la.kind == 51) {
+			lexer.NextToken();
+
+#line  1378 &quot;VBNET.ATG&quot; 
+			charsetModifier = CharsetModifier.Auto; 
+		} else if (la.kind == 178) {
+			lexer.NextToken();
+
+#line  1379 &quot;VBNET.ATG&quot; 
+			charsetModifier = CharsetModifier.Unicode; 
+		} else SynErr(210);
+	}
+
+	void VariableDeclarator(
+#line  1276 &quot;VBNET.ATG&quot; 
+ArrayList fieldDeclaration) {
+
+#line  1278 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		TypeReference type = null;
+		ObjectCreateExpression oce = null;
+		ArrayCreateExpression ace = null;
+		ArrayList rank = null;
+		ArrayList dimension = null;
+		
+		Identifier();
+
+#line  1287 &quot;VBNET.ATG&quot; 
+		VariableDeclaration f = new VariableDeclaration(t.val);
+		
+		if (
+#line  1289 &quot;VBNET.ATG&quot; 
+IsRank()) {
+			ArrayTypeModifiers(
+#line  1289 &quot;VBNET.ATG&quot; 
+out rank);
+		}
+		if (
+#line  1290 &quot;VBNET.ATG&quot; 
+IsSize()) {
+			ArrayInitializationModifier(
+#line  1290 &quot;VBNET.ATG&quot; 
+out dimension);
+		}
+		if (
+#line  1292 &quot;VBNET.ATG&quot; 
+IsObjectCreation()) {
+			Expect(49);
+			ObjectCreateExpression(
+#line  1292 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1294 &quot;VBNET.ATG&quot; 
+			if(expr is ArrayCreateExpression) {
+			ace = expr as ArrayCreateExpression;
+			f.Initializer = ace.ArrayInitializer;
+			
+			} else {
+				oce = expr as ObjectCreateExpression;
+				f.Initializer = oce;
+				if(oce.CreateType != null) {
+					f.Type = oce.CreateType;
+				}
+			}
+			
+		} else if (StartOf(16)) {
+			if (la.kind == 49) {
+				lexer.NextToken();
+				TypeName(
+#line  1307 &quot;VBNET.ATG&quot; 
+out type);
+			}
+
+#line  1309 &quot;VBNET.ATG&quot; 
+			if(type != null) {
+			type.Dimension = dimension;
+			}
+			f.Type = type;
+			if (type != null &amp;&amp; rank != null) {
+				if(type.RankSpecifier != null) {
+					Error(&quot;array rank only allowed one time&quot;);
+				} else {
+					type.RankSpecifier = rank;
+				}
+			}
+			
+			if (la.kind == 11) {
+				lexer.NextToken();
+				VariableInitializer(
+#line  1321 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1321 &quot;VBNET.ATG&quot; 
+				f.Initializer = expr; 
+			}
+		} else SynErr(211);
+
+#line  1323 &quot;VBNET.ATG&quot; 
+		fieldDeclaration.Add(f); 
+	}
+
+	void ConstantDeclarator(
+#line  1259 &quot;VBNET.ATG&quot; 
+ArrayList constantDeclaration) {
+
+#line  1261 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		TypeReference type = null;
+		string name = String.Empty;
+		
+		Identifier();
+
+#line  1265 &quot;VBNET.ATG&quot; 
+		name = t.val; 
+		if (la.kind == 49) {
+			lexer.NextToken();
+			TypeName(
+#line  1266 &quot;VBNET.ATG&quot; 
+out type);
+		}
+		Expect(11);
+		Expr(
+#line  1267 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1269 &quot;VBNET.ATG&quot; 
+		VariableDeclaration f = new VariableDeclaration(name, expr);
+		f.Type = type;
+		constantDeclaration.Add(f);
+		
+	}
+
+	void AccessorDecls(
+#line  1202 &quot;VBNET.ATG&quot; 
+out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
+
+#line  1204 &quot;VBNET.ATG&quot; 
+		ArrayList attributes = new ArrayList(); 
+		AttributeSection section;
+		getBlock = null;
+		setBlock = null; 
+		
+		while (la.kind == 28) {
+			AttributeSection(
+#line  1209 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1209 &quot;VBNET.ATG&quot; 
+			attributes.Add(section); 
+		}
+		if (la.kind == 102) {
+			GetAccessorDecl(
+#line  1211 &quot;VBNET.ATG&quot; 
+out getBlock, attributes);
+			if (la.kind == 28 || la.kind == 158) {
+
+#line  1213 &quot;VBNET.ATG&quot; 
+				attributes = new ArrayList(); 
+				while (la.kind == 28) {
+					AttributeSection(
+#line  1214 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1214 &quot;VBNET.ATG&quot; 
+					attributes.Add(section); 
+				}
+				SetAccessorDecl(
+#line  1215 &quot;VBNET.ATG&quot; 
+out setBlock, attributes);
+			}
+		} else if (la.kind == 158) {
+			SetAccessorDecl(
+#line  1218 &quot;VBNET.ATG&quot; 
+out setBlock, attributes);
+			if (la.kind == 28 || la.kind == 102) {
+
+#line  1220 &quot;VBNET.ATG&quot; 
+				attributes = new ArrayList(); 
+				while (la.kind == 28) {
+					AttributeSection(
+#line  1221 &quot;VBNET.ATG&quot; 
+out section);
+
+#line  1221 &quot;VBNET.ATG&quot; 
+					attributes.Add(section); 
+				}
+				GetAccessorDecl(
+#line  1222 &quot;VBNET.ATG&quot; 
+out getBlock, attributes);
+			}
+		} else SynErr(212);
+	}
+
+	void GetAccessorDecl(
+#line  1228 &quot;VBNET.ATG&quot; 
+out PropertyGetRegion getBlock, ArrayList attributes) {
+
+#line  1229 &quot;VBNET.ATG&quot; 
+		Statement stmt = null; 
+		Expect(102);
+		Expect(1);
+		Block(
+#line  1232 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  1234 &quot;VBNET.ATG&quot; 
+		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes);
+		
+		Expect(89);
+		Expect(102);
+		Expect(1);
+	}
+
+	void SetAccessorDecl(
+#line  1241 &quot;VBNET.ATG&quot; 
+out PropertySetRegion setBlock, ArrayList attributes) {
+
+#line  1243 &quot;VBNET.ATG&quot; 
+		Statement stmt = null;
+		ArrayList p = null;
+		
+		Expect(158);
+		if (la.kind == 25) {
+			lexer.NextToken();
+			if (StartOf(4)) {
+				FormalParameterList(
+#line  1247 &quot;VBNET.ATG&quot; 
+out p);
+			}
+			Expect(26);
+		}
+		Expect(1);
+		Block(
+#line  1249 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  1251 &quot;VBNET.ATG&quot; 
+		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes);
+		setBlock.Parameters = p;
+		
+		Expect(89);
+		Expect(158);
+		Expect(1);
+	}
+
+	void ArrayTypeModifiers(
+#line  1813 &quot;VBNET.ATG&quot; 
+out ArrayList arrayModifiers) {
+
+#line  1815 &quot;VBNET.ATG&quot; 
+		arrayModifiers = new ArrayList();
+		int i = 0;
+		
+		while (
+#line  1818 &quot;VBNET.ATG&quot; 
+IsRank()) {
+			Expect(25);
+			if (la.kind == 12 || la.kind == 26) {
+				RankList(
+#line  1820 &quot;VBNET.ATG&quot; 
+out i);
+			}
+
+#line  1822 &quot;VBNET.ATG&quot; 
+			arrayModifiers.Add(i);
+			
+			Expect(26);
+		}
+
+#line  1827 &quot;VBNET.ATG&quot; 
+		if(arrayModifiers.Count == 0) {
+		 arrayModifiers = null;
+		}
+		
+	}
+
+	void ArrayInitializationModifier(
+#line  1327 &quot;VBNET.ATG&quot; 
+out ArrayList arrayModifiers) {
+
+#line  1329 &quot;VBNET.ATG&quot; 
+		arrayModifiers = null;
+		
+		Expect(25);
+		InitializationRankList(
+#line  1331 &quot;VBNET.ATG&quot; 
+out arrayModifiers);
+		Expect(26);
+	}
+
+	void ObjectCreateExpression(
+#line  1701 &quot;VBNET.ATG&quot; 
+out Expression oce) {
+
+#line  1703 &quot;VBNET.ATG&quot; 
+		TypeReference type = null;
+		Expression initializer = null;
+		ArrayList arguments = null;
+		oce = null;
+		
+		Expect(128);
+		ArrayTypeName(
+#line  1708 &quot;VBNET.ATG&quot; 
+out type);
+		if (la.kind == 25) {
+			lexer.NextToken();
+			if (StartOf(17)) {
+				ArgumentList(
+#line  1710 &quot;VBNET.ATG&quot; 
+out arguments);
+			}
+			Expect(26);
+		}
+		if (la.kind == 21) {
+			ArrayInitializer(
+#line  1714 &quot;VBNET.ATG&quot; 
+out initializer);
+		}
+
+#line  1717 &quot;VBNET.ATG&quot; 
+		if(initializer == null) {
+		oce = new ObjectCreateExpression(type, arguments);
+		} else {
+			ArrayCreateExpression ace = new ArrayCreateExpression(type, initializer as ArrayInitializerExpression);
+			ace.Parameters = arguments;
+			oce = ace;
+		}
+		
+	}
+
+	void VariableInitializer(
+#line  1347 &quot;VBNET.ATG&quot; 
+out Expression initializerExpression) {
+
+#line  1349 &quot;VBNET.ATG&quot; 
+		initializerExpression = null;
+		
+		if (StartOf(18)) {
+			Expr(
+#line  1351 &quot;VBNET.ATG&quot; 
+out initializerExpression);
+		} else if (la.kind == 21) {
+			ArrayInitializer(
+#line  1352 &quot;VBNET.ATG&quot; 
+out initializerExpression);
+		} else SynErr(213);
+	}
+
+	void InitializationRankList(
+#line  1335 &quot;VBNET.ATG&quot; 
+out ArrayList rank) {
+
+#line  1337 &quot;VBNET.ATG&quot; 
+		rank = null;
+		Expression expr = null;
+		
+		Expr(
+#line  1340 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1340 &quot;VBNET.ATG&quot; 
+		rank = new ArrayList(); rank.Add(expr); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			Expr(
+#line  1342 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1342 &quot;VBNET.ATG&quot; 
+			rank.Add(expr); 
+		}
+	}
+
+	void ArrayInitializer(
+#line  1356 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1358 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
+		
+		Expect(21);
+		if (StartOf(19)) {
+			VariableInitializer(
+#line  1363 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1365 &quot;VBNET.ATG&quot; 
+			initializer.CreateExpressions.Add(expr);
+			
+			while (
+#line  1368 &quot;VBNET.ATG&quot; 
+NotFinalComma()) {
+				Expect(12);
+				VariableInitializer(
+#line  1368 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1369 &quot;VBNET.ATG&quot; 
+				initializer.CreateExpressions.Add(expr); 
+			}
+		}
+		Expect(22);
+
+#line  1372 &quot;VBNET.ATG&quot; 
+		outExpr = initializer; 
+	}
+
+	void EventMemberSpecifier(
+#line  1435 &quot;VBNET.ATG&quot; 
+out string name) {
+
+#line  1436 &quot;VBNET.ATG&quot; 
+		string type; name = String.Empty; 
+		if (StartOf(9)) {
+			Identifier();
+
+#line  1437 &quot;VBNET.ATG&quot; 
+			type = t.val; 
+			Expect(10);
+			Identifier();
+
+#line  1439 &quot;VBNET.ATG&quot; 
+			name = type + &quot;.&quot; + t.val; 
+		} else if (la.kind == 125) {
+			lexer.NextToken();
+			Expect(10);
+			if (StartOf(9)) {
+				Identifier();
+
+#line  1442 &quot;VBNET.ATG&quot; 
+				name = &quot;MyBase.&quot; + t.val; 
+			} else if (la.kind == 93) {
+				lexer.NextToken();
+
+#line  1443 &quot;VBNET.ATG&quot; 
+				name = &quot;MyBase.Error&quot;; 
+			} else SynErr(214);
+		} else SynErr(215);
+	}
+
+	void ConditionalOrExpr(
+#line  1581 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1582 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		ConditionalAndExpr(
+#line  1583 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 140) {
+			lexer.NextToken();
+			ConditionalAndExpr(
+#line  1583 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1583 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanOr, expr);  
+		}
+	}
+
+	void AssignmentOperator(
+#line  1478 &quot;VBNET.ATG&quot; 
+out AssignmentOperatorType op) {
+
+#line  1479 &quot;VBNET.ATG&quot; 
+		op = AssignmentOperatorType.None; 
+		switch (la.kind) {
+		case 11: {
+			lexer.NextToken();
+
+#line  1480 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Assign; 
+			break;
+		}
+		case 42: {
+			lexer.NextToken();
+
+#line  1481 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.ConcatString; 
+			break;
+		}
+		case 34: {
+			lexer.NextToken();
+
+#line  1482 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Add; 
+			break;
+		}
+		case 36: {
+			lexer.NextToken();
+
+#line  1483 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Subtract; 
+			break;
+		}
+		case 37: {
+			lexer.NextToken();
+
+#line  1484 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Multiply; 
+			break;
+		}
+		case 38: {
+			lexer.NextToken();
+
+#line  1485 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Divide; 
+			break;
+		}
+		case 39: {
+			lexer.NextToken();
+
+#line  1486 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.DivideInteger; 
+			break;
+		}
+		case 35: {
+			lexer.NextToken();
+
+#line  1487 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.Power; 
+			break;
+		}
+		case 40: {
+			lexer.NextToken();
+
+#line  1488 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.ShiftLeft; 
+			break;
+		}
+		case 41: {
+			lexer.NextToken();
+
+#line  1489 &quot;VBNET.ATG&quot; 
+			op = AssignmentOperatorType.ShiftRight; 
+			break;
+		}
+		default: SynErr(216); break;
+		}
+	}
+
+	void UnaryExpr(
+#line  1457 &quot;VBNET.ATG&quot; 
+out Expression uExpr) {
+
+#line  1459 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		UnaryOperatorType uop = UnaryOperatorType.None;
+		bool isUOp = false;
+		
+		while (la.kind == 14 || la.kind == 15 || la.kind == 16) {
+			if (la.kind == 14) {
+				lexer.NextToken();
+
+#line  1463 &quot;VBNET.ATG&quot; 
+				uop = UnaryOperatorType.Plus; isUOp = true; 
+			} else if (la.kind == 15) {
+				lexer.NextToken();
+
+#line  1464 &quot;VBNET.ATG&quot; 
+				uop = UnaryOperatorType.Minus; isUOp = true; 
+			} else {
+				lexer.NextToken();
+
+#line  1466 &quot;VBNET.ATG&quot; 
+				uop = UnaryOperatorType.Star;  isUOp = true;
+			}
+		}
+		SimpleExpr(
+#line  1468 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1470 &quot;VBNET.ATG&quot; 
+		if (isUOp) {
+		uExpr = new UnaryOperatorExpression(expr, uop);
+		} else {
+			uExpr = expr;
+		}
+		
+	}
+
+	void SimpleExpr(
+#line  1493 &quot;VBNET.ATG&quot; 
+out Expression pexpr) {
+
+#line  1495 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		TypeReference type = null;
+		string name = String.Empty;
+		pexpr = null;
+		
+		if (StartOf(20)) {
+			switch (la.kind) {
+			case 3: {
+				lexer.NextToken();
+
+#line  1503 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 4: {
+				lexer.NextToken();
+
+#line  1504 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 7: {
+				lexer.NextToken();
+
+#line  1505 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 6: {
+				lexer.NextToken();
+
+#line  1506 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 5: {
+				lexer.NextToken();
+
+#line  1507 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 9: {
+				lexer.NextToken();
+
+#line  1508 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 8: {
+				lexer.NextToken();
+
+#line  1509 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+				break;
+			}
+			case 175: {
+				lexer.NextToken();
+
+#line  1511 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(true, &quot;true&quot;);  
+				break;
+			}
+			case 97: {
+				lexer.NextToken();
+
+#line  1512 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(false, &quot;false&quot;); 
+				break;
+			}
+			case 131: {
+				lexer.NextToken();
+
+#line  1513 &quot;VBNET.ATG&quot; 
+				pexpr = new PrimitiveExpression(null, &quot;null&quot;);  
+				break;
+			}
+			case 25: {
+				lexer.NextToken();
+				Expr(
+#line  1514 &quot;VBNET.ATG&quot; 
+out expr);
+				Expect(26);
+
+#line  1514 &quot;VBNET.ATG&quot; 
+				pexpr = new ParenthesizedExpression(expr); 
+				break;
+			}
+			case 2: case 52: case 71: case 171: {
+				Identifier();
+
+#line  1515 &quot;VBNET.ATG&quot; 
+				pexpr = new IdentifierExpression(t.val); 
+				break;
+			}
+			case 53: case 55: case 66: case 77: case 78: case 85: case 112: case 118: case 161: case 162: case 167: {
+
+#line  1516 &quot;VBNET.ATG&quot; 
+				string val = String.Empty; 
+				PrimitiveTypeName(
+#line  1516 &quot;VBNET.ATG&quot; 
+out val);
+				Expect(10);
+				Identifier();
+
+#line  1517 &quot;VBNET.ATG&quot; 
+				pexpr = new FieldReferenceOrInvocationExpression(new TypeReferenceExpression(val), t.val); 
+				break;
+			}
+			case 120: {
+				lexer.NextToken();
+
+#line  1518 &quot;VBNET.ATG&quot; 
+				pexpr = new ThisReferenceExpression(); 
+				break;
+			}
+			case 125: case 126: {
+
+#line  1519 &quot;VBNET.ATG&quot; 
+				Expression retExpr = null; 
+				if (la.kind == 125) {
+					lexer.NextToken();
+
+#line  1520 &quot;VBNET.ATG&quot; 
+					retExpr = new BaseReferenceExpression(); 
+				} else if (la.kind == 126) {
+					lexer.NextToken();
+
+#line  1521 &quot;VBNET.ATG&quot; 
+					retExpr = new ClassReferenceExpression(); 
+				} else SynErr(217);
+				Expect(10);
+				IdentifierOrKeyword(
+#line  1523 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1523 &quot;VBNET.ATG&quot; 
+				pexpr = new FieldReferenceOrInvocationExpression(retExpr, name); 
+				break;
+			}
+			case 128: {
+				ObjectCreateExpression(
+#line  1524 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1524 &quot;VBNET.ATG&quot; 
+				pexpr = expr; 
+				break;
+			}
+			case 76: case 83: {
+				if (la.kind == 83) {
+					lexer.NextToken();
+				} else if (la.kind == 76) {
+					lexer.NextToken();
+				} else SynErr(218);
+				Expect(25);
+				Expr(
+#line  1525 &quot;VBNET.ATG&quot; 
+out expr);
+				Expect(12);
+				TypeName(
+#line  1525 &quot;VBNET.ATG&quot; 
+out type);
+				Expect(26);
+
+#line  1525 &quot;VBNET.ATG&quot; 
+				pexpr = new CastExpression(type, expr); 
+				break;
+			}
+			case 60: case 61: case 62: case 63: case 64: case 65: case 67: case 69: case 70: case 73: case 74: case 75: {
+				CastTarget(
+#line  1526 &quot;VBNET.ATG&quot; 
+out type);
+				Expect(25);
+				Expr(
+#line  1526 &quot;VBNET.ATG&quot; 
+out expr);
+				Expect(26);
+
+#line  1526 &quot;VBNET.ATG&quot; 
+				pexpr = new CastExpression(type, expr, true); 
+				break;
+			}
+			case 44: {
+				lexer.NextToken();
+				Expr(
+#line  1527 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1527 &quot;VBNET.ATG&quot; 
+				pexpr = new AddressOfExpression(expr); 
+				break;
+			}
+			case 103: {
+				lexer.NextToken();
+				Expect(25);
+				TypeName(
+#line  1528 &quot;VBNET.ATG&quot; 
+out type);
+				Expect(26);
+
+#line  1528 &quot;VBNET.ATG&quot; 
+				pexpr = new GetTypeExpression(type); 
+				break;
+			}
+			case 177: {
+				lexer.NextToken();
+				SimpleExpr(
+#line  1529 &quot;VBNET.ATG&quot; 
+out expr);
+				Expect(114);
+				TypeName(
+#line  1529 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  1529 &quot;VBNET.ATG&quot; 
+				pexpr = new TypeOfExpression(expr, type); 
+				break;
+			}
+			}
+			while (la.kind == 10 || la.kind == 25) {
+				if (la.kind == 10) {
+					lexer.NextToken();
+					IdentifierOrKeyword(
+#line  1532 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1532 &quot;VBNET.ATG&quot; 
+					pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); 
+				} else {
+					lexer.NextToken();
+
+#line  1533 &quot;VBNET.ATG&quot; 
+					ArrayList parameters = new ArrayList(); 
+					if (StartOf(21)) {
+
+#line  1535 &quot;VBNET.ATG&quot; 
+						expr = null; 
+						if (StartOf(18)) {
+							Argument(
+#line  1535 &quot;VBNET.ATG&quot; 
+out expr);
+						}
+
+#line  1535 &quot;VBNET.ATG&quot; 
+						parameters.Add(expr); 
+						while (la.kind == 12) {
+							lexer.NextToken();
+
+#line  1537 &quot;VBNET.ATG&quot; 
+							expr = null; 
+							if (StartOf(18)) {
+								Argument(
+#line  1538 &quot;VBNET.ATG&quot; 
+out expr);
+							}
+
+#line  1538 &quot;VBNET.ATG&quot; 
+							parameters.Add(expr); 
+						}
+					}
+					Expect(26);
+
+#line  1541 &quot;VBNET.ATG&quot; 
+					pexpr = new InvocationExpression(pexpr, parameters); 
+				}
+			}
+		} else if (la.kind == 10) {
+			lexer.NextToken();
+			IdentifierOrKeyword(
+#line  1545 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1545 &quot;VBNET.ATG&quot; 
+			pexpr = new FieldReferenceOrInvocationExpression(pexpr, name);
+			while (la.kind == 10 || la.kind == 25) {
+				if (la.kind == 10) {
+					lexer.NextToken();
+					IdentifierOrKeyword(
+#line  1547 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1547 &quot;VBNET.ATG&quot; 
+					pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); 
+				} else {
+					lexer.NextToken();
+
+#line  1548 &quot;VBNET.ATG&quot; 
+					ArrayList parameters = new ArrayList(); 
+					if (StartOf(21)) {
+
+#line  1550 &quot;VBNET.ATG&quot; 
+						expr = null; 
+						if (StartOf(18)) {
+							Argument(
+#line  1550 &quot;VBNET.ATG&quot; 
+out expr);
+						}
+
+#line  1550 &quot;VBNET.ATG&quot; 
+						parameters.Add(expr); 
+						while (la.kind == 12) {
+							lexer.NextToken();
+
+#line  1552 &quot;VBNET.ATG&quot; 
+							expr = null; 
+							if (StartOf(18)) {
+								Argument(
+#line  1553 &quot;VBNET.ATG&quot; 
+out expr);
+							}
+
+#line  1553 &quot;VBNET.ATG&quot; 
+							parameters.Add(expr); 
+						}
+					}
+					Expect(26);
+
+#line  1556 &quot;VBNET.ATG&quot; 
+					pexpr = new InvocationExpression(pexpr, parameters); 
+				}
+			}
+		} else SynErr(219);
+	}
+
+	void IdentifierOrKeyword(
+#line  2547 &quot;VBNET.ATG&quot; 
+out string name) {
+
+#line  2549 &quot;VBNET.ATG&quot; 
+		name = String.Empty;
+		
+		switch (la.kind) {
+		case 2: case 52: case 71: case 171: {
+			Identifier();
+
+#line  2551 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 43: {
+			lexer.NextToken();
+
+#line  2552 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 44: {
+			lexer.NextToken();
+
+#line  2553 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 45: {
+			lexer.NextToken();
+
+#line  2554 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 46: {
+			lexer.NextToken();
+
+#line  2555 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 47: {
+			lexer.NextToken();
+
+#line  2556 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 48: {
+			lexer.NextToken();
+
+#line  2557 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 49: {
+			lexer.NextToken();
+
+#line  2558 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 50: {
+			lexer.NextToken();
+
+#line  2559 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 51: {
+			lexer.NextToken();
+
+#line  2560 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 53: {
+			lexer.NextToken();
+
+#line  2561 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 54: {
+			lexer.NextToken();
+
+#line  2562 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 55: {
+			lexer.NextToken();
+
+#line  2563 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 56: {
+			lexer.NextToken();
+
+#line  2564 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 57: {
+			lexer.NextToken();
+
+#line  2565 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 58: {
+			lexer.NextToken();
+
+#line  2566 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 59: {
+			lexer.NextToken();
+
+#line  2567 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 60: {
+			lexer.NextToken();
+
+#line  2568 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 61: {
+			lexer.NextToken();
+
+#line  2569 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 62: {
+			lexer.NextToken();
+
+#line  2570 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 63: {
+			lexer.NextToken();
+
+#line  2571 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 64: {
+			lexer.NextToken();
+
+#line  2572 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 65: {
+			lexer.NextToken();
+
+#line  2573 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 66: {
+			lexer.NextToken();
+
+#line  2574 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 67: {
+			lexer.NextToken();
+
+#line  2575 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 68: {
+			lexer.NextToken();
+
+#line  2576 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 69: {
+			lexer.NextToken();
+
+#line  2577 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 70: {
+			lexer.NextToken();
+
+#line  2578 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 72: {
+			lexer.NextToken();
+
+#line  2579 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 73: {
+			lexer.NextToken();
+
+#line  2580 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 74: {
+			lexer.NextToken();
+
+#line  2581 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 75: {
+			lexer.NextToken();
+
+#line  2582 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 76: {
+			lexer.NextToken();
+
+#line  2583 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 77: {
+			lexer.NextToken();
+
+#line  2584 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 78: {
+			lexer.NextToken();
+
+#line  2585 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 79: {
+			lexer.NextToken();
+
+#line  2586 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 80: {
+			lexer.NextToken();
+
+#line  2587 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 81: {
+			lexer.NextToken();
+
+#line  2588 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 82: {
+			lexer.NextToken();
+
+#line  2589 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 83: {
+			lexer.NextToken();
+
+#line  2590 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 84: {
+			lexer.NextToken();
+
+#line  2591 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 85: {
+			lexer.NextToken();
+
+#line  2592 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 86: {
+			lexer.NextToken();
+
+#line  2593 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 87: {
+			lexer.NextToken();
+
+#line  2594 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 88: {
+			lexer.NextToken();
+
+#line  2595 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 89: {
+			lexer.NextToken();
+
+#line  2596 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 90: {
+			lexer.NextToken();
+
+#line  2597 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 91: {
+			lexer.NextToken();
+
+#line  2598 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 92: {
+			lexer.NextToken();
+
+#line  2599 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 93: {
+			lexer.NextToken();
+
+#line  2600 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 94: {
+			lexer.NextToken();
+
+#line  2601 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 95: {
+			lexer.NextToken();
+
+#line  2602 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 97: {
+			lexer.NextToken();
+
+#line  2603 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 98: {
+			lexer.NextToken();
+
+#line  2604 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 99: {
+			lexer.NextToken();
+
+#line  2605 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 100: {
+			lexer.NextToken();
+
+#line  2606 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 101: {
+			lexer.NextToken();
+
+#line  2607 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 102: {
+			lexer.NextToken();
+
+#line  2608 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 103: {
+			lexer.NextToken();
+
+#line  2609 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 104: {
+			lexer.NextToken();
+
+#line  2610 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 105: {
+			lexer.NextToken();
+
+#line  2611 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 106: {
+			lexer.NextToken();
+
+#line  2612 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 107: {
+			lexer.NextToken();
+
+#line  2613 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 108: {
+			lexer.NextToken();
+
+#line  2614 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 109: {
+			lexer.NextToken();
+
+#line  2615 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 110: {
+			lexer.NextToken();
+
+#line  2616 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 111: {
+			lexer.NextToken();
+
+#line  2617 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 112: {
+			lexer.NextToken();
+
+#line  2618 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 113: {
+			lexer.NextToken();
+
+#line  2619 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 114: {
+			lexer.NextToken();
+
+#line  2620 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 115: {
+			lexer.NextToken();
+
+#line  2621 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 116: {
+			lexer.NextToken();
+
+#line  2622 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 117: {
+			lexer.NextToken();
+
+#line  2623 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 118: {
+			lexer.NextToken();
+
+#line  2624 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 119: {
+			lexer.NextToken();
+
+#line  2625 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 120: {
+			lexer.NextToken();
+
+#line  2626 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 121: {
+			lexer.NextToken();
+
+#line  2627 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 122: {
+			lexer.NextToken();
+
+#line  2628 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 123: {
+			lexer.NextToken();
+
+#line  2629 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 124: {
+			lexer.NextToken();
+
+#line  2630 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 125: {
+			lexer.NextToken();
+
+#line  2631 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 126: {
+			lexer.NextToken();
+
+#line  2632 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 127: {
+			lexer.NextToken();
+
+#line  2633 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 128: {
+			lexer.NextToken();
+
+#line  2634 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 129: {
+			lexer.NextToken();
+
+#line  2635 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 130: {
+			lexer.NextToken();
+
+#line  2636 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 131: {
+			lexer.NextToken();
+
+#line  2637 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 132: {
+			lexer.NextToken();
+
+#line  2638 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 133: {
+			lexer.NextToken();
+
+#line  2639 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 134: {
+			lexer.NextToken();
+
+#line  2640 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 136: {
+			lexer.NextToken();
+
+#line  2641 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 137: {
+			lexer.NextToken();
+
+#line  2642 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 138: {
+			lexer.NextToken();
+
+#line  2643 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 139: {
+			lexer.NextToken();
+
+#line  2644 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 140: {
+			lexer.NextToken();
+
+#line  2645 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 141: {
+			lexer.NextToken();
+
+#line  2646 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 142: {
+			lexer.NextToken();
+
+#line  2647 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 144: {
+			lexer.NextToken();
+
+#line  2648 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 145: {
+			lexer.NextToken();
+
+#line  2649 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 146: {
+			lexer.NextToken();
+
+#line  2650 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 147: {
+			lexer.NextToken();
+
+#line  2651 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 148: {
+			lexer.NextToken();
+
+#line  2652 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 149: {
+			lexer.NextToken();
+
+#line  2653 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 150: {
+			lexer.NextToken();
+
+#line  2654 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 151: {
+			lexer.NextToken();
+
+#line  2655 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 152: {
+			lexer.NextToken();
+
+#line  2656 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 153: {
+			lexer.NextToken();
+
+#line  2657 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 154: {
+			lexer.NextToken();
+
+#line  2658 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 155: {
+			lexer.NextToken();
+
+#line  2659 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 156: {
+			lexer.NextToken();
+
+#line  2660 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 157: {
+			lexer.NextToken();
+
+#line  2661 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 158: {
+			lexer.NextToken();
+
+#line  2662 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 159: {
+			lexer.NextToken();
+
+#line  2663 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 160: {
+			lexer.NextToken();
+
+#line  2664 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 161: {
+			lexer.NextToken();
+
+#line  2665 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 162: {
+			lexer.NextToken();
+
+#line  2666 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 163: {
+			lexer.NextToken();
+
+#line  2667 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 164: {
+			lexer.NextToken();
+
+#line  2668 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 165: {
+			lexer.NextToken();
+
+#line  2669 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 167: {
+			lexer.NextToken();
+
+#line  2670 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 168: {
+			lexer.NextToken();
+
+#line  2671 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 169: {
+			lexer.NextToken();
+
+#line  2672 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 170: {
+			lexer.NextToken();
+
+#line  2673 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 172: {
+			lexer.NextToken();
+
+#line  2674 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 173: {
+			lexer.NextToken();
+
+#line  2675 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 174: {
+			lexer.NextToken();
+
+#line  2676 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 175: {
+			lexer.NextToken();
+
+#line  2677 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 176: {
+			lexer.NextToken();
+
+#line  2678 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 177: {
+			lexer.NextToken();
+
+#line  2679 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 178: {
+			lexer.NextToken();
+
+#line  2680 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 179: {
+			lexer.NextToken();
+
+#line  2681 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 180: {
+			lexer.NextToken();
+
+#line  2682 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 181: {
+			lexer.NextToken();
+
+#line  2683 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 182: {
+			lexer.NextToken();
+
+#line  2684 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 183: {
+			lexer.NextToken();
+
+#line  2685 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 184: {
+			lexer.NextToken();
+
+#line  2686 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 185: {
+			lexer.NextToken();
+
+#line  2687 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 186: {
+			lexer.NextToken();
+
+#line  2688 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		case 187: {
+			lexer.NextToken();
+
+#line  2689 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			break;
+		}
+		default: SynErr(220); break;
+		}
+	}
+
+	void CastTarget(
+#line  1563 &quot;VBNET.ATG&quot; 
+out TypeReference type) {
+
+#line  1565 &quot;VBNET.ATG&quot; 
+		type = null;
+		
+		switch (la.kind) {
+		case 60: {
+			lexer.NextToken();
+
+#line  1567 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Boolean&quot;); 
+			break;
+		}
+		case 61: {
+			lexer.NextToken();
+
+#line  1568 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Byte&quot;); 
+			break;
+		}
+		case 62: {
+			lexer.NextToken();
+
+#line  1569 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Char&quot;); 
+			break;
+		}
+		case 63: {
+			lexer.NextToken();
+
+#line  1570 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.DateTime&quot;); 
+			break;
+		}
+		case 65: {
+			lexer.NextToken();
+
+#line  1571 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Decimal&quot;); 
+			break;
+		}
+		case 64: {
+			lexer.NextToken();
+
+#line  1572 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Double&quot;); 
+			break;
+		}
+		case 67: {
+			lexer.NextToken();
+
+#line  1573 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Int32&quot;); 
+			break;
+		}
+		case 69: {
+			lexer.NextToken();
+
+#line  1574 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Int64&quot;); 
+			break;
+		}
+		case 70: {
+			lexer.NextToken();
+
+#line  1575 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Object&quot;); 
+			break;
+		}
+		case 73: {
+			lexer.NextToken();
+
+#line  1576 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Int16&quot;); 
+			break;
+		}
+		case 74: {
+			lexer.NextToken();
+
+#line  1577 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.Single&quot;); 
+			break;
+		}
+		case 75: {
+			lexer.NextToken();
+
+#line  1578 &quot;VBNET.ATG&quot; 
+			type = new TypeReference(&quot;System.String&quot;); 
+			break;
+		}
+		default: SynErr(221); break;
+		}
+	}
+
+	void Argument(
+#line  1743 &quot;VBNET.ATG&quot; 
+out Expression argumentexpr) {
+
+#line  1745 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		argumentexpr = null;
+		string name;
+		
+		if (
+#line  1749 &quot;VBNET.ATG&quot; 
+IsNamedAssign()) {
+			Identifier();
+
+#line  1749 &quot;VBNET.ATG&quot; 
+			name = t.val;  
+			Expect(13);
+			Expect(11);
+			Expr(
+#line  1749 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1751 &quot;VBNET.ATG&quot; 
+			argumentexpr = new NamedArgumentExpression(name, expr);
+			
+		} else if (StartOf(18)) {
+			Expr(
+#line  1754 &quot;VBNET.ATG&quot; 
+out argumentexpr);
+		} else SynErr(222);
+	}
+
+	void ConditionalAndExpr(
+#line  1586 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1587 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		InclusiveOrExpr(
+#line  1588 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 47) {
+			lexer.NextToken();
+			InclusiveOrExpr(
+#line  1588 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1588 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanAnd, expr);  
+		}
+	}
+
+	void InclusiveOrExpr(
+#line  1591 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1592 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		ExclusiveOrExpr(
+#line  1593 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 187) {
+			lexer.NextToken();
+			ExclusiveOrExpr(
+#line  1593 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1593 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  
+		}
+	}
+
+	void ExclusiveOrExpr(
+#line  1596 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1597 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		AndExpr(
+#line  1598 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 139) {
+			lexer.NextToken();
+			AndExpr(
+#line  1598 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1598 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  
+		}
+	}
+
+	void AndExpr(
+#line  1601 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1602 &quot;VBNET.ATG&quot; 
+		Expression expr; 
+		NotExpr(
+#line  1603 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 46) {
+			lexer.NextToken();
+			NotExpr(
+#line  1603 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1603 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  
+		}
+	}
+
+	void NotExpr(
+#line  1606 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1607 &quot;VBNET.ATG&quot; 
+		UnaryOperatorType uop = UnaryOperatorType.None; 
+		while (la.kind == 130) {
+			lexer.NextToken();
+
+#line  1608 &quot;VBNET.ATG&quot; 
+			uop = UnaryOperatorType.Not; 
+		}
+		EqualityExpr(
+#line  1609 &quot;VBNET.ATG&quot; 
+out outExpr);
+
+#line  1610 &quot;VBNET.ATG&quot; 
+		if (uop != UnaryOperatorType.None)
+		outExpr = new UnaryOperatorExpression(outExpr, uop);
+		
+	}
+
+	void EqualityExpr(
+#line  1615 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1617 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		RelationalExpr(
+#line  1620 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 11 || la.kind == 29 || la.kind == 117) {
+			if (la.kind == 29) {
+				lexer.NextToken();
+
+#line  1623 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.InEquality; 
+			} else if (la.kind == 11) {
+				lexer.NextToken();
+
+#line  1624 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Equality; 
+			} else {
+				lexer.NextToken();
+
+#line  1625 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Like; 
+			}
+			RelationalExpr(
+#line  1627 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1627 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void RelationalExpr(
+#line  1631 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1633 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		ShiftExpr(
+#line  1636 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (StartOf(22)) {
+			if (StartOf(23)) {
+				if (la.kind == 28) {
+					lexer.NextToken();
+
+#line  1639 &quot;VBNET.ATG&quot; 
+					op = BinaryOperatorType.LessThan; 
+				} else if (la.kind == 27) {
+					lexer.NextToken();
+
+#line  1640 &quot;VBNET.ATG&quot; 
+					op = BinaryOperatorType.GreaterThan; 
+				} else if (la.kind == 31) {
+					lexer.NextToken();
+
+#line  1641 &quot;VBNET.ATG&quot; 
+					op = BinaryOperatorType.LessThanOrEqual; 
+				} else if (la.kind == 30) {
+					lexer.NextToken();
+
+#line  1642 &quot;VBNET.ATG&quot; 
+					op = BinaryOperatorType.GreaterThanOrEqual; 
+				} else SynErr(223);
+				ShiftExpr(
+#line  1644 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1644 &quot;VBNET.ATG&quot; 
+				outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+			} else {
+				lexer.NextToken();
+
+#line  1647 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.IS; 
+				Expr(
+#line  1648 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1648 &quot;VBNET.ATG&quot; 
+				outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
+			}
+		}
+	}
+
+	void ShiftExpr(
+#line  1652 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1654 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		AdditiveExpr(
+#line  1657 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 32 || la.kind == 33) {
+			if (la.kind == 32) {
+				lexer.NextToken();
+
+#line  1660 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.ShiftLeft; 
+			} else {
+				lexer.NextToken();
+
+#line  1661 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.ShiftRight; 
+			}
+			AdditiveExpr(
+#line  1663 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1663 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void AdditiveExpr(
+#line  1667 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1669 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		MultiplicativeExpr(
+#line  1672 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (la.kind == 14 || la.kind == 15 || la.kind == 19) {
+			if (la.kind == 14) {
+				lexer.NextToken();
+
+#line  1675 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Add; 
+			} else if (la.kind == 15) {
+				lexer.NextToken();
+
+#line  1676 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Subtract; 
+			} else {
+				lexer.NextToken();
+
+#line  1677 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Concat; 
+			}
+			MultiplicativeExpr(
+#line  1679 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1679 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void MultiplicativeExpr(
+#line  1683 &quot;VBNET.ATG&quot; 
+out Expression outExpr) {
+
+#line  1685 &quot;VBNET.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		UnaryExpr(
+#line  1688 &quot;VBNET.ATG&quot; 
+out outExpr);
+		while (StartOf(24)) {
+			if (la.kind == 16) {
+				lexer.NextToken();
+
+#line  1691 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Multiply; 
+			} else if (la.kind == 17) {
+				lexer.NextToken();
+
+#line  1692 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Divide; 
+			} else if (la.kind == 18) {
+				lexer.NextToken();
+
+#line  1693 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.DivideInteger; 
+			} else if (la.kind == 121) {
+				lexer.NextToken();
+
+#line  1694 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Modulus; 
+			} else {
+				lexer.NextToken();
+
+#line  1695 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Power; 
+			}
+			UnaryExpr(
+#line  1697 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1697 &quot;VBNET.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
+		}
+	}
+
+	void ArrayTypeName(
+#line  1770 &quot;VBNET.ATG&quot; 
+out TypeReference typeref) {
+
+#line  1772 &quot;VBNET.ATG&quot; 
+		ArrayList rank = null;
+		
+		NonArrayTypeName(
+#line  1774 &quot;VBNET.ATG&quot; 
+out typeref);
+		ArrayInitializationModifiers(
+#line  1775 &quot;VBNET.ATG&quot; 
+out rank);
+
+#line  1777 &quot;VBNET.ATG&quot; 
+		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
+		
+	}
+
+	void ArgumentList(
+#line  1728 &quot;VBNET.ATG&quot; 
+out ArrayList arguments) {
+
+#line  1730 &quot;VBNET.ATG&quot; 
+		arguments = new ArrayList();
+		Expression expr = null;
+		
+		if (StartOf(18)) {
+			Argument(
+#line  1734 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1734 &quot;VBNET.ATG&quot; 
+			arguments.Add(expr); 
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Argument(
+#line  1737 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1737 &quot;VBNET.ATG&quot; 
+				arguments.Add(expr); 
+			}
+		}
+	}
+
+	void NonArrayTypeName(
+#line  1782 &quot;VBNET.ATG&quot; 
+out TypeReference typeref) {
+
+#line  1784 &quot;VBNET.ATG&quot; 
+		string name;
+		typeref = null;
+		
+		if (StartOf(9)) {
+			Qualident(
+#line  1787 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1787 &quot;VBNET.ATG&quot; 
+			typeref = new TypeReference(name); 
+		} else if (la.kind == 134) {
+			lexer.NextToken();
+
+#line  1788 &quot;VBNET.ATG&quot; 
+			typeref = new TypeReference(&quot;System.Object&quot;); 
+		} else if (StartOf(25)) {
+			PrimitiveTypeName(
+#line  1789 &quot;VBNET.ATG&quot; 
+out name);
+
+#line  1789 &quot;VBNET.ATG&quot; 
+			typeref = new TypeReference(name); 
+		} else SynErr(224);
+	}
+
+	void ArrayInitializationModifiers(
+#line  1792 &quot;VBNET.ATG&quot; 
+out ArrayList arrayModifiers) {
+
+#line  1794 &quot;VBNET.ATG&quot; 
+		arrayModifiers = new ArrayList();
+		ArrayList dim = new ArrayList();
+		
+		while (
+#line  1798 &quot;VBNET.ATG&quot; 
+IsDims()) {
+			Expect(25);
+			if (StartOf(18)) {
+				InitializationRankList(
+#line  1799 &quot;VBNET.ATG&quot; 
+out dim);
+			}
+
+#line  1801 &quot;VBNET.ATG&quot; 
+			arrayModifiers.Add(dim);
+			
+			Expect(26);
+		}
+
+#line  1806 &quot;VBNET.ATG&quot; 
+		if(arrayModifiers.Count == 0) {
+		 arrayModifiers = null;
+		}
+		
+	}
+
+	void RankList(
+#line  1834 &quot;VBNET.ATG&quot; 
+out int i) {
+
+#line  1835 &quot;VBNET.ATG&quot; 
+		i = 0; 
+		while (la.kind == 12) {
+			lexer.NextToken();
+
+#line  1836 &quot;VBNET.ATG&quot; 
+			++i; 
+		}
+	}
+
+	void Attribute(
+#line  1861 &quot;VBNET.ATG&quot; 
+out ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute) {
+
+#line  1862 &quot;VBNET.ATG&quot; 
+		string qualident; 
+		Qualident(
+#line  1863 &quot;VBNET.ATG&quot; 
+out qualident);
+
+#line  1865 &quot;VBNET.ATG&quot; 
+		ArrayList positional = new ArrayList();
+		ArrayList named      = new ArrayList();
+		string name = qualident;
+		
+		if (la.kind == 25) {
+			AttributeArguments(
+#line  1869 &quot;VBNET.ATG&quot; 
+ref positional, ref named);
+		}
+
+#line  1871 &quot;VBNET.ATG&quot; 
+		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute(name, positional, named);
+		
+	}
+
+	void AttributeArguments(
+#line  1876 &quot;VBNET.ATG&quot; 
+ref ArrayList positional, ref ArrayList named) {
+
+#line  1878 &quot;VBNET.ATG&quot; 
+		bool nameFound = false;
+		string name = &quot;&quot;;
+		Expression expr;
+		
+		Expect(25);
+		if (
+#line  1884 &quot;VBNET.ATG&quot; 
+IsNotClosingParenthesis()) {
+			if (
+#line  1886 &quot;VBNET.ATG&quot; 
+IsNamedAssign()) {
+
+#line  1886 &quot;VBNET.ATG&quot; 
+				nameFound = true; 
+				IdentifierOrKeyword(
+#line  1887 &quot;VBNET.ATG&quot; 
+out name);
+				if (la.kind == 13) {
+					lexer.NextToken();
+				}
+				Expect(11);
+			}
+			Expr(
+#line  1889 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1891 &quot;VBNET.ATG&quot; 
+			if(name == &quot;&quot;) positional.Add(expr);
+			else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				if (
+#line  1897 &quot;VBNET.ATG&quot; 
+IsNamedAssign()) {
+
+#line  1897 &quot;VBNET.ATG&quot; 
+					nameFound = true; 
+					IdentifierOrKeyword(
+#line  1898 &quot;VBNET.ATG&quot; 
+out name);
+					if (la.kind == 13) {
+						lexer.NextToken();
+					}
+					Expect(11);
+				} else if (StartOf(18)) {
+
+#line  1900 &quot;VBNET.ATG&quot; 
+					if (nameFound) Error(&quot;no positional argument after named argument&quot;); 
+				} else SynErr(225);
+				Expr(
+#line  1901 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  1901 &quot;VBNET.ATG&quot; 
+				if(name == &quot;&quot;) positional.Add(expr);
+				else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
+				
+			}
+		}
+		Expect(26);
+	}
+
+	void FormalParameter(
+#line  1971 &quot;VBNET.ATG&quot; 
+out ParameterDeclarationExpression p) {
+
+#line  1973 &quot;VBNET.ATG&quot; 
+		TypeReference type = null;
+		ParamModifiers mod = new ParamModifiers(this);
+		Expression expr = null;
+		p = null;
+		ArrayList arrayModifiers = null;
+		
+		while (StartOf(26)) {
+			ParameterModifier(
+#line  1979 &quot;VBNET.ATG&quot; 
+mod);
+		}
+		Identifier();
+
+#line  1980 &quot;VBNET.ATG&quot; 
+		string parameterName = t.val; 
+		if (
+#line  1981 &quot;VBNET.ATG&quot; 
+IsRank()) {
+			ArrayTypeModifiers(
+#line  1981 &quot;VBNET.ATG&quot; 
+out arrayModifiers);
+		}
+		if (la.kind == 49) {
+			lexer.NextToken();
+			TypeName(
+#line  1982 &quot;VBNET.ATG&quot; 
+out type);
+		}
+
+#line  1984 &quot;VBNET.ATG&quot; 
+		if(type != null) {
+		if (arrayModifiers != null) {
+			if (type.RankSpecifier != null) {
+				Error(&quot;array rank only allowed one time&quot;);
+			} else {
+				type.RankSpecifier = arrayModifiers;
+			}
+		}
+		} else {
+			type = new TypeReference(&quot;System.Object&quot;, arrayModifiers);
+		}
+		
+		if (la.kind == 11) {
+			lexer.NextToken();
+			Expr(
+#line  1996 &quot;VBNET.ATG&quot; 
+out expr);
+		}
+
+#line  1998 &quot;VBNET.ATG&quot; 
+		mod.Check();
+		p = new ParameterDeclarationExpression(type, parameterName, mod, expr);
+		
+	}
+
+	void ParameterModifier(
+#line  2708 &quot;VBNET.ATG&quot; 
+ParamModifiers m) {
+		if (la.kind == 56) {
+			lexer.NextToken();
+
+#line  2709 &quot;VBNET.ATG&quot; 
+			m.Add(ParamModifier.ByVal); 
+		} else if (la.kind == 54) {
+			lexer.NextToken();
+
+#line  2710 &quot;VBNET.ATG&quot; 
+			m.Add(ParamModifier.ByRef); 
+		} else if (la.kind == 138) {
+			lexer.NextToken();
+
+#line  2711 &quot;VBNET.ATG&quot; 
+			m.Add(ParamModifier.Optional); 
+		} else if (la.kind == 145) {
+			lexer.NextToken();
+
+#line  2712 &quot;VBNET.ATG&quot; 
+			m.Add(ParamModifier.ParamArray); 
+		} else SynErr(226);
+	}
+
+	void Statement() {
+
+#line  2023 &quot;VBNET.ATG&quot; 
+		Statement stmt;
+		string label = String.Empty;
+		
+		
+		if (
+#line  2027 &quot;VBNET.ATG&quot; 
+IsLabel()) {
+			LabelName(
+#line  2027 &quot;VBNET.ATG&quot; 
+out label);
+
+#line  2029 &quot;VBNET.ATG&quot; 
+			labelStatement = new LabelStatement(t.val);
+			compilationUnit.AddChild(labelStatement);
+			
+			Expect(13);
+			if (StartOf(15)) {
+
+#line  2032 &quot;VBNET.ATG&quot; 
+				isLabel = true; 
+				Statement();
+			}
+		} else if (StartOf(27)) {
+			EmbeddedStatement(
+#line  2033 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  2033 &quot;VBNET.ATG&quot; 
+			updateLabelStatement(stmt); 
+		} else if (StartOf(28)) {
+			LocalDeclarationStatement(
+#line  2034 &quot;VBNET.ATG&quot; 
+out stmt);
+
+#line  2034 &quot;VBNET.ATG&quot; 
+			updateLabelStatement(stmt); 
+		} else SynErr(227);
+	}
+
+	void LabelName(
+#line  2396 &quot;VBNET.ATG&quot; 
+out string name) {
+
+#line  2398 &quot;VBNET.ATG&quot; 
+		name = String.Empty;
+		
+		if (StartOf(9)) {
+			Identifier();
+
+#line  2400 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+		} else if (la.kind == 5) {
+			lexer.NextToken();
+
+#line  2401 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+		} else SynErr(228);
+	}
+
+	void EmbeddedStatement(
+#line  2071 &quot;VBNET.ATG&quot; 
+out Statement statement) {
+
+#line  2073 &quot;VBNET.ATG&quot; 
+		Statement embeddedStatement = null;
+		statement = null;
+		Expression expr = null;
+		string name = String.Empty;
+		ArrayList p = null;
+		
+		switch (la.kind) {
+		case 95: {
+			lexer.NextToken();
+
+#line  2079 &quot;VBNET.ATG&quot; 
+			ExitType exitType = ExitType.None; 
+			switch (la.kind) {
+			case 169: {
+				lexer.NextToken();
+
+#line  2081 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Sub; 
+				break;
+			}
+			case 101: {
+				lexer.NextToken();
+
+#line  2083 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Function; 
+				break;
+			}
+			case 148: {
+				lexer.NextToken();
+
+#line  2085 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Property; 
+				break;
+			}
+			case 84: {
+				lexer.NextToken();
+
+#line  2087 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Do; 
+				break;
+			}
+			case 99: {
+				lexer.NextToken();
+
+#line  2089 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.For; 
+				break;
+			}
+			case 176: {
+				lexer.NextToken();
+
+#line  2091 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Try; 
+				break;
+			}
+			case 183: {
+				lexer.NextToken();
+
+#line  2093 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.While; 
+				break;
+			}
+			case 157: {
+				lexer.NextToken();
+
+#line  2095 &quot;VBNET.ATG&quot; 
+				exitType = ExitType.Select; 
+				break;
+			}
+			default: SynErr(229); break;
+			}
+
+#line  2097 &quot;VBNET.ATG&quot; 
+			statement = new ExitStatement(exitType); 
+			break;
+		}
+		case 176: {
+			TryStatement(
+#line  2098 &quot;VBNET.ATG&quot; 
+out statement);
+			break;
+		}
+		case 173: {
+			lexer.NextToken();
+			if (StartOf(18)) {
+				Expr(
+#line  2100 &quot;VBNET.ATG&quot; 
+out expr);
+			}
+
+#line  2100 &quot;VBNET.ATG&quot; 
+			statement = new ThrowStatement(expr); 
+			break;
+		}
+		case 156: {
+			lexer.NextToken();
+			if (StartOf(18)) {
+				Expr(
+#line  2102 &quot;VBNET.ATG&quot; 
+out expr);
+			}
+
+#line  2102 &quot;VBNET.ATG&quot; 
+			statement = new ReturnStatement(expr); 
+			break;
+		}
+		case 170: {
+			lexer.NextToken();
+			Expr(
+#line  2104 &quot;VBNET.ATG&quot; 
+out expr);
+			EndOfStmt();
+			Block(
+#line  2104 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+			Expect(89);
+			Expect(170);
+
+#line  2105 &quot;VBNET.ATG&quot; 
+			statement = new LockStatement(expr, embeddedStatement); 
+			break;
+		}
+		case 151: {
+			lexer.NextToken();
+			Identifier();
+
+#line  2107 &quot;VBNET.ATG&quot; 
+			name = t.val; 
+			if (la.kind == 25) {
+				lexer.NextToken();
+				if (StartOf(17)) {
+					ArgumentList(
+#line  2108 &quot;VBNET.ATG&quot; 
+out p);
+				}
+				Expect(26);
+			}
+
+#line  2109 &quot;VBNET.ATG&quot; 
+			statement = new RaiseEventStatement(name, p); 
+			break;
+		}
+		case 184: {
+			WithStatement(
+#line  2111 &quot;VBNET.ATG&quot; 
+out statement);
+			break;
+		}
+		case 43: {
+			lexer.NextToken();
+
+#line  2113 &quot;VBNET.ATG&quot; 
+			Expression handlerExpr = null; 
+			Expr(
+#line  2114 &quot;VBNET.ATG&quot; 
+out expr);
+			Expect(12);
+			Expr(
+#line  2114 &quot;VBNET.ATG&quot; 
+out handlerExpr);
+
+#line  2116 &quot;VBNET.ATG&quot; 
+			statement = new AddHandlerStatement(expr, handlerExpr);
+			
+			break;
+		}
+		case 154: {
+			lexer.NextToken();
+
+#line  2119 &quot;VBNET.ATG&quot; 
+			Expression handlerExpr = null; 
+			Expr(
+#line  2120 &quot;VBNET.ATG&quot; 
+out expr);
+			Expect(12);
+			Expr(
+#line  2120 &quot;VBNET.ATG&quot; 
+out handlerExpr);
+
+#line  2122 &quot;VBNET.ATG&quot; 
+			statement = new RemoveHandlerStatement(expr, handlerExpr);
+			
+			break;
+		}
+		case 183: {
+			lexer.NextToken();
+			Expr(
+#line  2125 &quot;VBNET.ATG&quot; 
+out expr);
+			EndOfStmt();
+			Block(
+#line  2126 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+			Expect(89);
+			Expect(183);
+
+#line  2128 &quot;VBNET.ATG&quot; 
+			statement = new WhileStatement(expr, embeddedStatement);
+			
+			break;
+		}
+		case 84: {
+			lexer.NextToken();
+
+#line  2133 &quot;VBNET.ATG&quot; 
+			ConditionType conditionType = ConditionType.None;
+			
+			if (la.kind == 179 || la.kind == 183) {
+				WhileOrUntil(
+#line  2136 &quot;VBNET.ATG&quot; 
+out conditionType);
+				Expr(
+#line  2136 &quot;VBNET.ATG&quot; 
+out expr);
+				EndOfStmt();
+				Block(
+#line  2137 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+				Expect(119);
+
+#line  2140 &quot;VBNET.ATG&quot; 
+				statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.Start);
+				
+			} else if (la.kind == 1 || la.kind == 13) {
+				EndOfStmt();
+				Block(
+#line  2144 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+				Expect(119);
+				if (la.kind == 179 || la.kind == 183) {
+					WhileOrUntil(
+#line  2145 &quot;VBNET.ATG&quot; 
+out conditionType);
+					Expr(
+#line  2145 &quot;VBNET.ATG&quot; 
+out expr);
+				}
+
+#line  2147 &quot;VBNET.ATG&quot; 
+				statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.End);
+				
+			} else SynErr(230);
+			break;
+		}
+		case 99: {
+			lexer.NextToken();
+
+#line  2152 &quot;VBNET.ATG&quot; 
+			Expression group = null;
+			LoopControlVariableExpression loopControlExpr = null;
+			
+			if (la.kind == 86) {
+				lexer.NextToken();
+				LoopControlVariable(
+#line  2157 &quot;VBNET.ATG&quot; 
+out loopControlExpr);
+				Expect(110);
+				Expr(
+#line  2158 &quot;VBNET.ATG&quot; 
+out group);
+				EndOfStmt();
+				Block(
+#line  2159 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+				Expect(129);
+				if (StartOf(18)) {
+					Expr(
+#line  2160 &quot;VBNET.ATG&quot; 
+out expr);
+				}
+
+#line  2162 &quot;VBNET.ATG&quot; 
+				statement = new ForeachStatement(loopControlExpr, group, embeddedStatement, expr);
+				
+			} else if (StartOf(9)) {
+
+#line  2166 &quot;VBNET.ATG&quot; 
+				Expression start = null;
+				Expression end = null;
+				Expression step = null;
+				Expression nextExpr = null;
+				ArrayList nextExpressions = null;
+				
+				LoopControlVariable(
+#line  2172 &quot;VBNET.ATG&quot; 
+out loopControlExpr);
+				Expect(11);
+				Expr(
+#line  2173 &quot;VBNET.ATG&quot; 
+out start);
+				Expect(174);
+				Expr(
+#line  2173 &quot;VBNET.ATG&quot; 
+out end);
+				if (la.kind == 164) {
+					lexer.NextToken();
+					Expr(
+#line  2173 &quot;VBNET.ATG&quot; 
+out step);
+				}
+				EndOfStmt();
+				Block(
+#line  2174 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+				Expect(129);
+				if (StartOf(18)) {
+					Expr(
+#line  2177 &quot;VBNET.ATG&quot; 
+out nextExpr);
+
+#line  2177 &quot;VBNET.ATG&quot; 
+					nextExpressions = new ArrayList(); nextExpressions.Add(nextExpr); 
+					while (la.kind == 12) {
+						lexer.NextToken();
+						Expr(
+#line  2178 &quot;VBNET.ATG&quot; 
+out nextExpr);
+
+#line  2178 &quot;VBNET.ATG&quot; 
+						nextExpressions.Add(nextExpr); 
+					}
+				}
+
+#line  2181 &quot;VBNET.ATG&quot; 
+				statement = new ForStatement(loopControlExpr, start, end, step, embeddedStatement, nextExpressions);
+				
+			} else SynErr(231);
+			break;
+		}
+		case 93: {
+			lexer.NextToken();
+			Expr(
+#line  2185 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2185 &quot;VBNET.ATG&quot; 
+			statement = new ErrorStatement(expr); 
+			break;
+		}
+		case 153: {
+			lexer.NextToken();
+
+#line  2187 &quot;VBNET.ATG&quot; 
+			Expression clause = null; 
+			if (la.kind == 146) {
+				lexer.NextToken();
+			}
+			Expr(
+#line  2188 &quot;VBNET.ATG&quot; 
+out clause);
+
+#line  2190 &quot;VBNET.ATG&quot; 
+			ArrayList clauses = new ArrayList();
+			clauses.Add(clause);
+			/*ReDimStatement reDimStatement = new ReDimStatement(clauses);*/
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Expr(
+#line  2194 &quot;VBNET.ATG&quot; 
+out clause);
+
+#line  2194 &quot;VBNET.ATG&quot; 
+				clauses.Add(clause); 
+			}
+			break;
+		}
+		case 92: {
+			lexer.NextToken();
+			Expr(
+#line  2197 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2199 &quot;VBNET.ATG&quot; 
+			ArrayList arrays = new ArrayList();
+			arrays.Add(expr);
+			EraseStatement eraseStatement = new EraseStatement(arrays);
+			
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Expr(
+#line  2204 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2204 &quot;VBNET.ATG&quot; 
+				arrays.Add(expr); 
+			}
+
+#line  2205 &quot;VBNET.ATG&quot; 
+			statement = eraseStatement; 
+			break;
+		}
+		case 165: {
+			lexer.NextToken();
+
+#line  2207 &quot;VBNET.ATG&quot; 
+			statement = new StopStatement(); 
+			break;
+		}
+		case 107: {
+			lexer.NextToken();
+			Expr(
+#line  2209 &quot;VBNET.ATG&quot; 
+out expr);
+			if (la.kind == 172) {
+				lexer.NextToken();
+			}
+			if (
+#line  2211 &quot;VBNET.ATG&quot; 
+IsEndStmtAhead()) {
+				Expect(89);
+
+#line  2211 &quot;VBNET.ATG&quot; 
+				statement = new IfStatement(expr, new EndStatement()); 
+			} else if (la.kind == 1 || la.kind == 13) {
+				EndOfStmt();
+				Block(
+#line  2214 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2216 &quot;VBNET.ATG&quot; 
+				ArrayList elseIfSections = new ArrayList();
+				IfStatement ifStatement = new IfStatement(expr, embeddedStatement);
+				
+				while (la.kind == 88 || 
+#line  2221 &quot;VBNET.ATG&quot; 
+IsElseIf()) {
+					if (
+#line  2221 &quot;VBNET.ATG&quot; 
+IsElseIf()) {
+						Expect(87);
+						Expect(107);
+					} else {
+						lexer.NextToken();
+					}
+
+#line  2224 &quot;VBNET.ATG&quot; 
+					Expression condition = null; Statement block = null; 
+					Expr(
+#line  2225 &quot;VBNET.ATG&quot; 
+out condition);
+					if (la.kind == 172) {
+						lexer.NextToken();
+					}
+					EndOfStmt();
+					Block(
+#line  2226 &quot;VBNET.ATG&quot; 
+out block);
+
+#line  2228 &quot;VBNET.ATG&quot; 
+					ElseIfSection elseIfSection = new ElseIfSection(condition, block);
+					elseIfSections.Add(elseIfSection);
+					
+				}
+				if (la.kind == 87) {
+					lexer.NextToken();
+					EndOfStmt();
+					Block(
+#line  2234 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2236 &quot;VBNET.ATG&quot; 
+					ifStatement.EmbeddedElseStatement = embeddedStatement;
+					
+				}
+				Expect(89);
+				Expect(107);
+
+#line  2240 &quot;VBNET.ATG&quot; 
+				ifStatement.ElseIfStatements = elseIfSections;
+				statement = ifStatement;
+				
+			} else if (StartOf(27)) {
+				EmbeddedStatement(
+#line  2244 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2246 &quot;VBNET.ATG&quot; 
+				SimpleIfStatement ifStatement = new SimpleIfStatement(expr);
+				ArrayList statements = new ArrayList();
+				statements.Add(embeddedStatement);
+				ifStatement.Statements = statements;
+				
+				while (la.kind == 13) {
+					lexer.NextToken();
+					EmbeddedStatement(
+#line  2251 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2251 &quot;VBNET.ATG&quot; 
+					statements.Add(embeddedStatement); 
+				}
+				if (la.kind == 87) {
+					lexer.NextToken();
+					if (StartOf(27)) {
+						EmbeddedStatement(
+#line  2253 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+					}
+
+#line  2255 &quot;VBNET.ATG&quot; 
+					ArrayList elseStatements = new ArrayList();
+					elseStatements.Add(embeddedStatement);
+					ifStatement.ElseStatements = elseStatements;
+					
+					while (la.kind == 13) {
+						lexer.NextToken();
+						EmbeddedStatement(
+#line  2260 &quot;VBNET.ATG&quot; 
+out embeddedStatement);
+
+#line  2261 &quot;VBNET.ATG&quot; 
+						elseStatements.Add(embeddedStatement); 
+					}
+				}
+
+#line  2264 &quot;VBNET.ATG&quot; 
+				statement = ifStatement; 
+			} else SynErr(232);
+			break;
+		}
+		case 157: {
+			lexer.NextToken();
+			if (la.kind == 58) {
+				lexer.NextToken();
+			}
+			Expr(
+#line  2267 &quot;VBNET.ATG&quot; 
+out expr);
+			EndOfStmt();
+
+#line  2269 &quot;VBNET.ATG&quot; 
+			ArrayList selectSections = new ArrayList();
+			Statement block = null;
+			
+			while (la.kind == 58) {
+
+#line  2273 &quot;VBNET.ATG&quot; 
+				ArrayList caseClauses = null; 
+				lexer.NextToken();
+				CaseClauses(
+#line  2274 &quot;VBNET.ATG&quot; 
+out caseClauses);
+				if (
+#line  2274 &quot;VBNET.ATG&quot; 
+IsNotStatementSeparator()) {
+					lexer.NextToken();
+				}
+				EndOfStmt();
+
+#line  2276 &quot;VBNET.ATG&quot; 
+				SelectSection selectSection = new SelectSection();
+				selectSection.CaseClauses = caseClauses;
+				compilationUnit.BlockStart(selectSection);
+				
+				Block(
+#line  2280 &quot;VBNET.ATG&quot; 
+out block);
+
+#line  2282 &quot;VBNET.ATG&quot; 
+				selectSection.EmbeddedStatement = block;
+				compilationUnit.BlockEnd();
+				selectSections.Add(selectSection);
+				
+			}
+
+#line  2287 &quot;VBNET.ATG&quot; 
+			statement = new SelectStatement(expr, selectSections); 
+			Expect(89);
+			Expect(157);
+			break;
+		}
+		case 136: {
+
+#line  2289 &quot;VBNET.ATG&quot; 
+			OnErrorStatement onErrorStatement = null; 
+			OnErrorStatement(
+#line  2290 &quot;VBNET.ATG&quot; 
+out onErrorStatement);
+
+#line  2290 &quot;VBNET.ATG&quot; 
+			statement = onErrorStatement; 
+			break;
+		}
+		case 105: {
+
+#line  2291 &quot;VBNET.ATG&quot; 
+			GoToStatement goToStatement = null; 
+			GoToStatement(
+#line  2292 &quot;VBNET.ATG&quot; 
+out goToStatement);
+
+#line  2292 &quot;VBNET.ATG&quot; 
+			statement = goToStatement; 
+			break;
+		}
+		case 155: {
+
+#line  2293 &quot;VBNET.ATG&quot; 
+			ResumeStatement resumeStatement = null; 
+			ResumeStatement(
+#line  2294 &quot;VBNET.ATG&quot; 
+out resumeStatement);
+
+#line  2294 &quot;VBNET.ATG&quot; 
+			statement = resumeStatement; 
+			break;
+		}
+		case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 14: case 15: case 16: case 25: case 44: case 52: case 53: case 55: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 69: case 70: case 71: case 73: case 74: case 75: case 76: case 77: case 78: case 83: case 85: case 97: case 103: case 112: case 118: case 120: case 125: case 126: case 128: case 131: case 161: case 162: case 167: case 171: case 175: case 177: {
+
+#line  2297 &quot;VBNET.ATG&quot; 
+			Expression val = null;
+			AssignmentOperatorType op;
+			
+			bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
+			                        la.kind == Tokens.Not   || la.kind == Tokens.Times;
+			
+			UnaryExpr(
+#line  2303 &quot;VBNET.ATG&quot; 
+out expr);
+			if (StartOf(14)) {
+				AssignmentOperator(
+#line  2305 &quot;VBNET.ATG&quot; 
+out op);
+				Expr(
+#line  2305 &quot;VBNET.ATG&quot; 
+out val);
+
+#line  2305 &quot;VBNET.ATG&quot; 
+				expr = new AssignmentExpression(expr, op, val); 
+			} else if (la.kind == 1 || la.kind == 13 || la.kind == 87) {
+
+#line  2306 &quot;VBNET.ATG&quot; 
+				if (mustBeAssignment) Error(&quot;error in assignment.&quot;); 
+			} else SynErr(233);
+
+#line  2309 &quot;VBNET.ATG&quot; 
+			// a field reference expression that stands alone is a
+			// invocation expression without parantheses and arguments
+			if(expr is FieldReferenceOrInvocationExpression) {
+				expr = new InvocationExpression(expr, new ArrayList());
+			}
+			statement = new StatementExpression(expr);
+			
+			break;
+		}
+		case 57: {
+			lexer.NextToken();
+			UnaryExpr(
+#line  2316 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2316 &quot;VBNET.ATG&quot; 
+			statement = new StatementExpression(expr); 
+			break;
+		}
+		default: SynErr(234); break;
+		}
+	}
+
+	void LocalDeclarationStatement(
+#line  2038 &quot;VBNET.ATG&quot; 
+out Statement statement) {
+
+#line  2040 &quot;VBNET.ATG&quot; 
+		Modifiers m = new Modifiers(this);
+		ArrayList vars = new ArrayList();
+		LocalVariableDeclaration localVariableDeclaration;
+		bool dimfound = false;
+		
+		while (la.kind == 72 || la.kind == 82 || la.kind == 163) {
+			if (la.kind == 72) {
+				lexer.NextToken();
+
+#line  2047 &quot;VBNET.ATG&quot; 
+				m.Add(Modifier.Constant); 
+			} else if (la.kind == 163) {
+				lexer.NextToken();
+
+#line  2048 &quot;VBNET.ATG&quot; 
+				m.Add(Modifier.Static); 
+			} else {
+				lexer.NextToken();
+
+#line  2049 &quot;VBNET.ATG&quot; 
+				dimfound = true; 
+			}
+		}
+
+#line  2052 &quot;VBNET.ATG&quot; 
+		if(dimfound &amp;&amp; (m.Modifier &amp; Modifier.Constant) != 0) {
+		Error(&quot;Dim is not allowed on constants.&quot;);
+		}
+		
+		if(m.isNone &amp;&amp; dimfound == false) {
+			Error(&quot;Const, Dim or Static expected&quot;);
+		}
+		
+		localVariableDeclaration = new LocalVariableDeclaration(m.Modifier);
+		localVariableDeclaration.StartLocation = t.Location;
+		
+		VariableDeclarator(
+#line  2063 &quot;VBNET.ATG&quot; 
+vars);
+		while (la.kind == 12) {
+			lexer.NextToken();
+			VariableDeclarator(
+#line  2064 &quot;VBNET.ATG&quot; 
+vars);
+		}
+
+#line  2066 &quot;VBNET.ATG&quot; 
+		localVariableDeclaration.Variables = vars;
+		statement = localVariableDeclaration;
+		
+	}
+
+	void TryStatement(
+#line  2489 &quot;VBNET.ATG&quot; 
+out Statement tryStatement) {
+
+#line  2491 &quot;VBNET.ATG&quot; 
+		Statement blockStmt = null, finallyStmt = null;
+		ArrayList catchClauses = null;
+		
+		Expect(176);
+		EndOfStmt();
+		Block(
+#line  2495 &quot;VBNET.ATG&quot; 
+out blockStmt);
+		if (la.kind == 59 || la.kind == 89 || la.kind == 98) {
+			CatchClauses(
+#line  2497 &quot;VBNET.ATG&quot; 
+out catchClauses);
+			if (la.kind == 98) {
+				lexer.NextToken();
+				EndOfStmt();
+				Block(
+#line  2498 &quot;VBNET.ATG&quot; 
+out finallyStmt);
+			}
+		} else if (la.kind == 98) {
+			lexer.NextToken();
+			EndOfStmt();
+			Block(
+#line  2499 &quot;VBNET.ATG&quot; 
+out finallyStmt);
+		} else SynErr(235);
+		Expect(89);
+		Expect(176);
+
+#line  2503 &quot;VBNET.ATG&quot; 
+		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
+		
+	}
+
+	void WithStatement(
+#line  2467 &quot;VBNET.ATG&quot; 
+out Statement withStatement) {
+
+#line  2469 &quot;VBNET.ATG&quot; 
+		Statement blockStmt = null;
+		Expression expr = null;
+		
+		Expect(184);
+
+#line  2472 &quot;VBNET.ATG&quot; 
+		Point start = t.Location; 
+		Expr(
+#line  2473 &quot;VBNET.ATG&quot; 
+out expr);
+		EndOfStmt();
+
+#line  2475 &quot;VBNET.ATG&quot; 
+		withStatement = new WithStatement(expr);
+		withStatement.StartLocation = start;
+		withStatements.Push(withStatement);
+		
+		Block(
+#line  2479 &quot;VBNET.ATG&quot; 
+out blockStmt);
+
+#line  2481 &quot;VBNET.ATG&quot; 
+		((WithStatement)withStatement).Body = (BlockStatement)blockStmt;
+		withStatements.Pop();
+		
+		Expect(89);
+		Expect(184);
+
+#line  2485 &quot;VBNET.ATG&quot; 
+		withStatement.EndLocation = t.Location; 
+	}
+
+	void WhileOrUntil(
+#line  2460 &quot;VBNET.ATG&quot; 
+out ConditionType conditionType) {
+
+#line  2461 &quot;VBNET.ATG&quot; 
+		conditionType = ConditionType.None; 
+		if (la.kind == 183) {
+			lexer.NextToken();
+
+#line  2462 &quot;VBNET.ATG&quot; 
+			conditionType = ConditionType.While; 
+		} else if (la.kind == 179) {
+			lexer.NextToken();
+
+#line  2463 &quot;VBNET.ATG&quot; 
+			conditionType = ConditionType.Until; 
+		} else SynErr(236);
+	}
+
+	void LoopControlVariable(
+#line  2320 &quot;VBNET.ATG&quot; 
+out LoopControlVariableExpression loopExpr) {
+
+#line  2322 &quot;VBNET.ATG&quot; 
+		loopExpr = null;
+		//Expression expr = null;
+		TypeReference type = null;
+		ArrayList arrayModifiers = null;
+		string name;
+		
+		Qualident(
+#line  2328 &quot;VBNET.ATG&quot; 
+out name);
+		if (
+#line  2329 &quot;VBNET.ATG&quot; 
+IsRank()) {
+			ArrayTypeModifiers(
+#line  2329 &quot;VBNET.ATG&quot; 
+out arrayModifiers);
+		}
+		if (la.kind == 49) {
+			lexer.NextToken();
+			TypeName(
+#line  2330 &quot;VBNET.ATG&quot; 
+out type);
+
+#line  2330 &quot;VBNET.ATG&quot; 
+			if (name.IndexOf('.') &gt; 0) { Error(&quot;No type def for 'for each' member indexer allowed.&quot;); } 
+		}
+
+#line  2332 &quot;VBNET.ATG&quot; 
+		if(type != null) {
+		if(type.RankSpecifier != null &amp;&amp; arrayModifiers != null) {
+			Error(&quot;array rank only allowed one time&quot;);
+		} else {
+			type.RankSpecifier = arrayModifiers;
+		}
+		} else {
+			type = new TypeReference(&quot;Integer&quot;, arrayModifiers);
+		}
+		loopExpr = new LoopControlVariableExpression(name, type);
+		
+	}
+
+	void CaseClauses(
+#line  2416 &quot;VBNET.ATG&quot; 
+out ArrayList caseClauses) {
+
+#line  2418 &quot;VBNET.ATG&quot; 
+		caseClauses = null;
+		CaseClause caseClause = null;
+		
+		CaseClause(
+#line  2421 &quot;VBNET.ATG&quot; 
+out caseClause);
+
+#line  2423 &quot;VBNET.ATG&quot; 
+		caseClauses = new ArrayList();
+		caseClauses.Add(caseClause);
+		
+		while (la.kind == 12) {
+			lexer.NextToken();
+			CaseClause(
+#line  2426 &quot;VBNET.ATG&quot; 
+out caseClause);
+
+#line  2426 &quot;VBNET.ATG&quot; 
+			caseClauses.Add(caseClause); 
+		}
+	}
+
+	void OnErrorStatement(
+#line  2346 &quot;VBNET.ATG&quot; 
+out OnErrorStatement stmt) {
+
+#line  2348 &quot;VBNET.ATG&quot; 
+		stmt = null;
+		GoToStatement goToStatement = null;
+		
+		Expect(136);
+		Expect(93);
+		if (
+#line  2354 &quot;VBNET.ATG&quot; 
+IsNegativeLabelName()) {
+			Expect(105);
+			Expect(15);
+			Expect(5);
+
+#line  2356 &quot;VBNET.ATG&quot; 
+			long intLabel = Int64.Parse(t.val);
+			if(intLabel != 1) {
+				Error(&quot;invalid label in on error statement.&quot;);
+			}
+			stmt = new OnErrorStatement(new GoToStatement((intLabel * -1).ToString()));
+			
+		} else if (la.kind == 105) {
+			GoToStatement(
+#line  2362 &quot;VBNET.ATG&quot; 
+out goToStatement);
+
+#line  2364 &quot;VBNET.ATG&quot; 
+			string val = goToStatement.LabelName;
+			
+			// if value is numeric, make sure that is 0
+			try {
+				long intLabel = Int64.Parse(val);
+				if(intLabel != 0) {
+					Error(&quot;invalid label in on error statement.&quot;);
+				}
+			} catch {
+			}
+			stmt = new OnErrorStatement(goToStatement);
+			
+		} else if (la.kind == 155) {
+			lexer.NextToken();
+			Expect(129);
+
+#line  2378 &quot;VBNET.ATG&quot; 
+			stmt = new OnErrorStatement(new ResumeStatement(true));
+			
+		} else SynErr(237);
+	}
+
+	void GoToStatement(
+#line  2384 &quot;VBNET.ATG&quot; 
+out GoToStatement goToStatement) {
+
+#line  2386 &quot;VBNET.ATG&quot; 
+		string label = String.Empty;
+		
+		Expect(105);
+		LabelName(
+#line  2389 &quot;VBNET.ATG&quot; 
+out label);
+
+#line  2391 &quot;VBNET.ATG&quot; 
+		goToStatement = new GoToStatement(label);
+		
+	}
+
+	void ResumeStatement(
+#line  2405 &quot;VBNET.ATG&quot; 
+out ResumeStatement resumeStatement) {
+
+#line  2407 &quot;VBNET.ATG&quot; 
+		resumeStatement = null;
+		string label = String.Empty;
+		
+		if (
+#line  2410 &quot;VBNET.ATG&quot; 
+IsResumeNext()) {
+			Expect(155);
+			Expect(129);
+
+#line  2411 &quot;VBNET.ATG&quot; 
+			resumeStatement = new ResumeStatement(true); 
+		} else if (la.kind == 155) {
+			lexer.NextToken();
+			if (StartOf(29)) {
+				LabelName(
+#line  2412 &quot;VBNET.ATG&quot; 
+out label);
+			}
+
+#line  2412 &quot;VBNET.ATG&quot; 
+			resumeStatement = new ResumeStatement(label); 
+		} else SynErr(238);
+	}
+
+	void CaseClause(
+#line  2430 &quot;VBNET.ATG&quot; 
+out CaseClause caseClause) {
+
+#line  2432 &quot;VBNET.ATG&quot; 
+		Expression expr = null;
+		Expression sexpr = null;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		caseClause = null;
+		
+		if (la.kind == 87) {
+			lexer.NextToken();
+
+#line  2438 &quot;VBNET.ATG&quot; 
+			caseClause = new CaseClause(true); 
+		} else if (StartOf(30)) {
+			if (la.kind == 114) {
+				lexer.NextToken();
+			}
+			switch (la.kind) {
+			case 28: {
+				lexer.NextToken();
+
+#line  2442 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.LessThan; 
+				break;
+			}
+			case 27: {
+				lexer.NextToken();
+
+#line  2443 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.GreaterThan; 
+				break;
+			}
+			case 31: {
+				lexer.NextToken();
+
+#line  2444 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.LessThanOrEqual; 
+				break;
+			}
+			case 30: {
+				lexer.NextToken();
+
+#line  2445 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.GreaterThanOrEqual; 
+				break;
+			}
+			case 11: {
+				lexer.NextToken();
+
+#line  2446 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.Equality; 
+				break;
+			}
+			case 29: {
+				lexer.NextToken();
+
+#line  2447 &quot;VBNET.ATG&quot; 
+				op = BinaryOperatorType.InEquality; 
+				break;
+			}
+			default: SynErr(239); break;
+			}
+			Expr(
+#line  2449 &quot;VBNET.ATG&quot; 
+out expr);
+
+#line  2451 &quot;VBNET.ATG&quot; 
+			caseClause = new CaseClause(op, expr);
+			
+		} else if (StartOf(18)) {
+			Expr(
+#line  2453 &quot;VBNET.ATG&quot; 
+out expr);
+			if (la.kind == 174) {
+				lexer.NextToken();
+				Expr(
+#line  2453 &quot;VBNET.ATG&quot; 
+out sexpr);
+			}
+
+#line  2455 &quot;VBNET.ATG&quot; 
+			caseClause = new CaseClause(expr, sexpr);
+			
+		} else SynErr(240);
+	}
+
+	void CatchClauses(
+#line  2508 &quot;VBNET.ATG&quot; 
+out ArrayList catchClauses) {
+
+#line  2510 &quot;VBNET.ATG&quot; 
+		catchClauses = new ArrayList();
+		TypeReference type = null;
+		Statement blockStmt = null;
+		Expression expr = null;
+		string name = String.Empty;
+		
+		while (la.kind == 59) {
+			lexer.NextToken();
+			if (StartOf(9)) {
+				Identifier();
+
+#line  2518 &quot;VBNET.ATG&quot; 
+				name = t.val; 
+				if (la.kind == 49) {
+					lexer.NextToken();
+					TypeName(
+#line  2518 &quot;VBNET.ATG&quot; 
+out type);
+				}
+			}
+			if (la.kind == 182) {
+				lexer.NextToken();
+				Expr(
+#line  2519 &quot;VBNET.ATG&quot; 
+out expr);
+			}
+			EndOfStmt();
+			Block(
+#line  2521 &quot;VBNET.ATG&quot; 
+out blockStmt);
+
+#line  2522 &quot;VBNET.ATG&quot; 
+			catchClauses.Add(new CatchClause(type, name, blockStmt, expr)); 
+		}
+	}
+
 
-#line  431 &quot;VBNET.ATG&quot; 
-		compilationUnit = new CompilationUnit();
-		withStatements = new Stack();
-		
-		while (la.kind == 1) {
-			lexer.NextToken();
-		}
-		while (la.kind == 137) {
-			OptionStmt();
-		}
-		while (la.kind == 109) {
-			ImportsStmt();
-		}
-		while (
-#line  437 &quot;VBNET.ATG&quot; 
-IsGlobalAttrTarget()) {
-			GlobalAttributeSection();
-		}
-		while (StartOf(1)) {
-			NamespaceMemberDecl();
-		}
-		Expect(0);
-	}
 
-	void OptionStmt() {
-
-#line  442 &quot;VBNET.ATG&quot; 
-		INode node = null; bool val = true; 
-		Expect(137);
-
-#line  443 &quot;VBNET.ATG&quot; 
-		Point startPos = t.Location; 
-		if (la.kind == 96) {
-			lexer.NextToken();
-			if (la.kind == 135 || la.kind == 136) {
-				OptionValue(
-#line  445 &quot;VBNET.ATG&quot; 
-ref val);
-			}
-
-#line  446 &quot;VBNET.ATG&quot; 
-			node = new OptionExplicitDeclaration(val); 
-		} else if (la.kind == 166) {
-			lexer.NextToken();
-			if (la.kind == 135 || la.kind == 136) {
-				OptionValue(
-#line  448 &quot;VBNET.ATG&quot; 
-ref val);
-			}
-
-#line  449 &quot;VBNET.ATG&quot; 
-			node = new OptionStrictDeclaration(val); 
-		} else if (la.kind == 71) {
-			lexer.NextToken();
-			if (la.kind == 52) {
-				lexer.NextToken();
-
-#line  451 &quot;VBNET.ATG&quot; 
-				node = new OptionCompareDeclaration(CompareType.Binary); 
-			} else if (la.kind == 171) {
-				lexer.NextToken();
-
-#line  452 &quot;VBNET.ATG&quot; 
-				node = new OptionCompareDeclaration(CompareType.Text); 
-			} else SynErr(189);
-		} else SynErr(190);
-		EndOfStmt();
-
-#line  457 &quot;VBNET.ATG&quot; 
-		node.StartLocation = startPos;
-		node.EndLocation   = t.Location;
-		compilationUnit.AddChild(node);
-		
-	}
-
-	void ImportsStmt() {
-
-#line  481 &quot;VBNET.ATG&quot; 
-		ArrayList importClauses = new ArrayList();
-		importedNamespaces = new ArrayList();
-		object importClause;
-		
-		Expect(109);
-
-#line  487 &quot;VBNET.ATG&quot; 
-		Point startPos = t.Location;
-		ImportsStatement importsStatement = new ImportsStatement(null);
-		
-		ImportClause(
-#line  490 &quot;VBNET.ATG&quot; 
-out importClause);
-
-#line  490 &quot;VBNET.ATG&quot; 
-		importClauses.Add(importClause); 
-		while (la.kind == 12) {
-			lexer.NextToken();
-			ImportClause(
-#line  492 &quot;VBNET.ATG&quot; 
-out importClause);
-
-#line  492 &quot;VBNET.ATG&quot; 
-			importClauses.Add(importClause); 
-		}
-		EndOfStmt();
-
-#line  496 &quot;VBNET.ATG&quot; 
-		importsStatement.ImportClauses = importClauses;
-		importsStatement.StartLocation = startPos;
-		importsStatement.EndLocation   = t.Location;
-		compilationUnit.AddChild(importsStatement);
-		
-	}
-
-	void GlobalAttributeSection() {
-
-#line  1840 &quot;VBNET.ATG&quot; 
-		Point startPos = t.Location; 
-		Expect(28);
-		if (la.kind == 50) {
-			lexer.NextToken();
-		} else if (la.kind == 122) {
-			lexer.NextToken();
-		} else SynErr(191);
-
-#line  1843 &quot;VBNET.ATG&quot; 
-		string attributeTarget = t.val.ToLower();
-		ArrayList attributes = new ArrayList();
-		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
-		
-		Expect(13);
-		Attribute(
-#line  1847 &quot;VBNET.ATG&quot; 
-out attribute);
-
-#line  1847 &quot;VBNET.ATG&quot; 
-		attributes.Add(attribute); 
-		while (
-#line  1848 &quot;VBNET.ATG&quot; 
-NotFinalComma()) {
-			Expect(12);
-			Attribute(
-#line  1848 &quot;VBNET.ATG&quot; 
-out attribute);
-
-#line  1848 &quot;VBNET.ATG&quot; 
-			attributes.Add(attribute); 
-		}
-		if (la.kind == 12) {
-			lexer.NextToken();
-		}
-		Expect(27);
-		EndOfStmt();
-
-#line  1853 &quot;VBNET.ATG&quot; 
-		AttributeSection section = new AttributeSection(attributeTarget, attributes);
-		section.StartLocation = startPos;
-		section.EndLocation = t.EndLocation;
-		compilationUnit.AddChild(section);
-		
-	}
-
-	void NamespaceMemberDecl() {
-
-#line  526 &quot;VBNET.ATG&quot; 
-		Modifiers m = new Modifiers(this);
-		AttributeSection section;
-		ArrayList attributes = new ArrayList();
-		string qualident;
-		
-		if (la.kind == 127) {
-			lexer.NextToken();
-
-#line  533 &quot;VBNET.ATG&quot; 
-			Point startPos = t.Location;
-			
-			Qualident(
-#line  535 &quot;VBNET.ATG&quot; 
-out qualident);
-
-#line  537 &quot;VBNET.ATG&quot; 
-			INode node =  new NamespaceDeclaration(qualident);
-			node.StartLocation = startPos;
-			compilationUnit.AddChild(node);
-			compilationUnit.BlockStart(node);
-			
-			Expect(1);
-			NamespaceBody();
-
-#line  545 &quot;VBNET.ATG&quot; 
-			node.EndLocation = t.Location;
-			compilationUnit.BlockEnd();
-			
-		} else if (StartOf(2)) {
-			while (la.kind == 28) {
-				AttributeSection(
-#line  549 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  549 &quot;VBNET.ATG&quot; 
-				attributes.Add(section); 
-			}
-			while (StartOf(3)) {
-				TypeModifier(
-#line  550 &quot;VBNET.ATG&quot; 
-m);
-			}
-			NonModuleDeclaration(
-#line  550 &quot;VBNET.ATG&quot; 
-m, attributes);
-		} else SynErr(192);
-	}
-
-	void OptionValue(
-#line  463 &quot;VBNET.ATG&quot; 
-ref bool val) {
-		if (la.kind == 136) {
-			lexer.NextToken();
-
-#line  465 &quot;VBNET.ATG&quot; 
-			val = true; 
-		} else if (la.kind == 135) {
-			lexer.NextToken();
-
-#line  467 &quot;VBNET.ATG&quot; 
-			val = true; 
-		} else SynErr(193);
-	}
-
-	void EndOfStmt() {
-		if (la.kind == 1) {
-			lexer.NextToken();
-		} else if (la.kind == 13) {
-			lexer.NextToken();
-		} else SynErr(194);
-	}
-
-	void ImportClause(
-#line  503 &quot;VBNET.ATG&quot; 
-out object importClause) {
-
-#line  505 &quot;VBNET.ATG&quot; 
-		string qualident = null;
-		string aliasident = null;
-		importClause = null;
-		
-		if (
-#line  509 &quot;VBNET.ATG&quot; 
-IsAssignment()) {
-			Identifier();
-
-#line  509 &quot;VBNET.ATG&quot; 
-			aliasident = t.val;  
-			Expect(11);
-		}
-		Qualident(
-#line  510 &quot;VBNET.ATG&quot; 
-out qualident);
-
-#line  512 &quot;VBNET.ATG&quot; 
-		if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
-		if (aliasident != null) {
-			importClause = new ImportsAliasDeclaration(aliasident, qualident);
-		} else {
-			importedNamespaces.Add(qualident);
-			importClause = new ImportsDeclaration(qualident);
-		}
-		}
-		
-	}
-
-	void Identifier() {
-		if (la.kind == 2) {
-			lexer.NextToken();
-		} else if (la.kind == 171) {
-			lexer.NextToken();
-		} else if (la.kind == 52) {
-			lexer.NextToken();
-		} else if (la.kind == 71) {
-			lexer.NextToken();
-		} else SynErr(195);
-	}
-
-	void Qualident(
-#line  2527 &quot;VBNET.ATG&quot; 
-out string qualident) {
-
-#line  2528 &quot;VBNET.ATG&quot; 
-		string name = String.Empty; 
-		Identifier();
-
-#line  2529 &quot;VBNET.ATG&quot; 
-		StringBuilder qualidentBuilder = new StringBuilder(t.val); 
-		while (la.kind == 10) {
-			lexer.NextToken();
-			IdentifierOrKeyword(
-#line  2531 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  2531 &quot;VBNET.ATG&quot; 
-			qualidentBuilder.Append('.');
-			  qualidentBuilder.Append(name); 
-			
-		}
-
-#line  2535 &quot;VBNET.ATG&quot; 
-		qualident = qualidentBuilder.ToString(); 
-	}
-
-	void NamespaceBody() {
-		while (StartOf(1)) {
-			NamespaceMemberDecl();
-		}
-		Expect(89);
-		Expect(127);
-		Expect(1);
-	}
-
-	void AttributeSection(
-#line  1911 &quot;VBNET.ATG&quot; 
-out AttributeSection section) {
-
-#line  1913 &quot;VBNET.ATG&quot; 
-		string attributeTarget = &quot;&quot;;
-		ArrayList attributes = new ArrayList();
-		ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute;
-		
-		
-		Expect(28);
-
-#line  1918 &quot;VBNET.ATG&quot; 
-		Point startPos = t.Location; 
-		if (
-#line  1919 &quot;VBNET.ATG&quot; 
-IsLocalAttrTarget()) {
-			if (la.kind == 94) {
-				lexer.NextToken();
-
-#line  1920 &quot;VBNET.ATG&quot; 
-				attributeTarget = &quot;event&quot;;
-			} else if (la.kind == 156) {
-				lexer.NextToken();
-
-#line  1921 &quot;VBNET.ATG&quot; 
-				attributeTarget = &quot;return&quot;;
-			} else {
-				Identifier();
-
-#line  1924 &quot;VBNET.ATG&quot; 
-				string val = t.val.ToLower();
-				if (val != &quot;field&quot;	|| val != &quot;method&quot; ||
-					val != &quot;module&quot; || val != &quot;param&quot;  ||
-					val != &quot;property&quot; || val != &quot;type&quot;)
-				Error(&quot;attribute target specifier (event, return, field,&quot; +
-						&quot;method, module, param, property, or type) expected&quot;);
-				attributeTarget = t.val;
-				
-			}
-			Expect(13);
-		}
-		Attribute(
-#line  1934 &quot;VBNET.ATG&quot; 
-out attribute);
-
-#line  1934 &quot;VBNET.ATG&quot; 
-		attributes.Add(attribute); 
-		while (
-#line  1935 &quot;VBNET.ATG&quot; 
-NotFinalComma()) {
-			Expect(12);
-			Attribute(
-#line  1935 &quot;VBNET.ATG&quot; 
-out attribute);
-
-#line  1935 &quot;VBNET.ATG&quot; 
-			attributes.Add(attribute); 
-		}
-		if (la.kind == 12) {
-			lexer.NextToken();
-		}
-		Expect(27);
-
-#line  1939 &quot;VBNET.ATG&quot; 
-		section = new AttributeSection(attributeTarget, attributes);
-		section.StartLocation = startPos;
-		section.EndLocation = t.EndLocation;
-		
-	}
-
-	void TypeModifier(
-#line  2715 &quot;VBNET.ATG&quot; 
-Modifiers m) {
-		switch (la.kind) {
-		case 150: {
-			lexer.NextToken();
-
-#line  2716 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Public); 
-			break;
-		}
-		case 149: {
-			lexer.NextToken();
-
-#line  2717 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Protected); 
-			break;
-		}
-		case 100: {
-			lexer.NextToken();
-
-#line  2718 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Friend); 
-			break;
-		}
-		case 147: {
-			lexer.NextToken();
-
-#line  2719 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Private); 
-			break;
-		}
-		case 160: {
-			lexer.NextToken();
-
-#line  2720 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Shared); 
-			break;
-		}
-		case 159: {
-			lexer.NextToken();
-
-#line  2721 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Shadows); 
-			break;
-		}
-		case 123: {
-			lexer.NextToken();
-
-#line  2722 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.MustInherit); 
-			break;
-		}
-		case 132: {
-			lexer.NextToken();
-
-#line  2723 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.NotInheritable); 
-			break;
-		}
-		default: SynErr(196); break;
-		}
-	}
-
-	void NonModuleDeclaration(
-#line  554 &quot;VBNET.ATG&quot; 
-Modifiers m, ArrayList attributes) {
-
-#line  556 &quot;VBNET.ATG&quot; 
-		string name = String.Empty;
-		ArrayList names = null;
-		
-		switch (la.kind) {
-		case 68: {
-
-#line  559 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Classes); 
-			lexer.NextToken();
-
-#line  562 &quot;VBNET.ATG&quot; 
-			TypeDeclaration newType = new TypeDeclaration();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			newType.Type = Types.Class;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-			
-			Identifier();
-
-#line  570 &quot;VBNET.ATG&quot; 
-			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
-			EndOfStmt();
-			if (la.kind == 111) {
-				ClassBaseType(
-#line  572 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  572 &quot;VBNET.ATG&quot; 
-				newType.BaseType = name; 
-			}
-			while (la.kind == 108) {
-				TypeImplementsClause(
-#line  573 &quot;VBNET.ATG&quot; 
-out names);
-
-#line  573 &quot;VBNET.ATG&quot; 
-				newType.BaseInterfaces = names; 
-			}
-			ClassBody(
-#line  574 &quot;VBNET.ATG&quot; 
-newType);
-
-#line  576 &quot;VBNET.ATG&quot; 
-			compilationUnit.BlockEnd();
-			
-			break;
-		}
-		case 122: {
-			lexer.NextToken();
-
-#line  580 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Modules);
-			TypeDeclaration newType = new TypeDeclaration();
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			newType.StartLocation = t.Location;
-			newType.Type = Types.Module;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-			
-			Identifier();
-
-#line  590 &quot;VBNET.ATG&quot; 
-			newType.Name = t.val; newType.StartLocation = t.EndLocation;  
-			Expect(1);
-			ModuleBody(
-#line  592 &quot;VBNET.ATG&quot; 
-newType);
-
-#line  594 &quot;VBNET.ATG&quot; 
-			newType.EndLocation = t.Location;
-			compilationUnit.BlockEnd();
-			
-			break;
-		}
-		case 168: {
-			lexer.NextToken();
-
-#line  599 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Structures);
-			TypeDeclaration newType = new TypeDeclaration();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			newType.StartLocation = t.Location;
-			newType.Type = Types.Structure;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-			ArrayList baseInterfaces = new ArrayList();
-			
-			Identifier();
-
-#line  610 &quot;VBNET.ATG&quot; 
-			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
-			Expect(1);
-			while (la.kind == 108) {
-				TypeImplementsClause(
-#line  611 &quot;VBNET.ATG&quot; 
-out baseInterfaces);
-			}
-			StructureBody(
-#line  612 &quot;VBNET.ATG&quot; 
-newType);
-
-#line  614 &quot;VBNET.ATG&quot; 
-			newType.EndLocation = t.Location;
-			compilationUnit.BlockEnd();
-			
-			break;
-		}
-		case 91: {
-			lexer.NextToken();
-
-#line  620 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Enums);
-			TypeDeclaration newType = new TypeDeclaration();
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			
-			newType.Type = Types.Enum;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-			
-			Identifier();
-
-#line  631 &quot;VBNET.ATG&quot; 
-			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
-			if (la.kind == 49) {
-				lexer.NextToken();
-				PrimitiveTypeName(
-#line  632 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  632 &quot;VBNET.ATG&quot; 
-				newType.BaseType = name; 
-			}
-			Expect(1);
-			EnumBody(
-#line  634 &quot;VBNET.ATG&quot; 
-newType);
-
-#line  636 &quot;VBNET.ATG&quot; 
-			newType.EndLocation = t.Location;
-			compilationUnit.BlockEnd();
-			
-			break;
-		}
-		case 113: {
-			lexer.NextToken();
-
-#line  642 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Interfaces);
-			TypeDeclaration newType = new TypeDeclaration();
-			compilationUnit.AddChild(newType);
-			compilationUnit.BlockStart(newType);
-			newType.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			
-			newType.Type = Types.Interface;
-			newType.Modifier = m.Modifier;
-			newType.Attributes = attributes;
-			ArrayList baseInterfaces = new ArrayList();
-			
-			Identifier();
-
-#line  653 &quot;VBNET.ATG&quot; 
-			newType.Name = t.val; newType.StartLocation = t.EndLocation; 
-			EndOfStmt();
-			while (la.kind == 111) {
-				InterfaceBase(
-#line  654 &quot;VBNET.ATG&quot; 
-out baseInterfaces);
-
-#line  654 &quot;VBNET.ATG&quot; 
-				newType.BaseInterfaces = baseInterfaces; 
-			}
-			InterfaceBody(
-#line  655 &quot;VBNET.ATG&quot; 
-newType);
-
-#line  657 &quot;VBNET.ATG&quot; 
-			newType.EndLocation = t.Location;
-			compilationUnit.BlockEnd();
-			
-			break;
-		}
-		case 81: {
-			lexer.NextToken();
-
-#line  663 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Delegates);
-			DelegateDeclaration delegateDeclr = new DelegateDeclaration();
-			ArrayList p = null;
-			TypeReference type = null;
-			delegateDeclr.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			delegateDeclr.StartLocation = t.Location;
-			delegateDeclr.Modifier = m.Modifier;
-			delegateDeclr.Attributes = attributes;
-			
-			if (la.kind == 169) {
-				lexer.NextToken();
-				Identifier();
-
-#line  673 &quot;VBNET.ATG&quot; 
-				delegateDeclr.Name = t.val; 
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  674 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-
-#line  674 &quot;VBNET.ATG&quot; 
-					delegateDeclr.Parameters = p; 
-				}
-			} else if (la.kind == 101) {
-				lexer.NextToken();
-				Identifier();
-
-#line  676 &quot;VBNET.ATG&quot; 
-				delegateDeclr.Name = t.val; 
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  677 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-
-#line  677 &quot;VBNET.ATG&quot; 
-					delegateDeclr.Parameters = p; 
-				}
-				if (la.kind == 49) {
-					lexer.NextToken();
-					TypeName(
-#line  678 &quot;VBNET.ATG&quot; 
-out type);
-
-#line  678 &quot;VBNET.ATG&quot; 
-					delegateDeclr.ReturnType = type; 
-				}
-			} else SynErr(197);
-
-#line  680 &quot;VBNET.ATG&quot; 
-			delegateDeclr.EndLocation = t.EndLocation; 
-			Expect(1);
-
-#line  683 &quot;VBNET.ATG&quot; 
-			compilationUnit.AddChild(delegateDeclr);
-			
-			break;
-		}
-		default: SynErr(198); break;
-		}
-	}
-
-	void ClassBaseType(
-#line  873 &quot;VBNET.ATG&quot; 
-out string name) {
-
-#line  875 &quot;VBNET.ATG&quot; 
-		TypeReference type;
-		name = String.Empty;
-		
-		Expect(111);
-		TypeName(
-#line  879 &quot;VBNET.ATG&quot; 
-out type);
-
-#line  879 &quot;VBNET.ATG&quot; 
-		name = type.Type; 
-		EndOfStmt();
-	}
-
-	void TypeImplementsClause(
-#line  1408 &quot;VBNET.ATG&quot; 
-out ArrayList baseInterfaces) {
-
-#line  1410 &quot;VBNET.ATG&quot; 
-		baseInterfaces = new ArrayList();
-		TypeReference type = null;
-		
-		Expect(108);
-		TypeName(
-#line  1413 &quot;VBNET.ATG&quot; 
-out type);
-
-#line  1415 &quot;VBNET.ATG&quot; 
-		baseInterfaces.Add(type);
-		
-		while (la.kind == 12) {
-			lexer.NextToken();
-			TypeName(
-#line  1418 &quot;VBNET.ATG&quot; 
-out type);
-
-#line  1419 &quot;VBNET.ATG&quot; 
-			baseInterfaces.Add(type); 
-		}
-		EndOfStmt();
-	}
-
-	void ClassBody(
-#line  693 &quot;VBNET.ATG&quot; 
-TypeDeclaration newType) {
-
-#line  694 &quot;VBNET.ATG&quot; 
-		AttributeSection section; 
-		while (StartOf(5)) {
-
-#line  697 &quot;VBNET.ATG&quot; 
-			ArrayList attributes = new ArrayList();
-			Modifiers m = new Modifiers(this);
-			
-			while (la.kind == 28) {
-				AttributeSection(
-#line  700 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  700 &quot;VBNET.ATG&quot; 
-				attributes.Add(section); 
-			}
-			while (StartOf(6)) {
-				MemberModifier(
-#line  701 &quot;VBNET.ATG&quot; 
-m);
-			}
-			ClassMemberDecl(
-#line  702 &quot;VBNET.ATG&quot; 
-m, attributes);
-		}
-		Expect(89);
-		Expect(68);
-
-#line  704 &quot;VBNET.ATG&quot; 
-		newType.EndLocation = t.EndLocation; 
-		Expect(1);
-	}
-
-	void ModuleBody(
-#line  724 &quot;VBNET.ATG&quot; 
-TypeDeclaration newType) {
-
-#line  725 &quot;VBNET.ATG&quot; 
-		AttributeSection section; 
-		while (StartOf(5)) {
-
-#line  728 &quot;VBNET.ATG&quot; 
-			ArrayList attributes = new ArrayList();
-			Modifiers m = new Modifiers(this);
-			
-			while (la.kind == 28) {
-				AttributeSection(
-#line  731 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  731 &quot;VBNET.ATG&quot; 
-				attributes.Add(section); 
-			}
-			while (StartOf(6)) {
-				MemberModifier(
-#line  732 &quot;VBNET.ATG&quot; 
-m);
-			}
-			ClassMemberDecl(
-#line  733 &quot;VBNET.ATG&quot; 
-m, attributes);
-		}
-		Expect(89);
-		Expect(122);
-
-#line  735 &quot;VBNET.ATG&quot; 
-		newType.EndLocation = t.EndLocation; 
-		Expect(1);
-	}
-
-	void StructureBody(
-#line  708 &quot;VBNET.ATG&quot; 
-TypeDeclaration newType) {
-
-#line  709 &quot;VBNET.ATG&quot; 
-		AttributeSection section; 
-		while (StartOf(5)) {
-
-#line  712 &quot;VBNET.ATG&quot; 
-			ArrayList attributes = new ArrayList();
-			Modifiers m = new Modifiers(this);
-			
-			while (la.kind == 28) {
-				AttributeSection(
-#line  715 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  715 &quot;VBNET.ATG&quot; 
-				attributes.Add(section); 
-			}
-			while (StartOf(6)) {
-				MemberModifier(
-#line  716 &quot;VBNET.ATG&quot; 
-m);
-			}
-			StructureMemberDecl(
-#line  717 &quot;VBNET.ATG&quot; 
-m, attributes);
-		}
-		Expect(89);
-		Expect(168);
-
-#line  719 &quot;VBNET.ATG&quot; 
-		newType.EndLocation = t.EndLocation; 
-		Expect(1);
-	}
-
-	void PrimitiveTypeName(
-#line  2693 &quot;VBNET.ATG&quot; 
-out string type) {
-
-#line  2694 &quot;VBNET.ATG&quot; 
-		type = String.Empty; 
-		switch (la.kind) {
-		case 53: {
-			lexer.NextToken();
-
-#line  2695 &quot;VBNET.ATG&quot; 
-			type = &quot;Boolean&quot;; 
-			break;
-		}
-		case 77: {
-			lexer.NextToken();
-
-#line  2696 &quot;VBNET.ATG&quot; 
-			type = &quot;Date&quot;; 
-			break;
-		}
-		case 66: {
-			lexer.NextToken();
-
-#line  2697 &quot;VBNET.ATG&quot; 
-			type = &quot;Char&quot;; 
-			break;
-		}
-		case 167: {
-			lexer.NextToken();
-
-#line  2698 &quot;VBNET.ATG&quot; 
-			type = &quot;String&quot;; 
-			break;
-		}
-		case 78: {
-			lexer.NextToken();
-
-#line  2699 &quot;VBNET.ATG&quot; 
-			type = &quot;Decimal&quot;; 
-			break;
-		}
-		case 55: {
-			lexer.NextToken();
-
-#line  2700 &quot;VBNET.ATG&quot; 
-			type = &quot;Byte&quot;; 
-			break;
-		}
-		case 161: {
-			lexer.NextToken();
-
-#line  2701 &quot;VBNET.ATG&quot; 
-			type = &quot;Short&quot;; 
-			break;
-		}
-		case 112: {
-			lexer.NextToken();
-
-#line  2702 &quot;VBNET.ATG&quot; 
-			type = &quot;Integer&quot;; 
-			break;
-		}
-		case 118: {
-			lexer.NextToken();
-
-#line  2703 &quot;VBNET.ATG&quot; 
-			type = &quot;Long&quot;; 
-			break;
-		}
-		case 162: {
-			lexer.NextToken();
-
-#line  2704 &quot;VBNET.ATG&quot; 
-			type = &quot;Single&quot;; 
-			break;
-		}
-		case 85: {
-			lexer.NextToken();
-
-#line  2705 &quot;VBNET.ATG&quot; 
-			type = &quot;Double&quot;; 
-			break;
-		}
-		default: SynErr(199); break;
-		}
-	}
-
-	void EnumBody(
-#line  739 &quot;VBNET.ATG&quot; 
-TypeDeclaration newType) {
-
-#line  740 &quot;VBNET.ATG&quot; 
-		FieldDeclaration f; 
-		while (StartOf(7)) {
-			EnumMemberDecl(
-#line  742 &quot;VBNET.ATG&quot; 
-out f);
-
-#line  742 &quot;VBNET.ATG&quot; 
-			compilationUnit.AddChild(f); 
-		}
-		Expect(89);
-		Expect(91);
-
-#line  744 &quot;VBNET.ATG&quot; 
-		newType.EndLocation = t.EndLocation; 
-		Expect(1);
-	}
-
-	void InterfaceBase(
-#line  1393 &quot;VBNET.ATG&quot; 
-out ArrayList bases) {
-
-#line  1395 &quot;VBNET.ATG&quot; 
-		TypeReference type;
-		bases = new ArrayList();
-		
-		Expect(111);
-		TypeName(
-#line  1399 &quot;VBNET.ATG&quot; 
-out type);
-
-#line  1399 &quot;VBNET.ATG&quot; 
-		bases.Add(type); 
-		while (la.kind == 12) {
-			lexer.NextToken();
-			TypeName(
-#line  1402 &quot;VBNET.ATG&quot; 
-out type);
-
-#line  1402 &quot;VBNET.ATG&quot; 
-			bases.Add(type); 
-		}
-		Expect(1);
-	}
-
-	void InterfaceBody(
-#line  748 &quot;VBNET.ATG&quot; 
-TypeDeclaration newType) {
-		while (StartOf(8)) {
-			InterfaceMemberDecl();
-		}
-		Expect(89);
-		Expect(113);
-
-#line  750 &quot;VBNET.ATG&quot; 
-		newType.EndLocation = t.EndLocation; 
-		Expect(1);
-	}
-
-	void FormalParameterList(
-#line  1946 &quot;VBNET.ATG&quot; 
-out ArrayList parameter) {
-
-#line  1948 &quot;VBNET.ATG&quot; 
-		parameter = new ArrayList();
-		ParameterDeclarationExpression p;
-		AttributeSection section;
-		ArrayList attributes = new ArrayList();
-		
-		while (la.kind == 28) {
-			AttributeSection(
-#line  1953 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  1953 &quot;VBNET.ATG&quot; 
-			attributes.Add(section); 
-		}
-		FormalParameter(
-#line  1955 &quot;VBNET.ATG&quot; 
-out p);
-
-#line  1957 &quot;VBNET.ATG&quot; 
-		bool paramsFound = false;
-		p.Attributes = attributes;
-		parameter.Add(p);
-		
-		while (la.kind == 12) {
-			lexer.NextToken();
-
-#line  1962 &quot;VBNET.ATG&quot; 
-			attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); 
-			while (la.kind == 28) {
-				AttributeSection(
-#line  1963 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  1963 &quot;VBNET.ATG&quot; 
-				attributes.Add(section); 
-			}
-			FormalParameter(
-#line  1965 &quot;VBNET.ATG&quot; 
-out p);
-
-#line  1965 &quot;VBNET.ATG&quot; 
-			p.Attributes = attributes; parameter.Add(p); 
-		}
-	}
-
-	void TypeName(
-#line  1758 &quot;VBNET.ATG&quot; 
-out TypeReference typeref) {
-
-#line  1760 &quot;VBNET.ATG&quot; 
-		ArrayList rank = null;
-		
-		NonArrayTypeName(
-#line  1762 &quot;VBNET.ATG&quot; 
-out typeref);
-		ArrayTypeModifiers(
-#line  1763 &quot;VBNET.ATG&quot; 
-out rank);
-
-#line  1765 &quot;VBNET.ATG&quot; 
-		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
-		
-	}
-
-	void MemberModifier(
-#line  2726 &quot;VBNET.ATG&quot; 
-Modifiers m) {
-		switch (la.kind) {
-		case 123: {
-			lexer.NextToken();
-
-#line  2727 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.MustInherit);
-			break;
-		}
-		case 80: {
-			lexer.NextToken();
-
-#line  2728 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Default);
-			break;
-		}
-		case 100: {
-			lexer.NextToken();
-
-#line  2729 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Friend);
-			break;
-		}
-		case 159: {
-			lexer.NextToken();
-
-#line  2730 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Shadows);
-			break;
-		}
-		case 144: {
-			lexer.NextToken();
-
-#line  2731 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Overrides);
-			break;
-		}
-		case 124: {
-			lexer.NextToken();
-
-#line  2732 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.MustOverride);
-			break;
-		}
-		case 147: {
-			lexer.NextToken();
-
-#line  2733 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Private);
-			break;
-		}
-		case 149: {
-			lexer.NextToken();
-
-#line  2734 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Protected);
-			break;
-		}
-		case 150: {
-			lexer.NextToken();
-
-#line  2735 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Public);
-			break;
-		}
-		case 132: {
-			lexer.NextToken();
-
-#line  2736 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.NotInheritable);
-			break;
-		}
-		case 133: {
-			lexer.NextToken();
-
-#line  2737 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.NotOverridable);
-			break;
-		}
-		case 160: {
-			lexer.NextToken();
-
-#line  2738 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Shared);
-			break;
-		}
-		case 142: {
-			lexer.NextToken();
-
-#line  2739 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Overridable);
-			break;
-		}
-		case 141: {
-			lexer.NextToken();
-
-#line  2740 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Overloads);
-			break;
-		}
-		case 152: {
-			lexer.NextToken();
-
-#line  2741 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.ReadOnly);
-			break;
-		}
-		case 186: {
-			lexer.NextToken();
-
-#line  2742 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.WriteOnly);
-			break;
-		}
-		case 185: {
-			lexer.NextToken();
-
-#line  2743 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.WithEvents);
-			break;
-		}
-		case 82: {
-			lexer.NextToken();
-
-#line  2744 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Dim);
-			break;
-		}
-		default: SynErr(200); break;
-		}
-	}
-
-	void ClassMemberDecl(
-#line  869 &quot;VBNET.ATG&quot; 
-Modifiers m, ArrayList attributes) {
-		StructureMemberDecl(
-#line  870 &quot;VBNET.ATG&quot; 
-m, attributes);
-	}
-
-	void StructureMemberDecl(
-#line  884 &quot;VBNET.ATG&quot; 
-Modifiers m, ArrayList attributes) {
-
-#line  886 &quot;VBNET.ATG&quot; 
-		TypeReference type = null;
-		ArrayList p = null;
-		Statement stmt = null;
-		ArrayList variableDeclarators = new ArrayList();
-		
-		switch (la.kind) {
-		case 68: case 81: case 91: case 113: case 122: case 168: {
-			NonModuleDeclaration(
-#line  891 &quot;VBNET.ATG&quot; 
-m, attributes);
-			break;
-		}
-		case 169: {
-			lexer.NextToken();
-
-#line  895 &quot;VBNET.ATG&quot; 
-			Point startPos = t.Location;
-			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-			
-			if (StartOf(9)) {
-
-#line  900 &quot;VBNET.ATG&quot; 
-				string name = String.Empty;
-				MethodDeclaration methodDeclaration;
-				HandlesClause handlesClause = null;
-				ImplementsClause implementsClause = null;
-				
-				Identifier();
-
-#line  907 &quot;VBNET.ATG&quot; 
-				name = t.val;
-				m.Check(Modifier.Methods);
-				
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  910 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-				if (la.kind == 106 || la.kind == 108) {
-					if (la.kind == 108) {
-						ImplementsClause(
-#line  913 &quot;VBNET.ATG&quot; 
-out implementsClause);
-					} else {
-						HandlesClause(
-#line  915 &quot;VBNET.ATG&quot; 
-out handlesClause);
-					}
-				}
-
-#line  918 &quot;VBNET.ATG&quot; 
-				Point endLocation = t.EndLocation; 
-				Expect(1);
-				if (
-#line  922 &quot;VBNET.ATG&quot; 
-IsMustOverride(m)) {
-
-#line  924 &quot;VBNET.ATG&quot; 
-					methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
-					methodDeclaration.Specials[&quot;before&quot;] = comments;
-					methodDeclaration.StartLocation = startPos;
-					methodDeclaration.EndLocation   = endLocation;
-					
-					methodDeclaration.HandlesClause = handlesClause;
-					methodDeclaration.ImplementsClause = implementsClause;
-					
-					compilationUnit.AddChild(methodDeclaration);
-					
-				} else if (StartOf(10)) {
-
-#line  936 &quot;VBNET.ATG&quot; 
-					methodDeclaration = new MethodDeclaration(name, m.Modifier,  null, p, attributes);
-					methodDeclaration.Specials[&quot;before&quot;] = comments;
-					methodDeclaration.StartLocation = startPos;
-					methodDeclaration.EndLocation   = endLocation;
-					
-					methodDeclaration.HandlesClause = handlesClause;
-					methodDeclaration.ImplementsClause = implementsClause;
-					
-					compilationUnit.AddChild(methodDeclaration);
-					compilationUnit.BlockStart(methodDeclaration);
-					
-					Block(
-#line  947 &quot;VBNET.ATG&quot; 
-out stmt);
-
-#line  949 &quot;VBNET.ATG&quot; 
-					compilationUnit.BlockEnd();
-					methodDeclaration.Body  = (BlockStatement)stmt;
-					
-					Expect(89);
-					Expect(169);
-
-#line  952 &quot;VBNET.ATG&quot; 
-					methodDeclaration.Body.EndLocation = t.EndLocation; 
-					Expect(1);
-				} else SynErr(201);
-			} else if (la.kind == 128) {
-				lexer.NextToken();
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  955 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-
-#line  956 &quot;VBNET.ATG&quot; 
-				m.Check(Modifier.Constructors); 
-
-#line  957 &quot;VBNET.ATG&quot; 
-				Point constructorEndLocation = t.EndLocation; 
-				Expect(1);
-				Block(
-#line  959 &quot;VBNET.ATG&quot; 
-out stmt);
-				Expect(89);
-				Expect(169);
-
-#line  960 &quot;VBNET.ATG&quot; 
-				Point endLocation = t.EndLocation; 
-				Expect(1);
-
-#line  962 &quot;VBNET.ATG&quot; 
-				ConstructorDeclaration cd = new ConstructorDeclaration(&quot;New&quot;, m.Modifier, p, attributes); 
-				cd.StartLocation = startPos;
-				cd.Specials[&quot;before&quot;] = comments;
-				cd.EndLocation   = constructorEndLocation;
-				cd.Body = (BlockStatement)stmt;
-				cd.Body.EndLocation   = endLocation;
-				compilationUnit.AddChild(cd);
-				
-			} else SynErr(202);
-			break;
-		}
-		case 101: {
-			lexer.NextToken();
-
-#line  975 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Methods);
-			string name = String.Empty;
-			Point startPos = t.Location;
-			MethodDeclaration methodDeclaration;
-			HandlesClause handlesClause = null;
-			ImplementsClause implementsClause = null;
-			AttributeSection attributeSection = null;
-			
-			Identifier();
-
-#line  983 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			if (la.kind == 25) {
-				lexer.NextToken();
-				if (StartOf(4)) {
-					FormalParameterList(
-#line  984 &quot;VBNET.ATG&quot; 
-out p);
-				}
-				Expect(26);
-			}
-			if (la.kind == 49) {
-				lexer.NextToken();
-				if (la.kind == 28) {
-					AttributeSection(
-#line  985 &quot;VBNET.ATG&quot; 
-out attributeSection);
-				}
-				TypeName(
-#line  985 &quot;VBNET.ATG&quot; 
-out type);
-			}
-
-#line  987 &quot;VBNET.ATG&quot; 
-			if(type == null) {
-			type = new TypeReference(&quot;System.Object&quot;);
-			}
-			type.Attributes = attributeSection;
-			
-			if (la.kind == 106 || la.kind == 108) {
-				if (la.kind == 108) {
-					ImplementsClause(
-#line  994 &quot;VBNET.ATG&quot; 
-out implementsClause);
-				} else {
-					HandlesClause(
-#line  996 &quot;VBNET.ATG&quot; 
-out handlesClause);
-				}
-			}
-			Expect(1);
-			if (
-#line  1002 &quot;VBNET.ATG&quot; 
-IsMustOverride(m)) {
-
-#line  1004 &quot;VBNET.ATG&quot; 
-				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
-				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				methodDeclaration.StartLocation = startPos;
-				methodDeclaration.EndLocation   = t.EndLocation;
-				methodDeclaration.HandlesClause = handlesClause;
-				methodDeclaration.ImplementsClause = implementsClause;
-				compilationUnit.AddChild(methodDeclaration);
-				
-			} else if (StartOf(10)) {
-
-#line  1014 &quot;VBNET.ATG&quot; 
-				methodDeclaration = new MethodDeclaration(name, m.Modifier,  type, p, attributes);
-				methodDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				methodDeclaration.StartLocation = startPos;
-				methodDeclaration.EndLocation   = t.EndLocation;
-				
-				methodDeclaration.HandlesClause = handlesClause;
-				methodDeclaration.ImplementsClause = implementsClause;
-				
-				compilationUnit.AddChild(methodDeclaration);
-				compilationUnit.BlockStart(methodDeclaration);
-				
-				Block(
-#line  1025 &quot;VBNET.ATG&quot; 
-out stmt);
-
-#line  1027 &quot;VBNET.ATG&quot; 
-				compilationUnit.BlockEnd();
-				methodDeclaration.Body  = (BlockStatement)stmt;
-				
-				Expect(89);
-				Expect(101);
-
-#line  1032 &quot;VBNET.ATG&quot; 
-				methodDeclaration.Body.StartLocation = methodDeclaration.EndLocation;
-				methodDeclaration.Body.EndLocation   = t.EndLocation;
-				
-				Expect(1);
-			} else SynErr(203);
-			break;
-		}
-		case 79: {
-			lexer.NextToken();
-
-#line  1041 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.ExternalMethods);
-			Point startPos = t.Location;
-			CharsetModifier charsetModifer = CharsetModifier.None;
-			string library = String.Empty;
-			string alias = null;
-			string name = String.Empty;
-			
-			if (StartOf(11)) {
-				Charset(
-#line  1048 &quot;VBNET.ATG&quot; 
-out charsetModifer);
-			}
-			if (la.kind == 169) {
-				lexer.NextToken();
-				Identifier();
-
-#line  1051 &quot;VBNET.ATG&quot; 
-				name = t.val; 
-				Expect(116);
-				Expect(3);
-
-#line  1052 &quot;VBNET.ATG&quot; 
-				library = t.val; 
-				if (la.kind == 45) {
-					lexer.NextToken();
-					Expect(3);
-
-#line  1053 &quot;VBNET.ATG&quot; 
-					alias = t.val; 
-				}
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  1054 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-				Expect(1);
-
-#line  1057 &quot;VBNET.ATG&quot; 
-				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, null, p, attributes, library, alias, charsetModifer);
-				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				declareDeclaration.StartLocation = startPos;
-				declareDeclaration.EndLocation   = t.EndLocation;
-				compilationUnit.AddChild(declareDeclaration);
-				
-			} else if (la.kind == 101) {
-				lexer.NextToken();
-				Identifier();
-
-#line  1065 &quot;VBNET.ATG&quot; 
-				name = t.val; 
-				Expect(116);
-				Expect(3);
-
-#line  1066 &quot;VBNET.ATG&quot; 
-				library = t.val; 
-				if (la.kind == 45) {
-					lexer.NextToken();
-					Expect(3);
-
-#line  1067 &quot;VBNET.ATG&quot; 
-					alias = t.val; 
-				}
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  1068 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-				if (la.kind == 49) {
-					lexer.NextToken();
-					TypeName(
-#line  1069 &quot;VBNET.ATG&quot; 
-out type);
-				}
-				Expect(1);
-
-#line  1072 &quot;VBNET.ATG&quot; 
-				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, type, p, attributes, library, alias, charsetModifer);
-				declareDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				declareDeclaration.StartLocation = startPos;
-				declareDeclaration.EndLocation   = t.EndLocation;
-				compilationUnit.AddChild(declareDeclaration);
-				
-			} else SynErr(204);
-			break;
-		}
-		case 94: {
-			lexer.NextToken();
-
-#line  1083 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Events);
-			Point startPos = t.Location;
-			EventDeclaration eventDeclaration;
-			string name = String.Empty;
-			ImplementsClause implementsClause = null;
-			
-			Identifier();
-
-#line  1089 &quot;VBNET.ATG&quot; 
-			name= t.val; 
-			if (la.kind == 49) {
-				lexer.NextToken();
-				TypeName(
-#line  1091 &quot;VBNET.ATG&quot; 
-out type);
-			} else if (la.kind == 1 || la.kind == 25 || la.kind == 108) {
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  1093 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-			} else SynErr(205);
-			if (la.kind == 108) {
-				ImplementsClause(
-#line  1095 &quot;VBNET.ATG&quot; 
-out implementsClause);
-			}
-
-#line  1097 &quot;VBNET.ATG&quot; 
-			eventDeclaration = new EventDeclaration(type, m.Modifier, p, attributes, name, implementsClause);
-			eventDeclaration.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-			eventDeclaration.StartLocation = startPos;
-			eventDeclaration.EndLocation = t.EndLocation;
-			compilationUnit.AddChild(eventDeclaration);
-			
-			Expect(1);
-			break;
-		}
-		case 2: case 52: case 71: case 171: {
-
-#line  1105 &quot;VBNET.ATG&quot; 
-			Point startPos = t.Location; 
-
-#line  1107 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Fields);
-			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
-			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-			fd.StartLocation = startPos;
-			
-			VariableDeclarator(
-#line  1112 &quot;VBNET.ATG&quot; 
-variableDeclarators);
-
-#line  1114 &quot;VBNET.ATG&quot; 
-			((INode)variableDeclarators[0]).Specials[&quot;before&quot;] = comments;
-			
-			while (la.kind == 12) {
-				lexer.NextToken();
-				VariableDeclarator(
-#line  1116 &quot;VBNET.ATG&quot; 
-variableDeclarators);
-			}
-			Expect(1);
-
-#line  1119 &quot;VBNET.ATG&quot; 
-			fd.EndLocation = t.EndLocation;
-			fd.Fields = variableDeclarators;
-			compilationUnit.AddChild(fd);
-			
-			break;
-		}
-		case 72: {
-
-#line  1124 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Fields); 
-			lexer.NextToken();
-
-#line  1125 &quot;VBNET.ATG&quot; 
-			m.Add(Modifier.Constant);  
-
-#line  1127 &quot;VBNET.ATG&quot; 
-			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
-			fd.StartLocation = t.Location;
-			ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-			ArrayList constantDeclarators = new ArrayList();
-			
-			ConstantDeclarator(
-#line  1132 &quot;VBNET.ATG&quot; 
-constantDeclarators);
-
-#line  1134 &quot;VBNET.ATG&quot; 
-			((INode)constantDeclarators[0]).Specials[&quot;before&quot;] = comments;
-			
-			while (la.kind == 12) {
-				lexer.NextToken();
-				ConstantDeclarator(
-#line  1136 &quot;VBNET.ATG&quot; 
-constantDeclarators);
-			}
-
-#line  1138 &quot;VBNET.ATG&quot; 
-			fd.Fields = constantDeclarators;
-			fd.EndLocation = t.Location;
-			
-			Expect(1);
-
-#line  1143 &quot;VBNET.ATG&quot; 
-			fd.EndLocation = t.EndLocation;
-			compilationUnit.AddChild(fd);
-			
-			break;
-		}
-		case 148: {
-			lexer.NextToken();
-
-#line  1149 &quot;VBNET.ATG&quot; 
-			m.Check(Modifier.Properties);
-			Point startPos = t.Location;
-			ImplementsClause implementsClause = null;
-			
-			Identifier();
-
-#line  1153 &quot;VBNET.ATG&quot; 
-			string propertyName = t.val; 
-			if (la.kind == 25) {
-				lexer.NextToken();
-				if (StartOf(4)) {
-					FormalParameterList(
-#line  1154 &quot;VBNET.ATG&quot; 
-out p);
-				}
-				Expect(26);
-			}
-			if (la.kind == 49) {
-				lexer.NextToken();
-				TypeName(
-#line  1155 &quot;VBNET.ATG&quot; 
-out type);
-			}
-
-#line  1157 &quot;VBNET.ATG&quot; 
-			if(type == null) {
-			type = new TypeReference(&quot;System.Object&quot;);
-			}
-			
-			if (la.kind == 108) {
-				ImplementsClause(
-#line  1161 &quot;VBNET.ATG&quot; 
-out implementsClause);
-			}
-			Expect(1);
-			if (
-#line  1165 &quot;VBNET.ATG&quot; 
-IsMustOverride(m)) {
-
-#line  1167 &quot;VBNET.ATG&quot; 
-				PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
-				pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				pDecl.StartLocation = startPos;
-				pDecl.EndLocation   = t.Location;
-				pDecl.TypeReference = type;
-				pDecl.ImplementsClause = implementsClause;
-				pDecl.Parameters = p;
-				compilationUnit.AddChild(pDecl);
-				
-			} else if (la.kind == 28 || la.kind == 102 || la.kind == 158) {
-
-#line  1178 &quot;VBNET.ATG&quot; 
-				PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
-				pDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				pDecl.StartLocation = startPos;
-				pDecl.EndLocation   = t.Location;
-				pDecl.BodyStart   = t.Location;
-				pDecl.TypeReference = type;
-				pDecl.ImplementsClause = implementsClause;
-				pDecl.Parameters = p;
-				PropertyGetRegion getRegion;
-				PropertySetRegion setRegion;
-				
-				AccessorDecls(
-#line  1189 &quot;VBNET.ATG&quot; 
-out getRegion, out setRegion);
-				Expect(89);
-				Expect(148);
-				Expect(1);
-
-#line  1193 &quot;VBNET.ATG&quot; 
-				pDecl.GetRegion = getRegion;
-				pDecl.SetRegion = setRegion;
-				pDecl.BodyEnd = t.EndLocation;
-				compilationUnit.AddChild(pDecl);
-				
-			} else SynErr(206);
-			break;
-		}
-		default: SynErr(207); break;
-		}
-	}
-
-	void EnumMemberDecl(
-#line  849 &quot;VBNET.ATG&quot; 
-out FieldDeclaration f) {
-
-#line  851 &quot;VBNET.ATG&quot; 
-		Expression expr = null;
-		ArrayList attributes = new ArrayList();
-		AttributeSection section = null;
-		VariableDeclaration varDecl = null;
-		
-		while (la.kind == 28) {
-			AttributeSection(
-#line  856 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  856 &quot;VBNET.ATG&quot; 
-			attributes.Add(section); 
-		}
-		Identifier();
-
-#line  859 &quot;VBNET.ATG&quot; 
-		f = new FieldDeclaration(attributes);
-		varDecl = new VariableDeclaration(t.val);
-		varDecl.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-		f.Fields.Add(varDecl);
-		f.StartLocation = t.Location;
-		
-		if (la.kind == 11) {
-			lexer.NextToken();
-			Expr(
-#line  865 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  865 &quot;VBNET.ATG&quot; 
-			varDecl.Initializer = expr; 
-		}
-		Expect(1);
-	}
-
-	void InterfaceMemberDecl() {
-
-#line  760 &quot;VBNET.ATG&quot; 
-		TypeReference type =null;
-		ArrayList p = null;
-		AttributeSection section;
-		Modifiers mod = new Modifiers(this);
-		ArrayList attributes = new ArrayList();
-		ArrayList parameters = new ArrayList();
-		string name;
-		
-		if (StartOf(12)) {
-			while (la.kind == 28) {
-				AttributeSection(
-#line  768 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  768 &quot;VBNET.ATG&quot; 
-				attributes.Add(section); 
-			}
-			while (StartOf(6)) {
-				MemberModifier(
-#line  772 &quot;VBNET.ATG&quot; 
-mod);
-			}
-			if (la.kind == 94) {
-				lexer.NextToken();
-
-#line  775 &quot;VBNET.ATG&quot; 
-				mod.Check(Modifier.InterfaceEvents); 
-				Identifier();
-
-#line  776 &quot;VBNET.ATG&quot; 
-				name = t.val; 
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  777 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-				if (la.kind == 49) {
-					lexer.NextToken();
-					TypeName(
-#line  778 &quot;VBNET.ATG&quot; 
-out type);
-				}
-				Expect(1);
-
-#line  781 &quot;VBNET.ATG&quot; 
-				EventDeclaration ed = new EventDeclaration(type, mod.Modifier, p, attributes, name, null);
-				ed.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				compilationUnit.AddChild(ed);
-				ed.EndLocation = t.EndLocation;
-				
-			} else if (la.kind == 169) {
-				lexer.NextToken();
-
-#line  789 &quot;VBNET.ATG&quot; 
-				mod.Check(Modifier.InterfaceMethods);
-				ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-				
-				Identifier();
-
-#line  792 &quot;VBNET.ATG&quot; 
-				name = t.val; 
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  793 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-				Expect(1);
-
-#line  796 &quot;VBNET.ATG&quot; 
-				MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, null, p, attributes);
-				md.Specials[&quot;before&quot;] = comments;
-				md.EndLocation = t.EndLocation;
-				compilationUnit.AddChild(md);
-				
-			} else if (la.kind == 101) {
-				lexer.NextToken();
-
-#line  804 &quot;VBNET.ATG&quot; 
-				mod.Check(Modifier.InterfaceMethods);
-				AttributeSection attributeSection = null;
-				
-				Identifier();
-
-#line  807 &quot;VBNET.ATG&quot; 
-				name = t.val; 
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  808 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-				if (la.kind == 49) {
-					lexer.NextToken();
-					if (la.kind == 28) {
-						AttributeSection(
-#line  809 &quot;VBNET.ATG&quot; 
-out attributeSection);
-					}
-					TypeName(
-#line  809 &quot;VBNET.ATG&quot; 
-out type);
-				}
-
-#line  811 &quot;VBNET.ATG&quot; 
-				if(type == null) {
-				type = new TypeReference(&quot;System.Object&quot;);
-				}
-				type.Attributes = attributeSection;
-				MethodDeclaration md = new MethodDeclaration(name, mod.Modifier, type, p, attributes);
-				md.Specials[&quot;before&quot;] = lexer.SpecialTracker.RetreiveComments();
-				md.EndLocation = t.EndLocation;
-				compilationUnit.AddChild(md);
-				
-				Expect(1);
-			} else if (la.kind == 148) {
-				lexer.NextToken();
-
-#line  824 &quot;VBNET.ATG&quot; 
-				mod.Check(Modifier.InterfaceProperties);
-				ArrayList comments = lexer.SpecialTracker.RetreiveComments();
-				
-				Identifier();
-
-#line  827 &quot;VBNET.ATG&quot; 
-				name = t.val;  
-				if (la.kind == 25) {
-					lexer.NextToken();
-					if (StartOf(4)) {
-						FormalParameterList(
-#line  828 &quot;VBNET.ATG&quot; 
-out p);
-					}
-					Expect(26);
-				}
-				if (la.kind == 49) {
-					lexer.NextToken();
-					TypeName(
-#line  829 &quot;VBNET.ATG&quot; 
-out type);
-				}
-
-#line  831 &quot;VBNET.ATG&quot; 
-				if(type == null) {
-				type = new TypeReference(&quot;System.Object&quot;);
-				}
-				
-				Expect(1);
-
-#line  837 &quot;VBNET.ATG&quot; 
-				PropertyDeclaration pd = new PropertyDeclaration(name, type, mod.Modifier, attributes);
-				pd.Parameters = p;
-				pd.Specials[&quot;before&quot;] = comments;
-				pd.EndLocation = t.EndLocation;
-				compilationUnit.AddChild(pd);
-				
-			} else SynErr(208);
-		} else if (StartOf(13)) {
-			NonModuleDeclaration(
-#line  845 &quot;VBNET.ATG&quot; 
-mod, attributes);
-		} else SynErr(209);
-	}
-
-	void Expr(
-#line  1447 &quot;VBNET.ATG&quot; 
-out Expression expr) {
-
-#line  1448 &quot;VBNET.ATG&quot; 
-		expr = new Expression(); 
-		ConditionalOrExpr(
-#line  1449 &quot;VBNET.ATG&quot; 
-out expr);
-		while (StartOf(14)) {
-
-#line  1452 &quot;VBNET.ATG&quot; 
-			AssignmentOperatorType op; Expression val; 
-			AssignmentOperator(
-#line  1453 &quot;VBNET.ATG&quot; 
-out op);
-			Expr(
-#line  1453 &quot;VBNET.ATG&quot; 
-out val);
-
-#line  1453 &quot;VBNET.ATG&quot; 
-			expr = new AssignmentExpression(expr, op, val); 
-		}
-	}
-
-	void ImplementsClause(
-#line  1425 &quot;VBNET.ATG&quot; 
-out ImplementsClause clause) {
-
-#line  1427 &quot;VBNET.ATG&quot; 
-		clause = new ImplementsClause();
-		string typename = String.Empty;
-		string first;
-		
-		Expect(108);
-		Identifier();
-
-#line  1431 &quot;VBNET.ATG&quot; 
-		first = t.val; 
-		Expect(10);
-		Qualident(
-#line  1431 &quot;VBNET.ATG&quot; 
-out typename);
-
-#line  1431 &quot;VBNET.ATG&quot; 
-		((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); 
-		while (la.kind == 12) {
-			lexer.NextToken();
-			Identifier();
-
-#line  1432 &quot;VBNET.ATG&quot; 
-			first = t.val; 
-			Expect(10);
-			Qualident(
-#line  1432 &quot;VBNET.ATG&quot; 
-out typename);
-
-#line  1432 &quot;VBNET.ATG&quot; 
-			((ImplementsClause)clause).BaseMembers.Add(first + &quot;.&quot; + typename); 
-		}
-	}
-
-	void HandlesClause(
-#line  1383 &quot;VBNET.ATG&quot; 
-out HandlesClause handlesClause) {
-
-#line  1385 &quot;VBNET.ATG&quot; 
-		handlesClause = new HandlesClause();
-		string name;
-		
-		Expect(106);
-		EventMemberSpecifier(
-#line  1388 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  1388 &quot;VBNET.ATG&quot; 
-		handlesClause.EventNames.Add(name); 
-		while (la.kind == 12) {
-			lexer.NextToken();
-			EventMemberSpecifier(
-#line  1389 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  1389 &quot;VBNET.ATG&quot; 
-			handlesClause.EventNames.Add(name); 
-		}
-	}
-
-	void Block(
-#line  2004 &quot;VBNET.ATG&quot; 
-out Statement stmt) {
-
-#line  2007 &quot;VBNET.ATG&quot; 
-		BlockStatement blockStmt = new BlockStatement();
-		blockStmt.StartLocation = t.Location;
-		compilationUnit.BlockStart(blockStmt);
-		
-		while (StartOf(15) || 
-#line  2012 &quot;VBNET.ATG&quot; 
-IsEndStmtAhead()) {
-			if (StartOf(15)) {
-				Statement();
-				EndOfStmt();
-			} else {
-				Expect(89);
-				EndOfStmt();
-
-#line  2012 &quot;VBNET.ATG&quot; 
-				compilationUnit.AddChild(new EndStatement()); 
-			}
-		}
-
-#line  2015 &quot;VBNET.ATG&quot; 
-		stmt = blockStmt;
-		blockStmt.EndLocation = t.EndLocation;
-		compilationUnit.BlockEnd();
-		
-	}
-
-	void Charset(
-#line  1375 &quot;VBNET.ATG&quot; 
-out CharsetModifier charsetModifier) {
-
-#line  1376 &quot;VBNET.ATG&quot; 
-		charsetModifier = CharsetModifier.None; 
-		if (la.kind == 101 || la.kind == 169) {
-		} else if (la.kind == 48) {
-			lexer.NextToken();
-
-#line  1377 &quot;VBNET.ATG&quot; 
-			charsetModifier = CharsetModifier.ANSI; 
-		} else if (la.kind == 51) {
-			lexer.NextToken();
-
-#line  1378 &quot;VBNET.ATG&quot; 
-			charsetModifier = CharsetModifier.Auto; 
-		} else if (la.kind == 178) {
-			lexer.NextToken();
-
-#line  1379 &quot;VBNET.ATG&quot; 
-			charsetModifier = CharsetModifier.Unicode; 
-		} else SynErr(210);
-	}
-
-	void VariableDeclarator(
-#line  1276 &quot;VBNET.ATG&quot; 
-ArrayList fieldDeclaration) {
-
-#line  1278 &quot;VBNET.ATG&quot; 
-		Expression expr = null;
-		TypeReference type = null;
-		ObjectCreateExpression oce = null;
-		ArrayCreateExpression ace = null;
-		ArrayList rank = null;
-		ArrayList dimension = null;
-		
-		Identifier();
-
-#line  1287 &quot;VBNET.ATG&quot; 
-		VariableDeclaration f = new VariableDeclaration(t.val);
-		
-		if (
-#line  1289 &quot;VBNET.ATG&quot; 
-IsRank()) {
-			ArrayTypeModifiers(
-#line  1289 &quot;VBNET.ATG&quot; 
-out rank);
-		}
-		if (
-#line  1290 &quot;VBNET.ATG&quot; 
-IsSize()) {
-			ArrayInitializationModifier(
-#line  1290 &quot;VBNET.ATG&quot; 
-out dimension);
-		}
-		if (
-#line  1292 &quot;VBNET.ATG&quot; 
-IsObjectCreation()) {
-			Expect(49);
-			ObjectCreateExpression(
-#line  1292 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1294 &quot;VBNET.ATG&quot; 
-			if(expr is ArrayCreateExpression) {
-			ace = expr as ArrayCreateExpression;
-			f.Initializer = ace.ArrayInitializer;
-			
-			} else {
-				oce = expr as ObjectCreateExpression;
-				f.Initializer = oce;
-				if(oce.CreateType != null) {
-					f.Type = oce.CreateType;
-				}
-			}
-			
-		} else if (StartOf(16)) {
-			if (la.kind == 49) {
-				lexer.NextToken();
-				TypeName(
-#line  1307 &quot;VBNET.ATG&quot; 
-out type);
-			}
-
-#line  1309 &quot;VBNET.ATG&quot; 
-			if(type != null) {
-			type.Dimension = dimension;
-			}
-			f.Type = type;
-			if (type != null &amp;&amp; rank != null) {
-				if(type.RankSpecifier != null) {
-					Error(&quot;array rank only allowed one time&quot;);
-				} else {
-					type.RankSpecifier = rank;
-				}
-			}
-			
-			if (la.kind == 11) {
-				lexer.NextToken();
-				VariableInitializer(
-#line  1321 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1321 &quot;VBNET.ATG&quot; 
-				f.Initializer = expr; 
-			}
-		} else SynErr(211);
-
-#line  1323 &quot;VBNET.ATG&quot; 
-		fieldDeclaration.Add(f); 
-	}
-
-	void ConstantDeclarator(
-#line  1259 &quot;VBNET.ATG&quot; 
-ArrayList constantDeclaration) {
-
-#line  1261 &quot;VBNET.ATG&quot; 
-		Expression expr = null;
-		TypeReference type = null;
-		string name = String.Empty;
-		
-		Identifier();
-
-#line  1265 &quot;VBNET.ATG&quot; 
-		name = t.val; 
-		if (la.kind == 49) {
-			lexer.NextToken();
-			TypeName(
-#line  1266 &quot;VBNET.ATG&quot; 
-out type);
-		}
-		Expect(11);
-		Expr(
-#line  1267 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1269 &quot;VBNET.ATG&quot; 
-		VariableDeclaration f = new VariableDeclaration(name, expr);
-		f.Type = type;
-		constantDeclaration.Add(f);
-		
-	}
-
-	void AccessorDecls(
-#line  1202 &quot;VBNET.ATG&quot; 
-out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
-
-#line  1204 &quot;VBNET.ATG&quot; 
-		ArrayList attributes = new ArrayList(); 
-		AttributeSection section;
-		getBlock = null;
-		setBlock = null; 
-		
-		while (la.kind == 28) {
-			AttributeSection(
-#line  1209 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  1209 &quot;VBNET.ATG&quot; 
-			attributes.Add(section); 
-		}
-		if (la.kind == 102) {
-			GetAccessorDecl(
-#line  1211 &quot;VBNET.ATG&quot; 
-out getBlock, attributes);
-			if (la.kind == 28 || la.kind == 158) {
-
-#line  1213 &quot;VBNET.ATG&quot; 
-				attributes = new ArrayList(); 
-				while (la.kind == 28) {
-					AttributeSection(
-#line  1214 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  1214 &quot;VBNET.ATG&quot; 
-					attributes.Add(section); 
-				}
-				SetAccessorDecl(
-#line  1215 &quot;VBNET.ATG&quot; 
-out setBlock, attributes);
-			}
-		} else if (la.kind == 158) {
-			SetAccessorDecl(
-#line  1218 &quot;VBNET.ATG&quot; 
-out setBlock, attributes);
-			if (la.kind == 28 || la.kind == 102) {
-
-#line  1220 &quot;VBNET.ATG&quot; 
-				attributes = new ArrayList(); 
-				while (la.kind == 28) {
-					AttributeSection(
-#line  1221 &quot;VBNET.ATG&quot; 
-out section);
-
-#line  1221 &quot;VBNET.ATG&quot; 
-					attributes.Add(section); 
-				}
-				GetAccessorDecl(
-#line  1222 &quot;VBNET.ATG&quot; 
-out getBlock, attributes);
-			}
-		} else SynErr(212);
-	}
-
-	void GetAccessorDecl(
-#line  1228 &quot;VBNET.ATG&quot; 
-out PropertyGetRegion getBlock, ArrayList attributes) {
-
-#line  1229 &quot;VBNET.ATG&quot; 
-		Statement stmt = null; 
-		Expect(102);
-		Expect(1);
-		Block(
-#line  1232 &quot;VBNET.ATG&quot; 
-out stmt);
-
-#line  1234 &quot;VBNET.ATG&quot; 
-		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes);
-		
-		Expect(89);
-		Expect(102);
-		Expect(1);
-	}
-
-	void SetAccessorDecl(
-#line  1241 &quot;VBNET.ATG&quot; 
-out PropertySetRegion setBlock, ArrayList attributes) {
-
-#line  1243 &quot;VBNET.ATG&quot; 
-		Statement stmt = null;
-		ArrayList p = null;
-		
-		Expect(158);
-		if (la.kind == 25) {
-			lexer.NextToken();
-			if (StartOf(4)) {
-				FormalParameterList(
-#line  1247 &quot;VBNET.ATG&quot; 
-out p);
-			}
-			Expect(26);
-		}
-		Expect(1);
-		Block(
-#line  1249 &quot;VBNET.ATG&quot; 
-out stmt);
-
-#line  1251 &quot;VBNET.ATG&quot; 
-		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes);
-		setBlock.Parameters = p;
-		
-		Expect(89);
-		Expect(158);
-		Expect(1);
-	}
-
-	void ArrayTypeModifiers(
-#line  1813 &quot;VBNET.ATG&quot; 
-out ArrayList arrayModifiers) {
-
-#line  1815 &quot;VBNET.ATG&quot; 
-		arrayModifiers = new ArrayList();
-		int i = 0;
-		
-		while (
-#line  1818 &quot;VBNET.ATG&quot; 
-IsRank()) {
-			Expect(25);
-			if (la.kind == 12 || la.kind == 26) {
-				RankList(
-#line  1820 &quot;VBNET.ATG&quot; 
-out i);
-			}
-
-#line  1822 &quot;VBNET.ATG&quot; 
-			arrayModifiers.Add(i);
-			
-			Expect(26);
-		}
-
-#line  1827 &quot;VBNET.ATG&quot; 
-		if(arrayModifiers.Count == 0) {
-		 arrayModifiers = null;
-		}
-		
-	}
-
-	void ArrayInitializationModifier(
-#line  1327 &quot;VBNET.ATG&quot; 
-out ArrayList arrayModifiers) {
-
-#line  1329 &quot;VBNET.ATG&quot; 
-		arrayModifiers = null;
-		
-		Expect(25);
-		InitializationRankList(
-#line  1331 &quot;VBNET.ATG&quot; 
-out arrayModifiers);
-		Expect(26);
-	}
-
-	void ObjectCreateExpression(
-#line  1701 &quot;VBNET.ATG&quot; 
-out Expression oce) {
-
-#line  1703 &quot;VBNET.ATG&quot; 
-		TypeReference type = null;
-		Expression initializer = null;
-		ArrayList arguments = null;
-		oce = null;
-		
-		Expect(128);
-		ArrayTypeName(
-#line  1708 &quot;VBNET.ATG&quot; 
-out type);
-		if (la.kind == 25) {
-			lexer.NextToken();
-			if (StartOf(17)) {
-				ArgumentList(
-#line  1710 &quot;VBNET.ATG&quot; 
-out arguments);
-			}
-			Expect(26);
-		}
-		if (la.kind == 21) {
-			ArrayInitializer(
-#line  1714 &quot;VBNET.ATG&quot; 
-out initializer);
-		}
-
-#line  1717 &quot;VBNET.ATG&quot; 
-		if(initializer == null) {
-		oce = new ObjectCreateExpression(type, arguments);
-		} else {
-			ArrayCreateExpression ace = new ArrayCreateExpression(type, initializer as ArrayInitializerExpression);
-			ace.Parameters = arguments;
-			oce = ace;
-		}
-		
-	}
-
-	void VariableInitializer(
-#line  1347 &quot;VBNET.ATG&quot; 
-out Expression initializerExpression) {
-
-#line  1349 &quot;VBNET.ATG&quot; 
-		initializerExpression = null;
-		
-		if (StartOf(18)) {
-			Expr(
-#line  1351 &quot;VBNET.ATG&quot; 
-out initializerExpression);
-		} else if (la.kind == 21) {
-			ArrayInitializer(
-#line  1352 &quot;VBNET.ATG&quot; 
-out initializerExpression);
-		} else SynErr(213);
-	}
-
-	void InitializationRankList(
-#line  1335 &quot;VBNET.ATG&quot; 
-out ArrayList rank) {
-
-#line  1337 &quot;VBNET.ATG&quot; 
-		rank = null;
-		Expression expr = null;
-		
-		Expr(
-#line  1340 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1340 &quot;VBNET.ATG&quot; 
-		rank = new ArrayList(); rank.Add(expr); 
-		while (la.kind == 12) {
-			lexer.NextToken();
-			Expr(
-#line  1342 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1342 &quot;VBNET.ATG&quot; 
-			rank.Add(expr); 
-		}
-	}
-
-	void ArrayInitializer(
-#line  1356 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1358 &quot;VBNET.ATG&quot; 
-		Expression expr = null;
-		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
-		
-		Expect(21);
-		if (StartOf(19)) {
-			VariableInitializer(
-#line  1363 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1365 &quot;VBNET.ATG&quot; 
-			initializer.CreateExpressions.Add(expr);
-			
-			while (
-#line  1368 &quot;VBNET.ATG&quot; 
-NotFinalComma()) {
-				Expect(12);
-				VariableInitializer(
-#line  1368 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1369 &quot;VBNET.ATG&quot; 
-				initializer.CreateExpressions.Add(expr); 
-			}
-		}
-		Expect(22);
-
-#line  1372 &quot;VBNET.ATG&quot; 
-		outExpr = initializer; 
-	}
-
-	void EventMemberSpecifier(
-#line  1435 &quot;VBNET.ATG&quot; 
-out string name) {
-
-#line  1436 &quot;VBNET.ATG&quot; 
-		string type; name = String.Empty; 
-		if (StartOf(9)) {
-			Identifier();
-
-#line  1437 &quot;VBNET.ATG&quot; 
-			type = t.val; 
-			Expect(10);
-			Identifier();
-
-#line  1439 &quot;VBNET.ATG&quot; 
-			name = type + &quot;.&quot; + t.val; 
-		} else if (la.kind == 125) {
-			lexer.NextToken();
-			Expect(10);
-			if (StartOf(9)) {
-				Identifier();
-
-#line  1442 &quot;VBNET.ATG&quot; 
-				name = &quot;MyBase.&quot; + t.val; 
-			} else if (la.kind == 93) {
-				lexer.NextToken();
-
-#line  1443 &quot;VBNET.ATG&quot; 
-				name = &quot;MyBase.Error&quot;; 
-			} else SynErr(214);
-		} else SynErr(215);
-	}
-
-	void ConditionalOrExpr(
-#line  1581 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1582 &quot;VBNET.ATG&quot; 
-		Expression expr; 
-		ConditionalAndExpr(
-#line  1583 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (la.kind == 140) {
-			lexer.NextToken();
-			ConditionalAndExpr(
-#line  1583 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1583 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanOr, expr);  
-		}
-	}
-
-	void AssignmentOperator(
-#line  1478 &quot;VBNET.ATG&quot; 
-out AssignmentOperatorType op) {
-
-#line  1479 &quot;VBNET.ATG&quot; 
-		op = AssignmentOperatorType.None; 
-		switch (la.kind) {
-		case 11: {
-			lexer.NextToken();
-
-#line  1480 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.Assign; 
-			break;
-		}
-		case 42: {
-			lexer.NextToken();
-
-#line  1481 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.ConcatString; 
-			break;
-		}
-		case 34: {
-			lexer.NextToken();
-
-#line  1482 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.Add; 
-			break;
-		}
-		case 36: {
-			lexer.NextToken();
-
-#line  1483 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.Subtract; 
-			break;
-		}
-		case 37: {
-			lexer.NextToken();
-
-#line  1484 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.Multiply; 
-			break;
-		}
-		case 38: {
-			lexer.NextToken();
-
-#line  1485 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.Divide; 
-			break;
-		}
-		case 39: {
-			lexer.NextToken();
-
-#line  1486 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.DivideInteger; 
-			break;
-		}
-		case 35: {
-			lexer.NextToken();
-
-#line  1487 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.Power; 
-			break;
-		}
-		case 40: {
-			lexer.NextToken();
-
-#line  1488 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.ShiftLeft; 
-			break;
-		}
-		case 41: {
-			lexer.NextToken();
-
-#line  1489 &quot;VBNET.ATG&quot; 
-			op = AssignmentOperatorType.ShiftRight; 
-			break;
-		}
-		default: SynErr(216); break;
-		}
-	}
-
-	void UnaryExpr(
-#line  1457 &quot;VBNET.ATG&quot; 
-out Expression uExpr) {
-
-#line  1459 &quot;VBNET.ATG&quot; 
-		Expression expr;
-		UnaryOperatorType uop = UnaryOperatorType.None;
-		bool isUOp = false;
-		
-		while (la.kind == 14 || la.kind == 15 || la.kind == 16) {
-			if (la.kind == 14) {
-				lexer.NextToken();
-
-#line  1463 &quot;VBNET.ATG&quot; 
-				uop = UnaryOperatorType.Plus; isUOp = true; 
-			} else if (la.kind == 15) {
-				lexer.NextToken();
-
-#line  1464 &quot;VBNET.ATG&quot; 
-				uop = UnaryOperatorType.Minus; isUOp = true; 
-			} else {
-				lexer.NextToken();
-
-#line  1466 &quot;VBNET.ATG&quot; 
-				uop = UnaryOperatorType.Star;  isUOp = true;
-			}
-		}
-		SimpleExpr(
-#line  1468 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1470 &quot;VBNET.ATG&quot; 
-		if (isUOp) {
-		uExpr = new UnaryOperatorExpression(expr, uop);
-		} else {
-			uExpr = expr;
-		}
-		
-	}
-
-	void SimpleExpr(
-#line  1493 &quot;VBNET.ATG&quot; 
-out Expression pexpr) {
-
-#line  1495 &quot;VBNET.ATG&quot; 
-		Expression expr;
-		TypeReference type = null;
-		string name = String.Empty;
-		pexpr = null;
-		
-		if (StartOf(20)) {
-			switch (la.kind) {
-			case 3: {
-				lexer.NextToken();
-
-#line  1503 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
-				break;
-			}
-			case 4: {
-				lexer.NextToken();
-
-#line  1504 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
-				break;
-			}
-			case 7: {
-				lexer.NextToken();
-
-#line  1505 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
-				break;
-			}
-			case 6: {
-				lexer.NextToken();
-
-#line  1506 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
-				break;
-			}
-			case 5: {
-				lexer.NextToken();
-
-#line  1507 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
-				break;
-			}
-			case 9: {
-				lexer.NextToken();
-
-#line  1508 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
-				break;
-			}
-			case 8: {
-				lexer.NextToken();
-
-#line  1509 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(t.literalValue, t.val);  
-				break;
-			}
-			case 175: {
-				lexer.NextToken();
-
-#line  1511 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(true, &quot;true&quot;);  
-				break;
-			}
-			case 97: {
-				lexer.NextToken();
-
-#line  1512 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(false, &quot;false&quot;); 
-				break;
-			}
-			case 131: {
-				lexer.NextToken();
-
-#line  1513 &quot;VBNET.ATG&quot; 
-				pexpr = new PrimitiveExpression(null, &quot;null&quot;);  
-				break;
-			}
-			case 25: {
-				lexer.NextToken();
-				Expr(
-#line  1514 &quot;VBNET.ATG&quot; 
-out expr);
-				Expect(26);
-
-#line  1514 &quot;VBNET.ATG&quot; 
-				pexpr = new ParenthesizedExpression(expr); 
-				break;
-			}
-			case 2: case 52: case 71: case 171: {
-				Identifier();
-
-#line  1515 &quot;VBNET.ATG&quot; 
-				pexpr = new IdentifierExpression(t.val); 
-				break;
-			}
-			case 53: case 55: case 66: case 77: case 78: case 85: case 112: case 118: case 161: case 162: case 167: {
-
-#line  1516 &quot;VBNET.ATG&quot; 
-				string val = String.Empty; 
-				PrimitiveTypeName(
-#line  1516 &quot;VBNET.ATG&quot; 
-out val);
-				Expect(10);
-				Identifier();
-
-#line  1517 &quot;VBNET.ATG&quot; 
-				pexpr = new FieldReferenceOrInvocationExpression(new TypeReferenceExpression(val), t.val); 
-				break;
-			}
-			case 120: {
-				lexer.NextToken();
-
-#line  1518 &quot;VBNET.ATG&quot; 
-				pexpr = new ThisReferenceExpression(); 
-				break;
-			}
-			case 125: case 126: {
-
-#line  1519 &quot;VBNET.ATG&quot; 
-				Expression retExpr = null; 
-				if (la.kind == 125) {
-					lexer.NextToken();
-
-#line  1520 &quot;VBNET.ATG&quot; 
-					retExpr = new BaseReferenceExpression(); 
-				} else if (la.kind == 126) {
-					lexer.NextToken();
-
-#line  1521 &quot;VBNET.ATG&quot; 
-					retExpr = new ClassReferenceExpression(); 
-				} else SynErr(217);
-				Expect(10);
-				IdentifierOrKeyword(
-#line  1523 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  1523 &quot;VBNET.ATG&quot; 
-				pexpr = new FieldReferenceOrInvocationExpression(retExpr, name); 
-				break;
-			}
-			case 128: {
-				ObjectCreateExpression(
-#line  1524 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1524 &quot;VBNET.ATG&quot; 
-				pexpr = expr; 
-				break;
-			}
-			case 76: case 83: {
-				if (la.kind == 83) {
-					lexer.NextToken();
-				} else if (la.kind == 76) {
-					lexer.NextToken();
-				} else SynErr(218);
-				Expect(25);
-				Expr(
-#line  1525 &quot;VBNET.ATG&quot; 
-out expr);
-				Expect(12);
-				TypeName(
-#line  1525 &quot;VBNET.ATG&quot; 
-out type);
-				Expect(26);
-
-#line  1525 &quot;VBNET.ATG&quot; 
-				pexpr = new CastExpression(type, expr); 
-				break;
-			}
-			case 60: case 61: case 62: case 63: case 64: case 65: case 67: case 69: case 70: case 73: case 74: case 75: {
-				CastTarget(
-#line  1526 &quot;VBNET.ATG&quot; 
-out type);
-				Expect(25);
-				Expr(
-#line  1526 &quot;VBNET.ATG&quot; 
-out expr);
-				Expect(26);
-
-#line  1526 &quot;VBNET.ATG&quot; 
-				pexpr = new CastExpression(type, expr, true); 
-				break;
-			}
-			case 44: {
-				lexer.NextToken();
-				Expr(
-#line  1527 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1527 &quot;VBNET.ATG&quot; 
-				pexpr = new AddressOfExpression(expr); 
-				break;
-			}
-			case 103: {
-				lexer.NextToken();
-				Expect(25);
-				TypeName(
-#line  1528 &quot;VBNET.ATG&quot; 
-out type);
-				Expect(26);
-
-#line  1528 &quot;VBNET.ATG&quot; 
-				pexpr = new GetTypeExpression(type); 
-				break;
-			}
-			case 177: {
-				lexer.NextToken();
-				SimpleExpr(
-#line  1529 &quot;VBNET.ATG&quot; 
-out expr);
-				Expect(114);
-				TypeName(
-#line  1529 &quot;VBNET.ATG&quot; 
-out type);
-
-#line  1529 &quot;VBNET.ATG&quot; 
-				pexpr = new TypeOfExpression(expr, type); 
-				break;
-			}
-			}
-			while (la.kind == 10 || la.kind == 25) {
-				if (la.kind == 10) {
-					lexer.NextToken();
-					IdentifierOrKeyword(
-#line  1532 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  1532 &quot;VBNET.ATG&quot; 
-					pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); 
-				} else {
-					lexer.NextToken();
-
-#line  1533 &quot;VBNET.ATG&quot; 
-					ArrayList parameters = new ArrayList(); 
-					if (StartOf(21)) {
-
-#line  1535 &quot;VBNET.ATG&quot; 
-						expr = null; 
-						if (StartOf(18)) {
-							Argument(
-#line  1535 &quot;VBNET.ATG&quot; 
-out expr);
-						}
-
-#line  1535 &quot;VBNET.ATG&quot; 
-						parameters.Add(expr); 
-						while (la.kind == 12) {
-							lexer.NextToken();
-
-#line  1537 &quot;VBNET.ATG&quot; 
-							expr = null; 
-							if (StartOf(18)) {
-								Argument(
-#line  1538 &quot;VBNET.ATG&quot; 
-out expr);
-							}
-
-#line  1538 &quot;VBNET.ATG&quot; 
-							parameters.Add(expr); 
-						}
-					}
-					Expect(26);
-
-#line  1541 &quot;VBNET.ATG&quot; 
-					pexpr = new InvocationExpression(pexpr, parameters); 
-				}
-			}
-		} else if (la.kind == 10) {
-			lexer.NextToken();
-			IdentifierOrKeyword(
-#line  1545 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  1545 &quot;VBNET.ATG&quot; 
-			pexpr = new FieldReferenceOrInvocationExpression(pexpr, name);
-			while (la.kind == 10 || la.kind == 25) {
-				if (la.kind == 10) {
-					lexer.NextToken();
-					IdentifierOrKeyword(
-#line  1547 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  1547 &quot;VBNET.ATG&quot; 
-					pexpr = new FieldReferenceOrInvocationExpression(pexpr, name); 
-				} else {
-					lexer.NextToken();
-
-#line  1548 &quot;VBNET.ATG&quot; 
-					ArrayList parameters = new ArrayList(); 
-					if (StartOf(21)) {
-
-#line  1550 &quot;VBNET.ATG&quot; 
-						expr = null; 
-						if (StartOf(18)) {
-							Argument(
-#line  1550 &quot;VBNET.ATG&quot; 
-out expr);
-						}
-
-#line  1550 &quot;VBNET.ATG&quot; 
-						parameters.Add(expr); 
-						while (la.kind == 12) {
-							lexer.NextToken();
-
-#line  1552 &quot;VBNET.ATG&quot; 
-							expr = null; 
-							if (StartOf(18)) {
-								Argument(
-#line  1553 &quot;VBNET.ATG&quot; 
-out expr);
-							}
-
-#line  1553 &quot;VBNET.ATG&quot; 
-							parameters.Add(expr); 
-						}
-					}
-					Expect(26);
-
-#line  1556 &quot;VBNET.ATG&quot; 
-					pexpr = new InvocationExpression(pexpr, parameters); 
-				}
-			}
-		} else SynErr(219);
-	}
-
-	void IdentifierOrKeyword(
-#line  2547 &quot;VBNET.ATG&quot; 
-out string name) {
-
-#line  2549 &quot;VBNET.ATG&quot; 
-		name = String.Empty;
-		
-		switch (la.kind) {
-		case 2: case 52: case 71: case 171: {
-			Identifier();
-
-#line  2551 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 43: {
-			lexer.NextToken();
-
-#line  2552 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 44: {
-			lexer.NextToken();
-
-#line  2553 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 45: {
-			lexer.NextToken();
-
-#line  2554 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 46: {
-			lexer.NextToken();
-
-#line  2555 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 47: {
-			lexer.NextToken();
-
-#line  2556 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 48: {
-			lexer.NextToken();
-
-#line  2557 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 49: {
-			lexer.NextToken();
-
-#line  2558 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 50: {
-			lexer.NextToken();
-
-#line  2559 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 51: {
-			lexer.NextToken();
-
-#line  2560 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 53: {
-			lexer.NextToken();
-
-#line  2561 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 54: {
-			lexer.NextToken();
-
-#line  2562 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 55: {
-			lexer.NextToken();
-
-#line  2563 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 56: {
-			lexer.NextToken();
-
-#line  2564 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 57: {
-			lexer.NextToken();
-
-#line  2565 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 58: {
-			lexer.NextToken();
-
-#line  2566 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 59: {
-			lexer.NextToken();
-
-#line  2567 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 60: {
-			lexer.NextToken();
-
-#line  2568 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 61: {
-			lexer.NextToken();
-
-#line  2569 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 62: {
-			lexer.NextToken();
-
-#line  2570 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 63: {
-			lexer.NextToken();
-
-#line  2571 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 64: {
-			lexer.NextToken();
-
-#line  2572 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 65: {
-			lexer.NextToken();
-
-#line  2573 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 66: {
-			lexer.NextToken();
-
-#line  2574 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 67: {
-			lexer.NextToken();
-
-#line  2575 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 68: {
-			lexer.NextToken();
-
-#line  2576 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 69: {
-			lexer.NextToken();
-
-#line  2577 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 70: {
-			lexer.NextToken();
-
-#line  2578 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 72: {
-			lexer.NextToken();
-
-#line  2579 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 73: {
-			lexer.NextToken();
-
-#line  2580 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 74: {
-			lexer.NextToken();
-
-#line  2581 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 75: {
-			lexer.NextToken();
-
-#line  2582 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 76: {
-			lexer.NextToken();
-
-#line  2583 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 77: {
-			lexer.NextToken();
-
-#line  2584 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 78: {
-			lexer.NextToken();
-
-#line  2585 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 79: {
-			lexer.NextToken();
-
-#line  2586 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 80: {
-			lexer.NextToken();
-
-#line  2587 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 81: {
-			lexer.NextToken();
-
-#line  2588 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 82: {
-			lexer.NextToken();
-
-#line  2589 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 83: {
-			lexer.NextToken();
-
-#line  2590 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 84: {
-			lexer.NextToken();
-
-#line  2591 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 85: {
-			lexer.NextToken();
-
-#line  2592 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 86: {
-			lexer.NextToken();
-
-#line  2593 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 87: {
-			lexer.NextToken();
-
-#line  2594 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 88: {
-			lexer.NextToken();
-
-#line  2595 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 89: {
-			lexer.NextToken();
-
-#line  2596 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 90: {
-			lexer.NextToken();
-
-#line  2597 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 91: {
-			lexer.NextToken();
-
-#line  2598 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 92: {
-			lexer.NextToken();
-
-#line  2599 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 93: {
-			lexer.NextToken();
-
-#line  2600 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 94: {
-			lexer.NextToken();
-
-#line  2601 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 95: {
-			lexer.NextToken();
-
-#line  2602 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 97: {
-			lexer.NextToken();
-
-#line  2603 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 98: {
-			lexer.NextToken();
-
-#line  2604 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 99: {
-			lexer.NextToken();
-
-#line  2605 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 100: {
-			lexer.NextToken();
-
-#line  2606 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 101: {
-			lexer.NextToken();
-
-#line  2607 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 102: {
-			lexer.NextToken();
-
-#line  2608 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 103: {
-			lexer.NextToken();
-
-#line  2609 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 104: {
-			lexer.NextToken();
-
-#line  2610 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 105: {
-			lexer.NextToken();
-
-#line  2611 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 106: {
-			lexer.NextToken();
-
-#line  2612 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 107: {
-			lexer.NextToken();
-
-#line  2613 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 108: {
-			lexer.NextToken();
-
-#line  2614 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 109: {
-			lexer.NextToken();
-
-#line  2615 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 110: {
-			lexer.NextToken();
-
-#line  2616 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 111: {
-			lexer.NextToken();
-
-#line  2617 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 112: {
-			lexer.NextToken();
-
-#line  2618 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 113: {
-			lexer.NextToken();
-
-#line  2619 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 114: {
-			lexer.NextToken();
-
-#line  2620 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 115: {
-			lexer.NextToken();
-
-#line  2621 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 116: {
-			lexer.NextToken();
-
-#line  2622 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 117: {
-			lexer.NextToken();
-
-#line  2623 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 118: {
-			lexer.NextToken();
-
-#line  2624 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 119: {
-			lexer.NextToken();
-
-#line  2625 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 120: {
-			lexer.NextToken();
-
-#line  2626 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 121: {
-			lexer.NextToken();
-
-#line  2627 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 122: {
-			lexer.NextToken();
-
-#line  2628 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 123: {
-			lexer.NextToken();
-
-#line  2629 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 124: {
-			lexer.NextToken();
-
-#line  2630 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 125: {
-			lexer.NextToken();
-
-#line  2631 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 126: {
-			lexer.NextToken();
-
-#line  2632 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 127: {
-			lexer.NextToken();
-
-#line  2633 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 128: {
-			lexer.NextToken();
-
-#line  2634 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 129: {
-			lexer.NextToken();
-
-#line  2635 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 130: {
-			lexer.NextToken();
-
-#line  2636 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 131: {
-			lexer.NextToken();
-
-#line  2637 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 132: {
-			lexer.NextToken();
-
-#line  2638 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 133: {
-			lexer.NextToken();
-
-#line  2639 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 134: {
-			lexer.NextToken();
-
-#line  2640 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 136: {
-			lexer.NextToken();
-
-#line  2641 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 137: {
-			lexer.NextToken();
-
-#line  2642 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 138: {
-			lexer.NextToken();
-
-#line  2643 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 139: {
-			lexer.NextToken();
-
-#line  2644 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 140: {
-			lexer.NextToken();
-
-#line  2645 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 141: {
-			lexer.NextToken();
-
-#line  2646 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 142: {
-			lexer.NextToken();
-
-#line  2647 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 144: {
-			lexer.NextToken();
-
-#line  2648 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 145: {
-			lexer.NextToken();
-
-#line  2649 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 146: {
-			lexer.NextToken();
-
-#line  2650 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 147: {
-			lexer.NextToken();
-
-#line  2651 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 148: {
-			lexer.NextToken();
-
-#line  2652 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 149: {
-			lexer.NextToken();
-
-#line  2653 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 150: {
-			lexer.NextToken();
-
-#line  2654 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 151: {
-			lexer.NextToken();
-
-#line  2655 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 152: {
-			lexer.NextToken();
-
-#line  2656 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 153: {
-			lexer.NextToken();
-
-#line  2657 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 154: {
-			lexer.NextToken();
-
-#line  2658 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 155: {
-			lexer.NextToken();
-
-#line  2659 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 156: {
-			lexer.NextToken();
-
-#line  2660 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 157: {
-			lexer.NextToken();
-
-#line  2661 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 158: {
-			lexer.NextToken();
-
-#line  2662 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 159: {
-			lexer.NextToken();
-
-#line  2663 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 160: {
-			lexer.NextToken();
-
-#line  2664 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 161: {
-			lexer.NextToken();
-
-#line  2665 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 162: {
-			lexer.NextToken();
-
-#line  2666 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 163: {
-			lexer.NextToken();
-
-#line  2667 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 164: {
-			lexer.NextToken();
-
-#line  2668 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 165: {
-			lexer.NextToken();
-
-#line  2669 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 167: {
-			lexer.NextToken();
-
-#line  2670 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 168: {
-			lexer.NextToken();
-
-#line  2671 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 169: {
-			lexer.NextToken();
-
-#line  2672 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 170: {
-			lexer.NextToken();
-
-#line  2673 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 172: {
-			lexer.NextToken();
-
-#line  2674 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 173: {
-			lexer.NextToken();
-
-#line  2675 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 174: {
-			lexer.NextToken();
-
-#line  2676 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 175: {
-			lexer.NextToken();
-
-#line  2677 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 176: {
-			lexer.NextToken();
-
-#line  2678 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 177: {
-			lexer.NextToken();
-
-#line  2679 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 178: {
-			lexer.NextToken();
-
-#line  2680 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 179: {
-			lexer.NextToken();
-
-#line  2681 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 180: {
-			lexer.NextToken();
-
-#line  2682 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 181: {
-			lexer.NextToken();
-
-#line  2683 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 182: {
-			lexer.NextToken();
-
-#line  2684 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 183: {
-			lexer.NextToken();
-
-#line  2685 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 184: {
-			lexer.NextToken();
-
-#line  2686 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 185: {
-			lexer.NextToken();
-
-#line  2687 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 186: {
-			lexer.NextToken();
-
-#line  2688 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		case 187: {
-			lexer.NextToken();
-
-#line  2689 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			break;
-		}
-		default: SynErr(220); break;
-		}
-	}
-
-	void CastTarget(
-#line  1563 &quot;VBNET.ATG&quot; 
-out TypeReference type) {
-
-#line  1565 &quot;VBNET.ATG&quot; 
-		type = null;
-		
-		switch (la.kind) {
-		case 60: {
-			lexer.NextToken();
-
-#line  1567 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Boolean&quot;); 
-			break;
-		}
-		case 61: {
-			lexer.NextToken();
-
-#line  1568 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Byte&quot;); 
-			break;
-		}
-		case 62: {
-			lexer.NextToken();
-
-#line  1569 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Char&quot;); 
-			break;
-		}
-		case 63: {
-			lexer.NextToken();
-
-#line  1570 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.DateTime&quot;); 
-			break;
-		}
-		case 65: {
-			lexer.NextToken();
-
-#line  1571 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Decimal&quot;); 
-			break;
-		}
-		case 64: {
-			lexer.NextToken();
-
-#line  1572 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Double&quot;); 
-			break;
-		}
-		case 67: {
-			lexer.NextToken();
-
-#line  1573 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Int32&quot;); 
-			break;
-		}
-		case 69: {
-			lexer.NextToken();
-
-#line  1574 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Int64&quot;); 
-			break;
-		}
-		case 70: {
-			lexer.NextToken();
-
-#line  1575 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Object&quot;); 
-			break;
-		}
-		case 73: {
-			lexer.NextToken();
-
-#line  1576 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Int16&quot;); 
-			break;
-		}
-		case 74: {
-			lexer.NextToken();
-
-#line  1577 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.Single&quot;); 
-			break;
-		}
-		case 75: {
-			lexer.NextToken();
-
-#line  1578 &quot;VBNET.ATG&quot; 
-			type = new TypeReference(&quot;System.String&quot;); 
-			break;
-		}
-		default: SynErr(221); break;
-		}
-	}
-
-	void Argument(
-#line  1743 &quot;VBNET.ATG&quot; 
-out Expression argumentexpr) {
-
-#line  1745 &quot;VBNET.ATG&quot; 
-		Expression expr;
-		argumentexpr = null;
-		string name;
-		
-		if (
-#line  1749 &quot;VBNET.ATG&quot; 
-IsNamedAssign()) {
-			Identifier();
-
-#line  1749 &quot;VBNET.ATG&quot; 
-			name = t.val;  
-			Expect(13);
-			Expect(11);
-			Expr(
-#line  1749 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1751 &quot;VBNET.ATG&quot; 
-			argumentexpr = new NamedArgumentExpression(name, expr);
-			
-		} else if (StartOf(18)) {
-			Expr(
-#line  1754 &quot;VBNET.ATG&quot; 
-out argumentexpr);
-		} else SynErr(222);
-	}
-
-	void ConditionalAndExpr(
-#line  1586 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1587 &quot;VBNET.ATG&quot; 
-		Expression expr; 
-		InclusiveOrExpr(
-#line  1588 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (la.kind == 47) {
-			lexer.NextToken();
-			InclusiveOrExpr(
-#line  1588 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1588 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BooleanAnd, expr);  
-		}
-	}
-
-	void InclusiveOrExpr(
-#line  1591 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1592 &quot;VBNET.ATG&quot; 
-		Expression expr; 
-		ExclusiveOrExpr(
-#line  1593 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (la.kind == 187) {
-			lexer.NextToken();
-			ExclusiveOrExpr(
-#line  1593 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1593 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  
-		}
-	}
-
-	void ExclusiveOrExpr(
-#line  1596 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1597 &quot;VBNET.ATG&quot; 
-		Expression expr; 
-		AndExpr(
-#line  1598 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (la.kind == 139) {
-			lexer.NextToken();
-			AndExpr(
-#line  1598 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1598 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  
-		}
-	}
-
-	void AndExpr(
-#line  1601 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1602 &quot;VBNET.ATG&quot; 
-		Expression expr; 
-		NotExpr(
-#line  1603 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (la.kind == 46) {
-			lexer.NextToken();
-			NotExpr(
-#line  1603 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1603 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  
-		}
-	}
-
-	void NotExpr(
-#line  1606 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1607 &quot;VBNET.ATG&quot; 
-		UnaryOperatorType uop = UnaryOperatorType.None; 
-		while (la.kind == 130) {
-			lexer.NextToken();
-
-#line  1608 &quot;VBNET.ATG&quot; 
-			uop = UnaryOperatorType.Not; 
-		}
-		EqualityExpr(
-#line  1609 &quot;VBNET.ATG&quot; 
-out outExpr);
-
-#line  1610 &quot;VBNET.ATG&quot; 
-		if (uop != UnaryOperatorType.None)
-		outExpr = new UnaryOperatorExpression(outExpr, uop);
-		
-	}
-
-	void EqualityExpr(
-#line  1615 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1617 &quot;VBNET.ATG&quot; 
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-		
-		RelationalExpr(
-#line  1620 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (la.kind == 11 || la.kind == 29 || la.kind == 117) {
-			if (la.kind == 29) {
-				lexer.NextToken();
-
-#line  1623 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.InEquality; 
-			} else if (la.kind == 11) {
-				lexer.NextToken();
-
-#line  1624 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Equality; 
-			} else {
-				lexer.NextToken();
-
-#line  1625 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Like; 
-			}
-			RelationalExpr(
-#line  1627 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1627 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
-		}
-	}
-
-	void RelationalExpr(
-#line  1631 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1633 &quot;VBNET.ATG&quot; 
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-		
-		ShiftExpr(
-#line  1636 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (StartOf(22)) {
-			if (StartOf(23)) {
-				if (la.kind == 28) {
-					lexer.NextToken();
-
-#line  1639 &quot;VBNET.ATG&quot; 
-					op = BinaryOperatorType.LessThan; 
-				} else if (la.kind == 27) {
-					lexer.NextToken();
-
-#line  1640 &quot;VBNET.ATG&quot; 
-					op = BinaryOperatorType.GreaterThan; 
-				} else if (la.kind == 31) {
-					lexer.NextToken();
-
-#line  1641 &quot;VBNET.ATG&quot; 
-					op = BinaryOperatorType.LessThanOrEqual; 
-				} else if (la.kind == 30) {
-					lexer.NextToken();
-
-#line  1642 &quot;VBNET.ATG&quot; 
-					op = BinaryOperatorType.GreaterThanOrEqual; 
-				} else SynErr(223);
-				ShiftExpr(
-#line  1644 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1644 &quot;VBNET.ATG&quot; 
-				outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
-			} else {
-				lexer.NextToken();
-
-#line  1647 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.IS; 
-				Expr(
-#line  1648 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1648 &quot;VBNET.ATG&quot; 
-				outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
-			}
-		}
-	}
-
-	void ShiftExpr(
-#line  1652 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1654 &quot;VBNET.ATG&quot; 
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-		
-		AdditiveExpr(
-#line  1657 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (la.kind == 32 || la.kind == 33) {
-			if (la.kind == 32) {
-				lexer.NextToken();
-
-#line  1660 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.ShiftLeft; 
-			} else {
-				lexer.NextToken();
-
-#line  1661 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.ShiftRight; 
-			}
-			AdditiveExpr(
-#line  1663 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1663 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
-		}
-	}
-
-	void AdditiveExpr(
-#line  1667 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1669 &quot;VBNET.ATG&quot; 
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-		
-		MultiplicativeExpr(
-#line  1672 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (la.kind == 14 || la.kind == 15 || la.kind == 19) {
-			if (la.kind == 14) {
-				lexer.NextToken();
-
-#line  1675 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Add; 
-			} else if (la.kind == 15) {
-				lexer.NextToken();
-
-#line  1676 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Subtract; 
-			} else {
-				lexer.NextToken();
-
-#line  1677 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Concat; 
-			}
-			MultiplicativeExpr(
-#line  1679 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1679 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
-		}
-	}
-
-	void MultiplicativeExpr(
-#line  1683 &quot;VBNET.ATG&quot; 
-out Expression outExpr) {
-
-#line  1685 &quot;VBNET.ATG&quot; 
-		Expression expr;
-		BinaryOperatorType op = BinaryOperatorType.None;
-		
-		UnaryExpr(
-#line  1688 &quot;VBNET.ATG&quot; 
-out outExpr);
-		while (StartOf(24)) {
-			if (la.kind == 16) {
-				lexer.NextToken();
-
-#line  1691 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Multiply; 
-			} else if (la.kind == 17) {
-				lexer.NextToken();
-
-#line  1692 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Divide; 
-			} else if (la.kind == 18) {
-				lexer.NextToken();
-
-#line  1693 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.DivideInteger; 
-			} else if (la.kind == 121) {
-				lexer.NextToken();
-
-#line  1694 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Modulus; 
-			} else {
-				lexer.NextToken();
-
-#line  1695 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Power; 
-			}
-			UnaryExpr(
-#line  1697 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1697 &quot;VBNET.ATG&quot; 
-			outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
-		}
-	}
-
-	void ArrayTypeName(
-#line  1770 &quot;VBNET.ATG&quot; 
-out TypeReference typeref) {
-
-#line  1772 &quot;VBNET.ATG&quot; 
-		ArrayList rank = null;
-		
-		NonArrayTypeName(
-#line  1774 &quot;VBNET.ATG&quot; 
-out typeref);
-		ArrayInitializationModifiers(
-#line  1775 &quot;VBNET.ATG&quot; 
-out rank);
-
-#line  1777 &quot;VBNET.ATG&quot; 
-		typeref = new TypeReference(typeref == null ? &quot;UNKNOWN&quot; : typeref.Type, rank);
-		
-	}
-
-	void ArgumentList(
-#line  1728 &quot;VBNET.ATG&quot; 
-out ArrayList arguments) {
-
-#line  1730 &quot;VBNET.ATG&quot; 
-		arguments = new ArrayList();
-		Expression expr = null;
-		
-		if (StartOf(18)) {
-			Argument(
-#line  1734 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1734 &quot;VBNET.ATG&quot; 
-			arguments.Add(expr); 
-			while (la.kind == 12) {
-				lexer.NextToken();
-				Argument(
-#line  1737 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1737 &quot;VBNET.ATG&quot; 
-				arguments.Add(expr); 
-			}
-		}
-	}
-
-	void NonArrayTypeName(
-#line  1782 &quot;VBNET.ATG&quot; 
-out TypeReference typeref) {
-
-#line  1784 &quot;VBNET.ATG&quot; 
-		string name;
-		typeref = null;
-		
-		if (StartOf(9)) {
-			Qualident(
-#line  1787 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  1787 &quot;VBNET.ATG&quot; 
-			typeref = new TypeReference(name); 
-		} else if (la.kind == 134) {
-			lexer.NextToken();
-
-#line  1788 &quot;VBNET.ATG&quot; 
-			typeref = new TypeReference(&quot;System.Object&quot;); 
-		} else if (StartOf(25)) {
-			PrimitiveTypeName(
-#line  1789 &quot;VBNET.ATG&quot; 
-out name);
-
-#line  1789 &quot;VBNET.ATG&quot; 
-			typeref = new TypeReference(name); 
-		} else SynErr(224);
-	}
-
-	void ArrayInitializationModifiers(
-#line  1792 &quot;VBNET.ATG&quot; 
-out ArrayList arrayModifiers) {
-
-#line  1794 &quot;VBNET.ATG&quot; 
-		arrayModifiers = new ArrayList();
-		ArrayList dim = new ArrayList();
-		
-		while (
-#line  1798 &quot;VBNET.ATG&quot; 
-IsDims()) {
-			Expect(25);
-			if (StartOf(18)) {
-				InitializationRankList(
-#line  1799 &quot;VBNET.ATG&quot; 
-out dim);
-			}
-
-#line  1801 &quot;VBNET.ATG&quot; 
-			arrayModifiers.Add(dim);
-			
-			Expect(26);
-		}
-
-#line  1806 &quot;VBNET.ATG&quot; 
-		if(arrayModifiers.Count == 0) {
-		 arrayModifiers = null;
-		}
-		
-	}
-
-	void RankList(
-#line  1834 &quot;VBNET.ATG&quot; 
-out int i) {
-
-#line  1835 &quot;VBNET.ATG&quot; 
-		i = 0; 
-		while (la.kind == 12) {
-			lexer.NextToken();
-
-#line  1836 &quot;VBNET.ATG&quot; 
-			++i; 
-		}
-	}
-
-	void Attribute(
-#line  1861 &quot;VBNET.ATG&quot; 
-out ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute attribute) {
-
-#line  1862 &quot;VBNET.ATG&quot; 
-		string qualident; 
-		Qualident(
-#line  1863 &quot;VBNET.ATG&quot; 
-out qualident);
-
-#line  1865 &quot;VBNET.ATG&quot; 
-		ArrayList positional = new ArrayList();
-		ArrayList named      = new ArrayList();
-		string name = qualident;
-		
-		if (la.kind == 25) {
-			AttributeArguments(
-#line  1869 &quot;VBNET.ATG&quot; 
-ref positional, ref named);
-		}
-
-#line  1871 &quot;VBNET.ATG&quot; 
-		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.VB.Attribute(name, positional, named);
-		
-	}
-
-	void AttributeArguments(
-#line  1876 &quot;VBNET.ATG&quot; 
-ref ArrayList positional, ref ArrayList named) {
-
-#line  1878 &quot;VBNET.ATG&quot; 
-		bool nameFound = false;
-		string name = &quot;&quot;;
-		Expression expr;
-		
-		Expect(25);
-		if (
-#line  1884 &quot;VBNET.ATG&quot; 
-IsNotClosingParenthesis()) {
-			if (
-#line  1886 &quot;VBNET.ATG&quot; 
-IsNamedAssign()) {
-
-#line  1886 &quot;VBNET.ATG&quot; 
-				nameFound = true; 
-				IdentifierOrKeyword(
-#line  1887 &quot;VBNET.ATG&quot; 
-out name);
-				if (la.kind == 13) {
-					lexer.NextToken();
-				}
-				Expect(11);
-			}
-			Expr(
-#line  1889 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1891 &quot;VBNET.ATG&quot; 
-			if(name == &quot;&quot;) positional.Add(expr);
-			else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
-			
-			while (la.kind == 12) {
-				lexer.NextToken();
-				if (
-#line  1897 &quot;VBNET.ATG&quot; 
-IsNamedAssign()) {
-
-#line  1897 &quot;VBNET.ATG&quot; 
-					nameFound = true; 
-					IdentifierOrKeyword(
-#line  1898 &quot;VBNET.ATG&quot; 
-out name);
-					if (la.kind == 13) {
-						lexer.NextToken();
-					}
-					Expect(11);
-				} else if (StartOf(18)) {
-
-#line  1900 &quot;VBNET.ATG&quot; 
-					if (nameFound) Error(&quot;no positional argument after named argument&quot;); 
-				} else SynErr(225);
-				Expr(
-#line  1901 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  1901 &quot;VBNET.ATG&quot; 
-				if(name == &quot;&quot;) positional.Add(expr);
-				else { named.Add(new NamedArgumentExpression(name, expr)); name = &quot;&quot;; }
-				
-			}
-		}
-		Expect(26);
-	}
-
-	void FormalParameter(
-#line  1971 &quot;VBNET.ATG&quot; 
-out ParameterDeclarationExpression p) {
-
-#line  1973 &quot;VBNET.ATG&quot; 
-		TypeReference type = null;
-		ParamModifiers mod = new ParamModifiers(this);
-		Expression expr = null;
-		p = null;
-		ArrayList arrayModifiers = null;
-		
-		while (StartOf(26)) {
-			ParameterModifier(
-#line  1979 &quot;VBNET.ATG&quot; 
-mod);
-		}
-		Identifier();
-
-#line  1980 &quot;VBNET.ATG&quot; 
-		string parameterName = t.val; 
-		if (
-#line  1981 &quot;VBNET.ATG&quot; 
-IsRank()) {
-			ArrayTypeModifiers(
-#line  1981 &quot;VBNET.ATG&quot; 
-out arrayModifiers);
-		}
-		if (la.kind == 49) {
-			lexer.NextToken();
-			TypeName(
-#line  1982 &quot;VBNET.ATG&quot; 
-out type);
-		}
-
-#line  1984 &quot;VBNET.ATG&quot; 
-		if(type != null) {
-		if (arrayModifiers != null) {
-			if (type.RankSpecifier != null) {
-				Error(&quot;array rank only allowed one time&quot;);
-			} else {
-				type.RankSpecifier = arrayModifiers;
-			}
-		}
-		} else {
-			type = new TypeReference(&quot;System.Object&quot;, arrayModifiers);
-		}
-		
-		if (la.kind == 11) {
-			lexer.NextToken();
-			Expr(
-#line  1996 &quot;VBNET.ATG&quot; 
-out expr);
-		}
-
-#line  1998 &quot;VBNET.ATG&quot; 
-		mod.Check();
-		p = new ParameterDeclarationExpression(type, parameterName, mod, expr);
-		
-	}
-
-	void ParameterModifier(
-#line  2708 &quot;VBNET.ATG&quot; 
-ParamModifiers m) {
-		if (la.kind == 56) {
-			lexer.NextToken();
-
-#line  2709 &quot;VBNET.ATG&quot; 
-			m.Add(ParamModifier.ByVal); 
-		} else if (la.kind == 54) {
-			lexer.NextToken();
-
-#line  2710 &quot;VBNET.ATG&quot; 
-			m.Add(ParamModifier.ByRef); 
-		} else if (la.kind == 138) {
-			lexer.NextToken();
-
-#line  2711 &quot;VBNET.ATG&quot; 
-			m.Add(ParamModifier.Optional); 
-		} else if (la.kind == 145) {
-			lexer.NextToken();
-
-#line  2712 &quot;VBNET.ATG&quot; 
-			m.Add(ParamModifier.ParamArray); 
-		} else SynErr(226);
-	}
-
-	void Statement() {
-
-#line  2023 &quot;VBNET.ATG&quot; 
-		Statement stmt;
-		string label = String.Empty;
-		
-		
-		if (
-#line  2027 &quot;VBNET.ATG&quot; 
-IsLabel()) {
-			LabelName(
-#line  2027 &quot;VBNET.ATG&quot; 
-out label);
-
-#line  2029 &quot;VBNET.ATG&quot; 
-			labelStatement = new LabelStatement(t.val);
-			compilationUnit.AddChild(labelStatement);
-			
-			Expect(13);
-			if (StartOf(15)) {
-
-#line  2032 &quot;VBNET.ATG&quot; 
-				isLabel = true; 
-				Statement();
-			}
-		} else if (StartOf(27)) {
-			EmbeddedStatement(
-#line  2033 &quot;VBNET.ATG&quot; 
-out stmt);
-
-#line  2033 &quot;VBNET.ATG&quot; 
-			updateLabelStatement(stmt); 
-		} else if (StartOf(28)) {
-			LocalDeclarationStatement(
-#line  2034 &quot;VBNET.ATG&quot; 
-out stmt);
-
-#line  2034 &quot;VBNET.ATG&quot; 
-			updateLabelStatement(stmt); 
-		} else SynErr(227);
-	}
-
-	void LabelName(
-#line  2396 &quot;VBNET.ATG&quot; 
-out string name) {
-
-#line  2398 &quot;VBNET.ATG&quot; 
-		name = String.Empty;
-		
-		if (StartOf(9)) {
-			Identifier();
-
-#line  2400 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-		} else if (la.kind == 5) {
-			lexer.NextToken();
-
-#line  2401 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-		} else SynErr(228);
-	}
-
-	void EmbeddedStatement(
-#line  2071 &quot;VBNET.ATG&quot; 
-out Statement statement) {
-
-#line  2073 &quot;VBNET.ATG&quot; 
-		Statement embeddedStatement = null;
-		statement = null;
-		Expression expr = null;
-		string name = String.Empty;
-		ArrayList p = null;
-		
-		switch (la.kind) {
-		case 95: {
-			lexer.NextToken();
-
-#line  2079 &quot;VBNET.ATG&quot; 
-			ExitType exitType = ExitType.None; 
-			switch (la.kind) {
-			case 169: {
-				lexer.NextToken();
-
-#line  2081 &quot;VBNET.ATG&quot; 
-				exitType = ExitType.Sub; 
-				break;
-			}
-			case 101: {
-				lexer.NextToken();
-
-#line  2083 &quot;VBNET.ATG&quot; 
-				exitType = ExitType.Function; 
-				break;
-			}
-			case 148: {
-				lexer.NextToken();
-
-#line  2085 &quot;VBNET.ATG&quot; 
-				exitType = ExitType.Property; 
-				break;
-			}
-			case 84: {
-				lexer.NextToken();
-
-#line  2087 &quot;VBNET.ATG&quot; 
-				exitType = ExitType.Do; 
-				break;
-			}
-			case 99: {
-				lexer.NextToken();
-
-#line  2089 &quot;VBNET.ATG&quot; 
-				exitType = ExitType.For; 
-				break;
-			}
-			case 176: {
-				lexer.NextToken();
-
-#line  2091 &quot;VBNET.ATG&quot; 
-				exitType = ExitType.Try; 
-				break;
-			}
-			case 183: {
-				lexer.NextToken();
-
-#line  2093 &quot;VBNET.ATG&quot; 
-				exitType = ExitType.While; 
-				break;
-			}
-			case 157: {
-				lexer.NextToken();
-
-#line  2095 &quot;VBNET.ATG&quot; 
-				exitType = ExitType.Select; 
-				break;
-			}
-			default: SynErr(229); break;
-			}
-
-#line  2097 &quot;VBNET.ATG&quot; 
-			statement = new ExitStatement(exitType); 
-			break;
-		}
-		case 176: {
-			TryStatement(
-#line  2098 &quot;VBNET.ATG&quot; 
-out statement);
-			break;
-		}
-		case 173: {
-			lexer.NextToken();
-			if (StartOf(18)) {
-				Expr(
-#line  2100 &quot;VBNET.ATG&quot; 
-out expr);
-			}
-
-#line  2100 &quot;VBNET.ATG&quot; 
-			statement = new ThrowStatement(expr); 
-			break;
-		}
-		case 156: {
-			lexer.NextToken();
-			if (StartOf(18)) {
-				Expr(
-#line  2102 &quot;VBNET.ATG&quot; 
-out expr);
-			}
-
-#line  2102 &quot;VBNET.ATG&quot; 
-			statement = new ReturnStatement(expr); 
-			break;
-		}
-		case 170: {
-			lexer.NextToken();
-			Expr(
-#line  2104 &quot;VBNET.ATG&quot; 
-out expr);
-			EndOfStmt();
-			Block(
-#line  2104 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-			Expect(89);
-			Expect(170);
-
-#line  2105 &quot;VBNET.ATG&quot; 
-			statement = new LockStatement(expr, embeddedStatement); 
-			break;
-		}
-		case 151: {
-			lexer.NextToken();
-			Identifier();
-
-#line  2107 &quot;VBNET.ATG&quot; 
-			name = t.val; 
-			if (la.kind == 25) {
-				lexer.NextToken();
-				if (StartOf(17)) {
-					ArgumentList(
-#line  2108 &quot;VBNET.ATG&quot; 
-out p);
-				}
-				Expect(26);
-			}
-
-#line  2109 &quot;VBNET.ATG&quot; 
-			statement = new RaiseEventStatement(name, p); 
-			break;
-		}
-		case 184: {
-			WithStatement(
-#line  2111 &quot;VBNET.ATG&quot; 
-out statement);
-			break;
-		}
-		case 43: {
-			lexer.NextToken();
-
-#line  2113 &quot;VBNET.ATG&quot; 
-			Expression handlerExpr = null; 
-			Expr(
-#line  2114 &quot;VBNET.ATG&quot; 
-out expr);
-			Expect(12);
-			Expr(
-#line  2114 &quot;VBNET.ATG&quot; 
-out handlerExpr);
-
-#line  2116 &quot;VBNET.ATG&quot; 
-			statement = new AddHandlerStatement(expr, handlerExpr);
-			
-			break;
-		}
-		case 154: {
-			lexer.NextToken();
-
-#line  2119 &quot;VBNET.ATG&quot; 
-			Expression handlerExpr = null; 
-			Expr(
-#line  2120 &quot;VBNET.ATG&quot; 
-out expr);
-			Expect(12);
-			Expr(
-#line  2120 &quot;VBNET.ATG&quot; 
-out handlerExpr);
-
-#line  2122 &quot;VBNET.ATG&quot; 
-			statement = new RemoveHandlerStatement(expr, handlerExpr);
-			
-			break;
-		}
-		case 183: {
-			lexer.NextToken();
-			Expr(
-#line  2125 &quot;VBNET.ATG&quot; 
-out expr);
-			EndOfStmt();
-			Block(
-#line  2126 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-			Expect(89);
-			Expect(183);
-
-#line  2128 &quot;VBNET.ATG&quot; 
-			statement = new WhileStatement(expr, embeddedStatement);
-			
-			break;
-		}
-		case 84: {
-			lexer.NextToken();
-
-#line  2133 &quot;VBNET.ATG&quot; 
-			ConditionType conditionType = ConditionType.None;
-			
-			if (la.kind == 179 || la.kind == 183) {
-				WhileOrUntil(
-#line  2136 &quot;VBNET.ATG&quot; 
-out conditionType);
-				Expr(
-#line  2136 &quot;VBNET.ATG&quot; 
-out expr);
-				EndOfStmt();
-				Block(
-#line  2137 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-				Expect(119);
-
-#line  2140 &quot;VBNET.ATG&quot; 
-				statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.Start);
-				
-			} else if (la.kind == 1 || la.kind == 13) {
-				EndOfStmt();
-				Block(
-#line  2144 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-				Expect(119);
-				if (la.kind == 179 || la.kind == 183) {
-					WhileOrUntil(
-#line  2145 &quot;VBNET.ATG&quot; 
-out conditionType);
-					Expr(
-#line  2145 &quot;VBNET.ATG&quot; 
-out expr);
-				}
-
-#line  2147 &quot;VBNET.ATG&quot; 
-				statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.End);
-				
-			} else SynErr(230);
-			break;
-		}
-		case 99: {
-			lexer.NextToken();
-
-#line  2152 &quot;VBNET.ATG&quot; 
-			Expression group = null;
-			LoopControlVariableExpression loopControlExpr = null;
-			
-			if (la.kind == 86) {
-				lexer.NextToken();
-				LoopControlVariable(
-#line  2157 &quot;VBNET.ATG&quot; 
-out loopControlExpr);
-				Expect(110);
-				Expr(
-#line  2158 &quot;VBNET.ATG&quot; 
-out group);
-				EndOfStmt();
-				Block(
-#line  2159 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-				Expect(129);
-				if (StartOf(18)) {
-					Expr(
-#line  2160 &quot;VBNET.ATG&quot; 
-out expr);
-				}
-
-#line  2162 &quot;VBNET.ATG&quot; 
-				statement = new ForeachStatement(loopControlExpr, group, embeddedStatement, expr);
-				
-			} else if (StartOf(9)) {
-
-#line  2166 &quot;VBNET.ATG&quot; 
-				Expression start = null;
-				Expression end = null;
-				Expression step = null;
-				Expression nextExpr = null;
-				ArrayList nextExpressions = null;
-				
-				LoopControlVariable(
-#line  2172 &quot;VBNET.ATG&quot; 
-out loopControlExpr);
-				Expect(11);
-				Expr(
-#line  2173 &quot;VBNET.ATG&quot; 
-out start);
-				Expect(174);
-				Expr(
-#line  2173 &quot;VBNET.ATG&quot; 
-out end);
-				if (la.kind == 164) {
-					lexer.NextToken();
-					Expr(
-#line  2173 &quot;VBNET.ATG&quot; 
-out step);
-				}
-				EndOfStmt();
-				Block(
-#line  2174 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-				Expect(129);
-				if (StartOf(18)) {
-					Expr(
-#line  2177 &quot;VBNET.ATG&quot; 
-out nextExpr);
-
-#line  2177 &quot;VBNET.ATG&quot; 
-					nextExpressions = new ArrayList(); nextExpressions.Add(nextExpr); 
-					while (la.kind == 12) {
-						lexer.NextToken();
-						Expr(
-#line  2178 &quot;VBNET.ATG&quot; 
-out nextExpr);
-
-#line  2178 &quot;VBNET.ATG&quot; 
-						nextExpressions.Add(nextExpr); 
-					}
-				}
-
-#line  2181 &quot;VBNET.ATG&quot; 
-				statement = new ForStatement(loopControlExpr, start, end, step, embeddedStatement, nextExpressions);
-				
-			} else SynErr(231);
-			break;
-		}
-		case 93: {
-			lexer.NextToken();
-			Expr(
-#line  2185 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  2185 &quot;VBNET.ATG&quot; 
-			statement = new ErrorStatement(expr); 
-			break;
-		}
-		case 153: {
-			lexer.NextToken();
-
-#line  2187 &quot;VBNET.ATG&quot; 
-			Expression clause = null; 
-			if (la.kind == 146) {
-				lexer.NextToken();
-			}
-			Expr(
-#line  2188 &quot;VBNET.ATG&quot; 
-out clause);
-
-#line  2190 &quot;VBNET.ATG&quot; 
-			ArrayList clauses = new ArrayList();
-			clauses.Add(clause);
-			ReDimStatement reDimStatement = new ReDimStatement(clauses);
-			
-			while (la.kind == 12) {
-				lexer.NextToken();
-				Expr(
-#line  2194 &quot;VBNET.ATG&quot; 
-out clause);
-
-#line  2194 &quot;VBNET.ATG&quot; 
-				clauses.Add(clause); 
-			}
-			break;
-		}
-		case 92: {
-			lexer.NextToken();
-			Expr(
-#line  2197 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  2199 &quot;VBNET.ATG&quot; 
-			ArrayList arrays = new ArrayList();
-			arrays.Add(expr);
-			EraseStatement eraseStatement = new EraseStatement(arrays);
-			
-			
-			while (la.kind == 12) {
-				lexer.NextToken();
-				Expr(
-#line  2204 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  2204 &quot;VBNET.ATG&quot; 
-				arrays.Add(expr); 
-			}
-
-#line  2205 &quot;VBNET.ATG&quot; 
-			statement = eraseStatement; 
-			break;
-		}
-		case 165: {
-			lexer.NextToken();
-
-#line  2207 &quot;VBNET.ATG&quot; 
-			statement = new StopStatement(); 
-			break;
-		}
-		case 107: {
-			lexer.NextToken();
-			Expr(
-#line  2209 &quot;VBNET.ATG&quot; 
-out expr);
-			if (la.kind == 172) {
-				lexer.NextToken();
-			}
-			if (
-#line  2211 &quot;VBNET.ATG&quot; 
-IsEndStmtAhead()) {
-				Expect(89);
-
-#line  2211 &quot;VBNET.ATG&quot; 
-				statement = new IfStatement(expr, new EndStatement()); 
-			} else if (la.kind == 1 || la.kind == 13) {
-				EndOfStmt();
-				Block(
-#line  2214 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-
-#line  2216 &quot;VBNET.ATG&quot; 
-				ArrayList elseIfSections = new ArrayList();
-				IfStatement ifStatement = new IfStatement(expr, embeddedStatement);
-				
-				while (la.kind == 88 || 
-#line  2221 &quot;VBNET.ATG&quot; 
-IsElseIf()) {
-					if (
-#line  2221 &quot;VBNET.ATG&quot; 
-IsElseIf()) {
-						Expect(87);
-						Expect(107);
-					} else {
-						lexer.NextToken();
-					}
-
-#line  2224 &quot;VBNET.ATG&quot; 
-					Expression condition = null; Statement block = null; 
-					Expr(
-#line  2225 &quot;VBNET.ATG&quot; 
-out condition);
-					if (la.kind == 172) {
-						lexer.NextToken();
-					}
-					EndOfStmt();
-					Block(
-#line  2226 &quot;VBNET.ATG&quot; 
-out block);
-
-#line  2228 &quot;VBNET.ATG&quot; 
-					ElseIfSection elseIfSection = new ElseIfSection(condition, block);
-					elseIfSections.Add(elseIfSection);
-					
-				}
-				if (la.kind == 87) {
-					lexer.NextToken();
-					EndOfStmt();
-					Block(
-#line  2234 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-
-#line  2236 &quot;VBNET.ATG&quot; 
-					ifStatement.EmbeddedElseStatement = embeddedStatement;
-					
-				}
-				Expect(89);
-				Expect(107);
-
-#line  2240 &quot;VBNET.ATG&quot; 
-				ifStatement.ElseIfStatements = elseIfSections;
-				statement = ifStatement;
-				
-			} else if (StartOf(27)) {
-				EmbeddedStatement(
-#line  2244 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-
-#line  2246 &quot;VBNET.ATG&quot; 
-				SimpleIfStatement ifStatement = new SimpleIfStatement(expr);
-				ArrayList statements = new ArrayList();
-				statements.Add(embeddedStatement);
-				ifStatement.Statements = statements;
-				
-				while (la.kind == 13) {
-					lexer.NextToken();
-					EmbeddedStatement(
-#line  2251 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-
-#line  2251 &quot;VBNET.ATG&quot; 
-					statements.Add(embeddedStatement); 
-				}
-				if (la.kind == 87) {
-					lexer.NextToken();
-					if (StartOf(27)) {
-						EmbeddedStatement(
-#line  2253 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-					}
-
-#line  2255 &quot;VBNET.ATG&quot; 
-					ArrayList elseStatements = new ArrayList();
-					elseStatements.Add(embeddedStatement);
-					ifStatement.ElseStatements = elseStatements;
-					
-					while (la.kind == 13) {
-						lexer.NextToken();
-						EmbeddedStatement(
-#line  2260 &quot;VBNET.ATG&quot; 
-out embeddedStatement);
-
-#line  2261 &quot;VBNET.ATG&quot; 
-						elseStatements.Add(embeddedStatement); 
-					}
-				}
-
-#line  2264 &quot;VBNET.ATG&quot; 
-				statement = ifStatement; 
-			} else SynErr(232);
-			break;
-		}
-		case 157: {
-			lexer.NextToken();
-			if (la.kind == 58) {
-				lexer.NextToken();
-			}
-			Expr(
-#line  2267 &quot;VBNET.ATG&quot; 
-out expr);
-			EndOfStmt();
-
-#line  2269 &quot;VBNET.ATG&quot; 
-			ArrayList selectSections = new ArrayList();
-			Statement block = null;
-			
-			while (la.kind == 58) {
-
-#line  2273 &quot;VBNET.ATG&quot; 
-				ArrayList caseClauses = null; 
-				lexer.NextToken();
-				CaseClauses(
-#line  2274 &quot;VBNET.ATG&quot; 
-out caseClauses);
-				if (
-#line  2274 &quot;VBNET.ATG&quot; 
-IsNotStatementSeparator()) {
-					lexer.NextToken();
-				}
-				EndOfStmt();
-
-#line  2276 &quot;VBNET.ATG&quot; 
-				SelectSection selectSection = new SelectSection();
-				selectSection.CaseClauses = caseClauses;
-				compilationUnit.BlockStart(selectSection);
-				
-				Block(
-#line  2280 &quot;VBNET.ATG&quot; 
-out block);
-
-#line  2282 &quot;VBNET.ATG&quot; 
-				selectSection.EmbeddedStatement = block;
-				compilationUnit.BlockEnd();
-				selectSections.Add(selectSection);
-				
-			}
-
-#line  2287 &quot;VBNET.ATG&quot; 
-			statement = new SelectStatement(expr, selectSections); 
-			Expect(89);
-			Expect(157);
-			break;
-		}
-		case 136: {
-
-#line  2289 &quot;VBNET.ATG&quot; 
-			OnErrorStatement onErrorStatement = null; 
-			OnErrorStatement(
-#line  2290 &quot;VBNET.ATG&quot; 
-out onErrorStatement);
-
-#line  2290 &quot;VBNET.ATG&quot; 
-			statement = onErrorStatement; 
-			break;
-		}
-		case 105: {
-
-#line  2291 &quot;VBNET.ATG&quot; 
-			GoToStatement goToStatement = null; 
-			GoToStatement(
-#line  2292 &quot;VBNET.ATG&quot; 
-out goToStatement);
-
-#line  2292 &quot;VBNET.ATG&quot; 
-			statement = goToStatement; 
-			break;
-		}
-		case 155: {
-
-#line  2293 &quot;VBNET.ATG&quot; 
-			ResumeStatement resumeStatement = null; 
-			ResumeStatement(
-#line  2294 &quot;VBNET.ATG&quot; 
-out resumeStatement);
-
-#line  2294 &quot;VBNET.ATG&quot; 
-			statement = resumeStatement; 
-			break;
-		}
-		case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 14: case 15: case 16: case 25: case 44: case 52: case 53: case 55: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 69: case 70: case 71: case 73: case 74: case 75: case 76: case 77: case 78: case 83: case 85: case 97: case 103: case 112: case 118: case 120: case 125: case 126: case 128: case 131: case 161: case 162: case 167: case 171: case 175: case 177: {
-
-#line  2297 &quot;VBNET.ATG&quot; 
-			Expression val = null;
-			AssignmentOperatorType op;
-			
-			bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
-			                        la.kind == Tokens.Not   || la.kind == Tokens.Times;
-			
-			UnaryExpr(
-#line  2303 &quot;VBNET.ATG&quot; 
-out expr);
-			if (StartOf(14)) {
-				AssignmentOperator(
-#line  2305 &quot;VBNET.ATG&quot; 
-out op);
-				Expr(
-#line  2305 &quot;VBNET.ATG&quot; 
-out val);
-
-#line  2305 &quot;VBNET.ATG&quot; 
-				expr = new AssignmentExpression(expr, op, val); 
-			} else if (la.kind == 1 || la.kind == 13 || la.kind == 87) {
-
-#line  2306 &quot;VBNET.ATG&quot; 
-				if (mustBeAssignment) Error(&quot;error in assignment.&quot;); 
-			} else SynErr(233);
-
-#line  2309 &quot;VBNET.ATG&quot; 
-			// a field reference expression that stands alone is a
-			// invocation expression without parantheses and arguments
-			if(expr is FieldReferenceOrInvocationExpression) {
-				expr = new InvocationExpression(expr, new ArrayList());
-			}
-			statement = new StatementExpression(expr);
-			
-			break;
-		}
-		case 57: {
-			lexer.NextToken();
-			UnaryExpr(
-#line  2316 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  2316 &quot;VBNET.ATG&quot; 
-			statement = new StatementExpression(expr); 
-			break;
-		}
-		default: SynErr(234); break;
-		}
-	}
-
-	void LocalDeclarationStatement(
-#line  2038 &quot;VBNET.ATG&quot; 
-out Statement statement) {
-
-#line  2040 &quot;VBNET.ATG&quot; 
-		Modifiers m = new Modifiers(this);
-		ArrayList vars = new ArrayList();
-		LocalVariableDeclaration localVariableDeclaration;
-		bool dimfound = false;
-		
-		while (la.kind == 72 || la.kind == 82 || la.kind == 163) {
-			if (la.kind == 72) {
-				lexer.NextToken();
-
-#line  2047 &quot;VBNET.ATG&quot; 
-				m.Add(Modifier.Constant); 
-			} else if (la.kind == 163) {
-				lexer.NextToken();
-
-#line  2048 &quot;VBNET.ATG&quot; 
-				m.Add(Modifier.Static); 
-			} else {
-				lexer.NextToken();
-
-#line  2049 &quot;VBNET.ATG&quot; 
-				dimfound = true; 
-			}
-		}
-
-#line  2052 &quot;VBNET.ATG&quot; 
-		if(dimfound &amp;&amp; (m.Modifier &amp; Modifier.Constant) != 0) {
-		Error(&quot;Dim is not allowed on constants.&quot;);
-		}
-		
-		if(m.isNone &amp;&amp; dimfound == false) {
-			Error(&quot;Const, Dim or Static expected&quot;);
-		}
-		
-		localVariableDeclaration = new LocalVariableDeclaration(m.Modifier);
-		localVariableDeclaration.StartLocation = t.Location;
-		
-		VariableDeclarator(
-#line  2063 &quot;VBNET.ATG&quot; 
-vars);
-		while (la.kind == 12) {
-			lexer.NextToken();
-			VariableDeclarator(
-#line  2064 &quot;VBNET.ATG&quot; 
-vars);
-		}
-
-#line  2066 &quot;VBNET.ATG&quot; 
-		localVariableDeclaration.Variables = vars;
-		statement = localVariableDeclaration;
-		
-	}
-
-	void TryStatement(
-#line  2489 &quot;VBNET.ATG&quot; 
-out Statement tryStatement) {
-
-#line  2491 &quot;VBNET.ATG&quot; 
-		Statement blockStmt = null, finallyStmt = null;
-		ArrayList catchClauses = null;
-		
-		Expect(176);
-		EndOfStmt();
-		Block(
-#line  2495 &quot;VBNET.ATG&quot; 
-out blockStmt);
-		if (la.kind == 59 || la.kind == 89 || la.kind == 98) {
-			CatchClauses(
-#line  2497 &quot;VBNET.ATG&quot; 
-out catchClauses);
-			if (la.kind == 98) {
-				lexer.NextToken();
-				EndOfStmt();
-				Block(
-#line  2498 &quot;VBNET.ATG&quot; 
-out finallyStmt);
-			}
-		} else if (la.kind == 98) {
-			lexer.NextToken();
-			EndOfStmt();
-			Block(
-#line  2499 &quot;VBNET.ATG&quot; 
-out finallyStmt);
-		} else SynErr(235);
-		Expect(89);
-		Expect(176);
-
-#line  2503 &quot;VBNET.ATG&quot; 
-		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
-		
-	}
-
-	void WithStatement(
-#line  2467 &quot;VBNET.ATG&quot; 
-out Statement withStatement) {
-
-#line  2469 &quot;VBNET.ATG&quot; 
-		Statement blockStmt = null;
-		Expression expr = null;
-		
-		Expect(184);
-
-#line  2472 &quot;VBNET.ATG&quot; 
-		Point start = t.Location; 
-		Expr(
-#line  2473 &quot;VBNET.ATG&quot; 
-out expr);
-		EndOfStmt();
-
-#line  2475 &quot;VBNET.ATG&quot; 
-		withStatement = new WithStatement(expr);
-		withStatement.StartLocation = start;
-		withStatements.Push(withStatement);
-		
-		Block(
-#line  2479 &quot;VBNET.ATG&quot; 
-out blockStmt);
-
-#line  2481 &quot;VBNET.ATG&quot; 
-		((WithStatement)withStatement).Body = (BlockStatement)blockStmt;
-		withStatements.Pop();
-		
-		Expect(89);
-		Expect(184);
-
-#line  2485 &quot;VBNET.ATG&quot; 
-		withStatement.EndLocation = t.Location; 
-	}
-
-	void WhileOrUntil(
-#line  2460 &quot;VBNET.ATG&quot; 
-out ConditionType conditionType) {
-
-#line  2461 &quot;VBNET.ATG&quot; 
-		conditionType = ConditionType.None; 
-		if (la.kind == 183) {
-			lexer.NextToken();
-
-#line  2462 &quot;VBNET.ATG&quot; 
-			conditionType = ConditionType.While; 
-		} else if (la.kind == 179) {
-			lexer.NextToken();
-
-#line  2463 &quot;VBNET.ATG&quot; 
-			conditionType = ConditionType.Until; 
-		} else SynErr(236);
-	}
-
-	void LoopControlVariable(
-#line  2320 &quot;VBNET.ATG&quot; 
-out LoopControlVariableExpression loopExpr) {
-
-#line  2322 &quot;VBNET.ATG&quot; 
-		loopExpr = null;
-		//Expression expr = null;
-		TypeReference type = null;
-		ArrayList arrayModifiers = null;
-		string name;
-		
-		Qualident(
-#line  2328 &quot;VBNET.ATG&quot; 
-out name);
-		if (
-#line  2329 &quot;VBNET.ATG&quot; 
-IsRank()) {
-			ArrayTypeModifiers(
-#line  2329 &quot;VBNET.ATG&quot; 
-out arrayModifiers);
-		}
-		if (la.kind == 49) {
-			lexer.NextToken();
-			TypeName(
-#line  2330 &quot;VBNET.ATG&quot; 
-out type);
-
-#line  2330 &quot;VBNET.ATG&quot; 
-			if (name.IndexOf('.') &gt; 0) { Error(&quot;No type def for 'for each' member indexer allowed.&quot;); } 
-		}
-
-#line  2332 &quot;VBNET.ATG&quot; 
-		if(type != null) {
-		if(type.RankSpecifier != null &amp;&amp; arrayModifiers != null) {
-			Error(&quot;array rank only allowed one time&quot;);
-		} else {
-			type.RankSpecifier = arrayModifiers;
-		}
-		} else {
-			type = new TypeReference(&quot;Integer&quot;, arrayModifiers);
-		}
-		loopExpr = new LoopControlVariableExpression(name, type);
-		
-	}
-
-	void CaseClauses(
-#line  2416 &quot;VBNET.ATG&quot; 
-out ArrayList caseClauses) {
-
-#line  2418 &quot;VBNET.ATG&quot; 
-		caseClauses = null;
-		CaseClause caseClause = null;
-		
-		CaseClause(
-#line  2421 &quot;VBNET.ATG&quot; 
-out caseClause);
-
-#line  2423 &quot;VBNET.ATG&quot; 
-		caseClauses = new ArrayList();
-		caseClauses.Add(caseClause);
-		
-		while (la.kind == 12) {
-			lexer.NextToken();
-			CaseClause(
-#line  2426 &quot;VBNET.ATG&quot; 
-out caseClause);
-
-#line  2426 &quot;VBNET.ATG&quot; 
-			caseClauses.Add(caseClause); 
-		}
-	}
-
-	void OnErrorStatement(
-#line  2346 &quot;VBNET.ATG&quot; 
-out OnErrorStatement stmt) {
-
-#line  2348 &quot;VBNET.ATG&quot; 
-		stmt = null;
-		GoToStatement goToStatement = null;
-		
-		Expect(136);
-		Expect(93);
-		if (
-#line  2354 &quot;VBNET.ATG&quot; 
-IsNegativeLabelName()) {
-			Expect(105);
-			Expect(15);
-			Expect(5);
-
-#line  2356 &quot;VBNET.ATG&quot; 
-			long intLabel = Int64.Parse(t.val);
-			if(intLabel != 1) {
-				Error(&quot;invalid label in on error statement.&quot;);
-			}
-			stmt = new OnErrorStatement(new GoToStatement((intLabel * -1).ToString()));
-			
-		} else if (la.kind == 105) {
-			GoToStatement(
-#line  2362 &quot;VBNET.ATG&quot; 
-out goToStatement);
-
-#line  2364 &quot;VBNET.ATG&quot; 
-			string val = goToStatement.LabelName;
-			
-			// if value is numeric, make sure that is 0
-			try {
-				long intLabel = Int64.Parse(val);
-				if(intLabel != 0) {
-					Error(&quot;invalid label in on error statement.&quot;);
-				}
-			} catch {
-			}
-			stmt = new OnErrorStatement(goToStatement);
-			
-		} else if (la.kind == 155) {
-			lexer.NextToken();
-			Expect(129);
-
-#line  2378 &quot;VBNET.ATG&quot; 
-			stmt = new OnErrorStatement(new ResumeStatement(true));
-			
-		} else SynErr(237);
-	}
-
-	void GoToStatement(
-#line  2384 &quot;VBNET.ATG&quot; 
-out GoToStatement goToStatement) {
-
-#line  2386 &quot;VBNET.ATG&quot; 
-		string label = String.Empty;
-		
-		Expect(105);
-		LabelName(
-#line  2389 &quot;VBNET.ATG&quot; 
-out label);
-
-#line  2391 &quot;VBNET.ATG&quot; 
-		goToStatement = new GoToStatement(label);
-		
-	}
-
-	void ResumeStatement(
-#line  2405 &quot;VBNET.ATG&quot; 
-out ResumeStatement resumeStatement) {
-
-#line  2407 &quot;VBNET.ATG&quot; 
-		resumeStatement = null;
-		string label = String.Empty;
-		
-		if (
-#line  2410 &quot;VBNET.ATG&quot; 
-IsResumeNext()) {
-			Expect(155);
-			Expect(129);
-
-#line  2411 &quot;VBNET.ATG&quot; 
-			resumeStatement = new ResumeStatement(true); 
-		} else if (la.kind == 155) {
-			lexer.NextToken();
-			if (StartOf(29)) {
-				LabelName(
-#line  2412 &quot;VBNET.ATG&quot; 
-out label);
-			}
-
-#line  2412 &quot;VBNET.ATG&quot; 
-			resumeStatement = new ResumeStatement(label); 
-		} else SynErr(238);
-	}
-
-	void CaseClause(
-#line  2430 &quot;VBNET.ATG&quot; 
-out CaseClause caseClause) {
-
-#line  2432 &quot;VBNET.ATG&quot; 
-		Expression expr = null;
-		Expression sexpr = null;
-		BinaryOperatorType op = BinaryOperatorType.None;
-		caseClause = null;
-		
-		if (la.kind == 87) {
-			lexer.NextToken();
-
-#line  2438 &quot;VBNET.ATG&quot; 
-			caseClause = new CaseClause(true); 
-		} else if (StartOf(30)) {
-			if (la.kind == 114) {
-				lexer.NextToken();
-			}
-			switch (la.kind) {
-			case 28: {
-				lexer.NextToken();
-
-#line  2442 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.LessThan; 
-				break;
-			}
-			case 27: {
-				lexer.NextToken();
-
-#line  2443 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.GreaterThan; 
-				break;
-			}
-			case 31: {
-				lexer.NextToken();
-
-#line  2444 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.LessThanOrEqual; 
-				break;
-			}
-			case 30: {
-				lexer.NextToken();
-
-#line  2445 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.GreaterThanOrEqual; 
-				break;
-			}
-			case 11: {
-				lexer.NextToken();
-
-#line  2446 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.Equality; 
-				break;
-			}
-			case 29: {
-				lexer.NextToken();
-
-#line  2447 &quot;VBNET.ATG&quot; 
-				op = BinaryOperatorType.InEquality; 
-				break;
-			}
-			default: SynErr(239); break;
-			}
-			Expr(
-#line  2449 &quot;VBNET.ATG&quot; 
-out expr);
-
-#line  2451 &quot;VBNET.ATG&quot; 
-			caseClause = new CaseClause(op, expr);
-			
-		} else if (StartOf(18)) {
-			Expr(
-#line  2453 &quot;VBNET.ATG&quot; 
-out expr);
-			if (la.kind == 174) {
-				lexer.NextToken();
-				Expr(
-#line  2453 &quot;VBNET.ATG&quot; 
-out sexpr);
-			}
-
-#line  2455 &quot;VBNET.ATG&quot; 
-			caseClause = new CaseClause(expr, sexpr);
-			
-		} else SynErr(240);
-	}
-
-	void CatchClauses(
-#line  2508 &quot;VBNET.ATG&quot; 
-out ArrayList catchClauses) {
-
-#line  2510 &quot;VBNET.ATG&quot; 
-		catchClauses = new ArrayList();
-		TypeReference type = null;
-		Statement blockStmt = null;
-		Expression expr = null;
-		string name = String.Empty;
-		
-		while (la.kind == 59) {
-			lexer.NextToken();
-			if (StartOf(9)) {
-				Identifier();
-
-#line  2518 &quot;VBNET.ATG&quot; 
-				name = t.val; 
-				if (la.kind == 49) {
-					lexer.NextToken();
-					TypeName(
-#line  2518 &quot;VBNET.ATG&quot; 
-out type);
-				}
-			}
-			if (la.kind == 182) {
-				lexer.NextToken();
-				Expr(
-#line  2519 &quot;VBNET.ATG&quot; 
-out expr);
-			}
-			EndOfStmt();
-			Block(
-#line  2521 &quot;VBNET.ATG&quot; 
-out blockStmt);
-
-#line  2522 &quot;VBNET.ATG&quot; 
-			catchClauses.Add(new CatchClause(type, name, blockStmt, expr)); 
-		}
-	}
-
-
-
 	public void Parse(Lexer lexer)
 	{
 		this.errors = lexer.Errors;
 		this.lexer = lexer;
 		errors.SynErr = new ErrorCodeProc(SynErr);
 		lexer.NextToken();
-		VBNET();
+		VBNET();
 
 	}
 
@@ -6285,247 +6285,247 @@
 		errors.count++; 
 		string s;
 		switch (errorNumber) {
-			case 0: s = &quot;EOF expected&quot;; break;
-			case 1: s = &quot;EOL expected&quot;; break;
-			case 2: s = &quot;ident expected&quot;; break;
-			case 3: s = &quot;LiteralString expected&quot;; break;
-			case 4: s = &quot;LiteralCharacter expected&quot;; break;
-			case 5: s = &quot;LiteralInteger expected&quot;; break;
-			case 6: s = &quot;LiteralDouble expected&quot;; break;
-			case 7: s = &quot;LiteralSingle expected&quot;; break;
-			case 8: s = &quot;LiteralDecimal expected&quot;; break;
-			case 9: s = &quot;LiteralDate expected&quot;; break;
-			case 10: s = &quot;\&quot;.\&quot; expected&quot;; break;
-			case 11: s = &quot;\&quot;=\&quot; expected&quot;; break;
-			case 12: s = &quot;\&quot;,\&quot; expected&quot;; break;
-			case 13: s = &quot;\&quot;:\&quot; expected&quot;; break;
-			case 14: s = &quot;\&quot;+\&quot; expected&quot;; break;
-			case 15: s = &quot;\&quot;-\&quot; expected&quot;; break;
-			case 16: s = &quot;\&quot;*\&quot; expected&quot;; break;
-			case 17: s = &quot;\&quot;/\&quot; expected&quot;; break;
-			case 18: s = &quot;\&quot;\\\\\&quot; expected&quot;; break;
-			case 19: s = &quot;\&quot;&amp;\&quot; expected&quot;; break;
-			case 20: s = &quot;\&quot;^\&quot; expected&quot;; break;
-			case 21: s = &quot;\&quot;{\&quot; expected&quot;; break;
-			case 22: s = &quot;\&quot;}\&quot; expected&quot;; break;
-			case 23: s = &quot;\&quot;[\&quot; expected&quot;; break;
-			case 24: s = &quot;\&quot;]\&quot; expected&quot;; break;
-			case 25: s = &quot;\&quot;(\&quot; expected&quot;; break;
-			case 26: s = &quot;\&quot;)\&quot; expected&quot;; break;
-			case 27: s = &quot;\&quot;&gt;\&quot; expected&quot;; break;
-			case 28: s = &quot;\&quot;&lt;\&quot; expected&quot;; break;
-			case 29: s = &quot;\&quot;&lt;&gt;\&quot; expected&quot;; break;
-			case 30: s = &quot;\&quot;&gt;=\&quot; expected&quot;; break;
-			case 31: s = &quot;\&quot;&lt;=\&quot; expected&quot;; break;
-			case 32: s = &quot;\&quot;&lt;&lt;\&quot; expected&quot;; break;
-			case 33: s = &quot;\&quot;&gt;&gt;\&quot; expected&quot;; break;
-			case 34: s = &quot;\&quot;+=\&quot; expected&quot;; break;
-			case 35: s = &quot;\&quot;^=\&quot; expected&quot;; break;
-			case 36: s = &quot;\&quot;-=\&quot; expected&quot;; break;
-			case 37: s = &quot;\&quot;*=\&quot; expected&quot;; break;
-			case 38: s = &quot;\&quot;/=\&quot; expected&quot;; break;
-			case 39: s = &quot;\&quot;\\\\=\&quot; expected&quot;; break;
-			case 40: s = &quot;\&quot;&lt;&lt;=\&quot; expected&quot;; break;
-			case 41: s = &quot;\&quot;&gt;&gt;=\&quot; expected&quot;; break;
-			case 42: s = &quot;\&quot;&amp;=\&quot; expected&quot;; break;
-			case 43: s = &quot;\&quot;AddHandler\&quot; expected&quot;; break;
-			case 44: s = &quot;\&quot;AddressOf\&quot; expected&quot;; break;
-			case 45: s = &quot;\&quot;Alias\&quot; expected&quot;; break;
-			case 46: s = &quot;\&quot;And\&quot; expected&quot;; break;
-			case 47: s = &quot;\&quot;AndAlso\&quot; expected&quot;; break;
-			case 48: s = &quot;\&quot;Ansi\&quot; expected&quot;; break;
-			case 49: s = &quot;\&quot;As\&quot; expected&quot;; break;
-			case 50: s = &quot;\&quot;Assembly\&quot; expected&quot;; break;
-			case 51: s = &quot;\&quot;Auto\&quot; expected&quot;; break;
-			case 52: s = &quot;\&quot;Binary\&quot; expected&quot;; break;
-			case 53: s = &quot;\&quot;Boolean\&quot; expected&quot;; break;
-			case 54: s = &quot;\&quot;ByRef\&quot; expected&quot;; break;
-			case 55: s = &quot;\&quot;Byte\&quot; expected&quot;; break;
-			case 56: s = &quot;\&quot;ByVal\&quot; expected&quot;; break;
-			case 57: s = &quot;\&quot;Call\&quot; expected&quot;; break;
-			case 58: s = &quot;\&quot;Case\&quot; expected&quot;; break;
-			case 59: s = &quot;\&quot;Catch\&quot; expected&quot;; break;
-			case 60: s = &quot;\&quot;CBool\&quot; expected&quot;; break;
-			case 61: s = &quot;\&quot;CByte\&quot; expected&quot;; break;
-			case 62: s = &quot;\&quot;CChar\&quot; expected&quot;; break;
-			case 63: s = &quot;\&quot;CDate\&quot; expected&quot;; break;
-			case 64: s = &quot;\&quot;CDbl\&quot; expected&quot;; break;
-			case 65: s = &quot;\&quot;CDec\&quot; expected&quot;; break;
-			case 66: s = &quot;\&quot;Char\&quot; expected&quot;; break;
-			case 67: s = &quot;\&quot;CInt\&quot; expected&quot;; break;
-			case 68: s = &quot;\&quot;Class\&quot; expected&quot;; break;
-			case 69: s = &quot;\&quot;CLng\&quot; expected&quot;; break;
-			case 70: s = &quot;\&quot;CObj\&quot; expected&quot;; break;
-			case 71: s = &quot;\&quot;Compare\&quot; expected&quot;; break;
-			case 72: s = &quot;\&quot;Const\&quot; expected&quot;; break;
-			case 73: s = &quot;\&quot;CShort\&quot; expected&quot;; break;
-			case 74: s = &quot;\&quot;CSng\&quot; expected&quot;; break;
-			case 75: s = &quot;\&quot;CStr\&quot; expected&quot;; break;
-			case 76: s = &quot;\&quot;CType\&quot; expected&quot;; break;
-			case 77: s = &quot;\&quot;Date\&quot; expected&quot;; break;
-			case 78: s = &quot;\&quot;Decimal\&quot; expected&quot;; break;
-			case 79: s = &quot;\&quot;Declare\&quot; expected&quot;; break;
-			case 80: s = &quot;\&quot;Default\&quot; expected&quot;; break;
-			case 81: s = &quot;\&quot;Delegate\&quot; expected&quot;; break;
-			case 82: s = &quot;\&quot;Dim\&quot; expected&quot;; break;
-			case 83: s = &quot;\&quot;DirectCast\&quot; expected&quot;; break;
-			case 84: s = &quot;\&quot;Do\&quot; expected&quot;; break;
-			case 85: s = &quot;\&quot;Double\&quot; expected&quot;; break;
-			case 86: s = &quot;\&quot;Each\&quot; expected&quot;; break;
-			case 87: s = &quot;\&quot;Else\&quot; expected&quot;; break;
-			case 88: s = &quot;\&quot;ElseIf\&quot; expected&quot;; break;
-			case 89: s = &quot;\&quot;End\&quot; expected&quot;; break;
-			case 90: s = &quot;\&quot;EndIf\&quot; expected&quot;; break;
-			case 91: s = &quot;\&quot;Enum\&quot; expected&quot;; break;
-			case 92: s = &quot;\&quot;Erase\&quot; expected&quot;; break;
-			case 93: s = &quot;\&quot;Error\&quot; expected&quot;; break;
-			case 94: s = &quot;\&quot;Event\&quot; expected&quot;; break;
-			case 95: s = &quot;\&quot;Exit\&quot; expected&quot;; break;
-			case 96: s = &quot;\&quot;Explicit\&quot; expected&quot;; break;
-			case 97: s = &quot;\&quot;False\&quot; expected&quot;; break;
-			case 98: s = &quot;\&quot;Finally\&quot; expected&quot;; break;
-			case 99: s = &quot;\&quot;For\&quot; expected&quot;; break;
-			case 100: s = &quot;\&quot;Friend\&quot; expected&quot;; break;
-			case 101: s = &quot;\&quot;Function\&quot; expected&quot;; break;
-			case 102: s = &quot;\&quot;Get\&quot; expected&quot;; break;
-			case 103: s = &quot;\&quot;GetType\&quot; expected&quot;; break;
-			case 104: s = &quot;\&quot;GoSub\&quot; expected&quot;; break;
-			case 105: s = &quot;\&quot;GoTo\&quot; expected&quot;; break;
-			case 106: s = &quot;\&quot;Handles\&quot; expected&quot;; break;
-			case 107: s = &quot;\&quot;If\&quot; expected&quot;; break;
-			case 108: s = &quot;\&quot;Implements\&quot; expected&quot;; break;
-			case 109: s = &quot;\&quot;Imports\&quot; expected&quot;; break;
-			case 110: s = &quot;\&quot;In\&quot; expected&quot;; break;
-			case 111: s = &quot;\&quot;Inherits\&quot; expected&quot;; break;
-			case 112: s = &quot;\&quot;Integer\&quot; expected&quot;; break;
-			case 113: s = &quot;\&quot;Interface\&quot; expected&quot;; break;
-			case 114: s = &quot;\&quot;Is\&quot; expected&quot;; break;
-			case 115: s = &quot;\&quot;Let\&quot; expected&quot;; break;
-			case 116: s = &quot;\&quot;Lib\&quot; expected&quot;; break;
-			case 117: s = &quot;\&quot;Like\&quot; expected&quot;; break;
-			case 118: s = &quot;\&quot;Long\&quot; expected&quot;; break;
-			case 119: s = &quot;\&quot;Loop\&quot; expected&quot;; break;
-			case 120: s = &quot;\&quot;Me\&quot; expected&quot;; break;
-			case 121: s = &quot;\&quot;Mod\&quot; expected&quot;; break;
-			case 122: s = &quot;\&quot;Module\&quot; expected&quot;; break;
-			case 123: s = &quot;\&quot;MustInherit\&quot; expected&quot;; break;
-			case 124: s = &quot;\&quot;MustOverride\&quot; expected&quot;; break;
-			case 125: s = &quot;\&quot;MyBase\&quot; expected&quot;; break;
-			case 126: s = &quot;\&quot;MyClass\&quot; expected&quot;; break;
-			case 127: s = &quot;\&quot;Namespace\&quot; expected&quot;; break;
-			case 128: s = &quot;\&quot;New\&quot; expected&quot;; break;
-			case 129: s = &quot;\&quot;Next\&quot; expected&quot;; break;
-			case 130: s = &quot;\&quot;Not\&quot; expected&quot;; break;
-			case 131: s = &quot;\&quot;Nothing\&quot; expected&quot;; break;
-			case 132: s = &quot;\&quot;NotInheritable\&quot; expected&quot;; break;
-			case 133: s = &quot;\&quot;NotOverridable\&quot; expected&quot;; break;
-			case 134: s = &quot;\&quot;Object\&quot; expected&quot;; break;
-			case 135: s = &quot;\&quot;Off\&quot; expected&quot;; break;
-			case 136: s = &quot;\&quot;On\&quot; expected&quot;; break;
-			case 137: s = &quot;\&quot;Option\&quot; expected&quot;; break;
-			case 138: s = &quot;\&quot;Optional\&quot; expected&quot;; break;
-			case 139: s = &quot;\&quot;Or\&quot; expected&quot;; break;
-			case 140: s = &quot;\&quot;OrElse\&quot; expected&quot;; break;
-			case 141: s = &quot;\&quot;Overloads\&quot; expected&quot;; break;
-			case 142: s = &quot;\&quot;Overridable\&quot; expected&quot;; break;
-			case 143: s = &quot;\&quot;Override\&quot; expected&quot;; break;
-			case 144: s = &quot;\&quot;Overrides\&quot; expected&quot;; break;
-			case 145: s = &quot;\&quot;ParamArray\&quot; expected&quot;; break;
-			case 146: s = &quot;\&quot;Preserve\&quot; expected&quot;; break;
-			case 147: s = &quot;\&quot;Private\&quot; expected&quot;; break;
-			case 148: s = &quot;\&quot;Property\&quot; expected&quot;; break;
-			case 149: s = &quot;\&quot;Protected\&quot; expected&quot;; break;
-			case 150: s = &quot;\&quot;Public\&quot; expected&quot;; break;
-			case 151: s = &quot;\&quot;RaiseEvent\&quot; expected&quot;; break;
-			case 152: s = &quot;\&quot;ReadOnly\&quot; expected&quot;; break;
-			case 153: s = &quot;\&quot;ReDim\&quot; expected&quot;; break;
-			case 154: s = &quot;\&quot;RemoveHandler\&quot; expected&quot;; break;
-			case 155: s = &quot;\&quot;Resume\&quot; expected&quot;; break;
-			case 156: s = &quot;\&quot;Return\&quot; expected&quot;; break;
-			case 157: s = &quot;\&quot;Select\&quot; expected&quot;; break;
-			case 158: s = &quot;\&quot;Set\&quot; expected&quot;; break;
-			case 159: s = &quot;\&quot;Shadows\&quot; expected&quot;; break;
-			case 160: s = &quot;\&quot;Shared\&quot; expected&quot;; break;
-			case 161: s = &quot;\&quot;Short\&quot; expected&quot;; break;
-			case 162: s = &quot;\&quot;Single\&quot; expected&quot;; break;
-			case 163: s = &quot;\&quot;Static\&quot; expected&quot;; break;
-			case 164: s = &quot;\&quot;Step\&quot; expected&quot;; break;
-			case 165: s = &quot;\&quot;Stop\&quot; expected&quot;; break;
-			case 166: s = &quot;\&quot;Strict\&quot; expected&quot;; break;
-			case 167: s = &quot;\&quot;String\&quot; expected&quot;; break;
-			case 168: s = &quot;\&quot;Structure\&quot; expected&quot;; break;
-			case 169: s = &quot;\&quot;Sub\&quot; expected&quot;; break;
-			case 170: s = &quot;\&quot;SyncLock\&quot; expected&quot;; break;
-			case 171: s = &quot;\&quot;Text\&quot; expected&quot;; break;
-			case 172: s = &quot;\&quot;Then\&quot; expected&quot;; break;
-			case 173: s = &quot;\&quot;Throw\&quot; expected&quot;; break;
-			case 174: s = &quot;\&quot;To\&quot; expected&quot;; break;
-			case 175: s = &quot;\&quot;True\&quot; expected&quot;; break;
-			case 176: s = &quot;\&quot;Try\&quot; expected&quot;; break;
-			case 177: s = &quot;\&quot;TypeOf\&quot; expected&quot;; break;
-			case 178: s = &quot;\&quot;Unicode\&quot; expected&quot;; break;
-			case 179: s = &quot;\&quot;Until\&quot; expected&quot;; break;
-			case 180: s = &quot;\&quot;Variant\&quot; expected&quot;; break;
-			case 181: s = &quot;\&quot;Wend\&quot; expected&quot;; break;
-			case 182: s = &quot;\&quot;When\&quot; expected&quot;; break;
-			case 183: s = &quot;\&quot;While\&quot; expected&quot;; break;
-			case 184: s = &quot;\&quot;With\&quot; expected&quot;; break;
-			case 185: s = &quot;\&quot;WithEvents\&quot; expected&quot;; break;
-			case 186: s = &quot;\&quot;WriteOnly\&quot; expected&quot;; break;
-			case 187: s = &quot;\&quot;Xor\&quot; expected&quot;; break;
-			case 188: s = &quot;??? expected&quot;; break;
-			case 189: s = &quot;invalid OptionStmt&quot;; break;
-			case 190: s = &quot;invalid OptionStmt&quot;; break;
-			case 191: s = &quot;invalid GlobalAttributeSection&quot;; break;
-			case 192: s = &quot;invalid NamespaceMemberDecl&quot;; break;
-			case 193: s = &quot;invalid OptionValue&quot;; break;
-			case 194: s = &quot;invalid EndOfStmt&quot;; break;
-			case 195: s = &quot;invalid Identifier&quot;; break;
-			case 196: s = &quot;invalid TypeModifier&quot;; break;
-			case 197: s = &quot;invalid NonModuleDeclaration&quot;; break;
-			case 198: s = &quot;invalid NonModuleDeclaration&quot;; break;
-			case 199: s = &quot;invalid PrimitiveTypeName&quot;; break;
-			case 200: s = &quot;invalid MemberModifier&quot;; break;
-			case 201: s = &quot;invalid StructureMemberDecl&quot;; break;
-			case 202: s = &quot;invalid StructureMemberDecl&quot;; break;
-			case 203: s = &quot;invalid StructureMemberDecl&quot;; break;
-			case 204: s = &quot;invalid StructureMemberDecl&quot;; break;
-			case 205: s = &quot;invalid StructureMemberDecl&quot;; break;
-			case 206: s = &quot;invalid StructureMemberDecl&quot;; break;
-			case 207: s = &quot;invalid StructureMemberDecl&quot;; break;
-			case 208: s = &quot;invalid InterfaceMemberDecl&quot;; break;
-			case 209: s = &quot;invalid InterfaceMemberDecl&quot;; break;
-			case 210: s = &quot;invalid Charset&quot;; break;
-			case 211: s = &quot;invalid VariableDeclarator&quot;; break;
-			case 212: s = &quot;invalid AccessorDecls&quot;; break;
-			case 213: s = &quot;invalid VariableInitializer&quot;; break;
-			case 214: s = &quot;invalid EventMemberSpecifier&quot;; break;
-			case 215: s = &quot;invalid EventMemberSpecifier&quot;; break;
-			case 216: s = &quot;invalid AssignmentOperator&quot;; break;
-			case 217: s = &quot;invalid SimpleExpr&quot;; break;
-			case 218: s = &quot;invalid SimpleExpr&quot;; break;
-			case 219: s = &quot;invalid SimpleExpr&quot;; break;
-			case 220: s = &quot;invalid IdentifierOrKeyword&quot;; break;
-			case 221: s = &quot;invalid CastTarget&quot;; break;
-			case 222: s = &quot;invalid Argument&quot;; break;
-			case 223: s = &quot;invalid RelationalExpr&quot;; break;
-			case 224: s = &quot;invalid NonArrayTypeName&quot;; break;
-			case 225: s = &quot;invalid AttributeArguments&quot;; break;
-			case 226: s = &quot;invalid ParameterModifier&quot;; break;
-			case 227: s = &quot;invalid Statement&quot;; break;
-			case 228: s = &quot;invalid LabelName&quot;; break;
-			case 229: s = &quot;invalid EmbeddedStatement&quot;; break;
-			case 230: s = &quot;invalid EmbeddedStatement&quot;; break;
-			case 231: s = &quot;invalid EmbeddedStatement&quot;; break;
-			case 232: s = &quot;invalid EmbeddedStatement&quot;; break;
-			case 233: s = &quot;invalid EmbeddedStatement&quot;; break;
-			case 234: s = &quot;invalid EmbeddedStatement&quot;; break;
-			case 235: s = &quot;invalid TryStatement&quot;; break;
-			case 236: s = &quot;invalid WhileOrUntil&quot;; break;
-			case 237: s = &quot;invalid OnErrorStatement&quot;; break;
-			case 238: s = &quot;invalid ResumeStatement&quot;; break;
-			case 239: s = &quot;invalid CaseClause&quot;; break;
-			case 240: s = &quot;invalid CaseClause&quot;; break;
+			case 0: s = &quot;EOF expected&quot;; break;
+			case 1: s = &quot;EOL expected&quot;; break;
+			case 2: s = &quot;ident expected&quot;; break;
+			case 3: s = &quot;LiteralString expected&quot;; break;
+			case 4: s = &quot;LiteralCharacter expected&quot;; break;
+			case 5: s = &quot;LiteralInteger expected&quot;; break;
+			case 6: s = &quot;LiteralDouble expected&quot;; break;
+			case 7: s = &quot;LiteralSingle expected&quot;; break;
+			case 8: s = &quot;LiteralDecimal expected&quot;; break;
+			case 9: s = &quot;LiteralDate expected&quot;; break;
+			case 10: s = &quot;\&quot;.\&quot; expected&quot;; break;
+			case 11: s = &quot;\&quot;=\&quot; expected&quot;; break;
+			case 12: s = &quot;\&quot;,\&quot; expected&quot;; break;
+			case 13: s = &quot;\&quot;:\&quot; expected&quot;; break;
+			case 14: s = &quot;\&quot;+\&quot; expected&quot;; break;
+			case 15: s = &quot;\&quot;-\&quot; expected&quot;; break;
+			case 16: s = &quot;\&quot;*\&quot; expected&quot;; break;
+			case 17: s = &quot;\&quot;/\&quot; expected&quot;; break;
+			case 18: s = &quot;\&quot;\\\\\&quot; expected&quot;; break;
+			case 19: s = &quot;\&quot;&amp;\&quot; expected&quot;; break;
+			case 20: s = &quot;\&quot;^\&quot; expected&quot;; break;
+			case 21: s = &quot;\&quot;{\&quot; expected&quot;; break;
+			case 22: s = &quot;\&quot;}\&quot; expected&quot;; break;
+			case 23: s = &quot;\&quot;[\&quot; expected&quot;; break;
+			case 24: s = &quot;\&quot;]\&quot; expected&quot;; break;
+			case 25: s = &quot;\&quot;(\&quot; expected&quot;; break;
+			case 26: s = &quot;\&quot;)\&quot; expected&quot;; break;
+			case 27: s = &quot;\&quot;&gt;\&quot; expected&quot;; break;
+			case 28: s = &quot;\&quot;&lt;\&quot; expected&quot;; break;
+			case 29: s = &quot;\&quot;&lt;&gt;\&quot; expected&quot;; break;
+			case 30: s = &quot;\&quot;&gt;=\&quot; expected&quot;; break;
+			case 31: s = &quot;\&quot;&lt;=\&quot; expected&quot;; break;
+			case 32: s = &quot;\&quot;&lt;&lt;\&quot; expected&quot;; break;
+			case 33: s = &quot;\&quot;&gt;&gt;\&quot; expected&quot;; break;
+			case 34: s = &quot;\&quot;+=\&quot; expected&quot;; break;
+			case 35: s = &quot;\&quot;^=\&quot; expected&quot;; break;
+			case 36: s = &quot;\&quot;-=\&quot; expected&quot;; break;
+			case 37: s = &quot;\&quot;*=\&quot; expected&quot;; break;
+			case 38: s = &quot;\&quot;/=\&quot; expected&quot;; break;
+			case 39: s = &quot;\&quot;\\\\=\&quot; expected&quot;; break;
+			case 40: s = &quot;\&quot;&lt;&lt;=\&quot; expected&quot;; break;
+			case 41: s = &quot;\&quot;&gt;&gt;=\&quot; expected&quot;; break;
+			case 42: s = &quot;\&quot;&amp;=\&quot; expected&quot;; break;
+			case 43: s = &quot;\&quot;AddHandler\&quot; expected&quot;; break;
+			case 44: s = &quot;\&quot;AddressOf\&quot; expected&quot;; break;
+			case 45: s = &quot;\&quot;Alias\&quot; expected&quot;; break;
+			case 46: s = &quot;\&quot;And\&quot; expected&quot;; break;
+			case 47: s = &quot;\&quot;AndAlso\&quot; expected&quot;; break;
+			case 48: s = &quot;\&quot;Ansi\&quot; expected&quot;; break;
+			case 49: s = &quot;\&quot;As\&quot; expected&quot;; break;
+			case 50: s = &quot;\&quot;Assembly\&quot; expected&quot;; break;
+			case 51: s = &quot;\&quot;Auto\&quot; expected&quot;; break;
+			case 52: s = &quot;\&quot;Binary\&quot; expected&quot;; break;
+			case 53: s = &quot;\&quot;Boolean\&quot; expected&quot;; break;
+			case 54: s = &quot;\&quot;ByRef\&quot; expected&quot;; break;
+			case 55: s = &quot;\&quot;Byte\&quot; expected&quot;; break;
+			case 56: s = &quot;\&quot;ByVal\&quot; expected&quot;; break;
+			case 57: s = &quot;\&quot;Call\&quot; expected&quot;; break;
+			case 58: s = &quot;\&quot;Case\&quot; expected&quot;; break;
+			case 59: s = &quot;\&quot;Catch\&quot; expected&quot;; break;
+			case 60: s = &quot;\&quot;CBool\&quot; expected&quot;; break;
+			case 61: s = &quot;\&quot;CByte\&quot; expected&quot;; break;
+			case 62: s = &quot;\&quot;CChar\&quot; expected&quot;; break;
+			case 63: s = &quot;\&quot;CDate\&quot; expected&quot;; break;
+			case 64: s = &quot;\&quot;CDbl\&quot; expected&quot;; break;
+			case 65: s = &quot;\&quot;CDec\&quot; expected&quot;; break;
+			case 66: s = &quot;\&quot;Char\&quot; expected&quot;; break;
+			case 67: s = &quot;\&quot;CInt\&quot; expected&quot;; break;
+			case 68: s = &quot;\&quot;Class\&quot; expected&quot;; break;
+			case 69: s = &quot;\&quot;CLng\&quot; expected&quot;; break;
+			case 70: s = &quot;\&quot;CObj\&quot; expected&quot;; break;
+			case 71: s = &quot;\&quot;Compare\&quot; expected&quot;; break;
+			case 72: s = &quot;\&quot;Const\&quot; expected&quot;; break;
+			case 73: s = &quot;\&quot;CShort\&quot; expected&quot;; break;
+			case 74: s = &quot;\&quot;CSng\&quot; expected&quot;; break;
+			case 75: s = &quot;\&quot;CStr\&quot; expected&quot;; break;
+			case 76: s = &quot;\&quot;CType\&quot; expected&quot;; break;
+			case 77: s = &quot;\&quot;Date\&quot; expected&quot;; break;
+			case 78: s = &quot;\&quot;Decimal\&quot; expected&quot;; break;
+			case 79: s = &quot;\&quot;Declare\&quot; expected&quot;; break;
+			case 80: s = &quot;\&quot;Default\&quot; expected&quot;; break;
+			case 81: s = &quot;\&quot;Delegate\&quot; expected&quot;; break;
+			case 82: s = &quot;\&quot;Dim\&quot; expected&quot;; break;
+			case 83: s = &quot;\&quot;DirectCast\&quot; expected&quot;; break;
+			case 84: s = &quot;\&quot;Do\&quot; expected&quot;; break;
+			case 85: s = &quot;\&quot;Double\&quot; expected&quot;; break;
+			case 86: s = &quot;\&quot;Each\&quot; expected&quot;; break;
+			case 87: s = &quot;\&quot;Else\&quot; expected&quot;; break;
+			case 88: s = &quot;\&quot;ElseIf\&quot; expected&quot;; break;
+			case 89: s = &quot;\&quot;End\&quot; expected&quot;; break;
+			case 90: s = &quot;\&quot;EndIf\&quot; expected&quot;; break;
+			case 91: s = &quot;\&quot;Enum\&quot; expected&quot;; break;
+			case 92: s = &quot;\&quot;Erase\&quot; expected&quot;; break;
+			case 93: s = &quot;\&quot;Error\&quot; expected&quot;; break;
+			case 94: s = &quot;\&quot;Event\&quot; expected&quot;; break;
+			case 95: s = &quot;\&quot;Exit\&quot; expected&quot;; break;
+			case 96: s = &quot;\&quot;Explicit\&quot; expected&quot;; break;
+			case 97: s = &quot;\&quot;False\&quot; expected&quot;; break;
+			case 98: s = &quot;\&quot;Finally\&quot; expected&quot;; break;
+			case 99: s = &quot;\&quot;For\&quot; expected&quot;; break;
+			case 100: s = &quot;\&quot;Friend\&quot; expected&quot;; break;
+			case 101: s = &quot;\&quot;Function\&quot; expected&quot;; break;
+			case 102: s = &quot;\&quot;Get\&quot; expected&quot;; break;
+			case 103: s = &quot;\&quot;GetType\&quot; expected&quot;; break;
+			case 104: s = &quot;\&quot;GoSub\&quot; expected&quot;; break;
+			case 105: s = &quot;\&quot;GoTo\&quot; expected&quot;; break;
+			case 106: s = &quot;\&quot;Handles\&quot; expected&quot;; break;
+			case 107: s = &quot;\&quot;If\&quot; expected&quot;; break;
+			case 108: s = &quot;\&quot;Implements\&quot; expected&quot;; break;
+			case 109: s = &quot;\&quot;Imports\&quot; expected&quot;; break;
+			case 110: s = &quot;\&quot;In\&quot; expected&quot;; break;
+			case 111: s = &quot;\&quot;Inherits\&quot; expected&quot;; break;
+			case 112: s = &quot;\&quot;Integer\&quot; expected&quot;; break;
+			case 113: s = &quot;\&quot;Interface\&quot; expected&quot;; break;
+			case 114: s = &quot;\&quot;Is\&quot; expected&quot;; break;
+			case 115: s = &quot;\&quot;Let\&quot; expected&quot;; break;
+			case 116: s = &quot;\&quot;Lib\&quot; expected&quot;; break;
+			case 117: s = &quot;\&quot;Like\&quot; expected&quot;; break;
+			case 118: s = &quot;\&quot;Long\&quot; expected&quot;; break;
+			case 119: s = &quot;\&quot;Loop\&quot; expected&quot;; break;
+			case 120: s = &quot;\&quot;Me\&quot; expected&quot;; break;
+			case 121: s = &quot;\&quot;Mod\&quot; expected&quot;; break;
+			case 122: s = &quot;\&quot;Module\&quot; expected&quot;; break;
+			case 123: s = &quot;\&quot;MustInherit\&quot; expected&quot;; break;
+			case 124: s = &quot;\&quot;MustOverride\&quot; expected&quot;; break;
+			case 125: s = &quot;\&quot;MyBase\&quot; expected&quot;; break;
+			case 126: s = &quot;\&quot;MyClass\&quot; expected&quot;; break;
+			case 127: s = &quot;\&quot;Namespace\&quot; expected&quot;; break;
+			case 128: s = &quot;\&quot;New\&quot; expected&quot;; break;
+			case 129: s = &quot;\&quot;Next\&quot; expected&quot;; break;
+			case 130: s = &quot;\&quot;Not\&quot; expected&quot;; break;
+			case 131: s = &quot;\&quot;Nothing\&quot; expected&quot;; break;
+			case 132: s = &quot;\&quot;NotInheritable\&quot; expected&quot;; break;
+			case 133: s = &quot;\&quot;NotOverridable\&quot; expected&quot;; break;
+			case 134: s = &quot;\&quot;Object\&quot; expected&quot;; break;
+			case 135: s = &quot;\&quot;Off\&quot; expected&quot;; break;
+			case 136: s = &quot;\&quot;On\&quot; expected&quot;; break;
+			case 137: s = &quot;\&quot;Option\&quot; expected&quot;; break;
+			case 138: s = &quot;\&quot;Optional\&quot; expected&quot;; break;
+			case 139: s = &quot;\&quot;Or\&quot; expected&quot;; break;
+			case 140: s = &quot;\&quot;OrElse\&quot; expected&quot;; break;
+			case 141: s = &quot;\&quot;Overloads\&quot; expected&quot;; break;
+			case 142: s = &quot;\&quot;Overridable\&quot; expected&quot;; break;
+			case 143: s = &quot;\&quot;Override\&quot; expected&quot;; break;
+			case 144: s = &quot;\&quot;Overrides\&quot; expected&quot;; break;
+			case 145: s = &quot;\&quot;ParamArray\&quot; expected&quot;; break;
+			case 146: s = &quot;\&quot;Preserve\&quot; expected&quot;; break;
+			case 147: s = &quot;\&quot;Private\&quot; expected&quot;; break;
+			case 148: s = &quot;\&quot;Property\&quot; expected&quot;; break;
+			case 149: s = &quot;\&quot;Protected\&quot; expected&quot;; break;
+			case 150: s = &quot;\&quot;Public\&quot; expected&quot;; break;
+			case 151: s = &quot;\&quot;RaiseEvent\&quot; expected&quot;; break;
+			case 152: s = &quot;\&quot;ReadOnly\&quot; expected&quot;; break;
+			case 153: s = &quot;\&quot;ReDim\&quot; expected&quot;; break;
+			case 154: s = &quot;\&quot;RemoveHandler\&quot; expected&quot;; break;
+			case 155: s = &quot;\&quot;Resume\&quot; expected&quot;; break;
+			case 156: s = &quot;\&quot;Return\&quot; expected&quot;; break;
+			case 157: s = &quot;\&quot;Select\&quot; expected&quot;; break;
+			case 158: s = &quot;\&quot;Set\&quot; expected&quot;; break;
+			case 159: s = &quot;\&quot;Shadows\&quot; expected&quot;; break;
+			case 160: s = &quot;\&quot;Shared\&quot; expected&quot;; break;
+			case 161: s = &quot;\&quot;Short\&quot; expected&quot;; break;
+			case 162: s = &quot;\&quot;Single\&quot; expected&quot;; break;
+			case 163: s = &quot;\&quot;Static\&quot; expected&quot;; break;
+			case 164: s = &quot;\&quot;Step\&quot; expected&quot;; break;
+			case 165: s = &quot;\&quot;Stop\&quot; expected&quot;; break;
+			case 166: s = &quot;\&quot;Strict\&quot; expected&quot;; break;
+			case 167: s = &quot;\&quot;String\&quot; expected&quot;; break;
+			case 168: s = &quot;\&quot;Structure\&quot; expected&quot;; break;
+			case 169: s = &quot;\&quot;Sub\&quot; expected&quot;; break;
+			case 170: s = &quot;\&quot;SyncLock\&quot; expected&quot;; break;
+			case 171: s = &quot;\&quot;Text\&quot; expected&quot;; break;
+			case 172: s = &quot;\&quot;Then\&quot; expected&quot;; break;
+			case 173: s = &quot;\&quot;Throw\&quot; expected&quot;; break;
+			case 174: s = &quot;\&quot;To\&quot; expected&quot;; break;
+			case 175: s = &quot;\&quot;True\&quot; expected&quot;; break;
+			case 176: s = &quot;\&quot;Try\&quot; expected&quot;; break;
+			case 177: s = &quot;\&quot;TypeOf\&quot; expected&quot;; break;
+			case 178: s = &quot;\&quot;Unicode\&quot; expected&quot;; break;
+			case 179: s = &quot;\&quot;Until\&quot; expected&quot;; break;
+			case 180: s = &quot;\&quot;Variant\&quot; expected&quot;; break;
+			case 181: s = &quot;\&quot;Wend\&quot; expected&quot;; break;
+			case 182: s = &quot;\&quot;When\&quot; expected&quot;; break;
+			case 183: s = &quot;\&quot;While\&quot; expected&quot;; break;
+			case 184: s = &quot;\&quot;With\&quot; expected&quot;; break;
+			case 185: s = &quot;\&quot;WithEvents\&quot; expected&quot;; break;
+			case 186: s = &quot;\&quot;WriteOnly\&quot; expected&quot;; break;
+			case 187: s = &quot;\&quot;Xor\&quot; expected&quot;; break;
+			case 188: s = &quot;??? expected&quot;; break;
+			case 189: s = &quot;invalid OptionStmt&quot;; break;
+			case 190: s = &quot;invalid OptionStmt&quot;; break;
+			case 191: s = &quot;invalid GlobalAttributeSection&quot;; break;
+			case 192: s = &quot;invalid NamespaceMemberDecl&quot;; break;
+			case 193: s = &quot;invalid OptionValue&quot;; break;
+			case 194: s = &quot;invalid EndOfStmt&quot;; break;
+			case 195: s = &quot;invalid Identifier&quot;; break;
+			case 196: s = &quot;invalid TypeModifier&quot;; break;
+			case 197: s = &quot;invalid NonModuleDeclaration&quot;; break;
+			case 198: s = &quot;invalid NonModuleDeclaration&quot;; break;
+			case 199: s = &quot;invalid PrimitiveTypeName&quot;; break;
+			case 200: s = &quot;invalid MemberModifier&quot;; break;
+			case 201: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 202: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 203: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 204: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 205: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 206: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 207: s = &quot;invalid StructureMemberDecl&quot;; break;
+			case 208: s = &quot;invalid InterfaceMemberDecl&quot;; break;
+			case 209: s = &quot;invalid InterfaceMemberDecl&quot;; break;
+			case 210: s = &quot;invalid Charset&quot;; break;
+			case 211: s = &quot;invalid VariableDeclarator&quot;; break;
+			case 212: s = &quot;invalid AccessorDecls&quot;; break;
+			case 213: s = &quot;invalid VariableInitializer&quot;; break;
+			case 214: s = &quot;invalid EventMemberSpecifier&quot;; break;
+			case 215: s = &quot;invalid EventMemberSpecifier&quot;; break;
+			case 216: s = &quot;invalid AssignmentOperator&quot;; break;
+			case 217: s = &quot;invalid SimpleExpr&quot;; break;
+			case 218: s = &quot;invalid SimpleExpr&quot;; break;
+			case 219: s = &quot;invalid SimpleExpr&quot;; break;
+			case 220: s = &quot;invalid IdentifierOrKeyword&quot;; break;
+			case 221: s = &quot;invalid CastTarget&quot;; break;
+			case 222: s = &quot;invalid Argument&quot;; break;
+			case 223: s = &quot;invalid RelationalExpr&quot;; break;
+			case 224: s = &quot;invalid NonArrayTypeName&quot;; break;
+			case 225: s = &quot;invalid AttributeArguments&quot;; break;
+			case 226: s = &quot;invalid ParameterModifier&quot;; break;
+			case 227: s = &quot;invalid Statement&quot;; break;
+			case 228: s = &quot;invalid LabelName&quot;; break;
+			case 229: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 230: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 231: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 232: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 233: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 234: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 235: s = &quot;invalid TryStatement&quot;; break;
+			case 236: s = &quot;invalid WhileOrUntil&quot;; break;
+			case 237: s = &quot;invalid OnErrorStatement&quot;; break;
+			case 238: s = &quot;invalid ResumeStatement&quot;; break;
+			case 239: s = &quot;invalid CaseClause&quot;; break;
+			case 240: s = &quot;invalid CaseClause&quot;; break;
 
 			default: s = &quot;error &quot; + errorNumber; break;
 		}
@@ -6533,37 +6533,37 @@
 	}
 
 	static bool[,] set = {
-	{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, T,x,x,x, x,x,x,T, T,T,T,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, x,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
-	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
-	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,T,x,x, x,T,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,T,x,x, x,x,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
-	{x,T,x,x, x,x,x,x, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,T, T,T,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,T, T,T,T,T, T,T,T,x, T,x,T,T, T,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, T,T,x,x, x,x,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,x, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
-	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
-	{x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x}
+	{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, T,x,x,x, x,x,x,T, T,T,T,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, x,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,T,x,x, x,T,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,T,T,x, T,x,x,T, T,T,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,T,x,x, x,x,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,T, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, T,x,T,T, T,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,T, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,T, T,T,T,T, T,T,T,x, x,x,T,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, T,T,x,T, x,T,x,x, T,T,T,T, T,T,T,T, x,T,T,T, x,T,T,T, T,T,T,x, x,x,x,T, T,T,x,x, x,x,x,x, T,T,x,T, x,T,x,T, x,x,x,T, x,T,x,T, x,x,x,x, T,x,x,x, x,x,T,x, T,x,x,x, x,T,T,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,T,x,x, x,T,T,x, x,T,x,T, x,x,T,T, x,T,x,T, T,T,x,x, x,x,x,T, T,x,x,x, x,x},
+	{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x}
 
 	};
 } // end Parser

Modified: trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG	2005-01-31 18:03:07 UTC (rev 2200)
+++ trunk/MonoDevelop/Core/src/AddIns/BackendBindings/VBNetBinding/SharpRefactoryVB/src/Parser/generated/VBNET.ATG	2005-01-31 19:20:08 UTC (rev 2201)
@@ -762,7 +762,7 @@
 		AttributeSection section;
 		Modifiers mod = new Modifiers(this);
 		ArrayList attributes = new ArrayList();
-		ArrayList parameters = new ArrayList();
+		/*ArrayList parameters = new ArrayList();*/
 		string name;
 	.) =
 	{ AttributeSection&lt;out section&gt;			(. attributes.Add(section); .) }
@@ -2189,7 +2189,7 @@
 	(.
 		ArrayList clauses = new ArrayList();
 		clauses.Add(clause);
-		ReDimStatement reDimStatement = new ReDimStatement(clauses);
+		/*ReDimStatement reDimStatement = new ReDimStatement(clauses);*/
 	.)
 	{ &quot;,&quot; Expr&lt;out clause&gt; (. clauses.Add(clause); .) }
 	| /* 10.12.2 */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001804.html">[Monodevelop-patches-list] r2200 - in trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory: . src/Lexer src/Parser/generated
</A></li>
	<LI>Next message: <A HREF="001806.html">[Monodevelop-patches-list] r2202 - trunk/MonoDevelop/Core/src/ICSharpCode.SharpRefactory/src/Parser/generated
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1805">[ date ]</a>
              <a href="thread.html#1805">[ thread ]</a>
              <a href="subject.html#1805">[ subject ]</a>
              <a href="author.html#1805">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
