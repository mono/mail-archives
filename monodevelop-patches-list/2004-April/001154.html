<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1547 - in branches/MonoDevelop-generate-what: build/AddIns src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/DisplayBindings/SourceEditor src/AddIns/DisplayBindings/SourceEditor/CodeCompletion src/Main/Base src/Main/Base/Commands src/Main/Base/Commands/ProjectBrowserCommands src/Main/Base/Gui/CompletionDatabaseWizard src/Main/Base/Internal/Parser src/Main/Base/Internal/Parser/Implementations src/Main/Base/Services/ParserService
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1547%20-%20in%20branches/MonoDevelop-generate-what%3A%20build/AddIns%20src/AddIns/BackendBindings/CSharpBinding%20src/AddIns/BackendBindings/CSharpBinding/Parser%20src/AddIns/DisplayBindings/SourceEditor%20src/AddIns/DisplayBindings/SourceEditor/CodeCompletion%20src/Main/Base%20src/Main/Base/Commands%20src/Main/Base/Commands/ProjectBrowserCommands%20src/Main/Base/Gui/CompletionDatabaseWizard%20src/Main/Base/Internal/Parser%20src/Main/Base/Internal/Parser/Implementations%20src/Main/Base/Services/ParserService&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001153.html">
   <LINK REL="Next"  HREF="001155.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1547 - in branches/MonoDevelop-generate-what: build/AddIns src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/DisplayBindings/SourceEditor src/AddIns/DisplayBindings/SourceEditor/CodeCompletion src/Main/Base src/Main/Base/Commands src/Main/Base/Commands/ProjectBrowserCommands src/Main/Base/Gui/CompletionDatabaseWizard src/Main/Base/Internal/Parser src/Main/Base/Internal/Parser/Implementations src/Main/Base/Services/ParserService</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1547%20-%20in%20branches/MonoDevelop-generate-what%3A%20build/AddIns%20src/AddIns/BackendBindings/CSharpBinding%20src/AddIns/BackendBindings/CSharpBinding/Parser%20src/AddIns/DisplayBindings/SourceEditor%20src/AddIns/DisplayBindings/SourceEditor/CodeCompletion%20src/Main/Base%20src/Main/Base/Commands%20src/Main/Base/Commands/ProjectBrowserCommands%20src/Main/Base/Gui/CompletionDatabaseWizard%20src/Main/Base/Internal/Parser%20src/Main/Base/Internal/Parser/Implementations%20src/Main/Base/Services/ParserService&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1547 - in branches/MonoDevelop-generate-what: build/AddIns src/AddIns/BackendBindings/CSharpBinding src/AddIns/BackendBindings/CSharpBinding/Parser src/AddIns/DisplayBindings/SourceEditor src/AddIns/DisplayBindings/SourceEditor/CodeCompletion src/Main/Base src/Main/Base/Commands src/Main/Base/Commands/ProjectBrowserCommands src/Main/Base/Gui/CompletionDatabaseWizard src/Main/Base/Internal/Parser src/Main/Base/Internal/Parser/Implementations src/Main/Base/Services/ParserService">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Thu Apr 29 09:21:50 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001153.html">[Monodevelop-patches-list] r1546 - in trunk/MonoDevelop/src/AddIns: BackendBindings/CSharpBinding DebuggerAddIn
</A></li>
        <LI>Next message: <A HREF="001155.html">[Monodevelop-patches-list] r1548 - in branches/MonoDevelop-generate-what: build/data/resources/icons build/data/templates/file/CSharp docs src/AddIns/BackendBindings/CSharpBinding src/AddIns/DebuggerAddIn src/AddIns/DisplayBindings/SourceEditor src/AddIns/DisplayBindings/SourceEditor/Gui src/Main/Base src/Main/Base/Internal/Project/Project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1154">[ date ]</a>
              <a href="thread.html#1154">[ thread ]</a>
              <a href="subject.html#1154">[ subject ]</a>
              <a href="author.html#1154">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: iainmc
Date: 2004-04-29 09:21:50 -0400 (Thu, 29 Apr 2004)
New Revision: 1547

Added:
   branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DatabaseBackedCompletionDataService.cs
   branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/ICompletionDataService.cs
Modified:
   branches/MonoDevelop-generate-what/build/AddIns/SharpDevelopCore.addin.xml
   branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/ChangeLog
   branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs
   branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs
   branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/ChangeLog
   branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs
   branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs
   branches/MonoDevelop-generate-what/src/Main/Base/ChangeLog
   branches/MonoDevelop-generate-what/src/Main/Base/Commands/AutostartCommands.cs
   branches/MonoDevelop-generate-what/src/Main/Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs
   branches/MonoDevelop-generate-what/src/Main/Base/Gui/CompletionDatabaseWizard/CreateDBGenerator.cs
   branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/IParser.cs
   branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/Implementations/AbstractClass.cs
   branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/Implementations/AbstractUsing.cs
   branches/MonoDevelop-generate-what/src/Main/Base/Makefile.am
   branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs
   branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/IParserService.cs
Log:
Refactoring the database reading bits out of the ParserService


Modified: branches/MonoDevelop-generate-what/build/AddIns/SharpDevelopCore.addin.xml
===================================================================
--- branches/MonoDevelop-generate-what/build/AddIns/SharpDevelopCore.addin.xml	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/build/AddIns/SharpDevelopCore.addin.xml	2004-04-29 13:21:50 UTC (rev 1547)
@@ -38,6 +38,8 @@
 		       class = &quot;MonoDevelop.Services.DefaultFileService&quot;/&gt;
 		&lt;Class id    = &quot;ParserService&quot;
 		       class = &quot;MonoDevelop.Services.DefaultParserService&quot;/&gt;
+		&lt;Class id    = &quot;CompletionDataService&quot;
+		       class = &quot;MonoDevelop.Services.DatabaseBackedCompletionDataService&quot;/&gt;
 		&lt;Class id    = &quot;TaskService&quot;
 		       class = &quot;MonoDevelop.Services.TaskService&quot;/&gt;
 		&lt;Class id    = &quot;StatusBarService&quot;

Modified: branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/ChangeLog
===================================================================
--- branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/ChangeLog	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/ChangeLog	2004-04-29 13:21:50 UTC (rev 1547)
@@ -1,3 +1,8 @@
+2004-04-29  Iain McCoy  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">iain at mccoy.id.au</A>&gt;
+	* Parser/Parser.cs:
+	* Parser/Resolver.cs: changed to reflect creation of the
+	CompletionDataService
+
 2004-04-28  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
 
 	* CSharpLanguageBinding.cs: implemented GetMakefile passthru.

Modified: branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -89,19 +89,19 @@
 			return visitor.Cu;
 		}
 		
-		public ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName)
+		public ArrayList CtrlSpace(IParserService parserService, ICompletionDataService completionDataService, int caretLine, int caretColumn, string fileName)
 		{
-			return new Resolver().CtrlSpace(parserService, caretLine, caretColumn, fileName);
+			return new Resolver().CtrlSpace(parserService, completionDataService, caretLine, caretColumn, fileName);
 		}
 
-		public ArrayList IsAsResolve (IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		public ArrayList IsAsResolve (IParserService parserService, ICompletionDataService completionDataService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
-			return new Resolver ().IsAsResolve (parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+			return new Resolver ().IsAsResolve (parserService, completionDataService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 		}
 		
-		public ResolveResult Resolve(IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		public ResolveResult Resolve(IParserService parserService, ICompletionDataService completionDataService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
-			return new Resolver().Resolve(parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+			return new Resolver().Resolve(parserService, completionDataService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 		}
 		
 		///////// IParser Interface END

Modified: branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -20,6 +20,7 @@
 	public class Resolver
 	{
 		IParserService parserService;
+		ICompletionDataService completionDataService;
 		ICompilationUnit cu;
 		IClass callingClass;
 		LookupTableVisitor lookupTableVisitor;
@@ -57,7 +58,7 @@
 		int caretLine;
 		int caretColumn;
 		
-		public ResolveResult Resolve(IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		public ResolveResult Resolve(IParserService parserService, ICompletionDataService completionDataService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
 		{
 			Console.WriteLine(&quot;Start Resolving&quot;);
 			if (expression == null) {
@@ -85,7 +86,7 @@
 				}
 				string t = expression.Substring(i + 1);
 //				Console.WriteLine(&quot;in Using Statement&quot;);
-				string[] namespaces = parserService.GetNamespaceList(t);
+				string[] namespaces = completionDataService.GetNamespaceList(t);
 				if (namespaces == null || namespaces.Length &lt;= 0) {
 					return null;
 				}
@@ -180,14 +181,14 @@
 				if (n == null) {
 					return null;
 				}
-				ArrayList content = parserService.GetNamespaceContents(n);
+				ArrayList content = completionDataService.GetNamespaceContents(n);
 				ArrayList classes = new ArrayList();
 				for (int i = 0; i &lt; content.Count; ++i) {
 					if (content[i] is IClass) {
 						classes.Add((IClass)content[i]);
 					}
 				}
-				string[] namespaces = parserService.GetNamespaceList(n);
+				string[] namespaces = completionDataService.GetNamespaceList(n);
 				return new ResolveResult(namespaces, classes);
 			}
 			Console.WriteLine(&quot;Returning Result!&quot;);
@@ -643,7 +644,7 @@
 		/// &lt;/remarks&gt;
 		public string SearchNamespace(string name, ICompilationUnit unit)
 		{
-			if (parserService.NamespaceExists(name)) {
+			if (completionDataService.NamespaceExists(name)) {
 				return name;
 			}
 			if (unit == null) {
@@ -673,7 +674,7 @@
 				return null;
 			}
 			IClass c;
-			c = parserService.GetClass(name);
+			c = completionDataService.GetClass(name);
 			if (c != null) {
 //				Console.WriteLine(&quot;Found!&quot;);
 				return c;
@@ -699,7 +700,7 @@
 			string[] namespaces = fullname.Split(new char[] {'.'});
 			string curnamespace = namespaces[0] + '.';
 			for (int i = 1; i &lt; namespaces.Length; ++i) {
-				c = parserService.GetClass(curnamespace + name);
+				c = completionDataService.GetClass(curnamespace + name);
 				if (c != null) {
 					return c;
 				}
@@ -798,7 +799,7 @@
 			}
 		}
 
-		public ArrayList IsAsResolve (IParserService parserService, string expression, int caretLine, int caretColumn, string fileName, string fileContent)
+		public ArrayList IsAsResolve (IParserService parserService, ICompletionDataService completionDataService, string expression, int caretLine, int caretColumn, string fileName, string fileContent)
 		{
 			ArrayList result = new ArrayList ();
 			this.parserService = parserService;
@@ -853,7 +854,7 @@
 			return result;
 		}
 		
-		public ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName)
+		public ArrayList CtrlSpace(IParserService parserService, ICompletionDataService completionDataService, int caretLine, int caretColumn, string fileName)
 		{
 			ArrayList result = new ArrayList();
 			this.parserService = parserService;
@@ -886,11 +887,11 @@
 				result = ListMembers(result, callingClass);
 			}
 			string n = &quot;&quot;;
-			result.AddRange(parserService.GetNamespaceContents(n));
+			result.AddRange(completionDataService.GetNamespaceContents(n));
 			foreach (IUsing u in cu.Usings) {
 				if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
 					foreach (string name in u.Usings) {
-						result.AddRange(parserService.GetNamespaceContents(name));
+						result.AddRange(completionDataService.GetNamespaceContents(name));
 					}
 					foreach (string alias in u.Aliases.Keys) {
 						result.Add(alias);

Modified: branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/ChangeLog
===================================================================
--- branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/ChangeLog	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/ChangeLog	2004-04-29 13:21:50 UTC (rev 1547)
@@ -1,3 +1,8 @@
+2004-04-29  Iain McCoy  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">iain at mccoy.id.au</A>&gt;
+	* CodeCompletion/CodeCompletionData.cs:
+	* CodeCompletion/CodeCompletionDataProvider.cs: changed to
+	reflect creation of the CompletionDataService
+
 2004-04-27  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
 
 	* Gui/SourceEditorDisplayBinding.cs: workaround some to reduce the

Modified: branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionData.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -21,7 +21,7 @@
 	class CodeCompletionData : ICompletionDataWithMarkup
 	{
 		ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService) ServiceManager.Services.GetService (typeof (ClassBrowserIconsService));
-		IParserService parserService = (IParserService) MonoDevelop.Core.Services.ServiceManager.Services.GetService (typeof (IParserService));
+		ICompletionDataService completionDataService = (ICompletionDataService) MonoDevelop.Core.Services.ServiceManager.Services.GetService (typeof (ICompletionDataService));
 		static AmbienceService ambienceService = (AmbienceService) ServiceManager.Services.GetService (typeof (AmbienceService));
 		
 		string image;
@@ -91,8 +91,8 @@
 				//
 				// Mike
 				if (c is ClassProxy &amp;&amp; c.ClassType == ClassType.Delegate) {
-					description = ambienceService.CurrentAmbience.Convert(parserService.GetClass(c.FullyQualifiedName));
-					pango_description = PangoAmbience.Convert(parserService.GetClass(c.FullyQualifiedName));
+					description = ambienceService.CurrentAmbience.Convert(completionDataService.GetClass(c.FullyQualifiedName));
+					pango_description = PangoAmbience.Convert(completionDataService.GetClass(c.FullyQualifiedName));
 					c = null;
 				}
 				
@@ -130,8 +130,8 @@
 				//
 				// Mike
 				if (c is ClassProxy &amp;&amp; c.ClassType == ClassType.Delegate) {
-					description = ambienceService.CurrentAmbience.Convert(parserService.GetClass(c.FullyQualifiedName));
-					pango_description = PangoAmbience.Convert(parserService.GetClass(c.FullyQualifiedName));
+					description = ambienceService.CurrentAmbience.Convert(completionDataService.GetClass(c.FullyQualifiedName));
+					pango_description = PangoAmbience.Convert(completionDataService.GetClass(c.FullyQualifiedName));
 					c = null;
 				}
 				

Modified: branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CodeCompletionDataProvider.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -69,6 +69,7 @@
 			//string expression    = TextUtilities.GetExpressionBeforeOffset (textArea, insertIter.Offset);
 			ResolveResult results;
 			
+			ICompletionDataService completionDataService = (ICompletionDataService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(ICompletionDataService));
 			IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
 			IExpressionFinder expressionFinder = parserService.GetExpressionFinder(fileName);
 			string expression    = expressionFinder == null ? TextUtilities.GetExpressionBeforeOffset(textArea, insertIter.Offset) : expressionFinder.FindExpression(textArea.Buffer.GetText(textArea.Buffer.StartIter, insertIter, true), insertIter.Offset - 2);
@@ -86,7 +87,7 @@
 			}
 			if (charTyped == ' ') {
 				if (expression == &quot;using&quot; || expression.EndsWith(&quot; using&quot;) || expression.EndsWith(&quot;\tusing&quot;)|| expression.EndsWith(&quot;\nusing&quot;)|| expression.EndsWith(&quot;\rusing&quot;)) {
-					string[] namespaces = parserService.GetNamespaceList(&quot;&quot;);
+					string[] namespaces = completionDataService.GetNamespaceList(&quot;&quot;);
 					AddResolveResults(new ResolveResult(namespaces));
 				}
 			} else {

Modified: branches/MonoDevelop-generate-what/src/Main/Base/ChangeLog
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/ChangeLog	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/ChangeLog	2004-04-29 13:21:50 UTC (rev 1547)
@@ -1,3 +1,18 @@
+2004-04-29  Iain McCoy  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">iain at mccoy.id.au</A>&gt;
+	* Makefile.am
+	* Services/ParserService/ICompletionDataService.cs:
+	* Services/ParserService/IParserService.cs:
+	* Services/ParserService/DatabaseBackedCompletionDataService.cs:
+	* Services/ParserService/DefaultParserService.cs: Factor the
+	completion database reading bits out of DefaultParserService
+
+	* Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs:
+	* Commands/AutostartCommands.cs:
+	* Gui/CompletionDatabaseWizard/CreateDBGenerator.cs:
+	* Internal/Parser/Implementations/AbstractClass.cs:
+	* Internal/Parser/Implementations/AbstractUsing.cs:
+	* Internal/Parser/IParser.cs: update everything to reflect refactoring
+
 2004-04-28  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
 
 	* Internal/Project/Project/AbstractProject.cs: For now, dont ask

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Commands/AutostartCommands.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Commands/AutostartCommands.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Commands/AutostartCommands.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -60,7 +60,7 @@
 			if (!File.Exists (codeCompletionProxyFile)) {
 				generatingCompletionData = true;
 				RunWizard();
-				DefaultParserService parserService = (DefaultParserService)ServiceManager.Services.GetService(typeof(IParserService));
+				DatabaseBackedCompletionDataService parserService = (DatabaseBackedCompletionDataService)ServiceManager.Services.GetService(typeof(ICompletionDataService));
 				parserService.LoadProxyDataFile();
 			}
 		}

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Commands/ProjectBrowserCommands/ReferenceFolderNodeCommands.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -37,7 +37,7 @@
 			
 			if (node != null) {
 				IProject project = ((ProjectBrowserNode)node.Parent).Project;
-				IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+				ICompletionDataService completionDataService = (ICompletionDataService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(ICompletionDataService));
 				
 				SelectReferenceDialog selDialog = new SelectReferenceDialog(project);
 				if (selDialog.Run() == (int)Gtk.ResponseType.Ok) {
@@ -45,7 +45,7 @@
 					project.ProjectReferences.Clear ();
 					foreach (ProjectReference refInfo in selDialog.ReferenceInformations) {
 						project.ProjectReferences.Add(refInfo);
-						parserService.AddReferenceToCompletionLookup(project, refInfo);
+						completionDataService.AddReferenceToCompletionLookup(project, refInfo);
 					}
 					
 					DefaultDotNetNodeBuilder.InitializeReferences(node, project);
@@ -67,11 +67,11 @@
 			ReferenceNode   node    = browser.SelectedNode as ReferenceNode;
 			if (node != null) {				
 				IProject project = node.Project;  //((ProjectBrowserNode)node.Parent.Parent).Project;
-				IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+				ICompletionDataService completionDataService = (ICompletionDataService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(ICompletionDataService));
 				
 				ProjectReference refInfo = (ProjectWebReference)node.UserData;
 				WebReference.GenerateWebProxy(project, refInfo.HRef);				
-				parserService.AddReferenceToCompletionLookup(project, refInfo);							
+				completionDataService.AddReferenceToCompletionLookup(project, refInfo);							
 			}
 		}
 	}*/
@@ -89,7 +89,7 @@
 				IProject project = ((ProjectBrowserNode)node.Parent).Project;
 				FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
 				IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
-				IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));					
+				ICompletionDataService completionDataService = (ICompletionDataService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(ICompletionDataService));					
 			
 /*				using (AddWebReferenceDialog refDialog = new AddWebReferenceDialog(project)) {
 					if (refDialog.ShowDialog() == DialogResult.OK) {						
@@ -98,7 +98,7 @@
 								ProjectReference refInfo = (ProjectReference)objReference;
 								project.ProjectReferences.Add(refInfo);
 								if(refInfo.ReferenceType == ReferenceType.Assembly) {
-									parserService.AddReferenceToCompletionLookup(project, refInfo);
+									completionDataService.AddReferenceToCompletionLookup(project, refInfo);
 									bInitReferences = true;
 								}
 							} else if(objReference is ProjectFile) {
@@ -118,7 +118,7 @@
 								
 								// add to code completion
 								if(projectFile.Subtype == Subtype.Code ) {
-									parserService.ParseFile(projectFile.Name);
+									completionDataService.ParseFile(projectFile.Name);
 								}
 								
 							}							

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Gui/CompletionDatabaseWizard/CreateDBGenerator.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Gui/CompletionDatabaseWizard/CreateDBGenerator.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Gui/CompletionDatabaseWizard/CreateDBGenerator.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -18,11 +18,11 @@
 		public void Generate(IProgressMonitor progress)
 		{
 			string path = this.CreateCodeCompletionDir();
-			DefaultParserService parserService  = (DefaultParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(DefaultParserService));
+			DatabaseBackedCompletionDataService dataService  = (DatabaseBackedCompletionDataService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(DatabaseBackedCompletionDataService));
 			if (Fast) {
-				parserService.GenerateCodeCompletionDatabase (path, progress);
+				dataService.GenerateCodeCompletionDatabase (path, progress);
 			} else {
-				parserService.GenerateCodeCompletionDatabase (path, progress);
+				dataService.GenerateCodeCompletionDatabase (path, progress);
 			}
 		}
 	}

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/IParser.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/IParser.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/IParser.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -131,14 +131,15 @@
 		/// The caretLineNumber and caretColumn is 1 based.
 		/// &lt;/summary&gt;
 		ResolveResult Resolve(IParserService parserService, 
+		                      ICompletionDataService completionDataService, 
 		                      string expression, 
 		                      int caretLineNumber, 
 		                      int caretColumn, 
 		                      string fileName,
 		                      string fileContent);
 
-		ArrayList IsAsResolve (IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+		ArrayList IsAsResolve (IParserService parserService, ICompletionDataService completionDataService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
 		
-		ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName);
+		ArrayList CtrlSpace(IParserService parserService, ICompletionDataService completionDataService, int caretLine, int caretColumn, string fileName);
 	}
 }

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/Implementations/AbstractClass.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/Implementations/AbstractClass.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/Implementations/AbstractClass.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -169,7 +169,7 @@
 
 		public class ClassInheritanceEnumerator : IEnumerator, IEnumerable
 		{
-			static IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+			static ICompletionDataService completionDataService = (ICompletionDataService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(ICompletionDataService));
 			IClass topLevelClass;
 			IClass currentClass  = null;
 			Queue  baseTypeQueue = new Queue();
@@ -212,7 +212,7 @@
 				}
 				string baseTypeName = baseTypeQueue.Dequeue().ToString();
 
-				IClass baseType = parserService.GetClass(baseTypeName);
+				IClass baseType = completionDataService.GetClass(baseTypeName);
 				if (baseType == null) {
 					ICompilationUnit unit = currentClass == null ? null : currentClass.CompilationUnit;
 					if (unit != null) {

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/Implementations/AbstractUsing.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/Implementations/AbstractUsing.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Internal/Parser/Implementations/AbstractUsing.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -38,7 +38,7 @@
 			}
 		}
 		
-		static IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+		static ICompletionDataService completionDataService = (ICompletionDataService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(ICompletionDataService));
 		public string SearchNamespace(string partitialNamespaceName)
 		{
 			return SearchNamespace(partitialNamespaceName, true);
@@ -47,7 +47,7 @@
 		public string SearchNamespace(string partitialNamespaceName, bool caseSensitive)
 		{
 //			Console.WriteLine(&quot;SearchNamespace : &gt;{0}&lt;&quot;, partitialNamespaceName);
-			if (parserService.NamespaceExists(partitialNamespaceName, caseSensitive)) {
+			if (completionDataService.NamespaceExists(partitialNamespaceName, caseSensitive)) {
 				return partitialNamespaceName;
 			}
 			
@@ -55,7 +55,7 @@
 			string declaringNamespace = (string)aliases[&quot;&quot;];
 			if (declaringNamespace != null) {
 				while (declaringNamespace.Length &gt; 0) {
-					if ((caseSensitive ? declaringNamespace.EndsWith(partitialNamespaceName) : declaringNamespace.ToLower().EndsWith(partitialNamespaceName.ToLower()) ) &amp;&amp; parserService.NamespaceExists(declaringNamespace, caseSensitive)) {
+					if ((caseSensitive ? declaringNamespace.EndsWith(partitialNamespaceName) : declaringNamespace.ToLower().EndsWith(partitialNamespaceName.ToLower()) ) &amp;&amp; completionDataService.NamespaceExists(declaringNamespace, caseSensitive)) {
 						return declaringNamespace;
 					}
 					int index = declaringNamespace.IndexOf('.');
@@ -75,7 +75,7 @@
 				if (caseSensitive ? partitialNamespaceName.StartsWith(aliasString) : partitialNamespaceName.ToLower().StartsWith(aliasString.ToLower())) {
 					if (aliasString.Length &gt;= 0) {
 						string nsName = nsName = String.Concat(entry.Value.ToString(), partitialNamespaceName.Remove(0, aliasString.Length));
-						if (parserService.NamespaceExists(nsName, caseSensitive)) {
+						if (completionDataService.NamespaceExists(nsName, caseSensitive)) {
 							return nsName;
 						}
 					}
@@ -92,7 +92,7 @@
 		public IClass SearchType(string partitialTypeName, bool caseSensitive)
 		{
 //			Console.WriteLine(&quot;Search type : &gt;{0}&lt;&quot;, partitialTypeName);
-			IClass c = parserService.GetClass(partitialTypeName, caseSensitive);
+			IClass c = completionDataService.GetClass(partitialTypeName, caseSensitive);
 			if (c != null) {
 				return c;
 			}
@@ -100,7 +100,7 @@
 			foreach (string str in usings) {
 				string possibleType = String.Concat(str, &quot;.&quot;, partitialTypeName);
 //				Console.WriteLine(&quot;looking for &quot; + possibleType);
-				c = parserService.GetClass(possibleType, caseSensitive);
+				c = completionDataService.GetClass(possibleType, caseSensitive);
 				if (c != null) {
 //					Console.WriteLine(&quot;Found!&quot;);
 					return c;
@@ -113,7 +113,7 @@
 				while (declaringNamespace.Length &gt; 0) {
 					string className = String.Concat(declaringNamespace, &quot;.&quot;, partitialTypeName);
 //					Console.WriteLine(&quot;looking for &quot; + className);
-					c = parserService.GetClass(className, caseSensitive);
+					c = completionDataService.GetClass(className, caseSensitive);
 					if (c != null) {
 //						Console.WriteLine(&quot;Found!&quot;);
 						return c;
@@ -134,7 +134,7 @@
 					if (aliasString.Length &gt; 0) {
 						className = String.Concat(entry.Value.ToString(), partitialTypeName.Remove(0, aliasString.Length));
 //						Console.WriteLine(&quot;looking for &quot; + className);
-						c = parserService.GetClass(className, caseSensitive);
+						c = completionDataService.GetClass(className, caseSensitive);
 						if (c != null) {
 //							Console.WriteLine(&quot;Found!&quot;);
 							return c;

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Makefile.am
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Makefile.am	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Makefile.am	2004-04-29 13:21:50 UTC (rev 1547)
@@ -208,8 +208,10 @@
 ./Services/ClassBrowserIcons/ClassBrowserIconsService.cs \
 ./Services/ResourceNotFoundException.cs \
 ./Services/ParserService/DefaultParserService.cs \
+./Services/ParserService/IParserService.cs \
+./Services/ParserService/DatabaseBackedCompletionDataService.cs \
+./Services/ParserService/ICompletionDataService.cs \
 ./Services/ParserService/ClassProxyCollection.cs \
-./Services/ParserService/IParserService.cs \
 ./Services/ParserService/ClassProxy.cs \
 ./Services/ParserService/AssemblyInformation.cs \
 ./Services/ParserService/ParseInformation.cs \

Added: branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DatabaseBackedCompletionDataService.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DatabaseBackedCompletionDataService.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DatabaseBackedCompletionDataService.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -0,0 +1,445 @@
+using System;
+using System.IO;
+using System.Threading;
+using System.Collections;
+using System.Collections.Utility;
+using System.Diagnostics;
+using System.Reflection;
+using System.Runtime.Serialization;
+using System.Runtime.Serialization.Formatters;
+using System.Runtime.Serialization.Formatters.Binary;
+using System.Security;
+using System.Security.Permissions;
+using System.Security.Policy;
+using System.Xml;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Services
+{
+	class DatabaseBackedCompletionDataService : AbstractService, ICompletionDataService
+	{
+		Hashtable classes                = new Hashtable();
+		Hashtable caseInsensitiveClasses = new Hashtable();
+	
+		/// &lt;remarks&gt;
+		/// The keys are the assemblies loaded. This hash table ensures that no
+		/// assembly is loaded twice. I know that strong naming might be better but
+		/// the use case isn't there. No one references 2 differnt files if he references
+		/// the same assembly.
+		/// &lt;/remarks&gt;
+		Hashtable loadedAssemblies = new Hashtable();
+
+		// used to map 'real' namespace hashtable inside case insensitive hashtable
+		const string CaseInsensitiveKey = &quot;__CASE_INSENSITIVE_HASH&quot;;
+		Hashtable caseInsensitiveNamespaces = new Hashtable();
+		Hashtable namespaces                = new Hashtable();
+		
+		ClassProxyCollection classProxies = new ClassProxyCollection();
+		readonly static string[] assemblyList = {
+			&quot;Microsoft.VisualBasic&quot;,
+			//&quot;Microsoft.JScript&quot;,
+			&quot;mscorlib&quot;,
+			&quot;System.Data&quot;,
+			&quot;System.Design&quot;,
+			&quot;System.DirectoryServices&quot;,
+			&quot;System.Drawing.Design&quot;,
+			&quot;System.Drawing&quot;,
+			&quot;System.EnterpriseServices&quot;,
+			&quot;System.Management&quot;,
+			&quot;System.Messaging&quot;,
+			&quot;System.Runtime.Remoting&quot;,
+			&quot;System.Runtime.Serialization.Formatters.Soap&quot;,
+
+			&quot;System.Security&quot;,
+			&quot;System.ServiceProcess&quot;,
+			&quot;System.Web.Services&quot;,
+			&quot;System.Web&quot;,
+			//&quot;System.Windows.Forms&quot;,
+			&quot;System&quot;,
+			&quot;System.Xml&quot;,
+			&quot;glib-sharp&quot;,
+			&quot;atk-sharp&quot;,
+			&quot;pango-sharp&quot;,
+			&quot;gdk-sharp&quot;,
+			&quot;gtk-sharp&quot;,
+			&quot;gnome-sharp&quot;,
+			&quot;gconf-sharp&quot;,
+			&quot;gtkhtml-sharp&quot;,
+		};
+
+		public static string[] AssemblyList {
+			get {
+				return assemblyList;
+			}
+		}
+
+
+		/// &lt;remarks&gt;
+		/// The initialize method writes the location of the code completion proxy
+		/// file to this string.
+		/// &lt;/remarks&gt;
+		string codeCompletionProxyFile;
+		string codeCompletionMainFile;
+
+		public void SetClasses(Hashtable classes, Hashtable caseInsensitiveClasses) {
+			this.classes = classes;
+			this.caseInsensitiveClasses = caseInsensitiveClasses;
+		}
+		
+		private bool ContinueWithProcess(IProgressMonitor progressMonitor)
+		{
+			while (Gtk.Application.EventsPending ())
+				Gtk.Application.RunIteration ();
+			if (progressMonitor.Canceled)
+				return false;
+			else
+				return true;
+		}
+	
+		public void GenerateCodeCompletionDatabase(string createPath, IProgressMonitor progressMonitor)
+		{
+			SetCodeCompletionFileLocation(createPath);
+
+			// write all classes and proxies to the disc
+			BinaryWriter classWriter = new BinaryWriter(new BufferedStream(new FileStream(codeCompletionMainFile, FileMode.Create, FileAccess.Write, FileShare.None)));
+			BinaryWriter proxyWriter = new BinaryWriter(new BufferedStream(new FileStream(codeCompletionProxyFile, FileMode.Create, FileAccess.Write, FileShare.None)));
+			if (progressMonitor != null) {
+				progressMonitor.BeginTask(GettextCatalog.GetString (&quot;Generate code completion database&quot;), assemblyList.Length);
+			}
+			
+			// convert all assemblies
+			for (int i = 0; i &lt; assemblyList.Length; ++i) {
+				try {
+					FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+					string path = fileUtilityService.GetDirectoryNameWithSeparator(System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory());
+
+					AssemblyInformation frameworkAssemblyInformation = new AssemblyInformation();
+					frameworkAssemblyInformation.Load(String.Concat(path, assemblyList[i], &quot;.dll&quot;), false);
+					// create all class proxies
+					foreach (IClass newClass in frameworkAssemblyInformation.Classes) {
+						ClassProxy newProxy = new ClassProxy(newClass);
+						classProxies.Add(newProxy);
+						AddClassToNamespaceList(newProxy);
+
+						PersistentClass pc = new PersistentClass(classProxies, newClass);
+						newProxy.Offset = (uint)classWriter.BaseStream.Position;
+						newProxy.WriteTo(proxyWriter);
+						pc.WriteTo(classWriter);
+					}
+					
+					if (progressMonitor != null) {
+						progressMonitor.Worked(i, GettextCatalog.GetString (&quot;Writing class&quot;));
+					}
+					if (!ContinueWithProcess(progressMonitor))
+						return;
+				} catch (Exception e) {
+					Console.WriteLine(e.ToString());
+				}
+				System.GC.Collect();
+			}
+
+			classWriter.Close();
+			proxyWriter.Close();
+			if (progressMonitor != null) {
+				progressMonitor.Done();
+			}
+		}
+		
+		void SetCodeCompletionFileLocation(string path)
+		{
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+			string codeCompletionTemp = fileUtilityService.GetDirectoryNameWithSeparator(path);
+
+			codeCompletionProxyFile = codeCompletionTemp + &quot;CodeCompletionProxyDataV02.bin&quot;;
+			codeCompletionMainFile  = codeCompletionTemp + &quot;CodeCompletionMainDataV02.bin&quot;;
+		}
+
+		void SetDefaultCompletionFileLocation()
+		{
+			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+			SetCodeCompletionFileLocation(propertyService.GetProperty(&quot;SharpDevelop.CodeCompletion.DataDirectory&quot;, String.Empty).ToString());
+		}
+
+		public void LoadProxyDataFile()
+		{
+			if (!File.Exists(codeCompletionProxyFile)) {
+				return;
+			}
+			BinaryReader reader = new BinaryReader(new BufferedStream(new FileStream(codeCompletionProxyFile, FileMode.Open, FileAccess.Read, FileShare.Read)));
+			while (true) {
+				try {
+					ClassProxy newProxy = new ClassProxy(reader);
+					classProxies.Add(newProxy);
+					AddClassToNamespaceList(newProxy);
+				} catch (Exception) {
+					break;
+				}
+			}
+			reader.Close();
+		}
+
+		void LoadThread()
+		{
+			SetDefaultCompletionFileLocation();
+			
+			BinaryFormatter formatter = new BinaryFormatter();
+			
+			if (File.Exists(codeCompletionProxyFile)) {
+				LoadProxyDataFile();
+			}
+		}
+		
+		public override void InitializeService()
+		{
+			Thread myThread = new Thread(new ThreadStart(LoadThread));
+			myThread.IsBackground = true;
+			myThread.Priority = ThreadPriority.Lowest;
+			myThread.Start();
+			
+			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			projectService.CombineOpened += new CombineEventHandler(OpenCombine);
+		}
+
+		public void AddReferenceToCompletionLookup(IProject project, ProjectReference reference)
+		{
+			if (reference.ReferenceType != ReferenceType.Project) {
+				string fileName = reference.GetReferencedFileName(project);
+				if (fileName == null || fileName.Length == 0) {
+					return;
+				}
+				foreach (string assemblyName in assemblyList) {
+					if (Path.GetFileNameWithoutExtension(fileName).ToUpper() == assemblyName.ToUpper()) {
+						return;
+					}
+				}
+				// HACK : Don't load references for non C# projects
+				if (project.ProjectType != &quot;C#&quot;) {
+					return;
+				}
+				if (File.Exists(fileName)) {
+					Thread t = new Thread(new ThreadStart(new AssemblyLoader(this, fileName).LoadAssemblyParseInformations));
+					t.Start();
+				}
+			}
+		}
+		
+		class AssemblyLoader
+		{
+			DatabaseBackedCompletionDataService completionDataService;
+			string assemblyFileName;
+			
+			public AssemblyLoader(DatabaseBackedCompletionDataService completionDataService, string assemblyFileName)
+			{
+				this.completionDataService    = completionDataService;
+				this.assemblyFileName = assemblyFileName;
+			}
+			
+			public void LoadAssemblyParseInformations()
+			{
+				if (completionDataService.loadedAssemblies[assemblyFileName] != null) {
+					return;
+				}
+				completionDataService.loadedAssemblies[assemblyFileName] = true;
+				try {
+					AssemblyInformation assemblyInformation = new AssemblyInformation();
+					assemblyInformation.Load(assemblyFileName, true);
+					foreach (IClass newClass in assemblyInformation.Classes) {
+						completionDataService.AddClassToNamespaceList(newClass);
+						lock (completionDataService.classes) {
+							completionDataService.caseInsensitiveClasses[newClass.FullyQualifiedName.ToLower()] = completionDataService.classes[newClass.FullyQualifiedName] = new ClasstableEntry(null, null, newClass);
+						}
+					}
+				} catch (Exception e) {
+					Console.WriteLine(&quot;Can't add reference : &quot; + e.ToString());
+				}
+			}
+		}
+		
+		public void OpenCombine(object sender, CombineEventArgs e)
+		{
+			ArrayList projects =  Combine.GetAllProjects(e.Combine);
+			foreach (ProjectCombineEntry entry in projects) {
+				foreach (ProjectReference r in entry.Project.ProjectReferences) {
+					AddReferenceToCompletionLookup(entry.Project, r);
+				}
+			}
+		}
+		
+	
+		public Hashtable AddClassToNamespaceList(IClass addClass)
+		{
+			string nSpace = addClass.Namespace;
+			if (nSpace == null) {
+				nSpace = String.Empty;
+			}
+			
+			string[] path = nSpace.Split('.');
+			
+			lock (namespaces) {
+				Hashtable cur                = namespaces;
+				Hashtable caseInsensitiveCur = caseInsensitiveNamespaces;
+				
+				for (int i = 0; i &lt; path.Length; ++i) {
+					if (cur[path[i]] == null) {
+						Hashtable hashTable                = new Hashtable();
+						Hashtable caseInsensitivehashTable = new Hashtable();
+						cur[path[i]] = hashTable;
+						caseInsensitiveCur[path[i].ToLower()] = caseInsensitivehashTable;
+						caseInsensitivehashTable[CaseInsensitiveKey] = hashTable;
+					} else {
+						if (!(cur[path[i]] is Hashtable)) {
+							return null;
+						}
+					}
+					cur = (Hashtable)cur[path[i]];
+					caseInsensitiveCur = (Hashtable)caseInsensitiveCur[path[i].ToLower()];
+				}
+				caseInsensitiveCur[addClass.Name.ToLower()] = cur[addClass.Name] = addClass;
+				return cur;
+			}
+		}
+
+		public IClass GetClass(string typeName)
+		{
+			return GetClass(typeName, true);
+		}
+		public IClass GetClass(string typeName, bool caseSensitive)
+		{
+			if (!caseSensitive) {
+				typeName = typeName.ToLower();
+			}
+			
+			ClasstableEntry entry = (caseSensitive ? classes[typeName] : caseInsensitiveClasses[typeName]) as ClasstableEntry;
+			if (entry != null) {
+				return entry.Class;
+			}
+			
+			// try to load the class from our data file
+			int idx = classProxies.IndexOf(typeName, caseSensitive);
+			if (idx &gt; 0) {
+				BinaryReader reader = new BinaryReader(new BufferedStream(new FileStream(codeCompletionMainFile, FileMode.Open, FileAccess.Read, FileShare.Read)));
+				reader.BaseStream.Seek(classProxies[idx].Offset, SeekOrigin.Begin);
+				IClass c = new PersistentClass(reader, classProxies);
+				reader.Close();
+				lock (classes) {
+					caseInsensitiveClasses[typeName.ToLower()] = classes[typeName] = new ClasstableEntry(null, null, c);
+				}
+				return c;
+			}
+			return null;
+		}
+		
+		public string[] GetNamespaceList(string subNameSpace)
+		{
+			return GetNamespaceList(subNameSpace, true);
+		}
+		public string[] GetNamespaceList(string subNameSpace, bool caseSensitive)
+		{
+//			Console.WriteLine(&quot;GetNamespaceList &gt;{0}&lt;&quot;, subNameSpace);
+			
+			System.Diagnostics.Debug.Assert(subNameSpace != null);
+			if (!caseSensitive) {
+				subNameSpace = subNameSpace.ToLower();
+			}
+			
+			string[] path = subNameSpace.Split('.');
+			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
+			
+			if (subNameSpace.Length &gt; 0) {
+				for (int i = 0; i &lt; path.Length; ++i) {
+					if (!(cur[path[i]] is Hashtable)) {
+						return null;
+					}
+					cur = (Hashtable)cur[path[i]];
+				}
+			}
+			
+			if (!caseSensitive) {
+				cur = (Hashtable)cur[CaseInsensitiveKey];
+			}
+			
+			ArrayList namespaceList = new ArrayList();
+			foreach (DictionaryEntry entry in cur) {
+				if (entry.Value is Hashtable &amp;&amp; entry.Key.ToString().Length &gt; 0) {
+					namespaceList.Add(entry.Key);
+				}
+			}
+			
+			return (string[])namespaceList.ToArray(typeof(string));
+		}
+		
+		public ArrayList GetNamespaceContents(string subNameSpace)
+		{
+			return GetNamespaceContents(subNameSpace, true);
+		}
+		public ArrayList GetNamespaceContents(string subNameSpace, bool caseSensitive)
+		{
+//			Console.WriteLine(&quot;GetNamespaceContents &gt;{0}&lt;&quot;, subNameSpace);
+			
+			ArrayList namespaceList = new ArrayList();
+			if (subNameSpace == null) {
+				return namespaceList;
+			}
+			if (!caseSensitive) {
+				subNameSpace = subNameSpace.ToLower();
+			}
+			
+			string[] path = subNameSpace.Split('.');
+			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
+			
+			for (int i = 0; i &lt; path.Length; ++i) {
+				if (!(cur[path[i]] is Hashtable)) {
+					return namespaceList;
+				}
+				cur = (Hashtable)cur[path[i]];
+			}
+			
+			if (!caseSensitive) {
+				cur = (Hashtable)cur[CaseInsensitiveKey];
+			}
+			
+			foreach (DictionaryEntry entry in cur)  {
+				if (entry.Value is Hashtable) {
+					namespaceList.Add(entry.Key);
+				} else {
+					namespaceList.Add(entry.Value);
+				}
+			}
+			return namespaceList;
+		}
+		
+		public bool NamespaceExists(string name)
+		{
+			return NamespaceExists(name, true);
+		}
+		public bool NamespaceExists(string name, bool caseSensitive)
+		{
+//			Console.WriteLine(&quot;NamespaceExists &gt;{0}&lt;&quot;, name);
+			if (name == null) {
+				return false;
+			}
+			if (!caseSensitive) {
+				name = name.ToLower();
+			}
+			string[] path = name.Split('.');
+			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
+			
+			for (int i = 0; i &lt; path.Length; ++i) {
+				if (!(cur[path[i]] is Hashtable)) {
+					return false;
+				}
+				cur = (Hashtable)cur[path[i]];
+			}
+			return true;
+		}
+
+
+	}
+}

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -32,298 +32,39 @@
 {
 	public class DefaultParserService : AbstractService, IParserService
 	{
-		Hashtable classes                = new Hashtable();
-		Hashtable caseInsensitiveClasses = new Hashtable();
-		
-		// used to map 'real' namespace hashtable inside case insensitive hashtable
-		const string CaseInsensitiveKey = &quot;__CASE_INSENSITIVE_HASH&quot;;
-		Hashtable namespaces                = new Hashtable();
-		Hashtable caseInsensitiveNamespaces = new Hashtable();
-		
+		internal Hashtable classes                = new Hashtable();
+		internal Hashtable caseInsensitiveClasses = new Hashtable();
+	
 		Hashtable parsings   = new Hashtable();
 		
 		ParseInformation addedParseInformation = new ParseInformation();
 		ParseInformation removedParseInformation = new ParseInformation();
 
+		IParser[] parser;
+
 //// Alex: this one keeps requests for parsing and is used to start parser (pulsed)
 //// otherwise continuous reparsing of files is causing leaks
 //		public static Queue ParserPulse=new Queue();	// required for monitoring when to restart thread
 //// Alex: end of mod
 
-		/// &lt;remarks&gt;
-		/// The keys are the assemblies loaded. This hash table ensures that no
-		/// assembly is loaded twice. I know that strong naming might be better but
-		/// the use case isn't there. No one references 2 differnt files if he references
-		/// the same assembly.
-		/// &lt;/remarks&gt;
-		Hashtable loadedAssemblies = new Hashtable();
-		
-		ClassProxyCollection classProxies = new ClassProxyCollection();
-		IParser[] parser;
-		readonly static string[] assemblyList = {
-			&quot;Microsoft.VisualBasic&quot;,
-			//&quot;Microsoft.JScript&quot;,
-			&quot;mscorlib&quot;,
-			&quot;System.Data&quot;,
-			&quot;System.Design&quot;,
-			&quot;System.DirectoryServices&quot;,
-			&quot;System.Drawing.Design&quot;,
-			&quot;System.Drawing&quot;,
-			&quot;System.EnterpriseServices&quot;,
-			&quot;System.Management&quot;,
-			&quot;System.Messaging&quot;,
-			&quot;System.Runtime.Remoting&quot;,
-			&quot;System.Runtime.Serialization.Formatters.Soap&quot;,
+		ICompletionDataService completionDataService;
 
-			&quot;System.Security&quot;,
-			&quot;System.ServiceProcess&quot;,
-			&quot;System.Web.Services&quot;,
-			&quot;System.Web&quot;,
-			//&quot;System.Windows.Forms&quot;,
-			&quot;System&quot;,
-			&quot;System.Xml&quot;,
-			&quot;glib-sharp&quot;,
-			&quot;atk-sharp&quot;,
-			&quot;pango-sharp&quot;,
-			&quot;gdk-sharp&quot;,
-			&quot;gtk-sharp&quot;,
-			&quot;gnome-sharp&quot;,
-			&quot;gconf-sharp&quot;,
-			&quot;gtkhtml-sharp&quot;,
-		};
 		
 		public DefaultParserService()
 		{
 			addedParseInformation.DirtyCompilationUnit = new DummyCompilationUnit();
 			removedParseInformation.DirtyCompilationUnit = new DummyCompilationUnit();
 		}
-		
-		public static string[] AssemblyList {
-			get {
-				return assemblyList;
-			}
-		}
 
-		/// &lt;remarks&gt;
-		/// The initialize method writes the location of the code completion proxy
-		/// file to this string.
-		/// &lt;/remarks&gt;
-		string codeCompletionProxyFile;
-		string codeCompletionMainFile;
-
-		class ClasstableEntry
-		{
-			IClass           myClass;
-			ICompilationUnit myCompilationUnit;
-			string           myFileName;
-
-			public IClass Class {
-				get {
-					return myClass;
-				}
-			}
-
-			public ICompilationUnit CompilationUnit {
-				get {
-					return myCompilationUnit;
-				}
-			}
-
-			public string FileName {
-				get {
-					return myFileName;
-				}
-			}
-
-			public ClasstableEntry(string fileName, ICompilationUnit compilationUnit, IClass c)
-			{
-				this.myCompilationUnit = compilationUnit;
-				this.myFileName        = fileName;
-				this.myClass           = c;
-			}
-		}
-
-		private bool ContinueWithProcess(IProgressMonitor progressMonitor)
-		{
-			while (Gtk.Application.EventsPending ())
-				Gtk.Application.RunIteration ();
-			if (progressMonitor.Canceled)
-				return false;
-			else
-				return true;
-		}
-	
-		public void GenerateCodeCompletionDatabase(string createPath, IProgressMonitor progressMonitor)
-		{
-			SetCodeCompletionFileLocation(createPath);
-
-			// write all classes and proxies to the disc
-			BinaryWriter classWriter = new BinaryWriter(new BufferedStream(new FileStream(codeCompletionMainFile, FileMode.Create, FileAccess.Write, FileShare.None)));
-			BinaryWriter proxyWriter = new BinaryWriter(new BufferedStream(new FileStream(codeCompletionProxyFile, FileMode.Create, FileAccess.Write, FileShare.None)));
-			if (progressMonitor != null) {
-				progressMonitor.BeginTask(GettextCatalog.GetString (&quot;Generate code completion database&quot;), assemblyList.Length);
-			}
-			
-			// convert all assemblies
-			for (int i = 0; i &lt; assemblyList.Length; ++i) {
-				try {
-					FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-					string path = fileUtilityService.GetDirectoryNameWithSeparator(System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory());
-
-					AssemblyInformation frameworkAssemblyInformation = new AssemblyInformation();
-					frameworkAssemblyInformation.Load(String.Concat(path, assemblyList[i], &quot;.dll&quot;), false);
-					// create all class proxies
-					foreach (IClass newClass in frameworkAssemblyInformation.Classes) {
-						ClassProxy newProxy = new ClassProxy(newClass);
-						classProxies.Add(newProxy);
-						AddClassToNamespaceList(newProxy);
-
-						PersistentClass pc = new PersistentClass(classProxies, newClass);
-						newProxy.Offset = (uint)classWriter.BaseStream.Position;
-						newProxy.WriteTo(proxyWriter);
-						pc.WriteTo(classWriter);
-					}
-					
-					if (progressMonitor != null) {
-						progressMonitor.Worked(i, GettextCatalog.GetString (&quot;Writing class&quot;));
-					}
-					if (!ContinueWithProcess(progressMonitor))
-						return;
-				} catch (Exception e) {
-					Console.WriteLine(e.ToString());
-				}
-				System.GC.Collect();
-			}
-
-			classWriter.Close();
-			proxyWriter.Close();
-			if (progressMonitor != null) {
-				progressMonitor.Done();
-			}
-		}
-		
-		void SetCodeCompletionFileLocation(string path)
-		{
-			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-			string codeCompletionTemp = fileUtilityService.GetDirectoryNameWithSeparator(path);
-
-			codeCompletionProxyFile = codeCompletionTemp + &quot;CodeCompletionProxyDataV02.bin&quot;;
-			codeCompletionMainFile  = codeCompletionTemp + &quot;CodeCompletionMainDataV02.bin&quot;;
-		}
-
-		void SetDefaultCompletionFileLocation()
-		{
-			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
-			SetCodeCompletionFileLocation(propertyService.GetProperty(&quot;SharpDevelop.CodeCompletion.DataDirectory&quot;, String.Empty).ToString());
-		}
-
-		public void LoadProxyDataFile()
-		{
-			if (!File.Exists(codeCompletionProxyFile)) {
-				return;
-			}
-			BinaryReader reader = new BinaryReader(new BufferedStream(new FileStream(codeCompletionProxyFile, FileMode.Open, FileAccess.Read, FileShare.Read)));
-			while (true) {
-				try {
-					ClassProxy newProxy = new ClassProxy(reader);
-					classProxies.Add(newProxy);
-					AddClassToNamespaceList(newProxy);
-				} catch (Exception) {
-					break;
-				}
-			}
-			reader.Close();
-		}
-		
-		void LoadThread()
-		{
-			SetDefaultCompletionFileLocation();
-			
-			BinaryFormatter formatter = new BinaryFormatter();
-			
-			if (File.Exists(codeCompletionProxyFile)) {
-				LoadProxyDataFile();
-			}
-		}
-		
 		public override void InitializeService()
 		{
 			parser = (IParser[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/Workspace/Parser&quot;).BuildChildItems(this)).ToArray(typeof(IParser));
 			
-			Thread myThread = new Thread(new ThreadStart(LoadThread));
-			myThread.IsBackground = true;
-			myThread.Priority = ThreadPriority.Lowest;
-			myThread.Start();
-			
-			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
-			projectService.CombineOpened += new CombineEventHandler(OpenCombine);
+			completionDataService = (ICompletionDataService)ServiceManager.Services.GetService (typeof (ICompletionDataService));
+			completionDataService.SetClasses(classes, caseInsensitiveClasses);
 		}
+
 		
-		public void AddReferenceToCompletionLookup(IProject project, ProjectReference reference)
-		{
-			if (reference.ReferenceType != ReferenceType.Project) {
-				string fileName = reference.GetReferencedFileName(project);
-				if (fileName == null || fileName.Length == 0) {
-					return;
-				}
-				foreach (string assemblyName in assemblyList) {
-					if (Path.GetFileNameWithoutExtension(fileName).ToUpper() == assemblyName.ToUpper()) {
-						return;
-					}
-				}
-				// HACK : Don't load references for non C# projects
-				if (project.ProjectType != &quot;C#&quot;) {
-					return;
-				}
-				if (File.Exists(fileName)) {
-					Thread t = new Thread(new ThreadStart(new AssemblyLoader(this, fileName).LoadAssemblyParseInformations));
-					t.Start();
-				}
-			}
-		}
-		
-		class AssemblyLoader
-		{
-			DefaultParserService parserService;
-			string assemblyFileName;
-			
-			public AssemblyLoader(DefaultParserService parserService, string assemblyFileName)
-			{
-				this.parserService    = parserService;
-				this.assemblyFileName = assemblyFileName;
-			}
-			
-			public void LoadAssemblyParseInformations()
-			{
-				if (parserService.loadedAssemblies[assemblyFileName] != null) {
-					return;
-				}
-				parserService.loadedAssemblies[assemblyFileName] = true;
-				try {
-					AssemblyInformation assemblyInformation = new AssemblyInformation();
-					assemblyInformation.Load(assemblyFileName, true);
-					foreach (IClass newClass in assemblyInformation.Classes) {
-						parserService.AddClassToNamespaceList(newClass);
-						lock (parserService.classes) {
-							parserService.caseInsensitiveClasses[newClass.FullyQualifiedName.ToLower()] = parserService.classes[newClass.FullyQualifiedName] = new ClasstableEntry(null, null, newClass);
-						}
-					}
-				} catch (Exception e) {
-					Console.WriteLine(&quot;Can't add reference : &quot; + e.ToString());
-				}
-			}
-		}
-		
-		public void OpenCombine(object sender, CombineEventArgs e)
-		{
-			ArrayList projects =  Combine.GetAllProjects(e.Combine);
-			foreach (ProjectCombineEntry entry in projects) {
-				foreach (ProjectReference r in entry.Project.ProjectReferences) {
-					AddReferenceToCompletionLookup(entry.Project, r);
-				}
-			}
-		}
-		
 		public void StartParserThread()
 		{
 			Thread t = new Thread(new ThreadStart(ParserUpdateThread));
@@ -404,174 +145,12 @@
 				System.GC.Collect();
 			}
 		}
+	
+
+
 		
-		Hashtable AddClassToNamespaceList(IClass addClass)
-		{
-			string nSpace = addClass.Namespace;
-			if (nSpace == null) {
-				nSpace = String.Empty;
-			}
-			
-			string[] path = nSpace.Split('.');
-			
-			lock (namespaces) {
-				Hashtable cur                = namespaces;
-				Hashtable caseInsensitiveCur = caseInsensitiveNamespaces;
-				
-				for (int i = 0; i &lt; path.Length; ++i) {
-					if (cur[path[i]] == null) {
-						Hashtable hashTable                = new Hashtable();
-						Hashtable caseInsensitivehashTable = new Hashtable();
-						cur[path[i]] = hashTable;
-						caseInsensitiveCur[path[i].ToLower()] = caseInsensitivehashTable;
-						caseInsensitivehashTable[CaseInsensitiveKey] = hashTable;
-					} else {
-						if (!(cur[path[i]] is Hashtable)) {
-							return null;
-						}
-					}
-					cur = (Hashtable)cur[path[i]];
-					caseInsensitiveCur = (Hashtable)caseInsensitiveCur[path[i].ToLower()];
-				}
-				caseInsensitiveCur[addClass.Name.ToLower()] = cur[addClass.Name] = addClass;
-				return cur;
-			}
-		}
 		
 #region Default Parser Layer dependent functions
-		public IClass GetClass(string typeName)
-		{
-			return GetClass(typeName, true);
-		}
-		public IClass GetClass(string typeName, bool caseSensitive)
-		{
-			if (!caseSensitive) {
-				typeName = typeName.ToLower();
-			}
-			
-			ClasstableEntry entry = (caseSensitive ? classes[typeName] : caseInsensitiveClasses[typeName]) as ClasstableEntry;
-			if (entry != null) {
-				return entry.Class;
-			}
-			
-			// try to load the class from our data file
-			int idx = classProxies.IndexOf(typeName, caseSensitive);
-			if (idx &gt; 0) {
-				BinaryReader reader = new BinaryReader(new BufferedStream(new FileStream(codeCompletionMainFile, FileMode.Open, FileAccess.Read, FileShare.Read)));
-				reader.BaseStream.Seek(classProxies[idx].Offset, SeekOrigin.Begin);
-				IClass c = new PersistentClass(reader, classProxies);
-				reader.Close();
-				lock (classes) {
-					caseInsensitiveClasses[typeName.ToLower()] = classes[typeName] = new ClasstableEntry(null, null, c);
-				}
-				return c;
-			}
-			return null;
-		}
-		
-		public string[] GetNamespaceList(string subNameSpace)
-		{
-			return GetNamespaceList(subNameSpace, true);
-		}
-		public string[] GetNamespaceList(string subNameSpace, bool caseSensitive)
-		{
-//			Console.WriteLine(&quot;GetNamespaceList &gt;{0}&lt;&quot;, subNameSpace);
-			
-			System.Diagnostics.Debug.Assert(subNameSpace != null);
-			if (!caseSensitive) {
-				subNameSpace = subNameSpace.ToLower();
-			}
-			
-			string[] path = subNameSpace.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
-			
-			if (subNameSpace.Length &gt; 0) {
-				for (int i = 0; i &lt; path.Length; ++i) {
-					if (!(cur[path[i]] is Hashtable)) {
-						return null;
-					}
-					cur = (Hashtable)cur[path[i]];
-				}
-			}
-			
-			if (!caseSensitive) {
-				cur = (Hashtable)cur[CaseInsensitiveKey];
-			}
-			
-			ArrayList namespaceList = new ArrayList();
-			foreach (DictionaryEntry entry in cur) {
-				if (entry.Value is Hashtable &amp;&amp; entry.Key.ToString().Length &gt; 0) {
-					namespaceList.Add(entry.Key);
-				}
-			}
-			
-			return (string[])namespaceList.ToArray(typeof(string));
-		}
-		
-		public ArrayList GetNamespaceContents(string subNameSpace)
-		{
-			return GetNamespaceContents(subNameSpace, true);
-		}
-		public ArrayList GetNamespaceContents(string subNameSpace, bool caseSensitive)
-		{
-//			Console.WriteLine(&quot;GetNamespaceContents &gt;{0}&lt;&quot;, subNameSpace);
-			
-			ArrayList namespaceList = new ArrayList();
-			if (subNameSpace == null) {
-				return namespaceList;
-			}
-			if (!caseSensitive) {
-				subNameSpace = subNameSpace.ToLower();
-			}
-			
-			string[] path = subNameSpace.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
-			
-			for (int i = 0; i &lt; path.Length; ++i) {
-				if (!(cur[path[i]] is Hashtable)) {
-					return namespaceList;
-				}
-				cur = (Hashtable)cur[path[i]];
-			}
-			
-			if (!caseSensitive) {
-				cur = (Hashtable)cur[CaseInsensitiveKey];
-			}
-			
-			foreach (DictionaryEntry entry in cur)  {
-				if (entry.Value is Hashtable) {
-					namespaceList.Add(entry.Key);
-				} else {
-					namespaceList.Add(entry.Value);
-				}
-			}
-			return namespaceList;
-		}
-		
-		public bool NamespaceExists(string name)
-		{
-			return NamespaceExists(name, true);
-		}
-		public bool NamespaceExists(string name, bool caseSensitive)
-		{
-//			Console.WriteLine(&quot;NamespaceExists &gt;{0}&lt;&quot;, name);
-			if (name == null) {
-				return false;
-			}
-			if (!caseSensitive) {
-				name = name.ToLower();
-			}
-			string[] path = name.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
-			
-			for (int i = 0; i &lt; path.Length; ++i) {
-				if (!(cur[path[i]] is Hashtable)) {
-					return false;
-				}
-				cur = (Hashtable)cur[path[i]];
-			}
-			return true;
-		}
 #endregion
 		
 		public IParseInformation ParseFile(string fileName)
@@ -641,7 +220,7 @@
 			if (parseInformation.BestCompilationUnit is ICompilationUnit) {
 				ICompilationUnit cu = (ICompilationUnit)parseInformation.BestCompilationUnit;
 				foreach (IClass c in cu.Classes) {
-					AddClassToNamespaceList(c);
+					completionDataService.AddClassToNamespaceList(c);
 					lock (classes) {
 						caseInsensitiveClasses[c.FullyQualifiedName.ToLower()] = classes[c.FullyQualifiedName] = new ClasstableEntry(fileName, cu, c);
 					}
@@ -741,7 +320,7 @@
 		{
 			IParser parser = GetParser(fileName);
 			if (parser != null) {
-				return parser.CtrlSpace(parserService, caretLine, caretColumn, fileName);
+				return parser.CtrlSpace(parserService, completionDataService, caretLine, caretColumn, fileName);
 			}
 			return null;
 		}
@@ -751,7 +330,7 @@
 			try {
 				IParser parser = GetParser (fileName);
 				if (parser != null) {
-					return parser.IsAsResolve (this, expression, caretLineNumber, caretColumn, fileName, fileContent);
+					return parser.IsAsResolve (this, completionDataService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 				}
 				return null;
 			} catch {
@@ -771,7 +350,7 @@
 				IParser parser = GetParser(fileName);
 				//Console.WriteLine(&quot;Parse info : &quot; + GetParseInformation(fileName).MostRecentCompilationUnit.Tag);
 				if (parser != null) {
-					return parser.Resolve(this, expression, caretLineNumber, caretColumn, fileName, fileContent);
+					return parser.Resolve(this, completionDataService, expression, caretLineNumber, caretColumn, fileName, fileContent);
 				}
 				return null;
 			} catch {
@@ -829,4 +408,37 @@
 			}
 		}
 	}
+
+	class ClasstableEntry
+	{
+		IClass           myClass;
+		ICompilationUnit myCompilationUnit;
+		string           myFileName;
+
+		public IClass Class {
+			get {
+				return myClass;
+			}
+		}
+
+		public ICompilationUnit CompilationUnit {
+			get {
+				return myCompilationUnit;
+			}
+		}
+
+		public string FileName {
+			get {
+				return myFileName;
+			}
+		}
+
+		public ClasstableEntry(string fileName, ICompilationUnit compilationUnit, IClass c)
+		{
+			this.myCompilationUnit = compilationUnit;
+			this.myFileName        = fileName;
+			this.myClass           = c;
+		}
+	}
+
 }

Added: branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/ICompletionDataService.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/ICompletionDataService.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/ICompletionDataService.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -0,0 +1,32 @@
+using System;
+using System.Collections;
+using System.Diagnostics;
+using System.IO;
+
+using MonoDevelop.Core.AddIns;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Services
+{
+	public interface ICompletionDataService {
+		void SetClasses(Hashtable classes, Hashtable caseInsensitiveClasses);
+
+		IClass    GetClass(string typeName);
+		string[]  GetNamespaceList(string subNameSpace);
+		ArrayList GetNamespaceContents(string subNameSpace);
+		bool      NamespaceExists(string name);
+		
+		IClass    GetClass(string typeName, bool caseSensitive);
+		string[]  GetNamespaceList(string subNameSpace, bool caseSensitive);
+		ArrayList GetNamespaceContents(string subNameSpace, bool caseSensitive);
+		bool      NamespaceExists(string name, bool caseSensitive);
+
+
+		Hashtable AddClassToNamespaceList(IClass addClass);
+		void AddReferenceToCompletionLookup(IProject project, ProjectReference reference);
+	}
+}

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/IParserService.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/IParserService.cs	2004-04-29 09:12:23 UTC (rev 1546)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/IParserService.cs	2004-04-29 13:21:50 UTC (rev 1547)
@@ -47,18 +47,6 @@
 		IParser GetParser(string fileName);
 		IExpressionFinder GetExpressionFinder(string fileName);
 		
-		// Default Parser Layer dependent functions
-		IClass    GetClass(string typeName);
-		string[]  GetNamespaceList(string subNameSpace);
-		ArrayList GetNamespaceContents(string subNameSpace);
-		bool      NamespaceExists(string name);
-		
-		IClass    GetClass(string typeName, bool caseSensitive);
-		string[]  GetNamespaceList(string subNameSpace, bool caseSensitive);
-		ArrayList GetNamespaceContents(string subNameSpace, bool caseSensitive);
-		bool      NamespaceExists(string name, bool caseSensitive);
-		////////////////////////////////////////////
-
 		/// &lt;summary&gt;
 		/// Resolves an expression.
 		/// The caretLineNumber and caretColumn is 1 based.
@@ -70,7 +58,6 @@
 		                      string fileContent);
 		ArrayList IsAsResolve (string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
 		ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName);
-		void AddReferenceToCompletionLookup(IProject project, ProjectReference reference);
 
 		event ParseInformationEventHandler ParseInformationAdded;
 		event ParseInformationEventHandler ParseInformationRemoved;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001153.html">[Monodevelop-patches-list] r1546 - in trunk/MonoDevelop/src/AddIns: BackendBindings/CSharpBinding DebuggerAddIn
</A></li>
	<LI>Next message: <A HREF="001155.html">[Monodevelop-patches-list] r1548 - in branches/MonoDevelop-generate-what: build/data/resources/icons build/data/templates/file/CSharp docs src/AddIns/BackendBindings/CSharpBinding src/AddIns/DebuggerAddIn src/AddIns/DisplayBindings/SourceEditor src/AddIns/DisplayBindings/SourceEditor/Gui src/Main/Base src/Main/Base/Internal/Project/Project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1154">[ date ]</a>
              <a href="thread.html#1154">[ thread ]</a>
              <a href="subject.html#1154">[ subject ]</a>
              <a href="author.html#1154">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
