<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1425 - in trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding: . Gui Parser Parser/SharpDevelopTree
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1425%20-%20in%20trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding%3A%20.%20Gui%20Parser%20Parser/SharpDevelopTree&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001031.html">
   <LINK REL="Next"  HREF="001033.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1425 - in trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding: . Gui Parser Parser/SharpDevelopTree</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1425%20-%20in%20trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding%3A%20.%20Gui%20Parser%20Parser/SharpDevelopTree&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1425 - in trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding: . Gui Parser Parser/SharpDevelopTree">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Fri Apr  9 15:34:10 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001031.html">[Monodevelop-patches-list] r1424 - in trunk/MonoDevelop/src/Main/Base: . Commands Gui/HtmlControl Gui/Pads
</A></li>
        <LI>Next message: <A HREF="001033.html">[Monodevelop-patches-list] r1426 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1032">[ date ]</a>
              <a href="thread.html#1032">[ thread ]</a>
              <a href="subject.html#1032">[ subject ]</a>
              <a href="author.html#1032">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2004-04-09 15:34:10 -0400 (Fri, 09 Apr 2004)
New Revision: 1425

Added:
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/ExpressionFinder.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/JavaVisitor.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/Parser.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/Resolver.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/AttributeSection.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Class.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/CompilationUnit.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Constructor.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Event.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Field.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Indexer.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Method.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Parameter.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Property.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/ReturnType.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/TypeVisitor.cs
Modified:
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/ChangeLog
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Gui/ProjectConfigurationPropertyPanel.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/JavaBindingCompilerServices.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/JavaBindingExecutionServices.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Makefile.am
Log:
2004-04-09  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jluke at cfl.rr.com</A>&gt;
 
        * JavaBindingCompilerService.cs: account for classpath when compiling
        * Gui/ProjectConfigurationPropertyPanel.cs: rough port, needs major HIG love
        * JavaBindingExecutionService.cs: use ikvm instead of java runtime
        * Parser/*: make a copy of the CSharpBinding/Parser in case I am crazy enough
        to port the parser to work with Java (not built yet)



Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/ChangeLog	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/ChangeLog	2004-04-09 19:34:10 UTC (rev 1425)
@@ -1,3 +1,11 @@
+2004-04-09  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jluke at cfl.rr.com</A>&gt;
+
+	* JavaBindingCompilerService.cs: account for classpath when compiling
+	* Gui/ProjectConfigurationPropertyPanel.cs: rough port, needs major HIG love
+	* JavaBindingExecutionService.cs: use ikvm instead of java runtime
+	* Parser/*: make a copy of the CSharpBinding/Parser in case I am crazy enough
+	to port the parser to work with Java (not built yet)
+
 2004-03-25  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jluke at cfl.rr.com</A>&gt;
 	
 	import from SD and make it build with our

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Gui/ProjectConfigurationPropertyPanel.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Gui/ProjectConfigurationPropertyPanel.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Gui/ProjectConfigurationPropertyPanel.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -6,49 +6,43 @@
 // &lt;/file&gt;
 
 using System;
-using System.Drawing;
+using Gtk;
 
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Internal.ExternalTool;
 using MonoDevelop.Gui.Dialogs;
+using MonoDevelop.Gui.Widgets;
+using MonoDevelop.Services;
 using MonoDevelop.Core.Services;
 using MonoDevelop.Core.Properties;
 using MonoDevelop.Core.AddIns.Codons;
 
 namespace JavaBinding
 {
-	/// &lt;summary&gt;
-	/// Summary description for Form5.
-	/// &lt;/summary&gt;
 	public class ProjectConfigurationPropertyPanel : AbstractOptionPanel
 	{
-		/*private System.Windows.Forms.GroupBox groupBox1;
-		private System.Windows.Forms.GroupBox groupBox2;		
-		private System.Windows.Forms.Label label4;
-		private System.Windows.Forms.Label label5;
+		private Label label4;
+		private Label label5;
+		private Label titleLabel;
+		private Entry outputAssembly;
 
-		private System.Windows.Forms.TextBox textBox2;
-		private System.Windows.Forms.TextBox textBox3;				
-		private System.Windows.Forms.Button button1;
+		private Entry textBox3;				
+		private Button button1;
 		
-		private System.Windows.Forms.CheckBox checkBox3;
-		private System.Windows.Forms.CheckBox checkBox5;
-		private System.Windows.Forms.CheckBox checkBox6;
-		private System.Windows.Forms.CheckBox checkBox7;
+		private CheckButton checkBox3;
+		private CheckButton checkBox5;
+		private CheckButton checkBox6;
+		private CheckButton checkBox7;
 		
-		private System.Windows.Forms.Label label6;
-		private System.Windows.Forms.Label label7;
-		private System.Windows.Forms.Label label8;
+		private Label label6;
+		private Label label7;
+		private Label label8;
 
-		private System.Windows.Forms.TextBox textBox5;	//Compiler Path
-		private System.Windows.Forms.TextBox textBox6;	//Classpath
-		private System.Windows.Forms.TextBox textBox7;	//MainClass
+		private Entry textBox5;	//Compiler Path
+		private Entry textBox6;	//Classpath
+		private Entry textBox7;	//MainClass
 		
-		/// &lt;summary&gt;
-		/// Required designer variable.
-		/// &lt;/summary&gt;
-		private System.ComponentModel.Container components = null;
-		ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+		ResourceService resourceService = (ResourceService) ServiceManager.Services.GetService (typeof (IResourceService));
 		JavaCompilerParameters compilerParameters = null;
 		
 		public override bool ReceiveDialogMessage(DialogMessage message)
@@ -56,11 +50,11 @@
 			if (message == DialogMessage.OK) {
 				if (compilerParameters == null)
 					return true;
-				compilerParameters.GenWarnings = checkBox7.Checked;			
-				compilerParameters.Deprecation = checkBox6.Checked;			
-				compilerParameters.Debugmode = checkBox5.Checked;			
-				compilerParameters.Optimize = checkBox3.Checked;						
-				compilerParameters.OutputAssembly = textBox2.Text;
+				compilerParameters.GenWarnings = checkBox7.Active;			
+				compilerParameters.Deprecation = checkBox6.Active;			
+				compilerParameters.Debugmode = checkBox5.Active;			
+				compilerParameters.Optimize = checkBox3.Active;						
+				compilerParameters.OutputAssembly = outputAssembly.Text;
 				compilerParameters.OutputDirectory = textBox3.Text;
 				
 				compilerParameters.CompilerPath = textBox5.Text;
@@ -74,11 +68,11 @@
 		{
 			this.compilerParameters = (JavaCompilerParameters)((IProperties)CustomizationObject).GetProperty(&quot;Config&quot;);
 			
-			checkBox3.Checked = compilerParameters.Optimize;
-			checkBox5.Checked = compilerParameters.Debugmode;
-			checkBox6.Checked = compilerParameters.Deprecation;
-			checkBox7.Checked = compilerParameters.GenWarnings;
-			textBox2.Text = compilerParameters.OutputAssembly;
+			checkBox3.Active = compilerParameters.Optimize;
+			checkBox5.Active = compilerParameters.Debugmode;
+			checkBox6.Active = compilerParameters.Deprecation;
+			checkBox7.Active = compilerParameters.GenWarnings;
+			outputAssembly.Text = compilerParameters.OutputAssembly;
 			textBox3.Text = compilerParameters.OutputDirectory;				
 			
 			textBox5.Text = compilerParameters.CompilerPath;
@@ -88,251 +82,67 @@
 		
 		void SelectFolder(object sender, EventArgs e)
 		{
-			FolderDialog fdiag = new  FolderDialog();
+			using (FolderDialog fdiag = new FolderDialog (GettextCatalog.GetString (&quot;Browse&quot;))) {
 			
-			if (fdiag.DisplayDialog(resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.FolderBrowserDescription&quot;)) == DialogResult.OK) {
-				textBox3.Text = fdiag.Path;
+				if (fdiag.Run () == (int) ResponseType.Ok) {
+					//textBox3.Text = fdiag.Path;
+				}
+				fdiag.Hide ();
 			}
 		}
 		
-		public ProjectConfigurationPropertyPanel()
+		public ProjectConfigurationPropertyPanel ()
 		{
-			InitializeComponent();						
-			CustomizationObjectChanged += new EventHandler(SetValues);
+			InitializeComponent ();						
+			VBox vbox = new VBox ();
+			vbox.PackStart (titleLabel);
+			vbox.PackStart (outputAssembly);
+			vbox.PackStart (label6);
+			vbox.PackStart (textBox5);
+			vbox.PackStart (label7);
+			vbox.PackStart (textBox6);
+			vbox.PackStart (label8);
+			vbox.PackStart (textBox7);
+			vbox.PackStart (label4);
+			HBox hbox = new HBox ();
+			hbox.PackStart (checkBox5);
+			hbox.PackStart (checkBox6);
+			hbox.PackStart (checkBox3);
+			vbox.PackStart (hbox);
+			vbox.PackStart (label5);
+			vbox.PackStart (textBox3);
+			this.Add (vbox);
+			CustomizationObjectChanged += new EventHandler (SetValues);
 		}
 		
-		/// &lt;summary&gt;
-		/// Clean up any resources being used.
-		/// &lt;/summary&gt;
-		protected override void Dispose( bool disposing )
-		{
-			if( disposing )
-				{
-					if(components != null)
-						{
-							components.Dispose();
-						}
-				}
-				base.Dispose( disposing );
-		}
-		
-		#region Windows Form Designer generated code
-		/// &lt;summary&gt;
-		/// Required method for Designer support - do not modify
-		/// the contents of this method with the code editor.
-		/// &lt;/summary&gt;
 		private void InitializeComponent()
 		{
-			this.groupBox1 = new System.Windows.Forms.GroupBox();
-			this.checkBox6 = new System.Windows.Forms.CheckBox();
-			this.checkBox5 = new System.Windows.Forms.CheckBox();
-
-			this.checkBox3 = new System.Windows.Forms.CheckBox();
+			this.checkBox6 = new CheckButton (GettextCatalog.GetString (&quot;Deprecation&quot;));
+			this.checkBox5 = new CheckButton (GettextCatalog.GetString (&quot;Debug Info&quot;));
+			this.checkBox3 = new CheckButton (GettextCatalog.GetString (&quot;Optimize&quot;));
 			
-			this.groupBox2 = new System.Windows.Forms.GroupBox();
-			this.button1 = new System.Windows.Forms.Button();
-			this.textBox3 = new System.Windows.Forms.TextBox();
-			this.label5 = new System.Windows.Forms.Label();
-			this.textBox2 = new System.Windows.Forms.TextBox();
-			this.label4 = new System.Windows.Forms.Label();
+			this.button1 = new Button (&quot;...&quot;);
+			this.button1.Clicked += new EventHandler (SelectFolder);
+			this.textBox3 = new Entry ();
+			this.label5 = new Label ();
+			label5.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Output path&quot;));
+			this.titleLabel = new Label ();
+			this.outputAssembly = new Entry ();
+			titleLabel.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Output Assembly&quot;));
+			this.label4 = new Label ();
+			label4.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Warnings and Errors&quot;));
 			
-			this.checkBox7 = new System.Windows.Forms.CheckBox();
-			this.textBox5 = new System.Windows.Forms.TextBox();
-			this.textBox6 = new System.Windows.Forms.TextBox();
-			this.textBox7 = new System.Windows.Forms.TextBox();
+			this.checkBox7 = new CheckButton (GettextCatalog.GetString (&quot;Generate Warnings&quot;));
+			this.textBox5 = new Entry ();
+			this.textBox6 = new Entry ();
+			this.textBox7 = new Entry ();
 			
-			this.label6 = new System.Windows.Forms.Label();			
-			this.label7 = new System.Windows.Forms.Label();
-			this.label8 = new System.Windows.Forms.Label();
-			
-			this.groupBox1.SuspendLayout();
-			this.groupBox2.SuspendLayout();
-			this.SuspendLayout();
-			// 
-			// groupBox1
-			//
-			this.groupBox1.Controls.AddRange(new System.Windows.Forms.Control[] {	this.textBox5,
-			                                 this.textBox6,
-			                                 this.textBox7,
-			                                 this.label6,
-			                                 this.label7,
-			                                 this.label8,
-			                                 this.checkBox5,
-			                                 this.checkBox6,
-			                                 this.checkBox7,
-			                                 this.checkBox3});
-			this.groupBox1.Location = new System.Drawing.Point(8, 8);
-			this.groupBox1.Name = &quot;groupBox1&quot;;
-			this.groupBox1.Size = new System.Drawing.Size(376, 232);
-			this.groupBox1.TabIndex = 0;
-			this.groupBox1.TabStop = false;
-			this.groupBox1.Text = resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.CodeGenerationGroupBox&quot;);
-			
-			//
-			// checkBox6
-			// 
-			this.checkBox6.Location = new System.Drawing.Point(192, 128);
-			this.checkBox6.Name = &quot;checkBox6&quot;;
-			this.checkBox6.Size = new System.Drawing.Size(176, 16);
-			this.checkBox6.TabIndex = 8;
-			this.checkBox6.Text = &quot;Deprecation&quot;;
-			//this.checkBox5.Text = resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.DebugInformationCheckBox&quot;);
-			
-			//
-			// checkBox7
-			// 
-			this.checkBox7.Location = new System.Drawing.Point(192, 146);
-			this.checkBox7.Name = &quot;checkBox7&quot;;
-			this.checkBox7.Size = new System.Drawing.Size(176, 16);
-			this.checkBox7.TabIndex = 8;
-			this.checkBox7.Text = &quot;Generate Warnings&quot;;
-			//this.checkBox5.Text = resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.DebugInformationCheckBox&quot;);
-			
-			//
-			// checkBox5
-			// 
-			this.checkBox5.Location = new System.Drawing.Point(192, 112);
-			this.checkBox5.Name = &quot;checkBox5&quot;;
-			this.checkBox5.Size = new System.Drawing.Size(176, 16);
-			this.checkBox5.TabIndex = 8;
-			this.checkBox5.Text = resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.DebugInformationCheckBox&quot;);
-			
-			//
-			// checkBox3
-			// 
-			this.checkBox3.Location = new System.Drawing.Point(192, 96);
-			this.checkBox3.Name = &quot;checkBox3&quot;;
-			this.checkBox3.Size = new System.Drawing.Size(176, 16);
-			this.checkBox3.TabIndex = 7;
-			this.checkBox3.Text = resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.OptimizeCheckBox&quot;);
-			
-			// 
-			// label6
-			// 
-			this.label6.Location = new System.Drawing.Point(18, 50);
-			this.label6.Name = &quot;label6&quot;;
-			this.label6.Size = new System.Drawing.Size(80, 23);
-			this.label6.TabIndex = 99;
-			this.label6.Text = &quot;Compiler Path&quot;;	//resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.OutputPathLabel&quot;);
-			
-			//
-			// textBox5
-			// 
-			this.textBox5.Location = new System.Drawing.Point(186, 50);
-			this.textBox5.Name = &quot;textBox5&quot;;
-			this.textBox5.Size = new System.Drawing.Size(182, 20);
-			this.textBox5.TabIndex = 1;
-			this.textBox5.Text = &quot;&quot;;
-			
-			//
-			// label7
-			// 
-			this.label7.Location = new System.Drawing.Point(18, 70);
-			this.label7.Name = &quot;label7&quot;;
-			this.label7.Size = new System.Drawing.Size(80, 23);
-			this.label7.TabIndex = 99;
-			this.label7.Text = &quot;Class Path&quot;; 	//resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.OutputPathLabel&quot;);
-			
-			//
-			// textBox6
-			// 
-			this.textBox6.Location = new System.Drawing.Point(186, 70);
-			this.textBox6.Name = &quot;textBox6&quot;;
-			this.textBox6.Size = new System.Drawing.Size(182, 20);
-			this.textBox6.TabIndex = 1;
-			this.textBox6.Text = &quot;&quot;;
-			
-			//
-			// label8
-			// 
-			this.label8.Location = new System.Drawing.Point(18, 170);
-			this.label8.Name = &quot;label7&quot;;
-			this.label8.Size = new System.Drawing.Size(80, 23);
-			this.label8.TabIndex = 99;
-			this.label8.Text = &quot;Main Class&quot;; 	//resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.OutputPathLabel&quot;);
-			
-			
-			//
-			// textBox7
-			// 
-			this.textBox7.Location = new System.Drawing.Point(186, 170);
-			this.textBox7.Name = &quot;textBox7&quot;;
-			this.textBox7.Size = new System.Drawing.Size(182, 20);
-			this.textBox7.TabIndex = 1;
-			this.textBox7.Text = &quot;&quot;;
-			
-			// 
-			// groupBox2
-			// 
-			this.groupBox2.Controls.AddRange(new System.Windows.Forms.Control[] {   //this.checkBox4,
-																					this.button1,
-																					this.textBox3,
-																					this.label5,
-																					this.textBox2,
-																					this.label4});
-			this.groupBox2.Location = new System.Drawing.Point(8, 240);			
-			this.groupBox2.Name = &quot;groupBox2&quot;;
-			this.groupBox2.Size = new System.Drawing.Size(376, 96);
-			this.groupBox2.TabIndex = 2;
-			this.groupBox2.TabStop = false;
-			this.groupBox2.Text = resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.OutputGroupBox&quot;);
-			
-			//
-			// button1
-			// 
-			this.button1.Location = new System.Drawing.Point(344, 40);
-			this.button1.Name = &quot;button1&quot;;
-			this.button1.Size = new System.Drawing.Size(24, 24);
-			this.button1.TabIndex = 3;
-			this.button1.Text = &quot;...&quot;;
-			this.button1.Click += new EventHandler(SelectFolder);
-			// 
-			// textBox3
-			// 
-			this.textBox3.Location = new System.Drawing.Point(96, 40);
-			this.textBox3.Name = &quot;textBox3&quot;;
-			this.textBox3.Size = new System.Drawing.Size(240, 20);
-			this.textBox3.TabIndex = 2;
-			this.textBox3.Text = &quot;&quot;;
-			// 
-			// label5
-			// 
-			this.label5.Location = new System.Drawing.Point(8, 40);
-			this.label5.Name = &quot;label5&quot;;
-			this.label5.Size = new System.Drawing.Size(80, 23);
-			this.label5.TabIndex = 99;
-			this.label5.Text = resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.OutputPathLabel&quot;);
-			
-			//
-			// textBox2
-			// 
-			this.textBox2.Location = new System.Drawing.Point(96, 16);
-			this.textBox2.Name = &quot;textBox2&quot;;
-			this.textBox2.Size = new System.Drawing.Size(272, 20);
-			this.textBox2.TabIndex = 1;
-			this.textBox2.Text = &quot;&quot;;
-			// 
-			// label4
-			// 
-			this.label4.Location = new System.Drawing.Point(8, 16);
-			this.label4.Name = &quot;label4&quot;;
-			this.label4.Size = new System.Drawing.Size(88, 16);
-			this.label4.TabIndex = 99;
-			this.label4.Text = resourceService.GetString(&quot;Dialog.Options.PrjOptions.Configuration.WarningsAsErrorsCheckBox&quot;);
-			
-			//
-			// Form5
-			// 
-			this.ClientSize = new System.Drawing.Size(392, 341);
-			this.Controls.AddRange(new System.Windows.Forms.Control[] {   this.groupBox2,
-																		  this.groupBox1});
-			this.Name = &quot;Form5&quot;;
-			this.groupBox1.ResumeLayout(false);
-			this.groupBox2.ResumeLayout(false);
-			this.ResumeLayout(false);
-
+			this.label6 = new Label ();
+			label6.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Compiler path&quot;));
+			this.label7 = new Label ();
+			label7.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Classpath&quot;));
+			this.label8 = new Label ();
+			label8.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GettextCatalog.GetString (&quot;Main Class&quot;));
 		}
-		#endregion
-		*/
 	}
 }

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/JavaBindingCompilerServices.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/JavaBindingCompilerServices.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/JavaBindingCompilerServices.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -126,7 +126,14 @@
 			//string outstr = compilerparameters.CompilerPath + &quot;&quot; + files + &quot; -classpath &quot; + compilerparameters.ClassPath + options;
 			//string outstr = compilerparameters.CompilerPath + &quot;&quot; + files + &quot; -classpath &quot; + compilerparameters.ClassPath + options;
 
-			string outstr = compilerparameters.CompilerPath + &quot; &quot; + files + options;			
+			// FIXME: maybe just send javac command to vte
+			// we don't seem to have task support anyways
+			string outstr;
+			if (compilerparameters.ClassPath == &quot;&quot;) {
+				outstr = compilerparameters.CompilerPath + files + options;			
+			} else {
+				outstr = compilerparameters.CompilerPath + &quot; -classpath &quot; + compilerparameters.ClassPath + files + options;
+			}
 			DoCompilation (outstr, tf, ref output, ref error);
 			//Executor.ExecWaitWithCapture(outstr, tf, ref error , ref output);			
 			ICompilerResult cr = ParseOutput (tf, output);			

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/JavaBindingExecutionServices.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/JavaBindingExecutionServices.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/JavaBindingExecutionServices.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -8,15 +8,11 @@
 using System;
 using System.IO;
 using System.Diagnostics;
-using System.Collections;
 using System.Reflection;
-using System.Resources;
-using System.Xml;
-using System.CodeDom.Compiler;
-using System.Threading;
 
 using MonoDevelop.Internal.Project;
 using MonoDevelop.Gui;
+using MonoDevelop.Gui.Pads;
 using MonoDevelop.Core.Services;
 
 namespace JavaBinding
@@ -47,36 +43,51 @@
 			JavaCompilerParameters parameters = (JavaCompilerParameters)project.ActiveConfiguration;
 			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
 			string directory = fileUtilityService.GetDirectoryNameWithSeparator(((JavaCompilerParameters)project.ActiveConfiguration).OutputDirectory);
+			string mainClass = ((JavaCompilerParameters) project.ActiveConfiguration).MainClass;
 			
 			string CurrentDir = Directory.GetCurrentDirectory();
-			Directory.SetCurrentDirectory(parameters.OutputDirectory);
-			ProcessStartInfo psi;
-			if(((JavaCompilerParameters)project.ActiveConfiguration).MainClass==null) {
-					//FIXME:
-				psi = new ProcessStartInfo(&quot;xterm -e \&quot;java &quot; + ((JavaCompilerParameters)project.ActiveConfiguration).OutputAssembly + &quot;;read -p 'press any key to continue...' -n1\&quot;&quot;);
-			} else {
-				if (parameters.PauseConsoleOutput) {
-					//FIXME:
-					psi = new ProcessStartInfo(&quot;xterm -e \&quot;java &quot; + ((JavaCompilerParameters)project.ActiveConfiguration).MainClass + &quot;;read -p 'press any key to continue...' -n1\&quot;&quot;);
-				} else {
-					//FIXME:
-					psi = new ProcessStartInfo(&quot;xterm -e \&quot;java &quot; + ((JavaCompilerParameters)project.ActiveConfiguration).MainClass + &quot;;read -p 'press any key to continue...' -n1\&quot;&quot;);
-				}
+			Directory.SetCurrentDirectory (parameters.OutputDirectory);
+			ProcessStartInfo psi = new ProcessStartInfo(&quot;xterm -e \&quot;ikvm -classpath &quot; + parameters.ClassPath + &quot; &quot; + mainClass + &quot;;read -p 'press any key to continue...' -n1\&quot;&quot;);
+
+            try {
+                psi.WorkingDirectory = Path.GetDirectoryName (directory);
+                psi.UseShellExecute = false;
+
+                Process p = new Process ();
+                p.StartInfo = psi;
+                p.Start ();
+            } catch (Exception) {
+                throw new ApplicationException (&quot;Can not execute &quot; + &quot;\&quot;&quot; + directory + mainClass + &quot;\&quot;\n(Try restarting MonoDevelop or start your app manually)&quot;);
+            }
+
+/*
+			//FIXME: find out how to set the working dir better
+			TerminalPad outputPad = (TerminalPad) WorkbenchSingleton.Workbench.GetPad (typeof (TerminalPad));
+			outputPad.RunCommand (&quot;cd &quot; + parameters.OutputDirectory);
+
+			string runtime = &quot;ikvm&quot;; // make it project.RuntimeOptions or so
+			switch (runtime) {
+				// is this even supposed to work with CLI binaries?
+				//case &quot;java&quot;: // use an installed jre
+				//	outputPad.RunCommand (&quot;java -classpath &quot; + parameters.ClassPath + &quot; &quot;  + ((JavaCompilerParameters) project.ActiveConfiguration).MainClass);
+				//	break;
+				case &quot;ikvm&quot;: // JIT to Java then JIT to mono
+					outputPad.RunCommand (&quot;ikvm -classpath &quot; + parameters.ClassPath + &quot; &quot;  + ((JavaCompilerParameters) project.ActiveConfiguration).MainClass);
+					break;
+				default: // run compiled to exe with mono
+					string command = &quot;ikvmc -reference:/usr/lib/classpath.dll &quot; + ((JavaCompilerParameters) project.ActiveConfiguration).MainClass + &quot;.class &quot;;
+					string[] allJars = parameters.ClassPath.Split (':');
+					foreach (string jar in allJars)
+					{
+						if (jar != &quot;.&quot;)
+							command += jar + &quot; &quot;;
+					}
+					outputPad.RunCommand (command);
+					outputPad.RunCommand (&quot;mono &quot; + ((JavaCompilerParameters) project.ActiveConfiguration).MainClass + &quot;.exe&quot;);
+					break;
 			}
-			
-			try {
-				psi.WorkingDirectory = parameters.OutputDirectory;
-				psi.UseShellExecute = false;
-			
-				Process p = new Process();
-				p.StartInfo = psi;
-				p.Start();
-			} catch (Exception) {
-				throw new ApplicationException(&quot;Can not execute&quot;);
-			}
-			
-			Directory.SetCurrentDirectory(CurrentDir);		
+			outputPad.RunCommand (&quot;cd -&quot;);
+*/				
 		}
-				
 	}
 }

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Makefile.am
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Makefile.am	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Makefile.am	2004-04-09 19:34:10 UTC (rev 1425)
@@ -6,7 +6,6 @@
 	/r:../../../../build/bin/MonoDevelop.Core.dll \
 	/r:../../../../build/bin/MonoDevelop.SourceEditor.dll \
 	/r:../../../../build/bin/MonoDevelop.Base.dll \
-	/r:../../../../build/bin/ICSharpCode.SharpRefactory.dll \
 	/r:../../../../build/bin/MonoDevelop.Gui.Widgets.dll \
 	/r:gtk-sharp.dll
 
@@ -27,7 +26,7 @@
 	$(CSC) $(DLLS) $(build_sources) /out:$(ASSEMBLY) /target:library \
 	&amp;&amp; cp $(ASSEMBLY) ../../../../build/AddIns/AddIns/BackendBindings/.
 
-assemblydir = $(libdir)/monodevelop/AddIns/AddIns/BackendBindings/
+assemblydir = $(libdir)/monodevelop/AddIns/AddIns/BackendBindings
 assembly_DATA = $(ASSEMBLY)
 
 CLEANFILES = $(ASSEMBLY)

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/ExpressionFinder.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/ExpressionFinder.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/ExpressionFinder.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,380 @@
+using System;
+using System.Text;
+using MonoDevelop.Internal.Parser;
+
+namespace JavaBinding.Parser
+{
+	/// &lt;summary&gt;
+	/// Description of ExpressionFinder.	
+	/// &lt;/summary&gt;
+	public class ExpressionFinder : IExpressionFinder
+	{
+		public string FindExpression(string inText, int offset)
+		{
+			this.text = FilterComments(inText, ref offset);
+			this.text   = text;
+			this.offset = this.lastAccept = offset;
+			this.state  = START;
+			if (this.text == null) {
+				return null;
+			}
+			
+			while (state != ERROR) {
+				ReadNextToken();
+				//Console.WriteLine(&quot;cur state {0} got token {1} going to {2}&quot;, GetStateName(state), GetTokenName(curTokenType), GetStateName(stateTable[state, curTokenType]));
+				state = stateTable[state, curTokenType];
+				
+				if (state == ACCEPT || state == ACCEPT2) {
+					lastAccept = this.offset;
+				}
+				if (state == ACCEPTNOMORE) {
+					return this.text.Substring(this.offset + 1, offset - this.offset);
+				}
+			}
+			return this.text.Substring(this.lastAccept + 1, offset - this.lastAccept);
+		}
+		
+		#region Comment Filter and 'inside string watcher'
+		int initialOffset;
+		public string FilterComments(string text, ref int offset)
+		{
+			this.initialOffset = offset;
+			StringBuilder outText = new StringBuilder();
+			int curOffset = 0;
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset];
+				
+				switch (ch) {
+					case '@':
+						if (curOffset + 1 &lt; text.Length &amp;&amp; text[curOffset + 1] == '&quot;') {
+							outText.Append(text[curOffset++]); // @
+							outText.Append(text[curOffset++]); // &quot;
+							if (!ReadVerbatimString(outText, text, ref curOffset)) {
+								return null;
+							}
+						}else{
+							outText.Append(ch);
+							++curOffset;
+						}
+						break;
+					case '\'':
+						outText.Append(ch);
+						curOffset++;
+						// to read '&quot; and '\&quot; ... this should work for these cases
+						if (curOffset &lt;= initialOffset) {
+							outText.Append(text[curOffset++]);
+						}
+						if (curOffset &lt;= initialOffset) {
+							outText.Append(text[curOffset++]);
+						}
+						break;
+					case '&quot;':
+						outText.Append(ch);
+						curOffset++;
+						if (!ReadString(outText, text, ref curOffset)) {
+							return null;
+						}
+						break;
+					case '/':
+						if (curOffset + 1 &lt; text.Length &amp;&amp; text[curOffset + 1] == '/') {
+							offset    -= 2;
+							curOffset += 2;
+							if (!ReadToEOL(text, ref curOffset, ref offset)) {
+								return null;
+							}
+						} else if (curOffset + 1 &lt; text.Length &amp;&amp; text[curOffset + 1] == '*') {
+							offset    -= 2;
+							curOffset += 2;
+							if (!ReadMultiLineComment(text, ref curOffset, ref offset)) {
+								return null;
+							}
+						} else {
+							goto default;
+						}
+						break;
+					default:
+						outText.Append(ch);
+						++curOffset;
+						break;
+				}
+			}
+			
+			return outText.ToString();
+		}
+		
+		bool ReadToEOL(string text, ref int curOffset, ref int offset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				--offset;
+				if (ch == '\n') {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		bool ReadString(StringBuilder outText, string text, ref int curOffset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				outText.Append(ch);
+				if (ch == '&quot;') {
+					return true;
+				} else if (ch == '\\') {
+					outText.Append(text[curOffset++]);
+				}
+			}
+			return false;
+		}
+		
+		bool ReadVerbatimString(StringBuilder outText, string text, ref int curOffset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				outText.Append(ch);
+				if (ch == '&quot;') {
+					if (curOffset &lt; text.Length &amp;&amp; text[curOffset] == '&quot;') {
+						outText.Append(text[curOffset++]);
+					} else {
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+		
+		bool ReadMultiLineComment(string text, ref int curOffset, ref int offset)
+		{
+			while (curOffset &lt;= initialOffset) {
+				char ch = text[curOffset++];
+				--offset;
+				if (ch == '*') {
+					if (curOffset &lt; text.Length &amp;&amp; text[curOffset] == '/') {
+						++curOffset;
+						--offset;
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+		#endregion
+		
+		#region mini backward lexer
+		string text;
+		int    offset;
+		
+		char GetNext()
+		{
+			if (offset &gt;= 0) {
+				return text[offset--];
+			}
+			return '\0';
+		}
+		
+		char Peek()
+		{
+			if (offset &gt;= 0) {
+				return text[offset];
+			}
+			return '\0';
+		}
+		
+		void UnGet()
+		{
+			++offset;
+		}
+		
+		// tokens for our lexer
+		static int Err     = 0;
+		static int Dot     = 1;
+		static int StrLit  = 2;
+		static int Ident   = 3;
+		static int New     = 4;
+		static int Bracket = 5;
+		static int Parent  = 6;
+		static int Curly   = 7;
+		static int Using   = 8;
+		int curTokenType;
+		
+		string GetTokenName(int state)
+		{
+			string[] stateName = new string[] {
+				&quot;Err&quot;, &quot;Dot&quot;, &quot;StrLit&quot;, &quot;Ident&quot;, &quot;New&quot;, &quot;Bracket&quot;, &quot;Paren&quot;, &quot;Curly&quot;, &quot;Using&quot;
+			};
+			return stateName[state];
+		}
+		
+		void ReadNextToken()
+		{
+			char ch = GetNext();
+				
+			curTokenType = Err;
+			if (ch == '\0') {
+				return;
+			}
+			while (Char.IsWhiteSpace(ch)) {
+				ch = GetNext();
+			}
+			
+			switch (ch) {
+				case '}':
+					if (ReadBracket('{', '}')) {
+						curTokenType = Curly;
+					}
+					break;
+				case ')':
+					if (ReadBracket('(', ')')) {
+						curTokenType = Parent;
+					}
+					break;
+				case ']':
+					if (ReadBracket('[', ']')) {
+						curTokenType = Bracket;
+					}
+					break;
+				case '.':
+					curTokenType = Dot;
+					break;
+				case '\'':
+				case '&quot;':
+					if (ReadStringLiteral(ch)) {
+						curTokenType = StrLit;
+					}
+					break;
+				default:
+					string ident = ReadIdentifier(ch);
+					if (ident != null) {
+						switch (ident) {
+							case &quot;new&quot;:
+								curTokenType = New;
+								break;
+							case &quot;using&quot;:
+								curTokenType = Using;
+								break;
+							default:
+								curTokenType = Ident;
+								break;
+						}
+					}
+					break;
+			}
+		}
+		
+		bool ReadStringLiteral(char litStart)
+		{
+			while (true) {
+				char ch = GetNext();
+				if (ch == '\0') {
+					return false;
+				}
+				if (ch == litStart) {
+					if (Peek() == '@' &amp;&amp; litStart == '&quot;') {
+						GetNext();
+					}
+					return true;
+				}
+			}
+		}
+		
+		bool ReadBracket(char openBracket, char closingBracket)
+		{
+			int curlyBraceLevel    = 0;
+			int squareBracketLevel = 0;
+			int parenthesisLevel   = 0;
+			switch (openBracket) {
+				case '(':
+					parenthesisLevel++;
+					break;
+				case '[':
+					squareBracketLevel++;
+					break;
+				case '{':
+					curlyBraceLevel++;
+					break;
+			}
+			
+			while (parenthesisLevel != 0 || squareBracketLevel != 0 || curlyBraceLevel != 0) {
+				char ch = GetNext();
+				if (ch == '\0') {
+					return false;
+				}
+				switch (ch) {
+					case '(':
+						parenthesisLevel--;
+						break;
+					case '[':
+						squareBracketLevel--;
+						break;
+					case '{':
+						curlyBraceLevel--;
+						break;
+					case ')':
+						parenthesisLevel++;
+						break;
+					case ']':
+						squareBracketLevel++;
+						break;
+					case '}':
+						curlyBraceLevel++;
+						break;
+				}
+			}
+			return true;
+		}
+		
+		string ReadIdentifier(char ch)
+		{
+			string identifier = ch.ToString();
+			while (IsIdentifierPart(Peek())) {
+				identifier = GetNext() + identifier;
+			}
+			return identifier;
+		}
+		
+		bool IsIdentifierPart(char ch)
+		{
+			return Char.IsLetterOrDigit(ch) || ch == '_';
+		}
+		#endregion
+		
+		#region finite state machine 
+		static int ERROR  = 0;
+		static int START  = 1;
+		static int DOT    = 2;
+		static int MORE   = 3;
+		static int CURLY  = 4;
+		static int CURLY2 = 5;
+		static int CURLY3 = 6;
+		
+		static int ACCEPT = 7;
+		static int ACCEPTNOMORE = 8;
+		static int ACCEPT2 = 9;
+		
+		string GetStateName(int state)
+		{
+			string[] stateName = new string[] {
+				&quot;ERROR&quot;, &quot;START&quot;, &quot;DOT&quot;, &quot;MORE&quot;, &quot;CURLY&quot;, &quot;CURLY2&quot;, &quot;CURLY3&quot;, &quot;ACCEPT&quot;, &quot;ACCEPTNOMORE&quot;, &quot;ACCEPT2&quot;
+			};
+			return stateName[state];
+		}
+		
+		int state = 0;
+		int lastAccept = 0;
+		static int[,] stateTable = new int[,] {
+			//                   Err,     Dot,     Str,      ID,         New,     Brk,     Par,     Cur,   Using
+			/*ERROR*/        { ERROR,   ERROR,   ERROR,   ERROR,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*START*/        { ERROR,     DOT,  ACCEPT,  ACCEPT,        ERROR,   MORE, ACCEPT2,   CURLY,   ACCEPTNOMORE},
+			/*DOT*/          { ERROR,   ERROR,  ACCEPT,  ACCEPT,        ERROR,   MORE,  ACCEPT,   CURLY,   ERROR},
+			/*MORE*/         { ERROR,   ERROR,  ACCEPT,  ACCEPT,        ERROR,   MORE, ACCEPT2,   CURLY,   ERROR},
+			/*CURLY*/        { ERROR,   ERROR,   ERROR,   ERROR,        ERROR, CURLY2,   ERROR,   ERROR,   ERROR},
+			/*CURLY2*/       { ERROR,   ERROR,   ERROR,  CURLY3,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*CURLY3*/       { ERROR,   ERROR,   ERROR,   ERROR, ACCEPTNOMORE,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*ACCEPT*/       { ERROR,    MORE,   ERROR,   ERROR,       ACCEPT,  ERROR,   ERROR,   ERROR,   ACCEPTNOMORE},
+			/*ACCEPTNOMORE*/ { ERROR,   ERROR,   ERROR,   ERROR,        ERROR,  ERROR,   ERROR,   ERROR,   ERROR},
+			/*ACCEPT2*/      { ERROR,    MORE,   ERROR,  ACCEPT,       ACCEPT,  ERROR,   ERROR,   ERROR,   ERROR},
+		};
+		#endregion 
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/JavaVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/JavaVisitor.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/JavaVisitor.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,252 @@
+// created on 04.08.2003 at 17:49
+using System;
+using System.Drawing;
+using System.Diagnostics;
+using System.Collections;
+
+using RefParser = JRefactory.Parser;
+using AST = JRefactory.Parser.AST;
+using MonoDevelop.Internal.Parser;
+using JavaBinding.Parser.SharpDevelopTree;
+
+namespace JavaBinding.Parser
+{
+	public class Using : AbstractUsing
+	{
+	}
+	
+	public class JavaVisitor : RefParser.AbstractASTVisitor
+	{
+		CompilationUnit cu = new CompilationUnit();
+		Stack currentNamespace = new Stack();
+		Stack currentClass = new Stack();
+		
+		public CompilationUnit Cu {
+			get {
+				return cu;
+			}
+		}
+		
+		public override object Visit(AST.CompilationUnit compilationUnit, object data)
+		{
+			//TODO: usings, Comments
+			compilationUnit.AcceptChildren(this, data);
+			return cu;
+		}
+		
+		public override object Visit(AST.UsingDeclaration usingDeclaration, object data)
+		{
+			Using u = new Using();
+			u.Usings.Add(usingDeclaration.Namespace);
+			cu.Usings.Add(u);
+			return data;
+		}
+		
+		public override object Visit(AST.UsingAliasDeclaration usingAliasDeclaration, object data)
+		{
+			Using u = new Using();
+			u.Aliases[usingAliasDeclaration.Alias] = usingAliasDeclaration.Namespace;
+			cu.Usings.Add(u);
+			return data;
+		}
+		
+		AttributeSectionCollection VisitAttributes(ArrayList attributes)
+		{
+			// TODO Expressions???
+			AttributeSectionCollection result = new AttributeSectionCollection();
+			foreach (AST.AttributeSection section in attributes) {
+				AttributeCollection resultAttributes = new AttributeCollection();
+				foreach (AST.Attribute attribute in section.Attributes) {
+					IAttribute a = new ASTAttribute(attribute.Name, new ArrayList(attribute.PositionalArguments), new SortedList());
+					foreach (AST.NamedArgument n in attribute.NamedArguments) {
+						a.NamedArguments[n.Name] = n.Expr;
+					}
+				}
+				IAttributeSection s = new AttributeSection((AttributeTarget)Enum.Parse(typeof (AttributeTarget), section.AttributeTarget), resultAttributes);
+			}
+			return null;
+		}
+		
+//		ModifierEnum VisitModifier(JRefactory.Parser.Modifier m)
+//		{
+//			return (ModifierEnum)m;
+//		}
+		
+		public override object Visit(AST.NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			string name;
+			if (currentNamespace.Count == 0) {
+				name = namespaceDeclaration.NameSpace;
+			} else {
+				name = String.Concat((string)currentNamespace.Peek(), '.', namespaceDeclaration.NameSpace);
+			}
+			currentNamespace.Push(name);
+			object ret = namespaceDeclaration.AcceptChildren(this, data);
+			currentNamespace.Pop();
+			return ret;
+		}
+		
+		ClassType TranslateClassType(RefParser.Types type)
+		{
+			switch (type) {
+				case RefParser.Types.Class:
+					return ClassType.Class;
+				case RefParser.Types.Enum:
+					return ClassType.Enum;
+				case RefParser.Types.Interface:
+					return ClassType.Interface;
+				case RefParser.Types.Struct:
+					return ClassType.Struct;
+			}
+			return ClassType.Class;
+		}
+		
+		public override object Visit(AST.TypeDeclaration typeDeclaration, object data)
+		{
+			DefaultRegion region = GetRegion(typeDeclaration.StartLocation, typeDeclaration.EndLocation);
+			Class c = new Class(cu, TranslateClassType(typeDeclaration.Type), typeDeclaration.Modifier, region);
+			if (currentClass.Count &gt; 0) {
+				Class cur = ((Class)currentClass.Peek());
+				cur.InnerClasses.Add(c);
+				c.FullyQualifiedName = String.Concat(cur.FullyQualifiedName, '.', typeDeclaration.Name);
+			} else {
+				if (currentNamespace.Count == 0) {
+					c.FullyQualifiedName = typeDeclaration.Name;
+				} else {
+					c.FullyQualifiedName = String.Concat(currentNamespace.Peek(), '.', typeDeclaration.Name);
+				}
+				cu.Classes.Add(c);
+			}
+			if (typeDeclaration.BaseTypes != null) {
+				foreach (string type in typeDeclaration.BaseTypes) {
+					c.BaseTypes.Add(type);
+				}
+			}
+			currentClass.Push(c);
+			object ret = typeDeclaration.AcceptChildren(this, data);
+			currentClass.Pop();
+			c.UpdateModifier();
+			return ret;
+		}
+		
+		DefaultRegion GetRegion(Point start, Point end)
+		{
+			return new DefaultRegion(start.Y, start.X, end.Y, end.X);
+		}
+		
+		public override object Visit(AST.MethodDeclaration methodDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(methodDeclaration.StartLocation, methodDeclaration.EndLocation);
+			DefaultRegion bodyRegion = GetRegion(methodDeclaration.EndLocation, methodDeclaration.Body != null ? methodDeclaration.Body.EndLocation : new Point(-1, -1));
+//			Console.WriteLine(region + &quot; --- &quot; + bodyRegion);
+			ReturnType type = new ReturnType(methodDeclaration.TypeReference);
+			Class c       = (Class)currentClass.Peek();
+			
+			Method method = new Method(String.Concat(methodDeclaration.Name), type, methodDeclaration.Modifier, region, bodyRegion);
+			ParameterCollection parameters = new ParameterCollection();
+			if (methodDeclaration.Parameters != null) {
+				foreach (AST.ParameterDeclarationExpression par in methodDeclaration.Parameters) {
+					ReturnType parType = new ReturnType(par.TypeReference);
+					Parameter p = new Parameter(par.ParameterName, parType);
+					parameters.Add(p);
+				}
+			}
+			method.Parameters = parameters;
+			c.Methods.Add(method);
+			return null;
+		}
+		
+		public override object Visit(AST.ConstructorDeclaration constructorDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(constructorDeclaration.StartLocation, constructorDeclaration.EndLocation);
+			DefaultRegion bodyRegion = GetRegion(constructorDeclaration.EndLocation, constructorDeclaration.Body != null ? constructorDeclaration.Body.EndLocation : new Point(-1, -1));
+			
+			Class c       = (Class)currentClass.Peek();
+			
+			Constructor constructor = new Constructor(constructorDeclaration.Modifier, region, bodyRegion);
+			ParameterCollection parameters = new ParameterCollection();
+			if (constructorDeclaration.Parameters != null) {
+				foreach (AST.ParameterDeclarationExpression par in constructorDeclaration.Parameters) {
+					ReturnType parType = new ReturnType(par.TypeReference);
+					Parameter p = new Parameter(par.ParameterName, parType);
+					parameters.Add(p);
+				}
+			}
+			constructor.Parameters = parameters;
+			c.Methods.Add(constructor);
+			return null;
+		}
+		
+		
+		public override object Visit(AST.FieldDeclaration fieldDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(fieldDeclaration.StartLocation, fieldDeclaration.EndLocation);
+			Class c = (Class)currentClass.Peek();
+			ReturnType type = null;
+			if (fieldDeclaration.TypeReference == null) {
+				Debug.Assert(c.ClassType == ClassType.Enum);
+			} else {
+				type = new ReturnType(fieldDeclaration.TypeReference);
+			}
+			if (currentClass.Count &gt; 0) {
+				foreach (AST.VariableDeclaration field in fieldDeclaration.Fields) {
+					Field f = new Field(type, field.Name, fieldDeclaration.Modifier, region);
+					
+					c.Fields.Add(f);
+				}
+			}
+			return null;
+		}
+		
+		public override object Visit(AST.PropertyDeclaration propertyDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(propertyDeclaration.StartLocation, propertyDeclaration.EndLocation);
+			DefaultRegion bodyRegion = GetRegion(propertyDeclaration.BodyStart,     propertyDeclaration.BodyEnd);
+			
+			ReturnType type = new ReturnType(propertyDeclaration.TypeReference);
+			Class c = (Class)currentClass.Peek();
+			
+			Property property = new Property(propertyDeclaration.Name, type, propertyDeclaration.Modifier, region, bodyRegion);
+			c.Properties.Add(property);
+			return null;
+		}
+		
+		public override object Visit(AST.EventDeclaration eventDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(eventDeclaration.StartLocation, eventDeclaration.EndLocation);
+			DefaultRegion bodyRegion = GetRegion(eventDeclaration.BodyStart,     eventDeclaration.BodyEnd);
+			ReturnType type = new ReturnType(eventDeclaration.TypeReference);
+			Class c = (Class)currentClass.Peek();
+			Event e = null;
+			
+			if (eventDeclaration.VariableDeclarators != null) {
+				foreach (JRefactory.Parser.AST.VariableDeclaration varDecl in eventDeclaration.VariableDeclarators) {
+					e = new Event(varDecl.Name, type, eventDeclaration.Modifier, region, bodyRegion);
+					c.Events.Add(e);
+				}
+			} else {
+				e = new Event(eventDeclaration.Name, type, eventDeclaration.Modifier, region, bodyRegion);
+				c.Events.Add(e);
+			}
+			return null;
+		}
+		
+		public override object Visit(AST.IndexerDeclaration indexerDeclaration, object data)
+		{
+			DefaultRegion region     = GetRegion(indexerDeclaration.StartLocation, indexerDeclaration.EndLocation);
+			DefaultRegion bodyRegion = GetRegion(indexerDeclaration.BodyStart,     indexerDeclaration.BodyEnd);
+			ParameterCollection parameters = new ParameterCollection();
+			Indexer i = new Indexer(new ReturnType(indexerDeclaration.TypeReference), parameters, indexerDeclaration.Modifier, region, bodyRegion);
+			if (indexerDeclaration.Parameters != null) {
+				foreach (AST.ParameterDeclarationExpression par in indexerDeclaration.Parameters) {
+					ReturnType parType = new ReturnType(par.TypeReference);
+					Parameter p = new Parameter(par.ParameterName, parType);
+					parameters.Add(p);
+				}
+			}
+			Class c = (Class)currentClass.Peek();
+			c.Indexer.Add(i);
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/Parser.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/Parser.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/Parser.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,104 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Drawing;
+using System.Collections;
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+using JavaBinding.Parser.SharpDevelopTree;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser
+{
+	public class TParser : IParser
+	{
+		///&lt;summary&gt;IParser Interface&lt;/summary&gt; 
+		string[] lexerTags;
+		public string[] LexerTags {
+			set {
+				lexerTags = value;
+			}
+		}
+		public IExpressionFinder ExpressionFinder {
+			get {
+				return new ExpressionFinder();
+			}
+		}
+		
+		void RetrieveRegions(CompilationUnit cu, SpecialTracker tracker)
+		{
+			for (int i = 0; i &lt; tracker.CurrentSpecials.Count; ++i) {
+				PreProcessingDirective directive = tracker.CurrentSpecials[i] as PreProcessingDirective;
+				if (directive != null) {
+					if (directive.Cmd == &quot;#region&quot;) {
+						int deep = 1; 
+						for (int j = i + 1; j &lt; tracker.CurrentSpecials.Count; ++j) {
+							PreProcessingDirective nextDirective = tracker.CurrentSpecials[j] as PreProcessingDirective;
+							if (nextDirective != null) {
+								switch (nextDirective.Cmd) {
+									case &quot;#region&quot;:
+										++deep;
+										break;
+									case &quot;#endregion&quot;:
+										--deep;
+										if (deep == 0) {
+											cu.FoldingRegions.Add(new FoldingRegion(directive.Arg.Trim(), new DefaultRegion(directive.Start, new Point(nextDirective.End.X - 2, nextDirective.End.Y))));
+											goto end;
+										}
+										break;
+								}
+							}
+						}
+						end: ;
+					}
+				}
+			}
+		}
+		
+		public ICompilationUnitBase Parse(string fileName)
+		{
+			Console.WriteLine (&quot;*****&quot;);
+			JRefactory.Parser.Parser p = new JRefactory.Parser.Parser();
+			
+			Lexer lexer = new Lexer(new FileReader(fileName));
+			p.Parse(lexer);
+			
+			JavaVisitor visitor = new JavaVisitor ();
+			visitor.Visit(p.compilationUnit, null);
+			visitor.Cu.ErrorsDuringCompile = p.Errors.count &gt; 0;
+			RetrieveRegions(visitor.Cu, lexer.SpecialTracker);
+			return visitor.Cu;
+		}
+		
+		public ICompilationUnitBase Parse(string fileName, string fileContent)
+		{
+			JRefactory.Parser.Parser p = new JRefactory.Parser.Parser();
+			
+			Lexer lexer = new Lexer(new StringReader(fileContent));
+			p.Parse(lexer);
+			
+			JavaVisitor visitor = new JavaVisitor ();
+			visitor.Visit(p.compilationUnit, null);
+			visitor.Cu.ErrorsDuringCompile = p.Errors.count &gt; 0;
+			visitor.Cu.Tag = p.compilationUnit;
+			RetrieveRegions(visitor.Cu, lexer.SpecialTracker);
+			return visitor.Cu;
+		}
+		
+		public ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName)
+		{
+			return new Resolver().CtrlSpace(parserService, caretLine, caretColumn, fileName);
+		}
+		
+		public ResolveResult Resolve(IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			return new Resolver().Resolve(parserService, expression, caretLineNumber, caretColumn, fileName, fileContent);
+		}
+		
+		///////// IParser Interface END
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/Resolver.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/Resolver.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/Resolver.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,846 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Drawing;
+
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Parser;
+using JavaBinding.Parser.SharpDevelopTree;
+using JRefactory.Parser.AST;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser
+{
+	public class Resolver
+	{
+		IParserService parserService;
+		ICompilationUnit cu;
+		IClass callingClass;
+		LookupTableVisitor lookupTableVisitor;
+		
+		public IParserService ParserService {
+			get {
+				return parserService;
+			}
+		}
+		
+		public ICompilationUnit CompilationUnit {
+			get {
+				return cu;
+			}
+		}
+		
+		public IClass CallingClass {
+			get {
+				return callingClass;
+			}
+		}
+		
+		bool showStatic = false;
+		
+		public bool ShowStatic {
+			get {
+				return showStatic;
+			}
+			
+			set {
+				showStatic = value;
+			}
+		}
+		
+		int caretLine;
+		int caretColumn;
+		
+		public ResolveResult Resolve(IParserService parserService, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			Console.WriteLine(&quot;Start Resolving&quot;);
+			if (expression == null) {
+				return null;
+			}
+			expression = expression.TrimStart(null);
+			if (expression == &quot;&quot;) {
+				return null;
+			}
+			if (expression.StartsWith(&quot;using &quot;)) {
+				// expression[expression.Length - 1] != '.'
+				// the period that causes this Resove() is not part of the expression
+				if (expression[expression.Length - 1] == '.') {
+					return null;
+				}
+				int i;
+				for (i = expression.Length - 1; i &gt;= 0; --i) {
+					if (!(Char.IsLetterOrDigit(expression[i]) || expression[i] == '_' || expression[i] == '.')) {
+						break;
+					}
+				}
+				// no Identifier before the period
+				if (i == expression.Length - 1) {
+					return null;
+				}
+				string t = expression.Substring(i + 1);
+//				Console.WriteLine(&quot;in Using Statement&quot;);
+				string[] namespaces = parserService.GetNamespaceList(t);
+				if (namespaces == null || namespaces.Length &lt;= 0) {
+					return null;
+				}
+				return new ResolveResult(namespaces);
+			}
+			
+			Console.WriteLine(&quot;Not in Using&quot;);
+			this.caretLine     = caretLineNumber;
+			this.caretColumn   = caretColumn;
+			
+			this.parserService = parserService;
+			IParseInformation parseInfo = parserService.GetParseInformation(fileName);
+			JRefactory.Parser.AST.CompilationUnit fileCompilationUnit = parseInfo.MostRecentCompilationUnit.Tag as JRefactory.Parser.AST.CompilationUnit;
+			if (fileCompilationUnit == null) {
+//				JRefactory.Parser.Parser fileParser = new JRefactory.Parser.Parser();
+//				fileParser.Parse(new Lexer(new StringReader(fileContent)));
+				Console.WriteLine(&quot;!Warning: no parseinformation!&quot;);
+				return null;
+			}
+			/*
+			//// try to find last expression in original string, it could be like &quot; if (act!=null) act&quot;
+			//// in this case only &quot;act&quot; should be parsed as expression  
+			!!is so!! don't change things that work
+			Expression expr=null;	// tentative expression
+			Lexer l=null;
+			JRefactory.Parser.Parser p = new JRefactory.Parser.Parser();
+			while (expression.Length &gt; 0) {
+				l = new Lexer(new StringReader(expression));
+				expr = p.ParseExpression(l);
+				if (l.LookAhead.val != &quot;&quot; &amp;&amp; expression.LastIndexOf(l.LookAhead.val) &gt;= 0) {
+					if (expression.Substring(expression.LastIndexOf(l.LookAhead.val) + l.LookAhead.val.Length).Length &gt; 0) 
+						expression=expression.Substring(expression.LastIndexOf(l.LookAhead.val) + l.LookAhead.val.Length).Trim();
+					else {
+						expression=l.LookAhead.val.Trim();
+						l=new Lexer(new StringReader(expression));
+						expr=p.ParseExpression(l);
+						break;
+					}
+				} else {
+					if (l.Token.val!=&quot;&quot; || expr!=null) break;
+				}
+			}
+			//// here last subexpression should be fixed in expr
+			if it should be changed in expressionfinder don't fix it here
+			*/
+			JRefactory.Parser.Parser p = new JRefactory.Parser.Parser();
+			Lexer l = new Lexer(new StringReader(expression));
+			Expression expr = p.ParseExpression(l);
+			if (expr == null) {
+				return null;
+			}
+			lookupTableVisitor = new LookupTableVisitor();
+			lookupTableVisitor.Visit(fileCompilationUnit, null);
+			
+			TypeVisitor typeVisitor = new TypeVisitor(this);
+			
+			JavaVisitor cSharpVisitor = new JavaVisitor();
+			cu = (ICompilationUnit)cSharpVisitor.Visit(fileCompilationUnit, null);
+			if (cu != null) {
+				callingClass = GetInnermostClass();
+				//Console.WriteLine(&quot;CallingClass is &quot; + callingClass == null ? &quot;null&quot; : callingClass.Name);
+			}
+			//Console.WriteLine(&quot;expression = &quot; + expr.ToString());
+			IReturnType type = expr.AcceptVisitor(typeVisitor, null) as IReturnType;
+			//Console.WriteLine(&quot;type visited&quot;);
+			if (type == null || type.PointerNestingLevel != 0) {
+//				Console.WriteLine(&quot;Type == null || type.PointerNestingLevel != 0&quot;);
+				if (type != null) {
+					//Console.WriteLine(&quot;PointerNestingLevel is &quot; + type.PointerNestingLevel);
+				} else {
+					//Console.WriteLine(&quot;Type == null&quot;);
+				}
+				//// when type is null might be file needs to be reparsed - some vars were lost
+				fileCompilationUnit=parserService.ParseFile(fileName, fileContent).MostRecentCompilationUnit.Tag 
+					as JRefactory.Parser.AST.CompilationUnit;
+				lookupTableVisitor.Visit(fileCompilationUnit,null);
+				cu = (ICompilationUnit)cSharpVisitor.Visit(fileCompilationUnit, null);
+				if (cu != null) {
+					callingClass = GetInnermostClass();
+				}
+				type=expr.AcceptVisitor(typeVisitor,null) as IReturnType;
+				if (type==null)	return null;
+			}
+			if (type.ArrayDimensions != null &amp;&amp; type.ArrayDimensions.Length &gt; 0) {
+				type = new ReturnType(&quot;System.Array&quot;);
+			}
+			Console.WriteLine(&quot;Here: Type is &quot; + type.FullyQualifiedName);
+			IClass returnClass = SearchType(type.FullyQualifiedName, cu);
+			if (returnClass == null) {
+				// Try if type is Namespace:
+				string n = SearchNamespace(type.FullyQualifiedName, cu);
+				if (n == null) {
+					return null;
+				}
+				ArrayList content = parserService.GetNamespaceContents(n);
+				ArrayList classes = new ArrayList();
+				for (int i = 0; i &lt; content.Count; ++i) {
+					if (content[i] is IClass) {
+						classes.Add((IClass)content[i]);
+					}
+				}
+				string[] namespaces = parserService.GetNamespaceList(n);
+				return new ResolveResult(namespaces, classes);
+			}
+			Console.WriteLine(&quot;Returning Result!&quot;);
+			return new ResolveResult(returnClass, ListMembers(new ArrayList(), returnClass));
+		}
+		
+		ArrayList ListMembers(ArrayList members, IClass curType)
+		{
+//			Console.WriteLine(&quot;LIST MEMBERS!!!&quot;);
+//			Console.WriteLine(&quot;showStatic = &quot; + showStatic);
+//			Console.WriteLine(curType.InnerClasses.Count + &quot; classes&quot;);
+//			Console.WriteLine(curType.Properties.Count + &quot; properties&quot;);
+//			Console.WriteLine(curType.Methods.Count + &quot; methods&quot;);
+//			Console.WriteLine(curType.Events.Count + &quot; events&quot;);
+//			Console.WriteLine(curType.Fields.Count + &quot; fields&quot;);
+			if (showStatic) {
+				foreach (IClass c in curType.InnerClasses) {
+					if (IsAccessible(curType, c)) {
+						members.Add(c);
+//						Console.WriteLine(&quot;Member added&quot;);
+					}
+				}
+			}
+			foreach (IProperty p in curType.Properties) {
+				if (MustBeShowen(curType, p)) {
+					members.Add(p);
+//					Console.WriteLine(&quot;Member added&quot;);
+				} else {
+					//// for some public static properties msutbeshowen is false, so additional check
+					//// this is lame fix because curType doesn't allow to find out if to show only
+					//// static public or simply public properties
+					if (((AbstractMember)p).ReturnType!=null) {
+						// if public add it to completion window
+						if (((AbstractDecoration)p).IsPublic) members.Add(p);
+//						Console.WriteLine(&quot;Property {0} added&quot;, p.FullyQualifiedName);
+					}
+				}
+			}
+//			Console.WriteLine(&quot;ADDING METHODS!!!&quot;);
+			foreach (IMethod m in curType.Methods) {
+//				Console.WriteLine(&quot;Method : &quot; + m);
+				if (MustBeShowen(curType, m)) {
+					members.Add(m);
+//					Console.WriteLine(&quot;Member added&quot;);
+				}
+			}
+			foreach (IEvent e in curType.Events) {
+				if (MustBeShowen(curType, e)) {
+					members.Add(e);
+//					Console.WriteLine(&quot;Member added&quot;);
+				}
+			}
+			foreach (IField f in curType.Fields) {
+				if (MustBeShowen(curType, f)) {
+					members.Add(f);
+//					Console.WriteLine(&quot;Member added&quot;);
+				} else {
+					//// enum fields must be shown here if present
+					if (curType.ClassType == ClassType.Enum) {
+						if (IsAccessible(curType,f)) members.Add(f);
+//						Console.WriteLine(&quot;Member {0} added&quot;, f.FullyQualifiedName);
+					}
+				}
+			}
+//			Console.WriteLine(&quot;ClassType = &quot; + curType.ClassType);
+			if (curType.ClassType == ClassType.Interface &amp;&amp; !showStatic) {
+				foreach (string s in curType.BaseTypes) {
+					IClass baseClass = SearchType(s, curType.CompilationUnit);
+					if (baseClass != null &amp;&amp; baseClass.ClassType == ClassType.Interface) {
+						ListMembers(members, baseClass);
+					}
+				}
+			} else {
+				IClass baseClass = BaseClass(curType);
+				if (baseClass != null) {
+//					Console.WriteLine(&quot;Base Class = &quot; + baseClass.FullyQualifiedName);
+					ListMembers(members, baseClass);
+				}
+			}
+//			Console.WriteLine(&quot;listing finished&quot;);
+			return members;
+		}
+		
+		public IClass BaseClass(IClass curClass)
+		{
+			foreach (string s in curClass.BaseTypes) {
+				IClass baseClass = SearchType(s, curClass.CompilationUnit);
+				if (baseClass != null &amp;&amp; baseClass.ClassType != ClassType.Interface) {
+					return baseClass;
+				}
+			}
+			return null;
+		}
+		
+		bool InStatic()
+		{
+			IProperty property = GetProperty();
+			if (property != null) {
+				return property.IsStatic;
+			}
+			IMethod method = GetMethod();
+			if (method != null) {
+				return method.IsStatic;
+			}
+			return false;
+		}
+		
+		bool IsAccessible(IClass c, IDecoration member)
+		{
+//			Console.WriteLine(&quot;member.Modifiers = &quot; + member.Modifiers);
+			if ((member.Modifiers &amp; ModifierEnum.Internal) == ModifierEnum.Internal) {
+				return false;
+			}
+			if ((member.Modifiers &amp; ModifierEnum.Public) == ModifierEnum.Public) {
+//				Console.WriteLine(&quot;IsAccessible&quot;);
+				return true;
+			}
+			if ((member.Modifiers &amp; ModifierEnum.Protected) == ModifierEnum.Protected &amp;&amp; IsClassInInheritanceTree(c, callingClass)) {
+//				Console.WriteLine(&quot;IsAccessible&quot;);
+				return true;
+			}
+			return c.FullyQualifiedName == callingClass.FullyQualifiedName;
+		}
+		
+		bool MustBeShowen(IClass c, IDecoration member)
+		{
+//			Console.WriteLine(&quot;member:&quot; + member.Modifiers);
+			if ((!showStatic &amp;&amp;  ((member.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static)) ||
+			    ( showStatic &amp;&amp; !((member.Modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static))) {
+				//// enum type fields are not shown here - there is no info in member about enum field
+				return false;
+			}
+//			Console.WriteLine(&quot;Testing Accessibility&quot;);
+			return IsAccessible(c, member);
+		}
+		
+		public ArrayList SearchMethod(IReturnType type, string memberName)
+		{
+			if (type == null || type.PointerNestingLevel != 0) {
+				return new ArrayList();
+			}
+			IClass curType;
+			if (type.ArrayDimensions != null &amp;&amp; type.ArrayDimensions.Length &gt; 0) {
+				curType = SearchType(&quot;System.Array&quot;, null);
+			} else {
+				curType = SearchType(type.FullyQualifiedName, null);
+				if (curType == null) {
+					return new ArrayList();
+				}
+			}
+			return SearchMethod(new ArrayList(), curType, memberName);
+		}
+		
+		ArrayList SearchMethod(ArrayList methods, IClass curType, string memberName)
+		{
+			foreach (IMethod m in curType.Methods) {
+				if (m.Name == memberName &amp;&amp;
+				    MustBeShowen(curType, m) &amp;&amp;
+				    !((m.Modifiers &amp; ModifierEnum.Override) == ModifierEnum.Override)) {
+					methods.Add(m);
+				}
+			}
+			IClass baseClass = BaseClass(curType);
+			if (baseClass != null) {
+				return SearchMethod(methods, baseClass, memberName);
+			}
+			showStatic = false;
+			return methods;
+		}
+		
+		public ArrayList SearchIndexer(IReturnType type)
+		{
+			IClass curType = SearchType(type.FullyQualifiedName, null);
+			if (curType != null) {
+				return SearchIndexer(new ArrayList(), curType);
+			}
+			return new ArrayList();
+		}
+		
+		public ArrayList SearchIndexer(ArrayList indexer, IClass curType)
+		{
+			foreach (IIndexer i in curType.Indexer) {
+				if (MustBeShowen(curType, i) &amp;&amp; !((i.Modifiers &amp; ModifierEnum.Override) == ModifierEnum.Override)) {
+					indexer.Add(i);
+				}
+			}
+			IClass baseClass = BaseClass(curType);
+			if (baseClass != null) {
+				return SearchIndexer(indexer, baseClass);
+			}
+			showStatic = false;
+			return indexer;
+		}
+		
+		// no methods or indexer
+		public IReturnType SearchMember(IReturnType type, string memberName)
+		{
+			if (type == null || memberName == null || memberName == &quot;&quot;) {
+				return null;
+			}
+//			Console.WriteLine(&quot;searching member {0} in {1}&quot;, memberName, type.Name);
+			IClass curType = SearchType(type.FullyQualifiedName, cu);
+			if (curType == null) {
+//				Console.WriteLine(&quot;Type not found in SearchMember&quot;);
+				return null;
+			}
+			if (type.PointerNestingLevel != 0) {
+				return null;
+			}
+			if (type.ArrayDimensions != null &amp;&amp; type.ArrayDimensions.Length &gt; 0) {
+				curType = SearchType(&quot;System.Array&quot;, null);
+			}
+			if (curType.ClassType == ClassType.Enum) {
+				foreach (IField f in curType.Fields) {
+					if (f.Name == memberName &amp;&amp; MustBeShowen(curType, f)) {
+						showStatic = false;
+						return type; // enum members have the type of the enum
+					}
+				}
+			}
+			if (showStatic) {
+//				Console.WriteLine(&quot;showStatic == true&quot;);
+				foreach (IClass c in curType.InnerClasses) {
+					if (c.Name == memberName &amp;&amp; IsAccessible(curType, c)) {
+						return new ReturnType(c.FullyQualifiedName);
+					}
+				}
+			}
+//			Console.WriteLine(&quot;#Properties &quot; + curType.Properties.Count);
+			foreach (IProperty p in curType.Properties) {
+//				Console.WriteLine(&quot;checke Property &quot; + p.Name);
+//				Console.WriteLine(&quot;member name &quot; + memberName);
+				if (p.Name == memberName &amp;&amp; MustBeShowen(curType, p)) {
+//					Console.WriteLine(&quot;Property found &quot; + p.Name);
+					showStatic = false;
+					return p.ReturnType;
+				}
+			}
+			foreach (IField f in curType.Fields) {
+//				Console.WriteLine(&quot;checke Feld &quot; + f.Name);
+//				Console.WriteLine(&quot;member name &quot; + memberName);
+				if (f.Name == memberName &amp;&amp; MustBeShowen(curType, f)) {
+//					Console.WriteLine(&quot;Field found &quot; + f.Name);
+					showStatic = false;
+					return f.ReturnType;
+				}
+			}
+			foreach (IEvent e in curType.Events) {
+				if (e.Name == memberName &amp;&amp; MustBeShowen(curType, e)) {
+					showStatic = false;
+					return e.ReturnType;
+				}
+			}
+			foreach (string baseType in curType.BaseTypes) {
+				IClass c = SearchType(baseType, curType.CompilationUnit);
+				if (c != null) {
+					IReturnType erg = SearchMember(new ReturnType(c.FullyQualifiedName), memberName);
+					if (erg != null) {
+						return erg;
+					}
+				}
+			}
+			return null;
+		}
+		
+		bool IsInside(Point between, Point start, Point end)
+		{
+			if (between.Y &lt; start.Y || between.Y &gt; end.Y) {
+//				Console.WriteLine(&quot;Y = {0} not between {1} and {2}&quot;, between.Y, start.Y, end.Y);
+				return false;
+			}
+			if (between.Y &gt; start.Y) {
+				if (between.Y &lt; end.Y) {
+					return true;
+				}
+				// between.Y == end.Y
+//				Console.WriteLine(&quot;between.Y = {0} == end.Y = {1}&quot;, between.Y, end.Y);
+//				Console.WriteLine(&quot;returning {0}:, between.X = {1} &lt;= end.X = {2}&quot;, between.X &lt;= end.X, between.X, end.X);
+				return between.X &lt;= end.X;
+			}
+			// between.Y == start.Y
+//			Console.WriteLine(&quot;between.Y = {0} == start.Y = {1}&quot;, between.Y, start.Y);
+			if (between.X &lt; start.X) {
+				return false;
+			}
+			// start is OK and between.Y &lt;= end.Y
+			return between.Y &lt; end.Y || between.X &lt;= end.X;
+		}
+		
+		ReturnType SearchVariable(string name)
+		{
+//			Console.WriteLine(&quot;Searching Variable&quot;);
+//			
+//			Console.WriteLine(&quot;LookUpTable has {0} entries&quot;, lookupTableVisitor.variables.Count);
+//			Console.WriteLine(&quot;Listing Variables:&quot;);
+			IDictionaryEnumerator enumerator = lookupTableVisitor.variables.GetEnumerator();
+			while (enumerator.MoveNext()) {
+				Console.WriteLine(enumerator.Key);
+			}
+//			Console.WriteLine(&quot;end listing&quot;);
+			ArrayList variables = (ArrayList)lookupTableVisitor.variables[name];
+			if (variables == null || variables.Count &lt;= 0) {
+//				Console.WriteLine(name + &quot; not in LookUpTable&quot;);
+				return null;
+			}
+			
+			ReturnType found = null;
+			foreach (LocalLookupVariable v in variables) {
+//				Console.WriteLine(&quot;Position: ({0}/{1})&quot;, v.StartPos, v.EndPos);
+				if (IsInside(new Point(caretColumn, caretLine), v.StartPos, v.EndPos)) {
+					found = new ReturnType(v.TypeRef);
+//					Console.WriteLine(&quot;Variable found&quot;);
+					break;
+				}
+			}
+			if (found == null) {
+//				Console.WriteLine(&quot;No Variable found&quot;);
+				return null;
+			}
+			return found;
+		}
+		
+		/// &lt;remarks&gt;
+		/// does the dynamic lookup for the typeName
+		/// &lt;/remarks&gt;
+		public IReturnType DynamicLookup(string typeName)
+		{
+//			Console.WriteLine(&quot;starting dynamic lookup&quot;);
+//			Console.WriteLine(&quot;name == &quot; + typeName);
+			
+			// try if it exists a variable named typeName
+			ReturnType variable = SearchVariable(typeName);
+			if (variable != null) {
+				showStatic = false;
+				return variable;
+			}
+//			Console.WriteLine(&quot;No Variable found&quot;);
+			
+			if (callingClass == null) {
+				return null;
+			}
+			//// somehow search in callingClass fields is not returning anything, so I am searching here once again
+			foreach (IField f in callingClass.Fields) {
+				if (f.Name == typeName) {
+//					Console.WriteLine(&quot;Field found &quot; + f.Name);
+					return f.ReturnType;
+				}
+			}
+			//// end of mod for search in Fields
+		
+			// try if typeName is a method parameter
+			IReturnType p = SearchMethodParameter(typeName);
+			if (p != null) {
+//				Console.WriteLine(&quot;MethodParameter Found&quot;);
+				showStatic = false;
+				return p;
+			}
+//			Console.WriteLine(&quot;No Parameter found&quot;);
+			
+			// check if typeName == value in set method of a property
+			if (typeName == &quot;value&quot;) {
+				p = SearchProperty();
+				if (p != null) {
+					showStatic = false;
+					return p;
+				}
+			}
+//			Console.WriteLine(&quot;No Property found&quot;);
+			
+			// try if there exists a nonstatic member named typeName
+			showStatic = false;
+			IReturnType t = SearchMember(callingClass == null ? null : new ReturnType(callingClass.FullyQualifiedName), typeName);
+			if (t != null) {
+				return t;
+			}
+//			Console.WriteLine(&quot;No nonstatic member found&quot;);
+			
+			// try if there exists a static member named typeName
+			showStatic = true;
+			t = SearchMember(callingClass == null ? null : new ReturnType(callingClass.FullyQualifiedName), typeName);
+			if (t != null) {
+				showStatic = false;
+				return t;
+			}
+//			Console.WriteLine(&quot;No static member found&quot;);
+			
+			// try if there exists a static member in outer classes named typeName
+			ClassCollection classes = GetOuterClasses();
+			foreach (IClass c in GetOuterClasses()) {
+				t = SearchMember(callingClass == null ? null : new ReturnType(c.FullyQualifiedName), typeName);
+				if (t != null) {
+					showStatic = false;
+					return t;
+				}
+			}
+//			Console.WriteLine(&quot;No static member in outer classes found&quot;);
+//			Console.WriteLine(&quot;DynamicLookUp resultless&quot;);
+			return null;
+		}
+		
+		IProperty GetProperty()
+		{
+			foreach (IProperty property in callingClass.Properties) {
+				if (property.BodyRegion != null &amp;&amp; property.BodyRegion.IsInside(caretLine, caretColumn)) {
+					return property;
+				}
+			}
+			return null;
+		}
+		
+		IMethod GetMethod()
+		{
+			foreach (IMethod method in callingClass.Methods) {
+				if (method.BodyRegion != null &amp;&amp; method.BodyRegion.IsInside(caretLine, caretColumn)) {
+					return method;
+				}
+			}
+			return null;
+		}
+		
+		IReturnType SearchProperty()
+		{
+			IProperty property = GetProperty();
+			if (property == null) {
+				return null;
+			}
+			if (property.SetterRegion != null &amp;&amp; property.SetterRegion.IsInside(caretLine, caretColumn)) {
+				return property.ReturnType;
+			}
+			return null;
+		}
+		
+		IReturnType SearchMethodParameter(string parameter)
+		{
+			IMethod method = GetMethod();
+			if (method == null) {
+				Console.WriteLine(&quot;Method not found&quot;);
+				return null;
+			}
+			foreach (IParameter p in method.Parameters) {
+				if (p.Name == parameter) {
+					Console.WriteLine(&quot;Parameter found&quot;);
+					return p.ReturnType;
+				}
+			}
+			return null;
+		}
+		
+		/// &lt;remarks&gt;
+		/// use the usings to find the correct name of a namespace
+		/// &lt;/remarks&gt;
+		public string SearchNamespace(string name, ICompilationUnit unit)
+		{
+			if (parserService.NamespaceExists(name)) {
+				return name;
+			}
+			if (unit == null) {
+//				Console.WriteLine(&quot;done, resultless&quot;);
+				return null;
+			}
+			foreach (IUsing u in unit.Usings) {
+				if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
+					string nameSpace = u.SearchNamespace(name);
+					if (nameSpace != null) {
+						return nameSpace;
+					}
+				}
+			}
+//			Console.WriteLine(&quot;done, resultless&quot;);
+			return null;
+		}
+		
+		/// &lt;remarks&gt;
+		/// use the usings and the name of the namespace to find a class
+		/// &lt;/remarks&gt;
+		public IClass SearchType(string name, ICompilationUnit unit)
+		{
+//			Console.WriteLine(&quot;Searching Type &quot; + name);
+			if (name == null || name == String.Empty) {
+//				Console.WriteLine(&quot;No Name!&quot;);
+				return null;
+			}
+			IClass c;
+			c = parserService.GetClass(name);
+			if (c != null) {
+//				Console.WriteLine(&quot;Found!&quot;);
+				return c;
+			}
+//			Console.WriteLine(&quot;No FullName&quot;);
+			if (unit != null) {
+//				Console.WriteLine(unit.Usings.Count + &quot; Usings&quot;);
+				foreach (IUsing u in unit.Usings) {
+					if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
+//						Console.WriteLine(&quot;In UsingRegion&quot;);
+						c = u.SearchType(name);
+						if (c != null) {
+//							Console.WriteLine(&quot;SearchType Successfull!!!&quot;);
+							return c;
+						}
+					}
+				}
+			}
+			if (callingClass == null) {
+				return null;
+			}
+			string fullname = callingClass.FullyQualifiedName;
+			string[] namespaces = fullname.Split(new char[] {'.'});
+			string curnamespace = namespaces[0] + '.';
+			for (int i = 1; i &lt; namespaces.Length; ++i) {
+				c = parserService.GetClass(curnamespace + name);
+				if (c != null) {
+					return c;
+				}
+				curnamespace += namespaces[i] + '.';
+			}
+			return null;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns true, if class possibleBaseClass is in the inheritance tree from c
+		/// &lt;/remarks&gt;
+		bool IsClassInInheritanceTree(IClass possibleBaseClass, IClass c)
+		{
+			if (possibleBaseClass == null || c == null) {
+				return false;
+			}
+			if (possibleBaseClass.FullyQualifiedName == c.FullyQualifiedName) {
+				return true;
+			}
+			foreach (string baseClass in c.BaseTypes) {
+				if (IsClassInInheritanceTree(possibleBaseClass, SearchType(baseClass, cu))) {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns the innerst class in which the carret currently is, returns null
+		/// if the carret is outside any class boundaries.
+		/// &lt;/remarks&gt;
+		IClass GetInnermostClass()
+		{
+			if (cu != null) {
+				foreach (IClass c in cu.Classes) {
+					if (c != null &amp;&amp; c.Region != null &amp;&amp; c.Region.IsInside(caretLine, caretColumn)) {
+						return GetInnermostClass(c);
+					}
+				}
+			}
+			return null;
+		}
+		
+		IClass GetInnermostClass(IClass curClass)
+		{
+			if (curClass == null) {
+				return null;
+			}
+			if (curClass.InnerClasses == null) {
+				return curClass;
+			}
+			foreach (IClass c in curClass.InnerClasses) {
+				if (c != null &amp;&amp; c.Region != null &amp;&amp; c.Region.IsInside(caretLine, caretColumn)) {
+					return GetInnermostClass(c);
+				}
+			}
+			return curClass;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns all (nestet) classes in which the carret currently is exept
+		/// the innermost class, returns an empty collection if the carret is in 
+		/// no class or only in the innermost class.
+		/// the most outer class is the last in the collection.
+		/// &lt;/remarks&gt;
+		ClassCollection GetOuterClasses()
+		{
+			ClassCollection classes = new ClassCollection();
+			if (cu != null) {
+				foreach (IClass c in cu.Classes) {
+					if (c != null &amp;&amp; c.Region != null &amp;&amp; c.Region.IsInside(caretLine, caretColumn)) {
+						if (c != GetInnermostClass()) {
+							GetOuterClasses(classes, c);
+							classes.Add(c);
+						}
+						break;
+					}
+				}
+			}
+			
+			return classes;
+		}
+		
+		void GetOuterClasses(ClassCollection classes, IClass curClass)
+		{
+			if (curClass != null) {
+				foreach (IClass c in curClass.InnerClasses) {
+					if (c != null &amp;&amp; c.Region != null &amp;&amp; c.Region.IsInside(caretLine, caretColumn)) {
+						if (c != GetInnermostClass()) {
+							GetOuterClasses(classes, c);
+							classes.Add(c);
+						}
+						break;
+					}
+				}
+			}
+		}
+		
+		public ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName)
+		{
+			ArrayList result = new ArrayList();
+			this.parserService = parserService;
+			IParseInformation parseInfo = parserService.GetParseInformation(fileName);
+			JRefactory.Parser.AST.CompilationUnit fileCompilationUnit = parseInfo.MostRecentCompilationUnit.Tag as JRefactory.Parser.AST.CompilationUnit;
+			if (fileCompilationUnit == null) {
+				Console.WriteLine(&quot;!Warning: no parseinformation!&quot;);
+				return null;
+			}
+			lookupTableVisitor = new LookupTableVisitor();
+			lookupTableVisitor.Visit(fileCompilationUnit, null);
+			JavaVisitor cSharpVisitor = new JavaVisitor ();
+			cu = (ICompilationUnit)cSharpVisitor.Visit(fileCompilationUnit, null);
+			if (cu != null) {
+				callingClass = GetInnermostClass();
+//				Console.WriteLine(&quot;CallingClass is &quot; + callingClass == null ? &quot;null&quot; : callingClass.Name);
+			}
+			foreach (string name in lookupTableVisitor.variables.Keys) {
+				ArrayList variables = (ArrayList)lookupTableVisitor.variables[name];
+				if (variables != null &amp;&amp; variables.Count &gt; 0) {
+					foreach (LocalLookupVariable v in variables) {
+						if (IsInside(new Point(caretColumn, caretLine), v.StartPos, v.EndPos)) {
+							result.Add(v);
+							break;
+						}
+					}
+				}
+			}
+			if (callingClass != null) {
+				result = ListMembers(result, callingClass);
+			}
+			string n = &quot;&quot;;
+			result.AddRange(parserService.GetNamespaceContents(n));
+			foreach (IUsing u in cu.Usings) {
+				if (u != null &amp;&amp; (u.Region == null || u.Region.IsInside(caretLine, caretColumn))) {
+					foreach (string name in u.Usings) {
+						result.AddRange(parserService.GetNamespaceContents(name));
+					}
+					foreach (string alias in u.Aliases.Keys) {
+						result.Add(alias);
+					}
+				}
+			}
+			return result;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/AttributeSection.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/AttributeSection.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/AttributeSection.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,25 @@
+// created on 08.09.2003 at 16:17
+
+using MonoDevelop.Internal.Parser;
+using System.Collections;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class AttributeSection : AbstractAttributeSection
+	{
+		public AttributeSection(AttributeTarget attributeTarget,
+		                        AttributeCollection attributes) {
+			this.attributeTarget = attributeTarget;
+			this.attributes = attributes;
+		}
+	}
+	public class ASTAttribute : AbstractAttribute
+	{
+		public ASTAttribute(string name, ArrayList positionalArguments, SortedList namedArguments)
+		{
+			this.name = name;
+			this.positionalArguments = positionalArguments;
+			this.namedArguments = namedArguments;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Class.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Class.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Class.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,65 @@
+// created on 06.08.2003 at 12:37
+
+using System.Diagnostics;
+
+using MonoDevelop.Internal.Parser;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class Class : AbstractClass
+	{
+		ICompilationUnit cu;
+		
+		public Class(CompilationUnit cu, ClassType t, Modifier m, IRegion region)
+		{
+			this.cu = cu;
+			classType = t;
+			this.region = region;
+			modifiers = (ModifierEnum)m;
+		}
+		
+		public void UpdateModifier()
+		{
+			if (classType == ClassType.Enum) {
+				foreach (Field f in fields) {
+					f.AddModifier(ModifierEnum.Public);
+				}
+				return;
+			}
+			if (classType != ClassType.Interface) {
+				return;
+			}
+			foreach (Class c in innerClasses) {
+				c.modifiers = c.modifiers | ModifierEnum.Public;
+			}
+			foreach (IMethod m in methods) {
+				if (m is Constructor) {
+					((Constructor)m).AddModifier(ModifierEnum.Public);
+				} else if (m is Method) {
+					((Method)m).AddModifier(ModifierEnum.Public);
+				} else {
+					Debug.Assert(false, &quot;Unexpected type in method of interface. Can not set modifier to public!&quot;);
+				}
+			}
+			foreach (Event e in events) {
+				e.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Field f in fields) {
+				f.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Indexer i in indexer) {
+				i.AddModifier(ModifierEnum.Public);
+			}
+			foreach (Property p in properties) {
+				p.AddModifier(ModifierEnum.Public);
+			}
+			
+		}
+		public override ICompilationUnit CompilationUnit {
+			get {
+				return cu;
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/CompilationUnit.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/CompilationUnit.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/CompilationUnit.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,26 @@
+// created on 04.08.2003 at 17:31
+
+using MonoDevelop.Internal.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class CompilationUnit : AbstractCompilationUnit
+	{
+		
+		public override CommentCollection MiscComments {
+			get {
+				return null;
+			}
+		}
+		public override CommentCollection DokuComments {
+			get {
+				return null;
+			}
+		}
+		public override TagCollection TagComments {
+			get {
+				return null;
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Constructor.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Constructor.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Constructor.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,23 @@
+// created on 06.08.2003 at 12:35
+
+using MonoDevelop.Internal.Parser;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class Constructor : AbstractMethod
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Constructor(Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = &quot;#ctor&quot;;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Event.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Event.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Event.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,24 @@
+// created on 06.08.2003 at 12:30
+
+using MonoDevelop.Internal.Parser;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class Event : AbstractEvent
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Event(string name, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = name;
+			returnType         = type;
+			this.region        = region;
+			this.bodyRegion    = bodyRegion;
+			modifiers          = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Field.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Field.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Field.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,23 @@
+// created on 04.08.2003 at 18:06
+
+using MonoDevelop.Internal.Parser;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class Field : AbstractField
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Field(ReturnType type, string fullyQualifiedName, Modifier m, IRegion region)
+		{
+			this.returnType = type;
+			this.FullyQualifiedName = fullyQualifiedName;
+			this.region = region;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Indexer.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Indexer.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Indexer.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,24 @@
+// created on 06.08.2003 at 12:34
+
+using MonoDevelop.Internal.Parser;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class Indexer : AbstractIndexer
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Indexer(ReturnType type, ParameterCollection parameters, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			returnType      = type;
+			this.parameters = parameters;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Method.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Method.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Method.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,24 @@
+// created on 06.08.2003 at 12:35
+using System;
+using MonoDevelop.Internal.Parser;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class Method : AbstractMethod
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Method(string name, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			FullyQualifiedName = name;
+			returnType = type;
+			this.region     = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Parameter.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Parameter.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Parameter.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,15 @@
+// created on 07.08.2003 at 20:12
+
+using MonoDevelop.Internal.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class Parameter : AbstractParameter
+	{
+		public Parameter(string name, ReturnType type)
+		{
+			this.name = name;
+			returnType = type;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Property.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Property.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/Property.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,24 @@
+// created on 06.08.2003 at 12:36
+
+using MonoDevelop.Internal.Parser;
+using JRefactory.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class Property : AbstractProperty
+	{
+		public void AddModifier(ModifierEnum m)
+		{
+			modifiers = modifiers | m;
+		}
+		
+		public Property(string fullyQualifiedName, ReturnType type, Modifier m, IRegion region, IRegion bodyRegion)
+		{
+			this.FullyQualifiedName = fullyQualifiedName;
+			returnType = type;
+			this.region = region;
+			this.bodyRegion = bodyRegion;
+			modifiers = (ModifierEnum)m;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/ReturnType.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/ReturnType.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/SharpDevelopTree/ReturnType.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,50 @@
+// created on 04.08.2003 at 18:08
+
+using MonoDevelop.Internal.Parser;
+
+namespace JavaBinding.Parser.SharpDevelopTree
+{
+	public class ReturnType : AbstractReturnType
+	{
+		public new int PointerNestingLevel {
+			get {
+				return base.pointerNestingLevel;
+			}
+			set {
+				base.pointerNestingLevel = value;
+			}
+		}
+		
+		public new int[] ArrayDimensions {
+			get {
+				return base.arrayDimensions;
+			}
+			set {
+				base.arrayDimensions = value;
+			}
+		}
+		
+		public ReturnType(string fullyQualifiedName)
+		{
+			base.FullyQualifiedName = fullyQualifiedName;
+		}
+		
+		public ReturnType(string fullyQualifiedName, int[] arrayDimensions, int pointerNestingLevel)
+		{
+			this.FullyQualifiedName  = fullyQualifiedName;
+			this.arrayDimensions     = arrayDimensions;
+			this.pointerNestingLevel = pointerNestingLevel;
+		}
+		
+		public ReturnType (JRefactory.Parser.AST.TypeReference type)
+		{
+			base.FullyQualifiedName  = type.SystemType;
+			base.arrayDimensions     = type.RankSpecifier == null ? new int[] { } : type.RankSpecifier;
+			base.pointerNestingLevel = type.PointerNestingLevel;
+		}
+		public ReturnType Clone()
+		{
+			return new ReturnType(FullyQualifiedName, arrayDimensions, pointerNestingLevel);
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/TypeVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/TypeVisitor.cs	2004-04-09 18:35:02 UTC (rev 1424)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/Parser/TypeVisitor.cs	2004-04-09 19:34:10 UTC (rev 1425)
@@ -0,0 +1,307 @@
+// created on 22.08.2003 at 19:02
+
+using System;
+using System.Collections;
+
+using JRefactory.Parser;
+using JRefactory.Parser.AST;
+using JavaBinding.Parser.SharpDevelopTree;
+using MonoDevelop.Internal.Parser;
+
+namespace JavaBinding.Parser
+{
+	public class TypeVisitor : AbstractASTVisitor
+	{
+		Resolver resolver;
+		
+		public TypeVisitor(Resolver resolver)
+		{
+			this.resolver = resolver;
+		}
+		
+		public override object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			if (primitiveExpression.Value != null) {
+//				Console.WriteLine(&quot;Visiting &quot; + primitiveExpression.Value);
+				return new ReturnType(primitiveExpression.Value.GetType().FullName);
+			}
+			return null;
+		}
+		
+		public override object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			// TODO : Operators 
+			return binaryOperatorExpression.Left.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			if (parenthesizedExpression == null) {
+				return null;
+			}
+			return parenthesizedExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(InvocationExpression invocationExpression, object data)
+		{
+			if (invocationExpression.TargetObject is FieldReferenceExpression) {
+				FieldReferenceExpression field = (FieldReferenceExpression)invocationExpression.TargetObject;
+				IReturnType type = field.TargetObject.AcceptVisitor(this, data) as IReturnType;
+				ArrayList methods = resolver.SearchMethod(type, field.FieldName);
+				resolver.ShowStatic = false;
+				if (methods.Count &lt;= 0) {
+					return null;
+				}
+				// TODO: Find the right method
+				return ((IMethod)methods[0]).ReturnType;
+			} else if (invocationExpression.TargetObject is IdentifierExpression) {
+				string id = ((IdentifierExpression)invocationExpression.TargetObject).Identifier;
+				if (resolver.CallingClass == null) {
+					return null;
+				}
+				IReturnType type = new ReturnType(resolver.CallingClass.FullyQualifiedName);
+				ArrayList methods = resolver.SearchMethod(type, id);
+				resolver.ShowStatic = false;
+				if (methods.Count &lt;= 0) {
+					return null;
+				}
+				// TODO: Find the right method
+				return ((IMethod)methods[0]).ReturnType;
+			}
+			// invocationExpression is delegate call
+			IReturnType t = invocationExpression.AcceptChildren(this, data) as IReturnType;
+			if (t == null) {
+				return null;
+			}
+			IClass c = resolver.SearchType(t.FullyQualifiedName, resolver.CompilationUnit);
+			if (c.ClassType == ClassType.Delegate) {
+				ArrayList methods = resolver.SearchMethod(t, &quot;invoke&quot;);
+				if (methods.Count &lt;= 0) {
+					return null;
+				}
+				return ((IMethod)methods[0]).ReturnType;
+			}
+			return null;
+		}
+		
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		{
+			if (fieldReferenceExpression == null) {
+				return null;
+			}
+			
+			IReturnType returnType = fieldReferenceExpression.TargetObject.AcceptVisitor(this, data) as IReturnType;
+			if (returnType != null) {
+				string name = resolver.SearchNamespace(returnType.FullyQualifiedName, resolver.CompilationUnit);
+				if (name != null) {
+					string n = resolver.SearchNamespace(string.Concat(name, &quot;.&quot;, fieldReferenceExpression.FieldName), null);
+					if (n != null) {
+						return new ReturnType(n);
+					}
+					IClass c = resolver.SearchType(string.Concat(name, &quot;.&quot;, fieldReferenceExpression.FieldName), resolver.CompilationUnit);
+					if (c != null) {
+						resolver.ShowStatic = true;
+						return new ReturnType(c.FullyQualifiedName);
+					}
+					return null;
+				}
+				return resolver.SearchMember(returnType, fieldReferenceExpression.FieldName);
+			}
+//			Console.WriteLine(&quot;returnType of child is null!&quot;);
+			return null;
+		}
+		
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		{
+			ReturnType type = pointerReferenceExpression.Expression.AcceptVisitor(this, data) as ReturnType;
+			if (type == null) {
+				return null;
+			}
+			type = type.Clone();
+			--type.PointerNestingLevel;
+			if (type.PointerNestingLevel != 0) {
+				return null;
+			}
+			return resolver.SearchMember(type, pointerReferenceExpression.Identifier);
+		}
+		
+		public override object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			Console.WriteLine(&quot;visiting IdentifierExpression&quot;);
+			if (identifierExpression == null) {
+				return null;
+			}
+			string name = resolver.SearchNamespace(identifierExpression.Identifier, resolver.CompilationUnit);
+			if (name != null) {
+				return new ReturnType(name);
+			}
+			IClass c = resolver.SearchType(identifierExpression.Identifier, resolver.CompilationUnit);
+			if (c != null) {
+				resolver.ShowStatic = true;
+				return new ReturnType(c.FullyQualifiedName);
+			}
+			return resolver.DynamicLookup(identifierExpression.Identifier);
+		}
+		
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			return new ReturnType(typeReferenceExpression.TypeReference);
+		}
+		
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			if (unaryOperatorExpression == null) {
+				return null;
+			}
+			ReturnType expressionType = unaryOperatorExpression.Expression.AcceptVisitor(this, data) as ReturnType;
+			// TODO: Little bug: unary operator MAY change the return type,
+			//                   but that is only a minor issue
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.Not:
+					break;
+				case UnaryOperatorType.BitNot:
+					break;
+				case UnaryOperatorType.Minus:
+					break;
+				case UnaryOperatorType.Plus:
+					break;
+				case UnaryOperatorType.Increment:
+				case UnaryOperatorType.PostIncrement:
+					break;
+				case UnaryOperatorType.Decrement:
+				case UnaryOperatorType.PostDecrement:
+					break;
+				case UnaryOperatorType.Star:       // dereference
+					--expressionType.PointerNestingLevel;
+					break;
+				case UnaryOperatorType.BitWiseAnd: // get reference
+					++expressionType.PointerNestingLevel; 
+					break;
+				case UnaryOperatorType.None:
+					break;
+			}
+			return expressionType;
+		}
+		
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			return assignmentExpression.Left.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
+		{
+			return new ReturnType(&quot;System.Int32&quot;);
+		}
+		
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			return new ReturnType(&quot;System.Type&quot;);
+		}
+		
+		public override object Visit(CheckedExpression checkedExpression, object data)
+		{
+			return checkedExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
+		{
+			return uncheckedExpression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(CastExpression castExpression, object data)
+		{
+			return new ReturnType(castExpression.CastTo.Type);
+		}
+		
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
+		{
+			ReturnType returnType = new ReturnType(stackAllocExpression.Type);
+			++returnType.PointerNestingLevel;
+			return returnType;
+		}
+		
+		public override object Visit(IndexerExpression indexerExpression, object data)
+		{
+			IReturnType type = (IReturnType)indexerExpression.TargetObject.AcceptVisitor(this, data);
+			if (type == null) {
+				return null;
+			}
+			if (type.ArrayDimensions == null || type.ArrayDimensions.Length == 0) {
+				// check if ther is an indexer
+				if (indexerExpression.TargetObject is ThisReferenceExpression) {
+					if (resolver.CallingClass == null) {
+						return null;
+					}
+					type = new ReturnType(resolver.CallingClass.FullyQualifiedName);
+				}
+				ArrayList indexer = resolver.SearchIndexer(type);
+				if (indexer.Count == 0) {
+					return null;
+				}
+				// TODO: get the right indexer
+				return ((IIndexer)indexer[0]).ReturnType;
+			}
+			
+			// TODO: what is a[0] if a is pointer to array or array of pointer ? 
+			if (type.ArrayDimensions[type.ArrayDimensions.Length - 1] != indexerExpression.Indices.Count) {
+				return null;
+			}
+			int[] newArray = new int[type.ArrayDimensions.Length - 1];
+			Array.Copy(type.ArrayDimensions, 0, newArray, 0, type.ArrayDimensions.Length - 1);
+			return new ReturnType(type.Name, newArray, type.PointerNestingLevel);
+		}
+		
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			if (resolver.CallingClass == null) {
+				return null;
+			}
+			return new ReturnType(resolver.CallingClass.FullyQualifiedName);
+		}
+		
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+//			Console.WriteLine(&quot;Visiting base&quot;);
+			if (resolver.CallingClass == null) {
+				return null;
+			}
+			IClass baseClass = resolver.BaseClass(resolver.CallingClass);
+			if (baseClass == null) {
+//				Console.WriteLine(&quot;Base Class not found&quot;);
+				return null;
+			}
+//			Console.WriteLine(&quot;Base Class: &quot; + baseClass.FullyQualifiedName);
+			return new ReturnType(baseClass.FullyQualifiedName);
+		}
+		
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			string name = resolver.SearchType(objectCreateExpression.CreateType.Type, resolver.CompilationUnit).FullyQualifiedName;
+			return new ReturnType(name, objectCreateExpression.CreateType.RankSpecifier, objectCreateExpression.CreateType.PointerNestingLevel);
+		}
+		
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			ReturnType type = new ReturnType(arrayCreateExpression.CreateType);
+			if (arrayCreateExpression.Parameters != null &amp;&amp; arrayCreateExpression.Parameters.Count &gt; 0) {
+				int[] newRank = new int[arrayCreateExpression.Rank.Length + 1];
+				newRank[0] = arrayCreateExpression.Parameters.Count - 1;
+				Array.Copy(type.ArrayDimensions, 0, newRank, 1, type.ArrayDimensions.Length);
+				type.ArrayDimensions = newRank;
+			}
+			return type;
+		}
+		
+		public override object Visit(DirectionExpression directionExpression, object data)
+		{
+			// no calls allowed !!!
+			return null;
+		}
+		
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			// no calls allowed !!!
+			return null;
+		}
+	}
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001031.html">[Monodevelop-patches-list] r1424 - in trunk/MonoDevelop/src/Main/Base: . Commands Gui/HtmlControl Gui/Pads
</A></li>
	<LI>Next message: <A HREF="001033.html">[Monodevelop-patches-list] r1426 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1032">[ date ]</a>
              <a href="thread.html#1032">[ thread ]</a>
              <a href="subject.html#1032">[ subject ]</a>
              <a href="author.html#1032">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
