<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1492 - in branches/MonoDevelop-generate-what/src/Main/Base: . Services/ParserService
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1492%20-%20in%20branches/MonoDevelop-generate-what/src/Main/Base%3A%20.%20Services/ParserService&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001098.html">
   <LINK REL="Next"  HREF="001100.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1492 - in branches/MonoDevelop-generate-what/src/Main/Base: . Services/ParserService</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1492%20-%20in%20branches/MonoDevelop-generate-what/src/Main/Base%3A%20.%20Services/ParserService&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1492 - in branches/MonoDevelop-generate-what/src/Main/Base: . Services/ParserService">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Fri Apr 23 07:08:49 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001098.html">[Monodevelop-patches-list] r1491 - in branches/MonoDevelop-generate-what: build/AddIns src/Main/Base src/Main/Base/Commands src/Main/Base/Gui/CompletionDatabaseWizard src/Main/Base/Gui/Dialogs/OptionPanels/IDEOptions src/Main/Base/Services/ParserService src/Main/Base/Services/Project
</A></li>
        <LI>Next message: <A HREF="001100.html">[Monodevelop-patches-list] r1493 - trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1099">[ date ]</a>
              <a href="thread.html#1099">[ thread ]</a>
              <a href="subject.html#1099">[ subject ]</a>
              <a href="author.html#1099">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: iainmc
Date: 2004-04-23 07:08:49 -0400 (Fri, 23 Apr 2004)
New Revision: 1492

Added:
   branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DatabaseBackedParserService.cs
Removed:
   branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs
Modified:
   branches/MonoDevelop-generate-what/src/Main/Base/ChangeLog
   branches/MonoDevelop-generate-what/src/Main/Base/Makefile.am
   branches/MonoDevelop-generate-what/src/Main/Base/SharpDevelop.prjX
Log:
* Services/ParserService/DefaultParserService.cs: renamed to reflect
change in class name
* Makefile.am, SharpDevelop.prjX: changed to reflect renaming


Modified: branches/MonoDevelop-generate-what/src/Main/Base/ChangeLog
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/ChangeLog	2004-04-23 11:03:04 UTC (rev 1491)
+++ branches/MonoDevelop-generate-what/src/Main/Base/ChangeLog	2004-04-23 11:08:49 UTC (rev 1492)
@@ -1,5 +1,11 @@
 2004-04-23  Iain McCoy &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">iain at mccoy.id.au</A>&gt;
-	* Base/Services/Project/DefaultProjectService.cs
+	(I'd hate to get a changelog entry wrong, wouldn't I?)
+	* Services/ParserService/DefaultParserService.cs: renamed to reflect
+	change in class name
+	* Makefile.am, SharpDevelop.prjX: changed to reflect renaming
+
+2004-04-23  Iain McCoy &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">iain at mccoy.id.au</A>&gt;
+	* Services/Project/DefaultProjectService.cs
 	* Commands/AutostartCommands.cs
 	* Gui/CompletionDatabaseWizard/CreateDBGenerator.cs
 	* Gui/Dialogs/OptionPanels/IDEOptions/BuildPanel.cs

Modified: branches/MonoDevelop-generate-what/src/Main/Base/Makefile.am
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Makefile.am	2004-04-23 11:03:04 UTC (rev 1491)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Makefile.am	2004-04-23 11:08:49 UTC (rev 1492)
@@ -203,7 +203,7 @@
 ./Services/Language/Language.cs \
 ./Services/ClassBrowserIcons/ClassBrowserIconsService.cs \
 ./Services/ResourceNotFoundException.cs \
-./Services/ParserService/DefaultParserService.cs \
+./Services/ParserService/DatabaseBackedParserService.cs \
 ./Services/ParserService/ClassProxyCollection.cs \
 ./Services/ParserService/IParserService.cs \
 ./Services/ParserService/ClassProxy.cs \

Copied: branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DatabaseBackedParserService.cs (from rev 1491, branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs)

Deleted: branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs	2004-04-23 11:03:04 UTC (rev 1491)
+++ branches/MonoDevelop-generate-what/src/Main/Base/Services/ParserService/DefaultParserService.cs	2004-04-23 11:08:49 UTC (rev 1492)
@@ -1,817 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.IO;
-using System.Threading;
-using System.Collections;
-using System.Collections.Utility;
-using System.Diagnostics;
-using System.Reflection;
-using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters;
-using System.Runtime.Serialization.Formatters.Binary;
-using System.Security;
-using System.Security.Permissions;
-using System.Security.Policy;
-using System.Xml;
-
-using MonoDevelop.Core.Properties;
-using MonoDevelop.Core.Services;
-using MonoDevelop.Services;
-using MonoDevelop.Core.AddIns;
-using MonoDevelop.Internal.Project;
-using MonoDevelop.Gui;
-using MonoDevelop.Internal.Parser;
-
-namespace MonoDevelop.Services
-{
-	public class DatabaseBackedParserService : AbstractService, IParserService
-	{
-		Hashtable classes                = new Hashtable();
-		Hashtable caseInsensitiveClasses = new Hashtable();
-		
-		// used to map 'real' namespace hashtable inside case insensitive hashtable
-		const string CaseInsensitiveKey = &quot;__CASE_INSENSITIVE_HASH&quot;;
-		Hashtable namespaces                = new Hashtable();
-		Hashtable caseInsensitiveNamespaces = new Hashtable();
-		
-		Hashtable parsings   = new Hashtable();
-		
-		ParseInformation addedParseInformation = new ParseInformation();
-		ParseInformation removedParseInformation = new ParseInformation();
-
-//// Alex: this one keeps requests for parsing and is used to start parser (pulsed)
-//// otherwise continuous reparsing of files is causing leaks
-//		public static Queue ParserPulse=new Queue();	// required for monitoring when to restart thread
-//// Alex: end of mod
-
-		/// &lt;remarks&gt;
-		/// The keys are the assemblies loaded. This hash table ensures that no
-		/// assembly is loaded twice. I know that strong naming might be better but
-		/// the use case isn't there. No one references 2 differnt files if he references
-		/// the same assembly.
-		/// &lt;/remarks&gt;
-		Hashtable loadedAssemblies = new Hashtable();
-		
-		ClassProxyCollection classProxies = new ClassProxyCollection();
-		IParser[] parser;
-		readonly static string[] assemblyList = {
-			&quot;Microsoft.VisualBasic&quot;,
-			//&quot;Microsoft.JScript&quot;,
-			&quot;mscorlib&quot;,
-			&quot;System.Data&quot;,
-			&quot;System.Design&quot;,
-			&quot;System.DirectoryServices&quot;,
-			&quot;System.Drawing.Design&quot;,
-			&quot;System.Drawing&quot;,
-			&quot;System.EnterpriseServices&quot;,
-			&quot;System.Management&quot;,
-			&quot;System.Messaging&quot;,
-			&quot;System.Runtime.Remoting&quot;,
-			&quot;System.Runtime.Serialization.Formatters.Soap&quot;,
-
-			&quot;System.Security&quot;,
-			&quot;System.ServiceProcess&quot;,
-			&quot;System.Web.Services&quot;,
-			&quot;System.Web&quot;,
-			//&quot;System.Windows.Forms&quot;,
-			&quot;System&quot;,
-			&quot;System.Xml&quot;,
-			&quot;glib-sharp&quot;,
-			&quot;atk-sharp&quot;,
-			&quot;pango-sharp&quot;,
-			&quot;gdk-sharp&quot;,
-			&quot;gtk-sharp&quot;,
-			&quot;gnome-sharp&quot;,
-			&quot;gconf-sharp&quot;,
-			&quot;gtkhtml-sharp&quot;,
-		};
-		
-		public DatabaseBackedParserService()
-		{
-			addedParseInformation.DirtyCompilationUnit = new DummyCompilationUnit();
-			removedParseInformation.DirtyCompilationUnit = new DummyCompilationUnit();
-		}
-		
-		public static string[] AssemblyList {
-			get {
-				return assemblyList;
-			}
-		}
-
-		/// &lt;remarks&gt;
-		/// The initialize method writes the location of the code completion proxy
-		/// file to this string.
-		/// &lt;/remarks&gt;
-		string codeCompletionProxyFile;
-		string codeCompletionMainFile;
-
-		class ClasstableEntry
-		{
-			IClass           myClass;
-			ICompilationUnit myCompilationUnit;
-			string           myFileName;
-
-			public IClass Class {
-				get {
-					return myClass;
-				}
-			}
-
-			public ICompilationUnit CompilationUnit {
-				get {
-					return myCompilationUnit;
-				}
-			}
-
-			public string FileName {
-				get {
-					return myFileName;
-				}
-			}
-
-			public ClasstableEntry(string fileName, ICompilationUnit compilationUnit, IClass c)
-			{
-				this.myCompilationUnit = compilationUnit;
-				this.myFileName        = fileName;
-				this.myClass           = c;
-			}
-		}
-
-		private bool ContinueWithProcess(IProgressMonitor progressMonitor)
-		{
-			while (Gtk.Application.EventsPending ())
-				Gtk.Application.RunIteration ();
-			if (progressMonitor.Canceled)
-				return false;
-			else
-				return true;
-		}
-	
-		public void GenerateCodeCompletionDatabase(string createPath, IProgressMonitor progressMonitor)
-		{
-			SetCodeCompletionFileLocation(createPath);
-
-			// write all classes and proxies to the disc
-			BinaryWriter classWriter = new BinaryWriter(new BufferedStream(new FileStream(codeCompletionMainFile, FileMode.Create, FileAccess.Write, FileShare.None)));
-			BinaryWriter proxyWriter = new BinaryWriter(new BufferedStream(new FileStream(codeCompletionProxyFile, FileMode.Create, FileAccess.Write, FileShare.None)));
-			if (progressMonitor != null) {
-				progressMonitor.BeginTask(&quot;generate code completion database&quot;, assemblyList.Length);
-			}
-			
-			// convert all assemblies
-			for (int i = 0; i &lt; assemblyList.Length; ++i) {
-				try {
-					FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-					string path = fileUtilityService.GetDirectoryNameWithSeparator(System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory());
-
-					AssemblyInformation frameworkAssemblyInformation = new AssemblyInformation();
-					frameworkAssemblyInformation.Load(String.Concat(path, assemblyList[i], &quot;.dll&quot;), false);
-					// create all class proxies
-					foreach (IClass newClass in frameworkAssemblyInformation.Classes) {
-						ClassProxy newProxy = new ClassProxy(newClass);
-						classProxies.Add(newProxy);
-						AddClassToNamespaceList(newProxy);
-
-						PersistentClass pc = new PersistentClass(classProxies, newClass);
-						newProxy.Offset = (uint)classWriter.BaseStream.Position;
-						newProxy.WriteTo(proxyWriter);
-						pc.WriteTo(classWriter);
-					}
-					
-					if (progressMonitor != null) {
-						progressMonitor.Worked(i, &quot;Writing class&quot;);
-					}
-					if (!ContinueWithProcess(progressMonitor))
-						return;
-				} catch (Exception e) {
-					Console.WriteLine(e.ToString());
-				}
-				System.GC.Collect();
-			}
-
-			classWriter.Close();
-			proxyWriter.Close();
-			if (progressMonitor != null) {
-				progressMonitor.Done();
-			}
-		}
-		
-		void SetCodeCompletionFileLocation(string path)
-		{
-			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
-			string codeCompletionTemp = fileUtilityService.GetDirectoryNameWithSeparator(path);
-
-			codeCompletionProxyFile = codeCompletionTemp + &quot;CodeCompletionProxyDataV02.bin&quot;;
-			codeCompletionMainFile  = codeCompletionTemp + &quot;CodeCompletionMainDataV02.bin&quot;;
-		}
-
-		void SetDefaultCompletionFileLocation()
-		{
-			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
-			SetCodeCompletionFileLocation(propertyService.GetProperty(&quot;SharpDevelop.CodeCompletion.DataDirectory&quot;, String.Empty).ToString());
-		}
-
-		public void LoadProxyDataFile()
-		{
-			if (!File.Exists(codeCompletionProxyFile)) {
-				return;
-			}
-			BinaryReader reader = new BinaryReader(new BufferedStream(new FileStream(codeCompletionProxyFile, FileMode.Open, FileAccess.Read, FileShare.Read)));
-			while (true) {
-				try {
-					ClassProxy newProxy = new ClassProxy(reader);
-					classProxies.Add(newProxy);
-					AddClassToNamespaceList(newProxy);
-				} catch (Exception) {
-					break;
-				}
-			}
-			reader.Close();
-		}
-		
-		void LoadThread()
-		{
-			SetDefaultCompletionFileLocation();
-			
-			BinaryFormatter formatter = new BinaryFormatter();
-			
-			if (File.Exists(codeCompletionProxyFile)) {
-				LoadProxyDataFile();
-			}
-		}
-		
-		public override void InitializeService()
-		{
-			parser = (IParser[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/Workspace/Parser&quot;).BuildChildItems(this)).ToArray(typeof(IParser));
-			
-			Thread myThread = new Thread(new ThreadStart(LoadThread));
-			myThread.IsBackground = true;
-			myThread.Priority = ThreadPriority.Lowest;
-			myThread.Start();
-			
-			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
-			projectService.CombineOpened += new CombineEventHandler(OpenCombine);
-		}
-		
-		public void AddReferenceToCompletionLookup(IProject project, ProjectReference reference)
-		{
-			if (reference.ReferenceType != ReferenceType.Project) {
-				string fileName = reference.GetReferencedFileName(project);
-				if (fileName == null || fileName.Length == 0) {
-					return;
-				}
-				foreach (string assemblyName in assemblyList) {
-					if (Path.GetFileNameWithoutExtension(fileName).ToUpper() == assemblyName.ToUpper()) {
-						return;
-					}
-				}
-				// HACK : Don't load references for non C# projects
-				if (project.ProjectType != &quot;C#&quot;) {
-					return;
-				}
-				if (File.Exists(fileName)) {
-					Thread t = new Thread(new ThreadStart(new AssemblyLoader(this, fileName).LoadAssemblyParseInformations));
-					t.Start();
-				}
-			}
-		}
-		
-		class AssemblyLoader
-		{
-			DatabaseBackedParserService parserService;
-			string assemblyFileName;
-			
-			public AssemblyLoader(DatabaseBackedParserService parserService, string assemblyFileName)
-			{
-				this.parserService    = parserService;
-				this.assemblyFileName = assemblyFileName;
-			}
-			
-			public void LoadAssemblyParseInformations()
-			{
-				if (parserService.loadedAssemblies[assemblyFileName] != null) {
-					return;
-				}
-				parserService.loadedAssemblies[assemblyFileName] = true;
-				try {
-					AssemblyInformation assemblyInformation = new AssemblyInformation();
-					assemblyInformation.Load(assemblyFileName, true);
-					foreach (IClass newClass in assemblyInformation.Classes) {
-						parserService.AddClassToNamespaceList(newClass);
-						lock (parserService.classes) {
-							parserService.caseInsensitiveClasses[newClass.FullyQualifiedName.ToLower()] = parserService.classes[newClass.FullyQualifiedName] = new ClasstableEntry(null, null, newClass);
-						}
-					}
-				} catch (Exception e) {
-					Console.WriteLine(&quot;Can't add reference : &quot; + e.ToString());
-				}
-			}
-		}
-		
-		public void OpenCombine(object sender, CombineEventArgs e)
-		{
-			ArrayList projects =  Combine.GetAllProjects(e.Combine);
-			foreach (ProjectCombineEntry entry in projects) {
-				foreach (ProjectReference r in entry.Project.ProjectReferences) {
-					AddReferenceToCompletionLookup(entry.Project, r);
-				}
-			}
-		}
-		
-		public void StartParserThread()
-		{
-			Thread t = new Thread(new ThreadStart(ParserUpdateThread));
-			t.IsBackground  = true;
-			t.Start();
-		}
-		
-		Hashtable lastUpdateSize = new Hashtable();
-		void ParserUpdateThread()
-		{
-// 			string fn=null;
-			while (true) {
-				////Thread.Sleep(1000); // not required
-//// Alex: if some file was pulsed - during editor load and after - get file to reparse
-//				fn = null; // set to null for each repetition
-// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-//	Mike: Doesn't work with folding marker update --&gt; look at the folding markers
-//  Mike: You can't simply BREAK a feature and say I should fix it ... either bring the folding
-//        markers in a working state or leave this change ... I don't see that your change is a good
-//        alternative ... the current parserthread looks at the text and if it changed it reparses ...
-//        it is better than the old version you fixed 
-// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-//				lock(DatabaseBackedParserService.ParserPulse) {
-//					//Console.WriteLine(&quot;Pulse got: {0} entries&quot;,DatabaseBackedParserService.ParserPulse.Count);
-//					Monitor.Wait(DatabaseBackedParserService.ParserPulse);
-//					if (DatabaseBackedParserService.ParserPulse.Count&gt;0) {
-//						fn = (string)DatabaseBackedParserService.ParserPulse.Dequeue();
-//					}
-//				}
-				try {
-					if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null &amp;&amp; WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ActiveViewContent != null) {
-						IEditable editable = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ActiveViewContent as IEditable;
-						if (editable != null) {
-							string fileName = null;
-							
-							IViewContent viewContent = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent;
-							IParseableContent parseableContent = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ActiveViewContent as IParseableContent;
-							
-							if (parseableContent != null) {
-								fileName = parseableContent.ParseableContentName;
-							} else {
-								fileName = viewContent.IsUntitled ? viewContent.UntitledName : viewContent.ContentName;
-							}
-							
-							if (!(fileName == null || fileName.Length == 0)) {
-//								Thread.Sleep(300); // not required 
-								IParseInformation parseInformation = null;
-								bool updated = false;
-								lock (parsings) {
-									string text = editable.Text;
-									
-									if (lastUpdateSize[fileName] == null || (int)lastUpdateSize[fileName] != text.GetHashCode()) {
-										parseInformation = ParseFile(fileName, text);
-										lastUpdateSize[fileName] = text.GetHashCode();
-										updated = true;
-									} 
-								}
-								if (updated) {
-									if (parseInformation != null &amp;&amp; editable is IParseInformationListener) {
-										((IParseInformationListener)editable).ParseInformationUpdated(parseInformation);
-									}
-								}
-//								if (fn != null) {
-//									ParseFile(fn); // TODO: this one should update file parsings requested through queue
-//								}
-							}
-						}
-					}
-				} catch (Exception e) {
-					try {
-						Console.WriteLine(e.ToString());
-					} catch {}
-				}
-				Thread.Sleep(500); // not required
-				System.GC.Collect();
-			}
-		}
-		
-		Hashtable AddClassToNamespaceList(IClass addClass)
-		{
-			string nSpace = addClass.Namespace;
-			if (nSpace == null) {
-				nSpace = String.Empty;
-			}
-			
-			string[] path = nSpace.Split('.');
-			
-			lock (namespaces) {
-				Hashtable cur                = namespaces;
-				Hashtable caseInsensitiveCur = caseInsensitiveNamespaces;
-				
-				for (int i = 0; i &lt; path.Length; ++i) {
-					if (cur[path[i]] == null) {
-						Hashtable hashTable                = new Hashtable();
-						Hashtable caseInsensitivehashTable = new Hashtable();
-						cur[path[i]] = hashTable;
-						caseInsensitiveCur[path[i].ToLower()] = caseInsensitivehashTable;
-						caseInsensitivehashTable[CaseInsensitiveKey] = hashTable;
-					} else {
-						if (!(cur[path[i]] is Hashtable)) {
-							return null;
-						}
-					}
-					cur = (Hashtable)cur[path[i]];
-					caseInsensitiveCur = (Hashtable)caseInsensitiveCur[path[i].ToLower()];
-				}
-				caseInsensitiveCur[addClass.Name.ToLower()] = cur[addClass.Name] = addClass;
-				return cur;
-			}
-		}
-		
-#region Default Parser Layer dependent functions
-		public IClass GetClass(string typeName)
-		{
-			return GetClass(typeName, true);
-		}
-		public IClass GetClass(string typeName, bool caseSensitive)
-		{
-			if (!caseSensitive) {
-				typeName = typeName.ToLower();
-			}
-			
-			ClasstableEntry entry = (caseSensitive ? classes[typeName] : caseInsensitiveClasses[typeName]) as ClasstableEntry;
-			if (entry != null) {
-				return entry.Class;
-			}
-			
-			// try to load the class from our data file
-			int idx = classProxies.IndexOf(typeName, caseSensitive);
-			if (idx &gt; 0) {
-				BinaryReader reader = new BinaryReader(new BufferedStream(new FileStream(codeCompletionMainFile, FileMode.Open, FileAccess.Read, FileShare.Read)));
-				reader.BaseStream.Seek(classProxies[idx].Offset, SeekOrigin.Begin);
-				IClass c = new PersistentClass(reader, classProxies);
-				reader.Close();
-				lock (classes) {
-					caseInsensitiveClasses[typeName.ToLower()] = classes[typeName] = new ClasstableEntry(null, null, c);
-				}
-				return c;
-			}
-			return null;
-		}
-		
-		public string[] GetNamespaceList(string subNameSpace)
-		{
-			return GetNamespaceList(subNameSpace, true);
-		}
-		public string[] GetNamespaceList(string subNameSpace, bool caseSensitive)
-		{
-//			Console.WriteLine(&quot;GetNamespaceList &gt;{0}&lt;&quot;, subNameSpace);
-			
-			System.Diagnostics.Debug.Assert(subNameSpace != null);
-			if (!caseSensitive) {
-				subNameSpace = subNameSpace.ToLower();
-			}
-			
-			string[] path = subNameSpace.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
-			
-			if (subNameSpace.Length &gt; 0) {
-				for (int i = 0; i &lt; path.Length; ++i) {
-					if (!(cur[path[i]] is Hashtable)) {
-						return null;
-					}
-					cur = (Hashtable)cur[path[i]];
-				}
-			}
-			
-			if (!caseSensitive) {
-				cur = (Hashtable)cur[CaseInsensitiveKey];
-			}
-			
-			ArrayList namespaceList = new ArrayList();
-			foreach (DictionaryEntry entry in cur) {
-				if (entry.Value is Hashtable &amp;&amp; entry.Key.ToString().Length &gt; 0) {
-					namespaceList.Add(entry.Key);
-				}
-			}
-			
-			return (string[])namespaceList.ToArray(typeof(string));
-		}
-		
-		public ArrayList GetNamespaceContents(string subNameSpace)
-		{
-			return GetNamespaceContents(subNameSpace, true);
-		}
-		public ArrayList GetNamespaceContents(string subNameSpace, bool caseSensitive)
-		{
-//			Console.WriteLine(&quot;GetNamespaceContents &gt;{0}&lt;&quot;, subNameSpace);
-			
-			ArrayList namespaceList = new ArrayList();
-			if (subNameSpace == null) {
-				return namespaceList;
-			}
-			if (!caseSensitive) {
-				subNameSpace = subNameSpace.ToLower();
-			}
-			
-			string[] path = subNameSpace.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
-			
-			for (int i = 0; i &lt; path.Length; ++i) {
-				if (!(cur[path[i]] is Hashtable)) {
-					return namespaceList;
-				}
-				cur = (Hashtable)cur[path[i]];
-			}
-			
-			if (!caseSensitive) {
-				cur = (Hashtable)cur[CaseInsensitiveKey];
-			}
-			
-			foreach (DictionaryEntry entry in cur)  {
-				if (entry.Value is Hashtable) {
-					namespaceList.Add(entry.Key);
-				} else {
-					namespaceList.Add(entry.Value);
-				}
-			}
-			return namespaceList;
-		}
-		
-		public bool NamespaceExists(string name)
-		{
-			return NamespaceExists(name, true);
-		}
-		public bool NamespaceExists(string name, bool caseSensitive)
-		{
-//			Console.WriteLine(&quot;NamespaceExists &gt;{0}&lt;&quot;, name);
-			if (name == null) {
-				return false;
-			}
-			if (!caseSensitive) {
-				name = name.ToLower();
-			}
-			string[] path = name.Split('.');
-			Hashtable cur = caseSensitive ? namespaces : caseInsensitiveNamespaces;
-			
-			for (int i = 0; i &lt; path.Length; ++i) {
-				if (!(cur[path[i]] is Hashtable)) {
-					return false;
-				}
-				cur = (Hashtable)cur[path[i]];
-			}
-			return true;
-		}
-#endregion
-		
-		public IParseInformation ParseFile(string fileName)
-		{
-			return ParseFile(fileName, null);
-		}
-		
-		public IParseInformation ParseFile(string fileName, string fileContent)
-		{
-			IParser parser = GetParser(fileName);
-			
-			if (parser == null) {
-				return null;
-			}
-			
-			parser.LexerTags = new string[] { &quot;HACK&quot;, &quot;TODO&quot;, &quot;UNDONE&quot;, &quot;FIXME&quot; };
-			
-			ICompilationUnitBase parserOutput = null;
-			
-			if (fileContent == null) {
-				IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
-				if (projectService.CurrentOpenCombine != null) {
-					ArrayList projects = Combine.GetAllProjects(projectService.CurrentOpenCombine);
-					foreach (ProjectCombineEntry entry in projects) {
-						if (entry.Project.IsFileInProject(fileName)) {
-							fileContent = entry.Project.GetParseableFileContent(fileName);
-						}
-					}
-				}
-			}
-			
-			if (fileContent != null) {
-				parserOutput = parser.Parse(fileName, fileContent);
-			} else {
-				parserOutput = parser.Parse(fileName);
-			}
-			
-			ParseInformation parseInformation = parsings[fileName] as ParseInformation;
-			
-			int itemsAdded = 0;
-			int itemsRemoved = 0;
-			
-			if (parseInformation == null) {
-				parseInformation = new ParseInformation();
-			} else {
-				itemsAdded = GetAddedItems(
-				                           (ICompilationUnit)parseInformation.MostRecentCompilationUnit,
-				                           (ICompilationUnit)parserOutput,
-				                           (ICompilationUnit)addedParseInformation.DirtyCompilationUnit
-				                           );
-				
-				itemsRemoved = GetRemovedItems(
-				                               (ICompilationUnit)parseInformation.MostRecentCompilationUnit,
-				                               (ICompilationUnit)parserOutput,
-				                               (ICompilationUnit)removedParseInformation.DirtyCompilationUnit
-				                               );
-			}
-			if (parserOutput.ErrorsDuringCompile) {
-				parseInformation.DirtyCompilationUnit = parserOutput;
-			} else {
-				parseInformation.ValidCompilationUnit = parserOutput;
-				parseInformation.DirtyCompilationUnit = null;
-			}
-			
-			parsings[fileName] = parseInformation;
-			
-			if (parseInformation.BestCompilationUnit is ICompilationUnit) {
-				ICompilationUnit cu = (ICompilationUnit)parseInformation.BestCompilationUnit;
-				foreach (IClass c in cu.Classes) {
-					AddClassToNamespaceList(c);
-					lock (classes) {
-						caseInsensitiveClasses[c.FullyQualifiedName.ToLower()] = classes[c.FullyQualifiedName] = new ClasstableEntry(fileName, cu, c);
-					}
-				}
-			} else {
-//				Console.WriteLine(&quot;SKIP!&quot;);
-			}
-			
-			OnParseInformationChanged(new ParseInformationEventArgs(fileName, parseInformation));
-			
-			if (itemsRemoved &gt; 0) {
-				OnParseInformationRemoved (new ParseInformationEventArgs (fileName, removedParseInformation));
-			}
-			if(itemsAdded &gt; 0) {
-				OnParseInformationAdded(new ParseInformationEventArgs(fileName, addedParseInformation));
-			}
-			//if(itemsRemoved &gt; 0) {
-			//	OnParseInformationRemoved(new ParseInformationEventArgs(fileName, removedParseInformation));
-			//}
-			return parseInformation;
-		}
-		
-		void RemoveClasses(ICompilationUnit cu)
-		{
-			if (cu != null) {
-				lock (classes) {
-					foreach (IClass c in cu.Classes) {
-							classes.Remove(c.FullyQualifiedName);
-							caseInsensitiveClasses.Remove(c.FullyQualifiedName.ToLower());
-					}
-				}
-			}
-		}
-
-		public IParseInformation GetParseInformation(string fileName)
-		{
-			if (fileName == null || fileName.Length == 0) {
-				return null;
-			}
-			object cu = parsings[fileName];
-			if (cu == null) {
-				return ParseFile(fileName);
-			}
-			return (IParseInformation)cu;
-		}
-		
-		public IExpressionFinder GetExpressionFinder(string fileName)
-		{
-			IParser parser = GetParser(fileName);
-			if (parser != null) {
-				return parser.ExpressionFinder;
-			}
-			return null;
-		}
-		public virtual IParser GetParser(string fileName)
-		{
-			// HACK: I'm too lazy to do it 'right'
-			if (fileName != null) {
-				if (Path.GetExtension(fileName).ToUpper() == &quot;.CS&quot;) {
-					return parser[0];
-				}
-				if (Path.GetExtension(fileName).ToUpper() == &quot;.VB&quot;) {
-					return parser[1];
-				}
-			}
-			return null;
-		}
-		
-		int GetAddedItems(ICompilationUnit original, ICompilationUnit changed, ICompilationUnit result)
-		{
-			int count = 0;
-			//result.LookUpTable.Clear();
-			//result.Usings.Clear();
-			//result.Attributes.Clear();
-			result.Classes.Clear();
-			//result.MiscComments.Clear();
-			//result.DokuComments.Clear();
-			//result.TagComments.Clear();
-			
-			//count += DiffUtility.GetAddedItems(original.LookUpTable,  changed.LookUpTable,  result.LookUpTable);
-			//count += DiffUtility.GetAddedItems(original.Usings,       changed.Usings,       result.Usings);
-			//count += DiffUtility.GetAddedItems(original.Attributes,   changed.Attributes,   result.Attributes);
-			count += DiffUtility.GetAddedItems(original.Classes,      changed.Classes,      result.Classes);
-			//count += DiffUtility.GetAddedItems(original.MiscComments, changed.MiscComments, result.MiscComments);
-			//count += DiffUtility.GetAddedItems(original.DokuComments, changed.DokuComments, result.DokuComments);
-			//count += DiffUtility.GetAddedItems(original.TagComments,  changed.TagComments,  result.TagComments);
-			return count;
-		}
-		
-		int GetRemovedItems(ICompilationUnit original, ICompilationUnit changed, ICompilationUnit result) {
-			return GetAddedItems(changed, original, result);
-		}
-		
-		////////////////////////////////////
-		
-		public ArrayList CtrlSpace(IParserService parserService, int caretLine, int caretColumn, string fileName)
-		{
-			IParser parser = GetParser(fileName);
-			if (parser != null) {
-				return parser.CtrlSpace(parserService, caretLine, caretColumn, fileName);
-			}
-			return null;
-		}
-		
-		public ResolveResult Resolve(string expression,
-		                             int caretLineNumber,
-		                             int caretColumn,
-		                             string fileName,
-		                             string fileContent)
-		{
-			// added exception handling here to prevent silly parser exceptions from
-			// being thrown and corrupting the textarea control
-			try {
-				IParser parser = GetParser(fileName);
-				//Console.WriteLine(&quot;Parse info : &quot; + GetParseInformation(fileName).MostRecentCompilationUnit.Tag);
-				if (parser != null) {
-					return parser.Resolve(this, expression, caretLineNumber, caretColumn, fileName, fileContent);
-				}
-				return null;
-			} catch {
-				return null;
-			}
-		}
-
-		protected void OnParseInformationAdded(ParseInformationEventArgs e)
-		{
-			if (ParseInformationAdded != null) {
-				ParseInformationAdded(this, e);
-			}
-		}
-
-		protected void OnParseInformationRemoved(ParseInformationEventArgs e)
-		{
-			if (ParseInformationRemoved != null) {
-				ParseInformationRemoved(this, e);
-			}
-		}
-		protected virtual void OnParseInformationChanged(ParseInformationEventArgs e)
-		{
-			if (ParseInformationChanged != null) {
-				ParseInformationChanged(this, e);
-			}
-		}
-		
-		public event ParseInformationEventHandler ParseInformationAdded;
-		public event ParseInformationEventHandler ParseInformationRemoved;
-		public event ParseInformationEventHandler ParseInformationChanged;
-	}
-	
-	[Serializable]
-	public class DummyCompilationUnit : AbstractCompilationUnit
-	{
-		CommentCollection miscComments = new CommentCollection();
-		CommentCollection dokuComments = new CommentCollection();
-		TagCollection     tagComments  = new TagCollection();
-		
-		public override CommentCollection MiscComments {
-			get {
-				return miscComments;
-			}
-		}
-		
-		public override CommentCollection DokuComments {
-			get {
-				return dokuComments;
-			}
-		}
-		
-		public override TagCollection TagComments {
-			get {
-				return tagComments;
-			}
-		}
-	}
-}

Modified: branches/MonoDevelop-generate-what/src/Main/Base/SharpDevelop.prjX
===================================================================
--- branches/MonoDevelop-generate-what/src/Main/Base/SharpDevelop.prjX	2004-04-23 11:03:04 UTC (rev 1491)
+++ branches/MonoDevelop-generate-what/src/Main/Base/SharpDevelop.prjX	2004-04-23 11:08:49 UTC (rev 1492)
@@ -71,7 +71,7 @@
     &lt;File name=&quot;.\Internal\Parser\Implementations\AbstractReturnType.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Internal\Parser\Implementations\AbstractCompilationUnit.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\IParserService.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Services\ParserService\DefaultParserService.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Services\ParserService\DatabaseBackedParserService.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Internal\Codons\DisplayBinding\DisplayBindingCodon.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Internal\Conditions\CombineOpenCondition.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\Project\ProjectRenameEventArgs.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
@@ -1036,13 +1036,13 @@
     &lt;File name=&quot;.\Services\ParserService\.svn\text-base\AssemblyInformation.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\text-base\ClassProxy.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\text-base\ClassProxyCollection.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Services\ParserService\.svn\text-base\DefaultParserService.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Services\ParserService\.svn\text-base\DatabaseBackedParserService.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\text-base\IParserService.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\text-base\ParseInformation.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\wcprops\AssemblyInformation.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\wcprops\ClassProxy.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\wcprops\ClassProxyCollection.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Services\ParserService\.svn\wcprops\DefaultParserService.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Services\ParserService\.svn\wcprops\DatabaseBackedParserService.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\wcprops\IParserService.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\ParserService\.svn\wcprops\ParseInformation.cs.svn-work&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
     &lt;File name=&quot;.\Services\Project\.svn\text-base\CombineEventArgs.cs.svn-base&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001098.html">[Monodevelop-patches-list] r1491 - in branches/MonoDevelop-generate-what: build/AddIns src/Main/Base src/Main/Base/Commands src/Main/Base/Gui/CompletionDatabaseWizard src/Main/Base/Gui/Dialogs/OptionPanels/IDEOptions src/Main/Base/Services/ParserService src/Main/Base/Services/Project
</A></li>
	<LI>Next message: <A HREF="001100.html">[Monodevelop-patches-list] r1493 - trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1099">[ date ]</a>
              <a href="thread.html#1099">[ thread ]</a>
              <a href="subject.html#1099">[ subject ]</a>
              <a href="author.html#1099">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
