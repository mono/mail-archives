<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2714 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Gui/Components	Gui/Pads Gui/Search Gui/Search/DocumentIterator	Internal/ProgressMonitoring Services/DebuggerService	Services/DispatchService Services/File	Services/ProcessService Services/Project Services/Tasks
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2714%20-%20in%0A%09trunk/MonoDevelop/Core/src/MonoDevelop.Base%3A%20.%20Gui/Components%0A%09Gui/Pads%20Gui/Search%20Gui/Search/DocumentIterator%0A%09Internal/ProgressMonitoring%20Services/DebuggerService%0A%09Services/DispatchService%20Services/File%0A%09Services/ProcessService%20Services/Project%20Services/Tasks&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002313.html">
   <LINK REL="Next"  HREF="002315.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2714 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Gui/Components	Gui/Pads Gui/Search Gui/Search/DocumentIterator	Internal/ProgressMonitoring Services/DebuggerService	Services/DispatchService Services/File	Services/ProcessService Services/Project Services/Tasks</H1>
    <B>Lluis Sanchez &lt;lluis@ximian.com&gt;</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2714%20-%20in%0A%09trunk/MonoDevelop/Core/src/MonoDevelop.Base%3A%20.%20Gui/Components%0A%09Gui/Pads%20Gui/Search%20Gui/Search/DocumentIterator%0A%09Internal/ProgressMonitoring%20Services/DebuggerService%0A%09Services/DispatchService%20Services/File%0A%09Services/ProcessService%20Services/Project%20Services/Tasks&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2714 - in	trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Gui/Components	Gui/Pads Gui/Search Gui/Search/DocumentIterator	Internal/ProgressMonitoring Services/DebuggerService	Services/DispatchService Services/File	Services/ProcessService Services/Project Services/Tasks">lluis at mono-cvs.ximian.com
       </A><BR>
    <I>Mon Aug  8 07:40:09 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002313.html">[Monodevelop-patches-list] r2713 -	trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn
</A></li>
        <LI>Next message: <A HREF="002315.html">[Monodevelop-patches-list] r2715 - in	trunk/MonoDevelop/Core/src/Tools/mdhost: . src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2314">[ date ]</a>
              <a href="thread.html#2314">[ thread ]</a>
              <a href="subject.html#2314">[ subject ]</a>
              <a href="author.html#2314">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lluis
Date: 2005-08-08 07:40:09 -0400 (Mon, 08 Aug 2005)
New Revision: 2714

Added:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SearchResultPad.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/ISearchProgressMonitor.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/SearchProgressMonitor.cs
Removed:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ProcessService/DebugExecutionHandlerFactory.cs
Modified:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/MenuButtonEntry.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Search/DocumentIterator/DirectoryDocumentIterator.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Search/SearchReplaceInFilesManager.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/ProgressMonitoring/BaseProgressMonitor.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/DebuggerService/IDebuggerService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/DispatchService/SyncContextAttribute.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/File/DefaultFileService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ProcessService/ProcessHostController.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/TaskService.cs
Log:
2005-08-08  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt; 

	* Services/File/DefaultFileService.cs: Properly jump to the requested
	line after opening a file.
	* Services/DispatchService/SyncContextAttribute.cs: Some optimizations.
	* Internal/ProgressMonitoring/BaseProgressMonitor.cs: Apply the
	FreeDispatch attribute to the Log getter.
	
	* Services/ProcessService/ProcessHostController.cs: Send the object
	reference using the process pipe. No more huge base64 strings in
	the process command line.
	
	* Services/Project/ProjectService.cs:
	* Services/DebuggerService/IDebuggerService.cs: Moved implementation of
	DebugExecutionHandlerFactory to the debugger addin. 
	
	* Gui/Components/MenuButtonEntry.cs: Fix warnings.
	* Search/DocumentIterator/DirectoryDocumentIterator.cs: Don't get the
	whole directory structure at the beginning. Do it incrementally.
	
	* Services/Tasks/ISearchProgressMonitor.cs:
	* Services/Tasks/SearchProgressMonitor.cs:
	* Gui/Pads/SearchResultPad.cs:
	* Gui/Search/SearchReplaceInFilesManager.cs:
	* Services/Tasks/TaskService.cs: Added progress monitor and Pad specific
	for search results.



Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-08-08 11:40:09 UTC (rev 2714)
@@ -1,3 +1,30 @@
+2005-08-08  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at novell.com</A>&gt; 
+
+	* Services/File/DefaultFileService.cs: Properly jump to the requested
+	line after opening a file.
+	* Services/DispatchService/SyncContextAttribute.cs: Some optimizations.
+	* Internal/ProgressMonitoring/BaseProgressMonitor.cs: Apply the
+	FreeDispatch attribute to the Log getter.
+	
+	* Services/ProcessService/ProcessHostController.cs: Send the object
+	reference using the process pipe. No more huge base64 strings in
+	the process command line.
+	
+	* Services/Project/ProjectService.cs:
+	* Services/DebuggerService/IDebuggerService.cs: Moved implementation of
+	DebugExecutionHandlerFactory to the debugger addin. 
+	
+	* Gui/Components/MenuButtonEntry.cs: Fix warnings.
+	* Search/DocumentIterator/DirectoryDocumentIterator.cs: Don't get the
+	whole directory structure at the beginning. Do it incrementally.
+	
+	* Services/Tasks/ISearchProgressMonitor.cs:
+	* Services/Tasks/SearchProgressMonitor.cs:
+	* Gui/Pads/SearchResultPad.cs:
+	* Gui/Search/SearchReplaceInFilesManager.cs:
+	* Services/Tasks/TaskService.cs: Added progress monitor and Pad specific
+	for search results.
+
 2005-08-06  John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">john.luke at gmail.com</A>&gt;
 
     * MonoDevelop.Base.mdp: update

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/MenuButtonEntry.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/MenuButtonEntry.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Components/MenuButtonEntry.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -35,7 +35,6 @@
 	public class MenuButtonEntry : Gtk.HBox
 	{
 		Gtk.Entry entry;
-		Gtk.Button button;
 		ArrayList options = new ArrayList ();
 		
 		CommandManager manager;
@@ -61,7 +60,6 @@
 			if (button == null) button = new Gtk.Button (&quot;&gt;&quot;);
 			
 			this.entry = entry;
-			this.button = button;
 			
 			manager = new CommandManager ();
 			manager.RegisterGlobalHandler (this);
@@ -94,7 +92,7 @@
 		}
 		
 		[CommandHandler (&quot;InsertOption&quot;)]
-		void OnUpdateInsertOption (object selection)
+		protected void OnUpdateInsertOption (object selection)
 		{
 			int tempInt = entry.Position;
 			entry.DeleteSelection();
@@ -102,7 +100,7 @@
 		}
 		
 		[CommandUpdateHandler (&quot;InsertOption&quot;)]
-		void OnUpdateInsertOption (CommandArrayInfo info)
+		protected void OnUpdateInsertOption (CommandArrayInfo info)
 		{
 			foreach (string[] op in options) {
 				if (op [0] == &quot;-&quot;)

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SearchResultPad.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SearchResultPad.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Pads/SearchResultPad.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -0,0 +1,327 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.CodeDom.Compiler;
+using System.Collections;
+using System.IO;
+using System.Diagnostics;
+using System.Text;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Internal.Project;
+
+using Gtk;
+
+namespace MonoDevelop.Gui.Pads
+{
+	public class SearchResultPad : IPadContent
+	{
+		ScrolledWindow sw;
+		Gtk.TreeView view;
+		ListStore store;
+		string basePath;
+		IAsyncOperation asyncOperation;
+		string markupTitle;
+		string title;
+		string id;
+		int matchCount;
+		string statusText;
+		
+		const int COL_TYPE = 0, COL_LINE = 1, COL_COLUMN = 2, COL_DESC = 3, COL_FILE = 4, COL_PATH = 5, COL_FULLPATH = 6, COL_READ = 7, COL_READ_WEIGHT = 8, COL_ISFILE = 9;
+		
+		Gtk.TextBuffer logBuffer;
+		Gtk.TextView logTextView;
+		Gtk.ScrolledWindow logScroller;
+		ToggleToolButton buttonOutput;
+		ToolButton buttonStop;
+		Label status;
+		Gtk.Tooltips tips = new Gtk.Tooltips ();
+		
+		StringBuilder log = new StringBuilder ();
+		Widget control;
+		
+		public SearchResultPad ()
+		{
+			// Toolbar
+			
+			Toolbar toolbar = new Toolbar ();
+			toolbar.IconSize = IconSize.SmallToolbar;
+			toolbar.Orientation = Orientation.Vertical;
+			toolbar.ToolbarStyle = ToolbarStyle.Icons;
+
+			buttonStop = new ToolButton (&quot;gtk-stop&quot;);
+			buttonStop.Clicked += new EventHandler (OnButtonStopClick);
+			buttonStop.SetTooltip (tips, &quot;Stop&quot;, &quot;Stop&quot;);
+			toolbar.Insert (buttonStop, -1);
+
+			ToolButton buttonClear = new ToolButton (&quot;gtk-clear&quot;);
+			buttonClear.Clicked += new EventHandler (OnButtonClearClick);
+			buttonClear.SetTooltip (tips, &quot;Clear results&quot;, &quot;Clear results&quot;);
+			toolbar.Insert (buttonClear, -1);
+			
+			buttonOutput = new ToggleToolButton (MonoDevelop.Gui.Stock.OutputIcon);
+			buttonOutput.Clicked += new EventHandler (OnButtonOutputClick);
+			buttonOutput.SetTooltip (tips, &quot;Show output&quot;, &quot;Show output&quot;);
+			toolbar.Insert (buttonOutput, -1);
+			
+			// Results list
+			
+			store = new Gtk.ListStore (
+				typeof (Gdk.Pixbuf), // image
+				typeof (int),        // line
+				typeof (int),        // column
+				typeof (string),     // desc
+				typeof (string),     // file
+				typeof (string),     // path
+				typeof (string),     // full path
+				typeof (bool),       // read?
+				typeof (int),       // read? -- use Pango weight
+				typeof (bool));       // is file
+
+			view = new Gtk.TreeView (store);
+			view.RulesHint = true;
+			AddColumns ();
+			
+			sw = new Gtk.ScrolledWindow ();
+			sw.ShadowType = ShadowType.In;
+			sw.Add (view);
+			
+			// Log view
+			
+			logBuffer = new Gtk.TextBuffer (new Gtk.TextTagTable ());
+			logTextView = new Gtk.TextView (logBuffer);
+			logTextView.Editable = false;
+			logScroller = new Gtk.ScrolledWindow ();
+			logScroller.ShadowType = ShadowType.In;
+			logScroller.Add (logTextView);
+
+			// HPaned
+			
+			Gtk.HPaned paned = new Gtk.HPaned ();
+			paned.Pack1 (sw, true, true);
+			paned.Pack2 (logScroller, true, true);
+			
+			// HBox
+			
+			status = new Label ();
+			status.Xalign = 0.0f;
+			
+			VBox vbox = new VBox ();
+			vbox.PackStart (paned, true, true, 0);
+			vbox.PackStart (status, false, false, 3);
+			
+			HBox hbox = new HBox ();
+			hbox.PackStart (vbox, true, true, 0);
+			hbox.PackStart (toolbar, false, false, 0);
+			
+			control = hbox;
+			
+			Control.ShowAll ();
+			
+			logScroller.Hide ();
+			
+			view.RowActivated += new RowActivatedHandler (OnRowActivated);
+		}
+		
+		public void BeginProgress (string title)
+		{
+			this.title = title;
+			this.markupTitle = &quot;&lt;span foreground=\&quot;blue\&quot;&gt;&quot; + title + &quot;&lt;/span&gt;&quot;;
+			
+			matchCount = 0;
+			store.Clear ();
+			logBuffer.Clear ();
+			if (!logScroller.Visible)
+				log = new StringBuilder ();
+				
+			OnTitleChanged (null);
+			buttonStop.Sensitive = true;
+		}
+		
+		public void EndProgress ()
+		{
+			markupTitle = title;
+			OnTitleChanged (null);
+			buttonStop.Sensitive = false;
+			status.Text = &quot; &quot; + statusText;
+		}
+		
+		public bool AllowReuse {
+			get { return !buttonStop.Sensitive; }
+		}
+		
+		public IAsyncOperation AsyncOperation {
+			get {
+				return asyncOperation;
+			}
+			set {
+				asyncOperation = value;
+			}
+		}
+		
+		public void SetBasePath (string path)
+		{
+			basePath = path;
+		}
+		
+		public Gtk.Widget Control {
+			get {
+				return control;
+			}
+		}
+
+		public string DefaultPlacement {
+			get { return &quot;Bottom&quot;; }
+		}
+		
+		public string Title {
+			get {
+				return markupTitle;
+			}
+		}
+		
+		public string Id {
+			get { return id; }
+			set { id = value; }
+		}
+		
+		public string Icon {
+			get {
+				return MonoDevelop.Gui.Stock.FindIcon;
+			}
+		}
+		
+		public void RedrawContent()
+		{
+		}
+
+		void OnButtonClearClick (object sender, EventArgs e)
+		{
+			matchCount = 0;
+			store.Clear ();
+			logBuffer.Clear ();
+			if (log != null) log = new StringBuilder ();
+		}
+
+		void OnButtonStopClick (object sender, EventArgs e)
+		{
+			asyncOperation.Cancel ();
+		}
+
+		void OnButtonOutputClick (object sender, EventArgs e)
+		{
+			if (buttonOutput.Active) {
+				if (log != null) {
+					logBuffer.Text = log.ToString ();
+					log = null;
+				}
+				logScroller.Show ();
+			} else {
+				logScroller.Hide ();
+			}
+		}
+
+		public void WriteText (string text)
+		{
+			if (log != null)
+				log.Append (text);
+			else {
+				TextIter it = logBuffer.EndIter;
+				logBuffer.Insert (ref it, text);
+
+				if (text.EndsWith (&quot;\n&quot;))
+					logTextView.ScrollMarkOnscreen (logBuffer.InsertMark);
+			}
+		}
+
+		void AddColumns ()
+		{
+			Gtk.CellRendererPixbuf iconRender = new Gtk.CellRendererPixbuf ();
+			
+			Gtk.CellRendererText line = new Gtk.CellRendererText (), desc = new Gtk.CellRendererText () , path = new Gtk.CellRendererText (),
+			file = new Gtk.CellRendererText ();
+			
+			TreeViewColumn col;
+			col = view.AppendColumn (&quot;&quot;, iconRender, &quot;pixbuf&quot;, COL_TYPE);
+			view.AppendColumn (GettextCatalog.GetString (&quot;Line&quot;), line, &quot;text&quot;, COL_LINE, &quot;weight&quot;, COL_READ_WEIGHT, &quot;visible&quot;, COL_ISFILE);
+			col = view.AppendColumn (GettextCatalog.GetString (&quot;File&quot;), file, &quot;text&quot;, COL_FILE, &quot;weight&quot;, COL_READ_WEIGHT, &quot;visible&quot;, COL_ISFILE);
+			col.Resizable = true;
+			col = view.AppendColumn (GettextCatalog.GetString (&quot;Text&quot;), desc, &quot;text&quot;, COL_DESC, &quot;weight&quot;, COL_READ_WEIGHT);
+			col.Resizable = true;
+			col = view.AppendColumn (GettextCatalog.GetString (&quot;Path&quot;), path, &quot;text&quot;, COL_PATH, &quot;weight&quot;, COL_READ_WEIGHT, &quot;visible&quot;, COL_ISFILE);
+			col.Resizable = true;
+		}
+		
+		public void Dispose ()
+		{
+		}
+		
+		void OnRowActivated (object o, RowActivatedArgs args)
+		{
+			Gtk.TreeIter iter;
+			if (store.GetIter (out iter, args.Path)) {
+				if (!(bool) store.GetValue (iter, COL_ISFILE))
+					return;
+				store.SetValue (iter, COL_READ, true);
+				store.SetValue (iter, COL_READ_WEIGHT, (int) Pango.Weight.Normal);
+				
+				string path = (string) store.GetValue (iter, COL_FULLPATH);
+				int line = (int) store.GetValue (iter, COL_LINE);
+				/*int line = (int)*/ store.GetValue (iter, COL_COLUMN);
+
+				Runtime.FileService.OpenFile (path, line, 1, true);
+			}
+		}
+		
+		public void AddResult (string file, int line, int column, string text)
+		{
+			if (file == null) {
+				statusText = text;
+			} else {
+				matchCount++;
+				
+				Gdk.Pixbuf stock;
+				stock = sw.RenderIcon (Runtime.Gui.Icons.GetImageForFile (file), Gtk.IconSize.SmallToolbar, &quot;&quot;);
+	
+				string tmpPath = file;
+				if (basePath != null)
+					tmpPath = Runtime.FileUtilityService.AbsoluteToRelativePath (basePath, file);
+				
+				string fileName = tmpPath;
+				string path = tmpPath;
+				
+				fileName = Path.GetFileName (file);
+				
+				try {
+					path = Path.GetDirectoryName (tmpPath);
+				} catch (Exception) {}
+				
+				store.AppendValues (stock, line, column, text, fileName, path, file, false, (int) Pango.Weight.Bold, file != null);
+			}
+			
+			status.Text = &quot; &quot; + statusText + &quot; - &quot; + matchCount + &quot; matches&quot;;
+		}
+		
+		protected virtual void OnTitleChanged (EventArgs e)
+		{
+			if (TitleChanged != null)
+				TitleChanged(this, e);
+		}
+		
+		protected virtual void OnIconChanged (EventArgs e)
+		{
+			if (IconChanged != null)
+				IconChanged (this, e);
+		}
+		
+		public event EventHandler TitleChanged, IconChanged;
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Search/DocumentIterator/DirectoryDocumentIterator.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Search/DocumentIterator/DirectoryDocumentIterator.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Search/DocumentIterator/DirectoryDocumentIterator.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -17,19 +17,18 @@
 {
 	internal class DirectoryDocumentIterator : IDocumentIterator
 	{
-		string searchDirectory;
 		string fileMask;
-		bool   searchSubdirectories;
+		bool searchSubdirectories;
 		
-		StringCollection files    = null;
-		int              curIndex = -1;
+		StringCollection files = new StringCollection ();
+		Queue directories = new Queue ();
+		int curIndex = -1;
 		
 		public DirectoryDocumentIterator(string searchDirectory, string fileMask, bool searchSubdirectories)
 		{
-			this.searchDirectory      = searchDirectory;
 			this.fileMask             = fileMask;
 			this.searchSubdirectories = searchSubdirectories;
-			
+			directories.Enqueue (searchDirectory);
 			Reset();
 		}
 		
@@ -59,16 +58,41 @@
 		
 		public bool MoveForward() 
 		{
-			if (curIndex == -1) {
-				FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
-				files = fileUtilityService.SearchDirectory(this.searchDirectory, this.fileMask, this.searchSubdirectories);
+			curIndex++;
+			if (curIndex &gt;= files.Count)
+				return FetchDirectories ();
+			else
+				return true;
+		}
+		
+		bool FetchDirectories ()
+		{
+			if (directories.Count == 0)
+				return false;
+
+			string dir = (string) directories.Dequeue ();
+			
+			string[] dirFiles = Directory.GetFiles (dir, fileMask);
+			for (int n = 0; n &lt; dirFiles.Length; n++) {
+				files.Add (dirFiles [n]);
 			}
-			return ++curIndex &lt; files.Count;
+			
+			if (searchSubdirectories) {
+				string[] dirDirs = Directory.GetDirectories (dir);
+				for (int n = 0; n &lt; dirDirs.Length; n++)
+					directories.Enqueue (dirDirs [n]);
+			}
+			
+			if (dirFiles.Length == 0)
+				return FetchDirectories ();
+			else
+				return true;
 		}
 		
 		public bool MoveBackward()
 		{
 			if (curIndex == -1) {
+				while (FetchDirectories ());	// Fetch all
 				curIndex = files.Count - 1;
 				return true;
 			}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Search/SearchReplaceInFilesManager.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Search/SearchReplaceInFilesManager.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Gui/Search/SearchReplaceInFilesManager.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -30,6 +30,7 @@
 		static bool searching;
 		static bool cancelled;
 		static string searchError;
+		static ISearchProgressMonitor searchMonitor;
 		
 		public static SearchOptions SearchOptions {
 			get {
@@ -56,24 +57,26 @@
 		}
 		
 		/// &lt;remarks&gt;
-		/// This method displays the search result in the task view
+		/// This method displays the search result in the search results pad
 		/// &lt;/remarks&gt;
 		static void DisplaySearchResult(ISearchResult result)
 		{
 			if (result.Line != -1) {
 				string text = result.DocumentInformation.GetLineTextAtOffset (result.DocumentOffset);
-				Runtime.TaskService.AddTask (new Task (result.FileName, text, result.Column, result.Line));
+				searchMonitor.ReportResult (result.FileName, result.Line, result.Column, text);
 			} else {
 				string msg = string.Format (GettextCatalog.GetString (&quot;Match at offset {0}&quot;), result.DocumentOffset);
-				Runtime.TaskService.AddTask (new Task(result.FileName, msg, -1, -1));
+				searchMonitor.ReportResult (result.FileName, 0, 0, msg);
 			}
 		}
 		
 		static bool InitializeSearchInFiles()
 		{
 			Debug.Assert(searchOptions != null);
+			cancelled = false;
 			
-			Runtime.TaskService.ClearTasks();
+			searchMonitor = Runtime.TaskService.GetSearchProgressMonitor (true);
+			searchMonitor.CancelRequested += (MonitorHandler) Runtime.DispatchService.GuiDispatch (new MonitorHandler (OnCancelRequested));
 			
 			InitializeDocumentIterator(null, null);
 			InitializeSearchStrategy(null, null);
@@ -88,6 +91,11 @@
 			return true;
 		}
 		
+		static void OnCancelRequested (IProgressMonitor monitor)
+		{
+			CancelSearch ();
+		}
+		
 		static void FinishSearchInFiles ()
 		{
 			string msg;
@@ -98,16 +106,14 @@
 			else
 				msg = string.Format (GettextCatalog.GetString (&quot;Search completed. {0} matches found in {1} files.&quot;), find.MatchCount, find.SearchedFileCount);
 				
-			Runtime.TaskService.AddTask (new Task(null, msg, -1, -1));
-			Runtime.TaskService.ShowTasks ();
+			searchMonitor.ReportResult (null, 0, 0, msg);
+			
+			searchMonitor.Log.WriteLine (msg);
+			searchMonitor.Log.WriteLine (GettextCatalog.GetString (&quot;Search time: {0} seconds.&quot;), (DateTime.Now - timer).TotalSeconds);
 
-			Console.WriteLine (&quot;Search time: &quot; + (DateTime.Now - timer).TotalSeconds);
+			searchMonitor.Dispose ();
 			searching = false;
-			
-			// tell the user search is done.
-/*			Runtime.MessageService.ShowMessage (GettextCatalog.GetString (&quot;Search completed&quot;));
-			Console.WriteLine (&quot;Done&quot;);
-*/		}
+		}
 		
 		public static void ReplaceAll()
 		{
@@ -122,7 +128,7 @@
 			}
 			
 			string msg = string.Format (GettextCatalog.GetString (&quot;Replacing '{0}' in {1}.&quot;), searchOptions.SearchPattern, searchOptions.SearchDirectory);
-			Runtime.TaskService.AddTask (new Task(null, msg, -1, -1));
+			searchMonitor.ReportResult (null, 0, 0, msg);
 			
 			timer = DateTime.Now;
 			Runtime.DispatchService.BackgroundDispatch (new MessageHandler(ReplaceAllThread));
@@ -168,7 +174,7 @@
 			}
 			
 			string msg = string.Format (GettextCatalog.GetString (&quot;Looking for '{0}' in {1}.&quot;), searchOptions.SearchPattern, searchOptions.SearchDirectory);
-			Runtime.TaskService.AddTask (new Task(null, msg, -1, -1));
+			searchMonitor.ReportResult (null, 0, 0, msg);
 			
 			timer = DateTime.Now;
 			Runtime.DispatchService.BackgroundDispatch (new MessageHandler(FindAllThread));
@@ -192,7 +198,7 @@
 				}
 				catch (Exception ex)
 				{
-					Console.WriteLine (ex);
+					searchMonitor.Log.WriteLine (ex);
 					searchError = ex.Message;
 					break;
 				}
@@ -206,14 +212,6 @@
 			if (!searching) return;
 			cancelled = true;
 			find.Cancel ();
-			
-			while (searching) {
-				if (Gtk.Application.EventsPending ())
-					Gtk.Application.RunIteration ();
-				Thread.Sleep (10);
-			}
-				
-			cancelled = false;
 		}
 
 		internal static Gtk.Dialog DialogPointer

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/ProgressMonitoring/BaseProgressMonitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/ProgressMonitoring/BaseProgressMonitor.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Internal/ProgressMonitoring/BaseProgressMonitor.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -96,9 +96,11 @@
 			OnProgressChanged ();
 		}
 		
-		[FreeDispatch]
 		public TextWriter Log {
-			get { return logger; }
+			[FreeDispatch]
+			get {
+				return logger;
+			}
 		}
 		
 		[FreeDispatch]

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-08-08 11:40:09 UTC (rev 2714)
@@ -68,6 +68,7 @@
 Gui/Pads/SolutionPad/TreeViewPad.cs \
 Gui/Pads/SolutionPad/TypeNodeBuilder.cs \
 Gui/Pads/DefaultMonitorPad.cs \
+Gui/Pads/SearchResultPad.cs \
 Gui/ToolWidgets/ConfigurationComboBox.cs \
 Gui/AbstractPadContent.cs \
 Gui/ISecondaryViewContent.cs \
@@ -225,6 +226,8 @@
 Services/Tasks/Task.cs \
 Services/Tasks/BackgroundProgressMonitor.cs \
 Services/Tasks/OutputProgressMonitor.cs \
+Services/Tasks/ISearchProgressMonitor.cs \
+Services/Tasks/SearchProgressMonitor.cs \
 Services/Tasks/StatusProgressMonitor.cs \
 Services/AmbienceService/AmbienceService.cs \
 Services/AmbienceService/AmbienceReflectionDecorator.cs \
@@ -238,7 +241,6 @@
 Services/ProcessService/IProcessHostController.cs \
 Services/ProcessService/ProcessHostController.cs \
 Services/ProcessService/RemoteProcessObject.cs \
-Services/ProcessService/DebugExecutionHandlerFactory.cs \
 Services/ProcessService/DefaultExecutionHandlerFactory.cs \
 Services/ProcessService/ExecutionContext.cs \
 Services/ProcessService/ExternalConsoleFactory.cs \

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/DebuggerService/IDebuggerService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/DebuggerService/IDebuggerService.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/DebuggerService/IDebuggerService.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -52,5 +52,7 @@
 		IBreakpoint[] GetBreakpointsAtFile (string sourceFile);
 		
 		void ClearAllBreakpoints ();
+		
+		IExecutionHandlerFactory GetExecutionHandlerFactory ();
 	}
 }

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/DispatchService/SyncContextAttribute.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/DispatchService/SyncContextAttribute.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/DispatchService/SyncContextAttribute.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -73,8 +73,14 @@
 			if (syncContext == null) return nextSink.SyncProcessMessage (msg);
 			
 			IMethodMessage mm = (IMethodMessage)msg;
-			if (mm.MethodBase.IsDefined (typeof(FreeDispatchAttribute), true))
+			
+			if ((mm.MethodBase.Name == &quot;FieldGetter&quot; || mm.MethodBase.Name == &quot;FieldSetter&quot;) &amp;&amp; mm.MethodBase.DeclaringType == typeof(object)) {
 				return nextSink.SyncProcessMessage (msg);
+			}
+			
+			if (mm.MethodBase.IsDefined (typeof(FreeDispatchAttribute), true)) {
+				return nextSink.SyncProcessMessage (msg);
+			}
 
 			if (mm.MethodBase.IsDefined (typeof(AsyncDispatchAttribute), true)) {
 				AsyncProcessMessage (msg, DummySink.Instance);

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/File/DefaultFileService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/File/DefaultFileService.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/File/DefaultFileService.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -57,6 +57,7 @@
 			IDisplayBinding binding;
 			Project project;
 			FileInformation fileInfo;
+			IViewContent newContent;
 			
 			public LoadFileWrapper(IDisplayBinding binding, FileInformation fileInfo)
 			{
@@ -73,7 +74,7 @@
 			
 			public void Invoke(string fileName)
 			{
-				IViewContent newContent = binding.CreateContentForFile(fileName);
+				newContent = binding.CreateContentForFile(fileName);
 				if (project != null)
 				{
 					newContent.HasProject = true;
@@ -83,9 +84,15 @@
 				Runtime.Gui.DisplayBindings.AttachSubWindows(newContent.WorkbenchWindow);
 				
 				if (fileInfo.Line != -1 &amp;&amp; newContent is IPositionable) {
-					((IPositionable)newContent).JumpTo (fileInfo.Line, fileInfo.Column != -1 ? fileInfo.Column : 0);
+					GLib.Timeout.Add (10, new GLib.TimeoutHandler (JumpToLine));
 				}
 			}
+			
+			public bool JumpToLine ()
+			{
+				((IPositionable)newContent).JumpTo (Math.Max(1, fileInfo.Line), Math.Max(1, fileInfo.Column));
+				return false;
+			}
 		}
 		
 		public IAsyncOperation OpenFile (string fileName)
@@ -104,6 +111,9 @@
 				if (content.ContentName == fileName) {
 					if (bringToFront)
 						content.WorkbenchWindow.SelectWindow();
+					if (line != -1 &amp;&amp; content is IPositionable) {
+						((IPositionable)content).JumpTo (line, column != -1 ? column : 0);
+					}
 					return NullAsyncOperation.Success;
 				}
 			}

Deleted: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ProcessService/DebugExecutionHandlerFactory.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ProcessService/DebugExecutionHandlerFactory.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ProcessService/DebugExecutionHandlerFactory.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -1,125 +0,0 @@
-//
-// DebugExecutionHandlerFactory.cs
-//
-// Author:
-//   Lluis Sanchez Gual
-//
-// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
-//
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// &quot;Software&quot;), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-
-using System;
-using System.Threading;
-
-namespace MonoDevelop.Services
-{
-	public class DebugExecutionHandlerFactory: IExecutionHandlerFactory
-	{
-		public IExecutionHandler CreateExecutionHandler (string platformId)
-		{
-			if (Runtime.DebuggingService == null)
-				return null;
-
-			if (platformId == &quot;Mono&quot;)
-				return new DebugExecutionHandler ();
-			else
-				return null;
-		}
-	}
-	
-	class DebugExecutionHandler: IExecutionHandler, IProcessAsyncOperation
-	{
-		bool done;
-		ManualResetEvent stopEvent;
-		
-		public DebugExecutionHandler ()
-		{
-			Runtime.DebuggingService.StoppedEvent += new EventHandler (OnStopDebug);
-		}
-		
-		public IProcessAsyncOperation Execute (string command, string arguments, string workingDirectory, IConsole console)
-		{
-			Runtime.DebuggingService.Run (console, new string[] { command } );
-			return this;
-		}
-		
-		public void Cancel ()
-		{
-			Runtime.DebuggingService.Stop ();
-		}
-		
-		public void WaitForCompleted ()
-		{
-			lock (this) {
-				if (done) return;
-				if (stopEvent == null)
-					stopEvent = new ManualResetEvent (false);
-			}
-			stopEvent.WaitOne ();
-		}
-		
-		public int ExitCode {
-			get { return 0; }
-		}
-		
-		public bool IsCompleted {
-			get { return done; }
-		}
-		
-		public bool Success {
-			get { return true; }
-		}
-
-		void OnStopDebug (object sender, EventArgs args)
-		{
-			lock (this) {
-				done = true;
-				if (stopEvent != null)
-					stopEvent.Set ();
-				if (completedEvent != null)
-					completedEvent (this);
-			}
-
-			Runtime.DebuggingService.StoppedEvent -= new EventHandler (OnStopDebug);
-		}
-		
-		event OperationHandler IAsyncOperation.Completed {
-			add {
-				bool raiseNow = false;
-				lock (this) {
-					if (done)
-						raiseNow = true;
-					else
-						completedEvent += value;
-				}
-				if (raiseNow)
-					value (this);
-			}
-			remove {
-				lock (this) {
-					completedEvent -= value;
-				}
-			}
-		}
-		
-		event OperationHandler completedEvent;
-	}
-}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ProcessService/ProcessHostController.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ProcessService/ProcessHostController.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/ProcessService/ProcessHostController.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -77,11 +77,14 @@
 				try {
 					process = new Process ();
 					process.Exited += new EventHandler (ProcessExited);
-					process.StartInfo = new ProcessStartInfo (&quot;sh&quot;, &quot;-c \&quot;mono mdhost.exe &quot; + sref + &quot;\&quot;&quot;);
+					process.StartInfo = new ProcessStartInfo (&quot;sh&quot;, &quot;-c \&quot;mono mdhost.exe\&quot;&quot;);
 					process.StartInfo.WorkingDirectory = AppDomain.CurrentDomain.BaseDirectory;
 					process.StartInfo.UseShellExecute = false;
+					process.StartInfo.RedirectStandardInput = true;
 					process.EnableRaisingEvents = true;
 					process.Start ();
+					process.StandardInput.WriteLine (sref);
+					process.StandardInput.Flush ();
 				} catch (Exception ex) {
 					Console.WriteLine (ex);
 					throw;
@@ -100,9 +103,7 @@
 				runningEvent.Reset ();
 				processHost = null;
 				process = null;
-				
-				if (references &gt; 0)
-					Start ();
+				references = 0;
 			}
 		}
 		
@@ -119,7 +120,12 @@
 				throw new ApplicationException (&quot;Couldn't create a remote process.&quot;);
 			}
 			
-			return processHost.CreateInstance (type);
+			try {
+				return processHost.CreateInstance (type);
+			} catch {
+				ReleaseInstance (null);
+				throw;
+			}
 		}
 		
 		public RemoteProcessObject CreateInstance (string assemblyPath, string typeName)
@@ -135,7 +141,12 @@
 				throw new ApplicationException (&quot;Couldn't create a remote process.&quot;);
 			}
 			
-			return processHost.CreateInstance (assemblyPath, typeName);
+			try {
+				return processHost.CreateInstance (assemblyPath, typeName);
+			} catch {
+				ReleaseInstance (null);
+				throw;
+			}
 		}
 		
 		public void ReleaseInstance (RemoteProcessObject proc)

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -369,12 +369,16 @@
 		
 		public IAsyncOperation Debug (CombineEntry entry)
 		{
+			if (Runtime.DebuggingService == null) {
+				return NullAsyncOperation.Failure;
+			}
+
 			if (currentRunOperation != null &amp;&amp; !currentRunOperation.IsCompleted) return currentRunOperation;
 			
 			guiHelper.SetWorkbenchContext (WorkbenchContext.Debug);
 
 			IProgressMonitor monitor = new MessageDialogProgressMonitor ();
-			ExecutionContext context = new ExecutionContext (new DebugExecutionHandlerFactory (), Runtime.TaskService);
+			ExecutionContext context = new ExecutionContext (Runtime.DebuggingService.GetExecutionHandlerFactory (), Runtime.TaskService);
 			
 			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (DebugCombineEntryAsync), new object[] {entry, monitor, context});
 			currentRunOperation = monitor.AsyncOperation;

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/ISearchProgressMonitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/ISearchProgressMonitor.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/ISearchProgressMonitor.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -0,0 +1,39 @@
+//
+// ISearchProgressMonitor.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Services
+{	
+	public interface ISearchProgressMonitor: IProgressMonitor
+	{
+		void SetBasePath (string path);
+		void ReportResult (string fileName, int line, int column, string text);
+	}
+}

Added: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/SearchProgressMonitor.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/SearchProgressMonitor.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/SearchProgressMonitor.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -0,0 +1,114 @@
+//
+// SearchProgressMonitor.cs
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// &quot;Software&quot;), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.CodeDom.Compiler;
+using System.IO;
+using System.Diagnostics;
+using MonoDevelop.Services;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Gui;
+using MonoDevelop.Gui.Pads;
+
+using Gtk;
+using Pango;
+
+namespace MonoDevelop.Services
+{
+	public class SearchProgressMonitor : BaseProgressMonitor, ISearchProgressMonitor
+	{
+		SearchResultPad outputPad;
+		event EventHandler stopRequested;
+		
+		public SearchProgressMonitor (SearchResultPad pad, string title)
+		{
+			pad.AsyncOperation = this.AsyncOperation;
+			outputPad = pad;
+			outputPad.BeginProgress (title);
+		}
+		
+		[FreeDispatch]
+		public bool AllowReuse {
+			get { return outputPad.AllowReuse; }
+		}
+		
+		[FreeDispatch]
+		public void SetBasePath (string path)
+		{
+			outputPad.SetBasePath (path);
+		}
+		
+		[AsyncDispatch]
+		public void ReportResult (string fileName, int line, int column, string text)
+		{
+			outputPad.AddResult (fileName, line, column, text);
+		}
+		
+		protected override void OnWriteLog (string text)
+		{
+			if (outputPad == null) throw GetDisposedException ();
+			outputPad.WriteText (text);
+		}
+		
+		protected override void OnCompleted ()
+		{
+			if (outputPad == null) throw GetDisposedException ();
+			outputPad.WriteText (&quot;\n&quot;);
+			
+			foreach (string msg in SuccessMessages)
+				outputPad.WriteText (msg + &quot;\n&quot;);
+			
+			foreach (string msg in Warnings)
+				outputPad.WriteText (msg + &quot;\n&quot;);
+			
+			foreach (string msg in Errors)
+				outputPad.WriteText (msg + &quot;\n&quot;);
+			
+			outputPad.EndProgress ();
+			base.OnCompleted ();
+			
+			Runtime.TaskService.ReleasePad (outputPad);
+			outputPad = null;
+		}
+		
+		Exception GetDisposedException ()
+		{
+			return new InvalidOperationException (&quot;Search progress monitor already disposed.&quot;);
+		}
+		
+		protected override void OnCancelRequested ()
+		{
+			base.OnCancelRequested ();
+			if (stopRequested != null)
+				stopRequested (this, null);
+		}
+	}
+}

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/TaskService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/TaskService.cs	2005-08-07 20:42:19 UTC (rev 2713)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Tasks/TaskService.cs	2005-08-08 11:40:09 UTC (rev 2714)
@@ -21,6 +21,7 @@
 		string    compilerOutput = String.Empty;
 		
 		ArrayList outputMonitors = new ArrayList ();
+		ArrayList searchMonitors = new ArrayList ();
 		int monitorId = 0;
 		
 		
@@ -104,6 +105,42 @@
 			}
 		}
 		
+		public ISearchProgressMonitor GetSearchProgressMonitor (bool bringToFront)
+		{
+			SearchResultPad pad = null;
+			string title = GettextCatalog.GetString (&quot;Search Results&quot;);
+			
+			lock (searchMonitors) {
+				// Look for an available pad
+				for (int n=0; n&lt;searchMonitors.Count; n++) {
+					SearchResultPad mpad = (SearchResultPad) searchMonitors [n];
+					if (mpad.AllowReuse) {
+						pad = mpad;
+						searchMonitors.RemoveAt (n);
+						break;
+					}
+				}
+			}
+			if (pad != null) {
+				if (bringToFront) Runtime.Gui.Workbench.BringToFront (pad);
+				return new SearchProgressMonitor (pad, title);
+			}
+			
+			SearchResultPad monitorPad = new SearchResultPad ();
+			monitorPad.Id = &quot;SearchPad&quot; + (monitorId++);
+			Runtime.Gui.Workbench.ShowPad (monitorPad);
+			if (bringToFront) Runtime.Gui.Workbench.BringToFront (monitorPad);
+
+			return new SearchProgressMonitor (monitorPad, title);
+		}
+
+		internal void ReleasePad (SearchResultPad pad)
+		{
+			lock (searchMonitors) {
+				searchMonitors.Add (pad);
+			}
+		}
+		
 		[FreeDispatch]
 		public ICollection Tasks {
 			get {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002313.html">[Monodevelop-patches-list] r2713 -	trunk/MonoDevelop/Core/src/AddIns/DebuggerAddIn
</A></li>
	<LI>Next message: <A HREF="002315.html">[Monodevelop-patches-list] r2715 - in	trunk/MonoDevelop/Core/src/Tools/mdhost: . src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2314">[ date ]</a>
              <a href="thread.html#2314">[ thread ]</a>
              <a href="subject.html#2314">[ subject ]</a>
              <a href="author.html#2314">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
