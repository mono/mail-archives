<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1950 - in trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui Search Search/TextIterator
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1950%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor%3A%20.%20CodeCompletion%20Gui%20Search%20Search/TextIterator&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="001556.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1950 - in trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui Search Search/TextIterator</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1950%20-%20in%20trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor%3A%20.%20CodeCompletion%20Gui%20Search%20Search/TextIterator&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1950 - in trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor: . CodeCompletion Gui Search Search/TextIterator">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sat Sep 18 09:47:34 EDT 2004</I>
    <P><UL>
        
        <LI>Next message: <A HREF="001556.html">[Monodevelop-patches-list] r1951 - trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1555">[ date ]</a>
              <a href="thread.html#1555">[ thread ]</a>
              <a href="subject.html#1555">[ subject ]</a>
              <a href="author.html#1555">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lluis
Date: 2004-09-18 09:47:34 -0400 (Sat, 18 Sep 2004)
New Revision: 1950

Added:
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs
Modified:
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/ChangeLog
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Makefile.am
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceInFilesManager.cs
   trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextFileIterator.cs
Log:
	* Gui/SourceEditorView.cs: Use the new completion window.
	* CodeCompletion/CompletionListWindow.cs: New completion window for the
	source editor.
	* CodeCompletion/ListWindow.cs: The list window from which
	CompletionListWindow inherits.
	* Search/SearchReplaceInFilesManager.cs: Catch exceptions during search and
	replace, and show an error message in this case.
	* Search/TextIterator/ForwardTextFileIterator.cs: File.Move does not allow
	overwriting files. Changed to Copy.
	* Makefile.am: Added new files.


Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/ChangeLog	2004-09-09 01:59:22 UTC (rev 1949)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/ChangeLog	2004-09-18 13:47:34 UTC (rev 1950)
@@ -1,3 +1,16 @@
+2004-09-18  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&gt;
+
+	* Gui/SourceEditorView.cs: Use the new completion window.
+	* CodeCompletion/CompletionListWindow.cs: New completion window for the
+	source editor.
+	* CodeCompletion/ListWindow.cs: The list window from which
+	CompletionListWindow inherits.
+	* Search/SearchReplaceInFilesManager.cs: Catch exceptions during search and
+	replace, and show an error message in this case.
+	* Search/TextIterator/ForwardTextFileIterator.cs: File.Move does not allow
+	overwriting files. Changed to Copy.
+	* Makefile.am: Added new files.
+
 2004-08-07  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at off.net</A>&gt;
 
 	* AssemblyInfo.cs.in: Use new ASSEMBLY_VERSION variable.

Added: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs	2004-09-09 01:59:22 UTC (rev 1949)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/CompletionListWindow.cs	2004-09-18 13:47:34 UTC (rev 1950)
@@ -0,0 +1,189 @@
+
+using System;
+using System.Collections;
+
+using Gtk;
+using MonoDevelop.SourceEditor.Gui;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	public class CompletionListWindow : ListWindow, IListDataProvider
+	{
+		string fileName;
+		IProject project;
+		SourceEditorView control;
+		TextMark triggeringMark;
+		ICompletionData[] completionData;
+		DeclarationViewWindow declarationviewwindow = new DeclarationViewWindow ();
+		static DataComparer dataComparer = new DataComparer ();
+		
+		class DataComparer: IComparer
+		{
+			public int Compare (object x, object y)
+			{
+				ICompletionData d1 = x as ICompletionData;
+				ICompletionData d2 = y as ICompletionData;
+				return String.Compare (d1.Text[0], d2.Text[0]);
+			}
+		}
+		
+		static CompletionListWindow wnd;
+		
+		static CompletionListWindow ()
+		{
+			wnd = new CompletionListWindow ();
+		}
+		
+		public CompletionListWindow ()
+		{
+			SizeAllocated += new SizeAllocatedHandler (ListSizeChanged);
+		}
+		
+		public static void ShowWindow (char firstChar, TextIter trigIter, ICompletionDataProvider provider, SourceEditorView ctrl)
+		{
+			wnd.ShowListWindow (firstChar, trigIter, provider,  ctrl);
+		}
+		
+		void ShowListWindow (char firstChar, TextIter trigIter, ICompletionDataProvider provider, SourceEditorView ctrl)
+		{
+			this.control = ctrl;
+			this.fileName = ctrl.ParentEditor.DisplayBinding.ContentName;
+			this.project = ctrl.ParentEditor.DisplayBinding.Project;
+			triggeringMark = control.Buffer.CreateMark (null, trigIter, true);
+			
+			completionData = provider.GenerateCompletionData (project, fileName, ctrl, firstChar, triggeringMark);
+			if (completionData == null || completionData.Length == 0) return;
+			
+			this.Style = ctrl.Style.Copy();
+			
+			Array.Sort (completionData, dataComparer);
+			
+			DataProvider = this;
+			Gdk.Rectangle rect = control.GetIterLocation (control.Buffer.GetIterAtMark (triggeringMark));
+
+			int wx, wy;
+			control.BufferToWindowCoords (Gtk.TextWindowType.Widget, rect.X /*+ rect.Width*/, rect.Y + rect.Height, out wx, out wy);
+			
+			int tx, ty;
+			control.GdkWindow.GetOrigin (out tx, out ty);
+			
+			Move (tx + wx, ty + wy);
+			Show ();
+		}
+		
+		public static void HideWindow ()
+		{
+			wnd.Hide ();
+		}
+		
+		public static bool ProcessKeyEvent (Gdk.EventKey e)
+		{
+			if (!wnd.Visible) return false;
+			
+			ListWindow.KeyAction ka = wnd.ProcessKey (e);
+			
+			if ((ka &amp; ListWindow.KeyAction.CloseWindow) != 0)
+				wnd.Hide ();
+				
+			if ((ka &amp; ListWindow.KeyAction.Complete) != 0) {
+				TextIter offsetIter = wnd.control.Buffer.GetIterAtMark (wnd.triggeringMark);
+				TextIter endIter = wnd.control.Buffer.GetIterAtOffset (offsetIter.Offset + wnd.PartialWord.Length);
+				wnd.control.Buffer.MoveMark (wnd.control.Buffer.InsertMark, offsetIter);
+				wnd.control.Buffer.Delete (offsetIter, endIter);
+				wnd.control.Buffer.InsertAtCursor (wnd.CompleteWord);
+			}
+			
+			if ((ka &amp; ListWindow.KeyAction.Ignore) != 0)
+				return true;
+				
+			return false;
+		}
+		
+		public new void Hide ()
+		{
+			base.Hide ();
+			declarationviewwindow.HideAll ();
+		}
+		
+		void ListSizeChanged (object obj, SizeAllocatedArgs args)
+		{
+			Console.WriteLine (&quot;ListSizeChanged&quot;);
+			UpdateDeclarationView ();
+		}
+		
+		protected override void OnSelectionChanged ()
+		{
+			base.OnSelectionChanged ();
+			UpdateDeclarationView ();
+		}
+		
+		void UpdateDeclarationView ()
+		{
+			ICompletionData data = completionData[List.Selection];
+			
+			// FIXME: This code is buggy, and generates a bad placement sometimes when you jump a lot.
+			// but it is better than 0,0
+			// This code is for sizing the treeview properly.
+			
+			if (List.GdkWindow == null) return;
+			Gdk.Rectangle rect = List.GetRowArea (List.Selection);
+			int listpos_x = 0, listpos_y = 0;
+			while (listpos_x == 0)
+				GetPosition (out listpos_x, out listpos_y);
+			int vert = listpos_y + rect.Y;
+			
+			int lvWidth, lvHeight;
+			this.GdkWindow.GetSize (out lvWidth, out lvHeight);
+			if (vert &gt;= listpos_y + lvHeight - 2) {
+				vert = listpos_y + lvHeight - rect.Height;
+			} else if (vert &lt; listpos_y) {
+				vert = listpos_y;
+			}
+			// FIXME: This is a bad calc, its always on the right,
+			// it needs to test if thats too big, and if so, place on the left;
+			int horiz = listpos_x + lvWidth + 2;
+			ICompletionDataWithMarkup wMarkup = data as ICompletionDataWithMarkup;
+			declarationviewwindow.Destroy ();
+			
+			if (wMarkup != null) {
+				declarationviewwindow = new DeclarationViewWindow ();
+				declarationviewwindow.DescriptionMarkup = wMarkup.DescriptionPango;
+			} else {
+				declarationviewwindow = new DeclarationViewWindow ();
+				declarationviewwindow.DescriptionMarkup = data.Description;
+			}
+		
+			if (declarationviewwindow.DescriptionMarkup.Length == 0)
+				return;
+
+			int dvwWidth, dvwHeight;
+			declarationviewwindow.Move (this.Screen.Width+1, vert);
+
+			declarationviewwindow.ShowAll ();
+			
+			declarationviewwindow.GdkWindow.GetSize (out dvwWidth, out dvwHeight);
+			if (this.Screen.Width &lt;= horiz + dvwWidth) {
+				horiz = listpos_x - dvwWidth - 10;
+			}
+		
+			declarationviewwindow.Move (horiz, vert);
+		}
+		
+		public int ItemCount 
+		{ 
+			get { return completionData.Length; } 
+		}
+		
+		public string GetText (int n)
+		{
+			return completionData[n].Text[0];
+		}
+		
+		public Gdk.Pixbuf GetIcon (int n)
+		{
+			return RenderIcon (completionData[n].Image, Gtk.IconSize.Menu, &quot;&quot;);
+		}
+	}
+}

Added: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs	2004-09-09 01:59:22 UTC (rev 1949)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion/ListWindow.cs	2004-09-18 13:47:34 UTC (rev 1950)
@@ -0,0 +1,437 @@
+using Gtk;
+using Gdk;
+using Pango;
+using System;
+using System.Text;
+
+namespace MonoDevelop.SourceEditor.CodeCompletion
+{
+	public class ListWindow: Gtk.Window
+	{
+		VScrollbar scrollbar;
+		ListWidget list;
+		IListDataProvider provider;
+		
+		StringBuilder word;
+		int curPos;
+		
+		[Flags]
+		public enum KeyAction { Process=1, Ignore=2, CloseWindow=4, Complete=8 } 
+
+		public ListWindow (): base (Gtk.WindowType.Popup)
+		{
+			HBox box = new HBox ();
+			
+			list = new ListWidget (this);
+			list.SelectionChanged += new EventHandler (OnSelectionChanged);
+			box.PackStart (list, true, true, 0);
+			this.BorderWidth = 1;
+			
+			scrollbar = new VScrollbar (null);
+			scrollbar.ValueChanged += new EventHandler (OnScrollChanged); 
+			box.PackStart (scrollbar, false, false, 0);
+			
+			Add (box);
+			this.TypeHint = WindowTypeHint.Menu;
+		}
+		
+		public new void Show ()
+		{
+			this.ShowAll ();
+			Reset ();
+		}
+		
+		public void Reset ()
+		{
+			word = new StringBuilder ();
+			curPos = 0;
+			scrollbar.Adjustment.Lower = 0;
+			scrollbar.Adjustment.Upper = provider.ItemCount - list.VisibleRows;
+			scrollbar.Adjustment.PageIncrement = list.VisibleRows - 1;
+			scrollbar.Adjustment.StepIncrement = 1;
+			list.Reset ();
+		}
+		
+		public IListDataProvider DataProvider
+		{
+			get { return provider; }
+			set { provider = value; }
+		}
+		
+		public string CompleteWord
+		{
+			get { return provider.GetText (list.Selection);	}
+		}
+		
+		public string PartialWord
+		{
+			get { return word.ToString (); }
+		}
+		
+		protected ListWidget List
+		{
+			get { return list; }
+		}
+		
+		public KeyAction ProcessKey (EventKey e)
+		{
+			switch (e.Key)
+			{
+				case Gdk.Key.Up:
+					list.Selection --;
+					return KeyAction.Ignore;
+					
+				case Gdk.Key.Down:
+					list.Selection ++;
+					return KeyAction.Ignore;
+					
+				case Gdk.Key.Page_Up:
+					list.Selection -= list.VisibleRows - 1;
+					return KeyAction.Ignore;
+					
+				case Gdk.Key.Page_Down:
+					list.Selection += list.VisibleRows - 1;
+					return KeyAction.Ignore;
+					
+				case Gdk.Key.Left:
+					if (curPos == 0) return KeyAction.CloseWindow | KeyAction.Process;
+					curPos--;
+					return KeyAction.Process;
+					
+				case Gdk.Key.BackSpace:
+					if (curPos == 0) return KeyAction.CloseWindow | KeyAction.Process;
+					curPos--;
+					word.Remove (curPos, 1);
+					UpdateWordSelection ();
+					return KeyAction.Process;
+					
+				case Gdk.Key.Right:
+					if (curPos == word.Length) return KeyAction.CloseWindow | KeyAction.Process;
+					curPos++;
+					return KeyAction.Process;
+					
+				case Gdk.Key.Tab:
+				case Gdk.Key.Return:
+				case Gdk.Key.ISO_Enter:
+				case Gdk.Key.Key_3270_Enter:
+				case Gdk.Key.KP_Enter:
+					return KeyAction.Complete | KeyAction.Ignore | KeyAction.CloseWindow;
+					
+				case Gdk.Key.Escape:
+					return KeyAction.CloseWindow | KeyAction.Ignore;
+					
+				case Gdk.Key.Home:
+				case Gdk.Key.End:
+					return KeyAction.CloseWindow | KeyAction.Process;
+					
+				case Gdk.Key.Control_L:
+				case Gdk.Key.Control_R:
+				case Gdk.Key.Alt_L:
+				case Gdk.Key.Alt_R:
+				case Gdk.Key.Shift_L:
+				case Gdk.Key.Shift_R:
+				case Gdk.Key.ISO_Level3_Shift:	// AltGr
+					return KeyAction.Process;
+			}
+			
+			char c = (char)e.KeyValue;
+			
+			if (Char.IsLetterOrDigit (c) || c == '_') {
+				word.Insert (curPos++, c);
+				UpdateWordSelection ();
+				return KeyAction.Process;
+			}
+			else if ((Char.IsPunctuation (c) || c == ' ') &amp;&amp; !list.SelectionDisabled) {
+				return KeyAction.Complete | KeyAction.Process | KeyAction.CloseWindow;
+			}
+			
+			return KeyAction.CloseWindow | KeyAction.Process;
+		}
+		
+		void UpdateWordSelection ()
+		{
+			string s = word.ToString ();
+			int max = provider.ItemCount;
+			
+			int bestMatch = -1;
+			for (int n=0; n&lt;max; n++) 
+			{
+				string txt = provider.GetText (n);
+				if (txt.StartsWith (s)) {
+					list.Selection = n;
+					return;
+				}
+				else if (bestMatch == -1 &amp;&amp; txt.ToLower().StartsWith (s.ToLower()))
+					bestMatch = n;
+			}
+			
+			if (bestMatch != -1) {
+				list.Selection = bestMatch;
+				return;
+			}
+			
+			list.SelectionDisabled = true;
+		}
+		
+		void OnScrollChanged (object o, EventArgs args)
+		{
+			list.Page = (int) scrollbar.Value;
+		}
+		
+		void OnSelectionChanged (object o, EventArgs args)
+		{
+			scrollbar.Value = list.Page;
+			OnSelectionChanged ();
+		}
+		
+		protected virtual void OnSelectionChanged ()
+		{
+		}
+		
+		protected override bool OnExposeEvent (Gdk.EventExpose args)
+		{
+			base.OnExposeEvent (args);
+			
+			int winWidth, winHeight;
+			this.GetSize (out winWidth, out winHeight);
+			this.GdkWindow.DrawRectangle (this.Style.ForegroundGC (StateType.Insensitive), false, 0, 0, winWidth-1, winHeight-1);
+			return false;
+		}		
+	}
+
+	public class ListWidget: Gtk.DrawingArea
+	{
+		int margin = 2;
+		int leftPadding = 2;
+		int lineSep = 2;
+		int listWidth = 300;
+		
+		Pango.Layout layout;
+		ListWindow win;
+		int selection = 0;
+		int page = 0;
+		int visibleRows = -1;
+		int rowWidth, rowHeight;
+		bool buttonPressed;
+		bool disableSelection;
+
+		public event EventHandler SelectionChanged;
+				
+		public ListWidget (ListWindow win)
+		{
+			this.win = win;
+			this.Events = EventMask.ButtonPressMask | EventMask.ButtonReleaseMask | EventMask.PointerMotionMask; 
+		}
+		
+		public void Reset ()
+		{
+			selection = 0;
+			page = 0;
+			disableSelection = false;
+			UpdateStyle ();
+			QueueDraw ();
+			if (SelectionChanged != null) SelectionChanged (this, EventArgs.Empty);
+		}
+		
+		public int Selection
+		{
+			get {
+				return selection;
+			}
+			
+			set {
+				if (value &lt; 0)
+					value = 0;
+				else if (value &gt;= win.DataProvider.ItemCount)
+					value = win.DataProvider.ItemCount - 1;
+					
+				if (value != selection) 
+				{
+					selection = value;
+						
+					if (selection &lt; page)
+						page = selection;
+					else if (selection &gt;= page + VisibleRows) {
+						page = selection - VisibleRows + 1;
+						if (page &lt; 0) page = 0;
+					}
+					
+					if (SelectionChanged != null) SelectionChanged (this, EventArgs.Empty);
+				}
+				
+				if (disableSelection)
+					disableSelection = false;
+
+				this.QueueDraw ();
+			}
+		}
+		
+		public bool SelectionDisabled
+		{
+			get { return disableSelection; }
+			
+			set {
+				disableSelection = value; 
+				this.QueueDraw ();
+			}
+		}
+		
+		public int Page
+		{
+			get { 
+				return page; 
+			}
+			
+			set {
+				page = value;
+				this.QueueDraw ();
+			}
+		}
+		
+		protected override bool OnButtonPressEvent (EventButton e)
+		{
+			Selection = GetRowByPosition ((int) e.Y);
+			buttonPressed = true;
+			return base.OnButtonPressEvent (e);
+		}
+		
+		protected override bool OnButtonReleaseEvent (EventButton e)
+		{
+			buttonPressed = false;
+			return base.OnButtonReleaseEvent (e);
+		}
+		
+		protected override bool OnMotionNotifyEvent (EventMotion e)
+		{
+			if (!buttonPressed)
+				return base.OnMotionNotifyEvent (e);
+			
+			int winWidth, winHeight;
+			this.GdkWindow.GetSize (out winWidth, out winHeight);
+			
+	/*		int ypos = (int) e.Y;
+			if (ypos &lt; 0) {
+			}
+			else if (ypos &gt;= winHeight) {
+			}
+			else
+	*/			Selection = GetRowByPosition ((int) e.Y);
+			
+			return true;
+		}
+		
+		protected override bool OnExposeEvent (Gdk.EventExpose args)
+		{
+			base.OnExposeEvent (args);
+			DrawList ();
+	  		return true;
+		}
+		
+		void DrawList ()
+		{
+			int winWidth, winHeight;
+			this.GdkWindow.GetSize (out winWidth, out winHeight);
+			
+			int ypos = margin;
+			int lineWidth = winWidth - margin*2;
+			int count = win.DataProvider.ItemCount;
+			
+			int xpos = margin + leftPadding;
+				
+			int n = 0;
+			while (ypos &lt; winHeight - margin &amp;&amp; (page + n) &lt; win.DataProvider.ItemCount)
+			{
+				layout.SetMarkup (win.DataProvider.GetText (page + n));
+				Gdk.Pixbuf icon = win.DataProvider.GetIcon (page + n);
+				
+				int wi, he, typos, iypos;
+				layout.GetPixelSize (out wi, out he);
+				typos = he &lt; rowHeight ? ypos + (rowHeight - he) / 2 : ypos;
+				iypos = icon.Height &lt; rowHeight ? ypos + (rowHeight - icon.Height) / 2 : ypos;
+				
+				if (page + n == selection) {
+					if (!disableSelection) {
+						this.GdkWindow.DrawRectangle (this.Style.BaseGC (StateType.Selected), true, margin, ypos, lineWidth, he);
+						this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Selected), xpos + icon.Width + 2, typos, layout);
+					}
+					else {
+						this.GdkWindow.DrawRectangle (this.Style.BaseGC (StateType.Selected), false, margin, ypos, lineWidth, he);
+						this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Normal), xpos + icon.Width + 2, typos, layout);
+					}
+				}
+				else
+					this.GdkWindow.DrawLayout (this.Style.TextGC (StateType.Normal), xpos + icon.Width + 2, typos, layout);
+					
+				this.GdkWindow.DrawPixbuf (this.Style.ForegroundGC (StateType.Normal), icon, 0, 0, xpos, iypos, icon.Width, icon.Height, Gdk.RgbDither.None, 0, 0);
+				
+				ypos += rowHeight;
+				n++;
+			}
+		}
+		
+		int GetRowByPosition (int ypos)
+		{
+			if (visibleRows == -1) CalcVisibleRows ();
+			return page + (ypos-margin) / rowHeight;
+		}
+		
+		public Gdk.Rectangle GetRowArea (int row)
+		{
+			row -= page;
+			int winWidth, winHeight;
+			this.GdkWindow.GetSize (out winWidth, out winHeight);
+			
+			return new Gdk.Rectangle (margin, margin + rowHeight * row, winWidth, rowHeight);
+		}
+		
+		public int VisibleRows
+		{
+			get {
+				if (visibleRows == -1) CalcVisibleRows ();
+				return visibleRows;
+			}
+		}
+		
+		void CalcVisibleRows ()
+		{
+			int winHeight = 200;
+			int lvWidth, lvHeight;
+			this.GdkWindow.GetSize (out lvWidth, out lvHeight);
+
+			layout.GetPixelSize (out rowWidth, out rowHeight);
+			rowHeight += lineSep;
+			visibleRows = (winHeight + lineSep - margin * 2) / rowHeight;
+			
+			int newHeight = (rowHeight * visibleRows) + margin * 2 - lineSep;
+			
+			if (lvWidth != listWidth || lvHeight != newHeight)
+				this.SetSizeRequest (listWidth, newHeight);
+		} 
+
+		protected override void OnRealized ()
+		{
+			base.OnRealized ();
+			UpdateStyle ();
+		}
+		
+		void UpdateStyle ()
+		{
+			this.GdkWindow.Background = this.Style.Base (StateType.Normal);
+			layout = new Pango.Layout (this.PangoContext);
+			layout.Wrap = Pango.WrapMode.Char;
+			
+			FontDescription des = this.Style.FontDescription.Copy();
+			des.Size = win.Style.FontDescription.Size;
+			layout.FontDescription = des;
+			CalcVisibleRows ();
+		}
+	}
+
+	public interface IListDataProvider
+	{
+		int ItemCount { get; }
+		string GetText (int n);
+		Gdk.Pixbuf GetIcon (int n);
+	}
+}
+

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs	2004-09-09 01:59:22 UTC (rev 1949)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs	2004-09-18 13:47:34 UTC (rev 1950)
@@ -31,6 +31,7 @@
 		public SourceEditorBuffer buf;
 		int lineToMark = -1;
 		bool codeCompleteEnabled;
+		bool autoHideCompletionWindow = true;
 
 		public static new GLib.GType GType
 		{
@@ -57,13 +58,34 @@
 			ShowLineNumbers = true;
 			ShowLineMarkers = true;
 			ButtonPressEvent += new ButtonPressEventHandler (buttonPress);
+			FocusOutEvent += new FocusOutEventHandler (OnFocusOut);
 			buf.PlaceCursor (buf.StartIter);
 			GrabFocus ();
-
+			buf.MarkSet += new MarkSetHandler (BufferMarkSet);
+			buf.Changed += new EventHandler (BufferChanged);
 		}
-
+		
+		void BufferMarkSet (object s, MarkSetArgs a)
+		{
+			if (autoHideCompletionWindow &amp;&amp; a.Mark.Name == &quot;insert&quot;)
+				CompletionListWindow.HideWindow ();
+		}
+		
+		void OnFocusOut (object s, FocusOutEventArgs args)
+		{
+			CompletionListWindow.HideWindow ();
+		}
+		
+		void BufferChanged (object s, EventArgs args)
+		{
+			if (autoHideCompletionWindow)
+				CompletionListWindow.HideWindow ();
+		}
+		
 		void buttonPress (object o, ButtonPressEventArgs e)
 		{
+			CompletionListWindow.HideWindow ();
+			
 			if (!ShowLineMarkers)
 				return;
 			
@@ -95,7 +117,7 @@
 				}
 			}
 		}
-
+		
 		public void bookmarkToggled (object o, EventArgs e)
 		{
 			if (lineToMark == -1) return;
@@ -170,7 +192,8 @@
 			if (triggerIter.Equals (TextIter.Zero)) return;
 			triggerIter.ForwardChar ();
 			
-			CompletionWindow.ShowWindow (triggerChar, triggerIter, true, new CodeCompletionDataProvider (true), this);
+//			CompletionWindow.ShowWindow (triggerChar, triggerIter, true, new CodeCompletionDataProvider (true), this);
+			CompletionListWindow.ShowWindow (triggerChar, triggerIter, new CodeCompletionDataProvider (true), this);
 		}
 
 		bool MonodocResolver ()
@@ -223,6 +246,17 @@
 		
 		protected override bool OnKeyPressEvent (Gdk.EventKey evnt)
 		{
+			if (CompletionListWindow.ProcessKeyEvent (evnt))
+				return true;
+			
+			autoHideCompletionWindow = false;
+			bool res = ProcessPressEvent (evnt);
+			autoHideCompletionWindow = true;
+			return res;
+		}
+		
+		bool ProcessPressEvent (Gdk.EventKey evnt)
+		{
 			Gdk.Key key = evnt.Key;
 			uint state = (uint)evnt.State;
 			state &amp;= 1101u;
@@ -291,7 +325,8 @@
 			case '.':
 				bool retval = base.OnKeyPressEvent (evnt);
 				if (EnableCodeCompletion) {
-					CompletionWindow.ShowWindow ((char)key, buf.GetIterAtMark (buf.InsertMark), false, new CodeCompletionDataProvider (), this);
+//					CompletionWindow.ShowWindow ((char)key, buf.GetIterAtMark (buf.InsertMark), false, new CodeCompletionDataProvider (), this);
+					CompletionListWindow.ShowWindow ((char)key, buf.GetIterAtMark (buf.InsertMark), new CodeCompletionDataProvider (), this);
 				}
 				return retval;
 				/*case '(':

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Makefile.am	2004-09-09 01:59:22 UTC (rev 1949)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Makefile.am	2004-09-18 13:47:34 UTC (rev 1950)
@@ -4,6 +4,8 @@
 ./CodeCompletion/CodeCompletionData.cs \
 ./CodeCompletion/ICompletionData.cs \
 ./CodeCompletion/CompletionWindow.cs \
+./CodeCompletion/CompletionListWindow.cs \
+./CodeCompletion/ListWindow.cs \
 ./CodeCompletion/TextUtilities.cs \
 ./CodeCompletion/TemplateCompletionDataProvider.cs \
 ./CodeCompletion/CommentCompletionDataProvider.cs \

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceInFilesManager.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceInFilesManager.cs	2004-09-09 01:59:22 UTC (rev 1949)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceInFilesManager.cs	2004-09-18 13:47:34 UTC (rev 1950)
@@ -37,6 +37,7 @@
 		static DateTime timer;
 		static bool searching;
 		static bool cancelled;
+		static string searchError;
 		
 		public static SearchOptions SearchOptions {
 			get {
@@ -121,8 +122,13 @@
 		{
 			TaskService taskService = (TaskService)MonoDevelop.Core.Services.ServiceManager.GetService(typeof(TaskService));
 			string msg;
-			if (cancelled) msg = GettextCatalog.GetString (&quot;Search cancelled.&quot;);
-			else msg = string.Format (GettextCatalog.GetString (&quot;Search completed. {0} matches found in {1} files.&quot;), find.MatchCount, find.SearchedFileCount);
+			if (searchError != null)
+				msg = string.Format (GettextCatalog.GetString (&quot;The search could not be finished: {0}&quot;), searchError);
+			else if (cancelled)
+				msg = GettextCatalog.GetString (&quot;Search cancelled.&quot;);
+			else
+				msg = string.Format (GettextCatalog.GetString (&quot;Search completed. {0} matches found in {1} files.&quot;), find.MatchCount, find.SearchedFileCount);
+				
 			taskService.AddTask (new Task(null, msg, -1, -1));
 			
 			// present the taskview to show the search results
@@ -166,16 +172,26 @@
 		{
 			DispatchService dispatcher = (DispatchService)ServiceManager.GetService (typeof (DispatchService));
 			searching = true;
+			searchError = null;
 			
-			while (!cancelled) {
-				ISearchResult result = find.FindNext(searchOptions);
-				if (result == null) {
+			while (!cancelled) 
+			{
+				try
+				{
+					ISearchResult result = find.FindNext(searchOptions);
+					if (result == null) {
+						break;
+					}
+					
+					find.Replace(result, result.TransformReplacePattern(SearchOptions.ReplacePattern));
+					
+					dispatcher.GuiDispatch (new StatefulMessageHandler (DisplaySearchResultCallback), result);
+				}
+				catch (Exception ex) 
+				{
+					searchError = ex.Message;
 					break;
 				}
-				
-				find.Replace(result, result.TransformReplacePattern(SearchOptions.ReplacePattern));
-				
-				dispatcher.GuiDispatch (new StatefulMessageHandler (DisplaySearchResultCallback), result);
 			}
 			
 			dispatcher.GuiDispatch (new MessageHandler (FinishSearchInFiles));
@@ -207,14 +223,24 @@
 		{
 			DispatchService dispatcher = (DispatchService)ServiceManager.GetService (typeof (DispatchService));
 			searching = true;
+			searchError = null;
 			
-			while (!cancelled) {
-				ISearchResult result = find.FindNext (searchOptions);
-				if (result == null) {
+			while (!cancelled) 
+			{
+				try
+				{
+					ISearchResult result = find.FindNext (searchOptions);
+					if (result == null) {
+						break;
+					}
+	
+					dispatcher.GuiDispatch (new StatefulMessageHandler (DisplaySearchResultCallback), result);
+				}
+				catch (Exception ex)
+				{
+					searchError = ex.Message;
 					break;
 				}
-
-				dispatcher.GuiDispatch (new StatefulMessageHandler (DisplaySearchResultCallback), result);
 			}
 			
 			dispatcher.GuiDispatch (new MessageHandler (FinishSearchInFiles));

Modified: trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextFileIterator.cs
===================================================================
--- trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextFileIterator.cs	2004-09-09 01:59:22 UTC (rev 1949)
+++ trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextFileIterator.cs	2004-09-18 13:47:34 UTC (rev 1950)
@@ -114,9 +114,10 @@
 			if (reader.Modified)
 			{
 				string fileBackup = Path.GetTempFileName ();
-				File.Move (fileName, fileBackup);
+				File.Copy (fileName, fileBackup, true);
 				
 				try {
+					File.Delete (fileName);
 					reader.SaveToFile (fileName);
 					reader.Close ();
 				}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="001556.html">[Monodevelop-patches-list] r1951 - trunk/MonoDevelop/Core/src/AddIns/DisplayBindings/SourceEditor/CodeCompletion
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1555">[ date ]</a>
              <a href="thread.html#1555">[ thread ]</a>
              <a href="subject.html#1555">[ subject ]</a>
              <a href="author.html#1555">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
