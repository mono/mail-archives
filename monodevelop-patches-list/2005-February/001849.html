<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r2245 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Services/Project
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2245%20-%20in%20trunk/MonoDevelop/Core/src/MonoDevelop.Base%3A%20.%20Services/Project&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001848.html">
   <LINK REL="Next"  HREF="001850.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r2245 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Services/Project</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r2245%20-%20in%20trunk/MonoDevelop/Core/src/MonoDevelop.Base%3A%20.%20Services/Project&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r2245 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Services/Project">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Thu Feb 10 20:48:43 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001848.html">[Monodevelop-patches-list] r2244 - in trunk/MonoDevelop: . Core/src/MonoDevelop.Base Core/src/MonoDevelop.Base/Commands Core/src/MonoDevelop.Base/Gui/Dialogs Core/src/MonoDevelop.Base/Internal/Project Core/src/MonoDevelop.Base/Internal/Project/Combine Core/src/MonoDevelop.Base/Internal/Project/Project Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates Core/src/MonoDevelop.Base/Services Core/src/MonoDevelop.Base/Services/Project
</A></li>
        <LI>Next message: <A HREF="001850.html">[Monodevelop-patches-list] r2246 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Internal/Project/Combine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1849">[ date ]</a>
              <a href="thread.html#1849">[ thread ]</a>
              <a href="subject.html#1849">[ subject ]</a>
              <a href="author.html#1849">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tberman
Date: 2005-02-10 20:48:43 -0500 (Thu, 10 Feb 2005)
New Revision: 2245

Added:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs
Removed:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs
Modified:
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
   trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml
Log:
	* Services/Project/DefaultProjectService.cs: Moved, see below.
	* Services/Project/ProjectService.cs:
	* Makefile.am:
	* MonoDevelopCore.addin.xml:

	Moved DefaultProjectService to ProjectService.

2005-02-10  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at off.net</A>&gt;



Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-02-11 01:41:58 UTC (rev 2244)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/ChangeLog	2005-02-11 01:48:43 UTC (rev 2245)
@@ -1,5 +1,14 @@
 2005-02-10  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at off.net</A>&gt;
 
+	* Services/Project/DefaultProjectService.cs: Moved, see below.
+	* Services/Project/ProjectService.cs:
+	* Makefile.am:
+	* MonoDevelopCore.addin.xml:
+
+	Moved DefaultProjectService to ProjectService.
+
+2005-02-10  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at off.net</A>&gt;
+
 	* Commands/FileCommands.cs:
 	* Services/Project/DefaultProjectService.cs:
 	* Services/IconService.cs:

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-02-11 01:41:58 UTC (rev 2244)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Makefile.am	2005-02-11 01:48:43 UTC (rev 2245)
@@ -190,7 +190,7 @@
 Services/Project/ProjectEventArgs.cs \
 Services/Project/IProjectService.cs \
 Services/Project/ProjectRenameEventArgs.cs \
-Services/Project/DefaultProjectService.cs \
+Services/Project/ProjectService.cs \
 Services/Project/ParseInformationEventHandler.cs \
 Services/Project/CombineEventArgs.cs \
 Services/Project/FileFormatManager.cs \

Modified: trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml	2005-02-11 01:41:58 UTC (rev 2244)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/MonoDevelopCore.addin.xml	2005-02-11 01:48:43 UTC (rev 2245)
@@ -37,7 +37,7 @@
 		&lt;Class id    = &quot;SystemAssemblyService&quot;
 		       class = &quot;MonoDevelop.Services.SystemAssemblyService&quot;/&gt;
 		&lt;Class id    = &quot;ProjectService&quot;
-		       class = &quot;MonoDevelop.Services.DefaultProjectService&quot;/&gt;
+		       class = &quot;MonoDevelop.Services.ProjectService&quot;/&gt;
 		&lt;Class id    = &quot;FileService&quot;
 		       class = &quot;MonoDevelop.Services.DefaultFileService&quot;/&gt;
 		&lt;Class id    = &quot;ParserService&quot;

Deleted: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs	2005-02-11 01:41:58 UTC (rev 2244)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs	2005-02-11 01:48:43 UTC (rev 2245)
@@ -1,930 +0,0 @@
-// &lt;file&gt;
-//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
-//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
-//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
-//     &lt;version value=&quot;$version&quot;/&gt;
-// &lt;/file&gt;
-
-using System;
-using System.Collections;
-using System.Diagnostics;
-using System.IO;
-using System.Xml;
-using System.CodeDom.Compiler;
-using System.Threading;
-
-using MonoDevelop.Gui;
-using MonoDevelop.Internal.Project;
-using MonoDevelop.Internal.Serialization;
-
-using MonoDevelop.Core.Properties;
-using MonoDevelop.Core.Services;
-using MonoDevelop.Core.AddIns.Codons;
-using MonoDevelop.Internal.Templates;
-using MonoDevelop.Core.AddIns;
-
-namespace MonoDevelop.Services
-{
-	
-	public enum BeforeCompileAction {
-		Nothing,
-		SaveAllFiles,
-		PromptForSave,
-	}
-	
-	public class DefaultProjectService : AbstractService, IProjectService
-	{
-		Project currentProject = null;
-		Combine  currentCombine = null;
-		Combine  openCombine    = null;
-		DataContext dataContext = new DataContext ();
-		ProjectBindingCodon[] projectBindings;
-		
-		IAsyncOperation currentBuildOperation;
-		IAsyncOperation currentRunOperation;
-		
-		FileFormatManager formatManager = new FileFormatManager ();
-		IFileFormat defaultProjectFormat = new MdsFileFormat ();
-		IFileFormat defaultCombineFormat = new MdpFileFormat ();
-		
-		ICompilerResult lastResult = new DefaultCompilerResult ();
-			
-		public Project CurrentSelectedProject {
-			get {
-				return currentProject;
-			}
-			set {
-				Debug.Assert(openCombine != null);
-				currentProject = value;
-				OnCurrentProjectChanged(new ProjectEventArgs(currentProject));
-			}
-		}
-		
-		public Combine CurrentSelectedCombine {
-			get {
-				return currentCombine;
-			}
-			set {
-				Debug.Assert(openCombine != null);
-				currentCombine = value;
-				OnCurrentSelectedCombineChanged(new CombineEventArgs(currentCombine));
-			}
-		}
-		
-		public Combine CurrentOpenCombine {
-			get {
-				return openCombine;
-			}
-			set {
-				openCombine = value;
-			}
-		}
-		
-		public ICompilerResult LastCompilerResult {
-			get { return lastResult; }
-		}
-		
-		bool IsDirtyFileInCombine {
-			get {
-				CombineEntryCollection projects = openCombine.GetAllProjects();
-				
-				foreach (Project projectEntry in projects) {
-					foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
-						foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
-							if (content.IsDirty &amp;&amp; content.ContentName == fInfo.Name) {
-								return true;
-							}
-						}
-					}
-				}
-				return false;
-			}
-		}
-		
-		public bool NeedsCompiling {
-			get {
-				if (openCombine == null) {
-					return false;
-				}
-				return openCombine.NeedsBuilding || IsDirtyFileInCombine;
-			}
-		}
-		
-		public DataContext DataContext {
-			get { return dataContext; }
-		}
-		
-		public FileFormatManager FileFormats {
-			get { return formatManager; }
-		}
-		
-		public void SaveCombinePreferences()
-		{
-			if (CurrentOpenCombine != null)
-				SaveCombinePreferences(CurrentOpenCombine);
-		}
-		
-		public CombineEntry ReadFile (string file, IProgressMonitor monitor)
-		{
-			IFileFormat format = formatManager.GetFileFormat (file);
-
-			if (format == null)
-				throw new InvalidOperationException (&quot;Unknown file format: &quot; + file);
-			
-			CombineEntry obj = format.ReadFile (file, monitor) as CombineEntry;
-			if (obj == null)
-				throw new InvalidOperationException (&quot;Invalid file format: &quot; + file);
-			
-			if (obj.FileFormat == null)	
-				obj.FileFormat = format;
-
-			return obj;
-		}
-		
-		public void WriteFile (string file, CombineEntry entry, IProgressMonitor monitor)
-		{
-			IFileFormat format = entry.FileFormat;
-			if (format == null) {
-				if (entry is Project) format = defaultProjectFormat;
-				else if (entry is Combine) format = defaultCombineFormat;
-				else format = formatManager.GetFileFormatForObject (entry);
-				
-				if (format == null)
-					throw new InvalidOperationException (&quot;FileFormat not provided for combine entry '&quot; + entry.Name + &quot;'&quot;);
-			}
-			entry.FileName = format.GetValidFormatName (file);
-			format.WriteFile (entry.FileName, entry, monitor);
-		}
-		
-		public Project CreateSingleFileProject (string file)
-		{
-			foreach (ProjectBindingCodon projectBinding in projectBindings) {
-				Project project = projectBinding.ProjectBinding.CreateSingleFileProject (file);
-				if (project != null)
-					return project;
-			}
-			return null;
-		}
-		
-		public Project CreateProject (string type, ProjectCreateInformation info, XmlElement projectOptions)
-		{
-			foreach (ProjectBindingCodon projectBinding in projectBindings) {
-				if (projectBinding.ProjectBinding.Name == type) {
-					Project project = projectBinding.ProjectBinding.CreateProject (info, projectOptions);
-					return project;
-				}
-			}
-			return null;
-		}
-		
-		public void CloseCombine()
-		{
-			CloseCombine(true);
-		}
-
-		public void CloseCombine (bool saveCombinePreferencies)
-		{
-			if (CurrentOpenCombine != null) {
-				if (saveCombinePreferencies)
-					SaveCombinePreferences (CurrentOpenCombine);
-				Combine closedCombine = CurrentOpenCombine;
-				CurrentSelectedProject = null;
-				CurrentOpenCombine = CurrentSelectedCombine = null;
-				WorkbenchSingleton.Workbench.CloseAllViews();
-				OnCombineClosed(new CombineEventArgs(closedCombine));
-				closedCombine.Dispose();
-			}
-		}
-		
-		FileUtilityService fileUtilityService = Runtime.FileUtilityService;
-		
-		public bool IsCombineEntryFile (string filename)
-		{
-			if (filename.StartsWith (&quot;<A HREF="file://&quot;">file://&quot;</A>))
-				filename = filename.Substring (7);
-				
-			IFileFormat format = formatManager.GetFileFormat (filename);
-			return format != null;
-		}
-		
-		public IAsyncOperation OpenCombine(string filename)
-		{
-			if (openCombine != null) {
-				SaveCombine();
-				CloseCombine();
-			}
-
-			if (filename.StartsWith (&quot;<A HREF="file://&quot;">file://&quot;</A>))
-				filename = filename.Substring (7);
-
-			IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ();
-			
-			object[] data = new object[] { filename, monitor };
-			Runtime.DispatchService.BackgroundDispatch (new StatefulMessageHandler (backgroundLoadCombine), data);
-			return monitor.AsyncOperation;
-		}
-		
-		void backgroundLoadCombine (object arg)
-		{
-			object[] data = (object[]) arg;
-			string filename = data[0] as string;
-			IProgressMonitor monitor = data [1] as IProgressMonitor;
-			
-			try {
-				if (!fileUtilityService.TestFileExists(filename)) {
-					monitor.ReportError (string.Format (GettextCatalog.GetString (&quot;File not found: {0}&quot;), filename), null);
-					return;
-				}
-				
-				string validcombine = Path.ChangeExtension (filename, &quot;.mds&quot;);
-				
-				if (Path.GetExtension (filename).ToLower() != &quot;.mds&quot;) {
-					if (File.Exists (validcombine))
-						filename = validcombine;
-				} else if (Path.GetExtension (filename).ToLower () != &quot;.cmbx&quot;) {
-					if (File.Exists (Path.ChangeExtension (filename, &quot;.cmbx&quot;)))
-						filename = Path.ChangeExtension (filename, &quot;.cmbx&quot;);
-				}
-			
-				CombineEntry entry = ReadFile (filename, monitor);
-				if (!(entry is Combine)) {
-					Combine loadingCombine = new Combine();
-					loadingCombine.Entries.Add (entry);
-					loadingCombine.Name = entry.Name;
-					loadingCombine.Save (validcombine, monitor);
-					entry = loadingCombine;
-				}
-			
-				openCombine = (Combine) entry;
-				
-				Runtime.FileService.RecentOpen.AddLastProject (filename, openCombine.Name);
-				
-				openCombine.FileAddedToProject += new ProjectFileEventHandler (NotifyFileAddedToProject);
-				openCombine.FileRemovedFromProject += new ProjectFileEventHandler (NotifyFileRemovedFromProject);
-				openCombine.FileChangedInProject += new ProjectFileEventHandler (NotifyFileChangedInProject);
-				openCombine.ReferenceAddedToProject += new ProjectReferenceEventHandler (NotifyReferenceAddedToProject);
-				openCombine.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (NotifyReferenceRemovedFromProject);
-		
-				RestoreCombinePreferences (CurrentOpenCombine);
-				SaveCombine ();
-				monitor.ReportSuccess (GettextCatalog.GetString (&quot;Combine loaded.&quot;));
-				OnCombineOpened(new CombineEventArgs(openCombine));
-			} catch (Exception ex) {
-				monitor.ReportError (&quot;Load operation failed.&quot;, ex);
-			} finally {
-				monitor.Dispose ();
-			}
-		}
-		
-		public void SaveCombine()
-		{
-			IProgressMonitor monitor = Runtime.TaskService.GetSaveProgressMonitor ();
-			try {
-				openCombine.Save (monitor);
-				monitor.ReportSuccess (GettextCatalog.GetString (&quot;Combine saved.&quot;));
-			} catch (Exception ex) {
-				monitor.ReportError (GettextCatalog.GetString (&quot;Save failed.&quot;), ex);
-			} finally {
-				monitor.Dispose ();
-			}
-		}
-		
-		public void MarkFileDirty (string filename)
-		{
-			if (openCombine != null) {
-				Project entry = openCombine.GetProjectEntryContaining (filename);
-				if (entry != null) {
-					entry.NeedsBuilding = true;
-				}
-			}
-		}
-
-		public IAsyncOperation ExecuteActiveCombine ()
-		{
-			if (openCombine == null) return NullAsyncOperation.Success;
-			if (currentRunOperation != null &amp;&amp; !currentRunOperation.IsCompleted) return currentRunOperation;
-			IProgressMonitor monitor = new NullProgressMonitor ();
-			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (ExecuteActiveCombineAsync), monitor);
-			currentRunOperation = monitor.AsyncOperation;
-			return currentRunOperation;
-		}
-		
-		void ExecuteActiveCombineAsync (object ob)
-		{
-			IProgressMonitor monitor = (IProgressMonitor) ob;
-
-			OnBeforeStartProject ();
-			try {
-				openCombine.Execute (monitor);
-			} catch (Exception ex) {
-				monitor.ReportError (GettextCatalog.GetString (&quot;Execution failed.&quot;), ex);
-			} finally {
-				monitor.Dispose ();
-			}
-		}
-
-		public IAsyncOperation ExecuteProject (Project project)
-		{
-			IProgressMonitor monitor = new NullProgressMonitor ();
-			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (ExecuteProjectAsync), new object[] {project, monitor});
-			return monitor.AsyncOperation;
-		}
-		
-		void ExecuteProjectAsync (object ob)
-		{
-			object[] data = (object[]) ob;
-			Project project = (Project) data[0];
-			IProgressMonitor monitor = (IProgressMonitor) data[1];
-			OnBeforeStartProject ();
-			try {
-				project.Execute (monitor);
-			} catch (Exception ex) {
-				monitor.ReportError (GettextCatalog.GetString (&quot;Execution failed.&quot;), ex);
-			} finally {
-				monitor.Dispose ();
-			}
-		}
-		
-		class ProjectOperationHandler {
-			public Project Project;
-			public void Run (IAsyncOperation op) { Project.Dispose (); }
-		}
-		
-		public IAsyncOperation BuildFile (string file)
-		{
-			Project tempProject = CreateSingleFileProject (file);
-			if (tempProject != null) {
-				IAsyncOperation aop = BuildProject (tempProject);
-				ProjectOperationHandler h = new ProjectOperationHandler ();
-				h.Project = tempProject;
-				aop.Completed += new OperationHandler (h.Run);
-				return aop;
-			} else {
-				Runtime.MessageService.ShowError (string.Format (GettextCatalog.GetString (&quot;The current file {0} can't be compiled.&quot;), file));
-				return NullAsyncOperation.Failure;
-			}
-		}
-		
-		public IAsyncOperation ExecuteFile (string file)
-		{
-			Project tempProject = CreateSingleFileProject (file);
-			if (tempProject != null) {
-				IAsyncOperation aop = ExecuteProject (tempProject);
-				ProjectOperationHandler h = new ProjectOperationHandler ();
-				h.Project = tempProject;
-				aop.Completed += new OperationHandler (h.Run);
-				return aop;
-			} else {
-				Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;No runnable executable found.&quot;));
-				return NullAsyncOperation.Failure;
-			}
-		}
-	
-		public IAsyncOperation BuildActiveCombine ()
-		{
-			if (openCombine == null) return NullAsyncOperation.Success;
-			if (currentBuildOperation != null &amp;&amp; !currentBuildOperation.IsCompleted) return currentBuildOperation;
-			
-			DoBeforeCompileAction();
-			
-			IProgressMonitor monitor = Runtime.TaskService.GetBuildProgressMonitor ();			
-			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (BuildActiveCombineAsync), monitor);
-			currentBuildOperation = monitor.AsyncOperation;
-			return currentBuildOperation;
-		}
-		
-		void BuildActiveCombineAsync (object ob)
-		{
-			IProgressMonitor monitor = (IProgressMonitor) ob;
-			try {
-				BeginBuild ();
-				ICompilerResult result = openCombine.Build (monitor);
-				BuildDone (monitor, result);
-			} catch (Exception ex) {
-				monitor.ReportError (GettextCatalog.GetString (&quot;Build failed.&quot;), ex);
-			} finally {
-				monitor.Dispose ();
-			}
-		}
-		
-		public IAsyncOperation RebuildActiveCombine()
-		{
-			if (openCombine == null) return NullAsyncOperation.Success;
-			openCombine.Clean ();
-			return BuildActiveCombine ();
-		}
-		
-		public IAsyncOperation BuildActiveProject ()
-		{
-			if (CurrentSelectedProject == null) {
-				Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Active project not set.&quot;));
-				return NullAsyncOperation.Failure;
-			}
-				
-			return BuildProject (CurrentSelectedProject);
-		}
-		
-		public IAsyncOperation RebuildActiveProject ()
-		{
-			return RebuildProject (CurrentSelectedProject);
-		}
-		
-		public IAsyncOperation BuildProject (Project project)
-		{
-			BeforeCompile (project);
-			IProgressMonitor monitor = Runtime.TaskService.GetBuildProgressMonitor ();
-			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (BuildProjectAsync), new object[] {project, monitor});
-			return monitor.AsyncOperation;
-		}
-		
-		public void BuildProjectAsync (object ob)
-		{
-			object[] data = (object[]) ob;
-			Project project = (Project) data [0];
-			IProgressMonitor monitor = (IProgressMonitor) data [1];
-			ICompilerResult result = null;
-			try {
-				BeginBuild ();
-				result = project.Build (monitor);
-				BuildDone (monitor, result);
-			} catch (Exception ex) {
-				monitor.ReportError (GettextCatalog.GetString (&quot;Build failed.&quot;), ex);
-			} finally {
-				monitor.Dispose ();
-			}
-		}
-		
-		public IAsyncOperation RebuildProject (Project project)
-		{
-			project.Clean ();
-			return BuildProject (project);
-		}
-		
-		void BeginBuild ()
-		{
-			Runtime.TaskService.ClearTasks();
-			OnStartBuild ();
-		}
-		
-		void BuildDone (IProgressMonitor monitor, ICompilerResult result)
-		{
-			lastResult = result;
-			monitor.Log.WriteLine ();
-			monitor.Log.WriteLine (String.Format (GettextCatalog.GetString (&quot;---------------------- Done ----------------------&quot;)));
-			
-			foreach (CompilerError err in result.CompilerResults.Errors) {
-				Runtime.TaskService.AddTask (new Task(null, err));
-			}
-			
-			if (result.ErrorCount == 0 &amp;&amp; result.WarningCount == 0 &amp;&amp; lastResult.FailedBuildCount == 0) {
-				monitor.ReportSuccess (GettextCatalog.GetString (&quot;Build successful.&quot;));
-			} else if (result.ErrorCount == 0 &amp;&amp; result.WarningCount &gt; 0) {
-				monitor.ReportWarning (String.Format (GettextCatalog.GetString (&quot;Build: {0} errors, {1} warnings.&quot;), result.ErrorCount, result.WarningCount));
-			} else if (result.ErrorCount &gt; 0) {
-				monitor.ReportError (String.Format (GettextCatalog.GetString (&quot;Build: {0} errors, {1} warnings.&quot;), result.ErrorCount, result.WarningCount), null);
-			} else {
-				monitor.ReportError (String.Format (GettextCatalog.GetString (&quot;Build failed.&quot;)), null);
-			}
-			
-			OnEndBuild (lastResult.FailedBuildCount == 0);
-		}
-		
-		void BeforeCompile (Project project)
-		{
-			DoBeforeCompileAction();
-			
-			// cut&amp;pasted from CombineEntry.cs
-			Runtime.StringParserService.Properties[&quot;Project&quot;] = project.Name;
-			
-			string outputDir = ((AbstractProjectConfiguration)project.ActiveConfiguration).OutputDirectory;
-			try {
-				DirectoryInfo directoryInfo = new DirectoryInfo(outputDir);
-				if (!directoryInfo.Exists) {
-					directoryInfo.Create();
-				}
-			} catch (Exception e) {
-				throw new ApplicationException(&quot;Can't create project output directory &quot; + outputDir + &quot; original exception:\n&quot; + e.ToString());
-			}
-		}
-		
-		void DoBeforeCompileAction()
-		{
-			BeforeCompileAction action = (BeforeCompileAction)Runtime.Properties.GetProperty(&quot;SharpDevelop.Services.DefaultParserService.BeforeCompileAction&quot;, BeforeCompileAction.SaveAllFiles);
-			
-			switch (action) {
-				case BeforeCompileAction.Nothing:
-					break;
-				case BeforeCompileAction.PromptForSave:
-					bool save = false;
-					foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
-						if (content.ContentName != null &amp;&amp; content.IsDirty) {
-							if (!save) {
-								if (Runtime.MessageService.AskQuestion(GettextCatalog.GetString (&quot;Save changed files?&quot;))) {
-									save = true;
-								} else {
-									break;
-								}
-							}
-							MarkFileDirty(content.ContentName);
-							content.Save();
-						}
-					}
-					break;
-				case BeforeCompileAction.SaveAllFiles:
-					foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
-						if (content.ContentName != null &amp;&amp; content.IsDirty) {
-							MarkFileDirty(content.ContentName);
-							content.Save();
-						}
-					}
-					break;
-				default:
-					Debug.Assert(false);
-					break;
-			}
-		}
-		
-		void RemoveFileFromAllProjects(string fileName)
-		{
-			CombineEntryCollection projects = openCombine.GetAllProjects();
-			
-			restart:
-			foreach (Project projectEntry in projects) {
-				foreach (ProjectReference rInfo in projectEntry.ProjectReferences) {
-					if (rInfo.ReferenceType == ReferenceType.Assembly &amp;&amp; rInfo.Reference == fileName) {
-						projectEntry.ProjectReferences.Remove(rInfo);
-						goto restart;
-					}
-				}
-				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
-					if (fInfo.Name == fileName) {
-						projectEntry.ProjectFiles.Remove(fInfo);
-						goto restart;
-					}
-				}
-			}
-		}
-		
-		void RemoveAllInDirectory(string dirName)
-		{
-			CombineEntryCollection projects = openCombine.GetAllProjects();
-			
-			restart:
-			foreach (Project projectEntry in projects) {
-				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
-					if (fInfo.Name.StartsWith(dirName)) {
-						projectEntry.ProjectFiles.Remove(fInfo);
-						goto restart;
-					}
-				}
-			}
-		}
-		
-		void CheckFileRemove(object sender, FileEventArgs e)
-		{
-			if (openCombine != null) {
-				if (e.IsDirectory) {
-					RemoveAllInDirectory(e.FileName);
-				} else {
-					RemoveFileFromAllProjects(e.FileName);
-				}
-			}
-		}
-		
-		void RenameFileInAllProjects(string oldName, string newName)
-		{
-			CombineEntryCollection projects = openCombine.GetAllProjects();
-			
-			foreach (Project projectEntry in projects) {
-				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
-					if (fInfo.Name == oldName) {
-						fInfo.Name = newName;
-					}
-				}
-			}
-		}
-
-		void RenameDirectoryInAllProjects(string oldName, string newName)
-		{
-			CombineEntryCollection projects = openCombine.GetAllProjects();
-			
-			foreach (Project projectEntry in projects) {
-				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
-					if (fInfo.Name.StartsWith(oldName)) {
-						fInfo.Name = newName + fInfo.Name.Substring(oldName.Length);
-					}
-				}
-			}
-		}
-
-		void CheckFileRename(object sender, FileEventArgs e)
-		{
-			Debug.Assert(e.SourceFile != e.TargetFile);
-			if (openCombine != null) {
-				if (e.IsDirectory) {
-					RenameDirectoryInAllProjects(e.SourceFile, e.TargetFile);
-				} else {
-					RenameFileInAllProjects(e.SourceFile, e.TargetFile);
-				}
-			}
-		}
-		
-		public override void InitializeService()
-		{
-			base.InitializeService();
-
-			formatManager.RegisterFileFormat (defaultProjectFormat);
-			formatManager.RegisterFileFormat (defaultCombineFormat);
-			
-			FileFormatCodon[] formatCodons = (FileFormatCodon[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/ProjectFileFormats&quot;).BuildChildItems(null)).ToArray(typeof(FileFormatCodon));
-			foreach (FileFormatCodon codon in formatCodons)
-				formatManager.RegisterFileFormat (codon.FileFormat);
-			
-			DataContext.IncludeType (typeof(Combine));
-			DataContext.IncludeType (typeof(Project));
-			DataContext.IncludeType (typeof(DotNetProject));
-			
-			Runtime.FileService.FileRemoved += new FileEventHandler(CheckFileRemove);
-			Runtime.FileService.FileRenamed += new FileEventHandler(CheckFileRename);
-			
-			projectBindings = (ProjectBindingCodon[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/ProjectBindings&quot;).BuildChildItems(null)).ToArray(typeof(ProjectBindingCodon));
-		}
-		
-		string MakeValidName(string str)
-		{
-			string tmp = &quot;&quot;;
-			foreach (char ch in str) {
-				tmp += ((byte)ch).ToString();
-			}
-			return tmp;
-		}
-		
-		void RestoreCombinePreferences (Combine combine)
-		{
-			string combinefilename = combine.FileName;
-			string directory = Runtime.Properties.ConfigDirectory + &quot;CombinePreferences&quot;;
-
-			if (!Directory.Exists(directory)) {
-				return;
-			}
-			
-			string[] files = Directory.GetFiles(directory, combine.Name + &quot;*.xml&quot;);
-			
-			if (files.Length &gt; 0) {
-				XmlDocument doc = new XmlDocument();
-				try {
-					doc.Load(files[0]);
-				} catch (Exception) {
-					return;
-				}
-				XmlElement root = doc.DocumentElement;
-				string combinepath = Path.GetDirectoryName(combinefilename);
-				if (root[&quot;Files&quot;] != null) {
-					foreach (XmlElement el in root[&quot;Files&quot;].ChildNodes) {
-						string fileName = fileUtilityService.RelativeToAbsolutePath(combinepath, el.Attributes[&quot;filename&quot;].InnerText);
-						if (File.Exists(fileName)) {
-							Runtime.FileService.OpenFile (fileName, false);
-						}
-					}
-				}
-				
-				if (root[&quot;Views&quot;] != null) {
-					foreach (XmlElement el in root[&quot;Views&quot;].ChildNodes) {
-						foreach (IPadContent view in WorkbenchSingleton.Workbench.PadContentCollection) {
-							if (el.Attributes[&quot;class&quot;].InnerText == view.GetType().ToString() &amp;&amp; view is IMementoCapable &amp;&amp; el.ChildNodes.Count &gt; 0) {
-								IMementoCapable m = (IMementoCapable)view; 
-								m.SetMemento((IXmlConvertable)m.CreateMemento().FromXmlElement((XmlElement)el.ChildNodes[0]));
-							}
-						}
-					}
-				}
-				
-				if (root[&quot;Properties&quot;] != null) {
-					IProperties properties = (IProperties)new DefaultProperties().FromXmlElement((XmlElement)root[&quot;Properties&quot;].ChildNodes[0]);
-					string name = properties.GetProperty(&quot;ActiveWindow&quot;, &quot;&quot;);
-					foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
-						if (content.ContentName != null &amp;&amp;
-							content.ContentName == name) {
-							Runtime.DispatchService.GuiDispatch (new MessageHandler (content.WorkbenchWindow.SelectWindow));
-							break;
-						}
-					}
-				}
-			} 
-		}
-		
-		void SaveCombinePreferences (Combine combine)
-		{
-			string combinefilename = combine.FileName;
-			string directory = Runtime.Properties.ConfigDirectory + &quot;CombinePreferences&quot;;
-
-			if (!Directory.Exists(directory)) {
-				Directory.CreateDirectory(directory);
-			}
-			string combinepath = Path.GetDirectoryName(combinefilename);
-			XmlDocument doc = new XmlDocument();
-			doc.LoadXml(&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;UserCombinePreferences/&gt;&quot;);
-			
-			XmlAttribute fileNameAttribute = doc.CreateAttribute(&quot;filename&quot;);
-			fileNameAttribute.InnerText = combinefilename;
-			doc.DocumentElement.Attributes.Append(fileNameAttribute);
-			
-			XmlElement filesnode = doc.CreateElement(&quot;Files&quot;);
-			doc.DocumentElement.AppendChild(filesnode);
-			
-			foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
-				if (content.ContentName != null) {
-					XmlElement el = doc.CreateElement(&quot;File&quot;);
-					
-					XmlAttribute attr = doc.CreateAttribute(&quot;filename&quot;);
-					attr.InnerText = fileUtilityService.AbsoluteToRelativePath(combinepath, content.ContentName);
-					el.Attributes.Append(attr);
-					
-					filesnode.AppendChild(el);
-				}
-			}
-			
-			XmlElement viewsnode = doc.CreateElement(&quot;Views&quot;);
-			doc.DocumentElement.AppendChild(viewsnode);
-			
-			foreach (IPadContent view in WorkbenchSingleton.Workbench.PadContentCollection) {
-				if (view is IMementoCapable) {
-					XmlElement el = doc.CreateElement(&quot;ViewMemento&quot;);
-					
-					XmlAttribute attr = doc.CreateAttribute(&quot;class&quot;);
-					attr.InnerText = view.GetType().ToString();
-					el.Attributes.Append(attr);
-					
-					el.AppendChild(((IMementoCapable)view).CreateMemento().ToXmlElement(doc));
-					
-					viewsnode.AppendChild(el);
-				}
-			}
-			
-			IProperties properties = new DefaultProperties();
-			string name = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow == null ? String.Empty : WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName;
-			properties.SetProperty(&quot;ActiveWindow&quot;, name == null ? String.Empty : name);
-			
-			XmlElement propertynode = doc.CreateElement(&quot;Properties&quot;);
-			doc.DocumentElement.AppendChild(propertynode);
-			
-			propertynode.AppendChild(properties.ToXmlElement(doc));
-			
-			fileUtilityService.ObservedSave(new NamedFileOperationDelegate(doc.Save), directory + Path.DirectorySeparatorChar + combine.Name + &quot;.xml&quot;, FileErrorPolicy.ProvideAlternative);
-		}
-		
-		//********* own events
-		protected virtual void OnCombineOpened(CombineEventArgs e)
-		{
-			if (CombineOpened != null) {
-				CombineOpened(this, e);
-			}
-		}
-
-		protected virtual void OnCombineClosed(CombineEventArgs e)
-		{
-			if (CombineClosed != null) {
-				CombineClosed(this, e);
-			}
-		}
-		
-		protected virtual void OnCurrentSelectedCombineChanged(CombineEventArgs e)
-		{
-			if (CurrentSelectedCombineChanged != null) {
-				CurrentSelectedCombineChanged(this, e);
-			}
-		}
-		
-		protected virtual void OnCurrentProjectChanged(ProjectEventArgs e)
-		{
-			if (CurrentSelectedProject != null) {
-				Runtime.StringParserService.Properties[&quot;PROJECTNAME&quot;] = CurrentSelectedProject.Name;
-			}
-			if (CurrentProjectChanged != null) {
-				CurrentProjectChanged(this, e);
-			}
-		}
-		
-		public Project GetProject (string projectName)
-		{
-			if (CurrentOpenCombine == null) return null;
-			CombineEntryCollection allProjects = CurrentOpenCombine.GetAllProjects();
-			foreach (Project project in allProjects) {
-				if (project.Name == projectName)
-					return project;
-			}
-			return null;
-		}
-		
-		public void RemoveFileFromProject(string fileName)
-		{
-			if (openCombine != null) {
-				if (Directory.Exists (fileName)) {
-					RemoveAllInDirectory(fileName);
-				} else {
-					RemoveFileFromAllProjects(fileName);
-				}
-			}
-		}
-		
-		
-		void OnStartBuild()
-		{
-			if (StartBuild != null) {
-				StartBuild(this, null);
-			}
-		}
-		
-		void OnEndBuild (bool success)
-		{
-			if (EndBuild != null) {
-				EndBuild(success);
-			}
-		}
-		
-		void OnBeforeStartProject()
-		{
-			if (BeforeStartProject != null) {
-				BeforeStartProject(this, null);
-			}
-		}
-		
-		void NotifyFileRemovedFromProject (object sender, ProjectFileEventArgs e)
-		{
-			OnFileRemovedFromProject (e);
-		}
-		
-		void NotifyFileAddedToProject (object sender, ProjectFileEventArgs e)
-		{
-			OnFileAddedToProject (e);
-		}
-
-		internal void NotifyFileChangedInProject (object sender, ProjectFileEventArgs e)
-		{
-				OnFileChangedInProject (e);
-		}		
-		
-		internal void NotifyReferenceAddedToProject (object sender, ProjectReferenceEventArgs e)
-		{
-			OnReferenceRemovedFromProject (e);
-		}
-		
-		internal void NotifyReferenceRemovedFromProject (object sender, ProjectReferenceEventArgs e)
-		{
-			OnReferenceAddedToProject (e);
-		}
-		
-		protected virtual void OnFileRemovedFromProject (ProjectFileEventArgs e)
-		{
-			if (FileRemovedFromProject != null) {
-				FileRemovedFromProject(this, e);
-			}
-		}
-
-		protected virtual void OnFileAddedToProject (ProjectFileEventArgs e)
-		{
-			if (FileAddedToProject != null) {
-				FileAddedToProject (this, e);
-			}
-		}
-
-		protected virtual void OnFileChangedInProject (ProjectFileEventArgs e)
-		{
-			if (FileChangedInProject != null) {
-				FileChangedInProject (this, e);
-			}
-		}
-		
-		protected virtual void OnReferenceRemovedFromProject (ProjectReferenceEventArgs e)
-		{
-			if (ReferenceRemovedFromProject != null) {
-				ReferenceRemovedFromProject (this, e);
-			}
-		}
-		
-		protected virtual void OnReferenceAddedToProject (ProjectReferenceEventArgs e)
-		{
-			if (ReferenceAddedToProject != null) {
-				ReferenceAddedToProject (this, e);
-			}
-		}
-
-		public event ProjectFileEventHandler FileRemovedFromProject;
-		public event ProjectFileEventHandler FileAddedToProject;
-		public event ProjectFileEventHandler FileChangedInProject;
-		
-		public event EventHandler     StartBuild;
-		public event ProjectCompileEventHandler EndBuild;
-		public event EventHandler     BeforeStartProject;
-		
-		
-		public event CombineEventHandler CombineOpened;
-		public event CombineEventHandler CombineClosed;
-		public event CombineEventHandler CurrentSelectedCombineChanged;
-		
-		public event ProjectEventHandler       CurrentProjectChanged;
-		
-		public event ProjectReferenceEventHandler ReferenceAddedToProject;
-		public event ProjectReferenceEventHandler ReferenceRemovedFromProject;
-	}
-}

Copied: trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs (from rev 2244, trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs)
===================================================================
--- trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/DefaultProjectService.cs	2005-02-11 01:41:58 UTC (rev 2244)
+++ trunk/MonoDevelop/Core/src/MonoDevelop.Base/Services/Project/ProjectService.cs	2005-02-11 01:48:43 UTC (rev 2245)
@@ -0,0 +1,930 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+using System.IO;
+using System.Xml;
+using System.CodeDom.Compiler;
+using System.Threading;
+
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Internal.Serialization;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Internal.Templates;
+using MonoDevelop.Core.AddIns;
+
+namespace MonoDevelop.Services
+{
+	
+	public enum BeforeCompileAction {
+		Nothing,
+		SaveAllFiles,
+		PromptForSave,
+	}
+	
+	public class ProjectService : AbstractService, IProjectService
+	{
+		Project currentProject = null;
+		Combine  currentCombine = null;
+		Combine  openCombine    = null;
+		DataContext dataContext = new DataContext ();
+		ProjectBindingCodon[] projectBindings;
+		
+		IAsyncOperation currentBuildOperation;
+		IAsyncOperation currentRunOperation;
+		
+		FileFormatManager formatManager = new FileFormatManager ();
+		IFileFormat defaultProjectFormat = new MdsFileFormat ();
+		IFileFormat defaultCombineFormat = new MdpFileFormat ();
+		
+		ICompilerResult lastResult = new DefaultCompilerResult ();
+			
+		public Project CurrentSelectedProject {
+			get {
+				return currentProject;
+			}
+			set {
+				Debug.Assert(openCombine != null);
+				currentProject = value;
+				OnCurrentProjectChanged(new ProjectEventArgs(currentProject));
+			}
+		}
+		
+		public Combine CurrentSelectedCombine {
+			get {
+				return currentCombine;
+			}
+			set {
+				Debug.Assert(openCombine != null);
+				currentCombine = value;
+				OnCurrentSelectedCombineChanged(new CombineEventArgs(currentCombine));
+			}
+		}
+		
+		public Combine CurrentOpenCombine {
+			get {
+				return openCombine;
+			}
+			set {
+				openCombine = value;
+			}
+		}
+		
+		public ICompilerResult LastCompilerResult {
+			get { return lastResult; }
+		}
+		
+		bool IsDirtyFileInCombine {
+			get {
+				CombineEntryCollection projects = openCombine.GetAllProjects();
+				
+				foreach (Project projectEntry in projects) {
+					foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
+						foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
+							if (content.IsDirty &amp;&amp; content.ContentName == fInfo.Name) {
+								return true;
+							}
+						}
+					}
+				}
+				return false;
+			}
+		}
+		
+		public bool NeedsCompiling {
+			get {
+				if (openCombine == null) {
+					return false;
+				}
+				return openCombine.NeedsBuilding || IsDirtyFileInCombine;
+			}
+		}
+		
+		public DataContext DataContext {
+			get { return dataContext; }
+		}
+		
+		public FileFormatManager FileFormats {
+			get { return formatManager; }
+		}
+		
+		public void SaveCombinePreferences()
+		{
+			if (CurrentOpenCombine != null)
+				SaveCombinePreferences(CurrentOpenCombine);
+		}
+		
+		public CombineEntry ReadFile (string file, IProgressMonitor monitor)
+		{
+			IFileFormat format = formatManager.GetFileFormat (file);
+
+			if (format == null)
+				throw new InvalidOperationException (&quot;Unknown file format: &quot; + file);
+			
+			CombineEntry obj = format.ReadFile (file, monitor) as CombineEntry;
+			if (obj == null)
+				throw new InvalidOperationException (&quot;Invalid file format: &quot; + file);
+			
+			if (obj.FileFormat == null)	
+				obj.FileFormat = format;
+
+			return obj;
+		}
+		
+		public void WriteFile (string file, CombineEntry entry, IProgressMonitor monitor)
+		{
+			IFileFormat format = entry.FileFormat;
+			if (format == null) {
+				if (entry is Project) format = defaultProjectFormat;
+				else if (entry is Combine) format = defaultCombineFormat;
+				else format = formatManager.GetFileFormatForObject (entry);
+				
+				if (format == null)
+					throw new InvalidOperationException (&quot;FileFormat not provided for combine entry '&quot; + entry.Name + &quot;'&quot;);
+			}
+			entry.FileName = format.GetValidFormatName (file);
+			format.WriteFile (entry.FileName, entry, monitor);
+		}
+		
+		public Project CreateSingleFileProject (string file)
+		{
+			foreach (ProjectBindingCodon projectBinding in projectBindings) {
+				Project project = projectBinding.ProjectBinding.CreateSingleFileProject (file);
+				if (project != null)
+					return project;
+			}
+			return null;
+		}
+		
+		public Project CreateProject (string type, ProjectCreateInformation info, XmlElement projectOptions)
+		{
+			foreach (ProjectBindingCodon projectBinding in projectBindings) {
+				if (projectBinding.ProjectBinding.Name == type) {
+					Project project = projectBinding.ProjectBinding.CreateProject (info, projectOptions);
+					return project;
+				}
+			}
+			return null;
+		}
+		
+		public void CloseCombine()
+		{
+			CloseCombine(true);
+		}
+
+		public void CloseCombine (bool saveCombinePreferencies)
+		{
+			if (CurrentOpenCombine != null) {
+				if (saveCombinePreferencies)
+					SaveCombinePreferences (CurrentOpenCombine);
+				Combine closedCombine = CurrentOpenCombine;
+				CurrentSelectedProject = null;
+				CurrentOpenCombine = CurrentSelectedCombine = null;
+				WorkbenchSingleton.Workbench.CloseAllViews();
+				OnCombineClosed(new CombineEventArgs(closedCombine));
+				closedCombine.Dispose();
+			}
+		}
+		
+		FileUtilityService fileUtilityService = Runtime.FileUtilityService;
+		
+		public bool IsCombineEntryFile (string filename)
+		{
+			if (filename.StartsWith (&quot;<A HREF="file://&quot;">file://&quot;</A>))
+				filename = filename.Substring (7);
+				
+			IFileFormat format = formatManager.GetFileFormat (filename);
+			return format != null;
+		}
+		
+		public IAsyncOperation OpenCombine(string filename)
+		{
+			if (openCombine != null) {
+				SaveCombine();
+				CloseCombine();
+			}
+
+			if (filename.StartsWith (&quot;<A HREF="file://&quot;">file://&quot;</A>))
+				filename = filename.Substring (7);
+
+			IProgressMonitor monitor = Runtime.TaskService.GetLoadProgressMonitor ();
+			
+			object[] data = new object[] { filename, monitor };
+			Runtime.DispatchService.BackgroundDispatch (new StatefulMessageHandler (backgroundLoadCombine), data);
+			return monitor.AsyncOperation;
+		}
+		
+		void backgroundLoadCombine (object arg)
+		{
+			object[] data = (object[]) arg;
+			string filename = data[0] as string;
+			IProgressMonitor monitor = data [1] as IProgressMonitor;
+			
+			try {
+				if (!fileUtilityService.TestFileExists(filename)) {
+					monitor.ReportError (string.Format (GettextCatalog.GetString (&quot;File not found: {0}&quot;), filename), null);
+					return;
+				}
+				
+				string validcombine = Path.ChangeExtension (filename, &quot;.mds&quot;);
+				
+				if (Path.GetExtension (filename).ToLower() != &quot;.mds&quot;) {
+					if (File.Exists (validcombine))
+						filename = validcombine;
+				} else if (Path.GetExtension (filename).ToLower () != &quot;.cmbx&quot;) {
+					if (File.Exists (Path.ChangeExtension (filename, &quot;.cmbx&quot;)))
+						filename = Path.ChangeExtension (filename, &quot;.cmbx&quot;);
+				}
+			
+				CombineEntry entry = ReadFile (filename, monitor);
+				if (!(entry is Combine)) {
+					Combine loadingCombine = new Combine();
+					loadingCombine.Entries.Add (entry);
+					loadingCombine.Name = entry.Name;
+					loadingCombine.Save (validcombine, monitor);
+					entry = loadingCombine;
+				}
+			
+				openCombine = (Combine) entry;
+				
+				Runtime.FileService.RecentOpen.AddLastProject (filename, openCombine.Name);
+				
+				openCombine.FileAddedToProject += new ProjectFileEventHandler (NotifyFileAddedToProject);
+				openCombine.FileRemovedFromProject += new ProjectFileEventHandler (NotifyFileRemovedFromProject);
+				openCombine.FileChangedInProject += new ProjectFileEventHandler (NotifyFileChangedInProject);
+				openCombine.ReferenceAddedToProject += new ProjectReferenceEventHandler (NotifyReferenceAddedToProject);
+				openCombine.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (NotifyReferenceRemovedFromProject);
+		
+				RestoreCombinePreferences (CurrentOpenCombine);
+				SaveCombine ();
+				monitor.ReportSuccess (GettextCatalog.GetString (&quot;Combine loaded.&quot;));
+				OnCombineOpened(new CombineEventArgs(openCombine));
+			} catch (Exception ex) {
+				monitor.ReportError (&quot;Load operation failed.&quot;, ex);
+			} finally {
+				monitor.Dispose ();
+			}
+		}
+		
+		public void SaveCombine()
+		{
+			IProgressMonitor monitor = Runtime.TaskService.GetSaveProgressMonitor ();
+			try {
+				openCombine.Save (monitor);
+				monitor.ReportSuccess (GettextCatalog.GetString (&quot;Combine saved.&quot;));
+			} catch (Exception ex) {
+				monitor.ReportError (GettextCatalog.GetString (&quot;Save failed.&quot;), ex);
+			} finally {
+				monitor.Dispose ();
+			}
+		}
+		
+		public void MarkFileDirty (string filename)
+		{
+			if (openCombine != null) {
+				Project entry = openCombine.GetProjectEntryContaining (filename);
+				if (entry != null) {
+					entry.NeedsBuilding = true;
+				}
+			}
+		}
+
+		public IAsyncOperation ExecuteActiveCombine ()
+		{
+			if (openCombine == null) return NullAsyncOperation.Success;
+			if (currentRunOperation != null &amp;&amp; !currentRunOperation.IsCompleted) return currentRunOperation;
+			IProgressMonitor monitor = new NullProgressMonitor ();
+			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (ExecuteActiveCombineAsync), monitor);
+			currentRunOperation = monitor.AsyncOperation;
+			return currentRunOperation;
+		}
+		
+		void ExecuteActiveCombineAsync (object ob)
+		{
+			IProgressMonitor monitor = (IProgressMonitor) ob;
+
+			OnBeforeStartProject ();
+			try {
+				openCombine.Execute (monitor);
+			} catch (Exception ex) {
+				monitor.ReportError (GettextCatalog.GetString (&quot;Execution failed.&quot;), ex);
+			} finally {
+				monitor.Dispose ();
+			}
+		}
+
+		public IAsyncOperation ExecuteProject (Project project)
+		{
+			IProgressMonitor monitor = new NullProgressMonitor ();
+			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (ExecuteProjectAsync), new object[] {project, monitor});
+			return monitor.AsyncOperation;
+		}
+		
+		void ExecuteProjectAsync (object ob)
+		{
+			object[] data = (object[]) ob;
+			Project project = (Project) data[0];
+			IProgressMonitor monitor = (IProgressMonitor) data[1];
+			OnBeforeStartProject ();
+			try {
+				project.Execute (monitor);
+			} catch (Exception ex) {
+				monitor.ReportError (GettextCatalog.GetString (&quot;Execution failed.&quot;), ex);
+			} finally {
+				monitor.Dispose ();
+			}
+		}
+		
+		class ProjectOperationHandler {
+			public Project Project;
+			public void Run (IAsyncOperation op) { Project.Dispose (); }
+		}
+		
+		public IAsyncOperation BuildFile (string file)
+		{
+			Project tempProject = CreateSingleFileProject (file);
+			if (tempProject != null) {
+				IAsyncOperation aop = BuildProject (tempProject);
+				ProjectOperationHandler h = new ProjectOperationHandler ();
+				h.Project = tempProject;
+				aop.Completed += new OperationHandler (h.Run);
+				return aop;
+			} else {
+				Runtime.MessageService.ShowError (string.Format (GettextCatalog.GetString (&quot;The current file {0} can't be compiled.&quot;), file));
+				return NullAsyncOperation.Failure;
+			}
+		}
+		
+		public IAsyncOperation ExecuteFile (string file)
+		{
+			Project tempProject = CreateSingleFileProject (file);
+			if (tempProject != null) {
+				IAsyncOperation aop = ExecuteProject (tempProject);
+				ProjectOperationHandler h = new ProjectOperationHandler ();
+				h.Project = tempProject;
+				aop.Completed += new OperationHandler (h.Run);
+				return aop;
+			} else {
+				Runtime.MessageService.ShowError(GettextCatalog.GetString (&quot;No runnable executable found.&quot;));
+				return NullAsyncOperation.Failure;
+			}
+		}
+	
+		public IAsyncOperation BuildActiveCombine ()
+		{
+			if (openCombine == null) return NullAsyncOperation.Success;
+			if (currentBuildOperation != null &amp;&amp; !currentBuildOperation.IsCompleted) return currentBuildOperation;
+			
+			DoBeforeCompileAction();
+			
+			IProgressMonitor monitor = Runtime.TaskService.GetBuildProgressMonitor ();			
+			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (BuildActiveCombineAsync), monitor);
+			currentBuildOperation = monitor.AsyncOperation;
+			return currentBuildOperation;
+		}
+		
+		void BuildActiveCombineAsync (object ob)
+		{
+			IProgressMonitor monitor = (IProgressMonitor) ob;
+			try {
+				BeginBuild ();
+				ICompilerResult result = openCombine.Build (monitor);
+				BuildDone (monitor, result);
+			} catch (Exception ex) {
+				monitor.ReportError (GettextCatalog.GetString (&quot;Build failed.&quot;), ex);
+			} finally {
+				monitor.Dispose ();
+			}
+		}
+		
+		public IAsyncOperation RebuildActiveCombine()
+		{
+			if (openCombine == null) return NullAsyncOperation.Success;
+			openCombine.Clean ();
+			return BuildActiveCombine ();
+		}
+		
+		public IAsyncOperation BuildActiveProject ()
+		{
+			if (CurrentSelectedProject == null) {
+				Runtime.MessageService.ShowError (GettextCatalog.GetString (&quot;Active project not set.&quot;));
+				return NullAsyncOperation.Failure;
+			}
+				
+			return BuildProject (CurrentSelectedProject);
+		}
+		
+		public IAsyncOperation RebuildActiveProject ()
+		{
+			return RebuildProject (CurrentSelectedProject);
+		}
+		
+		public IAsyncOperation BuildProject (Project project)
+		{
+			BeforeCompile (project);
+			IProgressMonitor monitor = Runtime.TaskService.GetBuildProgressMonitor ();
+			Runtime.DispatchService.ThreadDispatch (new StatefulMessageHandler (BuildProjectAsync), new object[] {project, monitor});
+			return monitor.AsyncOperation;
+		}
+		
+		public void BuildProjectAsync (object ob)
+		{
+			object[] data = (object[]) ob;
+			Project project = (Project) data [0];
+			IProgressMonitor monitor = (IProgressMonitor) data [1];
+			ICompilerResult result = null;
+			try {
+				BeginBuild ();
+				result = project.Build (monitor);
+				BuildDone (monitor, result);
+			} catch (Exception ex) {
+				monitor.ReportError (GettextCatalog.GetString (&quot;Build failed.&quot;), ex);
+			} finally {
+				monitor.Dispose ();
+			}
+		}
+		
+		public IAsyncOperation RebuildProject (Project project)
+		{
+			project.Clean ();
+			return BuildProject (project);
+		}
+		
+		void BeginBuild ()
+		{
+			Runtime.TaskService.ClearTasks();
+			OnStartBuild ();
+		}
+		
+		void BuildDone (IProgressMonitor monitor, ICompilerResult result)
+		{
+			lastResult = result;
+			monitor.Log.WriteLine ();
+			monitor.Log.WriteLine (String.Format (GettextCatalog.GetString (&quot;---------------------- Done ----------------------&quot;)));
+			
+			foreach (CompilerError err in result.CompilerResults.Errors) {
+				Runtime.TaskService.AddTask (new Task(null, err));
+			}
+			
+			if (result.ErrorCount == 0 &amp;&amp; result.WarningCount == 0 &amp;&amp; lastResult.FailedBuildCount == 0) {
+				monitor.ReportSuccess (GettextCatalog.GetString (&quot;Build successful.&quot;));
+			} else if (result.ErrorCount == 0 &amp;&amp; result.WarningCount &gt; 0) {
+				monitor.ReportWarning (String.Format (GettextCatalog.GetString (&quot;Build: {0} errors, {1} warnings.&quot;), result.ErrorCount, result.WarningCount));
+			} else if (result.ErrorCount &gt; 0) {
+				monitor.ReportError (String.Format (GettextCatalog.GetString (&quot;Build: {0} errors, {1} warnings.&quot;), result.ErrorCount, result.WarningCount), null);
+			} else {
+				monitor.ReportError (String.Format (GettextCatalog.GetString (&quot;Build failed.&quot;)), null);
+			}
+			
+			OnEndBuild (lastResult.FailedBuildCount == 0);
+		}
+		
+		void BeforeCompile (Project project)
+		{
+			DoBeforeCompileAction();
+			
+			// cut&amp;pasted from CombineEntry.cs
+			Runtime.StringParserService.Properties[&quot;Project&quot;] = project.Name;
+			
+			string outputDir = ((AbstractProjectConfiguration)project.ActiveConfiguration).OutputDirectory;
+			try {
+				DirectoryInfo directoryInfo = new DirectoryInfo(outputDir);
+				if (!directoryInfo.Exists) {
+					directoryInfo.Create();
+				}
+			} catch (Exception e) {
+				throw new ApplicationException(&quot;Can't create project output directory &quot; + outputDir + &quot; original exception:\n&quot; + e.ToString());
+			}
+		}
+		
+		void DoBeforeCompileAction()
+		{
+			BeforeCompileAction action = (BeforeCompileAction)Runtime.Properties.GetProperty(&quot;SharpDevelop.Services.DefaultParserService.BeforeCompileAction&quot;, BeforeCompileAction.SaveAllFiles);
+			
+			switch (action) {
+				case BeforeCompileAction.Nothing:
+					break;
+				case BeforeCompileAction.PromptForSave:
+					bool save = false;
+					foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
+						if (content.ContentName != null &amp;&amp; content.IsDirty) {
+							if (!save) {
+								if (Runtime.MessageService.AskQuestion(GettextCatalog.GetString (&quot;Save changed files?&quot;))) {
+									save = true;
+								} else {
+									break;
+								}
+							}
+							MarkFileDirty(content.ContentName);
+							content.Save();
+						}
+					}
+					break;
+				case BeforeCompileAction.SaveAllFiles:
+					foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
+						if (content.ContentName != null &amp;&amp; content.IsDirty) {
+							MarkFileDirty(content.ContentName);
+							content.Save();
+						}
+					}
+					break;
+				default:
+					Debug.Assert(false);
+					break;
+			}
+		}
+		
+		void RemoveFileFromAllProjects(string fileName)
+		{
+			CombineEntryCollection projects = openCombine.GetAllProjects();
+			
+			restart:
+			foreach (Project projectEntry in projects) {
+				foreach (ProjectReference rInfo in projectEntry.ProjectReferences) {
+					if (rInfo.ReferenceType == ReferenceType.Assembly &amp;&amp; rInfo.Reference == fileName) {
+						projectEntry.ProjectReferences.Remove(rInfo);
+						goto restart;
+					}
+				}
+				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
+					if (fInfo.Name == fileName) {
+						projectEntry.ProjectFiles.Remove(fInfo);
+						goto restart;
+					}
+				}
+			}
+		}
+		
+		void RemoveAllInDirectory(string dirName)
+		{
+			CombineEntryCollection projects = openCombine.GetAllProjects();
+			
+			restart:
+			foreach (Project projectEntry in projects) {
+				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
+					if (fInfo.Name.StartsWith(dirName)) {
+						projectEntry.ProjectFiles.Remove(fInfo);
+						goto restart;
+					}
+				}
+			}
+		}
+		
+		void CheckFileRemove(object sender, FileEventArgs e)
+		{
+			if (openCombine != null) {
+				if (e.IsDirectory) {
+					RemoveAllInDirectory(e.FileName);
+				} else {
+					RemoveFileFromAllProjects(e.FileName);
+				}
+			}
+		}
+		
+		void RenameFileInAllProjects(string oldName, string newName)
+		{
+			CombineEntryCollection projects = openCombine.GetAllProjects();
+			
+			foreach (Project projectEntry in projects) {
+				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
+					if (fInfo.Name == oldName) {
+						fInfo.Name = newName;
+					}
+				}
+			}
+		}
+
+		void RenameDirectoryInAllProjects(string oldName, string newName)
+		{
+			CombineEntryCollection projects = openCombine.GetAllProjects();
+			
+			foreach (Project projectEntry in projects) {
+				foreach (ProjectFile fInfo in projectEntry.ProjectFiles) {
+					if (fInfo.Name.StartsWith(oldName)) {
+						fInfo.Name = newName + fInfo.Name.Substring(oldName.Length);
+					}
+				}
+			}
+		}
+
+		void CheckFileRename(object sender, FileEventArgs e)
+		{
+			Debug.Assert(e.SourceFile != e.TargetFile);
+			if (openCombine != null) {
+				if (e.IsDirectory) {
+					RenameDirectoryInAllProjects(e.SourceFile, e.TargetFile);
+				} else {
+					RenameFileInAllProjects(e.SourceFile, e.TargetFile);
+				}
+			}
+		}
+		
+		public override void InitializeService()
+		{
+			base.InitializeService();
+
+			formatManager.RegisterFileFormat (defaultProjectFormat);
+			formatManager.RegisterFileFormat (defaultCombineFormat);
+			
+			FileFormatCodon[] formatCodons = (FileFormatCodon[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/ProjectFileFormats&quot;).BuildChildItems(null)).ToArray(typeof(FileFormatCodon));
+			foreach (FileFormatCodon codon in formatCodons)
+				formatManager.RegisterFileFormat (codon.FileFormat);
+			
+			DataContext.IncludeType (typeof(Combine));
+			DataContext.IncludeType (typeof(Project));
+			DataContext.IncludeType (typeof(DotNetProject));
+			
+			Runtime.FileService.FileRemoved += new FileEventHandler(CheckFileRemove);
+			Runtime.FileService.FileRenamed += new FileEventHandler(CheckFileRename);
+			
+			projectBindings = (ProjectBindingCodon[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/ProjectBindings&quot;).BuildChildItems(null)).ToArray(typeof(ProjectBindingCodon));
+		}
+		
+		string MakeValidName(string str)
+		{
+			string tmp = &quot;&quot;;
+			foreach (char ch in str) {
+				tmp += ((byte)ch).ToString();
+			}
+			return tmp;
+		}
+		
+		void RestoreCombinePreferences (Combine combine)
+		{
+			string combinefilename = combine.FileName;
+			string directory = Runtime.Properties.ConfigDirectory + &quot;CombinePreferences&quot;;
+
+			if (!Directory.Exists(directory)) {
+				return;
+			}
+			
+			string[] files = Directory.GetFiles(directory, combine.Name + &quot;*.xml&quot;);
+			
+			if (files.Length &gt; 0) {
+				XmlDocument doc = new XmlDocument();
+				try {
+					doc.Load(files[0]);
+				} catch (Exception) {
+					return;
+				}
+				XmlElement root = doc.DocumentElement;
+				string combinepath = Path.GetDirectoryName(combinefilename);
+				if (root[&quot;Files&quot;] != null) {
+					foreach (XmlElement el in root[&quot;Files&quot;].ChildNodes) {
+						string fileName = fileUtilityService.RelativeToAbsolutePath(combinepath, el.Attributes[&quot;filename&quot;].InnerText);
+						if (File.Exists(fileName)) {
+							Runtime.FileService.OpenFile (fileName, false);
+						}
+					}
+				}
+				
+				if (root[&quot;Views&quot;] != null) {
+					foreach (XmlElement el in root[&quot;Views&quot;].ChildNodes) {
+						foreach (IPadContent view in WorkbenchSingleton.Workbench.PadContentCollection) {
+							if (el.Attributes[&quot;class&quot;].InnerText == view.GetType().ToString() &amp;&amp; view is IMementoCapable &amp;&amp; el.ChildNodes.Count &gt; 0) {
+								IMementoCapable m = (IMementoCapable)view; 
+								m.SetMemento((IXmlConvertable)m.CreateMemento().FromXmlElement((XmlElement)el.ChildNodes[0]));
+							}
+						}
+					}
+				}
+				
+				if (root[&quot;Properties&quot;] != null) {
+					IProperties properties = (IProperties)new DefaultProperties().FromXmlElement((XmlElement)root[&quot;Properties&quot;].ChildNodes[0]);
+					string name = properties.GetProperty(&quot;ActiveWindow&quot;, &quot;&quot;);
+					foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
+						if (content.ContentName != null &amp;&amp;
+							content.ContentName == name) {
+							Runtime.DispatchService.GuiDispatch (new MessageHandler (content.WorkbenchWindow.SelectWindow));
+							break;
+						}
+					}
+				}
+			} 
+		}
+		
+		void SaveCombinePreferences (Combine combine)
+		{
+			string combinefilename = combine.FileName;
+			string directory = Runtime.Properties.ConfigDirectory + &quot;CombinePreferences&quot;;
+
+			if (!Directory.Exists(directory)) {
+				Directory.CreateDirectory(directory);
+			}
+			string combinepath = Path.GetDirectoryName(combinefilename);
+			XmlDocument doc = new XmlDocument();
+			doc.LoadXml(&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;UserCombinePreferences/&gt;&quot;);
+			
+			XmlAttribute fileNameAttribute = doc.CreateAttribute(&quot;filename&quot;);
+			fileNameAttribute.InnerText = combinefilename;
+			doc.DocumentElement.Attributes.Append(fileNameAttribute);
+			
+			XmlElement filesnode = doc.CreateElement(&quot;Files&quot;);
+			doc.DocumentElement.AppendChild(filesnode);
+			
+			foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
+				if (content.ContentName != null) {
+					XmlElement el = doc.CreateElement(&quot;File&quot;);
+					
+					XmlAttribute attr = doc.CreateAttribute(&quot;filename&quot;);
+					attr.InnerText = fileUtilityService.AbsoluteToRelativePath(combinepath, content.ContentName);
+					el.Attributes.Append(attr);
+					
+					filesnode.AppendChild(el);
+				}
+			}
+			
+			XmlElement viewsnode = doc.CreateElement(&quot;Views&quot;);
+			doc.DocumentElement.AppendChild(viewsnode);
+			
+			foreach (IPadContent view in WorkbenchSingleton.Workbench.PadContentCollection) {
+				if (view is IMementoCapable) {
+					XmlElement el = doc.CreateElement(&quot;ViewMemento&quot;);
+					
+					XmlAttribute attr = doc.CreateAttribute(&quot;class&quot;);
+					attr.InnerText = view.GetType().ToString();
+					el.Attributes.Append(attr);
+					
+					el.AppendChild(((IMementoCapable)view).CreateMemento().ToXmlElement(doc));
+					
+					viewsnode.AppendChild(el);
+				}
+			}
+			
+			IProperties properties = new DefaultProperties();
+			string name = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow == null ? String.Empty : WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName;
+			properties.SetProperty(&quot;ActiveWindow&quot;, name == null ? String.Empty : name);
+			
+			XmlElement propertynode = doc.CreateElement(&quot;Properties&quot;);
+			doc.DocumentElement.AppendChild(propertynode);
+			
+			propertynode.AppendChild(properties.ToXmlElement(doc));
+			
+			fileUtilityService.ObservedSave(new NamedFileOperationDelegate(doc.Save), directory + Path.DirectorySeparatorChar + combine.Name + &quot;.xml&quot;, FileErrorPolicy.ProvideAlternative);
+		}
+		
+		//********* own events
+		protected virtual void OnCombineOpened(CombineEventArgs e)
+		{
+			if (CombineOpened != null) {
+				CombineOpened(this, e);
+			}
+		}
+
+		protected virtual void OnCombineClosed(CombineEventArgs e)
+		{
+			if (CombineClosed != null) {
+				CombineClosed(this, e);
+			}
+		}
+		
+		protected virtual void OnCurrentSelectedCombineChanged(CombineEventArgs e)
+		{
+			if (CurrentSelectedCombineChanged != null) {
+				CurrentSelectedCombineChanged(this, e);
+			}
+		}
+		
+		protected virtual void OnCurrentProjectChanged(ProjectEventArgs e)
+		{
+			if (CurrentSelectedProject != null) {
+				Runtime.StringParserService.Properties[&quot;PROJECTNAME&quot;] = CurrentSelectedProject.Name;
+			}
+			if (CurrentProjectChanged != null) {
+				CurrentProjectChanged(this, e);
+			}
+		}
+		
+		public Project GetProject (string projectName)
+		{
+			if (CurrentOpenCombine == null) return null;
+			CombineEntryCollection allProjects = CurrentOpenCombine.GetAllProjects();
+			foreach (Project project in allProjects) {
+				if (project.Name == projectName)
+					return project;
+			}
+			return null;
+		}
+		
+		public void RemoveFileFromProject(string fileName)
+		{
+			if (openCombine != null) {
+				if (Directory.Exists (fileName)) {
+					RemoveAllInDirectory(fileName);
+				} else {
+					RemoveFileFromAllProjects(fileName);
+				}
+			}
+		}
+		
+		
+		void OnStartBuild()
+		{
+			if (StartBuild != null) {
+				StartBuild(this, null);
+			}
+		}
+		
+		void OnEndBuild (bool success)
+		{
+			if (EndBuild != null) {
+				EndBuild(success);
+			}
+		}
+		
+		void OnBeforeStartProject()
+		{
+			if (BeforeStartProject != null) {
+				BeforeStartProject(this, null);
+			}
+		}
+		
+		void NotifyFileRemovedFromProject (object sender, ProjectFileEventArgs e)
+		{
+			OnFileRemovedFromProject (e);
+		}
+		
+		void NotifyFileAddedToProject (object sender, ProjectFileEventArgs e)
+		{
+			OnFileAddedToProject (e);
+		}
+
+		internal void NotifyFileChangedInProject (object sender, ProjectFileEventArgs e)
+		{
+				OnFileChangedInProject (e);
+		}		
+		
+		internal void NotifyReferenceAddedToProject (object sender, ProjectReferenceEventArgs e)
+		{
+			OnReferenceRemovedFromProject (e);
+		}
+		
+		internal void NotifyReferenceRemovedFromProject (object sender, ProjectReferenceEventArgs e)
+		{
+			OnReferenceAddedToProject (e);
+		}
+		
+		protected virtual void OnFileRemovedFromProject (ProjectFileEventArgs e)
+		{
+			if (FileRemovedFromProject != null) {
+				FileRemovedFromProject(this, e);
+			}
+		}
+
+		protected virtual void OnFileAddedToProject (ProjectFileEventArgs e)
+		{
+			if (FileAddedToProject != null) {
+				FileAddedToProject (this, e);
+			}
+		}
+
+		protected virtual void OnFileChangedInProject (ProjectFileEventArgs e)
+		{
+			if (FileChangedInProject != null) {
+				FileChangedInProject (this, e);
+			}
+		}
+		
+		protected virtual void OnReferenceRemovedFromProject (ProjectReferenceEventArgs e)
+		{
+			if (ReferenceRemovedFromProject != null) {
+				ReferenceRemovedFromProject (this, e);
+			}
+		}
+		
+		protected virtual void OnReferenceAddedToProject (ProjectReferenceEventArgs e)
+		{
+			if (ReferenceAddedToProject != null) {
+				ReferenceAddedToProject (this, e);
+			}
+		}
+
+		public event ProjectFileEventHandler FileRemovedFromProject;
+		public event ProjectFileEventHandler FileAddedToProject;
+		public event ProjectFileEventHandler FileChangedInProject;
+		
+		public event EventHandler     StartBuild;
+		public event ProjectCompileEventHandler EndBuild;
+		public event EventHandler     BeforeStartProject;
+		
+		
+		public event CombineEventHandler CombineOpened;
+		public event CombineEventHandler CombineClosed;
+		public event CombineEventHandler CurrentSelectedCombineChanged;
+		
+		public event ProjectEventHandler       CurrentProjectChanged;
+		
+		public event ProjectReferenceEventHandler ReferenceAddedToProject;
+		public event ProjectReferenceEventHandler ReferenceRemovedFromProject;
+	}
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001848.html">[Monodevelop-patches-list] r2244 - in trunk/MonoDevelop: . Core/src/MonoDevelop.Base Core/src/MonoDevelop.Base/Commands Core/src/MonoDevelop.Base/Gui/Dialogs Core/src/MonoDevelop.Base/Internal/Project Core/src/MonoDevelop.Base/Internal/Project/Combine Core/src/MonoDevelop.Base/Internal/Project/Project Core/src/MonoDevelop.Base/Internal/Templates/ProjectTemplates Core/src/MonoDevelop.Base/Services Core/src/MonoDevelop.Base/Services/Project
</A></li>
	<LI>Next message: <A HREF="001850.html">[Monodevelop-patches-list] r2246 - in trunk/MonoDevelop/Core/src/MonoDevelop.Base: . Internal/Project/Combine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1849">[ date ]</a>
              <a href="thread.html#1849">[ thread ]</a>
              <a href="subject.html#1849">[ subject ]</a>
              <a href="author.html#1849">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
