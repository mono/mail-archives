<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r942 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . Gui Gui/Dialogs Search Search/DocumentIterator Search/SearchResult Search/SearchStrategy Search/TextIterator
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r942%20-%20in%20trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor%3A%20.%20Gui%20Gui/Dialogs%20Search%20Search/DocumentIterator%20Search/SearchResult%20Search/SearchStrategy%20Search/TextIterator&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000546.html">
   <LINK REL="Next"  HREF="000548.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r942 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . Gui Gui/Dialogs Search Search/DocumentIterator Search/SearchResult Search/SearchStrategy Search/TextIterator</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r942%20-%20in%20trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor%3A%20.%20Gui%20Gui/Dialogs%20Search%20Search/DocumentIterator%20Search/SearchResult%20Search/SearchStrategy%20Search/TextIterator&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r942 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . Gui Gui/Dialogs Search Search/DocumentIterator Search/SearchResult Search/SearchStrategy Search/TextIterator">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Wed Feb 18 22:42:54 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000546.html">[Monodevelop-patches-list] r941 - in trunk/MonoDevelop: data/resources/glade src/Main/Base/Gui/Dialogs/OptionPanels/ProjectOptions
</A></li>
        <LI>Next message: <A HREF="000548.html">[Monodevelop-patches-list] r943 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: Commands Gui Search Search/DocumentIterator Search/SearchStrategy Search/TextIterator
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#547">[ date ]</a>
              <a href="thread.html#547">[ thread ]</a>
              <a href="subject.html#547">[ subject ]</a>
              <a href="author.html#547">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tberman
Date: 2004-02-18 22:42:53 -0500 (Wed, 18 Feb 2004)
New Revision: 942

Added:
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/Dialogs/ReplaceDialog.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/Dialogs/ReplaceInFilesDialog.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DefaultFind.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/AllOpenDocumentIterator.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/CurrentDocumentIterator.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/DirectoryDocumentIterator.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/IDocumentIterator.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/ProvidedDocumentInformation.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/ReverseDocumentIterator.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/WholeProjectDocumentIterator.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/IFind.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/ITextBufferStrategy.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchOptions.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceInFilesManager.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceManager.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceUtilities.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/DefaultSearchResult.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/ISearchResult.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/BruteForceSearchStrategy.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/ISearchStrategy.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/KMPSearchStrategy.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/RegExSearchStrategy.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/WildcardSearchStrategy.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextIterator.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextIteratorBuilder.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ITextIterator.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ITextIteratorBuilder.cs
Modified:
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Makefile.am
Log:
adding search stuff, doesnt work yet, but it does compile


Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/Dialogs/ReplaceDialog.cs (from rev 941, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Dialogs/ReplaceDialog.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Dialogs/ReplaceDialog.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/Dialogs/ReplaceDialog.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,446 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+using System.ComponentModel;
+using System.Collections.Specialized;
+
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.Core.Properties;
+
+using ICSharpCode.Core.Services;
+using ICSharpCode.SharpDevelop.Services;
+using ICSharpCode.TextEditor;
+//using MonoDevelop.EditorBindings.Search;
+
+using Gtk;
+using Glade;
+
+namespace ICSharpCode.SharpDevelop.Gui.Dialogs
+{
+	public class ReplaceDialog
+	{
+		private const int HISTORY_LIMIT = 20;
+		private const char HISTORY_SEPARATOR_CHAR = (char) 10;
+		// regular members
+		public bool replaceMode;
+		StringCollection findHistory = new StringCollection();
+		StringCollection replaceHistory = new StringCollection();
+		
+		// services
+		ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		static FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+		StringParserService stringParserService = (StringParserService)ServiceManager.Services.GetService (typeof (StringParserService));
+		
+		// gtk widgets
+		[Glade.Widget] Gtk.Combo searchPatternComboBox;
+		[Glade.Widget] Gtk.Combo replacePatternComboBox;
+		[Glade.Widget] Gtk.Button findHelpButton;
+		[Glade.Widget] Gtk.Button findButton;
+		[Glade.Widget] Gtk.Button markAllButton;
+		[Glade.Widget] Gtk.Button closeButton;
+		[Glade.Widget] Gtk.Button replaceButton;
+		[Glade.Widget] Gtk.Button replaceAllButton;
+		[Glade.Widget] Gtk.Button replaceHelpButton;
+		[Glade.Widget] Gtk.CheckButton ignoreCaseCheckBox;
+		[Glade.Widget] Gtk.CheckButton searchWholeWordOnlyCheckBox;
+		[Glade.Widget] Gtk.CheckButton useSpecialSearchStrategyCheckBox;
+		[Glade.Widget] Gtk.OptionMenu specialSearchStrategyComboBox;
+		[Glade.Widget] Gtk.OptionMenu searchLocationComboBox;
+		[Glade.Widget] Gtk.Label label1;
+		[Glade.Widget] Gtk.Label label2;
+		[Glade.Widget] Gtk.Label searchLocationLabel;
+		[Glade.Widget] Gtk.Dialog FindDialogWidget;
+		[Glade.Widget] Gtk.Dialog ReplaceDialogWidget;
+		Gtk.Dialog ReplaceDialogPointer;
+		
+		void InitDialog ()
+		{
+			label1.Text = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.FindWhat}&quot;);
+			searchLocationLabel.Text = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.SearchIn}&quot;);		
+			//findButton.Label = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.FindNextButton}&quot;);			
+			//closeButton.Label = stringParserService.Parse (&quot;${res:Global.CloseButtonText}&quot;);
+			findButton.UseUnderline = true;			
+			closeButton.UseUnderline = true;			
+			ignoreCaseCheckBox.Label = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.CaseSensitive}&quot;);
+			searchWholeWordOnlyCheckBox.Label = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.WholeWord}&quot;);
+			useSpecialSearchStrategyCheckBox.Label = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.UseMethodLabel}&quot;);			
+			
+			
+			//set up the size groups
+			SizeGroup labels = new SizeGroup(SizeGroupMode.Horizontal);
+			SizeGroup combos = new SizeGroup(SizeGroupMode.Horizontal);
+			SizeGroup options = new SizeGroup(SizeGroupMode.Horizontal);
+			SizeGroup helpButtons = new SizeGroup(SizeGroupMode.Horizontal);
+			SizeGroup checkButtons = new SizeGroup(SizeGroupMode.Horizontal);
+			labels.AddWidget(label1);			
+			combos.AddWidget(searchPatternComboBox);
+			helpButtons.AddWidget(findHelpButton);
+			checkButtons.AddWidget(ignoreCaseCheckBox);
+			checkButtons.AddWidget(searchWholeWordOnlyCheckBox);
+			checkButtons.AddWidget(useSpecialSearchStrategyCheckBox);
+			checkButtons.AddWidget(searchLocationLabel);
+			options.AddWidget(specialSearchStrategyComboBox);
+			options.AddWidget(searchLocationComboBox);
+			
+			// set button sensitivity
+			findHelpButton.Sensitive = false;
+			
+			// set replace dialog properties 
+			if(replaceMode)
+			{
+				ReplaceDialogPointer = this.ReplaceDialogWidget;
+				// set the label properties
+				label2.Text = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.ReplaceWith}&quot;);
+				//replaceButton.Label = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.ReplaceButton}&quot;);
+				replaceAllButton.Label = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.ReplaceAllButton}&quot;);
+				replaceButton.UseUnderline = true;
+				replaceAllButton.UseUnderline = true;
+				
+				// set te size groups to include the replace dialog
+				labels.AddWidget(label2);
+				combos.AddWidget(replacePatternComboBox);
+				helpButtons.AddWidget(replaceHelpButton);
+				
+				replaceHelpButton.Sensitive = false;
+			}
+			else
+			{
+				ReplaceDialogPointer = this.FindDialogWidget;
+				markAllButton.UseUnderline = true;
+				markAllButton.Label = stringParserService.Parse (&quot;${res:Dialog.NewProject.SearchReplace.MarkAllButton}&quot;);
+			}
+		}
+		
+		public ReplaceDialog(bool replaceMode)
+		{
+			// some members needed to initialise this dialog based on replace mode
+			this.replaceMode = replaceMode;
+			string dialogName = (replaceMode) ? &quot;ReplaceDialogWidget&quot; : &quot;FindDialogWidget&quot;;
+			
+			// we must do it from *here* otherwise, we get this assembly, not the caller
+			Glade.XML glade = new XML (null, &quot;texteditoraddin.glade&quot;, dialogName, null);
+			glade.Autoconnect (this);
+			InitDialog ();
+			/*if (replaceMode) {
+				//this.SetupFromXml(Path.Combine(propertyService.DataDirectory, @&quot;resources\dialogs\ReplaceDialog.xfrm&quot;));
+				//ControlDictionary[&quot;replaceHelpButton&quot;].Enabled = false;
+				InitDialogForReplace ();
+			} else {
+				InitDialogForFind ();
+				//this.SetupFromXml(Path.Combine(propertyService.DataDirectory, @&quot;resources\dialogs\FindDialog.xfrm&quot;));
+			}*/
+			
+			//AcceptButton = (Button)ControlDictionary[&quot;findButton&quot;];
+			//CancelButton = (Button)ControlDictionary[&quot;closeButton&quot;];
+			
+			LoadHistoryValues();
+			
+			ignoreCaseCheckBox.Active = !SearchReplaceManager.SearchOptions.IgnoreCase;
+			searchWholeWordOnlyCheckBox.Active = SearchReplaceManager.SearchOptions.SearchWholeWordOnly;
+			
+			useSpecialSearchStrategyCheckBox.Active  = SearchReplaceManager.SearchOptions.SearchStrategyType != SearchStrategyType.Normal;
+			useSpecialSearchStrategyCheckBox.Toggled += new EventHandler(SpecialSearchStrategyCheckBoxChangedEvent);
+			
+			Gtk.MenuItem tmpItem = new Gtk.MenuItem (&quot;Wildcards&quot;);
+			Gtk.Menu stratMenu = new Gtk.Menu ();
+			stratMenu.Append (tmpItem);
+			tmpItem = new Gtk.MenuItem (resourceService.GetString(&quot;Dialog.NewProject.SearchReplace.SearchStrategy.RegexSearch&quot;));
+			stratMenu.Append (tmpItem);
+			specialSearchStrategyComboBox.Menu = stratMenu;
+		
+			uint index = 0;
+			switch (SearchReplaceManager.SearchOptions.SearchStrategyType) {
+				case SearchStrategyType.Normal:
+				case SearchStrategyType.Wildcard:
+					break;
+				case SearchStrategyType.RegEx:
+					index = 1;
+					break;
+			}
+			specialSearchStrategyComboBox.SetHistory (index);
+			
+			Gtk.Menu locMenu = new Gtk.Menu ();
+			tmpItem = new Gtk.MenuItem (resourceService.GetString(&quot;Global.Location.currentfile&quot;));
+			locMenu.Append (tmpItem);
+			tmpItem = new Gtk.MenuItem (resourceService.GetString(&quot;Global.Location.allopenfiles&quot;));
+			locMenu.Append (tmpItem);
+			tmpItem = new Gtk.MenuItem (resourceService.GetString(&quot;Global.Location.wholeproject&quot;));
+			locMenu.Append (tmpItem);
+			
+			searchLocationComboBox.Menu = locMenu;	
+			
+			index = 0;
+			switch (SearchReplaceManager.SearchOptions.DocumentIteratorType) {
+				case DocumentIteratorType.AllOpenFiles:
+					index = 1;
+					break;
+				case DocumentIteratorType.WholeCombine:
+					SearchReplaceManager.SearchOptions.DocumentIteratorType = DocumentIteratorType.CurrentDocument;
+					break;
+			}
+			searchLocationComboBox.SetHistory (index);
+			
+			searchPatternComboBox.Entry.Text  = SearchReplaceManager.SearchOptions.SearchPattern;
+			
+			// insert event handlers
+			findButton.Clicked  += new EventHandler(FindNextEvent);
+			closeButton.Clicked += new EventHandler(CloseDialogEvent);
+			ReplaceDialogPointer.Close += new EventHandler(CloseDialogEvent);
+			ReplaceDialogPointer.DeleteEvent += new DeleteEventHandler (OnDeleted);
+			
+			if (replaceMode) {
+				ReplaceDialogPointer.Title = resourceService.GetString(&quot;Dialog.NewProject.SearchReplace.ReplaceDialogName&quot;);
+				replaceButton.Clicked    += new EventHandler(ReplaceEvent);
+				replaceAllButton.Clicked += new EventHandler(ReplaceAllEvent);
+				replacePatternComboBox.Entry.Text = SearchReplaceManager.SearchOptions.ReplacePattern;
+			} else {
+				ReplaceDialogPointer.Title = resourceService.GetString(&quot;Dialog.NewProject.SearchReplace.FindDialogName&quot;);
+				markAllButton.Clicked    += new EventHandler(MarkAllEvent);
+			}
+			
+				//ControlDictionary[&quot;replacePatternComboBox&quot;].Visible = false;
+				//ControlDictionary[&quot;replaceAllButton&quot;].Visible       = false;
+				//ControlDictionary[&quot;replacePatternLabel&quot;].Visible    = false;
+				//ControlDictionary[&quot;replacePatternButton&quot;].Visible   = false;
+				//ControlDictionary[&quot;replaceButton&quot;].Text             = resourceService.GetString(&quot;Dialog.NewProject.SearchReplace.ToggleReplaceModeButton&quot;);
+				//ClientSize = new Size(ClientSize.Width, ClientSize.Height - 32);
+			
+			SpecialSearchStrategyCheckBoxChangedEvent(null, null);
+			SearchReplaceManager.ReplaceDialog     = this;
+		}
+		
+		protected void OnClosed()
+		{
+			SaveHistoryValues();
+			
+		}
+		
+		void OnDeleted (object o, DeleteEventArgs args)
+		{
+			// perform the standard closing windows event
+			OnClosed();
+			SearchReplaceManager.ReplaceDialog = null;
+		}
+
+		public void SetSearchPattern(string pattern)
+		{
+			searchPatternComboBox.Entry.Text  = pattern;
+		}
+		
+		void SetupSearchReplaceManager()
+		{
+			SearchReplaceManager.SearchOptions.SearchPattern  = searchPatternComboBox.Entry.Text;
+			if (replaceMode) {
+				SearchReplaceManager.SearchOptions.ReplacePattern = replacePatternComboBox.Entry.Text;
+			}
+			
+			SearchReplaceManager.SearchOptions.IgnoreCase          = !ignoreCaseCheckBox.Active;
+			SearchReplaceManager.SearchOptions.SearchWholeWordOnly = searchWholeWordOnlyCheckBox.Active;
+			
+			if (useSpecialSearchStrategyCheckBox.Active) {
+				switch (specialSearchStrategyComboBox.History) {
+					case 0:
+						SearchReplaceManager.SearchOptions.SearchStrategyType = SearchStrategyType.Wildcard;
+						break;
+					case 1:
+						SearchReplaceManager.SearchOptions.SearchStrategyType = SearchStrategyType.RegEx;
+						break;
+				}
+			} else {
+				SearchReplaceManager.SearchOptions.SearchStrategyType = SearchStrategyType.Normal;
+			}
+			
+			switch (searchLocationComboBox.History) {
+				case 0:
+					SearchReplaceManager.SearchOptions.DocumentIteratorType = DocumentIteratorType.CurrentDocument;
+					break;
+				case 1:
+					SearchReplaceManager.SearchOptions.DocumentIteratorType = DocumentIteratorType.AllOpenFiles;
+					break;
+				case 2:
+					SearchReplaceManager.SearchOptions.DocumentIteratorType = DocumentIteratorType.WholeCombine;
+					break;
+			}
+		}
+		
+		void FindNextEvent(object sender, EventArgs e)
+		{
+			if (searchPatternComboBox.Entry.Text.Length == 0) {
+				return;
+			}
+			
+			try {
+				//Cursor = Cursors.WaitCursor;
+				SetupSearchReplaceManager();
+				SearchReplaceManager.FindNext();
+				//this.Focus();
+			}
+			finally {
+				//Cursor = Cursors.Default;
+			}
+			
+			AddSearchHistoryItem(findHistory, searchPatternComboBox.Entry.Text);
+		}
+		
+		void ReplaceEvent(object sender, EventArgs e)
+		{
+			if (searchPatternComboBox.Entry.Text.Length == 0) {
+				return;
+			}
+			
+			try {
+				//Cursor = Cursors.WaitCursor;
+				
+				SetupSearchReplaceManager();
+				SearchReplaceManager.Replace();
+			}
+			finally {
+				//Cursor = Cursors.Default;
+			}
+			
+			AddSearchHistoryItem(replaceHistory, replacePatternComboBox.Entry.Text);
+		}
+		
+		void ReplaceAllEvent(object sender, EventArgs e)
+		{
+			if (searchPatternComboBox.Entry.Text.Length == 0) {
+				return;
+			}
+			
+			try {
+				//Cursor = Cursors.WaitCursor;
+				
+				SetupSearchReplaceManager();
+				SearchReplaceManager.ReplaceAll();
+			} finally {
+				//Cursor = Cursors.Default;
+			}
+			
+			AddSearchHistoryItem(replaceHistory, replacePatternComboBox.Entry.Text);
+		}
+		
+		void MarkAllEvent(object sender, EventArgs e)
+		{
+			if (searchPatternComboBox.Entry.Text.Length == 0) {
+				return;
+			}
+			
+			try {
+				//Cursor = Cursors.WaitCursor;
+				
+				SetupSearchReplaceManager();
+				SearchReplaceManager.MarkAll();			
+			} finally {
+				//Cursor = Cursors.Default;
+			}
+			
+			AddSearchHistoryItem(findHistory, searchPatternComboBox.Entry.Text);
+		}
+		
+		void CloseDialogEvent(object sender, EventArgs e)
+		{
+			ReplaceDialogPointer.Hide();
+			OnClosed ();
+		}
+		
+		void SpecialSearchStrategyCheckBoxChangedEvent(object sender, EventArgs e)
+		{
+			if (useSpecialSearchStrategyCheckBox != null) {
+				specialSearchStrategyComboBox.Sensitive = useSpecialSearchStrategyCheckBox.Active;
+			}
+		}
+		
+		// generic method to add a string to a history item
+		private void AddSearchHistoryItem(StringCollection history, string toAdd)
+		{
+			// add the item to the find history
+			if (history.Contains(toAdd)) {
+				// remove it so it gets added at the top
+				history.Remove(toAdd);
+			}
+			// make sure there is only 20
+			if (history.Count == HISTORY_LIMIT) {
+				history.RemoveAt(HISTORY_LIMIT - 1);
+			}
+			history.Insert(0, toAdd);
+			
+			// update the drop down for the combobox
+			string[] stringArray = new string[history.Count];
+			history.CopyTo(stringArray, 0);
+			if (history == findHistory) {
+				searchPatternComboBox.PopdownStrings = stringArray;
+			} else if( history == replaceHistory) {
+				replacePatternComboBox.PopdownStrings = stringArray;
+			}
+		}
+		
+		// loads the history arrays from the property service
+		// NOTE: this dialog uses a newline character to separate search history strings in the properties file 
+		private void LoadHistoryValues()
+		{
+			object stringArray;
+			// set the history in properties
+			stringArray = propertyService.GetProperty(&quot;MonoDevelop.FindReplaceDialogs.FindHistory&quot;);
+		
+			if(stringArray != null) {
+				findHistory.AddRange(stringArray.ToString().Split(HISTORY_SEPARATOR_CHAR));
+				searchPatternComboBox.PopdownStrings = stringArray.ToString().Split(HISTORY_SEPARATOR_CHAR);
+			}
+			
+			// now do the replace history
+			if(replaceMode)	{					
+				stringArray = propertyService.GetProperty(&quot;MonoDevelop.FindReplaceDialogs.ReplaceHistory&quot;);
+				if(stringArray != null) {
+					replaceHistory.AddRange(stringArray.ToString().Split(HISTORY_SEPARATOR_CHAR));
+					replacePatternComboBox.PopdownStrings = stringArray.ToString().Split(HISTORY_SEPARATOR_CHAR);
+				}
+			}
+		}
+		
+		// saves the history arrays to the property service
+		// NOTE: this dialog uses a newline character to separate search history strings in the properties file
+		private void SaveHistoryValues()
+		{
+			string[] stringArray;
+			// set the history in properties
+			stringArray = new string[findHistory.Count];
+			findHistory.CopyTo(stringArray, 0);			
+			propertyService.SetProperty(&quot;MonoDevelop.FindReplaceDialogs.FindHistory&quot;, string.Join(HISTORY_SEPARATOR_CHAR.ToString(), stringArray));
+			
+			// now do the replace history
+			if(replaceMode)	{
+				stringArray = new string[replaceHistory.Count];
+				replaceHistory.CopyTo(stringArray, 0);				
+				propertyService.SetProperty(&quot;MonoDevelop.FindReplaceDialogs.ReplaceHistory&quot;, string.Join(HISTORY_SEPARATOR_CHAR.ToString(), stringArray));
+			}
+		}
+		
+		#region code to pretend to be a dialog (cause we can't inherit Dialog and use glade)
+		public void Present()
+		{
+			ReplaceDialogPointer.Present();
+		}
+		
+		public void Destroy()
+		{
+			// save the search and replace history to properties
+			OnClosed ();
+			ReplaceDialogPointer.Destroy();
+		}
+		
+		public void ShowAll()
+		{
+			ReplaceDialogPointer.ShowAll();
+		}
+		#endregion
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/Dialogs/ReplaceInFilesDialog.cs (from rev 941, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Dialogs/ReplaceInFilesDialog.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Gui/Dialogs/ReplaceInFilesDialog.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/Dialogs/ReplaceInFilesDialog.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,207 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+using System.ComponentModel;
+
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.Core.Properties;
+
+using ICSharpCode.Core.Services;
+using ICSharpCode.SharpDevelop.Services;
+using ICSharpCode.TextEditor;
+
+namespace ICSharpCode.SharpDevelop.Gui.Dialogs
+{
+	public class ReplaceInFilesDialog //: BaseSharpDevelopForm
+	{/*
+		ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+		IMessageService messageService  = (IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));
+		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		bool replaceMode;
+		
+		public ReplaceInFilesDialog(bool replaceMode)
+		{
+			this.replaceMode = replaceMode;
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+			if (replaceMode) {
+				this.SetupFromXml(propertyService.DataDirectory + @&quot;\resources\dialogs\ReplaceInFilesDialog.xfrm&quot;);
+				ControlDictionary[&quot;replacePatternComboBox&quot;].Text = SearchReplaceInFilesManager.SearchOptions.ReplacePattern;
+				ControlDictionary[&quot;replaceHelpButton&quot;].Enabled = false;
+			} else {
+				this.SetupFromXml(propertyService.DataDirectory + @&quot;\resources\dialogs\FindInFilesDialog.xfrm&quot;);
+			}
+			
+			ControlDictionary[&quot;findHelpButton&quot;].Enabled = false;
+			ControlDictionary[&quot;searchPatternComboBox&quot;].Text = SearchReplaceInFilesManager.SearchOptions.SearchPattern;
+			
+			AcceptButton = (Button)ControlDictionary[&quot;findButton&quot;];
+			CancelButton = (Button)ControlDictionary[&quot;closeButton&quot;];
+			
+			((ComboBox)ControlDictionary[&quot;specialSearchStrategyComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Dialog.NewProject.SearchReplace.SearchStrategy.WildcardSearch&quot;));
+			((ComboBox)ControlDictionary[&quot;specialSearchStrategyComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Dialog.NewProject.SearchReplace.SearchStrategy.RegexSearch&quot;));
+			int index = 0;
+			switch (SearchReplaceManager.SearchOptions.SearchStrategyType) {
+				case SearchStrategyType.Normal:
+				case SearchStrategyType.Wildcard:
+					break;
+				case SearchStrategyType.RegEx:
+					index = 1;
+					break;
+			}
+ 			((ComboBox)ControlDictionary[&quot;specialSearchStrategyComboBox&quot;]).SelectedIndex = index;
+			
+			((ComboBox)ControlDictionary[&quot;searchLocationComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Global.Location.directories&quot;));
+			((ComboBox)ControlDictionary[&quot;searchLocationComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Global.Location.allopenfiles&quot;));
+			((ComboBox)ControlDictionary[&quot;searchLocationComboBox&quot;]).Items.Add(resourceService.GetString(&quot;Global.Location.wholeproject&quot;));
+						
+			index = 0;
+			switch (SearchReplaceInFilesManager.SearchOptions.DocumentIteratorType) {
+				case DocumentIteratorType.AllOpenFiles:
+					index = 1;
+					break;
+				case DocumentIteratorType.WholeCombine:
+					index = 2;
+					break;
+			}
+			
+			((ComboBox)ControlDictionary[&quot;searchLocationComboBox&quot;]).SelectedIndex = index;
+			((ComboBox)ControlDictionary[&quot;searchLocationComboBox&quot;]).SelectedIndexChanged += new EventHandler(SearchLocationCheckBoxChangedEvent);
+			
+			((CheckBox)ControlDictionary[&quot;useSpecialSearchStrategyCheckBox&quot;]).CheckedChanged += new EventHandler(SpecialSearchStrategyCheckBoxChangedEvent);
+			
+			ControlDictionary[&quot;directoryTextBox&quot;].Text = SearchReplaceInFilesManager.SearchOptions.SearchDirectory;
+			ControlDictionary[&quot;fileMaskTextBox&quot;].Text = SearchReplaceInFilesManager.SearchOptions.FileMask;
+			((CheckBox)ControlDictionary[&quot;includeSubdirectoriesCheckBox&quot;]).Checked = SearchReplaceInFilesManager.SearchOptions.SearchSubdirectories;
+			
+			ControlDictionary[&quot;browseButton&quot;].Click += new EventHandler(BrowseDirectoryEvent);
+			
+			ControlDictionary[&quot;findButton&quot;].Click += new EventHandler(FindEvent);
+			
+			if (replaceMode) {
+				ControlDictionary[&quot;replaceAllButton&quot;].Click += new EventHandler(ReplaceEvent);
+			}
+			
+			
+			SearchLocationCheckBoxChangedEvent(null, null);
+			SpecialSearchStrategyCheckBoxChangedEvent(null, null);
+		}
+		
+		void FindEvent(object sender, EventArgs e)
+		{
+			if (SetupSearchReplaceInFilesManager()) {
+				SearchReplaceInFilesManager.FindAll();
+			}
+		}
+		
+		void ReplaceEvent(object sender, EventArgs e)
+		{
+			if (SetupSearchReplaceInFilesManager()) {
+				SearchReplaceInFilesManager.ReplaceAll();
+			}
+		}
+		
+		void BrowseDirectoryEvent(object sender, EventArgs e)
+		{
+			FolderDialog fd = new FolderDialog();
+			if (fd.DisplayDialog(resourceService.GetString(&quot;NewProject.SearchReplace.FindInFilesBrowseLabel&quot;)) == DialogResult.OK) {
+				ControlDictionary[&quot;directoryTextBox&quot;].Text = fd.Path;
+			}
+		}
+		
+		void SearchLocationCheckBoxChangedEvent(object sender, EventArgs e)
+		{
+			bool enableDirectorySearch = ((ComboBox)ControlDictionary[&quot;searchLocationComboBox&quot;]).SelectedIndex == 0;
+			ControlDictionary[&quot;fileMaskTextBox&quot;].Enabled = enableDirectorySearch;
+			ControlDictionary[&quot;directoryTextBox&quot;].Enabled = enableDirectorySearch;
+			ControlDictionary[&quot;browseButton&quot;].Enabled = enableDirectorySearch;
+			ControlDictionary[&quot;includeSubdirectoriesCheckBox&quot;].Enabled = enableDirectorySearch;
+		}
+		
+		void SpecialSearchStrategyCheckBoxChangedEvent(object sender, EventArgs e)
+		{
+			CheckBox cb = (CheckBox)ControlDictionary[&quot;useSpecialSearchStrategyCheckBox&quot;];
+			if (cb != null) {
+				ControlDictionary[&quot;specialSearchStrategyComboBox&quot;].Enabled = cb.Checked;
+			}
+		}
+		
+		bool SetupSearchReplaceInFilesManager()
+		{
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+			
+			string directoryName = ControlDictionary[&quot;directoryTextBox&quot;].Text;
+			string fileMask      = ControlDictionary[&quot;fileMaskTextBox&quot;].Text;
+			if (fileMask == null || fileMask.Length == 0) {
+				fileMask = &quot;*&quot;;
+			}
+			
+			if (SearchReplaceInFilesManager.SearchOptions.DocumentIteratorType == DocumentIteratorType.Directory) {
+				
+				if (!fileUtilityService.IsValidFileName(directoryName)) {
+					messageService.ShowErrorFormatted(&quot;${res:NewProject.SearchReplace.FindInFilesInvalidDirectoryMessage}&quot;, directoryName);
+					return false;
+				}
+				
+				if (!Directory.Exists(directoryName)) {
+					messageService.ShowErrorFormatted(&quot;${res:NewProject.SearchReplace.FindInFilesDirectoryNotExistingMessage}&quot;, directoryName);
+					return false;
+				}
+				
+				if (!fileUtilityService.IsValidFileName(fileMask) || fileMask.IndexOf('\\') &gt;= 0) {
+					messageService.ShowErrorFormatted(&quot;${res:NewProject.SearchReplace.FindInFilesInvalidFilemaskMessage}&quot;, fileMask);
+					return false;
+				}
+			}
+			if (fileMask == null || fileMask.Length == 0) {
+				SearchReplaceInFilesManager.SearchOptions.FileMask = &quot;*&quot;;
+			} else {
+				SearchReplaceInFilesManager.SearchOptions.FileMask        = fileMask;
+			}
+			SearchReplaceInFilesManager.SearchOptions.SearchDirectory = directoryName;
+			SearchReplaceInFilesManager.SearchOptions.SearchSubdirectories = ((CheckBox)ControlDictionary[&quot;includeSubdirectoriesCheckBox&quot;]).Checked;
+			
+			SearchReplaceInFilesManager.SearchOptions.SearchPattern  = ControlDictionary[&quot;searchPatternComboBox&quot;].Text;
+			if (replaceMode) {
+				SearchReplaceInFilesManager.SearchOptions.ReplacePattern = ControlDictionary[&quot;replacePatternComboBox&quot;].Text;
+			}
+			
+			SearchReplaceInFilesManager.SearchOptions.IgnoreCase          = !((CheckBox)ControlDictionary[&quot;ignoreCaseCheckBox&quot;]).Checked;
+			SearchReplaceInFilesManager.SearchOptions.SearchWholeWordOnly = ((CheckBox)ControlDictionary[&quot;searchWholeWordOnlyCheckBox&quot;]).Checked;
+			
+			if (((CheckBox)ControlDictionary[&quot;useSpecialSearchStrategyCheckBox&quot;]).Checked) {
+				switch (((ComboBox)ControlDictionary[&quot;specialSearchStrategyComboBox&quot;]).SelectedIndex) {
+					case 0:
+						SearchReplaceInFilesManager.SearchOptions.SearchStrategyType = SearchStrategyType.Wildcard;
+						break;
+					case 1:
+						SearchReplaceInFilesManager.SearchOptions.SearchStrategyType = SearchStrategyType.RegEx;
+						break;
+				}
+			} else {
+				SearchReplaceInFilesManager.SearchOptions.SearchStrategyType = SearchStrategyType.Normal;
+			}
+			
+			switch (((ComboBox)ControlDictionary[&quot;searchLocationComboBox&quot;]).SelectedIndex) {
+				case 0:
+					SearchReplaceInFilesManager.SearchOptions.DocumentIteratorType = DocumentIteratorType.Directory;
+					break;
+				case 1:
+					SearchReplaceInFilesManager.SearchOptions.DocumentIteratorType = DocumentIteratorType.AllOpenFiles;
+					break;
+				case 2:
+					SearchReplaceInFilesManager.SearchOptions.DocumentIteratorType = DocumentIteratorType.WholeCombine;
+					break;
+			}
+			return true;
+		}
+		*/
+	}
+}

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Gui/SourceEditorView.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -125,7 +125,6 @@
 					}
 					break;
 				case '[':
-					break;
 					try {
 						InsightWindow insightWindow = new InsightWindow(this, ParentEditor.DisplayBinding.ContentName);
 						

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Makefile.am
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Makefile.am	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Makefile.am	2004-02-19 03:42:53 UTC (rev 942)
@@ -20,6 +20,8 @@
 ./Gui/OptionPanels/GeneralTextEditorPanel.cs \
 ./Gui/EditTemplateGroupDialog.cs \
 ./Gui/Dialogs/GotoLineNumberDialog.cs \
+./Gui/Dialogs/ReplaceDialog.cs \
+./Gui/Dialogs/ReplaceInFilesDialog.cs \
 ./InsightWindow/IndexerInsightDataProvider.cs \
 ./InsightWindow/MethodInsightDataProvider.cs \
 ./InsightWindow/InsightWindow.cs \
@@ -39,7 +41,32 @@
 ./FormattingStrategy/IndentStyle.cs \
 ./FormattingStrategy/IFormattingStrategy.cs \
 ./FormattingStrategy/IFormattableDocument.cs \
-./Codons/EditActionCodon.cs
+./Codons/EditActionCodon.cs \
+./Search/DocumentIterator/ProvidedDocumentInformation.cs \
+./Search/DocumentIterator/DirectoryDocumentIterator.cs \
+./Search/DocumentIterator/AllOpenDocumentIterator.cs \
+./Search/DocumentIterator/IDocumentIterator.cs \
+./Search/DocumentIterator/ReverseDocumentIterator.cs \
+./Search/DocumentIterator/WholeProjectDocumentIterator.cs \
+./Search/DocumentIterator/CurrentDocumentIterator.cs \
+./Search/SearchStrategy/KMPSearchStrategy.cs \
+./Search/SearchStrategy/ISearchStrategy.cs \
+./Search/SearchStrategy/BruteForceSearchStrategy.cs \
+./Search/SearchStrategy/RegExSearchStrategy.cs \
+./Search/SearchStrategy/WildcardSearchStrategy.cs \
+./Search/SearchReplaceManager.cs \
+./Search/DefaultFind.cs \
+./Search/SearchResult/DefaultSearchResult.cs \
+./Search/SearchResult/ISearchResult.cs \
+./Search/SearchOptions.cs \
+./Search/SearchReplaceInFilesManager.cs \
+./Search/SearchReplaceUtilities.cs \
+./Search/IFind.cs \
+./Search/TextIterator/ITextIterator.cs \
+./Search/TextIterator/ITextIteratorBuilder.cs \
+./Search/TextIterator/ForwardTextIteratorBuilder.cs \
+./Search/TextIterator/ForwardTextIterator.cs \
+./Search/ITextBufferStrategy.cs
 
 all : $(DLL)
 

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DefaultFind.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DefaultFind.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DefaultFind.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,124 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+using System.Diagnostics;
+
+using ICSharpCode.SharpDevelop.Gui;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class DefaultFind : IFind
+	{
+		ISearchStrategy             searchStrategy      = null;
+		IDocumentIterator           documentIterator    = null;
+		ITextIterator               textIterator        = null;
+		ITextIteratorBuilder        textIteratorBuilder = null;
+		ProvidedDocumentInformation info = null;
+		
+		public ProvidedDocumentInformation CurrentDocumentInformation {
+			get {
+				return info;
+			}
+		}
+		
+		public ITextIteratorBuilder TextIteratorBuilder {
+			get {
+				return textIteratorBuilder;
+			}
+			set {
+				textIteratorBuilder = value;
+			}
+		}
+		
+		public ITextIterator TextIterator {
+			get {
+				return textIterator;
+			}
+		}
+		
+		public ISearchStrategy SearchStrategy {
+			get {
+				return searchStrategy;
+			}
+			set {
+				searchStrategy = value;
+			}
+		}
+		
+		public IDocumentIterator DocumentIterator {
+			get {
+				return documentIterator;
+			}
+			set {
+				documentIterator = value;
+			}
+		}
+		
+		ISearchResult CreateNamedSearchResult(ISearchResult pos)
+		{
+			if (info == null || pos == null) {
+				return null;
+			}
+			pos.ProvidedDocumentInformation = info;
+			return pos;
+		}
+		
+		public void Reset()
+		{
+			documentIterator.Reset();
+			textIterator = null;
+		}
+		
+		public void Replace(int offset, int length, string pattern)
+		{
+			if (CurrentDocumentInformation != null &amp;&amp; TextIterator != null) {
+				CurrentDocumentInformation.Replace(offset, length, pattern);
+				CurrentDocumentInformation.SaveBuffer();
+				TextIterator.InformReplace(offset, length, pattern.Length);
+			}
+		}
+		
+		public ISearchResult FindNext(SearchOptions options) 
+		{
+			// insanity check
+			Debug.Assert(searchStrategy      != null);
+			Debug.Assert(documentIterator    != null);
+			Debug.Assert(textIteratorBuilder != null);
+			Debug.Assert(options             != null);
+			
+			if (info != null &amp;&amp; textIterator != null &amp;&amp; documentIterator.CurrentFileName != null) {
+				if (info.FileName != documentIterator.CurrentFileName) { // create new iterator, if document changed
+					info         = documentIterator.Current;
+					textIterator = textIteratorBuilder.BuildTextIterator(info);
+				} else { // old document -&gt; initialize iterator position to caret pos
+					textIterator.Position = info.CurrentOffset;
+				}
+				
+				ISearchResult result = CreateNamedSearchResult(searchStrategy.FindNext(textIterator, options));
+				if (result != null) {
+					info.CurrentOffset = textIterator.Position;
+					return result;
+				}
+			}
+			
+			// not found or first start -&gt; move forward to the next document
+			if (documentIterator.MoveForward()) {
+				info = documentIterator.Current;
+				// document is valid for searching -&gt; set iterator &amp; fileName
+				if (info != null &amp;&amp; info.TextBuffer != null &amp;&amp; info.EndOffset &gt;= 0 &amp;&amp; info.EndOffset &lt; info.TextBuffer.Length) {
+					textIterator = textIteratorBuilder.BuildTextIterator(info);
+				} else {
+					textIterator = null;
+				}
+				
+				return FindNext(options);
+			}
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/AllOpenDocumentIterator.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/AllOpenDocumentIterator.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/AllOpenDocumentIterator.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,111 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class AllOpenDocumentIterator : IDocumentIterator
+	{
+		int  startIndex = -1;
+		bool resetted    = true;
+		
+		public AllOpenDocumentIterator()
+		{
+			Reset();
+		}
+		
+		public string CurrentFileName {
+			get {
+				if (!SearchReplaceUtilities.IsTextAreaSelected) {
+					return null;
+				}
+				
+				if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName == null) {
+					return WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.UntitledName;
+				}
+				
+				return WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName;
+			}
+		}
+		
+		public ProvidedDocumentInformation Current {
+			get {
+				if (!SearchReplaceUtilities.IsTextAreaSelected) {
+					return null;
+				}
+				//IDocument document = (((ITextEditorControlProvider)WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent).TextEditorControl).Document;
+				//return new ProvidedDocumentInformation(document,
+				//                                       CurrentFileName);
+				return null;
+			}
+		}
+		
+		int GetCurIndex()
+		{
+			for (int i = 0; i &lt; WorkbenchSingleton.Workbench.ViewContentCollection.Count; ++i) {
+				if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent == WorkbenchSingleton.Workbench.ViewContentCollection[i]) {
+					return i;
+				}
+			}
+			return -1;
+		}
+		
+		public bool MoveForward() 
+		{
+			int curIndex =  GetCurIndex();
+			if (curIndex &lt; 0) {
+				return false;
+			}
+			
+			if (resetted) {
+				resetted = false;
+				return true;
+			}
+			
+			int nextIndex = (curIndex + 1) % WorkbenchSingleton.Workbench.ViewContentCollection.Count;
+			if (nextIndex == startIndex) {
+				return false;
+			}
+			WorkbenchSingleton.Workbench.ViewContentCollection[nextIndex].WorkbenchWindow.SelectWindow();
+			return true;
+		}
+		
+		public bool MoveBackward()
+		{
+			int curIndex =  GetCurIndex();
+			if (curIndex &lt; 0) {
+				return false;
+			}
+			if (resetted) {
+				resetted = false;
+				return true;
+			}
+			
+			if (curIndex == 0) {
+				curIndex = WorkbenchSingleton.Workbench.ViewContentCollection.Count - 1;
+			}
+			
+			if (curIndex &gt; 0) {
+				--curIndex;
+				WorkbenchSingleton.Workbench.ViewContentCollection[curIndex].WorkbenchWindow.SelectWindow();
+				return true;
+			}
+			return false;
+		}
+		
+		public void Reset() 
+		{
+			startIndex = GetCurIndex();
+			resetted = true;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/CurrentDocumentIterator.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/CurrentDocumentIterator.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/CurrentDocumentIterator.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,73 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class CurrentDocumentIterator : IDocumentIterator
+	{
+		bool      didRead = false;
+		//IDocument curDocument = null;
+		
+		public CurrentDocumentIterator() 
+		{
+			Reset();
+		}
+			
+		public string CurrentFileName {
+			get {
+				if (!SearchReplaceUtilities.IsTextAreaSelected) {
+					return null;
+				}
+				if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName == null) {
+					return WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.UntitledName;
+				}
+				return WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent.ContentName;
+			}
+		}
+		
+		public ProvidedDocumentInformation Current {
+			get {
+				if (!SearchReplaceUtilities.IsTextAreaSelected) {
+					return null;
+				}
+				//curDocument = (((ITextEditorControlProvider)WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent).TextEditorControl).Document;
+				//return new ProvidedDocumentInformation(curDocument,
+				//                                     CurrentFileName);
+				return null;
+			}
+		}
+			
+		public bool MoveForward() 
+		{
+			if (!SearchReplaceUtilities.IsTextAreaSelected) {
+				return false;
+			}
+			if (didRead) {
+				return false;
+			}
+			didRead = true;
+			
+			return true;
+		}
+		
+		public bool MoveBackward()
+		{
+			return MoveForward();
+		}
+		
+		public void Reset() 
+		{
+			didRead = false;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/DirectoryDocumentIterator.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/DirectoryDocumentIterator.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/DirectoryDocumentIterator.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,109 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+using System.IO;
+
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.SharpDevelop.Internal.Project;
+using ICSharpCode.Core.Services;
+using ICSharpCode.SharpDevelop.Services;
+using ICSharpCode.TextEditor;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class DirectoryDocumentIterator : IDocumentIterator
+	{
+		string searchDirectory;
+		string fileMask;
+		bool   searchSubdirectories;
+		
+		StringCollection files    = null;
+		int              curIndex = -1;
+		
+		public DirectoryDocumentIterator(string searchDirectory, string fileMask, bool searchSubdirectories)
+		{
+			this.searchDirectory      = searchDirectory;
+			this.fileMask             = fileMask;
+			this.searchSubdirectories = searchSubdirectories;
+			
+			Reset();
+		}
+		
+		public string CurrentFileName {
+			get {
+				if (curIndex &lt; 0 || curIndex &gt;= files.Count) {
+					return null;
+				}
+				
+				return files[curIndex].ToString();;
+			}
+		}
+				
+		public ProvidedDocumentInformation Current {
+			get {
+				/*if (curIndex &lt; 0 || curIndex &gt;= files.Count) {
+					return null;
+				}
+				if (!File.Exists(files[curIndex].ToString())) {
+					++curIndex;
+					return Current;
+				}
+				IDocument document;
+				string fileName = files[curIndex].ToString();
+				foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
+					// WINDOWS DEPENDENCY : ToUpper
+					if (content.ContentName != null &amp;&amp;
+						content.ContentName.ToUpper() == fileName.ToUpper()) {
+						document = ((ITextEditorControlProvider)content).TextEditorControl.Document;
+						return new ProvidedDocumentInformation(document,
+						                                       fileName);
+					}
+				}
+				ITextBufferStrategy strategy = null;
+				try {
+					strategy = StringTextBufferStrategy.CreateTextBufferFromFile(fileName);
+				} catch (Exception) {
+					TaskService taskService = (TaskService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(TaskService));
+					taskService.Tasks.Add(new Task(String.Empty, &quot;can't access &quot; + fileName, -1, -1));
+					return null;
+				}
+				return new ProvidedDocumentInformation(strategy, 
+				                                       fileName, 
+				                                       0);
+				*/
+				return null;
+			}
+		}
+		
+		public bool MoveForward() 
+		{
+			if (curIndex == -1) {
+				FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+				files = fileUtilityService.SearchDirectory(this.searchDirectory, this.fileMask, this.searchSubdirectories);
+			}
+			return ++curIndex &lt; files.Count;
+		}
+		
+		public bool MoveBackward()
+		{
+			if (curIndex == -1) {
+				curIndex = files.Count - 1;
+				return true;
+			}
+			return --curIndex &gt;= -1;
+		}
+		
+		
+		public void Reset() 
+		{
+			curIndex = -1;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/IDocumentIterator.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/IDocumentIterator.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/IDocumentIterator.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,54 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// Represents a bi-directional iterator which could move froward/backward
+	/// in a document queue. Note that after move forward is called
+	/// move backward needn't to function correctly either move forward or move
+	/// backward is called but they're not mixed. After a reset the move operation
+	/// can be switched.
+	/// &lt;/summary&gt;
+	public interface IDocumentIterator 
+	{
+		/// &lt;value&gt;
+		/// Returns the current ProvidedDocumentInformation. This method
+		/// usually creates a new ProvidedDocumentInformation object which can
+		/// be time consuming
+		/// &lt;/value&gt;
+		ProvidedDocumentInformation Current {
+			get;
+		}
+		
+		/// &lt;value&gt;
+		/// Returns the file name of the current provided document information. This
+		/// property usually is not time consuming
+		/// &lt;/value&gt;
+		string CurrentFileName {
+			get;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Moves the iterator one document forward.
+		/// &lt;/remarks&gt;
+		bool MoveForward();
+		
+		/// &lt;remarks&gt;
+		/// Moves the iterator one document backward.
+		/// &lt;/remarks&gt;
+		bool MoveBackward();
+		
+		/// &lt;remarks&gt;
+		/// Resets the iterator to the start position.
+		/// &lt;/remarks&gt;
+		void Reset();
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/ProvidedDocumentInformation.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/ProvidedDocumentInformation.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/ProvidedDocumentInformation.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,110 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+
+using ICSharpCode.SharpDevelop.Gui;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class ProvidedDocumentInformation
+	{
+		//IDocument document;
+		ITextBufferStrategy textBuffer;
+		string              fileName;
+		int                 currentOffset;
+		
+		public ITextBufferStrategy TextBuffer {
+			get {
+				return textBuffer;
+			}
+			set {
+				textBuffer = value;
+			}
+		}
+		
+		public string FileName {
+			get {
+				return fileName;
+			}
+		}
+		
+		public int CurrentOffset {
+			get {
+//				if (document != null) {
+//					return document.Caret.Offset;
+//				}
+				return currentOffset;
+			}
+			set {
+//				if (document != null) {
+//					document.Caret.Offset = value;
+//				} else {
+					currentOffset = value;
+//				}
+			}
+		}
+		
+		public int EndOffset {
+			get {
+				//if (document != null) {
+				//	return SearchReplaceUtilities.CalcCurrentOffset(document);
+				//}
+				return currentOffset;
+			}
+		}
+		
+		public void Replace(int offset, int length, string pattern)
+		{
+			//if (document != null) {
+			//	document.Replace(offset, length, pattern);
+			//} else {
+			//	textBuffer.Replace(offset, length, pattern);
+			//}
+			
+			if (offset &lt;= CurrentOffset) {
+				CurrentOffset = CurrentOffset - length + pattern.Length;
+			}
+		}
+		
+		public void SaveBuffer()
+		{
+			//if (document != null) {
+				
+			//} else {
+				StreamWriter streamWriter = File.CreateText(this.fileName);
+				streamWriter.Write(textBuffer.GetText(0, textBuffer.Length));
+				streamWriter.Close();
+			//}
+		}
+		
+		/*public IDocument CreateDocument()
+		{
+			if (document != null) {
+				return document;
+			}
+			return new DocumentFactory().CreateFromFile(fileName);
+		}*/		
+		
+		/*public ProvidedDocumentInformation(IDocument document, string fileName)
+		{
+			this.document   = document;
+			this.textBuffer = document.TextBufferStrategy;
+			this.fileName   = fileName;
+//			this.currentOffset = document.Caret.Offset;
+		}*/
+		
+		public ProvidedDocumentInformation(ITextBufferStrategy textBuffer, string fileName, int currentOffset)
+		{
+			this.textBuffer    = textBuffer;
+			this.fileName      = fileName;
+			this.currentOffset = currentOffset;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/ReverseDocumentIterator.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/ReverseDocumentIterator.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/ReverseDocumentIterator.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,53 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// Represents a bi-directional iterator which could move froward/backward
+	/// in a document queue. 
+	/// &lt;/summary&gt;
+	public class ReverseDocumentIterator : IDocumentIterator 
+	{
+		IDocumentIterator documentIterator;
+		
+		public string CurrentFileName {
+			get {
+				return documentIterator.CurrentFileName;
+			}
+		}
+		
+		public ProvidedDocumentInformation Current {
+			get {
+				return documentIterator.Current;
+			}
+		}
+		
+		public ReverseDocumentIterator(IDocumentIterator documentIterator)
+		{
+			this.documentIterator = documentIterator;
+		}
+		
+		public bool MoveForward()
+		{
+			return documentIterator.MoveBackward();
+		}
+		
+		public bool MoveBackward()
+		{
+			return documentIterator.MoveBackward();
+		}
+		
+		public void Reset()
+		{
+			documentIterator.Reset();
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/WholeProjectDocumentIterator.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/WholeProjectDocumentIterator.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/DocumentIterator/WholeProjectDocumentIterator.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,121 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.IO;
+
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.SharpDevelop.Internal.Project;
+using ICSharpCode.Core.Services;
+using ICSharpCode.SharpDevelop.Services;
+using ICSharpCode.TextEditor;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class WholeProjectDocumentIterator : IDocumentIterator
+	{
+		ArrayList files    = new ArrayList();
+		int       curIndex = -1;
+		
+		public WholeProjectDocumentIterator()
+		{
+			Reset();
+		}
+		
+		public string CurrentFileName {
+			get {
+				if (curIndex &lt; 0 || curIndex &gt;= files.Count) {
+					return null;
+				}
+				
+				return files[curIndex].ToString();;
+			}
+		}
+				
+		public ProvidedDocumentInformation Current {
+			get {
+				if (curIndex &lt; 0 || curIndex &gt;= files.Count) {
+					return null;
+				}
+				if (!File.Exists(files[curIndex].ToString())) {
+					++curIndex;
+					return Current;
+				}
+				//IDocument document;
+				string fileName = files[curIndex].ToString();
+				/*foreach (IViewContent content in WorkbenchSingleton.Workbench.ViewContentCollection) {
+					// WINDOWS DEPENDENCY : ToUpper
+					if (content.ContentName != null &amp;&amp;
+						content.ContentName.ToUpper() == fileName.ToUpper()) {
+						document = (((ITextEditorControlProvider)content).TextEditorControl).Document;
+						return new ProvidedDocumentInformation(document,
+						                                       fileName);
+					}
+				}*/
+				ITextBufferStrategy strategy = null;
+				try {
+					//strategy = StringTextBufferStrategy.CreateTextBufferFromFile(fileName);
+				} catch (Exception) {
+					TaskService taskService = (TaskService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(TaskService));
+					taskService.Tasks.Add(new Task(String.Empty, &quot;can't access &quot; + fileName, -1, -1));
+					return null;
+				}
+				return new ProvidedDocumentInformation(strategy, 
+				                                       fileName, 
+				                                       0);
+			}
+		}
+		
+		public bool MoveForward() 
+		{
+			return ++curIndex &lt; files.Count;
+		}
+		
+		public bool MoveBackward()
+		{
+			if (curIndex == -1) {
+				curIndex = files.Count - 1;
+				return true;
+			}
+			return --curIndex &gt;= -1;
+		}
+		
+		
+		void AddFiles(IProject project)
+		{
+			foreach (ProjectFile file in project.ProjectFiles) {
+				if (file.BuildAction == BuildAction.Compile &amp;&amp;
+				    file.Subtype     == Subtype.Code) {
+					files.Add(file.Name);
+				}
+			}
+		}
+		
+		void AddFiles(Combine combine)
+		{
+			foreach (CombineEntry entry in combine.Entries) {
+				if (entry is ProjectCombineEntry) {
+					AddFiles(((ProjectCombineEntry)entry).Project);
+				} else {
+					AddFiles(((CombineCombineEntry)entry).Combine);
+				}
+			}
+		}
+		
+		public void Reset() 
+		{
+			files.Clear();
+			IProjectService projectService = (IProjectService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			if (projectService.CurrentOpenCombine != null) {
+				AddFiles(projectService.CurrentOpenCombine);
+			}
+			
+			curIndex = -1;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/IFind.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/IFind.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/IFind.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,75 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+
+using ICSharpCode.SharpDevelop.Gui;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// The basic interface for search operations in a document.
+	/// &lt;/summary&gt;
+	public interface IFind
+	{
+		/// &lt;value&gt;
+		/// An object that implements a search algorithm.
+		/// &lt;/value&gt;
+		ISearchStrategy SearchStrategy {
+			get;
+			set;
+		}
+		
+		/// &lt;value&gt;
+		/// Gets the current document information
+		/// &lt;/value&gt;
+		ProvidedDocumentInformation CurrentDocumentInformation {
+			get;
+		}
+		
+		/// &lt;value&gt;
+		/// An object that provides a document loading approach.
+		/// &lt;/value&gt;
+		IDocumentIterator DocumentIterator {
+			get;
+			set;
+		}
+		
+		/// &lt;value&gt;
+		/// The text iterator builder which builds ITextIterator objects
+		/// for the find.
+		/// &lt;/value&gt;
+		ITextIteratorBuilder TextIteratorBuilder {
+			get;
+			set;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Does a replace in the current document information. This
+		/// is the only method which should be used for doing replacements
+		/// in a searched document.
+		/// &lt;/remarks&gt;
+		void Replace(int offset, int length, string pattern);
+		
+		/// &lt;remarks&gt;
+		/// Finds next pattern.
+		/// &lt;remarks&gt;
+		/// &lt;returns&gt;
+		/// null if the pattern wasn't found. If it returns null the current document
+		/// information will be null too otherwise it will point to the document in which
+		/// the search pattern was found.
+		/// &lt;/returns&gt;
+		ISearchResult FindNext(SearchOptions options);
+		
+		/// &lt;remarks&gt;
+		/// Resets the find object to the original state.
+		/// &lt;/remarks&gt;
+		void Reset();
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/ITextBufferStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/ITextBufferStrategy.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/ITextBufferStrategy.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,85 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// Interface to describe a sequence of characters that can be edited. 	
+	/// &lt;/summary&gt;
+	public interface ITextBufferStrategy
+	{
+		/// &lt;value&gt;
+		/// The current length of the sequence of characters that can be edited.
+		/// &lt;/value&gt;
+		int Length {
+			get;
+		}
+		
+		/// &lt;summary&gt;
+		/// Inserts a string of characters into the sequence.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;offset&quot;&gt;
+		/// offset where to insert the string.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;text&quot;&gt;
+		/// text to be inserted.
+		/// &lt;/param&gt;
+		void Insert(int offset, string text);
+		
+		/// &lt;summary&gt;
+		/// Removes some portion of the sequence.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;offset&quot;&gt;
+		/// offset of the remove.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;length&quot;&gt;
+		/// number of characters to remove.
+		/// &lt;/param&gt;
+		void Remove(int offset, int length);
+		
+		/// &lt;summary&gt;
+		/// Replace some portion of the sequence.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;offset&quot;&gt;
+		/// offset.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;length&quot;&gt;
+		/// number of characters to replace.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;text&quot;&gt;
+		/// text to be replaced with.
+		/// &lt;/param&gt;
+		void Replace(int offset, int length, string text);
+		
+		/// &lt;summary&gt;
+		/// Fetches a string of characters contained in the sequence.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;offset&quot;&gt;
+		/// Offset into the sequence to fetch
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;length&quot;&gt;
+		/// number of characters to copy.
+		/// &lt;/param&gt;
+		string GetText(int offset, int length);
+		
+		/// &lt;summary&gt;
+		/// Returns a specific char of the sequence.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;offset&quot;&gt;
+		/// Offset of the char to get.
+		/// &lt;/param&gt;
+		char GetCharAt(int offset);
+		
+		/// &lt;summary&gt;
+		/// This method sets the stored content.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;text&quot;&gt;
+		/// The string that represents the character sequence.
+		/// &lt;/param&gt;
+		void SetContent(string text);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchOptions.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchOptions.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchOptions.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,141 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+
+using ICSharpCode.Core.Services;
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Undo;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class SearchOptions
+	{
+		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		IProperties properties;
+		
+		public bool IgnoreCase {
+			get {
+				return properties.GetProperty(&quot;IgnoreCase&quot;, false);
+			}
+			set {
+				properties.SetProperty(&quot;IgnoreCase&quot;, value);
+			}
+		}
+		
+		public bool SearchWholeWordOnly {
+			get {
+				return properties.GetProperty(&quot;SearchWholeWordOnly&quot;, false);
+			}
+			
+			set {
+				properties.SetProperty(&quot;SearchWholeWordOnly&quot;, value);
+			}
+		}
+		
+		public string SearchPattern {
+			get {
+				return properties.GetProperty(&quot;SearchPattern&quot;, String.Empty);
+			}
+			set {
+				properties.SetProperty(&quot;SearchPattern&quot;, value);
+			}
+		}
+		
+		public string ReplacePattern {
+			get {
+				return properties.GetProperty(&quot;ReplacePattern&quot;, String.Empty);
+			}
+			set {
+				properties.SetProperty(&quot;ReplacePattern&quot;, value);
+			}
+		}
+		
+		public DocumentIteratorType DocumentIteratorType {
+			get {
+				return (DocumentIteratorType)propertyService.GetProperty(&quot;DocumentIteratorType&quot;, DocumentIteratorType.CurrentDocument);
+			}
+			set {
+				if (DocumentIteratorType != value) {
+					propertyService.SetProperty(&quot;DocumentIteratorType&quot;, value);
+					OnDocumentIteratorTypeChanged(EventArgs.Empty);
+				}
+			}
+		}
+		
+		public SearchStrategyType SearchStrategyType {
+			get {
+				return (SearchStrategyType)propertyService.GetProperty(&quot;SearchStrategyType&quot;, SearchStrategyType.Normal);
+			}
+			set {
+				if (SearchStrategyType != value) {
+					propertyService.SetProperty(&quot;SearchStrategyType&quot;, value);
+					OnSearchStrategyTypeChanged(EventArgs.Empty);
+				}
+			}
+		}
+		
+		public string FileMask {
+			get {
+				return propertyService.GetProperty(&quot;FileMask&quot;, String.Empty);
+			}
+			set {
+				propertyService.SetProperty(&quot;FileMask&quot;, value);
+			}
+		}
+
+		public string SearchDirectory {
+			get {
+				return propertyService.GetProperty(&quot;SearchDirectory&quot;, String.Empty);
+			}
+			set {
+				propertyService.SetProperty(&quot;SearchDirectory&quot;, value);
+			}
+		}
+		
+		public bool SearchSubdirectories {
+			get {
+				return propertyService.GetProperty(&quot;SearchSubdirectories&quot;, true);
+			}
+			set {
+				propertyService.SetProperty(&quot;SearchSubdirectories&quot;, value);
+			}
+		}
+		
+		/// &lt;remarks&gt;
+		/// For unit testing purposes
+		/// &lt;/remarks&gt;
+		public SearchOptions(IProperties properties)
+		{
+			this.properties = properties;
+		}
+		
+		public SearchOptions(string propertyName)
+		{
+			properties = (IProperties)propertyService.GetProperty(propertyName, new DefaultProperties());
+		}
+		
+		protected void OnDocumentIteratorTypeChanged(EventArgs e)
+		{
+			if (DocumentIteratorTypeChanged != null) {
+				DocumentIteratorTypeChanged(this, e);
+			}
+		}
+		
+		protected void OnSearchStrategyTypeChanged(EventArgs e)
+		{
+			if (SearchStrategyTypeChanged != null) {
+				SearchStrategyTypeChanged(this, e);
+			}
+		}
+		
+		public event EventHandler DocumentIteratorTypeChanged;
+		public event EventHandler SearchStrategyTypeChanged;
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceInFilesManager.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceInFilesManager.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceInFilesManager.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,143 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+
+using ICSharpCode.SharpDevelop.Gui;
+
+using ICSharpCode.Core.Services;
+using ICSharpCode.SharpDevelop.Services;
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.SharpDevelop.Gui.Pads;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class SearchReplaceInFilesManager
+	{
+		static IFind find                  = new DefaultFind();
+		static SearchOptions searchOptions = new SearchOptions(&quot;SharpDevelop.SearchAndReplace.SearchAndReplaceInFilesProperties&quot;);
+		
+		static PropertyService      propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		
+		static string              currentFileName = String.Empty;
+		//static IDocument currentDocument = null;
+		
+		public static SearchOptions SearchOptions {
+			get {
+				return searchOptions;
+			}
+		}
+		
+		static SearchReplaceInFilesManager()
+		{
+			find.TextIteratorBuilder = new ForwardTextIteratorBuilder();
+			searchOptions.SearchStrategyTypeChanged   += new EventHandler(InitializeSearchStrategy);
+			searchOptions.DocumentIteratorTypeChanged += new EventHandler(InitializeDocumentIterator);
+			InitializeDocumentIterator(null, null);
+			InitializeSearchStrategy(null, null);
+		}
+		
+		static void InitializeSearchStrategy(object sender, EventArgs e)
+		{
+			find.SearchStrategy = SearchReplaceUtilities.CreateSearchStrategy(SearchOptions.SearchStrategyType);
+		}
+		
+		static void InitializeDocumentIterator(object sender, EventArgs e)
+		{
+			find.DocumentIterator = SearchReplaceUtilities.CreateDocumentIterator(SearchOptions.DocumentIteratorType);
+		}
+		
+		/// &lt;remarks&gt;
+		/// This method displays the search result in the task view
+		/// &lt;/remarks&gt;
+		static void DisplaySearchResult(ISearchResult result)
+		{
+			TaskService taskService = (TaskService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(TaskService));
+			
+			// check if the current document is up to date
+			if (currentFileName != result.FileName) {
+				// if not, create new document
+				currentFileName = result.FileName;
+				//currentDocument = result.CreateDocument(); 
+			}
+			
+			// get line out of the document and display it in the task list
+			//int lineNumber = currentDocument.GetLineNumberForOffset(Math.Min(currentDocument.TextLength, result.Offset));
+			//LineSegment line = currentDocument.GetLineSegment(lineNumber);
+			//taskService.Tasks.Add(new Task(result.FileName, currentDocument.GetText(line.Offset, line.Length), result.Offset - line.Offset, lineNumber));
+		}
+		
+		static bool InitializeSearchInFiles()
+		{
+			Debug.Assert(searchOptions != null);
+			
+			TaskService taskService = (TaskService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(TaskService));
+			taskService.Tasks.Clear();
+			
+			InitializeDocumentIterator(null, null);
+			InitializeSearchStrategy(null, null);
+			find.Reset();
+			find.SearchStrategy.CompilePattern(searchOptions);
+			
+			currentFileName = String.Empty;
+			//currentDocument = null;
+			
+			return true;
+		}
+		
+		static void FinishSearchInFiles()
+		{
+			TaskService taskService = (TaskService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(TaskService));
+			taskService.NotifyTaskChange();
+			
+			OpenTaskView taskView = WorkbenchSingleton.Workbench.GetPad(typeof(OpenTaskView)) as OpenTaskView;
+			if (taskView != null) taskView.BringToFront();
+		}
+		
+		public static void ReplaceAll()
+		{
+			if (!InitializeSearchInFiles()) {
+				return;
+			}
+			
+			while (true) {
+				ISearchResult result = find.FindNext(searchOptions);
+				if (result == null) {
+					break;
+				}
+				
+				find.Replace(result.Offset, 
+				             result.Length, 
+				             result.TransformReplacePattern(SearchOptions.ReplacePattern));
+				
+				DisplaySearchResult(result);
+			}
+			
+			FinishSearchInFiles();
+		}
+		
+		public static void FindAll()
+		{
+			if (!InitializeSearchInFiles()) {
+				return;
+			}
+			
+			while (true) {
+				ISearchResult result = find.FindNext(searchOptions);
+				if (result == null) {
+					break;
+				}
+				
+				DisplaySearchResult(result);
+			}
+			
+			FinishSearchInFiles();
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceManager.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceManager.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceManager.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,200 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+
+using ICSharpCode.SharpDevelop.Gui;
+
+using ICSharpCode.Core.Services;
+using ICSharpCode.SharpDevelop.Services;
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public enum DocumentIteratorType {
+		None,
+		CurrentDocument,
+		AllOpenFiles,
+		WholeCombine,
+		Directory // only used for search in files
+	}
+	
+	public enum SearchStrategyType {
+		None,
+		Normal,
+		RegEx,
+		Wildcard
+	}
+	
+	public class SearchReplaceManager
+	{
+		public static ReplaceDialog ReplaceDialog     = null;
+				
+		static IFind find                  = new DefaultFind();
+		static SearchOptions searchOptions = new SearchOptions(&quot;SharpDevelop.SearchAndReplace.SearchAndReplaceProperties&quot;);
+
+		
+		public static SearchOptions SearchOptions {
+			get {
+				return searchOptions;
+			}
+		}
+		
+		static SearchReplaceManager()
+		{
+			find.TextIteratorBuilder = new ForwardTextIteratorBuilder();
+			searchOptions.SearchStrategyTypeChanged   += new EventHandler(InitializeSearchStrategy);
+			searchOptions.DocumentIteratorTypeChanged += new EventHandler(InitializeDocumentIterator);
+			InitializeDocumentIterator(null, null);
+			InitializeSearchStrategy(null, null);
+		}	
+		
+		static void InitializeSearchStrategy(object sender, EventArgs e)
+		{
+			find.SearchStrategy = SearchReplaceUtilities.CreateSearchStrategy(SearchOptions.SearchStrategyType);
+		}
+		
+		static void InitializeDocumentIterator(object sender, EventArgs e)
+		{
+			find.DocumentIterator = SearchReplaceUtilities.CreateDocumentIterator(SearchOptions.DocumentIteratorType);
+		}
+		
+		// TODO: Transform Replace Pattern
+		public static void Replace()
+		{
+			if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null) {
+				/*TextEditorControl textarea = ((ITextEditorControlProvider)WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent).TextEditorControl;
+				string text = textarea.ActiveTextAreaControl.TextArea.SelectionManager.SelectedText;
+				if (text == SearchOptions.SearchPattern) {
+					int offset = textarea.ActiveTextAreaControl.TextArea.SelectionManager.SelectionCollection[0].Offset;
+					
+					textarea.BeginUpdate();
+					textarea.ActiveTextAreaControl.TextArea.SelectionManager.RemoveSelectedText();
+					textarea.Document.Insert(offset, SearchOptions.ReplacePattern);
+					textarea.ActiveTextAreaControl.Caret.Position = textarea.Document.OffsetToPosition(offset +  SearchOptions.ReplacePattern.Length);
+					textarea.EndUpdate();
+				}*/
+			}
+			FindNext();
+		}
+		
+		public static void MarkAll()
+		{
+			//TextEditorControl textArea = null;
+			/*if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null) {
+				textArea = ((ITextEditorControlProvider)WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent).TextEditorControl;
+				textArea.ActiveTextAreaControl.TextArea.SelectionManager.ClearSelection();
+			}*/
+			find.Reset();
+			find.SearchStrategy.CompilePattern(searchOptions);
+			while (true) {
+				ISearchResult result = SearchReplaceManager.find.FindNext(searchOptions);
+				
+				if (result == null) {
+					//MessageBox.Show((Form)WorkbenchSingleton.Workbench, &quot;Mark all done&quot;, &quot;Finished&quot;);
+					find.Reset();
+					return;
+				} else {
+					/*textArea = OpenTextArea(result.FileName); 
+					
+					textArea.ActiveTextAreaControl.Caret.Position = textArea.Document.OffsetToPosition(result.Offset);
+					int lineNr = textArea.Document.GetLineNumberForOffset(result.Offset);
+					
+					if (!textArea.Document.BookmarkManager.IsMarked(lineNr)) {
+						textArea.Document.BookmarkManager.ToggleMarkAt(lineNr);
+					}*/
+				}
+			}
+		}
+		
+		public static void ReplaceAll()
+		{
+			//TextEditorControl textArea = null;
+			/*if (WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null) {
+				textArea = ((ITextEditorControlProvider)WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent).TextEditorControl;
+				textArea.ActiveTextAreaControl.TextArea.SelectionManager.ClearSelection();
+			}*/
+			find.Reset();
+			find.SearchStrategy.CompilePattern(searchOptions);
+			
+			while (true) {
+				ISearchResult result = SearchReplaceManager.find.FindNext(SearchReplaceManager.searchOptions);
+				
+				if (result == null) {
+					//MessageBox.Show((Form)WorkbenchSingleton.Workbench, &quot;Replace all done&quot;, &quot;Finished&quot;);
+					find.Reset();
+					return;
+				} else {
+					/*textArea = OpenTextArea(result.FileName); 
+					
+					textArea.BeginUpdate();
+					textArea.ActiveTextAreaControl.TextArea.SelectionManager.SelectionCollection.Clear();
+					
+					string transformedPattern = result.TransformReplacePattern(SearchOptions.ReplacePattern);
+					find.Replace(result.Offset,
+					             result.Length, 
+					             transformedPattern);
+					textArea.EndUpdate();
+					textArea.Refresh();*/
+				}
+			}
+		}
+		
+		static ISearchResult lastResult = null;
+		public static void FindNext()
+		{
+			if (find == null || 
+			    searchOptions.SearchPattern == null || 
+			    searchOptions.SearchPattern.Length == 0) {
+				return;
+			}
+			
+			find.SearchStrategy.CompilePattern(searchOptions);
+			ISearchResult result = find.FindNext(searchOptions);
+				
+			if (result == null) {
+				ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+				/*MessageBox.Show((Form)WorkbenchSingleton.Workbench,
+				                resourceService.GetString(&quot;Dialog.NewProject.SearchReplace.SearchStringNotFound&quot;),
+				                &quot;Not Found&quot;, 
+				                MessageBoxButtons.OK, 
+				                MessageBoxIcon.Information);*/
+				find.Reset();
+			} else {
+				/*TextEditorControl textArea = OpenTextArea(result.FileName);
+				
+				if (lastResult != null  &amp;&amp; lastResult.FileName == result.FileName &amp;&amp; 
+				    textArea.ActiveTextAreaControl.Caret.Offset != lastResult.Offset + lastResult.Length) {
+					find.Reset();
+				}
+				int startPos = Math.Min(textArea.Document.TextLength, Math.Max(0, result.Offset));
+				int endPos   = Math.Min(textArea.Document.TextLength, startPos + result.Length);
+				
+				textArea.ActiveTextAreaControl.Caret.Position = textArea.Document.OffsetToPosition(endPos);
+				textArea.ActiveTextAreaControl.TextArea.SelectionManager.ClearSelection();
+				textArea.ActiveTextAreaControl.TextArea.SelectionManager.SetSelection(new DefaultSelection(textArea.Document, textArea.Document.OffsetToPosition(startPos),
+				                                                                                           textArea.Document.OffsetToPosition(endPos)));
+				textArea.Refresh();*/
+			}
+			
+			lastResult = result;
+		}
+		
+		/*static TextEditorControl OpenTextArea(string fileName) 
+		{
+			if (fileName != null) {
+				IFileService fileService = (IFileService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
+				fileService.OpenFile(fileName);
+			}
+			
+			return ((ITextEditorControlProvider)WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent).TextEditorControl;
+		}*/
+	}	
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceUtilities.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceUtilities.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchReplaceUtilities.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,81 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public sealed class SearchReplaceUtilities
+	{
+		public static bool IsTextAreaSelected {
+			get {
+				/*
+				return WorkbenchSingleton.Workbench.ActiveWorkbenchWindow != null &amp;&amp;
+					   WorkbenchSingleton.Workbench.ActiveWorkbenchWindow.ViewContent is ITextEditorControlProvider;
+				*/
+				return false;
+			}
+		}
+		
+		
+		public static bool IsWholeWordAt(ITextBufferStrategy document, int offset, int length)
+		{
+			return (offset - 1 &lt; 0 || Char.IsWhiteSpace(document.GetCharAt(offset - 1))) &amp;&amp;
+			       (offset + length + 1 &gt;= document.Length || Char.IsWhiteSpace(document.GetCharAt(offset + length)));
+		}
+
+		/*public static int CalcCurrentOffset(IDocument document) 
+		{
+//			TODO:
+//			int endOffset = document.Caret.Offset % document.TextLength;
+//			return endOffset;
+			return 0;
+		}*/
+		
+		public static ISearchStrategy CreateSearchStrategy(SearchStrategyType type)
+		{
+			switch (type) {
+				case SearchStrategyType.None:
+					return null;
+				case SearchStrategyType.Normal:
+					return new BruteForceSearchStrategy(); // new KMPSearchStrategy();
+				case SearchStrategyType.RegEx:
+					return new RegExSearchStrategy();
+				case SearchStrategyType.Wildcard:
+					return new WildcardSearchStrategy();
+				default:
+					throw new System.NotImplementedException(&quot;CreateSearchStrategy for type &quot; + type);
+			}
+		}
+		
+		
+		public static IDocumentIterator CreateDocumentIterator(DocumentIteratorType type)
+		{
+			switch (type) {
+				case DocumentIteratorType.None:
+					return null;
+				case DocumentIteratorType.CurrentDocument:
+					return new CurrentDocumentIterator();
+				case DocumentIteratorType.Directory:
+					return new DirectoryDocumentIterator(SearchReplaceInFilesManager.SearchOptions.SearchDirectory, 
+					                                     SearchReplaceInFilesManager.SearchOptions.FileMask, 
+					                                     SearchReplaceInFilesManager.SearchOptions.SearchSubdirectories);
+				case DocumentIteratorType.AllOpenFiles:
+					return new AllOpenDocumentIterator();
+				case DocumentIteratorType.WholeCombine:
+					return new WholeProjectDocumentIterator();
+				default:
+					throw new System.NotImplementedException(&quot;CreateDocumentIterator for type &quot; + type);
+			}
+		}
+	}
+	
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/DefaultSearchResult.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/DefaultSearchResult.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/DefaultSearchResult.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,71 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Undo;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class DefaultSearchResult : ISearchResult
+	{
+		ProvidedDocumentInformation providedDocumentInformation;
+		int    offset;
+		int    length;
+		
+		public string FileName {
+			get {
+				return providedDocumentInformation.FileName;
+			}
+		}
+		
+		public ProvidedDocumentInformation ProvidedDocumentInformation {
+			set {
+				providedDocumentInformation = value;
+			}
+		}
+		
+		public int Offset {
+			get {
+				return offset;
+			}
+		}
+		
+		public int Length {
+			get {
+				return length;
+			}
+		}
+		
+		public virtual string TransformReplacePattern(string pattern)
+		{
+			return pattern;
+		}
+		
+		/*public IDocument CreateDocument()
+		{
+			return providedDocumentInformation.CreateDocument();
+		}*/
+		
+		public DefaultSearchResult(int offset, int length)
+		{
+			this.offset   = offset;
+			this.length   = length;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[DefaultLocation: FileName={0}, Offset={1}, Length={2}]&quot;,
+			                     FileName,
+			                     Offset,
+			                     Length);
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/ISearchResult.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/ISearchResult.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchResult/ISearchResult.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,66 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Undo;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// This interface describes the result a search strategy must
+	/// return with a call to find next.
+	/// &lt;/summary&gt;
+	public interface ISearchResult
+	{
+		/// &lt;value&gt;
+		/// Returns the file name of the search result. This
+		/// value is null till the ProvidedDocumentInformation 
+		/// property is set.
+		/// &lt;/value&gt;
+		string FileName {
+			get;
+		}
+		
+		/// &lt;value&gt;
+		/// This property is set by the find object and need not to be
+		/// set by the search strategies. All search results that are returned
+		/// by the find object do have a ProvidedDocumentInformation.
+		/// &lt;/value&gt;
+		ProvidedDocumentInformation ProvidedDocumentInformation {
+			set;
+		}
+		
+		/// &lt;value&gt;
+		/// The offset of the pattern match
+		/// &lt;/value&gt;
+		int Offset {
+			get;
+		}
+		
+		/// &lt;value&gt;
+		/// The length of the pattern match.
+		/// &lt;/value&gt;
+		int Length {
+			get;
+		}
+		
+		/// &lt;remarks&gt;
+		/// This method creates a document for the file FileName. This method works
+		/// only after the ProvidedDocumentInformation is set.
+		/// &lt;/remarks&gt;
+		
+		/// &lt;remarks&gt;
+		/// Replace operations must transform the replace pattern with this
+		/// method.
+		/// &lt;/remarks&gt;
+		string TransformReplacePattern(string pattern);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/BruteForceSearchStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/BruteForceSearchStrategy.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/BruteForceSearchStrategy.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,72 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Undo;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	///  Only for fallback purposes.
+	/// &lt;/summary&gt;
+	public class BruteForceSearchStrategy : ISearchStrategy
+	{
+		string searchPattern;
+		
+		bool MatchCaseSensitive(ITextBufferStrategy document, int offset, string pattern)
+		{
+			for (int i = 0; i &lt; pattern.Length; ++i) {
+				if (offset + i &gt;= document.Length || document.GetCharAt(offset + i) != pattern[i]) {
+					return false;
+				}
+			}
+			return true;
+		}
+		
+		bool MatchCaseInsensitive(ITextBufferStrategy document, int offset, string pattern)
+		{
+			for (int i = 0; i &lt; pattern.Length; ++i) {
+				if (offset + i &gt;= document.Length || Char.ToUpper(document.GetCharAt(offset + i)) != pattern[i]) {
+					return false;
+				}
+			}
+			return true;
+		}
+		
+		bool IsWholeWordAt(ITextBufferStrategy document, int offset, int length)
+		{
+			return (offset - 1 &lt; 0 || Char.IsWhiteSpace(document.GetCharAt(offset - 1))) &amp;&amp;
+			       (offset + length + 1 &gt;= document.Length || Char.IsWhiteSpace(document.GetCharAt(offset + length)));
+		}
+		
+		int InternalFindNext(ITextIterator textIterator, SearchOptions options)
+		{
+			while (textIterator.MoveAhead(1)) {
+				if (options.IgnoreCase ? MatchCaseInsensitive(textIterator.TextBuffer, textIterator.Position, searchPattern) :
+				                         MatchCaseSensitive(textIterator.TextBuffer, textIterator.Position, searchPattern)) {
+					if (!options.SearchWholeWordOnly || IsWholeWordAt(textIterator.TextBuffer, textIterator.Position, searchPattern.Length)) {
+						return textIterator.Position;
+					}
+				}
+			}
+			return -1;
+		}
+		
+		public void CompilePattern(SearchOptions options)
+		{
+			searchPattern = options.IgnoreCase ? options.SearchPattern.ToUpper() : options.SearchPattern;
+		}
+		
+		public ISearchResult FindNext(ITextIterator textIterator, SearchOptions options)
+		{
+			int offset = InternalFindNext(textIterator, options);
+			return offset &gt;= 0 ? new DefaultSearchResult(offset, searchPattern.Length) : null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/ISearchStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/ISearchStrategy.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/ISearchStrategy.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,35 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Undo;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// This interface is the basic interface which all 
+	/// search algorithms must implement.
+	/// &lt;/summary&gt;
+	public interface ISearchStrategy
+	{
+		/// &lt;remarks&gt;
+		/// Only with a call to this method the search strategy must
+		/// update their pattern information. This method will be called 
+		/// before the FindNext function.
+		/// &lt;/remarks&gt;
+		void CompilePattern(SearchOptions options);
+		
+		/// &lt;remarks&gt;
+		/// The find next method should search the next occurrence of the 
+		/// compiled pattern in the text using the textIterator and options.
+		/// &lt;/remarks&gt;
+		ISearchResult FindNext(ITextIterator textIterator, SearchOptions options);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/KMPSearchStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/KMPSearchStrategy.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/KMPSearchStrategy.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,78 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// Implements the Knuth, Morris, Pratt searching algorithm.
+	/// &lt;/summary&gt;
+	public class KMPSearchStrategy : ISearchStrategy
+	{
+		string searchPattern;
+		int[]  overlap;
+		
+		public void CompilePattern(SearchOptions options)
+		{
+			if (searchPattern != (options.IgnoreCase ? options.SearchPattern.ToUpper() : options.SearchPattern)) {
+				searchPattern = options.IgnoreCase ? options.SearchPattern.ToUpper() : options.SearchPattern;
+				overlap = new int[searchPattern.Length + 1];
+				Preprocessing();
+			}
+		}
+		
+		void Preprocessing()
+		{
+			overlap[0] = -1;
+			for (int i = 0, j = -1; i &lt; searchPattern.Length;) {
+				while (j &gt;= 0 &amp;&amp; searchPattern[i] != searchPattern[j]) {
+					j = overlap[j];
+				}
+				++i;
+				++j;
+				overlap[i] = j;
+			}
+		}
+		
+		int InternalFindNext(ITextIterator textIterator, SearchOptions options)
+		{
+			int j = 0;
+			if (!textIterator.MoveAhead(1)) {
+				return -1;
+			}
+			while (true) { // until pattern found or Iterator finished
+				while (j &gt;= 0 &amp;&amp; searchPattern[j] != (options.IgnoreCase ? Char.ToUpper(textIterator.GetCharRelative(j)) : textIterator.GetCharRelative(j))) {
+					if (!textIterator.MoveAhead(j - overlap[j])) {
+						return -1;
+					}
+					j = overlap[j];
+				}
+				if (++j &gt;= searchPattern.Length) {
+					if ((!options.SearchWholeWordOnly || SearchReplaceUtilities.IsWholeWordAt(textIterator.TextBuffer, textIterator.Position, searchPattern.Length))) {
+						return textIterator.Position;
+					}
+					if (!textIterator.MoveAhead(j - overlap[j])) {
+						return -1;
+					}
+					j = overlap[j];
+				}
+			}			
+		}
+		
+		public ISearchResult FindNext(ITextIterator textIterator, SearchOptions options)
+		{
+			int offset = InternalFindNext(textIterator, options);
+			
+			if (offset + searchPattern.Length &gt;= textIterator.TextBuffer.Length) {
+				return FindNext(textIterator, options);
+			}
+			
+			return offset &gt;= 0 ? new DefaultSearchResult(offset, searchPattern.Length) : null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/RegExSearchStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/RegExSearchStrategy.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/RegExSearchStrategy.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,50 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Text.RegularExpressions;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Undo;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class RegExSearchStrategy : ISearchStrategy
+	{
+		Regex regex = null;
+		
+		public void CompilePattern(SearchOptions options)
+		{
+			RegexOptions regexOptions = RegexOptions.Compiled;
+			if (options.IgnoreCase) {
+				regexOptions |= RegexOptions.IgnoreCase;
+			}
+			regex = new Regex(options.SearchPattern, regexOptions);
+		}
+		
+		public ISearchResult FindNext(ITextIterator textIterator, SearchOptions options)
+		{
+			string document = textIterator.TextBuffer.GetText(0, textIterator.TextBuffer.Length);
+			
+			while (textIterator.MoveAhead(1)) {
+				Match m = regex.Match(document, textIterator.Position);
+				if (m == null || m.Index &lt;= 0 || m.Length &lt;= 0) {
+					
+				} else {
+					int delta = m.Index - textIterator.Position;
+					if (delta &lt;= 0 || textIterator.MoveAhead(delta)) {
+						return new DefaultSearchResult(m.Index, m.Length);
+					} else {
+						return null;
+					}
+				}
+			}
+			
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/WildcardSearchStrategy.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/WildcardSearchStrategy.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/SearchStrategy/WildcardSearchStrategy.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,157 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.SharpDevelop.Internal.Undo;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// Implements a wildcard search strategy.
+	/// 
+	/// Wildcard search has following pattern code :
+	///      * = Zero or more of any character
+	///      ? = Any single character
+	///      # = Any single digit
+	///  [...] = Any one character in the set
+	/// [!...] = Any one character not in the set
+	/// &lt;/summary&gt;
+	public class WildcardSearchStrategy : ISearchStrategy
+	{
+		enum CommandType {
+			Match,
+			AnyZeroOrMore,
+			AnySingle,
+			AnyDigit,
+			AnyInList,
+			NoneInList
+		}
+		
+		class Command {
+			public CommandType CommandType = CommandType.Match;
+			public char        SingleChar  = '\0';
+			public string      CharList    = String.Empty;
+		}
+		
+		ArrayList patternProgram = null;
+		int       curMatchEndOffset = -1;
+		
+		void CompilePattern(string pattern, bool ignoreCase)
+		{
+			patternProgram = new ArrayList();
+			for (int i = 0; i &lt; pattern.Length; ++i) {
+				Command newCommand = new Command();
+				switch (pattern[i]) {
+					case '#':
+						newCommand.CommandType = CommandType.AnyDigit;
+						break;
+					case '*':
+						newCommand.CommandType = CommandType.AnyZeroOrMore;
+						break;
+					case '?':
+						newCommand.CommandType = CommandType.AnySingle;
+						break;
+					case '[':
+						int index = pattern.IndexOf(']', i);
+						if (index &gt; 0) {
+							newCommand.CommandType = CommandType.AnyInList;
+							string list = pattern.Substring(i + 1, index - i - 1);
+							if (list[0] == '!') {
+								newCommand.CommandType = CommandType.NoneInList;
+								list = list.Substring(1);
+							}
+							newCommand.CharList = ignoreCase ? list.ToUpper() : list;
+							i = index;
+						} else {
+							goto default;
+						}
+						break;
+					default:
+						newCommand.CommandType = CommandType.Match;
+						newCommand.SingleChar  = ignoreCase ? Char.ToUpper(pattern[i]) : pattern[i];
+						break;
+				}
+				patternProgram.Add(newCommand);
+			}
+		}
+		
+		bool Match(ITextBufferStrategy document, 
+		           int  offset, 
+		           bool ignoreCase,
+		           int  programStart)
+		{
+			int curOffset = offset;
+			curMatchEndOffset = -1;
+			
+			for (int pc = programStart; pc &lt; patternProgram.Count; ++pc) {
+				if (curOffset &gt;= document.Length) {
+					return false;
+				}
+				
+				char    ch  = ignoreCase ? Char.ToUpper(document.GetCharAt(curOffset)) : document.GetCharAt(curOffset);
+				Command cmd = (Command)patternProgram[pc];
+				
+				switch (cmd.CommandType) {
+					case CommandType.Match:
+						if (ch != cmd.SingleChar) {
+							return false;
+						}
+						break;
+					case CommandType.AnyZeroOrMore:
+						return Match(document, curOffset, ignoreCase, pc + 1) ||
+						       Match(document, curOffset + 1, ignoreCase, pc);
+					case CommandType.AnySingle:
+						break;
+					case CommandType.AnyDigit:
+						if (!Char.IsDigit(ch)) {
+							return false;
+						}
+						break;
+					case CommandType.AnyInList:
+						if (cmd.CharList.IndexOf(ch) &lt; 0) {
+							return false;
+						}
+						break;
+					case CommandType.NoneInList:
+						if (cmd.CharList.IndexOf(ch) &gt;= 0) {
+							return false;
+						}
+						break;
+				}
+				++curOffset;
+			}
+			curMatchEndOffset = curOffset;
+			return true;
+		}
+		
+		int InternalFindNext(ITextIterator textIterator, SearchOptions options)
+		{
+			while (textIterator.MoveAhead(1)) {
+				if (Match(textIterator.TextBuffer, textIterator.Position, options.IgnoreCase, 0)) {
+					if (!options.SearchWholeWordOnly || SearchReplaceUtilities.IsWholeWordAt(textIterator.TextBuffer, textIterator.Position, curMatchEndOffset - textIterator.Position)) {
+						return textIterator.Position;
+					}
+				}
+			}
+			return -1;
+		}
+		
+		public void CompilePattern(SearchOptions options)
+		{
+			CompilePattern(options.SearchPattern, options.IgnoreCase);
+		}
+		
+		public ISearchResult FindNext(ITextIterator textIterator, SearchOptions options)
+		{
+			int offset = InternalFindNext(textIterator, options);
+			return offset &gt;= 0 ? new DefaultSearchResult(offset, curMatchEndOffset - offset) : null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextIterator.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextIterator.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextIterator.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,133 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Diagnostics;
+using System.Collections;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class ForwardTextIterator : ITextIterator
+	{
+		enum TextIteratorState {
+			Resetted,
+			Iterating,
+			Done,
+		}
+		
+		TextIteratorState state;
+		
+		ITextBufferStrategy textBuffer;
+		int                 currentOffset;
+		int                 endOffset;
+		int                 oldOffset = -1;
+		
+		public ITextBufferStrategy TextBuffer {
+			get {
+				return textBuffer;
+			}
+		}
+		
+		public char Current {
+			get {
+				switch (state) {
+					case TextIteratorState.Resetted:
+						throw new System.InvalidOperationException(&quot;Call moveAhead first&quot;);
+					case TextIteratorState.Iterating:
+						return textBuffer.GetCharAt(currentOffset);
+					case TextIteratorState.Done:
+						throw new System.InvalidOperationException(&quot;TextIterator is at the end&quot;);
+					default:
+						throw new System.InvalidOperationException(&quot;unknown text iterator state&quot;);
+				}
+			}
+		}
+		
+		public int Position {
+			get {
+				return currentOffset;
+			}
+			set {
+				currentOffset = value;
+			}
+		}
+		
+		
+		public ForwardTextIterator(ITextBufferStrategy textBuffer, int endOffset)
+		{
+			Debug.Assert(textBuffer != null);
+			Debug.Assert(endOffset &gt;= 0 &amp;&amp; endOffset &lt; textBuffer.Length);
+			
+			this.textBuffer = textBuffer;
+			this.endOffset  = endOffset;
+			Reset();
+		}
+		
+		public char GetCharRelative(int offset)
+		{
+			if (state != TextIteratorState.Iterating) {
+				throw new System.InvalidOperationException();
+			}
+			
+			int realOffset = (currentOffset + (1 + Math.Abs(offset) / textBuffer.Length) * textBuffer.Length + offset) % textBuffer.Length;
+			return textBuffer.GetCharAt(realOffset);
+		}
+		
+		public bool MoveAhead(int numChars)
+		{
+			Debug.Assert(numChars &gt; 0);
+			
+			switch (state) {
+				case TextIteratorState.Resetted:
+					currentOffset = endOffset;
+					state = TextIteratorState.Iterating;
+					return true;
+				case TextIteratorState.Done:
+					return false;
+				case TextIteratorState.Iterating:
+					currentOffset = (currentOffset + numChars) % textBuffer.Length;
+					bool finish = oldOffset != -1 &amp;&amp; (oldOffset &gt; currentOffset || oldOffset &lt; endOffset) &amp;&amp; currentOffset &gt;= endOffset;
+					
+					oldOffset = currentOffset;
+					if (finish) {
+						state = TextIteratorState.Done;
+						return false;
+					}
+					return true;
+				default:
+					throw new Exception(&quot;Unknown text iterator state&quot;);
+			}
+		}
+		
+		public void InformReplace(int offset, int length, int newLength)
+		{
+			if (offset &lt;= endOffset) {
+				endOffset = endOffset - length + newLength;
+			}
+			
+			if (offset &lt;= currentOffset) {
+				currentOffset = currentOffset - length + newLength;
+			}
+			
+			if (offset &lt;= oldOffset) {
+				oldOffset = oldOffset - length + newLength;
+			}
+		}
+
+		public void Reset()
+		{
+			state         = TextIteratorState.Resetted;
+			currentOffset = endOffset;
+			oldOffset     = -1;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ForwardTextIterator: currentOffset={0}, endOffset={1}, state={2}]&quot;, currentOffset, endOffset, state);
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextIteratorBuilder.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextIteratorBuilder.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ForwardTextIteratorBuilder.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,22 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Diagnostics;
+using System.Collections;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	public class ForwardTextIteratorBuilder : ITextIteratorBuilder
+	{
+		public ITextIterator BuildTextIterator(ProvidedDocumentInformation info)
+		{
+			Debug.Assert(info != null);
+			return new ForwardTextIterator(info.TextBuffer, info.EndOffset);
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ITextIterator.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ITextIterator.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ITextIterator.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,72 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// This iterator iterates on a text buffer strategy.
+	/// &lt;/summary&gt;
+	public interface ITextIterator
+	{
+		/// &lt;value&gt;
+		/// The text buffer strategy
+		/// &lt;/value&gt;
+		ITextBufferStrategy TextBuffer {
+			get;
+		}
+		
+		/// &lt;value&gt;
+		/// Gets the current char this is the same as 
+		/// GetCharRelative(0)
+		/// &lt;/value&gt;
+		/// &lt;exception cref=&quot;System.InvalidOperationException&quot;&gt;
+		/// If this method is called before the first MoveAhead or after 
+		/// MoveAhead or after MoveAhead returns false.
+		/// &lt;/exception&gt;
+		char Current {
+			get;
+		}
+		
+		/// &lt;value&gt;
+		/// The current position=offset of the text iterator cursor
+		/// &lt;/value&gt;
+		int Position {
+			get;
+			set;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Gets a char relative to the current position (negative values
+		/// will work too).
+		/// &lt;/remarks&gt;
+		/// &lt;exception cref=&quot;System.InvalidOperationException&quot;&gt;
+		/// If this method is called before the first MoveAhead or after 
+		/// MoveAhead or after MoveAhead returns false.
+		/// &lt;/exception&gt;
+		char GetCharRelative(int offset);
+		
+		/// &lt;remarks&gt;
+		/// Moves the iterator position numChars
+		/// &lt;/remarks&gt;
+		bool MoveAhead(int numChars);
+		
+		/// &lt;remarks&gt;
+		/// Rests the iterator
+		/// &lt;/remarks&gt;
+		void Reset();
+		
+		/// &lt;remarks&gt;
+		/// The find object calls the InformReplace method to inform the text iterator
+		/// about the replace operation on the TextBuffer. The text iterator must update
+		/// all internal offsets to the new offsets (if neccessary)
+		/// &lt;/remarks&gt;
+		void InformReplace(int offset, int length, int newLength);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ITextIteratorBuilder.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ITextIteratorBuilder.cs	2004-02-19 02:32:39 UTC (rev 941)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Search/TextIterator/ITextIteratorBuilder.cs	2004-02-19 03:42:53 UTC (rev 942)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.TextEditor.Document
+{
+	/// &lt;summary&gt;
+	/// Builds a text iterator object.
+	/// &lt;/summary&gt;
+	public interface ITextIteratorBuilder
+	{
+		ITextIterator BuildTextIterator(ProvidedDocumentInformation info);
+	}
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000546.html">[Monodevelop-patches-list] r941 - in trunk/MonoDevelop: data/resources/glade src/Main/Base/Gui/Dialogs/OptionPanels/ProjectOptions
</A></li>
	<LI>Next message: <A HREF="000548.html">[Monodevelop-patches-list] r943 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: Commands Gui Search Search/DocumentIterator Search/SearchStrategy Search/TextIterator
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#547">[ date ]</a>
              <a href="thread.html#547">[ thread ]</a>
              <a href="subject.html#547">[ subject ]</a>
              <a href="author.html#547">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
