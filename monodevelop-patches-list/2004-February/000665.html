<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1060 - in branches/MonoDevelop-playground: . src/Plugins src/Plugins/FileBrowser src/Plugins/Services
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1060%20-%20in%20branches/MonoDevelop-playground%3A%20.%20src/Plugins%20src/Plugins/FileBrowser%20src/Plugins/Services&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000664.html">
   <LINK REL="Next"  HREF="000666.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1060 - in branches/MonoDevelop-playground: . src/Plugins src/Plugins/FileBrowser src/Plugins/Services</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1060%20-%20in%20branches/MonoDevelop-playground%3A%20.%20src/Plugins%20src/Plugins/FileBrowser%20src/Plugins/Services&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1060 - in branches/MonoDevelop-playground: . src/Plugins src/Plugins/FileBrowser src/Plugins/Services">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sun Feb 29 04:47:46 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000664.html">[Monodevelop-patches-list] r1059 - trunk/MonoDevelop/gdldock/sources/gdl
</A></li>
        <LI>Next message: <A HREF="000666.html">[Monodevelop-patches-list] r1061 - in branches/MonoDevelop-playground: . gdldock/sources/gdl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#665">[ date ]</a>
              <a href="thread.html#665">[ thread ]</a>
              <a href="subject.html#665">[ subject ]</a>
              <a href="author.html#665">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jzwart
Date: 2004-02-29 04:47:46 -0500 (Sun, 29 Feb 2004)
New Revision: 1060

Added:
   branches/MonoDevelop-playground/src/Plugins/FileBrowser/
   branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowser.cs
   branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowserPlugin.cs
   branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowserWidgetFactory.cs
   branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileIconLoader.cs
   branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileScout.cs
   branches/MonoDevelop-playground/src/Plugins/FileBrowser/Makefile.am
   branches/MonoDevelop-playground/src/Plugins/FileBrowser/filebrowser.plugin.in
   branches/MonoDevelop-playground/src/Plugins/Services/
   branches/MonoDevelop-playground/src/Plugins/Services/AbstractService.cs
   branches/MonoDevelop-playground/src/Plugins/Services/DefaultProperties.cs
   branches/MonoDevelop-playground/src/Plugins/Services/FileUtilityService.cs
   branches/MonoDevelop-playground/src/Plugins/Services/IMessageService.cs
   branches/MonoDevelop-playground/src/Plugins/Services/IProperties.cs
   branches/MonoDevelop-playground/src/Plugins/Services/IResourceService.cs
   branches/MonoDevelop-playground/src/Plugins/Services/IService.cs
   branches/MonoDevelop-playground/src/Plugins/Services/IStringTagProvider.cs
   branches/MonoDevelop-playground/src/Plugins/Services/IXmlConvertable.cs
   branches/MonoDevelop-playground/src/Plugins/Services/Makefile.am
   branches/MonoDevelop-playground/src/Plugins/Services/PropertyEventArgs.cs
   branches/MonoDevelop-playground/src/Plugins/Services/PropertyFileLoadException.cs
   branches/MonoDevelop-playground/src/Plugins/Services/PropertyService.cs
   branches/MonoDevelop-playground/src/Plugins/Services/ResourceNotFoundException.cs
   branches/MonoDevelop-playground/src/Plugins/Services/ResourceService.cs
   branches/MonoDevelop-playground/src/Plugins/Services/ServiceManager.cs
   branches/MonoDevelop-playground/src/Plugins/Services/ServicesPlugin.cs
   branches/MonoDevelop-playground/src/Plugins/Services/StringParserService.cs
   branches/MonoDevelop-playground/src/Plugins/Services/UnknownPropertyNodeException.cs
   branches/MonoDevelop-playground/src/Plugins/Services/services.plugin.in
Modified:
   branches/MonoDevelop-playground/configure.in
   branches/MonoDevelop-playground/src/Plugins/Makefile.am
Log:
Make the FileBrowser work again. Refactored most of the services into
src/Plugins/Services. Expect a rewrite of some portions eventually.


Modified: branches/MonoDevelop-playground/configure.in
===================================================================
--- branches/MonoDevelop-playground/configure.in	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/configure.in	2004-02-29 09:47:46 UTC (rev 1060)
@@ -88,7 +88,9 @@
 src/Makefile
 src/StartUp/Makefile
 src/Plugins/Makefile
+src/Plugins/Services/Makefile
 src/Plugins/Workbench/Makefile
+src/Plugins/FileBrowser/Makefile
 monodevelop
 ])
 


Property changes on: branches/MonoDevelop-playground/src/Plugins/FileBrowser
___________________________________________________________________
Name: svn:ignore
   + Makefile
Makefile.in
filebrowser.plugin
filebrowser.dll


Added: branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowser.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowser.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowser.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,155 @@
+//
+// Author: John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jluke at cfl.rr.com</A>&gt;
+// License: LGPL
+//
+
+using System;
+using System.IO;
+using Gtk;
+using GtkSharp;
+
+using MonoDevelop.Services;
+
+namespace MonoDevelop.FileBrowser
+{
+	public class FileBrowser : ScrolledWindow
+	{
+		private static GLib.GType gtype;
+		private Gtk.TreeView tv;
+		private ListStore store;
+		private string currentDir;
+		private bool ignoreHidden = true;
+		private string[] files;
+		private bool init = false;
+		PropertyService PropertyService = (PropertyService) ServiceManager.Services.GetService (typeof (PropertyService));
+
+		public FileBrowser () : base (GType)
+		{
+			this.VscrollbarPolicy = PolicyType.Automatic;
+			this.HscrollbarPolicy = PolicyType.Automatic;
+
+			IProperties p = (IProperties) PropertyService.GetProperty (&quot;SharpDevelop.UI.SelectStyleOptions&quot;, new DefaultProperties ());
+			ignoreHidden = !p.GetProperty (&quot;ICSharpCode.SharpDevelop.Gui.FileScout.ShowHidden&quot;, false);
+
+			tv = new Gtk.TreeView ();
+			tv.RulesHint = true;
+			tv.AppendColumn (&quot;Directories&quot;, new CellRendererText (), &quot;text&quot;, 0);
+			store = new ListStore (typeof (string));
+			currentDir = Environment.GetEnvironmentVariable (&quot;HOME&quot;);
+			Populate ();
+			tv.Model = store;
+
+			tv.RowActivated += new RowActivatedHandler (OnRowActivated);
+			tv.Selection.Changed += new EventHandler (OnSelectionChanged);
+
+			this.Add (tv);
+			this.ShowAll ();
+			init = true;
+		}
+
+		// jba 23 feb 04 - reneabled this property to make the file browser obey the
+		// ignoreHidden property from the visual style option panel
+		public bool IgnoreHidden
+		{
+			get { return ignoreHidden; }
+			set {
+				/* for some reasont his code crashes (NullReferenceException on the Populate() call
+				if (ignoreHidden != value) {
+					ignoreHidden = value; 
+					// redraw folder list
+					System.Console.WriteLine(&quot;before poplate call&quot;);
+					Populate ();
+				}
+				*/
+				
+				ignoreHidden = value;
+			}
+		}
+
+		public Gtk.TreeView TreeView
+		{
+			get { return tv; }
+		}
+
+		public string CurrentDir
+		{
+			get { return System.IO.Path.GetFullPath (currentDir); }
+			set { currentDir = value;
+				  Populate (); }
+		}
+
+		public string[] Files
+		{
+			get {
+				if (files == null) {
+					return new string [0];
+				}
+				return files; 
+			}
+		}
+
+		public static new GLib.GType GType
+		{
+			get
+			{
+				if (gtype == GLib.GType.Invalid)
+					gtype = RegisterGType (typeof (FileBrowser));
+
+				return gtype;
+			}
+		}
+
+		void Populate ()
+		{
+			store.Clear ();
+			// seems unnecessary
+			store.AppendValues (&quot;.&quot;);
+
+			if (currentDir != &quot;/&quot;)
+				store.AppendValues (&quot;..&quot;);
+
+			DirectoryInfo di = new DirectoryInfo (currentDir);
+			DirectoryInfo[] dirs = di.GetDirectories ();
+	
+			foreach (DirectoryInfo d in dirs)
+			{
+				if (ignoreHidden)
+				{
+					if (!d.Name.StartsWith (&quot;.&quot;))
+						store.AppendValues (d.Name);
+				}
+				else
+				{
+					store.AppendValues (d.Name);
+				}
+			}
+			if (init == true)
+				tv.Selection.SelectPath (new Gtk.TreePath (&quot;0&quot;));
+		}
+
+		private void OnSelectionChanged (object o, EventArgs args)
+		{
+			TreeIter iter;
+			TreeModel model;
+			if (tv.Selection.GetSelected (out model, out iter))
+			{
+				string selection = (string) store.GetValue (iter, 0);
+				files = Directory.GetFiles (System.IO.Path.Combine (currentDir, selection));
+			}
+		}
+
+		private void OnRowActivated (object o, RowActivatedArgs args)
+		{
+			TreeIter iter;
+			store.GetIter (out iter, args.Path);
+			string file = (string) store.GetValue (iter, 0);
+			string newDir = System.IO.Path.Combine (currentDir, file);
+			if (Directory.Exists (newDir))
+			{
+				currentDir = newDir;
+				Populate ();
+			}
+		}
+	}
+}
+

Added: branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowserPlugin.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowserPlugin.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowserPlugin.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,65 @@
+//
+// FileScoutPlugin.cs: Registers the FileScout class with the plugin loader.
+//
+// Author:
+//   Jeroen Zwartepoorte &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
+//
+// (C) Copyright Jeroen Zwartepoorte 2004
+//
+
+using System;
+using Gtk;
+using log4net;
+using MonoDevelop.Workbench;
+
+namespace MonoDevelop.FileBrowser {
+	class FileBrowserPlugin : BasePlugin {
+		private static readonly ILog log = LogManager.GetLogger (typeof (FileBrowserPlugin));
+	
+		public override string Author {
+			get {
+				return &quot;Jeroen Zwartepoorte&quot;;
+			}
+		}
+		
+		public override string Copyright {
+			get {
+				return &quot;GPL&quot;;
+			}
+		}
+		
+		public override string Description {
+			get {
+				return &quot;Treeview displaying folders &amp; files&quot;;
+			}
+		}
+		
+		public override string Name {
+			get {
+				return &quot;FileScout&quot;;
+			}
+		}
+		
+		public override string Url {
+			get {
+				return &quot;<A HREF="http://www.xs4all.nl/~jeroen/&quot;;">http://www.xs4all.nl/~jeroen/&quot;;</A>
+			}
+		}
+		
+		public override string Version {
+			get {
+				return &quot;1.0&quot;;
+			}
+		}
+	
+		public override bool InitializePlugin (byte major, byte minor)
+		{
+			Workbench.Workbench.AddWidgetFactory (new FileBrowserWidgetFactory ());
+			return true;
+		}
+		
+		public override void FinalizePlugin ()
+		{
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowserWidgetFactory.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowserWidgetFactory.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileBrowserWidgetFactory.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,48 @@
+//
+// FileBrowserWidgetFactory.cs: Factory for creating the FileBrowser widget.
+//
+// Author:
+//   Jeroen Zwartepoorte &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
+//
+// (C) Copyright Jeroen Zwartepoorte 2004
+//
+
+using System;
+using log4net;
+using Gtk;
+using MonoDevelop.Workbench;
+
+namespace MonoDevelop.FileBrowser {
+class FileBrowserWidgetFactory : IWorkbenchWidgetFactory {
+	private static readonly ILog log = LogManager.GetLogger (typeof (FileBrowserWidgetFactory));
+
+	public string WidgetName {
+		get {
+			return &quot;ContentPane&quot;;
+		}
+	}
+
+	public string WidgetTitle {
+		get {
+			return &quot;Content pane&quot;;
+		}
+	}
+	
+	public Gdk.Pixbuf WidgetIcon {
+		get {
+			return null;
+		}
+	}
+	
+	public bool Dockable {
+		get {
+			return true;
+		}
+	}
+
+	public Widget CreateWidget (Workbench workbench)
+	{
+		return new FileBrowser ();
+	}
+}
+}

Added: branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileIconLoader.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileIconLoader.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileIconLoader.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,56 @@
+using System;
+using System.Collections;
+
+using Gtk;
+using Gnome;
+
+namespace MonoDevelop.FileBrowser
+{
+	public class FileIconLoader
+	{
+		static IconTheme iconTheme;
+		static ThumbnailFactory thumbnailFactory;
+		static Hashtable iconHash;
+
+		static FileIconLoader ()
+		{
+			iconTheme = new IconTheme ();
+			thumbnailFactory = new ThumbnailFactory (ThumbnailSize.Normal);
+			iconHash = new Hashtable ();
+		}
+
+		private FileIconLoader ()
+		{
+		}
+
+		public static Gdk.Pixbuf GetPixbufForFile (string filename, int width, int height)
+		{
+			Gnome.IconLookupResultFlags result;
+			string icon;
+			try {
+				icon = Gnome.Icon.LookupSync (iconTheme, thumbnailFactory, filename, &quot;&quot;, Gnome.IconLookupFlags.None, out result);
+			} catch {
+				icon = &quot;gnome-fs-regular&quot;;
+			}
+			Gdk.Pixbuf pix = GetPixbufForType (icon);
+			return pix.ScaleSimple (height, width, Gdk.InterpType.Bilinear);
+		}
+
+		public static Gdk.Pixbuf GetPixbufForType (string type)
+		{
+			Gdk.Pixbuf bf = (Gdk.Pixbuf) iconHash [type];
+			if (bf == null) {
+				string p_filename = &quot;gnome-fs-regular&quot;;
+				IconInfo info = null;
+				try {
+					info = iconTheme.LookupIcon (type, 24, 0);
+				} catch {
+					return new Gdk.Pixbuf (&quot;../data/resources/icons/gnome-fs-regular.png&quot;);
+				}
+				bf = new Gdk.Pixbuf (info == null ? p_filename : info.Filename);
+				iconHash [type] = bf;
+			}
+			return bf;
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileScout.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileScout.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/FileBrowser/FileScout.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,435 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Text;
+using System.Collections;
+using System.Resources;
+
+using MonoDevelop.Services;
+
+namespace MonoDevelop.FileBrowser
+{
+	public class FileList : Gtk.TreeView
+	{
+		private FileSystemWatcher watcher;
+		private ItemCollection Items;
+		private Gtk.ListStore store;
+		private Gtk.Menu popmenu = null;
+		
+		public FileList()
+		{
+			Items = new ItemCollection(this);
+			ResourceManager resources = new ResourceManager(&quot;ProjectComponentResources&quot;, this.GetType().Module.Assembly);
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+			
+			store = new Gtk.ListStore (typeof (string),
+						   typeof (string),
+						   typeof (string),
+						   typeof (FileListItem),
+						   typeof (Gdk.Pixbuf));
+			Model = store;
+
+			HeadersVisible = true;
+			HeadersClickable = true;
+			Reorderable = true;
+			RulesHint = true;
+
+			Gtk.TreeViewColumn name_column = new Gtk.TreeViewColumn ();
+			name_column.Title = &quot;File&quot;;
+			
+			Gtk.TreeViewColumn size_column = new Gtk.TreeViewColumn ();
+			size_column.Title = &quot;Size&quot;;
+
+			Gtk.TreeViewColumn modi_column = new Gtk.TreeViewColumn ();
+			modi_column.Title = &quot;Last modified&quot;;
+
+			Gtk.CellRendererPixbuf pix_render = new Gtk.CellRendererPixbuf ();
+			name_column.PackStart (pix_render, false);
+			name_column.AddAttribute (pix_render, &quot;pixbuf&quot;, 4);
+			
+			Gtk.CellRendererText render1 = new Gtk.CellRendererText ();
+			name_column.PackStart (render1, false);
+			name_column.AddAttribute (render1, &quot;text&quot;, 0);
+			
+			Gtk.CellRendererText render2 = new Gtk.CellRendererText ();
+			size_column.PackStart (render2, false);
+			size_column.AddAttribute (render2, &quot;text&quot;, 1);
+			
+			Gtk.CellRendererText render3 = new Gtk.CellRendererText ();
+			modi_column.PackStart (render3, false);
+			modi_column.AddAttribute (render3, &quot;text&quot;, 2);
+				
+			//listView.AppendColumn (complete_column);
+			AppendColumn(name_column);
+			AppendColumn(size_column);
+			AppendColumn(modi_column);
+
+//			menu = new MagicMenus.PopupMenu();
+//			menu.MenuCommands.Add(new MagicMenus.MenuCommand(&quot;Delete file&quot;, new EventHandler(deleteFiles)));
+//			menu.MenuCommands.Add(new MagicMenus.MenuCommand(&quot;Rename&quot;, new EventHandler(renameFile)));
+			
+			watcher = new FileSystemWatcher ();
+			
+			if(watcher != null) {
+				watcher.NotifyFilter = NotifyFilters.FileName;
+				watcher.EnableRaisingEvents = false;
+				
+				watcher.Renamed += new RenamedEventHandler(fileRenamed);
+				watcher.Deleted += new FileSystemEventHandler(fileDeleted);
+				watcher.Created += new FileSystemEventHandler(fileCreated);
+				watcher.Changed += new FileSystemEventHandler(fileChanged);
+			}
+		}
+		
+		internal void ItemAdded(FileListItem item) {
+			store.AppendValues(item.Text, item.Size, item.LastModified, item, item.Icon);
+		}
+		
+		void ItemRemoved(FileListItem item) {
+			// TODO
+		}
+		
+		internal void Clear() {
+			store.Clear();
+		}
+		
+		void fileDeleted(object sender, FileSystemEventArgs e)
+		{
+			foreach(FileListItem fileItem in Items)
+			{
+				if(fileItem.FullName.ToLower() == e.FullPath.ToLower()) {
+					Items.Remove(fileItem);
+					break;
+				}
+			}
+		}
+		
+		void fileChanged(object sender, FileSystemEventArgs e)
+		{
+			foreach(FileListItem fileItem in Items)
+			{
+				if(fileItem.FullName.ToLower() == e.FullPath.ToLower()) {
+					
+					FileInfo info = new FileInfo(e.FullPath);
+					
+					fileItem.Size = Math.Round((double)info.Length / 1024).ToString() + &quot; KB&quot;;
+					fileItem.LastModified = info.LastWriteTime.ToString();
+					break;
+				}
+			}
+		}
+		
+		void fileCreated(object sender, FileSystemEventArgs e)
+		{
+			FileInfo info = new FileInfo(e.FullPath);
+			
+			FileListItem fileItem = Items.Add(new FileListItem(e.FullPath,
+				Math.Round((double)info.Length / 1024).ToString() + &quot; KB&quot;,
+				info.LastWriteTime.ToString())
+			);
+			
+			Items.Add(fileItem);
+		}
+		
+		void fileRenamed(object sender, RenamedEventArgs e)
+		{
+			foreach(FileListItem fileItem in Items)
+			{
+				if(fileItem.FullName.ToLower() == e.OldFullPath.ToLower()) {
+					fileItem.FullName = e.FullPath;
+					//fileItem.Text = e.Name;
+					break;
+				}
+			}
+		}
+		
+		void renameFile(object sender, EventArgs e)
+		{
+		/*
+			if(SelectedItems.Count == 1) {
+				//SelectedItems[0].BeginEdit();
+			}
+		*/
+		}
+		
+		void deleteFiles(object sender, EventArgs e)
+		{
+			IMessageService messageService =(IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));
+			
+			if (messageService.AskQuestion(&quot;Are you sure ?&quot;, &quot;Delete files&quot;)) {
+				/*foreach(FileListItem fileItem in SelectedItems)
+				{
+					try {
+						File.Delete(fileItem.FullName);
+					} catch(Exception ex) {
+						messageService.ShowError(ex, &quot;Couldn't delete file '&quot; + Path.GetFileName(fileItem.FullName) + &quot;'&quot;);
+						break;
+					}
+				}*/
+			}
+		}
+		
+		public class FileListItem
+		{
+			string fullname;
+			string text;
+			string size;
+			string lastModified;
+			Gdk.Pixbuf icon;
+			
+			public string FullName {
+				get {
+					return fullname;
+				} 
+				set {
+					fullname = System.IO.Path.GetFullPath(value);
+					text = System.IO.Path.GetFileName(fullname);
+				}
+			}
+			
+			public String Text {
+				get {
+					return text;
+				}
+			}
+			
+			public string Size {
+				get {
+					return size;
+				}
+				set {
+					size = value;
+				}
+			}
+			
+			public string LastModified {
+				get {
+					return lastModified;
+				}
+				set {
+					lastModified = value;
+				}
+			}
+
+			public Gdk.Pixbuf Icon {
+				get {
+					return icon;
+				}
+				set {
+					icon = value;
+				}
+			}
+			
+			public FileListItem(string fullname, string size, string lastModified) 
+			{
+				this.size = size;
+				this.lastModified = lastModified;
+				//FIXME: This is because //home/blah is not the same as /home/blah according to Icon.LookupSync, if we get weird behaviours, lets look at this again, see if we still need it.
+				FullName = fullname.Substring (1);
+				icon = FileIconLoader.GetPixbufForFile (FullName, 24, 24);
+			}
+
+			public FileListItem (string name)
+			{
+				FileInfo fi = new FileInfo (name);
+				this.size = Math.Round ((double) fi.Length / 1024).ToString () + &quot; KB&quot;;
+				this.lastModified = fi.LastWriteTime.ToString ();
+				FullName = System.IO.Path.GetFullPath (name); 
+				icon = FileIconLoader.GetPixbufForFile (FullName, 24, 24);
+			}
+		}
+		
+		class ItemCollection {
+			FileList parent;
+			ArrayList list = new ArrayList();
+			
+			public ItemCollection(FileList parent) {
+				this.parent = parent;
+			}
+			
+			public FileListItem Add(FileListItem item) {
+				list.Add(item);
+				parent.ItemAdded(item);
+				return item;
+			}
+			
+			public void Remove(FileListItem item) {
+				parent.ItemRemoved(item);
+				list.Remove(item);
+			}
+			
+			public void Clear() {
+				list.Clear();
+				parent.Clear();
+			}
+			
+			public IEnumerator GetEnumerator() {
+				ArrayList copy = (ArrayList)list.Clone();
+				return copy.GetEnumerator();
+			}
+		}
+	}
+	
+	public class FileScout : Gtk.VPaned
+	{
+		ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(ResourceService));
+		public Gtk.Widget Control {
+			get {
+				return this;
+			}
+		}
+		
+		public void BringToFront() {
+			// TODO
+		}
+		
+		public string Title {
+			get {
+				return resourceService.GetString(&quot;MainWindow.Windows.FileScoutLabel&quot;);
+			}
+		}
+		
+		/*public string Icon {
+			get {
+				return MonoDevelop.Gui.Stock.OpenFolderBitmap;
+			}
+		}*/
+		
+		public void RedrawContent()
+		{
+			//OnTitleChanged(null);
+			//OnIconChanged(null);
+		}
+		
+		FileList   filelister = new FileList();
+		FileBrowser fb = new FileBrowser ();
+		Gtk.Entry pathEntry;
+		PropertyService PropertyService = (PropertyService) ServiceManager.Services.GetService (typeof (PropertyService));
+
+		public FileScout()
+		{
+			fb.TreeView.Selection.Changed += new EventHandler (OnDirChanged);
+			filelister.RowActivated += new Gtk.RowActivatedHandler(FileSelected);
+
+			Gtk.Frame treef  = new Gtk.Frame();
+			Gtk.VBox utilVBox = new Gtk.VBox (false, 0);
+			Gtk.HBox hbox = new Gtk.HBox (false, 6);
+			pathEntry = new Gtk.Entry (fb.CurrentDir);
+			pathEntry.Activated += new EventHandler (OnPathEntryActivated);
+			hbox.PackStart (pathEntry);
+			Gtk.Button homeButton = new Gtk.Button ();
+			Gdk.Pixbuf pix = FileIconLoader.GetPixbufForType (&quot;gnome-home&quot;);
+			homeButton.Add (new Gtk.Image (pix.ScaleSimple (20, 20, Gdk.InterpType.Bilinear)));
+			homeButton.Relief = Gtk.ReliefStyle.None;
+			homeButton.Clicked += new EventHandler (OnHomeClicked);
+			hbox.PackStart (homeButton, false, false, 0);
+			utilVBox.PackStart (hbox, false, true, 0);
+			utilVBox.PackStart (fb);
+			treef.Add(utilVBox);
+			
+			Gtk.ScrolledWindow listsw = new Gtk.ScrolledWindow ();
+			listsw.Add(filelister);
+			Gtk.Frame listf  = new Gtk.Frame();
+			listf.Add(listsw);
+			
+			Pack1(treef, true, true);
+			Pack2(listf, true, true);
+
+			fb.TreeView.Selection.SelectPath (new Gtk.TreePath (&quot;0&quot;));
+		}
+
+		void OnHomeClicked (object sender, EventArgs args)
+		{
+			fb.CurrentDir = Environment.GetEnvironmentVariable (&quot;HOME&quot;);
+			OnDirChanged (sender, args);
+		}
+
+		void OnPathEntryActivated (object sender, EventArgs args)
+		{
+			if (Directory.Exists (pathEntry.Text.Trim ()))
+			{
+				fb.CurrentDir = pathEntry.Text;
+				OnDirChanged (sender, args);
+			}
+		}
+		
+		void OnDirChanged(object sender, EventArgs args) 
+		{
+			pathEntry.Text = fb.CurrentDir;
+			filelister.Clear ();
+
+			PropertyService p = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+			bool ignoreHidden = !p.GetProperty (&quot;ICSharpCode.SharpDevelop.Gui.FileScout.ShowHidden&quot;, false);
+			fb.IgnoreHidden = ignoreHidden;
+
+			foreach (string f in fb.Files)
+			{
+				if (!(System.IO.Path.GetFileName (f)).StartsWith (&quot;.&quot;))
+				{
+					FileList.FileListItem it = new FileList.FileListItem (f);
+					filelister.ItemAdded (it);
+				}
+				else
+				{
+					if (!ignoreHidden)
+					{
+						FileList.FileListItem it = new FileList.FileListItem (f);
+						filelister.ItemAdded (it);
+					
+					}
+				}
+			}
+		}
+
+		void FileSelected(object sender, Gtk.RowActivatedArgs e)
+		{
+			Console.WriteLine (&quot;FileScout.FileSelected FIXME&quot;);
+			/*IProjectService projectService = (IProjectService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			IFileService    fileService    = (IFileService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+
+			Gtk.TreeIter iter;
+			if (filelister.Model.GetIterFirst(out iter) == false) {
+				return;
+			}
+			do {
+				if (filelister.Selection.IterIsSelected(iter) == false) {
+					continue;
+				} 
+				FileList.FileListItem item = (FileList.FileListItem)filelister.Model.GetValue(iter, 3);
+				switch (System.IO.Path.GetExtension(item.FullName)) {
+					case &quot;.cmbx&quot;:
+					case &quot;.prjx&quot;:
+						projectService.OpenCombine(item.FullName);
+						break;
+					default:
+						Console.WriteLine (item.FullName);
+						fileService.OpenFile(item.FullName);
+						break;
+				}
+			} while (filelister.Model.IterNext(out iter) == true);*/
+		}
+/*
+		protected virtual void OnTitleChanged(EventArgs e)
+		{
+			if (TitleChanged != null) {
+				TitleChanged(this, e);
+			}
+		}
+		protected virtual void OnIconChanged(EventArgs e)
+		{
+			if (IconChanged != null) {
+				IconChanged(this, e);
+			}
+		}
+		*/
+		public event EventHandler TitleChanged;
+		public event EventHandler IconChanged;
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/FileBrowser/Makefile.am
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/FileBrowser/Makefile.am	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/FileBrowser/Makefile.am	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,35 @@
+filebrowserdir = $(libdir)/monodevelop
+filebrowserassembly = $(filebrowserdir)/filebrowser.dll
+filebrowser_DATA = filebrowser.dll
+plugindir = $(monodevelop_plugin_dir)
+plugin_DATA = filebrowser.plugin
+CLEANFILES = filebrowser.dll filebrowser.plugin
+CSC = mcs
+
+filebrowser_sources = \
+	FileBrowser.cs \
+	FileBrowserPlugin.cs \
+	FileBrowserWidgetFactory.cs \
+	FileIconLoader.cs \
+	FileScout.cs
+
+filebrowser_assemblies = \
+	-r:../../StartUp/monodevelop.exe \
+	-r:log4net.dll \
+	-r:gtk-sharp.dll \
+	-r:gdk-sharp.dll \
+	-r:glib-sharp.dll \
+	-r:gnome-sharp.dll \
+	-r:../../../build/bin/gdl-sharp.dll \
+	-r:../Services/services.dll \
+	-r:../Workbench/workbench.dll
+
+filebrowser.dll: $(filebrowser_sources)
+	$(CSC) -debug -t:library -out:filebrowser.dll $(filebrowser_sources) $(filebrowser_assemblies)
+
+filebrowser.plugin: filebrowser.plugin.in
+	sed -e 's^\@assembly\@^$(filebrowserassembly)^g' &lt; $(srcdir)/filebrowser.plugin.in &gt; filebrowser.plugin
+
+EXTRA_DIST = \
+	$(filebrowser_sources) \
+	filebrowser.plugin.in

Added: branches/MonoDevelop-playground/src/Plugins/FileBrowser/filebrowser.plugin.in
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/FileBrowser/filebrowser.plugin.in	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/FileBrowser/filebrowser.plugin.in	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,5 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;plugin version=&quot;1.0&quot;&gt;
+	&lt;assembly&gt;@assembly@&lt;/assembly&gt;
+	&lt;class name=&quot;MonoDevelop.FileBrowser.FileBrowserPlugin&quot;/&gt;
+&lt;/plugin&gt;

Modified: branches/MonoDevelop-playground/src/Plugins/Makefile.am
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Makefile.am	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Makefile.am	2004-02-29 09:47:46 UTC (rev 1060)
@@ -1 +1 @@
-SUBDIRS = Workbench
+SUBDIRS = Services Workbench FileBrowser


Property changes on: branches/MonoDevelop-playground/src/Plugins/Services
___________________________________________________________________
Name: svn:ignore
   + Makefile
Makefile.in
services.dll
services.plugin


Added: branches/MonoDevelop-playground/src/Plugins/Services/AbstractService.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/AbstractService.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/AbstractService.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,42 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	public class AbstractService : IService
+	{
+		public virtual void InitializeService()
+		{
+			OnInitialize(EventArgs.Empty);
+		}
+		
+		
+		public virtual void UnloadService()
+		{
+			OnUnload(EventArgs.Empty);
+		}
+		
+		protected virtual void OnInitialize(EventArgs e)
+		{
+			if (Initialize != null) {
+				Initialize(this, e);
+			}
+		}
+		
+		protected virtual void OnUnload(EventArgs e)
+		{
+			if (Unload != null) {
+				Unload(this, e);
+			}
+		}
+		
+		public event EventHandler Initialize;
+		public event EventHandler Unload;
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/DefaultProperties.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/DefaultProperties.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/DefaultProperties.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,286 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Diagnostics;
+using System.Xml;
+using System.Reflection;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// Default &lt;code&gt;IProperties&lt;/code&gt; implementation, should
+	/// be enough for most cases :)
+	/// &lt;/summary&gt;
+	public class DefaultProperties : IProperties
+	{
+		Hashtable properties = new Hashtable();
+		
+		/// &lt;summary&gt;
+		/// Gets a property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		public object GetProperty(string key, object defaultvalue)
+		{
+			if (!properties.ContainsKey(key)) {
+				if (defaultvalue != null) {
+					properties[key] = defaultvalue;
+				}
+				return defaultvalue;
+			}
+			
+			object obj = properties[key];
+			
+			// stored an XmlElement in properties node -&gt;
+			// set a FromXmlElement of the defaultvalue type at this propertyposition.
+			if (defaultvalue is IXmlConvertable &amp;&amp; obj is XmlElement) {
+				obj = properties[key] = ((IXmlConvertable)defaultvalue).FromXmlElement((XmlElement)((XmlElement)obj).FirstChild);
+			}
+			return obj;
+		}
+		
+		/// &lt;summary&gt;
+		/// Gets a property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;null&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		public object GetProperty(string key)
+		{
+			return GetProperty(key, (object)null);
+		}
+		
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;int&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		public int GetProperty(string key, int defaultvalue)
+		{
+			return int.Parse(GetProperty(key, (object)defaultvalue).ToString());
+		}
+		
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;bool&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		public bool GetProperty(string key, bool defaultvalue)
+		{
+			return bool.Parse(GetProperty(key, (object)defaultvalue).ToString());
+		}
+
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;short&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		public short GetProperty(string key, short defaultvalue)
+		{
+			return short.Parse(GetProperty(key, (object)defaultvalue).ToString());
+		}
+
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;byte&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		public byte GetProperty(string key, byte defaultvalue)
+		{
+			return byte.Parse(GetProperty(key, (object)defaultvalue).ToString());
+		}
+		
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;string&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		public string GetProperty(string key, string defaultvalue)
+		{
+			return GetProperty(key, (object)defaultvalue).ToString();
+		}
+		
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;enum&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		public System.Enum GetProperty(string key, System.Enum defaultvalue)
+		{
+			return (System.Enum)Enum.Parse(defaultvalue.GetType(), GetProperty(key, (object)defaultvalue).ToString());
+		}
+		
+		/// &lt;summary&gt;
+		/// Sets the property &lt;code&gt;key&lt;/code&gt; to the value &lt;code&gt;val&lt;/code&gt;.
+		/// If &lt;code&gt;val&lt;/code&gt; is null, the property will be taken out from the
+		/// properties.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;val&quot;&gt;
+		/// The value of the property.
+		/// &lt;/param&gt;
+		public void SetProperty(string key, object val)
+		{
+			object oldValue = properties[key];
+			if (!val.Equals(oldValue)) {
+				properties[key] = val;
+				OnPropertyChanged(new PropertyEventArgs(this, key, oldValue, val));
+			}
+		}
+		
+		public DefaultProperties()
+		{
+		}
+		
+		protected void SetValueFromXmlElement(XmlElement element)
+		{
+			XmlNodeList nodes = element.ChildNodes;
+			foreach (XmlElement el in nodes) {
+				if (el.Name == &quot;Property&quot;) {
+					properties[el.Attributes[&quot;key&quot;].InnerText] = el.Attributes[&quot;value&quot;].InnerText;
+				} else if (el.Name == &quot;XmlConvertableProperty&quot;) {
+					properties[el.Attributes[&quot;key&quot;].InnerText] = el;
+				} else {
+					throw new UnknownPropertyNodeException(el.Name);
+				}
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// Converts a &lt;code&gt;XmlElement&lt;/code&gt; to an &lt;code&gt;DefaultProperties&lt;/code&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// A new &lt;code&gt;DefaultProperties&lt;/code&gt; object 
+		/// &lt;/returns&gt;
+		public virtual object FromXmlElement(XmlElement element)
+		{
+			DefaultProperties defaultProperties = new DefaultProperties();
+			defaultProperties.SetValueFromXmlElement(element);
+			return defaultProperties;
+		}
+		
+		/// &lt;summary&gt;
+		/// Converts the &lt;code&gt;DefaultProperties&lt;/code&gt; object to a &lt;code&gt;XmlElement&lt;/code&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// A new &lt;code&gt;XmlElement&lt;/code&gt; object which represents the state
+		/// of the &lt;code&gt;DefaultProperties&lt;/code&gt; object.
+		/// &lt;/returns&gt;
+		public virtual XmlElement ToXmlElement(XmlDocument doc)
+		{
+			XmlElement propertiesnode  = doc.CreateElement(&quot;Properties&quot;);
+			
+			foreach (DictionaryEntry entry in properties) {
+				if (entry.Value != null) {
+					if (entry.Value is XmlElement) { // write unchanged XmlElement back
+						propertiesnode.AppendChild(doc.ImportNode((XmlElement)entry.Value, true));
+					} else if (entry.Value is IXmlConvertable) { // An Xml convertable object
+						XmlElement convertableNode = doc.CreateElement(&quot;XmlConvertableProperty&quot;);
+						
+						XmlAttribute key = doc.CreateAttribute(&quot;key&quot;);
+						key.InnerText = entry.Key.ToString();
+						convertableNode.Attributes.Append(key);
+						
+						convertableNode.AppendChild(((IXmlConvertable)entry.Value).ToXmlElement(doc));
+						
+						propertiesnode.AppendChild(convertableNode);
+					} else {
+						XmlElement el = doc.CreateElement(&quot;Property&quot;);
+						
+						XmlAttribute key   = doc.CreateAttribute(&quot;key&quot;);
+						key.InnerText      = entry.Key.ToString();
+						el.Attributes.Append(key);
+	
+						XmlAttribute val   = doc.CreateAttribute(&quot;value&quot;);
+						val.InnerText      = entry.Value.ToString();
+						el.Attributes.Append(val);
+						
+						propertiesnode.AppendChild(el);
+					}
+				}
+			}
+			return propertiesnode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Returns a new instance of &lt;code&gt;IProperties&lt;/code&gt; which has
+		/// the same properties.
+		/// &lt;/summary&gt;
+		public IProperties Clone()
+		{
+			DefaultProperties df = new DefaultProperties();
+			df.properties = (Hashtable)properties.Clone();
+			return df;
+		}
+		
+		protected virtual void OnPropertyChanged(PropertyEventArgs e)
+		{
+			if (PropertyChanged != null) {
+				PropertyChanged(this, e);
+			}
+		}
+		
+		public event PropertyEventHandler PropertyChanged;
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/FileUtilityService.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/FileUtilityService.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/FileUtilityService.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,442 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+#define LINUX
+
+using System;
+using System.IO;
+using System.Text;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Reflection;
+using System.Resources;
+using System.Diagnostics;
+using System.Xml;
+
+namespace MonoDevelop.Services
+{
+	public enum FileErrorPolicy {
+		Inform,
+		ProvideAlternative
+	}
+	
+	public enum FileOperationResult {
+		OK,
+		Failed,
+		SavedAlternatively
+	}
+	
+	public delegate void FileOperationDelegate();
+	
+	public delegate void NamedFileOperationDelegate(string fileName);
+	
+	/// &lt;summary&gt;
+	/// A utility class related to file utilities.
+	/// &lt;/summary&gt;
+	public class FileUtilityService : AbstractService
+	{
+		readonly static char[] separators = { Path.DirectorySeparatorChar, Path.VolumeSeparatorChar, Path.AltDirectorySeparatorChar };
+		readonly static char[] dir_sep = { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar };
+		string sharpDevelopRootPath;
+		
+		public string SharpDevelopRootPath {
+			get {
+				return sharpDevelopRootPath;
+			}
+		}
+		
+		public FileUtilityService()
+		{
+			sharpDevelopRootPath = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location) + Path.DirectorySeparatorChar + &quot;..&quot;;
+		}
+		
+		public override void InitializeService()
+		{
+			base.InitializeService();
+		}
+		
+		public override void UnloadService()
+		{
+			base.UnloadService();
+		}
+
+		public StringCollection SearchDirectory(string directory, string filemask, bool searchSubdirectories)
+		{
+			StringCollection collection = new StringCollection();
+			SearchDirectory(directory, filemask, collection, searchSubdirectories);
+			return collection;
+		}
+		
+		public StringCollection SearchDirectory(string directory, string filemask)
+		{
+			return SearchDirectory(directory, filemask, true);
+		}
+		
+		/// &lt;summary&gt;
+		/// Finds all files which are valid to the mask &lt;code&gt;filemask&lt;/code&gt; in the path
+		/// &lt;code&gt;directory&lt;/code&gt; and all subdirectories (if searchSubdirectories
+		/// is true. The found files are added to the StringCollection 
+		/// &lt;code&gt;collection&lt;/code&gt;.
+		/// &lt;/summary&gt;
+		void SearchDirectory(string directory, string filemask, StringCollection collection, bool searchSubdirectories)
+		{
+			try {
+				string[] file = Directory.GetFiles(directory, filemask);
+				foreach (string f in file) {
+					collection.Add(f);
+				}
+				
+				if (searchSubdirectories) {
+					string[] dir = Directory.GetDirectories(directory);
+					foreach (string d in dir) {
+						SearchDirectory(d, filemask, collection, searchSubdirectories);
+					}
+				}
+			} catch (Exception e) {
+				IMessageService messageService =(IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));
+				messageService.ShowError(e, &quot;Can't access directory &quot; + directory);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// Converts a given absolute path and a given base path to a path that leads
+		/// from the base path to the absoulte path. (as a relative path)
+		/// &lt;/summary&gt;
+		public string AbsoluteToRelativePath(string baseDirectoryPath, string absPath)
+		{
+			if (! Path.IsPathRooted (absPath))
+				return absPath;
+			
+			absPath = Path.GetFullPath (absPath);
+			baseDirectoryPath = Path.GetFullPath (baseDirectoryPath);
+			
+			string[] bPath = baseDirectoryPath.Split (separators);
+			string[] aPath = absPath.Split (separators);
+			int indx = 0;
+			for(; indx &lt; Math.Min(bPath.Length, aPath.Length); ++indx){
+				if(!bPath[indx].Equals(aPath[indx]))
+					break;
+			}
+			
+			if (indx == 0) {
+				return absPath;
+			}
+			
+			string erg = &quot;&quot;;
+			
+			if(indx == bPath.Length) {
+				erg += &quot;.&quot; + Path.DirectorySeparatorChar;
+			} else {
+				for (int i = indx; i &lt; bPath.Length; ++i) {
+					erg += &quot;..&quot; + Path.DirectorySeparatorChar;
+				}
+			}
+			erg += String.Join(Path.DirectorySeparatorChar.ToString(), aPath, indx, aPath.Length-indx);
+			
+			return erg;
+		}
+		
+		/// &lt;summary&gt;
+		/// Converts a given relative path and a given base path to a path that leads
+		/// to the relative path absoulte.
+		/// &lt;/summary&gt;
+		public string RelativeToAbsolutePath(string baseDirectoryPath, string relPath)
+		{			
+			return Path.GetFullPath (baseDirectoryPath + Path.DirectorySeparatorChar + relPath);
+		}
+		
+		/// &lt;summary&gt;
+		/// This method checks the file fileName if it is valid.
+		/// &lt;/summary&gt;
+		public bool IsValidFileName(string fileName)
+		{
+			// Fixme: 260 is the hardcoded maximal length for a path on my Windows XP system
+			//        I can't find a .NET property or method for determining this variable.
+			if (fileName == null || fileName.Length == 0 || fileName.Length &gt;= 260) {
+				return false;
+			}
+			
+			// platform independend : check for invalid path chars
+			foreach (char invalidChar in Path.InvalidPathChars) {
+				if (fileName.IndexOf(invalidChar) &gt;= 0) {
+					return false;
+				}
+			}
+			
+			// platform dependend : Check for invalid file names (DOS)
+			// this routine checks for follwing bad file names :
+			// CON, PRN, AUX, NUL, COM1-9 and LPT1-9
+			
+			string nameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
+			if (nameWithoutExtension != null) {
+				nameWithoutExtension = nameWithoutExtension.ToUpper();
+			}
+			
+			if (nameWithoutExtension == &quot;CON&quot; ||
+			    nameWithoutExtension == &quot;PRN&quot; ||
+			    nameWithoutExtension == &quot;AUX&quot; ||
+			    nameWithoutExtension == &quot;NUL&quot;) {
+		    	
+		    	return false;
+		    }
+			    
+		    char ch = nameWithoutExtension.Length == 4 ? nameWithoutExtension[3] : '\0';
+			
+			return !((nameWithoutExtension.StartsWith(&quot;COM&quot;) ||
+			          nameWithoutExtension.StartsWith(&quot;LPT&quot;)) &amp;&amp;
+			          Char.IsDigit(ch));
+		}
+		
+		public bool TestFileExists(string filename)
+		{
+			if (!File.Exists(filename)) {
+				IResourceService resourceService = (IResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+				StringParserService stringParserService = (StringParserService)ServiceManager.Services.GetService(typeof(StringParserService));
+				
+				IMessageService messageService =(IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));
+				messageService.ShowWarning(stringParserService.Parse(resourceService.GetString(&quot;Fileutility.CantFindFileError&quot;), new string[,] { {&quot;FILE&quot;,  filename} }));
+				return false;
+			}
+			return true;
+		}
+		
+		public bool IsDirectory(string filename)
+		{
+			if (!Directory.Exists(filename)) {
+				return false;
+			}
+			FileAttributes attr = File.GetAttributes(filename);
+			return (attr &amp; FileAttributes.Directory) != 0;
+		}
+		
+		/// &lt;summary&gt;
+		/// Returns directoryName + &quot;\\&quot; (Win32) when directoryname doesn't end with
+		/// &quot;\\&quot;
+		/// &lt;/summary&gt;
+		public string GetDirectoryNameWithSeparator(string directoryName)
+		{
+			if (directoryName == null) return &quot;&quot;;
+			
+			if (directoryName.EndsWith(Path.DirectorySeparatorChar.ToString())) {
+				return directoryName;
+			}
+			return directoryName + Path.DirectorySeparatorChar;
+		}
+		
+		// Observe SAVE functions
+		public FileOperationResult ObservedSave(FileOperationDelegate saveFile, string fileName, string message, FileErrorPolicy policy)
+		{
+			Debug.Assert(IsValidFileName(fileName));
+#if !LINUX			
+			try {
+				saveFile();
+				return FileOperationResult.OK;
+			} catch (Exception e) {
+				switch (policy) {
+					case FileErrorPolicy.Inform:
+						using (SaveErrorInformDialog informDialog = new SaveErrorInformDialog(fileName, message, &quot;Error while saving&quot;, e)) {
+							informDialog.ShowDialog();
+						}
+						break;
+					case FileErrorPolicy.ProvideAlternative:
+						using (SaveErrorChooseDialog chooseDialog = new SaveErrorChooseDialog(fileName, message, &quot;Error while saving&quot;, e, false)) {
+							switch (chooseDialog.ShowDialog()) {
+								case DialogResult.OK: // choose location (never happens here)
+								break;
+								case DialogResult.Retry:
+									return ObservedSave(saveFile, fileName, message, policy);
+								case DialogResult.Ignore:
+									return FileOperationResult.Failed;
+							}
+						}
+						break;
+				}
+			}
+#else
+			try {
+				saveFile();
+				return FileOperationResult.OK;
+			} catch (Exception e) {
+				Console.WriteLine(&quot;Error while saving : &quot; + e.ToString());
+			}
+	
+#endif
+			return FileOperationResult.Failed;
+		}
+		
+		public FileOperationResult ObservedSave(FileOperationDelegate saveFile, string fileName, FileErrorPolicy policy)
+		{
+			IResourceService resourceService = (IResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+			return ObservedSave(saveFile,
+			                    fileName,
+			                    resourceService.GetString(&quot;ICSharpCode.Services.FileUtilityService.CantSaveFileStandardText&quot;),
+			                    policy);
+		}
+		
+		public FileOperationResult ObservedSave(FileOperationDelegate saveFile, string fileName)
+		{
+			return ObservedSave(saveFile, fileName, FileErrorPolicy.Inform);
+		}
+		
+		public FileOperationResult ObservedSave(NamedFileOperationDelegate saveFileAs, string fileName, string message, FileErrorPolicy policy)
+		{
+			Debug.Assert(IsValidFileName(fileName));
+#if !LINUX
+			try {
+				fileName = System.IO.Path.GetFullPath (fileName);
+				saveFileAs(fileName);
+				return FileOperationResult.OK;
+			} catch (Exception e) {
+				switch (policy) {
+					case FileErrorPolicy.Inform:
+						using (SaveErrorInformDialog informDialog = new SaveErrorInformDialog(fileName, message, &quot;Error while saving&quot;, e)) {
+							informDialog.ShowDialog();
+						}
+						break;
+					case FileErrorPolicy.ProvideAlternative:
+						restartlabel:
+							using (SaveErrorChooseDialog chooseDialog = new SaveErrorChooseDialog(fileName, message, &quot;Error while saving&quot;, e, true)) {
+								switch (chooseDialog.ShowDialog()) {
+									case DialogResult.OK:
+										using (SaveFileDialog fdiag = new SaveFileDialog()) {
+											fdiag.OverwritePrompt = true;
+											fdiag.AddExtension    = true;
+											fdiag.CheckFileExists = false;
+											fdiag.CheckPathExists = true;
+											fdiag.Title           = &quot;Choose alternate file name&quot;;
+											fdiag.FileName        = fileName;
+											if (fdiag.ShowDialog() == DialogResult.OK) {
+												return ObservedSave(saveFileAs, fdiag.FileName, message, policy);
+											} else {
+												goto restartlabel;
+											}
+										}
+										case DialogResult.Retry:
+											return ObservedSave(saveFileAs, fileName, message, policy);
+									case DialogResult.Ignore:
+										return FileOperationResult.Failed;
+								}
+							}
+							break;
+				}
+			}
+#else
+			try {
+				saveFileAs(fileName);
+				return FileOperationResult.OK;
+			} catch (Exception e) {
+				Console.WriteLine(&quot;Error while saving as : &quot; + e.ToString());
+			}
+#endif
+			return FileOperationResult.Failed;
+		}
+		
+		public FileOperationResult ObservedSave(NamedFileOperationDelegate saveFileAs, string fileName, FileErrorPolicy policy)
+		{
+			IResourceService resourceService = (IResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+			return ObservedSave(saveFileAs,
+			                    fileName,
+			                    resourceService.GetString(&quot;ICSharpCode.Services.FileUtilityService.CantSaveFileStandardText&quot;),
+			                    policy);
+		}
+		
+		public FileOperationResult ObservedSave(NamedFileOperationDelegate saveFileAs, string fileName)
+		{
+			return ObservedSave(saveFileAs, fileName, FileErrorPolicy.Inform);
+		}
+		
+		// Observe LOAD functions
+		public FileOperationResult ObservedLoad(FileOperationDelegate saveFile, string fileName, string message, FileErrorPolicy policy)
+		{
+			Debug.Assert(IsValidFileName(fileName));
+#if !LINUX
+			try {
+				saveFile();
+				return FileOperationResult.OK;
+			} catch (Exception e) {
+				switch (policy) {
+					case FileErrorPolicy.Inform:
+						using (SaveErrorInformDialog informDialog = new SaveErrorInformDialog(fileName, message, &quot;Error while loading&quot;, e)) {
+							informDialog.ShowDialog();
+						}
+						break;
+					case FileErrorPolicy.ProvideAlternative:
+						using (SaveErrorChooseDialog chooseDialog = new SaveErrorChooseDialog(fileName, message, &quot;Error while loading&quot;, e, false)) {
+							switch (chooseDialog.ShowDialog()) {
+								case DialogResult.OK: // choose location (never happens here)
+								break;
+								case DialogResult.Retry:
+									return ObservedLoad(saveFile, fileName, message, policy);
+								case DialogResult.Ignore:
+									return FileOperationResult.Failed;
+							}
+						}
+						break;
+				}
+			}
+#else
+			try {
+				saveFile();
+				return FileOperationResult.OK;
+			} catch (Exception e) {
+				Console.WriteLine(&quot;Error while loading &quot; + e.ToString());
+			}
+#endif
+			return FileOperationResult.Failed;
+		}
+		
+		public FileOperationResult ObservedLoad(FileOperationDelegate saveFile, string fileName, FileErrorPolicy policy)
+		{
+			IResourceService resourceService = (IResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+			return ObservedLoad(saveFile,
+			                    fileName,
+			                    resourceService.GetString(&quot;ICSharpCode.Services.FileUtilityService.CantLoadFileStandardText&quot;),
+			                    policy);
+		}
+		
+		public FileOperationResult ObservedLoad(FileOperationDelegate saveFile, string fileName)
+		{
+			return ObservedSave(saveFile, fileName, FileErrorPolicy.Inform);
+		}
+		
+		class LoadWrapper
+		{
+			NamedFileOperationDelegate saveFileAs;
+			string fileName;
+			
+			public LoadWrapper(NamedFileOperationDelegate saveFileAs, string fileName)
+			{
+				this.saveFileAs = saveFileAs;
+				this.fileName   = fileName;
+			}
+			
+			public void Invoke()
+			{
+				saveFileAs(fileName);
+			}
+		}
+		
+		public FileOperationResult ObservedLoad(NamedFileOperationDelegate saveFileAs, string fileName, string message, FileErrorPolicy policy)
+		{
+			return ObservedLoad(new FileOperationDelegate(new LoadWrapper(saveFileAs, fileName).Invoke), fileName, message, policy);
+		}
+		
+		public FileOperationResult ObservedLoad(NamedFileOperationDelegate saveFileAs, string fileName, FileErrorPolicy policy)
+		{
+			IResourceService resourceService = (IResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+			return ObservedLoad(saveFileAs,
+			                    fileName,
+			                    resourceService.GetString(&quot;ICSharpCode.Services.FileUtilityService.CantLoadFileStandardText&quot;),
+			                    policy);
+		}
+		
+		public FileOperationResult ObservedLoad(NamedFileOperationDelegate saveFileAs, string fileName)
+		{
+			return ObservedLoad(saveFileAs, fileName, FileErrorPolicy.Inform);
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/IMessageService.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/IMessageService.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/IMessageService.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,42 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// This interface must be implemented by all services.
+	/// &lt;/summary&gt;
+	public interface IMessageService
+	{
+		void ShowError(Exception ex);
+		void ShowError(string message);
+		void ShowError(Exception ex, string message);
+		void ShowErrorFormatted(string formatstring, params string[] formatitems);
+		
+		void ShowWarning(string message);
+		void ShowWarningFormatted(string formatstring, params string[] formatitems);
+		
+		void ShowMessage(string message);
+		void ShowMessage(string message, string caption);
+		void ShowMessageFormatted(string formatstring, params string[] formatitems);
+		void ShowMessageFormatted(string caption, string formatstring, params string[] formatitems);
+		
+		/// &lt;summary&gt;
+		/// returns the number of the chosen button
+		/// &lt;/summary&gt;
+		int  ShowCustomDialog(string caption, 
+		                      string dialogText,
+		                      params string[] buttontexts);
+		
+		bool AskQuestion(string question);
+		bool AskQuestionFormatted(string formatstring, params string[] formatitems);
+		bool AskQuestion(string question, string caption);
+		bool AskQuestionFormatted(string caption, string formatstring, params string[] formatitems);
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/IProperties.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/IProperties.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/IProperties.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,165 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Diagnostics;
+using System.Xml;
+using System.Reflection;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// The &lt;code&gt;IProperties&lt;/code&gt; interface defines a set of properties
+	/// &lt;/summary&gt;
+	public interface IProperties : IXmlConvertable
+	{
+		/// &lt;summary&gt;
+		/// Gets a property out of the collection. The defaultvalue must either 
+		/// have a cast to a string (and back) or implement the 
+		/// &lt;code&gt;IXmlConcertable&lt;/code&gt; interface.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't
+		/// found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		object GetProperty(string key, object defaultvalue);
+		
+		/// &lt;summary&gt;
+		/// Gets a property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;null&lt;/code&gt;, if the property wasn't 
+		/// found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		object GetProperty(string key);
+		
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;int&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't
+		/// found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		int GetProperty(string key, int defaultvalue);
+		
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;bool&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't
+		/// found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		bool GetProperty(string key, bool defaultvalue);
+
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;short&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't
+		/// found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		short GetProperty(string key, short defaultvalue);
+
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;byte&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't
+		/// found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		byte GetProperty(string key, byte defaultvalue);
+
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;string&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't
+		/// found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		string GetProperty(string key, string defaultvalue);
+		
+		/// &lt;summary&gt;
+		/// Gets a &lt;code&gt;enum&lt;/code&gt; property out of the collection.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The property, or &lt;code&gt;defaultvalue&lt;/code&gt;, if the property wasn't found.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;defaultvalue&quot;&gt;
+		/// The default value of the property.
+		/// &lt;/param&gt;
+		System.Enum GetProperty(string key, System.Enum defaultvalue);
+		
+		/// &lt;summary&gt;
+		/// Sets the property &lt;code&gt;key&lt;/code&gt; to the value &lt;code&gt;val&lt;/code&gt;.
+		/// If &lt;code&gt;val&lt;/code&gt; is null, the property will be taken out from the
+		/// properties.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;key&quot;&gt;
+		/// The name of the property.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;val&quot;&gt;
+		/// The value of the property.
+		/// &lt;/param&gt;
+		void SetProperty(string key, object val);
+		
+		/// &lt;summary&gt;
+		/// Returns a new instance of &lt;code&gt;IProperties&lt;/code&gt; which has 
+		/// the same properties.
+		/// &lt;/summary&gt;
+		IProperties Clone();
+		
+		/// &lt;summary&gt;
+		/// The property changed event handler, it is called
+		/// when a property has changed.
+		/// &lt;/summary&gt;
+		event PropertyEventHandler PropertyChanged;
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/IResourceService.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/IResourceService.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/IResourceService.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,18 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// This interface must be implemented by all services.
+	/// &lt;/summary&gt;
+	public interface IResourceService
+	{
+		string GetString(string name);
+		
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/IService.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/IService.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/IService.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,30 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// This interface must be implemented by all services.
+	/// &lt;/summary&gt;
+	public interface IService
+	{
+		/// &lt;summary&gt;
+		/// This method is called after the services are loaded.
+		/// &lt;/summary&gt;
+		void InitializeService();
+		
+		/// &lt;summary&gt;
+		/// This method is called before the service is unloaded.
+		/// &lt;/summary&gt;
+		void UnloadService();
+		
+		event EventHandler Initialize;
+		event EventHandler Unload;
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/IStringTagProvider.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/IStringTagProvider.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/IStringTagProvider.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,18 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+namespace MonoDevelop.Services
+{
+	public interface IStringTagProvider 
+	{
+		string[] Tags {
+			get;
+		}
+		
+		string Convert(string tag);
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/IXmlConvertable.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/IXmlConvertable.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/IXmlConvertable.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,37 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System.Xml;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// If you want define own, complex options you can implement this interface
+	/// and save it in the main Option class, your class will be saved as xml in
+	/// the global properties.
+	/// Use your class like any other property. (the conversion will be transparent)
+	/// &lt;/summary&gt;
+	public interface IXmlConvertable
+	{
+		/// &lt;summary&gt;
+		/// Converts a &lt;code&gt;XmlElement&lt;/code&gt; to an &lt;code&gt;IXmlConvertable&lt;/code&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// A new &lt;code&gt;IXmlConvertable&lt;/code&gt; object 
+		/// &lt;/returns&gt;
+		object FromXmlElement(XmlElement element);
+		
+		/// &lt;summary&gt;
+		/// Converts the &lt;code&gt;IXmlConvertable&lt;/code&gt; object to a &lt;code&gt;XmlElement&lt;/code&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// A new &lt;code&gt;XmlElement&lt;/code&gt; object which represents the state
+		/// of the &lt;code&gt;IXmlConvertable&lt;/code&gt; object.
+		/// &lt;/returns&gt;
+		XmlElement ToXmlElement(XmlDocument doc);
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/Makefile.am
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/Makefile.am	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/Makefile.am	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,44 @@
+servicesdir = $(libdir)/monodevelop
+servicesassembly = $(servicesdir)/services.dll
+services_DATA = services.dll
+plugindir = $(monodevelop_plugin_dir)
+plugin_DATA = services.plugin
+CLEANFILES = services.dll services.plugin
+CSC = mcs
+
+services_sources = \
+	AbstractService.cs \
+	DefaultProperties.cs \
+	FileUtilityService.cs \
+	IMessageService.cs \
+	IProperties.cs \
+	IResourceService.cs \
+	IService.cs \
+	IStringTagProvider.cs \
+	IXmlConvertable.cs \
+	PropertyEventArgs.cs \
+	PropertyFileLoadException.cs \
+	PropertyService.cs \
+	ResourceNotFoundException.cs \
+	ResourceService.cs \
+	ServiceManager.cs \
+	ServicesPlugin.cs \
+	StringParserService.cs \
+	UnknownPropertyNodeException.cs
+
+services_assemblies = \
+	-r:../../StartUp/monodevelop.exe \
+	-r:log4net.dll \
+	-r:gtk-sharp.dll \
+	-r:gdk-sharp.dll \
+	-r:glib-sharp.dll
+
+services.dll: $(services_sources)
+	$(CSC) -debug -t:library -out:services.dll $(services_sources) $(services_assemblies)
+
+services.plugin: services.plugin.in
+	sed -e 's^\@assembly\@^$(servicesassembly)^g' &lt; $(srcdir)/services.plugin.in &gt; services.plugin
+
+EXTRA_DIST = \
+	$(services_sources) \
+	services.plugin.in

Added: branches/MonoDevelop-playground/src/Plugins/Services/PropertyEventArgs.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/PropertyEventArgs.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/PropertyEventArgs.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,65 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	public delegate void PropertyEventHandler(object sender, PropertyEventArgs e);
+	
+	public class PropertyEventArgs : EventArgs
+	{
+		IProperties properties;
+		string      key;
+		object      newValue;
+		object      oldValue;
+		
+		/// &lt;returns&gt;
+		/// returns the changed property object
+		/// &lt;/returns&gt;
+		public IProperties Properties {
+			get {
+				return properties;
+			}
+		}
+		
+		/// &lt;returns&gt;
+		/// The key of the changed property
+		/// &lt;/returns&gt;
+		public string Key {
+			get {
+				return key;
+			}
+		}
+		
+		/// &lt;returns&gt;
+		/// The new value of the property
+		/// &lt;/returns&gt;
+		public object NewValue {
+			get {
+				return newValue;
+			}
+		}
+		
+		/// &lt;returns&gt;
+		/// The new value of the property
+		/// &lt;/returns&gt;
+		public object OldValue {
+			get {
+				return oldValue;
+			}
+		}
+		
+		public PropertyEventArgs(IProperties properties, string key, object oldValue, object newValue)
+		{
+			this.properties = properties;
+			this.key        = key;
+			this.oldValue   = oldValue;
+			this.newValue   = newValue;
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/PropertyFileLoadException.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/PropertyFileLoadException.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/PropertyFileLoadException.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,21 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// Is thrown when no property file could be loaded.
+	/// &lt;/summary&gt;
+	public class PropertyFileLoadException : Exception
+	{
+		public PropertyFileLoadException() : base(&quot;couldn't load global property file&quot;)
+		{
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/PropertyService.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/PropertyService.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/PropertyService.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,164 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Diagnostics;
+using System.Text;
+using System.Xml;
+using System.Reflection;
+
+namespace MonoDevelop.Services
+{ 
+	/// &lt;summary&gt;
+	/// This class handles the Global Properties for the IDE, all what can be configured should be
+	/// loaded/saved by this class. It is a bit like a Singleton with static delegation instead
+	/// of returning a static reference to a &lt;code&gt;IProperties&lt;/code&gt; object.
+	/// &lt;/summary&gt;
+	public class PropertyService : DefaultProperties, IService
+	{
+		
+		readonly static string propertyFileName    = &quot;MonoDevelopProperties.xml&quot;;
+		readonly static string propertyFileVersion = &quot;1.1&quot;;
+		
+		readonly static string propertyXmlRootNodeName  = &quot;SharpDevelopProperties&quot;;
+		
+		static string dataDirectory;
+		
+		static PropertyService()
+		{
+			string confDataDirectory = System.Configuration.ConfigurationSettings.AppSettings[&quot;DataDirectory&quot;];
+			
+			if (confDataDirectory != null) {
+				dataDirectory = confDataDirectory;
+			} else {
+				dataDirectory = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location) + 
+				                                       Path.DirectorySeparatorChar + &quot;..&quot; +
+				                                       Path.DirectorySeparatorChar + &quot;data&quot;;
+			}
+
+			configDirectory = Environment.GetEnvironmentVariable (&quot;XDG_CONFIG_HOME&quot;);
+			if (configDirectory == null || configDirectory == &quot;&quot;)
+				configDirectory = System.IO.Path.Combine (Environment.GetEnvironmentVariable (&quot;HOME&quot;), &quot;.config&quot;);
+
+			configDirectory = System.IO.Path.Combine (configDirectory, &quot;MonoDevelop&quot;);
+			configDirectory += System.IO.Path.DirectorySeparatorChar;
+		}
+
+		static string configDirectory;
+		/// &lt;summary&gt;
+		/// returns the path of the default application configuration directory
+		/// &lt;/summary&gt;
+		public string ConfigDirectory {
+			get {
+				return configDirectory;
+			}
+		}
+		
+		public string DataDirectory {
+			get {
+				return dataDirectory;
+			}
+		}
+		
+		public PropertyService()
+		{
+			try {
+				LoadProperties();
+			} catch (PropertyFileLoadException) {
+				//System.Windows.Forms.MessageBox.Show(&quot;Can't load property file&quot;, &quot;Warning&quot;); // don't use message service --&gt; cyclic dependency
+			}
+		}
+		
+		void WritePropertiesToFile(string fileName)
+		{
+			XmlDocument doc = new XmlDocument();
+			doc.LoadXml(&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;&quot; + propertyXmlRootNodeName + &quot; fileversion = \&quot;&quot; + propertyFileVersion + &quot;\&quot; /&gt;&quot;);
+			
+			doc.DocumentElement.AppendChild(ToXmlElement(doc));
+			
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+			fileUtilityService.ObservedSave(new NamedFileOperationDelegate(doc.Save), fileName, FileErrorPolicy.ProvideAlternative);
+		}
+		
+		bool LoadPropertiesFromStream(string filename)
+		{
+			try {
+				XmlDocument doc = new XmlDocument();
+				doc.Load(filename);
+				
+				if (doc.DocumentElement.Attributes[&quot;fileversion&quot;].InnerText != propertyFileVersion) {
+					return false;
+				}
+				SetValueFromXmlElement(doc.DocumentElement[&quot;Properties&quot;]);
+			} catch (Exception e) {
+				//Console.WriteLine(&quot;Exception while load properties from stream :\n &quot; + e.ToString());
+				return false;
+			}
+			return true;
+		}
+		
+		/// &lt;summary&gt;
+		/// Loads the global properties from the current users application data folder, or
+		/// if it doesn't exists or couldn't read them it reads the default properties out
+		/// of the application folder.
+		/// &lt;/summary&gt;
+		/// &lt;exception cref=&quot;PropertyFileLoadException&quot;&gt;
+		/// Is thrown when no property file could be loaded.
+		/// &lt;/exception&gt;
+		void LoadProperties()
+		{
+			if (!Directory.Exists(configDirectory)) {
+				Directory.CreateDirectory(configDirectory);
+			}
+			
+			if (!LoadPropertiesFromStream(configDirectory + propertyFileName)) {
+				if (!LoadPropertiesFromStream(DataDirectory + Path.DirectorySeparatorChar + &quot;options&quot; + Path.DirectorySeparatorChar + propertyFileName)) {
+					throw new PropertyFileLoadException();
+				}
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// Saves the current global property state to a file in the users application data folder.
+		/// &lt;/summary&gt;
+		public void SaveProperties()
+		{
+			WritePropertiesToFile(configDirectory + propertyFileName);
+		}
+		
+		// IService implementation:
+		public virtual void InitializeService()
+		{
+			OnInitialize(EventArgs.Empty);
+		}
+		
+		public virtual void UnloadService()
+		{
+			// save properties on exit
+			SaveProperties();
+			OnUnload(EventArgs.Empty);
+		}
+		
+		protected virtual void OnInitialize(EventArgs e)
+		{
+			if (Initialize != null) {
+				Initialize(this, e);
+			}
+		}
+		
+		protected virtual void OnUnload(EventArgs e)
+		{
+			if (Unload != null) {
+				Unload(this, e);
+			}
+		}
+		
+		public event EventHandler Initialize;
+		public event EventHandler Unload;			
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/ResourceNotFoundException.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/ResourceNotFoundException.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/ResourceNotFoundException.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,22 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// Is thrown when the GlobalResource manager can't find a requested
+	/// resource.
+	/// &lt;/summary&gt;
+	public class ResourceNotFoundException : Exception
+	{
+		public ResourceNotFoundException(string resource) : base(&quot;Resource not found : &quot; + resource)
+		{
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/ResourceService.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/ResourceService.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/ResourceService.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,376 @@
+&#65279;// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//   license.txt&quot;/&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Threading;
+using System.Resources;
+using System.Diagnostics;
+using System.Reflection;
+using System.Xml;
+using System.Runtime.InteropServices;
+
+using Gdk;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// This Class contains two ResourceManagers, which handle string and image resources
+	/// for the application. It do handle localization strings on this level.
+	/// &lt;/summary&gt;
+	public class ImageButton : Gtk.Button
+	{
+		public ImageButton (string stock, string label)
+		{
+			Gtk.HBox hbox1 = new Gtk.HBox(false,0);
+			hbox1.PackStart(new Gtk.Image(stock, Gtk.IconSize.Button), false, true, 0);
+			hbox1.PackStart(new Gtk.Label(label), true, true, 0);
+			this.Add(hbox1);
+		}
+	}
+	
+	public class ResourceService : AbstractService, IResourceService
+	{
+		readonly static string uiLanguageProperty = &quot;CoreProperties.UILanguage&quot;;
+		
+		readonly static string stringResources  = &quot;StringResources&quot;;
+		readonly static string imageResources   = &quot;BitmapResources&quot;;
+		
+		static string resourceDirctory;
+		
+		static ResourceService()
+		{
+			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+			resourceDirctory = propertyService.DataDirectory + Path.DirectorySeparatorChar + &quot;resources&quot;;
+
+			iconFactory = new Gtk.IconFactory ();
+
+			// FIXME: remove this when all MonoDevelop is using Gtk+
+			// stock icons
+			stockMappings = new Hashtable ();
+			//MonoDevelop.Gui.Stock.Init ();
+			iconFactory.AddDefault ();
+		}
+		
+		Hashtable userStrings = null;
+		Hashtable userIcons   = null;
+		
+		ResourceManager strings = null;
+		ResourceManager icon    = null;
+		
+		Hashtable localStrings = null;
+		Hashtable localIcons   = null;
+		
+		void ChangeProperty(object sender, PropertyEventArgs e)
+		{
+			if (e.Key == uiLanguageProperty &amp;&amp; e.OldValue != e.NewValue) {
+				LoadLanguageResources();
+			} 
+		}
+		
+		void LoadLanguageResources()
+		{
+			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+			string language = propertyService.GetProperty(uiLanguageProperty, Thread.CurrentThread.CurrentUICulture.Name);
+			
+			localStrings = Load(stringResources, language);
+			if (localStrings == null &amp;&amp; language.IndexOf('-') &gt; 0) {
+				localStrings = Load(stringResources, language.Split(new char[] {'-'})[0]);
+			}
+			
+			localIcons = Load(imageResources, language);
+			if (localIcons == null &amp;&amp; language.IndexOf('-') &gt; 0) {
+				localIcons = Load(imageResources, language.Split(new char[] {'-'})[0]);
+			}
+		}
+		
+		public override void InitializeService()
+		{
+			base.InitializeService();
+			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+			propertyService.PropertyChanged += new PropertyEventHandler(ChangeProperty);
+			
+			LoadLanguageResources();
+		}
+		
+		// core service : Can't use Initialize, because all other stuff needs this service before initialize is called.
+		public ResourceService()
+		{
+			strings = new ResourceManager(stringResources, Assembly.GetCallingAssembly());
+			icon    = new ResourceManager(imageResources,  Assembly.GetCallingAssembly());
+			
+			if (System.Configuration.ConfigurationSettings.AppSettings[&quot;UserStrings&quot;] != null) {
+				userStrings = Load(resourceDirctory +  Path.DirectorySeparatorChar + System.Configuration.ConfigurationSettings.AppSettings[&quot;UserStrings&quot;]);
+			}
+			if (System.Configuration.ConfigurationSettings.AppSettings[&quot;UserIcons&quot;] != null) {
+				userIcons   = Load(resourceDirctory +  Path.DirectorySeparatorChar + System.Configuration.ConfigurationSettings.AppSettings[&quot;UserIcons&quot;]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// The LoadFont routines provide a safe way to load fonts.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
+		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// The font to load or the menu font, if the requested font couldn't be loaded.
+		/// &lt;/returns&gt;
+		/*public Font LoadFont(string fontName, int size)
+		{
+			return LoadFont(fontName, size, FontStyle.Regular);
+		}*/
+		
+		/// &lt;summary&gt;
+		/// The LoadFont routines provide a safe way to load fonts.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
+		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
+		/// &lt;param name=&quot;style&quot;&gt;The &lt;see cref=&quot;System.Drawing.FontStyle&quot;/&gt; of the font&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// The font to load or the menu font, if the requested font couldn't be loaded.
+		/// &lt;/returns&gt;
+		/*public Font LoadFont(string fontName, int size, FontStyle style)
+		{
+			try {
+				return new Font(fontName, size, style);
+			} catch (Exception) {
+				//return SystemInformation.MenuFont;
+				return null;
+			}
+		}*/
+		
+		/// &lt;summary&gt;
+		/// The LoadFont routines provide a safe way to load fonts.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
+		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
+		/// &lt;param name=&quot;unit&quot;&gt;The &lt;see cref=&quot;System.Drawing.GraphicsUnit&quot;/&gt; of the font&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// The font to load or the menu font, if the requested font couldn't be loaded.
+		/// &lt;/returns&gt;
+		/*public Font LoadFont(string fontName, int size, GraphicsUnit unit)
+		{
+			return LoadFont(fontName, size, FontStyle.Regular, unit);
+		}*/
+		
+		/// &lt;summary&gt;
+		/// The LoadFont routines provide a safe way to load fonts.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
+		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
+		/// &lt;param name=&quot;style&quot;&gt;The &lt;see cref=&quot;System.Drawing.FontStyle&quot;/&gt; of the font&lt;/param&gt;
+		/// &lt;param name=&quot;unit&quot;&gt;The &lt;see cref=&quot;System.Drawing.GraphicsUnit&quot;/&gt; of the font&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// The font to load or the menu font, if the requested font couldn't be loaded.
+		/// &lt;/returns&gt;
+
+		//FIXME: Convert to Pango.FontDescription
+		/*public Font LoadFont(string fontName, int size, FontStyle style, GraphicsUnit unit)
+		{
+			//try {
+				return new Font(fontName, size, style);
+			//} catch (Exception) {
+				//return new Gtk.Label (&quot;-&quot;).Style.FontDescription;
+			//}
+		}*/
+		
+		Hashtable Load(string fileName)
+		{
+			if (File.Exists(fileName)) {
+				Hashtable resources = new Hashtable();
+				ResourceReader rr = new ResourceReader(fileName);
+				foreach (DictionaryEntry entry in rr) {
+					resources.Add(entry.Key, entry.Value);
+				}
+				rr.Close();
+				return resources;
+			}
+			return null;
+		}
+		Hashtable Load(string name, string language)
+		{
+			return Load(resourceDirctory + Path.DirectorySeparatorChar + name + &quot;.&quot; + language + &quot;.resources&quot;);
+			
+		}
+		
+		/// &lt;summary&gt;
+		/// Returns a string from the resource database, it handles localization
+		/// transparent for the user.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The string in the (localized) resource database.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;name&quot;&gt;
+		/// The name of the requested resource.
+		/// &lt;/param&gt;
+		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
+		/// Is thrown when the GlobalResource manager can't find a requested resource.
+		/// &lt;/exception&gt;
+		public string GetString(string name)
+		{
+			if (name.StartsWith (&quot;${&quot;)) {
+				name = name.Substring (6);
+				name = name.Substring (0, name.Length - 1);
+			}
+			if (this.userStrings != null &amp;&amp; this.userStrings[name] != null) {
+				return userStrings[name].ToString();
+			}
+			if (localStrings != null &amp;&amp; localStrings[name] != null) {
+				return localStrings[name].ToString();
+			}
+			
+			string s = strings.GetString(name);
+			
+			if (s == null) {
+				throw new ResourceNotFoundException(&quot;string &gt;&quot; + name + &quot;&lt;&quot;);
+			}
+			
+			return s;
+		}
+		
+		// use P/Invoke to be able to pass some NULL parameters
+		[DllImport(&quot;libgtk-win32-2.0-0.dll&quot;)]
+		static extern IntPtr
+		gtk_icon_set_render_icon (IntPtr raw, IntPtr style, int direction,
+		                          int state, int size, IntPtr widget,
+		                          string detail);
+
+		/// &lt;summary&gt;
+		/// Returns a icon from the resource database, it handles localization
+		/// transparent for the user. In the resource database can be a bitmap
+		/// instead of an icon in the dabase. It is converted automatically.
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The icon in the (localized) resource database.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;name&quot;&gt;
+		/// The name of the requested icon.
+		/// &lt;/param&gt;
+		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
+		/// Is thrown when the GlobalResource manager can't find a requested resource.
+		/// &lt;/exception&gt;
+
+		public Gdk.Pixbuf GetIcon (string name)
+		{
+			return GetIcon (name, Gtk.IconSize.Button);
+		}
+		
+		public Gdk.Pixbuf GetIcon (string name, Gtk.IconSize size)
+		{
+			string stockid = GetStockId (name);
+			if (stockid != null) {
+				Gtk.IconSet iconset = Gtk.IconFactory.LookupDefault (stockid);
+				if (iconset != null) {
+					// use P/Invoke to be able to pass some NULL parameters
+					IntPtr raw_ret = gtk_icon_set_render_icon
+						(iconset.Handle,
+						 Gtk.Widget.DefaultStyle.Handle,
+						 (int) Gtk.TextDirection.None,
+						 (int) Gtk.StateType.Normal,
+						 (int) size,
+						 IntPtr.Zero, null);
+					return (Gdk.Pixbuf) GLib.Object.GetObject(raw_ret);
+				}
+			}
+			
+			// throw GLib.GException as the old code?
+			return null;
+		}
+		
+		/// &lt;summary&gt;
+		/// Returns a bitmap from the resource database, it handles localization
+		/// transparent for the user. 
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;
+		/// The bitmap in the (localized) resource database.
+		/// &lt;/returns&gt;
+		/// &lt;param name=&quot;name&quot;&gt;
+		/// The name of the requested bitmap.
+		/// &lt;/param&gt;
+		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
+		/// Is thrown when the GlobalResource manager can't find a requested resource.
+		/// &lt;/exception&gt;
+
+		public Gdk.Pixbuf GetBitmap (string name)
+		{
+			return GetBitmap (name, Gtk.IconSize.Button);
+		}
+
+		public Gdk.Pixbuf GetBitmap(string name, Gtk.IconSize size)
+		{
+			// Try stock icons first
+			Gdk.Pixbuf pix = GetIcon (name, size);
+			if (pix == null) {
+				// Try loading directly from disk then
+				pix = new Gdk.Pixbuf(&quot;../data/resources/icons/&quot; + name);
+			}
+			return pix;
+		}
+
+		public Gtk.Image GetImage (string name, Gtk.IconSize size)
+		{
+			string stock = GetStockId (name);
+			if (stock != null)
+				return new Gtk.Image (stock, size);
+			return new Gtk.Image (GetBitmap (name));
+		}
+		
+		static Gtk.IconFactory iconFactory = null;
+		static Hashtable stockMappings = null;
+
+		internal static void AddToIconFactory (string stockId,
+		                                       string filename,
+						       Gtk.IconSize iconSize)
+		{
+			try {
+				Gtk.IconSet iconSet = iconFactory.Lookup (stockId);
+				if (iconSet == null) {
+					iconSet = new Gtk.IconSet ();
+					iconFactory.Add (stockId, iconSet);
+				}
+
+				Gtk.IconSource source = new Gtk.IconSource ();
+				source.Filename = Path.GetFullPath (Path.Combine (&quot;../data/resources/icons&quot;, filename));
+				source.Size = iconSize;
+				iconSet.AddSource (source);
+
+				// FIXME: temporary hack to retrieve the correct icon
+				// from the filename
+				stockMappings.Add (filename, stockId);
+			}
+			catch (GLib.GException ex) {
+				// just discard the exception, the icon simply can't be
+				// loaded
+				Console.WriteLine (&quot;Warning: can't load &quot; + filename +
+				                   &quot; icon file&quot;);
+			}
+		}
+
+		internal static void AddToIconFactory (string stockId, string filename)
+		{
+			AddToIconFactory (stockId, filename, Gtk.IconSize.Invalid);
+		}
+		
+		internal static void AddDefaultStockMapping (string stockFile, string nativeStock)
+		{
+			stockMappings.Add (stockFile, nativeStock);
+		}
+
+		public static string GetStockId (string filename)
+		{
+			string s = (string) stockMappings [filename];
+			
+			if (s != null)
+				return s;
+			
+			Console.WriteLine (&quot;WARNING Could not find stock {0}&quot;, filename);
+			
+			return filename;
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/ServiceManager.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/ServiceManager.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/ServiceManager.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,128 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Threading;
+using System.Resources;
+using System.Diagnostics;
+using System.Reflection;
+using System.Xml;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// This class does basic service handling for you.
+	/// &lt;/summary&gt;
+	public class ServiceManager
+	{
+		ArrayList serviceList       = new ArrayList();
+		Hashtable servicesHashtable = new Hashtable();
+		
+		static ServiceManager defaultServiceManager = new ServiceManager();
+		
+		/// &lt;summary&gt;
+		/// Gets the default ServiceManager
+		/// &lt;/summary&gt;
+		public static ServiceManager Services {
+			get {
+				return defaultServiceManager;
+			}
+		}		
+		
+		/// &lt;summary&gt;
+		/// Don't create ServiceManager objects, only have ONE per application.
+		/// &lt;/summary&gt;
+		private ServiceManager()
+		{
+			// add 'core' services
+			AddService(new PropertyService());
+			AddService(new StringParserService());
+			AddService(new FileUtilityService());
+		}
+		
+		/// &lt;remarks&gt;
+		/// This method initializes the service system to a path inside the add-in tree.
+		/// This method must be called ONCE.
+		/// &lt;/remarks&gt;
+		public void InitializeServicesSubsystem(string servicesPath)
+		{
+			// add add-in tree services
+			//AddServices((IService[])AddInTreeSingleton.AddInTree.GetTreeNode(servicesPath).BuildChildItems(this).ToArray(typeof(IService)));
+			
+			// initialize all services
+			foreach (IService service in serviceList) {
+				DateTime now = DateTime.Now;
+				service.InitializeService();
+			}
+		}
+		
+		/// &lt;remarks&gt;
+		/// Calls UnloadService on all services. This method must be called ONCE.
+		/// &lt;/remarks&gt;
+		public void UnloadAllServices()
+		{
+			foreach (IService service in serviceList) {
+				service.UnloadService();
+			}
+		}
+		
+		public void AddService(IService service)
+		{
+			serviceList.Add(service);
+		}
+		
+		public void AddServices(IService[] services)
+		{
+			foreach (IService service in services) {
+				AddService(service);
+			}
+		}
+		
+		// HACK: MONO BUGFIX
+		// this doesn't work on mono:serviceType.IsInstanceOfType(service)
+		bool IsInstanceOfType(Type type, IService service)
+		{
+			Type serviceType = service.GetType();
+
+			foreach (Type iface in serviceType.GetInterfaces()) {
+				if (iface == type) {
+					return true;
+				}
+			}
+			
+			while (serviceType != typeof(System.Object)) {
+				if (type == serviceType) {
+					return true;
+				}
+				serviceType = serviceType.BaseType;
+			}
+			return false;
+		}
+		
+		/// &lt;remarks&gt;
+		/// Requestes a specific service, may return null if this service is not found.
+		/// &lt;/remarks&gt;
+		public IService GetService(Type serviceType)
+		{
+			IService s = (IService)servicesHashtable[serviceType];
+			if (s != null) {
+				return s;
+			}
+			
+			foreach (IService service in serviceList) {
+				if (IsInstanceOfType(serviceType, service)) {
+					servicesHashtable[serviceType] = service;
+					return service;
+				}
+			}
+			
+			return null;
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/ServicesPlugin.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/ServicesPlugin.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/ServicesPlugin.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,63 @@
+//
+// ServicesPlugin.cs: Registers the Services class with the plugin loader.
+//
+// Author:
+//   Jeroen Zwartepoorte &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
+//
+// (C) Copyright Jeroen Zwartepoorte 2004
+//
+
+using System;
+using Gtk;
+using log4net;
+
+namespace MonoDevelop.Services {
+	class ServicesPlugin : BasePlugin {
+		private static readonly ILog log = LogManager.GetLogger (typeof (ServicesPlugin));
+	
+		public override string Author {
+			get {
+				return &quot;Jeroen Zwartepoorte&quot;;
+			}
+		}
+		
+		public override string Copyright {
+			get {
+				return &quot;GPL&quot;;
+			}
+		}
+		
+		public override string Description {
+			get {
+				return &quot;Core services used in MonoDevelop&quot;;
+			}
+		}
+		
+		public override string Name {
+			get {
+				return &quot;Services&quot;;
+			}
+		}
+		
+		public override string Url {
+			get {
+				return &quot;<A HREF="http://www.xs4all.nl/~jeroen/&quot;;">http://www.xs4all.nl/~jeroen/&quot;;</A>
+			}
+		}
+		
+		public override string Version {
+			get {
+				return &quot;1.0&quot;;
+			}
+		}
+	
+		public override bool InitializePlugin (byte major, byte minor)
+		{
+			return true;
+		}
+		
+		public override void FinalizePlugin ()
+		{
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/StringParserService.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/StringParserService.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/StringParserService.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,213 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// this class parses internal ${xyz} tags of sd.
+	/// All environment variables are avaible under the name env.[NAME]
+	/// where [NAME] represents the string under which it is avaiable in
+	/// the environment.
+	/// &lt;/summary&gt;
+	public class StringParserService : AbstractService
+	{
+		PropertyDictionary properties         = new PropertyDictionary();
+		Hashtable          stringTagProviders = new Hashtable();
+		
+		public PropertyDictionary Properties {
+			get {
+				return properties;
+			}
+		}
+		
+		public StringParserService()
+		{
+			IDictionary variables = Environment.GetEnvironmentVariables();
+			foreach (string name in variables.Keys) {
+				properties.Add(&quot;env:&quot; + name, (string)variables[name]);
+			}
+		}
+		
+		public string Parse(string input)
+		{
+			return Parse(input, null);
+		}
+		
+		/// &lt;summary&gt;
+		/// Parses an array and replaces the elements
+		/// &lt;/summary&gt;
+		public void Parse(ref string[] inputs)
+		{
+			for (int i = inputs.GetLowerBound(0); i &lt;= inputs.GetUpperBound(0); ++i) {
+				inputs[i] = Parse(inputs[i], null);
+			}
+		}
+		
+		public void RegisterStringTagProvider(IStringTagProvider tagProvider)
+		{
+			foreach (string str in tagProvider.Tags) {
+				stringTagProviders[str.ToUpper()] = tagProvider;
+			}
+		}
+		
+		string Replace (string[,] customTags, string propertyName)
+		{
+			string propertyValue = null;
+			switch (propertyName.ToUpper()) {
+				case &quot;DATE&quot;: // current date
+					propertyValue = DateTime.Today.ToShortDateString();
+					break;
+				case &quot;TIME&quot;: // current time
+					propertyValue = DateTime.Now.ToShortTimeString();
+					break;
+				default:
+					propertyValue = null;
+					if (customTags != null) {
+						for (int j = 0; j &lt; customTags.GetLength(0); ++j) {
+							if (propertyName.ToUpper() == customTags[j, 0].ToUpper()) {
+								propertyValue = customTags[j, 1];
+								break;
+							}
+						}
+					}
+					
+					if (propertyValue == null) {
+						propertyValue = properties[propertyName.ToUpper()];
+					}
+					
+					if (propertyValue == null) {
+						IStringTagProvider stringTagProvider = stringTagProviders[propertyName.ToUpper()] as IStringTagProvider;
+						if (stringTagProvider != null) {
+							propertyValue = stringTagProvider.Convert(propertyName.ToUpper());
+						}
+					}
+					
+					if (propertyValue == null) {
+						int k = propertyName.IndexOf(':');
+						if (k &gt; 0) {
+							switch (propertyName.Substring(0, k).ToUpper()) {
+								case &quot;RES&quot;:
+									IResourceService resourceService = (IResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+									if (resourceService != null) {
+											propertyValue = Parse(resourceService.GetString(propertyName.Substring(k + 1)), customTags);
+									}
+									break;
+								case &quot;PROPERTY&quot;:
+									PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+									propertyValue = propertyService.GetProperty(propertyName.Substring(k + 1)).ToString();
+									break;
+							}
+						}
+					}
+					break;
+			}
+			
+			return propertyValue;
+		}
+			
+		/// &lt;summary&gt;
+		/// Expands ${xyz} style property values.
+		/// &lt;/summary&gt;
+		public string Parse(string input, string [,] customTags)
+		{
+			StringBuilder sb = new StringBuilder (input.Length);
+			for (int i = 0; i &lt; input.Length; i++) {
+				if (input [i] != '$') {
+					sb.Append (input [i]);
+					continue;
+				}
+				
+				int start = i;
+				
+				if (++i &gt;= input.Length)
+					break;
+				
+				if (input [i] != '{') {
+					sb.Append (input [i]);
+					continue;
+				}
+				
+				int end;
+				for (end = ++i; end &lt; input.Length; end++) {
+					if (input [end] == '}')
+						break;
+				}
+				
+				string replacement;
+				if (end == input.Length || (replacement = Replace (customTags, input.Substring (i, end - i))) == null) {
+					sb.Append (input.Substring (start, end - start));
+					break;
+				}
+				
+				sb.Append (replacement);
+				i = end;
+			}
+			
+			sb.Replace (@&quot;\&amp;&quot;, &quot;||!|&quot;);
+			sb.Replace (&quot;&amp;&quot;, &quot;_&quot;);
+			sb.Replace (&quot;||!|&quot;, &quot;&amp;&quot;);
+			
+			return sb.ToString ();
+		}
+	}
+	
+	public class PropertyDictionary : DictionaryBase
+	{
+		/// &lt;summary&gt;
+		/// Maintains a list of the property names that are readonly.
+		/// &lt;/summary&gt;
+		StringCollection readOnlyProperties = new StringCollection();
+		
+		/// &lt;summary&gt;
+		/// Adds a property that cannot be changed.
+		/// &lt;/summary&gt;
+		/// &lt;remarks&gt;
+		/// Properties added with this method can never be changed.  Note that
+		/// they are removed if the &lt;c&gt;Clear&lt;/c&gt; method is called.
+		/// &lt;/remarks&gt;
+		/// &lt;param name=&quot;name&quot;&gt;Name of property&lt;/param&gt;
+		/// &lt;param name=&quot;value&quot;&gt;Value of property&lt;/param&gt;
+		public void AddReadOnly(string name, string value) 
+		{
+			if (!readOnlyProperties.Contains(name)) {
+				readOnlyProperties.Add(name);
+				Dictionary.Add(name, value);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// Adds a property to the collection.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;name&quot;&gt;Name of property&lt;/param&gt;
+		/// &lt;param name=&quot;value&quot;&gt;Value of property&lt;/param&gt;
+		public void Add(string name, string value) 
+		{
+			if (!readOnlyProperties.Contains(name)) {
+				Dictionary.Add(name, value);
+			}
+		}
+		
+		public string this[string name] {
+			get { 
+				return (string)Dictionary[(object)name.ToUpper()];
+			}
+			set {
+				Dictionary[name.ToUpper()] = value;
+			}
+		}
+		
+		protected override void OnClear() 
+		{
+			readOnlyProperties.Clear();
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/UnknownPropertyNodeException.cs
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/UnknownPropertyNodeException.cs	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/UnknownPropertyNodeException.cs	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,21 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// Is thrown when an unknown XmlNode in a property file is encountered.
+	/// &lt;/summary&gt;
+	public class UnknownPropertyNodeException : Exception
+	{
+		public UnknownPropertyNodeException(string nodeName) : base(&quot;unknown XmlNode : &quot; + nodeName)
+		{
+		}
+	}
+}

Added: branches/MonoDevelop-playground/src/Plugins/Services/services.plugin.in
===================================================================
--- branches/MonoDevelop-playground/src/Plugins/Services/services.plugin.in	2004-02-28 23:00:02 UTC (rev 1059)
+++ branches/MonoDevelop-playground/src/Plugins/Services/services.plugin.in	2004-02-29 09:47:46 UTC (rev 1060)
@@ -0,0 +1,5 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;plugin version=&quot;1.0&quot;&gt;
+	&lt;assembly&gt;@assembly@&lt;/assembly&gt;
+	&lt;class name=&quot;MonoDevelop.Services.ServicesPlugin&quot;/&gt;
+&lt;/plugin&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000664.html">[Monodevelop-patches-list] r1059 - trunk/MonoDevelop/gdldock/sources/gdl
</A></li>
	<LI>Next message: <A HREF="000666.html">[Monodevelop-patches-list] r1061 - in branches/MonoDevelop-playground: . gdldock/sources/gdl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#665">[ date ]</a>
              <a href="thread.html#665">[ thread ]</a>
              <a href="subject.html#665">[ subject ]</a>
              <a href="author.html#665">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
