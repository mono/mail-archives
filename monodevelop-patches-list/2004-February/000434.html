<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r829 - trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r829%20-%20trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000433.html">
   <LINK REL="Next"  HREF="000435.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r829 - trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r829%20-%20trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r829 - trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sun Feb  8 20:42:14 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000433.html">[Monodevelop-patches-list] r828 - in trunk/MonoDevelop: . build/AddIns src/AddIns/DisplayBindings/SourceEditor/Gui src/AddIns/DisplayBindings/TextEditor src/Libraries/ICSharpCode.TextEditor src/Main/Core/AddIns
</A></li>
        <LI>Next message: <A HREF="000435.html">[Monodevelop-patches-list] r830 - in trunk/MonoDevelop: . build/AddIns build/AddIns/AddIns/BackendBindings src/AddIns/DisplayBindings/SourceEditor src/AddIns/DisplayBindings/SourceEditor/Codons src/AddIns/DisplayBindings/TextEditor src/AddIns/DisplayBindings/TextEditor/Commands
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#434">[ date ]</a>
              <a href="thread.html#434">[ thread ]</a>
              <a href="subject.html#434">[ subject ]</a>
              <a href="author.html#434">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tberman
Date: 2004-02-08 20:42:14 -0500 (Sun, 08 Feb 2004)
New Revision: 829

Added:
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/CodeActions.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/CommentRegionCommand.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/FoldingCommands.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/FormatCommands.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/ICSharpCode.SharpDevelop.DefaultEditor.Commands.GenerateCodeAction.resources
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/IEditAction.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/ProjectCommands.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/SearchCommands.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/TextAreaContextmenuCommands.cs
   trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/ToolCommands.cs
Log:
blah blah, more cruft


Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/CodeActions.cs (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/CodeActions.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/CodeActions.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/CodeActions.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,1163 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Drawing;
+using System.Drawing.Printing;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Text;
+
+using ICSharpCode.Core.AddIns;
+using ICSharpCode.Core.AddIns.Codons;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.Core.Services;
+
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor.Actions;
+using ICSharpCode.TextEditor;
+using SharpDevelop.Internal.Parser;
+using ICSharpCode.SharpDevelop.Services;
+
+using MonoDevelop.EditorBindings.FormattingStrategy;
+using MonoDevelop.SourceEditor.Gui;
+
+namespace ICSharpCode.SharpDevelop.DefaultEditor.Commands
+{
+	public class GenerateCodeAction : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not ported to the new editor yet&quot;);
+			/*
+			IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			
+			if (window == null || !(window.ViewContent is ITextEditorControlProvider)) {
+				return;
+			}
+			TextEditorControl textEditorControl = ((ITextEditorControlProvider)window.ViewContent).TextEditorControl;
+			
+			IParserService parserService = (IParserService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+			
+			IParseInformation parseInformation = parserService.GetParseInformation(textEditorControl.FileName);
+			
+			if (parseInformation == null) {
+				return;
+			}
+			
+			ICompilationUnit cu = parseInformation.MostRecentCompilationUnit as ICompilationUnit;
+			if (cu == null) {
+				return;
+			}
+			IClass currentClass = GetCurrentClass(textEditorControl, cu, textEditorControl.FileName);
+			
+			if (currentClass != null) {
+				ArrayList categories = new ArrayList();
+				/*using (FormVersion1 form = new FormVersion1(textEditorControl, new CodeGenerator[] {
+					new ConstructorCodeGenerator(currentClass),
+					new GetPropertiesCodeGenerator(currentClass),
+					new SetPropertiesCodeGenerator(currentClass),
+					new GetSetPropertiesCodeGenerator(currentClass),
+					new OnXXXMethodsCodeGenerator(currentClass),
+					new OverrideMethodsCodeGenerator(currentClass),
+					new InterfaceImplementorCodeGenerator(currentClass),
+					new AbstractClassImplementorCodeGenerator(currentClass)
+				})) {
+					form.ShowDialog();
+				}*/
+			}
+		}
+		
+		/// &lt;remarks&gt;
+		/// Returns the class in which the carret currently is, returns null
+		/// if the carret is outside the class boundaries.
+		/// &lt;/remarks&gt;
+		/*IClass GetCurrentClass(TextEditorControl textEditorControl, ICompilationUnit cu, string fileName)
+		{
+			
+			IDocument document = textEditorControl.Document;
+			if (cu != null) {
+				int caretLineNumber = document.GetLineNumberForOffset(textEditorControl.ActiveTextAreaControl.Caret.Offset) + 1;
+				int caretColumn     = textEditorControl.ActiveTextAreaControl.Caret.Offset - document.GetLineSegment(caretLineNumber - 1).Offset + 1;
+				
+				foreach (IClass c in cu.Classes) {
+					if (c.Region.IsInside(caretLineNumber, caretColumn)) {
+						return c;
+					}
+				}
+			}
+			return null;
+		}*/
+	}
+	
+	public class SurroundCodeAction : AbstractEditAction
+	{
+		public override void Execute(SourceEditorView editActionHandler)
+		{
+//			SelectionWindow selectionWindow = new SelectionWindow(&quot;Surround&quot;);
+//			selectionWindow.Show();
+		}
+	}
+	
+	/// &lt;summary&gt;
+	///     Add summary description for form
+	/// &lt;/summary&gt;
+	/*
+	public class FormVersion1 //: Form
+	{
+		//private System.Windows.Forms.ColumnHeader createdObject0;
+		//private System.Windows.Forms.ListView categoryListView;
+		//private System.Windows.Forms.Label statusLabel;
+		//private System.Windows.Forms.CheckedListBox selectionListBox;
+		
+		
+		TextEditorControl textEditorControl;
+		
+		CodeGenerator SelectedCodeGenerator {
+			get {
+				if (categoryListView.SelectedItems.Count != 1) {
+					return null;
+				}
+				return (CodeGenerator)categoryListView.SelectedItems[0].Tag;
+				return null;
+			}
+		}
+		
+		public FormVersion1(TextEditorControl textEditorControl, CodeGenerator[] codeGenerators)
+		{
+			this.textEditorControl = textEditorControl;
+			
+			//  Must be called for initialization
+			this.InitializeComponents();
+			
+			Point caretPos  = textEditorControl.ActiveTextAreaControl.Caret.Position;
+			Point visualPos = new Point(textEditorControl.ActiveTextAreaControl.TextArea.TextView.GetDrawingXPos(caretPos.Y, caretPos.X) + textEditorControl.ActiveTextAreaControl.TextArea.TextView.DrawingPosition.X,
+			          (int)((1 + caretPos.Y) * textEditorControl.ActiveTextAreaControl.TextArea.TextView.FontHeight) - textEditorControl.ActiveTextAreaControl.TextArea.VirtualTop.Y - 1 + textEditorControl.ActiveTextAreaControl.TextArea.TextView.DrawingPosition.Y);
+			//Location = textEditorControl.ActiveTextAreaControl.TextArea.PointToScreen(visualPos);  //FIXME:Should we be defining this pedro?
+			//StartPosition   = FormStartPosition.Manual;
+			
+			ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+			//categoryListView.SmallImageList = categoryListView.LargeImageList = classBrowserIconService.ImageList;
+			
+			foreach (CodeGenerator codeGenerator in codeGenerators) {
+				if (codeGenerator.Content.Count &gt; 0) {
+					//ListViewItem newItem = new ListViewItem(codeGenerator.CategoryName);
+					//newItem.ImageIndex = codeGenerator.ImageIndex;
+					//newItem.Tag        = codeGenerator;
+					//categoryListView.Items.Add(newItem);
+				}
+			}
+			
+			//categoryListView.SelectedIndexChanged += new EventHandler(CategoryListViewItemChanged);
+		}
+		protected void OnActivated(EventArgs e)
+		{
+			//base.OnActivated(e);
+			if (categoryListView.Items.Count &gt; 0) {
+				categoryListView.Select();
+				categoryListView.Focus();
+				categoryListView.Items[0].Focused = categoryListView.Items[0].Selected = true;
+			} else {
+				Close();
+			}
+		}
+		
+		protected bool ProcessDialogKey()
+		{
+			
+			switch (keyData) {
+				case Keys.Escape:
+					Close();
+					return true;
+				case Keys.Back:
+					categoryListView.Focus();
+					return true;
+				case Keys.Return:
+					if (categoryListView.Focused) {
+						selectionListBox.Focus();
+					} else {
+						Close();
+						SelectedCodeGenerator.GenerateCode(textEditorControl.ActiveTextAreaControl.TextArea, selectionListBox.CheckedItems.Count &gt; 0 ? (IList)selectionListBox.CheckedItems : (IList)selectionListBox.SelectedItems);
+					}
+					return true;
+			}
+			return base.ProcessDialogKey(keyData);
+			
+			return false;
+		}
+		
+		void CategoryListViewItemChanged(object sender, EventArgs e)
+		{
+			
+			CodeGenerator codeGenerator = SelectedCodeGenerator;
+			if (codeGenerator == null) {
+				return;
+			}
+			statusLabel.Text = codeGenerator.Hint;
+			selectionListBox.BeginUpdate();
+			selectionListBox.Items.Clear();
+			foreach (object o in codeGenerator.Content) {
+				selectionListBox.Items.Add(o);
+			}
+			selectionListBox.SelectedIndex = 0;
+			selectionListBox.EndUpdate();
+			
+		}
+		
+		/// &lt;summary&gt;
+		///   This method was autogenerated - do not change the contents manually
+		/// &lt;/summary&gt;
+		private void InitializeComponents()
+		{
+			
+			// 
+			//  Set up generated class form
+			// 
+			this.SuspendLayout();
+			this.Name = &quot;form&quot;;
+			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
+			this.Size = new System.Drawing.Size(264, 312);
+			this.ShowInTaskbar = false;
+			
+			// 
+			//  Set up member selectionListBox
+			// 
+			selectionListBox = new System.Windows.Forms.CheckedListBox();
+			selectionListBox.Name = &quot;selectionListBox&quot;;
+			selectionListBox.Location = new System.Drawing.Point(0, 128);
+			selectionListBox.Size = new System.Drawing.Size(264, 184);
+			selectionListBox.Dock = System.Windows.Forms.DockStyle.Fill;
+			selectionListBox.TabIndex = 2;
+			this.Controls.Add(selectionListBox);
+			
+			// 
+			//  Set up member statusLabel
+			// 
+			statusLabel = new System.Windows.Forms.Label();
+			statusLabel.Name = &quot;statusLabel&quot;;
+			statusLabel.Text = &quot;Choose fields to generate getters and setters&quot;;
+			statusLabel.TabIndex = 1;
+			statusLabel.Size = new System.Drawing.Size(264, 16);
+			statusLabel.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
+			statusLabel.Location = new System.Drawing.Point(0, 112);
+			statusLabel.Dock = System.Windows.Forms.DockStyle.Top;
+			this.Controls.Add(statusLabel);
+			
+			// 
+			//  Set up member categoryListView
+			// 
+			categoryListView = new System.Windows.Forms.ListView();
+			categoryListView.Name = &quot;categoryListView&quot;;
+			categoryListView.Dock = System.Windows.Forms.DockStyle.Top;
+			categoryListView.TabIndex = 0;
+			categoryListView.View = System.Windows.Forms.View.Details;
+			categoryListView.Size = new System.Drawing.Size(264, 112);
+			categoryListView.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
+			
+			// 
+			//  Set up member createdObject0
+			// 
+			createdObject0 = new System.Windows.Forms.ColumnHeader();
+			createdObject0.Width = 258;
+			categoryListView.Columns.Add(createdObject0);
+			this.Controls.Add(categoryListView);
+			this.ResumeLayout(false);
+			
+		}
+	}
+	*/
+	
+	/*
+	public abstract class CodeGenerator
+	{
+		ArrayList content = new ArrayList();
+		protected int       numOps  = 0;
+		protected IAmbience csa;
+		protected IClass    currentClass = null;
+		//protected TextArea editActionHandler;
+		
+		public CodeGenerator(IClass currentClass)
+		{	
+			try {
+				csa = (IAmbience)AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/Workbench/Ambiences&quot;).BuildChildItem(&quot;CSharp&quot;, this);
+			} catch {
+				Console.WriteLine(&quot;CSharpAmbience not found -- is the C# backend binding loaded???&quot;);
+				return;
+			}
+			
+			this.currentClass = currentClass;
+			csa.ConversionFlags = ConversionFlags.All;
+		}
+		
+		public abstract string CategoryName {
+			get;
+		}
+		public abstract string Hint {
+			get;
+		}
+		public abstract int ImageIndex {
+			get;
+		}
+		
+		public ArrayList Content {
+			get {
+				return content;
+			}
+		}
+		
+		public void GenerateCode(TextArea editActionHandler, IList items)
+		{
+			numOps = 0;
+			this.editActionHandler = editActionHandler;
+			editActionHandler.BeginUpdate();
+			
+			bool save1         = editActionHandler.TextEditorProperties.AutoInsertCurlyBracket;
+			IndentStyle save2  = editActionHandler.TextEditorProperties.IndentStyle;
+			editActionHandler.TextEditorProperties.AutoInsertCurlyBracket = false;
+			editActionHandler.TextEditorProperties.IndentStyle            = IndentStyle.Smart;
+						
+			
+			StartGeneration(items);
+			
+			if (numOps &gt; 0) {
+				editActionHandler.Document.UndoStack.UndoLast(numOps);
+			}
+			// restore old property settings
+			editActionHandler.TextEditorProperties.AutoInsertCurlyBracket = save1;
+			editActionHandler.TextEditorProperties.IndentStyle            = save2;
+			editActionHandler.EndUpdate();
+			
+			editActionHandler.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
+			editActionHandler.Document.CommitUpdate();
+		}
+		
+		protected abstract void StartGeneration(IList items);
+		
+		protected void Return()
+		{
+			IndentLine();
+			new Return().Execute(editActionHandler);++numOps;
+		}
+		
+		protected void IndentLine()
+		{
+			int delta = editActionHandler.Document.FormattingStrategy.IndentLine(editActionHandler.Document, editActionHandler.Document.GetLineNumberForOffset(editActionHandler.Caret.Offset));
+			if (delta != 0) {
+				++numOps;
+				LineSegment caretLine = editActionHandler.Document.GetLineSegmentForOffset(editActionHandler.Caret.Offset);
+				editActionHandler.Caret.Position = editActionHandler.Document.OffsetToPosition(Math.Min(editActionHandler.Caret.Offset + delta, caretLine.Offset + caretLine.Length));
+			}
+		}
+	}
+	*/
+
+	/*
+	public abstract class FieldCodeGenerator : CodeGenerator
+	{
+		public FieldCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+			foreach (IField field in currentClass.Fields) {
+				Content.Add(new FieldWrapper(field));
+			}
+		}
+		
+		public class FieldWrapper
+		{
+			IField field;
+			
+			public IField Field {
+				get {
+					return field;
+				}
+			}
+			
+			public FieldWrapper(IField field)
+			{
+				this.field = field;
+			}
+			
+			public override string ToString()
+			{
+				AmbienceService ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
+				return ambienceService.CurrentAmbience.Convert(field);
+			}
+		}
+	}
+	
+	public class ConstructorCodeGenerator : FieldCodeGenerator
+	{
+		public override string CategoryName {
+			get {
+				return &quot;Constructor&quot;;
+			}
+		}
+		
+		public override  string Hint {
+			get {
+				return &quot;Choose fields to initialize by constructor&quot;;
+			}
+		}
+		
+		public override int ImageIndex {
+			get {
+				ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+				return classBrowserIconService.MethodIndex;
+			}
+		}
+		
+		public ConstructorCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+		}
+		
+		protected override void StartGeneration(IList items)
+		{
+			editActionHandler.InsertString(&quot;public &quot; + currentClass.Name + &quot;(&quot;);
+			++numOps;
+			
+			for (int i = 0; i &lt; items.Count; ++i) {
+				FieldWrapper fw = (FieldWrapper)items[i];
+				editActionHandler.InsertString(csa.Convert(fw.Field.ReturnType) + &quot; &quot; + fw.Field.Name);
+				++numOps;
+				if (i + 1 &lt; items.Count) {
+					editActionHandler.InsertString(&quot;, &quot;);
+					++numOps;
+				}
+			}
+			
+			editActionHandler.InsertChar(')');++numOps;
+			Return();
+			editActionHandler.InsertChar('{');++numOps;
+			Return();
+			
+			for (int i = 0; i &lt; items.Count; ++i) {
+				FieldWrapper fw = (FieldWrapper)items[i];
+				editActionHandler.InsertString(&quot;this.&quot; + fw.Field.Name + &quot; = &quot; + fw.Field.Name + &quot;;&quot;);++numOps;
+				Return();
+			}
+			editActionHandler.InsertChar('}');++numOps;
+			Return();
+			IndentLine();
+		}
+	}
+	
+	public abstract class PropertiesCodeGenerator : FieldCodeGenerator
+	{
+		
+		public PropertiesCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+		}
+		
+		public override int ImageIndex {
+			get {
+				ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+				return classBrowserIconService.PropertyIndex;
+			}
+		}
+		
+		protected override void StartGeneration(IList items)
+		{
+			for (int i = 0; i &lt; items.Count; ++i) {
+				FieldWrapper fw = (FieldWrapper)items[i];
+				
+				editActionHandler.InsertString(&quot;public &quot; + (fw.Field.IsStatic ? &quot;static &quot; : &quot;&quot;) + csa.Convert(fw.Field.ReturnType) + &quot; &quot; + Char.ToUpper(fw.Field.Name[0]) + fw.Field.Name.Substring(1) + &quot; {&quot;);++numOps;
+				Return();
+				
+				GeneratePropertyBody(editActionHandler, fw);
+				
+				editActionHandler.InsertChar('}');++numOps;
+				Return();
+				IndentLine();
+			}
+		}
+		
+		protected void GenerateGetter(TextArea editActionHandler, FieldWrapper fw)
+		{
+			editActionHandler.InsertString(&quot;get {&quot;);++numOps;
+			Return();
+			
+			editActionHandler.InsertString(&quot;return &quot; + fw.Field.Name+ &quot;;&quot;);++numOps;
+			Return();
+			
+			editActionHandler.InsertChar('}');++numOps;
+			Return();
+		}
+		
+		protected void GenerateSetter(TextArea editActionHandler, FieldWrapper fw)
+		{
+			editActionHandler.InsertString(&quot;set {&quot;);++numOps;
+			Return();
+			
+			editActionHandler.InsertString(fw.Field.Name+ &quot; = value;&quot;);++numOps;
+			Return();
+			
+			editActionHandler.InsertChar('}');++numOps;
+			Return();
+		}
+		
+		protected abstract void GeneratePropertyBody(TextArea editActionHandler, FieldWrapper fw);
+	}*/
+
+	/*
+	
+	public class GetPropertiesCodeGenerator : PropertiesCodeGenerator
+	{
+		public override string CategoryName {
+			get {
+				return &quot;Getter&quot;;
+			}
+		}
+		
+		public override  string Hint {
+			get {
+				return &quot;Choose fields to generate getters&quot;;
+			}
+		}
+		
+		public GetPropertiesCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+		}
+		
+		protected override void GeneratePropertyBody(TextArea editActionHandler, FieldWrapper fw)
+		{
+			GenerateGetter(editActionHandler, fw);
+		}
+	}
+	
+	public class SetPropertiesCodeGenerator : PropertiesCodeGenerator
+	{
+		public override string CategoryName {
+			get {
+				return &quot;Setter&quot;;
+			}
+		}
+		
+		public override  string Hint {
+			get {
+				return &quot;Choose fields to generate setters&quot;;
+			}
+		}
+		
+		public SetPropertiesCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+		}
+		
+		protected override void GeneratePropertyBody(TextArea editActionHandler, FieldWrapper fw)
+		{
+			GenerateSetter(editActionHandler, fw);
+		}
+	}
+	
+	public class GetSetPropertiesCodeGenerator : PropertiesCodeGenerator
+	{
+		public override string CategoryName {
+			get {
+				return &quot;Getter and Setter&quot;;
+			}
+		}
+		
+		public override  string Hint {
+			get {
+				return &quot;Choose fields to generate getters and setters&quot;;
+			}
+		}
+		
+		public GetSetPropertiesCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+		}
+		protected override void GeneratePropertyBody(TextArea editActionHandler, FieldWrapper fw)
+		{
+			GenerateGetter(editActionHandler, fw);
+			GenerateSetter(editActionHandler, fw);
+		}
+	}
+	
+	public class OnXXXMethodsCodeGenerator : CodeGenerator
+	{
+		public override string CategoryName {
+			get {
+				return &quot;Event OnXXX methods&quot;;
+			}
+		}
+		
+		public override  string Hint {
+			get {
+				return &quot;Choose events to generate OnXXX methods&quot;;
+			}
+		}
+		
+		public override int ImageIndex {
+			get {
+				ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+				return classBrowserIconService.EventIndex;
+			}
+		}
+		
+		public OnXXXMethodsCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+			foreach (IEvent evt in currentClass.Events) {
+				Content.Add(new EventWrapper(evt));
+			}
+		}
+		
+		protected override void StartGeneration(IList items)
+		{
+			for (int i = 0; i &lt; items.Count; ++i) {
+				EventWrapper ew = (EventWrapper)items[i];
+				string eventArgsName = String.Empty;
+				if (ew.Event.ReturnType.FullyQualifiedName.EndsWith(&quot;Handler&quot;)) {
+					eventArgsName = ew.Event.ReturnType.FullyQualifiedName.Substring(0, ew.Event.ReturnType.FullyQualifiedName.Length - &quot;Handler&quot;.Length);
+				} else {
+					eventArgsName = ew.Event.ReturnType.FullyQualifiedName;
+				}
+				eventArgsName += &quot;Args&quot;;
+				
+				editActionHandler.InsertString(&quot;protected &quot; + (ew.Event.IsStatic ? &quot;static&quot; : &quot;virtual&quot;) + &quot; void On&quot; + ew.Event.Name + &quot;(&quot; + eventArgsName + &quot; e)&quot;);++numOps;
+				Return();
+				editActionHandler.InsertChar('{');++numOps;
+				Return();
+				
+				editActionHandler.InsertString(&quot;if (&quot; + ew.Event.Name + &quot; != null) {&quot;);++numOps;
+				Return();
+				editActionHandler.InsertString(ew.Event.Name + &quot;(this, e);&quot;);++numOps;
+				Return();
+				editActionHandler.InsertChar('}');++numOps;
+				Return();
+				editActionHandler.InsertChar('}');++numOps;
+				Return();
+				IndentLine();
+			}
+		}
+		
+		class EventWrapper
+		{
+			IEvent evt;
+			public IEvent Event {
+				get {
+					return evt;
+				}
+			}
+			public EventWrapper(IEvent evt)
+			{
+				this.evt = evt;
+			}
+			
+			public override string ToString()
+			{
+				AmbienceService ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
+				return ambienceService.CurrentAmbience.Convert(evt);
+			}
+		}
+	}
+	
+	public class InterfaceImplementorCodeGenerator : CodeGenerator
+	{
+		ICompilationUnit unit;
+		
+		public override string CategoryName {
+			get {
+				return &quot;Interface implementation&quot;;
+			}
+		}
+		
+		public override  string Hint {
+			get {
+				return &quot;Choose interfaces to implement&quot;;
+			}
+		}
+		
+		public override int ImageIndex {
+			get {
+				ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+				return classBrowserIconService.InterfaceIndex;
+			}
+		}
+		
+		public InterfaceImplementorCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+			IParserService parserService = (IParserService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+			
+			foreach (string className in currentClass.BaseTypes) {
+				IClass baseType = parserService.GetClass(className);
+				if (baseType == null) {
+					this.unit = currentClass == null ? null : currentClass.CompilationUnit;
+					if (unit != null) {
+						foreach (IUsing u in unit.Usings) {
+							baseType = u.SearchType(className);
+							if (baseType != null) {
+								break;
+							}
+						}
+					}
+				}
+				
+				if (baseType != null &amp;&amp; baseType.ClassType == ClassType.Interface) {
+					Content.Add(new ClassWrapper(baseType));
+				}
+			}
+		}
+		
+		protected override void StartGeneration(IList items)
+		{
+			for (int i = 0; i &lt; items.Count; ++i) {
+				ClassWrapper cw = (ClassWrapper)items[i];
+				Queue interfaces = new Queue();
+				interfaces.Enqueue(cw.Class);
+				while (interfaces.Count &gt; 0) {
+					IClass intf = (IClass)interfaces.Dequeue();
+					GenerateInterface(intf);
+					
+					// search an enqueue all base interfaces
+					foreach (string interfaceName in intf.BaseTypes) {
+						IClass baseType = null;
+						foreach (IUsing u in unit.Usings) {
+							baseType = u.SearchType(interfaceName);
+							if (baseType != null) {
+								break;
+							}
+						}
+						if (baseType != null) {
+							interfaces.Enqueue(baseType);
+						}
+					}
+				}
+			}
+		}
+		
+		void GenerateInterface(IClass intf)
+		{
+			Return();
+			Return();
+			editActionHandler.InsertString(&quot;#region &quot; + intf.FullyQualifiedName + &quot; interface implementation\n\t\t&quot;);++numOps;
+			
+			foreach (IProperty property in intf.Properties) {
+				string returnType = csa.Convert(property.ReturnType);
+				editActionHandler.InsertString(&quot;public &quot; + returnType + &quot; &quot; + property.Name + &quot; {&quot;);++numOps;
+				Return();
+				
+				if (property.CanGet) {
+					editActionHandler.InsertString(&quot;\tget {&quot;);++numOps;
+					Return();
+					editActionHandler.InsertString(&quot;\t\treturn &quot; + GetReturnValue(returnType) +&quot;;&quot;);++numOps;
+					Return();
+					editActionHandler.InsertString(&quot;\t}&quot;);++numOps;
+					Return();
+				}
+				
+				if (property.CanSet) {
+					editActionHandler.InsertString(&quot;\tset {&quot;);++numOps;
+					Return();
+					editActionHandler.InsertString(&quot;\t}&quot;);++numOps;
+					Return();
+				}
+				
+				editActionHandler.InsertChar('}');++numOps;
+				Return();
+				Return();
+				IndentLine();
+			}
+			
+			for (int i = 0; i &lt; intf.Methods.Count; ++i) {
+				IMethod method = intf.Methods[i];
+				string parameters = String.Empty;
+				string returnType = csa.Convert(method.ReturnType);
+				
+				for (int j = 0; j &lt; method.Parameters.Count; ++j) {
+					parameters += csa.Convert(method.Parameters[j]);
+					if (j + 1 &lt; method.Parameters.Count) {
+						parameters += &quot;, &quot;;
+					}
+				}
+				
+				editActionHandler.InsertString(&quot;public &quot; + returnType + &quot; &quot; + method.Name + &quot;(&quot; + parameters + &quot;)&quot;);++numOps;
+				Return();++numOps;
+				editActionHandler.InsertChar('{');++numOps;
+				Return();
+				
+				switch (returnType) {
+					case &quot;void&quot;:
+						break;
+					default:
+						editActionHandler.InsertString(&quot;return &quot; + GetReturnValue(returnType) + &quot;;&quot;);++numOps;
+						break;
+				}
+				Return();
+				
+				editActionHandler.InsertChar('}');++numOps;
+				if (i + 1 &lt; intf.Methods.Count) {
+					Return();
+					Return();
+					IndentLine();
+				} else {
+					IndentLine();
+				}
+			}
+			
+			Return();
+			editActionHandler.InsertString(&quot;#endregion&quot;);++numOps;
+			Return();
+		}
+		
+		string GetReturnValue(string returnType)
+		{
+			switch (returnType) {
+				case &quot;string&quot;:
+					return &quot;String.Empty&quot;;
+				case &quot;char&quot;:
+					return &quot;'\\0'&quot;;
+				case &quot;bool&quot;:
+					return &quot;false&quot;;
+				case &quot;int&quot;:
+				case &quot;long&quot;:
+				case &quot;short&quot;:
+				case &quot;byte&quot;:
+				case &quot;uint&quot;:
+				case &quot;ulong&quot;:
+				case &quot;ushort&quot;:
+				case &quot;double&quot;:
+				case &quot;float&quot;:
+				case &quot;decimal&quot;:
+					return &quot;0&quot;;
+				default:
+					return &quot;null&quot;;
+			}
+		}
+		
+		class ClassWrapper
+		{
+			IClass c;
+			public IClass Class {
+				get {
+					return c;
+				}
+			}
+			public ClassWrapper(IClass c)
+			{
+				this.c = c;
+			}
+			
+			public override string ToString()
+			{
+				AmbienceService ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
+				return ambienceService.CurrentAmbience.Convert(c);
+			}
+		}
+	}
+	
+	public class OverrideMethodsCodeGenerator : CodeGenerator
+	{
+		public override string CategoryName {
+			get {
+				return &quot;Override methods&quot;;
+			}
+		}
+		
+		public override  string Hint {
+			get {
+				return &quot;Choose methods to override&quot;;
+			}
+		}
+		
+		public override int ImageIndex {
+			get {
+				ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+				return classBrowserIconService.MethodIndex;
+			}
+		}
+		
+		public OverrideMethodsCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+			foreach (IClass c in currentClass.ClassInheritanceTree) {
+				if (c.FullyQualifiedName != currentClass.FullyQualifiedName) {
+					foreach (IMethod method in c.Methods) {
+						if (!method.IsPrivate &amp;&amp; (method.IsAbstract || method.IsVirtual || method.IsOverride)) {
+							Content.Add(new MethodWrapper(method));
+						}
+					}
+				}
+			}
+		}
+		
+		protected override void StartGeneration(IList items)
+		{
+//			bool moveToMethod = sf.SelectedItems.Count == 1;
+//			int  caretPos     = 0;
+			for (int i = 0; i &lt; items.Count; ++i) {
+				MethodWrapper mw = (MethodWrapper)items[i];
+				
+				string parameters = String.Empty;
+				string paramList  = String.Empty;
+				string returnType = csa.Convert(mw.Method.ReturnType);
+				
+				for (int j = 0; j &lt; mw.Method.Parameters.Count; ++j) {
+					paramList  += mw.Method.Parameters[j].Name;
+					parameters += csa.Convert(mw.Method.Parameters[j]);
+					if (j + 1 &lt; mw.Method.Parameters.Count) {
+						parameters += &quot;, &quot;;
+						paramList  += &quot;, &quot;;
+					}
+				}
+				
+				editActionHandler.InsertString(csa.Convert(mw.Method.Modifiers) + &quot;override &quot; + returnType + &quot; &quot; + mw.Method.Name + &quot;(&quot; + parameters + &quot;)&quot;);++numOps;
+				Return();
+				editActionHandler.InsertChar('{');++numOps;
+				Return();
+				
+				if (returnType != &quot;void&quot;) {
+					string str = &quot;return base.&quot; + mw.Method.Name + &quot;(&quot; + paramList + &quot;);&quot;;
+					editActionHandler.InsertString(str);++numOps;
+				}
+				
+				Return();
+//				caretPos = editActionHandler.Document.Caret.Offset;
+
+				editActionHandler.InsertChar('}');++numOps;
+				Return();
+				IndentLine();
+			}
+//			if (moveToMethod) {
+//				editActionHandler.Document.Caret.Offset = caretPos;
+//			}
+		}
+		
+		class MethodWrapper
+		{
+			IMethod method;
+			
+			public IMethod Method {
+				get {
+					return method;
+				}
+			}
+			
+			public MethodWrapper(IMethod method)
+			{
+				this.method = method;
+			}
+			
+			public override string ToString()
+			{
+				AmbienceService ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
+				IAmbience ambience = ambienceService.CurrentAmbience;
+				ambience.ConversionFlags = ConversionFlags.None;
+				return ambience.Convert(method);
+			}
+		}
+	}
+	
+	public class AbstractClassImplementorCodeGenerator : CodeGenerator
+	{
+		ICompilationUnit unit;
+		
+		public override string CategoryName {
+			get {
+				return &quot;Abstract class overridings&quot;;
+			}
+		}
+		
+		public override  string Hint {
+			get {
+				return &quot;Choose abstract class to override&quot;;
+			}
+		}
+		
+		public override int ImageIndex {
+			get {
+				ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+				return classBrowserIconService.InterfaceIndex;
+			}
+		}
+		
+		public AbstractClassImplementorCodeGenerator(IClass currentClass) : base(currentClass)
+		{
+			IParserService parserService = (IParserService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+			
+			foreach (string className in currentClass.BaseTypes) {
+				IClass baseType = parserService.GetClass(className);
+				if (baseType == null) {
+					this.unit = currentClass == null ? null : currentClass.CompilationUnit;
+					if (unit != null) {
+						foreach (IUsing u in unit.Usings) {
+							baseType = u.SearchType(className);
+							if (baseType != null) {
+								break;
+							}
+						}
+					}
+				}
+				
+				if (baseType != null &amp;&amp; baseType.ClassType == ClassType.Class &amp;&amp; baseType.IsAbstract) {
+					Content.Add(new ClassWrapper(baseType));
+				}
+			}
+		}
+		
+		protected override void StartGeneration(IList items)
+		{
+			for (int i = 0; i &lt; items.Count; ++i) {
+				ClassWrapper cw = (ClassWrapper)items[i];
+				Queue interfaces = new Queue();
+				interfaces.Enqueue(cw.Class);
+				while (interfaces.Count &gt; 0) {
+					IClass intf = (IClass)interfaces.Dequeue();
+					GenerateInterface(intf);
+					
+					// search an enqueue all base interfaces
+					foreach (string interfaceName in intf.BaseTypes) {
+						IClass baseType = null;
+						foreach (IUsing u in unit.Usings) {
+							baseType = u.SearchType(interfaceName);
+							if (baseType != null) {
+								break;
+							}
+						}
+						if (baseType != null) {
+							interfaces.Enqueue(baseType);
+						}
+					}
+				}
+			}
+		}
+		
+		void GenerateInterface(IClass intf)
+		{
+			Return();Return();
+			editActionHandler.InsertString(&quot;#region &quot; + intf.FullyQualifiedName + &quot; abstract class implementation\n\t\t&quot;);++numOps;
+			
+			foreach (IProperty property in intf.Properties) {
+				if (!property.IsAbstract) {
+					continue;
+				}
+				string returnType = csa.Convert(property.ReturnType);
+				if (property.IsProtected) {
+					editActionHandler.InsertString(&quot;protected &quot;);
+				} else {
+					editActionHandler.InsertString(&quot;public &quot;);
+				}
+				
+				editActionHandler.InsertString(&quot;override &quot; + returnType + &quot; &quot; + property.Name + &quot; {\n&quot;);++numOps;
+				
+				if (property.CanGet) {
+					editActionHandler.InsertString(&quot;\tget {&quot;);++numOps;
+					Return();
+					editActionHandler.InsertString(&quot;\t\treturn &quot; + GetReturnValue(returnType) +&quot;;&quot;);++numOps;
+					Return();
+					editActionHandler.InsertString(&quot;\t}&quot;);++numOps;
+					Return();
+				}
+				
+				if (property.CanSet) {
+					editActionHandler.InsertString(&quot;\tset {&quot;);++numOps;
+					Return();
+					editActionHandler.InsertString(&quot;\t}&quot;);++numOps;
+					Return();
+				}
+				
+				editActionHandler.InsertChar('}');++numOps;
+				Return();
+				Return();
+				IndentLine();
+			}
+			
+			for (int i = 0; i &lt; intf.Methods.Count; ++i) {
+				IMethod method = intf.Methods[i];
+				string parameters = String.Empty;
+				string returnType = csa.Convert(method.ReturnType);
+				if (!method.IsAbstract) {
+					continue;
+				}
+				for (int j = 0; j &lt; method.Parameters.Count; ++j) {
+					parameters += csa.Convert(method.Parameters[j]);
+					if (j + 1 &lt; method.Parameters.Count) {
+						parameters += &quot;, &quot;;
+					}
+				}
+				if (method.IsProtected) {
+					editActionHandler.InsertString(&quot;protected &quot;);
+				} else {
+					editActionHandler.InsertString(&quot;public &quot;);
+				}
+				
+				editActionHandler.InsertString(&quot;override &quot; + returnType + &quot; &quot; + method.Name + &quot;(&quot; + parameters + &quot;)&quot;);++numOps;
+				Return();
+				editActionHandler.InsertChar('{');++numOps;
+				Return();
+				
+				switch (returnType) {
+					case &quot;void&quot;:
+						break;
+					default:
+						editActionHandler.InsertString(&quot;return &quot; + GetReturnValue(returnType) + &quot;;&quot;);++numOps;
+						break;
+				}
+				Return();
+				
+				editActionHandler.InsertChar('}');++numOps;
+				if (i + 1 &lt; intf.Methods.Count) {
+					Return();
+					Return();
+					IndentLine();
+				} else {
+					IndentLine();
+				}
+			}
+			Return();
+			editActionHandler.InsertString(&quot;#endregion&quot;);++numOps;
+			Return();
+		}
+		
+		string GetReturnValue(string returnType)
+		{
+			switch (returnType) {
+				case &quot;string&quot;:
+					return &quot;String.Empty&quot;;
+				case &quot;char&quot;:
+					return &quot;'\\0'&quot;;
+				case &quot;bool&quot;:
+					return &quot;false&quot;;
+				case &quot;int&quot;:
+				case &quot;long&quot;:
+				case &quot;short&quot;:
+				case &quot;byte&quot;:
+				case &quot;uint&quot;:
+				case &quot;ulong&quot;:
+				case &quot;ushort&quot;:
+				case &quot;double&quot;:
+				case &quot;float&quot;:
+				case &quot;decimal&quot;:
+					return &quot;0&quot;;
+				default:
+					return &quot;null&quot;;
+			}
+		}
+		
+		class ClassWrapper
+		{
+			IClass c;
+			public IClass Class {
+				get {
+					return c;
+				}
+			}
+			public ClassWrapper(IClass c)
+			{
+				this.c = c;
+			}
+			
+			public override string ToString()
+			{
+				AmbienceService ambienceService = (AmbienceService)ServiceManager.Services.GetService(typeof(AmbienceService));
+				return ambienceService.CurrentAmbience.Convert(c);
+			}
+		}
+	}
+}*/

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/CommentRegionCommand.cs (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/CommentRegionCommand.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/CommentRegionCommand.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/CommentRegionCommand.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,47 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Markus Palme&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">MarkusPalme at gmx.de</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Drawing;
+using System.Drawing.Printing;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Text;
+
+using ICSharpCode.Core.AddIns;
+using ICSharpCode.Core.AddIns.Codons;
+
+using ICSharpCode.Core.Properties;
+
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor;
+
+namespace ICSharpCode.SharpDevelop.DefaultEditor.Commands
+{
+	public class CommentRegion : AbstractMenuCommand
+	{ 
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not ported to the new editor yet&quot;);
+			/*
+			IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			
+			if (window == null || !(window.ViewContent is ITextEditorControlProvider)) {
+				return;
+			}
+			
+			TextEditorControl textarea = ((ITextEditorControlProvider)window.ViewContent).TextEditorControl;
+			new ICSharpCode.TextEditor.Actions.ToggleComment().Execute(textarea.ActiveTextAreaControl.TextArea);
+			*/
+		}
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/FoldingCommands.cs (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/FoldingCommands.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/FoldingCommands.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/FoldingCommands.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,68 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Drawing;
+using System.Drawing.Printing;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Text;
+using System.Xml;
+using System.Xml.Xsl;
+
+using ICSharpCode.Core.AddIns;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.Core.AddIns.Codons;
+
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.TextEditor;
+using ICSharpCode.TextEditor.Actions;
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.SharpDevelop.Gui.HtmlControl;
+using ICSharpCode.Core.Services;
+
+namespace ICSharpCode.SharpDevelop.DefaultEditor.Commands
+{
+	public class ToggleFolding : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				//return new ICSharpCode.TextEditor.Actions.ToggleFolding();
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+			}
+		}
+	}
+	
+	public class ToggleAllFoldings : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new Editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.ToggleAllFoldings();
+			}
+		}
+	}
+	
+	public class ShowDefinitionsOnly : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new Editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.ShowDefinitionsOnly();
+			}
+		}
+	}
+
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/FormatCommands.cs (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/FormatCommands.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/FormatCommands.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/FormatCommands.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,270 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Drawing;
+using System.Drawing.Printing;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Text;
+
+using ICSharpCode.Core.Services;
+using ICSharpCode.Core.AddIns;
+using ICSharpCode.Core.AddIns.Codons;
+
+using ICSharpCode.Core.Properties;
+
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor;
+using ICSharpCode.TextEditor.Actions;
+
+namespace ICSharpCode.SharpDevelop.DefaultEditor.Commands
+{
+	public class RemoveLeadingWS : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.RemoveLeadingWS();
+			}
+		}
+	}
+	
+	public class RemoveTrailingWS : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.RemoveTrailingWS();
+			}
+		}
+	}
+	
+	
+	public class ToUpperCase : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.ToUpperCase();
+			}
+		}
+	}
+	
+	public class ToLowerCase : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.ToLowerCase();
+			}
+		}
+	}
+	
+	public class InvertCaseAction : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.InvertCaseAction();
+			}
+		}
+	}
+	
+	public class CapitalizeAction : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.CapitalizeAction();
+			}
+		}
+	}
+	
+	public class ConvertTabsToSpaces : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.ConvertTabsToSpaces();
+			}
+		}
+	}
+	
+	public class ConvertSpacesToTabs : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.ConvertSpacesToTabs();
+			}
+		}
+	}
+	
+	public class ConvertLeadingTabsToSpaces : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new Editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.ConvertLeadingTabsToSpaces();
+			}
+		}
+	}
+	
+	public class ConvertLeadingSpacesToTabs : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new Editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.ConvertLeadingSpacesToTabs();
+			}
+		}
+	}
+	
+	/// &lt;summary&gt;
+	/// This is a sample editaction plugin, it indents the selected area.
+	/// &lt;/summary&gt;
+	public class IndentSelection : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in the new Editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.FormatBuffer();
+			}
+		}
+	}
+	
+	/// &lt;summary&gt;
+	/// This is a sample editaction plugin, it indents the selected area.
+	/// &lt;/summary&gt;
+	public class SortSelection : AbstractMenuCommand
+	{
+		static PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+		class SortComparer : IComparer
+		{
+			
+			//SortDirection sortDirection;
+			bool isCaseSensitive;
+			bool ignoreWhitespaces;
+			
+			public SortComparer()
+			{
+				//isCaseSensitive   = propertyService.GetProperty(SortOptionsDialog.caseSensitiveOption, true);
+				//ignoreWhitespaces = propertyService.GetProperty(SortOptionsDialog.ignoreWhiteSpacesOption, true);
+				//sortDirection     = (SortDirection)propertyService.GetProperty(SortOptionsDialog.sortDirectionOption, SortDirection.Ascending);
+			}
+			
+			public int Compare(object x, object y)
+			{
+				if (x == null || y == null) {
+					return -1;
+				}
+				string str1;
+				string str2;
+				
+				//if (sortDirection == SortDirection.Ascending) {
+					str1 = x.ToString();
+					str2 = y.ToString();
+				//} else {
+					str1 = y.ToString();
+					str2 = x.ToString();
+				//}
+				
+				if (ignoreWhitespaces) {
+					str1 = str1.Trim();
+					str2 = str2.Trim();
+				}
+				
+				if (!isCaseSensitive) {
+					str1 = str1.ToUpper();
+					str2 = str2.ToUpper();
+				}
+				
+				return str1.CompareTo(str2);
+			}
+		}
+		
+		/*
+		public void SortLines(IDocument document, int startLine, int endLine)
+		{
+			ArrayList lines = new ArrayList();
+			for (int i = startLine; i &lt;= endLine; ++i) {
+				LineSegment line = document.GetLineSegment(i);
+				lines.Add(document.GetText(line.Offset, line.Length));
+			}
+			
+			lines.Sort(new SortComparer());
+			
+			//bool removeDupes = propertyService.GetProperty(SortOptionsDialog.removeDupesOption, false);
+			bool removeDupes = false; //FIXME: TMP
+			if (removeDupes) {
+				for (int i = 0; i &lt; lines.Count - 1; ++i) {
+					if (lines[i].Equals(lines[i + 1])) {
+						lines.RemoveAt(i);
+						--i;
+					}
+				}
+			}
+			
+			for (int i = 0; i &lt; lines.Count; ++i) {
+				LineSegment line = document.GetLineSegment(startLine + i);
+				document.Replace(line.Offset, line.Length, lines[i].ToString());
+			}
+			
+			// remove removed duplicate lines
+			for (int i = startLine + lines.Count; i &lt;= endLine; ++i) {
+				LineSegment line = document.GetLineSegment(startLine + lines.Count);
+				document.Remove(line.Offset, line.TotalLength);
+			}
+		}*/
+		
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not ported to the new Option Panel&quot;);
+			/*IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			
+			if (window == null || !(window.ViewContent is ITextEditorControlProvider)) {
+				return;
+			}
+			
+			using (SortOptionsDialog sortOptionsDialog = new SortOptionsDialog()) {
+				sortOptionsDialog.Owner = (Form)WorkbenchSingleton.Workbench;
+				if (sortOptionsDialog.ShowDialog() == DialogResult.OK) {
+					TextArea textarea = ((ITextEditorControlProvider)window.ViewContent).TextEditorControl.ActiveTextAreaControl.TextArea;
+					textarea.BeginUpdate();
+					if (textarea.SelectionManager.HasSomethingSelected) {
+						foreach (ISelection selection in textarea.SelectionManager.SelectionCollection) {
+							SortLines(textarea.Document, selection.StartPosition.Y, selection.EndPosition.Y);
+						}
+					} else { 
+						SortLines(textarea.Document, 0, textarea.Document.TotalNumberOfLines - 1);
+					}
+					textarea.Caret.ValidateCaretPos();
+					textarea.EndUpdate();
+					textarea.Refresh();
+				}
+			}*/
+		}
+	}
+	
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/ICSharpCode.SharpDevelop.DefaultEditor.Commands.GenerateCodeAction.resources (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/ICSharpCode.SharpDevelop.DefaultEditor.Commands.GenerateCodeAction.resources)

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/IEditAction.cs (from rev 814, trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/IEditAction.cs)
===================================================================
--- trunk/MonoDevelop/src/Libraries/ICSharpCode.TextEditor/src/Actions/IEditAction.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/IEditAction.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,61 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+using MonoDevelop.SourceEditor.Gui;
+
+using Gdk;
+
+namespace ICSharpCode.TextEditor.Actions
+{
+	/// &lt;summary&gt;
+	/// To define a new key for the textarea, you must write a class which
+	/// implements this interface.
+	/// &lt;/summary&gt;
+	public interface IEditAction
+	{
+		/// &lt;value&gt;
+		/// An array of keys on which this edit action occurs.
+		/// &lt;/value&gt;
+		Gdk.Key[] Keys {
+			get;
+			set;
+		}
+		
+		/// &lt;remarks&gt;
+		/// When the key which is defined per XML is pressed, this method will be launched.
+		/// &lt;/remarks&gt;
+		void Execute(SourceEditorView textArea);
+	}
+	
+	/// &lt;summary&gt;
+	/// To define a new key for the textarea, you must write a class which
+	/// implements this interface.
+	/// &lt;/summary&gt;
+	public abstract class AbstractEditAction : IEditAction
+	{
+		Gdk.Key[] keys = null;
+		
+		/// &lt;value&gt;
+		/// An array of keys on which this edit action occurs.
+		/// &lt;/value&gt;
+		public Gdk.Key[] Keys {
+			get {
+				return keys;
+			}
+			set {
+				keys = value;
+			}
+		}
+		
+		/// &lt;remarks&gt;
+		/// When the key which is defined per XML is pressed, this method will be launched.
+		/// &lt;/remarks&gt;
+		public abstract void Execute(SourceEditorView textArea);
+	}		
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/ProjectCommands.cs (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/ProjectCommands.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/ProjectCommands.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/ProjectCommands.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,45 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Drawing;
+using System.Drawing.Printing;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Text;
+
+using ICSharpCode.Core.AddIns;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.Core.AddIns.Codons;
+using ICSharpCode.Core.Services;
+
+using ICSharpCode.SharpDevelop.Services;
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.SharpDevelop.Gui;
+
+namespace ICSharpCode.SharpDevelop.DefaultEditor.Commands
+{
+	public class ExportProjectToHtml : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			IProjectService projectService = (IProjectService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			if (projectService.CurrentSelectedProject != null) {
+				//ExportProjectToHtmlDialog ephd = new ExportProjectToHtmlDialog(projectService.CurrentSelectedProject);
+				//ephd.Owner = (Form)WorkbenchSingleton.Workbench;
+				//ephd.ShowDialog();
+				//ephd.Dispose();
+			}
+		}
+	}
+
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/SearchCommands.cs (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/SearchCommands.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/SearchCommands.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/SearchCommands.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,180 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Drawing;
+using System.Drawing.Printing;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Text;
+
+using ICSharpCode.Core.AddIns;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.Core.AddIns.Codons;
+using ICSharpCode.TextEditor;
+using ICSharpCode.TextEditor.Actions;
+
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.SharpDevelop.Gui;
+
+namespace ICSharpCode.SharpDevelop.DefaultEditor.Commands
+{
+	
+	public abstract class AbstractEditActionMenuCommand : AbstractMenuCommand
+	{
+		public abstract IEditAction EditAction {
+			get;
+		}
+		
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+			/*IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			
+			if (window == null || !(window.ViewContent is ITextEditorControlProvider)) {
+				return;
+			}
+			TextEditorControl textEditor = ((ITextEditorControlProvider)window.ViewContent).TextEditorControl;
+			EditAction.Execute(textEditor.ActiveTextAreaControl.TextArea);*/
+		}
+	}
+	
+	public class Find : AbstractMenuCommand
+	{
+		public static void SetSearchPattern()
+		{
+//			// Get Highlighted value and set it to FindDialog.searchPattern
+//			IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+//			
+//			if (window != null &amp;&amp; (window.ViewContent is ITextEditorControlProvider)) {
+//				TextAreaControl textarea = ((ITextEditorControlProvider)window.ViewContent).TextAreaControl;				
+//				string selectedText = textarea.Document.SelectedText;
+//				if (selectedText != null &amp;&amp; selectedText.Length &gt; 0) {
+//					SearchReplaceManager.SearchOptions.SearchPattern = selectedText;
+//				}
+//			}
+		}
+		
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+			/*
+			SetSearchPattern();
+			if (SearchReplaceManager.ReplaceDialog != null) {
+				if (SearchReplaceManager.ReplaceDialog.replaceMode == false) {
+					SearchReplaceManager.ReplaceDialog.SetSearchPattern(SearchReplaceManager.SearchOptions.SearchPattern);
+					SearchReplaceManager.ReplaceDialog.Present ();
+				} else {
+					SearchReplaceManager.ReplaceDialog.Destroy ();
+					ReplaceDialog rd = new ReplaceDialog (false);
+					rd.ShowAll ();
+				}
+			} else {
+				ReplaceDialog rd = new ReplaceDialog(false);
+				rd.ShowAll();
+			}*/
+		}
+	}
+	
+	public class FindNext : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			//SearchReplaceManager.FindNext();
+		}
+	}
+	
+	public class Replace : AbstractMenuCommand
+	{
+		public override void Run()
+		{ 
+			Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+			//Find.SetSearchPattern();
+			
+			/*if (SearchReplaceManager.ReplaceDialog != null) {
+				if (SearchReplaceManager.ReplaceDialog.replaceMode == true) {
+					SearchReplaceManager.ReplaceDialog.SetSearchPattern(SearchReplaceManager.SearchOptions.SearchPattern);
+					SearchReplaceManager.ReplaceDialog.Present ();
+				} else {
+					SearchReplaceManager.ReplaceDialog.Destroy ();
+					ReplaceDialog rd = new ReplaceDialog (true);
+					rd.ShowAll ();
+				}
+			} else {
+				ReplaceDialog rd = new ReplaceDialog(true);
+				rd.ShowAll();
+			}*/
+		}
+	}
+	
+	public class FindInFiles : AbstractMenuCommand
+	{
+		public static void SetSearchPattern()
+		{
+//			// Get Highlighted value and set it to FindDialog.searchPattern
+//			IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+//			
+//			if (window != null &amp;&amp; (window.ViewContent is ITextEditorControlProvider)) {
+//				TextAreaControl textarea = ((ITextEditorControlProvider)window.ViewContent).TextAreaControl;				
+//				string selectedText = textarea.Document.SelectedText;
+//				if (selectedText != null &amp;&amp; selectedText.Length &gt; 0) {
+//					SearchReplaceInFilesManager.SearchOptions.SearchPattern = selectedText;
+//				}
+//			}			
+		}
+		public override void Run()
+		{
+			SetSearchPattern();
+			//using (ReplaceInFilesDialog rd = new ReplaceInFilesDialog(false)) {
+			//	rd.Owner = (Form)WorkbenchSingleton.Workbench;
+			//	rd.ShowDialog();
+			//}
+		}
+	}
+	
+	public class ReplaceInFiles : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			FindInFiles.SetSearchPattern();
+			
+			//using (ReplaceInFilesDialog rd = new ReplaceInFilesDialog(true)) {
+			//	rd.Owner = (Form)WorkbenchSingleton.Workbench;
+			//	rd.ShowDialog();
+			//}
+		}
+	}
+	
+	public class GotoLineNumber : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not implemented in the new editor&quot;);
+			/*if (!GotoLineNumberDialog.IsVisible) {
+				GotoLineNumberDialog gnd = new GotoLineNumberDialog();
+				gnd.Run ();
+				gnd.Hide ();
+			}*/
+		}
+	}
+	
+	public class GotoMatchingBrace : AbstractEditActionMenuCommand
+	{
+		public override IEditAction EditAction {
+			get {
+				Console.WriteLine (&quot;Not implemented in New Editor&quot;);
+				return null;
+				//return new ICSharpCode.TextEditor.Actions.GotoMatchingBrace();
+			}
+		}
+	}
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/TextAreaContextmenuCommands.cs (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/TextAreaContextmenuCommands.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/TextAreaContextmenuCommands.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/TextAreaContextmenuCommands.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,105 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Drawing;
+using System.Drawing.Printing;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Text;
+
+using ICSharpCode.Core.AddIns;
+using ICSharpCode.Core.AddIns.Conditions;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.Core.AddIns.Codons;
+
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor.Document;
+using ICSharpCode.SharpDevelop.Gui.Components;
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.TextEditor;
+using ICSharpCode.Core.Services;
+
+namespace ICSharpCode.SharpDevelop.DefaultEditor.Commands
+{
+	public class ShowBufferOptions : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not ported to the new editor yet&quot;);
+			/*
+			IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			
+			if (window == null || !(window.ViewContent is ITextEditorControlProvider)) {
+				return;
+			}
+			TextEditorControl textarea = ((ITextEditorControlProvider)window.ViewContent).TextEditorControl;
+			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+			ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
+			*/
+			/*TabbedOptions o = new TabbedOptions(resourceService.GetString(&quot;Dialog.Options.BufferOptions&quot;),
+			                                    ((IProperties)propertyService.GetProperty(&quot;ICSharpCode.TextEditor.Document.Document.DefaultDocumentAggregatorProperties&quot;, new DefaultProperties())),
+			                                    AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/SharpDevelop/ViewContent/DefaultTextEditor/OptionsDialog&quot;));*/
+			//o.Width  = 450;
+			//o.Height = 425;
+			//o.FormBorderStyle = FormBorderStyle.FixedDialog;
+			//o.ShowDialog();
+			//o.Dispose();
+			//textarea.OptionsChanged();
+		}
+	}
+	
+	
+	public class HighlightingTypeBuilder : ISubmenuBuilder
+	{
+		
+		//TextEditorControl  control      = null;
+		//Gtk.MenuItem[] menuCommands = null;
+		
+		
+		public Gtk.MenuItem[] BuildSubmenu(ConditionCollection conditionCollection, object owner)
+		{
+			/*
+			control = (TextEditorControl)owner;
+			
+			ArrayList menuItems = new ArrayList();
+			
+			foreach (DictionaryEntry entry in HighlightingManager.Manager.HighlightingDefinitions) {
+				SdMenuCheckBox item = new SdMenuCheckBox(null, null, entry.Key.ToString());
+				item.Active = control.Document.HighlightingStrategy.Name == entry.Key.ToString();
+				item.Toggled    += new EventHandler(ChangeSyntax);
+				menuItems.Add(item);
+			}
+			menuCommands = (Gtk.MenuItem[])menuItems.ToArray(typeof(Gtk.MenuItem));
+			return menuCommands;
+			*/
+			return null;
+		}
+		
+		void ChangeSyntax(object sender, EventArgs e)
+		{
+			/*
+			if (control != null) {
+				SdMenuCheckBox item = (SdMenuCheckBox)sender;
+				foreach (SdMenuCheckBox i in menuCommands) {
+					i.Active = false;
+				}
+				item.Active = true;
+				IHighlightingStrategy strat = HighlightingStrategyFactory.CreateHighlightingStrategy(((Gtk.Label)item.Child).Text);
+				if (strat == null) {
+					throw new Exception(&quot;Strategy can't be null&quot;);
+				}
+				control.Document.HighlightingStrategy = strat;
+				control.Refresh();
+			}*/
+		}
+	}	
+}

Copied: trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/ToolCommands.cs (from rev 814, trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/ToolCommands.cs)
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/TextEditor/Commands/ToolCommands.cs	2004-02-07 23:57:58 UTC (rev 814)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor/Commands/ToolCommands.cs	2004-02-09 01:42:14 UTC (rev 829)
@@ -0,0 +1,249 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#252;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Drawing;
+using System.Drawing.Printing;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Text;
+using System.Xml;
+using System.Xml.Xsl;
+
+using ICSharpCode.Core.AddIns;
+
+using ICSharpCode.Core.Properties;
+using ICSharpCode.Core.AddIns.Codons;
+
+using ICSharpCode.SharpDevelop.Gui.Dialogs;
+using ICSharpCode.TextEditor;
+using ICSharpCode.SharpDevelop.Gui;
+using ICSharpCode.SharpDevelop.Gui.HtmlControl;
+using ICSharpCode.Core.Services;
+
+using Gtk;
+using GtkSharp;
+
+namespace ICSharpCode.SharpDevelop.DefaultEditor.Commands
+{
+	public class ColorDialog : ColorSelectionDialog
+	{
+		public ColorDialog () : base (&quot;DON'T use this dialog it DOESN'T work correctly&quot;)
+		{
+			this.ColorSelection.HasPalette = true;
+			this.ColorSelection.HasOpacityControl = false;		
+		}
+		
+		public string ColorStr ()
+		{
+			Gdk.Color color = this.ColorSelection.CurrentColor;
+			StringBuilder s = new StringBuilder ();
+			ushort[] vals = { color.red, color.green, color.blue };
+			// debug line
+			// Console.WriteLine(&quot;r {0}, b {1}, g{2}&quot;, color.red, color.green, color.blue );
+			char[] hexchars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+			s.Append (&quot;#FF&quot;);
+			foreach (ushort val in vals) {
+				/* Convert to a range of 0-255, then lookup the
+				 * digit for each half-byte */
+				byte rounded = (byte) (val &gt;&gt; 8);
+				s.Append (hexchars[(rounded &amp; 0xf0) &gt;&gt; 4]);
+				s.Append (hexchars[rounded &amp; 0x0f]);
+			}
+			return s.ToString ();
+		}
+	}
+
+	public class ShowColorDialog : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not Ported to the new editor yet&quot;);
+
+			/*IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			if (window == null || !(window.ViewContent is ITextEditorControlProvider)) {
+				return;
+			}
+			//TextEditorControl textarea = ((ITextEditorControlProvider)window.ViewContent).TextEditorControl;
+			//FIXME:  
+			// - The return sting value is not the same choosen in the Dialog
+                        // - Return color name (not color value) if it IsKnownColor but it's still not implemented for System.Drawing.Color
+			ColorDialog dialog  = new ColorDialog ();
+			if ( dialog.Run () == (int) ResponseType.Ok) {
+				string ColorStr = dialog.ColorStr();
+				//string ColorStr = dialog.ColorSelection.CurrentColor.ToString();
+				//textarea.Document.Insert(textarea.ActiveTextAreaControl.Caret.Offset, ColorStr);
+				//int lineNumber = textarea.Document.GetLineNumberForOffset(textarea.ActiveTextAreaControl.Caret.Offset);
+				//textarea.ActiveTextAreaControl.Caret.Column += ColorStr.Length;
+				//textarea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, new Point(0, lineNumber)));
+				//textarea.Document.CommitUpdate();
+				
+
+			};
+			dialog.Hide();
+
+			*/
+			/*using (ColorDialog cd = new ColorDialog()) {
+				if (cd.ShowDialog() == DialogResult.OK) {
+					string colorstr = &quot;#&quot; + cd.Color.ToArgb().ToString(&quot;X&quot;);
+					if (cd.Color.IsKnownColor) {
+						colorstr = cd.Color.ToKnownColor().ToString();
+					}
+					
+					textarea.Document.Insert(textarea.ActiveTextAreaControl.Caret.Offset, colorstr);
+					int lineNumber = textarea.Document.GetLineNumberForOffset(textarea.ActiveTextAreaControl.Caret.Offset);
+					textarea.ActiveTextAreaControl.Caret.Column += colorstr.Length;
+					textarea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, new Point(0, lineNumber)));
+					textarea.Document.CommitUpdate();
+				}
+			}*/
+		}
+	}
+	
+	public class QuickDocumentation : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not ported to the new editor yet&quot;);
+			/*
+			IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			
+			if (window == null || !(window.ViewContent is ITextEditorControlProvider)) {
+				return;
+			}
+			TextEditorControl textAreaControl = ((ITextEditorControlProvider)window.ViewContent).TextEditorControl;
+			
+			int startLine = textAreaControl.Document.GetLineNumberForOffset(textAreaControl.ActiveTextAreaControl.Caret.Offset);
+			int endLine   = startLine;
+			
+			LineSegment line = textAreaControl.Document.GetLineSegment(startLine);
+			string curLine   = textAreaControl.Document.GetText(line.Offset, line.Length).Trim();
+			if (!curLine.StartsWith(&quot;///&quot;)) {
+				return;
+			}
+			
+			while (startLine &gt; 0) {
+				line    = textAreaControl.Document.GetLineSegment(startLine);
+				curLine = textAreaControl.Document.GetText(line.Offset, line.Length).Trim();
+				if (curLine.StartsWith(&quot;///&quot;)) {
+					--startLine;
+				} else {
+					break;
+				}
+			}
+			
+			while (endLine &lt; textAreaControl.Document.TotalNumberOfLines - 1) {
+				line    = textAreaControl.Document.GetLineSegment(endLine);
+				curLine = textAreaControl.Document.GetText(line.Offset, line.Length).Trim();
+				if (curLine.StartsWith(&quot;///&quot;)) {
+					++endLine;
+				} else {
+					break;
+				}
+			}
+			
+			StringBuilder documentation = new StringBuilder();
+			for (int lineNr = startLine + 1; lineNr &lt; endLine; ++lineNr) {
+				line    = textAreaControl.Document.GetLineSegment(lineNr);
+				curLine = textAreaControl.Document.GetText(line.Offset, line.Length).Trim();
+				documentation.Append(curLine.Substring(3));
+				documentation.Append('\n');
+			}
+			string xml  = &quot;&lt;member&gt;&quot; + documentation.ToString() + &quot;&lt;/member&gt;&quot;;
+			
+			string html = String.Empty;
+			
+			try {
+				FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+				PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+				html = ICSharpCode.SharpDevelop.Internal.Project.ConvertXml.ConvertData(xml,
+				                   propertyService.DataDirectory +
+				                   Path.DirectorySeparatorChar + &quot;ConversionStyleSheets&quot; +
+				                   Path.DirectorySeparatorChar + &quot;ShowXmlDocumentation.xsl&quot;,
+				                   null);
+			} catch (Exception e) {
+				//MessageBox.Show(e.ToString());
+			}
+			//new ToolWindowForm(textAreaControl, html).Show();
+			*/
+		}
+		
+		class ToolWindowForm //: Form
+		{/*
+			public ToolWindowForm(TextEditorControl textEditorControl, string html)
+			{
+				Point caretPos  = textEditorControl.ActiveTextAreaControl.Caret.Position;
+				Point visualPos = new Point(textEditorControl.ActiveTextAreaControl.TextArea.TextView.GetDrawingXPos(caretPos.Y, caretPos.X) + textEditorControl.ActiveTextAreaControl.TextArea.TextView.DrawingPosition.X,
+				          (int)((1 + caretPos.Y) * textEditorControl.ActiveTextAreaControl.TextArea.TextView.FontHeight) - textEditorControl.ActiveTextAreaControl.TextArea.VirtualTop.Y - 1 + textEditorControl.ActiveTextAreaControl.TextArea.TextView.DrawingPosition.Y);
+				//Location = textEditorControl.ActiveTextAreaControl.TextArea.PointToScreen(visualPos);  //FIXME: Again, should we have this method?!?
+				PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+				
+				HtmlControl hc = new HtmlControl();
+				hc.Html = html;
+				FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.Services.GetService(typeof(FileUtilityService));
+				hc.CascadingStyleSheet = propertyService.DataDirectory +
+				                   Path.DirectorySeparatorChar + &quot;resources&quot; +
+				                   Path.DirectorySeparatorChar + &quot;css&quot; +
+				                   Path.DirectorySeparatorChar + &quot;MsdnHelp.css&quot;;
+				//hc.Dock = DockStyle.Fill;
+				hc.BeforeNavigate += new BrowserNavigateEventHandler(BrowserNavigateCancel);
+				//Controls.Add(hc);
+								
+				//ShowInTaskbar   = false;
+				//FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
+				//StartPosition   = FormStartPosition.Manual;
+			}
+			
+			void BrowserNavigateCancel(object sender, BrowserNavigateEventArgs e)
+			{
+				e.Cancel = true;
+			}
+			
+			protected  void OnDeactivate(EventArgs e)
+			{
+				//Close();
+			}
+			
+			protected  bool ProcessDialogKey()
+			{
+				
+				//if (keyData == Keys.Escape) {
+				//	Close();
+				//	return true;
+				//}
+				//return base.ProcessDialogKey(keyData);
+				
+				//return false;
+			}
+			*/
+		}
+	}
+	
+	public class SplitTextEditor : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			Console.WriteLine (&quot;Not implemented in the new Editor&quot;);
+			/*
+			IWorkbenchWindow window = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			
+			if (window == null || !(window.ViewContent is ITextEditorControlProvider)) {
+				return;
+			}
+			TextEditorControl textEditorControl = ((ITextEditorControlProvider)window.ViewContent).TextEditorControl;
+			if (textEditorControl != null) {
+				//textEditorControl.Split();
+			}
+			*/
+		}
+	}
+
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000433.html">[Monodevelop-patches-list] r828 - in trunk/MonoDevelop: . build/AddIns src/AddIns/DisplayBindings/SourceEditor/Gui src/AddIns/DisplayBindings/TextEditor src/Libraries/ICSharpCode.TextEditor src/Main/Core/AddIns
</A></li>
	<LI>Next message: <A HREF="000435.html">[Monodevelop-patches-list] r830 - in trunk/MonoDevelop: . build/AddIns build/AddIns/AddIns/BackendBindings src/AddIns/DisplayBindings/SourceEditor src/AddIns/DisplayBindings/SourceEditor/Codons src/AddIns/DisplayBindings/TextEditor src/AddIns/DisplayBindings/TextEditor/Commands
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#434">[ date ]</a>
              <a href="thread.html#434">[ thread ]</a>
              <a href="subject.html#434">[ subject ]</a>
              <a href="author.html#434">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
