<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r812 - in trunk/MonoDevelop: gdldock/gdl gdldock/sources/gdl src/AddIns/DisplayBindings/EditorBindings/Gui/Pads src/Main/Base src/Main/Base/Gui/Pads src/Main/Base/Gui/Workbench src/Main/Base/Gui/Workbench/Layouts
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r812%20-%20in%20trunk/MonoDevelop%3A%20gdldock/gdl%20gdldock/sources/gdl%20src/AddIns/DisplayBindings/EditorBindings/Gui/Pads%20src/Main/Base%20src/Main/Base/Gui/Pads%20src/Main/Base/Gui/Workbench%20src/Main/Base/Gui/Workbench/Layouts&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000416.html">
   <LINK REL="Next"  HREF="000418.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r812 - in trunk/MonoDevelop: gdldock/gdl gdldock/sources/gdl src/AddIns/DisplayBindings/EditorBindings/Gui/Pads src/Main/Base src/Main/Base/Gui/Pads src/Main/Base/Gui/Workbench src/Main/Base/Gui/Workbench/Layouts</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r812%20-%20in%20trunk/MonoDevelop%3A%20gdldock/gdl%20gdldock/sources/gdl%20src/AddIns/DisplayBindings/EditorBindings/Gui/Pads%20src/Main/Base%20src/Main/Base/Gui/Pads%20src/Main/Base/Gui/Workbench%20src/Main/Base/Gui/Workbench/Layouts&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r812 - in trunk/MonoDevelop: gdldock/gdl gdldock/sources/gdl src/AddIns/DisplayBindings/EditorBindings/Gui/Pads src/Main/Base src/Main/Base/Gui/Pads src/Main/Base/Gui/Workbench src/Main/Base/Gui/Workbench/Layouts">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sat Feb  7 18:22:11 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000416.html">[Monodevelop-patches-list] r811 - in trunk/MonoDevelop/src: Libraries/MonoDevelop.Gui.Widgets/FileBrowser Main/Base/Gui/Pads
</A></li>
        <LI>Next message: <A HREF="000418.html">[Monodevelop-patches-list] r813 - in trunk/MonoDevelop: . src/Main/Base/Gui/Dialogs/OptionPanels/IDEOptions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#417">[ date ]</a>
              <a href="thread.html#417">[ thread ]</a>
              <a href="subject.html#417">[ subject ]</a>
              <a href="author.html#417">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jzwart
Date: 2004-02-07 18:22:11 -0500 (Sat, 07 Feb 2004)
New Revision: 812

Added:
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-bar.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-bar.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-stock.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-stock.h
   trunk/MonoDevelop/gdldock/sources/gdl/stock-close-12.png
   trunk/MonoDevelop/gdldock/sources/gdl/stock-menu-left-12.png
   trunk/MonoDevelop/gdldock/sources/gdl/stock-menu-right-12.png
Modified:
   trunk/MonoDevelop/gdldock/gdl/gdl-api.xml
   trunk/MonoDevelop/gdldock/sources/gdl/Makefile
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.h
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.c
   trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.h
   trunk/MonoDevelop/src/AddIns/DisplayBindings/EditorBindings/Gui/Pads/CompilerMessageView.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Pads/OpenTaskView.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Workbench/DefaultWorkbench.cs
   trunk/MonoDevelop/src/Main/Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs
   trunk/MonoDevelop/src/Main/Base/Makefile
Log:
Using GdlDock now instead of the hack with multiple Notebook's and Paned's. Also
some HIG fixes in the TaskView and CompilerMessageView.



Modified: trunk/MonoDevelop/gdldock/gdl/gdl-api.xml
===================================================================
--- trunk/MonoDevelop/gdldock/gdl/gdl-api.xml	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/gdl/gdl-api.xml	2004-02-07 23:22:11 UTC (rev 812)
@@ -21,7 +21,8 @@
     &lt;enum name=&quot;DockItemFlags&quot; cname=&quot;GdlDockItemFlags&quot; type=&quot;enum&quot; hidden=&quot;1&quot;&gt;
       &lt;member cname=&quot;GDL_DOCK_IN_DRAG&quot; name=&quot;InDrag&quot; value=&quot;1 &amp;lt;&amp;lt; GDL_DOCK_OBJECT_FLAGS_SHIFT&quot; /&gt;
       &lt;member cname=&quot;GDL_DOCK_IN_PREDRAG&quot; name=&quot;InPredrag&quot; value=&quot;1 &amp;lt;&amp;lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 1)&quot; /&gt;
-      &lt;member cname=&quot;GDL_DOCK_USER_ACTION&quot; name=&quot;UserAction&quot; value=&quot;1 &amp;lt;&amp;lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 2)&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_ICONIFIED&quot; name=&quot;Iconified&quot; value=&quot;1 &amp;lt;&amp;lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 2)&quot; /&gt;
+      &lt;member cname=&quot;GDL_DOCK_USER_ACTION&quot; name=&quot;UserAction&quot; value=&quot;1 &amp;lt;&amp;lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 3)&quot; /&gt;
     &lt;/enum&gt;
     &lt;enum name=&quot;DockObjectFlags&quot; cname=&quot;GdlDockObjectFlags&quot; type=&quot;flags&quot;&gt;
       &lt;member cname=&quot;GDL_DOCK_AUTOMATIC&quot; name=&quot;Automatic&quot; value=&quot;1 &amp;lt;&amp;lt; 0&quot; /&gt;
@@ -109,6 +110,19 @@
         &lt;/parameters&gt;
       &lt;/method&gt;
     &lt;/object&gt;
+    &lt;object name=&quot;DockBar&quot; cname=&quot;GdlDockBar&quot; parent=&quot;GtkVBox&quot;&gt;
+      &lt;field cname=&quot;dock&quot; type=&quot;GdlDock*&quot; /&gt;
+      &lt;field cname=&quot;_priv&quot; type=&quot;GdlDockBarPrivate*&quot; /&gt;
+      &lt;property name=&quot;Master&quot; cname=&quot;master&quot; type=&quot;GdlDockMaster&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;method name=&quot;GetType&quot; cname=&quot;gdl_dock_bar_get_type&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;GType&quot; /&gt;
+      &lt;/method&gt;
+      &lt;constructor cname=&quot;gdl_dock_bar_new&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;GdlDock*&quot; name=&quot;dock&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
+    &lt;/object&gt;
     &lt;object name=&quot;DockItem&quot; cname=&quot;GdlDockItem&quot; parent=&quot;GdlDockObject&quot;&gt;
       &lt;field cname=&quot;child&quot; type=&quot;GtkWidget*&quot; /&gt;
       &lt;field cname=&quot;behavior&quot; type=&quot;GdlDockItemBehavior&quot; /&gt;
@@ -120,7 +134,6 @@
       &lt;property name=&quot;Orientation&quot; cname=&quot;orientation&quot; type=&quot;GtkOrientation&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
       &lt;property name=&quot;Resize&quot; cname=&quot;resize&quot; type=&quot;gboolean&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
       &lt;property name=&quot;Behavior&quot; cname=&quot;behavior&quot; type=&quot;GdlDockItemBehavior&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
-      &lt;property name=&quot;GripSize&quot; cname=&quot;grip_size&quot; type=&quot;guint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
       &lt;property name=&quot;Locked&quot; cname=&quot;locked&quot; type=&quot;gboolean&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
       &lt;property name=&quot;PreferredWidth&quot; cname=&quot;preferred_width&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
       &lt;property name=&quot;PreferredHeight&quot; cname=&quot;preferred_height&quot; type=&quot;gint&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
@@ -171,6 +184,9 @@
       &lt;method name=&quot;HideItem&quot; cname=&quot;gdl_dock_item_hide_item&quot;&gt;
         &lt;return-type type=&quot;void&quot; /&gt;
       &lt;/method&gt;
+      &lt;method name=&quot;IconifyItem&quot; cname=&quot;gdl_dock_item_iconify_item&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
       &lt;method name=&quot;Lock&quot; cname=&quot;gdl_dock_item_lock&quot;&gt;
         &lt;return-type type=&quot;void&quot; /&gt;
       &lt;/method&gt;
@@ -181,6 +197,14 @@
           &lt;parameter type=&quot;GdlDockItemBehavior&quot; name=&quot;behavior&quot; /&gt;
         &lt;/parameters&gt;
       &lt;/constructor&gt;
+      &lt;constructor cname=&quot;gdl_dock_item_new_with_stock&quot;&gt;
+        &lt;parameters&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;name&quot; /&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;long_name&quot; /&gt;
+          &lt;parameter type=&quot;const-gchar*&quot; name=&quot;stock_id&quot; /&gt;
+          &lt;parameter type=&quot;GdlDockItemBehavior&quot; name=&quot;behavior&quot; /&gt;
+        &lt;/parameters&gt;
+      &lt;/constructor&gt;
       &lt;method name=&quot;PreferredSize&quot; cname=&quot;gdl_dock_item_preferred_size&quot;&gt;
         &lt;return-type type=&quot;void&quot; /&gt;
         &lt;parameters&gt;
@@ -218,8 +242,11 @@
         &lt;return-type type=&quot;void&quot; /&gt;
       &lt;/method&gt;
     &lt;/object&gt;
-    &lt;object name=&quot;DockItemGrip&quot; cname=&quot;GdlDockItemGrip&quot; parent=&quot;GtkWidget&quot;&gt;
+    &lt;object name=&quot;DockItemGrip&quot; cname=&quot;GdlDockItemGrip&quot; parent=&quot;GtkContainer&quot;&gt;
       &lt;field cname=&quot;item&quot; type=&quot;GdlDockItem*&quot; /&gt;
+      &lt;field cname=&quot;title_window&quot; type=&quot;GdkWindow*&quot; /&gt;
+      &lt;field cname=&quot;_priv&quot; type=&quot;GdlDockItemGripPrivate*&quot; /&gt;
+      &lt;property name=&quot;Item&quot; cname=&quot;item&quot; type=&quot;GdlDockItem&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
       &lt;signal name=&quot;Activate&quot; cname=&quot;activate&quot; when=&quot;LAST&quot;&gt;
         &lt;return-type type=&quot;GCclosureMarshalVoid_Void&quot; /&gt;
         &lt;parameters&gt;
@@ -380,9 +407,11 @@
       &lt;field cname=&quot;master&quot; type=&quot;GObject*&quot; /&gt;
       &lt;field cname=&quot;name&quot; type=&quot;gchar*&quot; /&gt;
       &lt;field cname=&quot;long_name&quot; type=&quot;gchar*&quot; /&gt;
+      &lt;field cname=&quot;stock_id&quot; type=&quot;gchar*&quot; /&gt;
       &lt;field cname=&quot;reduce_pending&quot; type=&quot;gboolean&quot; /&gt;
       &lt;property name=&quot;Name&quot; cname=&quot;name&quot; type=&quot;gchar*&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
       &lt;property name=&quot;LongName&quot; cname=&quot;long_name&quot; type=&quot;gchar*&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
+      &lt;property name=&quot;StockId&quot; cname=&quot;stock_id&quot; type=&quot;gchar*&quot; readable=&quot;true&quot; writeable=&quot;true&quot; /&gt;
       &lt;property name=&quot;Master&quot; cname=&quot;master&quot; type=&quot;GdlDockMaster&quot; readable=&quot;true&quot; writeable=&quot;true&quot; construct-only=&quot;true&quot; /&gt;
       &lt;signal cname=&quot;detach&quot; when=&quot;LAST&quot; name=&quot;Detached&quot;&gt;
         &lt;return-type type=&quot;void&quot; /&gt;
@@ -568,5 +597,15 @@
       &lt;field cname=&quot;rect&quot; type=&quot;GdkRectangle&quot; /&gt;
       &lt;field cname=&quot;extra&quot; type=&quot;GValue&quot; /&gt;
     &lt;/struct&gt;
+    &lt;class name=&quot;Global&quot; cname=&quot;GdlGlobal&quot;&gt;
+      &lt;method name=&quot;StockInit&quot; cname=&quot;gdl_stock_init&quot; shared=&quot;true&quot;&gt;
+        &lt;return-type type=&quot;void&quot; /&gt;
+      &lt;/method&gt;
+    &lt;/class&gt;
+    &lt;object name=&quot;Stock&quot; cname=&quot;GdlStock&quot;&gt;
+      &lt;static-string cname=&quot;GDL_STOCK_CLOSE&quot; name=&quot;Close&quot; value=&quot;gdl-close&quot; /&gt;
+      &lt;static-string cname=&quot;GDL_STOCK_MENU_LEFT&quot; name=&quot;MenuLeft&quot; value=&quot;gdl-menu-left&quot; /&gt;
+      &lt;static-string cname=&quot;GDL_STOCK_MENU_RIGHT&quot; name=&quot;MenuRight&quot; value=&quot;gdl-menu-right&quot; /&gt;
+    &lt;/object&gt;
   &lt;/namespace&gt;
 &lt;/api&gt;
\ No newline at end of file

Modified: trunk/MonoDevelop/gdldock/sources/gdl/Makefile
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/Makefile	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/Makefile	2004-02-07 23:22:11 UTC (rev 812)
@@ -15,6 +15,7 @@
 	$(GDL_DEPENDENCIES_CFLAGS)
 
 libgdldock_headers = \
+	gdl-dock-bar.h \
 	gdl-dock-object.h \
 	gdl-dock-master.h \
 	gdl-dock.h \
@@ -25,10 +26,12 @@
 	gdl-dock-tablabel.h \
 	gdl-dock-layout.h \
 	gdl-dock-placeholder.h \
+	gdl-stock.h
 
 libgdldock_SOURCES = \
 	$(libgdldock_headers) \
 	gdl-i18n.h \
+	gdl-dock-bar.c \
 	gdl-dock-object.c \
 	gdl-dock-master.c \
 	gdl-dock.c \
@@ -39,6 +42,7 @@
 	gdl-dock-tablabel.c \
 	gdl-dock-layout.c \
 	gdl-dock-placeholder.c \
+	gdl-stock.c \
 	libgdltypebuiltins.c \
 	libgdlmarshal.c
 
@@ -56,11 +60,12 @@
 
 libgdldock.so: $(libgdldock_OBJECTS)
 	$(CC) $(LDFLAGS) -shared -fPIC -o libgdldock.so $+ &amp;&amp; \
-	cp libgdldock.so ../../../build/bin
+	cp libgdldock.so ../../../build/bin &amp;&amp; \
+	cp *.png ../../../build/bin
 
 %.o: %.c
 	$(CC) $(CFLAGS) $(INCLUDES) -c $&lt;
-
+	
 # enumerations code generation
 
 libgdltypebuiltins.c: $(libgdldock_headers)

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-bar.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-bar.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-bar.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -0,0 +1,339 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- 
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2003 Jeroen Zwartepoorte &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &quot;gdl-i18n.h&quot;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;gdl-tools.h&quot;
+#include &quot;gdl-dock.h&quot;
+#include &quot;gdl-dock-master.h&quot;
+#include &quot;gdl-dock-bar.h&quot;
+
+enum {
+    PROP_0,
+    PROP_MASTER,
+};
+
+/* ----- Private prototypes ----- */
+
+static void  gdl_dock_bar_class_init      (GdlDockBarClass *klass);
+static void  gdl_dock_bar_instance_init   (GdlDockBar      *dockbar);
+
+static void  gdl_dock_bar_get_property    (GObject         *object,
+                                           guint            prop_id,
+                                           GValue          *value,
+                                           GParamSpec      *pspec);
+static void  gdl_dock_bar_set_property    (GObject         *object,
+                                           guint            prop_id,
+                                           const GValue    *value,
+                                           GParamSpec      *pspec);
+
+static void  gdl_dock_bar_destroy         (GtkObject       *object);
+
+static void  gdl_dock_bar_attach          (GdlDockBar      *dockbar,
+                                           GdlDockMaster   *master);
+
+/* ----- Class variables and definitions ----- */
+
+struct _GdlDockBarPrivate {
+    GdlDockMaster *master;
+    GSList        *items;
+    GtkTooltips   *tooltips;
+};
+
+/* ----- Private functions ----- */
+
+GDL_CLASS_BOILERPLATE (GdlDockBar, gdl_dock_bar, GtkVBox, GTK_TYPE_VBOX);
+
+static void
+gdl_dock_bar_class_init (GdlDockBarClass *klass)
+{
+    GObjectClass       *g_object_class;
+    GtkObjectClass     *gtk_object_class;
+    
+    g_object_class = G_OBJECT_CLASS (klass);
+    gtk_object_class = GTK_OBJECT_CLASS (klass);
+
+    g_object_class-&gt;get_property = gdl_dock_bar_get_property;
+    g_object_class-&gt;set_property = gdl_dock_bar_set_property;
+
+    gtk_object_class-&gt;destroy = gdl_dock_bar_destroy;
+
+    g_object_class_install_property (
+        g_object_class, PROP_MASTER,
+        g_param_spec_object (&quot;master&quot;, _(&quot;Master&quot;),
+                             _(&quot;GdlDockMaster object which the dockbar widget &quot;
+                               &quot;is attached to&quot;),
+                             GDL_TYPE_DOCK_MASTER, 
+                             G_PARAM_READWRITE));
+}
+
+static void
+gdl_dock_bar_instance_init (GdlDockBar *dockbar)
+{
+    dockbar-&gt;_priv = g_new0 (GdlDockBarPrivate, 1);
+    dockbar-&gt;_priv-&gt;master = NULL;
+    dockbar-&gt;_priv-&gt;items = NULL;
+    dockbar-&gt;_priv-&gt;tooltips = gtk_tooltips_new ();
+}
+
+static void
+gdl_dock_bar_get_property (GObject         *object,
+                           guint            prop_id,
+                           GValue          *value,
+                           GParamSpec      *pspec)
+{
+    GdlDockBar *dockbar = GDL_DOCK_BAR (object);
+
+    switch (prop_id) {
+        case PROP_MASTER:
+            g_value_set_object (value, dockbar-&gt;_priv-&gt;master);
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    };
+}
+
+static void
+gdl_dock_bar_set_property (GObject         *object,
+                           guint            prop_id,
+                           const GValue    *value,
+                           GParamSpec      *pspec)
+{
+    GdlDockBar *dockbar = GDL_DOCK_BAR (object);
+
+    switch (prop_id) {
+        case PROP_MASTER:
+            gdl_dock_bar_attach (dockbar, g_value_get_object (value));
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    };
+}
+
+static void
+gdl_dock_bar_destroy (GtkObject *object)
+{
+    GdlDockBar *dockbar = GDL_DOCK_BAR (object);
+
+    if (dockbar-&gt;_priv) {
+        GdlDockBarPrivate *priv = dockbar-&gt;_priv;
+        
+        if (priv-&gt;master) {
+            g_signal_handlers_disconnect_matched (priv-&gt;master,
+                                                  G_SIGNAL_MATCH_DATA,
+                                                  0, 0, NULL, NULL, dockbar);
+            g_object_unref (priv-&gt;master);
+            priv-&gt;master = NULL;
+        }
+
+        if (priv-&gt;tooltips) {
+            gtk_object_destroy (GTK_OBJECT (priv-&gt;tooltips));
+            priv-&gt;tooltips = NULL;
+        }
+        
+        dockbar-&gt;_priv = NULL;
+
+        g_free (priv);
+    }
+    
+    GDL_CALL_PARENT (GTK_OBJECT_CLASS, destroy, (object));
+}
+
+static void
+gdl_dock_bar_remove_item (GdlDockBar  *dockbar,
+                          GdlDockItem *item)
+{
+    GdlDockBarPrivate *priv;
+    GtkWidget *button;
+
+    g_return_if_fail (GDL_IS_DOCK_BAR (dockbar));
+    g_return_if_fail (GDL_IS_DOCK_ITEM (item));
+
+    priv = dockbar-&gt;_priv;
+
+    if (g_slist_index (priv-&gt;items, item) == -1) {
+        g_warning (&quot;Item has not been added to the dockbar&quot;);
+        return;
+    }
+    
+    priv-&gt;items = g_slist_remove (priv-&gt;items, item);
+    
+    button = g_object_get_data (G_OBJECT (item), &quot;GdlDockBarButton&quot;);
+    g_assert (button != NULL);
+    gtk_container_remove (GTK_CONTAINER (dockbar), button);
+    g_object_set_data (G_OBJECT (item), &quot;GdlDockBarButton&quot;, NULL);
+}
+
+static void
+gdl_dock_bar_item_clicked (GtkWidget   *button,
+                           GdlDockItem *item)
+{
+    GdlDockBar *dockbar;
+    GdlDockObject *controller;
+
+    g_return_if_fail (item != NULL);
+    
+    dockbar = g_object_get_data (G_OBJECT (item), &quot;GdlDockBar&quot;);
+    g_assert (dockbar != NULL);
+    g_object_set_data (G_OBJECT (item), &quot;GdlDockBar&quot;, NULL);
+
+    controller = gdl_dock_master_get_controller (GDL_DOCK_OBJECT_GET_MASTER (item));
+
+    GDL_DOCK_OBJECT_UNSET_FLAGS (item, GDL_DOCK_ICONIFIED);
+    gdl_dock_item_show_item (item);
+    gdl_dock_bar_remove_item (dockbar, item);
+    gtk_widget_queue_resize (GTK_WIDGET (controller));
+}
+
+static void
+gdl_dock_bar_add_item (GdlDockBar  *dockbar,
+                       GdlDockItem *item)
+{
+    GdlDockBarPrivate *priv;
+    GtkWidget *button;
+    gchar *stock_id;
+    gchar *name;
+    GtkWidget *image;
+
+    g_return_if_fail (GDL_IS_DOCK_BAR (dockbar));
+    g_return_if_fail (GDL_IS_DOCK_ITEM (item));
+
+    priv = dockbar-&gt;_priv;
+
+    if (g_slist_index (priv-&gt;items, item) != -1) {
+        g_warning (&quot;Item has already been added to the dockbar&quot;);
+        return;
+    }
+
+    priv-&gt;items = g_slist_append (priv-&gt;items, item);
+    
+    /* Create a button for the item. */
+    button = gtk_button_new ();
+    gtk_button_set_relief (GTK_BUTTON (button), GTK_RELIEF_NONE);
+    
+    g_object_get (item, &quot;stock_id&quot;, &amp;stock_id, &quot;long_name&quot;, &amp;name, NULL);
+    if (stock_id) {
+        image = gtk_image_new_from_stock (stock_id,
+                                          GTK_ICON_SIZE_SMALL_TOOLBAR);
+        g_free (stock_id);
+    } else {
+        image = gtk_image_new_from_stock (GTK_STOCK_NEW,
+                                          GTK_ICON_SIZE_SMALL_TOOLBAR);
+    }
+    gtk_container_add (GTK_CONTAINER (button), image);
+    gtk_box_pack_start (GTK_BOX (dockbar), button, FALSE, FALSE, 0);
+
+    gtk_tooltips_set_tip (priv-&gt;tooltips, button, name, name);
+
+    g_object_set_data (G_OBJECT (item), &quot;GdlDockBar&quot;, dockbar);
+    g_object_set_data (G_OBJECT (item), &quot;GdlDockBarButton&quot;, button);
+    g_signal_connect (G_OBJECT (button), &quot;clicked&quot;,
+                      G_CALLBACK (gdl_dock_bar_item_clicked), item);
+
+    gtk_widget_show_all (button);
+}
+
+static void
+build_list (GdlDockObject *object, GList **list)
+{
+    /* add only items, not toplevels */
+    if (GDL_IS_DOCK_ITEM (object))
+        *list = g_list_prepend (*list, object);
+}
+
+static void
+update_dock_items (GdlDockBar *dockbar)
+{
+    GdlDockMaster *master;
+    GList *items, *l;
+
+    g_return_if_fail (dockbar != NULL);
+    
+    if (!dockbar-&gt;_priv-&gt;master)
+        return;
+
+    master = dockbar-&gt;_priv-&gt;master;
+    
+    /* build items list */
+    items = NULL;
+    gdl_dock_master_foreach (master, (GFunc) build_list, &amp;items);
+    
+    for (l = items; l != NULL; l = l-&gt;next) {
+        GdlDockItem *item = GDL_DOCK_ITEM (l-&gt;data);
+        
+        if (GDL_DOCK_ITEM_ICONIFIED (item))
+	        gdl_dock_bar_add_item (dockbar, item);
+    }
+    
+    g_list_free (items);
+}
+
+static void
+gdl_dock_bar_layout_changed_cb (GdlDockMaster *master,
+                                GdlDockBar    *dockbar)
+{
+    update_dock_items (dockbar);
+}
+
+static void
+gdl_dock_bar_attach (GdlDockBar    *dockbar,
+                     GdlDockMaster *master)
+{
+    g_return_if_fail (dockbar != NULL);
+    g_return_if_fail (master == NULL || GDL_IS_DOCK_MASTER (master));
+    
+    if (dockbar-&gt;_priv-&gt;master) {
+        g_signal_handlers_disconnect_matched (dockbar-&gt;_priv-&gt;master,
+                                              G_SIGNAL_MATCH_DATA,
+                                              0, 0, NULL, NULL, dockbar);
+        g_object_unref (dockbar-&gt;_priv-&gt;master);
+    }
+    
+    dockbar-&gt;_priv-&gt;master = master;
+    if (dockbar-&gt;_priv-&gt;master) {
+        g_object_ref (dockbar-&gt;_priv-&gt;master);
+        g_signal_connect (dockbar-&gt;_priv-&gt;master, &quot;layout_changed&quot;,
+                          G_CALLBACK (gdl_dock_bar_layout_changed_cb),
+                          dockbar);
+    }
+
+    update_dock_items (dockbar);
+}
+
+GtkWidget *
+gdl_dock_bar_new (GdlDock *dock)
+{
+    GdlDockMaster *master = NULL;
+    
+    /* get the master of the given dock */
+    if (dock)
+        master = GDL_DOCK_OBJECT_GET_MASTER (dock);
+
+    return g_object_new (GDL_TYPE_DOCK_BAR,
+                         &quot;master&quot;, master, NULL);
+}

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-bar.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-bar.h	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-bar.h	2004-02-07 23:22:11 UTC (rev 812)
@@ -0,0 +1,61 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This file is part of the GNOME Devtools Libraries.
+ *
+ * Copyright (C) 2003 Jeroen Zwartepoorte &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.  
+ */
+
+#ifndef __GDL_DOCK_BAR_H__
+#define __GDL_DOCK_BAR_H__
+
+#include &lt;gtk/gtkvbox.h&gt;
+
+G_BEGIN_DECLS
+
+/* standard macros */
+#define GDL_TYPE_DOCK_BAR            (gdl_dock_bar_get_type ())
+#define GDL_DOCK_BAR(obj)            (GTK_CHECK_CAST ((obj), GDL_TYPE_DOCK_BAR, GdlDockBar))
+#define GDL_DOCK_BAR_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GDL_TYPE_DOCK_BAR, GdlDockBarClass))
+#define GDL_IS_DOCK_BAR(obj)         (GTK_CHECK_TYPE ((obj), GDL_TYPE_DOCK_BAR))
+#define GDL_IS_DOCK_BAR_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GDL_TYPE_DOCK_BAR))
+#define GDL_DOCK_BAR_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), GTK_TYPE_DOCK_BAR, GdlDockBarClass))
+
+/* data types &amp; structures */
+typedef struct _GdlDockBar        GdlDockBar;
+typedef struct _GdlDockBarClass   GdlDockBarClass;
+typedef struct _GdlDockBarPrivate GdlDockBarPrivate;
+
+struct _GdlDockBar {
+    GtkVBox parent;
+
+    GdlDock *dock;
+
+    GdlDockBarPrivate *_priv;
+};
+
+struct _GdlDockBarClass {
+    GtkVBoxClass parent_class;
+};
+
+GType      gdl_dock_bar_get_type       (void); 
+
+GtkWidget *gdl_dock_bar_new            (GdlDock     *dock);
+
+G_END_DECLS
+
+#endif /* __GDL_DOCK_BAR_H__ */

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -24,6 +24,7 @@
 #include &quot;gdl-dock-item.h&quot;
 #include &quot;gdl-dock-item-grip.h&quot;
 #include &quot;gdl-dock.h&quot;
+#include &quot;gdl-stock.h&quot;
 #include &quot;gdl-tools.h&quot;
 
 #define A11Y_UNFINISHED
@@ -34,53 +35,126 @@
 };
 static guint signals [LAST_SIGNAL];
 
+enum {
+    PROP_0,
+    PROP_ITEM
+};
+ 
+struct _GdlDockItemGripPrivate {
+    GtkWidget   *close_button;
+    GtkWidget   *iconify_button;
+    GtkTooltips *tooltips;
+
+    GdkPixbuf   *icon_pixbuf;
+    PangoLayout *title_layout;
+};
+ 
 GDL_CLASS_BOILERPLATE (GdlDockItemGrip, gdl_dock_item_grip,
-			 GtkWidget, GTK_TYPE_WIDGET);
+		       GtkContainer, GTK_TYPE_CONTAINER);
 
+static void
+gdl_dock_item_grip_get_title_area (GdlDockItemGrip *grip,
+                                   GdkRectangle    *area)
+{
+    GtkWidget *widget = GTK_WIDGET (grip);
+    gint       border = GTK_CONTAINER (grip)-&gt;border_width;
+
+    area-&gt;x      = widget-&gt;allocation.x + border;
+    area-&gt;y      = widget-&gt;allocation.y + border;
+    area-&gt;width  = (widget-&gt;allocation.width -
+                    2 * border -
+                    2 * grip-&gt;_priv-&gt;close_button-&gt;allocation.width);
+    area-&gt;height = grip-&gt;_priv-&gt;close_button-&gt;allocation.height;
+
+    if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
+        area-&gt;x += 2 * grip-&gt;_priv-&gt;close_button-&gt;allocation.width;
+}
+  
 static gint
 gdl_dock_item_grip_expose (GtkWidget      *widget,
 			   GdkEventExpose *event)
 {
-    GdkRectangle *clip = &amp;event-&gt;area;
-    GdkRectangle *rect = &amp;widget-&gt;allocation;
-    GdlDockItemGrip *grip = (GdlDockItemGrip *) widget;
-    GtkShadowType shadow = GTK_SHADOW_OUT;
+    GdlDockItemGrip *grip;
+    gint             border;
+    gchar           *stock_id;
+    GdkRectangle     pixbuf_rect;
+    gint             pixbuf_width;
+    GdkRectangle     title_area;
+    GdkRectangle     expose_area;
+    gchar           *name;
+    gint             layout_width;
+    gint             layout_height;
+    gint             text_x;
+    gint             text_y;
 
-    gtk_paint_handle (widget-&gt;style,
-                      widget-&gt;window,
-                      GTK_WIDGET_STATE (widget),
-                      shadow,
-                      clip, widget, &quot;dockitem&quot;,
-                      rect-&gt;x, rect-&gt;y, rect-&gt;width, rect-&gt;height, 
-                      grip-&gt;item-&gt;orientation);
+    grip = GDL_DOCK_ITEM_GRIP (widget);
+    border = GTK_CONTAINER (grip)-&gt;border_width;
 
-    if (GTK_WIDGET_HAS_FOCUS (widget)) {
-        gint focus_width;
-        gint focus_pad;
-        GdkRectangle focus;
-		
-        gtk_widget_style_get (GTK_WIDGET (widget),
-                              &quot;focus-line-width&quot;, &amp;focus_width,
-                              &quot;focus-padding&quot;, &amp;focus_pad,
-                              NULL); 
-		
-        focus = *rect;
-        focus.x += widget-&gt;style-&gt;xthickness + focus_pad;
-        focus.y += widget-&gt;style-&gt;ythickness + focus_pad;
-        focus.width -= 2 * (widget-&gt;style-&gt;xthickness + focus_pad);
-        focus.height -= 2 * (widget-&gt;style-&gt;xthickness + focus_pad);
-		
-        gtk_paint_focus (widget-&gt;style, widget-&gt;window,
-                         GTK_WIDGET_STATE (widget),
-                         clip, widget, &quot;dockitem&quot;,
-                         focus.x, focus.y,
-                         focus.width, focus.height);
+    g_object_get (G_OBJECT (grip-&gt;item), &quot;stock_id&quot;, &amp;stock_id, NULL);
+    if (stock_id) {
+        GdkPixbuf *pixbuf;
+        
+        if (!grip-&gt;_priv-&gt;icon_pixbuf) {
+            pixbuf = gtk_widget_render_icon (widget, stock_id,
+                                             GTK_ICON_SIZE_MENU, &quot;&quot;);
+            grip-&gt;_priv-&gt;icon_pixbuf = pixbuf;
+        } else {
+            pixbuf = grip-&gt;_priv-&gt;icon_pixbuf;
+        }
+        
+        g_free (stock_id);
+
+        pixbuf_rect.width = gdk_pixbuf_get_width (pixbuf);
+        pixbuf_rect.height = gdk_pixbuf_get_height (pixbuf);
+        pixbuf_rect.x = widget-&gt;allocation.x + border;
+        pixbuf_rect.y = widget-&gt;allocation.y + border +
+                        (widget-&gt;allocation.height - pixbuf_rect.height) / 2;
+
+        if (gdk_rectangle_intersect (&amp;event-&gt;area, &amp;pixbuf_rect, &amp;expose_area)) {
+            GdkGC *gc;
+            GtkStyle *style;
+
+            style = gtk_widget_get_style (widget);
+            gc = style-&gt;bg_gc[widget-&gt;state];
+            gdk_draw_pixbuf (GDK_DRAWABLE (widget-&gt;window), gc, pixbuf,
+                             0, 0, pixbuf_rect.x, pixbuf_rect.y,
+                             pixbuf_rect.width, pixbuf_rect.height,
+                             GDK_RGB_DITHER_NONE, 0, 0);
+	}
+
+	pixbuf_width = pixbuf_rect.width + 1;
+    } else {
+        pixbuf_width = 0;
     }
 
-    return FALSE;
-}
+    gdl_dock_item_grip_get_title_area (grip, &amp;title_area);
 
+    if (gdk_rectangle_intersect (&amp;title_area, &amp;event-&gt;area, &amp;expose_area)) {
+        if (!grip-&gt;_priv-&gt;title_layout) {
+            g_object_get (G_OBJECT (grip-&gt;item), &quot;long_name&quot;, &amp;name, NULL);
+            grip-&gt;_priv-&gt;title_layout = gtk_widget_create_pango_layout (widget,
+                                                                        name);
+            g_free (name);
+        }
 
+        pango_layout_get_pixel_size (grip-&gt;_priv-&gt;title_layout, &amp;layout_width,
+                                     &amp;layout_height);
+
+        if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR)
+            text_x = title_area.x + pixbuf_width;
+        else
+            text_x = title_area.x + title_area.width - layout_width - pixbuf_width;
+
+        text_y = title_area.y + (title_area.height - layout_height) / 2;
+
+        gtk_paint_layout (widget-&gt;style, widget-&gt;window, widget-&gt;state, TRUE,
+                          &amp;expose_area, widget, NULL, text_x, text_y,
+                          grip-&gt;_priv-&gt;title_layout);
+    }
+
+    return GTK_WIDGET_CLASS (parent_class)-&gt;expose_event (widget, event);
+}  
+
 #ifndef A11Y_UNFINISHED
 
 static AtkObjectClass *a11y_parent_class = NULL;
@@ -270,16 +344,168 @@
 }
 
 static void
-gdl_dock_item_grip_dispose (GObject *object)
+gdl_dock_item_grip_item_notify (GObject    *master,
+                                GParamSpec *pspec,
+                                gpointer    data)
 {
-    GDL_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+    GdlDockItemGrip *grip;
+    gchar           *name;
+    gchar           *stock_id;
+
+    grip = GDL_DOCK_ITEM_GRIP (data);
+
+    g_object_get (master, &quot;long_name&quot;, &amp;name, &quot;stock_id&quot;, &amp;stock_id, NULL);
+    if (name) {
+        g_object_unref (grip-&gt;_priv-&gt;title_layout);
+        grip-&gt;_priv-&gt;title_layout = NULL;
+        g_free (name);
+    }
+    if (stock_id) {
+        g_object_unref (grip-&gt;_priv-&gt;icon_pixbuf);
+        grip-&gt;_priv-&gt;icon_pixbuf = NULL;
+        g_free (stock_id);
+    }
+
+    gtk_widget_queue_resize (GTK_WIDGET (grip));
 }
 
 static void
+gdl_dock_item_grip_destroy (GtkObject *object)
+{
+    GdlDockItemGrip *grip = GDL_DOCK_ITEM_GRIP (object);
+    
+    if (grip-&gt;_priv) {
+        GdlDockItemGripPrivate *priv = grip-&gt;_priv;
+
+        if (priv-&gt;title_layout) {
+            g_object_unref (priv-&gt;title_layout);
+            priv-&gt;title_layout = NULL;
+        }
+        
+        if (priv-&gt;icon_pixbuf) {
+            g_object_unref (priv-&gt;icon_pixbuf);
+            priv-&gt;icon_pixbuf = NULL;
+        }
+
+        if (priv-&gt;tooltips) {
+            gtk_object_destroy (GTK_OBJECT (priv-&gt;tooltips));
+            priv-&gt;tooltips = NULL;
+        }
+
+        g_signal_handlers_disconnect_by_func (grip-&gt;item,
+                                              gdl_dock_item_grip_item_notify,
+                                              grip);
+        grip-&gt;item = NULL;
+
+        grip-&gt;_priv = NULL;
+        g_free (priv);
+    }
+
+    GDL_CALL_PARENT (GTK_OBJECT_CLASS, destroy, (object));
+}
+
+static void
+gdl_dock_item_grip_set_property (GObject      *object,
+                                 guint         prop_id,
+                                 const GValue *value,
+                                 GParamSpec   *pspec)
+{
+    GdlDockItemGrip *grip;
+
+    g_return_if_fail (GDL_IS_DOCK_ITEM_GRIP (object));
+
+    grip = GDL_DOCK_ITEM_GRIP (object);
+    
+    switch (prop_id) {
+        case PROP_ITEM:
+            grip-&gt;item = g_value_get_object (value);
+            if (grip-&gt;item) {
+                g_signal_connect (grip-&gt;item, &quot;notify::long_name&quot;,
+                                  G_CALLBACK (gdl_dock_item_grip_item_notify),
+                                  grip);
+                g_signal_connect (grip-&gt;item, &quot;notify::stock_id&quot;,
+                                  G_CALLBACK (gdl_dock_item_grip_item_notify),
+                                  grip);
+            }
+            break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+gdl_dock_item_grip_close_clicked (GtkWidget       *widget,
+                                  GdlDockItemGrip *grip)
+{
+    g_return_if_fail (grip-&gt;item != NULL);
+
+    gdl_dock_item_hide_item (grip-&gt;item);
+}
+
+static void
+gdl_dock_item_grip_iconify_clicked (GtkWidget       *widget,
+                                    GdlDockItemGrip *grip)
+{
+    g_return_if_fail (grip-&gt;item != NULL);
+
+    gdl_dock_item_iconify_item (grip-&gt;item);
+    
+    /* Workaround to unhighlight the iconify button. */
+    GTK_BUTTON (grip-&gt;_priv-&gt;iconify_button)-&gt;in_button = FALSE;
+    gtk_button_leave (GTK_BUTTON (grip-&gt;_priv-&gt;iconify_button));
+}
+  
+static void
 gdl_dock_item_grip_instance_init (GdlDockItemGrip *grip)
 {
-    GTK_WIDGET_SET_FLAGS (grip, GTK_CAN_FOCUS);
+    GtkWidget *image;
+
     GTK_WIDGET_SET_FLAGS (grip, GTK_NO_WINDOW);
+    
+    grip-&gt;_priv = g_new0 (GdlDockItemGripPrivate, 1);
+    grip-&gt;_priv-&gt;icon_pixbuf = NULL;
+    grip-&gt;_priv-&gt;title_layout = NULL;
+
+    gdl_stock_init ();
+
+    gtk_widget_push_composite_child ();
+    grip-&gt;_priv-&gt;close_button = gtk_button_new ();
+    gtk_widget_pop_composite_child ();
+    
+    GTK_WIDGET_UNSET_FLAGS (grip-&gt;_priv-&gt;close_button, GTK_CAN_FOCUS);
+    gtk_widget_set_parent (grip-&gt;_priv-&gt;close_button, GTK_WIDGET (grip));
+    gtk_button_set_relief (GTK_BUTTON (grip-&gt;_priv-&gt;close_button), GTK_RELIEF_NONE);
+    gtk_widget_show (grip-&gt;_priv-&gt;close_button);
+
+    image = gtk_image_new_from_stock (GDL_STOCK_CLOSE, GTK_ICON_SIZE_MENU);
+    gtk_container_add (GTK_CONTAINER (grip-&gt;_priv-&gt;close_button), image);
+    gtk_widget_show (image);
+
+    g_signal_connect (G_OBJECT (grip-&gt;_priv-&gt;close_button), &quot;clicked&quot;,
+                      G_CALLBACK (gdl_dock_item_grip_close_clicked), grip);
+
+    gtk_widget_push_composite_child ();
+    grip-&gt;_priv-&gt;iconify_button = gtk_button_new ();
+    gtk_widget_pop_composite_child ();
+    
+    GTK_WIDGET_UNSET_FLAGS (grip-&gt;_priv-&gt;iconify_button, GTK_CAN_FOCUS);
+    gtk_widget_set_parent (grip-&gt;_priv-&gt;iconify_button, GTK_WIDGET (grip));
+    gtk_button_set_relief (GTK_BUTTON (grip-&gt;_priv-&gt;iconify_button), GTK_RELIEF_NONE);
+    gtk_widget_show (grip-&gt;_priv-&gt;iconify_button);
+
+    image = gtk_image_new_from_stock (GDL_STOCK_MENU_LEFT, GTK_ICON_SIZE_MENU);
+    gtk_container_add (GTK_CONTAINER (grip-&gt;_priv-&gt;iconify_button), image);
+    gtk_widget_show (image);
+
+    g_signal_connect (G_OBJECT (grip-&gt;_priv-&gt;iconify_button), &quot;clicked&quot;,
+                      G_CALLBACK (gdl_dock_item_grip_iconify_clicked), grip);
+
+    grip-&gt;_priv-&gt;tooltips = gtk_tooltips_new ();
+    gtk_tooltips_set_tip (grip-&gt;_priv-&gt;tooltips, grip-&gt;_priv-&gt;iconify_button,
+                          _(&quot;Iconify&quot;), _(&quot;Iconify this dock&quot;));
+    gtk_tooltips_set_tip (grip-&gt;_priv-&gt;tooltips, grip-&gt;_priv-&gt;close_button,
+                          _(&quot;Close&quot;), _(&quot;Close this dock&quot;));
 }
 
 #ifndef A11Y_UNFINISHED
@@ -315,24 +541,275 @@
 }
 
 static void
+gdl_dock_item_grip_realize (GtkWidget *widget)
+{
+    GdlDockItemGrip *grip = GDL_DOCK_ITEM_GRIP (widget);
+
+    GTK_WIDGET_CLASS (parent_class)-&gt;realize (widget);
+
+    if (!grip-&gt;title_window) {
+        GdkWindowAttr  attributes;
+        GdkRectangle   area;
+        GdkCursor     *cursor;
+
+        gdl_dock_item_grip_get_title_area (grip, &amp;area);
+
+        attributes.x                 = area.x;
+        attributes.y                 = area.y;
+        attributes.width             = area.width;
+        attributes.height            = area.height;
+        attributes.window_type       = GDK_WINDOW_TEMP;
+        attributes.wclass            = GDK_INPUT_ONLY;
+        attributes.override_redirect = TRUE;
+        attributes.event_mask        = (GDK_BUTTON_PRESS_MASK   |
+                                        GDK_BUTTON_RELEASE_MASK |
+                                        GDK_BUTTON_MOTION_MASK  |
+                                        gtk_widget_get_events (widget));
+
+        grip-&gt;title_window = gdk_window_new (gtk_widget_get_parent_window (widget),
+                                             &amp;attributes,
+                                             (GDK_WA_X |
+                                              GDK_WA_Y |
+                                              GDK_WA_NOREDIR));
+
+        gdk_window_set_user_data (grip-&gt;title_window, widget);
+  
+        cursor = gdk_cursor_new_for_display (gtk_widget_get_display (widget),
+                                             GDK_HAND2);
+        gdk_window_set_cursor (grip-&gt;title_window, cursor);
+        gdk_cursor_unref (cursor);
+    }
+}
+
+static void
+gdl_dock_item_grip_unrealize (GtkWidget *widget)
+{
+    GdlDockItemGrip *grip = GDL_DOCK_ITEM_GRIP (widget);
+
+    if (grip-&gt;title_window) {
+        gdk_window_set_user_data (grip-&gt;title_window, NULL);
+        gdk_window_destroy (grip-&gt;title_window);
+        grip-&gt;title_window = NULL;
+    }
+
+    GTK_WIDGET_CLASS (parent_class)-&gt;unrealize (widget);
+}
+
+static void
+gdl_dock_item_grip_map (GtkWidget *widget)
+{
+    GdlDockItemGrip *grip = GDL_DOCK_ITEM_GRIP (widget);
+
+    GTK_WIDGET_CLASS (parent_class)-&gt;map (widget);
+
+    if (grip-&gt;title_window)
+        gdk_window_show (grip-&gt;title_window);
+}
+
+static void
+gdl_dock_item_grip_unmap (GtkWidget *widget)
+{
+    GdlDockItemGrip *grip = GDL_DOCK_ITEM_GRIP (widget);
+
+    if (grip-&gt;title_window)
+        gdk_window_hide (grip-&gt;title_window);
+
+    GTK_WIDGET_CLASS (parent_class)-&gt;unmap (widget);
+}
+
+static void
+gdl_dock_item_grip_size_request (GtkWidget      *widget,
+                                 GtkRequisition *requisition)
+{
+    GtkRequisition   child_requisition;
+    GtkContainer    *container;
+    GdlDockItemGrip *grip;
+    GdkRectangle     title_rect;
+    gchar           *stock_id;
+
+    g_return_if_fail (GDL_IS_DOCK_ITEM_GRIP (widget));
+    g_return_if_fail (requisition != NULL);
+
+    container = GTK_CONTAINER (widget);
+    grip = GDL_DOCK_ITEM_GRIP (widget);
+    
+    requisition-&gt;width = container-&gt;border_width * 2;
+    requisition-&gt;height = container-&gt;border_width * 2;
+
+    if (GTK_WIDGET_VISIBLE (grip-&gt;_priv-&gt;close_button)) {
+        gtk_widget_size_request (grip-&gt;_priv-&gt;close_button, &amp;child_requisition);
+
+        requisition-&gt;width += child_requisition.width;
+        requisition-&gt;height += child_requisition.height;
+    }
+    
+    if (GTK_WIDGET_VISIBLE (grip-&gt;_priv-&gt;iconify_button)) {
+        gtk_widget_size_request (grip-&gt;_priv-&gt;iconify_button, &amp;child_requisition);
+
+        requisition-&gt;width += child_requisition.width;
+    }
+
+    gdl_dock_item_grip_get_title_area (grip, &amp;title_rect);
+    requisition-&gt;width += title_rect.width;
+
+    g_object_get (G_OBJECT (grip-&gt;item), &quot;stock_id&quot;, &amp;stock_id, NULL);
+    if (stock_id) {
+        GdkPixbuf *pixbuf;
+        
+        if (!grip-&gt;_priv-&gt;icon_pixbuf) {
+            pixbuf = gtk_widget_render_icon (widget, stock_id,
+                                             GTK_ICON_SIZE_MENU, &quot;&quot;);
+            grip-&gt;_priv-&gt;icon_pixbuf = pixbuf;
+        } else {
+            pixbuf = grip-&gt;_priv-&gt;icon_pixbuf;
+        }
+
+        requisition-&gt;width += gdk_pixbuf_get_width (pixbuf) + 1;
+        g_free (stock_id);
+    }
+}
+
+static void
+gdl_dock_item_grip_size_allocate (GtkWidget     *widget,
+                                  GtkAllocation *allocation)
+{
+    GdlDockItemGrip *grip;
+    GtkContainer    *container;
+    GtkRequisition   button_requisition = { 0, };
+    GtkAllocation    child_allocation;
+
+    g_return_if_fail (GDL_IS_DOCK_ITEM_GRIP (widget));
+    g_return_if_fail (allocation != NULL);
+  
+    grip = GDL_DOCK_ITEM_GRIP (widget);
+    container = GTK_CONTAINER (widget);
+
+    GTK_WIDGET_CLASS (parent_class)-&gt;size_allocate (widget, allocation);
+
+    if (GTK_WIDGET_VISIBLE (grip-&gt;_priv-&gt;close_button)) {
+        gtk_widget_size_request (grip-&gt;_priv-&gt;close_button, &amp;button_requisition);
+
+        if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR)
+            child_allocation.x = (allocation-&gt;width -
+                                  container-&gt;border_width -
+                                  button_requisition.width);
+        else
+            child_allocation.x = container-&gt;border_width;
+
+        child_allocation.y = container-&gt;border_width;
+        child_allocation.width = button_requisition.width;
+        child_allocation.height = button_requisition.height;
+
+        gtk_widget_size_allocate (grip-&gt;_priv-&gt;close_button, &amp;child_allocation);
+    }
+
+    if (GTK_WIDGET_VISIBLE (grip-&gt;_priv-&gt;iconify_button)) {
+        if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR)
+            child_allocation.x = (allocation-&gt;width -
+                                  container-&gt;border_width -
+                                  2 * button_requisition.width);
+        else
+            child_allocation.x = container-&gt;border_width + button_requisition.width;
+
+        child_allocation.y = container-&gt;border_width;
+        child_allocation.width = button_requisition.width;
+        child_allocation.height = button_requisition.height;
+
+        gtk_widget_size_allocate (grip-&gt;_priv-&gt;iconify_button, &amp;child_allocation);
+    }
+    
+    if (grip-&gt;title_window) {
+        GdkRectangle area;
+        
+        gdl_dock_item_grip_get_title_area (grip, &amp;area);
+        
+        gdk_window_move_resize (grip-&gt;title_window,
+                                area.x, area.y, area.width, area.height);
+    }
+}
+
+static void 
+gdl_dock_item_grip_add (GtkContainer *container,
+                        GtkWidget    *widget)
+{
+    g_warning (&quot;gtk_container_add not implemented for GdlDockItemGrip&quot;);
+}
+
+static void  
+gdl_dock_item_grip_remove (GtkContainer *container,
+                           GtkWidget    *widget)
+{
+    g_warning (&quot;gtk_container_remove not implemented for GdlDockItemGrip&quot;);
+}
+
+static void
+gdl_dock_item_grip_forall (GtkContainer *container,
+                           gboolean      include_internals,
+                           GtkCallback   callback,
+                           gpointer      callback_data)
+{
+    GdlDockItemGrip *grip;
+    
+    g_return_if_fail (GDL_IS_DOCK_ITEM_GRIP (container));
+
+    grip = GDL_DOCK_ITEM_GRIP (container);
+
+    if (include_internals) {
+        (* callback) (grip-&gt;_priv-&gt;close_button, callback_data);
+        (* callback) (grip-&gt;_priv-&gt;iconify_button, callback_data);
+    }
+}
+
+static GtkType
+gdl_dock_item_grip_child_type (GtkContainer *container)
+{
+    return GTK_TYPE_WIDGET;
+}
+
+static void
 gdl_dock_item_grip_class_init (GdlDockItemGripClass *klass)
 {
-    GtkBindingSet  *binding_set;
-    GObjectClass   *gobject_class = (GObjectClass *) klass;
-    GtkWidgetClass *widget_class = (GtkWidgetClass *) klass;
+    GtkBindingSet *binding_set;
+    GObjectClass *gobject_class;
+    GtkObjectClass *gtk_object_class;
+    GtkWidgetClass *widget_class;
+    GtkContainerClass *container_class;
 
     parent_class = g_type_class_peek_parent (klass);
+    gobject_class = G_OBJECT_CLASS (klass);
+    gtk_object_class = GTK_OBJECT_CLASS (klass);
+    widget_class = GTK_WIDGET_CLASS (klass);
+    container_class = GTK_CONTAINER_CLASS (klass);
 
-    gobject_class-&gt;dispose = gdl_dock_item_grip_dispose;
+    gobject_class-&gt;set_property = gdl_dock_item_grip_set_property;
 
+    gtk_object_class-&gt;destroy = gdl_dock_item_grip_destroy;
+
     widget_class-&gt;expose_event = gdl_dock_item_grip_expose;
     widget_class-&gt;get_accessible = gdl_dock_item_grip_get_accessible;
     widget_class-&gt;key_press_event = gdl_dock_item_grip_key_press_event;
+    widget_class-&gt;realize = gdl_dock_item_grip_realize;
+    widget_class-&gt;unrealize = gdl_dock_item_grip_unrealize;
+    widget_class-&gt;map = gdl_dock_item_grip_map;
+    widget_class-&gt;unmap = gdl_dock_item_grip_unmap;
+    widget_class-&gt;size_request = gdl_dock_item_grip_size_request;
+    widget_class-&gt;size_allocate = gdl_dock_item_grip_size_allocate;
 
+    container_class-&gt;add = gdl_dock_item_grip_add;
+    container_class-&gt;remove = gdl_dock_item_grip_remove;
+    container_class-&gt;forall = gdl_dock_item_grip_forall;
+    container_class-&gt;child_type = gdl_dock_item_grip_child_type;
+
     klass-&gt;activate = gdl_dock_item_grip_activate;
 
     binding_set = gtk_binding_set_by_class (klass);
 
+    g_object_class_install_property (
+        gobject_class, PROP_ITEM,
+        g_param_spec_object (&quot;item&quot;, _(&quot;Controlling dock item&quot;),
+                             _(&quot;Dockitem which 'owns' this grip&quot;),
+                             GDL_TYPE_DOCK_ITEM,
+                             G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
     signals [ACTIVATE] =
         g_signal_new (&quot;activate&quot;,
                       G_TYPE_FROM_CLASS (klass),
@@ -353,9 +830,8 @@
 GtkWidget *
 gdl_dock_item_grip_new (GdlDockItem *item)
 {
-    GdlDockItemGrip *grip = g_object_new (GDL_TYPE_DOCK_ITEM_GRIP, NULL);
+    GdlDockItemGrip *grip = g_object_new (GDL_TYPE_DOCK_ITEM_GRIP, &quot;item&quot;, item,
+                                          NULL);
 
-    grip-&gt;item = item;
-
     return GTK_WIDGET (grip);
 }

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.h	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item-grip.h	2004-02-07 23:22:11 UTC (rev 812)
@@ -30,17 +30,25 @@
 #define GDL_DOCK_ITEM_GRIP_GET_CLASS(obj)  \
     (GTK_CHECK_GET_CLASS ((obj), GDL_TYPE_DOCK_ITEM_GRIP, GdlDockItemGripClass))
 
-typedef struct {
-    GtkWidget parent;
+typedef struct _GdlDockItemGrip        GdlDockItemGrip;
+typedef struct _GdlDockItemGripClass   GdlDockItemGripClass;
+typedef struct _GdlDockItemGripPrivate GdlDockItemGripPrivate;
+
+struct _GdlDockItemGrip {
+    GtkContainer parent;
 	
     GdlDockItem *item;
-} GdlDockItemGrip;
+    
+    GdkWindow *title_window;
+    
+    GdlDockItemGripPrivate *_priv;
+};
 
-typedef struct {
-    GtkWidgetClass parent_class;
+struct _GdlDockItemGripClass {
+    GtkContainerClass parent_class;
 
     void (*activate) (GdlDockItemGrip *grip);
-} GdlDockItemGripClass;
+};
 
 GType      gdl_dock_item_grip_get_type (void);
 GtkWidget *gdl_dock_item_grip_new      (GdlDockItem *item);

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -37,7 +37,6 @@
 #include &lt;gdk/gdkkeysyms.h&gt;
 
 #include &quot;gdl-tools.h&quot;
-#include &quot;gdl-dock-master.h&quot;
 #include &quot;gdl-dock.h&quot;
 #include &quot;gdl-dock-item.h&quot;
 #include &quot;gdl-dock-item-grip.h&quot;
@@ -45,6 +44,7 @@
 #include &quot;gdl-dock-paned.h&quot;
 #include &quot;gdl-dock-tablabel.h&quot;
 #include &quot;gdl-dock-placeholder.h&quot;
+#include &quot;gdl-dock-master.h&quot;
 #include &quot;libgdltypebuiltins.h&quot;
 #include &quot;libgdlmarshal.h&quot;
 
@@ -143,7 +143,6 @@
     PROP_ORIENTATION,
     PROP_RESIZE,
     PROP_BEHAVIOR,
-    PROP_GRIP_SIZE,
     PROP_LOCKED,
     PROP_PREFERRED_WIDTH,
     PROP_PREFERRED_HEIGHT
@@ -158,7 +157,6 @@
 
 static guint gdl_dock_item_signals [LAST_SIGNAL] = { 0 };
 
-#define DEFAULT_GRIP_SIZE  10
 #define GDL_DOCK_ITEM_NOT_LOCKED(item) !((item)-&gt;behavior &amp; GDL_DOCK_ITEM_BEH_LOCKED)
 #define GDL_DOCK_ITEM_GRIP_SHOWN(item) \
     (GDL_DOCK_ITEM_HAS_GRIP (item) &amp;&amp; \
@@ -242,7 +240,7 @@
         g_param_spec_enum (&quot;orientation&quot;, _(&quot;Orientation&quot;),
                            _(&quot;Orientation of the docking item&quot;),
                            GTK_TYPE_ORIENTATION,
-                           GTK_ORIENTATION_HORIZONTAL,
+                           GTK_ORIENTATION_VERTICAL,
                            G_PARAM_READWRITE | G_PARAM_CONSTRUCT |
                            GDL_DOCK_PARAM_EXPORT));
 
@@ -271,13 +269,6 @@
                             G_PARAM_READWRITE));
                                      
     g_object_class_install_property (
-        g_object_class, PROP_GRIP_SIZE,
-        g_param_spec_uint (&quot;grip_size&quot;, _(&quot;Grip size&quot;),
-                           _(&quot;Size in pixels of the grip to drag the dock item&quot;),
-                           0, 100, DEFAULT_GRIP_SIZE,
-                           G_PARAM_READWRITE));
-
-    g_object_class_install_property (
         g_object_class, PROP_LOCKED,
         g_param_spec_boolean (&quot;locked&quot;, _(&quot;Locked&quot;),
                               _(&quot;If set, the dock item cannot be dragged around &quot;
@@ -352,7 +343,7 @@
 
     item-&gt;child = NULL;
     
-    item-&gt;orientation = GTK_ORIENTATION_HORIZONTAL;
+    item-&gt;orientation = GTK_ORIENTATION_VERTICAL;
     item-&gt;behavior = GDL_DOCK_ITEM_BEH_NORMAL;
 
     item-&gt;resize = TRUE;
@@ -363,7 +354,6 @@
     item-&gt;_priv-&gt;menu = NULL;
 
     item-&gt;_priv-&gt;preferred_width = item-&gt;_priv-&gt;preferred_height = -1;
-    item-&gt;_priv-&gt;grip_size = DEFAULT_GRIP_SIZE;
     item-&gt;_priv-&gt;tab_label = NULL;
 
     item-&gt;_priv-&gt;ph = NULL;
@@ -430,11 +420,6 @@
             
             break;
         }
-        case PROP_GRIP_SIZE:
-            item-&gt;_priv-&gt;grip_size = g_value_get_uint (value);
-            if (GDL_DOCK_ITEM_GRIP_SHOWN (item))
-                gtk_widget_queue_resize (GTK_WIDGET (item));
-            break;
         case PROP_LOCKED:
         {
             GdlDockItemBehavior old_beh = item-&gt;behavior;
@@ -484,9 +469,6 @@
         case PROP_BEHAVIOR:
             g_value_set_flags (value, item-&gt;behavior);
             break;
-        case PROP_GRIP_SIZE:
-            g_value_set_uint (value, item-&gt;_priv-&gt;grip_size);
-            break;
         case PROP_LOCKED:
             g_value_set_boolean (value, !GDL_DOCK_ITEM_NOT_LOCKED (item));
             break;
@@ -630,6 +612,7 @@
                             GtkRequisition *requisition)
 {
     GtkRequisition  child_requisition;
+    GtkRequisition  grip_requisition;
     GdlDockItem    *item;
 
     g_return_if_fail (GDL_IS_DOCK_ITEM (widget));
@@ -647,16 +630,26 @@
     }
 
     if (item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL) {
-        requisition-&gt;width = 
-            GDL_DOCK_ITEM_GRIP_SHOWN (item) ? item-&gt;_priv-&gt;grip_size : 0;
+        if (GDL_DOCK_ITEM_GRIP_SHOWN (item)) {
+            gtk_widget_size_request (item-&gt;_priv-&gt;grip, &amp;grip_requisition);
+            requisition-&gt;width = grip_requisition.width;
+        } else {
+            requisition-&gt;width = 0;
+        }
+
         if (item-&gt;child) {
             requisition-&gt;width += child_requisition.width;
             requisition-&gt;height = child_requisition.height;
         } else
             requisition-&gt;height = 0;
     } else {
-        requisition-&gt;height = 
-            GDL_DOCK_ITEM_GRIP_SHOWN (item) ? item-&gt;_priv-&gt;grip_size : 0;
+        if (GDL_DOCK_ITEM_GRIP_SHOWN (item)) {
+            gtk_widget_size_request (item-&gt;_priv-&gt;grip, &amp;grip_requisition);
+            requisition-&gt;height = grip_requisition.height;
+        } else {
+            requisition-&gt;height = 0;
+        }
+
         if (item-&gt;child) {
             requisition-&gt;width = child_requisition.width;
             requisition-&gt;height += child_requisition.height;
@@ -703,21 +696,24 @@
         
         if (GDL_DOCK_ITEM_GRIP_SHOWN (item)) {
             GtkAllocation grip_alloc = *allocation;
+            GtkRequisition grip_req;
             
+            gtk_widget_size_request (item-&gt;_priv-&gt;grip, &amp;grip_req);
+            
             grip_alloc.x = grip_alloc.y = 0;
             
             if (item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL) {
-                child_allocation.x += item-&gt;_priv-&gt;grip_size;
-                child_allocation.width -= item-&gt;_priv-&gt;grip_size;
-                grip_alloc.width = item-&gt;_priv-&gt;grip_size;
+                child_allocation.x += grip_req.width;
+                child_allocation.width -= grip_req.width;
+                grip_alloc.width = grip_req.width;
             } else {
-                child_allocation.y += item-&gt;_priv-&gt;grip_size;
-                child_allocation.height -= item-&gt;_priv-&gt;grip_size;
-                grip_alloc.height = item-&gt;_priv-&gt;grip_size;
+                child_allocation.y += grip_req.height;
+                child_allocation.height -= grip_req.height;
+                grip_alloc.height = grip_req.height;
             }
             if (item-&gt;_priv-&gt;grip)
                 gtk_widget_size_allocate (item-&gt;_priv-&gt;grip, &amp;grip_alloc);
-        };
+        }
         gtk_widget_size_allocate (item-&gt;child, &amp;child_allocation);
     }
 }
@@ -859,6 +855,9 @@
     return FALSE;
 }
 
+#define EVENT_IN_GRIP_EVENT_WINDOW(ev,gr) \
+    ((gr) != NULL &amp;&amp; (ev)-&gt;window == GDL_DOCK_ITEM_GRIP (gr)-&gt;title_window)
+
 #define EVENT_IN_TABLABEL_EVENT_WINDOW(ev,tl) \
     ((tl) != NULL &amp;&amp; (ev)-&gt;window == GDL_DOCK_TABLABEL (tl)-&gt;event_window)
 
@@ -869,15 +868,15 @@
     GdlDockItem *item;
     gboolean     event_handled;
     gboolean     in_handle;
+    GdkCursor   *cursor;
   
     g_return_val_if_fail (widget != NULL, FALSE);
     g_return_val_if_fail (GDL_IS_DOCK_ITEM (widget), FALSE);
     g_return_val_if_fail (event != NULL, FALSE);
     
     item = GDL_DOCK_ITEM (widget);
-    
-    if (!(event-&gt;window == widget-&gt;window ||
-          EVENT_IN_TABLABEL_EVENT_WINDOW (event, item-&gt;_priv-&gt;tab_label)))
+
+    if (!EVENT_IN_GRIP_EVENT_WINDOW (event, item-&gt;_priv-&gt;grip))
         return FALSE;
     
     /* Verify that the item is not locked. */
@@ -889,10 +888,10 @@
     /* Check if user clicked on the drag handle. */      
     switch (item-&gt;orientation) {
     case GTK_ORIENTATION_HORIZONTAL:
-        in_handle = event-&gt;x &lt; item-&gt;_priv-&gt;grip_size;
+        in_handle = event-&gt;x &lt; item-&gt;_priv-&gt;grip-&gt;allocation.width;
         break;
     case GTK_ORIENTATION_VERTICAL:
-        in_handle = event-&gt;y &lt; item-&gt;_priv-&gt;grip_size;
+        in_handle = event-&gt;y &lt; item-&gt;_priv-&gt;grip-&gt;allocation.height;
         break;
     default:
         in_handle = FALSE;
@@ -907,6 +906,12 @@
             item-&gt;_priv-&gt;start_y = event-&gt;y;
 
             GDL_DOCK_ITEM_SET_FLAGS (item, GDL_DOCK_IN_PREDRAG);
+            
+            cursor = gdk_cursor_new_for_display (gtk_widget_get_display (widget),
+                                                 GDK_FLEUR);
+            gdk_window_set_cursor (GDL_DOCK_ITEM_GRIP (item-&gt;_priv-&gt;grip)-&gt;title_window,
+                                   cursor);
+            gdk_cursor_unref (cursor);
         
             event_handled = TRUE;
         };
@@ -922,6 +927,11 @@
             event_handled = TRUE;
         }
              
+        cursor = gdk_cursor_new_for_display (gtk_widget_get_display (widget),
+                                             GDK_HAND2);
+        gdk_window_set_cursor (GDL_DOCK_ITEM_GRIP (item-&gt;_priv-&gt;grip)-&gt;title_window,
+                               cursor);
+        gdk_cursor_unref (cursor);
     } else if (event-&gt;button == 3 &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; in_handle) {
         gdl_dock_item_popup_menu (item, event-&gt;button, event-&gt;time);
         event_handled = TRUE;    	
@@ -943,8 +953,7 @@
 
     item = GDL_DOCK_ITEM (widget);
 
-    if (!(event-&gt;window == widget-&gt;window ||
-          EVENT_IN_TABLABEL_EVENT_WINDOW (event, item-&gt;_priv-&gt;tab_label)))
+    if (!EVENT_IN_GRIP_EVENT_WINDOW (event, item-&gt;_priv-&gt;grip))
         return FALSE;
 
     if (GDL_DOCK_ITEM_IN_PREDRAG (item)) {
@@ -1298,11 +1307,11 @@
            drag handle */
         switch (item-&gt;orientation) {
         case GTK_ORIENTATION_HORIZONTAL:
-            item-&gt;dragoff_x = item-&gt;_priv-&gt;grip_size / 2;
+            /*item-&gt;dragoff_x = item-&gt;_priv-&gt;grip_size / 2;*/
             item-&gt;dragoff_y = GTK_WIDGET (data)-&gt;allocation.height / 2;
             break;
         case GTK_ORIENTATION_VERTICAL:
-            item-&gt;dragoff_x = GTK_WIDGET (data)-&gt;allocation.width / 2;
+            /*item-&gt;dragoff_x = GTK_WIDGET (data)-&gt;allocation.width / 2;*/
             item-&gt;dragoff_y = item-&gt;_priv-&gt;grip_size / 2;
             break;
         };
@@ -1343,13 +1352,10 @@
 gdl_dock_item_showhide_grip (GdlDockItem *item)
 {
     if (item-&gt;_priv-&gt;grip) {
-        if (GDL_DOCK_ITEM_GRIP_SHOWN (item)) {
+        if (GDL_DOCK_ITEM_GRIP_SHOWN (item))
             gtk_widget_show (item-&gt;_priv-&gt;grip);
-            GTK_WIDGET_SET_FLAGS (item-&gt;_priv-&gt;grip, GTK_CAN_FOCUS);
-        } else {
+        else
             gtk_widget_hide (item-&gt;_priv-&gt;grip);
-            GTK_WIDGET_UNSET_FLAGS (item-&gt;_priv-&gt;grip, GTK_CAN_FOCUS);
-        }
     }
     gtk_widget_queue_resize (GTK_WIDGET (item));
 }
@@ -1381,11 +1387,31 @@
                                         &quot;behavior&quot;, behavior,
                                         NULL));
     GDL_DOCK_OBJECT_UNSET_FLAGS (item, GDL_DOCK_AUTOMATIC);
-    gdl_dock_item_set_tablabel (item, gdl_dock_tablabel_new (item));
+    gdl_dock_item_set_tablabel (item, gtk_label_new (long_name));
 
     return GTK_WIDGET (item);
 }
 
+GtkWidget *
+gdl_dock_item_new_with_stock (const gchar         *name,
+                              const gchar         *long_name,
+                              const gchar         *stock_id,
+                              GdlDockItemBehavior  behavior)
+{
+    GdlDockItem *item;
+
+    item = GDL_DOCK_ITEM (g_object_new (GDL_TYPE_DOCK_ITEM, 
+                                        &quot;name&quot;, name, 
+                                        &quot;long_name&quot;, long_name,
+                                        &quot;stock_id&quot;, stock_id,
+                                        &quot;behavior&quot;, behavior,
+                                        NULL));
+    GDL_DOCK_OBJECT_UNSET_FLAGS (item, GDL_DOCK_AUTOMATIC);
+    gdl_dock_item_set_tablabel (item, gtk_label_new (long_name));
+
+    return GTK_WIDGET (item);
+}
+
 /* convenient function (and to preserve source compat) */
 void
 gdl_dock_item_dock_to (GdlDockItem      *item,
@@ -1566,6 +1592,15 @@
 }
 
 void
+gdl_dock_item_iconify_item (GdlDockItem *item)
+{
+    g_return_if_fail (item != NULL);
+    
+    GDL_DOCK_OBJECT_SET_FLAGS (item, GDL_DOCK_ICONIFIED);
+    gdl_dock_item_hide_item (item);
+}
+
+void
 gdl_dock_item_show_item (GdlDockItem *item)
 {
     g_return_if_fail (item != NULL);

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.h	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-item.h	2004-02-07 23:22:11 UTC (rev 812)
@@ -59,9 +59,10 @@
 typedef enum {
     GDL_DOCK_IN_DRAG             = 1 &lt;&lt; GDL_DOCK_OBJECT_FLAGS_SHIFT,
     GDL_DOCK_IN_PREDRAG          = 1 &lt;&lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 1),
+    GDL_DOCK_ICONIFIED           = 1 &lt;&lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 2),
     /* for general use: indicates the user has started an action on
        the dock item */
-    GDL_DOCK_USER_ACTION         = 1 &lt;&lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 2)
+    GDL_DOCK_USER_ACTION         = 1 &lt;&lt; (GDL_DOCK_OBJECT_FLAGS_SHIFT + 3)
 } GdlDockItemFlags;
 
 typedef struct _GdlDockItem        GdlDockItem;
@@ -106,6 +107,8 @@
     ((GDL_DOCK_ITEM_FLAGS (item) &amp; GDL_DOCK_IN_DRAG) != 0)
 #define GDL_DOCK_ITEM_IN_PREDRAG(item) \
     ((GDL_DOCK_ITEM_FLAGS (item) &amp; GDL_DOCK_IN_PREDRAG) != 0)
+#define GDL_DOCK_ITEM_ICONIFIED(item) \
+    ((GDL_DOCK_ITEM_FLAGS (item) &amp; GDL_DOCK_ICONIFIED) != 0)
 #define GDL_DOCK_ITEM_USER_ACTION(item) \
     ((GDL_DOCK_ITEM_FLAGS (item) &amp; GDL_DOCK_USER_ACTION) != 0)
    
@@ -121,6 +124,10 @@
 GtkWidget     *gdl_dock_item_new               (const gchar         *name,
                                                 const gchar         *long_name,
                                                 GdlDockItemBehavior  behavior);
+GtkWidget     *gdl_dock_item_new_with_stock    (const gchar         *name,
+                                                const gchar         *long_name,
+                                                const gchar         *stock_id,
+                                                GdlDockItemBehavior  behavior);
 
 GType          gdl_dock_item_get_type          (void);
 
@@ -146,6 +153,8 @@
 
 void           gdl_dock_item_hide_item         (GdlDockItem *item);
 
+void           gdl_dock_item_iconify_item      (GdlDockItem *item);
+
 void           gdl_dock_item_show_item         (GdlDockItem *item);
 
 void           gdl_dock_item_lock              (GdlDockItem *item);

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-layout.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -35,7 +35,6 @@
 #include &quot;gdl-tools.h&quot;
 #include &quot;gdl-dock-placeholder.h&quot;
 
-
 #define GDL_GLADEDIR &quot;.&quot;
 
 /* ----- Private variables ----- */

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-notebook.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -125,7 +125,7 @@
     object_class-&gt;present = gdl_dock_notebook_present;
     object_class-&gt;reorder = gdl_dock_notebook_reorder;
     
-    item_class-&gt;has_grip = TRUE;
+    item_class-&gt;has_grip = FALSE;
     item_class-&gt;set_orientation = gdl_dock_notebook_set_orientation;    
     
     g_object_class_install_property (
@@ -172,10 +172,7 @@
     /* create the container notebook */
     item-&gt;child = gtk_notebook_new ();
     gtk_widget_set_parent (item-&gt;child, GTK_WIDGET (notebook));
-    if (item-&gt;orientation == GTK_ORIENTATION_HORIZONTAL)
-        gtk_notebook_set_tab_pos (GTK_NOTEBOOK (item-&gt;child), GTK_POS_TOP);
-    else
-        gtk_notebook_set_tab_pos (GTK_NOTEBOOK (item-&gt;child), GTK_POS_LEFT);
+    gtk_notebook_set_tab_pos (GTK_NOTEBOOK (item-&gt;child), GTK_POS_BOTTOM);
     g_signal_connect (item-&gt;child, &quot;switch_page&quot;,
                       (GCallback) gdl_dock_notebook_switch_page_cb, (gpointer) item);
     g_signal_connect (item-&gt;child, &quot;notify::page&quot;,
@@ -372,19 +369,24 @@
         else {
             GdlDockItem *item = GDL_DOCK_ITEM (object);
             GdlDockItem *requestor_item = GDL_DOCK_ITEM (requestor);
+            gchar       *name;
             GtkWidget   *label;
             gint         position = -1;
             
             label = gdl_dock_item_get_tablabel (requestor_item);
             if (!label) {
-                label = gdl_dock_tablabel_new (requestor_item);
+                g_object_get (requestor_item, &quot;long_name&quot;, &amp;name, NULL);
+                label = gtk_label_new (name);
+                g_free (name);
                 gdl_dock_item_set_tablabel (requestor_item, label);
             }
+#if 0
             if (GDL_IS_DOCK_TABLABEL (label)) {
                 gdl_dock_tablabel_deactivate (GDL_DOCK_TABLABEL (label));
                 /* hide the item grip, as we will use the tablabel's */
                 gdl_dock_item_hide_grip (requestor_item);
             }
+#endif
 
             if (other_data &amp;&amp; G_VALUE_HOLDS (other_data, G_TYPE_INT))
                 position = g_value_get_int (other_data);

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -81,6 +81,7 @@
     PROP_0,
     PROP_NAME,
     PROP_LONG_NAME,
+    PROP_STOCK_ID,
     PROP_MASTER,
     PROP_EXPORT_PROPERTIES
 };
@@ -130,6 +131,13 @@
                              G_PARAM_READWRITE));
 
     g_object_class_install_property (
+        g_object_class, PROP_STOCK_ID,
+        g_param_spec_string (&quot;stock_id&quot;, _(&quot;Stock Icon&quot;),
+                             _(&quot;Stock icon for the dock object&quot;),
+                             NULL,
+                             G_PARAM_READWRITE));
+
+    g_object_class_install_property (
         g_object_class, PROP_MASTER,
         g_param_spec_object (&quot;master&quot;, _(&quot;Dock master&quot;),
                              _(&quot;Dock master this dock object is bound to&quot;),
@@ -202,6 +210,10 @@
         g_free (object-&gt;long_name);
         object-&gt;long_name = g_value_dup_string (value);
         break;
+    case PROP_STOCK_ID:
+        g_free (object-&gt;stock_id);
+        object-&gt;stock_id = g_value_dup_string (value);
+        break;
     case PROP_MASTER:
         if (g_value_get_object (value)) 
             gdl_dock_object_bind (object, g_value_get_object (value));
@@ -229,6 +241,9 @@
     case PROP_LONG_NAME:
         g_value_set_string (value, object-&gt;long_name);
         break;
+    case PROP_STOCK_ID:
+        g_value_set_string (value, object-&gt;stock_id);
+        break;
     case PROP_MASTER:
         g_value_set_object (value, object-&gt;master);
         break;

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.h	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-object.h	2004-02-07 23:22:11 UTC (rev 812)
@@ -88,6 +88,7 @@
     GObject            *master;
     gchar              *name;
     gchar              *long_name;
+    gchar              *stock_id;
     
     gboolean            reduce_pending;
 };

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-placeholder.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -27,10 +27,11 @@
 #endif
 
 #include &quot;gdl-i18n.h&quot;
-#include &quot;gdl-dock-master.h&quot;
+
 #include &quot;gdl-tools.h&quot;
 #include &quot;gdl-dock-placeholder.h&quot;
 #include &quot;gdl-dock-item.h&quot;
+#include &quot;gdl-dock-master.h&quot;
 #include &quot;libgdltypebuiltins.h&quot;
 
 

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock-tablabel.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -94,7 +94,8 @@
 
 /* ----- Private interface ----- */
 
-GDL_CLASS_BOILERPLATE (GdlDockTablabel, gdl_dock_tablabel, GtkBin, GTK_TYPE_BIN);
+GDL_CLASS_BOILERPLATE (GdlDockTablabel, gdl_dock_tablabel,
+                       GtkBin, GTK_TYPE_BIN);
 
 static void
 gdl_dock_tablabel_class_init (GdlDockTablabelClass *klass)

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -2,7 +2,7 @@
  *
  * This file is part of the GNOME Devtools Libraries.
  *
- * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ * Copyright (C) 2002 Gustavo Gir&#195;&#161;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -121,7 +121,7 @@
     gint                float_y;
     gint                width;
     gint                height;
-    
+
     /* auxiliary fields */
     GdkGC              *xor_gc;
 };
@@ -439,7 +439,11 @@
                 g_object_get (GDL_DOCK_OBJECT (object)-&gt;master,
                               &quot;default_title&quot;, &amp;default_title,
                               NULL);
+#if GLIB_CHECK_VERSION(2,3,0)
+                g_value_take_string (value, default_title);
+#else
                 g_value_set_string_take_ownership (value, default_title);
+#endif
             }
             else
                 g_value_set_string (value, NULL);
@@ -543,9 +547,9 @@
 gdl_dock_size_request (GtkWidget      *widget,
                        GtkRequisition *requisition)
 {
-    GdlDock      *dock;
-    GtkContainer *container;
-    guint         border_width;
+    GdlDock       *dock;
+    GtkContainer  *container;
+    guint          border_width;
 
     g_return_if_fail (widget != NULL);
     g_return_if_fail (GDL_IS_DOCK (widget));
@@ -572,9 +576,9 @@
 gdl_dock_size_allocate (GtkWidget     *widget,
                         GtkAllocation *allocation)
 {
-    GdlDock      *dock;
-    GtkContainer *container;
-    guint         border_width;
+    GdlDock       *dock;
+    GtkContainer  *container;
+    guint          border_width;
 
     g_return_if_fail (widget != NULL);
     g_return_if_fail (GDL_IS_DOCK (widget));
@@ -1202,4 +1206,3 @@
                         rect-&gt;x + 1, rect-&gt;y + 1,
                         rect-&gt;width - 2, rect-&gt;height - 2);
 }
-

Modified: trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.h	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-dock.h	2004-02-07 23:22:11 UTC (rev 812)
@@ -2,7 +2,7 @@
  *
  * This file is part of the GNOME Devtools Libraries.
  *
- * Copyright (C) 2002 Gustavo Gir&#225;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
+ * Copyright (C) 2002 Gustavo Gir&#195;&#161;ldez &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gustavo.giraldez at gmx.net</A>&gt;
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-stock.c
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-stock.c	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-stock.c	2004-02-07 23:22:11 UTC (rev 812)
@@ -0,0 +1,125 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- 
+ * gdl-stock.c
+ * 
+ * Copyright (C) 2003 Jeroen Zwartepoorte
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
+#include &lt;gtk/gtk.h&gt;
+#include &lt;gtk/gtkiconfactory.h&gt;
+#include &quot;gdl-stock.h&quot;
+
+#define GDL_IMAGESDIR &quot;.&quot;
+
+static GtkIconFactory *gdl_stock_factory = NULL;
+
+static struct {
+	const gchar *stock_id;
+	const gchar *filename;
+}
+gdl_icons[] = 
+{
+	{ GDL_STOCK_CLOSE, &quot;stock-close-12.png&quot; },
+	{ GDL_STOCK_MENU_LEFT, &quot;stock-menu-left-12.png&quot; },
+	{ GDL_STOCK_MENU_RIGHT, &quot;stock-menu-right-12.png&quot; }
+};
+
+static void
+icon_set_from_file (GtkIconSet       *set,
+		    const gchar      *filename,
+		    GtkIconSize       size,
+		    gboolean          fallback)
+{
+	GtkIconSource *source;
+	GdkPixbuf     *pixbuf;
+	gchar         *path;
+
+	source = gtk_icon_source_new ();
+
+	gtk_icon_source_set_size (source, size);
+	gtk_icon_source_set_size_wildcarded (source, FALSE);
+	
+	path = g_build_filename (GDL_IMAGESDIR, filename, NULL);
+	pixbuf = gdk_pixbuf_new_from_file (path, NULL);
+	if (!pixbuf) {
+	    g_warning (&quot;Unable to load stock icon %s&quot;, path);
+	    g_object_unref (source);
+	    g_free (path);
+	    return;
+	}
+	
+	g_free (path);
+
+	gtk_icon_source_set_pixbuf (source, pixbuf);
+	
+	g_object_unref (pixbuf);
+	
+	gtk_icon_set_add_source (set, source);
+	
+	if (fallback) {
+		gtk_icon_source_set_size_wildcarded (source, TRUE);
+		gtk_icon_set_add_source (set, source);
+	}
+	
+	gtk_icon_source_free (source);
+}
+
+static void
+add_icon (GtkIconFactory *factory,
+	  const gchar    *stock_id,
+	  const gchar    *filename)
+{
+	GtkIconSet *set;
+	gboolean    fallback = FALSE;
+
+	set = gtk_icon_factory_lookup (factory, stock_id);
+
+	if (!set) {
+		set = gtk_icon_set_new ();
+		gtk_icon_factory_add (factory, stock_id, set);
+		gtk_icon_set_unref (set);
+
+		fallback = TRUE;
+	}
+	
+	icon_set_from_file (set, filename, GTK_ICON_SIZE_MENU, fallback);
+}
+
+void
+gdl_stock_init (void)
+{
+	static gboolean initialized = FALSE;
+	gint i;
+
+	if (initialized)
+		return;
+
+	gdl_stock_factory = gtk_icon_factory_new ();
+
+	for (i = 0; i &lt; G_N_ELEMENTS (gdl_icons); i++) {
+		add_icon (gdl_stock_factory,
+			  gdl_icons[i].stock_id,
+			  gdl_icons[i].filename);
+	}
+
+	gtk_icon_factory_add_default (gdl_stock_factory);
+
+	initialized = TRUE;
+}

Added: trunk/MonoDevelop/gdldock/sources/gdl/gdl-stock.h
===================================================================
--- trunk/MonoDevelop/gdldock/sources/gdl/gdl-stock.h	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/gdldock/sources/gdl/gdl-stock.h	2004-02-07 23:22:11 UTC (rev 812)
@@ -0,0 +1,34 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- 
+ * gdl-stock.h
+ * 
+ * Copyright (C) 2003 Jeroen Zwartepoorte
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __GDL_STOCK_H__
+#define __GDL_STOCK_H__
+
+G_BEGIN_DECLS
+
+#define GDL_STOCK_CLOSE			&quot;gdl-close&quot;
+#define GDL_STOCK_MENU_LEFT		&quot;gdl-menu-left&quot;
+#define GDL_STOCK_MENU_RIGHT		&quot;gdl-menu-right&quot;
+
+void gdl_stock_init (void);
+
+G_END_DECLS
+
+#endif /* __GDL_STOCK_H__ */

Added: trunk/MonoDevelop/gdldock/sources/gdl/stock-close-12.png
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/gdldock/sources/gdl/stock-close-12.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/gdldock/sources/gdl/stock-menu-left-12.png
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/gdldock/sources/gdl/stock-menu-left-12.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/gdldock/sources/gdl/stock-menu-right-12.png
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/gdldock/sources/gdl/stock-menu-right-12.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/MonoDevelop/src/AddIns/DisplayBindings/EditorBindings/Gui/Pads/CompilerMessageView.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/DisplayBindings/EditorBindings/Gui/Pads/CompilerMessageView.cs	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/src/AddIns/DisplayBindings/EditorBindings/Gui/Pads/CompilerMessageView.cs	2004-02-07 23:22:11 UTC (rev 812)
@@ -15,6 +15,8 @@
 using ICSharpCode.Core.Services;
 using ICSharpCode.SharpDevelop.Gui;
 
+using Gtk;
+
 namespace MonoDevelop.EditorBindings.Gui.Pads
 {
 	// Note: I moved the pads to this assembly, because I want no cyclic dll dependency
@@ -66,6 +68,7 @@
 			textEditorControl = new Gtk.TextView (buffer);
 			textEditorControl.Editable = false;
 			scroller = new Gtk.ScrolledWindow ();
+			scroller.ShadowType = ShadowType.In;
 			scroller.Add (textEditorControl);
 			ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
 			

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Pads/OpenTaskView.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Pads/OpenTaskView.cs	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Pads/OpenTaskView.cs	2004-02-07 23:22:11 UTC (rev 812)
@@ -14,6 +14,7 @@
 using ICSharpCode.Core.Services;
 using ICSharpCode.SharpDevelop.Services;
 
+using Gtk;
 using GtkSharp;
 
 using ICSharpCode.Core.Properties;
@@ -75,6 +76,7 @@
 			AddColumns ();
 			
 			sw = new Gtk.ScrolledWindow ();
+			sw.ShadowType = ShadowType.In;
 			sw.Add (view);
 			
 			taskService.TasksChanged     += new EventHandler (ShowResults);

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Workbench/DefaultWorkbench.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Workbench/DefaultWorkbench.cs	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Workbench/DefaultWorkbench.cs	2004-02-07 23:22:11 UTC (rev 812)
@@ -135,6 +135,7 @@
 		
 		public DefaultWorkbench() : base (&quot;MonoDevelop&quot;)
 		{
+			Console.WriteLine (&quot;Creating DefaultWorkbench&quot;);
 			ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
 			// FIXME: edit the name in the resource
 			//Title = resourceService.GetString(&quot;MainWindow.DialogName&quot;);
@@ -268,6 +269,7 @@
 		
 		public virtual void ShowPad(IPadContent content)
 		{
+			Console.WriteLine (&quot;ShowPad : {0}&quot;, content);
 			PadContentCollection.Add(content);
 			
 			if (layout != null) {

Modified: trunk/MonoDevelop/src/Main/Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/src/Main/Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs	2004-02-07 23:22:11 UTC (rev 812)
@@ -18,6 +18,8 @@
 using ICSharpCode.SharpDevelop.Services;
 
 using Gtk;
+using Gdl;
+using GdlSharp;
 using MonoDevelop.Gui.Widgets;
 
 namespace ICSharpCode.SharpDevelop.Gui
@@ -34,22 +36,19 @@
 		Window wbWindow;
 		Container rootWidget;
 		Container toolbarContainer;
-
+		Dock dock;
 		Notebook tabControl;
 
-		//FIXME: this is also an ugly hack
-		//VBox mainBox;
-		DockingManager dockManager;
 		//ICSharpCode.SharpDevelop.Gui.Components.OpenFileTab tabControl = new ICSharpCode.SharpDevelop.Gui.Components.OpenFileTab();
 
 		ArrayList _windows = new ArrayList ();
 
 		public IWorkbenchWindow ActiveWorkbenchwindow {
 			get {
-				if (tabControl == null || tabControl.CurrentPage &lt; 0 || tabControl.CurrentPage &gt;= tabControl.NPages)  {
+				/*if (tabControl == null || tabControl.CurrentPage &lt; 0 || tabControl.CurrentPage &gt;= tabControl.NPages)  {
 					return null;
-				}
-				return (IWorkbenchWindow)_windows[tabControl.CurrentPage];
+				}*/
+				return null;//(IWorkbenchWindow)_windows[tabControl.CurrentPage];
 			}
 		}
 		
@@ -77,10 +76,6 @@
 			this.workbench = workbench;
 			wbWindow = (Window) workbench;
 			
-			Gtk.VBox mainBox = new VBox (false, 2);
-			tabControl = new Notebook();
-			tabControl.Scrollable = true;
-			
 			Gtk.VBox vbox = new VBox (false, 0);
 			rootWidget = vbox;
 
@@ -94,13 +89,22 @@
 				vbox.PackStart(toolvbox, false, false, 0);
 			}
 			
-			vbox.PackStart(mainBox);
+			// Create the docking widget and add it to the window.
+			dock = new Dock ();
+			Gtk.HBox dockBox = new HBox (false, 5);
+			dockBox.PackStart (dock, true, true, 0);
+			vbox.PackStart (dockBox, true, true, 0);
 
+			// Create the notebook for the various documents.
+			tabControl = new Notebook ();
+			DockItem item = new DockItem (&quot;Documents&quot;, &quot;Documents&quot;,
+						      DockItemBehavior.Locked);
+			item.Add (tabControl);
+			item.ShowAll ();
+			dock.AddItem (item, DockPlacement.Center);
+
 			workbench.Add (vbox);
 			
-			//dockManager = new DockingManager(wbWindow);
-			dockManager = new DockingManager(mainBox, tabControl);
-
 /*
 			wbForm = (Form)workbench;
 			wbForm.Controls.Clear();
@@ -116,7 +120,7 @@
 //			Control firstControl = null;
 */
 			IStatusBarService statusBarService = (IStatusBarService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IStatusBarService));
-			mainBox.PackEnd (statusBarService.Control, false, true, 0);
+			vbox.PackEnd (statusBarService.Control, false, true, 0);
 /*			
 			wbForm.Add (statusBarService.Control);
 			((DefaultWorkbench)workbench).commandBarManager.CommandBars.Add(((DefaultWorkbench)workbench).TopMenu);
@@ -153,7 +157,7 @@
 				Console.WriteLine(&quot;can't load docking configuration, version clash ?&quot;);
 			}
 			RedrawAllComponents();
-			//wbWindow.ShowAll ();
+			wbWindow.ShowAll ();
 		}
 
 		public Gtk.Widget LayoutWidget {
@@ -192,35 +196,35 @@
 			};
 			
 			foreach (string typeName in leftContents) {
-				Content c = GetContent(typeName);
+				Content c = GetContent (typeName);
 				if (c != null) {
-					if (leftContent == null) {
-						leftContent = dockManager.AddContentWithState(c, DockState.Left) as WindowContent;
-					} else {
-						dockManager.AddContentToWindowContent(c, leftContent);
-					}
+					DockItem item = new DockItem (c.Title, c.Title, &quot;gtk-execute&quot;,
+								      DockItemBehavior.Normal);
+					item.Add (c.Widget);
+					item.ShowAll ();
+					dock.AddItem (item, DockPlacement.Left);
 				}
 			}
 			
 			foreach (string typeName in bottomContents) {
-				Content c = GetContent(typeName);
+				Content c = GetContent (typeName);
 				if (c != null) {
-					if (bottomContent == null) {
-						bottomContent = dockManager.AddContentWithState(c, DockState.Bottom) as WindowContent;
-					} else {
-						dockManager.AddContentToWindowContent(c, bottomContent);
-					}
+					DockItem item = new DockItem (c.Title, c.Title, &quot;gtk-execute&quot;,
+								      DockItemBehavior.Normal);
+					item.Add (c.Widget);
+					item.ShowAll ();
+					dock.AddItem (item, DockPlacement.Bottom);
 				}
 			}
 			
 			foreach (string typeName in rightContents) {
-				Content c = GetContent(typeName);
+				Content c = GetContent (typeName);
 				if (c != null) {
-					if (rightContent == null) {
-						rightContent = dockManager.AddContentWithState(c, DockState.Right) as WindowContent;
-					} else {
-						dockManager.AddContentToWindowContent(c, rightContent);
-					}
+					DockItem item = new DockItem (c.Title, c.Title, &quot;gtk-execute&quot;,
+								      DockItemBehavior.Normal);
+					item.Add (c.Widget);
+					item.ShowAll ();
+					dock.AddItem (item, DockPlacement.Right);
 				}
 			}
 			//Console.WriteLine(&quot; Default Layout created.&quot;);
@@ -266,27 +270,33 @@
 	
 		public void ShowPad(IPadContent content)
 		{
-			// FIXME: GTKize			
-
+			Console.WriteLine (&quot;ShowPad {0}&quot;, content.Title);
 			if (contentHash[content] == null) {
-				IProperties properties = (IProperties)propertyService.GetProperty(&quot;Workspace.ViewMementos&quot;, new DefaultProperties());
+				/*DockItem item = new DockItem (content.Title,
+							      content.Title,
+							      DockItemBehavior.Normal);
+				item.Add (content.Control);
+				item.ShowAll ();
+				dock.AddItem (item, DockPlacement.Top);*/
+			
+				/*IProperties properties = (IProperties)propertyService.GetProperty(&quot;Workspace.ViewMementos&quot;, new DefaultProperties());
 				//content.Control.Dock = DockStyle.None;
 				Content newContent;
 				if (content.Icon != null) {
 					//ImageList imgList = new ImageList();
 					//imgList.ColorDepth = ColorDepth.Depth32Bit;
-					IconService iconService = (IconService)ServiceManager.Services.GetService(typeof(IconService));
+					//IconService iconService = (IconService)ServiceManager.Services.GetService(typeof(IconService));
 					//imgList.Images.Add(iconService.GetBitmap(content.Icon));
 					//newContent = dockManager.Contents.Add(content.Control, content.Title, imgList, 0);
-					newContent = dockManager.Contents.Add(content.Control, content.Title, iconService.GetBitmap(content.Icon));
+					//newContent = dockManager.Contents.Add(content.Control, content.Title, iconService.GetBitmap(content.Icon));
 				} else {
-					newContent = dockManager.Contents.Add(content.Control, content.Title);
-				}
-				contentHash[content] = newContent;
+					//newContent = dockManager.Contents.Add(content.Control, content.Title);
+				}*/
+				contentHash[content] = new Content (content.Control, content.Title, null);
 			} else {
 				Content c = (Content)contentHash[content];
 				if (c != null) {
-					dockManager.ShowContent(c);
+					//dockManager.ShowContent(c);
 				}
 			}
 		}
@@ -310,7 +320,7 @@
 			if (padContent != null) {
 				Content content = (Content)contentHash[padContent];
 				if (content != null) {
-					dockManager.HideContent(content);
+					//dockManager.HideContent(content);
 				}
 			}
 

Modified: trunk/MonoDevelop/src/Main/Base/Makefile
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Makefile	2004-02-07 22:56:04 UTC (rev 811)
+++ trunk/MonoDevelop/src/Main/Base/Makefile	2004-02-07 23:22:11 UTC (rev 812)
@@ -361,6 +361,7 @@
 		/r:../../../build/bin/ICSharpCode.SharpAssembly.dll \
 		/r:../../../build/bin/MonoDevelop.Gui.Utils.dll \
 		/r:../../../build/bin/MonoDevelop.Gui.Widgets.dll \
+		/r:../../../build/bin/gdl-sharp.dll \
 		/resource:../../../data/resources/glade/Base.glade,Base.glade \
 		/r:System.Data.dll /r:System.Web.Services.dll /define:LINUX \
 		/define:GTK /r:gtk-sharp.dll /r:gdk-sharp.dll /r:glib-sharp.dll \


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000416.html">[Monodevelop-patches-list] r811 - in trunk/MonoDevelop/src: Libraries/MonoDevelop.Gui.Widgets/FileBrowser Main/Base/Gui/Pads
</A></li>
	<LI>Next message: <A HREF="000418.html">[Monodevelop-patches-list] r813 - in trunk/MonoDevelop: . src/Main/Base/Gui/Dialogs/OptionPanels/IDEOptions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#417">[ date ]</a>
              <a href="thread.html#417">[ thread ]</a>
              <a href="subject.html#417">[ subject ]</a>
              <a href="author.html#417">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
