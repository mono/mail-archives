<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1743 - trunk/MonoDevelop/src/Libraries/Gdl
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1743%20-%20trunk/MonoDevelop/src/Libraries/Gdl&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001349.html">
   <LINK REL="Next"  HREF="001351.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1743 - trunk/MonoDevelop/src/Libraries/Gdl</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1743%20-%20trunk/MonoDevelop/src/Libraries/Gdl&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1743 - trunk/MonoDevelop/src/Libraries/Gdl">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sat Jun 12 10:34:03 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001349.html">[Monodevelop-patches-list] r1742 - trunk/MonoDevelop
</A></li>
        <LI>Next message: <A HREF="001351.html">[Monodevelop-patches-list] r1744 - trunk/MonoDevelop/src/Libraries/Gdl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1350">[ date ]</a>
              <a href="thread.html#1350">[ thread ]</a>
              <a href="subject.html#1350">[ subject ]</a>
              <a href="author.html#1350">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jzwart
Date: 2004-06-12 10:34:03 -0400 (Sat, 12 Jun 2004)
New Revision: 1743

Added:
   trunk/MonoDevelop/src/Libraries/Gdl/DetachedHandler.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockedHandler.cs
Modified:
   trunk/MonoDevelop/src/Libraries/Gdl/Dock.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockItem.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockMaster.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockNotebook.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockObject.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockPaned.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockPlaceholder.cs
   trunk/MonoDevelop/src/Libraries/Gdl/GdlDockTest.cs
   trunk/MonoDevelop/src/Libraries/Gdl/Makefile.Gdl
Log:
Don't reduce when frozen; Don't confuse the &quot;dock&quot; signal with the
gdl_dock_object_dock *method*; Use proper events for docking and detaching, 
together with virtual OnDocked and OnDetached methods. Lots of other fixage.
Added more stuff to the GdlDockTest program.


Added: trunk/MonoDevelop/src/Libraries/Gdl/DetachedHandler.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DetachedHandler.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DetachedHandler.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -0,0 +1,21 @@
+using System;
+
+namespace Gdl
+{
+	public delegate void DetachedHandler (object o, DetachedArgs args);
+	
+	public class DetachedArgs : EventArgs {
+		private bool recursive;
+	
+		public DetachedArgs (bool recursive)
+		{
+			this.recursive = recursive;
+		}
+	
+		public bool Recursive {
+			get {
+				return recursive;
+			}
+		}
+	}
+}

Modified: trunk/MonoDevelop/src/Libraries/Gdl/Dock.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/Dock.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/Dock.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -11,65 +11,71 @@
 		private DockObject root = null;
 		private bool floating;
 		private Widget window;
-		private bool auto_title;
+		private bool autoTitle;
 		private int float_x;
 		private int float_y;
 		private int width = -1;
 		private int height = -1;
-		private Gdk.GC xor_gc;
+		private Gdk.GC xorGC;
+		private string title;
 
 		public Dock ()
 		{
 			Flags |= (int)WidgetFlags.NoWindow;
-			DockObjectFlags &amp;= ~(DockObjectFlags.Automatic);
+			
 			if (Master == null) {
+				DockObjectFlags &amp;= ~(DockObjectFlags.Automatic);
 				Bind (new DockMaster ());
 			}
+
 			if (floating) {
 				//Need code here to handle floating shit.
 			}
+
 			DockObjectFlags |= DockObjectFlags.Attached;
 		}
 		
-		public Dock (Dock original, bool _floating) : this ()
+		public Dock (Dock original, bool floating) : this ()
 		{
 			Master = original.Master;
-			floating = _floating;
+			this.floating = floating;
 		}
 		
-		public DockObject Root {
-			get { return root; }
-			set { root = value; }
-		}
-		
 		public bool Floating {
-			get { return floating; }
-			set { floating = value; }
+			get {
+				return floating;
+			}
+			set {
+				floating = value;
+			}
 		}
 		
-		public string DefaultTitle {
+		public int FloatX {
 			get {
-				if (Master != null)
-					return Master.DefaultTitle;
-				return null;
+				return float_x;
 			}
 			set {
-				if (Master != null)
-					Master.DefaultTitle = value;
+				float_x = value;
+				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
+					((Window)window).Resize (width, height);
 			}
 		}
 		
-		public int Width {
-			get { return width; }
+		public int FloatY {
+			get {
+				return float_y;
+			}
 			set {
-				width = value;
+				float_y = value;
 				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
 					((Window)window).Resize (width, height);
 			}
 		}
 		
 		public int Height {
-			get { return height; }
+			get {
+				return height;
+			}
 			set {
 				height = value;
 				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
@@ -77,19 +83,42 @@
 			}
 		}
 		
-		public int FloatX {
-			get { return float_x; }
+		private bool IsController {
+			get {
+				if (Master == null)
+					return false;
+				return Master.Controller == this;
+			}
+		}
+
+		public ICollection NamedItems {
+			get {
+				return Master.DockObjects;
+			}
+		}
+		
+		public DockObject Root {
+			get {
+				return root;
+			}
 			set {
-				float_x = value;
-				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
-					((Window)window).Resize (width, height);
+				root = value;
 			}
 		}
 		
-		public int FloatY {
-			get { return float_y; }
+		public string Title {
+			get {
+				return title;
+			}
 			set {
-				float_y = value;
+				title = value;
+			}
+		}
+		
+		public int Width {
+			get { return width; }
+			set {
+				width = value;
 				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
 					((Window)window).Resize (width, height);
 			}
@@ -127,23 +156,18 @@
 		protected override void OnMapped ()
 		{
 			base.OnMapped ();
-			Console.WriteLine (&quot;Mapping&quot;);
-			if (root != null) {
-				Console.WriteLine (&quot;root.Visible = &quot; + root.Visible);
-				if (root.Visible &amp;&amp; !root.IsMapped) {
-					Console.WriteLine (&quot;Mapping root&quot;);
-					root.Map ();
-				}
-			}
+
+			if (root != null &amp;&amp; root.Visible &amp;&amp; !root.IsMapped)
+				root.Map ();
 		}
 		
 		protected override void OnUnmapped ()
 		{
 			base.OnUnmapped ();
-			if (root != null) {
-				if (root.Visible &amp;&amp; root.IsMapped)
-					root.Unmap ();
-			}
+
+			if (root != null &amp;&amp; root.Visible &amp;&amp; root.IsMapped)
+				root.Unmap ();
+
 			if (window != null)
 				window.Unmap ();
 		}
@@ -151,8 +175,10 @@
 		protected override void OnShown ()
 		{
 			base.OnShown ();
+
 			if (floating &amp;&amp; window != null)
 				window.Show ();
+
 			if (IsController) {
 				foreach (DockObject item in Master.TopLevelDocks) {
 					if (item == this)
@@ -166,34 +192,36 @@
 		protected override void OnHidden ()
 		{
 			base.OnHidden ();
+			
 			if (floating &amp;&amp; window != null)
 				window.Hide ();
-			/*PORT:
-			    if (GDL_DOCK_IS_CONTROLLER (dock)) {
-        gdl_dock_master_foreach_toplevel (GDL_DOCK_OBJECT_GET_MASTER (dock),
-                                          FALSE, (GFunc) gdl_dock_foreach_automatic,
-                                          gtk_widget_hide);
-    		}*/
+
+			if (IsController) {
+				foreach (DockObject item in Master.TopLevelDocks) {
+					if (item == this)
+						continue;
+					if (item.IsAutomatic)
+						item.Hide ();
+				}
+			}
 		}
 		
 		protected override void OnAdded (Widget widget)
 		{
-			Console.WriteLine (&quot;OnAdded {0}&quot;, widget);
 			DockItem child = widget as DockItem;
-			if (child == null)
-				return;
-			
 			AddItem (child, DockPlacement.Top);
 		}
 		
 		protected override void OnRemoved (Widget widget)
 		{
-			bool was_visible = widget.Visible;
+			bool wasVisible = widget.Visible;
+
 			if (root == widget) {
+				root.DockObjectFlags &amp;= ~(DockObjectFlags.Attached);
 				root = null;
-				((DockObject)widget).DockObjectFlags &amp;= ~(DockObjectFlags.Attached);
 				widget.Unparent ();
-				if (was_visible &amp;&amp; Visible)
+
+				if (wasVisible &amp;&amp; Visible)
 					QueueResize ();
 			}
 		}
@@ -204,38 +232,30 @@
 				invoker.Invoke (root);
 		}
 		
-		/*PORT THIS CODE: its an override of Container.ChildType
-		static GtkType
-gdl_dock_child_type (GtkContainer *container)
-{
-    return GDL_TYPE_DOCK_ITEM;
-}*/
-		
-		public override void Detach (bool recursive)
+		public override void OnDetached (bool recursive)
 		{
 			if (recursive &amp;&amp; root != null)
 				root.Detach (recursive);
+
 			DockObjectFlags &amp;= ~(DockObjectFlags.Attached);
 		}
 		
-		public override void Reduce ()
+		public override void OnReduce ()
 		{
 			if (root != null)
 				return;
 			
-			if (IsAutomatic)
+			if (IsAutomatic) {
 				Destroy ();
-			else if (!(IsAttached)) {
+			} else if (!IsAttached) {
 				if (floating)
 					Hide ();
-				else {
-					if (Parent != null &amp;&amp; Parent is Container)
-						((Container)Parent).Remove (this);
-				}
+				else if (Parent != null &amp;&amp; Parent is Container)
+					((Container)Parent).Remove (this);
 			}
 		}
 		
-		public override bool DockRequest (int x, int y, DockRequest request)
+		public override bool OnDockRequest (int x, int y, DockRequest request)
 		{
 			Gdk.Rectangle alloc = Allocation;
 			int bw = (int)BorderWidth;
@@ -281,7 +301,7 @@
 						req_rect.Height = (int)(req_rect.Height * 0.3);
 						my_request.Rect = req_rect;
 					} else {
-						may_dock = root.DockRequest (x, y, my_request);
+						may_dock = root.OnDockRequest (x, y, my_request);
 					}
 				}
 			}
@@ -291,16 +311,18 @@
 			return may_dock;
 		}
 		
-		public override void Docking (DockObject requestor, DockPlacement position, object user_data)
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
 		{
+			/* only dock items allowed at this time */
 			if (!(requestor is DockItem))
 				return;
+
 			if (position == DockPlacement.Floating) {
 				Console.WriteLine (&quot;Adding a floating dockitem&quot;);
 				DockItem item = requestor as DockItem;
 				int x = 0, y = 0, width = -1, height = 01;
-				if (user_data != null &amp;&amp; user_data is Gdk.Rectangle) {
-					Gdk.Rectangle rect = (Gdk.Rectangle)user_data;
+				if (data != null &amp;&amp; data is Gdk.Rectangle) {
+					Gdk.Rectangle rect = (Gdk.Rectangle)data;
 					x = rect.X;
 					y = rect.Y;
 					width = rect.Width;
@@ -308,61 +330,66 @@
 				}
 				AddFloatingItem (item, x, y, width, height);
 			} else if (root != null) {
-				Console.WriteLine (&quot;root was not null, docking to root&quot;);
-				root.Docking (requestor, position, null);
-				//gdl_dock_set_title (dock /*this*/);
-			} else {
-				Console.WriteLine (&quot;root is null, setting requestor to root&quot;);
+				/* This is somewhat a special case since we know
+				   which item to pass the request on because we only
+				   have one child */
+				root.Dock (requestor, position, null);
+				SetWindowTitle ();
+			} else { /* Item about to be added is root item. */
 				root = requestor;
-				root.DockObjectFlags &amp;= DockObjectFlags.Attached;
+				root.DockObjectFlags |= DockObjectFlags.Attached;
 				root.Parent = this;
 				((DockItem)root).ShowGrip ();
-				if (IsRealized) {
-					Console.WriteLine (&quot;realizing new root&quot;);
+				
+				/* Realize the item (create its corresponding GdkWindow)
+			           when the Dock has been realized. */
+				if (IsRealized)
 					root.Realize ();
-				}
+				
+				/* Map the widget if it's visible and the parent is
+			           visible and has been mapped. This is done to make
+			           sure that the GdkWindow is visible. */
 				if (Visible &amp;&amp; root.Visible) {
-					Console.WriteLine (&quot;root is visible&quot;);
-					if (IsMapped) {
-						Console.WriteLine (&quot;mapping new root&quot;);
+					if (IsMapped)
 						root.Map ();
-					}
+					
+					/* Make the widget resize. */
 					root.QueueResize ();
 				}
-				//gdl_dock_set_title (dock /*this*/);
+				
+				SetWindowTitle ();
 			}
 		}
 		
-		public override bool Reorder (DockObject requestor, DockPlacement new_position, object other_data)
+		public override bool OnReorder (DockObject requestor, DockPlacement position, object data)
 		{
-			bool handled = false;
-			if (floating &amp;&amp; new_position == DockPlacement.Floating &amp;&amp; root == requestor) {
-				if (other_data != null &amp;&amp; other_data is Gdk.Rectangle) {
-					Gdk.Rectangle rect = (Gdk.Rectangle)other_data;
-					if (window != null &amp;&amp; window is Window) {
-						((Window)window).Move (rect.X, rect.Y);
-						handled = true;
-					}
+			if (Floating &amp;&amp; position == DockPlacement.Floating &amp;&amp; root == requestor) {
+				if (window != null &amp;&amp; window is Window &amp;&amp;
+				    data != null &amp;&amp; data is Gdk.Rectangle) {
+					Gdk.Rectangle rect = (Gdk.Rectangle)data;
+					((Window)window).Move (rect.X, rect.Y);
+					return true;
 				}
 			}
-			return handled;
+
+			return false;
 		}
 		
-		public override bool ChildPlacement (DockObject child, ref DockPlacement placement)
+		public override bool OnChildPlacement (DockObject child, ref DockPlacement placement)
 		{
-			bool retval = true;
 			if (root == child) {
-				if (placement == DockPlacement.None || placement == DockPlacement.Floating)
+				if (placement == DockPlacement.None ||
+				    placement == DockPlacement.Floating)
 					placement = DockPlacement.Top;
-			} else
-				retval = false;
+				return true;
+			}
 				
-			return retval;
+			return false;
 		}
 		
-		public override void Present (DockObject child)
+		public override void OnPresent (DockObject child)
 		{
-			if (floating &amp;&amp; window != null &amp;&amp; window is Window)
+			if (Floating &amp;&amp; window != null &amp;&amp; window is Window)
 				((Window)window).Present ();
 		}
 		
@@ -370,98 +397,114 @@
 		{
 			if (item == null)
 				return;
+
 			if (placement == DockPlacement.Floating)
 				AddFloatingItem (item, 0, 0, -1, -1);
-			else {
-				Console.WriteLine (&quot;about to dock&quot;);
-				Docking (item, placement, null);
-			}
+			else
+				Dock (item, placement, null);
 		}
 		
 		public void AddFloatingItem (DockItem item, int x, int y, int width, int height)
 		{
-			Gdl.Dock new_dock = new Dock (this, true);
-			new_dock.Width = width;
-			new_dock.Height = height;
-			new_dock.FloatX = x;
-			new_dock.FloatY = y;
+			Gdl.Dock dock = new Dock (this, true);
+			dock.Width = width;
+			dock.Height = height;
+			dock.FloatX = x;
+			dock.FloatY = y;
+			
 			if (Visible) {
-				new_dock.Show ();
+				dock.Show ();
 				if (IsMapped)
-					new_dock.Map ();
-				new_dock.QueueResize ();
+					dock.Map ();
+				dock.QueueResize ();
 			}
-			new_dock.AddItem (item, DockPlacement.Top);
+			
+			dock.AddItem (item, DockPlacement.Top);
 		}
 		
 		public DockItem GetItemByName (string name)
 		{
 			if (name == null)
 				return null;
+
 			DockObject found = Master.GetObject (name);
 			if (found != null &amp;&amp; found is DockItem)
 				return (DockItem)found;
-			return null;
+			else
+				return null;
 		}
 		
 		public DockPlaceholder GetPlaceholderByName (string name)
 		{
 			if (name == null)
 				return null;
+
 			DockObject found = Master.GetObject (name);
 			if (found != null &amp;&amp; found is DockPlaceholder)
 				return (DockPlaceholder)found;
-			return null;
+			else
+				return null;
 		}
 		
-		public ArrayList NamedItems {
-			get {
-				/*PORT THIS:
-				
-    gdl_dock_master_foreach (GDL_DOCK_OBJECT_GET_MASTER (dock),
-                             (GFunc) _gdl_dock_foreach_build_list, &amp;list);
-                             */
-                             return null;
-			}
-		}
-		
 		public static Dock GetTopLevel (DockObject obj)
 		{
 			DockObject parent = obj;
 			while (parent != null &amp;&amp; !(parent is Gdl.Dock))
 				parent = parent.ParentObject;
-			return (Dock)parent;
+
+			return parent != null ? (Dock)parent : null;
 		}
 		
 		public void XorRect (Gdk.Rectangle rect)
 		{
-			if (xor_gc == null) {
+			if (xorGC == null) {
 				if (IsRealized) {
 					Gdk.GCValues values = new Gdk.GCValues ();
 					values.Function = Gdk.Function.Invert;
 					values.SubwindowMode = Gdk.SubwindowMode.IncludeInferiors;
-					xor_gc = new Gdk.GC (GdkWindow);
-					xor_gc.SetValues (values, Gdk.GCValuesMask.Function | Gdk.GCValuesMask.Subwindow);
-				} else
+					xorGC = new Gdk.GC (GdkWindow);
+					xorGC.SetValues (values, Gdk.GCValuesMask.Function |
+							 Gdk.GCValuesMask.Subwindow);
+				} else {
 					return;
+				}
 			}
-			xor_gc.SetLineAttributes (1, Gdk.LineStyle.OnOffDash, Gdk.CapStyle.NotLast, Gdk.JoinStyle.Bevel);
-			xor_gc.SetDashes (1, new sbyte[] { 1, 1}, 2);
-			GdkWindow.DrawRectangle (xor_gc, false, rect.X, rect.Y, rect.Width, rect.Height);
-			xor_gc.SetDashes (0, new sbyte[] { 1, 1}, 2);
-			GdkWindow.DrawRectangle (xor_gc, false, rect.X + 1, rect.Y + 1, rect.Width - 2, rect.Height - 2);
+
+			xorGC.SetLineAttributes (1, Gdk.LineStyle.OnOffDash,
+						 Gdk.CapStyle.NotLast,
+						 Gdk.JoinStyle.Bevel);
+			xorGC.SetDashes (1, new sbyte[] { 1, 1}, 2);
+			
+			GdkWindow.DrawRectangle (xorGC, false, rect.X, rect.Y,
+						 rect.Width, rect.Height);
+
+			xorGC.SetDashes (0, new sbyte[] { 1, 1}, 2);
+
+			GdkWindow.DrawRectangle (xorGC, false, rect.X + 1,
+						 rect.Y + 1, rect.Width - 2,
+						 rect.Height - 2);
 		}
 		
-		private bool IsController {
-			get {
-				if (Master == null) {
-					Console.WriteLine (&quot;Master is null&quot;);
-					return false;
-				}
-				if (Master.Controller == null)
-					Console.WriteLine (&quot;Master.Controller is null&quot;);
-				return (Master.Controller == this); 
+		private void SetWindowTitle ()
+		{
+			if (window == null)
+				return;
+		
+			if (!autoTitle &amp;&amp; LongName != null)
+				title = LongName;
+			else if (Master != null)
+				title = Master.DefaultTitle;
+			
+			if (title == null &amp;&amp; root != null)
+				title = root.LongName;
+			
+			if (title == null) {
+				autoTitle = true;
+				title = &quot;Dock &quot; + Master.DockNumber++;
+				LongName = title;
 			}
+			
+			((Window)window).Title = title;
 		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/Gdl/DockItem.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockItem.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockItem.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -4,7 +4,6 @@
 
 namespace Gdl
 {
-
 	public delegate void DockItemMotionHandler (DockItem o, int x, int y);
 	public delegate void DockItemDragBeginHandler (DockItem o);
 	public delegate void DockItemDragEndHandler (DockItem o, bool cancel);
@@ -15,19 +14,22 @@
 		private DockItemBehavior behavior = DockItemBehavior.Normal;
 		private Orientation orientation = Orientation.Vertical;
 		private bool resize = false;
-		private int dragoff_x = 0;
-		private int dragoff_y = 0;
+		private int dragoffX = 0;
+		private int dragoffY = 0;
 		private Menu menu = null;
-		private bool grip_shown;
 		private DockItemGrip grip;
-		private uint grip_size;
-		private Widget tab_label = null;
-		private int preferred_width = -1;
-		private int preferred_height = -1;
+		private uint gripSize;
+		private Widget tabLabel = null;
+		private int preferredWidth = -1;
+		private int preferredHeight = -1;
 		private DockPlaceholder ph = null;
-		private int start_x;
-		private int start_y;
+		private int startX;
+		private int startY;
 		
+		public event DockItemMotionHandler DockItemMotion;
+		public event DockItemDragBeginHandler DockItemDragBegin;
+		public event DockItemDragEndHandler DockItemDragEnd;		
+				
 		static DockItem ()
 		{
 			Rc.ParseString (&quot;style \&quot;gdl-dock-item-default\&quot; {\n&quot; +
@@ -38,94 +40,128 @@
 			                    &quot;style : gtk \&quot;gdl-dock-item-default\&quot;\n&quot;);
 		}
 		
-		public DockItem ()
+		protected DockItem ()
 		{
+			Flags |= (int)WidgetFlags.NoWindow;
+		
 			if (HasGrip) {
-				grip_shown = true;
 				grip = new DockItemGrip (this);
 				grip.Parent = this;
 				grip.Show ();
-			} else {
-				grip_shown = false;
 			}
-			DockObjectFlags &amp;= ~(DockObjectFlags.Automatic);
 		}
 		
-		public DockItem (string name, string long_name, DockItemBehavior behavior) : this ()
+		public DockItem (string name, string longName, DockItemBehavior behavior) : this ()
 		{
 			Name = name;
-			LongName = long_name;
-			Behavior = behavior;
-			//FIXME: Set the tab label here, should it just be an hbox or that
-			//strange DockTabLabel with what looks like a lot of dead code
-			//from gdl-dock
+			LongName = longName;
+			Behavior = behavior;			
 		}
 		
-		public DockItem (string name, string long_name, string stock_id, DockItemBehavior behavior) : this (name, long_name, behavior)
+		public DockItem (string name, string longName, string stockid,
+				 DockItemBehavior behavior) : this (name, longName, behavior)
 		{
-			StockId = stock_id;
+			StockId = stockid;
 		}
 		
-		public Widget TabLabel {
-			get { return tab_label; }
-			set { tab_label = value; }
+		public DockItemBehavior Behavior {
+			get {
+				return behavior;
+			}
+			set {
+				DockItemBehavior oldBehavior = behavior;
+				behavior = value;
+				if (((oldBehavior ^ behavior) &amp; DockItemBehavior.Locked) != 0) {
+					/* PORT THIS:
+					                if (GDL_DOCK_OBJECT_GET_MASTER (item))
+                    g_signal_emit_by_name (GDL_DOCK_OBJECT_GET_MASTER (item),
+                                           &quot;layout_changed&quot;);
+                g_object_notify (g_object, &quot;locked&quot;);
+                gdl_dock_item_showhide_grip (item);
+                */
+                }
+			}
 		}
 		
-		public new Widget Child {
-			get { return child; }
-			set { child = value; }
+		public bool CantClose {
+			get {
+				return ((Behavior &amp; DockItemBehavior.CantClose) != 0);
+			}
 		}
 		
-		public virtual bool HasGrip {
-			get { return true; }
+		public bool CantIconify {
+			get {
+				return ((Behavior &amp; DockItemBehavior.CantIconify) != 0);
+			}
 		}
 		
+		public new Widget Child {
+			get {
+				return child;
+			}
+			set {
+				child = value;
+			}
+		}
+		
 		public int DragOffX {
-			get { return dragoff_x; }
-			set { dragoff_x = value; }
+			get {
+				return dragoffX;
+			}
+			set {
+				dragoffX = value; 
+			}
 		}
 		
 		public int DragOffY {
-			get { return dragoff_y; }
-			set { dragoff_y = value; }
+			get {
+				return dragoffY;
+			}
+			set {
+				dragoffY = value;
+			}
 		}
 		
-		public override bool IsCompound {
-			get { return false; }
+		public bool GripShown {
+			get {
+				return (HasGrip &amp;&amp; !Locked &amp;&amp; grip.Visible);
+			}
 		}
 		
-		public Orientation Orientation {
-			get { return orientation; }
-			set { SetOrientation (value); }
+		public virtual bool HasGrip {
+			get {
+				return true;
+			}
 		}
 		
-		public bool Resize {
-			get { return resize; }
-			set {
-				resize = value;
-				QueueResize ();
+		public bool Iconified {
+			get {
+				return ((DockObjectFlags &amp; DockObjectFlags.Iconified) != 0);
 			}
 		}
 		
-		public DockItemBehavior Behavior {
-			get { return behavior; }
-			set {
-				DockItemBehavior old_beh = behavior;
-				behavior = value;
-				if (((old_beh ^ behavior) &amp; DockItemBehavior.Locked) != 0) {
-					/* PORT THIS:
-					                if (GDL_DOCK_OBJECT_GET_MASTER (item))
-                    g_signal_emit_by_name (GDL_DOCK_OBJECT_GET_MASTER (item),
-                                           &quot;layout_changed&quot;);
-                g_object_notify (g_object, &quot;locked&quot;);
-                gdl_dock_item_showhide_grip (item);
-                */
-                }
+		public bool InDrag {
+			get {
+				return ((DockObjectFlags &amp; DockObjectFlags.InDrag) != 0);
 			}
 		}
 		
+		public bool InPreDrag {
+			get {
+				return ((DockObjectFlags &amp; DockObjectFlags.InPreDrag) != 0);
+			}
+		}
+		
+		public override bool IsCompound {
+			get {
+				return false;
+			}
+		}
+		
 		public bool Locked {
-			get { return ((behavior &amp; DockItemBehavior.Locked) != 0); }
+			get {
+				return ((behavior &amp; DockItemBehavior.Locked) != 0);
+			}
 			set {
 				DockItemBehavior old_beh = behavior;
 				if (value)
@@ -142,82 +178,95 @@
 			}
 		}
 		
-		public int PreferredWidth {
-			get { return preferred_width; }
-			set { preferred_width = value; }
+		public Orientation Orientation {
+			get {
+				return orientation;
+			}
+			set {
+				SetOrientation (value);
+			}
 		}
 		
 		public int PreferredHeight {
-			get { return preferred_height; }
-			set { preferred_height = value; }
+			get {
+				return preferredHeight;
+			}
+			set {
+				preferredHeight = value;
+			}
 		}
 		
-		public bool InDrag {
-			get { return ((DockObjectFlags &amp; DockObjectFlags.InDrag) != 0); }
+		public int PreferredWidth {
+			get {
+				return preferredWidth;
+			}
+			set {
+				preferredWidth = value;
+			}
 		}
 		
-		public bool InPreDrag {
-			get { return ((DockObjectFlags &amp; DockObjectFlags.InPreDrag) != 0); }
+		public bool Resize {
+			get {
+				return resize;
+			}
+			set {
+				resize = value;
+				QueueResize ();
+			}
 		}
 		
-		public bool Iconified {
-			get { return ((DockObjectFlags &amp; DockObjectFlags.Iconified) != 0); }
+		public Widget TabLabel {
+			get {
+				return tabLabel;
+			}
+			set {
+				tabLabel = value;
+			}
 		}
 		
 		public bool UserAction {
-			get { return ((DockObjectFlags &amp; DockObjectFlags.UserAction) != 0); }
-		}
-		
-		public bool GripShown {
 			get {
-				return (HasGrip &amp;&amp; !Locked &amp;&amp; grip_shown);
+				return ((DockObjectFlags &amp; DockObjectFlags.UserAction) != 0);
 			}
 		}
 		
-		public bool CantClose {
-			get { return ((Behavior &amp; DockItemBehavior.CantClose) != 0); }
-		}
-		
-		public bool CantIconify {
-			get { return ((Behavior &amp; DockItemBehavior.CantIconify) != 0); }
-		}
-		
 		protected override void OnAdded (Widget widget)
 		{
 			if (widget is DockObject) {
 				Console.WriteLine (&quot;You can't add a DockObject to a DockItem&quot;);
 				return;
 			}
+			
 			if (Child != null) {
 				Console.WriteLine (&quot;This DockItem already has a child&quot;);
 				return;
 			}
+			
 			widget.Parent = this;
 			Child = widget;
 		}
 		
 		protected override void OnRemoved (Widget widget)
 		{
+			bool wasVisible = widget.Visible;
+
 			if (grip == widget) {
-				bool grip_was_visible = widget.Visible;
 				widget.Unparent ();
 				grip = null;
-				if (grip_was_visible)
+				if (wasVisible)
 					QueueResize ();
 				return;
+			} else if (widget != Child) {
+				return;
 			}
-			if (InDrag) {
+
+			if (InDrag)
 				DockDragEnd (true);
-			}
 			
-			if (widget != Child)
-				return;
-			
-			bool was_visible = widget.Visible;
 			widget.Unparent ();
 			Child = null;
 			
-			if (was_visible)
+			if (wasVisible)
 				QueueResize ();
 		}
 		
@@ -312,7 +361,9 @@
 		protected override void OnMapped ()
 		{
 			Flags |= (int)WidgetFlags.Mapped;
+			
 			GdkWindow.Show ();
+
 			if (Child != null &amp;&amp; Child.Visible &amp;&amp; !Child.IsMapped)
 				Child.Map ();
 			if (grip != null &amp;&amp; grip.Visible &amp;&amp; !grip.IsMapped)
@@ -322,7 +373,9 @@
 		protected override void OnUnmapped ()
 		{
 			Flags &amp;= ~((int)WidgetFlags.Mapped);
+			
 			GdkWindow.Hide ();
+			
 			if (grip != null)
 				grip.Unmap ();
 		}
@@ -365,82 +418,82 @@
 				grip.ParentWindow = GdkWindow;
 		}
 		
-		protected override void OnStyleSet (Style previous_style)
+		protected override void OnStyleSet (Style style)
 		{
-			if (IsRealized &amp;&amp; !NoWindow) {
+			if (IsRealized &amp;&amp; !IsNoWindow) {
 				Style.SetBackground (GdkWindow, State);
-				if (Drawable) {
+				if (IsDrawable)
 					GdkWindow.Clear ();
-				}
 			}
 		}
 		
 		protected override bool OnExposeEvent (Gdk.EventExpose evnt)
 		{
-			if (Drawable &amp;&amp; evnt.Window == GdkWindow) {
-				Style.PaintBox (Style, GdkWindow, State, ShadowType.None, evnt.Area, this, &quot;dockitem&quot;, 0, 0, -1, -1);
+			if (IsDrawable &amp;&amp; evnt.Window == GdkWindow) {
+				Style.PaintBox (Style, GdkWindow, State,
+						ShadowType.None, evnt.Area, this,
+						&quot;dockitem&quot;, 0, 0, -1, -1);
 				base.OnExposeEvent (evnt);
 			}
+
 			return false;
 		}
 		
-		private bool EventInGripWindow (Gdk.Event evnt)
-		{
-			if (grip != null &amp;&amp; grip.TitleWindow == evnt.Window)
-				return true;
-			return false;
-		}
-		
 		protected override bool OnButtonPressEvent (Gdk.EventButton evnt)
 		{
-			if (!EventInGripWindow (evnt))
+			if (!EventInGripWindow (evnt) || Locked)
 				return false;
-			if (Locked)
-				return false;
 			
-			bool event_handled = false;
-			bool in_handle;
+			bool eventHandled = false;
+			bool inHandle;
 			Gdk.Cursor cursor = null;
 			
+			/* Check if user clicked on the drag handle. */      
 			switch (Orientation) {
 			case Orientation.Horizontal:
-				in_handle = evnt.X &lt; grip.Allocation.Width;
+				inHandle = evnt.X &lt; grip.Allocation.Width;
 				break;
 			case Orientation.Vertical:
-				in_handle = evnt.Y &lt; grip.Allocation.Height;
+				inHandle = evnt.Y &lt; grip.Allocation.Height;
 				break;
 			default:
-				in_handle = false;
+				inHandle = false;
 				break;
 			}
 			
+			/* Left mousebutton click on dockitem. */
 			if (evnt.Button == 1 &amp;&amp; evnt.Type == Gdk.EventType.ButtonPress) {
-				if (in_handle) {
-					start_x = (int)evnt.X;
-					start_y = (int)evnt.Y;
+				/* Set in_drag flag, grab pointer and call begin drag operation. */
+				if (inHandle) {
+					startX = (int)evnt.X;
+					startY = (int)evnt.Y;
 					DockObjectFlags |= DockObjectFlags.InPreDrag;
 					cursor = new Gdk.Cursor (Display, Gdk.CursorType.Fleur);
 					grip.TitleWindow.Cursor = cursor;
-					event_handled = true;
+					eventHandled = true;
 				}
 			} else if (evnt.Type == Gdk.EventType.ButtonRelease &amp;&amp; evnt.Button == 1) {
 				if (InDrag) {
+					/* User dropped widget somewhere. */
 					DockDragEnd (false);
-					event_handled = true;
+					eventHandled = true;
 				} else if (InPreDrag) {
 					DockObjectFlags &amp;= ~(DockObjectFlags.InPreDrag);
-					event_handled = true;
+					eventHandled = true;
 				}
 				
+				/* we check the window since if the item was redocked it's
+				   been unrealized and maybe it's not realized again yet */
 				if (grip.TitleWindow != null) {
 					cursor = new Gdk.Cursor (Display, Gdk.CursorType.Hand2);
 					grip.TitleWindow.Cursor = cursor;
 				}
-			} else if (evnt.Button == 3 &amp;&amp; evnt.Type == Gdk.EventType.ButtonPress &amp;&amp; in_handle) {
+			} else if (evnt.Button == 3 &amp;&amp; evnt.Type == Gdk.EventType.ButtonPress &amp;&amp; inHandle) {
 				DockPopupMenu (evnt.Button, evnt.Time);
-				event_handled = true;
+				eventHandled = true;
 			}
-			return event_handled;
+
+			return eventHandled;
 		}
 		
 		protected override bool OnButtonReleaseEvent (Gdk.EventButton evnt)
@@ -452,11 +505,13 @@
 		{
 			if (!EventInGripWindow (evnt))
 				return false;
+
 			if (InPreDrag) {
-				if (Drag.CheckThreshold (this, start_x, start_y, (int)evnt.X, (int)evnt.Y)) {
+				if (Drag.CheckThreshold (this, startX, startY,
+							 (int)evnt.X, (int)evnt.Y)) {
 					DockObjectFlags &amp;= ~(DockObjectFlags.InPreDrag);
-					dragoff_x = start_x;
-					dragoff_y = start_y;
+					dragoffX = startX;
+					dragoffY = startY;
 					DockDragStart ();
 				}
 			}
@@ -464,16 +519,13 @@
 			if (!InDrag)
 				return false;
 			
-			int new_x = (int)evnt.XRoot;
-			int new_y = (int)evnt.YRoot;
+			int newX = (int)evnt.XRoot;
+			int newY = (int)evnt.YRoot;
+			OnMotion (newX, newY);
 			
-			
-			OnMotion (new_x, new_y);
 			return true;
 		}
 		
-		public event DockItemMotionHandler DockItemMotion;
-				
 		protected void OnMotion (int x, int y)
 		{
 			if (DockItemMotion != null)
@@ -486,19 +538,12 @@
 				DockDragEnd (false);
 				return true;
 			}
+			
 			return base.OnKeyPressEvent (evnt);
 		}
 		
-		public static Requisition PreferredSize (DockItem item)
+		public override bool OnDockRequest (int x, int y, DockRequest request)
 		{
-			Requisition req;
-			req.Width = Math.Max (item.preferred_width, item.Allocation.Width);
-			req.Height = Math.Max (item.preferred_height, item.Allocation.Height);
-			return req;
-		}
-		
-		public override bool DockRequest (int x, int y, DockRequest request)
-		{
 			Gdk.Rectangle alloc = Allocation;
 			int rel_x = x - alloc.X;
 			int rel_y = y - alloc.Y;
@@ -570,12 +615,11 @@
 			return false;
 		}
 		
-		public override void Docking (DockObject requestor, DockPlacement position, object other_data)
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
 		{
 			DockObject parent = ParentObject;
 			DockObject newParent = null;
 			bool addOurselvesFirst;
-			DockObject parentObj = this.ParentObject;
 			
 			switch (position) {
 			case DockPlacement.Top:
@@ -619,14 +663,15 @@
 			if (Visible)
 				newParent.Show ();
 			
-			if (position != DockPlacement.Center &amp;&amp; other_data != null &amp;&amp; other_data is System.Int32) {
+			if (position != DockPlacement.Center &amp;&amp; data != null &amp;&amp;
+			    data is System.Int32) {
 				//PORT THIS:
 				//g_object_set (G_OBJECT (newParent), &quot;position&quot;, g_value_get_uint (other_data), NULL);
 			}
 			
 			DockObjectFlags &amp;= ~(DockObjectFlags.InReflow);
+
 			newParent.Thaw ();
-			
 			if (parent != null)
 				parent.Thaw ();
 		}
@@ -671,8 +716,6 @@
 			OnDragBegin ();
 		}
 		
-		public event DockItemDragBeginHandler DockItemDragBegin;
-		
 		protected void OnDragBegin ()
 		{
 			if (DockItemDragBegin != null)
@@ -688,7 +731,6 @@
 			DockObjectFlags &amp;= ~(DockObjectFlags.InDrag);
 		}
 		
-		public event DockItemDragEndHandler DockItemDragEnd;
 		
 		protected void OnDragEnd (bool cancel)
 		{
@@ -707,19 +749,22 @@
 			QueueResize ();
 		}
 		
-		public void DockTo (DockItem target, DockPlacement position, int docking_param)
+		public void DockTo (DockItem target, DockPlacement position)
 		{
-			if (target == null || position == DockPlacement.Floating)
+			if (target == null &amp;&amp; position != DockPlacement.Floating)
 				return;
-			if (position == DockPlacement.Floating || target == null) {
+
+			if (position == DockPlacement.Floating || target != null) {
 				if (!IsBound) {
-					Console.WriteLine (&quot;Attempting to bind an unbound object&quot;);
+					Console.WriteLine (&quot;Attempting to bind an unbound item&quot;);
 					return;
 				}
-				dragoff_x = dragoff_y = 0;
+				
+				dragoffX = dragoffY = 0;
 				((Dock)Master.Controller).AddFloatingItem (this, 0, 0, -1, -1);
-			} else
-				target.Docking (this, position, null);
+			} else {
+				target.Dock (this, position, null);
+			}
 		}
 		
 		public virtual void SetOrientation (Orientation orientation)
@@ -741,18 +786,14 @@
 		
 		public void HideGrip ()
 		{
-			if (grip_shown) {
-				grip_shown = false;
+			if (GripShown)
 				ShowHideGrip ();
-			}
 		}
 		
 		public void ShowGrip ()
 		{
-			if (!grip_shown) {
-				grip_shown = true;
+			if (!GripShown)
 				ShowHideGrip ();
-			}
 		}
 		
 		public void Bind (Dock dock)
@@ -766,16 +807,18 @@
 		public void HideItem ()
 		{
 			if (!IsAttached)
+				/* already hidden/detached */
 				return;
 			
-			if (!IsAutomatic) {
+			/* if the object is manual, create a new placeholder to be
+			   able to restore the position later */
+			if (!IsAutomatic)
 				ph = new DockPlaceholder (this, false);
-			}
 			
 			Freeze ();
-			if (IsCompound) {
+
+			if (IsCompound)
 				Foreach (new Callback (HideItem));
-			}
 			
 			Detach (true);
 			Thaw ();
@@ -815,7 +858,7 @@
 				ph = null;
 			} else if (IsBound) {
 				if (Master.Controller != null) {
-					Master.Controller.Docking (this, DockPlacement.Floating, null);
+					Master.Controller.Dock (this, DockPlacement.Floating, null);
 				}
 			}
 		}
@@ -832,5 +875,21 @@
 				}
 			}
 		}
+
+		public static Requisition PreferredSize (DockItem item)
+		{
+			Requisition req;
+			req.Width = Math.Max (item.preferredWidth, item.Allocation.Width);
+			req.Height = Math.Max (item.preferredHeight, item.Allocation.Height);
+			return req;
+		}
+		
+		private bool EventInGripWindow (Gdk.Event evnt)
+		{
+			if (grip != null &amp;&amp; grip.TitleWindow == evnt.Window)
+				return true;
+			else
+				return false;
+		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/Gdl/DockMaster.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockMaster.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockMaster.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -1,7 +1,6 @@
 // created on 05/06/2004 at 11:14 A
 using System;
 using System.Collections;
-
 using Gtk;
 
 namespace Gdl
@@ -9,66 +8,90 @@
 	public class DockMaster
 	{
 		private object obj;
-		private Hashtable dock_objects = new Hashtable ();
-		private ArrayList toplevel_docks = null;
+		private Hashtable dockObjects = new Hashtable ();
+		private ArrayList toplevelDocks = null;
 		private DockObject controller = null;
-		private int dock_number = 1;
+		private int dockNumber = 1;
 		private int number = 1;
-		private string default_title;
+		private string defaultTitle;
 		private Gdk.GC root_xor_gc;
-		private bool rect_drawn;
-		private Dock rect_owner;
-		private DockRequest drag_request;
+		private bool rectDrawn;
+		private Dock rectOwner;
+		private DockRequest dragRequest;
 		private uint idle_layout_changed_id;
-		private Hashtable locked_items = new Hashtable ();
-		private Hashtable unlocked_items = new Hashtable ();
+		private Hashtable lockedItems = new Hashtable ();
+		private Hashtable unlockedItems = new Hashtable ();
 		
-		public DockMaster () { Console.WriteLine (&quot;Creating a new DockMaster&quot;); }
+		public DockMaster () 
+		{
+			Console.WriteLine (&quot;Creating a new DockMaster&quot;);
+		}
 		
 		public string DefaultTitle {
-			get { return default_title; }
-			set { default_title = value; }
+			get {
+				return defaultTitle;
+			}
+			set {
+				defaultTitle = value;
+			}
 		}
-				
+		
+		public int DockNumber {
+			get {
+				return dockNumber;
+			}
+			set {
+				dockNumber = value;
+			}
+		}
+		
+		public ICollection DockObjects {
+			get {
+				return dockObjects.Values;
+			}
+		}
+		
 		public int Locked {
 			get {
-				if (unlocked_items.Count == 0)
+				if (unlockedItems.Count == 0)
 					return 1;
-				if (locked_items.Count == 0)
+				if (lockedItems.Count == 0)
 					return 0;
 				return -1;
 			}
 			set {
 				if (value &gt;= 0)
-					this.LockUnlock (value &gt; 0);
+					LockUnlock (value &gt; 0);
 			}
 		}
 		
 		public ArrayList TopLevelDocks {
-			get { return toplevel_docks; }
+			get {
+				return toplevelDocks;
+			}
 		}
 		
-		protected void foreach_lock_unlock (DockItem item, bool locked)
+		protected void ForeachLockUnlock (DockItem item, bool locked)
 		{
 			item.Locked = locked;
 			if (item.IsCompound) {
 				/*PORT THIS: Container.Foreach doesnt take the arg i need it to take.
 				        gtk_container_foreach (GTK_CONTAINER (item),
-                               (GtkCallback) foreach_lock_unlock,
+                               (GtkCallback) ForeachLockUnlock,
                                (gpointer) locked);*/
 			}
 		}
 		
 		public void LockUnlock (bool locked)
 		{
-			foreach (Gdl.Dock dock in toplevel_docks) {
+			foreach (Dock dock in toplevelDocks) {
 				if (dock.Root != null &amp;&amp; dock.Root is DockItem)
-					foreach_lock_unlock ((DockItem)dock.Root, locked);
+					ForeachLockUnlock ((DockItem)dock.Root, locked);
 			}
 			/*PORT THIS:
 			    // just to be sure hidden items are set too
     gdl_dock_master_foreach (master,
-                             (GFunc) foreach_lock_unlock,
+                             (GFunc) ForeachLockUnlock,
                              (gpointer) locked);*/
 		}
 		
@@ -77,29 +100,32 @@
 		{
 			if (item == null)
 				return;
-			if (this.drag_request == null)
-				this.drag_request = new DockRequest ();
-			DockRequest request = this.drag_request;
+
+			if (dragRequest == null)
+				dragRequest = new DockRequest ();
+
+			DockRequest request = dragRequest;
 			request.Applicant = item;
 			request.Target = item;
 			request.Position = DockPlacement.Floating;
 			request.Extra = null;
-			this.rect_drawn = false;
-			this.rect_owner = null;
+			rectDrawn = false;
+			rectOwner = null;
 		}
 		
 		public void DragEnd (DockItem item, bool cancelled)
 		{
 			if (item == null)
 				return;
-			DockRequest request = this.drag_request;
+
+			DockRequest request = dragRequest;
 			if (item != request.Applicant)
 				return;
-			if (this.rect_drawn)
+			if (rectDrawn)
 				XorRect ();
 			if (cancelled || request.Applicant == request.Target)
 				return;
-			request.Target.Docking (request.Applicant, request.Position, request.Extra);
+			request.Target.Dock (request.Applicant, request.Position, request.Extra);
 			//emit LayoutChanged here
 		}
 		
@@ -107,7 +133,7 @@
 		{
 			if (item == null)
 				return;
-			DockRequest request = this.drag_request;
+			DockRequest request = dragRequest;
 			if (request.Applicant == item)
 				return;
 			DockRequest my_request = new DockRequest (request);
@@ -139,13 +165,13 @@
 				dock.GdkWindow.GetOrigin (out win_x, out win_y);
 				x = root_x - win_x;
 				y = root_y - win_y;
-				may_dock = dock.DockRequest (x, y, my_request);
+				may_dock = dock.OnDockRequest (x, y, my_request);
 			} else {
-				foreach (Dock top_dock in toplevel_docks) {
+				foreach (Dock top_dock in toplevelDocks) {
 					top_dock.GdkWindow.GetOrigin (out win_x, out win_y);
 					x = root_x - win_x;
 					y = root_y - win_y;
-					may_dock = top_dock.DockRequest (x, y, my_request);
+					may_dock = top_dock.OnDockRequest (x, y, my_request);
 					if (may_dock)
 						break;
 				}
@@ -168,78 +194,79 @@
 			      my_request.Rect.Y == request.Rect.Y &amp;&amp;
 			      my_request.Rect.Width == request.Rect.Width &amp;&amp;
 			      my_request.Rect.Height == request.Rect.Height &amp;&amp;
-			      dock == this.rect_owner)) {
-				if (this.rect_drawn) {
+			      dock == rectOwner)) {
+				if (rectDrawn) {
 					XorRect ();
 				}
 			}
 			
 			request = my_request;
-			this.rect_owner = dock;
+			rectOwner = dock;
 			
-			if (!this.rect_drawn) {
+			if (!rectDrawn) {
 				XorRect ();
 			}
 		}
 		
 		public void XorRect ()
 		{
-			if (this.drag_request == null)
+			if (dragRequest == null)
 				return;
-			this.rect_drawn = !(this.rect_drawn);
-			if (this.rect_owner != null) {
-				this.rect_owner.XorRect (this.drag_request.Rect);
+			rectDrawn = !(rectDrawn);
+			if (rectOwner != null) {
+				rectOwner.XorRect (dragRequest.Rect);
 				return;
 			}
 			
-			Gdk.Rectangle rect = this.drag_request.Rect;
+			Gdk.Rectangle rect = dragRequest.Rect;
 			Gdk.Window window = Gdk.Global.DefaultRootWindow;
-			if (this.root_xor_gc == null) {
+			if (root_xor_gc == null) {
 				Gdk.GCValues values = new Gdk.GCValues ();
 				values.Function = Gdk.Function.Invert;
 				values.SubwindowMode = Gdk.SubwindowMode.IncludeInferiors;
-				this.root_xor_gc = new Gdk.GC (window);
-				this.root_xor_gc.SetValues (values, Gdk.GCValuesMask.Function | Gdk.GCValuesMask.Subwindow);
+				root_xor_gc = new Gdk.GC (window);
+				root_xor_gc.SetValues (values, Gdk.GCValuesMask.Function | Gdk.GCValuesMask.Subwindow);
 			}
-			this.root_xor_gc.SetLineAttributes (1, Gdk.LineStyle.OnOffDash, Gdk.CapStyle.NotLast, Gdk.JoinStyle.Bevel);
-			this.root_xor_gc.SetDashes (1, new sbyte[] {1, 1}, 2);
-			window.DrawRectangle (this.root_xor_gc, false, rect.X, rect.Y, rect.Width, rect.Height);
-			this.root_xor_gc.SetDashes (0, new sbyte[] {1, 1}, 2);
-			window.DrawRectangle (this.root_xor_gc, false, rect.X + 1, rect.Y + 1, rect.Width - 2, rect.Height - 2);
+			root_xor_gc.SetLineAttributes (1, Gdk.LineStyle.OnOffDash, Gdk.CapStyle.NotLast, Gdk.JoinStyle.Bevel);
+			root_xor_gc.SetDashes (1, new sbyte[] {1, 1}, 2);
+			window.DrawRectangle (root_xor_gc, false, rect.X, rect.Y, rect.Width, rect.Height);
+			root_xor_gc.SetDashes (0, new sbyte[] {1, 1}, 2);
+			window.DrawRectangle (root_xor_gc, false, rect.X + 1, rect.Y + 1, rect.Width - 2, rect.Height - 2);
 		}
 		
-		public void Add (DockObject objekt)
+		public void Add (DockObject obj)
 		{
-			if (objekt == null)
+			if (obj == null)
 				return;
-			if (!objekt.IsAutomatic) {
-				if (objekt.Name == null)
-					objekt.Name = &quot;__dock_&quot; + this.number++;
-				DockObject found_object = (DockObject)this.dock_objects[objekt.Name];
-				if (found_object != null) {
+
+			if (!obj.IsAutomatic) {
+				if (obj.Name == null)
+					obj.Name = &quot;__dock_&quot; + number++;
+
+				DockObject foundObject = (DockObject)dockObjects[obj.Name];
+				if (foundObject != null)
 					Console.WriteLine (&quot;Unable to add object, name taken&quot;);
-				} else {
-					this.dock_objects[objekt.Name] = objekt;
-				}
+				else
+					dockObjects[obj.Name] = obj;
 			}
 			
-			if (objekt is Dock) {
-				if (this.toplevel_docks == null) {
-					this.controller = objekt;
-					this.toplevel_docks = new ArrayList ();
+			if (obj is Dock) {
+				if (toplevelDocks == null) {
+					controller = obj;
+					toplevelDocks = new ArrayList ();
 				}
-				if (((Dock)objekt).Floating) {
-					this.toplevel_docks.Insert (0, objekt);
-				} else {
-					this.toplevel_docks.Add (objekt);
-				}
+				
+				if (((Dock)obj).Floating)
+					toplevelDocks.Insert (0, obj);
+				else
+					toplevelDocks.Add (obj);
+				
 				/* PORT THIS:
 				        g_signal_connect (object, &quot;dock&quot;,
-                          G_CALLBACK (item_dock_cb), master);
+                          				  G_CALLBACK (item_dock_cb), master);
 				*/
-			} else if (objekt is DockItem) {
-				Console.WriteLine (&quot;HOOKING UP EVENTS&quot;);
-				DockItem dock_item = objekt as DockItem;
+			} else if (obj is DockItem) {
+				DockItem dock_item = obj as DockItem;
 				dock_item.DockItemDragBegin += new DockItemDragBeginHandler (DragBegin);
 				dock_item.DockItemMotion += new DockItemMotionHandler (DragMotion);
 				dock_item.DockItemDragEnd += new DockItemDragEndHandler (DragEnd);
@@ -265,32 +292,32 @@
 			}
 		}
 		
-		public void Remove (DockObject objekt)
+		public void Remove (DockObject obj)
 		{
-			if (objekt == null)
+			if (obj == null)
 				return;
-			if (objekt is DockItem &amp;&amp; ((DockItem)objekt).HasGrip) {
-				int locked = this.Locked;
-				if (this.locked_items.Contains (objekt)) {
-					this.locked_items.Remove (objekt);
-					if (this.Locked != locked) {
+			if (obj is DockItem &amp;&amp; ((DockItem)obj).HasGrip) {
+				int locked = Locked;
+				if (lockedItems.Contains (obj)) {
+					lockedItems.Remove (obj);
+					if (Locked != locked) {
 						//g_object_notify (G_OBJECT (master /*this*/), &quot;locked&quot;);
 					}
 				}
-				if (this.unlocked_items.Contains (objekt)) {
-					this.locked_items.Remove (objekt);
-					if (this.Locked != locked) {
+				if (unlockedItems.Contains (obj)) {
+					lockedItems.Remove (obj);
+					if (Locked != locked) {
 						//g_object_notify (G_OBJECT( master /*this*/), &quot;locked&quot;);
 					}
 				}
 			}
 			
-			if (objekt is Dock) {
-				if (this.toplevel_docks.Contains (objekt))
-					this.toplevel_docks.Remove (objekt);
-				if (objekt == this.controller) {
+			if (obj is Dock) {
+				if (toplevelDocks.Contains (obj))
+					toplevelDocks.Remove (obj);
+				if (obj == controller) {
 					DockObject new_controller = null;
-					ArrayList reversed = toplevel_docks;
+					ArrayList reversed = toplevelDocks;
 					reversed.Reverse ();
 					foreach (DockObject item in reversed) {
 						if (!item.IsAutomatic) {
@@ -299,15 +326,15 @@
 						}
 					}
 					if (new_controller != null) {
-						this.controller = new_controller;
+						controller = new_controller;
 					} else {
-						this.controller = null;
+						controller = null;
 					}
 				}
 			}
 			
-			if (objekt is DockItem) {
-				DockItem dock_item = objekt as DockItem;
+			if (obj is DockItem) {
+				DockItem dock_item = obj as DockItem;
 				dock_item.DockItemDragBegin -= DragBegin;
 				dock_item.DockItemDragEnd -= DragEnd;
 				dock_item.DockItemMotion -= DragMotion;
@@ -316,15 +343,15 @@
 			/*PORT THIS:
     g_signal_handlers_disconnect_matched (object, G_SIGNAL_MATCH_DATA, 
                                           0, 0, NULL, NULL, master);*/
-			if (objekt.Name != null) {
-				if (this.dock_objects.Contains (objekt.Name)) {
-					this.dock_objects.Remove (objekt.Name);
+			if (obj.Name != null) {
+				if (dockObjects.Contains (obj.Name)) {
+					dockObjects.Remove (obj.Name);
 				}
 			}
 			
-			if (!objekt.IsAutomatic) {
-				if (this.idle_layout_changed_id == 0) {
-					this.idle_layout_changed_id = 0; //g_idle_add (idle_emit_layout_changed);
+			if (!obj.IsAutomatic) {
+				if (idle_layout_changed_id == 0) {
+					idle_layout_changed_id = 0; //g_idle_add (idle_emit_layout_changed);
 				}
 			}
 		}
@@ -333,22 +360,22 @@
 		{
 			if (name == null)
 				return null;
-			return (DockObject)this.dock_objects[name];
+			return (DockObject)dockObjects[name];
 		}
 		
 		public DockObject Controller {
-			get { return this.controller; }
+			get { return controller; }
 			set {
 				if (value != null) {
 					if (value.IsAutomatic)
 						Console.WriteLine (&quot;New controller is automatic, only manual dock objects should be named controller&quot;);
-					if (!this.toplevel_docks.Contains (value))
-						this.Add (value);
-					this.controller = value;
+					if (!toplevelDocks.Contains (value))
+						Add (value);
+					controller = value;
 				} else {
-					this.controller = null;
+					controller = null;
 				}
 			}
 		}
 	}
-}
\ No newline at end of file
+}

Modified: trunk/MonoDevelop/src/Libraries/Gdl/DockNotebook.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockNotebook.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockNotebook.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -7,10 +7,24 @@
 {
 	public class DockNotebook : DockItem
 	{
+		private struct DockInfo
+		{
+			public DockPlacement position;
+			public object data;
+			
+			public DockInfo (DockPlacement position, object data)
+			{
+				this.position = position;
+				this.data = data;
+			}
+		}
 		
+		private DockInfo dockInfo;
+		private CallbackInvoker storedInvoker;
+
 		static DockNotebook ()
 		{
-			Gtk.Rc.ParseString (&quot;style \&quot;gdl-dock-notebook-default\&quot; {\n&quot; +
+			Rc.ParseString (&quot;style \&quot;gdl-dock-notebook-default\&quot; {\n&quot; +
 			                    &quot;xthickness = 2\n&quot; +
 			                    &quot;ythickness = 2\n&quot; +
 			                    &quot;}\n&quot; +
@@ -20,15 +34,15 @@
 		
 		public DockNotebook ()
 		{
-			this.Child = new Gtk.Notebook ();
-			this.Child.Parent = this;
-			((Gtk.Notebook)this.Child).TabPos = Gtk.PositionType.Bottom;
-			//((Gtk.Notebook)this.Child).SwitchPage += new Gtk.SwitchPageHandler (SwitchPageCb);
-			//((Gtk.Notebook)this.Child).ButtonPressEvent += new Gtk.ButtonPressEvent (ButtonPressCb);
-			//((Gtk.Notebook)this.Child).ButtonReleaseEvent += new Gtk.ButtonReleaseEvent (ButtonReleaseCb);
-			((Gtk.Notebook)this.Child).Scrollable = true;
-			this.Child.Show ();
-			this.DockObjectFlags &amp;= DockObjectFlags.Automatic;
+			Child = new Notebook ();
+			Child.Parent = this;
+			((Notebook)Child).TabPos = PositionType.Bottom;
+			//((Notebook)Child).SwitchPage += new SwitchPageHandler (SwitchPageCb);
+			//((Notebook)Child).ButtonPressEvent += new ButtonPressEvent (ButtonPressCb);
+			//((Notebook)Child).ButtonReleaseEvent += new ButtonReleaseEvent (ButtonReleaseCb);
+			((Notebook)Child).Scrollable = true;
+			Child.Show ();
+			DockObjectFlags &amp;= DockObjectFlags.Automatic;
 		}
 		
 		protected void SwitchPageHandler (object o, SwitchPageArgs e)
@@ -36,94 +50,83 @@
 			//Does this code need to be ported at all?
 		}
 		
-		protected override void OnAdded (Gtk.Widget widget)
+		protected override void OnAdded (Widget widget)
 		{
 			if (widget == null || !(widget is DockItem))
 				return;
-			this.Docking ((DockObject)widget, DockPlacement.Center, null);
+
+			Dock ((DockObject)widget, DockPlacement.Center, null);
 		}
 		
-		private CallbackInvoker stored_invoker;
-		protected override void ForAll (bool include_internals, CallbackInvoker invoker)
+		protected override void ForAll (bool includeInternals, CallbackInvoker invoker)
 		{
-			if (include_internals) {
-				base.ForAll (include_internals, invoker);
+			if (includeInternals) {
+				base.ForAll (includeInternals, invoker);
 			} else {
-				if (this.Child != null) {
-					stored_invoker = invoker;
-					((Gtk.Notebook)this.Child).Foreach (new Gtk.Callback (childForAll));
+				if (Child != null) {
+					storedInvoker = invoker;
+					((Notebook)Child).Foreach (new Callback (ChildForAll));
 				}
 			}
 		}
 		
-		private void childForAll (Gtk.Widget widget)
+		private void ChildForAll (Widget widget)
 		{
-			stored_invoker.Invoke (widget);
+			storedInvoker.Invoke (widget);
 		}
 		
-		protected struct DockInfo
+		private void DockChild (Widget w)
 		{
-			public DockPlacement position;
-			public object other_data;
-			
-			public DockInfo (DockPlacement pos, object data)
-			{
-				position = pos;
-				other_data = data;
-			}
-		}
-		
-		private void dock_child (Widget w)
-		{
 			if (w is DockObject)
-				this.Docking ((DockObject)w, stored_info.position, stored_info.other_data);
+				Dock ((DockObject)w, dockInfo.position, dockInfo.data);
 		}
 		
-		private DockInfo stored_info;
-		public override void Docking (DockObject requestor, DockPlacement position, object extra_data)
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
 		{
+			/* we only add support for DockPlacement.Center docking
+			   strategy here... for the rest use our parent class' method */
 			if (position == DockPlacement.Center) {
+				/* we can only dock simple (not compound) items */
 				if (requestor.IsCompound) {
 					requestor.Freeze ();
-					stored_info = new DockInfo (position, extra_data);
-					requestor.Foreach (new Gtk.Callback (dock_child));
+					dockInfo = new DockInfo (position, data);
+					requestor.Foreach (new Callback (DockChild));
 					requestor.Thaw ();
 				} else {
-					DockItem requestor_item = requestor as DockItem;
-					if (requestor_item == null)
-						return;
-					Gtk.Widget label = requestor_item.TabLabel;
+					DockItem requestorItem = requestor as DockItem;
+					Widget label = requestorItem.TabLabel;
 					if (label == null) {
-						label = new Gtk.Label (requestor_item.LongName);
-						requestor_item.TabLabel = label;
+						label = new Label (requestorItem.LongName);
+						requestorItem.TabLabel = label;
 					}
-					int new_position = -1;
-					if (extra_data is Int32)
-						new_position = Convert.ToInt32 (extra_data);
-					Console.WriteLine (requestor_item + &quot; --&gt; &quot; + requestor_item.Child + &quot; &lt;-- &quot; + requestor_item.Child.Parent);
-					((Gtk.Notebook)this.Child).InsertPage (requestor, label, new_position);
+					
+					int tabPosition = -1;
+					if (data is Int32)
+						tabPosition = Convert.ToInt32 (data);
+					((Notebook)Child).InsertPage (requestor, label, tabPosition);
 					requestor.DockObjectFlags |= DockObjectFlags.Attached;
 				}
-			} else
-				base.Docking (requestor, position, extra_data);
+			} else {
+				base.OnDocked (requestor, position, data);
+			}
 		}
 		
-		public override void SetOrientation (Gtk.Orientation orientation)
+		public override void SetOrientation (Orientation orientation)
 		{
-			if (this.Child != null &amp;&amp; this.Child is Gtk.Notebook) {
-				if (orientation == Gtk.Orientation.Horizontal)
-					((Gtk.Notebook)this.Child).TabPos = Gtk.PositionType.Top;
+			if (Child != null &amp;&amp; Child is Notebook) {
+				if (orientation == Orientation.Horizontal)
+					((Notebook)Child).TabPos = PositionType.Top;
 				else
-					((Gtk.Notebook)this.Child).TabPos = Gtk.PositionType.Left;
+					((Notebook)Child).TabPos = PositionType.Left;
 			}
 			base.SetOrientation (orientation);
 		}
 		
-		public override bool ChildPlacement (DockObject child, ref DockPlacement position)
+		public override bool OnChildPlacement (DockObject child, ref DockPlacement position)
 		{
 			DockPlacement pos = DockPlacement.None;
-			if (this.Child != null) {
-				foreach (Gtk.Widget widget in ((Gtk.Notebook)this.Child).Children) {
+			if (Child != null) {
+				foreach (Widget widget in ((Notebook)Child).Children) {
 					if (widget == child) {
 						pos = DockPlacement.Center;
 						break;
@@ -137,27 +140,29 @@
 			return false;
 		}
 		
-		public override void Present (DockObject child)
+		public override void OnPresent (DockObject child)
 		{
-			int i = ((Gtk.Notebook)this.Child).PageNum (child);
-			if (i &gt;= 0) {
-				((Gtk.Notebook)this.Child).CurrentPage = i;
-			}
-			base.Present (child);
+			Notebook nb = Child as Notebook;
+			
+			int i = nb.PageNum (child);
+			if (i &gt;= 0)
+				nb.CurrentPage = i;
+
+			base.OnPresent (child);
 		}
 		
-		public override bool Reorder (DockObject requestor, DockPlacement new_position, object other_data)
+		public override bool OnReorder (DockObject requestor, DockPlacement position, object other_data)
 		{
 			bool handled = false;
 			int current_position, new_pos = -1;
 			
-			if (this.Child != null &amp;&amp; new_position == DockPlacement.Center) {
-				current_position = ((Gtk.Notebook)this.Child).PageNum (requestor);
+			if (Child != null &amp;&amp; position == DockPlacement.Center) {
+				current_position = ((Notebook)Child).PageNum (requestor);
 				if (current_position &gt;= 0) {
 					handled = true;
 					if (other_data is Int32)
 						new_pos = Convert.ToInt32 (other_data);
-					((Gtk.Notebook)this.Child).ReorderChild (requestor, new_pos);
+					((Notebook)Child).ReorderChild (requestor, new_pos);
 				}
 			}
 			return handled;
@@ -168,12 +173,12 @@
 		}
 		
 		public int Page {
-			get { return ((Gtk.Notebook)this.Child).CurrentPage; }
-			set { ((Gtk.Notebook)this.Child).CurrentPage = value; }
+			get { return ((Notebook)Child).CurrentPage; }
+			set { ((Notebook)Child).CurrentPage = value; }
 		}
 		
 		public override bool HasGrip {
 			get { return false; }
 		}
 	}
-}
\ No newline at end of file
+}

Modified: trunk/MonoDevelop/src/Libraries/Gdl/DockObject.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockObject.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockObject.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -2,40 +2,85 @@
 using System;
 using Gtk;
 
-//FIXME: need to figure out how to handle reduce vmethod vs real_reduce vs
-//reduce public api... fucking gobject.
-
-//FIXME: Event emitting doesnt happen, and it needs to.
 namespace Gdl
 {
 	public class DockObject : Container
 	{	
-		private Container container;
-		private DockObjectFlags flags;
-		private int freeze_count;
+		private DockObjectFlags flags = DockObjectFlags.Automatic;
+		private int freezeCount = 0;
 		private DockMaster master;
 		private string name;
-		private string long_name;
-		private string stock_id;
-		private bool reduce_pending;
+		private string longName;
+		private string stockid;
+		private bool reducePending;
 		
-		public new string Name {
-			get { return name; }
-			set { name = value; }
+		public event DetachedHandler Detached;
+		public event DockedHandler Docked;
+		
+		public DockObjectFlags DockObjectFlags {
+			get {
+				return flags;
+			}
+			set {
+				flags = value;
+			}
 		}
 		
-		public string LongName {
-			get { return long_name; }
-			set { long_name = value; }
+		public bool InDetach {
+			get {
+				return ((flags &amp; DockObjectFlags.InDetach) != 0);
+			}
 		}
 		
-		public string StockId {
-			get { return stock_id; }
-			set { stock_id = value; }
+		public bool InReflow {
+			get {
+				return ((flags &amp; DockObjectFlags.InReflow) != 0);
+			}
 		}
 		
+		public bool IsAttached {
+			get {
+				return ((flags &amp; DockObjectFlags.Attached) != 0);
+			}
+		}
+		
+		public bool IsAutomatic {
+			get {
+				return ((flags &amp; DockObjectFlags.Automatic) != 0);
+			}
+		}
+		
+		public bool IsBound {
+			get {
+				return master != null;
+			}
+		}
+		
+		public virtual bool IsCompound {
+			get {
+				return true;
+			}
+		}
+		
+		public bool IsFrozen {
+			get {
+				return freezeCount &gt; 0;
+			}
+		}
+		
+		public string LongName {
+			get {
+				return longName;
+			}
+			set {
+				longName = value;
+			}
+		}
+		
 		public DockMaster Master {
-			get { return master; }
+			get {
+				return master;
+			}
 			set {
 				if (value != null)
 					Bind (master);
@@ -44,46 +89,71 @@
 			}
 		}
 		
+		public new string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public DockObject ParentObject {
+			get {
+				Widget parent = Parent;
+				while (parent != null &amp;&amp; !(parent is DockObject)) {
+					parent = parent.Parent;
+				}
+				return parent != null ? (DockObject)parent : null;
+			}
+		}
+		public string StockId {
+			get {
+				return stockid;
+			}
+			set {
+				stockid = value;
+			}
+		}
+		
 		protected override void OnShown ()
 		{
-			if (IsCompound) {
-				foreach (Widget child in Children) {
+			if (IsCompound)
+				foreach (Widget child in Children)
 					child.Show ();
-				}
-			}
+
 			base.OnShown ();
 		}
 		
 		protected override void OnHidden ()
 		{
-			if (IsCompound) {
-				foreach (Widget child in Children) {
+			if (IsCompound)
+				foreach (Widget child in Children)
 					child.Hide ();
-				}
-			}
+
 			base.OnHidden ();
 		}
 		
-		public virtual void Detach (bool recursive)
+		public virtual void OnDetached (bool recursive)
 		{
-			//Detach children
+			/* detach children */
 			if (recursive &amp;&amp; IsCompound) {
 				foreach (DockObject child in Children) {
 					child.Detach (recursive);
 				}
 			}
-			//Detach object itself.
+			
+			/* detach the object itself */
 			flags &amp;= ~(DockObjectFlags.Attached);
 			DockObject parent = ParentObject;
-			if (Parent != null &amp;&amp; Parent is Container) {
+			if (Parent != null &amp;&amp; Parent is Container)
 				((Container)Parent).Remove (this);
-			}
+
 			if (parent != null)
 				parent.Reduce ();
 		}
 		
-		
-		public virtual void Reduce ()
+		public virtual void OnReduce ()
 		{
 			if (!IsCompound)
 				return;
@@ -93,145 +163,181 @@
 			if (children.Length &lt;= 1) {
 				if (parent != null)
 					parent.Freeze ();
+
 				Freeze ();
 				Detach (false);
+
 				foreach (Widget widget in children) {
 					DockObject child = widget as DockObject;
-					if (child == null) continue;
 					child.flags |= DockObjectFlags.InReflow;
 					child.Detach (false);
 					if (parent != null)
 						parent.Add (child);
 					child.flags &amp;= ~(DockObjectFlags.InReflow);
 				}
-				reduce_pending = false;
+				
+				reducePending = false;
+
 				Thaw ();
 				if (parent != null)
 					parent.Thaw ();
 			}
 		}
 		
-		public virtual bool DockRequest (int x, int y, DockRequest request)
+		public virtual bool OnDockRequest (int x, int y, DockRequest request)
 		{
 			return false;
 		}
 		
-		public virtual void Docking (DockObject requestor, DockPlacement position, object other_data)
+		public virtual void OnDocked (DockObject requestor, DockPlacement position, object data)
 		{
-			DockObject parent;
-			if (requestor == null)
+		}
+		
+		public virtual bool OnReorder (DockObject child, DockPlacement new_position, object data)
+		{
+			return false;
+		}
+		
+		public virtual void OnPresent (DockObject child)
+		{
+			Show ();			
+		}
+		
+		public virtual bool OnChildPlacement (DockObject child, ref DockPlacement placement)
+		{
+			return false;
+		}
+		
+		public bool ChildPlacement (DockObject child, ref DockPlacement placement)
+		{
+			if (!IsCompound)
+				return false;
+			
+			return OnChildPlacement (child, ref placement);
+		}
+		
+		public void Detach (bool recursive)
+		{
+			if (!IsAttached)
 				return;
 				
-			if (requestor == this)
+			/* freeze the object to avoid reducing while detaching children */
+			Freeze ();
+			
+			DockObjectFlags |= DockObjectFlags.InDetach;
+			OnDetached (recursive);
+			if (Detached != null) {
+				DetachedArgs args = new DetachedArgs (recursive);
+				Detached (this, args);
+			}
+			DockObjectFlags &amp;= ~(DockObjectFlags.InDetach);
+
+			Thaw ();		
+		}
+		
+		public void Dock (DockObject requestor, DockPlacement position, object data)
+		{
+			if (requestor == null || requestor == this)
 				return;
-			
+				
 			if (master == null) {
-				Console.WriteLine (&quot;Dock operation requested in a non-bound object.&quot;);
+				Console.WriteLine (&quot;Dock operation requested in a non-bound object {}.&quot;, this);
 				Console.WriteLine (&quot;This might break.&quot;);
 			}
+
 			if (!requestor.IsBound)
-				requestor.Bind (master);
-			if (requestor.Master != master) {
-				Console.WriteLine (&quot;Cannot complete dock as they belong to different masters.&quot;);
+				requestor.Bind (Master);
+
+			if (requestor.Master != Master) {
+				Console.WriteLine (&quot;Cannot dock {0} to {1} as they belong to different masters.&quot;,
+						   requestor, this);
 				return;
 			}
-			//Attempt to optimize the placement with reordering (heh)
+
+			/* first, see if we can optimize things by reordering */
 			if (position != DockPlacement.None) {
-				if (Reorder (requestor, position, other_data) || (ParentObject != null &amp;&amp; ParentObject.Reorder (requestor, position, other_data)))
+				DockObject parent = ParentObject;
+				if (OnReorder (requestor, position, data) ||
+				    (parent != null &amp;&amp; parent.OnReorder (requestor, position, data)))
 					return;
 			}
+
+			/* freeze the object, since under some conditions it might
+			   be destroyed when detaching the requestor */
 			Freeze ();
+
+			/* detach the requestor before docking */
 			if (requestor.IsAttached)
 				requestor.Detach (false);
+
+			/* notify interested parties that an object has been docked. */
 			if (position != DockPlacement.None) {
-				/*FIXME: port this code: 
-				g_signal_emit (object, gdl_dock_object_signals [DOCK], 0,
-				requestor, position, other_data);
-				*/
+				OnDocked (requestor, position, data);
+				if (Docked != null) {
+					DockedArgs args = new DockedArgs (requestor, position);
+					Docked (this, args);
+				}
 			}
+			
 			Thaw ();
 		}
 		
-		public virtual bool Reorder (DockObject child, DockPlacement new_position, object other_data)
+		public void Present (DockObject child)
 		{
-			return false;
+			if (ParentObject != null)
+				/* chain the call to our parent */
+				ParentObject.Present (this);
+			
+			OnPresent (child);
 		}
-		
-		public virtual void Present (DockObject child)
+
+		public void Reduce ()
 		{
-			Show ();
-		}
-		
-		public virtual bool ChildPlacement (DockObject child, ref DockPlacement placement)
-		{
-			return false;
-		}
-		
-		public virtual bool IsCompound {
-			get {
-				return true;
+			if (IsFrozen) {
+				reducePending = true;
+				return;
 			}
+
+			OnReduce ();		
 		}
-		
-		public DockObject ParentObject {
-			get {
-				Widget parent = Parent;
-				while (parent != null &amp;&amp; !(parent is DockObject)) {
-					parent = parent.Parent;
-				}
-				return parent != null ? (DockObject)parent : null;
-			}
-		}
-		
-		public bool IsAttached {
-			get {
-				return ((flags &amp; DockObjectFlags.Attached) != 0);
-			}
-		}
-		
-		public bool IsAutomatic {
-			get {
-				return ((flags &amp; DockObjectFlags.Automatic) != 0);
-			}
-		}
-		
-		public bool InReflow {
-			get {
-				return ((flags &amp; DockObjectFlags.InReflow) != 0);
-			}
-		}
-		
+
 		public void Freeze ()
 		{
-			freeze_count++;
+			freezeCount++;
 		}
 		
 		public void Thaw ()
 		{
-			freeze_count--;
-			if (freeze_count == 0 &amp;&amp; reduce_pending) {
-				reduce_pending = false;
+			if (freezeCount &lt; 0) {
+				Console.WriteLine (&quot;DockObject.Thaw: freezeCount &lt; 0&quot;);
+				return;
+			}
+
+			freezeCount--;
+
+			if (freezeCount == 0 &amp;&amp; reducePending) {
+				reducePending = false;
 				Reduce ();
 			}
 		}
 		
-		public void Bind (DockMaster _master)
+		public void Bind (DockMaster master)
 		{
-			Console.WriteLine (&quot;About to attempt a bind&quot;);
-			if (_master == null) {
-				Console.WriteLine (&quot;passed master is null&quot;);
+			if (master == null) {
+				Console.WriteLine (&quot;Passed master is null&quot;);
 				return;
 			}
-			if (master == _master) {
-				Console.WriteLine (&quot;passed master is this master&quot;);
+			if (this.master == master) {
+				Console.WriteLine (&quot;Passed master is this master&quot;);
 				return;
 			}
-			if (master != null) {
+			if (this.master != null) {
 				Console.WriteLine (&quot;Attempt to bind an already bound object&quot;);
 				return;
 			}
-			_master.Add (this);
-			master = _master;
+			
+			master.Add (this);
+			this.master = master;
 			//g_object_notify (G_OBJECT (object) /*this*/, &quot;master&quot;);
 		}
 		
@@ -239,6 +345,7 @@
 		{
 			if (IsAttached)
 				Detach (true);
+
 			if (master != null) {
 				DockMaster _master = master;
 				master = null;
@@ -246,16 +353,5 @@
 				//g_object_notify (G_OBJECT (object) /*this*/, &quot;master&quot;);
 			}
 		}
-		
-		public bool IsBound {
-			get {
-				return master != null;
-			}
-		}
-		
-		public DockObjectFlags DockObjectFlags {
-			get { return flags; }
-			set { flags = value; }
-		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/Gdl/DockPaned.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockPaned.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockPaned.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -7,7 +7,7 @@
 {
 	public class DockPaned : DockItem
 	{
-		private bool position_changed = false;
+		private bool positionChanged = false;
 
 		public DockPaned (Orientation orientation)
 		{
@@ -15,11 +15,15 @@
 		}
 		
 		public override bool HasGrip {
-			get { return false; }
+			get {
+				return false;
+			}
 		}
 		
 		public override bool IsCompound {
-			get { return true; }
+			get {
+				return true;
+			}
 		}
 		
 		public int Position {
@@ -41,34 +45,38 @@
 			if (Child != null)
 				Child.Unparent ();
 				
+			/* create the container paned */
 			if (orientation == Orientation.Horizontal)
 				Child = new HPaned ();
 			else
 				Child = new VPaned ();
 			
-			//Signal connects?
+			// FIXME: Register signal handlers.						
+												
 			Child.Parent = this;
 			Child.Show ();
 		}
 		
 		protected override void OnAdded (Widget widget)
 		{
-			if (widget == null)
+			if (Child == null)
 				return;
-			Gtk.Paned paned = (Gtk.Paned)this.Child;
-			if (paned.Child1 != null &amp;&amp; paned.Child2 != null) {
+		
+			Paned paned = Child as Paned;
+			if (paned.Child1 != null &amp;&amp; paned.Child2 != null)
 				return;
-			}
 			
 			DockItem item = widget as DockItem;
 			DockPlacement pos = DockPlacement.None;			
 			if (paned.Child1 == null)
-				pos = (this.Orientation == Gtk.Orientation.Horizontal ? DockPlacement.Left : DockPlacement.Top);
+				pos = (Orientation == Orientation.Horizontal ?
+				       DockPlacement.Left : DockPlacement.Top);
 			else
-				pos = (this.Orientation == Gtk.Orientation.Horizontal ? DockPlacement.Right : DockPlacement.Bottom);
+				pos = (Orientation == Orientation.Horizontal ?
+				       DockPlacement.Right : DockPlacement.Bottom);
 			
 			if (pos != DockPlacement.None)
-				Docking (item, pos, null);
+				Dock (item, pos, null);
 		}
 		
 		private void childForAll (Widget widget)
@@ -89,42 +97,39 @@
 			}
 		}
 		
-		public override void Docking (DockObject requestor, DockPlacement position, object other_data)
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
 		{
 			if (Child == null)
 				return;
+		
 			Paned paned = (Paned)Child;
-			bool hresize = false;
-			bool wresize = false;
 			bool done = false;
 			
-			if (requestor is DockItem) {
-				hresize = ((DockItem)requestor).PreferredHeight == -2 ? true : false;
-				wresize = ((DockItem)requestor).PreferredWidth == -2 ? true : false;
-			}
-			
+			/* see if we can dock the item in our paned */
 			switch (Orientation) {
 			case Orientation.Horizontal:
 				if (paned.Child1 == null &amp;&amp; position == DockPlacement.Left) {
-					paned.Pack1 (requestor, wresize, false);
+					paned.Pack1 (requestor, false, false);
 					done = true;
 				} else if (paned.Child2 == null &amp;&amp; position == DockPlacement.Right) {
-					paned.Pack2 (requestor, wresize, false);
+					paned.Pack2 (requestor, true, false);
 					done = true;
 				}
 				break;
 			case Orientation.Vertical:
 				if (paned.Child1 == null &amp;&amp; position == DockPlacement.Top) {
-					paned.Pack1 (requestor, hresize, false);
+					paned.Pack1 (requestor, false, false);
 					done = true;
 				} else if (paned.Child2 == null &amp;&amp; position == DockPlacement.Bottom) {
-					paned.Pack2 (requestor, hresize, false);
+					paned.Pack2 (requestor, true, false);
 					done = true;
 				}
 				break;
 			}
+			
 			if (!done) {
-				base.Docking (requestor, position, other_data);
+				/* this will create another paned and reparent us there */
+				base.OnDocked (requestor, position, data);
 			} else {
 				((DockItem)requestor).ShowGrip ();
 				requestor.DockObjectFlags |= DockObjectFlags.Attached;

Modified: trunk/MonoDevelop/src/Libraries/Gdl/DockPlaceholder.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockPlaceholder.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockPlaceholder.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -16,16 +16,16 @@
 		
 		public DockPlaceholder ()
 		{
-			this.Flags |= (int)Gtk.WidgetFlags.NoWindow;
-			this.Flags &amp;= ~((int)Gtk.WidgetFlags.CanFocus);
+			Flags |= (int)WidgetFlags.NoWindow;
+			Flags &amp;= ~((int)WidgetFlags.CanFocus);
 		}
 		
 		public DockPlaceholder (string name, DockObject objekt, DockPlacement position, bool sticky) : this ()
 		{
-			this.Sticky = sticky;
-			this.Name = name;
+			Sticky = sticky;
+			Name = name;
 			if (objekt != null) {
-				this.Attach (objekt);
+				Attach (objekt);
 				if (position == DockPlacement.None) {
 					position = DockPlacement.Center;
 				}
@@ -48,71 +48,71 @@
 		
 		public DockObject Host {
 			get { return host; }
-			set { this.Attach (value); }
+			set { Attach (value); }
 		}
 		
 		public DockPlacement NextPlacement {
 			get {
-				if (this.placement_stack != null &amp;&amp; this.placement_stack.Count != 0)
-					return (DockPlacement)this.placement_stack[0];
+				if (placement_stack != null &amp;&amp; placement_stack.Count != 0)
+					return (DockPlacement)placement_stack[0];
 				return DockPlacement.Center;
 			}
 			set { 
 				if (placement_stack == null)
 					placement_stack = new ArrayList ();
-				this.placement_stack.Insert (0, value);
+				placement_stack.Insert (0, value);
 			}
 		}
 		
-		protected override void OnAdded (Gtk.Widget widget)
+		protected override void OnAdded (Widget widget)
 		{
 			if (!(widget is DockItem))
 				return;
-			this.Docking ((DockItem)widget, this.NextPlacement, null);
+			Dock ((DockItem)widget, NextPlacement, null);
 		}
 		
-		public override void Detach (bool recursive)
+		public override void OnDetached (bool recursive)
 		{
-			this.DisconnectHost ();
-			this.placement_stack = null;
-			this.DockObjectFlags &amp;= ~(DockObjectFlags.Attached);
+			DisconnectHost ();
+			placement_stack = null;
+			DockObjectFlags &amp;= ~(DockObjectFlags.Attached);
 		}
 		
-		public override void Reduce ()
+		public override void OnReduce ()
 		{
 		}
 		
-		public override void Docking (DockObject requestor, DockPlacement position, object other_data)
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
 		{
-			if (this.host != null) {
-				this.host.Docking (requestor, position, other_data);
+			if (host != null) {
+				host.Dock (requestor, position, data);
 			} else {
-				if (!this.IsBound) {
+				if (!IsBound) {
 					Console.WriteLine (&quot;Attempt to dock a dock object to an unbound placeholder&quot;);
 					return;
 				}
-				this.Master.Controller.Docking (requestor, DockPlacement.Floating, null);
+				Master.Controller.Dock (requestor, DockPlacement.Floating, null);
 			}
 		}
 		
-		public override void Present (DockObject child)
+		public override void OnPresent (DockObject child)
 		{
 		}
 		
 		public void DoExcursion ()
 		{
-			if (this.host != null &amp;&amp; !this.Sticky &amp;&amp; this.placement_stack != null &amp;&amp; this.host.IsCompound) {
+			if (host != null &amp;&amp; !Sticky &amp;&amp; placement_stack != null &amp;&amp; host.IsCompound) {
 				DockPlacement pos;
-				DockPlacement stack_pos = this.NextPlacement;
-				foreach (Gtk.Widget child in this.host.Children) {
+				DockPlacement stack_pos = NextPlacement;
+				foreach (Widget child in host.Children) {
 					DockObject item = child as DockObject;
 					if (item == null)
 						continue;
 					pos = stack_pos;
 					
-					this.host.ChildPlacement (item, ref pos);
+					host.ChildPlacement (item, ref pos);
 					if (pos == stack_pos) {
-						this.placement_stack.RemoveAt (0);
+						placement_stack.RemoveAt (0);
 						DisconnectHost ();
 						ConnectHost (item);
 						
@@ -127,14 +127,14 @@
 		private void DisconnectHost ()
 		{
 			//Disconnect from host detach and dock events here.
-			this.host = null;
+			host = null;
 		}
 		
 		private void ConnectHost (DockObject new_host)
 		{
-			if (this.host != null)
+			if (host != null)
 				DisconnectHost ();
-			this.host = new_host;
+			host = new_host;
 			//Connect to host detach and dock events here.
 		}
 		
@@ -143,21 +143,21 @@
 			if (objekt == null)
 				return;
 			
-			if (!this.IsBound)
-				this.Bind(objekt.Master);
+			if (!IsBound)
+				Bind(objekt.Master);
 			
-			if (objekt.Master != this.Master)
+			if (objekt.Master != Master)
 				return;
 			
-			this.Freeze ();
+			Freeze ();
 			
-			if (this.host != null)
-				this.Detach (false);
+			if (host != null)
+				Detach (false);
 			
 			ConnectHost (objekt);
 			
-			this.DockObjectFlags |= DockObjectFlags.Attached;
-			this.Thaw ();
+			DockObjectFlags |= DockObjectFlags.Attached;
+			Thaw ();
 		}
 	}
 }

Added: trunk/MonoDevelop/src/Libraries/Gdl/DockedHandler.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockedHandler.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockedHandler.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -0,0 +1,29 @@
+using System;
+
+namespace Gdl
+{
+	public delegate void DockedHandler (object o, DockedArgs args);
+	
+	public class DockedArgs : EventArgs {
+		private DockObject requestor;
+		private DockPlacement position;
+	
+		public DockedArgs (DockObject requestor, DockPlacement position)
+		{
+			this.requestor = requestor;
+			this.position = position;
+		}
+	
+		public DockObject Requestor {
+			get {
+				return requestor;
+			}
+		}
+		
+		public DockPlacement Position {
+			get {
+				return position;
+			}
+		}
+	}
+}

Modified: trunk/MonoDevelop/src/Libraries/Gdl/GdlDockTest.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/GdlDockTest.cs	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/GdlDockTest.cs	2004-06-12 14:34:03 UTC (rev 1743)
@@ -1,14 +1,9 @@
 using System;
 using Gtk;
-using GtkSharp;
-using Gnome;
-using GnomeSharp;
 using Gdl;
 
 class T
 {
-	Program program;
-	
 	static void Main (string[] args)
 	{
 		new T (args);
@@ -16,42 +11,65 @@
 	
 	T (string[] args)
 	{
-		//program = new Program (&quot;test&quot;, &quot;0.0&quot;, Modules.UI, args);
-		//App app = new App (&quot;test&quot;, &quot;Test for Gdl.Dock widget&quot;);
-		Gtk.Application.Init ();
-		Gtk.Window app = new Gtk.Window (&quot;test&quot;);
-		app.SetDefaultSize (600, 450);
+		Application.Init ();
+		Window app = new Window (&quot;test&quot;);
+		app.SetDefaultSize (400, 400);
 		app.DeleteEvent += new DeleteEventHandler (OnAppDelete);
 		
 		Dock dock = new Dock ();
 		//DockLayout layout = new DockLayout (dock);
 		
-		DockItem di = new DockItem (&quot;item1&quot;, &quot;Item #1&quot;, Gtk.Stock.Execute, DockItemBehavior.Normal);
-		di.Add (new Button (&quot;test&quot;));
-		dock.AddItem (di, DockPlacement.Center);
+		DockItem di = new DockItem (&quot;item1&quot;, &quot;Item #1&quot;, DockItemBehavior.Locked);
+		di.Add (CreateTextView ());
+		dock.AddItem (di, DockPlacement.Top);
 		
-		DockItem di2 = new DockItem (&quot;item2&quot;, &quot;Item #2&quot;, DockItemBehavior.Normal);
-		di2.Add (new Label (&quot;test2&quot;));
-		dock.AddItem (di2, DockPlacement.Center);
+		DockItem di2 = new DockItem (&quot;item2&quot;, &quot;Item #2 has some large title&quot;,
+					     Gtk.Stock.Execute, DockItemBehavior.Normal);
+		di2.Add (new Button (&quot;Button 2&quot;));
+		dock.AddItem (di2, DockPlacement.Right);
 		
-		/*DockItem di3 = new DockItem (&quot;item3&quot;, &quot;Item #3&quot;, DockItemBehavior.Normal);
-		di3.Add (new Label (&quot;test3&quot;));
-		dock.AddItem (di3, DockPlacement.Top);
+		DockItem di3 = new DockItem (&quot;item3&quot;, &quot;Item #3 has accented characters&quot;,/* (&#225;&#233;&#237;&#243;&#250;&#241;)&quot;,*/
+					     Gtk.Stock.Convert, DockItemBehavior.Normal |
+					     DockItemBehavior.CantClose);
+		di3.Add (CreateTextView ());
+		dock.AddItem (di3, DockPlacement.Bottom);
 		
-		/*DockItem di4 = new DockItem (&quot;item4&quot;, &quot;Item #4&quot;, DockItemBehavior.Normal);
-		di4.Add (new Label (&quot;test4&quot;));
-		dock.AddItem (di4, DockPlacement.Center);*/
+		DockItem[] items = new DockItem[4];
+		items[0] = new DockItem (&quot;item4&quot;, &quot;Item #4&quot;, Gtk.Stock.JustifyFill,
+					 DockItemBehavior.Normal | DockItemBehavior.CantIconify);
+		items[0].Add (CreateTextView ());
+		dock.AddItem (items[0], DockPlacement.Bottom);
 		
+		for (int i = 1; i &lt; 3; i++) {
+			string name = &quot;Item #&quot; + (i + 4);
+			items[i] = new DockItem (name, name, Gtk.Stock.New,
+						 DockItemBehavior.Normal);
+			items[i].Add (CreateTextView ());
+			items[i].Show ();
+
+	    		items[0].Dock (items[i], DockPlacement.Center, null);	    
+		}
+
 		app.Add (dock);
 		app.ShowAll ();
-		//if (dock.Root == null) {
-		//	Console.WriteLine (&quot;Crap, dock.root is null&quot;);
-		//}
-		Gtk.Application.Run ();
+		Application.Run ();
 	}
 	
+	private Widget CreateTextView ()
+	{
+		ScrolledWindow sw = new ScrolledWindow (null, null);
+		sw.ShadowType = ShadowType.In;
+		sw.HscrollbarPolicy = PolicyType.Automatic;
+		sw.VscrollbarPolicy = PolicyType.Automatic;
+		TextView tv = new TextView ();
+		sw.Add (tv);
+		sw.ShowAll ();
+
+		return sw;
+	}
+	
 	private void OnAppDelete (object o, DeleteEventArgs args)
 	{
-		Gtk.Application.Quit ();
+		Application.Quit ();
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/Gdl/Makefile.Gdl
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/Makefile.Gdl	2004-06-11 19:37:56 UTC (rev 1742)
+++ trunk/MonoDevelop/src/Libraries/Gdl/Makefile.Gdl	2004-06-12 14:34:03 UTC (rev 1743)
@@ -16,7 +16,9 @@
 ./DockItemGrip.cs \
 ./DockPlaceholder.cs \
 ./DockPaned.cs \
-./DockNotebook.cs
+./DockNotebook.cs \
+./DockedHandler.cs \
+./DetachedHandler.cs
 
 PKG_REFERENCES = \
 gtk-sharp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001349.html">[Monodevelop-patches-list] r1742 - trunk/MonoDevelop
</A></li>
	<LI>Next message: <A HREF="001351.html">[Monodevelop-patches-list] r1744 - trunk/MonoDevelop/src/Libraries/Gdl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1350">[ date ]</a>
              <a href="thread.html#1350">[ thread ]</a>
              <a href="subject.html#1350">[ subject ]</a>
              <a href="author.html#1350">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
