<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1699 - trunk/MonoDevelop/src/Libraries/Gdl
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1699%20-%20trunk/MonoDevelop/src/Libraries/Gdl&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001305.html">
   <LINK REL="Next"  HREF="001307.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1699 - trunk/MonoDevelop/src/Libraries/Gdl</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1699%20-%20trunk/MonoDevelop/src/Libraries/Gdl&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1699 - trunk/MonoDevelop/src/Libraries/Gdl">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sun Jun  6 19:01:28 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001305.html">[Monodevelop-patches-list] r1698 - in trunk/MonoDevelop/src/Libraries/MonoDevelop.Gui.Widgets: . TabLabel
</A></li>
        <LI>Next message: <A HREF="001307.html">[Monodevelop-patches-list] r1700 - trunk/MonoDevelop/src/Libraries/Gdl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1306">[ date ]</a>
              <a href="thread.html#1306">[ thread ]</a>
              <a href="subject.html#1306">[ subject ]</a>
              <a href="author.html#1306">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tberman
Date: 2004-06-06 19:01:28 -0400 (Sun, 06 Jun 2004)
New Revision: 1699

Modified:
   trunk/MonoDevelop/src/Libraries/Gdl/Dock.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockMaster.cs
   trunk/MonoDevelop/src/Libraries/Gdl/DockRequest.cs
   trunk/MonoDevelop/src/Libraries/Gdl/Gdl.prjx
Log:
testing anon mirror sync... this will work *even* less for people attempting to compile.


Modified: trunk/MonoDevelop/src/Libraries/Gdl/Dock.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/Dock.cs	2004-06-06 21:04:45 UTC (rev 1698)
+++ trunk/MonoDevelop/src/Libraries/Gdl/Dock.cs	2004-06-06 23:01:28 UTC (rev 1699)
@@ -1,12 +1,25 @@
 // created on 05/06/2004 at 11:21 A
 
 using System;
+using System.Collections;
 using Gtk;
 
 namespace Gdl
 {
 	public class Dock : DockObject
 	{
+	
+		public Dock ()
+		{
+			this.DockObjectFlags &amp;= ~(DockObjectFlags.Automatic);
+		}
+		
+		public Dock (Dock original, bool _floating) : this ()
+		{
+			this.Master = original.Master;
+			this.floating = _floating;
+		}
+		
 		private DockObject root = null;
 		private bool floating;
 		private Widget window;
@@ -16,6 +29,11 @@
 		private int width = -1;
 		private int height = -1;
 		private Gdk.GC xor_gc;
+
+		public DockObject Root {
+			get { return root; }
+			set { root = value; }
+		}
 		
 		public bool Floating {
 			get { return floating; }
@@ -257,10 +275,159 @@
 			return may_dock;
 		}
 		
-		private void AddItem (DockItem item, DockPlacement placement)
+		public override void Dock (DockObject requestor, DockPlacement position, object user_data)
 		{
+			if (!(requestor is DockItem))
+				return;
+			if (position == DockPlacement.Floating) {
+				DockItem item = requestor as DockItem;
+				int x, y, width, height;
+				if (user_data != null &amp;&amp; user_data is Gdk.Rectangle) {
+					Gdk.Rectangle rect = user_data as Gdk.Rectangle;
+					x = rect.X;
+					y = rect.Y;
+					width = rect.Width;
+					height = rect.Height;
+				} else {
+					x = y = 0;
+					width = height = -1;
+				}
+				AddFloatingItem (item, x, y, width, height);
+			} else if (this.root != null) {
+				this.root.Dock (requestor, position, null);
+				//gdl_dock_set_title (dock /*this*/);
+			} else {
+				this.root = requestor;
+				this.root.DockObjectFlags &amp;= DockObjectFlags.Attached;
+				this.root.Parent = this;
+				((DockItem)this.root).ShowGrip ();
+				if (this.IsRealized)
+					this.root.Realize ();
+				if (this.Visible &amp;&amp; this.root.Visible) {
+					if (this.IsMapped)
+						this.root.Map ();
+					this.root.QueueResize ();
+				}
+				//gdl_dock_set_title (dock /*this*/);
+			}
 		}
 		
+		public override bool Reorder (DockObject requestor, DockPlacement new_position, object other_data)
+		{
+			bool handled = false;
+			if (this.floating &amp;&amp; new_position == DockPlacement.Floating &amp;&amp; this.root == requestor) {
+				if (other_data != null &amp;&amp; other_data is Gdk.Rectangle) {
+					Gdk.Rectangle rect = other_data as Gdk.Rectangle;
+					if (this.window != null &amp;&amp; this.window is Gtk.Window) {
+						((Gtk.Window)this.window).Move (rect.X, rect.Y);
+						handled = true;
+					}
+				}
+			}
+			return handled;
+		}
+		
+		public override bool ChildPlacement (DockObject child, DockPlacement placement)
+		{
+			bool retval = true;
+			if (this.root == child) {
+				if (placement == DockPlacement.None || placement == DockPlacement.Floating)
+					placement = DockPlacement.Top;
+			} else
+				retval = false;
+				
+			return retval;
+		}
+		
+		public override void Present (DockObject child)
+		{
+			if (this.floating &amp;&amp; this.window != null &amp;&amp; this.window is Gtk.Window)
+				((Gtk.Window)this.window).Present ();
+		}
+		
+		public void AddItem (DockItem item, DockPlacement placement)
+		{
+			if (item == null)
+				return;
+			if (placement == DockPlacement.Floating)
+				AddFloatingItem (item, 0, 0, -1, -1);
+			else
+				this.Dock (item, null);
+		}
+		
+		public void AddFloatingItem (DockItem item, int x, int y, int width, int height)
+		{
+			Gdl.Dock new_dock = new Dock (this, true);
+			new_dock.Width = width;
+			new_dock.Height = height;
+			new_dock.FloatX = x;
+			new_dock.FloatY = y;
+			if (this.Visible) {
+				new_dock.Show ();
+				if (this.IsMapped)
+					new_dock.Map ();
+				new_dock.QueueResize ();
+			}
+			new_dock.AddItem (item, DockPlacement.Top);
+		}
+		
+		public DockItem GetItemByName (string name)
+		{
+			if (name == null)
+				return null;
+			DockObject found = DockMaster.GetObject (name);
+			if (found != null &amp;&amp; found is DockItem)
+				return found;
+			return null;
+		}
+		
+		public DockPlaceholder GetPlaceholderByName (string name)
+		{
+			if (name == null)
+				return null;
+			DockObject found = DockMaster.GetObject (name);
+			if (found != null &amp;&amp; found is DockPlaceholder)
+				return found;
+			return null;
+		}
+		
+		public ArrayList NamedItems {
+			get {
+				/*PORT THIS:
+				
+    gdl_dock_master_foreach (GDL_DOCK_OBJECT_GET_MASTER (dock),
+                             (GFunc) _gdl_dock_foreach_build_list, &amp;list);
+                             */
+			}
+		}
+		
+		public static Dock GetTopLevel (DockObject obj)
+		{
+			DockObject parent = obj;
+			while (parent != null &amp;&amp; !(parent is Gdl.Dock))
+				parent = parent.ParentObject;
+			return parent;
+		}
+		
+		public void XorRect (Gdk.Rectangle rect)
+		{
+			if (this.xor_gc == null) {
+				if (this.IsRealized) {
+					Gdk.GCValues values = new Gdk.GCValues ();
+					values.Function = Gdk.Function.Invert;
+					values.SubwindowMode = Gdk.SubwindowMode.IncludeInferiors;
+					this.xor_gc = new Gdk.GC (this.GdkWindow);
+					this.xor_gc.SetValues (values, Gdk.GCValuesMask.Function | Gdk.GCValuesMask.Subwindow);
+				} else
+					return;
+			}
+			xor_gc.SetLineAttributes (1, Gdk.LineStyle.OnOffDash, Gdk.CapStyle.NotLast, Gdk.JoinStyle.Bevel);
+			xor_gc.SetDashes (1, new sbyte[] { 1, 1}, 2);
+			this.GdkWindow.DrawRectangle (xor_gc, false, rect.X, rect.Y, rect.Width, rect.Height);
+			xor_gc.SetDashes (0, new sbyte[] { 1, 1}, 2);
+			this.GdkWindow.DrawRectangle (xor_gc, false, rect.X + 1, rect.Y + 1, rect.Width - 2, rect.Height - 2);
+		}
+		
 		private bool IsController {
 			get {
 				return (this.Master.Controller == this); 

Modified: trunk/MonoDevelop/src/Libraries/Gdl/DockMaster.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockMaster.cs	2004-06-06 21:04:45 UTC (rev 1698)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockMaster.cs	2004-06-06 23:01:28 UTC (rev 1699)
@@ -9,19 +9,133 @@
 	public class DockMaster
 	{
 		private object obj;
-		private Hashtable dock_objects;
-		private ArrayList toplevel_docks;
-		private DockObject controller;
-		private int dock_number;
-		private int number;
+		private Hashtable dock_objects = new Hashtable ();
+		private ArrayList toplevel_docks = null;
+		private DockObject controller = null;
+		private int dock_number = 1;
+		private int number = 1;
 		private string default_title;
 		private Gdk.GC root_xor_gc;
 		private bool rect_drawn;
 		private Dock rect_owner;
 		private DockRequest drag_request;
 		private uint idle_layout_changed_id;
-		private Hashtable locked_items;
-		private Hashtable unlocked_items;
+		private Hashtable locked_items = new Hashtable ();
+		private Hashtable unlocked_items = new Hashtable ();
 		
+		public string DefaultTitle {
+			get { return default_title; }
+			set { default_title = value; }
+		}
+		
+		public int Locked {
+			get {
+				if (unlocked_items.Count == 0)
+					return 1;
+				if (locked_items.Count == 0)
+					return 0;
+				return -1;
+			}
+			set {
+				if (int &gt;= 0)
+					this.LockUnlock (value &gt; 0);
+			}
+		}
+		
+		protected void foreach_lock_unlock (DockItem item, bool locked)
+		{
+			item.Locked = locked;
+			if (item.IsCompound) {
+				/*PORT THIS: Container.Foreach doesnt take the arg i need it to take.
+				        gtk_container_foreach (GTK_CONTAINER (item),
+                               (GtkCallback) foreach_lock_unlock,
+                               (gpointer) locked);*/
+			}
+		}
+		
+		public void LockUnlock (bool locked)
+		{
+			foreach (Gdl.Dock dock in toplevel_docks) {
+				if (dock.Root != null &amp;&amp; dock.Root is DockItem)
+					foreach_lock_unlock ((DockItem)dock.Root, locked);
+			}
+			/*PORT THIS:
+			    // just to be sure hidden items are set too
+    gdl_dock_master_foreach (master,
+                             (GFunc) foreach_lock_unlock,
+                             (gpointer) locked);*/
+		}
+		
+		
+		public void DragBegin (DockItem item)
+		{
+			if (item == null)
+				return;
+			if (this.drag_request == null)
+				this.drag_request = new DockRequest ();
+			DockRequest request = this.drag_request;
+			request.Applicant = item;
+			request.Target = item;
+			request.Position = DockPlacement.Floating;
+			request.Extra = null;
+			this.rect_drawn = false;
+			this.rect_owner = null;
+		}
+		
+		public void DragEnd (DockItem item, bool cancelled)
+		{
+			if (item == null)
+				return;
+			DockRequest request = this.drag_request;
+			if (item != request.Applicant)
+				return;
+			if (this.rect_drawn)
+				XorRect ();
+			if (cancelled || request.Applicant == request.Target)
+				return;
+			request.Target.Dock (request.Applicant, request.Position, request.Extra);
+			//emit LayoutChanged here
+		}
+		
+		public void DragMotion (DockItem item, int root_x, int root_y)
+		{
+			if (item == null)
+				return;
+			DockRequest request = this.drag_request;
+			if (request.Applicant == item)
+				return;
+			DockRequest my_request = new DockRequest (request);
+			int win_x, win_y;
+			int x, y;
+			Dock dock = null;
+			bool may_dock;
+			
+			Gdk.Window window = Gdk.Window.AtPointer (out win_x, out win_y);
+			if (window != null) {
+				IntPtr widg = window.GetUserData ();
+				if (widg != null) {
+					Gtk.Widget widget = GLib.Object.GetObject (widg, false) as Gtk.Widget;
+					if (widget != null) {
+						while (widget != null &amp;&amp; (!(widget is Dock) || (widget is DockObject &amp;&amp; ((DockObject)widget).Master == this)))
+							widget = widget.Parent;
+						if (widget != null) {
+							int win_w, win_h, winx, winy, depth;
+							widget.GdkWindow.GetGeometry (out winx, out winy, out win_w, out win_h, out depth);
+							widget.GdkWindow.GetOrigin (out win_x, out win_y);
+							if (root_x &gt;= win_x &amp;&amp; root_x &lt; win_x + win_w &amp;&amp; root_y &gt;= win_y &amp;&amp; root_y &lt; win_y + win_h)
+								dock = widget as Dock;
+						}
+					}
+				}
+			}
+			
+			if (dock != null) {
+				dock.GdkWindow.GetOrigin (out win_x, out win_y);
+				x = root_x - win_x;
+				y = root_y - win_y;
+				may_dock = dock.DockRequest (x, y, my_request);
+			} else {
+				foreach (Dock top_dock in toplevel_docks)
+		}
 	}
 }
\ No newline at end of file

Modified: trunk/MonoDevelop/src/Libraries/Gdl/DockRequest.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/DockRequest.cs	2004-06-06 21:04:45 UTC (rev 1698)
+++ trunk/MonoDevelop/src/Libraries/Gdl/DockRequest.cs	2004-06-06 23:01:28 UTC (rev 1699)
@@ -14,6 +14,15 @@
 		private Rectangle rect;
 		private object extra;
 		
+		public DockRequest (DockRequest copy)
+		{
+			this.applicant = copy.Applicant;
+			this.target = copy.Target;
+			this.position = copy.Position;
+			this.rect = copy.Rect;
+			this.extra = copy.Extra;
+		}
+		
 		public DockObject Applicant {
 			get { return applicant; }
 			set { applicant = value; }

Modified: trunk/MonoDevelop/src/Libraries/Gdl/Gdl.prjx
===================================================================
--- trunk/MonoDevelop/src/Libraries/Gdl/Gdl.prjx	2004-06-06 21:04:45 UTC (rev 1698)
+++ trunk/MonoDevelop/src/Libraries/Gdl/Gdl.prjx	2004-06-06 23:01:28 UTC (rev 1699)
@@ -15,6 +15,7 @@
   &lt;References&gt;
     &lt;Reference type=&quot;Gac&quot; refto=&quot;gtk-sharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
     &lt;Reference type=&quot;Gac&quot; refto=&quot;gdk-sharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;glib-sharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
   &lt;/References&gt;
   &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
   &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001305.html">[Monodevelop-patches-list] r1698 - in trunk/MonoDevelop/src/Libraries/MonoDevelop.Gui.Widgets: . TabLabel
</A></li>
	<LI>Next message: <A HREF="001307.html">[Monodevelop-patches-list] r1700 - trunk/MonoDevelop/src/Libraries/Gdl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1306">[ date ]</a>
              <a href="thread.html#1306">[ thread ]</a>
              <a href="subject.html#1306">[ subject ]</a>
              <a href="author.html#1306">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
