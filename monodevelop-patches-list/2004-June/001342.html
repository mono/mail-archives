<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1735 - in trunk/MonoDevelop/src/AddIns/Misc: . AssemblyAnalyser AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1735%20-%20in%20trunk/MonoDevelop/src/AddIns/Misc%3A%20.%20AssemblyAnalyser%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001341.html">
   <LINK REL="Next"  HREF="001343.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1735 - in trunk/MonoDevelop/src/AddIns/Misc: . AssemblyAnalyser AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1735%20-%20in%20trunk/MonoDevelop/src/AddIns/Misc%3A%20.%20AssemblyAnalyser%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui%20AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1735 - in trunk/MonoDevelop/src/AddIns/Misc: . AssemblyAnalyser AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Thu Jun 10 22:19:09 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001341.html">[Monodevelop-patches-list] r1734 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . Gui Search/DocumentIterator
</A></li>
        <LI>Next message: <A HREF="001343.html">[Monodevelop-patches-list] r1736 - in trunk/MonoDevelop/src/AddIns/Misc: . AddInManager AddInManager/Commands AddInManager/Gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1342">[ date ]</a>
              <a href="thread.html#1342">[ thread ]</a>
              <a href="subject.html#1342">[ subject ]</a>
              <a href="author.html#1342">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2004-06-10 22:19:09 -0400 (Thu, 10 Jun 2004)
New Revision: 1735

Added:
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/AssemblyAnalyser.key
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/AssemblyAnalyzer.cmbx
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/AssemblyAnalyser.addin.xml
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/AssemblyInfo.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Commands.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserControl.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserView.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyRuleViewControl.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyTreeControl.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultDetailsView.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultListControl.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/ICSharpCode.AssemblyAnalyser.Addin.prjx
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Makefile
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/AssemblyInfo.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/AssemblyAnalyser.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/Resolution.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/ICSharpCode.AssemblyAnalyser.prjx
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Makefile
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractReflectionRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyClsCompliantRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyStrongNameRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyVersionNumberRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AvoidNamespacesWithFewMembers.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventFirstParameterIsObjectRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventHandlersReturnVoidRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventsHaveTwoParametersRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/InterfaceNotEmptyRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesShouldBeInNamespacesRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IAssemblyRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IConstructorRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IEventRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IFieldRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMemberRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodBaseRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IModuleRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/INamespaceRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IParameterRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IPropertyRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IReflectionRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ITypeRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/AttributeSuffixIsAttributeRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/CheckCollectionSuffix.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EnumsHaveNoEnumSuffix.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventFirstParameterNameIsSender.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventSecondParameterNameIsE.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/FlagEnumerationsArePlural.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/InterfacesPrefixIsI.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersArePascalCased.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersDoNotContainUnderscores.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesArePascalCased.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesDoNotContainUnderscores.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParametersAreCamelCased.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/PermissionSuffixIsPermissionRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/StreamSuffixIsStreamRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesArePascalCased.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingUtilities.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/PriorityLevel.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ProtectionLevels.cs
   trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/TODO.txt
Log:
import beginnig of port of AssemblyAnalyzer
the AddIn Gui stuff needs to be ported, etc.


Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/AssemblyAnalyser.key
===================================================================
(Binary files differ)


Property changes on: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/AssemblyAnalyser.key
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/AssemblyAnalyzer.cmbx
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/AssemblyAnalyzer.cmbx	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/AssemblyAnalyzer.cmbx	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+&lt;Combine fileversion=&quot;1.0&quot; name=&quot;AssemblyAnalyser&quot; description=&quot;&quot;&gt;
+  &lt;StartMode startupentry=&quot;ICSharpCode.AssemblyAnalyser.AddIn&quot; single=&quot;True&quot;&gt;
+    &lt;Execute entry=&quot;ICSharpCode.AssemblyAnalyser.AddIn&quot; type=&quot;None&quot; /&gt;
+    &lt;Execute entry=&quot;ICSharpCode.AssemblyAnalyser&quot; type=&quot;None&quot; /&gt;
+  &lt;/StartMode&gt;
+  &lt;Entries&gt;
+    &lt;Entry filename=&quot;.\ICSharpCode.AssemblyAnalyzer.AddIn\ICSharpCode.AssemblyAnalyser.Addin.prjx&quot; /&gt;
+    &lt;Entry filename=&quot;.\ICSharpCode.AssemblyAnalyzer\ICSharpCode.AssemblyAnalyser.prjx&quot; /&gt;
+  &lt;/Entries&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration name=&quot;Release&quot;&gt;
+      &lt;Entry name=&quot;ICSharpCode.AssemblyAnalyser.AddIn&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+      &lt;Entry name=&quot;ICSharpCode.AssemblyAnalyser&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration name=&quot;Debug&quot;&gt;
+      &lt;Entry name=&quot;ICSharpCode.AssemblyAnalyser.AddIn&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+      &lt;Entry name=&quot;ICSharpCode.AssemblyAnalyser&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Combine&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/AssemblyInfo.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/AssemblyInfo.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/AssemblyInfo.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,37 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+
+[assembly: AssemblyTitle(&quot;MonoDevelop.AssemblyAnalyser&quot;)]
+[assembly: AssemblyDescription(&quot;Analyses the assembly for .NET coding standards&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.*&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+#if TEST
+[assembly: AssemblyKeyFile(&quot;&quot;)]
+#else
+[assembly: AssemblyKeyFile(&quot;&quot;)]
+//[assembly: AssemblyKeyFile(&quot;../src/AddIns/Misc/AssemblyAnalyser/AssemblyAnalyser.key&quot;)]
+#endif 

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/AssemblyAnalyser.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/AssemblyAnalyser.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/AssemblyAnalyser.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,213 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+using MonoDevelop.AssemblyAnalyser.Rules;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyAnalyser.	
+	/// &lt;/summary&gt;
+	public class AssemblyAnalyser : System.MarshalByRefObject
+	{
+		ArrayList assemblyRules    = new ArrayList();
+		ArrayList moduleRules      = new ArrayList();
+		ArrayList typeRules        = new ArrayList();
+		ArrayList namespaceRules   = new ArrayList();
+		ArrayList memberRules      = new ArrayList();
+		ArrayList methodBaseRules  = new ArrayList();
+		ArrayList constructorRules = new ArrayList();
+		ArrayList eventRules       = new ArrayList();
+		ArrayList fieldRules       = new ArrayList();
+		ArrayList methodRules      = new ArrayList();
+		ArrayList parameterRules   = new ArrayList();
+		ArrayList propertyRules    = new ArrayList();
+		
+		ArrayList resolutions      = new ArrayList();
+		
+		Hashtable namespaces       = new Hashtable();
+		
+		public ArrayList Resolutions {
+			get {
+				return resolutions;
+			}
+		}
+		
+		public AssemblyAnalyser()
+		{
+			
+			Type[] types = typeof(AssemblyAnalyser).Assembly.GetTypes();
+			foreach (Type type in types) {
+				if (!type.IsAbstract &amp;&amp; type.IsClass) {
+					if (type.GetInterface(typeof(IAssemblyRule).FullName) != null) {
+ 						assemblyRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IConstructorRule).FullName) != null) {
+						constructorRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IEventRule).FullName) != null) {
+						eventRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IFieldRule).FullName) != null) {
+						fieldRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IMemberRule).FullName) != null) {
+						memberRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IMethodBaseRule).FullName) != null) {
+						methodBaseRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IMethodRule).FullName) != null) {
+						methodRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IModuleRule).FullName) != null) {
+						moduleRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(INamespaceRule).FullName) != null) {
+						namespaceRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IParameterRule).FullName) != null) {
+						parameterRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(IPropertyRule).FullName) != null) {
+						propertyRules.Add(type.Assembly.CreateInstance(type.FullName));
+					} else if (type.GetInterface(typeof(ITypeRule).FullName) != null) {
+						typeRules.Add(type.Assembly.CreateInstance(type.FullName));
+					}
+				}
+			}
+		}
+		
+		void AddResolutions(Resolution resolution)
+		{
+			if (resolution != null) {
+				resolutions.Add(resolution);
+			}
+		}
+		
+		public void Analyse(string fileName)
+		{
+			Assembly assembly = null;
+			try {
+				assembly = Assembly.LoadFrom(fileName);
+			} catch (Exception e) {
+				resolutions.Add(new Resolution(new CustomRule(&quot;${res:MonoDevelop.AssemblyAnalyser.AssemblyCantBeLoaded.Description}&quot;,
+				                                              &quot;${res:MonoDevelop.AssemblyAnalyser.AssemblyCantBeLoaded.Details}&quot;, PriorityLevel.CriticalError, 100), 
+				                               &quot;${res:MonoDevelop.AssemblyAnalyser.AssemblyCantBeLoaded.Resolution}&quot;,
+				                               fileName,
+				                               new string[,] { { &quot;FileName&quot;, fileName }, {&quot;ExceptionMessage&quot;, e.Message}}));
+				return;
+			}
+			Analyse(assembly);
+		}
+		
+		public void Analyse(Module module, Type type)
+		{
+			if (type.IsSpecialName || !(Char.IsLetter(type.Name[0]) || type.Name[0] == '_')) {
+				return;
+			}
+			string ns = type.Namespace == null ? &quot;&quot; : type.Namespace;
+			if (namespaces[ns] == null) {
+				namespaces[ns] = new ArrayList();
+			}
+			((ArrayList)namespaces[ns]).Add(type);
+			
+			foreach (ITypeRule typeRule in typeRules) {
+				AddResolutions(typeRule.Check(type));
+			}
+			
+			foreach (Type nestedType in type.GetNestedTypes()) {
+				Analyse(module, nestedType);
+			}
+			BindingFlags bf = BindingFlags.DeclaredOnly |
+			                  BindingFlags.Public |
+			                  BindingFlags.NonPublic |
+			                  BindingFlags.Static |
+			                  BindingFlags.Instance;
+			
+			
+			foreach (MemberInfo memberInfo in type.GetMembers(bf)) {
+				foreach (IMemberRule memberRule in memberRules) {
+					AddResolutions(memberRule.Check(module, memberInfo));
+				}
+			}
+			
+			foreach (ConstructorInfo constructorInfo in type.GetConstructors(bf)) {
+				if (!constructorInfo.IsSpecialName) {
+					// search parameters
+					foreach (ParameterInfo parameter in constructorInfo.GetParameters()) {
+						foreach (IParameterRule parameterRule in parameterRules) {
+							AddResolutions(parameterRule.Check(module, parameter));
+						}
+					}
+					
+					foreach (IConstructorRule constructorRule in constructorRules) {
+						AddResolutions(constructorRule.Check(constructorInfo));
+					}
+				}
+			}
+			
+			foreach (EventInfo eventInfo in type.GetEvents(bf)) {
+				if (!eventInfo.IsSpecialName) {
+					foreach (IEventRule eventRule in eventRules) {
+						AddResolutions(eventRule.Check(eventInfo));
+					}
+				}
+			}
+			
+			foreach (FieldInfo fieldInfo in type.GetFields(bf)) {
+				if (!fieldInfo.IsSpecialName) {
+					foreach (IFieldRule fieldRule in fieldRules) {
+						AddResolutions(fieldRule.Check(module, fieldInfo));
+					}
+				}
+			}
+			
+			// TODO: IMethodBaseRule
+			foreach (MethodInfo methodInfo in type.GetMethods(bf)) {
+				if (!methodInfo.IsSpecialName) {
+					Console.WriteLine(methodInfo.Attributes);
+				
+					// search parameters
+					foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
+						foreach (IParameterRule parameterRule in parameterRules) {
+							AddResolutions(parameterRule.Check(module, parameter));
+						}
+					}
+					
+					foreach (IMethodRule methodRule in methodRules) {
+						AddResolutions(methodRule.Check(module, methodInfo));
+					}
+				}
+			}
+			
+			foreach (PropertyInfo propertyInfo in type.GetProperties(bf)) {
+				if (!propertyInfo.IsSpecialName) {
+					foreach (IPropertyRule propertyRule in propertyRules) {
+						AddResolutions(propertyRule.Check(propertyInfo));
+					}
+				}
+			}
+		}
+		public void Analyse(Assembly assembly)
+		{
+			namespaces = new Hashtable();
+			resolutions = new ArrayList();
+			foreach (IAssemblyRule assemblyRule in assemblyRules) {
+				AddResolutions(assemblyRule.Check(assembly));
+			}
+			
+			foreach (Module module in assembly.GetModules()) {
+				foreach (IModuleRule moduleRule in moduleRules) {
+					AddResolutions(moduleRule.Check(module));
+				}
+				foreach (Type type in module.GetTypes()) {
+					Analyse(module, type);
+				}
+			}
+			
+			foreach (DictionaryEntry namespaceEntry in namespaces) {
+				foreach (INamespaceRule namespaceRule in namespaceRules) {
+					AddResolutions(namespaceRule.Check(namespaceEntry.Key.ToString(), (ArrayList)namespaceEntry.Value));
+				}
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/Resolution.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/Resolution.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Engine/Resolution.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,59 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using MonoDevelop.AssemblyAnalyser.Rules;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;/summary&gt;
+	/// &lt;summary&gt;
+	/// Description of Resolution.	
+	public class Resolution : System.MarshalByRefObject
+	{
+		IRule  failedRule;
+		string text;
+		string item;
+		string[,] variables;
+		
+		public IRule FailedRule {
+			get {
+				return failedRule;
+			}
+		}
+		public string Text {
+			get {
+				return text;
+			}
+		}
+		public string Item {
+			get {
+				return item;
+			}
+		}
+		public string[,] Variables {
+			get {
+				return variables;
+			}
+		}
+		
+		public Resolution(IRule failedRule, string text, string item)
+		{
+			this.failedRule = failedRule;
+			this.text = text;
+			this.item = item;
+		}
+		
+		public Resolution(IRule failedRule, string text, string item, string[,] variables)
+		{
+			this.failedRule = failedRule;
+			this.text = text;
+			this.item = item;
+			this.variables = variables;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/ICSharpCode.AssemblyAnalyser.prjx
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/ICSharpCode.AssemblyAnalyser.prjx	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/ICSharpCode.AssemblyAnalyser.prjx	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,96 @@
+&lt;Project name=&quot;ICSharpCode.AssemblyAnalyser&quot; standardNamespace=&quot;ICSharpCode.AssemblyAnalyser&quot; description=&quot;&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
+  &lt;Contents&gt;
+    &lt;File name=&quot;.\AssemblyInfo.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IAssemblyRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IConstructorRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IEventRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IFieldRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IMemberRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IMethodBaseRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IMethodRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IModuleRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\INamespaceRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IParameterRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IPropertyRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IReflectionRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\IRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\ITypeRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\ProtectionLevels.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\PriorityLevel.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Engine&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Engine\AssemblyAnalyser.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\AbstractRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\AbstractReflectionRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Engine\Resolution.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\AssemblyStrongNameRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\AssemblyVersionNumberRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\InterfaceNotEmptyRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\AbstractTypesPublicConstructorsRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\AttributeSuffixIsAttributeRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\CheckCollectionSuffix.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\DelegatesHaveNoDelegateSuffix.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\DictionaryTypeSuffixIsDictionary.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\EnumsHaveNoEnumSuffix.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\EventArgsSuffixIsEventArgsRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\EventFirstParameterNameIsSender.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\EventHandlerSuffixIsEventHandler.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\EventsDoNotHaveBeforeOrAfterPrefix.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\EventSecondParameterNameIsE.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\ExceptionSuffixIsExceptionRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\FlagEnumerationsArePlural.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\InterfacesPrefixIsI.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingUtilities.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\MembersArePascalCased.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\OnlyAttributesSuffixAttributeRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\OnlyCollectionsSuffixCollectionRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\OnlyStreamsSuffixStreamRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\StreamSuffixIsStreamRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\TypeNamesDoNotContainUnderscores.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\TODO.txt&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\TypesImplementingInterfacesHaveNoSuffixImplRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\OnlyEventArgsSuffixEventArgsRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\OnlyExceptionsSuffixExceptionRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\NamespacesArePascalCased.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\NamespacesDoNotContainUnderscores.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\MembershipConditionNamesSuffixIsMembershipCondition.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\PermissionSuffixIsPermissionRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\MembersDoNotContainUnderscores.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\OnlyEventHandlerSuffixIsEventHandlerRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\OnlyPermissionsSuffixPermissionRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\TypesArePascalCased.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\ParameterNamesDoNotHaveUnderscores.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\NamingRules\ParametersAreCamelCased.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\EventHandlersReturnVoidRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\EventFirstParameterIsObjectRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\EventSecondParameterIsEventArgsRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\EventsHaveTwoParametersRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\TypesShouldBeInNamespacesRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\AvoidNamespacesWithFewMembers.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\PropertiesShouldNotHaveSetOnly.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\TypesHaveNoPublicInstanceFields.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Rules\DesignRules\AssemblyClsCompliantRule.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+  &lt;/Contents&gt;
+  &lt;References&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;nunit.framework, Version=2.1.4.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77&quot; localcopy=&quot;False&quot; /&gt;
+  &lt;/References&gt;
+  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
+  &lt;Configuration runwithwarnings=&quot;True&quot; name=&quot;Debug&quot;&gt;
+    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;False&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;TEST&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+    &lt;Output directory=&quot;..\..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.AssemblyAnalyser&quot; executeScript=&quot;..\..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+  &lt;/Configuration&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration runwithwarnings=&quot;True&quot; name=&quot;Debug&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;False&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;TEST&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.AssemblyAnalyser&quot; executeScript=&quot;..\..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;False&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.AssemblyAnalyser&quot; executeScript=&quot;..\..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Project&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Makefile
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Makefile	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Makefile	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,77 @@
+
+ASSEMBLY = ICSharpCode.AssemblyAnalyzer.dll
+CSC = mcs /debug
+
+FILES = \
+./Engine/AssemblyAnalyser.cs \
+./Engine/Resolution.cs \
+./Rules/AbstractRule.cs \
+./Rules/IParameterRule.cs \
+./Rules/IMemberRule.cs \
+./Rules/IConstructorRule.cs \
+./Rules/IPropertyRule.cs \
+./Rules/NamingUtilities.cs \
+./Rules/IAssemblyRule.cs \
+./Rules/AbstractReflectionRule.cs \
+./Rules/DesignRules/AssemblyVersionNumberRule.cs \
+./Rules/DesignRules/TypesShouldBeInNamespacesRule.cs \
+./Rules/DesignRules/EventsHaveTwoParametersRule.cs \
+./Rules/DesignRules/AssemblyClsCompliantRule.cs \
+./Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs \
+./Rules/DesignRules/InterfaceNotEmptyRule.cs \
+./Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs \
+./Rules/DesignRules/EventHandlersReturnVoidRule.cs \
+./Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs \
+./Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs \
+./Rules/DesignRules/AvoidNamespacesWithFewMembers.cs \
+./Rules/DesignRules/EventFirstParameterIsObjectRule.cs \
+./Rules/DesignRules/AssemblyStrongNameRule.cs \
+./Rules/ProtectionLevels.cs \
+./Rules/IModuleRule.cs \
+./Rules/ITypeRule.cs \
+./Rules/IMethodRule.cs \
+./Rules/IRule.cs \
+./Rules/IReflectionRule.cs \
+./Rules/IFieldRule.cs \
+./Rules/IMethodBaseRule.cs \
+./Rules/PriorityLevel.cs \
+./Rules/NamingRules/CheckCollectionSuffix.cs \
+./Rules/NamingRules/PermissionSuffixIsPermissionRule.cs \
+./Rules/NamingRules/NamespacesArePascalCased.cs \
+./Rules/NamingRules/ParametersAreCamelCased.cs \
+./Rules/NamingRules/EventFirstParameterNameIsSender.cs \
+./Rules/NamingRules/FlagEnumerationsArePlural.cs \
+./Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs \
+./Rules/NamingRules/InterfacesPrefixIsI.cs \
+./Rules/NamingRules/MembersDoNotContainUnderscores.cs \
+./Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs \
+./Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs \
+./Rules/NamingRules/MembersArePascalCased.cs \
+./Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs \
+./Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs \
+./Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs \
+./Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs \
+./Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs \
+./Rules/NamingRules/EnumsHaveNoEnumSuffix.cs \
+./Rules/NamingRules/NamespacesDoNotContainUnderscores.cs \
+./Rules/NamingRules/TypesArePascalCased.cs \
+./Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs \
+./Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs \
+./Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs \
+./Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs \
+./Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs \
+./Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs \
+./Rules/NamingRules/EventSecondParameterNameIsE.cs \
+./Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs \
+./Rules/NamingRules/StreamSuffixIsStreamRule.cs \
+./Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs \
+./Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs \
+./Rules/NamingRules/AttributeSuffixIsAttributeRule.cs \
+./Rules/IEventRule.cs \
+./Rules/INamespaceRule.cs \
+./AssemblyInfo.cs
+
+all: $(ASSEMBLY)
+
+$(ASSEMBLY): $(FILES)
+	$(CSC) /out:$(ASSEMBLY) /target:library $(FILES) 

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractReflectionRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractReflectionRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractReflectionRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,41 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AbstractReflectionRule.	
+	/// &lt;/summary&gt;
+	public abstract class AbstractReflectionRule : AbstractRule, MonoDevelop.AssemblyAnalyser.Rules.IReflectionRule
+	{
+		protected ProtectionLevels memberProtectionLevel     = ProtectionLevels.All;
+		protected ProtectionLevels nestedTypeProtectionLevel = ProtectionLevels.All;
+		protected ProtectionLevels typeProtectionLevel       = ProtectionLevels.All;
+		
+		#region MonoDevelop.AssemblyAnalyser.Rules.IReflectionRule interface implementation
+		public virtual ProtectionLevels MemberProtectionLevel {
+			get {
+				return memberProtectionLevel;
+			}
+		}
+		
+		public virtual ProtectionLevels NestedTypeProtectionLevel {
+			get {
+				return nestedTypeProtectionLevel;
+			}
+		}
+		
+		public virtual ProtectionLevels TypeProtectionLevel {
+			get {
+				return typeProtectionLevel;
+			}
+		}
+		#endregion
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/AbstractRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,82 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AbstractRule.	
+	/// &lt;/summary&gt;
+	public abstract class AbstractRule : System.MarshalByRefObject, IRule
+	{
+		protected PriorityLevel priorityLevel = PriorityLevel.Error;
+		protected int certainty = 99;
+		
+		#region MonoDevelop.AssemblyAnalyser.Rules.IRule interface implementation
+		public PriorityLevel PriorityLevel {
+			get {
+				return priorityLevel;
+			}
+		}
+		
+		public int Certainty {
+			get {
+				return certainty;
+			}
+		}
+		
+		public abstract string Description {
+			get;
+		}
+		
+		public abstract string Details {
+			get;
+		}
+		
+		public virtual void EndAnalysis()
+		{
+		}
+		
+		public virtual void StartAnalysis()
+		{
+		}
+		#endregion
+	}
+	
+	public class CustomRule : AbstractRule
+	{
+		string description;
+		string details;
+		
+		public override string Description {
+			get {
+				return description;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return details;
+			}
+		}
+		
+		public CustomRule(string description, string details)
+		{
+			this.description = description;
+			this.details = details;
+		}
+		public CustomRule(string description, string details, PriorityLevel priorityLevel, int certainty)
+		{
+			this.description = description;
+			this.details = details;
+			this.priorityLevel = priorityLevel;
+			this.certainty = certainty;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AbstractTypesPublicConstructorsRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,100 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyStrongName.	
+	/// &lt;/summary&gt;
+	public class AbstractTypesPublicConstructorsRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AbstractTypesPublicConstructors.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AbstractTypesPublicConstructors.Details}&quot;;
+			}
+		}
+		
+		public AbstractTypesPublicConstructorsRule()
+		{
+			priorityLevel = PriorityLevel.CriticalWarning;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsAbstract) {
+				foreach (ConstructorInfo info in type.GetConstructors()) {
+					if (info.IsPublic) {
+ 						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AbstractTypesPublicConstructors.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+					}
+				}
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class AbstractTypesPublicConstructorsRuleTest
+	{
+		abstract class AbstractClassPublic1 {
+			public AbstractClassPublic1()
+			{
+			}
+		}
+		abstract class AbstractClassPublic2 {
+			protected AbstractClassPublic2()
+			{
+			}
+			public AbstractClassPublic2(int x, int y)
+			{
+			}
+		}
+		[Test]
+		public void TestAbstractTypesWithPublicConstructor()
+		{
+			AbstractTypesPublicConstructorsRule rule = new AbstractTypesPublicConstructorsRule();
+			Assertion.AssertNotNull(rule.Check(typeof(AbstractClassPublic1)));
+			Assertion.AssertNotNull(rule.Check(typeof(AbstractClassPublic2)));
+		}
+		
+		abstract class AbstractClass1 {
+			protected AbstractClass1()
+			{
+			}
+		}
+		abstract class AbstractClass2 {
+			protected AbstractClass2(int x, int y)
+			{
+			}
+		}
+		
+		[Test]
+		public void TestAbstractTypesWithoutPublicConstructor()
+		{
+			AbstractTypesPublicConstructorsRule rule = new AbstractTypesPublicConstructorsRule();
+			Assertion.AssertNull(rule.Check(typeof(AbstractClass1)));
+			Assertion.AssertNull(rule.Check(typeof(AbstractClass2)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyClsCompliantRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyClsCompliantRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyClsCompliantRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,51 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyStrongName.	
+	/// &lt;/summary&gt;
+	public class AssemblyClsCompliantRule : AbstractReflectionRule, IAssemblyRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyClsCompliantRule.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyClsCompliantRule.Details}&quot;;
+			}
+		}
+		
+		public AssemblyClsCompliantRule()
+		{
+			certainty = 99;
+		}
+		
+		public Resolution Check(Assembly assembly)
+		{
+			object[] attributes = assembly.GetCustomAttributes(typeof(System.CLSCompliantAttribute), true);
+			if (attributes == null || attributes.Length == 0) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyClsCompliantRule.Resolution1}&quot;, assembly.Location, new string[,] { {&quot;AssemblyName&quot;, Path.GetFileName(assembly.Location)} });
+			} else {
+				foreach (CLSCompliantAttribute attr in attributes) {
+					if (!attr.IsCompliant) {
+						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyClsCompliantRule.Resolution2}&quot;, assembly.Location, new string[,] { {&quot;AssemblyName&quot;, Path.GetFileName(assembly.Location)} });
+					}
+				}
+			}
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyStrongNameRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyStrongNameRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyStrongNameRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,45 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyStrongName.	
+	/// &lt;/summary&gt;
+	public class AssemblyStrongNameRule : AbstractReflectionRule, IAssemblyRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyStrongName.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyStrongName.Details}&quot;;
+			}
+		}
+		
+		public AssemblyStrongNameRule()
+		{
+			certainty = 95;
+		}
+		
+		public Resolution Check(Assembly assembly)
+		{
+			byte[] publicKeyToken = assembly.GetName().GetPublicKeyToken();
+			if (publicKeyToken == null || publicKeyToken.Length == 0) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyStrongName.Resolution}&quot;, assembly.Location, new string[,] { {&quot;AssemblyName&quot;, Path.GetFileName(assembly.Location)} });
+			}
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyVersionNumberRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyVersionNumberRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AssemblyVersionNumberRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,45 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Reflection;
+using MonoDevelop.AssemblyAnalyser.Rules;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyVersionNumber.	
+	/// &lt;/summary&gt;
+	public class AssemblyVersionNumberRule : AbstractReflectionRule, IAssemblyRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyVersionNumber.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyVersionNumber.Details}&quot;;
+			}
+		}
+		
+		public AssemblyVersionNumberRule()
+		{
+			certainty = 95;
+		}
+		
+		public Resolution Check(Assembly assembly)
+		{
+			if (assembly.GetName().Version == new Version(0, 0, 0, 0)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AssemblyVersionNumber.Resolution}&quot;, assembly.Location, new string[,] { {&quot;AssemblyName&quot;, Path.GetFileName(assembly.Location)} });
+			}
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AvoidNamespacesWithFewMembers.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AvoidNamespacesWithFewMembers.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/AvoidNamespacesWithFewMembers.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,75 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AvoidNamespacesWithFewMembers.	
+	/// &lt;/summary&gt;
+	public class AvoidNamespacesWithFewMembers : AbstractReflectionRule, INamespaceRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AvoidNamespacesWithFewMembers.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AvoidNamespacesWithFewMembers.Details}&quot;;
+			}
+		}
+		
+		public AvoidNamespacesWithFewMembers()
+		{
+			base.certainty     = 50;
+			base.priorityLevel = PriorityLevel.Warning;
+		}
+		
+		public Resolution Check(string namespaceName, ICollection types)
+		{
+			if (namespaceName != null &amp;&amp; namespaceName.Length &gt; 0 &amp;&amp; types.Count &lt; 5) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AvoidNamespacesWithFewMembers.Resolution}&quot;, namespaceName, new string[,]{{&quot;NamespaceName&quot;, namespaceName}});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class AvoidNamespacesWithFewMembersTest
+	{
+		[Test]
+		public void TestCorrectNamespaces()
+		{
+			AvoidNamespacesWithFewMembers rule = new AvoidNamespacesWithFewMembers();
+			Assertion.AssertNull(rule.Check(&quot;MyNamespace&quot;, new Type[] {typeof(System.Object),
+			                                                             typeof(System.Object),
+			                                                             typeof(System.Object),
+			                                                             typeof(System.Object),
+			                                                             typeof(System.Object),
+			                                                             typeof(System.Object)}));
+		}
+		
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			AvoidNamespacesWithFewMembers rule = new AvoidNamespacesWithFewMembers();
+			Assertion.AssertNotNull(rule.Check(&quot;a&quot;, new Type[] {}));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventFirstParameterIsObjectRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventFirstParameterIsObjectRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventFirstParameterIsObjectRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,90 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventFirstParameterIsObject.	
+	/// &lt;/summary&gt;
+	public class EventFirstParameterIsObjectRule : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterIsObject.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterIsObject.Details}&quot;;
+			}
+		}
+		
+		public EventFirstParameterIsObjectRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length &gt; 0 &amp;&amp; parameters[0].ParameterType != typeof(System.Object)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterIsObject.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, { &quot;OldParameterType&quot;, parameters[0].ParameterType.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventFirstParameterIsObjectRuleTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventFirstParameterIsObjectRule rule = new EventFirstParameterIsObjectRule();
+			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(int sender, EventArgs e);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(6, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventFirstParameterIsObjectRule rule = new EventFirstParameterIsObjectRule();
+			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventHandlersReturnVoidRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventHandlersReturnVoidRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventHandlersReturnVoidRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,88 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventFirstParameterNameIsSender.	
+	/// &lt;/summary&gt;
+	public class EventHandlersReturnVoidRule : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlersReturnVoid.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlersReturnVoid.Details}&quot;;
+			}
+		}
+		
+		public EventHandlersReturnVoidRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			if (invokeMethod.ReturnType != typeof(void)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlersReturnVoid.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, {&quot;OldReturnType&quot;, invokeMethod.ReturnType.FullName}});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventHandlersReturnVoidRuleTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventHandlersReturnVoidRule rule = new EventHandlersReturnVoidRule();
+			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate int IncorrectEventHandler(object sender, EventArgs e);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventHandlersReturnVoidRule rule = new EventHandlersReturnVoidRule();
+			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventSecondParameterIsEventArgsRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,90 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventFirstParameterIsObject.	
+	/// &lt;/summary&gt;
+	public class EventSecondParameterIsEventArgsRule : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterIsEventArgs.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterIsEventArgs.Details}&quot;;
+			}
+		}
+		
+		public EventSecondParameterIsEventArgsRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length &gt; 1 &amp;&amp; !typeof(System.EventArgs).IsAssignableFrom(parameters[1].ParameterType)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterIsEventArgs.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, { &quot;OldParameterType&quot;, parameters[1].ParameterType.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventSecondParameterIsEventArgsRuleTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventSecondParameterIsEventArgsRule rule = new EventSecondParameterIsEventArgsRule();
+			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(object sender, int e);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(int e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventSecondParameterIsEventArgsRule rule = new EventSecondParameterIsEventArgsRule();
+			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventsHaveTwoParametersRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventsHaveTwoParametersRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/EventsHaveTwoParametersRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,90 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventsHaveTwoParameters.	
+	/// &lt;/summary&gt;
+	public class EventsHaveTwoParametersRule : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsHaveTwoParameters.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsHaveTwoParameters.Details}&quot;;
+			}
+		}
+		
+		public EventsHaveTwoParametersRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length != 2) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsHaveTwoParameters.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventsHaveTwoParametersTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventsHaveTwoParametersRule rule = new EventsHaveTwoParametersRule();
+			Assertion.AssertNull(rule.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(object sender, EventArgs e, int i);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e, 5);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventsHaveTwoParametersRule rule = new EventsHaveTwoParametersRule();
+			Assertion.AssertNotNull(rule.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/InterfaceNotEmptyRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/InterfaceNotEmptyRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/InterfaceNotEmptyRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,84 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of InterfaceNotEmpty.	
+	/// &lt;/summary&gt;
+	public class InterfaceNotEmptyRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfaceNotEmpty.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfaceNotEmpty.Details}&quot;;
+			}
+		}
+		public Resolution Check(Type type)
+		{
+			if (type.IsInterface &amp;&amp; type.GetMembers().Length == 0) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfaceNotEmpty.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class InterfaceNotEmptyRuleTests
+	{
+		interface NonEmptyInterface1
+		{
+			void A();
+		}
+		interface NonEmptyInterface2
+		{
+			event EventHandler TestEvent;
+		}
+		interface NonEmptyInterface3
+		{
+			int MyProperty {
+				get;
+			}
+		}
+		[Test]
+		public void TestNonEmptyInterface()
+		{
+			InterfaceNotEmptyRule rule = new InterfaceNotEmptyRule();
+			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface1)));
+			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface2)));
+			Assertion.AssertNull(rule.Check(typeof(NonEmptyInterface3)));
+		}
+		
+		interface EmptyInterface
+		{
+		}
+		
+		[Test]
+		public void TestEmptyInterface()
+		{
+			InterfaceNotEmptyRule rule = new InterfaceNotEmptyRule();
+			Assertion.AssertNotNull(rule.Check(typeof(EmptyInterface)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/PropertiesShouldNotHaveSetOnly.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,99 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of PropertiesShouldNotHaveSetOnly.	
+	/// &lt;/summary&gt;
+	public class PropertiesShouldNotHaveSetOnly : AbstractReflectionRule, IPropertyRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PropertiesShouldNotHaveSetOnly.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PropertiesShouldNotHaveSetOnly.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(PropertyInfo property)
+		{
+			if (!property.CanRead &amp;&amp; property.CanWrite) {
+				return new Resolution(this, 
+				                      &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PropertiesShouldNotHaveSetOnly.Resolution}&quot;,
+				                      NamingUtilities.Combine(property.DeclaringType.FullName, property.Name),
+				                      new string[,] { 
+				                      	{&quot;PropertyName&quot;, property.Name}, 
+				                      	{&quot;DeclaringType&quot;, property.DeclaringType.FullName}, 
+				                      });
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class PropertiesShouldNotHaveSetOnlyTest
+	{
+		class A {
+			public int Inta {
+				get {
+					return 5;
+				}
+				set {
+					
+				}
+			}
+			public string StrB {
+				get {
+					return &quot;&quot;;
+				}
+			}
+		}
+		[Test]
+		public void TestCorrectProperties()
+		{
+			PropertiesShouldNotHaveSetOnly rule = new PropertiesShouldNotHaveSetOnly();
+			Assertion.AssertNull(rule.Check(typeof(A).GetProperty(&quot;Inta&quot;)));
+			Assertion.AssertNull(rule.Check(typeof(A).GetProperty(&quot;StrB&quot;)));
+		}
+		
+		class B {
+			public int Inta {
+				set {
+				}
+			}
+			public string StrB {
+				set {
+				}
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectProperties()
+		{
+			PropertiesShouldNotHaveSetOnly rule = new PropertiesShouldNotHaveSetOnly();
+			Assertion.AssertNotNull(rule.Check(typeof(B).GetProperty(&quot;Inta&quot;)));
+			Assertion.AssertNotNull(rule.Check(typeof(B).GetProperty(&quot;StrB&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesHaveNoPublicInstanceFields.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,105 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of PropertiesShouldNotHaveSetOnly.	
+	/// &lt;/summary&gt;
+	public class TypesHaveNoPublicInstanceFields : AbstractReflectionRule, IFieldRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesHaveNoPublicInstanceFields.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesHaveNoPublicInstanceFields.Details}&quot;;
+			}
+		}
+		
+		public TypesHaveNoPublicInstanceFields()
+		{
+			base.certainty = 90;
+		}
+		
+		public Resolution Check(Module module, FieldInfo field)
+		{
+			if (!field.IsStatic &amp;&amp; (field.IsPublic || field.IsAssembly)) {
+				return new Resolution(this, 
+				                      &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesHaveNoPublicInstanceFields.Resolution}&quot;,
+				                      NamingUtilities.Combine(field.DeclaringType.FullName, field.Name),
+				                      new string[,] {
+				                      	{&quot;FieldName&quot;, field.Name}, 
+				                      	{&quot;DeclaringType&quot;, field.DeclaringType.FullName}, 
+				                      });
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypesHaveNoPublicInstanceFieldsTest
+	{
+		class A {
+			int a;
+			protected string b;
+			public static int c = 12;
+			public int AA {
+				get {
+					return a;
+				}
+				set {
+					a = value;
+				}
+			}
+			public string B {
+				get {
+					return b;
+				}
+				set {
+					b = value;
+				}
+			}
+		}
+		[Test]
+		public void TestCorrectFields()
+		{
+			TypesHaveNoPublicInstanceFields rule = new TypesHaveNoPublicInstanceFields();
+			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;a&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
+			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;b&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
+			Assertion.AssertNull(rule.Check(null, typeof(A).GetField(&quot;c&quot;, BindingFlags.Public | BindingFlags.Static)));
+		}
+		
+		class B {
+			public int a = 5;
+			internal string b =&quot;&quot;;
+		}
+		
+		[Test]
+		public void TestIncorrectFields()
+		{
+			TypesHaveNoPublicInstanceFields rule = new TypesHaveNoPublicInstanceFields();
+			Assertion.AssertNotNull(rule.Check(null, typeof(B).GetField(&quot;a&quot;, BindingFlags.Public | BindingFlags.Instance)));
+			Assertion.AssertNotNull(rule.Check(null, typeof(B).GetField(&quot;b&quot;, BindingFlags.NonPublic | BindingFlags.Instance)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesShouldBeInNamespacesRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesShouldBeInNamespacesRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/DesignRules/TypesShouldBeInNamespacesRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,74 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of TypesShouldBeInNamespaces.	
+	/// &lt;/summary&gt;
+	public class TypesShouldBeInNamespacesRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesShouldBeInNamespaces.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesShouldBeInNamespaces.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.Namespace == null || type.Namespace.Length == 0) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesShouldBeInNamespaces.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+class OutsideNamespace
+{
+	
+}
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypesShouldBeInNamespacesRuleTest
+	{
+		interface ICorrectInterface
+		{
+		}
+		[Test]
+		public void TestCorrectAttribute()
+		{
+			TypesShouldBeInNamespacesRule rule = new TypesShouldBeInNamespacesRule();
+			Assertion.AssertNull(rule.Check(typeof(System.ICloneable)));
+			Assertion.AssertNull(rule.Check(typeof(TypesShouldBeInNamespacesRuleTest)));
+			Assertion.AssertNull(rule.Check(typeof(ICorrectInterface)));
+		}
+		
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			TypesShouldBeInNamespacesRule rule = new TypesShouldBeInNamespacesRule();
+			Assertion.AssertNotNull(rule.Check(typeof(OutsideNamespace)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IAssemblyRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IAssemblyRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IAssemblyRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IAssemblyRule.	
+	/// &lt;/summary&gt;
+	public interface IAssemblyRule : IReflectionRule
+	{
+		Resolution Check(Assembly assembly);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IConstructorRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IConstructorRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IConstructorRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IConstructorRule.	
+	/// &lt;/summary&gt;
+	public interface IConstructorRule : IReflectionRule
+	{
+		Resolution Check(ConstructorInfo constructor);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IEventRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IEventRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IEventRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IEventRule.	
+	/// &lt;/summary&gt;
+	public interface IEventRule : IReflectionRule
+	{
+		Resolution Check(EventInfo evnt);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IFieldRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IFieldRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IFieldRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IFieldRule.	
+	/// &lt;/summary&gt;
+	public interface IFieldRule : IReflectionRule
+	{
+		Resolution Check(Module module, FieldInfo field);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMemberRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMemberRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMemberRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IMemberRule.	
+	/// &lt;/summary&gt;
+	public interface IMemberRule : IReflectionRule
+	{
+		 Resolution Check(Module module, MemberInfo member);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodBaseRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodBaseRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodBaseRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IMethodBaseRule.	
+	/// &lt;/summary&gt;
+	public interface IMethodBaseRule : IReflectionRule
+	{
+		Resolution Check(Module module, MethodBase methodBase);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IMethodRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IMethodRule.	
+	/// &lt;/summary&gt;
+	public interface IMethodRule : IReflectionRule
+	{
+		Resolution Check(Module module, MethodInfo method);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IModuleRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IModuleRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IModuleRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IModuleRule.	
+	/// &lt;/summary&gt;
+	public interface IModuleRule : IReflectionRule
+	{
+		Resolution Check(Module module);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/INamespaceRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/INamespaceRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/INamespaceRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,21 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of INamespaceRule.	
+	/// &lt;/summary&gt;
+	public interface INamespaceRule : IReflectionRule
+	{
+		Resolution Check(string namespaceName, ICollection types);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IParameterRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IParameterRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IParameterRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IParameterRule.	
+	/// &lt;/summary&gt;
+	public interface IParameterRule : IReflectionRule
+	{
+		Resolution Check(Module module, ParameterInfo param);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IPropertyRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IPropertyRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IPropertyRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IPropertyRule.	
+	/// &lt;/summary&gt;
+	public interface IPropertyRule : IReflectionRule
+	{
+		Resolution Check(PropertyInfo property);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IReflectionRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IReflectionRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IReflectionRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,31 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IAssemblyRule.	
+	/// &lt;/summary&gt;
+	public interface IReflectionRule : IRule
+	{
+		ProtectionLevels MemberProtectionLevel {
+			get;
+		}
+		
+		ProtectionLevels NestedTypeProtectionLevel {
+			get;
+		}
+		
+		ProtectionLevels TypeProtectionLevel {
+			get;
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/IRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,37 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IRule.	
+	/// &lt;/summary&gt;
+	public interface IRule
+	{
+		void EndAnalysis();
+		void StartAnalysis();
+		
+		PriorityLevel PriorityLevel {
+			get;
+		}
+		
+		int Certainty {
+			get;
+		}
+		
+		string Description {
+			get;
+		}
+		
+		string Details {
+			get;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ITypeRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ITypeRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ITypeRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,20 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of ITypeRule.	
+	/// &lt;/summary&gt;
+	public interface ITypeRule : IReflectionRule
+	{
+		Resolution Check(Type type);
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/AttributeSuffixIsAttributeRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/AttributeSuffixIsAttributeRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/AttributeSuffixIsAttributeRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,71 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class AttributeSuffixIsAttributeRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AttributeSuffixIsAttribute.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AttributeSuffixIsAttribute.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsSubclassOf(typeof(System.Attribute)) &amp;&amp; !type.Name.EndsWith(&quot;Attribute&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.AttributeSuffixIsAttribute.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class AttributeSuffixIsAttributeRuleTest
+	{
+		class MyAttribute : System.Attribute
+		{
+		}
+		[Test]
+		public void TestCorrectAttribute()
+		{
+			AttributeSuffixIsAttributeRule rule = new AttributeSuffixIsAttributeRule();
+			Assertion.AssertNull(rule.Check(typeof(MyAttribute)));
+		}
+		
+		class MyAttr : System.Attribute
+		{
+		}
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			AttributeSuffixIsAttributeRule rule = new AttributeSuffixIsAttributeRule();
+			Assertion.AssertNotNull(rule.Check(typeof(MyAttr)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/CheckCollectionSuffix.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/CheckCollectionSuffix.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/CheckCollectionSuffix.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,138 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of CheckCollectionSuffix.	
+	/// &lt;/summary&gt;
+	public class CheckCollectionSuffix : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Details}&quot;;
+			}
+		}
+		
+		public CheckCollectionSuffix()
+		{
+			base.certainty = 90;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if ((typeof(ICollection).IsAssignableFrom(type) || typeof(IEnumerable).IsAssignableFrom(type)) &amp;&amp; !typeof(System.Collections.IDictionary).IsAssignableFrom(type)) {
+				if (typeof(Queue).IsAssignableFrom(type)) {
+					if (!type.Name.EndsWith(&quot;Queue&quot;)) {
+						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Resolution1}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }} );
+					}
+				} else if (typeof(Stack).IsAssignableFrom(type)) {
+					if (!type.Name.EndsWith(&quot;Stack&quot;)) {
+						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Resolution2}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+					}
+				} else {
+					if (!type.Name.EndsWith(&quot;Collection&quot;)) {
+						return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.CheckCollectionSuffix.Resolution3}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+					}
+				}
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class CheckCollectionSuffixTest
+	{
+		#region Collection suffix tests
+		class MyCollection : System.Collections.ArrayList
+		{
+		}
+		class MyDictionary : System.Collections.Hashtable
+		{
+		}
+		[Test]
+		public void TestCorrectCollection()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyCollection)));
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyDictionary)));
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(CheckCollectionSuffixTest)));
+		}
+		
+		class MyColl : System.Collections.ArrayList
+		{
+		}
+		[Test]
+		public void TestIncorrectCollection()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MyColl)));
+		}
+		#endregion
+		
+		#region Queue suffix tests
+		class MyQueue : System.Collections.Queue
+		{
+		}
+		[Test]
+		public void TestCorrectQueue()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyQueue)));
+		}
+		
+		class MyQWEQWEQ : System.Collections.Queue
+		{
+		}
+		[Test]
+		public void TestIncorrectQueue()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MyQWEQWEQ)));
+		}
+		#endregion 
+		
+		#region Stack suffix tests
+		class MyStack : System.Collections.Stack
+		{
+		}
+		[Test]
+		public void TestCorrectStack()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNull(checkCollectionSuffix.Check(typeof(MyStack)));
+		}
+		class MySfwefew : System.Collections.Stack
+		{
+		}
+		[Test]
+		public void TestIncorrectStack()
+		{
+			CheckCollectionSuffix checkCollectionSuffix = new CheckCollectionSuffix();
+			Assertion.AssertNotNull(checkCollectionSuffix.Check(typeof(MySfwefew)));
+		}
+		#endregion
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DelegatesHaveNoDelegateSuffix.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,71 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of DelegatesHaveNoDelegateSuffix.	
+	/// &lt;/summary&gt;
+	public class DelegatesHaveNoDelegateSuffix : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DelegatesHaveNoDelegateSuffix.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DelegatesHaveNoDelegateSuffix.Details}&quot;;
+			}
+		}
+		
+		public DelegatesHaveNoDelegateSuffix()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsSubclassOf(typeof(System.Delegate)) &amp;&amp; type.Name.EndsWith(&quot;Delegate&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DelegatesHaveNoDelegateSuffix.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class DelegatesHaveNoDelegateSuffixTest
+	{
+		delegate void MyDelegateWithoutDelegateSuffix();
+		[Test]
+		public void TestCorrectDelegate()
+		{
+			DelegatesHaveNoDelegateSuffix delegatesHaveNoDelegateSuffix = new DelegatesHaveNoDelegateSuffix();
+			Assertion.AssertNull(delegatesHaveNoDelegateSuffix.Check(typeof(MyDelegateWithoutDelegateSuffix)));
+		}
+		
+		delegate void MyDelegateWithDelegateSuffixDelegate();
+		[Test]
+		public void TestIncorrectDelegate()
+		{
+			DelegatesHaveNoDelegateSuffix delegatesHaveNoDelegateSuffix = new DelegatesHaveNoDelegateSuffix();
+			Assertion.AssertNotNull(delegatesHaveNoDelegateSuffix.Check(typeof(MyDelegateWithDelegateSuffixDelegate)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/DictionaryTypeSuffixIsDictionary.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,72 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of DelegatesHaveNoDelegateSuffix.	
+	/// &lt;/summary&gt;
+	public class DictionaryTypeSuffixIsDictionary : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DictionaryTypeSuffixIsDictionary.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DictionaryTypeSuffixIsDictionary.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.Collections.IDictionary).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Dictionary&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.DictionaryTypeSuffixIsDictionary.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class DictionaryTypeSuffixIsDictionaryTest
+	{
+		class CorrectDictionary : System.Collections.Hashtable
+		{
+		}
+		[Test]
+		public void TestCorrectDictionary()
+		{
+			DictionaryTypeSuffixIsDictionary dictionaryTypeSuffixIsDictionary = new DictionaryTypeSuffixIsDictionary();
+			Assertion.AssertNull(dictionaryTypeSuffixIsDictionary.Check(typeof(CorrectDictionary)));
+		}
+		
+		class IncorrectDictionaryWrongSuffix : System.Collections.Hashtable
+		{
+		}
+		[Test]
+		public void TestIncorrectDictionary()
+		{
+			DictionaryTypeSuffixIsDictionary dictionaryTypeSuffixIsDictionary = new DictionaryTypeSuffixIsDictionary();
+			Assertion.AssertNotNull(dictionaryTypeSuffixIsDictionary.Check(typeof(IncorrectDictionaryWrongSuffix)));
+		}
+		
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EnumsHaveNoEnumSuffix.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EnumsHaveNoEnumSuffix.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EnumsHaveNoEnumSuffix.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,78 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of DelegatesHaveNoDelegateSuffix.	
+	/// &lt;/summary&gt;
+	public class EnumsHaveNoEnumSuffix : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EnumsHaveNoEnumSuffix.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EnumsHaveNoEnumSuffix.Details}&quot;;
+			}
+		}
+		
+		public EnumsHaveNoEnumSuffix()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsSubclassOf(typeof(System.Enum)) &amp;&amp; type.Name.EndsWith(&quot;Enum&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EnumsHaveNoEnumSuffix.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EnumsHaveNoEnumSuffixTest
+	{
+		enum CorrectEnumWithAnotherSuffix
+		{
+			A, B, C
+		}
+		[Test]
+		public void TestCorrectEnum()
+		{
+			EnumsHaveNoEnumSuffix enumsHaveNoEnumSuffix = new EnumsHaveNoEnumSuffix();
+			Assertion.AssertNull(enumsHaveNoEnumSuffix.Check(typeof(CorrectEnumWithAnotherSuffix)));
+		}
+		
+		enum IncorrectEnum
+		{
+			A, B, C
+		}
+		[Test]
+		public void TestIncorrectDictionary()
+		{
+			EnumsHaveNoEnumSuffix enumsHaveNoEnumSuffix = new EnumsHaveNoEnumSuffix();
+			Assertion.AssertNotNull(enumsHaveNoEnumSuffix.Check(typeof(IncorrectEnum)));
+		}
+		
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventArgsSuffixIsEventArgsRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,72 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class EventArgsSuffixIsEventArgsRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventArgsSuffixIsEventArgs.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventArgsSuffixIsEventArgs.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.EventArgs).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;EventArgs&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventArgsSuffixIsEventArgs.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventArgsSuffixIsEventArgsRuleTest
+	{
+		class CorrectEventArgs : System.EventArgs
+		{
+		}
+		[Test]
+		public void TestCorrectEventArgs()
+		{
+			EventArgsSuffixIsEventArgsRule rule = new EventArgsSuffixIsEventArgsRule();
+			Assertion.AssertNull(rule.Check(typeof(CorrectEventArgs)));
+		}
+		
+		class IncorrectEventArgsWithWrongSuffix : System.EventArgs
+		{
+		}
+		[Test]
+		public void TestIncorrectEventArgs()
+		{
+			EventArgsSuffixIsEventArgsRule rule = new EventArgsSuffixIsEventArgsRule();
+			Assertion.AssertNotNull(rule.Check(typeof(IncorrectEventArgsWithWrongSuffix)));
+		}
+		
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventFirstParameterNameIsSender.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventFirstParameterNameIsSender.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventFirstParameterNameIsSender.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,90 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventFirstParameterNameIsSender.	
+	/// &lt;/summary&gt;
+	public class EventFirstParameterNameIsSender : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterNameIsSender.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterNameIsSender.Details}&quot;;
+			}
+		}
+		
+		public EventFirstParameterNameIsSender()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length &gt; 0 &amp;&amp; parameters[0].Name != &quot;sender&quot;) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventFirstParameterNameIsSender.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, { &quot;OldParameterName&quot;, parameters[0].Name }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventFirstParameterNameIsSenderTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventFirstParameterNameIsSender eventFirstParameterNameIsSender = new EventFirstParameterNameIsSender();
+			Assertion.AssertNull(eventFirstParameterNameIsSender.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(object s, EventArgs e);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventFirstParameterNameIsSender eventFirstParameterNameIsSender = new EventFirstParameterNameIsSender();
+			Assertion.AssertNotNull(eventFirstParameterNameIsSender.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventHandlerSuffixIsEventHandler.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,93 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventHandlerSuffixIsEventHandler.	
+	/// &lt;/summary&gt;
+	public class EventHandlerSuffixIsEventHandler : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlerSuffixIsEventHandler.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlerSuffixIsEventHandler.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			if (!evnt.EventHandlerType.Name.EndsWith(&quot;EventHandler&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventHandlerSuffixIsEventHandler.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventsDoNotHaveBeforeOrAfterPrefixTest
+	{
+		public event EventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
+			Assertion.AssertNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+
+		public event EventHandler BeforeIncorrectEvent;
+		protected virtual void OnBeforeIncorrectEvent(EventArgs e)
+		{
+			if (BeforeIncorrectEvent != null) {
+				BeforeIncorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestIncorrectEventHandler1()
+		{
+			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
+			Assertion.AssertNotNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;BeforeIncorrectEvent&quot;)));
+		}
+		
+		public event EventHandler AfterIncorrectEvent;
+		protected virtual void OnAfterIncorrectEvent(EventArgs e)
+		{
+			if (AfterIncorrectEvent != null) {
+				AfterIncorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestIncorrectEventHandler2()
+		{
+			EventsDoNotHaveBeforeOrAfterPrefix eventsDoNotHaveBeforeOrAfterPrefix = new EventsDoNotHaveBeforeOrAfterPrefix();
+			Assertion.AssertNotNull(eventsDoNotHaveBeforeOrAfterPrefix.Check(this.GetType().GetEvent(&quot;AfterIncorrectEvent&quot;)));
+		}
+		
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventSecondParameterNameIsE.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventSecondParameterNameIsE.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventSecondParameterNameIsE.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,89 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventFirstParameterNameIsSender.	
+	/// &lt;/summary&gt;
+	public class EventSecondParameterNameIsE : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterNameIsE.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterNameIsE.Details}&quot;;
+			}
+		}
+		
+		public EventSecondParameterNameIsE()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			MethodInfo invokeMethod = evnt.EventHandlerType.GetMethod(&quot;Invoke&quot;);
+			ParameterInfo[] parameters = invokeMethod.GetParameters();
+
+			if (parameters.Length &gt; 1 &amp;&amp; parameters[1].Name != &quot;e&quot;) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventSecondParameterNameIsE.Resolution}&quot;, evnt.EventHandlerType.FullName, new string[,] { { &quot;EventType&quot;, evnt.EventHandlerType.FullName }, { &quot;OldParameterName&quot;, parameters[1].Name }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventSecondParameterNameIsETest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventSecondParameterNameIsE eventSecondParameterNameIsE = new EventSecondParameterNameIsE();
+			Assertion.AssertNull(eventSecondParameterNameIsE.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandler(object sender, EventArgs notE);
+		public event IncorrectEventHandler IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventSecondParameterNameIsE eventSecondParameterNameIsE = new EventSecondParameterNameIsE();
+			Assertion.AssertNotNull(eventSecondParameterNameIsE.Check(this.GetType().GetEvent(&quot;IncorrectEvent&quot;)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/EventsDoNotHaveBeforeOrAfterPrefix.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,89 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of EventsDoNotHaveBeforeOrAfterPrefix.	
+	/// &lt;/summary&gt;
+	public class EventsDoNotHaveBeforeOrAfterPrefix : AbstractReflectionRule, IEventRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsDoNotHaveBeforeOrAfterPrefix.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsDoNotHaveBeforeOrAfterPrefix.Details}&quot;;
+			}
+		}
+		
+		public EventsDoNotHaveBeforeOrAfterPrefix()
+		{
+			base.certainty = 90;
+		}
+		
+		public Resolution Check(EventInfo evnt)
+		{
+			if (evnt.Name.StartsWith(&quot;Before&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsDoNotHaveBeforeOrAfterPrefix.Resolution1}&quot;, NamingUtilities.Combine(evnt.ReflectedType.FullName, evnt.Name), new string[,] { { &quot;EventName&quot;, evnt.Name }, { &quot;ReflectedType&quot;, evnt.ReflectedType.FullName }});
+			} else if (evnt.Name.StartsWith(&quot;After&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.EventsDoNotHaveBeforeOrAfterPrefix.Resolution2}&quot;, NamingUtilities.Combine(evnt.ReflectedType.FullName, evnt.Name), new string[,] { { &quot;EventName&quot;, evnt.Name }, { &quot;ReflectedType&quot;, evnt.ReflectedType.FullName }});	
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class EventHandlerSuffixIsEventHandlerTest
+	{
+		public delegate void CorrectEventHandler(object sender, EventArgs e);
+		public event CorrectEventHandler CorrectEvent;
+		protected virtual void OnCorrectEvent(EventArgs e)
+		{
+			if (CorrectEvent != null) {
+				CorrectEvent(this, e);
+			}
+		}
+		[Test]
+		public void TestCorrectEventHandler()
+		{
+			EventHandlerSuffixIsEventHandler eventHandlerSuffixIsEventHandler = new EventHandlerSuffixIsEventHandler();
+			Assertion.AssertNull(eventHandlerSuffixIsEventHandler.Check(this.GetType().GetEvent(&quot;CorrectEvent&quot;)));
+		}
+		
+		public delegate void IncorrectEventHandlerWithWrongSuffix(object sender, EventArgs e);
+		public event IncorrectEventHandlerWithWrongSuffix IncorrectEvent;
+		protected virtual void OnIncorrectEvent(EventArgs e)
+		{
+			if (IncorrectEvent != null) {
+				IncorrectEvent(this, e);
+			}
+		}
+		
+		[Test]
+		public void TestIncorrectEventHandler()
+		{
+			EventHandlerSuffixIsEventHandler eventHandlerSuffixIsEventHandler = new EventHandlerSuffixIsEventHandler();
+			EventInfo evnt = this.GetType().GetEvent(&quot;IncorrectEvent&quot;);
+			Assertion.AssertNotNull(&quot;Type name is &gt;&quot; + evnt.EventHandlerType.FullName + &quot;&lt;&quot;, eventHandlerSuffixIsEventHandler.Check(evnt));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ExceptionSuffixIsExceptionRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,75 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of ExceptionSuffixIsException.	
+	/// &lt;/summary&gt;
+	public class ExceptionSuffixIsExceptionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ExceptionSuffixIsException.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ExceptionSuffixIsException.Details}&quot;;
+			}
+		}
+		
+		public ExceptionSuffixIsExceptionRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.Exception).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Exception&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ExceptionSuffixIsException.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class ExceptionSuffixIsExceptionRuleTest
+	{
+		class MyException : System.Exception
+		{
+		}
+		[Test]
+		public void TestCorrectException()
+		{
+			ExceptionSuffixIsExceptionRule rule = new ExceptionSuffixIsExceptionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyException)));
+		}
+		
+		class MyExcpt : System.Exception
+		{
+		}
+		[Test]
+		public void TestIncorrectException()
+		{
+			ExceptionSuffixIsExceptionRule rule = new ExceptionSuffixIsExceptionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(MyExcpt)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/FlagEnumerationsArePlural.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/FlagEnumerationsArePlural.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/FlagEnumerationsArePlural.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,83 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class FlagEnumerationsArePlural : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.FlagEnumerationsArePlural.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.FlagEnumerationsArePlural.Details}&quot;;
+			}
+		}
+		
+		public FlagEnumerationsArePlural()
+		{
+			base.certainty = 75;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsSubclassOf(typeof(System.Enum)) &amp;&amp; type.IsDefined(typeof(System.FlagsAttribute), true)) {
+				if (!type.Name.EndsWith(&quot;s&quot;) &amp;&amp; !type.Name.EndsWith(&quot;ae&quot;) &amp;&amp; !type.Name.EndsWith(&quot;i&quot;)) {
+ 					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.FlagEnumerationsArePlural.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+				}
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class FlagEnumerationsArePluralTest
+	{
+		[Flags()]
+		enum CorrectFlags { a, b, c}
+		[Flags()]
+		enum CorrectNovae { Type1, Type2}
+		[Flags()]
+		enum CorrectSpaghetti { Bolognese, Napoli}
+		
+		[Test]
+		public void TestCorrectPluralEnums()
+		{
+			FlagEnumerationsArePlural elagEnumerationsArePlural = new FlagEnumerationsArePlural();
+			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectFlags)));
+			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectNovae)));
+			Assertion.AssertNull(elagEnumerationsArePlural.Check(typeof(CorrectSpaghetti)));
+		}
+		
+		[Flags()]
+		enum SomeFlag { Bolognese, Napoli}
+		
+		[Test]
+		public void TestIncorrectPluralEnums()
+		{
+			FlagEnumerationsArePlural elagEnumerationsArePlural = new FlagEnumerationsArePlural();
+			Assertion.AssertNotNull(elagEnumerationsArePlural.Check(typeof(SomeFlag)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/InterfacesPrefixIsI.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/InterfacesPrefixIsI.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/InterfacesPrefixIsI.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,78 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class InterfacesPrefixIsI : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfacesPrefixIsI.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfacesPrefixIsI.Details}&quot;;
+			}
+		}
+		
+		public InterfacesPrefixIsI()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.IsInterface &amp;&amp; !type.Name.StartsWith(&quot;I&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.InterfacesPrefixIsI.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class InterfacesPrefixIsITest
+	{
+		interface ICorrectInterface
+		{
+		}
+		[Test]
+		public void TestCorrectAttribute()
+		{
+			InterfacesPrefixIsI interfacesPrefixIsI = new InterfacesPrefixIsI();
+			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(System.ICloneable)));
+			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(System.IComparable)));
+			Assertion.AssertNull(interfacesPrefixIsI.Check(typeof(ICorrectInterface)));
+		}
+		
+		interface WrongInterface
+		{
+		}
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			InterfacesPrefixIsI interfacesPrefixIsI = new InterfacesPrefixIsI();
+			Assertion.AssertNotNull(interfacesPrefixIsI.Check(typeof(WrongInterface)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersArePascalCased.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersArePascalCased.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersArePascalCased.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,59 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class MembersArePascalCased : AbstractReflectionRule, IMemberRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersArePascalCased.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersArePascalCased.Details}&quot;;
+			}
+		}
+		
+		public MembersArePascalCased()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Module module, MemberInfo member)
+		{
+			if (member is FieldInfo || member is ConstructorInfo) {
+				return null;
+			}
+			if (member is MethodInfo) {
+				MethodInfo mi = (MethodInfo)member;
+				if (mi.IsSpecialName) {
+					return null;
+				}
+			}
+			
+			if (!NamingUtilities.IsPascalCase(member.Name)) {
+				return new Resolution(this, 
+				                      &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersArePascalCased.Resolution}&quot;,
+				                      NamingUtilities.Combine(member.DeclaringType.FullName, member.Name),
+				                      new string[,] { 
+				                      	{&quot;MemberName&quot;, member.Name}, 
+				                      	{&quot;DeclaringType&quot;, member.DeclaringType.FullName}, 
+				                      	{&quot;AlternateName&quot;, NamingUtilities.PascalCase(member.Name)}});
+			}
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersDoNotContainUnderscores.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersDoNotContainUnderscores.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembersDoNotContainUnderscores.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,54 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class MembersDoNotContainUnderscores : AbstractReflectionRule, IMemberRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersDoNotContainUnderscores.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersDoNotContainUnderscores.Details}&quot;;
+			}
+		}
+		
+		public MembersDoNotContainUnderscores()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Module module, MemberInfo member)
+		{
+			if (member is FieldInfo || member is ConstructorInfo) {
+				return null;
+			}
+			if (member is MethodInfo) {
+				MethodInfo mi = (MethodInfo)member;
+				if (mi.IsSpecialName) {
+					return null;
+				}
+			}
+			
+			if (NamingUtilities.ContainsUnderscore(member.Name)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembersDoNotContainUnderscores.Resolution}&quot;, NamingUtilities.Combine(member.ReflectedType.FullName, member.Name), new string[,] { {&quot;MemberName&quot;, member.Name}, {&quot;DeclaringType&quot;, member.DeclaringType.FullName} });
+			}
+			
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/MembershipConditionNamesSuffixIsMembershipCondition.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,110 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class MembershipConditionNamesSuffixIsMembershipCondition : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembershipConditionNamesSuffixIsMembershipCondition.Description}&quot;;
+			}
+		}
+		
+		// System.Attribute
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembershipConditionNamesSuffixIsMembershipCondition.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.Security.Policy.IMembershipCondition).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;MembershipCondition&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.MembershipConditionNamesSuffixIsMembershipCondition.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class MembershipConditionNamesSuffixIsMembershipConditionTest
+	{
+		class MyClass 
+		{
+		}
+		[Test]
+		public void TestCorrectMembershipCondition()
+		{
+			MembershipConditionNamesSuffixIsMembershipCondition membershipConditionNamesSuffixIsMembershipCondition = new MembershipConditionNamesSuffixIsMembershipCondition();
+			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(System.Security.Policy.AllMembershipCondition)));
+			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(System.Security.Policy.ZoneMembershipCondition)));
+			Assertion.AssertNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(MyClass)));
+		}
+		
+		class MyClass2 : System.Security.Policy.IMembershipCondition
+		{
+			#region System.Security.ISecurityEncodable interface implementation
+			public void FromXml(System.Security.SecurityElement e)
+			{
+				
+			}
+			
+			public System.Security.SecurityElement ToXml()
+			{
+				return null;
+			}
+			#endregion
+			
+			#region System.Security.ISecurityPolicyEncodable interface implementation
+			public void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level)
+			{
+				
+			}
+			
+			public System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level)
+			{
+				return null;
+			}
+			#endregion
+			
+			#region System.Security.Policy.IMembershipCondition interface implementation
+			public System.Security.Policy.IMembershipCondition Copy()
+			{
+				return null;
+			}
+			
+			public bool Check(System.Security.Policy.Evidence evidence)
+			{
+				return false;
+			}
+			#endregion
+		}
+		
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			MembershipConditionNamesSuffixIsMembershipCondition membershipConditionNamesSuffixIsMembershipCondition = new MembershipConditionNamesSuffixIsMembershipCondition();
+			Assertion.AssertNotNull(membershipConditionNamesSuffixIsMembershipCondition.Check(typeof(MyClass2)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesArePascalCased.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesArePascalCased.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesArePascalCased.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,79 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of NamespacesArePascalCased.	
+	/// &lt;/summary&gt;
+	public class NamespacesArePascalCased : AbstractReflectionRule, INamespaceRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesArePascalCased.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesArePascalCased.Details}&quot;;
+			}
+		}
+		
+		public NamespacesArePascalCased()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(string namespaceName, ICollection types)
+		{
+			string[] namespaces = namespaceName.Split('.');
+			foreach (string name in namespaces) {
+				if (!NamingUtilities.IsPascalCase(name)) {
+					for (int i = 0; i &lt; namespaces.Length; ++i) {
+						namespaces[i] = NamingUtilities.PascalCase(namespaces[i]);
+					}
+					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesArePascalCased.Resolution}&quot;, namespaceName, new string[,]{{&quot;NamespaceName&quot;, namespaceName}, {&quot;AlternateName&quot;, String.Join(&quot;.&quot;, namespaces) }});
+				}
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class NamespacesArePascalCasedTest
+	{
+		[Test]
+		public void TestCorrectNamespaces()
+		{
+			NamespacesArePascalCased namespacesArePascalCased = new NamespacesArePascalCased();
+			Assertion.AssertNull(&quot;Empty Namespace&quot;, namespacesArePascalCased.Check(&quot;&quot;, null));
+			Assertion.AssertNull(&quot;Single Namespace&quot;, namespacesArePascalCased.Check(&quot;MyNamespace&quot;, null));
+			Assertion.AssertNull(&quot;Complex Namespace&quot;, namespacesArePascalCased.Check(&quot;System.Windows.Form&quot;, null));
+		}
+		
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			NamespacesArePascalCased namespacesArePascalCased = new NamespacesArePascalCased();
+			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;a&quot;, null));
+			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;A.Namespace.isWrong&quot;, null));
+			Assertion.AssertNotNull(namespacesArePascalCased.Check(&quot;System.windows.Form&quot;, null));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesDoNotContainUnderscores.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesDoNotContainUnderscores.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/NamespacesDoNotContainUnderscores.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,73 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of NamespacesArePascalCased.	
+	/// &lt;/summary&gt;
+	public class NamespacesDoNotContainUnderscores : AbstractReflectionRule, INamespaceRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesDoNotContainUnderscores.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesDoNotContainUnderscores.Details}&quot;;
+			}
+		}
+		
+		public NamespacesDoNotContainUnderscores()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(string namespaceName, ICollection types)
+		{
+			if (NamingUtilities.ContainsUnderscore(namespaceName)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.NamespacesDoNotContainUnderscores.Resolution}&quot;, namespaceName, new string[,]{{&quot;NamespaceName&quot;, namespaceName}});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class NamespacesDoNotContainUnderscoresTest
+	{
+		[Test]
+		public void TestCorrectNamespaces()
+		{
+			NamespacesDoNotContainUnderscores rule = new NamespacesDoNotContainUnderscores();
+			Assertion.AssertNull(&quot;Empty Namespace&quot;, rule.Check(&quot;&quot;, null));
+			Assertion.AssertNull(&quot;Single Namespace&quot;, rule.Check(&quot;MyNamespace&quot;, null));
+			Assertion.AssertNull(&quot;Complex Namespace&quot;, rule.Check(&quot;System.Windows.Form&quot;, null));
+		}
+		
+		[Test]
+		public void TestIncorrectNamespaces()
+		{
+			NamespacesDoNotContainUnderscores rule = new NamespacesDoNotContainUnderscores();
+			Assertion.AssertNotNull(rule.Check(&quot;_&quot;, null));
+			Assertion.AssertNotNull(rule.Check(&quot;A.Namespace.isWrong_&quot;, null));
+			Assertion.AssertNotNull(rule.Check(&quot;System._Windows.Form&quot;, null));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyAttributesSuffixAttributeRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,80 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyAttributesSuffixAttribute.	
+	/// &lt;/summary&gt;
+	public class OnlyAttributesSuffixAttributeRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyAttributesSuffixAttribute.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyAttributesSuffixAttribute.Details}&quot;;
+			}
+		}
+		
+		public OnlyAttributesSuffixAttributeRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!type.IsSubclassOf(typeof(System.Attribute)) &amp;&amp; type.Name.EndsWith(&quot;Attribute&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyAttributesSuffixAttribute.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyAttributesSuffixAttributeTest
+	{
+		class MyOtherClass
+		{
+		}
+		class RealAttribute : System.Attribute
+		{
+		}
+		[Test]
+		public void TestCorrectAttribute()
+		{
+			OnlyAttributesSuffixAttributeRule rule = new OnlyAttributesSuffixAttributeRule();
+			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
+			Assertion.AssertNull(rule.Check(typeof(RealAttribute)));
+		}
+		
+		class MyAttribute
+		{
+		}
+		[Test]
+		public void TestIncorrectAttribute()
+		{
+			OnlyAttributesSuffixAttributeRule rule = new OnlyAttributesSuffixAttributeRule();
+			Assertion.AssertNotNull(rule.Check(typeof(MyAttribute)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyCollectionsSuffixCollectionRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,133 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of CheckCollectionSuffix.	
+	/// &lt;/summary&gt;
+	public class OnlyCollectionsSuffixCollectionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Details}&quot;;
+			}
+		}
+		
+		public OnlyCollectionsSuffixCollectionRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(ICollection).IsAssignableFrom(type) &amp;&amp; !typeof(IEnumerable).IsAssignableFrom(type)) {
+				if (!typeof(Queue).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Queue&quot;)) {
+					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Resolution1}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+				} else if (!typeof(Stack).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Stack&quot;)) {
+					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Resolution2}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+				} else if (type.Name.EndsWith(&quot;Collection&quot;)) {
+					return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyCollectionsSuffixCollection.Resolution3}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+				}
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyCollectionsSuffixCollectionRuleTest
+	{
+		#region Collection suffix tests
+		class MyCollection : System.Collections.ArrayList
+		{
+		}
+		class OtherClass 
+		{
+		}
+		[Test]
+		public void TestCorrectCollection()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyCollection)));
+			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
+		}
+		
+		class My2Collection
+		{
+		}
+		[Test]
+		public void TestIncorrectCollection()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(My2Collection)));
+		}
+		#endregion
+		
+		#region Queue suffix tests
+		class MyQueue : System.Collections.Queue
+		{
+		}
+		[Test]
+		public void TestCorrectQueue()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyQueue)));
+		}
+		
+		class My2Queue
+		{
+		}
+		[Test]
+		public void TestIncorrectQueue()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(My2Queue)));
+		}
+		#endregion 
+		
+		#region Stack suffix tests
+		class MyStack : System.Collections.Stack
+		{
+		}
+		[Test]
+		public void TestCorrectStack()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyStack)));
+		}
+		
+		class My2Stack
+		{
+		}
+		[Test]
+		public void TestIncorrectStack()
+		{
+			OnlyCollectionsSuffixCollectionRule rule = new OnlyCollectionsSuffixCollectionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(My2Stack)));
+		}
+		#endregion
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventArgsSuffixEventArgsRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,85 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyEventArgsSuffixEventArgsRule.	
+	/// &lt;/summary&gt;
+	public class OnlyEventArgsSuffixEventArgsRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventArgsSuffixEventArgs.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventArgsSuffixEventArgs.Details}&quot;;
+			}
+		}
+		
+		public OnlyEventArgsSuffixEventArgsRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(System.EventArgs).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;EventArgs&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventArgsSuffixEventArgs.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyEventArgsSuffixEventArgsRuleTest
+	{
+		class CorrectEventArgs : System.EventArgs
+		{
+		}
+		class OtherClass
+		{
+		}
+		class MyEventArgs : CorrectEventArgs
+		{
+		}
+		[Test]
+		public void TestCorrectEventArgs()
+		{
+			OnlyEventArgsSuffixEventArgsRule rule = new OnlyEventArgsSuffixEventArgsRule();
+			Assertion.AssertNull(rule.Check(typeof(CorrectEventArgs)));
+			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
+			Assertion.AssertNull(rule.Check(typeof(MyEventArgs)));
+		}
+		
+		class IncorrectEventArgs
+		{
+		}
+		[Test]
+		public void TestIncorrectEventArgs()
+		{
+			OnlyEventArgsSuffixEventArgsRule rule = new OnlyEventArgsSuffixEventArgsRule();
+			Assertion.AssertNotNull(rule.Check(typeof(IncorrectEventArgs)));
+		}
+		
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyEventHandlerSuffixIsEventHandlerRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,50 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyEventHandlerSuffixIsEventHandlerRule.	
+	/// &lt;/summary&gt;
+	public class OnlyEventHandlerSuffixIsEventHandlerRule : AbstractReflectionRule, IMemberRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventHandlerSuffixIsEventHandler.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventHandlerSuffixIsEventHandler.Details}&quot;;
+			}
+		}
+		
+		public OnlyEventHandlerSuffixIsEventHandlerRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Module module, MemberInfo member)
+		{
+			if (member is MethodInfo) {
+				MethodInfo mi = (MethodInfo)member;
+				if (mi.IsSpecialName) {
+					return null;
+				}
+			}
+			if (member.Name.EndsWith(&quot;EventHandler&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyEventHandlerSuffixIsEventHandler.Resolution}&quot;, NamingUtilities.Combine(member.ReflectedType.FullName, member.Name), new string[,] { {&quot;MemberName&quot;, member.Name}, {&quot;DeclaringType&quot;, member.DeclaringType.FullName} });
+			}
+			return null;
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyExceptionsSuffixExceptionRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,80 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyExceptionsSuffixExceptionRule.	
+	/// &lt;/summary&gt;
+	public class OnlyExceptionsSuffixExceptionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyExceptionsSuffixException.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyExceptionsSuffixException.Details}&quot;;
+			}
+		}
+		
+		public OnlyExceptionsSuffixExceptionRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(System.Exception).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Exception&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyExceptionsSuffixException.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyExceptionsSuffixExceptionRuleTest
+	{
+		class MyException : System.Exception
+		{
+		}
+		class OtherClass
+		{}
+		[Test]
+		public void TestCorrectException()
+		{
+			OnlyExceptionsSuffixExceptionRule rule = new OnlyExceptionsSuffixExceptionRule();
+			Assertion.AssertNull(rule.Check(typeof(MyException)));
+			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
+		}
+		
+		class NotAnException
+		{
+		}
+		[Test]
+		public void TestIncorrectException()
+		{
+			OnlyExceptionsSuffixExceptionRule rule = new OnlyExceptionsSuffixExceptionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(NotAnException)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyPermissionsSuffixPermissionRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,77 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyExceptionsSuffixException.	
+	/// &lt;/summary&gt;
+	public class OnlyPermissionsSuffixPermissionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyPermissionsSuffixPermission.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyPermissionsSuffixPermission.Details}&quot;;
+			}
+		}
+		
+		public OnlyPermissionsSuffixPermissionRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(System.Security.IPermission).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Permission&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyPermissionsSuffixPermission.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyPermissionsSuffixPermissionRuleTest
+	{
+		class OtherClass
+		{}
+		[Test]
+		public void TestCorrectPermission()
+		{
+			OnlyPermissionsSuffixPermissionRule rule = new OnlyPermissionsSuffixPermissionRule();
+			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.EnvironmentPermission)));
+			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.FileIOPermission)));
+			Assertion.AssertNull(rule.Check(typeof(OtherClass)));
+		}
+		
+		class NotAnPermission
+		{
+		}
+		[Test]
+		public void TestIncorrectPermission()
+		{
+			OnlyPermissionsSuffixPermissionRule rule = new OnlyPermissionsSuffixPermissionRule();
+			Assertion.AssertNotNull(rule.Check(typeof(NotAnPermission)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/OnlyStreamsSuffixStreamRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,84 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of OnlyStreamsSuffixStreamRule.	
+	/// &lt;/summary&gt;
+	public class OnlyStreamsSuffixStreamRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyStreamsSuffixStream.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyStreamsSuffixStream.Details}&quot;;
+			}
+		}
+		
+		public OnlyStreamsSuffixStreamRule()
+		{
+			base.certainty = 99;
+			base.priorityLevel = PriorityLevel.CriticalError;
+		}
+		
+		
+		public Resolution Check(Type type)
+		{
+			if (!typeof(System.IO.Stream).IsAssignableFrom(type) &amp;&amp; type.Name.EndsWith(&quot;Stream&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.OnlyStreamsSuffixStream.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using System.IO;
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class OnlyStreamsSuffixStreamRuleTest
+	{
+		class MyOtherClass
+		{
+		}
+		class RealStream : System.IO.FileStream  
+		{
+			public RealStream(string path,FileMode mode) : base(path, mode)
+			{}
+		}
+		[Test]
+		public void TestCorrectStream()
+		{
+			OnlyStreamsSuffixStreamRule rule = new OnlyStreamsSuffixStreamRule();
+			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
+			Assertion.AssertNull(rule.Check(typeof(RealStream)));
+		}
+		
+		class MyStream
+		{
+		}
+		[Test]
+		public void TestIncorrectStream()
+		{
+			OnlyStreamsSuffixStreamRule rule = new OnlyStreamsSuffixStreamRule();
+			Assertion.AssertNotNull(rule.Check(typeof(MyStream)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParameterNamesDoNotHaveUnderscores.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,98 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+using System.Collections;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of ParameterNamesDoNotHaveUnderscores.	
+	/// &lt;/summary&gt;
+	public class ParameterNamesDoNotHaveUnderscores : AbstractReflectionRule, IParameterRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParameterNamesDoNotHaveUnderscores.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParameterNamesDoNotHaveUnderscores.Details}&quot;;
+			}
+		}
+		
+		public ParameterNamesDoNotHaveUnderscores()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Module module, ParameterInfo param)
+		{
+			if (param.Name != null &amp;&amp; param.Name.IndexOf('_') &gt;= 0) {
+				string memberName = NamingUtilities.Combine(param.Member.DeclaringType.FullName, param.Member.Name);
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParameterNamesDoNotHaveUnderscores.Resolution}&quot;, memberName, new string[,] {{&quot;ParameterName&quot;, param.Name}, {&quot;MemberName&quot;, memberName}});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class ParameterNamesDoNotHaveUnderscoresTest
+	{
+		public class A {
+			public void TestMethod1(int right)
+			{
+			}
+			public void TestMethod2(int a, int b, int c, int d)
+			{
+			}
+			public void TestMethod3(int wrong_)
+			{
+			}
+			public void TestMethod4(int _a, int b_c, int ____, int wrong_)
+			{
+			}
+			public static void TestMethod(MethodInfo methodInfo, bool isNull)
+			{
+				ParameterNamesDoNotHaveUnderscores parameterNamesDoNotHaveUnderscores = new ParameterNamesDoNotHaveUnderscores();
+				foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
+					if (isNull) {
+						Assertion.AssertNull(parameterNamesDoNotHaveUnderscores.Check(null, parameter));
+					} else {
+						Assertion.AssertNotNull(parameterNamesDoNotHaveUnderscores.Check(null, parameter));
+					}
+				}
+			}
+		}
+		
+		
+		[Test]
+		public void TestCorrectParameters()
+		{
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod1&quot;), true);
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod2&quot;), true);
+		}
+		
+		[Test]
+		public void TestIncorrectParameters()
+		{
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod3&quot;), false);
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod4&quot;), false);
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParametersAreCamelCased.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParametersAreCamelCased.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/ParametersAreCamelCased.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,98 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+using System.Collections;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of NamespacesArePascalCased.	
+	/// &lt;/summary&gt;
+	public class ParametersAreCamelCased : AbstractReflectionRule, IParameterRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParametersAreCamelCased.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParametersAreCamelCased.Details}&quot;;
+			}
+		}
+		
+		public ParametersAreCamelCased()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Module module, ParameterInfo param)
+		{
+			if (!NamingUtilities.IsCamelCase(param.Name)) {
+				string memberName = NamingUtilities.Combine(param.Member.DeclaringType.FullName, param.Member.Name);
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.ParametersAreCamelCased.Resolution}&quot;, memberName, new string[,] {{&quot;ParameterName&quot;, param.Name}, {&quot;MemberName&quot;, memberName}, {&quot;AlternateName&quot;, NamingUtilities.CamelCase(param.Name)}});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class ParametersAreCamelCasedTest
+	{
+		public class A {
+			public void TestMethod1(int right)
+			{
+			}
+			public void TestMethod2(int a, int b, int c, int d)
+			{
+			}
+			public void TestMethod3(int Wrong)
+			{
+			}
+			public void TestMethod4(int A, int B, int C, int D)
+			{
+			}
+			public static void TestMethod(MethodInfo methodInfo, bool isNull)
+			{
+				ParametersAreCamelCased parametersAreCamelCased = new ParametersAreCamelCased();
+				foreach (ParameterInfo parameter in methodInfo.GetParameters()) {
+					if (isNull) {
+						Assertion.AssertNull(parametersAreCamelCased.Check(null, parameter));
+					} else {
+						Assertion.AssertNotNull(parametersAreCamelCased.Check(null, parameter));
+					}
+				}
+			}
+		}
+		
+		
+		[Test]
+		public void TestCorrectParameters()
+		{
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod1&quot;), true);
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod2&quot;), true);
+		}
+		
+		[Test]
+		public void TestIncorrectParameters()
+		{
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod3&quot;), false);
+			A.TestMethod(typeof(A).GetMethod(&quot;TestMethod4&quot;), false);
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/PermissionSuffixIsPermissionRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/PermissionSuffixIsPermissionRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/PermissionSuffixIsPermissionRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,62 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of PermissionSuffixIsPermissionRule.	
+	/// &lt;/summary&gt;
+	public class PermissionSuffixIsPermissionRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PermissionSuffixIsPermission.Description}&quot;;
+			}
+		}
+		
+		// System.Attribute
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PermissionSuffixIsPermission.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.Security.IPermission).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Permission&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.PermissionSuffixIsPermission.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class PermissionSuffixIsPermissionRuleTest
+	{
+		[Test]
+		public void TestCorrectPermission()
+		{
+			PermissionSuffixIsPermissionRule rule = new PermissionSuffixIsPermissionRule();
+			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.EnvironmentPermission)));
+			Assertion.AssertNull(rule.Check(typeof(System.Security.Permissions.FileIOPermission)));
+			Assertion.AssertNull(rule.Check(typeof(PermissionSuffixIsPermissionRuleTest)));
+		}
+		
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/StreamSuffixIsStreamRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/StreamSuffixIsStreamRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/StreamSuffixIsStreamRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,84 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of StreamSuffixIsStreamRule.	
+	/// &lt;/summary&gt;
+	public class StreamSuffixIsStreamRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.StreamSuffixIsStream.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.StreamSuffixIsStream.Details}&quot;;
+			}
+		}
+		
+		public StreamSuffixIsStreamRule()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (typeof(System.IO.Stream).IsAssignableFrom(type) &amp;&amp; !type.Name.EndsWith(&quot;Stream&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.StreamSuffixIsStream.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using System.IO;
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class StreamSuffixIsStreamRuleTest
+	{
+		class MyOtherClass
+		{
+		}
+		class RealStream : System.IO.FileStream  
+		{
+			public RealStream(string path,FileMode mode) : base(path, mode)
+			{}
+		}
+		[Test]
+		public void TestCorrectStream()
+		{
+			StreamSuffixIsStreamRule rule = new StreamSuffixIsStreamRule();
+			Assertion.AssertNull(rule.Check(typeof(MyOtherClass)));
+			Assertion.AssertNull(rule.Check(typeof(RealStream)));
+		}
+		
+		class WrongStrm : System.IO.FileStream  
+		{
+			public WrongStrm(string path,FileMode mode) : base(path, mode)
+			{}
+		}
+		[Test]
+		public void TestIncorrectStream()
+		{
+			StreamSuffixIsStreamRule rule = new StreamSuffixIsStreamRule();
+			Assertion.AssertNotNull(rule.Check(typeof(WrongStrm)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypeNamesDoNotContainUnderscores.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,75 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class TypeNamesDoNotContainUnderscores : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypeNamesDoNotContainUnderscores.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypeNamesDoNotContainUnderscores.Details}&quot;;
+			}
+		}
+		
+		public TypeNamesDoNotContainUnderscores()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (NamingUtilities.ContainsUnderscore(type.Name)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypeNamesDoNotContainUnderscores.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypeNamesDoNotContainUnderscoresTest
+	{
+		interface ICorrectInterface
+		{
+		}
+		[Test]
+		public void TestCorrectTypenames()
+		{
+			TypeNamesDoNotContainUnderscores typeNamesDoNotContainUnderscores = new TypeNamesDoNotContainUnderscores();
+			Assertion.AssertNull(typeNamesDoNotContainUnderscores.Check(typeof(ICorrectInterface)));
+		}
+		
+		class Wrong_Class
+		{
+		}
+		[Test]
+		public void TestIncorrectTypenames()
+		{
+			TypeNamesDoNotContainUnderscores typeNamesDoNotContainUnderscores = new TypeNamesDoNotContainUnderscores();
+			Assertion.AssertNotNull(typeNamesDoNotContainUnderscores.Check(typeof(Wrong_Class)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesArePascalCased.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesArePascalCased.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesArePascalCased.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,81 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of AttributeSuffixIsAttribute.	
+	/// &lt;/summary&gt;
+	public class TypesArePascalCased : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesArePascalCased.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesArePascalCased.Details}&quot;;
+			}
+		}
+		
+		public TypesArePascalCased()
+		{
+			base.certainty = 99;
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (!NamingUtilities.IsPascalCase(type.Name)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesArePascalCased.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }, {&quot;AlternateName&quot;, NamingUtilities.PascalCase(type.Name)}});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypesArePascalCasedTest
+	{
+		interface IInterface
+		{
+		}
+		class AClassImplTest
+		{
+			
+		}
+		[Test]
+		public void TestCorrectTypenames()
+		{
+			TypesArePascalCased typesArePascalCased = new TypesArePascalCased();
+			Assertion.AssertNull(typesArePascalCased.Check(typeof(IInterface)));
+			Assertion.AssertNull(typesArePascalCased.Check(typeof(AClassImplTest)));
+		}
+		
+		class wrong
+		{
+			
+		}
+		[Test]
+		public void TestIncorrectTypenames()
+		{
+			TypesArePascalCased typesArePascalCased = new TypesArePascalCased();
+			Assertion.AssertNotNull(typesArePascalCased.Check(typeof(wrong)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingRules/TypesImplementingInterfacesHaveNoSuffixImplRule.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,75 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of TypesImplementingInterfacesHaveNoSuffixImplRule.	
+	/// &lt;/summary&gt;
+	public class TypesImplementingInterfacesHaveNoSuffixImplRule : AbstractReflectionRule, ITypeRule
+	{
+		public override string Description {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesImplementingInterfacesHaveNoSuffixImpl.Description}&quot;;
+			}
+		}
+		
+		public override string Details {
+			get {
+				return &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesImplementingInterfacesHaveNoSuffixImpl.Details}&quot;;
+			}
+		}
+		
+		public Resolution Check(Type type)
+		{
+			if (type.GetInterfaces().Length &gt; 0 &amp;&amp; type.Name.EndsWith(&quot;Impl&quot;)) {
+				return new Resolution(this, &quot;${res:MonoDevelop.AssemblyAnalyser.Rules.TypesImplementingInterfacesHaveNoSuffixImpl.Resolution}&quot;, type.FullName, new string[,] { { &quot;TypeName&quot;, type.FullName }});
+			}
+			return null;
+		}
+	}
+}
+#region Unit Test
+#if TEST
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	using NUnit.Framework;
+
+	[TestFixture]
+	public class TypesImplementingInterfacesHaveNoSuffixImplRuleTest
+	{
+		interface IInterface
+		{
+		}
+		class AClassImplTest : IInterface
+		{
+			
+		}
+		[Test]
+		public void TestCorrectTypenames()
+		{
+			TypesImplementingInterfacesHaveNoSuffixImplRule rule = new TypesImplementingInterfacesHaveNoSuffixImplRule();
+			Assertion.AssertNull(rule.Check(typeof(AClassImplTest)));
+		}
+		
+		class BImpl : IInterface
+		{
+			
+		}
+		[Test]
+		public void TestIncorrectTypenames()
+		{
+			TypesImplementingInterfacesHaveNoSuffixImplRule rule = new TypesImplementingInterfacesHaveNoSuffixImplRule();
+			Assertion.AssertNotNull(rule.Check(typeof(BImpl)));
+		}
+	}
+}
+#endif
+#endregion

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingUtilities.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingUtilities.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/NamingUtilities.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,73 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of NamingUtilities.	
+	/// &lt;/summary&gt;
+	public sealed class NamingUtilities
+	{
+		/// &lt;summary&gt;
+		/// Pascal casing is like 'PascalCase'
+		/// &lt;/summary&gt;
+		public static bool IsPascalCase(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return true;
+			}
+			return Char.IsUpper(name[0]);
+		}
+		
+		public static string PascalCase(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return name;
+			}
+			return Char.ToUpper(name[0]) + name.Substring(1);
+		}
+		
+		
+		/// &lt;summary&gt;
+		/// Camel casing is like 'camelCase'
+		/// &lt;/summary&gt;
+		public static bool IsCamelCase(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return true;
+			}
+			return Char.IsLower(name[0]);
+		}
+		
+		
+		public static string CamelCase(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return name;
+			}
+			return Char.ToLower(name[0]) + name.Substring(1);
+		}
+		
+		public static bool ContainsUnderscore(string name)
+		{
+			if (name == null || name.Length == 0) {
+				return false;
+			}
+			return name.IndexOf('_') &gt;= 0;
+		}
+		
+		public static string Combine(string typeName, string memberName)
+		{
+			return String.Concat(typeName, 
+			                     '.',
+			                     memberName);
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/PriorityLevel.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/PriorityLevel.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/PriorityLevel.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,24 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	/// &lt;summary&gt;
+	/// Description of IAssemblyRule.	
+	/// &lt;/summary&gt;
+	public enum PriorityLevel
+	{
+		Information,
+		Warning,
+		CriticalWarning,
+		Error,
+		CriticalError
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ProtectionLevels.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ProtectionLevels.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/Rules/ProtectionLevels.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,35 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.AssemblyAnalyser.Rules
+{
+	[Flags]
+	public enum ProtectionLevels
+	{
+		None = 0,
+		
+		Public   = 1,
+		Family   = 2,
+		Private  = 4,
+		Assembly = 8,
+		FamilyAndAssembly = 16,
+		FamilyOrAssembly  = 32,
+		
+		NestedPublic   = 64,
+		NestedFamily   = 128,
+		NestedPrivate  = 256,
+		NestedAssembly = 512,
+		NestedFamilyAndAssembly = 1024,
+		NestedFamilyOrAssembly = 2048,
+		
+		All = Public | Family | Private | Assembly | FamilyAndAssembly | FamilyOrAssembly |
+		      NestedPublic | NestedFamily | NestedPrivate | NestedAssembly | NestedFamilyAndAssembly | NestedFamilyOrAssembly,
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/TODO.txt
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/TODO.txt	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer/TODO.txt	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,206 @@
+Goal:
+Basically 're-invent' FxCop (a very, very good no cost tool from Microsoft)
+
+Todo:
+Translate all FxCop rules to Assembly Analyser and write a unit test that tests
+the rule in action (except maybe 'Assembly' and 'Module' rules.
+
+Status (FxCop rules):
+
+DesignRules:
+	* AbstractTypesShouldNotHaveConstructors IS AbstractTypesPublicConstructors
+AddAndSubtractOverrideShouldHaveOperatorEqualsOverride
+	* AssembliesAreMarkedClsCompliant IS AssemblyClsCompliantRule
+	* AssembliesHaveStrongNames IS AssemblyStrongName
+	* AssembliesHaveVersionNumbers IS AssemblyVersionNumber
+AssembliesShouldBeComVisibleAttributed
+AttributesAreAttributeUsageAttributed
+AttributesShouldHaveAccessorsForAllArguments
+AvoidDefaultConstructorForStructures
+AvoidMarkingMembersObsolete
+AvoidMarkingTypesObsolete
+	* AvoidNamespacesWithFewMembers IS AvoidNamespacesWithFewMembers
+AvoidOutParameters
+AvoidValueTypesPassedAsByRefParameters
+ConsiderHavingOnlyOneDimensionForIndexer
+ConsiderReplacingMethodsWithProperties
+ConsiderReplacingRepetitiveArgsWithParameterArray
+DefaultParametersAreNotUsed
+EnumerationsShouldBeFlagsAttributed
+EnumerationsShouldBeInt32
+EnumerationsShouldBeIntegralType
+	* EventFirstParametersAreTypeObject IS EventFirstParameterIsObject
+	* EventHandlersReturnVoid IS EventHandlersReturnVoid
+	* EventSecondParametersAreEventArgsType IS EventSecondParameterIsEventArgs
+	* EventsHaveTwoParameters IS EventsHaveTwoParameters
+EventsShouldBeUsed
+ExceptionAndSystemExceptionTypesAreNotCaught
+ExceptionsRequireMultipleConstructors
+ExplicitMethodImplementationsInUnsealedClassesHaveVisibleAlternates
+ExternallyVisibleNestedTypesShouldNotBeUsed
+ICollectionImplementationsHaveStronglyTypedMembers
+IComparableImplementationsOverrideEquals
+IComparableImplementationsOverrideOperators
+IEnumeratorImplementationsHaveStronglyTypedMembers
+IListImplementationsHaveStronglyTypedMembers
+	* InterfacesShouldNotBeEmpty IS InterfaceNotEmpty
+ISerializableTypesAreMarkedSerializable
+ObsoleteAttributeOnMemberShouldProvideMessage
+ObsoleteAttributeOnTypeShouldProvideMessage
+OnlyIntegralValuesOrStringsShouldBeUsedForIndexers
+PointersAndMultiDimensionalArraysAreNotPassedAsParameters
+	* PropertiesShouldNotBeWriteOnly IS PropertiesShouldNotHaveSetOnly
+ReferenceTypesAreNotPassedAsByRefParameters
+ReferenceTypesShouldNotOverrideOperatorEquals
+SealedTypesDoNotDeclareProtectedMembers
+SealedTypesDoNotDeclareVirtualMembers
+TypesAllocatingUnmanagedResourcesImplementIDisposable
+	* TypesBelongToNamespaces IS TypesShouldBeInNamespaces
+	* TypesDoNotHavePublicInstanceFields IS TypesHaveNoPublicInstanceFields
+TypesHavingOnlyStaticMembersShouldBeSealed
+TypesHavingOnlyStaticMembersShouldNotHaveConstructors
+
+NamingRules:
+	* AttributeNamesHaveAttributeSuffix IS AttributeSuffixIsAttribute
+	* CollectionNamesHaveCollectionSuffix IS CheckCollectionSuffix
+	* ConditionNamesHaveConditionSuffix IS MembershipConditionNamesSuffixIsMembershipCondition (I think 'MembershipCondition' is more correct than just 'Condition', right?)
+	* DelegateNamesDoNotHaveDelegateSuffix IS DelegatesHaveNoDelegateSuffix
+	* DictionaryNamesHaveDictionarySuffix IS DictionaryTypeSuffixIsDictionary
+	* EnumerationNamesDoNotHaveEnumSuffix IS EnumsHaveNoEnumSuffix
+	* EventArgsNamesHaveEventArgsSuffix IS EventArgsSuffixIsEventArgs
+	* EventFirstParametersHaveNameSender IS EventFirstParameterNameIsSender
+	* EventHandlerNamesHaveEventHandlerSuffix IS EventHandlerSuffixIsEventHandler
+	* EventsDoNotHaveBeforeOrAfterPrefix IS EventsDoNotHaveBeforeOrAfterPrefix
+	* EventSecondParametersHaveNameE IS EventSecondParameterNameIsE
+	* ExceptionNamesHaveExceptionSuffix IS ExceptionSuffixIsException
+	* FlagEnumerationsShouldHavePluralNames IS FlagEnumerationsArePlural
+	* InterfaceNamesHaveIPrefix IS InterfacesPrefixIsI
+	* MemberNamesArePascalCased IS MembersArePascalCased
+MemberNamesDifferByMoreThanCase
+	* MemberNamesDoNotHaveUnderscores IS MembersDoNotContainUnderscores
+MemberNamesHaveOnlyShortAcronymsAllCaps
+MemberNamesHaveShortAcronymsAllCaps
+	* NamespaceNamesArePascalCased IS NamespacesArePascalCased
+NamespaceNamesDifferByMoreThanCase
+	* NamespaceNamesDoNotHaveUnderscores IS NamespacesDoNotContainUnderscores
+NamespaceNamesDoNotMatchKeywords
+NamespaceNamesHaveOnlyShortAcronymsAllCaps
+NamespaceNamesHaveShortAcronymsAllCaps
+	* OnlyAttributeNamesHaveAttributeSuffix IS OnlyAttributesSuffixAttribute
+	* OnlyCollectionNamesHaveCollectionSuffix IS OnlyCollectionsSuffixCollection
+	-&gt; OnlyDictionaryNamesHaveDictionarySuffix HANDLED IN OnlyCollectionsSuffixCollection
+	* OnlyEventArgsNamesHaveEventArgsSuffix IS OnlyEventArgsSuffixEventArgs
+	( OnlyEventHandlerNamesHaveEventHandlerSuffix is OnlyEventHandlerSuffixIsEventHandler
+	* OnlyExceptionNamesHaveExceptionSuffix IS OnlyExceptionsSuffixException
+OnlyFlagEnumerationsShouldHavePluralNames
+	* OnlyPermissionNamesHavePermissionSuffix IS OnlyPermissionsSuffixPermission
+	-&gt; OnlyQueueNamesHaveQueueSuffix HANDLED IN OnlyCollectionsSuffixCollection
+	-&gt; OnlyStackNamesHaveStackSuffix HANDLED IN OnlyCollectionsSuffixCollection
+	* OnlyStreamNamesHaveStreamSuffix IS OnlyStreamsSuffixStream
+	* ParameterNamesAreCamelCased IS ParametersAreCamelCased
+ParameterNamesDifferByMoreThanCase
+ParameterNamesDoNotContainLanguageSpecificTypeNames
+	* ParameterNamesDoNotHaveUnderscores IS ParameterNamesDoNotHaveUnderscores
+ParameterNamesDoNotMatchKeywords
+ParameterNamesDoNotMatchMemberNames
+ParameterNamesHaveOnlyShortAcronymsAllCaps
+ParameterNamesHaveShortAcronymsAllCaps
+ParameterNamesShouldHaveCompleteWords
+ParameterNamesShouldNotContainTypeNames
+	* PermissionNamesHavePermissionSuffix IS PermissionSuffixIsPermission
+PropertyNamesShouldNotMatchGetMethodNames
+	* StreamNamesHaveStreamSuffix IS StreamSuffixIsStream
+	* TypeNamesArePascalCased IS TypesArePascalCased
+TypeNamesDifferByMoreThanCase
+TypeNamesDoNotHaveCPrefix
+	* TypeNamesDoNotHaveUnderscores IS TypeNamesDoNotContainUnderscores
+TypeNamesDoNotMatchKeywords
+TypeNamesDoNotMatchNamespaceNames
+TypeNamesHaveOnlyShortAcronymsAllCaps
+TypeNamesHaveShortAcronymsAllCaps
+	* TypesImplementingInterfacesDoNotHaveImplSuffix IS TypesImplementingInterfacesHaveNoSuffixImpl
+
+
+Performance Rules:
+
+AvoidBuildingNonCallableCode
+AvoidBuildingUninstantiatedInternalClasses
+AvoidUnsealedAttributes
+ConsiderJaggedArrayInsteadOfMultiDimensionalArrayInFields
+ConsiderJaggedArrayInsteadOfMultiDimensionalArrayInMethods
+ConsiderJaggedArrayInsteadOfMultiDimensionalArrayInProperties
+ConsiderOverridingEqualsAndOperatorEqualsOnValueTypes
+DisposeMethodsCallSuppressFinalize
+PropertiesShouldNotReturnArrays
+TestForEmptyStringsUsingStringLength
+
+Security Rules:
+
+ArrayFieldsShouldNotBeReadOnly
+AssertRequiresDemand
+ConsiderPermitOnlyOrDenySecurityReview
+DemandsOnValueTypeConstructorsDoNotPreventInstantiation
+DemandsOnValueTypesDoNotPreventInstantiation
+EventHandlersRequireSecurity
+GetObjectDataIsSerializationFormatterSecurityPermissionAttributed
+IntPtrFieldsHavePrivateAccessLevel
+LinkDemandsOnTypesDoNotPreventAccessToTypeFields
+MembersDoNotSuppressUnmanagedCodeSecurity
+MembersThatCallLateBoundMembersRequireDeclarativeSecurity
+MethodLevelSecurityOverridesTypeLevelSecurity
+MethodsInTypesWithIntPtrFieldAndFinalizeMethodRequireGCKeepAlive
+PartiallyTrustedMethodsCallPartiallyTrustedMethodsOnly
+PartiallyTrustedTypesExtendPartiallyTrustedTypesOnly
+PInvokeMethodCallWithSuppressUnmanagedCodeSecurityAttributeRequiresSecurityCheck
+PublicTypesImplementingNonPublicInterfacesShouldBeSealed
+SerializationMagicConstructorsRequireSecurityCheck
+StaticConstructorsHavePrivateAccessLevel
+TypesAreNotPublicPInvokeMethodsAndSuppressUnmanagedCodeSecurityAttributed
+TypesDoNotSuppressUnmanagedCodeSecurity
+UnsealedPublicTypesDoNotHaveInternalVirtualMembers
+UnsecuredMembersDoNotCallMembersProtectedByLinkDemands
+VirtualMethodsAndOverridesRequireSameLinkDemands
+
+Usage Rules:
+
+AssembliesHavePermissionRequests
+AssembliesHaveValidStrongNames
+AvoidNonConstantStaticFields
+AvoidWebMethodAttributedServicedComponentMembers
+ConsiderCallingDataMembersDisposeMethod
+ConstructorsShouldNotCallBaseClassVirtualMethods
+CreateDomainIsNotCalledWithNullParameters
+DisposeMethodsCallBaseClassDispose
+DisposeMethodsRequireFinalizeMethod
+EnumerationsShouldNotBeFlagsAttributed
+EqualsOverridesRequireGetHashCodeOverride
+ExceptionsAreMarkedSerializable
+ExceptionsShouldNotBeThrownFromFilterBlocks
+FinalizeMethodsCallBaseClassFinalize
+FinalizeMethodsHaveProtectedAccessLevel
+InheritedPublicMembersDoNotChangeToPrivate
+MemberNamesShouldBeSpelledCorrectly
+MembersDifferByMoreThanReturnType
+NamespaceNamesShouldBeSpelledCorrectly
+OperatorEqualsOverridesRequireEqualsOverride
+OperatorOverloadsHaveNamedAlternativeMethods
+OperatorsHaveSymmetricalOverloads
+ParameterNamesShouldBeSpelledCorrectly
+PInvokeOnlyValidEntryPoints
+PropertiesReturningCollectionsShouldBeReadOnly
+ResourceFilesAreBuiltUsingReleaseVersions
+ResourceStringsShouldBeSpelledCorrectly
+SerializableTypesShouldHaveMagicConstructor
+TypeNamesShouldBeSpelledCorrectly
+UseParamsForVariableArguments
+ValueTypesEqualsOverridesRequireOperatorEqualsOverride
+ValueTypesWithRvaFieldsDoNotHaveNonPublicFields
+WindowsFormsApplicationsAreMarkedStaThread 
+
+Globalization Rules:
+
+CultureInfoShouldBePassed
+IFormatProviderShouldBePassed
+LocaleShouldBeSetForDataTypes
+
+COM Rules:

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/AssemblyAnalyser.addin.xml
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/AssemblyAnalyser.addin.xml	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/AssemblyAnalyser.addin.xml	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,24 @@
+&lt;AddIn
+	name        = &quot;Assembly Analyzer&quot;
+	author      = &quot;Mike Krueger&quot;
+	copyright   = &quot;GPL&quot;
+	url         = &quot;<A HREF="http://www.icsharpcode.net&quot;">http://www.icsharpcode.net&quot;</A>
+	description = &quot;FxCop clone&quot;
+	version     = &quot;1.0.0&quot;
+&gt;
+	&lt;Runtime&gt;
+		&lt;Import assembly=&quot;ICSharpCode.AssemblyAnalyser.AddIn.dll&quot;/&gt;
+	&lt;/Runtime&gt;
+	
+	&lt;Extension path = &quot;/SharpDevelop/Workbench/MainMenu/View&quot;&gt;
+		&lt;Conditional iscombineopen=&quot;True&quot; action=&quot;Disable&quot;&gt;
+			&lt;MenuItem
+				id           = &quot;AssemblyAnalyser&quot;
+				insertafter  = &quot;ShowStartPage&quot;
+				insertbefore = &quot;StartPageSeparator&quot;
+				label        = &quot;${res:XML.MainMenu.ViewMenu.AssemblyAnalyser}&quot;
+				class        = &quot;MonoDevelop.AssemblyAnalyser.ShowAssemblyAnalyser&quot;
+			/&gt;
+		&lt;/Conditional&gt;
+	&lt;/Extension&gt;
+&lt;/AddIn&gt;

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/AssemblyInfo.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/AssemblyInfo.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/AssemblyInfo.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,32 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+
+[assembly: AssemblyTitle(&quot;&quot;)]
+[assembly: AssemblyDescription(&quot;&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.*&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Commands.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Commands.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Commands.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,27 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+using MonoDevelop.AssemblyAnalyser.Rules;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	public class ShowAssemblyAnalyser : AbstractMenuCommand
+	{
+		public override void Run()
+		{
+			if (AssemblyAnalyserView.AssemblyAnalyserViewInstance == null) {
+				WorkbenchSingleton.Workbench.ShowView(new AssemblyAnalyserView());
+			} else {
+				AssemblyAnalyserView.AssemblyAnalyserViewInstance.WorkbenchWindow.SelectWindow();
+			}
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserControl.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserControl.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserControl.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,173 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Reflection;
+using System.Windows.Forms;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyAnalyserControl.	
+	/// &lt;/summary&gt;
+	public class AssemblyAnalyserControl : System.Windows.Forms.UserControl
+	{
+		private System.Windows.Forms.Splitter splitter2;
+		private System.Windows.Forms.TabControl tabControl;
+		private MonoDevelop.AssemblyAnalyser.ResultListControl resultListControl;
+		private System.Windows.Forms.Splitter splitter;
+		private MonoDevelop.AssemblyAnalyser.AssemblyTreeControl assemblyTreeControl;
+		private System.Windows.Forms.Panel panel;
+		private System.Windows.Forms.TabPage assembliesTabPage;
+		private MonoDevelop.AssemblyAnalyser.ResultDetailsView resultDetailsView;
+		
+		public AssemblyAnalyserControl()
+		{
+			//
+			// The InitializeComponent() call is required for Windows Forms designer support.
+			//
+			
+			InitializeComponent();
+			resultListControl.ResultDetailsView = resultDetailsView;
+			assemblyTreeControl.ResultListControl = resultListControl;
+			
+		}
+		
+		public void ClearContents()
+		{
+			resultListControl.ClearContents();
+			assemblyTreeControl.ClearContents();
+		}
+		
+		public void AnalyzeAssembly(AssemblyAnalyser analyser, string fileName)
+		{
+			if (File.Exists(fileName)) {
+				analyser.Analyse(fileName);
+				assemblyTreeControl.AddAssembly(fileName, analyser.Resolutions);
+			}
+		}
+		
+		public void PrintAllResolutions()
+		{
+			assemblyTreeControl.PrintAllResolutions();
+		}
+		
+		#region Windows Forms Designer generated code
+		/// &lt;summary&gt;
+		/// This method is required for Windows Forms designer support.
+		/// Do not change the method contents inside the source code editor. The Forms designer might
+		/// not be able to load this method if it was changed manually.
+		/// &lt;/summary&gt;
+		private void InitializeComponent() {
+			this.resultDetailsView = new MonoDevelop.AssemblyAnalyser.ResultDetailsView();
+			this.assembliesTabPage = new System.Windows.Forms.TabPage();
+			this.panel = new System.Windows.Forms.Panel();
+			this.assemblyTreeControl = new MonoDevelop.AssemblyAnalyser.AssemblyTreeControl();
+			this.splitter = new System.Windows.Forms.Splitter();
+			this.resultListControl = new MonoDevelop.AssemblyAnalyser.ResultListControl();
+			this.tabControl = new System.Windows.Forms.TabControl();
+			this.splitter2 = new System.Windows.Forms.Splitter();
+			this.assembliesTabPage.SuspendLayout();
+			this.panel.SuspendLayout();
+			this.tabControl.SuspendLayout();
+			this.SuspendLayout();
+			// 
+			// resultDetailsView
+			// 
+			this.resultDetailsView.Dock = System.Windows.Forms.DockStyle.Bottom;
+			this.resultDetailsView.Location = new System.Drawing.Point(0, 304);
+			this.resultDetailsView.Name = &quot;resultDetailsView&quot;;
+			this.resultDetailsView.Size = new System.Drawing.Size(544, 200);
+			this.resultDetailsView.TabIndex = 1;
+			// 
+			// assembliesTabPage
+			// 
+			this.assembliesTabPage.Controls.Add(this.assemblyTreeControl);
+			this.assembliesTabPage.Location = new System.Drawing.Point(4, 22);
+			this.assembliesTabPage.Name = &quot;assembliesTabPage&quot;;
+			this.assembliesTabPage.Size = new System.Drawing.Size(192, 478);
+			this.assembliesTabPage.TabIndex = 0;
+			this.assembliesTabPage.Text = &quot;Assemblies&quot;;
+			// 
+			// panel
+			// 
+			this.panel.Controls.Add(this.resultListControl);
+			this.panel.Controls.Add(this.splitter2);
+			this.panel.Controls.Add(this.resultDetailsView);
+			this.panel.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.panel.Location = new System.Drawing.Point(204, 0);
+			this.panel.Name = &quot;panel&quot;;
+			this.panel.Size = new System.Drawing.Size(544, 504);
+			this.panel.TabIndex = 2;
+			// 
+			// assemblyTreeControl
+			// 
+			this.assemblyTreeControl.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.assemblyTreeControl.Location = new System.Drawing.Point(0, 0);
+			this.assemblyTreeControl.Name = &quot;assemblyTreeControl&quot;;
+			this.assemblyTreeControl.Size = new System.Drawing.Size(192, 478);
+			this.assemblyTreeControl.TabIndex = 0;
+			// 
+			// splitter
+			// 
+			this.splitter.Location = new System.Drawing.Point(200, 0);
+			this.splitter.Name = &quot;splitter&quot;;
+			this.splitter.Size = new System.Drawing.Size(4, 504);
+			this.splitter.TabIndex = 1;
+			this.splitter.TabStop = false;
+			// 
+			// resultListControl
+			// 
+			this.resultListControl.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.resultListControl.Location = new System.Drawing.Point(0, 0);
+			this.resultListControl.Name = &quot;resultListControl&quot;;
+			this.resultListControl.Size = new System.Drawing.Size(544, 300);
+			this.resultListControl.TabIndex = 3;
+			this.resultListControl.Load += new System.EventHandler(this.ResultListControlLoad);
+			// 
+			// tabControl
+			// 
+			this.tabControl.Controls.Add(this.assembliesTabPage);
+			this.tabControl.Dock = System.Windows.Forms.DockStyle.Left;
+			this.tabControl.Location = new System.Drawing.Point(0, 0);
+			this.tabControl.Name = &quot;tabControl&quot;;
+			this.tabControl.SelectedIndex = 0;
+			this.tabControl.Size = new System.Drawing.Size(200, 504);
+			this.tabControl.TabIndex = 0;
+			// 
+			// splitter2
+			// 
+			this.splitter2.Dock = System.Windows.Forms.DockStyle.Bottom;
+			this.splitter2.Location = new System.Drawing.Point(0, 300);
+			this.splitter2.Name = &quot;splitter2&quot;;
+			this.splitter2.Size = new System.Drawing.Size(544, 4);
+			this.splitter2.TabIndex = 2;
+			this.splitter2.TabStop = false;
+			// 
+			// AssemblyAnalyserControl
+			// 
+			this.Controls.Add(this.panel);
+			this.Controls.Add(this.splitter);
+			this.Controls.Add(this.tabControl);
+			this.Name = &quot;AssemblyAnalyserControl&quot;;
+			this.Size = new System.Drawing.Size(748, 504);
+			this.assembliesTabPage.ResumeLayout(false);
+			this.panel.ResumeLayout(false);
+			this.tabControl.ResumeLayout(false);
+			this.ResumeLayout(false);
+		}
+		#endregion
+		
+		void ResultListControlLoad(object sender, System.EventArgs e)
+		{
+			
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserView.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserView.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/AssemblyAnalyserView.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,127 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Reflection;
+using System.Security.Policy;
+using System.Threading;
+using System.Windows.Forms;
+
+using MonoDevelop.Gui;
+using MonoDevelop.Core;
+using MonoDevelop.Services;
+using MonoDevelop.Gui.HtmlControl;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyAnalyserView.	
+	/// &lt;/summary&gt;
+	public class AssemblyAnalyserView : AbstractViewContent
+	{
+		public static AssemblyAnalyserView AssemblyAnalyserViewInstance = null;
+		
+		AssemblyAnalyserControl assemblyAnalyserControl;
+		
+		AppDomain        analyserDomain  = null;
+		AssemblyAnalyser currentAnalyser = null;
+		public override Control Control {
+			get {
+				return assemblyAnalyserControl;
+			}
+		}
+		public override bool IsViewOnly {
+			get {
+				return true;
+			}
+		}
+		
+		public override bool IsReadOnly {
+			get {
+				return false;
+			}
+		}
+		
+		public AssemblyAnalyserView() : base(&quot;Assembly Analyser&quot;)
+		{
+			AssemblyAnalyserViewInstance = this;
+			assemblyAnalyserControl = new AssemblyAnalyserControl();
+			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			projectService.StartBuild += new EventHandler(ProjectServiceStartBuild);
+			projectService.EndBuild   += new EventHandler(ProjectServiceEndBuild);
+			RefreshProjectAssemblies();
+		}
+		
+		public void RefreshProjectAssemblies()
+		{
+			if (currentAnalyser == null) {
+				currentAnalyser = CreateRemoteAnalyser();
+			}
+			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			ArrayList projectCombineEntries = Combine.GetAllProjects(projectService.CurrentOpenCombine);
+			assemblyAnalyserControl.ClearContents();
+			foreach (ProjectCombineEntry projectEntry in projectCombineEntries) {
+				string outputAssembly = projectService.GetOutputAssemblyName(projectEntry.Project);
+				assemblyAnalyserControl.AnalyzeAssembly(currentAnalyser, outputAssembly);
+			}
+			assemblyAnalyserControl.PrintAllResolutions();
+		}
+		
+		public override void Load(string fileName)
+		{
+		}
+		
+		public override void Dispose()
+		{
+			DisposeAnalyser();
+			
+			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
+			projectService.StartBuild -= new EventHandler(ProjectServiceStartBuild);
+			projectService.EndBuild   -= new EventHandler(ProjectServiceEndBuild);
+			
+			IStatusBarService statusBarService = (IStatusBarService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IStatusBarService));
+			
+			statusBarService.SetMessage(&quot;${res:MainWindow.StatusBar.ReadyMessage}&quot;);
+			AssemblyAnalyserViewInstance = null;
+		}
+		
+		void DisposeAnalyser()
+		{
+			currentAnalyser = null;
+			AppDomain.Unload(analyserDomain);
+			analyserDomain = null;
+		}
+		
+		void ProjectServiceStartBuild(object sender, EventArgs e)
+		{
+			assemblyAnalyserControl.ClearContents();
+			DisposeAnalyser();
+		}
+		
+		void ProjectServiceEndBuild(object sender, EventArgs e)
+		{
+			assemblyAnalyserControl.Invoke(new ThreadStart(RefreshProjectAssemblies));
+		}
+		
+		AssemblyAnalyser CreateRemoteAnalyser()
+		{
+			AppDomainSetup setup = new AppDomainSetup();
+			Evidence evidence = new Evidence(AppDomain.CurrentDomain.Evidence);
+			setup.ApplicationName = &quot;Analyser&quot;;
+			setup.ApplicationBase = Application.StartupPath;
+
+			analyserDomain = AppDomain.CreateDomain(&quot;AnalyserDomain&quot;, evidence, setup);
+			return (AssemblyAnalyser)analyserDomain.CreateInstanceAndUnwrap(
+				typeof(AssemblyAnalyser).Assembly.FullName, 
+				typeof(AssemblyAnalyser).FullName,
+				false, BindingFlags.Default,null,null,null,null,null);
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyRuleViewControl.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyRuleViewControl.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyRuleViewControl.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,59 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Windows.Forms;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyRuleViewControl.	
+	/// &lt;/summary&gt;
+	[ToolboxBitmap(typeof(System.Windows.Forms.TreeView))]
+	public class AssemblyRuleViewControl : System.Windows.Forms.UserControl
+	{
+		private System.Windows.Forms.TreeView ruleTreeView;
+		public AssemblyRuleViewControl()
+		{
+			//
+			// The InitializeComponent() call is required for Windows Forms designer support.
+			//
+			InitializeComponent();
+			
+		}
+		
+		#region Windows Forms Designer generated code
+		/// &lt;summary&gt;
+		/// This method is required for Windows Forms designer support.
+		/// Do not change the method contents inside the source code editor. The Forms designer might
+		/// not be able to load this method if it was changed manually.
+		/// &lt;/summary&gt;
+		private void InitializeComponent() {
+			this.ruleTreeView = new System.Windows.Forms.TreeView();
+			this.SuspendLayout();
+			// 
+			// ruleTreeView
+			// 
+			this.ruleTreeView.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.ruleTreeView.ImageIndex = -1;
+			this.ruleTreeView.Location = new System.Drawing.Point(0, 0);
+			this.ruleTreeView.Name = &quot;ruleTreeView&quot;;
+			this.ruleTreeView.SelectedImageIndex = -1;
+			this.ruleTreeView.Size = new System.Drawing.Size(292, 266);
+			this.ruleTreeView.TabIndex = 0;
+			// 
+			// AssemblyRuleViewControl
+			// 
+			this.Controls.Add(this.ruleTreeView);
+			this.Name = &quot;AssemblyRuleViewControl&quot;;
+			this.Size = new System.Drawing.Size(292, 266);
+			this.ResumeLayout(false);
+		}
+		#endregion
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyTreeControl.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyTreeControl.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/AssemblyTreeControl.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,132 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Drawing;
+using System.Reflection;
+using System.Windows.Forms;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of AssemblyTreeControl.	
+	/// &lt;/summary&gt;
+	[ToolboxBitmap(typeof(System.Windows.Forms.TreeView))]
+	public class AssemblyTreeControl : System.Windows.Forms.UserControl
+	{
+		private System.Windows.Forms.TreeView assemblyTreeView;
+		TreeNode assembliesNode;
+		ResultListControl resultListControl;
+		
+		public ResultListControl ResultListControl {
+			get {
+				return resultListControl;
+			}
+			set {
+				resultListControl = value;
+			}
+		}
+		
+		public AssemblyTreeControl()
+		{
+			//
+			// The InitializeComponent() call is required for Windows Forms designer support.
+			//
+			InitializeComponent();
+			StringParserService stringParserService = (StringParserService)ServiceManager.Services.GetService(typeof(StringParserService));
+			ClassBrowserIconsService classBrowserIconService = (ClassBrowserIconsService)ServiceManager.Services.GetService(typeof(ClassBrowserIconsService));
+			assemblyTreeView.ImageList = classBrowserIconService.ImageList;
+			
+			assembliesNode = new TreeNode(stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.AssemblyTreeControl.AssembliesNode}&quot;));
+			assembliesNode.ImageIndex = assembliesNode.SelectedImageIndex = 0;
+			assemblyTreeView.Nodes.Add(assembliesNode);
+			assemblyTreeView.AfterCollapse += new TreeViewEventHandler(AssemblyTreeViewAfterCollapse);
+			assemblyTreeView.AfterExpand += new TreeViewEventHandler(AssemblyTreeViewAfterExpand);
+			assemblyTreeView.AfterSelect += new TreeViewEventHandler(AssemblyTreeViewAfterSelect);
+		}
+		
+		void AssemblyTreeViewAfterCollapse(object sender, TreeViewEventArgs e)
+		{
+			if (e.Node == assembliesNode) {
+				assembliesNode.ImageIndex = assembliesNode.SelectedImageIndex = 0;
+			}
+		}
+		
+		void AssemblyTreeViewAfterExpand(object sender, TreeViewEventArgs e)
+		{
+			if (e.Node == assembliesNode) {
+				assembliesNode.ImageIndex = assembliesNode.SelectedImageIndex = 1;
+			}
+		}
+		
+		void AssemblyTreeViewAfterSelect(object sender, TreeViewEventArgs e)
+		{
+			if (e.Node.Tag == null) {
+				PrintAllResolutions();
+			} else {
+				this.resultListControl.PrintReport((ArrayList)e.Node.Tag);
+			}
+		}
+		
+		public void PrintAllResolutions()
+		{
+			ArrayList allResolutions = new ArrayList();
+			foreach (TreeNode node in assembliesNode.Nodes) {
+				allResolutions.AddRange((ArrayList)node.Tag);
+			}
+			this.resultListControl.PrintReport(allResolutions);
+		}
+		
+		public void ClearContents()
+		{
+			Console.WriteLine(&quot;CLEAR CONTENTS&quot;);
+			assembliesNode.Nodes.Clear();
+		}
+		
+		public void AddAssembly(string assemblyFileName, ArrayList resolutions)
+		{
+			TreeNode newNode = new TreeNode(Path.GetFileName(assemblyFileName));
+			newNode.Tag = resolutions;
+			newNode.ImageIndex = newNode.SelectedImageIndex = 2;
+			assembliesNode.Nodes.Add(newNode);
+			assembliesNode.Expand();
+		}
+		
+		#region Windows Forms Designer generated code
+		/// &lt;summary&gt;
+		/// This method is required for Windows Forms designer support.
+		/// Do not change the method contents inside the source code editor. The Forms designer might
+		/// not be able to load this method if it was changed manually.
+		/// &lt;/summary&gt;
+		private void InitializeComponent() {
+			this.assemblyTreeView = new System.Windows.Forms.TreeView();
+			this.SuspendLayout();
+			// 
+			// assemblyTreeView
+			// 
+			this.assemblyTreeView.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.assemblyTreeView.HideSelection = false;
+			this.assemblyTreeView.ImageIndex = -1;
+			this.assemblyTreeView.Location = new System.Drawing.Point(0, 0);
+			this.assemblyTreeView.Name = &quot;assemblyTreeView&quot;;
+			this.assemblyTreeView.SelectedImageIndex = -1;
+			this.assemblyTreeView.Size = new System.Drawing.Size(292, 266);
+			this.assemblyTreeView.TabIndex = 0;
+			// 
+			// AssemblyTreeControl
+			// 
+			this.Controls.Add(this.assemblyTreeView);
+			this.Name = &quot;AssemblyTreeControl&quot;;
+			this.Size = new System.Drawing.Size(292, 266);
+			this.ResumeLayout(false);
+		}
+		#endregion
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultDetailsView.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultDetailsView.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultDetailsView.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,119 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Drawing;
+using System.Windows.Forms;
+
+using MonoDevelop.Gui;
+using MonoDevelop.Core;
+using MonoDevelop.Services;
+using MonoDevelop.BrowserDisplayBinding;
+using MonoDevelop.Gui.HtmlControl;
+using MonoDevelop.Core.Services;
+using MonoDevelop.AssemblyAnalyser.Rules;
+using MonoDevelop.Gui.Pads;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of ResultDetailsView.	
+	/// &lt;/summary&gt;
+	[ToolboxBitmap(typeof(System.Windows.Forms.RichTextBox))]
+	public class ResultDetailsView : System.Windows.Forms.UserControl
+	{
+		HtmlControl htmlControl;
+		Resolution  currentResolution;
+		public ResultDetailsView()
+		{
+			//
+			// The InitializeComponent() call is required for Windows Forms designer support.
+			//
+			InitializeComponent();
+			
+			htmlControl = new HtmlControl();
+			htmlControl.Dock = DockStyle.Fill;
+			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
+			htmlControl.CascadingStyleSheet = propertyService.DataDirectory + Path.DirectorySeparatorChar +
+			                                  &quot;resources&quot; + Path.DirectorySeparatorChar +
+			                                  &quot;css&quot; + Path.DirectorySeparatorChar +
+			                                  &quot;MsdnHelp.css&quot;;
+			
+			ClearContents();
+			htmlControl.BeforeNavigate += new BrowserNavigateEventHandler(HtmlControlBeforeNavigate);
+			this.Controls.Add(htmlControl);
+		}
+		
+		void HtmlControlBeforeNavigate(object sender, BrowserNavigateEventArgs e)
+		{
+			e.Cancel = true;
+			Console.WriteLine(&quot; &gt;{0}&lt; &quot;, e.Url);
+			if (e.Url.StartsWith(&quot;<A HREF="help://types/&quot;">help://types/&quot;</A>)) {
+				string typeName = e.Url.Substring(&quot;<A HREF="help://types/&quot;.Length">help://types/&quot;.Length</A>);
+				HelpBrowser helpBrowser = (HelpBrowser)WorkbenchSingleton.Workbench.GetPad(typeof(HelpBrowser));
+				helpBrowser.ShowHelpFromType(typeName);
+			} else if (e.Url.StartsWith(&quot;<A HREF="help://gotocause&quot;">help://gotocause&quot;</A>)) {
+				GotoCurrentCause();
+			}
+		}
+		
+		public void ClearContents()
+		{
+			htmlControl.Html = &quot;&lt;HTML&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;;
+		}
+		
+		void GotoCurrentCause()
+		{
+			IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+			Position position = parserService.GetPosition(currentResolution.Item.Replace('+', '.'));
+			
+			if (position != null &amp;&amp; position.Cu != null) {
+				IFileService fileService = (IFileService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
+				fileService.JumpToFilePosition(position.Cu.FileName, Math.Max(0, position.Line - 1), Math.Max(0, position.Column - 1));
+			}
+		}
+		
+		bool CanGoto(Resolution res)
+		{
+			IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+			Position position = parserService.GetPosition(res.Item.Replace('+', '.'));
+			return position != null &amp;&amp; position.Cu != null;
+		}
+		
+		public void ViewResolution(Resolution resolution)
+		{
+			this.currentResolution = resolution;
+			StringParserService stringParserService = (StringParserService)ServiceManager.Services.GetService(typeof(StringParserService));
+			
+			htmlControl.Html = @&quot;&lt;HTML&gt;&lt;BODY ID='bodyID' CLASS='dtBODY'&gt;
+			&lt;DIV ID='nstext'&gt;
+			&lt;DL&gt;&quot; + stringParserService.Parse(resolution.FailedRule.Description)  + @&quot;&lt;/DL&gt;
+			&lt;H4 CLASS='dtH4'&gt;&quot; + stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultDetailsView.DescriptionLabel}&quot;) + @&quot;&lt;/H4&gt;
+			&lt;DL&gt;&quot; + stringParserService.Parse(resolution.FailedRule.Details) +  @&quot;&lt;/DL&gt;
+			&lt;H4 CLASS='dtH4'&gt;&quot; + stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultDetailsView.ResolutionLabel}&quot;) + @&quot;&lt;/H4&gt; 
+			&lt;DL&gt;&quot; + stringParserService.Parse(resolution.Text, resolution.Variables) +  @&quot;&lt;/DL&gt;
+			&quot; + (CanGoto(resolution) ? stringParserService.Parse(&quot;&lt;A HREF=\&quot;<A HREF="help://gotocause\&quot;">help://gotocause\&quot;</A>&gt;${res:MonoDevelop.AssemblyAnalyser.ResultDetailsView.JumpToSourceCodeLink}&lt;/A&gt;&quot;) : &quot;&quot;) + @&quot;
+			&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;;
+		}
+		
+		#region Windows Forms Designer generated code
+		/// &lt;summary&gt;
+		/// This method is required for Windows Forms designer support.
+		/// Do not change the method contents inside the source code editor. The Forms designer might
+		/// not be able to load this method if it was changed manually.
+		/// &lt;/summary&gt;
+		private void InitializeComponent() {
+			// 
+			// ResultDetailsView
+			// 
+			this.Name = &quot;ResultDetailsView&quot;;
+			this.Size = new System.Drawing.Size(292, 266);
+		}
+		#endregion
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultListControl.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultListControl.cs	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Gui/Panels/ResultListControl.cs	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,228 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krueger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Drawing;
+using System.Windows.Forms;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.AssemblyAnalyser.Rules;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.AssemblyAnalyser
+{
+	/// &lt;summary&gt;
+	/// Description of ResultListControl.	
+	/// &lt;/summary&gt;
+	[ToolboxBitmap(typeof(System.Windows.Forms.ListView))]
+	public class ResultListControl : System.Windows.Forms.UserControl
+	{
+		private System.Windows.Forms.ListView listView;
+		private System.Windows.Forms.ColumnHeader criticalHeader;
+		private System.Windows.Forms.ColumnHeader itemHeader;
+		private System.Windows.Forms.ColumnHeader ruleHeader;
+		private System.Windows.Forms.ColumnHeader certaintyHeader;
+		private System.Windows.Forms.ColumnHeader levelHeader;
+		
+		ResultDetailsView resultDetailsView = null;
+		
+		public ResultDetailsView ResultDetailsView {
+			get {
+				return resultDetailsView;
+			}
+			set {
+				resultDetailsView = value;
+			}
+		}
+		
+		public ResultListControl()
+		{
+			//
+			// The InitializeComponent() call is required for Windows Forms designer support.
+			//
+			InitializeComponent();
+			
+			StringParserService stringParserService = (StringParserService)ServiceManager.Services.GetService(typeof(StringParserService));
+			levelHeader.Text     = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.LevelHeader}&quot;);
+			certaintyHeader.Text = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.CertaintyHeader}&quot;);
+			ruleHeader.Text      = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.RuleHeader}&quot;);
+			itemHeader.Text      = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.ItemHeader}&quot;);
+		}
+		
+		public void ClearContents()
+		{
+			this.listView.SelectedIndexChanged -= new System.EventHandler(this.ListViewSelectedIndexChanged);
+			listView.Items.Clear();
+			this.listView.SelectedIndexChanged += new System.EventHandler(this.ListViewSelectedIndexChanged);
+		}
+		
+		public void PrintReport(ArrayList resolutions)
+		{
+			try {
+				listView.BeginUpdate();
+				listView.Items.Clear();
+				StringParserService stringParserService = (StringParserService)ServiceManager.Services.GetService(typeof(StringParserService));
+				int cerr = 0, err = 0, cwar = 0, war = 0, inf = 0;
+				foreach (Resolution resolution in resolutions) {
+					string critical = String.Empty;
+					string type     = String.Empty;
+					Color foreColor = Color.Black;
+					
+					switch (resolution.FailedRule.PriorityLevel) {
+						case PriorityLevel.CriticalError:
+							critical = &quot;!&quot;;
+							type = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.ErrorType}&quot;);
+							foreColor = Color.Red;
+							++cerr;
+							break;
+						case PriorityLevel.Error:
+							type = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.ErrorType}&quot;);
+							foreColor = Color.DarkRed;
+							++err;
+							break;
+						case PriorityLevel.CriticalWarning:
+							critical = &quot;!&quot;;
+							type = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.WarningType}&quot;);
+							foreColor = Color.Blue;
+							++cwar;
+							break;
+						case PriorityLevel.Warning:
+							type = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.WarningType}&quot;);
+							foreColor = Color.DarkBlue;
+							++war;
+							break;
+						case PriorityLevel.Information:
+							type = stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.InformationType}&quot;);
+							++inf;
+							break;
+					}
+					string certainity = resolution.FailedRule.Certainty.ToString() + &quot;%&quot;;
+					string text = stringParserService.Parse(resolution.FailedRule.Description);
+					string item = stringParserService.Parse(resolution.Item);
+					ListViewItem listViewItem = new ListViewItem(new string[] {critical, type, certainity, text, item});
+					listViewItem.Font      = new Font(&quot;Arial&quot;, 9, FontStyle.Bold);
+					listViewItem.ForeColor = foreColor;
+					listViewItem.Tag = resolution;
+					listView.Items.Add(listViewItem);
+					
+				}
+				IStatusBarService statusBarService = (IStatusBarService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IStatusBarService));
+				if (resolutions.Count == 0) {
+					statusBarService.SetMessage(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.NoDefectsFoundStatusBarMessage}&quot;);
+				} else {
+					statusBarService.SetMessage(stringParserService.Parse(&quot;${res:MonoDevelop.AssemblyAnalyser.ResultListControl.TotalDefectsStatusBarMessage}&quot;,
+					                                          new string[,] {
+					                                          	{&quot;TotalDefects&quot;, resolutions.Count.ToString()},
+					                                          	{&quot;CriticalErrors&quot;, cerr.ToString()},
+					                                          	{&quot;Errors&quot;,err.ToString()},
+					                                          	{&quot;CriticalWarnings&quot;, cwar.ToString()},
+					                                          	{&quot;Warnings&quot;, war.ToString()},
+					                                          	{&quot;Informations&quot;, inf.ToString()}
+					                                          }));
+				}
+			} catch (Exception e) {
+				Console.WriteLine(&quot;Got exception : &quot; + e.ToString());
+			} finally {
+				listView.EndUpdate();
+			}
+		}
+		
+		#region Windows Forms Designer generated code
+		/// &lt;summary&gt;
+		/// This method is required for Windows Forms designer support.
+		/// Do not change the method contents inside the source code editor. The Forms designer might
+		/// not be able to load this method if it was changed manually.
+		/// &lt;/summary&gt;
+		private void InitializeComponent() {
+			this.levelHeader = new System.Windows.Forms.ColumnHeader();
+			this.certaintyHeader = new System.Windows.Forms.ColumnHeader();
+			this.ruleHeader = new System.Windows.Forms.ColumnHeader();
+			this.itemHeader = new System.Windows.Forms.ColumnHeader();
+			this.criticalHeader = new System.Windows.Forms.ColumnHeader();
+			this.listView = new System.Windows.Forms.ListView();
+			this.SuspendLayout();
+			// 
+			// levelHeader
+			// 
+			this.levelHeader.Text = &quot;Level&quot;;
+			this.levelHeader.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
+			// 
+			// certaintyHeader
+			// 
+			this.certaintyHeader.Text = &quot;Certainty&quot;;
+			this.certaintyHeader.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
+			// 
+			// ruleHeader
+			// 
+			this.ruleHeader.Text = &quot;Rule&quot;;
+			this.ruleHeader.Width = 350;
+			// 
+			// itemHeader
+			// 
+			this.itemHeader.Text = &quot;Item&quot;;
+			this.itemHeader.Width = 200;
+			// 
+			// criticalHeader
+			// 
+			this.criticalHeader.Text = &quot;!&quot;;
+			this.criticalHeader.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
+			this.criticalHeader.Width = 20;
+			// 
+			// listView
+			// 
+			this.listView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
+						this.criticalHeader,
+						this.levelHeader,
+						this.certaintyHeader,
+						this.ruleHeader,
+						this.itemHeader});
+			this.listView.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.listView.FullRowSelect = true;
+			this.listView.HideSelection = false;
+			this.listView.Location = new System.Drawing.Point(0, 0);
+			this.listView.MultiSelect = false;
+			this.listView.Name = &quot;listView&quot;;
+			this.listView.Size = new System.Drawing.Size(572, 396);
+			this.listView.TabIndex = 3;
+			this.listView.View = System.Windows.Forms.View.Details;
+			this.listView.ItemActivate += new System.EventHandler(this.ListViewItemActivate);
+			this.listView.SelectedIndexChanged += new System.EventHandler(this.ListViewSelectedIndexChanged);
+			// 
+			// ResultListControl
+			// 
+			this.Controls.Add(this.listView);
+			this.Name = &quot;ResultListControl&quot;;
+			this.Size = new System.Drawing.Size(572, 396);
+			this.ResumeLayout(false);
+		}
+		#endregion
+		void ListViewSelectedIndexChanged(object sender, System.EventArgs e)
+		{
+			if (resultDetailsView != null &amp;&amp; listView.SelectedItems.Count &gt; 0) {
+				resultDetailsView.ViewResolution((Resolution)listView.SelectedItems[0].Tag);
+			}
+			listView.Focus();
+		}
+		void ListViewItemActivate(object sender, System.EventArgs e)
+		{
+			ListViewItem item  = listView.SelectedItems[0];
+			if (item != null &amp;&amp; item.Tag != null) {
+				Resolution res = (Resolution)item.Tag;
+				IParserService parserService = (IParserService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IParserService));
+				Position position = parserService.GetPosition(res.Item.Replace('+', '.'));
+				
+				if (position != null &amp;&amp; position.Cu != null) {
+					IFileService fileService = (IFileService)MonoDevelop.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
+					Console.WriteLine(&quot;File name : &quot; + position.Cu.FileName);
+					fileService.JumpToFilePosition(position.Cu.FileName, Math.Max(0, position.Line - 1), Math.Max(0, position.Column - 1));
+				}
+			}
+		}
+		
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/ICSharpCode.AssemblyAnalyser.Addin.prjx
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/ICSharpCode.AssemblyAnalyser.Addin.prjx	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/ICSharpCode.AssemblyAnalyser.Addin.prjx	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,41 @@
+&lt;Project name=&quot;ICSharpCode.AssemblyAnalyser.AddIn&quot; standardNamespace=&quot;ICSharpCode.AssemblyAnalyser&quot; description=&quot;&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
+  &lt;Contents&gt;
+    &lt;File name=&quot;.\Commands.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\AssemblyInfo.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Gui&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Gui\AssemblyAnalyserView.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Gui\AssemblyAnalyserControl.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Gui\Panels\AssemblyTreeControl.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Gui\Panels\AssemblyRuleViewControl.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Gui\Panels&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Gui\Panels\ResultListControl.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Gui\Panels\ResultDetailsView.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\AssemblyAnalyser.addin&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\ICSharpCode.AssemblyAnalyser.AssemblyAnalyserControl.resources&quot; subtype=&quot;Code&quot; buildaction=&quot;EmbedAsResource&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\ICSharpCode.AssemblyAnalyser.ResultListControl.resources&quot; subtype=&quot;Code&quot; buildaction=&quot;EmbedAsResource&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+  &lt;/Contents&gt;
+  &lt;References&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;..\..\..\..\..\bin\ICSharpCode.Core.dll&quot; localcopy=&quot;False&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;..\..\..\..\..\bin\SharpDevelop.Base.dll&quot; localcopy=&quot;False&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;nunit.framework, Version=2.1.4.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77&quot; localcopy=&quot;False&quot; /&gt;
+    &lt;Reference type=&quot;Project&quot; refto=&quot;ICSharpCode.AssemblyAnalyser&quot; localcopy=&quot;False&quot; /&gt;
+  &lt;/References&gt;
+  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
+  &lt;Configuration runwithwarnings=&quot;True&quot; name=&quot;Debug&quot;&gt;
+    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;False&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;TEST&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+    &lt;Output directory=&quot;..\..\..\..\..\AddIns\AddIns\Misc\AssemblyAnalyser&quot; assembly=&quot;ICSharpCode.AssemblyAnalyser.Addin&quot; executeScript=&quot;..\..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+  &lt;/Configuration&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration runwithwarnings=&quot;True&quot; name=&quot;Debug&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;False&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;TEST&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\..\AddIns\AddIns\Misc\AssemblyAnalyser&quot; assembly=&quot;ICSharpCode.AssemblyAnalyser.Addin&quot; executeScript=&quot;..\..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; compilerversion=&quot;&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;False&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\..\AddIns\AddIns\Misc\AssemblyAnalyser&quot; assembly=&quot;ICSharpCode.AssemblyAnalyser.Addin&quot; executeScript=&quot;..\..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Project&gt;
\ No newline at end of file

Added: trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Makefile
===================================================================
--- trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Makefile	2004-06-10 22:23:41 UTC (rev 1734)
+++ trunk/MonoDevelop/src/AddIns/Misc/AssemblyAnalyser/ICSharpCode.AssemblyAnalyzer.AddIn/Makefile	2004-06-11 02:19:09 UTC (rev 1735)
@@ -0,0 +1,22 @@
+
+ASSEMBLY = ICSharpCode.AssemblyAnalyzer.Addin.dll
+CSC = mcs /debug
+
+REFS = \
+	/r:../../../../../build/bin/MonoDevelop.Core.dll \
+	/r:../../../../../build/bin/MonoDevelop.Base.dll
+
+FILES = \
+./Gui/AssemblyAnalyserControl.cs \
+./Gui/AssemblyAnalyserView.cs \
+./Gui/Panels/ResultListControl.cs \
+./Gui/Panels/AssemblyRuleViewControl.cs \
+./Gui/Panels/AssemblyTreeControl.cs \
+./Gui/Panels/ResultDetailsView.cs \
+./Commands.cs \
+./AssemblyInfo.cs
+
+all: $(ASSEMBLY)
+
+$(ASSEMBLY): $(FILES)
+	$(CSC) /out:$(ASSEMBLY) /target:library $(FILES) $(REFS)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001341.html">[Monodevelop-patches-list] r1734 - in trunk/MonoDevelop/src/AddIns/DisplayBindings/SourceEditor: . Gui Search/DocumentIterator
</A></li>
	<LI>Next message: <A HREF="001343.html">[Monodevelop-patches-list] r1736 - in trunk/MonoDevelop/src/AddIns/Misc: . AddInManager AddInManager/Commands AddInManager/Gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1342">[ date ]</a>
              <a href="thread.html#1342">[ thread ]</a>
              <a href="subject.html#1342">[ subject ]</a>
              <a href="author.html#1342">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
