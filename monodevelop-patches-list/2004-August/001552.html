<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1945 - in branches/MonoDevelop-plan-43/src: Libraries Libraries/SharpRefactory Libraries/SharpRefactory/CodeDOM Libraries/SharpRefactory/Lexer Libraries/SharpRefactory/Lexer/Reader Libraries/SharpRefactory/Lexer/Specials Libraries/SharpRefactory/Parser Libraries/SharpRefactory/Parser/AST Libraries/SharpRefactory/Parser/AST/Expressions Libraries/SharpRefactory/Parser/AST/GlobalScope Libraries/SharpRefactory/Parser/AST/Statements Libraries/SharpRefactory/Parser/AST/TypeLevel Libraries/SharpRefactory/Parser/generated Libraries/SharpRefactory/Parser/generated/keywordlist Libraries/SharpRefactory/PrettyPrinter Libraries/SharpRefactory/VBConverter Plugins Plugins/CSharp Plugins/Parser Plugins/Parser/Collections Plugins/Parser/Implementations Plugins/Parser/ParserService Plugins/Parser/PersistenceLayer Plugins/Parser/ReflectionLayer
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1945%20-%20in%20branches/MonoDevelop-plan-43/src%3A%20Libraries%20Libraries/SharpRefactory%20Libraries/SharpRefactory/CodeDOM%20Libraries/SharpRefactory/Lexer%20Libraries/SharpRefactory/Lexer/Reader%20Libraries/SharpRefactory/Lexer/Specials%20Libraries/SharpRefactory/Parser%20Libraries/SharpRefactory/Parser/AST%20Libraries/SharpRefactory/Parser/AST/Expressions%20Libraries/SharpRefactory/Parser/AST/GlobalScope%20Libraries/SharpRefactory/Parser/AST/Statements%20Libraries/SharpRefactory/Parser/AST/TypeLevel%20Libraries/SharpRefactory/Parser/generated%20Libraries/SharpRefactory/Parser/generated/keywordlist%20Libraries/SharpRefactory/PrettyPrinter%20Libraries/SharpRefactory/VBConverter%20Plugins%20Plugins/CSharp%20Plugins/Parser%20Plugins/Parser/Collections%20Plugins/Parser/Implementations%20Plugins/Parser/ParserService%20Plugins/Parser/PersistenceLayer%20Plugins/Parser/ReflectionLayer&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001551.html">
   <LINK REL="Next"  HREF="001553.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1945 - in branches/MonoDevelop-plan-43/src: Libraries Libraries/SharpRefactory Libraries/SharpRefactory/CodeDOM Libraries/SharpRefactory/Lexer Libraries/SharpRefactory/Lexer/Reader Libraries/SharpRefactory/Lexer/Specials Libraries/SharpRefactory/Parser Libraries/SharpRefactory/Parser/AST Libraries/SharpRefactory/Parser/AST/Expressions Libraries/SharpRefactory/Parser/AST/GlobalScope Libraries/SharpRefactory/Parser/AST/Statements Libraries/SharpRefactory/Parser/AST/TypeLevel Libraries/SharpRefactory/Parser/generated Libraries/SharpRefactory/Parser/generated/keywordlist Libraries/SharpRefactory/PrettyPrinter Libraries/SharpRefactory/VBConverter Plugins Plugins/CSharp Plugins/Parser Plugins/Parser/Collections Plugins/Parser/Implementations Plugins/Parser/ParserService Plugins/Parser/PersistenceLayer Plugins/Parser/ReflectionLayer</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1945%20-%20in%20branches/MonoDevelop-plan-43/src%3A%20Libraries%20Libraries/SharpRefactory%20Libraries/SharpRefactory/CodeDOM%20Libraries/SharpRefactory/Lexer%20Libraries/SharpRefactory/Lexer/Reader%20Libraries/SharpRefactory/Lexer/Specials%20Libraries/SharpRefactory/Parser%20Libraries/SharpRefactory/Parser/AST%20Libraries/SharpRefactory/Parser/AST/Expressions%20Libraries/SharpRefactory/Parser/AST/GlobalScope%20Libraries/SharpRefactory/Parser/AST/Statements%20Libraries/SharpRefactory/Parser/AST/TypeLevel%20Libraries/SharpRefactory/Parser/generated%20Libraries/SharpRefactory/Parser/generated/keywordlist%20Libraries/SharpRefactory/PrettyPrinter%20Libraries/SharpRefactory/VBConverter%20Plugins%20Plugins/CSharp%20Plugins/Parser%20Plugins/Parser/Collections%20Plugins/Parser/Implementations%20Plugins/Parser/ParserService%20Plugins/Parser/PersistenceLayer%20Plugins/Parser/ReflectionLayer&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1945 - in branches/MonoDevelop-plan-43/src: Libraries Libraries/SharpRefactory Libraries/SharpRefactory/CodeDOM Libraries/SharpRefactory/Lexer Libraries/SharpRefactory/Lexer/Reader Libraries/SharpRefactory/Lexer/Specials Libraries/SharpRefactory/Parser Libraries/SharpRefactory/Parser/AST Libraries/SharpRefactory/Parser/AST/Expressions Libraries/SharpRefactory/Parser/AST/GlobalScope Libraries/SharpRefactory/Parser/AST/Statements Libraries/SharpRefactory/Parser/AST/TypeLevel Libraries/SharpRefactory/Parser/generated Libraries/SharpRefactory/Parser/generated/keywordlist Libraries/SharpRefactory/PrettyPrinter Libraries/SharpRefactory/VBConverter Plugins Plugins/CSharp Plugins/Parser Plugins/Parser/Collections Plugins/Parser/Implementations Plugins/Parser/ParserService Plugins/Parser/PersistenceLayer Plugins/Parser/ReflectionLayer">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sun Aug 15 17:12:39 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001551.html">[Monodevelop-patches-list] r1944 - in branches/MonoDevelop-plan-43: . src/Plugins src/Plugins/CSharp src/Plugins/Editor
</A></li>
        <LI>Next message: <A HREF="001553.html">[Monodevelop-patches-list] r1946 - in branches/MonoDevelop-plan-43: . src/Plugins/Content src/Plugins/Node src/Plugins/Workbench
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1552">[ date ]</a>
              <a href="thread.html#1552">[ thread ]</a>
              <a href="subject.html#1552">[ subject ]</a>
              <a href="author.html#1552">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tberman
Date: 2004-08-15 17:12:38 -0400 (Sun, 15 Aug 2004)
New Revision: 1945

Added:
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/AssemblyInfo.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/ChangeLog
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/CodeDOM/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/CodeDOM/CodeDOMVisitor.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Lexer.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/FileReader.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/IReader.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/StringReader.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/BlankLine.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/Comment.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/CommentType.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/PreProcessingDirective.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/SpecialTracker.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/SpecialType.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Tokens.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Main.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AbstractASTVisitor.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AbstractNode.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AttributeTargets.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/CompilationUnit.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/DebugASTVisitor.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Enums.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ArrayCreateExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ArrayInitializerExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/AssignmentExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/BaseReferenceExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/BinaryOperatorExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/CastExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/CheckedExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ConditionalExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/DirectionExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/Expression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/FieldReferenceExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/IdentifierExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/IndexerExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/InvocationExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ObjectCreateExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ParenthesizedExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/PointerReferenceExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/PrimitiveExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/SizeOfExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/StackAllocExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ThisReferenceExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/TypeOfExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/TypeReferenceExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/UnaryOperatorExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/UncheckedExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/AttributeSection.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/DelegateDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/NamespaceDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/TypeDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/UsingAliasDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/UsingDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/IASTVisitor.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/INode.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/LookupTableVisitor.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Modifier.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/BlockStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/BreakStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/CheckedStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ContinueStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/DoWhileStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/EmptyStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/FixedStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ForStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ForeachStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/GotoCaseStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/GotoStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/IfElseStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/IfStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LabelStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LocalVariableDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LockStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ReturnStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/Statement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/StatementExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/SwitchStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ThrowStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/TryCatchStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UncheckedStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UnsafeStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UsingStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/WhileStatement.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/ConstructorDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/DestructorDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventAddRegion.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventRemoveRegion.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/FieldDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/IndexerDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/MethodDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/OperatorDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/ParameterDeclarationExpression.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertyDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertyGetRegion.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertySetRegion.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/TypeReference.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/VariableDeclaration.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Error.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Modifiers.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Parser.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Parser.frame
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/ParserUtil.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Scanner.frame
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/SharpCoco.exe
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/cs.ATG
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/gen.bat
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/ATGTokensSection.gen
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/BuildKeywords.pl
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/CSharpKeywordList.txt
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/Keywords.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/Tokens.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/trace.txt
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/OutputFormatter.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintData.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintUtil.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintVisitor.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/SpecialVisitor.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/VBNetRefactory.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/VBNetVisitor.cs
   branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/sharprefactory.build
   branches/MonoDevelop-plan-43/src/Plugins/Parser/
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ClassType.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/AttributeCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/AttributeSectionCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/ClassCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/CommentCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/EventCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/FieldCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/IUsingCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/MethodCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/ParameterCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/PropertyCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/TagCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/TypedCSharpCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Comment.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IAttribute.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IClass.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IComment.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ICompilationUnit.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ICompilationUnitBase.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IDecoration.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IEvent.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IExpressionFinder.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IField.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IIndexer.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IMember.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IMethod.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IParameter.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IParser.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IProperty.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IRegion.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IReturnType.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/IUsing.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractAttribute.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractClass.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractComment.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractCompilationUnit.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractDecoration.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractEvent.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractField.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractIndexer.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractMember.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractMethod.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractNamedEntity.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractParameter.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractProperty.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractReturnType.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractUsing.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/DefaultRegion.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ModifierEnum.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParameterModifier.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/AssemblyInformation.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassInformationEventHandler.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassProxy.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassProxyCollection.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/CodeCompletionDatabase.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/DefaultParserService.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/IParserService.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ParseInformation.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentClass.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentEvent.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentField.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentIndexer.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentMethod.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentParameter.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentProperty.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentReturnType.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionClass.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionEvent.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionField.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionIndexer.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionMethod.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionParameter.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionProperty.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionReturnType.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/Tag.cs
   branches/MonoDevelop-plan-43/src/Plugins/Parser/parser.build
Modified:
   branches/MonoDevelop-plan-43/src/Libraries/libraries.build
   branches/MonoDevelop-plan-43/src/Plugins/CSharp/CSharpNodeViewer.cs
   branches/MonoDevelop-plan-43/src/Plugins/plugins.build
Log:
large commit, merging over some of the parser stuff. The 'Parser' plugin isnt compiled right now, as we need to figure out the whole project situation to make this work.


Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/AssemblyInfo.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/AssemblyInfo.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/AssemblyInfo.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,32 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+
+[assembly: AssemblyTitle(&quot;&quot;)]
+[assembly: AssemblyDescription(&quot;&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.*&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/ChangeLog
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/ChangeLog	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/ChangeLog	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,11 @@
+2004-05-24  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&gt;
+
+	* src/Parser/AST/AbstractNode.cs: Lazily create children arraylist.
+
+2004-03-29  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
+
+	* src/Parser/Expressions/PrimitiveExpression.cs: stop requiring ICU 
+
+2004-03-21  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
+
+	* src/*: Merged in sync with #D parser. Renamespace to ICSharpCode

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/CodeDOM/CodeDOMVisitor.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/CodeDOM/CodeDOMVisitor.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/CodeDOM/CodeDOMVisitor.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,1133 @@
+// CodeDOMVisitor.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Reflection;
+using System.CodeDom;
+using System.Text;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class CodeDOMVisitor : AbstractASTVisitor
+	{
+		Stack namespaceDeclarations = new Stack();
+		Stack typeDeclarations     = new Stack();
+		Stack codeStack  = new Stack();
+		TypeDeclaration currentTypeDeclaration;
+
+		// dummy collection used to swallow statements
+		System.CodeDom.CodeStatementCollection NullStmtCollection = new CodeStatementCollection();
+		
+		public CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
+		public ArrayList namespaces = new ArrayList();
+		
+		static string[,] typeConversionList = new string[,] {
+			{&quot;System.Void&quot;,    &quot;void&quot;},
+			{&quot;System.Object&quot;,  &quot;object&quot;},
+			{&quot;System.Boolean&quot;, &quot;bool&quot;},
+			{&quot;System.Byte&quot;,    &quot;byte&quot;},
+			{&quot;System.SByte&quot;,   &quot;sbyte&quot;},
+			{&quot;System.Char&quot;,    &quot;char&quot;},
+			{&quot;System.Enum&quot;,    &quot;enum&quot;},
+			{&quot;System.Int16&quot;,   &quot;short&quot;},
+			{&quot;System.Int32&quot;,   &quot;int&quot;},
+			{&quot;System.Int64&quot;,   &quot;long&quot;},
+			{&quot;System.UInt16&quot;,  &quot;ushort&quot;},
+			{&quot;System.UInt32&quot;,  &quot;uint&quot;},
+			{&quot;System.UInt64&quot;,  &quot;ulong&quot;},
+			{&quot;System.Single&quot;,  &quot;float&quot;},
+			{&quot;System.Double&quot;,  &quot;double&quot;},
+			{&quot;System.Decimal&quot;, &quot;decimal&quot;},
+			{&quot;System.String&quot;,  &quot;string&quot;}
+		};
+		
+		static Hashtable typeConversionTable = new Hashtable();
+		
+		static CodeDOMVisitor()
+		{
+			for (int i = 0; i &lt; typeConversionList.GetLength(0); ++i) {
+				typeConversionTable[typeConversionList[i, 1]] = typeConversionList[i, 0];
+			}
+		}
+
+		string ConvType(string type) 
+		{
+			if (typeConversionTable[type] != null) {
+				return typeConversionTable[type].ToString();
+			}
+			return type;
+		}
+
+		void AddStmt(System.CodeDom.CodeStatement stmt)
+		{
+			System.CodeDom.CodeStatementCollection stmtCollection = codeStack.Peek() as System.CodeDom.CodeStatementCollection;
+			if (stmtCollection != null) {
+				stmtCollection.Add(stmt);
+			}
+		}
+
+		void AddStmt(System.CodeDom.CodeExpression expr)
+		{
+			System.CodeDom.CodeStatementCollection stmtCollection = codeStack.Peek() as System.CodeDom.CodeStatementCollection;
+			if (stmtCollection != null) {
+				stmtCollection.Add(expr);
+			}
+		}
+
+		// FIXME: map all modifiers correctly
+		MemberAttributes ConvMemberAttributes(Modifier modifier) 
+		{
+			MemberAttributes attr = (MemberAttributes)0;
+
+			if ((modifier &amp; Modifier.Abstract) != 0)
+				attr |=  MemberAttributes.Abstract;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.AccessMask;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.Assembly;
+			if ((modifier &amp; Modifier.Const) != 0)
+				attr |=  MemberAttributes.Const;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.Family;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.FamilyAndAssembly;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.FamilyOrAssembly;
+			if ((modifier &amp; Modifier.Sealed) != 0)
+				attr |=  MemberAttributes.Final;
+			if ((modifier &amp; Modifier.New) != 0)
+				attr |=  MemberAttributes.New;
+			if ((modifier &amp; Modifier.Virtual) != 0)
+				attr |=  MemberAttributes.Overloaded;
+			if ((modifier &amp; Modifier.Override) != 0)
+				attr |=  MemberAttributes.Override;
+			if ((modifier &amp; Modifier.Private) != 0)
+				attr |=  MemberAttributes.Private;
+			if ((modifier &amp; Modifier.Public) != 0)
+				attr |=  MemberAttributes.Public;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.ScopeMask;
+			if ((modifier &amp; Modifier.Static) != 0)
+				attr |=  MemberAttributes.Static;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.VTableMask;
+
+			return attr;
+		}
+
+		void ProcessSpecials(Hashtable specials)
+		{
+			if (specials == null) {
+				return;
+			}
+			
+			foreach (object special in specials) {
+				if (special is BlankLine) {
+					AddStmt(new CodeSnippetStatement());
+				} else if (special is PreProcessingDirective) {
+					// TODO
+				} else if (special is Comment) {
+					Comment comment = (Comment)special;
+					switch (comment.CommentType) {
+						case CommentType.SingleLine:
+							AddStmt(new CodeCommentStatement(comment.CommentText, false));
+							break;
+						case CommentType.Documentation:
+							AddStmt(new CodeCommentStatement(comment.CommentText, true));
+							break;
+						case CommentType.Block:
+							AddStmt(new CodeCommentStatement(comment.CommentText, false));
+							break;
+					}
+				}
+			}
+		}
+
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
+		public override object Visit(CompilationUnit compilationUnit, object data)
+		{
+			CodeNamespace globalNamespace = new CodeNamespace(&quot;Global&quot;);
+			namespaces.Add(globalNamespace);
+			namespaceDeclarations.Push(globalNamespace);
+			compilationUnit.AcceptChildren(this, data);
+			codeCompileUnit.Namespaces.Add(globalNamespace);
+			return globalNamespace;
+		}
+		
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			ProcessSpecials(namespaceDeclaration.Specials);
+
+			CodeNamespace currentNamespace = new CodeNamespace(namespaceDeclaration.NameSpace);
+			namespaces.Add(currentNamespace);
+			// add imports from mother namespace
+			foreach (CodeNamespaceImport import in ((CodeNamespace)namespaceDeclarations.Peek()).Imports) {
+				currentNamespace.Imports.Add(import);
+			}
+			namespaceDeclarations.Push(currentNamespace);
+			namespaceDeclaration.AcceptChildren(this, data);
+			namespaceDeclarations.Pop();
+			codeCompileUnit.Namespaces.Add(currentNamespace);
+			
+			// TODO : Nested namespaces allowed in CodeDOM ? Doesn't seem so :(
+			return null;
+		}
+		
+		public override object Visit(UsingDeclaration usingDeclaration, object data)
+		{
+			ProcessSpecials(usingDeclaration.Specials);
+
+			((CodeNamespace)namespaceDeclarations.Peek()).Imports.Add(new CodeNamespaceImport(usingDeclaration.Namespace));
+			return null;
+		}
+		
+		public override object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(AttributeSection attributeSection, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			ProcessSpecials(typeDeclaration.Specials);
+
+			this.currentTypeDeclaration = typeDeclaration;
+			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(typeDeclaration.Name);
+			codeTypeDeclaration.IsClass     = typeDeclaration.Type == Types.Class;
+			codeTypeDeclaration.IsEnum      = typeDeclaration.Type == Types.Enum;
+			codeTypeDeclaration.IsInterface = typeDeclaration.Type == Types.Interface;
+			codeTypeDeclaration.IsStruct    = typeDeclaration.Type == Types.Struct;
+			
+			if (typeDeclaration.BaseTypes != null) {
+				foreach (object o in typeDeclaration.BaseTypes) {
+					codeTypeDeclaration.BaseTypes.Add(new CodeTypeReference(o.ToString()));
+				}
+			}
+			
+			typeDeclarations.Push(codeTypeDeclaration);
+			typeDeclaration.AcceptChildren(this,data);
+//			((INode)typeDeclaration.Children[0]).(this, data);
+			
+			typeDeclarations.Pop();
+			
+			((CodeNamespace)namespaceDeclarations.Peek()).Types.Add(codeTypeDeclaration);
+			
+			return null;
+		}
+		
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+//			CodeTypeDelegate codeTypeDelegate = new CodeTypeDelegate(delegateDeclaration.Name);
+//			codeTypeDelegate.Parameters
+//			
+//			((CodeNamespace)namespaceDeclarations.Peek()).Types.Add(codeTypeDelegate);
+			return null;
+		}
+		
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			ProcessSpecials(fieldDeclaration.Specials);
+
+			for (int i = 0; i &lt; fieldDeclaration.Fields.Count; ++i) 
+			{
+				VariableDeclaration field = (VariableDeclaration)fieldDeclaration.Fields[i];
+				
+				CodeMemberField memberField = new CodeMemberField(new CodeTypeReference(ConvType(fieldDeclaration.TypeReference.Type)), field.Name);
+				memberField.Attributes = ConvMemberAttributes(fieldDeclaration.Modifier);
+				if (field.Initializer != null) {
+					memberField.InitExpression =  (CodeExpression)((INode)field.Initializer).AcceptVisitor(this, data);
+				}
+				
+				((CodeTypeDeclaration)typeDeclarations.Peek()).Members.Add(memberField);
+			}
+			
+			return null;
+		}
+		
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			ProcessSpecials(methodDeclaration.Specials);
+
+			CodeMemberMethod memberMethod = new CodeMemberMethod();
+			memberMethod.Name = methodDeclaration.Name;
+			memberMethod.Attributes = ConvMemberAttributes(methodDeclaration.Modifier);
+			
+			codeStack.Push(memberMethod.Statements);
+
+			((CodeTypeDeclaration)typeDeclarations.Peek()).Members.Add(memberMethod);
+
+			// Add Method Parameters
+			foreach (ParameterDeclarationExpression parameter in methodDeclaration.Parameters)
+			{
+				memberMethod.Parameters.Add((CodeParameterDeclarationExpression)Visit(parameter, data));
+			}
+
+			methodDeclaration.Body.AcceptChildren(this, data);
+
+			codeStack.Pop();
+
+			return null;
+		}
+		
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(PropertySetRegion PropertySetRegion, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(EventAddRegion eventAddRegion, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(EventRemoveRegion eventRemoveRegion, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			ProcessSpecials(constructorDeclaration.Specials);
+
+			CodeMemberMethod memberMethod = new CodeConstructor();
+
+			codeStack.Push(memberMethod.Statements);
+			((CodeTypeDeclaration)typeDeclarations.Peek()).Members.Add(memberMethod);
+//			constructorDeclaration.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			return null;
+		}
+		
+		public override object Visit(DestructorDeclaration destructorDeclaration, object data)
+		{
+			return null;
+		}
+
+		public override object Visit(OperatorDeclaration operatorDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(IndexerDeclaration indexerDeclaration, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(BlockStatement blockStatement, object data)
+		{
+			ProcessSpecials(blockStatement.Specials);
+
+			blockStatement.AcceptChildren(this, data);
+			return null;
+		}
+		
+		public override object Visit(StatementExpression statementExpression, object data)
+		{
+			object exp = statementExpression.Expression.AcceptVisitor(this, data);
+			if (exp is CodeExpression) {
+				AddStmt(new CodeExpressionStatement((CodeExpression)exp));
+			}
+			return exp;
+		}
+		
+		public string Convert(TypeReference typeRef)
+		{
+			StringBuilder builder = new StringBuilder();
+			builder.Append(ConvType(typeRef.Type));
+			
+			for (int i = 0; i &lt; typeRef.PointerNestingLevel; ++i) {
+				builder.Append('*');
+			}
+			
+			
+			for (int i = 0; i &lt; typeRef.RankSpecifier.Length; ++i) {
+				builder.Append('[');
+				for (int j = 1; j &lt; typeRef.RankSpecifier[i]; ++j) {
+					builder.Append(',');
+				}
+				builder.Append(']');
+			}
+			
+			return builder.ToString();
+		}
+		
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			CodeVariableDeclarationStatement declStmt = null;
+
+			CodeTypeReference type = new CodeTypeReference(Convert(localVariableDeclaration.Type));
+			
+			foreach (VariableDeclaration var in localVariableDeclaration.Variables) {
+				if (var.Initializer != null) {
+					declStmt = new CodeVariableDeclarationStatement(type,
+					                                             var.Name,
+					                                             (CodeExpression)((INode)var.Initializer).AcceptVisitor(this, data));
+				} else {
+					declStmt = new CodeVariableDeclarationStatement(type,
+					                                             var.Name);
+				}
+			}
+
+			AddStmt(declStmt);
+
+			return declStmt;
+		}
+		
+		public override object Visit(EmptyStatement emptyStatement, object data)
+		{
+			CodeSnippetStatement emptyStmt = new CodeSnippetStatement();
+
+			AddStmt(emptyStmt);
+
+			return emptyStmt;
+		}
+		
+		public override object Visit(ReturnStatement returnStatement, object data)
+		{
+			ProcessSpecials(returnStatement.Specials);
+
+			CodeMethodReturnStatement returnStmt = new CodeMethodReturnStatement((CodeExpression)returnStatement.ReturnExpression.AcceptVisitor(this,data));
+
+			AddStmt(returnStmt);
+
+			return returnStmt;
+		}
+		
+		public override object Visit(IfStatement ifStatement, object data)
+		{
+			ProcessSpecials(ifStatement.Specials);
+
+			CodeConditionStatement ifStmt = new CodeConditionStatement();
+			
+			ifStmt.Condition = (CodeExpression)ifStatement.Condition.AcceptVisitor(this, data);
+
+			codeStack.Push(ifStmt.TrueStatements);
+			ifStatement.EmbeddedStatement.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			AddStmt(ifStmt);
+
+			return ifStmt;
+		}
+		
+		public override object Visit(IfElseStatement ifElseStatement, object data)
+		{
+			ProcessSpecials(ifElseStatement.Specials);
+
+			CodeConditionStatement ifStmt = new CodeConditionStatement();
+
+			ifStmt.Condition = (CodeExpression)ifElseStatement.Condition.AcceptVisitor(this, data);
+
+			codeStack.Push(ifStmt.TrueStatements);
+			ifElseStatement.EmbeddedStatement.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			codeStack.Push(ifStmt.FalseStatements);
+			ifElseStatement.EmbeddedElseStatement.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			AddStmt(ifStmt);
+
+			return ifStmt;
+		}
+		
+		public override object Visit(WhileStatement whileStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(DoWhileStatement doWhileStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ForStatement forStatement, object data)
+		{
+			CodeIterationStatement forLoop = new CodeIterationStatement();
+
+			if (forStatement.Initializers != null) 
+			{
+				if (forStatement.Initializers.Count &gt; 1)
+				{
+					throw new NotSupportedException(&quot;CodeDom does not support Multiple For-Loop Initializer Statements&quot;);
+				}
+
+				foreach (object o in forStatement.Initializers)
+				{
+					if (o is Expression) 
+					{
+						forLoop.InitStatement = new CodeExpressionStatement((CodeExpression)((Expression)o).AcceptVisitor(this,data));
+					}
+					if (o is Statement) 
+					{
+						codeStack.Push(NullStmtCollection);
+						forLoop.InitStatement = (CodeStatement)((Statement)o).AcceptVisitor(this, data);
+						codeStack.Pop();
+					}
+				}
+			}
+
+			if (forStatement.Condition == null) 
+			{
+				forLoop.TestExpression = new CodePrimitiveExpression(true);
+			} 
+			else 
+			{
+				forLoop.TestExpression = (CodeExpression)forStatement.Condition.AcceptVisitor(this, data);
+			}
+
+			codeStack.Push(forLoop.Statements);
+			forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			codeStack.Pop();
+
+			if (forStatement.Iterator != null) 
+			{
+				if (forStatement.Initializers.Count &gt; 1)
+				{
+					throw new NotSupportedException(&quot;CodeDom does not support Multiple For-Loop Iterator Statements&quot;);
+				}
+
+				foreach (Statement stmt in forStatement.Iterator) 
+				{
+					forLoop.IncrementStatement = (CodeStatement)stmt.AcceptVisitor(this, data);
+				}
+			}
+
+			AddStmt(forLoop);
+
+			return forLoop;
+		}
+		
+		public override object Visit(LabelStatement labelStatement, object data)
+		{
+			ProcessSpecials(labelStatement.Specials);
+
+			System.CodeDom.CodeLabeledStatement labelStmt = new CodeLabeledStatement(labelStatement.Label,(CodeStatement)labelStatement.AcceptVisitor(this, data));
+
+			// Add Statement to Current Statement Collection
+			AddStmt(labelStmt);
+
+			return labelStmt;
+		}
+		
+		public override object Visit(GotoStatement gotoStatement, object data)
+		{
+			ProcessSpecials(gotoStatement.Specials);
+
+			System.CodeDom.CodeGotoStatement gotoStmt = new CodeGotoStatement(gotoStatement.Label);
+
+			// Add Statement to Current Statement Collection
+			AddStmt(gotoStmt);
+
+			return gotoStmt;
+		}
+		
+		public override object Visit(SwitchStatement switchStatement, object data)
+		{
+			throw new NotSupportedException(&quot;CodeDom does not support Switch Statement&quot;);
+		}
+		
+		public override object Visit(BreakStatement breakStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ContinueStatement continueStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(ForeachStatement foreachStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(LockStatement lockStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(UsingStatement usingStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			ProcessSpecials(tryCatchStatement.Specials);
+
+			// add a try-catch-finally
+			CodeTryCatchFinallyStatement tryStmt = new CodeTryCatchFinallyStatement();
+
+			codeStack.Push(tryStmt.TryStatements);
+			ProcessSpecials(tryCatchStatement.StatementBlock.Specials);
+			tryCatchStatement.StatementBlock.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			if (tryCatchStatement.FinallyBlock != null)
+			{
+				codeStack.Push(tryStmt.FinallyStatements);
+				ProcessSpecials(tryCatchStatement.FinallyBlock.Specials);
+				tryCatchStatement.FinallyBlock.AcceptChildren(this,data);
+				codeStack.Pop();
+			}
+
+			if (tryCatchStatement.CatchClauses != null) 
+			{
+				foreach (CatchClause clause in tryCatchStatement.CatchClauses) 
+				{
+					CodeCatchClause catchClause = new CodeCatchClause(clause.VariableName);
+					catchClause.CatchExceptionType = new CodeTypeReference(clause.Type);
+					tryStmt.CatchClauses.Add(catchClause);
+
+					codeStack.Push(catchClause.Statements);
+					ProcessSpecials(clause.StatementBlock.Specials);
+					clause.StatementBlock.AcceptChildren(this, data);
+					codeStack.Pop();
+				}
+			}
+
+			// Add Statement to Current Statement Collection
+			AddStmt(tryStmt);
+
+			return tryStmt;
+		}
+		
+		public override object Visit(ThrowStatement throwStatement, object data)
+		{
+			ProcessSpecials(throwStatement.Specials);
+
+			CodeThrowExceptionStatement throwStmt = new CodeThrowExceptionStatement((CodeExpression)throwStatement.ThrowExpression.AcceptVisitor(this, data));
+
+			// Add Statement to Current Statement Collection
+			AddStmt(throwStmt);
+
+			return throwStmt;
+		}
+		
+		public override object Visit(FixedStatement fixedStatement, object data)
+		{
+			throw new NotSupportedException(&quot;CodeDom does not support Fixed Statement&quot;);
+		}
+		
+		public override object Visit(PrimitiveExpression expression, object data)
+		{
+			return new CodePrimitiveExpression(expression.Value);
+		}
+		
+		public override object Visit(BinaryOperatorExpression expression, object data)
+		{
+			CodeBinaryOperatorType op = CodeBinaryOperatorType.Add;
+			switch (expression.Op) {
+				case BinaryOperatorType.Add:
+					op = CodeBinaryOperatorType.Add;
+					break;
+				case BinaryOperatorType.BitwiseAnd:
+					op = CodeBinaryOperatorType.BitwiseAnd;
+					break;
+				case BinaryOperatorType.BitwiseOr:
+					op = CodeBinaryOperatorType.BitwiseOr;
+					break;
+				case BinaryOperatorType.LogicalAnd:
+					op = CodeBinaryOperatorType.BooleanAnd;
+					break;
+				case BinaryOperatorType.LogicalOr:
+					op = CodeBinaryOperatorType.BooleanOr;
+					break;
+				case BinaryOperatorType.Divide:
+					op = CodeBinaryOperatorType.Divide;
+					break;
+				case BinaryOperatorType.GreaterThan:
+					op = CodeBinaryOperatorType.GreaterThan;
+					break;
+				case BinaryOperatorType.GreaterThanOrEqual:
+					op = CodeBinaryOperatorType.GreaterThanOrEqual;
+					break;
+				case BinaryOperatorType.Equality:
+					op = CodeBinaryOperatorType.IdentityEquality;
+					break;
+				case BinaryOperatorType.InEquality:
+					op = CodeBinaryOperatorType.IdentityInequality;
+					break;
+				case BinaryOperatorType.LessThan:
+					op = CodeBinaryOperatorType.LessThan;
+					break;
+				case BinaryOperatorType.LessThanOrEqual:
+					op = CodeBinaryOperatorType.LessThanOrEqual;
+					break;
+				case BinaryOperatorType.Modulus:
+					op = CodeBinaryOperatorType.Modulus;
+					break;
+				case BinaryOperatorType.Multiply:
+					op = CodeBinaryOperatorType.Multiply;
+					break;
+				case BinaryOperatorType.Subtract:
+					op = CodeBinaryOperatorType.Subtract;
+					break;
+				case BinaryOperatorType.ValueEquality:
+					op = CodeBinaryOperatorType.ValueEquality;
+					break;
+				case BinaryOperatorType.ShiftLeft:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.Multiply;
+					break;
+				case BinaryOperatorType.ShiftRight:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.Multiply;
+					break;
+				case BinaryOperatorType.IS:
+					op = CodeBinaryOperatorType.IdentityEquality;
+					break;
+				case BinaryOperatorType.AS:
+					op = CodeBinaryOperatorType.IdentityEquality;
+					break;
+				case BinaryOperatorType.ExclusiveOr:
+					// CodeDOM suxx
+					op = CodeBinaryOperatorType.BitwiseAnd;
+					break;
+			}
+			return new CodeBinaryOperatorExpression((CodeExpression)expression.Left.AcceptVisitor(this, data),
+			                                        op,
+			                                        (CodeExpression)expression.Right.AcceptVisitor(this, data));
+		}
+		
+		public override object Visit(ParenthesizedExpression expression, object data)
+		{
+			return expression.Expression.AcceptVisitor(this, data);
+		}
+		
+		public override object Visit(InvocationExpression invocationExpression, object data)
+		{
+			Expression     target     = invocationExpression.TargetObject;
+			CodeExpression targetExpr;
+			string         methodName = null;
+			if (target == null) {
+				targetExpr = new CodeThisReferenceExpression();
+			} else if (target is FieldReferenceExpression) {
+				FieldReferenceExpression fRef = (FieldReferenceExpression)target;
+				targetExpr = (CodeExpression)fRef.TargetObject.AcceptVisitor(this, data);
+				if (fRef.TargetObject is FieldReferenceExpression) {
+					FieldReferenceExpression fRef2 = (FieldReferenceExpression)fRef.TargetObject;
+					if (fRef2.FieldName != null &amp;&amp; Char.IsUpper(fRef2.FieldName[0])) {
+						// an exception is thrown if it doesn't end in an indentifier exception
+						// for example for : this.MyObject.MyMethod() leads to an exception, which 
+						// is correct in this case ... I know this is really HACKY :)
+						try {
+							targetExpr = ConvertToIdentifier(fRef2);
+						} catch (Exception) {}
+					}
+				}
+				methodName = fRef.FieldName;
+			} else {
+				targetExpr = (CodeExpression)target.AcceptVisitor(this, data);
+			}
+			return new CodeMethodInvokeExpression(targetExpr, methodName, GetExpressionList(invocationExpression.Parameters));
+		}
+		
+		public override object Visit(IdentifierExpression expression, object data)
+		{
+			if (IsField(expression.Identifier)) {
+				return new CodeFieldReferenceExpression(new CodeThisReferenceExpression(),
+				                                        expression.Identifier);
+			}
+			return new CodeVariableReferenceExpression(expression.Identifier);
+		}
+		
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			return null;
+		}
+
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			CodeExpression var;
+
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.Minus:
+					if (unaryOperatorExpression.Expression is PrimitiveExpression) {
+						PrimitiveExpression expression = (PrimitiveExpression)unaryOperatorExpression.Expression;
+						if (expression.Value is int) {
+							return new CodePrimitiveExpression(- (int)expression.Value);
+						}
+						if (expression.Value is long) {
+							return new CodePrimitiveExpression(- (long)expression.Value);
+						}
+						if (expression.Value is double) {
+							return new CodePrimitiveExpression(- (double)expression.Value);
+						}
+						if (expression.Value is float) {
+							return new CodePrimitiveExpression(- (float)expression.Value);
+						}
+						
+					} 
+					return  new CodeBinaryOperatorExpression(new CodePrimitiveExpression(0),
+			                                        CodeBinaryOperatorType.Subtract,
+			                                        (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Plus:
+					return unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+				case UnaryOperatorType.PostIncrement:
+					// emulate i++, with i = i + 1
+					var = (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+					return new CodeAssignStatement(var,
+									new CodeBinaryOperatorExpression(var,
+																	 CodeBinaryOperatorType.Add,
+																	 new CodePrimitiveExpression(1)));
+
+				case UnaryOperatorType.PostDecrement:
+					// emulate i--, with i = i - 1
+					var = (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+					return new CodeAssignStatement(var,
+						new CodeBinaryOperatorExpression(var,
+						CodeBinaryOperatorType.Subtract,
+						new CodePrimitiveExpression(1)));
+
+				case UnaryOperatorType.Decrement:
+					// emulate --i, with i = i - 1
+					var = (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+					return new CodeAssignStatement(var,
+						new CodeBinaryOperatorExpression(var,
+						CodeBinaryOperatorType.Subtract,
+						new CodePrimitiveExpression(1)));
+
+				case UnaryOperatorType.Increment:
+					// emulate ++i, with i = i + 1
+					var = (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+					return new CodeAssignStatement(var,
+						new CodeBinaryOperatorExpression(var,
+						CodeBinaryOperatorType.Add,
+						new CodePrimitiveExpression(1)));
+
+			}
+			return null;
+		}
+		bool methodReference = false;
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			if (assignmentExpression.Op == AssignmentOperatorType.Add) {
+				
+				methodReference = true;
+				CodeExpression methodInvoker = (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null);
+				methodReference = false;
+					
+				if (assignmentExpression.Left is IdentifierExpression) 
+				{
+					AddStmt(new CodeAttachEventStatement(new CodeEventReferenceExpression(new CodeThisReferenceExpression(), ((IdentifierExpression)assignmentExpression.Left).Identifier),
+					                                                          methodInvoker));
+				} else {
+					FieldReferenceExpression fr = (FieldReferenceExpression)assignmentExpression.Left;
+					
+					AddStmt(new CodeAttachEventStatement(new CodeEventReferenceExpression((CodeExpression)fr.TargetObject.AcceptVisitor(this, data), fr.FieldName),
+					                                                          methodInvoker));
+				}
+			} else {
+				if (assignmentExpression.Left is IdentifierExpression) {
+					AddStmt(new CodeAssignStatement((CodeExpression)assignmentExpression.Left.AcceptVisitor(this, null), (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null)));
+				} else {
+					AddStmt(new CodeAssignStatement((CodeExpression)assignmentExpression.Left.AcceptVisitor(this, null), (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null)));
+				}
+			}
+			return null;
+		}
+		
+		public override object Visit(CheckedStatement checkedStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(UncheckedStatement uncheckedStatement, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			return new CodeTypeOfExpression(ConvType(typeOfExpression.TypeReference.Type));
+		}
+		
+		public override object Visit(CheckedExpression checkedExpression, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		{
+			return null;
+		}
+		
+		public override object Visit(CastExpression castExpression, object data)
+		{
+			string typeRef = castExpression.CastTo.Type;
+			return new CodeCastExpression(typeRef, (CodeExpression)castExpression.Expression.AcceptVisitor(this, data));
+		}
+		
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
+		{
+			// TODO
+			return null;
+		}
+		
+		public override object Visit(IndexerExpression indexerExpression, object data)
+		{
+			return new CodeIndexerExpression((CodeExpression)indexerExpression.TargetObject.AcceptVisitor(this, data), GetExpressionList(indexerExpression.Indices));
+		}
+		
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			return new CodeThisReferenceExpression();
+		}
+		
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			return new CodeBaseReferenceExpression();
+		}
+		
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			if (arrayCreateExpression.ArrayInitializer == null) {
+				if (arrayCreateExpression.Rank != null &amp;&amp; arrayCreateExpression.Rank.Length &gt; 0) {
+					return new CodeArrayCreateExpression(ConvType(arrayCreateExpression.CreateType.Type),
+					                                     arrayCreateExpression.Rank[0]);
+				}
+				return new CodeArrayCreateExpression(ConvType(arrayCreateExpression.CreateType.Type),
+				                                     0);
+			}
+			return new CodeArrayCreateExpression(ConvType(arrayCreateExpression.CreateType.Type),
+			                                     GetExpressionList(arrayCreateExpression.ArrayInitializer.CreateExpressions));
+		}
+		
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			return new CodeObjectCreateExpression(ConvType(objectCreateExpression.CreateType.Type),
+			                                      objectCreateExpression.Parameters == null ? null : GetExpressionList(objectCreateExpression.Parameters));
+		}
+		
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			return new CodeParameterDeclarationExpression(new CodeTypeReference(ConvType(parameterDeclarationExpression.TypeReference.Type)), parameterDeclarationExpression.ParameterName);
+		}
+		
+		bool IsField(string type, string fieldName)
+		{
+			Type t       = null;
+			Assembly asm = null;
+			
+			t = this.GetType(type);
+			if (t == null)
+			{
+				asm = typeof(System.Drawing.Point).Assembly;
+				t = asm.GetType(type);
+			}
+			
+			//if (t == null) {
+			//	asm = typeof(System.Windows.Forms.Control).Assembly;
+			//	t = asm.GetType(type);
+			//}
+			
+			if (t == null) {
+				asm = typeof(System.String).Assembly;
+				t = asm.GetType(type);
+			}
+			
+			return t != null &amp;&amp; t.GetField(fieldName) != null;
+		}
+		
+		bool IsFieldReferenceExpression(FieldReferenceExpression fieldReferenceExpression)
+		{
+			if (fieldReferenceExpression.TargetObject is ThisReferenceExpression) {
+				foreach (object o in this.currentTypeDeclaration.Children) {
+					if (o is FieldDeclaration) {
+						FieldDeclaration fd = (FieldDeclaration)o;
+						foreach (VariableDeclaration field in fd.Fields) {
+							if (fieldReferenceExpression.FieldName == field.Name) {
+								return true;
+							}
+						}
+					}
+				}
+			}
+			return false; //Char.IsLower(fieldReferenceExpression.FieldName[0]);
+		}
+		
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		{
+			if (methodReference) {
+				return new CodeMethodReferenceExpression((CodeExpression)fieldReferenceExpression.TargetObject.AcceptVisitor(this, data), fieldReferenceExpression.FieldName);
+			}
+			if (IsFieldReferenceExpression(fieldReferenceExpression)) {
+				return new CodeFieldReferenceExpression((CodeExpression)fieldReferenceExpression.TargetObject.AcceptVisitor(this, data),
+				                                        fieldReferenceExpression.FieldName);
+			} else {
+				if (fieldReferenceExpression.TargetObject is FieldReferenceExpression) {
+					if (IsQualIdent((FieldReferenceExpression)fieldReferenceExpression.TargetObject)) {
+						CodeTypeReferenceExpression typeRef = ConvertToIdentifier((FieldReferenceExpression)fieldReferenceExpression.TargetObject);
+						if (IsField(typeRef.Type.BaseType, fieldReferenceExpression.FieldName)) {
+							return new CodeFieldReferenceExpression(typeRef,
+							                                           fieldReferenceExpression.FieldName);
+						} else {
+							return new CodePropertyReferenceExpression(typeRef,
+							                                           fieldReferenceExpression.FieldName);
+						}
+					}
+				}
+				
+				CodeExpression codeExpression = (CodeExpression)fieldReferenceExpression.TargetObject.AcceptVisitor(this, data);
+				return new CodePropertyReferenceExpression(codeExpression,
+				                                           fieldReferenceExpression.FieldName);
+			}
+		}
+		
+		public override object Visit(DirectionExpression directionExpression, object data)
+		{
+			return null;
+		}
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			return null;
+		}
+		public override object Visit(ConditionalExpression conditionalExpression, object data)
+		{
+			return null;
+		}
+#endregion
+		bool IsQualIdent(FieldReferenceExpression fieldReferenceExpression)
+		{
+			while (fieldReferenceExpression.TargetObject is FieldReferenceExpression) {
+				fieldReferenceExpression = (FieldReferenceExpression)fieldReferenceExpression.TargetObject;
+			}
+			return fieldReferenceExpression.TargetObject is IdentifierExpression;
+		}
+		
+		bool IsField(string identifier)
+		{
+			foreach (INode node in currentTypeDeclaration.Children) {
+				if (node is FieldDeclaration) {
+					FieldDeclaration fd = (FieldDeclaration)node;
+					if (fd.GetVariableDeclaration(identifier) != null) {
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+		
+		CodeTypeReferenceExpression ConvertToIdentifier(FieldReferenceExpression fieldReferenceExpression)
+		{
+//			CodeFieldReferenceExpression  cpre = new CodeFieldReferenceExpression (); 
+//			CodeFieldReferenceExpression firstCpre = cpre,newCpre;
+			string type = String.Empty;
+			
+			while (fieldReferenceExpression.TargetObject is FieldReferenceExpression) {
+//				newCpre = new CodeFieldReferenceExpression(); 
+//				Console.WriteLine(fieldReferenceExpression.FieldName);
+//				cpre.FieldName  = fieldReferenceExpression.FieldName;
+//				cpre.TargetObject = newCpre;
+//				cpre = newCpre;
+				type = &quot;.&quot;  + fieldReferenceExpression.FieldName + type;
+				fieldReferenceExpression = (FieldReferenceExpression)fieldReferenceExpression.TargetObject;
+			}
+			type = &quot;.&quot;  + fieldReferenceExpression.FieldName + type;
+//			newCpre = new CodeFieldReferenceExpression(); 
+//			Console.WriteLine(fieldReferenceExpression.FieldName);
+//			cpre.FieldName  = fieldReferenceExpression.FieldName;
+//			cpre.TargetObject = newCpre;
+//			cpre = newCpre;
+				
+			if (fieldReferenceExpression.TargetObject is IdentifierExpression) {
+				return new CodeTypeReferenceExpression(((IdentifierExpression)fieldReferenceExpression.TargetObject).Identifier + type);
+//				cpre.TargetObject =
+//				return firstCpre;
+			} else {
+				throw new Exception();
+			}
+		}
+		
+		CodeExpression[] GetExpressionList(ArrayList expressionList)
+		{
+			if (expressionList == null) {
+				return new CodeExpression[0];
+			}
+			CodeExpression[] list = new CodeExpression[expressionList.Count];
+			for (int i = 0; i &lt; expressionList.Count; ++i) {
+				list[i] = (CodeExpression)((Expression)expressionList[i]).AcceptVisitor(this, null);
+				if (list[i] == null) {
+					list[i] = new CodePrimitiveExpression(0);
+				}
+			}
+			return list;
+		}
+		
+		Type GetType(string typeName)
+		{
+			foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies()) 
+			{
+				Type type = asm.GetType(typeName);
+				if (type != null) 
+				{
+					return type;
+				}
+			}
+			return Type.GetType(typeName);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Lexer.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Lexer.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Lexer.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,878 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Drawing;
+using System.Diagnostics;
+using System.Globalization;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class Token
+	{
+		public int kind;
+		
+		public int col;
+		public int line;
+		
+		public object literalValue = null;
+		public string val;
+		public Token  next;
+		
+		public Point EndLocation {
+			get {
+				return new Point(col + val.Length, line);
+			}
+		}
+		public Point Location {
+			get {
+				return new Point(col, line);
+			}
+		}
+		
+		public Token()
+		{
+		}
+		
+		public Token(int kind)
+		{
+			this.kind = kind;
+		}
+		
+//		public Token(Tokens kind, int col, int line)
+//		{
+//			this.kind = kind;
+//			this.col  = col;
+//			this.line = line;
+//		}
+		
+		public Token(int kind, int col, int line, string val)
+		{
+			this.kind = kind;
+			this.col  = col;
+			this.line = line;
+			this.val  = val;
+		}
+		
+		public Token(int kind, int col, int line, string val, object literalValue)
+		{
+			this.kind         = kind;
+			this.col          = col;
+			this.line         = line;
+			this.val          = val;
+			this.literalValue = literalValue;
+		}
+	}
+	
+	public class Lexer
+	{
+		IReader reader;
+		
+		int col  = 1;
+		int line = 1;
+		
+		Errors         errors   = new Errors();
+		SpecialTracker specialTracker = new SpecialTracker();
+		Token          lastToken = null;
+		Token          curToken  = null;
+		Token          peekToken = null;
+		
+		public SpecialTracker SpecialTracker {
+			get {
+				return specialTracker;
+			}
+		}
+		
+		public Errors Errors {
+			get {
+				return errors;
+			}
+		}
+		
+		public Token Token {
+			get {
+				return lastToken;
+			}
+		}
+		
+		public Token LookAhead {
+			get {
+				return curToken;
+			}
+		}
+		
+		public void StartPeek()
+		{
+			peekToken = curToken;
+		}
+		
+		public Token Peek()
+		{
+			if (peekToken.next == null) {
+				peekToken.next = Next();
+				specialTracker.InformToken(peekToken.next.kind);
+			}
+			peekToken = peekToken.next;
+			return peekToken;
+		}
+		
+		public Token NextToken()
+		{
+			if (curToken == null) {
+				curToken = Next();
+				specialTracker.InformToken(curToken.kind);
+				return curToken;
+			}
+			
+			lastToken = curToken;
+			
+			if (curToken.next == null) {
+				curToken.next = Next();
+				specialTracker.InformToken(curToken.next.kind);
+			}
+			
+			curToken  = curToken.next;
+			return curToken;
+		}
+		
+		public Lexer(IReader reader)
+		{
+			this.reader = reader;
+		}
+		
+		Token Next()
+		{
+			while (!reader.Eos()) {
+				char ch = reader.GetNext();
+				
+				if (Char.IsWhiteSpace(ch)) {
+					++col;
+					
+					if (ch == '\n') {
+						specialTracker.AddEndOfLine();
+						++line;
+						col = 1;
+					}
+					continue;
+				}
+				
+				if (Char.IsLetter(ch) || ch == '_') {
+					int x = col;
+					int y = line;
+					string s = ReadIdent(ch);
+					if (Keywords.IsKeyword(s)) {
+						return new Token(Keywords.GetToken(s), x, y, s);
+					}
+					return new Token(Tokens.Identifier, x, y, s);
+				}
+				
+				if (Char.IsDigit(ch)) {
+					return ReadDigit(ch, col);
+				}
+				
+				if (ch == '/') {
+					if (reader.Peek() == '/' || reader.Peek() == '*') {
+						++col;
+						ReadComment();
+						continue;
+					}
+				} else if (ch == '#') {
+					Point start = new Point(col, line);
+					++col;
+					string directive = ReadIdent('#');
+					string argument  = ReadToEOL();
+					this.specialTracker.AddPreProcessingDirective(directive, argument, start, new Point(start.X + directive.Length + argument.Length, start.Y));
+					continue;
+				}
+				
+				if (ch == '&quot;') {
+					++col;
+					return ReadString();
+				}
+				
+				if (ch == '\'') {
+					++col;
+					return ReadChar();
+				}
+				
+				if (ch == '@') {
+					int x = col;
+					int y = line;
+					ch = reader.GetNext();
+					++col;
+					if (ch == '&quot;') {
+						return ReadVerbatimString();
+					}
+					if (Char.IsLetterOrDigit(ch)) {
+						return new Token(Tokens.Identifier, x, y, ReadIdent(ch));
+					}
+					errors.Error(y, x, String.Format(&quot;Unexpected char in Lexer.Next() : {0}&quot;, ch));
+				}
+				
+				Token token = ReadOperator(ch);
+				
+				// try error recovery :)
+				if (token == null) {
+					return Next();
+				}
+				return token;
+			}
+			
+			return new Token(Tokens.EOF, col, line, String.Empty);
+		}
+		
+		string ReadIdent(char ch)
+		{
+			StringBuilder s = new StringBuilder(ch.ToString());
+			++col;
+			while (!reader.Eos() &amp;&amp; (Char.IsLetterOrDigit(ch = reader.GetNext()) || ch == '_')) {
+				s.Append(ch.ToString());
+				++col;
+			}
+			if (!reader.Eos()) {
+				reader.UnGet();
+			}
+			return s.ToString();
+		}
+		
+		Token ReadDigit(char ch, int x)
+		{
+			int y = line;
+			++col;
+			StringBuilder sb = new StringBuilder(ch.ToString());
+			StringBuilder prefix = new StringBuilder();
+			StringBuilder suffix = new StringBuilder();
+			
+			bool ishex      = false;
+			bool isunsigned = false;
+			bool islong     = false;
+			bool isfloat    = false;
+			bool isdouble   = false;
+			bool isdecimal  = false;
+			
+			if (ch == '0' &amp;&amp; Char.ToUpper(reader.Peek()) == 'X') {
+				const string hex = &quot;0123456789ABCDEF&quot;;
+				reader.GetNext(); // skip 'x'
+				++col;
+				while (hex.IndexOf(Char.ToUpper(reader.Peek())) != -1) {
+					sb.Append(Char.ToUpper(reader.GetNext()));
+					++col;
+				}
+				ishex = true;
+				prefix.Append(&quot;0x&quot;);
+			} else {
+				while (Char.IsDigit(reader.Peek())) {
+					sb.Append(reader.GetNext());
+					++col;
+				}
+			}
+			
+			if (reader.Peek() == '.') { // read floating point number
+				isdouble = true; // double is default
+				if (ishex) {
+					errors.Error(y, x, String.Format(&quot;No hexadecimal floating point values allowed&quot;));
+				}
+				sb.Append(reader.GetNext());
+				++col;
+				
+				while (Char.IsDigit(reader.Peek())) { // read decimal digits beyond the dot
+					sb.Append(reader.GetNext());
+					++col;
+				}
+			}
+			
+			if (Char.ToUpper(reader.Peek()) == 'E') { // read exponent
+				isdouble = true;
+				sb.Append(reader.GetNext());
+				++col;
+				if (reader.Peek() == '-' || reader.Peek() == '+') {
+					sb.Append(reader.GetNext());
+					++col;
+				}
+				while (Char.IsDigit(reader.Peek())) { // read exponent value
+					sb.Append(reader.GetNext());
+					++col;
+				}
+				isunsigned = true;
+			}
+			
+			if (Char.ToUpper(reader.Peek()) == 'F') { // float value
+				suffix.Append(reader.Peek());
+				reader.GetNext();
+				++col;
+				isfloat = true;
+			} else if (Char.ToUpper(reader.Peek()) == 'M') { // double type suffix (obsolete, double is default)
+				suffix.Append(reader.Peek());
+				reader.GetNext();
+				++col;
+				isdouble = true;
+			} else if (Char.ToUpper(reader.Peek()) == 'D') { // decimal value
+				suffix.Append(reader.Peek());
+				reader.GetNext();
+				++col;
+				isdecimal = true;
+			} else if (!isdouble) {
+				if (Char.ToUpper(reader.Peek()) == 'U') {
+					suffix.Append(reader.Peek());
+					reader.GetNext();
+					++col;
+					isunsigned = true;
+				}
+				
+				if (Char.ToUpper(reader.Peek()) == 'L') {
+					suffix.Append(reader.Peek());
+					reader.GetNext();
+					++col;
+					islong = true;
+					if (!isunsigned &amp;&amp; Char.ToUpper(reader.Peek()) == 'U') {
+						suffix.Append(reader.Peek());
+						reader.GetNext();
+						++col;
+						isunsigned = true;
+					}
+				}
+			}
+			
+			string digit = sb.ToString();
+			string stringValue = String.Concat(prefix.ToString(), digit, suffix.ToString());
+			if (isfloat) {
+				try {
+					NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
+					numberFormatInfo.CurrencyDecimalSeparator = &quot;.&quot;;
+					return new Token(Tokens.Literal, x, y, stringValue, Single.Parse(digit, numberFormatInfo));
+				} catch (Exception) {
+					errors.Error(y, x, String.Format(&quot;Can't parse float {0}&quot;, digit));
+					return new Token(Tokens.Literal, x, y, stringValue, 0f);
+				}
+			}
+			if (isdecimal) {
+				try {
+					NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
+					numberFormatInfo.CurrencyDecimalSeparator = &quot;.&quot;;
+					return new Token(Tokens.Literal, x, y, stringValue, Decimal.Parse(digit, numberFormatInfo));
+				} catch (Exception) {
+					errors.Error(y, x, String.Format(&quot;Can't parse decimal {0}&quot;, digit));
+					return new Token(Tokens.Literal, x, y, stringValue, 0m);
+				}
+			}
+			if (isdouble) {
+				try {
+					NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
+					numberFormatInfo.CurrencyDecimalSeparator = &quot;.&quot;;
+					return new Token(Tokens.Literal, x, y, stringValue, Double.Parse(digit, numberFormatInfo));
+				} catch (Exception) {
+					errors.Error(y, x, String.Format(&quot;Can't parse double {0}&quot;, digit));
+					return new Token(Tokens.Literal, x, y, stringValue, 0d);
+				}
+			}
+			if (islong) {
+				if (isunsigned) {
+					try {
+						return new Token(Tokens.Literal, x, y, stringValue, UInt64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+					} catch (Exception) {
+						errors.Error(y, x, String.Format(&quot;Can't parse unsigned long {0}&quot;, digit));
+						return new Token(Tokens.Literal, x, y, stringValue, 0UL);
+					}
+				} else {
+					try {
+						return new Token(Tokens.Literal, x, y, stringValue, Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+					} catch (Exception) {
+						errors.Error(y, x, String.Format(&quot;Can't parse long {0}&quot;, digit));
+						return new Token(Tokens.Literal, x, y, stringValue, 0L);
+					}
+				}
+			} else {
+				if (isunsigned) {
+					try {
+						return new Token(Tokens.Literal, x, y, stringValue, UInt32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+					} catch (Exception) {
+						errors.Error(y, x, String.Format(&quot;Can't parse unsigned int {0}&quot;, digit));
+						return new Token(Tokens.Literal, x, y, stringValue, 0U);
+					}
+				} else {
+					try {
+						return new Token(Tokens.Literal, x, y, stringValue, Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+					} catch (Exception) {
+						errors.Error(y, x, String.Format(&quot;Can't parse int {0}&quot;, digit));
+						return new Token(Tokens.Literal, x, y, stringValue, 0);
+					}
+				}
+			}
+		}
+		
+		Token ReadString()
+		{
+			int x = col;
+			int y = line;
+			
+			char ch = '\0';
+			StringBuilder s             = new StringBuilder();
+			StringBuilder originalValue = new StringBuilder();
+			originalValue.Append('&quot;');
+			while (!reader.Eos() &amp;&amp; ((ch = reader.GetNext()) != '&quot;')) {
+				++col;
+				if (ch == '\\') {
+					originalValue.Append('\\');
+					originalValue.Append(ReadEscapeSequence(out ch));
+					s.Append(ch);
+				} else if (ch == '\n') {
+					errors.Error(y, x, String.Format(&quot;No new line is allowed inside a string literal&quot;));
+					break;
+				} else {
+					originalValue.Append(ch);
+					s.Append(ch);
+				}
+			}
+			if (ch != '&quot;') {
+				errors.Error(y, x, String.Format(&quot;End of file reached inside string literal&quot;));
+			}
+			originalValue.Append('&quot;');
+			return new Token(Tokens.Literal, x, y, originalValue.ToString(), s.ToString());
+		}
+		
+		Token ReadVerbatimString()
+		{
+			int x = col;
+			int y = line;
+			char ch = '\0';
+			StringBuilder s = new StringBuilder();
+			while (!reader.Eos()) {
+				ch = reader.GetNext();
+				if (ch == '&quot;') {
+					if (reader.Peek() != '&quot;') {
+						break;
+					}
+					reader.GetNext();
+				}
+				++col;
+				if (ch == '\n') {
+					++line;
+					col = 1;
+				}
+				s.Append(ch);
+			}
+			if (ch != '&quot;') {
+				errors.Error(y, x, String.Format(&quot;End of file reached inside verbatim string literal&quot;));
+			}
+			return new Token(Tokens.Literal, x, y, String.Concat(&quot;@\&quot;&quot;, s.ToString(), '&quot;'), s.ToString());
+		}
+		
+		string hexdigits = &quot;0123456789ABCDEF&quot;;
+		
+		string ReadEscapeSequence(out char ch)
+		{
+			StringBuilder s = new StringBuilder();
+			if (reader.Eos()) {
+				errors.Error(line, col, String.Format(&quot;End of file reached inside escape sequence&quot;));
+			}
+			char c = reader.GetNext();
+			s.Append(c);
+			++col;
+			switch (c)  {
+				case '\'':
+					ch = '\'';
+					break;
+				case '\&quot;':
+					ch = '\&quot;';
+					break;
+				case '\\':
+					ch = '\\';
+					break;
+				case '0':
+					ch = '\0';
+					break;
+				case 'a':
+					ch = '\a';
+					break;
+				case 'b':
+					ch = '\b';
+					break;
+				case 'f':
+					ch = '\f';
+					break;
+				case 'n':
+					ch = '\n';
+					break;
+				case 'r':
+					ch = '\r';
+					break;
+				case 't':
+					ch = '\t';
+					break;
+				case 'v':
+					ch = '\v';
+					break;
+				case 'u':
+				case 'x':
+					c = reader.GetNext();
+					int number = hexdigits.IndexOf(Char.ToUpper(c));
+					if (number &lt; 0) {
+						errors.Error(line, col, String.Format(&quot;Invalid char in literal : {0}&quot;, c));
+					}
+					s.Append(c);
+					for (int i = 0; i &lt; 3; ++i) {
+						c = reader.GetNext();
+						int idx = hexdigits.IndexOf(Char.ToUpper(c));
+						if (idx &gt;= 0) {
+							s.Append(c);
+							number = idx * (16 * (i + 1)) + number;
+						} else {
+							reader.UnGet();
+							break;
+						}
+					}
+					ch = (char)number;
+					break;
+				default:
+					errors.Error(line, col, String.Format(&quot;Unexpected escape sequence : {0}&quot;, c));
+					ch = '\0';
+					break;
+			}
+			return s.ToString();
+		}
+		
+		Token ReadChar()
+		{
+			int x = col;
+			int y = line;
+			
+			if (reader.Eos()) {
+				errors.Error(y, x, String.Format(&quot;End of file reached inside character literal&quot;));
+			}
+			StringBuilder originalValue = new StringBuilder();
+			char  ch = reader.GetNext();
+			originalValue.Append(&quot;'&quot;);
+			originalValue.Append(ch);
+			++col;
+			
+			if (ch == '\\') {
+				originalValue.Append(ReadEscapeSequence(out ch));
+			}
+			
+			if (reader.Eos()) {
+				errors.Error(y, x, String.Format(&quot;End of file reached inside character literal&quot;));
+			}
+			if (reader.GetNext() != '\'') {
+				errors.Error(y, x, String.Format(&quot;Char not terminated&quot;));
+			}
+			originalValue.Append(&quot;'&quot;);
+			return new Token(Tokens.Literal, x, y, originalValue.ToString(), ch);
+		}
+		
+		Token ReadOperator(char ch)
+		{
+			int x = col;
+			int y = line;
+			++col;
+			switch (ch) {
+				case '+':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '+':
+								++col;
+								return new Token(Tokens.Increment, x, y, &quot;++&quot;);
+							case '=':
+								++col;
+								return new Token(Tokens.PlusAssign, x, y, &quot;+=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Plus, x, y, &quot;+&quot;);
+				case '-':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '-':
+								++col;
+								return new Token(Tokens.Decrement, x, y, &quot;--&quot;);
+							case '=':
+								++col;
+								return new Token(Tokens.MinusAssign, x, y, &quot;-=&quot;);
+							case '&gt;':
+								++col;
+								return new Token(Tokens.Pointer, x, y, &quot;-&gt;&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Minus, x, y, &quot;-&quot;);
+				case '*':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.TimesAssign, x, y, &quot;*=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Times, x, y, &quot;*&quot;);
+				case '/':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.DivAssign, x, y, &quot;/=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Div, x, y, &quot;/&quot;);
+				case '%':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.ModAssign, x, y, &quot;%=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Mod, x, y, &quot;%&quot;);
+				case '&amp;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '&amp;':
+								++col;
+								return new Token(Tokens.LogicalAnd, x, y, &quot;&amp;&amp;&quot;);
+							case '=':
+								++col;
+								return new Token(Tokens.BitwiseAndAssign, x, y, &quot;&amp;=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.BitwiseAnd, x, y, &quot;&amp;&quot;);
+				case '|':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '|':
+								++col;
+								return new Token(Tokens.LogicalOr, x, y, &quot;||&quot;);
+							case '=':
+								++col;
+								return new Token(Tokens.BitwiseOrAssign, x, y, &quot;|=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.BitwiseOr, x, y, &quot;|&quot;);
+				case '^':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.XorAssign, x, y, &quot;^=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Xor, x, y, &quot;^&quot;);
+				case '!':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.NotEqual, x, y, &quot;!=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Not, x, y, &quot;!&quot;);
+				case '~':
+					return new Token(Tokens.BitwiseComplement, x, y, &quot;~&quot;);
+				case '=':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '=':
+								++col;
+								return new Token(Tokens.Equal, x, y, &quot;==&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.Assign, x, y, &quot;=&quot;);
+				case '&lt;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '&lt;':
+								if (!reader.Eos()) {
+									switch (reader.GetNext()) {
+										case '=':
+											col += 2;
+											return new Token(Tokens.ShiftLeftAssign, x, y, &quot;&lt;&lt;=&quot;);
+										default:
+											++col;
+											reader.UnGet();
+											break;
+									}
+								}
+								return new Token(Tokens.ShiftLeft, x, y, &quot;&lt;&lt;&quot;);
+							case '=':
+								++col;
+								return new Token(Tokens.LessEqual, x, y, &quot;&lt;=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.LessThan, x, y, &quot;&lt;&quot;);
+				case '&gt;':
+					if (!reader.Eos()) {
+						switch (reader.GetNext()) {
+							case '&gt;':
+								if (!reader.Eos()) {
+									switch (reader.GetNext()) {
+										case '=':
+											col += 2;
+											return new Token(Tokens.ShiftRightAssign, x, y, &quot;&gt;&gt;=&quot;);
+										default:
+											++col;
+											reader.UnGet();
+											break;
+									}
+								}
+								return new Token(Tokens.ShiftRight, x, y, &quot;&gt;&gt;&quot;);
+							case '=':
+								++col;
+								return new Token(Tokens.GreaterEqual, x, y, &quot;&gt;=&quot;);
+							default:
+								reader.UnGet();
+								break;
+						}
+					}
+					return new Token(Tokens.GreaterThan, x, y, &quot;&gt;&quot;);
+				case '?':
+					return new Token(Tokens.Question, x, y, &quot;?&quot;);
+				case ';':
+					return new Token(Tokens.Semicolon, x, y, &quot;;&quot;);
+				case ':':
+					return new Token(Tokens.Colon, x, y, &quot;:&quot;);
+				case ',':
+					return new Token(Tokens.Comma, x, y, &quot;,&quot;);
+				case '.':
+					if (Char.IsDigit(reader.Peek())) {
+						 reader.UnGet();
+						 col -= 2;
+						 return ReadDigit('0', col + 1);
+					}
+					return new Token(Tokens.Dot, x, y, &quot;.&quot;);
+				case ')':
+					return new Token(Tokens.CloseParenthesis, x, y, &quot;)&quot;);
+				case '(':
+					return new Token(Tokens.OpenParenthesis, x, y, &quot;(&quot;);
+				case ']':
+					return new Token(Tokens.CloseSquareBracket, x, y, &quot;]&quot;);
+				case '[':
+					return new Token(Tokens.OpenSquareBracket, x, y, &quot;[&quot;);
+				case '}':
+					return new Token(Tokens.CloseCurlyBrace, x, y, &quot;}&quot;);
+				case '{':
+					return new Token(Tokens.OpenCurlyBrace, x, y, &quot;{&quot;);
+				default:
+					--col;
+					return null;
+			}
+		}
+		
+		void ReadComment()
+		{
+			char ch = reader.GetNext();
+			++col;
+			switch (ch) {
+				case '*':
+					ReadMultiLineComment();
+					break;
+				case '/':
+					if (reader.GetNext() == '/') {
+						ReadSingleLineComment(CommentType.Documentation);
+					} else {
+						reader.UnGet();
+						ReadSingleLineComment(CommentType.SingleLine);
+					}
+					break;
+				default:
+					errors.Error(line, col, String.Format(&quot;Error while reading comment&quot;));
+					break;
+			}
+		}
+		
+		string ReadToEOL()
+		{
+			StringBuilder sb = new StringBuilder();
+			if (!reader.Eos()) {
+				char ch = reader.GetNext();
+				while (!reader.Eos()) {
+					if (ch == '\n') {
+						++line;
+						col = 1;
+						return sb.ToString();
+					} else {
+						sb.Append(ch);
+					}
+					ch = reader.GetNext();
+					++col;
+				}
+			}
+			return sb.ToString();
+		}
+		
+		void ReadSingleLineComment(CommentType commentType)
+		{
+			specialTracker.StartComment(commentType, new Point(line, col));
+			specialTracker.AddString(ReadToEOL());
+			specialTracker.FinishComment();
+		}
+		
+		void ReadMultiLineComment()
+		{
+			specialTracker.StartComment(CommentType.Block, new Point(line, col));
+			int x = col;
+			int y = line;
+			while (!reader.Eos()) {
+				char ch;
+				switch (ch = reader.GetNext()) {
+					case '\n':
+						specialTracker.AddChar('\n');
+						++line;
+						col = 1;
+						break;
+					case '*':
+						++col;
+						switch (reader.Peek()) {
+							case '/':
+								reader.GetNext();
+								++col;
+								specialTracker.FinishComment();
+								return;
+							default:
+								specialTracker.AddChar('*');
+								continue;
+						}
+					default:
+						specialTracker.AddChar(ch);
+						++col;
+						break;
+				}
+			}
+			specialTracker.FinishComment();
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/FileReader.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/FileReader.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/FileReader.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,53 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class FileReader : IReader
+	{
+		string file = null;
+		int    ptr  = 0;
+		
+		public FileReader(string filename)
+		{
+			StreamReader sreader = File.OpenText(filename);
+			file = sreader.ReadToEnd();
+			sreader.Close();
+		}
+		
+		public char GetNext()
+		{
+//			if (Eos()) {
+//				throw new ParserException(&quot;warning : FileReader.GetNext : Read char over eos.&quot;, 0, 0);
+//			}
+			return file[ptr++];
+		}
+		
+		public char Peek()
+		{
+//			if (Eos()) {
+//				throw new ParserException(&quot;warning : FileReader.Peek : Read char over eos.&quot;, 0, 0);
+//			}
+			return file[ptr];
+		}
+		
+		public void UnGet()
+		{
+			--ptr;
+//			if (ptr &lt; 0) 
+//				throw new Exception(&quot;error : FileReader.UnGet : ungetted first char&quot;);
+		}
+		
+		public bool Eos()
+		{
+			return ptr &gt;= file.Length;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/IReader.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/IReader.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/IReader.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,19 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public interface IReader
+	{
+		char GetNext();
+		char Peek();
+		
+		void UnGet();
+		
+		bool Eos();
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/StringReader.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/StringReader.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Reader/StringReader.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,49 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class StringReader : IReader
+	{
+		string data = null;
+		int    ptr  = 0;
+		
+		public StringReader(string data)
+		{
+			this.data = data;
+		}
+		
+		public char GetNext()
+		{
+			if (Eos()) {
+				return '\0';
+			}
+			return data[ptr++];
+		}
+		
+		public char Peek()
+		{
+			if (Eos()) {
+				return '\0';
+			}
+			return data[ptr];
+		}
+		
+		public void UnGet()
+		{
+			ptr = Math.Max(0, ptr - 1);
+		}
+		
+		public bool Eos()
+		{
+			return ptr &gt;= data.Length;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/BlankLine.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/BlankLine.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/BlankLine.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,14 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class BlankLine
+	{
+		public BlankLine()
+		{
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/Comment.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/Comment.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/Comment.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,56 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+using System.Drawing;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class Comment
+	{
+		CommentType   commentType;
+		string        comment;
+		Point         startPosition;
+		
+		public CommentType CommentType {
+			get {
+				return commentType;
+			}
+			set {
+				commentType = value;
+			}
+		}
+		
+		public string CommentText {
+			get {
+				return comment;
+			}
+			set {
+				comment = value;
+			}
+		}
+		
+		public Point StartPosition {
+			get {
+				return startPosition;
+			}
+			set {
+				startPosition = value;
+			}
+		}
+		
+		public Comment(CommentType commentType, string comment, Point startPosition)
+		{
+			this.commentType   = commentType;
+			this.comment       = comment;
+			this.startPosition = startPosition;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[Comment: CommentType = {0}]&quot;,
+			                     CommentType);
+		}
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/CommentType.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/CommentType.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/CommentType.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,14 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public enum CommentType
+	{
+		Block,
+		SingleLine,
+		Documentation
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/PreProcessingDirective.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/PreProcessingDirective.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/PreProcessingDirective.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,66 @@
+using System;
+using System.Drawing;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class PreProcessingDirective
+	{
+		string cmd;
+		string arg;
+		Point  start;
+		Point  end;
+		
+		public Point Start {
+			get {
+				return start;
+			}
+			set {
+				start = value;
+			}
+		}
+		
+		public Point End {
+			get {
+				return end;
+			}
+			set {
+				end = value;
+			}
+		}
+		
+		public string Cmd {
+			get {
+				return cmd;
+			}
+			set {
+				cmd = value;
+			}
+		}
+		
+		public string Arg {
+			get {
+				return arg;
+			}
+			set {
+				arg = value;
+			}
+		}
+		public override string ToString()
+		{
+			return String.Format(&quot;[PreProcessingDirective: Cmd = {0}, Arg = {1}]&quot;,
+			                     Cmd,
+			                     Arg);
+		}
+		
+		public PreProcessingDirective(string cmd, string arg, Point start, Point end)
+		{
+			this.cmd = cmd;
+			this.arg = arg;
+			this.start = start;
+			this.end = end;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/SpecialTracker.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/SpecialTracker.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/SpecialTracker.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,68 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+using System.Drawing;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class SpecialTracker
+	{
+		ArrayList    currentSpecials = new ArrayList();
+		
+		CommentType   currentCommentType;
+		StringBuilder sb                  = new StringBuilder();
+		Point         startPosition;
+		
+		public ArrayList CurrentSpecials {
+			get {
+				return currentSpecials;
+			}
+		}
+		
+		public void InformToken(int kind)
+		{
+			currentSpecials.Add(kind);
+		}
+		
+		public ArrayList RetrieveSpecials()
+		{
+			ArrayList tmp = currentSpecials;
+			currentSpecials = new ArrayList();
+			return tmp;
+		}
+		
+		public void AddEndOfLine()
+		{
+			currentSpecials.Add(new BlankLine());
+		}
+		
+		public void AddPreProcessingDirective(string cmd, string arg, Point start, Point end)
+		{
+			currentSpecials.Add(new PreProcessingDirective(cmd, arg, start, end));
+		}
+		
+		// used for comment tracking
+		public void StartComment(CommentType commentType, Point startPosition)
+		{
+			this.currentCommentType = commentType;
+			this.startPosition      = startPosition;
+			this.sb.Length          = 0; 
+		}
+		
+		public void AddChar(char c)
+		{
+			sb.Append(c);
+		}
+		
+		public void AddString(string s)
+		{
+			sb.Append(s);
+		}
+		
+		public void FinishComment()
+		{
+			currentSpecials.Add(new Comment(currentCommentType, sb.ToString(), startPosition));
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/SpecialType.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/SpecialType.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Specials/SpecialType.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,13 @@
+using System;
+using System.Text;
+using System.CodeDom;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public enum SpecialType {
+		SingleLine,
+		Documentation,
+		Block
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Tokens.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Tokens.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Lexer/Tokens.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,164 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public sealed class Tokens
+	{
+		/*----- terminal classes -----*/
+		public const int EOF                = 0;
+		public const int Identifier         = 1;
+		public const int Literal            = 2;
+		
+		/*----- special character -----*/
+		public const int Assign             = 3;
+		public const int Plus               = 4;
+		public const int Minus              = 5;
+		public const int Times              = 6;
+		public const int Div                = 7;
+		public const int Mod                = 8;
+		
+		public const int Colon              = 9;
+		public const int Semicolon          = 10;
+		public const int Question           = 11;
+		public const int Comma              = 12;
+		public const int Dot                = 13;
+		
+		public const int OpenCurlyBrace     = 14;
+		public const int CloseCurlyBrace    = 15;
+		
+		public const int OpenSquareBracket  = 16;
+		public const int CloseSquareBracket = 17;
+		
+		public const int OpenParenthesis    = 18;
+		public const int CloseParenthesis   = 19;
+		
+		public const int GreaterThan        = 20;
+		public const int LessThan           = 21;
+		
+		public const int Not                = 22;
+		public const int LogicalAnd         = 23;
+		public const int LogicalOr          = 24;
+		
+		public const int BitwiseComplement  = 25;
+		public const int BitwiseAnd         = 26;
+		public const int BitwiseOr          = 27;
+		public const int Xor                = 28;
+		
+		/*----- special character sequences -----*/
+		public const int Increment          = 29;
+		public const int Decrement          = 30;
+		public const int Equal              = 31;
+		public const int NotEqual           = 32;
+		public const int GreaterEqual       = 33;
+		public const int LessEqual          = 34;
+		
+		public const int ShiftLeft          = 35;
+		public const int ShiftRight         = 36;
+		
+		public const int PlusAssign         = 37;
+		public const int MinusAssign        = 38;
+		public const int TimesAssign        = 39;
+		public const int DivAssign          = 40;
+		public const int ModAssign          = 41;
+		public const int BitwiseAndAssign   = 42;
+		public const int BitwiseOrAssign    = 43;
+		public const int XorAssign          = 44;
+		public const int ShiftLeftAssign    = 45;
+		public const int ShiftRightAssign   = 46;
+		
+		public const int Pointer            = 47;
+		
+		/*----- C# keywords -----*/
+		public const int Abstract           = 48;
+		public const int As                 = 49;
+		public const int Base               = 50;
+		public const int Bool               = 51;
+		public const int Break              = 52;
+		public const int Byte               = 53;
+		public const int Case               = 54;
+		public const int Catch              = 55;
+		public const int Char               = 56;
+		public const int Checked            = 57;
+		
+		public const int Class              = 58;
+		public const int Const              = 59;
+		public const int Continue           = 60;
+		public const int Decimal            = 61;
+		public const int Default            = 62;
+		public const int Delegate           = 63;
+		public const int Do                 = 64;
+		public const int Double             = 65;
+		public const int Else               = 66;
+		public const int Enum               = 67;
+		
+		public const int Event              = 68;
+		public const int Explicit           = 69;
+		public const int Extern             = 70;
+		public const int False              = 71;
+		public const int Finally            = 72;
+		public const int Fixed              = 73;
+		public const int Float              = 74;
+		public const int For                = 75;
+		public const int Foreach            = 76;
+		public const int Goto               = 77;
+		
+		public const int If                 = 78;
+		public const int Implicit           = 79;
+		public const int In                 = 80;
+		public const int Int                = 81;
+		public const int Interface          = 82;
+		public const int Internal           = 83;
+		public const int Is                 = 84;
+		public const int Lock               = 85;
+		public const int Long               = 86;
+		public const int Namespace          = 87;
+		
+		public const int New                = 88;
+		public const int Null               = 89;
+		public const int Object             = 90;
+		public const int Operator           = 91;
+		public const int Out                = 92;
+		public const int Override           = 93;
+		public const int Params             = 94;
+		public const int Private            = 95;
+		public const int Protected          = 96;
+		public const int Public             = 97;
+		
+		public const int Readonly           = 98;
+		public const int Ref                = 99;
+		public const int Return             = 100;
+		public const int Sbyte              = 101;
+		public const int Sealed             = 102;
+		public const int Short              = 103;
+		public const int Sizeof             = 104;
+		public const int Stackalloc         = 105;
+		public const int Static             = 106;
+		public const int String             = 107;
+		
+		public const int Struct             = 108;
+		public const int Switch             = 109;
+		public const int This               = 110;
+		public const int Throw              = 111;
+		public const int True               = 112;
+		public const int Try                = 113;
+		public const int Typeof             = 114;
+		public const int Uint               = 115;
+		public const int Ulong              = 116;
+		public const int Unchecked          = 117;
+		
+		public const int Unsafe             = 118;
+		public const int Ushort             = 119;
+		public const int Using              = 120;
+		public const int Virtual            = 121;
+		public const int Void               = 122;
+		public const int Volatile           = 123;
+		public const int While              = 124;
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Main.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Main.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Main.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,100 @@
+// project created on 09.08.2003 at 10:16
+using System;
+using System.Collections.Specialized;
+using System.IO;
+using System.CodeDom;
+using System.CodeDom.Compiler;
+using Microsoft.CSharp;
+
+using ICSharpCode.SharpRefactory.PrettyPrinter;
+using ICSharpCode.SharpRefactory.Parser;
+
+
+class MainClass
+{
+	public static StringCollection SearchDirectory(string directory, string filemask)
+	{
+		return SearchDirectory(directory, filemask, true);
+	}
+	
+	public static StringCollection SearchDirectory(string directory, string filemask, bool searchSubdirectories)
+	{
+		StringCollection collection = new StringCollection();
+		SearchDirectory(directory, filemask, collection, searchSubdirectories);
+		return collection;
+	}
+	
+	/// &lt;summary&gt;
+	/// Finds all files which are valid to the mask &lt;code&gt;filemask&lt;/code&gt; in the path
+	/// &lt;code&gt;directory&lt;/code&gt; and all subdirectories (if searchSubdirectories
+	/// is true. The found files are added to the StringCollection 
+	/// &lt;code&gt;collection&lt;/code&gt;.
+	/// &lt;/summary&gt;
+	static void SearchDirectory(string directory, string filemask, StringCollection collection, bool searchSubdirectories)
+	{
+		try {
+			string[] file = Directory.GetFiles(directory, filemask);
+			foreach (string f in file) {
+				collection.Add(f);
+			}
+			
+			if (searchSubdirectories) {
+				string[] dir = Directory.GetDirectories(directory);
+				foreach (string d in dir) {
+					SearchDirectory(d, filemask, collection, searchSubdirectories);
+				}
+			}
+		} catch (Exception) {
+		}
+	}
+	
+	static void PrettyPrintDirectories()
+	{
+		StringCollection files = SearchDirectory(&quot;C:\\b&quot;, &quot;*.cs&quot;);
+		foreach (string fileName in files) {
+			Parser p = new Parser();
+			Console.Write(&quot;Converting : &quot; + fileName);
+			p.Parse(new Lexer(new FileReader(fileName)));
+			if (p.Errors.count == 0) {
+				StreamReader sr = File.OpenText(fileName);
+				string content = sr.ReadToEnd();
+				sr.Close();
+				PrettyPrintVisitor ppv = new PrettyPrintVisitor(content);
+				ppv.Visit(p.compilationUnit, null);
+				
+				StreamWriter sw = new StreamWriter(fileName);
+				sw.Write(ppv.Text);
+				sw.Close();
+				
+				Console.WriteLine(&quot; done.&quot;);
+			} else {
+				Console.Write(&quot; Source code errors:&quot;);
+				Console.WriteLine(p.Errors.ErrorOutput);
+			}
+		}
+		Console.ReadLine();
+	}
+
+	public static void Main (string[] args)
+	{
+//		PrettyPrintDirectories();
+		Parser p = new Parser();
+		string fileName = &quot;C:\\a.cs&quot;;
+		Console.Write(&quot;Converting : &quot; + fileName);
+		p.Parse(new Lexer(new FileReader(fileName)));
+		if (p.Errors.count == 0) {
+			StreamReader sr = File.OpenText(fileName);
+			string content = sr.ReadToEnd();
+			sr.Close();
+			PrettyPrintVisitor ppv = new PrettyPrintVisitor(content);
+			ppv.Visit(p.compilationUnit, null);
+			
+			Console.WriteLine(ppv.Text);
+			
+			Console.WriteLine(&quot; done.&quot;);
+		} else {
+			Console.Write(&quot; Source code errors:&quot;);
+			Console.WriteLine(p.Errors.ErrorOutput);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AbstractASTVisitor.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AbstractASTVisitor.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AbstractASTVisitor.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,640 @@
+using System;
+using System.Collections;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public abstract class AbstractASTVisitor : IASTVisitor
+	{
+		protected Stack blockStack = new Stack();
+		
+		public BlockStatement CurrentBlock {
+			get {
+				if (blockStack.Count == 0) {
+					return null;
+				}
+				return (BlockStatement)blockStack.Peek();
+			}
+		}
+		
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
+		public virtual object Visit(INode node, object data)
+		{
+			Console.WriteLine(&quot;Warning: INode visited&quot;);
+			Console.WriteLine(&quot;Visitor was: &quot; + this.GetType());
+			Console.WriteLine(&quot;Node was : &quot; + node.GetType());
+			return node.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(CompilationUnit compilationUnit, object data)
+		{
+			if (compilationUnit == null) {
+				return data;
+			}
+			return compilationUnit.AcceptChildren(this, data);
+		}
+		
+#region Global Scope
+		public virtual object Visit(UsingDeclaration usingDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			return namespaceDeclaration.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(AttributeSection attributeSection, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			foreach (AttributeSection section in typeDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			return typeDeclaration.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+			foreach (AttributeSection section in delegateDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			foreach (ParameterDeclarationExpression p in delegateDeclaration.Parameters) {
+				p.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+#endregion
+
+#region Type level
+		public virtual object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			if (variableDeclaration.Initializer != null) {
+				return variableDeclaration.Initializer.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			foreach (AttributeSection section in fieldDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			foreach (VariableDeclaration var in fieldDeclaration.Fields) {
+				var.AcceptVisitor(this, fieldDeclaration);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			foreach (AttributeSection section in propertyDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			if (propertyDeclaration.HasGetRegion) {
+				propertyDeclaration.GetRegion.AcceptVisitor(this, data);
+			}
+			if (propertyDeclaration.HasSetRegion) {
+				propertyDeclaration.SetRegion.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			foreach (AttributeSection section in propertyGetRegion.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			blockStack.Push(propertyGetRegion.Block);
+			object ret = data;
+			if (propertyGetRegion.Block != null) {
+				ret = propertyGetRegion.Block.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(PropertySetRegion propertySetRegion, object data)
+		{
+			foreach (AttributeSection section in propertySetRegion.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			blockStack.Push(propertySetRegion.Block);
+			object ret = data;
+			if (propertySetRegion.Block != null) {
+				ret = propertySetRegion.Block.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			foreach (AttributeSection section in eventDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			if (eventDeclaration.HasAddRegion) {
+				eventDeclaration.AddRegion.AcceptVisitor(this, data);
+			}
+			if (eventDeclaration.HasRemoveRegion) {
+				eventDeclaration.RemoveRegion.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(EventAddRegion eventAddRegion, object data)
+		{
+			foreach (AttributeSection section in eventAddRegion.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			blockStack.Push(eventAddRegion.Block);
+			object ret = data;
+			if (eventAddRegion.Block != null) {
+				ret = eventAddRegion.Block.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(EventRemoveRegion eventRemoveRegion, object data)
+		{
+			foreach (AttributeSection section in eventRemoveRegion.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			blockStack.Push(eventRemoveRegion.Block);
+			object ret = data;
+			if (eventRemoveRegion.Block != null) {
+				eventRemoveRegion.Block.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			foreach (AttributeSection section in parameterDeclarationExpression.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			return parameterDeclarationExpression.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(IndexerDeclaration indexerDeclaration, object data)
+		{
+			foreach (AttributeSection section in indexerDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			foreach (ParameterDeclarationExpression p in indexerDeclaration.Parameters) {
+				p.AcceptVisitor(this, data);
+			}
+			if (indexerDeclaration.HasGetRegion) {
+				indexerDeclaration.GetRegion.AcceptVisitor(this, data);
+			}
+			if (indexerDeclaration.HasSetRegion) {
+				indexerDeclaration.SetRegion.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			foreach (AttributeSection section in methodDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			blockStack.Push(methodDeclaration.Body);
+			foreach (ParameterDeclarationExpression p in methodDeclaration.Parameters) {
+				p.AcceptVisitor(this, data);
+			}
+			object ret = data;
+			if (methodDeclaration.Body != null) {
+				methodDeclaration.Body.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			foreach (AttributeSection section in constructorDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			blockStack.Push(constructorDeclaration.Body);
+			foreach (ParameterDeclarationExpression p in constructorDeclaration.Parameters) {
+				p.AcceptVisitor(this, data);
+			}
+			object ret = data;
+			if (constructorDeclaration.Body != null) {
+				ret = constructorDeclaration.Body.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		public virtual object Visit(DestructorDeclaration destructorDeclaration, object data)
+		{
+			foreach (AttributeSection section in destructorDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			blockStack.Push(destructorDeclaration.Body);
+			object ret = data;
+			if (destructorDeclaration.Body != null) {
+				destructorDeclaration.Body.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(OperatorDeclaration operatorDeclaration, object data)
+		{
+			foreach (AttributeSection section in operatorDeclaration.Attributes) {
+				section.AcceptVisitor(this, data);
+			}
+			blockStack.Push(operatorDeclaration.Body);
+			object ret = data;
+			if (operatorDeclaration.Body != null) {
+				ret = operatorDeclaration.Body.AcceptChildren(this, data);
+			}
+			blockStack.Pop();
+			return ret;
+		}
+#endregion
+		
+#region Statements
+		public virtual object Visit(BlockStatement blockStatement, object data)
+		{
+			if (blockStatement == null) {
+				return null;
+			}
+			blockStack.Push(blockStatement);
+			object ret = blockStatement.AcceptChildren(this, data);
+			blockStack.Pop();
+			return ret;
+		}
+		
+		public virtual object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			foreach (VariableDeclaration decl in localVariableDeclaration.Variables) {
+				decl.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(EmptyStatement emptyStatement, object data)
+		{
+			return data;
+		}
+		
+		public virtual object Visit(IfStatement ifStatement, object data)
+		{
+			object ret = data;
+			if (ifStatement.Condition != null) {
+				ret = ifStatement.Condition.AcceptVisitor(this, data);
+			}
+			if (ifStatement.EmbeddedStatement != null) {
+				ret = ifStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		public virtual object Visit(IfElseStatement ifElseStatement, object data)
+		{
+			object ret = data;
+			if (ifElseStatement.Condition != null) {
+				ret = ifElseStatement.Condition.AcceptVisitor(this, data);
+			}
+			if (ifElseStatement.EmbeddedStatement != null) {
+				ret = ifElseStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			if (ifElseStatement.EmbeddedElseStatement != null) {
+				ret = ifElseStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		
+		public virtual object Visit(WhileStatement whileStatement, object data)
+		{
+			object ret = data;
+			if (whileStatement.Condition != null) {
+				ret = whileStatement.Condition.AcceptVisitor(this, data);
+			}
+			if (whileStatement.EmbeddedStatement == null) {
+				return ret;
+			}
+			return whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(DoWhileStatement doWhileStatement, object data)
+		{
+			object ret = data;
+			if (doWhileStatement.Condition != null) {
+				ret = doWhileStatement.Condition.AcceptVisitor(this, data);
+			}
+			if (doWhileStatement.EmbeddedStatement == null) {
+				return ret;
+			}
+			return doWhileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ForStatement forStatement, object data)
+		{
+			object ret = data;
+			if (forStatement.Initializers != null) {
+				foreach(INode n in forStatement.Initializers) {
+					n.AcceptVisitor(this, data);
+				}
+			}
+			if (forStatement.Condition != null) {
+				ret = forStatement.Condition.AcceptVisitor(this, data);
+			}
+			if (forStatement.Iterator != null) {
+				foreach(INode n in forStatement.Iterator) {
+					n.AcceptVisitor(this, data);
+				}
+			}
+			if (forStatement.EmbeddedStatement == null) {
+				return ret;
+			}
+			return forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ForeachStatement foreachStatement, object data)
+		{
+			if (foreachStatement.Expression != null) {
+				foreachStatement.Expression.AcceptVisitor(this, data);
+			}
+			if (foreachStatement.EmbeddedStatement == null) {
+				return data;
+			}
+			return foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(LabelStatement labelStatement, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(GotoStatement gotoStatement, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(BreakStatement breakStatement, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(ContinueStatement continueStatement, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(ReturnStatement returnStatement, object data)
+		{
+			if (returnStatement.ReturnExpression != null) {
+				return returnStatement.ReturnExpression.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(SwitchStatement switchStatement, object data)
+		{
+			if (switchStatement == null) {
+				return null;
+			}
+			if (switchStatement.SwitchExpression != null) {
+				switchStatement.SwitchExpression.AcceptVisitor(this, data);
+			}
+			foreach (SwitchSection section in switchStatement.SwitchSections) {
+				section.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(SwitchSection switchSection, object data)
+		{
+			foreach (CaseLabel label in switchSection.SwitchLabels) {
+				if (label.Label != null) {
+					label.Label.AcceptVisitor(this, data);
+				}
+			}
+			return switchSection.AcceptChildren(this, data);
+		}
+		
+		public virtual object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		{
+			if (gotoCaseStatement.CaseExpression != null) {
+				gotoCaseStatement.CaseExpression.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(LockStatement lockStatement, object data)
+		{
+			if (lockStatement.EmbeddedStatement == null) {
+				return data;
+			}
+			return lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(UsingStatement usingStatement, object data)
+		{
+			object ret = data;
+			if (usingStatement.UsingStmnt != null) {
+				ret = usingStatement.UsingStmnt.AcceptVisitor(this, data);
+			}
+			if (usingStatement.EmbeddedStatement != null) {
+				ret = usingStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			return ret;
+		}
+		public virtual object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			if (tryCatchStatement == null) {
+				return data;
+			}
+			if (tryCatchStatement.StatementBlock != null) {
+				tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
+			}
+			if (tryCatchStatement.CatchClauses != null) {
+				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
+					if (catchClause != null) {
+						catchClause.StatementBlock.AcceptVisitor(this, data);
+					}
+				}
+			}
+			if (tryCatchStatement.FinallyBlock != null) {
+				return tryCatchStatement.FinallyBlock.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		public virtual object Visit(ThrowStatement throwStatement, object data)
+		{
+			if (throwStatement.ThrowExpression == null) {
+				return data;
+			}
+			return throwStatement.ThrowExpression.AcceptVisitor(this, data);
+		}
+		
+		public virtual object Visit(FixedStatement fixedStatement, object data)
+		{
+			return fixedStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(CheckedStatement checkedStatement, object data)
+		{
+			if (checkedStatement.Block == null) {
+				return data;
+			}
+			return checkedStatement.Block.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(UncheckedStatement uncheckedStatement, object data)
+		{
+			if (uncheckedStatement.Block == null) {
+				return null;
+			}
+			return uncheckedStatement.Block.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(StatementExpression statementExpression, object data)
+		{
+			if (statementExpression.Expression == null) {
+				return null;
+			}
+			return statementExpression.Expression.AcceptVisitor(this, data);
+		}
+#endregion
+		
+#region Expressions
+		public virtual object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			binaryOperatorExpression.Left.AcceptVisitor(this, data);
+			return binaryOperatorExpression.Right.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			return parenthesizedExpression.Expression.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		{
+			if (fieldReferenceExpression.TargetObject != null) {
+				return fieldReferenceExpression.TargetObject.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		public virtual object Visit(InvocationExpression invocationExpression, object data)
+		{
+			if (invocationExpression.TargetObject != null) {
+				return invocationExpression.TargetObject.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		public virtual object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			return unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			if (assignmentExpression.Left == null || assignmentExpression.Right == null) return null;
+			assignmentExpression.Left.AcceptVisitor(this, data);
+			return assignmentExpression.Right.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(SizeOfExpression sizeOfExpression, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(CheckedExpression checkedExpression, object data)
+		{
+			return checkedExpression.Expression.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(UncheckedExpression uncheckedExpression, object data)
+		{
+			return uncheckedExpression.Expression.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		{
+			return pointerReferenceExpression.Expression.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(CastExpression castExpression, object data)
+		{
+			return castExpression.Expression.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(StackAllocExpression stackAllocExpression, object data)
+		{
+			return stackAllocExpression.Expression.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(IndexerExpression indexerExpression, object data)
+		{
+			return indexerExpression.TargetObject.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			return data;
+		}
+		public virtual object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			foreach (Expression e in objectCreateExpression.Parameters) {
+				e.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		
+		public virtual object Visit(ArrayCreationParameter arrayCreationParameter, object data)
+		{
+			if (arrayCreationParameter.Expressions != null) {
+				foreach (Expression e in arrayCreationParameter.Expressions) {
+					e.AcceptVisitor(this, data);
+				}
+			}
+			return data;
+		}
+		
+		public virtual object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			if (arrayCreateExpression.Parameters != null) {
+				foreach (INode node in arrayCreateExpression.Parameters) {
+					node.AcceptVisitor(this, data);
+				}
+			}
+			if (arrayCreateExpression.ArrayInitializer != null) {
+				return arrayCreateExpression.ArrayInitializer.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		public virtual object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			foreach (Expression e in arrayInitializerExpression.CreateExpressions) {
+				e.AcceptVisitor(this, data);
+			}
+			return data;
+		}
+		public virtual object Visit(DirectionExpression directionExpression, object data)
+		{
+			return directionExpression.Expression.AcceptVisitor(this, data);
+		}
+		public virtual object Visit(ConditionalExpression conditionalExpression, object data)
+		{
+			conditionalExpression.TestCondition.AcceptVisitor(this, data);
+			conditionalExpression.TrueExpression.AcceptVisitor(this, data);
+			return conditionalExpression.FalseExpression.AcceptVisitor(this, data);
+		}
+#endregion
+#endregion
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AbstractNode.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AbstractNode.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AbstractNode.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,122 @@
+// AbstractNode.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Text;
+using System.Drawing;
+
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public abstract class AbstractNode : INode
+	{
+		INode     parent;
+		ArrayList children;
+		Hashtable specials;
+		Point     startLocation;
+		Point     endLocation;
+		
+		public INode Parent {
+			get	{
+				return parent;
+			}
+			set {
+				parent = value;
+			}
+		}
+		
+		public Point StartLocation {
+			get {
+				return startLocation;
+			}
+			set {
+				startLocation = value;
+			}
+		}
+		
+		public Point EndLocation {
+			get {
+				return endLocation;
+			}
+			set {
+				endLocation = value;
+			}
+		}
+		
+		public Hashtable Specials {
+			get {
+				return specials;
+			}
+			set {
+				specials = value;
+			}
+		}
+		
+		public ArrayList Children {
+			get {
+				if (children == null) children = new ArrayList();
+				return children;
+			}
+		}
+		
+		public virtual void AddChild(INode childNode)
+		{
+			children.Add(childNode);
+		}
+		
+		public virtual object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public object AcceptChildren(IASTVisitor visitor, object data)
+		{
+			if (children == null) return data;
+			foreach (INode child in children) {
+				if (child != null) {
+					child.AcceptVisitor(visitor, data);
+				}
+			}
+			return data;
+		}
+		
+		public static string GetCollectionString(ICollection collection)
+		{
+			StringBuilder output = new StringBuilder();
+			output.Append('{');
+			
+			if (collection != null) {
+				IEnumerator en = collection.GetEnumerator();
+				bool isFirst = true;
+				while (en.MoveNext()) {
+					if (!isFirst) {
+						output.Append(&quot;, &quot;);
+					} else {
+						isFirst = false;
+					}
+					output.Append(en.Current.ToString());
+				}
+			} else {
+				return &quot;null&quot;;
+			}
+			
+			output.Append('}');
+			return output.ToString();
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AttributeTargets.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AttributeTargets.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/AttributeTargets.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,21 @@
+using System;
+using System.Collections;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	[Flags]
+	public enum AttributeTarget
+	{
+		Assembly = 0x0001,
+		Field    = 0x0002,
+		Event    = 0x0004,
+		Method   = 0x0008,
+		Module   = 0x0010,
+		Param    = 0x0020,
+		Property = 0x0040,
+		Return   = 0x0080,
+		Type     = 0x0100
+	}
+	
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/CompilationUnit.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/CompilationUnit.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/CompilationUnit.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,93 @@
+// CompilationUnit.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Threading;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class CompilationUnit : AbstractNode
+	{
+		// Childs: UsingAliasDeclaration, UsingDeclaration
+		
+		Stack blockStack = new Stack();
+		INode lastChild = null;
+		ArrayList lookUpTable = new ArrayList(); // [VariableDeclaration]
+		
+		public CompilationUnit()
+		{
+			blockStack.Push(this);
+		}
+		
+		public void BlockStart(INode block)
+		{
+			blockStack.Push(block);
+		}
+		
+		public void BlockEnd()
+		{
+			lastChild = (INode)blockStack.Pop();
+		}
+		
+		public INode TakeBlock()
+		{
+			return (INode)blockStack.Pop();
+		}
+		
+		public override void AddChild(INode childNode)
+		{
+			if (childNode != null) {
+				INode parent = (INode)blockStack.Peek();
+				parent.Children.Add(childNode);
+				childNode.Parent = parent;
+				lastChild = childNode;
+				if (childNode is LocalVariableDeclaration) {
+					AddToLookUpTable((LocalVariableDeclaration)childNode);
+				}
+			}
+		}
+		
+		public void AddToLookUpTable(LocalVariableDeclaration v)
+		{
+			v.Block = (INode)blockStack.Peek();
+			lookUpTable.Add(v);
+		}
+		
+		ArrayList specials = new ArrayList();
+		public void AddSpecial(string key, object val)
+		{
+			specials.Add(new DictionaryEntry(key, val));
+		}
+		
+		public void CommitSpecials()
+		{
+			if (lastChild == null) {
+				return;
+			}
+			foreach (DictionaryEntry entry in specials) {
+				lastChild.Specials[entry.Key] = entry.Value;
+			}
+			specials.Clear();
+		}
+			
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/DebugASTVisitor.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/DebugASTVisitor.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/DebugASTVisitor.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,427 @@
+using System;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class DebugASTVisitor : AbstractASTVisitor
+	{
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
+		public override object Visit(CompilationUnit compilationUnit, object data)
+		{
+			Console.WriteLine(compilationUnit.ToString());
+			return compilationUnit.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			Console.WriteLine(fieldDeclaration.ToString());
+			return fieldDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			Console.WriteLine(namespaceDeclaration.ToString());
+			return namespaceDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(UsingDeclaration usingDeclaration, object data)
+		{
+			Console.WriteLine(usingDeclaration.ToString());
+			return usingDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		{
+			Console.WriteLine(usingAliasDeclaration.ToString());
+			return usingAliasDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			Console.WriteLine(typeDeclaration.ToString());
+			return typeDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+			Console.WriteLine(delegateDeclaration.ToString());
+			return delegateDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			Console.WriteLine(variableDeclaration.ToString());
+			return variableDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			Console.WriteLine(methodDeclaration.ToString());
+			if (methodDeclaration.Body != null) {
+				return methodDeclaration.Body.AcceptChildren(this, data);
+			}
+			return methodDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(AttributeSection attributeSection, object data)
+		{
+			Console.WriteLine(attributeSection.ToString());
+			return attributeSection.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		{
+			Console.WriteLine(fieldReferenceExpression.ToString());
+			return fieldReferenceExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			Console.WriteLine(constructorDeclaration.ToString());
+			return constructorDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(DestructorDeclaration destructorDeclaration, object data)
+		{
+			Console.WriteLine(destructorDeclaration.ToString());
+			return destructorDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(OperatorDeclaration operatorDeclaration, object data)
+		{
+			Console.WriteLine(operatorDeclaration.ToString());
+			return operatorDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(IndexerDeclaration indexerDeclaration, object data)
+		{
+			Console.WriteLine(indexerDeclaration.ToString());
+			return indexerDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			Console.WriteLine(parameterDeclarationExpression.ToString());
+			return parameterDeclarationExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(FixedStatement fixedStatement, object data)
+		{
+			Console.WriteLine(fixedStatement.ToString());
+			return fixedStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			Console.WriteLine(propertyDeclaration.ToString());
+			return propertyDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			Console.WriteLine(propertyGetRegion.ToString());
+			return propertyGetRegion.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(PropertySetRegion PropertySetRegion, object data)
+		{
+			Console.WriteLine(PropertySetRegion.ToString());
+			return PropertySetRegion.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			Console.WriteLine(eventDeclaration.ToString());
+			return eventDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(EventAddRegion eventAddRegion, object data)
+		{
+			Console.WriteLine(eventAddRegion.ToString());
+			return eventAddRegion.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(EventRemoveRegion eventRemoveRegion, object data)
+		{
+			Console.WriteLine(eventRemoveRegion.ToString());
+			return eventRemoveRegion.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(BlockStatement blockStatement, object data)
+		{
+			Console.WriteLine(blockStatement.ToString());
+			return blockStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(StatementExpression statementExpression, object data)
+		{
+			Console.WriteLine(statementExpression.ToString());
+			return statementExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			Console.WriteLine(localVariableDeclaration.ToString());
+			return localVariableDeclaration.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(EmptyStatement emptyStatement, object data)
+		{
+			Console.WriteLine(emptyStatement.ToString());
+			return emptyStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ReturnStatement returnStatement, object data)
+		{
+			Console.WriteLine(returnStatement.ToString());
+			return returnStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(IfStatement ifStatement, object data)
+		{
+			Console.WriteLine(ifStatement.ToString());
+			return ifStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(IfElseStatement ifElseStatement, object data)
+		{
+			Console.WriteLine(ifElseStatement.ToString());
+			return ifElseStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(WhileStatement whileStatement, object data)
+		{
+			Console.WriteLine(whileStatement.ToString());
+			return whileStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(DoWhileStatement doWhileStatement, object data)
+		{
+			Console.WriteLine(doWhileStatement.ToString());
+			return doWhileStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ForStatement forStatement, object data)
+		{
+			Console.WriteLine(forStatement.ToString());
+			return forStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(LabelStatement labelStatement, object data)
+		{
+			Console.WriteLine(labelStatement.ToString());
+			return labelStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(GotoStatement gotoStatement, object data)
+		{
+			Console.WriteLine(gotoStatement.ToString());
+			return gotoStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(SwitchStatement switchStatement, object data)
+		{
+			Console.WriteLine(switchStatement.ToString());
+			return switchStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(BreakStatement breakStatement, object data)
+		{
+			Console.WriteLine(breakStatement.ToString());
+			return breakStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ContinueStatement continueStatement, object data)
+		{
+			Console.WriteLine(continueStatement.ToString());
+			return continueStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		{
+			Console.WriteLine(gotoCaseStatement.ToString());
+			return gotoCaseStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ForeachStatement foreachStatement, object data)
+		{
+			Console.WriteLine(foreachStatement.ToString());
+			return foreachStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(LockStatement lockStatement, object data)
+		{
+			Console.WriteLine(lockStatement.ToString());
+			return lockStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(UsingStatement usingStatement, object data)
+		{
+			Console.WriteLine(usingStatement.ToString());
+			return usingStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			Console.WriteLine(tryCatchStatement.ToString());
+			return tryCatchStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ThrowStatement throwStatement, object data)
+		{
+			Console.WriteLine(throwStatement.ToString());
+			return throwStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(CheckedStatement checkedStatement, object data)
+		{
+			Console.WriteLine(checkedStatement.ToString());
+			return checkedStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(UncheckedStatement uncheckedStatement, object data)
+		{
+			Console.WriteLine(uncheckedStatement.ToString());
+			return uncheckedStatement.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(PrimitiveExpression expression, object data)
+		{
+			Console.WriteLine(expression.ToString());
+			return expression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(BinaryOperatorExpression expression, object data)
+		{
+			Console.WriteLine(expression.ToString());
+			return expression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ParenthesizedExpression expression, object data)
+		{
+			Console.WriteLine(expression.ToString());
+			return expression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(InvocationExpression invocationExpression, object data)
+		{
+			Console.WriteLine(invocationExpression.ToString());
+			return invocationExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(IdentifierExpression expression, object data)
+		{
+			Console.WriteLine(expression.ToString());
+			return expression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			Console.WriteLine(typeReferenceExpression.ToString());
+			return typeReferenceExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			Console.WriteLine(unaryOperatorExpression.ToString());
+			return unaryOperatorExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			Console.WriteLine(assignmentExpression.ToString());
+			return assignmentExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
+		{
+			Console.WriteLine(sizeOfExpression.ToString());
+			return sizeOfExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			Console.WriteLine(typeOfExpression.ToString());
+			return typeOfExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(CheckedExpression checkedExpression, object data)
+		{
+			Console.WriteLine(checkedExpression.ToString());
+			return checkedExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
+		{
+			Console.WriteLine(uncheckedExpression.ToString());
+			return uncheckedExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		{
+			Console.WriteLine(pointerReferenceExpression.ToString());
+			return pointerReferenceExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(CastExpression castExpression, object data)
+		{
+			Console.WriteLine(castExpression.ToString());
+			return castExpression.AcceptChildren(this, data);
+		}
+		
+		
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
+		{
+			Console.WriteLine(stackAllocExpression.ToString());
+			return stackAllocExpression.AcceptChildren(this, data);
+		}
+		
+		
+		public override object Visit(IndexerExpression indexerExpression, object data)
+		{
+			Console.WriteLine(indexerExpression.ToString());
+			return indexerExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			Console.WriteLine(thisReferenceExpression.ToString());
+			return thisReferenceExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			Console.WriteLine(baseReferenceExpression.ToString());
+			return baseReferenceExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			Console.WriteLine(objectCreateExpression.ToString());
+			return objectCreateExpression.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			Console.WriteLine(arrayCreateExpression.ToString());
+			return arrayCreateExpression.AcceptChildren(this, data);
+		}
+		public override object Visit(DirectionExpression directionExpression, object data)
+		{
+			Console.WriteLine(directionExpression.ToString());
+			return directionExpression.AcceptChildren(this, data);
+		}
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			Console.WriteLine(arrayInitializerExpression.ToString());
+			return arrayInitializerExpression.AcceptChildren(this, data);
+		}
+		public override object Visit(ConditionalExpression conditionalExpression, object data)
+		{
+			Console.WriteLine(conditionalExpression.ToString());
+			return conditionalExpression.AcceptChildren(this, data);
+		}
+
+#endregion
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Enums.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Enums.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Enums.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,122 @@
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	/// &lt;summary&gt;
+	/// Summary description for Class1.
+	/// &lt;/summary&gt;
+	public enum Types
+	{
+		Class,
+		Interface,
+		Struct,
+		Enum
+	}
+	
+	public enum ParentType
+	{
+		ClassOrStruct,
+		InterfaceOrEnum,
+		Namespace,
+		Unknown
+	}
+	
+	public enum FieldDirection {
+		None,
+		In,
+		Out,
+		Ref
+	}
+	
+	public enum Members
+	{
+		Constant,
+		Field,
+		Method,
+		Property,
+		Event,
+		Indexer,
+		Operator,
+		Constructor,
+		StaticConstructor,
+		Destructor,
+		NestedType
+	}
+	
+	public enum ParamModifiers
+	{
+		In,
+		Out,
+		Ref,
+		Params
+	}
+	public enum UnaryOperatorType
+	{
+		None,
+		Not,
+		BitNot,
+		
+		Minus,
+		Plus,
+		
+		Increment,
+		Decrement,
+		
+		PostIncrement,
+		PostDecrement,
+		
+		Star,
+		BitWiseAnd
+	}
+	
+	public enum AssignmentOperatorType
+	{
+		None,
+		Assign,
+		
+		Add,
+		Subtract,
+		Multiply,
+		Divide,
+		Modulus,
+		
+		ShiftLeft,
+		ShiftRight,
+		
+		BitwiseAnd,
+		BitwiseOr,
+		ExclusiveOr,
+	}
+	
+	public enum BinaryOperatorType
+	{
+		None,
+		Add,
+		BitwiseAnd,
+		BitwiseOr,
+		LogicalAnd,
+		LogicalOr,
+		Divide,
+		GreaterThan,
+		GreaterThanOrEqual,
+		
+		Equality,
+		InEquality,
+		
+		LessThan,
+		LessThanOrEqual,
+		Modulus,
+		Multiply,
+		Subtract,
+		ValueEquality,
+		
+		// additional
+		ShiftLeft,
+		ShiftRight,
+		IS,
+		AS,
+		ExclusiveOr,
+	}
+	
+	
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ArrayCreateExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ArrayCreateExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ArrayCreateExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,126 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class ArrayCreationParameter : AbstractNode 
+	{
+		ArrayList expressions = null;
+		int       dimensions  = -1;
+		
+		public bool IsExpressionList {
+			get {
+				return expressions != null;
+			}
+		}
+		
+		public ArrayList Expressions {
+			get {
+				return expressions;
+			}
+			set {
+				expressions = value;
+			}
+		}
+		
+		public int Dimensions {
+			get {
+				return dimensions;
+			}
+			set {
+				dimensions = value;
+			}
+		}
+		
+		public ArrayCreationParameter(ArrayList expressions)
+		{
+			this.expressions = expressions;
+		}
+		
+		public ArrayCreationParameter(int dimensions)
+		{
+			this.dimensions = dimensions;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ArrayCreationParameter: Dimensions={0}, Expressions={1}&quot;,
+			                     dimensions,
+			                     GetCollectionString(expressions));
+		}
+	}
+	
+	public class ArrayCreateExpression : Expression
+	{
+		TypeReference              createType       = null;
+		ArrayList                  parameters       = null; // ArrayCreationParameter
+		int[]                      rank             = null;
+		ArrayInitializerExpression arrayInitializer = null; // Array Initializer OR NULL
+		
+		public TypeReference CreateType {
+			get {
+				return createType;
+			}
+			set {
+				createType = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public int[] Rank {
+			get {
+				return rank;
+			}
+			set {
+				rank = value;
+			}
+		}
+		
+		public ArrayInitializerExpression ArrayInitializer {
+			get {
+				return arrayInitializer;
+			}
+			set {
+				arrayInitializer = value;
+			}
+		}
+		
+		public ArrayCreateExpression(TypeReference createType)
+		{
+			this.createType = createType;
+		}
+		
+//		public ArrayCreateExpression(TypeReference createType, ArrayInitializerExpression arrayInitializer)
+//		{
+//			this.createType = createType;
+//			this.arrayInitializer = arrayInitializer;
+//		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ArrayCreateExpression: CreateType={0}, Parameters={1}, ArrayInitializer={2}]&quot;,
+			                     createType,
+			                     GetCollectionString(parameters),
+			                     arrayInitializer);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ArrayInitializerExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ArrayInitializerExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ArrayInitializerExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,31 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST {
+	
+	public class ArrayInitializerExpression : Expression
+	{
+		ArrayList     createExpressions = new ArrayList();
+		
+		public ArrayList CreateExpressions {
+			get {
+				return createExpressions;
+			}
+			set {
+				createExpressions = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ArrayInitializerExpression: CreateExpressions={0}]&quot;, 
+			                     GetCollectionString(createExpressions));
+		}
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/AssignmentExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/AssignmentExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/AssignmentExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,58 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class AssignmentExpression : Expression
+	{
+		Expression left;
+		AssignmentOperatorType op;
+		Expression right;
+		
+		public Expression Left {
+			get {
+				return left;
+			}
+			set {
+				left = value;
+			}
+		}
+		
+		public AssignmentOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public Expression Right {
+			get {
+				return right;
+			}
+			set {
+				right = value;
+			}
+		}
+		
+		public AssignmentExpression(Expression left, AssignmentOperatorType op, Expression right)
+		{
+			this.left  = left;
+			this.op    = op;
+			this.right = right;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[AssignmentExpression: Op={0}, Left={1}, Right={2}]&quot;,
+			                     op,
+			                     left,
+			                     right);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/BaseReferenceExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/BaseReferenceExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/BaseReferenceExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,18 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class BaseReferenceExpression : Expression
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BaseReferenceExpression]&quot;);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/BinaryOperatorExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/BinaryOperatorExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/BinaryOperatorExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,59 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class BinaryOperatorExpression : Expression
+	{
+		Expression left;
+		BinaryOperatorType op;
+		Expression right;
+		
+		public Expression Left {
+			get {
+				return left;
+			}
+			set {
+				left = value;
+			}
+		}
+		
+		public BinaryOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public Expression Right {
+			get {
+				return right;
+			}
+			set {
+				right = value;
+			}
+		}
+		
+		public BinaryOperatorExpression(Expression left, BinaryOperatorType op, Expression right)
+		{
+			this.left  = left;
+			this.op    = op;
+			this.right = right;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BinaryOperatorExpression: Op={0}, Left={1}, Right={2}]&quot;,
+			                     op,
+			                     left,
+			                     right);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/CastExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/CastExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/CastExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,54 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class CastExpression : Expression
+	{
+		TypeReference castTo;
+		Expression expression;
+		
+		
+		public TypeReference CastTo {
+			get {
+				return castTo;
+			}
+			set {
+				castTo = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public CastExpression(TypeReference castTo)
+		{
+			this.castTo = castTo;
+		}
+		
+		public CastExpression(TypeReference castTo, Expression expression)
+		{
+			this.castTo = castTo;
+			this.expression = expression;
+		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[CastExpression: CastTo={0}, Expression={1}]&quot;,
+			                     castTo,
+			                     expression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/CheckedExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/CheckedExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/CheckedExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class CheckedExpression : Expression
+	{
+		Expression expression;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public CheckedExpression(Expression expression)
+		{
+			this.expression  = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[CheckedExpression: Expression={0}]&quot;,
+			                     expression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ConditionalExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ConditionalExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ConditionalExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,55 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST {
+	
+	public class ConditionalExpression : Expression
+	{
+		Expression testCondition;
+		Expression trueExpression;
+		Expression falseExpression;
+		
+		public Expression TestCondition {
+			get {
+				return testCondition;
+			}
+			set {
+				testCondition = value;
+			}
+		}
+		public Expression TrueExpression {
+			get {
+				return trueExpression;
+			}
+			set {
+				trueExpression = value;
+			}
+		}
+		public Expression FalseExpression {
+			get {
+				return falseExpression;
+			}
+			set {
+				falseExpression = value;
+			}
+		}
+		
+		public ConditionalExpression(Expression testCondition, Expression trueExpression, Expression falseExpression)
+		{
+			this.testCondition = testCondition;
+			this.trueExpression = trueExpression;
+			this.falseExpression = falseExpression;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		public override string ToString()
+		{
+			return String.Format(&quot;[ConditionalExpression: TestCondition={0}, TrueExpression={1}, FalseExpression{2}]&quot;,
+			                     testCondition,
+			                     trueExpression,
+			                     falseExpression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/DirectionExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/DirectionExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/DirectionExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,40 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST {
+	
+	public class DirectionExpression : Expression
+	{
+		FieldDirection fieldDirection;
+		Expression     expression;
+		
+		public FieldDirection FieldDirection {
+			get {
+				return fieldDirection;
+			}
+			set {
+				fieldDirection = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public DirectionExpression(FieldDirection fieldDirection, Expression expression)
+		{
+			this.fieldDirection = fieldDirection;
+			this.expression = expression;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}
+

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/Expression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/Expression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/Expression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,29 @@
+// Expression.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class Expression : AbstractNode
+	{
+		public Expression()
+		{
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/FieldReferenceExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/FieldReferenceExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/FieldReferenceExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,47 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST {
+	
+	public class FieldReferenceExpression : Expression
+	{
+		Expression targetObject;
+		string fieldName;
+		
+		public Expression TargetObject {
+			get {
+				return targetObject;
+			}
+			set {
+				targetObject = value;
+			}
+		}
+		
+		public string FieldName {
+			get {
+				return fieldName;
+			}
+			set {
+				fieldName = value;
+			}
+		}
+		
+		public FieldReferenceExpression(Expression targetObject, string fieldName)
+		{
+			this.targetObject = targetObject;
+			this.fieldName = fieldName;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[FieldReferenceExpression: FieldName={0}, TargetObject={1}]&quot;,
+			                     fieldName,
+			                     targetObject);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/IdentifierExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/IdentifierExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/IdentifierExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,36 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class IdentifierExpression : Expression
+	{
+		string identifier;
+		
+		public string Identifier {
+			get {
+				return identifier;
+			}
+			set {
+				identifier = value;
+			}
+		}
+		
+		public IdentifierExpression(string identifier)
+		{
+			this.identifier = identifier;
+		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[IdentifierExpression: Identifier={0}]&quot;,
+			                     identifier);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/IndexerExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/IndexerExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/IndexerExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,48 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class IndexerExpression : Expression
+	{
+		Expression targetObject;
+		ArrayList  indices; // Expression list
+		
+		public Expression TargetObject {
+			get {
+				return targetObject;
+			}
+			set {
+				targetObject = value;
+			}
+		}
+		
+		public ArrayList Indices {
+			get {
+				return indices;
+			}
+			set {
+				indices = value;
+			}
+		}
+		
+		public IndexerExpression(Expression targetObject, ArrayList indices)
+		{
+			this.targetObject = targetObject;
+			this.indices = indices;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[IndexerExpression: TargetObject={0}, Indices={1}]&quot;,
+			                     targetObject,
+			                     GetCollectionString(indices));
+		}
+
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/InvocationExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/InvocationExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/InvocationExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,47 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST {
+	
+	public class InvocationExpression : Expression
+	{
+		Expression  targetObject;
+		ArrayList   parameters; // Expression list
+		
+		public Expression TargetObject {
+			get {
+				return targetObject;
+			}
+			set {
+				targetObject = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public InvocationExpression(Expression targetObject, ArrayList parameters)
+		{
+			this.targetObject = targetObject;
+			this.parameters = parameters;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[InvocationExpression: TargetObject={0}, parameters={1}]&quot;,
+			                     targetObject,
+			                     GetCollectionString(parameters));
+		}
+	}
+}
+

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ObjectCreateExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ObjectCreateExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ObjectCreateExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,46 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class ObjectCreateExpression : Expression
+	{
+		TypeReference createType;
+		ArrayList     parameters;
+		
+		public TypeReference CreateType {
+			get {
+				return createType;
+			}
+			set {
+				createType = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ObjectCreateExpression(TypeReference createType, ArrayList parameters)
+		{
+			this.createType = createType;
+			this.parameters = parameters;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ObjectCreateExpression: CreateType={0}, Parameters={1}]&quot;,
+			                     createType,
+			                     GetCollectionString(parameters));
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ParenthesizedExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ParenthesizedExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ParenthesizedExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class ParenthesizedExpression : Expression
+	{
+		Expression expression;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public ParenthesizedExpression(Expression expression)
+		{
+			this.expression  = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ParenthesizedExpression: Expression={0}]&quot;,
+			                     expression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/PointerReferenceExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/PointerReferenceExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/PointerReferenceExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,40 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class PointerReferenceExpression : Expression
+	{
+		Expression expression;
+		string     identifier;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public string Identifier {
+			get {
+				return identifier;
+			}
+			set {
+				identifier = value;
+			}
+		}
+		
+		public PointerReferenceExpression(Expression expression, string identifier)
+		{
+			this.expression = expression;
+			this.identifier = identifier;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/PrimitiveExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/PrimitiveExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/PrimitiveExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,49 @@
+using System;
+using System.Collections;
+using System.Globalization;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST {
+	
+	public class PrimitiveExpression : Expression
+	{
+		object val;
+		string stringValue;
+		
+		public object Value {
+			get {
+				return val;
+			}
+			set {
+				val = value;
+			}
+		}
+		
+		public string StringValue {
+			get {
+				return stringValue;
+			}
+			set {
+				stringValue = value;
+			}
+		}
+		
+		public PrimitiveExpression(object val, string stringValue)
+		{
+			this.val = val;
+			this.stringValue = stringValue;
+		}
+		
+		static NumberFormatInfo nfi = CultureInfo.InvariantCulture.NumberFormat;
+
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[PrimitiveExpression: StringValue={0}]&quot;,
+			                     stringValue);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/SizeOfExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/SizeOfExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/SizeOfExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class SizeOfExpression : Expression
+	{
+		TypeReference typeReference;
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public SizeOfExpression(TypeReference typeReference)
+		{
+			this.typeReference  = typeReference;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[SizeOfExpression: TypeReference={0}]&quot;,
+			                     typeReference);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/StackAllocExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/StackAllocExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/StackAllocExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,46 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class StackAllocExpression : Expression
+	{
+		TypeReference type;
+		Expression expression;
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		public StackAllocExpression(TypeReference type, Expression expression)
+		{
+			this.type = type;
+			this.expression = expression;
+		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[StackAllocExpression: Type={0}, Expression={1}]&quot;,
+			                     type,
+			                     expression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ThisReferenceExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ThisReferenceExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/ThisReferenceExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,19 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class ThisReferenceExpression : Expression
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ThisReferenceExpression]&quot;);
+		}
+
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/TypeOfExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/TypeOfExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/TypeOfExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class TypeOfExpression : Expression
+	{
+		TypeReference typeReference;
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public TypeOfExpression(TypeReference typeReference)
+		{
+			this.typeReference  = typeReference;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeOfExpression: TypeReference={0}]&quot;, 
+			                     typeReference);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/TypeReferenceExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/TypeReferenceExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/TypeReferenceExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,39 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST {
+	
+	public class TypeReferenceExpression : Expression
+	{
+		TypeReference  typeReference;
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public TypeReferenceExpression(string type)
+		{
+			this.typeReference = new TypeReference(type);
+		}
+		public TypeReferenceExpression(TypeReference  typeReference)
+		{
+			this.typeReference = typeReference;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeReferenceExpression: TypeReference={0}]&quot;, 
+			                     typeReference);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/UnaryOperatorExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/UnaryOperatorExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/UnaryOperatorExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,51 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class UnaryOperatorExpression : Expression
+	{
+		Expression        expression;
+		UnaryOperatorType op;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		public UnaryOperatorType Op {
+			get {
+				return op;
+			}
+			set {
+				op = value;
+			}
+		}
+		
+		public UnaryOperatorExpression(UnaryOperatorType op)
+		{
+			this.op    = op;
+		}
+		
+		public UnaryOperatorExpression(Expression expression, UnaryOperatorType op)
+		{
+			this.expression  = expression;
+			this.op    = op;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UnaryOperatorExpression: Op={0}, Expression={1}]&quot;,
+			                     op,
+			                     expression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/UncheckedExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/UncheckedExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Expressions/UncheckedExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class UncheckedExpression : Expression
+	{
+		Expression expression;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public UncheckedExpression(Expression expression)
+		{
+			this.expression  = expression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UncheckedExpression: Expression={0}]&quot;, 
+			                     expression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/AttributeSection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/AttributeSection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/AttributeSection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,110 @@
+// AttributeDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class NamedArgument : AbstractNode
+	{
+		string name;
+		Expression expr;
+		
+		public string Name {
+			get {
+				return name;
+			}
+		}
+		public Expression Expr {
+			get {
+				return expr;
+			}
+		}
+		
+		public NamedArgument(string name, Expression expr)
+		{
+			this.name = name;
+			this.expr = expr;
+		}
+	}
+	
+	public class Attribute : AbstractNode
+	{
+		string name;
+		ArrayList positionalArguments;
+		ArrayList namedArguments;
+		
+		public Attribute(string name, ArrayList positionalArguments, ArrayList namedArguments)
+		{
+			this.name = name;
+			this.positionalArguments = positionalArguments; //[Expression]
+			this.namedArguments      = namedArguments; //[NamedArgument]
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+		}
+		public ArrayList PositionalArguments {
+			get {
+				return positionalArguments;
+			}
+		}
+		public ArrayList NamedArguments {
+			get {
+				return namedArguments;
+			}
+		}
+	}
+	
+	public class AttributeSection : AbstractNode
+	{
+		string    attributeTarget;
+		ArrayList attributes; // [Attribute]
+		
+		public string AttributeTarget {
+			get {
+				return attributeTarget;
+			}
+			set {
+				attributeTarget = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public AttributeSection(string attributeTarget, ArrayList attributes)
+		{
+			this.attributeTarget = attributeTarget;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/DelegateDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/DelegateDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/DelegateDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,91 @@
+// DelegateDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class DelegateDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		TypeReference   returnType;
+		ArrayList       parameters = new ArrayList(); // [ParameterDeclarationExpression]
+		ArrayList       attributes = new ArrayList();
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference ReturnType {
+			get {
+				return returnType;
+			}
+			set {
+				returnType = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+
+		public override string ToString()
+		{
+			return String.Format(&quot;[DelegateDeclaration: Name={0}, Modifier={1}, ReturnType={2}, parameters={3}, attributes={4}]&quot;,
+			                     name,
+			                     modifier,
+			                     returnType,
+			                     GetCollectionString(parameters),
+			                     GetCollectionString(attributes));
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/NamespaceDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/NamespaceDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/NamespaceDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,51 @@
+// NamespaceDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class NamespaceDeclaration : AbstractNode
+	{
+		string    nameSpace;
+		
+		public string NameSpace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public NamespaceDeclaration(string nameSpace)
+		{
+			this.nameSpace = nameSpace;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[NamespaceDeclaration: Namespace={0}]&quot;, nameSpace);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/TypeDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/TypeDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/TypeDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,98 @@
+// TypeDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class TypeDeclaration : AbstractNode
+	{
+		// Children of Enum : [Field]
+		string name;
+		Modifier modifier;
+		Types type; // Class | Interface | Struct | Enum
+		StringCollection bases;
+		ArrayList attributes;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		public Types Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		public StringCollection BaseTypes {
+			get {
+				return bases;
+			}
+			set {
+				bases = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+//		public TypeDeclaration(string name, Modifier modifier, Types type, StringCollection bases, ArrayList attributes)
+//		{
+//			this.name = name;
+//			this.modifier = modifier;
+//			this.type = type;
+//			this.bases = bases;
+//			this.attributes = attributes;
+//		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeDeclaration: Name={0}, Modifier={1}, Type={2}, BaseTypes={3}]&quot;,
+			                     name,
+			                     modifier,
+			                     type,
+			                     GetCollectionString(bases));
+		}
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/UsingAliasDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/UsingAliasDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/UsingAliasDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,64 @@
+// UsingAliasDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class UsingAliasDeclaration : AbstractNode
+	{
+		string    alias;
+		string    nameSpace;
+		
+		public string Alias {
+			get {
+				return alias;
+			}
+			set {
+				alias = value;
+			}
+		}
+		
+		public string Namespace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public UsingAliasDeclaration(string alias, string nameSpace)
+		{
+			this.alias     = alias;
+			this.nameSpace = nameSpace;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UsingAliasDeclaration: Namespace={0}, Alias={1}]&quot;,
+			                     nameSpace,
+			                     alias);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/UsingDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/UsingDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/GlobalScope/UsingDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,52 @@
+// UsingDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class UsingDeclaration : AbstractNode
+	{
+		string nameSpace;
+		
+		public string Namespace {
+			get {
+				return nameSpace;
+			}
+			set {
+				nameSpace = value;
+			}
+		}
+		
+		public UsingDeclaration(string nameSpace)
+		{
+			this.nameSpace = nameSpace;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UsingDeclaration: Namespace={0}]&quot;,
+			                     nameSpace);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/IASTVisitor.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/IASTVisitor.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/IASTVisitor.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,93 @@
+using System;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public interface IASTVisitor
+	{
+		object Visit(INode node, object data);
+		
+		object Visit(CompilationUnit compilationUnit, object data);
+		object Visit(NamespaceDeclaration namespaceDeclaration, object data);
+		object Visit(UsingDeclaration usingDeclaration, object data);
+		object Visit(UsingAliasDeclaration usingAliasDeclaration, object data);
+		object Visit(AttributeSection attributeSection, object data);
+		
+		// Types
+		object Visit(TypeDeclaration typeDeclaration, object data);
+		object Visit(DelegateDeclaration delegateDeclaration, object data);
+		
+		// Members
+		object Visit(VariableDeclaration variableDeclaration, object data);
+		object Visit(FieldDeclaration    fieldDeclaration, object data);
+		
+		object Visit(MethodDeclaration methodDeclaration, object data);
+		object Visit(PropertyDeclaration propertyDeclaration, object data);
+		object Visit(PropertyGetRegion propertyGetRegion, object data);
+		object Visit(PropertySetRegion PropertySetRegion, object data);
+		object Visit(EventDeclaration eventDeclaration, object data);
+		object Visit(EventAddRegion eventAddRegion, object data);
+		object Visit(EventRemoveRegion eventRemoveRegion, object data);
+		
+		object Visit(ConstructorDeclaration constructorDeclaration, object data);
+		object Visit(DestructorDeclaration destructorDeclaration, object data);
+		object Visit(OperatorDeclaration operatorDeclaration, object data);
+		object Visit(IndexerDeclaration indexerDeclaration, object data);
+		
+		// Statements
+		object Visit(BlockStatement blockStatement, object data);
+		object Visit(StatementExpression statementExpression, object data);
+		object Visit(LocalVariableDeclaration variableDeclaration, object data);
+		object Visit(EmptyStatement emptyStatement, object data);
+		object Visit(ReturnStatement returnStatement, object data);
+		object Visit(IfStatement ifStatement, object data);
+		object Visit(IfElseStatement ifElseStatement, object data);
+		object Visit(WhileStatement whileStatement, object data);
+		object Visit(DoWhileStatement doWhileStatement, object data);
+		object Visit(ForStatement forStatement, object data);
+		object Visit(LabelStatement labelStatement, object data);
+		object Visit(GotoStatement gotoStatement, object data);
+		object Visit(SwitchStatement switchStatement, object data);
+		object Visit(BreakStatement breakStatement, object data);
+		object Visit(ContinueStatement continueStatement, object data);
+		object Visit(GotoCaseStatement gotoCaseStatement, object data);
+		object Visit(ForeachStatement foreachStatement, object data);
+		object Visit(LockStatement lockStatement, object data);
+		object Visit(UsingStatement usingStatement, object data);
+		object Visit(TryCatchStatement tryCatchStatement, object data);
+		object Visit(ThrowStatement throwStatement, object data);
+		object Visit(FixedStatement fixedStatement, object data);
+		object Visit(CheckedStatement checkedStatement, object data);
+		object Visit(UncheckedStatement uncheckedStatement, object data);
+		
+		// Expressions
+		object Visit(PrimitiveExpression      primitiveExpression, object data);
+		object Visit(BinaryOperatorExpression binaryOperatorExpression, object data);
+		object Visit(ParenthesizedExpression parenthesizedExpression, object data);
+		object Visit(InvocationExpression invocationExpression, object data);
+		object Visit(IdentifierExpression identifierExpression, object data);
+		object Visit(TypeReferenceExpression typeReferenceExpression, object data);
+		object Visit(UnaryOperatorExpression unaryOperatorExpression, object data);
+		object Visit(AssignmentExpression assignmentExpression, object data);
+		object Visit(SizeOfExpression sizeOfExpression, object data);
+		object Visit(TypeOfExpression typeOfExpression, object data);
+		object Visit(CheckedExpression checkedExpression, object data);
+		object Visit(UncheckedExpression uncheckedExpression, object data);
+		object Visit(PointerReferenceExpression pointerReferenceExpression, object data);
+		object Visit(CastExpression castExpression, object data);
+		object Visit(StackAllocExpression stackAllocExpression, object data);
+		object Visit(IndexerExpression indexerExpression, object data);
+		object Visit(ThisReferenceExpression thisReferenceExpression, object data);
+		object Visit(BaseReferenceExpression baseReferenceExpression, object data);
+		object Visit(ObjectCreateExpression objectCreateExpression, object data);
+		object Visit(ArrayCreationParameter arrayCreationParameter, object data);
+		object Visit(ArrayCreateExpression arrayCreateExpression, object data);
+		object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data);
+		object Visit(FieldReferenceExpression fieldReferenceExpression, object data);
+		object Visit(DirectionExpression directionExpression, object data);
+		object Visit(ArrayInitializerExpression arrayInitializerExpression, object data);
+		object Visit(ConditionalExpression conditionalExpression, object data);
+		
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/INode.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/INode.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/INode.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,66 @@
+// INode.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public interface INode
+	{
+		INode Parent { 
+			get;
+			set;
+		}
+		
+		Hashtable Specials {
+			get;
+			set;
+		}
+		
+		ArrayList Children {
+			get;
+		}
+		
+		Point StartLocation {
+			get;
+			set;
+		}
+		
+		Point EndLocation {
+			get;
+			set;
+		}
+		
+		/// &lt;summary&gt;
+		/// Visits all children
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;visitor&quot;&gt;The visitor to accept&lt;/param&gt;
+		/// &lt;param name=&quot;data&quot;&gt;Additional data for the visitor&lt;/param&gt;
+		/// &lt;returns&gt;The paremeter &lt;paramref name=&quot;data&quot;/&gt;&lt;/returns&gt;
+		object AcceptChildren(IASTVisitor visitor, object data);
+		
+		/// &lt;summary&gt;
+		/// Accept the visitor
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;visitor&quot;&gt;The visitor to accept&lt;/param&gt;
+		/// &lt;param name=&quot;data&quot;&gt;Additional data for the visitor&lt;/param&gt;
+		/// &lt;returns&gt;The value the visitor returns after the visit&lt;/returns&gt;
+		object AcceptVisitor(IASTVisitor visitor, object data);
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/LookupTableVisitor.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/LookupTableVisitor.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/LookupTableVisitor.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,83 @@
+using System;
+using System.Drawing;
+using System.Collections;
+
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class LocalLookupVariable
+	{
+		TypeReference typeRef;
+		Point         startPos;
+		Point         endPos;
+		
+		public TypeReference TypeRef {
+			get {
+				return typeRef;
+			}
+		}
+		public Point StartPos {
+			get {
+				return startPos;
+			}
+		}
+		public Point EndPos {
+			get {
+				return endPos;
+			}
+		}
+		
+		public LocalLookupVariable(TypeReference typeRef, Point startPos, Point endPos)
+		{
+			this.typeRef = typeRef;
+			this.startPos = startPos;
+			this.endPos = endPos;
+		}
+	}
+	
+	public class LookupTableVisitor : AbstractASTVisitor
+	{
+		public Hashtable variables = new Hashtable();
+		
+		public void AddVariable(TypeReference typeRef, string name, Point startPos, Point endPos)
+		{
+			ArrayList list;
+			if (variables[name] == null) {
+				variables[name] = list = new ArrayList();
+			} else {
+				list = (ArrayList)variables[name];
+			}
+			list.Add(new LocalLookupVariable(typeRef, startPos, endPos));
+		}
+		
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			foreach (VariableDeclaration varDecl in localVariableDeclaration.Variables) {
+				AddVariable(localVariableDeclaration.Type, 
+				            varDecl.Name,
+				            localVariableDeclaration.StartLocation,
+				            CurrentBlock == null ? new Point(-1, -1) : CurrentBlock.EndLocation);
+			}
+			return data;
+		}
+		
+		// ForStatement and UsingStatement use a LocalVariableDeclaration,
+		// so they don't need to be visited separately
+		
+		public override object Visit(ForeachStatement foreachStatement, object data)
+		{
+			AddVariable(foreachStatement.TypeReference,
+			            foreachStatement.VariableName,
+			            foreachStatement.StartLocation,
+			            foreachStatement.EndLocation);
+			if (foreachStatement.Expression != null) {
+				foreachStatement.Expression.AcceptVisitor(this, data);
+			}
+			if (foreachStatement.EmbeddedStatement == null) {
+				return data;
+			}
+			return foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Modifier.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Modifier.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Modifier.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,48 @@
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	[Flags]
+	public enum Modifier
+	{
+		// Access 
+		Private   = 0x0001,
+		Internal  = 0x0002,
+		Protected = 0x0004,
+		Public    = 0x0008,
+	 
+		// Scope
+		Abstract  = 0x0010, 
+		Virtual   = 0x0020,
+		Sealed    = 0x0040,
+		Static    = 0x0080,
+		Override  = 0x0100,
+		Readonly  = 0x0200,
+		Const	  = 0X0400,
+		New       = 0x0800,
+	 	 
+		// Special 
+		Extern    = 0x1000,
+		Volatile  = 0x2000,
+		Unsafe    = 0x4000,
+		
+		// Modifier scopes
+		None      = 0x0000,
+		
+		Classes                         = New | Public | Protected | Internal | Private | Abstract | Sealed,
+		Fields                          = New | Public | Protected | Internal | Private | Static   | Readonly | Volatile,
+		PropertysEventsMethods          = New | Public | Protected | Internal | Private | Static   | Virtual  | Sealed   | Override | Abstract | Extern,
+		Indexers                        = New | Public | Protected | Internal | Private | Virtual  | Sealed   | Override | Abstract | Extern,
+		Operators                       = Public | Static | Extern,
+		Constants                       = New | Public | Protected | Internal | Private,
+		StructsInterfacesEnumsDelegates = New | Public | Protected | Internal | Private,
+		StaticConstructors              = Extern | Static | Unsafe,
+		Destructors                     = Extern | Unsafe,
+		Constructors                    = Public | Protected | Internal | Private | Extern,
+		
+		All       = Private  | Internal | Protected | Public |
+		            Abstract | Virtual  | Sealed    | Static | 
+		            Override | Readonly | Const     | New    |
+		            Extern   | Volatile | Unsafe
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/BlockStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/BlockStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/BlockStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,19 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class BlockStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BlockStatement: Children={0}]&quot;, 
+			                     GetCollectionString(base.Children));
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/BreakStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/BreakStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/BreakStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,18 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class BreakStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[BreakStatement]&quot;);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/CheckedStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/CheckedStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/CheckedStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,34 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class CheckedStatement : Statement
+	{
+		Statement block;
+		
+		public Statement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public CheckedStatement(Statement block)
+		{
+			this.block = block;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[CheckedStatement: Block={0}]&quot;, 
+			                     block);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ContinueStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ContinueStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ContinueStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,18 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class ContinueStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ContinueStatement]&quot;);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/DoWhileStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/DoWhileStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/DoWhileStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,44 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class DoWhileStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		public DoWhileStatement(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[DoWhileStatement: Condition={0}, EmbeddedStatement={1}]&quot;, 
+			                     condition,
+			                     embeddedStatement);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/EmptyStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/EmptyStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/EmptyStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,18 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class EmptyStatement : Statement
+	{
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[EmptyStatement]&quot;);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/FixedStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/FixedStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/FixedStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,57 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class FixedStatement : Statement
+	{
+		TypeReference type;
+		ArrayList     pointerDeclarators = new ArrayList();
+		Statement     embeddedStatement;
+		
+		public TypeReference TypeReference {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public ArrayList PointerDeclarators {
+			get {
+				return pointerDeclarators;
+			}
+			set {
+				pointerDeclarators = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public FixedStatement(TypeReference type)
+		{
+			this.type = type;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[FixedStatement: Type={0}, PointerDeclarators={1}, EmbeddedStatement={2}]&quot;, 
+			                     type,
+			                     GetCollectionString(pointerDeclarators),
+			                     embeddedStatement);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ForStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ForStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ForStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,62 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class ForStatement : Statement
+	{
+		ArrayList  initializers; // EmbeddedStatement OR list of StatmentExpressions
+		Expression condition;
+		ArrayList  iterator;     // list of StatmentExpressions
+		Statement  embeddedStatement;
+		
+		public ArrayList Initializers {
+			get {
+				return initializers;
+			}
+			set {
+				initializers = value;
+			}
+		}
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public ArrayList Iterator {
+			get {
+				return iterator;
+			}
+			set {
+				iterator = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public ForStatement(ArrayList initializers, Expression condition, ArrayList iterator, Statement embeddedStatement)
+		{
+			this.initializers = initializers;
+			this.condition = condition;
+			this.iterator = iterator;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ForeachStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ForeachStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ForeachStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,62 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class ForeachStatement : Statement
+	{
+		TypeReference typeReference;
+		string        variableName;
+		Expression    expression;
+		Statement     embeddedStatement;
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public string VariableName {
+			get {
+				return variableName;
+			}
+			set {
+				variableName = value;
+			}
+		}
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public ForeachStatement(TypeReference typeReference, string variableName, Expression expression, Statement embeddedStatement)
+		{
+			this.typeReference     = typeReference;
+			this.variableName      = variableName;
+			this.expression        = expression;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/GotoCaseStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/GotoCaseStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/GotoCaseStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,37 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class GotoCaseStatement : Statement
+	{
+		Expression caseExpression;
+		
+		/// &lt;value&gt;null == goto default;&lt;/value&gt;
+		public Expression CaseExpression {
+			get {
+				return caseExpression;
+			}
+			set {
+				caseExpression = value;
+			}
+		}
+		
+		public bool IsDefaultCase {
+			get {
+				return caseExpression == null;
+			}
+		}
+		
+		public GotoCaseStatement(Expression caseExpression)
+		{
+			this.caseExpression = caseExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/GotoStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/GotoStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/GotoStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class GotoStatement : Statement
+	{
+		string label;
+		
+		public string Label {
+			get {
+				return label;
+			}
+			set {
+				label = value;
+			}
+		}
+		
+		public GotoStatement(string label)
+		{
+			this.label = label;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[GotoStatement: Label={0}]&quot;,
+			                     label);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/IfElseStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/IfElseStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/IfElseStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,49 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class IfElseStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		Statement  embeddedElseStatement;
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public Statement EmbeddedElseStatement {
+			get {
+				return embeddedElseStatement;
+			}
+			set {
+				embeddedElseStatement = value;
+			}
+		}
+		
+		public IfElseStatement(Expression condition, Statement embeddedStatement, Statement embeddedElseStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+			this.embeddedElseStatement = embeddedElseStatement;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/IfStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/IfStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/IfStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,37 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class IfStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		public IfStatement(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LabelStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LabelStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LabelStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class LabelStatement : Statement
+	{
+		string label;
+		
+		public string Label {
+			get {
+				return label;
+			}
+			set {
+				label = value;
+			}
+		}
+		
+		public LabelStatement(string label)
+		{
+			this.label = label;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LabelStatement: Label={0}]&quot;,
+			                     label);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LocalVariableDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LocalVariableDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LocalVariableDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,80 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class LocalVariableDeclaration : Statement
+	{
+		TypeReference type;
+		Modifier      modifier = Modifier.None;
+		ArrayList     variables = new ArrayList(); // [VariableDeclaration]
+		INode block; // the block in witch the variable is declared; needed for the LookupTable
+		
+		public TypeReference Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Variables {
+			get {
+				return variables;
+			}
+		}
+		
+		public INode Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public LocalVariableDeclaration(TypeReference type)
+		{
+			this.type = type;
+		}
+		
+		public LocalVariableDeclaration(TypeReference type, Modifier modifier)
+		{
+			this.type     = type;
+			this.modifier = modifier;
+		}
+		
+		public VariableDeclaration GetVariableDeclaration(string variableName)
+		{
+			foreach (VariableDeclaration variableDeclaration in variables) {
+				if (variableDeclaration.Name == variableName) {
+					return variableDeclaration;
+				}
+			}
+			return null;
+		}
+				
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LocalVariableDeclaration: Type={0}, Modifier ={1} Variables={2}]&quot;, 
+			                     type, 
+			                     modifier, 
+			                     GetCollectionString(variables));
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LockStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LockStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/LockStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,44 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class LockStatement : Statement
+	{
+		Expression lockExpression;
+		Statement  embeddedStatement;
+		
+		public Expression LockExpression {
+			get {
+				return lockExpression;
+			}
+			set {
+				lockExpression = value;
+			}
+		}
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		public LockStatement(Expression lockExpression, Statement embeddedStatement)
+		{
+			this.lockExpression = lockExpression;
+			this.embeddedStatement = embeddedStatement;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[LockStatement: LockExpression={0}, EmbeddedStatement={1}]&quot;, 
+			                     lockExpression,
+			                     embeddedStatement);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ReturnStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ReturnStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ReturnStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class ReturnStatement : Statement
+	{
+		Expression returnExpression;
+		
+		public Expression ReturnExpression {
+			get {
+				return returnExpression;
+			}
+			set {
+				returnExpression = value;
+			}
+		}
+		
+		public ReturnStatement(Expression returnExpression)
+		{
+			this.returnExpression = returnExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ReturnStatement: ReturnExpression={0}]&quot;, 
+			                     returnExpression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/Statement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/Statement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/Statement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,26 @@
+// Statement.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class Statement : AbstractNode
+	{
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/StatementExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/StatementExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/StatementExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,51 @@
+// StatementExpression.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class StatementExpression : Statement
+	{
+		Expression expression;
+		
+		public Expression Expression {
+			get {
+				return expression;
+			}
+			set {
+				expression = value;
+			}
+		}
+		
+		
+		public StatementExpression(Expression expression)
+		{
+			this.expression = expression;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[StatementExpression: Expression={0}]&quot;, expression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/SwitchStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/SwitchStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/SwitchStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,89 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class SwitchStatement : BlockStatement
+	{
+		Expression switchExpression;
+		ArrayList  switchSections  = new ArrayList();
+		
+		public Expression SwitchExpression {
+			get {
+				return switchExpression;
+			}
+			set {
+				switchExpression = value;
+			}
+		}
+		
+		public ArrayList SwitchSections {
+			get {
+				return switchSections;
+			}
+			set {
+				switchSections = value;
+			}
+		}
+		
+		public SwitchStatement(Expression switchExpression, ArrayList switchSections)
+		{
+			this.switchExpression = switchExpression;
+			this.switchSections = switchSections;
+		}
+		
+		public SwitchStatement(Expression switchExpression)
+		{
+			this.switchExpression = switchExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class SwitchSection : BlockStatement
+	{
+		ArrayList switchLabels = new ArrayList();
+		
+		public ArrayList SwitchLabels {
+			get {
+				return switchLabels;
+			}
+			set {
+				switchLabels = value;
+			}
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public class CaseLabel
+	{
+		Expression label;
+		
+		/// &lt;value&gt;null means default case&lt;/value&gt;
+		public Expression Label {
+			get {
+				return label;
+			}
+			set {
+				label = value;
+			}
+		}
+		
+		public CaseLabel(Expression label)
+		{
+			this.label = label;
+		}
+		
+		public CaseLabel()
+		{
+			this.label = null;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ThrowStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ThrowStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/ThrowStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class ThrowStatement : Statement
+	{
+		Expression throwExpression;
+		
+		public Expression ThrowExpression {
+			get {
+				return throwExpression;
+			}
+			set {
+				throwExpression = value;
+			}
+		}
+		
+		public ThrowStatement(Expression throwExpression)
+		{
+			this.throwExpression = throwExpression;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ThrowStatement: ThrowExpression={0}]&quot;, 
+			                     throwExpression);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/TryCatchStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/TryCatchStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/TryCatchStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,123 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class TryCatchStatement : Statement
+	{
+		Statement statementBlock;
+		ArrayList catchClauses;
+		Statement finallyBlock;
+		
+		public Statement StatementBlock {
+			get {
+				return statementBlock;
+			}
+			set {
+				statementBlock = value;
+			}
+		}
+		
+		public ArrayList CatchClauses {
+			get {
+				return catchClauses;
+			}
+			set {
+				catchClauses = value;
+			}
+		}
+		
+		public Statement FinallyBlock {
+			get {
+				return finallyBlock;
+			}
+			set {
+				finallyBlock = value;
+			}
+		}
+		
+		public TryCatchStatement(Statement statementBlock, ArrayList catchClauses, Statement finallyBlock)
+		{
+			this.statementBlock = statementBlock;
+			this.catchClauses = catchClauses;
+			this.finallyBlock = finallyBlock;
+		}
+		
+		public TryCatchStatement(Statement statementBlock, ArrayList catchClauses)
+		{
+			this.statementBlock = statementBlock;
+			this.catchClauses = catchClauses;
+			this.finallyBlock = null;
+		}
+		
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TryCatchStatement: StatementBlock={0}, CatchClauses={1}, FinallyBlock={2}]&quot;,
+			                     statementBlock,
+			                     GetCollectionString(catchClauses),
+			                     finallyBlock);
+		}
+	}
+	
+	public class CatchClause
+	{
+		string type;
+		string variableName;
+		Statement       statementBlock;
+		
+		public string Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public string VariableName {
+			get {
+				return variableName;
+			}
+			set {
+				variableName = value;
+			}
+		}
+		
+		public Statement StatementBlock {
+			get {
+				return statementBlock;
+			}
+			set {
+				statementBlock = value;
+			}
+		}
+		
+		public CatchClause(string type, string variableName, Statement statementBlock)
+		{
+			this.type = type;
+			this.variableName = variableName;
+			this.statementBlock = statementBlock;
+		}
+		
+		public CatchClause(Statement statementBlock)
+		{
+			this.type         = null;
+			this.variableName = null;
+			this.statementBlock = statementBlock;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[CatchClause: Type={0}, VariableName={1}, StatementBlock={2}]&quot;, 
+			                     type,
+			                     variableName,
+			                     statementBlock);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UncheckedStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UncheckedStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UncheckedStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class UncheckedStatement : Statement
+	{
+		Statement block;
+		
+		public Statement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public UncheckedStatement(Statement block)
+		{
+			this.block = block;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UncheckedStatement: Block={0}]&quot;, 
+			                     block);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UnsafeStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UnsafeStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UnsafeStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,35 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class UnsafeStatement : Statement
+	{
+		Statement block;
+		
+		public Statement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public UnsafeStatement(Statement block)
+		{
+			this.block = block;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UnsafeStatement: Block={0}]&quot;, 
+			                     block);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UsingStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UsingStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/UsingStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,49 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class UsingStatement : Statement
+	{
+		Statement  usingStatement;
+		Statement  embeddedStatement;
+		
+		public Statement UsingStmnt {
+			get {
+				return usingStatement;
+			}
+			set {
+				usingStatement = value;
+			}
+		}
+		
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public UsingStatement(Statement usingStatement, Statement embeddedStatement)
+		{
+			this.usingStatement = usingStatement;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[UsingStatement: UsingStmnt={0}, EmbeddedStatement={1}]&quot;, 
+			                     usingStatement,
+			                     embeddedStatement);
+		}
+
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/WhileStatement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/WhileStatement.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/Statements/WhileStatement.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,47 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST 
+{
+	public class WhileStatement : Statement
+	{
+		Expression condition;
+		Statement  embeddedStatement;
+		
+		public Expression Condition {
+			get {
+				return condition;
+			}
+			set {
+				condition = value;
+			}
+		}
+		
+		public Statement EmbeddedStatement {
+			get {
+				return embeddedStatement;
+			}
+			set {
+				embeddedStatement = value;
+			}
+		}
+		
+		public WhileStatement(Expression condition, Statement embeddedStatement)
+		{
+			this.condition = condition;
+			this.embeddedStatement = embeddedStatement;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[WhileStatement: Condition={0}, EmbeddedStatement={1}]&quot;, 
+			                     condition,
+			                     embeddedStatement);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/ConstructorDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/ConstructorDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/ConstructorDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,131 @@
+// ConstructorDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class ConstructorDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		ArrayList       parameters = new ArrayList(); // [ParameterDeclarationExpression]
+		ArrayList       attributes = new ArrayList();
+		ConstructorInitializer constructorInitializer;
+		BlockStatement  blockStatement = null;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public ConstructorInitializer ConstructorInitializer {
+			get {
+				return constructorInitializer;
+			}
+			set {
+				constructorInitializer = value;
+			}
+		}
+		public BlockStatement Body {
+			get {
+				return blockStatement;
+			}
+			set {
+				blockStatement = value;
+			}
+		}
+		
+		public ConstructorDeclaration(string name, Modifier modifier, ArrayList parameters, ConstructorInitializer constructorInitializer, ArrayList attributes)
+		{
+			this.name     = name;
+			this.modifier = modifier;
+			if (parameters != null) {
+				this.parameters = parameters;
+			}
+			this.constructorInitializer = constructorInitializer;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public enum ConstructorInitializerType {
+		Base,
+		This
+	}
+	
+	public class ConstructorInitializer
+	{
+		ConstructorInitializerType constructorInitializerType;
+		ArrayList                  arguments = new ArrayList(); // [Expression]
+		
+		public ConstructorInitializerType ConstructorInitializerType {
+			get {
+				return constructorInitializerType;
+			}
+			set {
+				constructorInitializerType = value;
+			}
+		}
+		
+		public ArrayList Arguments {
+			get {
+				return arguments;
+			}
+			set {
+				arguments = value;
+			}
+		}
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/DestructorDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/DestructorDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/DestructorDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,75 @@
+// DestructorDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class DestructorDeclaration : AbstractNode
+	{
+		string name; // exclusive '~'
+		ArrayList attributes = new ArrayList();
+		Modifier modifier;
+		BlockStatement  body;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public BlockStatement Body {
+			get {
+				return body;
+			}
+			set {
+				body = value;
+			}
+		}
+		
+		public DestructorDeclaration(string name, ArrayList attributes)
+		{
+			this.name = name;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventAddRegion.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventAddRegion.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventAddRegion.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,56 @@
+// EventAddRegion.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class EventAddRegion : AbstractNode
+	{
+		ArrayList attributes;
+		BlockStatement block;
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public BlockStatement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public EventAddRegion(ArrayList attributes)
+		{
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,154 @@
+// EventDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class EventDeclaration : AbstractNode
+	{
+		TypeReference   typeReference;
+		ArrayList variableDeclarators; // [Field]
+		Modifier modifier;
+		ArrayList attributes;
+		string name;
+		EventAddRegion    addRegion;
+		EventRemoveRegion removeRegion;
+		Point           bodyStart;
+		Point           bodyEnd;
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		public ArrayList VariableDeclarators {
+			get {
+				return variableDeclarators;
+			}
+			set {
+				variableDeclarators = value;
+			}
+		}
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		public EventAddRegion AddRegion {
+			get {
+				return addRegion;
+			}
+			set {
+				addRegion = value;
+			}
+		}
+		public EventRemoveRegion RemoveRegion {
+			get {
+				return removeRegion;
+			}
+			set {
+				removeRegion = value;
+			}
+		}
+		
+		public bool HasAddRegion {
+			get {
+				return addRegion != null;
+			}
+		}
+		
+		public bool HasRemoveRegion {
+			get {
+				return removeRegion != null;
+			}
+		}
+		public Point BodyStart {
+			get {
+				return bodyStart;
+			}
+			set {
+				bodyStart = value;
+			}
+		}
+		public Point BodyEnd {
+			get {
+				return bodyEnd;
+			}
+			set {
+				bodyEnd = value;
+			}
+		}
+		
+		public EventDeclaration()
+		{}
+		
+		public EventDeclaration(Modifier modifier, ArrayList attributes)
+		{
+			this.modifier = modifier;
+			this.attributes = attributes;
+		}
+		
+		public EventDeclaration(TypeReference typeReference, ArrayList variableDeclarators, Modifier modifier, ArrayList attributes)
+		{
+			this.typeReference = typeReference;
+			this.name = null;
+			this.variableDeclarators = variableDeclarators;
+			this.modifier = modifier;
+			this.attributes = attributes;
+		}
+		
+		public EventDeclaration(TypeReference typeReference, string name, Modifier modifier, ArrayList attributes)
+		{
+			this.typeReference = typeReference;
+			this.name = name;
+			this.variableDeclarators = null;
+			this.modifier = modifier;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventRemoveRegion.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventRemoveRegion.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/EventRemoveRegion.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,56 @@
+// EventRemoveRegion.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class EventRemoveRegion : AbstractNode
+	{
+		BlockStatement block;
+		ArrayList      attributes;
+		
+		public BlockStatement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public EventRemoveRegion(ArrayList attributes)
+		{
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/FieldDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/FieldDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/FieldDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,92 @@
+// FieldDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class FieldDeclaration : AbstractNode
+	{
+		ArrayList       attributes = null;
+		TypeReference   typeReference = null;
+		Modifier        modifier;
+		ArrayList       fields = new ArrayList(); // [VariableDeclaration]
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		public ArrayList Fields {
+			get {
+				return fields;
+			}
+			set {
+				fields = value;
+			}
+		}
+		
+		// for enum members
+		public FieldDeclaration(ArrayList attributes)
+		{
+			this.attributes = attributes;
+		}
+		
+		// for all other cases
+		public FieldDeclaration(ArrayList attributes, TypeReference typeReference, Modifier modifier)
+		{
+			this.attributes    = attributes;
+			this.typeReference = typeReference;
+			this.modifier      = modifier;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public VariableDeclaration GetVariableDeclaration(string variableName)
+		{
+			foreach (VariableDeclaration variableDeclaration in Fields) {
+				if (variableDeclaration.Name == variableName) {
+					return variableDeclaration;
+				}
+			}
+			return null;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/IndexerDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/IndexerDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/IndexerDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,158 @@
+// IndexerDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class IndexerDeclaration : AbstractNode
+	{
+		TypeReference type = null;
+		Modifier      modifier;
+		ArrayList     parameters = new ArrayList();
+		ArrayList     attributes = new ArrayList();
+		string        namespaceName;
+		Point           bodyStart;
+		Point           bodyEnd;
+				
+		PropertyGetRegion  propertyGetRegion = null;
+		PropertySetRegion  propertySetRegion = null;
+		
+		public TypeReference TypeReference {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public bool HasGetRegion {
+			get {
+				return propertyGetRegion != null;
+			}
+		}
+		
+		public bool HasSetRegion {
+			get {
+				return propertySetRegion != null;
+			}
+		}
+		
+		public bool IsReadOnly {
+			get {
+				return HasGetRegion &amp;&amp; !HasSetRegion;
+			}
+		}
+		
+		public bool IsWriteOnly {
+			get {
+				return !HasGetRegion &amp;&amp; HasSetRegion;
+			}
+		}
+		
+		public PropertyGetRegion GetRegion {
+			get {
+				return propertyGetRegion;
+			}
+			set {
+				propertyGetRegion = value;
+			}
+		}
+		public PropertySetRegion SetRegion {
+			get {
+				return propertySetRegion;
+			}
+			set {
+				propertySetRegion = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		public string NamespaceName {
+			get {
+				return namespaceName;
+			}
+			set {
+				namespaceName = value;
+			}
+		}
+		
+		public Point BodyStart {
+			get {
+				return bodyStart;
+			}
+			set {
+				bodyStart = value;
+			}
+		}
+		
+		public Point BodyEnd {
+			get {
+				return bodyEnd;
+			}
+			set {
+				bodyEnd = value;
+			}
+		}
+		
+		public IndexerDeclaration(Modifier modifier, ArrayList parameters, ArrayList attributes)
+		{
+			this.modifier = modifier;
+			this.parameters = parameters;
+			this.attributes = attributes;
+		}
+		
+		public IndexerDeclaration(TypeReference typeReference, ArrayList parameters, Modifier modifier, ArrayList attributes)
+		{
+			this.type = typeReference;
+			this.modifier = modifier;
+			this.parameters = parameters;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/MethodDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/MethodDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/MethodDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,105 @@
+// MethodDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class MethodDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier modifier;
+		TypeReference   typeReference;
+		ArrayList       parameters = new ArrayList(); // [ParameterDeclarationExpression]
+		ArrayList       attributes = new ArrayList();
+		BlockStatement  body;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public BlockStatement Body {
+			get {
+				return body;
+			}
+			set {
+				body = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public ArrayList Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public MethodDeclaration(string name, Modifier modifier, TypeReference typeReference, ArrayList parameters, ArrayList attributes)
+		{
+			this.name = name;
+			this.modifier = modifier;
+			this.typeReference = typeReference;
+			this.parameters = parameters;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[MethodDeclaration: Name={0}, Modifier={1}, TypeReference={2}]&quot;, name, modifier, typeReference);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/OperatorDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/OperatorDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/OperatorDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,182 @@
+// OperatorDeclaratoin.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class OperatorDeclaration : AbstractNode
+	{
+		OperatorDeclarator opratorDeclarator;
+		Modifier           modifier;
+		ArrayList          attributes = new ArrayList();
+		Statement     body;
+		
+		// TODO: delegate OperatorDeclarator Members
+		public OperatorDeclarator OpratorDeclarator {
+			get {
+				return opratorDeclarator;
+			}
+			set {
+				opratorDeclarator = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public Statement Body {
+			get {
+				return body;
+			}set {
+				body = value;
+			}
+		}
+		
+		public OperatorDeclaration(OperatorDeclarator opratorDeclarator, Modifier Modifier, ArrayList attributes)
+		{
+			this.opratorDeclarator = opratorDeclarator;
+			this.modifier          = Modifier;
+			this.attributes        = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+	
+	public enum OperatorType {
+		Unary,
+		Binary,
+		Implicit,
+		Explicit
+	}
+	
+	public class OperatorDeclarator
+	{
+		OperatorType  operatorType;
+		TypeReference typeReference;
+		int           overloadOperatorToken;
+		
+		TypeReference firstParameterType;
+		string firstParameterName;
+		
+		TypeReference secondParameterType;
+		string secondParameterName;
+		
+		public OperatorType OperatorType {
+			get {
+				return operatorType;
+			}
+			set {
+				operatorType = value;
+			}
+		}
+		public bool IsConversion {
+			get {
+				return operatorType == OperatorType.Implicit || operatorType == OperatorType.Explicit;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public int OverloadOperatorToken {
+			get {
+				return overloadOperatorToken;
+			}
+			set {
+				overloadOperatorToken = value;
+			}
+		}
+		
+		public TypeReference FirstParameterType {
+			get {
+				return firstParameterType;
+			}
+			set {
+				firstParameterType = value;
+			}
+		}
+		public string FirstParameterName {
+			get {
+				return firstParameterName;
+			}
+			set {
+				firstParameterName = value;
+			}
+		}
+		public TypeReference SecondParameterType {
+			get {
+				return secondParameterType;
+			}
+			set {
+				secondParameterType = value;
+			}
+		}
+		public string SecondParameterName {
+			get {
+				return secondParameterName;
+			}
+			set {
+				secondParameterName = value;
+			}
+		}
+		
+		public OperatorDeclarator(OperatorType operatorType, TypeReference typeReference, int overloadOperatorToken, TypeReference firstParameterType, string firstParameterName, TypeReference secondParameterType, string secondParameterName)
+		{
+			this.operatorType = operatorType;
+			this.typeReference = typeReference;
+			this.overloadOperatorToken = overloadOperatorToken;
+			this.firstParameterType = firstParameterType;
+			this.firstParameterName = firstParameterName;
+			this.secondParameterType = secondParameterType;
+			this.secondParameterName = secondParameterName;
+		}
+		
+		public OperatorDeclarator(OperatorType operatorType,TypeReference typeReference,  TypeReference firstParameterType, string firstParameterName)
+		{
+			this.operatorType       = operatorType;
+			this.typeReference      = typeReference;
+			this.firstParameterType = firstParameterType;
+			this.firstParameterName = firstParameterName;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/ParameterDeclarationExpression.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/ParameterDeclarationExpression.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/ParameterDeclarationExpression.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,59 @@
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST {
+	
+	public class ParameterDeclarationExpression : Expression
+	{
+		TypeReference  typeReference;
+		string         parameterName;
+		ParamModifiers paramModifiers;
+		ArrayList      attributes = new ArrayList();
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		public string ParameterName {
+			get {
+				return parameterName;
+			}
+			set {
+				parameterName = value;
+			}
+		}
+		
+		public ParamModifiers ParamModifiers {
+			get {
+				return paramModifiers;
+			}
+			set {
+				paramModifiers = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public ParameterDeclarationExpression(TypeReference typeReference, string parameterName, ParamModifiers paramModifiers)
+		{
+			this.typeReference  = typeReference;
+			this.parameterName  = parameterName;
+			this.paramModifiers = paramModifiers;
+		}
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertyDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertyDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertyDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,145 @@
+// PropertyDeclaration.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Drawing;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class PropertyDeclaration : AbstractNode
+	{
+		string          name;
+		Modifier        modifier;
+		TypeReference   typeReference;
+		ArrayList       attributes;
+		Point           bodyStart;
+		Point           bodyEnd;
+		
+		PropertyGetRegion  propertyGetRegion = null;
+		PropertySetRegion  propertySetRegion = null;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Modifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+		
+		public TypeReference TypeReference {
+			get {
+				return typeReference;
+			}
+			set {
+				typeReference = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public PropertyGetRegion GetRegion {
+			get {
+				return propertyGetRegion;
+			}
+			set {
+				propertyGetRegion = value;
+			}
+		}
+		public PropertySetRegion SetRegion {
+			get {
+				return propertySetRegion;
+			}
+			set {
+				propertySetRegion = value;
+			}
+		}
+		
+		public bool HasGetRegion {
+			get {
+				return propertyGetRegion != null;
+			}
+		}
+		
+		public bool HasSetRegion {
+			get {
+				return propertySetRegion != null;
+			}
+		}
+		
+		public bool IsReadOnly {
+			get {
+				return HasGetRegion &amp;&amp; !HasSetRegion;
+			}
+		}
+		
+		public bool IsWriteOnly {
+			get {
+				return !HasGetRegion &amp;&amp; HasSetRegion;
+			}
+		}
+		
+		
+		public Point BodyStart {
+			get {
+				return bodyStart;
+			}
+			set {
+				bodyStart = value;
+			}
+		}
+		public Point BodyEnd {
+			get {
+				return bodyEnd;
+			}
+			set {
+				bodyEnd = value;
+			}
+		}
+		
+		
+		public PropertyDeclaration(string name, TypeReference typeReference, Modifier modifier, ArrayList attributes)
+		{
+			this.name = name;
+			this.typeReference = typeReference;
+			this.modifier = modifier;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertyGetRegion.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertyGetRegion.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertyGetRegion.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,56 @@
+// PropertyGetRegion.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class PropertyGetRegion : AbstractNode
+	{
+		BlockStatement block;
+		ArrayList      attributes;
+		
+		public BlockStatement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+		
+		public PropertyGetRegion(BlockStatement block, ArrayList attributes)
+		{
+			this.block = block;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertySetRegion.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertySetRegion.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/PropertySetRegion.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,57 @@
+// PropertySetRegion.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class PropertySetRegion : AbstractNode
+	{
+		BlockStatement block;
+		ArrayList      attributes;
+		
+		public BlockStatement Block {
+			get {
+				return block;
+			}
+			set {
+				block = value;
+			}
+		}
+		
+		public ArrayList Attributes {
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+			
+		public PropertySetRegion(BlockStatement block, ArrayList attributes)
+		{
+			this.block = block;
+			this.attributes = attributes;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/TypeReference.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/TypeReference.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/TypeReference.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,115 @@
+// TypeReference.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class TypeReference
+	{
+		string type;
+		string systemType;
+		int    pointerNestingLevel = 0;
+		int[]  rankSpecifier;
+		
+		static Hashtable types = new Hashtable();
+		static TypeReference()
+		{
+			types.Add(&quot;bool&quot;,    &quot;System.Boolean&quot;);
+			types.Add(&quot;byte&quot;,    &quot;System.Byte&quot;);
+			types.Add(&quot;char&quot;,    &quot;System.Char&quot;);
+			types.Add(&quot;decimal&quot;, &quot;System.Decimal&quot;);
+			types.Add(&quot;double&quot;,  &quot;System.Double&quot;);
+			types.Add(&quot;float&quot;,   &quot;System.Single&quot;);
+			types.Add(&quot;int&quot;,     &quot;System.Int32&quot;);
+			types.Add(&quot;long&quot;,    &quot;System.Int64&quot;);
+			types.Add(&quot;object&quot;,  &quot;System.Object&quot;);
+			types.Add(&quot;sbyte&quot;,   &quot;System.SByte&quot;);
+			types.Add(&quot;short&quot;,   &quot;System.Int16&quot;);
+			types.Add(&quot;string&quot;,  &quot;System.String&quot;);
+			types.Add(&quot;uint&quot;,    &quot;System.UInt32&quot;);
+			types.Add(&quot;ulong&quot;,   &quot;System.UInt64&quot;);
+			types.Add(&quot;ushort&quot;,  &quot;System.UInt16&quot;);
+			types.Add(&quot;void&quot;,    &quot;System.Void&quot;);
+		}
+		
+		public string Type {
+			get {
+				return type;
+			}
+			set {
+				type = value;
+			}
+		}
+		
+		public string SystemType {
+			get {
+				return systemType;
+			}
+		}
+		
+		public int PointerNestingLevel {
+			get {
+				return pointerNestingLevel;
+			}
+			set {
+				pointerNestingLevel = value;
+			}
+		}
+		
+		public int[] RankSpecifier {
+			get {
+				return rankSpecifier;
+			}
+		}
+		
+		public bool IsArrayType {
+			get {
+				return rankSpecifier != null &amp;&amp; rankSpecifier.Length &gt; 0;
+			}
+		}
+		
+		string GetSystemType(string type)
+		{
+			if (types[type] != null) {
+				return (string)types[type];
+			}
+			return type;
+		}
+		
+		public TypeReference(string type)
+		{
+			this.systemType = GetSystemType(type);
+			this.type = type;
+		}
+		
+		public TypeReference(string type, int pointerNestingLevel, int[] rankSpecifier)
+		{
+			this.type = type;
+			this.systemType = GetSystemType(type);
+			this.pointerNestingLevel = pointerNestingLevel;
+			this.rankSpecifier = rankSpecifier;
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[TypeReference: Type={0}, PointerNestingLevel={1}, RankSpecifier={2}]&quot;, type, pointerNestingLevel, rankSpecifier);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/VariableDeclaration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/VariableDeclaration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/AST/TypeLevel/VariableDeclaration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,67 @@
+// Field.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+
+namespace ICSharpCode.SharpRefactory.Parser.AST
+{
+	public class VariableDeclaration : AbstractNode
+	{
+		string     name;
+		Expression initializer = null;
+		
+		public string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		
+		public Expression Initializer {
+			get {
+				return initializer;
+			}
+			set {
+				initializer = value;
+			}
+		}
+		
+		public VariableDeclaration(string name)
+		{
+			this.name = name;
+		}
+		
+		public VariableDeclaration(string name, Expression initializer)
+		{
+			this.name = name;
+			this.initializer = initializer;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[VariableDeclaration: Name={0}, Initializer={1}]&quot;, name, initializer);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Error.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Error.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Error.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,48 @@
+using System;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public delegate void ErrorCodeProc(int line, int col, int n);
+	public delegate void ErrorMsgProc(int line, int col, string msg);
+	
+	public class Errors
+	{
+		public int count = 0;                                               // number of errors detected
+		public ErrorCodeProc SynErr;
+		public ErrorCodeProc SemErr;
+		public ErrorMsgProc  Error;
+		StringBuilder errorText = new StringBuilder();
+		
+		public string ErrorOutput {
+			get {
+				return errorText.ToString();
+			}
+		}
+		public Errors()
+		{
+			SynErr = new ErrorCodeProc(DefaultCodeError);  // syntactic errors
+			SemErr = new ErrorCodeProc(DefaultCodeError);  // semantic errors
+			Error  = new ErrorMsgProc(DefaultMsgError);    // user defined string based errors
+		}
+		
+	//	public void Exception (string s)
+	//	{
+	//		Console.WriteLine(s); 
+	//		System.Environment.Exit(0);
+	//	}
+	
+		void DefaultCodeError (int line, int col, int n)
+		{
+			errorText.Append(String.Format(&quot;-- line {0} col {1} : error {2}&quot;, line, col, n));
+			errorText.Append(&quot;\n&quot;);
+			count++;
+		}
+	
+		void DefaultMsgError (int line, int col, string s) {
+			errorText.Append(String.Format(&quot;-- line {0} col {1} : {2}&quot;, line, col, s));
+			errorText.Append(&quot;\n&quot;);
+			count++;
+		}
+	} // Errors
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Modifiers.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Modifiers.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Modifiers.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,44 @@
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class Modifiers
+	{
+		Modifier cur;
+		Parser   parser;
+		
+		public Modifier Modifier {
+			get {
+				return cur;
+			}
+		}
+		
+		public Modifiers(Parser parser)
+		{
+			this.parser = parser;
+			cur         = Modifier.None;
+		}
+		
+		public bool isNone { get { return cur == Modifier.None; } }
+		
+		public void Add(Modifier m) 
+		{
+			if ((cur &amp; m) == 0) {
+				cur |= m;
+			} else {
+				parser.Error(&quot;modifier &quot; + m + &quot; already defined&quot;);
+			}
+		}
+		
+		public void Add(Modifiers m)
+		{
+			Add(m.cur);
+		}
+		
+		public void Check(Modifier allowed)
+		{
+			Modifier wrong = cur &amp; (allowed ^ Modifier.All);
+			if (wrong != Modifier.None) {
+				parser.Error(&quot;modifier(s) &quot; + wrong + &quot; not allowed here&quot;);
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Parser.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Parser.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Parser.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,4979 @@
+
+#line  1 &quot;cs.ATG&quot; 
+using System.Drawing;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+using System;
+using System.Reflection;
+
+namespace ICSharpCode.SharpRefactory.Parser {
+
+
+
+public class Parser
+{
+	const int maxT = 125;
+
+	const  bool   T            = true;
+	const  bool   x            = false;
+	const  int    minErrDist   = 2;
+	const  string errMsgFormat = &quot;-- line {0} col {1}: {2}&quot;;  // 0=line, 1=column, 2=text
+	int    errDist             = minErrDist;
+	Errors errors;
+	Lexer  lexer;
+
+	public Errors Errors {
+		get {
+			return errors;
+		}
+	}
+
+
+#line  10 &quot;cs.ATG&quot; 
+string assemblyName = null;
+
+public CompilationUnit compilationUnit;
+
+public string ContainingAssembly {
+	set {
+		assemblyName = value;
+	}
+}
+
+Token t {
+	get {
+		return lexer.Token;
+	}
+}
+Token la {
+	get {
+		return lexer.LookAhead;
+	}
+}
+
+Hashtable typeStrings     = null;
+ArrayList usingNamespaces = null;
+
+public void Error(string s)
+{
+	if (errDist &gt;= minErrDist) {
+		errors.Error(la.line, la.col, s);
+	}
+	errDist = 0;
+}
+
+public Expression ParseExpression(Lexer lexer)
+{
+	this.errors = lexer.Errors;
+	this.lexer = lexer;
+	errors.SynErr = new ErrorCodeProc(SynErr);
+	lexer.NextToken();
+	Expression expr;
+	Expr(out expr);
+	return expr;
+}
+
+bool IsTypeCast()
+{
+	if (IsSimpleTypeCast()) {
+		return true;
+	}
+	
+	if (assemblyName != null) {
+		return CheckTypeCast();
+	}
+	
+	return GuessTypeCast();
+}
+
+bool IsSimpleTypeCast()
+{
+	// check: &quot;(&quot; pointer or array of keyword type &quot;)&quot;
+	
+	if (la.kind != Tokens.OpenParenthesis) {
+		return false;
+	}
+
+	StartPeek();
+	Token pt1 = Peek();
+	Token pt  = Peek();
+	
+	return ParserUtil.IsTypeKW(pt1) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp;
+	       pt.kind == Tokens.CloseParenthesis;
+}
+
+bool CheckTypeCast()
+{
+	// check: leading &quot;(&quot; pointer or array of some type &quot;)&quot;
+
+	if (la.kind != Tokens.OpenParenthesis) {
+		return false;
+	}
+	
+	string qualident;
+	
+	StartPeek();
+	Token pt = Peek();
+	
+	return IsQualident(ref pt, out qualident) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	       pt.kind == Tokens.CloseParenthesis &amp;&amp; IsType(qualident);		
+}
+
+bool IsType(string qualident)
+{
+	if (typeStrings == null) {
+		CreateTypeStrings();
+	}
+	
+	if (typeStrings.ContainsValue(qualident)) {
+		return true;
+	}
+	
+	foreach (string ns in usingNamespaces) {
+		if (typeStrings.ContainsValue(ns + &quot;.&quot; + qualident)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+bool GuessTypeCast()
+{
+	// check: &quot;(&quot; pointer or array of some type &quot;)&quot; possible type cast successor
+	
+	if (la.kind != Tokens.OpenParenthesis) return false;
+	
+	string qualident;
+	
+	StartPeek();
+	Token pt = Peek();
+	
+	if (IsQualident(ref pt, out qualident) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	    pt.kind == Tokens.CloseParenthesis) {
+		// check successor
+		pt = Peek();
+		return pt.kind == Tokens.Identifier || pt.kind == Tokens.Literal   ||
+		       pt.kind == Tokens.OpenParenthesis   || ParserUtil.IsUnaryOperator(pt)         ||
+		       pt.kind == Tokens.New        || pt.kind == Tokens.This      ||
+		       pt.kind == Tokens.Base       || pt.kind == Tokens.Null      ||
+		       pt.kind == Tokens.Checked    || pt.kind == Tokens.Unchecked ||
+		       pt.kind == Tokens.Typeof     || pt.kind == Tokens.Sizeof    ||
+		       (ParserUtil.IsTypeKW(pt) &amp;&amp; Peek().kind == Tokens.Dot);
+	} else return false;
+}
+
+void CreateTypeStrings()
+{
+	Assembly a;
+	Type[] types;
+	AssemblyName [] aNames;
+	
+	if (assemblyName != null &amp;&amp; assemblyName.Length &gt; 0) {    /* AW 2002-12-30 add check for length &gt; 0 */
+		typeStrings = new Hashtable();
+		a = Assembly.LoadFrom(assemblyName);
+		types = a.GetTypes();
+		foreach (Type t in types) 
+			typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
+		aNames = a.GetReferencedAssemblies();
+		
+		for (int i = 0; i &lt; aNames.Length; i++) {
+			a = Assembly.LoadFrom(aNames[i].Name);
+			types = a.GetExportedTypes();
+			
+			foreach(Type t in types)
+				if (usingNamespaces.Contains(t.FullName.Substring(0, t.FullName.LastIndexOf('.'))))
+					typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
+		}
+	}
+}
+
+/* Checks whether the next sequences of tokens is a qualident *
+ * and returns the qualident string                           */
+/* !!! Proceeds from current peek position !!! */
+bool IsQualident (ref Token pt, out string qualident)
+{
+	qualident = &quot;&quot;;
+	if (pt.kind == Tokens.Identifier) {
+		qualident = pt.val;
+		pt = Peek();
+		while (pt.kind == Tokens.Dot) {
+			pt = Peek();
+			if (pt.kind != Tokens.Identifier) return false;
+			qualident += &quot;.&quot; + pt.val;
+			pt = Peek();
+		}
+		return true;
+	} else return false;
+}
+
+/* skip: { &quot;*&quot; | &quot;[&quot; { &quot;,&quot; } &quot;]&quot; } */
+/* !!! Proceeds from current peek position !!! */
+bool IsPointerOrDims (ref Token pt)
+{
+	for (;;) {
+		if (pt.kind == Tokens.OpenSquareBracket) {
+			do pt = Peek();
+			while (pt.kind == Tokens.Comma);
+			if (pt.kind != Tokens.CloseSquareBracket) return false;
+		} else if (pt.kind != Tokens.Times) break;
+		pt = Peek();
+	}
+	return true;
+}
+
+/* Return the n-th token after the current lookahead token */
+void StartPeek()
+{
+	lexer.StartPeek();
+}
+
+Token Peek()
+{
+	return lexer.Peek();
+}
+
+Token Peek (int n)
+{
+	lexer.StartPeek();
+	Token x = la;
+	while (n &gt; 0) {
+		x = lexer.Peek();
+		n--;
+	}
+	return x;
+}
+
+/*-----------------------------------------------------------------*
+ * Resolver routines to resolve LL(1) conflicts:                   *                                                  *
+ * These resolution routine return a boolean value that indicates  *
+ * whether the alternative at hand shall be choosen or not.        *
+ * They are used in IF ( ... ) expressions.                        *       
+ *-----------------------------------------------------------------*/
+
+/* True, if ident is followed by &quot;=&quot; */
+bool IdentAndAsgn ()
+{
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.Assign;
+}
+
+bool IsAssignment () { return IdentAndAsgn(); }
+
+/* True, if ident is followed by &quot;,&quot;, &quot;=&quot;, or &quot;;&quot; */
+bool IdentAndCommaOrAsgnOrSColon () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Identifier &amp;&amp; 
+	       (peek == Tokens.Comma || peek == Tokens.Assign || peek == Tokens.Semicolon);
+}
+bool IsVarDecl () { return IdentAndCommaOrAsgnOrSColon(); }
+
+/* True, if the comma is not a trailing one, *
+ * like the last one in: a, b, c,            */
+bool NotFinalComma () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Comma &amp;&amp;
+	       peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
+}
+
+/* True, if &quot;void&quot; is followed by &quot;*&quot; */
+bool NotVoidPointer () {
+	return la.kind == Tokens.Void &amp;&amp; Peek(1).kind != Tokens.Times;
+}
+
+/* True, if &quot;checked&quot; or &quot;unchecked&quot; are followed by &quot;{&quot; */
+bool UnCheckedAndLBrace () {
+	return la.kind == Tokens.Checked || la.kind == Tokens.Unchecked &amp;&amp;
+	       Peek(1).kind == Tokens.OpenCurlyBrace;
+}
+
+/* True, if &quot;.&quot; is followed by an ident */
+bool DotAndIdent () {
+	return la.kind == Tokens.Dot &amp;&amp; Peek(1).kind == Tokens.Identifier;
+}
+
+/* True, if ident is followed by &quot;:&quot; */
+bool IdentAndColon () {
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.Colon;
+}
+
+bool IsLabel () { return IdentAndColon(); }
+
+/* True, if ident is followed by &quot;(&quot; */
+bool IdentAndLPar () {
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.OpenParenthesis;
+}
+
+/* True, if &quot;catch&quot; is followed by &quot;(&quot; */
+bool CatchAndLPar () {
+	return la.kind == Tokens.Catch &amp;&amp; Peek(1).kind == Tokens.OpenParenthesis;
+}
+bool IsTypedCatch () { return CatchAndLPar(); }
+
+/* True, if &quot;[&quot; is followed by the ident &quot;assembly&quot; */
+bool IsGlobalAttrTarget () {
+	Token pt = Peek(1);
+	return la.kind == Tokens.OpenSquareBracket &amp;&amp; 
+	       pt.kind == Tokens.Identifier &amp;&amp; pt.val == &quot;assembly&quot;;
+}
+
+/* True, if &quot;[&quot; is followed by &quot;,&quot; or &quot;]&quot; */
+bool LBrackAndCommaOrRBrack () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.OpenSquareBracket &amp;&amp;
+	       (peek == Tokens.Comma || peek == Tokens.CloseSquareBracket);
+}
+
+bool IsDims () { return LBrackAndCommaOrRBrack(); }
+
+/* True, if &quot;[&quot; is followed by &quot;,&quot; or &quot;]&quot; *
+ * or if the current token is &quot;*&quot;         */
+bool TimesOrLBrackAndCommaOrRBrack () {
+	return la.kind == Tokens.Times || LBrackAndCommaOrRBrack();
+}
+bool IsPointerOrDims () { return TimesOrLBrackAndCommaOrRBrack(); }
+bool IsPointer () { return la.kind == Tokens.Times; }
+
+/* True, if lookahead is a primitive type keyword, or *
+ * if it is a type declaration followed by an ident   */
+bool IsLocalVarDecl () {
+	if ((ParserUtil.IsTypeKW(la) &amp;&amp; Peek(1).kind != Tokens.Dot) || la.kind == Tokens.Void) return true;
+	
+	StartPeek();
+	Token pt = la ;  // peek token
+	string ignore;
+	
+	return IsQualident(ref pt, out ignore) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	       pt.kind == Tokens.Identifier;
+}
+
+/* True, if lookahead ident is &quot;get&quot; */
+bool IdentIsGet () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;get&quot;;
+}
+
+/* True, if lookahead ident is &quot;set&quot; */
+bool IdentIsSet () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;set&quot;;
+}
+
+/* True, if lookahead ident is &quot;add&quot; */
+bool IdentIsAdd () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;add&quot;;
+}
+
+/* True, if lookahead ident is &quot;remove&quot; */
+bool IdentIsRemove () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;remove&quot;;
+}
+
+/* True, if lookahead is a local attribute target specifier, *
+ * i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,         *
+ *             &quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;      */
+bool IsLocalAttrTarget () {
+	int cur = la.kind;
+	string val = la.val;
+
+	return (cur == Tokens.Event || cur == Tokens.Return ||
+	        (cur == Tokens.Identifier &amp;&amp;
+	         (val == &quot;field&quot; || val == &quot;method&quot;   || val == &quot;module&quot; ||
+	          val == &quot;param&quot; || val == &quot;property&quot; || val == &quot;type&quot;))) &amp;&amp;
+	       Peek(1).kind == Tokens.Colon;
+}
+
+
+/*------------------------------------------------------------------------*
+ *----- LEXER TOKEN LIST  ------------------------------------------------*
+ *------------------------------------------------------------------------*/
+
+
+/*
+
+*/
+	void SynErr(int n)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.SynErr(lexer.LookAhead.line, lexer.LookAhead.col, n);
+		}
+		errDist = 0;
+	}
+
+	public void SemErr(string msg)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.Error(lexer.Token.line, lexer.Token.col, msg);
+		}
+		errDist = 0;
+	}
+	
+	void Expect(int n)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+		}
+	}
+	
+	bool StartOf(int s)
+	{
+		return set[s, lexer.LookAhead.kind];
+	}
+	
+	void ExpectWeak(int n, int follow)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+			while (!StartOf(follow)) {
+				lexer.NextToken();
+			}
+		}
+	}
+	
+	bool WeakSeparator(int n, int syFol, int repFol)
+	{
+		bool[] s = new bool[maxT + 1];
+		
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+			return true; 
+		} else if (StartOf(repFol)) {
+			return false;
+		} else {
+			for (int i = 0; i &lt;= maxT; i++) {
+				s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
+			}
+			SynErr(n);
+			while (!s[lexer.LookAhead.kind]) {
+				lexer.NextToken();
+			}
+			return StartOf(syFol);
+		}
+	}
+	
+	void CS() {
+
+#line  516 &quot;cs.ATG&quot; 
+		compilationUnit = new CompilationUnit(); 
+		while (la.kind == 120) {
+			UsingDirective();
+		}
+		while (
+#line  519 &quot;cs.ATG&quot; 
+IsGlobalAttrTarget()) {
+			GlobalAttributeSection();
+		}
+		while (StartOf(1)) {
+			NamespaceMemberDecl();
+		}
+		Expect(0);
+	}
+
+	void UsingDirective() {
+
+#line  526 &quot;cs.ATG&quot; 
+		usingNamespaces = new ArrayList();
+		string qualident = null, aliasident = null;
+		
+		Expect(120);
+
+#line  530 &quot;cs.ATG&quot; 
+		Point startPos = t.Location;
+		INode node     = null; 
+		
+		if (
+#line  533 &quot;cs.ATG&quot; 
+IsAssignment()) {
+			lexer.NextToken();
+
+#line  533 &quot;cs.ATG&quot; 
+			aliasident = t.val; 
+			Expect(3);
+		}
+		Qualident(
+#line  534 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  534 &quot;cs.ATG&quot; 
+		if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
+		 if (aliasident != null) {
+		   node = new UsingAliasDeclaration(aliasident, qualident);
+		 } else {
+		     usingNamespaces.Add(qualident);
+		     node = new UsingDeclaration(qualident);
+		 }
+		}
+		
+		Expect(10);
+
+#line  543 &quot;cs.ATG&quot; 
+		node.StartLocation = startPos;
+		node.EndLocation   = t.EndLocation;
+		compilationUnit.AddChild(node);
+		
+	}
+
+	void GlobalAttributeSection() {
+		Expect(16);
+
+#line  552 &quot;cs.ATG&quot; 
+		Point startPos = t.Location; 
+		Expect(1);
+
+#line  552 &quot;cs.ATG&quot; 
+		if (t.val != &quot;assembly&quot;) Error(&quot;global attribute target specifier (\&quot;assembly\&quot;) expected&quot;);
+		string attributeTarget = t.val;
+		ArrayList attributes = new ArrayList();
+		ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
+		
+		Expect(9);
+		Attribute(
+#line  557 &quot;cs.ATG&quot; 
+out attribute);
+
+#line  557 &quot;cs.ATG&quot; 
+		attributes.Add(attribute); 
+		while (
+#line  558 &quot;cs.ATG&quot; 
+NotFinalComma()) {
+			Expect(12);
+			Attribute(
+#line  558 &quot;cs.ATG&quot; 
+out attribute);
+
+#line  558 &quot;cs.ATG&quot; 
+			attributes.Add(attribute); 
+		}
+		if (la.kind == 12) {
+			lexer.NextToken();
+		}
+		Expect(17);
+
+#line  560 &quot;cs.ATG&quot; 
+		AttributeSection section = new AttributeSection(attributeTarget, attributes);
+		section.StartLocation = startPos;
+		section.EndLocation = t.EndLocation;
+		compilationUnit.AddChild(section);
+		
+	}
+
+	void NamespaceMemberDecl() {
+
+#line  642 &quot;cs.ATG&quot; 
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		Modifiers m = new Modifiers(this);
+		string qualident;
+		
+		if (la.kind == 87) {
+			lexer.NextToken();
+
+#line  648 &quot;cs.ATG&quot; 
+			Point startPos = t.Location; 
+			Qualident(
+#line  649 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  649 &quot;cs.ATG&quot; 
+			INode node =  new NamespaceDeclaration(qualident);
+			node.StartLocation = startPos;
+			compilationUnit.AddChild(node);
+			compilationUnit.BlockStart(node);
+			
+			Expect(14);
+			while (la.kind == 120) {
+				UsingDirective();
+			}
+			while (StartOf(1)) {
+				NamespaceMemberDecl();
+			}
+			Expect(15);
+			if (la.kind == 10) {
+				lexer.NextToken();
+			}
+
+#line  658 &quot;cs.ATG&quot; 
+			node.EndLocation   = t.EndLocation;
+			compilationUnit.BlockEnd();
+			
+		} else if (StartOf(2)) {
+			while (la.kind == 16) {
+				AttributeSection(
+#line  662 &quot;cs.ATG&quot; 
+out section);
+
+#line  662 &quot;cs.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(3)) {
+				TypeModifier(
+#line  663 &quot;cs.ATG&quot; 
+m);
+			}
+			TypeDecl(
+#line  664 &quot;cs.ATG&quot; 
+m, attributes);
+		} else SynErr(126);
+	}
+
+	void Qualident(
+#line  749 &quot;cs.ATG&quot; 
+out string qualident) {
+		Expect(1);
+
+#line  751 &quot;cs.ATG&quot; 
+		StringBuilder qualidentBuilder = new StringBuilder(t.val); 
+		while (
+#line  752 &quot;cs.ATG&quot; 
+DotAndIdent()) {
+			Expect(13);
+			Expect(1);
+
+#line  752 &quot;cs.ATG&quot; 
+			qualidentBuilder.Append('.');
+			qualidentBuilder.Append(t.val); 
+			
+		}
+
+#line  755 &quot;cs.ATG&quot; 
+		qualident = qualidentBuilder.ToString(); 
+	}
+
+	void Attribute(
+#line  567 &quot;cs.ATG&quot; 
+out ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute) {
+
+#line  568 &quot;cs.ATG&quot; 
+		string qualident; 
+		Qualident(
+#line  570 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  570 &quot;cs.ATG&quot; 
+		ArrayList positional = new ArrayList();
+		ArrayList named      = new ArrayList();
+		string name = qualident;
+		
+		if (la.kind == 18) {
+			AttributeArguments(
+#line  574 &quot;cs.ATG&quot; 
+ref positional, ref named);
+		}
+
+#line  574 &quot;cs.ATG&quot; 
+		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.Attribute(name, positional, named);
+	}
+
+	void AttributeArguments(
+#line  577 &quot;cs.ATG&quot; 
+ref ArrayList positional, ref ArrayList named) {
+
+#line  579 &quot;cs.ATG&quot; 
+		bool nameFound = false;
+		string name = &quot;&quot;;
+		Expression expr;
+		
+		Expect(18);
+		if (StartOf(4)) {
+			if (
+#line  587 &quot;cs.ATG&quot; 
+IsAssignment()) {
+
+#line  587 &quot;cs.ATG&quot; 
+				nameFound = true; 
+				lexer.NextToken();
+
+#line  588 &quot;cs.ATG&quot; 
+				name = t.val; 
+				Expect(3);
+			}
+			Expr(
+#line  590 &quot;cs.ATG&quot; 
+out expr);
+
+#line  590 &quot;cs.ATG&quot; 
+			if(name == &quot;&quot;) positional.Add(expr);
+			else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+				if (
+#line  597 &quot;cs.ATG&quot; 
+IsAssignment()) {
+
+#line  597 &quot;cs.ATG&quot; 
+					nameFound = true; 
+					Expect(1);
+
+#line  598 &quot;cs.ATG&quot; 
+					name = t.val; 
+					Expect(3);
+				} else if (StartOf(4)) {
+
+#line  600 &quot;cs.ATG&quot; 
+					if (nameFound) Error(&quot;no positional argument after named argument&quot;); 
+				} else SynErr(127);
+				Expr(
+#line  601 &quot;cs.ATG&quot; 
+out expr);
+
+#line  601 &quot;cs.ATG&quot; 
+				if(name == &quot;&quot;) positional.Add(expr);
+				else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
+				
+			}
+		}
+		Expect(19);
+	}
+
+	void Expr(
+#line  1714 &quot;cs.ATG&quot; 
+out Expression expr) {
+
+#line  1715 &quot;cs.ATG&quot; 
+		expr = null; Expression expr1 = null, expr2 = null; 
+		UnaryExpr(
+#line  1717 &quot;cs.ATG&quot; 
+out expr);
+		if (StartOf(5)) {
+			ConditionalOrExpr(
+#line  1720 &quot;cs.ATG&quot; 
+ref expr);
+			if (la.kind == 11) {
+				lexer.NextToken();
+				Expr(
+#line  1720 &quot;cs.ATG&quot; 
+out expr1);
+				Expect(9);
+				Expr(
+#line  1720 &quot;cs.ATG&quot; 
+out expr2);
+
+#line  1720 &quot;cs.ATG&quot; 
+				expr = new ConditionalExpression(expr, expr1, expr2);  
+			}
+		} else if (StartOf(6)) {
+
+#line  1722 &quot;cs.ATG&quot; 
+			AssignmentOperatorType op; Expression val; 
+			AssignmentOperator(
+#line  1722 &quot;cs.ATG&quot; 
+out op);
+			Expr(
+#line  1722 &quot;cs.ATG&quot; 
+out val);
+
+#line  1722 &quot;cs.ATG&quot; 
+			expr = new AssignmentExpression(expr, op, val); 
+		} else SynErr(128);
+	}
+
+	void AttributeSection(
+#line  609 &quot;cs.ATG&quot; 
+out AttributeSection section) {
+
+#line  611 &quot;cs.ATG&quot; 
+		string attributeTarget = &quot;&quot;;
+		ArrayList attributes = new ArrayList();
+		ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
+		
+		
+		Expect(16);
+
+#line  617 &quot;cs.ATG&quot; 
+		Point startPos = t.Location; 
+		if (
+#line  618 &quot;cs.ATG&quot; 
+IsLocalAttrTarget()) {
+			if (la.kind == 68) {
+				lexer.NextToken();
+
+#line  619 &quot;cs.ATG&quot; 
+				attributeTarget = &quot;event&quot;;
+			} else if (la.kind == 100) {
+				lexer.NextToken();
+
+#line  620 &quot;cs.ATG&quot; 
+				attributeTarget = &quot;return&quot;;
+			} else {
+				lexer.NextToken();
+
+#line  621 &quot;cs.ATG&quot; 
+				if (t.val != &quot;field&quot;    || t.val != &quot;method&quot; ||
+				  t.val != &quot;module&quot;   || t.val != &quot;param&quot;  ||
+				  t.val != &quot;property&quot; || t.val != &quot;type&quot;)
+				Error(&quot;attribute target specifier (event, return, field,&quot; +
+				      &quot;method, module, param, property, or type) expected&quot;);
+				attributeTarget = t.val;
+				
+			}
+			Expect(9);
+		}
+		Attribute(
+#line  631 &quot;cs.ATG&quot; 
+out attribute);
+
+#line  631 &quot;cs.ATG&quot; 
+		attributes.Add(attribute); 
+		while (
+#line  632 &quot;cs.ATG&quot; 
+NotFinalComma()) {
+			Expect(12);
+			Attribute(
+#line  632 &quot;cs.ATG&quot; 
+out attribute);
+
+#line  632 &quot;cs.ATG&quot; 
+			attributes.Add(attribute); 
+		}
+		if (la.kind == 12) {
+			lexer.NextToken();
+		}
+		Expect(17);
+
+#line  634 &quot;cs.ATG&quot; 
+		section = new AttributeSection(attributeTarget, attributes);
+		section.StartLocation = startPos;
+		section.EndLocation = t.EndLocation;
+		
+	}
+
+	void TypeModifier(
+#line  920 &quot;cs.ATG&quot; 
+Modifiers m) {
+		switch (la.kind) {
+		case 88: {
+			lexer.NextToken();
+
+#line  922 &quot;cs.ATG&quot; 
+			m.Add(Modifier.New); 
+			break;
+		}
+		case 97: {
+			lexer.NextToken();
+
+#line  923 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Public); 
+			break;
+		}
+		case 96: {
+			lexer.NextToken();
+
+#line  924 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Protected); 
+			break;
+		}
+		case 83: {
+			lexer.NextToken();
+
+#line  925 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Internal); 
+			break;
+		}
+		case 95: {
+			lexer.NextToken();
+
+#line  926 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Private); 
+			break;
+		}
+		case 118: {
+			lexer.NextToken();
+
+#line  927 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Unsafe); 
+			break;
+		}
+		case 48: {
+			lexer.NextToken();
+
+#line  928 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Abstract); 
+			break;
+		}
+		case 102: {
+			lexer.NextToken();
+
+#line  929 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Sealed); 
+			break;
+		}
+		default: SynErr(129); break;
+		}
+	}
+
+	void TypeDecl(
+#line  667 &quot;cs.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+
+#line  669 &quot;cs.ATG&quot; 
+		TypeReference type;
+		StringCollection names;
+		ArrayList p; string name;
+		
+		if (la.kind == 58) {
+
+#line  673 &quot;cs.ATG&quot; 
+			m.Check(Modifier.Classes); 
+			lexer.NextToken();
+
+#line  674 &quot;cs.ATG&quot; 
+			TypeDeclaration newType = new TypeDeclaration();
+			compilationUnit.AddChild(newType);
+			compilationUnit.BlockStart(newType);
+			
+			newType.Type = Types.Class;
+			newType.Modifier = m.Modifier;
+			newType.Attributes = attributes;
+			
+			Expect(1);
+
+#line  682 &quot;cs.ATG&quot; 
+			newType.Name = t.val; 
+			if (la.kind == 9) {
+				ClassBase(
+#line  683 &quot;cs.ATG&quot; 
+out names);
+
+#line  683 &quot;cs.ATG&quot; 
+				newType.BaseTypes = names; 
+			}
+
+#line  683 &quot;cs.ATG&quot; 
+			newType.StartLocation = t.EndLocation; 
+			ClassBody();
+			if (la.kind == 10) {
+				lexer.NextToken();
+			}
+
+#line  685 &quot;cs.ATG&quot; 
+			newType.EndLocation = t.Location; 
+			compilationUnit.BlockEnd();
+			
+		} else if (StartOf(7)) {
+
+#line  688 &quot;cs.ATG&quot; 
+			m.Check(Modifier.StructsInterfacesEnumsDelegates); 
+			if (la.kind == 108) {
+				lexer.NextToken();
+
+#line  689 &quot;cs.ATG&quot; 
+				TypeDeclaration newType = new TypeDeclaration();
+				compilationUnit.AddChild(newType);
+				compilationUnit.BlockStart(newType);
+				newType.Type = Types.Struct; 
+				newType.Modifier = m.Modifier;
+				newType.Attributes = attributes;
+				
+				Expect(1);
+
+#line  696 &quot;cs.ATG&quot; 
+				newType.Name = t.val; 
+				if (la.kind == 9) {
+					StructInterfaces(
+#line  697 &quot;cs.ATG&quot; 
+out names);
+
+#line  697 &quot;cs.ATG&quot; 
+					newType.BaseTypes = names; 
+				}
+
+#line  697 &quot;cs.ATG&quot; 
+				newType.StartLocation = t.EndLocation; 
+				StructBody();
+				if (la.kind == 10) {
+					lexer.NextToken();
+				}
+
+#line  699 &quot;cs.ATG&quot; 
+				newType.EndLocation = t.Location; 
+				compilationUnit.BlockEnd();
+				
+			} else if (la.kind == 82) {
+				lexer.NextToken();
+
+#line  703 &quot;cs.ATG&quot; 
+				TypeDeclaration newType = new TypeDeclaration();
+				compilationUnit.AddChild(newType);
+				compilationUnit.BlockStart(newType);
+				newType.Type = Types.Interface;
+				newType.Attributes = attributes;
+				newType.Modifier = m.Modifier;
+				Expect(1);
+
+#line  709 &quot;cs.ATG&quot; 
+				newType.Name = t.val; 
+				if (la.kind == 9) {
+					InterfaceBase(
+#line  710 &quot;cs.ATG&quot; 
+out names);
+
+#line  710 &quot;cs.ATG&quot; 
+					newType.BaseTypes = names; 
+				}
+
+#line  710 &quot;cs.ATG&quot; 
+				newType.StartLocation = t.EndLocation; 
+				InterfaceBody();
+				if (la.kind == 10) {
+					lexer.NextToken();
+				}
+
+#line  712 &quot;cs.ATG&quot; 
+				newType.EndLocation = t.Location; 
+				compilationUnit.BlockEnd();
+				
+			} else if (la.kind == 67) {
+				lexer.NextToken();
+
+#line  716 &quot;cs.ATG&quot; 
+				TypeDeclaration newType = new TypeDeclaration();
+				compilationUnit.AddChild(newType);
+				compilationUnit.BlockStart(newType);
+				newType.Type = Types.Enum;
+				newType.Attributes = attributes;
+				newType.Modifier = m.Modifier;
+				Expect(1);
+
+#line  722 &quot;cs.ATG&quot; 
+				newType.Name = t.val; 
+				if (la.kind == 9) {
+					lexer.NextToken();
+					IntegralType(
+#line  723 &quot;cs.ATG&quot; 
+out name);
+
+#line  723 &quot;cs.ATG&quot; 
+					newType.BaseTypes = new StringCollection(); 
+					newType.BaseTypes.Add(name);
+					
+				}
+
+#line  726 &quot;cs.ATG&quot; 
+				newType.StartLocation = t.EndLocation; 
+				EnumBody();
+				if (la.kind == 10) {
+					lexer.NextToken();
+				}
+
+#line  728 &quot;cs.ATG&quot; 
+				newType.EndLocation = t.Location; 
+				compilationUnit.BlockEnd();
+				
+			} else {
+				lexer.NextToken();
+
+#line  732 &quot;cs.ATG&quot; 
+				DelegateDeclaration delegateDeclr = new DelegateDeclaration();
+				delegateDeclr.StartLocation = t.Location;
+				delegateDeclr.Modifier = m.Modifier;
+				delegateDeclr.Attributes = attributes;
+				
+				if (
+#line  737 &quot;cs.ATG&quot; 
+NotVoidPointer()) {
+					Expect(122);
+
+#line  737 &quot;cs.ATG&quot; 
+					delegateDeclr.ReturnType = new TypeReference(&quot;void&quot;, 0, null); 
+				} else if (StartOf(8)) {
+					Type(
+#line  738 &quot;cs.ATG&quot; 
+out type);
+
+#line  738 &quot;cs.ATG&quot; 
+					delegateDeclr.ReturnType = type; 
+				} else SynErr(130);
+				Expect(1);
+
+#line  740 &quot;cs.ATG&quot; 
+				delegateDeclr.Name = t.val; 
+				Expect(18);
+				if (StartOf(9)) {
+					FormalParameterList(
+#line  741 &quot;cs.ATG&quot; 
+out p);
+
+#line  741 &quot;cs.ATG&quot; 
+					delegateDeclr.Parameters = p; 
+				}
+				Expect(19);
+				Expect(10);
+
+#line  743 &quot;cs.ATG&quot; 
+				delegateDeclr.EndLocation = t.Location;
+				compilationUnit.AddChild(delegateDeclr);
+				
+			}
+		} else SynErr(131);
+	}
+
+	void ClassBase(
+#line  758 &quot;cs.ATG&quot; 
+out StringCollection names) {
+
+#line  760 &quot;cs.ATG&quot; 
+		string qualident;
+		names = new StringCollection(); 
+		
+		Expect(9);
+		ClassType(
+#line  764 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  764 &quot;cs.ATG&quot; 
+		names.Add(qualident); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			Qualident(
+#line  765 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  765 &quot;cs.ATG&quot; 
+			names.Add(qualident); 
+		}
+	}
+
+	void ClassBody() {
+
+#line  769 &quot;cs.ATG&quot; 
+		AttributeSection section; 
+		Expect(14);
+		while (StartOf(10)) {
+
+#line  772 &quot;cs.ATG&quot; 
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+			
+			while (la.kind == 16) {
+				AttributeSection(
+#line  775 &quot;cs.ATG&quot; 
+out section);
+
+#line  775 &quot;cs.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(11)) {
+				MemberModifier(
+#line  776 &quot;cs.ATG&quot; 
+m);
+			}
+			ClassMemberDecl(
+#line  777 &quot;cs.ATG&quot; 
+m, attributes);
+		}
+		Expect(15);
+	}
+
+	void StructInterfaces(
+#line  782 &quot;cs.ATG&quot; 
+out StringCollection names) {
+
+#line  784 &quot;cs.ATG&quot; 
+		string qualident; 
+		names = new StringCollection();
+		
+		Expect(9);
+		Qualident(
+#line  788 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  788 &quot;cs.ATG&quot; 
+		names.Add(qualident); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			Qualident(
+#line  789 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  789 &quot;cs.ATG&quot; 
+			names.Add(qualident); 
+		}
+	}
+
+	void StructBody() {
+
+#line  793 &quot;cs.ATG&quot; 
+		AttributeSection section; 
+		Expect(14);
+		while (StartOf(12)) {
+
+#line  796 &quot;cs.ATG&quot; 
+			ArrayList attributes = new ArrayList();
+			Modifiers m = new Modifiers(this);
+			
+			while (la.kind == 16) {
+				AttributeSection(
+#line  799 &quot;cs.ATG&quot; 
+out section);
+
+#line  799 &quot;cs.ATG&quot; 
+				attributes.Add(section); 
+			}
+			while (StartOf(11)) {
+				MemberModifier(
+#line  800 &quot;cs.ATG&quot; 
+m);
+			}
+			StructMemberDecl(
+#line  801 &quot;cs.ATG&quot; 
+m, attributes);
+		}
+		Expect(15);
+	}
+
+	void InterfaceBase(
+#line  806 &quot;cs.ATG&quot; 
+out StringCollection names) {
+
+#line  808 &quot;cs.ATG&quot; 
+		string qualident;
+		names = new StringCollection();
+		
+		Expect(9);
+		Qualident(
+#line  812 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  812 &quot;cs.ATG&quot; 
+		names.Add(qualident); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			Qualident(
+#line  813 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  813 &quot;cs.ATG&quot; 
+			names.Add(qualident); 
+		}
+	}
+
+	void InterfaceBody() {
+		Expect(14);
+		while (StartOf(13)) {
+			InterfaceMemberDecl();
+		}
+		Expect(15);
+	}
+
+	void IntegralType(
+#line  939 &quot;cs.ATG&quot; 
+out string name) {
+
+#line  939 &quot;cs.ATG&quot; 
+		name = &quot;&quot;; 
+		switch (la.kind) {
+		case 101: {
+			lexer.NextToken();
+
+#line  941 &quot;cs.ATG&quot; 
+			name = &quot;sbyte&quot;; 
+			break;
+		}
+		case 53: {
+			lexer.NextToken();
+
+#line  942 &quot;cs.ATG&quot; 
+			name = &quot;byte&quot;; 
+			break;
+		}
+		case 103: {
+			lexer.NextToken();
+
+#line  943 &quot;cs.ATG&quot; 
+			name = &quot;short&quot;; 
+			break;
+		}
+		case 119: {
+			lexer.NextToken();
+
+#line  944 &quot;cs.ATG&quot; 
+			name = &quot;ushort&quot;; 
+			break;
+		}
+		case 81: {
+			lexer.NextToken();
+
+#line  945 &quot;cs.ATG&quot; 
+			name = &quot;int&quot;; 
+			break;
+		}
+		case 115: {
+			lexer.NextToken();
+
+#line  946 &quot;cs.ATG&quot; 
+			name = &quot;uint&quot;; 
+			break;
+		}
+		case 86: {
+			lexer.NextToken();
+
+#line  947 &quot;cs.ATG&quot; 
+			name = &quot;long&quot;; 
+			break;
+		}
+		case 116: {
+			lexer.NextToken();
+
+#line  948 &quot;cs.ATG&quot; 
+			name = &quot;ulong&quot;; 
+			break;
+		}
+		case 56: {
+			lexer.NextToken();
+
+#line  949 &quot;cs.ATG&quot; 
+			name = &quot;char&quot;; 
+			break;
+		}
+		default: SynErr(132); break;
+		}
+	}
+
+	void EnumBody() {
+
+#line  819 &quot;cs.ATG&quot; 
+		FieldDeclaration f; 
+		Expect(14);
+		if (la.kind == 1 || la.kind == 16) {
+			EnumMemberDecl(
+#line  821 &quot;cs.ATG&quot; 
+out f);
+
+#line  821 &quot;cs.ATG&quot; 
+			compilationUnit.AddChild(f); 
+			while (
+#line  822 &quot;cs.ATG&quot; 
+NotFinalComma()) {
+				Expect(12);
+				EnumMemberDecl(
+#line  822 &quot;cs.ATG&quot; 
+out f);
+
+#line  822 &quot;cs.ATG&quot; 
+				compilationUnit.AddChild(f); 
+			}
+			if (la.kind == 12) {
+				lexer.NextToken();
+			}
+		}
+		Expect(15);
+	}
+
+	void Type(
+#line  827 &quot;cs.ATG&quot; 
+out TypeReference type) {
+
+#line  829 &quot;cs.ATG&quot; 
+		string name = &quot;&quot;;
+		int pointer = 0;
+		
+		if (la.kind == 1 || la.kind == 90 || la.kind == 107) {
+			ClassType(
+#line  833 &quot;cs.ATG&quot; 
+out name);
+		} else if (StartOf(14)) {
+			SimpleType(
+#line  834 &quot;cs.ATG&quot; 
+out name);
+		} else if (la.kind == 122) {
+			lexer.NextToken();
+			Expect(6);
+
+#line  835 &quot;cs.ATG&quot; 
+			pointer = 1; name = &quot;void&quot;; 
+		} else SynErr(133);
+
+#line  836 &quot;cs.ATG&quot; 
+		ArrayList r = new ArrayList(); 
+		while (
+#line  837 &quot;cs.ATG&quot; 
+IsPointerOrDims()) {
+
+#line  837 &quot;cs.ATG&quot; 
+			int i = 1; 
+			if (la.kind == 6) {
+				lexer.NextToken();
+
+#line  838 &quot;cs.ATG&quot; 
+				++pointer; 
+			} else if (la.kind == 16) {
+				lexer.NextToken();
+				while (la.kind == 12) {
+					lexer.NextToken();
+
+#line  839 &quot;cs.ATG&quot; 
+					++i; 
+				}
+				Expect(17);
+
+#line  839 &quot;cs.ATG&quot; 
+				r.Add(i); 
+			} else SynErr(134);
+		}
+
+#line  841 &quot;cs.ATG&quot; 
+		int[] rank = new int[r.Count]; r.CopyTo(rank); 
+		type = new TypeReference(name, pointer, rank);
+		
+	}
+
+	void FormalParameterList(
+#line  875 &quot;cs.ATG&quot; 
+out ArrayList parameter) {
+
+#line  877 &quot;cs.ATG&quot; 
+		parameter = new ArrayList();
+		ParameterDeclarationExpression p;
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		
+		while (la.kind == 16) {
+			AttributeSection(
+#line  883 &quot;cs.ATG&quot; 
+out section);
+
+#line  883 &quot;cs.ATG&quot; 
+			attributes.Add(section); 
+		}
+		if (StartOf(15)) {
+			FixedParameter(
+#line  885 &quot;cs.ATG&quot; 
+out p);
+
+#line  885 &quot;cs.ATG&quot; 
+			bool paramsFound = false;
+			p.Attributes = attributes;
+			parameter.Add(p);
+			
+			while (la.kind == 12) {
+				lexer.NextToken();
+
+#line  890 &quot;cs.ATG&quot; 
+				attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); 
+				while (la.kind == 16) {
+					AttributeSection(
+#line  891 &quot;cs.ATG&quot; 
+out section);
+
+#line  891 &quot;cs.ATG&quot; 
+					attributes.Add(section); 
+				}
+				if (StartOf(15)) {
+					FixedParameter(
+#line  893 &quot;cs.ATG&quot; 
+out p);
+
+#line  893 &quot;cs.ATG&quot; 
+					p.Attributes = attributes; parameter.Add(p); 
+				} else if (la.kind == 94) {
+					ParameterArray(
+#line  894 &quot;cs.ATG&quot; 
+out p);
+
+#line  894 &quot;cs.ATG&quot; 
+					paramsFound = true; p.Attributes = attributes; parameter.Add(p); 
+				} else SynErr(135);
+			}
+		} else if (la.kind == 94) {
+			ParameterArray(
+#line  897 &quot;cs.ATG&quot; 
+out p);
+
+#line  897 &quot;cs.ATG&quot; 
+			p.Attributes = attributes; parameter.Add(p); 
+		} else SynErr(136);
+	}
+
+	void ClassType(
+#line  932 &quot;cs.ATG&quot; 
+out string name) {
+
+#line  932 &quot;cs.ATG&quot; 
+		string qualident; name = &quot;&quot;;
+		if (la.kind == 1) {
+			Qualident(
+#line  934 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  934 &quot;cs.ATG&quot; 
+			name = qualident; 
+		} else if (la.kind == 90) {
+			lexer.NextToken();
+
+#line  935 &quot;cs.ATG&quot; 
+			name = &quot;object&quot;; 
+		} else if (la.kind == 107) {
+			lexer.NextToken();
+
+#line  936 &quot;cs.ATG&quot; 
+			name = &quot;string&quot;; 
+		} else SynErr(137);
+	}
+
+	void MemberModifier(
+#line  952 &quot;cs.ATG&quot; 
+Modifiers m) {
+		switch (la.kind) {
+		case 48: {
+			lexer.NextToken();
+
+#line  954 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Abstract); 
+			break;
+		}
+		case 70: {
+			lexer.NextToken();
+
+#line  955 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Extern); 
+			break;
+		}
+		case 83: {
+			lexer.NextToken();
+
+#line  956 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Internal); 
+			break;
+		}
+		case 88: {
+			lexer.NextToken();
+
+#line  957 &quot;cs.ATG&quot; 
+			m.Add(Modifier.New); 
+			break;
+		}
+		case 93: {
+			lexer.NextToken();
+
+#line  958 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Override); 
+			break;
+		}
+		case 95: {
+			lexer.NextToken();
+
+#line  959 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Private); 
+			break;
+		}
+		case 96: {
+			lexer.NextToken();
+
+#line  960 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Protected); 
+			break;
+		}
+		case 97: {
+			lexer.NextToken();
+
+#line  961 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Public); 
+			break;
+		}
+		case 98: {
+			lexer.NextToken();
+
+#line  962 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Readonly); 
+			break;
+		}
+		case 102: {
+			lexer.NextToken();
+
+#line  963 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Sealed); 
+			break;
+		}
+		case 106: {
+			lexer.NextToken();
+
+#line  964 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Static); 
+			break;
+		}
+		case 118: {
+			lexer.NextToken();
+
+#line  965 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Unsafe); 
+			break;
+		}
+		case 121: {
+			lexer.NextToken();
+
+#line  966 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Virtual); 
+			break;
+		}
+		case 123: {
+			lexer.NextToken();
+
+#line  967 &quot;cs.ATG&quot; 
+			m.Add(Modifier.Volatile); 
+			break;
+		}
+		default: SynErr(138); break;
+		}
+	}
+
+	void ClassMemberDecl(
+#line  1178 &quot;cs.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+
+#line  1179 &quot;cs.ATG&quot; 
+		Statement stmt = null; 
+		if (StartOf(16)) {
+			StructMemberDecl(
+#line  1181 &quot;cs.ATG&quot; 
+m, attributes);
+		} else if (la.kind == 25) {
+
+#line  1182 &quot;cs.ATG&quot; 
+			m.Check(Modifier.Destructors); Point startPos = t.Location; 
+			lexer.NextToken();
+			Expect(1);
+
+#line  1183 &quot;cs.ATG&quot; 
+			DestructorDeclaration d = new DestructorDeclaration(t.val, attributes); 
+			d.Modifier = m.Modifier;
+			d.StartLocation = startPos;
+			
+			Expect(18);
+			Expect(19);
+			if (la.kind == 14) {
+				Block(
+#line  1187 &quot;cs.ATG&quot; 
+out stmt);
+			} else if (la.kind == 10) {
+				lexer.NextToken();
+			} else SynErr(139);
+
+#line  1187 &quot;cs.ATG&quot; 
+			d.EndLocation = t.EndLocation; 
+			d.Body = (BlockStatement)stmt;
+			compilationUnit.AddChild(d);
+			
+		} else SynErr(140);
+	}
+
+	void StructMemberDecl(
+#line  970 &quot;cs.ATG&quot; 
+Modifiers m, ArrayList attributes) {
+
+#line  972 &quot;cs.ATG&quot; 
+		string qualident = null;
+		TypeReference type;
+		Expression expr;
+		ArrayList p = new ArrayList();
+		Statement stmt = null;
+		ArrayList variableDeclarators = new ArrayList();
+		
+		if (la.kind == 59) {
+
+#line  980 &quot;cs.ATG&quot; 
+			m.Check(Modifier.Constants); 
+			lexer.NextToken();
+
+#line  981 &quot;cs.ATG&quot; 
+			Point startPos = t.Location; 
+			Type(
+#line  982 &quot;cs.ATG&quot; 
+out type);
+			Expect(1);
+
+#line  982 &quot;cs.ATG&quot; 
+			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier | Modifier.Const);
+			VariableDeclaration f = new VariableDeclaration(t.val);
+			fd.Fields.Add(f);
+			
+			Expect(3);
+			Expr(
+#line  986 &quot;cs.ATG&quot; 
+out expr);
+
+#line  986 &quot;cs.ATG&quot; 
+			f.Initializer = expr; 
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Expect(1);
+
+#line  987 &quot;cs.ATG&quot; 
+				f = new VariableDeclaration(t.val);
+				fd.Fields.Add(f);
+				
+				Expect(3);
+				Expr(
+#line  990 &quot;cs.ATG&quot; 
+out expr);
+
+#line  990 &quot;cs.ATG&quot; 
+				f.Initializer = expr; 
+			}
+			Expect(10);
+
+#line  991 &quot;cs.ATG&quot; 
+			fd.EndLocation = t.EndLocation; compilationUnit.AddChild(fd); 
+		} else if (
+#line  994 &quot;cs.ATG&quot; 
+NotVoidPointer()) {
+
+#line  994 &quot;cs.ATG&quot; 
+			m.Check(Modifier.PropertysEventsMethods); 
+			Expect(122);
+
+#line  995 &quot;cs.ATG&quot; 
+			Point startPos = t.Location; 
+			Qualident(
+#line  996 &quot;cs.ATG&quot; 
+out qualident);
+			Expect(18);
+			if (StartOf(9)) {
+				FormalParameterList(
+#line  997 &quot;cs.ATG&quot; 
+out p);
+			}
+			Expect(19);
+
+#line  997 &quot;cs.ATG&quot; 
+			MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
+			                                                           m.Modifier, 
+			                                                           new TypeReference(&quot;void&quot;), 
+			                                                           p, 
+			                                                           attributes);
+			methodDeclaration.StartLocation = startPos;
+			methodDeclaration.EndLocation   = t.EndLocation;
+			compilationUnit.AddChild(methodDeclaration);
+			compilationUnit.BlockStart(methodDeclaration);
+			
+			if (la.kind == 14) {
+				Block(
+#line  1007 &quot;cs.ATG&quot; 
+out stmt);
+			} else if (la.kind == 10) {
+				lexer.NextToken();
+			} else SynErr(141);
+
+#line  1007 &quot;cs.ATG&quot; 
+			compilationUnit.BlockEnd();
+			methodDeclaration.Body  = (BlockStatement)stmt;
+			
+		} else if (la.kind == 68) {
+
+#line  1011 &quot;cs.ATG&quot; 
+			m.Check(Modifier.PropertysEventsMethods); 
+			lexer.NextToken();
+
+#line  1012 &quot;cs.ATG&quot; 
+			EventDeclaration eventDecl = new EventDeclaration(m.Modifier, attributes);
+			eventDecl.StartLocation = t.Location;
+			compilationUnit.AddChild(eventDecl);
+			compilationUnit.BlockStart(eventDecl);
+			EventAddRegion addBlock = null;
+			EventRemoveRegion removeBlock = null;
+			
+			Type(
+#line  1019 &quot;cs.ATG&quot; 
+out type);
+
+#line  1019 &quot;cs.ATG&quot; 
+			eventDecl.TypeReference = type; 
+			if (
+#line  1021 &quot;cs.ATG&quot; 
+IsVarDecl()) {
+				VariableDeclarator(
+#line  1021 &quot;cs.ATG&quot; 
+variableDeclarators);
+				while (la.kind == 12) {
+					lexer.NextToken();
+					VariableDeclarator(
+#line  1022 &quot;cs.ATG&quot; 
+variableDeclarators);
+				}
+				Expect(10);
+
+#line  1022 &quot;cs.ATG&quot; 
+				eventDecl.VariableDeclarators = variableDeclarators; eventDecl.EndLocation = t.EndLocation;  
+			} else if (la.kind == 1) {
+				Qualident(
+#line  1023 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  1023 &quot;cs.ATG&quot; 
+				eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation;  
+				Expect(14);
+
+#line  1024 &quot;cs.ATG&quot; 
+				eventDecl.BodyStart = t.Location; 
+				EventAccessorDecls(
+#line  1025 &quot;cs.ATG&quot; 
+out addBlock, out removeBlock);
+				Expect(15);
+
+#line  1026 &quot;cs.ATG&quot; 
+				eventDecl.BodyEnd   = t.EndLocation; 
+			} else SynErr(142);
+
+#line  1027 &quot;cs.ATG&quot; 
+			compilationUnit.BlockEnd();
+			
+			eventDecl.AddRegion = addBlock;
+			eventDecl.RemoveRegion = removeBlock;
+			
+		} else if (
+#line  1034 &quot;cs.ATG&quot; 
+IdentAndLPar()) {
+
+#line  1034 &quot;cs.ATG&quot; 
+			m.Check(Modifier.Constructors | Modifier.StaticConstructors); 
+			Expect(1);
+
+#line  1035 &quot;cs.ATG&quot; 
+			string name = t.val; Point startPos = t.Location; 
+			Expect(18);
+			if (StartOf(9)) {
+
+#line  1035 &quot;cs.ATG&quot; 
+				m.Check(Modifier.Constructors); 
+				FormalParameterList(
+#line  1036 &quot;cs.ATG&quot; 
+out p);
+			}
+			Expect(19);
+
+#line  1038 &quot;cs.ATG&quot; 
+			ConstructorInitializer init = null;  
+			if (la.kind == 9) {
+
+#line  1039 &quot;cs.ATG&quot; 
+				m.Check(Modifier.Constructors); 
+				ConstructorInitializer(
+#line  1040 &quot;cs.ATG&quot; 
+out init);
+			}
+
+#line  1042 &quot;cs.ATG&quot; 
+			ConstructorDeclaration cd = new ConstructorDeclaration(name, m.Modifier, p, init, attributes); 
+			cd.StartLocation = startPos;
+			cd.EndLocation   = t.EndLocation;
+			
+			if (la.kind == 14) {
+				Block(
+#line  1047 &quot;cs.ATG&quot; 
+out stmt);
+			} else if (la.kind == 10) {
+				lexer.NextToken();
+			} else SynErr(143);
+
+#line  1047 &quot;cs.ATG&quot; 
+			cd.Body = (BlockStatement)stmt; compilationUnit.AddChild(cd); 
+		} else if (la.kind == 69 || la.kind == 79) {
+
+#line  1050 &quot;cs.ATG&quot; 
+			m.Check(Modifier.Operators);
+			if (m.isNone) Error(&quot;at least one modifier must be set&quot;); 
+			bool isImplicit = true;
+			
+			if (la.kind == 79) {
+				lexer.NextToken();
+			} else {
+				lexer.NextToken();
+
+#line  1054 &quot;cs.ATG&quot; 
+				isImplicit = false; 
+			}
+			Expect(91);
+			Type(
+#line  1055 &quot;cs.ATG&quot; 
+out type);
+
+#line  1055 &quot;cs.ATG&quot; 
+			TypeReference operatorType = type; 
+			Expect(18);
+			Type(
+#line  1056 &quot;cs.ATG&quot; 
+out type);
+			Expect(1);
+
+#line  1056 &quot;cs.ATG&quot; 
+			string varName = t.val; 
+			Expect(19);
+			if (la.kind == 14) {
+				Block(
+#line  1056 &quot;cs.ATG&quot; 
+out stmt);
+			} else if (la.kind == 10) {
+				lexer.NextToken();
+
+#line  1056 &quot;cs.ATG&quot; 
+				stmt = null; 
+			} else SynErr(144);
+
+#line  1059 &quot;cs.ATG&quot; 
+			OperatorDeclarator operatorDeclarator = new OperatorDeclarator(isImplicit ? OperatorType.Implicit : OperatorType.Explicit,
+			                                                              operatorType,
+			                                                              type,
+			                                                              varName);
+			OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+			operatorDeclaration.Body = stmt;
+			compilationUnit.AddChild(operatorDeclaration);
+			
+		} else if (StartOf(17)) {
+			TypeDecl(
+#line  1069 &quot;cs.ATG&quot; 
+m, attributes);
+		} else if (StartOf(8)) {
+			Type(
+#line  1070 &quot;cs.ATG&quot; 
+out type);
+
+#line  1070 &quot;cs.ATG&quot; 
+			Point startPos = t.Location; 
+			if (la.kind == 91) {
+
+#line  1072 &quot;cs.ATG&quot; 
+				Token op;
+				m.Check(Modifier.Operators);
+				if (m.isNone) Error(&quot;at least one modifier must be set&quot;);
+				
+				lexer.NextToken();
+				OverloadableOperator(
+#line  1076 &quot;cs.ATG&quot; 
+out op);
+
+#line  1076 &quot;cs.ATG&quot; 
+				TypeReference firstType, secondType = null; string secondName = null; 
+				Expect(18);
+				Type(
+#line  1077 &quot;cs.ATG&quot; 
+out firstType);
+				Expect(1);
+
+#line  1077 &quot;cs.ATG&quot; 
+				string firstName = t.val; 
+				if (la.kind == 12) {
+					lexer.NextToken();
+					Type(
+#line  1078 &quot;cs.ATG&quot; 
+out secondType);
+					Expect(1);
+
+#line  1078 &quot;cs.ATG&quot; 
+					secondName = t.val; 
+
+#line  1078 &quot;cs.ATG&quot; 
+					if (ParserUtil.IsUnaryOperator(op) &amp;&amp; !ParserUtil.IsBinaryOperator(op))
+					Error(&quot;too many operands for unary operator&quot;); 
+					
+				} else if (la.kind == 19) {
+
+#line  1081 &quot;cs.ATG&quot; 
+					if (ParserUtil.IsBinaryOperator(op))
+					Error(&quot;too few operands for binary operator&quot;);
+					
+				} else SynErr(145);
+				Expect(19);
+				if (la.kind == 14) {
+					Block(
+#line  1085 &quot;cs.ATG&quot; 
+out stmt);
+				} else if (la.kind == 10) {
+					lexer.NextToken();
+				} else SynErr(146);
+
+#line  1087 &quot;cs.ATG&quot; 
+				OperatorDeclarator operatorDeclarator = new OperatorDeclarator(secondType != null ? OperatorType.Binary : OperatorType.Unary, 
+				                                                              type,
+				                                                              op.kind,
+				                                                              firstType,
+				                                                              firstName,
+				                                                              secondType,
+				                                                              secondName);
+				OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+				operatorDeclaration.Body = stmt;
+				compilationUnit.AddChild(operatorDeclaration);
+				
+			} else if (
+#line  1100 &quot;cs.ATG&quot; 
+IsVarDecl()) {
+
+#line  1100 &quot;cs.ATG&quot; 
+				m.Check(Modifier.Fields); 
+				FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+				fd.StartLocation = startPos; 
+				
+				VariableDeclarator(
+#line  1104 &quot;cs.ATG&quot; 
+variableDeclarators);
+				while (la.kind == 12) {
+					lexer.NextToken();
+					VariableDeclarator(
+#line  1105 &quot;cs.ATG&quot; 
+variableDeclarators);
+				}
+				Expect(10);
+
+#line  1106 &quot;cs.ATG&quot; 
+				fd.EndLocation = t.EndLocation; fd.Fields = variableDeclarators; compilationUnit.AddChild(fd); 
+			} else if (la.kind == 110) {
+
+#line  1109 &quot;cs.ATG&quot; 
+				m.Check(Modifier.Indexers); 
+				lexer.NextToken();
+				Expect(16);
+				FormalParameterList(
+#line  1110 &quot;cs.ATG&quot; 
+out p);
+				Expect(17);
+
+#line  1110 &quot;cs.ATG&quot; 
+				Point endLocation = t.EndLocation; 
+				Expect(14);
+
+#line  1111 &quot;cs.ATG&quot; 
+				IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
+				indexer.StartLocation = startPos;
+				indexer.EndLocation   = endLocation;
+				indexer.BodyStart     = t.Location;
+				PropertyGetRegion getRegion;
+				PropertySetRegion setRegion;
+				
+				AccessorDecls(
+#line  1118 &quot;cs.ATG&quot; 
+out getRegion, out setRegion);
+				Expect(15);
+
+#line  1119 &quot;cs.ATG&quot; 
+				indexer.BodyEnd    = t.EndLocation;
+				indexer.GetRegion = getRegion;
+				indexer.SetRegion = setRegion;
+				compilationUnit.AddChild(indexer);
+				
+			} else if (la.kind == 1) {
+				Qualident(
+#line  1124 &quot;cs.ATG&quot; 
+out qualident);
+
+#line  1124 &quot;cs.ATG&quot; 
+				Point qualIdentEndLocation = t.EndLocation; 
+				if (la.kind == 14 || la.kind == 18) {
+					if (la.kind == 18) {
+
+#line  1127 &quot;cs.ATG&quot; 
+						m.Check(Modifier.PropertysEventsMethods); 
+						lexer.NextToken();
+						if (StartOf(9)) {
+							FormalParameterList(
+#line  1128 &quot;cs.ATG&quot; 
+out p);
+						}
+						Expect(19);
+
+#line  1128 &quot;cs.ATG&quot; 
+						MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
+						                                                     m.Modifier, 
+						                                                     type, 
+						                                                     p, 
+						                                                     attributes);
+						     methodDeclaration.StartLocation = startPos;
+						     methodDeclaration.EndLocation   = t.EndLocation;
+						     compilationUnit.AddChild(methodDeclaration);
+						  
+						if (la.kind == 14) {
+							Block(
+#line  1137 &quot;cs.ATG&quot; 
+out stmt);
+						} else if (la.kind == 10) {
+							lexer.NextToken();
+						} else SynErr(147);
+
+#line  1137 &quot;cs.ATG&quot; 
+						methodDeclaration.Body  = (BlockStatement)stmt; 
+					} else {
+						lexer.NextToken();
+
+#line  1140 &quot;cs.ATG&quot; 
+						PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
+						pDecl.StartLocation = startPos;
+						pDecl.EndLocation   = qualIdentEndLocation;
+						pDecl.BodyStart   = t.Location;
+						PropertyGetRegion getRegion;
+						PropertySetRegion setRegion;
+						
+						AccessorDecls(
+#line  1147 &quot;cs.ATG&quot; 
+out getRegion, out setRegion);
+						Expect(15);
+
+#line  1149 &quot;cs.ATG&quot; 
+						pDecl.GetRegion = getRegion;
+						pDecl.SetRegion = setRegion;
+						pDecl.BodyEnd = t.EndLocation;
+						compilationUnit.AddChild(pDecl);
+						
+					}
+				} else if (la.kind == 13) {
+
+#line  1157 &quot;cs.ATG&quot; 
+					m.Check(Modifier.Indexers); 
+					lexer.NextToken();
+					Expect(110);
+					Expect(16);
+					FormalParameterList(
+#line  1158 &quot;cs.ATG&quot; 
+out p);
+					Expect(17);
+
+#line  1159 &quot;cs.ATG&quot; 
+					IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
+					indexer.StartLocation = startPos;
+					indexer.EndLocation   = t.EndLocation;
+					indexer.NamespaceName = qualident;
+					PropertyGetRegion getRegion;
+					PropertySetRegion setRegion;
+					
+					Expect(14);
+
+#line  1166 &quot;cs.ATG&quot; 
+					Point bodyStart = t.Location; 
+					AccessorDecls(
+#line  1167 &quot;cs.ATG&quot; 
+out getRegion, out setRegion);
+					Expect(15);
+
+#line  1168 &quot;cs.ATG&quot; 
+					indexer.BodyStart = bodyStart;
+					indexer.BodyEnd   = t.EndLocation;
+					indexer.GetRegion = getRegion;
+					indexer.SetRegion = setRegion;
+					compilationUnit.AddChild(indexer);
+					
+				} else SynErr(148);
+			} else SynErr(149);
+		} else SynErr(150);
+	}
+
+	void InterfaceMemberDecl() {
+
+#line  1195 &quot;cs.ATG&quot; 
+		TypeReference type;
+		ArrayList p;
+		AttributeSection section;
+		Modifier mod = Modifier.None;
+		ArrayList attributes = new ArrayList();
+		ArrayList parameters = new ArrayList();
+		string name;
+		PropertyGetRegion getBlock;
+		PropertySetRegion setBlock;
+		Point startLocation = new Point(-1, -1);
+		
+		while (la.kind == 16) {
+			AttributeSection(
+#line  1207 &quot;cs.ATG&quot; 
+out section);
+
+#line  1207 &quot;cs.ATG&quot; 
+			attributes.Add(section); 
+		}
+		if (la.kind == 88) {
+			lexer.NextToken();
+
+#line  1208 &quot;cs.ATG&quot; 
+			mod = Modifier.New; startLocation = t.Location; 
+		}
+		if (
+#line  1211 &quot;cs.ATG&quot; 
+NotVoidPointer()) {
+			Expect(122);
+
+#line  1211 &quot;cs.ATG&quot; 
+			if (startLocation.X == -1) startLocation = t.Location; 
+			Expect(1);
+
+#line  1211 &quot;cs.ATG&quot; 
+			name = t.val; 
+			Expect(18);
+			if (StartOf(9)) {
+				FormalParameterList(
+#line  1212 &quot;cs.ATG&quot; 
+out parameters);
+			}
+			Expect(19);
+			Expect(10);
+
+#line  1212 &quot;cs.ATG&quot; 
+			MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference(&quot;void&quot;), parameters, attributes);
+			md.StartLocation = startLocation;
+			md.EndLocation = t.EndLocation;
+			compilationUnit.AddChild(md);
+			
+		} else if (StartOf(18)) {
+			if (StartOf(8)) {
+				Type(
+#line  1218 &quot;cs.ATG&quot; 
+out type);
+
+#line  1218 &quot;cs.ATG&quot; 
+				if (startLocation.X == -1) startLocation = t.Location; 
+				if (la.kind == 1) {
+					lexer.NextToken();
+
+#line  1220 &quot;cs.ATG&quot; 
+					name = t.val; Point qualIdentEndLocation = t.EndLocation; 
+					if (la.kind == 18) {
+						lexer.NextToken();
+						if (StartOf(9)) {
+							FormalParameterList(
+#line  1223 &quot;cs.ATG&quot; 
+out parameters);
+						}
+						Expect(19);
+						Expect(10);
+
+#line  1223 &quot;cs.ATG&quot; 
+						MethodDeclaration md = new MethodDeclaration(name, mod, type, parameters, attributes);
+						md.StartLocation = startLocation;
+						md.EndLocation = t.EndLocation;
+						compilationUnit.AddChild(md);
+						
+					} else if (la.kind == 14) {
+
+#line  1229 &quot;cs.ATG&quot; 
+						PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); 
+						lexer.NextToken();
+
+#line  1230 &quot;cs.ATG&quot; 
+						Point bodyStart = t.Location;
+						InterfaceAccessors(
+#line  1230 &quot;cs.ATG&quot; 
+out getBlock, out setBlock);
+						Expect(15);
+
+#line  1230 &quot;cs.ATG&quot; 
+						pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; 
+					} else SynErr(151);
+				} else if (la.kind == 110) {
+					lexer.NextToken();
+					Expect(16);
+					FormalParameterList(
+#line  1233 &quot;cs.ATG&quot; 
+out p);
+					Expect(17);
+
+#line  1233 &quot;cs.ATG&quot; 
+					Point bracketEndLocation = t.EndLocation; 
+
+#line  1233 &quot;cs.ATG&quot; 
+					IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); 
+					Expect(14);
+
+#line  1234 &quot;cs.ATG&quot; 
+					Point bodyStart = t.Location;
+					InterfaceAccessors(
+#line  1234 &quot;cs.ATG&quot; 
+out getBlock, out setBlock);
+					Expect(15);
+
+#line  1234 &quot;cs.ATG&quot; 
+					id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;
+				} else SynErr(152);
+			} else {
+				lexer.NextToken();
+
+#line  1237 &quot;cs.ATG&quot; 
+				if (startLocation.X == -1) startLocation = t.Location; 
+				Type(
+#line  1237 &quot;cs.ATG&quot; 
+out type);
+				Expect(1);
+
+#line  1237 &quot;cs.ATG&quot; 
+				EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
+				compilationUnit.AddChild(ed);
+				
+				Expect(10);
+
+#line  1240 &quot;cs.ATG&quot; 
+				ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; 
+			}
+		} else SynErr(153);
+	}
+
+	void EnumMemberDecl(
+#line  1245 &quot;cs.ATG&quot; 
+out FieldDeclaration f) {
+
+#line  1247 &quot;cs.ATG&quot; 
+		Expression expr = null;
+		ArrayList attributes = new ArrayList();
+		AttributeSection section = null;
+		VariableDeclaration varDecl = null;
+		
+		while (la.kind == 16) {
+			AttributeSection(
+#line  1253 &quot;cs.ATG&quot; 
+out section);
+
+#line  1253 &quot;cs.ATG&quot; 
+			attributes.Add(section); 
+		}
+		Expect(1);
+
+#line  1254 &quot;cs.ATG&quot; 
+		f = new FieldDeclaration(attributes);
+		varDecl         = new VariableDeclaration(t.val);
+		f.Fields.Add(varDecl);
+		f.StartLocation = t.Location;
+		
+		if (la.kind == 3) {
+			lexer.NextToken();
+			Expr(
+#line  1259 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1259 &quot;cs.ATG&quot; 
+			varDecl.Initializer = expr; 
+		}
+	}
+
+	void SimpleType(
+#line  864 &quot;cs.ATG&quot; 
+out string name) {
+
+#line  865 &quot;cs.ATG&quot; 
+		name = String.Empty; 
+		if (StartOf(19)) {
+			IntegralType(
+#line  867 &quot;cs.ATG&quot; 
+out name);
+		} else if (la.kind == 74) {
+			lexer.NextToken();
+
+#line  868 &quot;cs.ATG&quot; 
+			name = t.val; 
+		} else if (la.kind == 65) {
+			lexer.NextToken();
+
+#line  869 &quot;cs.ATG&quot; 
+			name = t.val; 
+		} else if (la.kind == 61) {
+			lexer.NextToken();
+
+#line  870 &quot;cs.ATG&quot; 
+			name = t.val; 
+		} else if (la.kind == 51) {
+			lexer.NextToken();
+
+#line  871 &quot;cs.ATG&quot; 
+			name = t.val; 
+		} else SynErr(154);
+	}
+
+	void NonArrayType(
+#line  846 &quot;cs.ATG&quot; 
+out TypeReference type) {
+
+#line  848 &quot;cs.ATG&quot; 
+		string name = &quot;&quot;;
+		int pointer = 0;
+		
+		if (la.kind == 1 || la.kind == 90 || la.kind == 107) {
+			ClassType(
+#line  852 &quot;cs.ATG&quot; 
+out name);
+		} else if (StartOf(14)) {
+			SimpleType(
+#line  853 &quot;cs.ATG&quot; 
+out name);
+		} else if (la.kind == 122) {
+			lexer.NextToken();
+			Expect(6);
+
+#line  854 &quot;cs.ATG&quot; 
+			pointer = 1; name = &quot;void&quot;; 
+		} else SynErr(155);
+		while (
+#line  856 &quot;cs.ATG&quot; 
+IsPointer()) {
+			Expect(6);
+
+#line  857 &quot;cs.ATG&quot; 
+			++pointer; 
+		}
+
+#line  860 &quot;cs.ATG&quot; 
+		type = new TypeReference(name, pointer, null);
+		
+	}
+
+	void FixedParameter(
+#line  901 &quot;cs.ATG&quot; 
+out ParameterDeclarationExpression p) {
+
+#line  903 &quot;cs.ATG&quot; 
+		TypeReference type;
+		ParamModifiers mod = ParamModifiers.In;
+		
+		if (la.kind == 92 || la.kind == 99) {
+			if (la.kind == 99) {
+				lexer.NextToken();
+
+#line  908 &quot;cs.ATG&quot; 
+				mod = ParamModifiers.Ref; 
+			} else {
+				lexer.NextToken();
+
+#line  909 &quot;cs.ATG&quot; 
+				mod = ParamModifiers.Out; 
+			}
+		}
+		Type(
+#line  911 &quot;cs.ATG&quot; 
+out type);
+		Expect(1);
+
+#line  911 &quot;cs.ATG&quot; 
+		p = new ParameterDeclarationExpression(type, t.val, mod); 
+	}
+
+	void ParameterArray(
+#line  914 &quot;cs.ATG&quot; 
+out ParameterDeclarationExpression p) {
+
+#line  915 &quot;cs.ATG&quot; 
+		TypeReference type; 
+		Expect(94);
+		Type(
+#line  917 &quot;cs.ATG&quot; 
+out type);
+		Expect(1);
+
+#line  917 &quot;cs.ATG&quot; 
+		p = new ParameterDeclarationExpression(type, t.val, ParamModifiers.Params); 
+	}
+
+	void Block(
+#line  1363 &quot;cs.ATG&quot; 
+out Statement stmt) {
+		Expect(14);
+
+#line  1365 &quot;cs.ATG&quot; 
+		BlockStatement blockStmt = new BlockStatement();
+		blockStmt.StartLocation = t.Location;
+		compilationUnit.BlockStart(blockStmt);
+		
+		while (StartOf(20)) {
+			Statement();
+		}
+		Expect(15);
+
+#line  1370 &quot;cs.ATG&quot; 
+		stmt = blockStmt;
+		blockStmt.EndLocation = t.EndLocation;
+		compilationUnit.BlockEnd();
+		
+	}
+
+	void VariableDeclarator(
+#line  1356 &quot;cs.ATG&quot; 
+ArrayList fieldDeclaration) {
+
+#line  1357 &quot;cs.ATG&quot; 
+		Expression expr = null; 
+		Expect(1);
+
+#line  1359 &quot;cs.ATG&quot; 
+		VariableDeclaration f = new VariableDeclaration(t.val); 
+		if (la.kind == 3) {
+			lexer.NextToken();
+			VariableInitializer(
+#line  1360 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1360 &quot;cs.ATG&quot; 
+			f.Initializer = expr; 
+		}
+
+#line  1360 &quot;cs.ATG&quot; 
+		fieldDeclaration.Add(f); 
+	}
+
+	void EventAccessorDecls(
+#line  1305 &quot;cs.ATG&quot; 
+out EventAddRegion addBlock, out EventRemoveRegion removeBlock) {
+
+#line  1306 &quot;cs.ATG&quot; 
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		Statement stmt;
+		addBlock = null;
+		removeBlock = null;
+		
+		while (la.kind == 16) {
+			AttributeSection(
+#line  1313 &quot;cs.ATG&quot; 
+out section);
+
+#line  1313 &quot;cs.ATG&quot; 
+			attributes.Add(section); 
+		}
+		if (
+#line  1315 &quot;cs.ATG&quot; 
+IdentIsAdd()) {
+
+#line  1315 &quot;cs.ATG&quot; 
+			addBlock = new EventAddRegion(attributes); 
+			AddAccessorDecl(
+#line  1316 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1316 &quot;cs.ATG&quot; 
+			attributes = new ArrayList(); addBlock.Block = (BlockStatement)stmt; 
+			while (la.kind == 16) {
+				AttributeSection(
+#line  1317 &quot;cs.ATG&quot; 
+out section);
+
+#line  1317 &quot;cs.ATG&quot; 
+				attributes.Add(section); 
+			}
+			RemoveAccessorDecl(
+#line  1318 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1318 &quot;cs.ATG&quot; 
+			removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; 
+		} else if (
+#line  1319 &quot;cs.ATG&quot; 
+IdentIsRemove()) {
+			RemoveAccessorDecl(
+#line  1320 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1320 &quot;cs.ATG&quot; 
+			removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new ArrayList(); 
+			while (la.kind == 16) {
+				AttributeSection(
+#line  1321 &quot;cs.ATG&quot; 
+out section);
+
+#line  1321 &quot;cs.ATG&quot; 
+				attributes.Add(section); 
+			}
+			AddAccessorDecl(
+#line  1322 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1322 &quot;cs.ATG&quot; 
+			addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; 
+		} else if (la.kind == 1) {
+			lexer.NextToken();
+
+#line  1323 &quot;cs.ATG&quot; 
+			Error(&quot;add or remove accessor declaration expected&quot;); 
+		} else SynErr(156);
+	}
+
+	void ConstructorInitializer(
+#line  1392 &quot;cs.ATG&quot; 
+out ConstructorInitializer ci) {
+
+#line  1393 &quot;cs.ATG&quot; 
+		Expression expr; ci = new ConstructorInitializer(); 
+		Expect(9);
+		if (la.kind == 50) {
+			lexer.NextToken();
+
+#line  1397 &quot;cs.ATG&quot; 
+			ci.ConstructorInitializerType = ConstructorInitializerType.Base; 
+		} else if (la.kind == 110) {
+			lexer.NextToken();
+
+#line  1398 &quot;cs.ATG&quot; 
+			ci.ConstructorInitializerType = ConstructorInitializerType.This; 
+		} else SynErr(157);
+		Expect(18);
+		if (StartOf(21)) {
+			Argument(
+#line  1401 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1401 &quot;cs.ATG&quot; 
+			ci.Arguments.Add(expr); 
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Argument(
+#line  1401 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1401 &quot;cs.ATG&quot; 
+				ci.Arguments.Add(expr); 
+			}
+		}
+		Expect(19);
+	}
+
+	void OverloadableOperator(
+#line  1413 &quot;cs.ATG&quot; 
+out Token op) {
+		switch (la.kind) {
+		case 4: {
+			lexer.NextToken();
+			break;
+		}
+		case 5: {
+			lexer.NextToken();
+			break;
+		}
+		case 22: {
+			lexer.NextToken();
+			break;
+		}
+		case 25: {
+			lexer.NextToken();
+			break;
+		}
+		case 29: {
+			lexer.NextToken();
+			break;
+		}
+		case 30: {
+			lexer.NextToken();
+			break;
+		}
+		case 112: {
+			lexer.NextToken();
+			break;
+		}
+		case 71: {
+			lexer.NextToken();
+			break;
+		}
+		case 6: {
+			lexer.NextToken();
+			break;
+		}
+		case 7: {
+			lexer.NextToken();
+			break;
+		}
+		case 8: {
+			lexer.NextToken();
+			break;
+		}
+		case 26: {
+			lexer.NextToken();
+			break;
+		}
+		case 27: {
+			lexer.NextToken();
+			break;
+		}
+		case 28: {
+			lexer.NextToken();
+			break;
+		}
+		case 35: {
+			lexer.NextToken();
+			break;
+		}
+		case 36: {
+			lexer.NextToken();
+			break;
+		}
+		case 31: {
+			lexer.NextToken();
+			break;
+		}
+		case 32: {
+			lexer.NextToken();
+			break;
+		}
+		case 20: {
+			lexer.NextToken();
+			break;
+		}
+		case 21: {
+			lexer.NextToken();
+			break;
+		}
+		case 33: {
+			lexer.NextToken();
+			break;
+		}
+		case 34: {
+			lexer.NextToken();
+			break;
+		}
+		default: SynErr(158); break;
+		}
+
+#line  1422 &quot;cs.ATG&quot; 
+		op = t; 
+	}
+
+	void AccessorDecls(
+#line  1263 &quot;cs.ATG&quot; 
+out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
+
+#line  1265 &quot;cs.ATG&quot; 
+		ArrayList attributes = new ArrayList(); 
+		AttributeSection section;
+		getBlock = null;
+		setBlock = null; 
+		
+		while (la.kind == 16) {
+			AttributeSection(
+#line  1271 &quot;cs.ATG&quot; 
+out section);
+
+#line  1271 &quot;cs.ATG&quot; 
+			attributes.Add(section); 
+		}
+		if (
+#line  1273 &quot;cs.ATG&quot; 
+IdentIsGet()) {
+			GetAccessorDecl(
+#line  1274 &quot;cs.ATG&quot; 
+out getBlock, attributes);
+			if (la.kind == 1 || la.kind == 16) {
+
+#line  1275 &quot;cs.ATG&quot; 
+				attributes = new ArrayList(); 
+				while (la.kind == 16) {
+					AttributeSection(
+#line  1276 &quot;cs.ATG&quot; 
+out section);
+
+#line  1276 &quot;cs.ATG&quot; 
+					attributes.Add(section); 
+				}
+				SetAccessorDecl(
+#line  1277 &quot;cs.ATG&quot; 
+out setBlock, attributes);
+			}
+		} else if (
+#line  1279 &quot;cs.ATG&quot; 
+IdentIsSet()) {
+			SetAccessorDecl(
+#line  1280 &quot;cs.ATG&quot; 
+out setBlock, attributes);
+			if (la.kind == 1 || la.kind == 16) {
+
+#line  1281 &quot;cs.ATG&quot; 
+				attributes = new ArrayList(); 
+				while (la.kind == 16) {
+					AttributeSection(
+#line  1282 &quot;cs.ATG&quot; 
+out section);
+
+#line  1282 &quot;cs.ATG&quot; 
+					attributes.Add(section); 
+				}
+				GetAccessorDecl(
+#line  1283 &quot;cs.ATG&quot; 
+out getBlock, attributes);
+			}
+		} else if (la.kind == 1) {
+			lexer.NextToken();
+
+#line  1285 &quot;cs.ATG&quot; 
+			Error(&quot;get or set accessor declaration expected&quot;); 
+		} else SynErr(159);
+	}
+
+	void InterfaceAccessors(
+#line  1327 &quot;cs.ATG&quot; 
+out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
+
+#line  1329 &quot;cs.ATG&quot; 
+		AttributeSection section;
+		ArrayList attributes = new ArrayList();
+		getBlock = null; setBlock = null;
+		
+		while (la.kind == 16) {
+			AttributeSection(
+#line  1334 &quot;cs.ATG&quot; 
+out section);
+
+#line  1334 &quot;cs.ATG&quot; 
+			attributes.Add(section); 
+		}
+		if (
+#line  1336 &quot;cs.ATG&quot; 
+IdentIsGet()) {
+			Expect(1);
+
+#line  1336 &quot;cs.ATG&quot; 
+			getBlock = new PropertyGetRegion(null, attributes); 
+		} else if (
+#line  1337 &quot;cs.ATG&quot; 
+IdentIsSet()) {
+			Expect(1);
+
+#line  1337 &quot;cs.ATG&quot; 
+			setBlock = new PropertySetRegion(null, attributes); 
+		} else if (la.kind == 1) {
+			lexer.NextToken();
+
+#line  1338 &quot;cs.ATG&quot; 
+			Error(&quot;set or get expected&quot;); 
+		} else SynErr(160);
+		Expect(10);
+
+#line  1340 &quot;cs.ATG&quot; 
+		attributes = new ArrayList(); 
+		if (la.kind == 1 || la.kind == 16) {
+			while (la.kind == 16) {
+				AttributeSection(
+#line  1342 &quot;cs.ATG&quot; 
+out section);
+
+#line  1342 &quot;cs.ATG&quot; 
+				attributes.Add(section); 
+			}
+			if (
+#line  1344 &quot;cs.ATG&quot; 
+IdentIsGet()) {
+				Expect(1);
+
+#line  1344 &quot;cs.ATG&quot; 
+				if (getBlock != null) Error(&quot;get already declared&quot;);
+				else getBlock = new PropertyGetRegion(null, attributes);
+				
+			} else if (
+#line  1347 &quot;cs.ATG&quot; 
+IdentIsSet()) {
+				Expect(1);
+
+#line  1347 &quot;cs.ATG&quot; 
+				if (setBlock != null) Error(&quot;set already declared&quot;);
+				else setBlock = new PropertySetRegion(null, attributes);
+				
+			} else if (la.kind == 1) {
+				lexer.NextToken();
+
+#line  1350 &quot;cs.ATG&quot; 
+				Error(&quot;set or get expected&quot;); 
+			} else SynErr(161);
+			Expect(10);
+		}
+	}
+
+	void GetAccessorDecl(
+#line  1289 &quot;cs.ATG&quot; 
+out PropertyGetRegion getBlock, ArrayList attributes) {
+
+#line  1290 &quot;cs.ATG&quot; 
+		Statement stmt = null; 
+		Expect(1);
+
+#line  1293 &quot;cs.ATG&quot; 
+		if (t.val != &quot;get&quot;) Error(&quot;get expected&quot;); 
+		if (la.kind == 14) {
+			Block(
+#line  1294 &quot;cs.ATG&quot; 
+out stmt);
+		} else if (la.kind == 10) {
+			lexer.NextToken();
+		} else SynErr(162);
+
+#line  1294 &quot;cs.ATG&quot; 
+		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes); 
+	}
+
+	void SetAccessorDecl(
+#line  1297 &quot;cs.ATG&quot; 
+out PropertySetRegion setBlock, ArrayList attributes) {
+
+#line  1298 &quot;cs.ATG&quot; 
+		Statement stmt = null; 
+		Expect(1);
+
+#line  1301 &quot;cs.ATG&quot; 
+		if (t.val != &quot;set&quot;) Error(&quot;set expected&quot;); 
+		if (la.kind == 14) {
+			Block(
+#line  1302 &quot;cs.ATG&quot; 
+out stmt);
+		} else if (la.kind == 10) {
+			lexer.NextToken();
+		} else SynErr(163);
+
+#line  1302 &quot;cs.ATG&quot; 
+		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes); 
+	}
+
+	void AddAccessorDecl(
+#line  1376 &quot;cs.ATG&quot; 
+out Statement stmt) {
+
+#line  1377 &quot;cs.ATG&quot; 
+		stmt = null;
+		Expect(1);
+
+#line  1380 &quot;cs.ATG&quot; 
+		if (t.val != &quot;add&quot;) Error(&quot;add expected&quot;); 
+		Block(
+#line  1381 &quot;cs.ATG&quot; 
+out stmt);
+	}
+
+	void RemoveAccessorDecl(
+#line  1384 &quot;cs.ATG&quot; 
+out Statement stmt) {
+
+#line  1385 &quot;cs.ATG&quot; 
+		stmt = null;
+		Expect(1);
+
+#line  1388 &quot;cs.ATG&quot; 
+		if (t.val != &quot;remove&quot;) Error(&quot;remove expected&quot;); 
+		Block(
+#line  1389 &quot;cs.ATG&quot; 
+out stmt);
+	}
+
+	void VariableInitializer(
+#line  1405 &quot;cs.ATG&quot; 
+out Expression initializerExpression) {
+
+#line  1406 &quot;cs.ATG&quot; 
+		TypeReference type = null; Expression expr = null; initializerExpression = null; 
+		if (StartOf(4)) {
+			Expr(
+#line  1408 &quot;cs.ATG&quot; 
+out initializerExpression);
+		} else if (la.kind == 14) {
+			ArrayInitializer(
+#line  1409 &quot;cs.ATG&quot; 
+out initializerExpression);
+		} else if (la.kind == 105) {
+			lexer.NextToken();
+			Type(
+#line  1410 &quot;cs.ATG&quot; 
+out type);
+			Expect(16);
+			Expr(
+#line  1410 &quot;cs.ATG&quot; 
+out expr);
+			Expect(17);
+
+#line  1410 &quot;cs.ATG&quot; 
+			initializerExpression = new StackAllocExpression(type, expr); 
+		} else SynErr(164);
+	}
+
+	void Statement() {
+
+#line  1493 &quot;cs.ATG&quot; 
+		TypeReference type;
+		Expression expr;
+		Statement stmt;
+		
+		if (
+#line  1499 &quot;cs.ATG&quot; 
+IsLabel()) {
+			Expect(1);
+
+#line  1499 &quot;cs.ATG&quot; 
+			compilationUnit.AddChild(new LabelStatement(t.val)); 
+			Expect(9);
+			Statement();
+		} else if (la.kind == 59) {
+			lexer.NextToken();
+			Type(
+#line  1502 &quot;cs.ATG&quot; 
+out type);
+
+#line  1502 &quot;cs.ATG&quot; 
+			LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifier.Const); string ident = null; var.StartLocation = t.Location; 
+			Expect(1);
+
+#line  1503 &quot;cs.ATG&quot; 
+			ident = t.val; 
+			Expect(3);
+			Expr(
+#line  1504 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1504 &quot;cs.ATG&quot; 
+			var.Variables.Add(new VariableDeclaration(ident, expr)); 
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Expect(1);
+
+#line  1505 &quot;cs.ATG&quot; 
+				ident = t.val; 
+				Expect(3);
+				Expr(
+#line  1505 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1505 &quot;cs.ATG&quot; 
+				var.Variables.Add(new VariableDeclaration(ident, expr)); 
+			}
+			Expect(10);
+
+#line  1506 &quot;cs.ATG&quot; 
+			compilationUnit.AddChild(var); 
+		} else if (
+#line  1508 &quot;cs.ATG&quot; 
+IsLocalVarDecl()) {
+			LocalVariableDecl(
+#line  1508 &quot;cs.ATG&quot; 
+out stmt);
+			Expect(10);
+
+#line  1508 &quot;cs.ATG&quot; 
+			compilationUnit.AddChild(stmt); 
+		} else if (StartOf(22)) {
+			EmbeddedStatement(
+#line  1509 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1509 &quot;cs.ATG&quot; 
+			compilationUnit.AddChild(stmt); 
+		} else SynErr(165);
+	}
+
+	void Argument(
+#line  1425 &quot;cs.ATG&quot; 
+out Expression argumentexpr) {
+
+#line  1427 &quot;cs.ATG&quot; 
+		Expression expr;
+		FieldDirection fd = FieldDirection.None;
+		
+		if (la.kind == 92 || la.kind == 99) {
+			if (la.kind == 99) {
+				lexer.NextToken();
+
+#line  1432 &quot;cs.ATG&quot; 
+				fd = FieldDirection.Ref; 
+			} else {
+				lexer.NextToken();
+
+#line  1433 &quot;cs.ATG&quot; 
+				fd = FieldDirection.Out; 
+			}
+		}
+		Expr(
+#line  1435 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1435 &quot;cs.ATG&quot; 
+		argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; 
+	}
+
+	void ArrayInitializer(
+#line  1454 &quot;cs.ATG&quot; 
+out Expression outExpr) {
+
+#line  1456 &quot;cs.ATG&quot; 
+		Expression expr = null;
+		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
+		
+		Expect(14);
+		if (StartOf(23)) {
+			VariableInitializer(
+#line  1461 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1461 &quot;cs.ATG&quot; 
+			initializer.CreateExpressions.Add(expr); 
+			while (
+#line  1461 &quot;cs.ATG&quot; 
+NotFinalComma()) {
+				Expect(12);
+				VariableInitializer(
+#line  1461 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1461 &quot;cs.ATG&quot; 
+				initializer.CreateExpressions.Add(expr); 
+			}
+			if (la.kind == 12) {
+				lexer.NextToken();
+			}
+		}
+		Expect(15);
+
+#line  1462 &quot;cs.ATG&quot; 
+		outExpr = initializer; 
+	}
+
+	void AssignmentOperator(
+#line  1438 &quot;cs.ATG&quot; 
+out AssignmentOperatorType op) {
+
+#line  1439 &quot;cs.ATG&quot; 
+		op = AssignmentOperatorType.None; 
+		switch (la.kind) {
+		case 3: {
+			lexer.NextToken();
+
+#line  1441 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.Assign; 
+			break;
+		}
+		case 37: {
+			lexer.NextToken();
+
+#line  1442 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.Add; 
+			break;
+		}
+		case 38: {
+			lexer.NextToken();
+
+#line  1443 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.Subtract; 
+			break;
+		}
+		case 39: {
+			lexer.NextToken();
+
+#line  1444 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.Multiply; 
+			break;
+		}
+		case 40: {
+			lexer.NextToken();
+
+#line  1445 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.Divide; 
+			break;
+		}
+		case 41: {
+			lexer.NextToken();
+
+#line  1446 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.Modulus; 
+			break;
+		}
+		case 42: {
+			lexer.NextToken();
+
+#line  1447 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.BitwiseAnd; 
+			break;
+		}
+		case 43: {
+			lexer.NextToken();
+
+#line  1448 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.BitwiseOr; 
+			break;
+		}
+		case 44: {
+			lexer.NextToken();
+
+#line  1449 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.ExclusiveOr; 
+			break;
+		}
+		case 45: {
+			lexer.NextToken();
+
+#line  1450 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.ShiftLeft; 
+			break;
+		}
+		case 46: {
+			lexer.NextToken();
+
+#line  1451 &quot;cs.ATG&quot; 
+			op = AssignmentOperatorType.ShiftRight; 
+			break;
+		}
+		default: SynErr(166); break;
+		}
+	}
+
+	void LocalVariableDecl(
+#line  1465 &quot;cs.ATG&quot; 
+out Statement stmt) {
+
+#line  1467 &quot;cs.ATG&quot; 
+		TypeReference type;
+		VariableDeclaration      var = null;
+		LocalVariableDeclaration localVariableDeclaration; 
+		
+		Type(
+#line  1472 &quot;cs.ATG&quot; 
+out type);
+
+#line  1472 &quot;cs.ATG&quot; 
+		localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; 
+		LocalVariableDeclarator(
+#line  1473 &quot;cs.ATG&quot; 
+out var);
+
+#line  1473 &quot;cs.ATG&quot; 
+		localVariableDeclaration.Variables.Add(var); 
+		while (la.kind == 12) {
+			lexer.NextToken();
+			LocalVariableDeclarator(
+#line  1474 &quot;cs.ATG&quot; 
+out var);
+
+#line  1474 &quot;cs.ATG&quot; 
+			localVariableDeclaration.Variables.Add(var); 
+		}
+
+#line  1475 &quot;cs.ATG&quot; 
+		stmt = localVariableDeclaration; 
+	}
+
+	void LocalVariableDeclarator(
+#line  1478 &quot;cs.ATG&quot; 
+out VariableDeclaration var) {
+
+#line  1479 &quot;cs.ATG&quot; 
+		Expression expr = null; 
+		Expect(1);
+
+#line  1481 &quot;cs.ATG&quot; 
+		var = new VariableDeclaration(t.val); 
+		if (la.kind == 3) {
+			lexer.NextToken();
+			LocalVariableInitializer(
+#line  1481 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1481 &quot;cs.ATG&quot; 
+			var.Initializer = expr; 
+		}
+	}
+
+	void LocalVariableInitializer(
+#line  1484 &quot;cs.ATG&quot; 
+out Expression expr) {
+
+#line  1485 &quot;cs.ATG&quot; 
+		expr = null; 
+		if (StartOf(4)) {
+			Expr(
+#line  1487 &quot;cs.ATG&quot; 
+out expr);
+		} else if (la.kind == 14) {
+			ArrayInitializer(
+#line  1488 &quot;cs.ATG&quot; 
+out expr);
+		} else SynErr(167);
+	}
+
+	void EmbeddedStatement(
+#line  1515 &quot;cs.ATG&quot; 
+out Statement statement) {
+
+#line  1517 &quot;cs.ATG&quot; 
+		TypeReference type = null;
+		Expression expr = null;
+		Statement embeddedStatement = null;
+		statement = null;
+		
+		if (la.kind == 14) {
+			Block(
+#line  1523 &quot;cs.ATG&quot; 
+out statement);
+		} else if (la.kind == 10) {
+			lexer.NextToken();
+
+#line  1525 &quot;cs.ATG&quot; 
+			statement = new EmptyStatement(); 
+		} else if (
+#line  1527 &quot;cs.ATG&quot; 
+UnCheckedAndLBrace()) {
+
+#line  1527 &quot;cs.ATG&quot; 
+			Statement block; bool isChecked = true; 
+			if (la.kind == 57) {
+				lexer.NextToken();
+			} else if (la.kind == 117) {
+				lexer.NextToken();
+
+#line  1528 &quot;cs.ATG&quot; 
+				isChecked = false;
+			} else SynErr(168);
+			Block(
+#line  1529 &quot;cs.ATG&quot; 
+out block);
+
+#line  1529 &quot;cs.ATG&quot; 
+			statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); 
+		} else if (StartOf(4)) {
+			StatementExpr(
+#line  1531 &quot;cs.ATG&quot; 
+out statement);
+			Expect(10);
+		} else if (la.kind == 78) {
+			lexer.NextToken();
+
+#line  1533 &quot;cs.ATG&quot; 
+			Statement elseStatement = null; 
+			Expect(18);
+			Expr(
+#line  1534 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+			EmbeddedStatement(
+#line  1535 &quot;cs.ATG&quot; 
+out embeddedStatement);
+			if (la.kind == 66) {
+				lexer.NextToken();
+				EmbeddedStatement(
+#line  1536 &quot;cs.ATG&quot; 
+out elseStatement);
+			}
+
+#line  1537 &quot;cs.ATG&quot; 
+			statement = elseStatement != null ? (Statement)new IfElseStatement(expr, embeddedStatement, elseStatement) :  (Statement)new IfStatement(expr, embeddedStatement); 
+		} else if (la.kind == 109) {
+			lexer.NextToken();
+
+#line  1538 &quot;cs.ATG&quot; 
+			ArrayList switchSections = new ArrayList(); 
+			Expect(18);
+			Expr(
+#line  1539 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+			Expect(14);
+			while (la.kind == 54 || la.kind == 62) {
+				SwitchSection(
+#line  1540 &quot;cs.ATG&quot; 
+out statement);
+
+#line  1540 &quot;cs.ATG&quot; 
+				switchSections.Add(statement); 
+			}
+			Expect(15);
+
+#line  1541 &quot;cs.ATG&quot; 
+			statement = new SwitchStatement(expr, switchSections); 
+		} else if (la.kind == 124) {
+			lexer.NextToken();
+			Expect(18);
+			Expr(
+#line  1543 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+			EmbeddedStatement(
+#line  1544 &quot;cs.ATG&quot; 
+out embeddedStatement);
+
+#line  1544 &quot;cs.ATG&quot; 
+			statement = new WhileStatement(expr, embeddedStatement); 
+		} else if (la.kind == 64) {
+			lexer.NextToken();
+			EmbeddedStatement(
+#line  1545 &quot;cs.ATG&quot; 
+out embeddedStatement);
+			Expect(124);
+			Expect(18);
+			Expr(
+#line  1546 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+			Expect(10);
+
+#line  1546 &quot;cs.ATG&quot; 
+			statement = new DoWhileStatement(expr, embeddedStatement); 
+		} else if (la.kind == 75) {
+			lexer.NextToken();
+
+#line  1547 &quot;cs.ATG&quot; 
+			ArrayList initializer = null, iterator = null; 
+			Expect(18);
+			if (StartOf(4)) {
+				ForInitializer(
+#line  1548 &quot;cs.ATG&quot; 
+out initializer);
+			}
+			Expect(10);
+			if (StartOf(4)) {
+				Expr(
+#line  1549 &quot;cs.ATG&quot; 
+out expr);
+			}
+			Expect(10);
+			if (StartOf(4)) {
+				ForIterator(
+#line  1550 &quot;cs.ATG&quot; 
+out iterator);
+			}
+			Expect(19);
+			EmbeddedStatement(
+#line  1551 &quot;cs.ATG&quot; 
+out embeddedStatement);
+
+#line  1551 &quot;cs.ATG&quot; 
+			statement = new ForStatement(initializer, expr, iterator, embeddedStatement); 
+		} else if (la.kind == 76) {
+			lexer.NextToken();
+			Expect(18);
+			Type(
+#line  1552 &quot;cs.ATG&quot; 
+out type);
+			Expect(1);
+
+#line  1552 &quot;cs.ATG&quot; 
+			string varName = t.val; Point start = t.Location;
+			Expect(80);
+			Expr(
+#line  1553 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+			EmbeddedStatement(
+#line  1554 &quot;cs.ATG&quot; 
+out embeddedStatement);
+
+#line  1554 &quot;cs.ATG&quot; 
+			statement = new ForeachStatement(type, varName , expr, embeddedStatement); 
+			statement.EndLocation = t.EndLocation;
+			
+		} else if (la.kind == 52) {
+			lexer.NextToken();
+			Expect(10);
+
+#line  1558 &quot;cs.ATG&quot; 
+			statement = new BreakStatement(); 
+		} else if (la.kind == 60) {
+			lexer.NextToken();
+			Expect(10);
+
+#line  1559 &quot;cs.ATG&quot; 
+			statement = new ContinueStatement(); 
+		} else if (la.kind == 77) {
+			GotoStatement(
+#line  1560 &quot;cs.ATG&quot; 
+out statement);
+		} else if (la.kind == 100) {
+			lexer.NextToken();
+			if (StartOf(4)) {
+				Expr(
+#line  1561 &quot;cs.ATG&quot; 
+out expr);
+			}
+			Expect(10);
+
+#line  1561 &quot;cs.ATG&quot; 
+			statement = new ReturnStatement(expr); 
+		} else if (la.kind == 111) {
+			lexer.NextToken();
+			if (StartOf(4)) {
+				Expr(
+#line  1562 &quot;cs.ATG&quot; 
+out expr);
+			}
+			Expect(10);
+
+#line  1562 &quot;cs.ATG&quot; 
+			statement = new ThrowStatement(expr); 
+		} else if (la.kind == 113) {
+			TryStatement(
+#line  1564 &quot;cs.ATG&quot; 
+out statement);
+		} else if (la.kind == 85) {
+			lexer.NextToken();
+			Expect(18);
+			Expr(
+#line  1566 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+			EmbeddedStatement(
+#line  1567 &quot;cs.ATG&quot; 
+out embeddedStatement);
+
+#line  1567 &quot;cs.ATG&quot; 
+			statement = new LockStatement(expr, embeddedStatement); 
+		} else if (la.kind == 120) {
+
+#line  1569 &quot;cs.ATG&quot; 
+			Statement resourceAcquisitionStmt = null; 
+			lexer.NextToken();
+			Expect(18);
+			ResourceAcquisition(
+#line  1571 &quot;cs.ATG&quot; 
+out resourceAcquisitionStmt);
+			Expect(19);
+			EmbeddedStatement(
+#line  1572 &quot;cs.ATG&quot; 
+out embeddedStatement);
+
+#line  1572 &quot;cs.ATG&quot; 
+			statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); 
+		} else if (la.kind == 118) {
+			lexer.NextToken();
+			Block(
+#line  1574 &quot;cs.ATG&quot; 
+out embeddedStatement);
+
+#line  1574 &quot;cs.ATG&quot; 
+			statement = new UnsafeStatement(embeddedStatement); 
+		} else if (la.kind == 73) {
+			lexer.NextToken();
+			Expect(18);
+			Type(
+#line  1577 &quot;cs.ATG&quot; 
+out type);
+
+#line  1577 &quot;cs.ATG&quot; 
+			if (type.PointerNestingLevel == 0) Error(&quot;can only fix pointer types&quot;);
+			FixedStatement fxStmt = new FixedStatement(type);
+			string identifier = null;
+			
+			Expect(1);
+
+#line  1581 &quot;cs.ATG&quot; 
+			identifier = t.val; 
+			Expect(3);
+			Expr(
+#line  1582 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1582 &quot;cs.ATG&quot; 
+			fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); 
+			while (la.kind == 12) {
+				lexer.NextToken();
+				Expect(1);
+
+#line  1584 &quot;cs.ATG&quot; 
+				identifier = t.val; 
+				Expect(3);
+				Expr(
+#line  1585 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1585 &quot;cs.ATG&quot; 
+				fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); 
+			}
+			Expect(19);
+			EmbeddedStatement(
+#line  1587 &quot;cs.ATG&quot; 
+out embeddedStatement);
+
+#line  1587 &quot;cs.ATG&quot; 
+			fxStmt.EmbeddedStatement = embeddedStatement; statement = fxStmt;
+		} else SynErr(169);
+	}
+
+	void StatementExpr(
+#line  1695 &quot;cs.ATG&quot; 
+out Statement stmt) {
+
+#line  1700 &quot;cs.ATG&quot; 
+		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
+		                       la.kind == Tokens.Not   || la.kind == Tokens.BitwiseComplement ||
+		                       la.kind == Tokens.Times || la.kind == Tokens.BitwiseAnd   || IsTypeCast();
+		Expression expr = null;
+		
+		UnaryExpr(
+#line  1706 &quot;cs.ATG&quot; 
+out expr);
+		if (StartOf(6)) {
+
+#line  1709 &quot;cs.ATG&quot; 
+			AssignmentOperatorType op; Expression val; 
+			AssignmentOperator(
+#line  1709 &quot;cs.ATG&quot; 
+out op);
+			Expr(
+#line  1709 &quot;cs.ATG&quot; 
+out val);
+
+#line  1709 &quot;cs.ATG&quot; 
+			expr = new AssignmentExpression(expr, op, val); 
+		} else if (la.kind == 10 || la.kind == 12 || la.kind == 19) {
+
+#line  1710 &quot;cs.ATG&quot; 
+			if (mustBeAssignment) Error(&quot;error in assignment.&quot;); 
+		} else SynErr(170);
+
+#line  1711 &quot;cs.ATG&quot; 
+		stmt = new StatementExpression(expr); 
+	}
+
+	void SwitchSection(
+#line  1609 &quot;cs.ATG&quot; 
+out Statement stmt) {
+
+#line  1611 &quot;cs.ATG&quot; 
+		SwitchSection switchSection = new SwitchSection();
+		Expression expr;
+		
+		SwitchLabel(
+#line  1615 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1615 &quot;cs.ATG&quot; 
+		switchSection.SwitchLabels.Add(expr); 
+		while (la.kind == 54 || la.kind == 62) {
+			SwitchLabel(
+#line  1615 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1615 &quot;cs.ATG&quot; 
+			switchSection.SwitchLabels.Add(expr); 
+		}
+
+#line  1616 &quot;cs.ATG&quot; 
+		compilationUnit.BlockStart(switchSection); 
+		Statement();
+		while (StartOf(20)) {
+			Statement();
+		}
+
+#line  1619 &quot;cs.ATG&quot; 
+		compilationUnit.BlockEnd();
+		stmt = switchSection;
+		
+	}
+
+	void ForInitializer(
+#line  1590 &quot;cs.ATG&quot; 
+out ArrayList initializer) {
+
+#line  1592 &quot;cs.ATG&quot; 
+		Statement stmt; 
+		initializer = new ArrayList();
+		
+		if (
+#line  1596 &quot;cs.ATG&quot; 
+IsLocalVarDecl()) {
+			LocalVariableDecl(
+#line  1596 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1596 &quot;cs.ATG&quot; 
+			initializer.Add(stmt);
+		} else if (StartOf(4)) {
+			StatementExpr(
+#line  1597 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1597 &quot;cs.ATG&quot; 
+			initializer.Add(stmt);
+			while (la.kind == 12) {
+				lexer.NextToken();
+				StatementExpr(
+#line  1597 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1597 &quot;cs.ATG&quot; 
+				initializer.Add(stmt);
+			}
+
+#line  1597 &quot;cs.ATG&quot; 
+			initializer.Add(stmt);
+		} else SynErr(171);
+	}
+
+	void ForIterator(
+#line  1600 &quot;cs.ATG&quot; 
+out ArrayList iterator) {
+
+#line  1602 &quot;cs.ATG&quot; 
+		Statement stmt; 
+		iterator = new ArrayList();
+		
+		StatementExpr(
+#line  1606 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1606 &quot;cs.ATG&quot; 
+		iterator.Add(stmt);
+		while (la.kind == 12) {
+			lexer.NextToken();
+			StatementExpr(
+#line  1606 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1606 &quot;cs.ATG&quot; 
+			iterator.Add(stmt); 
+		}
+	}
+
+	void GotoStatement(
+#line  1668 &quot;cs.ATG&quot; 
+out Statement stmt) {
+
+#line  1669 &quot;cs.ATG&quot; 
+		Expression expr; stmt = null; 
+		Expect(77);
+		if (la.kind == 1) {
+			lexer.NextToken();
+
+#line  1673 &quot;cs.ATG&quot; 
+			stmt = new GotoStatement(t.val); 
+			Expect(10);
+		} else if (la.kind == 54) {
+			lexer.NextToken();
+			Expr(
+#line  1674 &quot;cs.ATG&quot; 
+out expr);
+			Expect(10);
+
+#line  1674 &quot;cs.ATG&quot; 
+			stmt = new GotoCaseStatement(expr); 
+		} else if (la.kind == 62) {
+			lexer.NextToken();
+			Expect(10);
+
+#line  1675 &quot;cs.ATG&quot; 
+			stmt = new GotoCaseStatement(null); 
+		} else SynErr(172);
+	}
+
+	void TryStatement(
+#line  1631 &quot;cs.ATG&quot; 
+out Statement tryStatement) {
+
+#line  1633 &quot;cs.ATG&quot; 
+		Statement blockStmt = null, finallyStmt = null;
+		ArrayList catchClauses = null;
+		
+		Expect(113);
+		Block(
+#line  1637 &quot;cs.ATG&quot; 
+out blockStmt);
+		if (la.kind == 55) {
+			CatchClauses(
+#line  1639 &quot;cs.ATG&quot; 
+out catchClauses);
+			if (la.kind == 72) {
+				lexer.NextToken();
+				Block(
+#line  1639 &quot;cs.ATG&quot; 
+out finallyStmt);
+			}
+		} else if (la.kind == 72) {
+			lexer.NextToken();
+			Block(
+#line  1640 &quot;cs.ATG&quot; 
+out finallyStmt);
+		} else SynErr(173);
+
+#line  1643 &quot;cs.ATG&quot; 
+		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
+			
+	}
+
+	void ResourceAcquisition(
+#line  1679 &quot;cs.ATG&quot; 
+out Statement stmt) {
+
+#line  1681 &quot;cs.ATG&quot; 
+		stmt = null;
+		Expression expr;
+		
+		if (
+#line  1686 &quot;cs.ATG&quot; 
+IsLocalVarDecl()) {
+			LocalVariableDecl(
+#line  1686 &quot;cs.ATG&quot; 
+out stmt);
+		} else if (StartOf(4)) {
+			Expr(
+#line  1687 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1691 &quot;cs.ATG&quot; 
+			stmt = new StatementExpression(expr); 
+		} else SynErr(174);
+	}
+
+	void SwitchLabel(
+#line  1624 &quot;cs.ATG&quot; 
+out Expression expr) {
+
+#line  1625 &quot;cs.ATG&quot; 
+		expr = null; 
+		if (la.kind == 54) {
+			lexer.NextToken();
+			Expr(
+#line  1627 &quot;cs.ATG&quot; 
+out expr);
+			Expect(9);
+		} else if (la.kind == 62) {
+			lexer.NextToken();
+			Expect(9);
+		} else SynErr(175);
+	}
+
+	void CatchClauses(
+#line  1648 &quot;cs.ATG&quot; 
+out ArrayList catchClauses) {
+
+#line  1650 &quot;cs.ATG&quot; 
+		catchClauses = new ArrayList();
+		
+		Expect(55);
+
+#line  1653 &quot;cs.ATG&quot; 
+		string name;
+		string identifier;
+		Statement stmt; 
+		
+		if (la.kind == 14) {
+			Block(
+#line  1659 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1659 &quot;cs.ATG&quot; 
+			catchClauses.Add(new CatchClause(stmt)); 
+		} else if (la.kind == 18) {
+			lexer.NextToken();
+			ClassType(
+#line  1661 &quot;cs.ATG&quot; 
+out name);
+
+#line  1661 &quot;cs.ATG&quot; 
+			identifier = null; 
+			if (la.kind == 1) {
+				lexer.NextToken();
+
+#line  1661 &quot;cs.ATG&quot; 
+				identifier = t.val; 
+			}
+			Expect(19);
+			Block(
+#line  1661 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1661 &quot;cs.ATG&quot; 
+			catchClauses.Add(new CatchClause(name, identifier, stmt)); 
+			while (
+#line  1662 &quot;cs.ATG&quot; 
+IsTypedCatch()) {
+				Expect(55);
+				Expect(18);
+				ClassType(
+#line  1662 &quot;cs.ATG&quot; 
+out name);
+
+#line  1662 &quot;cs.ATG&quot; 
+				identifier = null; 
+				if (la.kind == 1) {
+					lexer.NextToken();
+
+#line  1662 &quot;cs.ATG&quot; 
+					identifier = t.val; 
+				}
+				Expect(19);
+				Block(
+#line  1662 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1662 &quot;cs.ATG&quot; 
+				catchClauses.Add(new CatchClause(name, identifier, stmt)); 
+			}
+			if (la.kind == 55) {
+				lexer.NextToken();
+				Block(
+#line  1664 &quot;cs.ATG&quot; 
+out stmt);
+
+#line  1664 &quot;cs.ATG&quot; 
+				catchClauses.Add(new CatchClause(stmt)); 
+			}
+		} else SynErr(176);
+	}
+
+	void UnaryExpr(
+#line  1727 &quot;cs.ATG&quot; 
+out Expression uExpr) {
+
+#line  1729 &quot;cs.ATG&quot; 
+		TypeReference type = null;
+		Expression expr;
+		ArrayList  expressions = new ArrayList();
+		uExpr = null;
+		
+		while (StartOf(24) || 
+#line  1751 &quot;cs.ATG&quot; 
+IsTypeCast()) {
+			if (la.kind == 4) {
+				lexer.NextToken();
+
+#line  1736 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); 
+			} else if (la.kind == 5) {
+				lexer.NextToken();
+
+#line  1737 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); 
+			} else if (la.kind == 22) {
+				lexer.NextToken();
+
+#line  1738 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); 
+			} else if (la.kind == 25) {
+				lexer.NextToken();
+
+#line  1739 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); 
+			} else if (la.kind == 6) {
+				lexer.NextToken();
+
+#line  1740 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); 
+			} else if (la.kind == 29) {
+				lexer.NextToken();
+
+#line  1741 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); 
+			} else if (la.kind == 30) {
+				lexer.NextToken();
+
+#line  1742 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); 
+			} else if (la.kind == 26) {
+				lexer.NextToken();
+
+#line  1743 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); 
+			} else {
+				Expect(18);
+				Type(
+#line  1751 &quot;cs.ATG&quot; 
+out type);
+				Expect(19);
+
+#line  1751 &quot;cs.ATG&quot; 
+				expressions.Add(new CastExpression(type)); 
+			}
+		}
+		PrimaryExpr(
+#line  1754 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1754 &quot;cs.ATG&quot; 
+		for (int i = 0; i &lt; expressions.Count; ++i) {
+		Expression nextExpression = i + 1 &lt; expressions.Count ? (Expression)expressions[i + 1] : expr;
+		if (expressions[i] is CastExpression) {
+			((CastExpression)expressions[i]).Expression = nextExpression;
+		} else {
+			((UnaryOperatorExpression)expressions[i]).Expression = nextExpression;
+		}
+		}
+		if (expressions.Count &gt; 0) {
+			uExpr = (Expression)expressions[0];
+		} else {
+			uExpr = expr;
+		}
+		
+	}
+
+	void ConditionalOrExpr(
+#line  1856 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1857 &quot;cs.ATG&quot; 
+		Expression expr;   
+		ConditionalAndExpr(
+#line  1859 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (la.kind == 24) {
+			lexer.NextToken();
+			UnaryExpr(
+#line  1859 &quot;cs.ATG&quot; 
+out expr);
+			ConditionalAndExpr(
+#line  1859 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1859 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  
+		}
+	}
+
+	void PrimaryExpr(
+#line  1771 &quot;cs.ATG&quot; 
+out Expression pexpr) {
+
+#line  1773 &quot;cs.ATG&quot; 
+		TypeReference type = null;
+		bool isArrayCreation = false;
+		Expression expr;
+		pexpr = null;
+		
+		switch (la.kind) {
+		case 112: {
+			lexer.NextToken();
+
+#line  1780 &quot;cs.ATG&quot; 
+			pexpr = new PrimitiveExpression(true, &quot;true&quot;);  
+			break;
+		}
+		case 71: {
+			lexer.NextToken();
+
+#line  1781 &quot;cs.ATG&quot; 
+			pexpr = new PrimitiveExpression(false, &quot;false&quot;); 
+			break;
+		}
+		case 89: {
+			lexer.NextToken();
+
+#line  1782 &quot;cs.ATG&quot; 
+			pexpr = new PrimitiveExpression(null, &quot;null&quot;);  
+			break;
+		}
+		case 2: {
+			lexer.NextToken();
+
+#line  1783 &quot;cs.ATG&quot; 
+			pexpr = new PrimitiveExpression(t.literalValue, t.val);  
+			break;
+		}
+		case 1: {
+			lexer.NextToken();
+
+#line  1785 &quot;cs.ATG&quot; 
+			pexpr = new IdentifierExpression(t.val); 
+			break;
+		}
+		case 18: {
+			lexer.NextToken();
+			Expr(
+#line  1787 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+
+#line  1787 &quot;cs.ATG&quot; 
+			pexpr = new ParenthesizedExpression(expr); 
+			break;
+		}
+		case 51: case 53: case 56: case 61: case 65: case 74: case 81: case 86: case 90: case 101: case 103: case 107: case 115: case 116: case 119: {
+			switch (la.kind) {
+			case 51: {
+				lexer.NextToken();
+				break;
+			}
+			case 53: {
+				lexer.NextToken();
+				break;
+			}
+			case 56: {
+				lexer.NextToken();
+				break;
+			}
+			case 61: {
+				lexer.NextToken();
+				break;
+			}
+			case 65: {
+				lexer.NextToken();
+				break;
+			}
+			case 74: {
+				lexer.NextToken();
+				break;
+			}
+			case 81: {
+				lexer.NextToken();
+				break;
+			}
+			case 86: {
+				lexer.NextToken();
+				break;
+			}
+			case 90: {
+				lexer.NextToken();
+				break;
+			}
+			case 101: {
+				lexer.NextToken();
+				break;
+			}
+			case 103: {
+				lexer.NextToken();
+				break;
+			}
+			case 107: {
+				lexer.NextToken();
+				break;
+			}
+			case 115: {
+				lexer.NextToken();
+				break;
+			}
+			case 116: {
+				lexer.NextToken();
+				break;
+			}
+			case 119: {
+				lexer.NextToken();
+				break;
+			}
+			}
+
+#line  1793 &quot;cs.ATG&quot; 
+			string val = t.val; 
+			Expect(13);
+			Expect(1);
+
+#line  1793 &quot;cs.ATG&quot; 
+			pexpr = new FieldReferenceExpression(new TypeReferenceExpression(val), t.val); 
+			break;
+		}
+		case 110: {
+			lexer.NextToken();
+
+#line  1795 &quot;cs.ATG&quot; 
+			pexpr = new ThisReferenceExpression(); 
+			break;
+		}
+		case 50: {
+			lexer.NextToken();
+
+#line  1797 &quot;cs.ATG&quot; 
+			Expression retExpr = new BaseReferenceExpression(); 
+			if (la.kind == 13) {
+				lexer.NextToken();
+				Expect(1);
+
+#line  1799 &quot;cs.ATG&quot; 
+				retExpr = new FieldReferenceExpression(retExpr, t.val); 
+			} else if (la.kind == 16) {
+				lexer.NextToken();
+				Expr(
+#line  1800 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1800 &quot;cs.ATG&quot; 
+				ArrayList indices = new ArrayList(); indices.Add(expr); 
+				while (la.kind == 12) {
+					lexer.NextToken();
+					Expr(
+#line  1801 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1801 &quot;cs.ATG&quot; 
+					indices.Add(expr); 
+				}
+				Expect(17);
+
+#line  1802 &quot;cs.ATG&quot; 
+				retExpr = new IndexerExpression(retExpr, indices); 
+			} else SynErr(177);
+
+#line  1803 &quot;cs.ATG&quot; 
+			pexpr = retExpr; 
+			break;
+		}
+		case 88: {
+			lexer.NextToken();
+			NonArrayType(
+#line  1804 &quot;cs.ATG&quot; 
+out type);
+
+#line  1804 &quot;cs.ATG&quot; 
+			ArrayList parameters = new ArrayList(); 
+			if (la.kind == 18) {
+				lexer.NextToken();
+
+#line  1809 &quot;cs.ATG&quot; 
+				ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); 
+				if (StartOf(21)) {
+					Argument(
+#line  1809 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1809 &quot;cs.ATG&quot; 
+					parameters.Add(expr); 
+					while (la.kind == 12) {
+						lexer.NextToken();
+						Argument(
+#line  1810 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1810 &quot;cs.ATG&quot; 
+						parameters.Add(expr); 
+					}
+				}
+				Expect(19);
+
+#line  1810 &quot;cs.ATG&quot; 
+				pexpr = oce; 
+			} else if (la.kind == 16) {
+
+#line  1812 &quot;cs.ATG&quot; 
+				isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type); pexpr = ace; 
+				lexer.NextToken();
+
+#line  1813 &quot;cs.ATG&quot; 
+				int dims = 0; ArrayList rank = new ArrayList(); ArrayList parameterExpression = new ArrayList(); 
+				if (StartOf(4)) {
+					Expr(
+#line  1815 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1815 &quot;cs.ATG&quot; 
+					parameterExpression.Add(expr); 
+					while (la.kind == 12) {
+						lexer.NextToken();
+						Expr(
+#line  1815 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1815 &quot;cs.ATG&quot; 
+						parameterExpression.Add(expr); 
+					}
+					Expect(17);
+
+#line  1815 &quot;cs.ATG&quot; 
+					parameters.Add(new ArrayCreationParameter(parameterExpression)); ace.Parameters = parameters; 
+					while (
+#line  1816 &quot;cs.ATG&quot; 
+IsDims()) {
+						Expect(16);
+
+#line  1816 &quot;cs.ATG&quot; 
+						dims =0;
+						while (la.kind == 12) {
+							lexer.NextToken();
+
+#line  1816 &quot;cs.ATG&quot; 
+							dims++;
+						}
+
+#line  1816 &quot;cs.ATG&quot; 
+						rank.Add(dims); parameters.Add(new ArrayCreationParameter(dims)); 
+						Expect(17);
+					}
+
+#line  1817 &quot;cs.ATG&quot; 
+					if (rank.Count &gt; 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } 
+					if (la.kind == 14) {
+						ArrayInitializer(
+#line  1818 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1818 &quot;cs.ATG&quot; 
+						ace.ArrayInitializer = (ArrayInitializerExpression)expr; 
+					}
+				} else if (la.kind == 12 || la.kind == 17) {
+					while (la.kind == 12) {
+						lexer.NextToken();
+
+#line  1820 &quot;cs.ATG&quot; 
+						dims++;
+					}
+
+#line  1820 &quot;cs.ATG&quot; 
+					parameters.Add(new ArrayCreationParameter(dims)); 
+					Expect(17);
+					while (
+#line  1820 &quot;cs.ATG&quot; 
+IsDims()) {
+						Expect(16);
+
+#line  1820 &quot;cs.ATG&quot; 
+						dims =0;
+						while (la.kind == 12) {
+							lexer.NextToken();
+
+#line  1820 &quot;cs.ATG&quot; 
+							dims++;
+						}
+
+#line  1820 &quot;cs.ATG&quot; 
+						parameters.Add(new ArrayCreationParameter(dims)); 
+						Expect(17);
+					}
+					ArrayInitializer(
+#line  1820 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1820 &quot;cs.ATG&quot; 
+					ace.ArrayInitializer = (ArrayInitializerExpression)expr; ace.Parameters = parameters; 
+				} else SynErr(178);
+			} else SynErr(179);
+			break;
+		}
+		case 114: {
+			lexer.NextToken();
+			Expect(18);
+			if (
+#line  1826 &quot;cs.ATG&quot; 
+NotVoidPointer()) {
+				Expect(122);
+
+#line  1826 &quot;cs.ATG&quot; 
+				type = new TypeReference(&quot;void&quot;); 
+			} else if (StartOf(8)) {
+				Type(
+#line  1827 &quot;cs.ATG&quot; 
+out type);
+			} else SynErr(180);
+			Expect(19);
+
+#line  1828 &quot;cs.ATG&quot; 
+			pexpr = new TypeOfExpression(type); 
+			break;
+		}
+		case 104: {
+			lexer.NextToken();
+			Expect(18);
+			Type(
+#line  1829 &quot;cs.ATG&quot; 
+out type);
+			Expect(19);
+
+#line  1829 &quot;cs.ATG&quot; 
+			pexpr = new SizeOfExpression(type); 
+			break;
+		}
+		case 57: {
+			lexer.NextToken();
+			Expect(18);
+			Expr(
+#line  1830 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+
+#line  1830 &quot;cs.ATG&quot; 
+			pexpr = new CheckedExpression(expr); 
+			break;
+		}
+		case 117: {
+			lexer.NextToken();
+			Expect(18);
+			Expr(
+#line  1831 &quot;cs.ATG&quot; 
+out expr);
+			Expect(19);
+
+#line  1831 &quot;cs.ATG&quot; 
+			pexpr = new CheckedExpression(expr); 
+			break;
+		}
+		default: SynErr(181); break;
+		}
+		while (StartOf(25)) {
+			if (la.kind == 29 || la.kind == 30) {
+				if (la.kind == 29) {
+					lexer.NextToken();
+
+#line  1835 &quot;cs.ATG&quot; 
+					pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); 
+				} else if (la.kind == 30) {
+					lexer.NextToken();
+
+#line  1836 &quot;cs.ATG&quot; 
+					pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); 
+				} else SynErr(182);
+			} else if (la.kind == 47) {
+				lexer.NextToken();
+				Expect(1);
+
+#line  1839 &quot;cs.ATG&quot; 
+				pexpr = new PointerReferenceExpression(pexpr, t.val); 
+			} else if (la.kind == 13) {
+				lexer.NextToken();
+				Expect(1);
+
+#line  1840 &quot;cs.ATG&quot; 
+				pexpr = new FieldReferenceExpression(pexpr, t.val);
+			} else if (la.kind == 18) {
+				lexer.NextToken();
+
+#line  1842 &quot;cs.ATG&quot; 
+				ArrayList parameters = new ArrayList(); 
+				if (StartOf(21)) {
+					Argument(
+#line  1843 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1843 &quot;cs.ATG&quot; 
+					parameters.Add(expr); 
+					while (la.kind == 12) {
+						lexer.NextToken();
+						Argument(
+#line  1844 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1844 &quot;cs.ATG&quot; 
+						parameters.Add(expr); 
+					}
+				}
+				Expect(19);
+
+#line  1845 &quot;cs.ATG&quot; 
+				pexpr = new InvocationExpression(pexpr, parameters); 
+			} else {
+
+#line  1847 &quot;cs.ATG&quot; 
+				if (isArrayCreation) Error(&quot;element access not allow on array creation&quot;);
+				ArrayList indices = new ArrayList();
+				
+				lexer.NextToken();
+				Expr(
+#line  1850 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1850 &quot;cs.ATG&quot; 
+				indices.Add(expr); 
+				while (la.kind == 12) {
+					lexer.NextToken();
+					Expr(
+#line  1851 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1851 &quot;cs.ATG&quot; 
+					indices.Add(expr); 
+				}
+				Expect(17);
+
+#line  1852 &quot;cs.ATG&quot; 
+				pexpr = new IndexerExpression(pexpr, indices); 
+			}
+		}
+	}
+
+	void ConditionalAndExpr(
+#line  1862 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1863 &quot;cs.ATG&quot; 
+		Expression expr; 
+		InclusiveOrExpr(
+#line  1865 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (la.kind == 23) {
+			lexer.NextToken();
+			UnaryExpr(
+#line  1865 &quot;cs.ATG&quot; 
+out expr);
+			InclusiveOrExpr(
+#line  1865 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1865 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  
+		}
+	}
+
+	void InclusiveOrExpr(
+#line  1868 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1869 &quot;cs.ATG&quot; 
+		Expression expr; 
+		ExclusiveOrExpr(
+#line  1871 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (la.kind == 27) {
+			lexer.NextToken();
+			UnaryExpr(
+#line  1871 &quot;cs.ATG&quot; 
+out expr);
+			ExclusiveOrExpr(
+#line  1871 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1871 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  
+		}
+	}
+
+	void ExclusiveOrExpr(
+#line  1874 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1875 &quot;cs.ATG&quot; 
+		Expression expr; 
+		AndExpr(
+#line  1877 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (la.kind == 28) {
+			lexer.NextToken();
+			UnaryExpr(
+#line  1877 &quot;cs.ATG&quot; 
+out expr);
+			AndExpr(
+#line  1877 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1877 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  
+		}
+	}
+
+	void AndExpr(
+#line  1880 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1881 &quot;cs.ATG&quot; 
+		Expression expr; 
+		EqualityExpr(
+#line  1883 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (la.kind == 26) {
+			lexer.NextToken();
+			UnaryExpr(
+#line  1883 &quot;cs.ATG&quot; 
+out expr);
+			EqualityExpr(
+#line  1883 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1883 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  
+		}
+	}
+
+	void EqualityExpr(
+#line  1886 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1888 &quot;cs.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		RelationalExpr(
+#line  1892 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (la.kind == 31 || la.kind == 32) {
+			if (la.kind == 32) {
+				lexer.NextToken();
+
+#line  1895 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.InEquality; 
+			} else {
+				lexer.NextToken();
+
+#line  1896 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.Equality; 
+			}
+			UnaryExpr(
+#line  1898 &quot;cs.ATG&quot; 
+out expr);
+			RelationalExpr(
+#line  1898 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1898 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void RelationalExpr(
+#line  1902 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1904 &quot;cs.ATG&quot; 
+		TypeReference type;
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		ShiftExpr(
+#line  1909 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (StartOf(26)) {
+			if (StartOf(27)) {
+				if (la.kind == 21) {
+					lexer.NextToken();
+
+#line  1912 &quot;cs.ATG&quot; 
+					op = BinaryOperatorType.LessThan; 
+				} else if (la.kind == 20) {
+					lexer.NextToken();
+
+#line  1913 &quot;cs.ATG&quot; 
+					op = BinaryOperatorType.GreaterThan; 
+				} else if (la.kind == 34) {
+					lexer.NextToken();
+
+#line  1914 &quot;cs.ATG&quot; 
+					op = BinaryOperatorType.LessThanOrEqual; 
+				} else if (la.kind == 33) {
+					lexer.NextToken();
+
+#line  1915 &quot;cs.ATG&quot; 
+					op = BinaryOperatorType.GreaterThanOrEqual; 
+				} else SynErr(183);
+				UnaryExpr(
+#line  1917 &quot;cs.ATG&quot; 
+out expr);
+				ShiftExpr(
+#line  1917 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1917 &quot;cs.ATG&quot; 
+				outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+			} else {
+				if (la.kind == 84) {
+					lexer.NextToken();
+
+#line  1920 &quot;cs.ATG&quot; 
+					op = BinaryOperatorType.IS; 
+				} else if (la.kind == 49) {
+					lexer.NextToken();
+
+#line  1921 &quot;cs.ATG&quot; 
+					op = BinaryOperatorType.AS; 
+				} else SynErr(184);
+				Type(
+#line  1923 &quot;cs.ATG&quot; 
+out type);
+
+#line  1923 &quot;cs.ATG&quot; 
+				outExpr = new BinaryOperatorExpression(outExpr, op, new TypeReferenceExpression(type)); 
+			}
+		}
+	}
+
+	void ShiftExpr(
+#line  1927 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1929 &quot;cs.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		AdditiveExpr(
+#line  1933 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (la.kind == 35 || la.kind == 36) {
+			if (la.kind == 35) {
+				lexer.NextToken();
+
+#line  1936 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.ShiftLeft; 
+			} else {
+				lexer.NextToken();
+
+#line  1937 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.ShiftRight; 
+			}
+			UnaryExpr(
+#line  1939 &quot;cs.ATG&quot; 
+out expr);
+			AdditiveExpr(
+#line  1939 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1939 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void AdditiveExpr(
+#line  1943 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1945 &quot;cs.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		MultiplicativeExpr(
+#line  1949 &quot;cs.ATG&quot; 
+ref outExpr);
+		while (la.kind == 4 || la.kind == 5) {
+			if (la.kind == 4) {
+				lexer.NextToken();
+
+#line  1952 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.Add; 
+			} else {
+				lexer.NextToken();
+
+#line  1953 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.Subtract; 
+			}
+			UnaryExpr(
+#line  1955 &quot;cs.ATG&quot; 
+out expr);
+			MultiplicativeExpr(
+#line  1955 &quot;cs.ATG&quot; 
+ref expr);
+
+#line  1955 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
+		}
+	}
+
+	void MultiplicativeExpr(
+#line  1959 &quot;cs.ATG&quot; 
+ref Expression outExpr) {
+
+#line  1961 &quot;cs.ATG&quot; 
+		Expression expr;
+		BinaryOperatorType op = BinaryOperatorType.None;
+		
+		while (la.kind == 6 || la.kind == 7 || la.kind == 8) {
+			if (la.kind == 6) {
+				lexer.NextToken();
+
+#line  1967 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.Multiply; 
+			} else if (la.kind == 7) {
+				lexer.NextToken();
+
+#line  1968 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.Divide; 
+			} else {
+				lexer.NextToken();
+
+#line  1969 &quot;cs.ATG&quot; 
+				op = BinaryOperatorType.Modulus; 
+			}
+			UnaryExpr(
+#line  1971 &quot;cs.ATG&quot; 
+out expr);
+
+#line  1971 &quot;cs.ATG&quot; 
+			outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
+		}
+	}
+
+
+
+	public void Parse(Lexer lexer)
+	{
+		this.errors = lexer.Errors;
+		this.lexer = lexer;
+		errors.SynErr = new ErrorCodeProc(SynErr);
+		lexer.NextToken();
+		CS();
+
+	}
+
+	void SynErr(int line, int col, int errorNumber)
+	{
+		errors.count++; 
+		string s;
+		switch (errorNumber) {
+			case 0: s = &quot;EOF expected&quot;; break;
+			case 1: s = &quot;ident expected&quot;; break;
+			case 2: s = &quot;literal expected&quot;; break;
+			case 3: s = &quot;\&quot;=\&quot; expected&quot;; break;
+			case 4: s = &quot;\&quot;+\&quot; expected&quot;; break;
+			case 5: s = &quot;\&quot;-\&quot; expected&quot;; break;
+			case 6: s = &quot;\&quot;*\&quot; expected&quot;; break;
+			case 7: s = &quot;\&quot;/\&quot; expected&quot;; break;
+			case 8: s = &quot;\&quot;%\&quot; expected&quot;; break;
+			case 9: s = &quot;\&quot;:\&quot; expected&quot;; break;
+			case 10: s = &quot;\&quot;;\&quot; expected&quot;; break;
+			case 11: s = &quot;\&quot;?\&quot; expected&quot;; break;
+			case 12: s = &quot;\&quot;,\&quot; expected&quot;; break;
+			case 13: s = &quot;\&quot;.\&quot; expected&quot;; break;
+			case 14: s = &quot;\&quot;{\&quot; expected&quot;; break;
+			case 15: s = &quot;\&quot;}\&quot; expected&quot;; break;
+			case 16: s = &quot;\&quot;[\&quot; expected&quot;; break;
+			case 17: s = &quot;\&quot;]\&quot; expected&quot;; break;
+			case 18: s = &quot;\&quot;(\&quot; expected&quot;; break;
+			case 19: s = &quot;\&quot;)\&quot; expected&quot;; break;
+			case 20: s = &quot;\&quot;&gt;\&quot; expected&quot;; break;
+			case 21: s = &quot;\&quot;&lt;\&quot; expected&quot;; break;
+			case 22: s = &quot;\&quot;!\&quot; expected&quot;; break;
+			case 23: s = &quot;\&quot;&amp;&amp;\&quot; expected&quot;; break;
+			case 24: s = &quot;\&quot;||\&quot; expected&quot;; break;
+			case 25: s = &quot;\&quot;~\&quot; expected&quot;; break;
+			case 26: s = &quot;\&quot;&amp;\&quot; expected&quot;; break;
+			case 27: s = &quot;\&quot;|\&quot; expected&quot;; break;
+			case 28: s = &quot;\&quot;^\&quot; expected&quot;; break;
+			case 29: s = &quot;\&quot;++\&quot; expected&quot;; break;
+			case 30: s = &quot;\&quot;--\&quot; expected&quot;; break;
+			case 31: s = &quot;\&quot;==\&quot; expected&quot;; break;
+			case 32: s = &quot;\&quot;!=\&quot; expected&quot;; break;
+			case 33: s = &quot;\&quot;&gt;=\&quot; expected&quot;; break;
+			case 34: s = &quot;\&quot;&lt;=\&quot; expected&quot;; break;
+			case 35: s = &quot;\&quot;&lt;&lt;\&quot; expected&quot;; break;
+			case 36: s = &quot;\&quot;&gt;&gt;\&quot; expected&quot;; break;
+			case 37: s = &quot;\&quot;+=\&quot; expected&quot;; break;
+			case 38: s = &quot;\&quot;-=\&quot; expected&quot;; break;
+			case 39: s = &quot;\&quot;*=\&quot; expected&quot;; break;
+			case 40: s = &quot;\&quot;/=\&quot; expected&quot;; break;
+			case 41: s = &quot;\&quot;%=\&quot; expected&quot;; break;
+			case 42: s = &quot;\&quot;&amp;=\&quot; expected&quot;; break;
+			case 43: s = &quot;\&quot;|=\&quot; expected&quot;; break;
+			case 44: s = &quot;\&quot;^=\&quot; expected&quot;; break;
+			case 45: s = &quot;\&quot;&lt;&lt;=\&quot; expected&quot;; break;
+			case 46: s = &quot;\&quot;&gt;&gt;=\&quot; expected&quot;; break;
+			case 47: s = &quot;\&quot;-&gt;\&quot; expected&quot;; break;
+			case 48: s = &quot;\&quot;abstract\&quot; expected&quot;; break;
+			case 49: s = &quot;\&quot;as\&quot; expected&quot;; break;
+			case 50: s = &quot;\&quot;base\&quot; expected&quot;; break;
+			case 51: s = &quot;\&quot;bool\&quot; expected&quot;; break;
+			case 52: s = &quot;\&quot;break\&quot; expected&quot;; break;
+			case 53: s = &quot;\&quot;byte\&quot; expected&quot;; break;
+			case 54: s = &quot;\&quot;case\&quot; expected&quot;; break;
+			case 55: s = &quot;\&quot;catch\&quot; expected&quot;; break;
+			case 56: s = &quot;\&quot;char\&quot; expected&quot;; break;
+			case 57: s = &quot;\&quot;checked\&quot; expected&quot;; break;
+			case 58: s = &quot;\&quot;class\&quot; expected&quot;; break;
+			case 59: s = &quot;\&quot;const\&quot; expected&quot;; break;
+			case 60: s = &quot;\&quot;continue\&quot; expected&quot;; break;
+			case 61: s = &quot;\&quot;decimal\&quot; expected&quot;; break;
+			case 62: s = &quot;\&quot;default\&quot; expected&quot;; break;
+			case 63: s = &quot;\&quot;delegate\&quot; expected&quot;; break;
+			case 64: s = &quot;\&quot;do\&quot; expected&quot;; break;
+			case 65: s = &quot;\&quot;double\&quot; expected&quot;; break;
+			case 66: s = &quot;\&quot;else\&quot; expected&quot;; break;
+			case 67: s = &quot;\&quot;enum\&quot; expected&quot;; break;
+			case 68: s = &quot;\&quot;event\&quot; expected&quot;; break;
+			case 69: s = &quot;\&quot;explicit\&quot; expected&quot;; break;
+			case 70: s = &quot;\&quot;extern\&quot; expected&quot;; break;
+			case 71: s = &quot;\&quot;false\&quot; expected&quot;; break;
+			case 72: s = &quot;\&quot;finally\&quot; expected&quot;; break;
+			case 73: s = &quot;\&quot;fixed\&quot; expected&quot;; break;
+			case 74: s = &quot;\&quot;float\&quot; expected&quot;; break;
+			case 75: s = &quot;\&quot;for\&quot; expected&quot;; break;
+			case 76: s = &quot;\&quot;foreach\&quot; expected&quot;; break;
+			case 77: s = &quot;\&quot;goto\&quot; expected&quot;; break;
+			case 78: s = &quot;\&quot;if\&quot; expected&quot;; break;
+			case 79: s = &quot;\&quot;implicit\&quot; expected&quot;; break;
+			case 80: s = &quot;\&quot;in\&quot; expected&quot;; break;
+			case 81: s = &quot;\&quot;int\&quot; expected&quot;; break;
+			case 82: s = &quot;\&quot;interface\&quot; expected&quot;; break;
+			case 83: s = &quot;\&quot;internal\&quot; expected&quot;; break;
+			case 84: s = &quot;\&quot;is\&quot; expected&quot;; break;
+			case 85: s = &quot;\&quot;lock\&quot; expected&quot;; break;
+			case 86: s = &quot;\&quot;long\&quot; expected&quot;; break;
+			case 87: s = &quot;\&quot;namespace\&quot; expected&quot;; break;
+			case 88: s = &quot;\&quot;new\&quot; expected&quot;; break;
+			case 89: s = &quot;\&quot;null\&quot; expected&quot;; break;
+			case 90: s = &quot;\&quot;object\&quot; expected&quot;; break;
+			case 91: s = &quot;\&quot;operator\&quot; expected&quot;; break;
+			case 92: s = &quot;\&quot;out\&quot; expected&quot;; break;
+			case 93: s = &quot;\&quot;override\&quot; expected&quot;; break;
+			case 94: s = &quot;\&quot;params\&quot; expected&quot;; break;
+			case 95: s = &quot;\&quot;private\&quot; expected&quot;; break;
+			case 96: s = &quot;\&quot;protected\&quot; expected&quot;; break;
+			case 97: s = &quot;\&quot;public\&quot; expected&quot;; break;
+			case 98: s = &quot;\&quot;readonly\&quot; expected&quot;; break;
+			case 99: s = &quot;\&quot;ref\&quot; expected&quot;; break;
+			case 100: s = &quot;\&quot;return\&quot; expected&quot;; break;
+			case 101: s = &quot;\&quot;sbyte\&quot; expected&quot;; break;
+			case 102: s = &quot;\&quot;sealed\&quot; expected&quot;; break;
+			case 103: s = &quot;\&quot;short\&quot; expected&quot;; break;
+			case 104: s = &quot;\&quot;sizeof\&quot; expected&quot;; break;
+			case 105: s = &quot;\&quot;stackalloc\&quot; expected&quot;; break;
+			case 106: s = &quot;\&quot;static\&quot; expected&quot;; break;
+			case 107: s = &quot;\&quot;string\&quot; expected&quot;; break;
+			case 108: s = &quot;\&quot;struct\&quot; expected&quot;; break;
+			case 109: s = &quot;\&quot;switch\&quot; expected&quot;; break;
+			case 110: s = &quot;\&quot;this\&quot; expected&quot;; break;
+			case 111: s = &quot;\&quot;throw\&quot; expected&quot;; break;
+			case 112: s = &quot;\&quot;true\&quot; expected&quot;; break;
+			case 113: s = &quot;\&quot;try\&quot; expected&quot;; break;
+			case 114: s = &quot;\&quot;typeof\&quot; expected&quot;; break;
+			case 115: s = &quot;\&quot;uint\&quot; expected&quot;; break;
+			case 116: s = &quot;\&quot;ulong\&quot; expected&quot;; break;
+			case 117: s = &quot;\&quot;unchecked\&quot; expected&quot;; break;
+			case 118: s = &quot;\&quot;unsafe\&quot; expected&quot;; break;
+			case 119: s = &quot;\&quot;ushort\&quot; expected&quot;; break;
+			case 120: s = &quot;\&quot;using\&quot; expected&quot;; break;
+			case 121: s = &quot;\&quot;virtual\&quot; expected&quot;; break;
+			case 122: s = &quot;\&quot;void\&quot; expected&quot;; break;
+			case 123: s = &quot;\&quot;volatile\&quot; expected&quot;; break;
+			case 124: s = &quot;\&quot;while\&quot; expected&quot;; break;
+			case 125: s = &quot;??? expected&quot;; break;
+			case 126: s = &quot;invalid NamespaceMemberDecl&quot;; break;
+			case 127: s = &quot;invalid AttributeArguments&quot;; break;
+			case 128: s = &quot;invalid Expr&quot;; break;
+			case 129: s = &quot;invalid TypeModifier&quot;; break;
+			case 130: s = &quot;invalid TypeDecl&quot;; break;
+			case 131: s = &quot;invalid TypeDecl&quot;; break;
+			case 132: s = &quot;invalid IntegralType&quot;; break;
+			case 133: s = &quot;invalid Type&quot;; break;
+			case 134: s = &quot;invalid Type&quot;; break;
+			case 135: s = &quot;invalid FormalParameterList&quot;; break;
+			case 136: s = &quot;invalid FormalParameterList&quot;; break;
+			case 137: s = &quot;invalid ClassType&quot;; break;
+			case 138: s = &quot;invalid MemberModifier&quot;; break;
+			case 139: s = &quot;invalid ClassMemberDecl&quot;; break;
+			case 140: s = &quot;invalid ClassMemberDecl&quot;; break;
+			case 141: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 142: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 143: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 144: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 145: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 146: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 147: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 148: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 149: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 150: s = &quot;invalid StructMemberDecl&quot;; break;
+			case 151: s = &quot;invalid InterfaceMemberDecl&quot;; break;
+			case 152: s = &quot;invalid InterfaceMemberDecl&quot;; break;
+			case 153: s = &quot;invalid InterfaceMemberDecl&quot;; break;
+			case 154: s = &quot;invalid SimpleType&quot;; break;
+			case 155: s = &quot;invalid NonArrayType&quot;; break;
+			case 156: s = &quot;invalid EventAccessorDecls&quot;; break;
+			case 157: s = &quot;invalid ConstructorInitializer&quot;; break;
+			case 158: s = &quot;invalid OverloadableOperator&quot;; break;
+			case 159: s = &quot;invalid AccessorDecls&quot;; break;
+			case 160: s = &quot;invalid InterfaceAccessors&quot;; break;
+			case 161: s = &quot;invalid InterfaceAccessors&quot;; break;
+			case 162: s = &quot;invalid GetAccessorDecl&quot;; break;
+			case 163: s = &quot;invalid SetAccessorDecl&quot;; break;
+			case 164: s = &quot;invalid VariableInitializer&quot;; break;
+			case 165: s = &quot;invalid Statement&quot;; break;
+			case 166: s = &quot;invalid AssignmentOperator&quot;; break;
+			case 167: s = &quot;invalid LocalVariableInitializer&quot;; break;
+			case 168: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 169: s = &quot;invalid EmbeddedStatement&quot;; break;
+			case 170: s = &quot;invalid StatementExpr&quot;; break;
+			case 171: s = &quot;invalid ForInitializer&quot;; break;
+			case 172: s = &quot;invalid GotoStatement&quot;; break;
+			case 173: s = &quot;invalid TryStatement&quot;; break;
+			case 174: s = &quot;invalid ResourceAcquisition&quot;; break;
+			case 175: s = &quot;invalid SwitchLabel&quot;; break;
+			case 176: s = &quot;invalid CatchClauses&quot;; break;
+			case 177: s = &quot;invalid PrimaryExpr&quot;; break;
+			case 178: s = &quot;invalid PrimaryExpr&quot;; break;
+			case 179: s = &quot;invalid PrimaryExpr&quot;; break;
+			case 180: s = &quot;invalid PrimaryExpr&quot;; break;
+			case 181: s = &quot;invalid PrimaryExpr&quot;; break;
+			case 182: s = &quot;invalid PrimaryExpr&quot;; break;
+			case 183: s = &quot;invalid RelationalExpr&quot;; break;
+			case 184: s = &quot;invalid RelationalExpr&quot;; break;
+
+			default: s = &quot;error &quot; + errorNumber; break;
+		}
+		errors.Error(line, col, s);
+	}
+
+	static bool[,] set = {
+	{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x},
+	{x,T,T,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,T,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,T,x,x, T,T,x,x, x,T,x,x, x,T,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, T,T,T,x, x,x,x,x, x,x,x,x, x,T,x,T, T,x,x,T, x,x,T,x, T,x,T,T, T,T,x,T, x,x,x,x, x,x,x},
+	{x,x,x,x, T,T,T,T, T,T,T,T, T,x,x,T, x,T,x,T, T,T,x,T, T,x,T,T, T,x,x,T, T,T,T,T, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,T, x,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,T,x, T,x,T,x, x,x,x,T, x,T,x,T, x,x,x,T, x,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, T,x,T,T, x,T,x,T, x,T,x,T, T,T,T,x, x,x,T,x, x,x,x,T, x,T,T,T, x,x,T,x, T,x,T,x, x,T,x,T, T,T,T,x, x,T,T,T, x,x,T,T, T,x,x,x, x,x,x,T, T,x,T,T, x,T,T,T, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,T,x,T, T,T,T,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,x,T, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, T,x,T,T, x,T,x,T, x,T,x,T, T,T,T,x, x,x,T,x, x,x,x,T, x,T,T,T, x,x,T,x, T,x,T,x, x,T,x,T, T,T,T,x, x,T,T,T, x,x,T,T, T,x,x,x, x,x,x,T, T,x,T,T, x,T,T,T, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, T,x,T,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,T, x,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,T, x,x,x,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, x,T,x,T, x,x,x,T, x,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,T,T, x,T,x,T, x,T,x,T, T,T,x,x, x,x,T,x, x,x,x,T, x,T,T,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,T, T,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, T,x,x,x, x,T,x,x, x,T,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,T, x,x,x,x, x,x,x,T, T,x,x,T, x,x,T,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,T, x,x,x,x, x,x,x},
+	{x,T,T,x, T,T,T,x, x,x,T,x, x,x,T,x, x,x,T,x, x,x,T,x, x,T,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, T,T,x,T, T,T,x,x, T,T,x,x, x,x,x,T, x,T,T,T, T,T,T,x, x,T,x,x, x,T,T,x, T,T,T,x, x,x,x,x, x,x,x,x, T,T,x,T, T,x,x,T, x,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, T,x,x},
+	{x,T,T,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,T,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,T,x,x, T,T,x,x, x,T,x,x, x,T,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, T,T,T,x, T,x,x,x, x,x,x,T, x,T,x,T, T,x,x,T, x,x,T,x, T,x,T,T, T,T,x,T, x,x,x,x, x,x,x},
+	{x,T,T,x, T,T,T,x, x,x,T,x, x,x,T,x, x,x,T,x, x,x,T,x, x,T,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, T,T,x,x, T,T,x,x, T,T,x,x, x,x,x,T, x,T,T,T, T,T,T,x, x,T,x,x, x,T,T,x, T,T,T,x, x,x,x,x, x,x,x,x, T,T,x,T, T,x,x,T, x,T,T,T, T,T,T,T, T,T,T,T, T,x,x,x, T,x,x},
+	{x,T,T,x, T,T,T,x, x,x,x,x, x,x,T,x, x,x,T,x, x,x,T,x, x,T,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,T,x,x, T,T,x,x, x,T,x,x, x,T,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,x, T,T,T,x, x,x,x,x, x,x,x,x, x,T,x,T, T,T,x,T, x,x,T,x, T,x,T,T, T,T,x,T, x,x,x,x, x,x,x},
+	{x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,T,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
+	{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x}
+
+	};
+} // end Parser
+
+}
\ No newline at end of file

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Parser.frame
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Parser.frame	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Parser.frame	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,120 @@
+using System;
+using System.Reflection;
+
+--&gt;namespace
+
+--&gt;tokens
+
+public class Parser
+{
+--&gt;constants
+	const  bool   T            = true;
+	const  bool   x            = false;
+	const  int    minErrDist   = 2;
+	const  string errMsgFormat = &quot;-- line {0} col {1}: {2}&quot;;  // 0=line, 1=column, 2=text
+	int    errDist             = minErrDist;
+	Errors errors;
+	Lexer  lexer;
+
+	public Errors Errors {
+		get {
+			return errors;
+		}
+	}
+
+--&gt;declarations
+
+/*
+--&gt;pragmas
+*/
+	void SynErr(int n)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.SynErr(lexer.LookAhead.line, lexer.LookAhead.col, n);
+		}
+		errDist = 0;
+	}
+
+	public void SemErr(string msg)
+	{
+		if (errDist &gt;= minErrDist) {
+			errors.Error(lexer.Token.line, lexer.Token.col, msg);
+		}
+		errDist = 0;
+	}
+	
+	void Expect(int n)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+		}
+	}
+	
+	bool StartOf(int s)
+	{
+		return set[s, lexer.LookAhead.kind];
+	}
+	
+	void ExpectWeak(int n, int follow)
+	{
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+		} else {
+			SynErr(n);
+			while (!StartOf(follow)) {
+				lexer.NextToken();
+			}
+		}
+	}
+	
+	bool WeakSeparator(int n, int syFol, int repFol)
+	{
+		bool[] s = new bool[maxT + 1];
+		
+		if (lexer.LookAhead.kind == n) {
+			lexer.NextToken();
+			return true; 
+		} else if (StartOf(repFol)) {
+			return false;
+		} else {
+			for (int i = 0; i &lt;= maxT; i++) {
+				s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
+			}
+			SynErr(n);
+			while (!s[lexer.LookAhead.kind]) {
+				lexer.NextToken();
+			}
+			return StartOf(syFol);
+		}
+	}
+	
+--&gt;productions
+
+	public void Parse(Lexer lexer)
+	{
+		this.errors = lexer.Errors;
+		this.lexer = lexer;
+		errors.SynErr = new ErrorCodeProc(SynErr);
+		lexer.NextToken();
+--&gt;parseRoot
+	}
+
+	void SynErr(int line, int col, int errorNumber)
+	{
+		errors.count++; 
+		string s;
+		switch (errorNumber) {
+--&gt;errors
+			default: s = &quot;error &quot; + errorNumber; break;
+		}
+		errors.Error(line, col, s);
+	}
+
+	static bool[,] set = {
+--&gt;initialization
+	};
+} // end Parser
+
+$$$

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/ParserUtil.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/ParserUtil.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/ParserUtil.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,38 @@
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public sealed class ParserUtil
+	{
+		public static bool IsUnaryOperator(Token t)
+		{
+			return t.kind == Tokens.Plus      || t.kind == Tokens.Minus             ||
+			       t.kind == Tokens.Not       || t.kind == Tokens.BitwiseComplement ||
+			       t.kind == Tokens.Increment || t.kind == Tokens.Decrement         ||
+			       t.kind == Tokens.True      || t.kind == Tokens.False;
+		}
+		
+		public static bool IsBinaryOperator (Token t)
+		{
+			return t.kind == Tokens.Plus  || t.kind == Tokens.Minus ||
+			       t.kind == Tokens.Times || t.kind == Tokens.Div   ||
+			       t.kind == Tokens.Mod   ||
+			       t.kind == Tokens.BitwiseAnd   || t.kind == Tokens.BitwiseOr  ||
+			       t.kind == Tokens.Xor          ||
+			       t.kind == Tokens.ShiftLeft    || t.kind == Tokens.ShiftRight ||
+			       t.kind == Tokens.Equal        || t.kind == Tokens.NotEqual   ||
+			       t.kind == Tokens.GreaterThan  || t.kind == Tokens.LessThan   ||
+			       t.kind == Tokens.GreaterEqual || t.kind == Tokens.LessEqual;
+		}
+		
+		public static bool IsTypeKW(Token t)
+		{
+			return t.kind == Tokens.Char    || t.kind == Tokens.Bool   ||
+			       t.kind == Tokens.Object  || t.kind == Tokens.String ||
+			       t.kind == Tokens.Sbyte   || t.kind == Tokens.Byte   ||
+			       t.kind == Tokens.Short   || t.kind == Tokens.Ushort ||
+			       t.kind == Tokens.Int     || t.kind == Tokens.Uint   ||
+			       t.kind == Tokens.Long    || t.kind == Tokens.Ulong  ||
+			       t.kind == Tokens.Float   || t.kind == Tokens.Double ||
+			       t.kind == Tokens.Decimal;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Scanner.frame
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Scanner.frame	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/Scanner.frame	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,222 @@
+using System;
+using System.Drawing;
+using System.IO;
+using System.Collections;
+using System.Text;
+
+--&gt;namespace
+
+public class Token {
+	public int kind;    // token kind
+	public int pos;     // token position in the source text (starting at 0)
+	public int col;     // token column (starting at 0)
+	public int line;    // token line (starting at 1)
+	public string val;  // token value
+	public Token next;  // AW 2003-03-07 Tokens are kept in linked list
+	
+	public Point Location {
+		get {
+			return new Point(line, col);
+		}
+	}
+
+	public Token () { }
+	public Token (int kind) { this.kind = kind; }
+}
+
+public class Buffer {
+	public const int eof = '\uffff';
+
+	static byte[] buf;
+	static int bufLen;
+	static int pos;
+	
+	public static void Fill (string fileName) {
+		FileStream s = null;
+		try {
+			s = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
+			Fill(s);
+		} catch (IOException) {
+			Console.WriteLine(&quot;--- Cannot open file {0}&quot;, fileName);
+			System.Environment.Exit(0);
+		} finally {
+			if (s != null) s.Close();
+		}
+	}
+	
+	public static void Fill (Stream s) {
+		bufLen = (int) s.Length;
+		buf = new byte[bufLen];
+		s.Read(buf, 0, bufLen); 
+		pos = 0;
+	}
+		
+	public static int Read () {
+		if (pos &lt; bufLen) return buf[pos++];
+		else return 0;
+	}
+
+	public static int Peek () {
+		if (pos &lt; bufLen) return buf[pos];
+		else return 0;
+	}
+	
+	/* AW 2003-03-10 moved this from ParserGen.cs */
+	public static string GetString (int beg, int end) {
+		StringBuilder s = new StringBuilder(64);
+		int oldPos = Buffer.Pos;
+		Buffer.Pos = beg;
+		while (beg &lt; end) { s.Append((char)Buffer.Read()); beg++; }
+		Buffer.Pos = oldPos;
+		return s.ToString();
+	}
+
+	public static int Pos {
+		get { return pos; }
+		set {
+			if (value &lt; 0) pos = 0; 
+			else if (value &gt;= bufLen) pos = bufLen; 
+			else pos = value;
+		}
+	}
+}
+
+public class Scanner {
+	const char EOF = '\0';
+	const char EOL = '\n';
+	const char CR  = '\n';
+
+--&gt;constants
+	
+--&gt;declarations
+
+	static Token t;          // current token
+	static char ch;          // current input character
+	static int pos;          // column number of current character
+	static int line;         // line number of current character
+	static int lineStart;    // start position of current line
+	static int oldEols;    // EOLs that appeared in a comment;
+	static BitArray ignore;  // set of characters to be ignored by the scanner
+
+	/* ML ----- begin */
+	static Token tokens;  // the complete input token stream
+	static Token pt;      // current peek token
+	
+	static int peekCount = 0;
+	
+	public static int PeekCount { get { return peekCount; } }
+	
+	static void Init()
+	{
+		pos = -1; line = 1; lineStart = 0;
+		oldEols = 0;
+		NextCh();
+--&gt;initialization
+
+		/* AW 2003-03-07 fill token list */
+		tokens = new Token();  // first token is a dummy
+		Token node = tokens;
+		do {
+			node.next = NextToken();
+			node = node.next;
+		} while (node.kind != 0);	/* AW: 0 =&gt; EOF */
+		t = pt = tokens;
+	}
+
+	public static void Init(String fileName) {
+		Buffer.Fill(fileName);
+		Init();
+	}
+	
+	public static void Init(Stream s) {
+		Buffer.Fill(s);
+		Init();
+	}
+
+	static void NextCh() {
+		if (oldEols &gt; 0) { ch = EOL; oldEols--; } 
+		else {
+			ch = (char)Buffer.Read(); pos++;
+			// replace isolated '\r' by '\n' in order to make
+			// eol handling uniform across Windows, Unix and Mac
+			if (ch == '\r' &amp;&amp; Buffer.Peek() != '\n') ch = EOL;
+			else if (ch &gt; '\u007f') ch = '?';
+			if (ch == EOL) { line++; lineStart = pos + 1; }
+		}
+	}
+	
+--&gt;comment
+	
+	static void CheckLiteral() {
+		switch (t.val) {
+--&gt;literals
+		}
+	}
+
+	/* AW Scan() renamed to NextToken() */
+	static Token NextToken() {
+		while (ignore[ch]) NextCh();
+--&gt;scan1
+		t = new Token();
+		t.pos = pos; t.col = pos - lineStart + 1; t.line = line; 
+		int state = start[ch];
+		StringBuilder buf = new StringBuilder(16);
+		buf.Append(ch); NextCh();
+		
+		switch (state) {
+			case 0: { t.kind = noSym; goto done; }  // NextCh already done
+--&gt;scan2
+		}
+		done: 
+		t.val = buf.ToString();
+		return t;
+	}
+	
+	/* AW 2003-03-07 get the next token, move on and synch peek token with current */
+	public static Token Scan () {
+		t = pt = t.next;
+		return t;
+	}
+
+	/* AW 2003-03-07 get the next token, ignore pragmas */
+	public static Token Peek () {
+		do {                      // skip pragmas while peeking
+			pt = pt.next;
+		} while (pt != null &amp;&amp; pt.kind &gt; maxT);
+		return pt;
+	}
+	
+	/* AW 2003-03-11 to make sure peek start at current scan position */
+	public static void StartPeek () { pt = t; }
+} // end Scanner
+
+
+public delegate void ErrorCodeProc (int line, int col, int n);
+public delegate void ErrorMsgProc (int line, int col, string msg);
+
+public class Errors {
+	public static int count = 0;                                               // number of errors detected
+	public static ErrorCodeProc SynErr = new ErrorCodeProc(DefaultCodeError);  // syntactic errors
+	public static ErrorCodeProc SemErr = new ErrorCodeProc(DefaultCodeError);  // semantic errors
+	public static ErrorMsgProc Error = new ErrorMsgProc(DefaultMsgError);      // user defined string based errors
+	public static StringBuilder errorText = new StringBuilder();
+	
+	public static void Exception (string s) {
+		Console.WriteLine(s); 
+		System.Environment.Exit(0);
+	}
+
+	static void DefaultCodeError (int line, int col, int n) {
+		errorText.Append(String.Format(&quot;-- line {0} col {1}: error {2}&quot;, line, col, n));
+		errorText.Append(&quot;\n&quot;);
+		count++;
+	}
+
+	static void DefaultMsgError (int line, int col, string s) {
+		errorText.Append(String.Format(&quot;-- line {0} col {1}: {2}&quot;, line, col, s));
+		errorText.Append(&quot;\n&quot;);
+		count++;
+	}
+} // Errors
+
+$$$

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/SharpCoco.exe
===================================================================
(Binary files differ)


Property changes on: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/SharpCoco.exe
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/cs.ATG
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/cs.ATG	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/cs.ATG	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,1975 @@
+using System.Drawing;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+COMPILER CS    /* AW 2002-12-30 renamed from CompilationUnit to CS */
+
+string assemblyName = null;
+
+public CompilationUnit compilationUnit;
+
+public string ContainingAssembly {
+	set {
+		assemblyName = value;
+	}
+}
+
+Token t {
+	get {
+		return lexer.Token;
+	}
+}
+Token la {
+	get {
+		return lexer.LookAhead;
+	}
+}
+
+Hashtable typeStrings     = null;
+ArrayList usingNamespaces = null;
+
+public void Error(string s)
+{
+	if (errDist &gt;= minErrDist) {
+		errors.Error(la.line, la.col, s);
+	}
+	errDist = 0;
+}
+
+public Expression ParseExpression(Lexer lexer)
+{
+	this.errors = lexer.Errors;
+	this.lexer = lexer;
+	errors.SynErr = new ErrorCodeProc(SynErr);
+	lexer.NextToken();
+	Expression expr;
+	Expr(out expr);
+	return expr;
+}
+
+bool IsTypeCast()
+{
+	if (IsSimpleTypeCast()) {
+		return true;
+	}
+	
+	if (assemblyName != null) {
+		return CheckTypeCast();
+	}
+	
+	return GuessTypeCast();
+}
+
+bool IsSimpleTypeCast()
+{
+	// check: &quot;(&quot; pointer or array of keyword type &quot;)&quot;
+	
+	if (la.kind != Tokens.OpenParenthesis) {
+		return false;
+	}
+
+	StartPeek();
+	Token pt1 = Peek();
+	Token pt  = Peek();
+	
+	return ParserUtil.IsTypeKW(pt1) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp;
+	       pt.kind == Tokens.CloseParenthesis;
+}
+
+bool CheckTypeCast()
+{
+	// check: leading &quot;(&quot; pointer or array of some type &quot;)&quot;
+
+	if (la.kind != Tokens.OpenParenthesis) {
+		return false;
+	}
+	
+	string qualident;
+	
+	StartPeek();
+	Token pt = Peek();
+	
+	return IsQualident(ref pt, out qualident) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	       pt.kind == Tokens.CloseParenthesis &amp;&amp; IsType(qualident);		
+}
+
+bool IsType(string qualident)
+{
+	if (typeStrings == null) {
+		CreateTypeStrings();
+	}
+	
+	if (typeStrings.ContainsValue(qualident)) {
+		return true;
+	}
+	
+	foreach (string ns in usingNamespaces) {
+		if (typeStrings.ContainsValue(ns + &quot;.&quot; + qualident)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+bool GuessTypeCast()
+{
+	// check: &quot;(&quot; pointer or array of some type &quot;)&quot; possible type cast successor
+	
+	if (la.kind != Tokens.OpenParenthesis) return false;
+	
+	string qualident;
+	
+	StartPeek();
+	Token pt = Peek();
+	
+	if (IsQualident(ref pt, out qualident) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	    pt.kind == Tokens.CloseParenthesis) {
+		// check successor
+		pt = Peek();
+		return pt.kind == Tokens.Identifier || pt.kind == Tokens.Literal   ||
+		       pt.kind == Tokens.OpenParenthesis   || ParserUtil.IsUnaryOperator(pt)         ||
+		       pt.kind == Tokens.New        || pt.kind == Tokens.This      ||
+		       pt.kind == Tokens.Base       || pt.kind == Tokens.Null      ||
+		       pt.kind == Tokens.Checked    || pt.kind == Tokens.Unchecked ||
+		       pt.kind == Tokens.Typeof     || pt.kind == Tokens.Sizeof    ||
+		       (ParserUtil.IsTypeKW(pt) &amp;&amp; Peek().kind == Tokens.Dot);
+	} else return false;
+}
+
+void CreateTypeStrings()
+{
+	Assembly a;
+	Type[] types;
+	AssemblyName [] aNames;
+	
+	if (assemblyName != null &amp;&amp; assemblyName.Length &gt; 0) {    /* AW 2002-12-30 add check for length &gt; 0 */
+		typeStrings = new Hashtable();
+		a = Assembly.LoadFrom(assemblyName);
+		types = a.GetTypes();
+		foreach (Type t in types) 
+			typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
+		aNames = a.GetReferencedAssemblies();
+		
+		for (int i = 0; i &lt; aNames.Length; i++) {
+			a = Assembly.LoadFrom(aNames[i].Name);
+			types = a.GetExportedTypes();
+			
+			foreach(Type t in types)
+				if (usingNamespaces.Contains(t.FullName.Substring(0, t.FullName.LastIndexOf('.'))))
+					typeStrings.Add(t.FullName.GetHashCode(), t.FullName);
+		}
+	}
+}
+
+/* Checks whether the next sequences of tokens is a qualident *
+ * and returns the qualident string                           */
+/* !!! Proceeds from current peek position !!! */
+bool IsQualident (ref Token pt, out string qualident)
+{
+	qualident = &quot;&quot;;
+	if (pt.kind == Tokens.Identifier) {
+		qualident = pt.val;
+		pt = Peek();
+		while (pt.kind == Tokens.Dot) {
+			pt = Peek();
+			if (pt.kind != Tokens.Identifier) return false;
+			qualident += &quot;.&quot; + pt.val;
+			pt = Peek();
+		}
+		return true;
+	} else return false;
+}
+
+/* skip: { &quot;*&quot; | &quot;[&quot; { &quot;,&quot; } &quot;]&quot; } */
+/* !!! Proceeds from current peek position !!! */
+bool IsPointerOrDims (ref Token pt)
+{
+	for (;;) {
+		if (pt.kind == Tokens.OpenSquareBracket) {
+			do pt = Peek();
+			while (pt.kind == Tokens.Comma);
+			if (pt.kind != Tokens.CloseSquareBracket) return false;
+		} else if (pt.kind != Tokens.Times) break;
+		pt = Peek();
+	}
+	return true;
+}
+
+/* Return the n-th token after the current lookahead token */
+void StartPeek()
+{
+	lexer.StartPeek();
+}
+
+Token Peek()
+{
+	return lexer.Peek();
+}
+
+Token Peek (int n)
+{
+	lexer.StartPeek();
+	Token x = la;
+	while (n &gt; 0) {
+		x = lexer.Peek();
+		n--;
+	}
+	return x;
+}
+
+/*-----------------------------------------------------------------*
+ * Resolver routines to resolve LL(1) conflicts:                   *                                                  *
+ * These resolution routine return a boolean value that indicates  *
+ * whether the alternative at hand shall be choosen or not.        *
+ * They are used in IF ( ... ) expressions.                        *       
+ *-----------------------------------------------------------------*/
+
+/* True, if ident is followed by &quot;=&quot; */
+bool IdentAndAsgn ()
+{
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.Assign;
+}
+
+bool IsAssignment () { return IdentAndAsgn(); }
+
+/* True, if ident is followed by &quot;,&quot;, &quot;=&quot;, or &quot;;&quot; */
+bool IdentAndCommaOrAsgnOrSColon () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Identifier &amp;&amp; 
+	       (peek == Tokens.Comma || peek == Tokens.Assign || peek == Tokens.Semicolon);
+}
+bool IsVarDecl () { return IdentAndCommaOrAsgnOrSColon(); }
+
+/* True, if the comma is not a trailing one, *
+ * like the last one in: a, b, c,            */
+bool NotFinalComma () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.Comma &amp;&amp;
+	       peek != Tokens.CloseCurlyBrace &amp;&amp; peek != Tokens.CloseSquareBracket;
+}
+
+/* True, if &quot;void&quot; is followed by &quot;*&quot; */
+bool NotVoidPointer () {
+	return la.kind == Tokens.Void &amp;&amp; Peek(1).kind != Tokens.Times;
+}
+
+/* True, if &quot;checked&quot; or &quot;unchecked&quot; are followed by &quot;{&quot; */
+bool UnCheckedAndLBrace () {
+	return la.kind == Tokens.Checked || la.kind == Tokens.Unchecked &amp;&amp;
+	       Peek(1).kind == Tokens.OpenCurlyBrace;
+}
+
+/* True, if &quot;.&quot; is followed by an ident */
+bool DotAndIdent () {
+	return la.kind == Tokens.Dot &amp;&amp; Peek(1).kind == Tokens.Identifier;
+}
+
+/* True, if ident is followed by &quot;:&quot; */
+bool IdentAndColon () {
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.Colon;
+}
+
+bool IsLabel () { return IdentAndColon(); }
+
+/* True, if ident is followed by &quot;(&quot; */
+bool IdentAndLPar () {
+	return la.kind == Tokens.Identifier &amp;&amp; Peek(1).kind == Tokens.OpenParenthesis;
+}
+
+/* True, if &quot;catch&quot; is followed by &quot;(&quot; */
+bool CatchAndLPar () {
+	return la.kind == Tokens.Catch &amp;&amp; Peek(1).kind == Tokens.OpenParenthesis;
+}
+bool IsTypedCatch () { return CatchAndLPar(); }
+
+/* True, if &quot;[&quot; is followed by the ident &quot;assembly&quot; */
+bool IsGlobalAttrTarget () {
+	Token pt = Peek(1);
+	return la.kind == Tokens.OpenSquareBracket &amp;&amp; 
+	       pt.kind == Tokens.Identifier &amp;&amp; pt.val == &quot;assembly&quot;;
+}
+
+/* True, if &quot;[&quot; is followed by &quot;,&quot; or &quot;]&quot; */
+bool LBrackAndCommaOrRBrack () {
+	int peek = Peek(1).kind;
+	return la.kind == Tokens.OpenSquareBracket &amp;&amp;
+	       (peek == Tokens.Comma || peek == Tokens.CloseSquareBracket);
+}
+
+bool IsDims () { return LBrackAndCommaOrRBrack(); }
+
+/* True, if &quot;[&quot; is followed by &quot;,&quot; or &quot;]&quot; *
+ * or if the current token is &quot;*&quot;         */
+bool TimesOrLBrackAndCommaOrRBrack () {
+	return la.kind == Tokens.Times || LBrackAndCommaOrRBrack();
+}
+bool IsPointerOrDims () { return TimesOrLBrackAndCommaOrRBrack(); }
+bool IsPointer () { return la.kind == Tokens.Times; }
+
+/* True, if lookahead is a primitive type keyword, or *
+ * if it is a type declaration followed by an ident   */
+bool IsLocalVarDecl () {
+	if ((ParserUtil.IsTypeKW(la) &amp;&amp; Peek(1).kind != Tokens.Dot) || la.kind == Tokens.Void) return true;
+	
+	StartPeek();
+	Token pt = la ;  // peek token
+	string ignore;
+	
+	return IsQualident(ref pt, out ignore) &amp;&amp; IsPointerOrDims(ref pt) &amp;&amp; 
+	       pt.kind == Tokens.Identifier;
+}
+
+/* True, if lookahead ident is &quot;get&quot; */
+bool IdentIsGet () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;get&quot;;
+}
+
+/* True, if lookahead ident is &quot;set&quot; */
+bool IdentIsSet () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;set&quot;;
+}
+
+/* True, if lookahead ident is &quot;add&quot; */
+bool IdentIsAdd () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;add&quot;;
+}
+
+/* True, if lookahead ident is &quot;remove&quot; */
+bool IdentIsRemove () {
+	return la.kind == Tokens.Identifier &amp;&amp; la.val == &quot;remove&quot;;
+}
+
+/* True, if lookahead is a local attribute target specifier, *
+ * i.e. one of &quot;event&quot;, &quot;return&quot;, &quot;field&quot;, &quot;method&quot;,         *
+ *             &quot;module&quot;, &quot;param&quot;, &quot;property&quot;, or &quot;type&quot;      */
+bool IsLocalAttrTarget () {
+	int cur = la.kind;
+	string val = la.val;
+
+	return (cur == Tokens.Event || cur == Tokens.Return ||
+	        (cur == Tokens.Identifier &amp;&amp;
+	         (val == &quot;field&quot; || val == &quot;method&quot;   || val == &quot;module&quot; ||
+	          val == &quot;param&quot; || val == &quot;property&quot; || val == &quot;type&quot;))) &amp;&amp;
+	       Peek(1).kind == Tokens.Colon;
+}
+
+
+/*------------------------------------------------------------------------*
+ *----- LEXER TOKEN LIST  ------------------------------------------------*
+ *------------------------------------------------------------------------*/
+TOKENS
+	/*----- terminal classes -----*/
+	/* EOF is 0 */
+	ident
+	literal
+	
+	/*----- special character -----*/
+	&quot;=&quot; /* 3 */
+	
+	&quot;+&quot;
+	&quot;-&quot;
+	&quot;*&quot;
+	&quot;/&quot;
+	&quot;%&quot;
+	
+	&quot;:&quot;
+	&quot;;&quot;
+	&quot;?&quot;
+	&quot;,&quot;
+	&quot;.&quot;
+	
+	&quot;{&quot;
+	&quot;}&quot;
+	
+	&quot;[&quot;
+	&quot;]&quot;
+	
+	&quot;(&quot;
+	&quot;)&quot;
+	
+	&quot;&gt;&quot;
+	&quot;&lt;&quot;
+	
+	&quot;!&quot;
+	&quot;&amp;&amp;&quot;
+	&quot;||&quot;
+	
+	&quot;~&quot;
+	&quot;&amp;&quot;
+	&quot;|&quot;
+	&quot;^&quot;
+
+	/*----- special character sequences -----*/
+	&quot;++&quot; /* 29 */
+	&quot;--&quot;
+	&quot;==&quot;
+	&quot;!=&quot;
+	&quot;&gt;=&quot;
+	&quot;&lt;=&quot;
+	
+	&quot;&lt;&lt;&quot;
+	&quot;&gt;&gt;&quot;
+	
+	&quot;+=&quot;
+	&quot;-=&quot;
+	&quot;*=&quot;
+	&quot;/=&quot;
+	&quot;%=&quot;
+	&quot;&amp;=&quot;
+	&quot;|=&quot;
+	&quot;^=&quot;
+	&quot;&lt;&lt;=&quot;
+	&quot;&gt;&gt;=&quot;
+	
+	&quot;-&gt;&quot;
+	
+	/*----- C# keywords -----*/
+	&quot;abstract&quot; /* 48 */
+	&quot;as&quot;
+	&quot;base&quot;
+	&quot;bool&quot;
+	&quot;break&quot;
+	&quot;byte&quot;
+	&quot;case&quot;
+	&quot;catch&quot;
+	&quot;char&quot;
+	&quot;checked&quot;
+	&quot;class&quot;
+	&quot;const&quot;
+	&quot;continue&quot;
+	&quot;decimal&quot;
+	&quot;default&quot;
+	&quot;delegate&quot;
+	&quot;do&quot;
+	&quot;double&quot;
+	&quot;else&quot;
+	&quot;enum&quot;
+	&quot;event&quot;
+	&quot;explicit&quot;
+	&quot;extern&quot;
+	&quot;false&quot;
+	&quot;finally&quot;
+	&quot;fixed&quot;
+	&quot;float&quot;
+	&quot;for&quot;
+	&quot;foreach&quot;
+	&quot;goto&quot;
+	&quot;if&quot;
+	&quot;implicit&quot;
+	&quot;in&quot;
+	&quot;int&quot;
+	&quot;interface&quot;
+	&quot;internal&quot;
+	&quot;is&quot;
+	&quot;lock&quot;
+	&quot;long&quot;
+	&quot;namespace&quot;
+	&quot;new&quot;
+	&quot;null&quot;
+	&quot;object&quot;
+	&quot;operator&quot;
+	&quot;out&quot;
+	&quot;override&quot;
+	&quot;params&quot;
+	&quot;private&quot;
+	&quot;protected&quot;
+	&quot;public&quot;
+	&quot;readonly&quot;
+	&quot;ref&quot;
+	&quot;return&quot;
+	&quot;sbyte&quot;
+	&quot;sealed&quot;
+	&quot;short&quot;
+	&quot;sizeof&quot;
+	&quot;stackalloc&quot;
+	&quot;static&quot;
+	&quot;string&quot;
+	&quot;struct&quot;
+	&quot;switch&quot;
+	&quot;this&quot;
+	&quot;throw&quot;
+	&quot;true&quot;
+	&quot;try&quot;
+	&quot;typeof&quot;
+	&quot;uint&quot;
+	&quot;ulong&quot;
+	&quot;unchecked&quot;
+	&quot;unsafe&quot;
+	&quot;ushort&quot;
+	&quot;using&quot;
+	&quot;virtual&quot;
+	&quot;void&quot;
+	&quot;volatile&quot;
+	&quot;while&quot;
+
+/*------------------------------------------------------------------------*
+ *----- PARSER -----------------------------------------------------------*
+ *------------------------------------------------------------------------*/
+
+PRODUCTIONS
+
+/*--- compilation unit: */
+CS
+(. compilationUnit = new CompilationUnit(); .)
+=
+	{ UsingDirective }
+	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
+	{ NamespaceMemberDecl }
+	EOF
+.
+
+UsingDirective
+(.
+	usingNamespaces = new ArrayList();
+	string qualident = null, aliasident = null;
+.)
+=
+	&quot;using&quot;                     (. Point startPos = t.Location;
+	                               INode node     = null; 
+	                            .)
+	[ IF (IsAssignment()) ident (. aliasident = t.val; .) &quot;=&quot;  ]  /*--- using alias directive */
+	Qualident&lt;out qualident&gt;    (. if (qualident != null &amp;&amp; qualident.Length &gt; 0) {
+	                                 if (aliasident != null) {
+	                                   node = new UsingAliasDeclaration(aliasident, qualident);
+	                                 } else {
+	                                     usingNamespaces.Add(qualident);
+	                                     node = new UsingDeclaration(qualident);
+	                                 }
+	                               }
+	                            .)
+	&quot;;&quot;                         (. node.StartLocation = startPos;
+	                               node.EndLocation   = t.EndLocation;
+	                               compilationUnit.AddChild(node);
+	                            .)
+.
+
+GlobalAttributeSection
+=
+	
+	&quot;[&quot; (. Point startPos = t.Location; .) ident                   (. if (t.val != &quot;assembly&quot;) Error(&quot;global attribute target specifier (\&quot;assembly\&quot;) expected&quot;);
+	                               string attributeTarget = t.val;
+	                               ArrayList attributes = new ArrayList();
+	                               ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
+	                            .)
+	&quot;:&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)
+	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
+	[ &quot;,&quot; ]
+	&quot;]&quot;                         (. AttributeSection section = new AttributeSection(attributeTarget, attributes);
+	                               section.StartLocation = startPos;
+	                               section.EndLocation = t.EndLocation;
+	                               compilationUnit.AddChild(section);
+	                            .)
+.
+
+Attribute&lt;out ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute&gt;
+(. string qualident; .)
+=
+	Qualident&lt;out qualident&gt;           (. ArrayList positional = new ArrayList();
+	                                      ArrayList named      = new ArrayList();
+	                                      string name = qualident;
+	                                   .)
+	[ AttributeArguments&lt;ref positional, ref named&gt; ] (. attribute  = new ICSharpCode.SharpRefactory.Parser.AST.Attribute(name, positional, named);.)
+.
+
+AttributeArguments&lt;ref ArrayList positional, ref ArrayList named&gt;
+(.
+	bool nameFound = false;
+	string name = &quot;&quot;;
+	Expression expr;
+.)
+=
+	&quot;(&quot;
+	[
+		[
+			IF (IsAssignment())          (. nameFound = true; .)
+			ident                        (. name = t.val; .)
+			&quot;=&quot;
+		] Expr&lt;out expr&gt;                 (. if(name == &quot;&quot;) positional.Add(expr);
+		                                    else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
+		                                 .)
+		
+		{
+			&quot;,&quot;
+				(
+					IF (IsAssignment())    (. nameFound = true; .)
+					ident                      (. name = t.val; .)
+					&quot;=&quot;
+					| /*Empty*/                (. if (nameFound) Error(&quot;no positional argument after named argument&quot;); .)
+				) Expr&lt;out expr&gt;           (. if(name == &quot;&quot;) positional.Add(expr);
+				                              else { named.Add(new NamedArgument(name, expr)); name = &quot;&quot;; }
+				                           .)
+		}
+	]
+	&quot;)&quot;
+.
+
+AttributeSection&lt;out AttributeSection section&gt;
+(.
+	string attributeTarget = &quot;&quot;;
+	ArrayList attributes = new ArrayList();
+	ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
+	
+.)
+=
+	&quot;[&quot; (. Point startPos = t.Location; .) /*--- attribute target specifier: */
+	[ IF (IsLocalAttrTarget())
+		( &quot;event&quot;                       (. attributeTarget = &quot;event&quot;;.)
+		| &quot;return&quot;                      (. attributeTarget = &quot;return&quot;;.)
+		| ident                         (. if (t.val != &quot;field&quot;    || t.val != &quot;method&quot; ||
+		                                      t.val != &quot;module&quot;   || t.val != &quot;param&quot;  ||
+		                                      t.val != &quot;property&quot; || t.val != &quot;type&quot;)
+		                                    Error(&quot;attribute target specifier (event, return, field,&quot; +
+		                                          &quot;method, module, param, property, or type) expected&quot;);
+		                                   attributeTarget = t.val;
+		                                .)
+		) &quot;:&quot; 
+	]
+	/*--- attribute list: */
+	Attribute&lt;out attribute&gt;            (. attributes.Add(attribute); .)
+	{ IF (NotFinalComma()) &quot;,&quot; Attribute&lt;out attribute&gt; (. attributes.Add(attribute); .)}
+	[ &quot;,&quot; ]
+	&quot;]&quot;                         (. section = new AttributeSection(attributeTarget, attributes);
+	                               section.StartLocation = startPos;
+	                               section.EndLocation = t.EndLocation;
+	                            .)
+.
+
+NamespaceMemberDecl
+(.
+	AttributeSection section;
+	ArrayList attributes = new ArrayList();
+	Modifiers m = new Modifiers(this);
+	string qualident;
+.)
+= /*--- namespace declaration: */
+	&quot;namespace&quot;                  (. Point startPos = t.Location; .)
+	Qualident&lt;out qualident&gt;     (. INode node =  new NamespaceDeclaration(qualident);
+	                                node.StartLocation = startPos;
+	                                compilationUnit.AddChild(node);
+	                                compilationUnit.BlockStart(node);
+	                              .)
+	&quot;{&quot;
+	{ UsingDirective }
+	{ NamespaceMemberDecl }
+	&quot;}&quot;
+	[ &quot;;&quot; ]                       (. node.EndLocation   = t.EndLocation;
+	                                 compilationUnit.BlockEnd();
+	                              .)
+	/*--- type declaration: */
+	| { AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	{ TypeModifier&lt;m&gt; }
+	TypeDecl&lt;m, attributes&gt;
+.
+
+TypeDecl&lt;Modifiers m, ArrayList attributes&gt;
+(.
+	TypeReference type;
+	StringCollection names;
+	ArrayList p; string name;
+.)
+= /*--- class declaration: */      (. m.Check(Modifier.Classes); .)
+	&quot;class&quot;                        (. TypeDeclaration newType = new TypeDeclaration();
+	                                  compilationUnit.AddChild(newType);
+	                                  compilationUnit.BlockStart(newType);
+	                                  
+	                                  newType.Type = Types.Class;
+	                                  newType.Modifier = m.Modifier;
+	                                  newType.Attributes = attributes;
+	                                .)
+	ident                           (. newType.Name = t.val; .)
+	[ ClassBase&lt;out names&gt;          (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
+	ClassBody
+	[ &quot;;&quot; ]                         (. newType.EndLocation = t.Location; 
+	                                   compilationUnit.BlockEnd();
+	                                .)
+	| /*--- struct declaration: */  (. m.Check(Modifier.StructsInterfacesEnumsDelegates); .)
+	( &quot;struct&quot;                      (. TypeDeclaration newType = new TypeDeclaration();
+	                                   compilationUnit.AddChild(newType);
+	                                   compilationUnit.BlockStart(newType);
+	                                   newType.Type = Types.Struct; 
+	                                   newType.Modifier = m.Modifier;
+	                                   newType.Attributes = attributes;
+	                                 .)
+	ident                            (. newType.Name = t.val; .)
+	[ StructInterfaces&lt;out names&gt;    (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
+	StructBody
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
+	                                    compilationUnit.BlockEnd();
+	                                 .)
+	| /*--- interface declaration: */ 
+	&quot;interface&quot;                      (. TypeDeclaration newType = new TypeDeclaration();
+	                                    compilationUnit.AddChild(newType);
+	                                    compilationUnit.BlockStart(newType);
+	                                    newType.Type = Types.Interface;
+	                                    newType.Attributes = attributes;
+	                                    newType.Modifier = m.Modifier;.)
+	ident                            (. newType.Name = t.val; .)
+	[ InterfaceBase&lt;out names&gt;       (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
+	InterfaceBody
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
+	                                    compilationUnit.BlockEnd();
+	                                 .)
+	| /*--- enumeration declaration: */
+	&quot;enum&quot;                           (. TypeDeclaration newType = new TypeDeclaration();
+	                                    compilationUnit.AddChild(newType);
+	                                    compilationUnit.BlockStart(newType);
+	                                    newType.Type = Types.Enum;
+	                                    newType.Attributes = attributes;
+	                                    newType.Modifier = m.Modifier;.)
+	ident                            (. newType.Name = t.val; .)
+	[ &quot;:&quot; IntegralType&lt;out name&gt;     (. newType.BaseTypes = new StringCollection(); 
+	                                    newType.BaseTypes.Add(name);
+	                                 .)
+	]                                (. newType.StartLocation = t.EndLocation; .)
+	EnumBody 
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
+	                                    compilationUnit.BlockEnd();
+	                                 .)
+	| /*--- delegate declaration: */
+	&quot;delegate&quot;                       (. DelegateDeclaration delegateDeclr = new DelegateDeclaration();
+	                                    delegateDeclr.StartLocation = t.Location;
+	                                    delegateDeclr.Modifier = m.Modifier;
+	                                    delegateDeclr.Attributes = attributes;
+	                                 .)
+	( IF (NotVoidPointer()) &quot;void&quot;   (. delegateDeclr.ReturnType = new TypeReference(&quot;void&quot;, 0, null); .)
+		| Type&lt;out type&gt;             (. delegateDeclr.ReturnType = type; .)
+	)
+	ident                            (. delegateDeclr.Name = t.val; .)
+	&quot;(&quot; [ FormalParameterList&lt;out p&gt; (. delegateDeclr.Parameters = p; .)
+	] &quot;)&quot;
+	&quot;;&quot;                              (. delegateDeclr.EndLocation = t.Location;
+	                                    compilationUnit.AddChild(delegateDeclr);
+	                                 .)
+	)
+.
+
+Qualident&lt;out string qualident&gt;
+=
+	ident                              (. StringBuilder qualidentBuilder = new StringBuilder(t.val); .)
+	{ IF (DotAndIdent()) &quot;.&quot; ident     (. qualidentBuilder.Append('.');
+	                                      qualidentBuilder.Append(t.val); 
+	                                    .)
+	} (. qualident = qualidentBuilder.ToString(); .)
+.
+
+ClassBase&lt;out StringCollection names&gt;
+(.
+	string qualident;
+	names = new StringCollection(); 
+.)
+=
+	&quot;:&quot; ClassType&lt;out qualident&gt;       (. names.Add(qualident); .)
+	{ &quot;,&quot; Qualident&lt;out qualident&gt;     (. names.Add(qualident); .) }
+.
+
+ClassBody
+(. AttributeSection section; .)
+=
+	&quot;{&quot;
+	{                                  (.ArrayList attributes = new ArrayList();
+		                                 Modifiers m = new Modifiers(this);
+		                               .)
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; } 
+		ClassMemberDecl&lt;m, attributes&gt; 
+	}
+	&quot;}&quot;
+.
+
+StructInterfaces&lt;out StringCollection names&gt;
+(.
+	string qualident; 
+	names = new StringCollection();
+.)
+=
+	&quot;:&quot; Qualident&lt;out qualident&gt;        (. names.Add(qualident); .)
+	{ &quot;,&quot; Qualident&lt;out qualident&gt;      (. names.Add(qualident); .) }
+.
+
+StructBody
+(. AttributeSection section; .)
+=
+	&quot;{&quot; 
+	{                                    (.ArrayList attributes = new ArrayList();
+		                                   Modifiers m = new Modifiers(this);
+		                                 .)
+		{ AttributeSection&lt;out section&gt;  (. attributes.Add(section); .) }
+		{ MemberModifier&lt;m&gt; } 
+		StructMemberDecl&lt;m, attributes&gt; 
+	}
+	&quot;}&quot; 
+.
+
+InterfaceBase&lt;out StringCollection names&gt;
+(.
+	string qualident;
+	names = new StringCollection();
+.)
+=
+	&quot;:&quot; Qualident&lt;out qualident&gt;    (. names.Add(qualident); .)
+	{ &quot;,&quot; Qualident&lt;out qualident&gt;  (. names.Add(qualident); .) }
+.
+
+InterfaceBody
+= &quot;{&quot; { InterfaceMemberDecl } &quot;}&quot; .
+
+EnumBody                                 (. FieldDeclaration f; .)
+=
+	&quot;{&quot; [ EnumMemberDecl&lt;out f&gt;          (. compilationUnit.AddChild(f); .)
+	{ IF (NotFinalComma()) &quot;,&quot; EnumMemberDecl&lt;out f&gt; (. compilationUnit.AddChild(f); .)
+	}
+	[&quot;,&quot;] ] &quot;}&quot;
+.
+
+Type&lt;out TypeReference type&gt;
+(.
+	string name = &quot;&quot;;
+	int pointer = 0;
+.)
+=
+	( ClassType&lt;out name&gt;
+	| SimpleType&lt;out name&gt;
+	| &quot;void&quot; &quot;*&quot;                         (. pointer = 1; name = &quot;void&quot;; .)
+	)                                    (. ArrayList r = new ArrayList(); .)
+	{ IF (IsPointerOrDims())             (. int i = 1; .)
+		( &quot;*&quot;                            (. ++pointer; .)
+		| &quot;[&quot; { &quot;,&quot; (. ++i; .) } &quot;]&quot;     (. r.Add(i); .)
+		) 
+	}                                    (. int[] rank = new int[r.Count]; r.CopyTo(rank); 
+	                                        type = new TypeReference(name, pointer, rank);
+	                                     .)
+.
+
+NonArrayType&lt;out TypeReference type&gt;
+(.
+	string name = &quot;&quot;;
+	int pointer = 0;
+.)
+=
+	( ClassType&lt;out name&gt;
+	| SimpleType&lt;out name&gt;
+	| &quot;void&quot; &quot;*&quot;                         (. pointer = 1; name = &quot;void&quot;; .)
+	)                                    
+	{ IF (IsPointer())                   
+		( &quot;*&quot;                            (. ++pointer; .)
+		) 
+	}                                    (. 
+	                                        type = new TypeReference(name, pointer, null);
+	                                     .)
+.
+
+SimpleType&lt;out string name&gt;
+(. name = String.Empty; .)
+=
+	IntegralType&lt;out name&gt; 
+	| &quot;float&quot;   (. name = t.val; .)
+	| &quot;double&quot;  (. name = t.val; .)
+	| &quot;decimal&quot; (. name = t.val; .)
+	| &quot;bool&quot;    (. name = t.val; .)
+.
+
+
+FormalParameterList&lt;out ArrayList parameter&gt;
+(.
+	parameter = new ArrayList();
+	ParameterDeclarationExpression p;
+	AttributeSection section;
+	ArrayList attributes = new ArrayList();
+.)
+=
+	{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
+	(
+		FixedParameter&lt;out p&gt; (. bool paramsFound = false;
+		                         p.Attributes = attributes;
+		                         parameter.Add(p);
+		                      .)
+		{
+			&quot;,&quot;                              (. attributes = new ArrayList(); if (paramsFound) Error(&quot;params array must be at end of parameter list&quot;); .)
+			{ AttributeSection&lt;out section&gt; (.attributes.Add(section); .) }
+			(
+				FixedParameter&lt;out p&gt;        (. p.Attributes = attributes; parameter.Add(p); .)
+				| ParameterArray&lt;out p&gt;      (. paramsFound = true; p.Attributes = attributes; parameter.Add(p); .)
+			)
+		}
+		| ParameterArray&lt;out p&gt;              (. p.Attributes = attributes; parameter.Add(p); .)
+	)
+.
+
+FixedParameter&lt;out ParameterDeclarationExpression p&gt;
+(.
+	TypeReference type;
+	ParamModifiers mod = ParamModifiers.In;
+.)
+=
+	[
+		&quot;ref&quot;    (. mod = ParamModifiers.Ref; .)
+		| &quot;out&quot;  (. mod = ParamModifiers.Out; .)
+	]
+	Type&lt;out type&gt; ident (. p = new ParameterDeclarationExpression(type, t.val, mod); .)
+.
+
+ParameterArray&lt;out ParameterDeclarationExpression p&gt;
+(. TypeReference type; .)
+=
+	&quot;params&quot; Type&lt;out type&gt; ident (. p = new ParameterDeclarationExpression(type, t.val, ParamModifiers.Params); .)
+. 
+
+TypeModifier&lt;Modifiers m&gt;
+=
+	&quot;new&quot;                              (. m.Add(Modifier.New); .)
+	| &quot;public&quot;                         (. m.Add(Modifier.Public); .)
+	| &quot;protected&quot;                      (. m.Add(Modifier.Protected); .)
+	| &quot;internal&quot;                       (. m.Add(Modifier.Internal); .)
+	| &quot;private&quot;                        (. m.Add(Modifier.Private); .)
+	| &quot;unsafe&quot;                         (. m.Add(Modifier.Unsafe); .)
+	| &quot;abstract&quot;                       (. m.Add(Modifier.Abstract); .)
+	| &quot;sealed&quot;                         (. m.Add(Modifier.Sealed); .)
+.
+
+ClassType&lt;out string name&gt;             (. string qualident; name = &quot;&quot;;.)
+=
+	Qualident&lt;out qualident&gt;           (. name = qualident; .)
+	| &quot;object&quot;                         (. name = &quot;object&quot;; .)
+	| &quot;string&quot;                         (. name = &quot;string&quot;; .)
+.
+
+IntegralType&lt;out string name&gt;          (. name = &quot;&quot;; .)
+=
+	&quot;sbyte&quot;                            (. name = &quot;sbyte&quot;; .)
+	| &quot;byte&quot;                           (. name = &quot;byte&quot;; .)
+	| &quot;short&quot;                          (. name = &quot;short&quot;; .)
+	| &quot;ushort&quot;                         (. name = &quot;ushort&quot;; .)
+	| &quot;int&quot;                            (. name = &quot;int&quot;; .)
+	| &quot;uint&quot;                           (. name = &quot;uint&quot;; .)
+	| &quot;long&quot;                           (. name = &quot;long&quot;; .)
+	| &quot;ulong&quot;                          (. name = &quot;ulong&quot;; .)
+	| &quot;char&quot;                           (. name = &quot;char&quot;; .)
+.
+
+MemberModifier&lt;Modifiers m&gt;
+=
+	&quot;abstract&quot;                         (. m.Add(Modifier.Abstract); .)
+	| &quot;extern&quot;                         (. m.Add(Modifier.Extern); .)
+	| &quot;internal&quot;                       (. m.Add(Modifier.Internal); .)
+	| &quot;new&quot;                            (. m.Add(Modifier.New); .)
+	| &quot;override&quot;                       (. m.Add(Modifier.Override); .)
+	| &quot;private&quot;                        (. m.Add(Modifier.Private); .)
+	| &quot;protected&quot;                      (. m.Add(Modifier.Protected); .)
+	| &quot;public&quot;                         (. m.Add(Modifier.Public); .)
+	| &quot;readonly&quot;                       (. m.Add(Modifier.Readonly); .)
+	| &quot;sealed&quot;                         (. m.Add(Modifier.Sealed); .)
+	| &quot;static&quot;                         (. m.Add(Modifier.Static); .)
+	| &quot;unsafe&quot;                         (. m.Add(Modifier.Unsafe); .)
+	| &quot;virtual&quot;                        (. m.Add(Modifier.Virtual); .)
+	| &quot;volatile&quot;                       (. m.Add(Modifier.Volatile); .)
+.
+
+StructMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
+(.
+	string qualident = null;
+	TypeReference type;
+	Expression expr;
+	ArrayList p = new ArrayList();
+	Statement stmt = null;
+	ArrayList variableDeclarators = new ArrayList();
+.)
+=
+	/*--- constant declaration: */         (. m.Check(Modifier.Constants); .)
+	&quot;const&quot;                                (.Point startPos = t.Location; .)
+	Type&lt;out type&gt; ident                   (. FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier | Modifier.Const);
+	                                          VariableDeclaration f = new VariableDeclaration(t.val);
+	                                          fd.Fields.Add(f);
+	                                       .)
+	&quot;=&quot; Expr&lt;out expr&gt;                     (. f.Initializer = expr; .)
+	{ &quot;,&quot; ident                            (. f = new VariableDeclaration(t.val);
+	                                          fd.Fields.Add(f);
+	                                       .)
+		&quot;=&quot; Expr&lt;out expr&gt;                 (. f.Initializer = expr; .)
+	} &quot;;&quot;                                  (. fd.EndLocation = t.EndLocation; compilationUnit.AddChild(fd); .)
+	
+	/*--- void method (procedure) declaration: */
+	| IF (NotVoidPointer())                (. m.Check(Modifier.PropertysEventsMethods); .)
+	&quot;void&quot;                                 (. Point startPos = t.Location; .)
+	Qualident&lt;out qualident&gt; &quot;(&quot; 
+	[ FormalParameterList&lt;out p&gt; ] &quot;)&quot;     (. MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
+	                                                                                                      m.Modifier, 
+	                                                                                                      new TypeReference(&quot;void&quot;), 
+	                                                                                                      p, 
+	                                                                                                      attributes);
+	                                          methodDeclaration.StartLocation = startPos;
+	                                          methodDeclaration.EndLocation   = t.EndLocation;
+	                                          compilationUnit.AddChild(methodDeclaration);
+	                                          compilationUnit.BlockStart(methodDeclaration);
+	                                       .)
+	( Block&lt;out stmt&gt; | &quot;;&quot; )              (. compilationUnit.BlockEnd();
+	                                          methodDeclaration.Body  = (BlockStatement)stmt;
+	                                       .)
+	
+	| /*--- event declaration: */          (. m.Check(Modifier.PropertysEventsMethods); .)
+	&quot;event&quot;                                (. EventDeclaration eventDecl = new EventDeclaration(m.Modifier, attributes);
+	                                          eventDecl.StartLocation = t.Location;
+	                                          compilationUnit.AddChild(eventDecl);
+	                                          compilationUnit.BlockStart(eventDecl);
+	                                          EventAddRegion addBlock = null;
+	                                          EventRemoveRegion removeBlock = null;
+	                                       .)
+	Type&lt;out type&gt;                         (. eventDecl.TypeReference = type; .)
+	(
+		IF (IsVarDecl()) VariableDeclarator&lt;variableDeclarators&gt;
+		{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; } &quot;;&quot;      (. eventDecl.VariableDeclarators = variableDeclarators; eventDecl.EndLocation = t.EndLocation;  .)
+		| Qualident&lt;out qualident&gt;         (. eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation;  .)
+		&quot;{&quot; (. eventDecl.BodyStart = t.Location; .)
+		EventAccessorDecls&lt;out addBlock, out removeBlock&gt; 
+		&quot;}&quot; (. eventDecl.BodyEnd   = t.EndLocation; .)
+	)                                       (. compilationUnit.BlockEnd();
+	                                           
+	                                           eventDecl.AddRegion = addBlock;
+	                                           eventDecl.RemoveRegion = removeBlock;
+	                                       .)
+	
+	/*--- constructor or static contructor declaration: */
+	| IF (IdentAndLPar())                  (. m.Check(Modifier.Constructors | Modifier.StaticConstructors); .)
+	ident (. string name = t.val; Point startPos = t.Location; .) &quot;(&quot; [  (. m.Check(Modifier.Constructors); .)
+	FormalParameterList&lt;out p&gt;
+	]
+	&quot;)&quot; (.ConstructorInitializer init = null;  .)
+	[                                      (. m.Check(Modifier.Constructors); .)
+		ConstructorInitializer&lt;out init&gt;
+	] (. 
+	     ConstructorDeclaration cd = new ConstructorDeclaration(name, m.Modifier, p, init, attributes); 
+	     cd.StartLocation = startPos;
+	     cd.EndLocation   = t.EndLocation;
+	  .)
+	
+	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. cd.Body = (BlockStatement)stmt; compilationUnit.AddChild(cd); .)
+	
+	/*--- conversion operator declaration: */
+	|                                      (. m.Check(Modifier.Operators);
+	                                          if (m.isNone) Error(&quot;at least one modifier must be set&quot;); 
+	                                          bool isImplicit = true;
+	                                       .)
+	( &quot;implicit&quot; | &quot;explicit&quot; (. isImplicit = false; .) ) 
+	&quot;operator&quot; Type&lt;out type&gt; (. TypeReference operatorType = type; .) 
+	&quot;(&quot; Type&lt;out type&gt; ident (. string varName = t.val; .) &quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; (. stmt = null; .) )
+	(.
+		
+		OperatorDeclarator operatorDeclarator = new OperatorDeclarator(isImplicit ? OperatorType.Implicit : OperatorType.Explicit,
+		                                                               operatorType,
+		                                                               type,
+		                                                               varName);
+		OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+		operatorDeclaration.Body = stmt;
+		compilationUnit.AddChild(operatorDeclaration);
+	.)
+	
+	/*--- inner type declaration: */
+	| TypeDecl&lt;m, attributes&gt;
+	| Type&lt;out type&gt;                       (. Point startPos = t.Location; .)
+	(
+		/*--- operator declaration: */     (. Token op;
+		                                      m.Check(Modifier.Operators);
+		                                      if (m.isNone) Error(&quot;at least one modifier must be set&quot;);
+		                                   .)
+		&quot;operator&quot; OverloadableOperator&lt;out op&gt; (. TypeReference firstType, secondType = null; string secondName = null; .)
+		&quot;(&quot; Type&lt;out firstType&gt; ident (. string firstName = t.val; .)
+		( &quot;,&quot; Type&lt;out secondType&gt; ident (. secondName = t.val; .)        (. if (ParserUtil.IsUnaryOperator(op) &amp;&amp; !ParserUtil.IsBinaryOperator(op))
+		                                      Error(&quot;too many operands for unary operator&quot;); 
+		                                   .)
+		| /* empty */                      (. if (ParserUtil.IsBinaryOperator(op))
+		                                      Error(&quot;too few operands for binary operator&quot;);
+		                                   .)
+		)
+		&quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; )
+		(.
+			OperatorDeclarator operatorDeclarator = new OperatorDeclarator(secondType != null ? OperatorType.Binary : OperatorType.Unary, 
+			                                                               type,
+			                                                               op.kind,
+			                                                               firstType,
+			                                                               firstName,
+			                                                               secondType,
+			                                                               secondName);
+			OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+			operatorDeclaration.Body = stmt;
+			compilationUnit.AddChild(operatorDeclaration);
+		.)
+		
+		/*--- field declaration: */
+		| IF (IsVarDecl())                 (. m.Check(Modifier.Fields); 
+		                                      FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
+		                                      fd.StartLocation = startPos; 
+		                                   .)
+		VariableDeclarator&lt;variableDeclarators&gt;
+		{ &quot;,&quot; VariableDeclarator&lt;variableDeclarators&gt; }
+		&quot;;&quot;                                (. fd.EndLocation = t.EndLocation; fd.Fields = variableDeclarators; compilationUnit.AddChild(fd); .)
+		
+		/*--- unqualified indexer declaration (without interface name): */
+		|                                  (. m.Check(Modifier.Indexers); .)
+		&quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (. Point endLocation = t.EndLocation; .) &quot;{&quot; (.
+			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
+			         indexer.StartLocation = startPos;
+			         indexer.EndLocation   = endLocation;
+			         indexer.BodyStart     = t.Location;
+			         PropertyGetRegion getRegion;
+			         PropertySetRegion setRegion;
+			       .) 
+		AccessorDecls&lt;out getRegion, out setRegion&gt; &quot;}&quot; (. 
+			          indexer.BodyEnd    = t.EndLocation;
+			          indexer.GetRegion = getRegion;
+			          indexer.SetRegion = setRegion;
+			          compilationUnit.AddChild(indexer);
+			       .)
+		| Qualident&lt;out qualident&gt; (. Point qualIdentEndLocation = t.EndLocation; .)
+		(
+			/*--- &quot;not void&quot; method (function) declaration: */
+			(                              (. m.Check(Modifier.PropertysEventsMethods); .)
+			    &quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; (. MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
+	                                                                                                      m.Modifier, 
+	                                                                                                      type, 
+	                                                                                                      p, 
+	                                                                                                      attributes);
+	                                                      methodDeclaration.StartLocation = startPos;
+	                                                      methodDeclaration.EndLocation   = t.EndLocation;
+	                                                      compilationUnit.AddChild(methodDeclaration);
+	                                                   .)
+			     ( Block&lt;out stmt&gt; | &quot;;&quot; ) (. methodDeclaration.Body  = (BlockStatement)stmt; .)
+			
+			/*--- property declaration: */  
+			| &quot;{&quot; (. PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
+			         pDecl.StartLocation = startPos;
+			         pDecl.EndLocation   = qualIdentEndLocation;
+			         pDecl.BodyStart   = t.Location;
+			         PropertyGetRegion getRegion;
+			         PropertySetRegion setRegion;
+			      .)
+			   AccessorDecls&lt;out getRegion, out setRegion&gt; 
+			   &quot;}&quot; (. 
+			          pDecl.GetRegion = getRegion;
+			          pDecl.SetRegion = setRegion;
+			          pDecl.BodyEnd = t.EndLocation;
+			          compilationUnit.AddChild(pDecl);
+			       .)
+			)
+			
+			/*--- qualified indexer declaration (with interface name): */
+			|                              (. m.Check(Modifier.Indexers); .)
+			&quot;.&quot; &quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (.
+			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
+			         indexer.StartLocation = startPos;
+			         indexer.EndLocation   = t.EndLocation;
+			         indexer.NamespaceName = qualident;
+			         PropertyGetRegion getRegion;
+			         PropertySetRegion setRegion;
+			       .) 
+			  &quot;{&quot; (. Point bodyStart = t.Location; .)
+			  AccessorDecls&lt;out getRegion, out setRegion&gt; 
+			  &quot;}&quot;  (. indexer.BodyStart = bodyStart;
+			          indexer.BodyEnd   = t.EndLocation;
+			          indexer.GetRegion = getRegion;
+			          indexer.SetRegion = setRegion;
+			          compilationUnit.AddChild(indexer);
+			       .)
+		)
+	)
+.
+
+ClassMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
+(. Statement stmt = null; .)
+=
+	StructMemberDecl&lt;m, attributes&gt;
+	| /*--- destructor declaration: */ (. m.Check(Modifier.Destructors); Point startPos = t.Location; .)
+	&quot;~&quot; ident                          (. DestructorDeclaration d = new DestructorDeclaration(t.val, attributes); 
+	                                      d.Modifier = m.Modifier;
+	                                      d.StartLocation = startPos;
+	                                   .)
+	&quot;(&quot; &quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; )  (. d.EndLocation = t.EndLocation; 
+	                                      d.Body = (BlockStatement)stmt;
+	                                      compilationUnit.AddChild(d);
+	                                   .)
+.
+
+InterfaceMemberDecl
+(.
+	TypeReference type;
+	ArrayList p;
+	AttributeSection section;
+	Modifier mod = Modifier.None;
+	ArrayList attributes = new ArrayList();
+	ArrayList parameters = new ArrayList();
+	string name;
+	PropertyGetRegion getBlock;
+	PropertySetRegion setBlock;
+	Point startLocation = new Point(-1, -1);
+.)
+=
+	{ AttributeSection&lt;out section&gt;     (. attributes.Add(section); .)}
+	[ &quot;new&quot; (. mod = Modifier.New; startLocation = t.Location; .) ]
+	(
+		/*--- interface void method (procedure) declaration: */
+		IF (NotVoidPointer()) &quot;void&quot; (. if (startLocation.X == -1) startLocation = t.Location; .) ident (. name = t.val; .)
+		&quot;(&quot; [ FormalParameterList&lt;out parameters&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference(&quot;void&quot;), parameters, attributes);
+		                                              md.StartLocation = startLocation;
+		                                              md.EndLocation = t.EndLocation;
+		                                              compilationUnit.AddChild(md);
+		                                           .)
+		| (
+			Type&lt;out type&gt; (. if (startLocation.X == -1) startLocation = t.Location; .)
+			(
+				ident                  (. name = t.val; Point qualIdentEndLocation = t.EndLocation; .)
+				(
+					/*--- interface &quot;not void&quot; method (function) declaration: */
+					&quot;(&quot; [ FormalParameterList&lt;out parameters&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, type, parameters, attributes);
+					                                              md.StartLocation = startLocation;
+					                                              md.EndLocation = t.EndLocation;
+					                                              compilationUnit.AddChild(md);
+					                                           .)
+					/*--- interface property declaration: */
+					|                   (. PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); .)
+					&quot;{&quot; (. Point bodyStart = t.Location;.) InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; .)
+				)
+				/*--- interface indexer declaration: */
+				| &quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (.Point bracketEndLocation = t.EndLocation; .)  (. IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); .)
+				&quot;{&quot; (. Point bodyStart = t.Location;.) InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;.)
+			)
+			/*--- interface event declaration: */
+			| &quot;event&quot; (. if (startLocation.X == -1) startLocation = t.Location; .) Type&lt;out type&gt; ident (. EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
+			                                  compilationUnit.AddChild(ed);
+			                               .)
+			&quot;;&quot;                            (. ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; .)
+		)
+	)
+.
+
+EnumMemberDecl&lt;out FieldDeclaration f&gt;
+(.
+	Expression expr = null;
+	ArrayList attributes = new ArrayList();
+	AttributeSection section = null;
+	VariableDeclaration varDecl = null;
+.)
+=
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	ident                           (. f = new FieldDeclaration(attributes);
+	                                   varDecl         = new VariableDeclaration(t.val);
+	                                   f.Fields.Add(varDecl);
+	                                   f.StartLocation = t.Location;
+	                                .)
+	[ &quot;=&quot; Expr&lt;out expr&gt; (. varDecl.Initializer = expr; .) ]
+.
+
+
+AccessorDecls&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
+(.
+	ArrayList attributes = new ArrayList(); 
+	AttributeSection section;
+	getBlock = null;
+	setBlock = null; 
+.)
+=
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	(
+		IF (IdentIsGet())
+			GetAccessorDecl&lt;out getBlock, attributes&gt;
+			[                       (. attributes = new ArrayList(); .)
+				{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+				SetAccessorDecl&lt;out setBlock, attributes&gt;
+			]
+		| IF (IdentIsSet())
+			SetAccessorDecl&lt;out setBlock, attributes&gt;
+			[                        (. attributes = new ArrayList(); .)
+				{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+				GetAccessorDecl&lt;out getBlock, attributes&gt;
+			]
+		| ident (. Error(&quot;get or set accessor declaration expected&quot;); .)
+	)
+.
+
+GetAccessorDecl&lt;out PropertyGetRegion getBlock, ArrayList attributes&gt;
+(. Statement stmt = null; .)
+=
+	ident /* &quot;get&quot; is not a keyword!? */
+	(. if (t.val != &quot;get&quot;) Error(&quot;get expected&quot;); .)
+	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes); .)
+.
+
+SetAccessorDecl&lt;out PropertySetRegion setBlock, ArrayList attributes&gt;
+(. Statement stmt = null; .)
+=
+	ident /* &quot;set&quot; is not a keyword!? */
+	(. if (t.val != &quot;set&quot;) Error(&quot;set expected&quot;); .)
+	( Block&lt;out stmt&gt; | &quot;;&quot; ) (. setBlock = new PropertySetRegion((BlockStatement)stmt, attributes); .)
+.
+
+EventAccessorDecls&lt;out EventAddRegion addBlock, out EventRemoveRegion removeBlock&gt;
+(. AttributeSection section;
+   ArrayList attributes = new ArrayList();
+   Statement stmt;
+   addBlock = null;
+   removeBlock = null;
+.)
+=
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	(
+		IF (IdentIsAdd())            (. addBlock = new EventAddRegion(attributes); .)
+			AddAccessorDecl&lt;out stmt&gt;       (. attributes = new ArrayList(); addBlock.Block = (BlockStatement)stmt; .)
+			{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .)}
+			RemoveAccessorDecl&lt;out stmt&gt;    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; .)
+		| IF (IdentIsRemove())
+			RemoveAccessorDecl &lt;out stmt&gt;    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new ArrayList(); .)
+			{ AttributeSection&lt;out section&gt;  (. attributes.Add(section); .) }
+			AddAccessorDecl&lt;out stmt&gt;        (. addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; .)
+		| ident (. Error(&quot;add or remove accessor declaration expected&quot;); .)
+	)
+.
+
+InterfaceAccessors&lt;out PropertyGetRegion getBlock, out PropertySetRegion setBlock&gt;
+(.
+	AttributeSection section;
+	ArrayList attributes = new ArrayList();
+	getBlock = null; setBlock = null;
+.)
+=
+	{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+	(
+		IF (IdentIsGet()) ident   (. getBlock = new PropertyGetRegion(null, attributes); .)
+		| IF (IdentIsSet()) ident (. setBlock = new PropertySetRegion(null, attributes); .)
+		| ident                   (. Error(&quot;set or get expected&quot;); .)
+	)
+	&quot;;&quot;                           (. attributes = new ArrayList(); .)
+	[
+		{ AttributeSection&lt;out section&gt; (. attributes.Add(section); .) }
+		(
+			IF (IdentIsGet()) ident   (. if (getBlock != null) Error(&quot;get already declared&quot;);
+			                             else getBlock = new PropertyGetRegion(null, attributes);
+			                          .)
+			| IF (IdentIsSet()) ident (. if (setBlock != null) Error(&quot;set already declared&quot;);
+			                             else setBlock = new PropertySetRegion(null, attributes);
+			                          .)
+			| ident                   (. Error(&quot;set or get expected&quot;); .)
+		)
+		&quot;;&quot;
+	]
+.
+
+VariableDeclarator&lt;ArrayList fieldDeclaration&gt;
+(. Expression expr = null; .)
+=
+	ident                                 (. VariableDeclaration f = new VariableDeclaration(t.val); .)
+	[ &quot;=&quot; VariableInitializer&lt;out expr&gt;   (. f.Initializer = expr; .) ] (. fieldDeclaration.Add(f); .)
+.
+
+Block&lt;out Statement stmt&gt; /* not BlockStatement because of EmbeddedStatement */
+=
+	&quot;{&quot; (. BlockStatement blockStmt = new BlockStatement();
+	       blockStmt.StartLocation = t.Location;
+	       compilationUnit.BlockStart(blockStmt);
+	    .)
+	{ Statement }
+	&quot;}&quot; (. stmt = blockStmt;
+	       blockStmt.EndLocation = t.EndLocation;
+	       compilationUnit.BlockEnd();
+	    .)
+.
+
+AddAccessorDecl&lt;out Statement stmt&gt;
+(.stmt = null;.) 
+=
+	/* &quot;add&quot; is not a keyword!? */
+	ident (. if (t.val != &quot;add&quot;) Error(&quot;add expected&quot;); .)
+	Block&lt;out stmt&gt;
+.
+
+RemoveAccessorDecl&lt;out Statement stmt&gt;
+(.stmt = null;.) 
+=
+	/* &quot;remove&quot; is not a keyword!? */
+	ident (. if (t.val != &quot;remove&quot;) Error(&quot;remove expected&quot;); .)
+	Block&lt;out stmt&gt;
+.
+
+ConstructorInitializer&lt;out ConstructorInitializer ci&gt;
+(. Expression expr; ci = new ConstructorInitializer(); .)
+=
+	&quot;:&quot;
+	(
+		&quot;base&quot; (. ci.ConstructorInitializerType = ConstructorInitializerType.Base; .)
+		| &quot;this&quot;  (. ci.ConstructorInitializerType = ConstructorInitializerType.This; .)
+	) 
+	&quot;(&quot;
+	[ Argument&lt;out expr&gt; (. ci.Arguments.Add(expr); .) { &quot;,&quot; Argument&lt;out expr&gt; (. ci.Arguments.Add(expr); .) } ]
+	&quot;)&quot;
+.
+
+VariableInitializer&lt;out Expression initializerExpression&gt;
+(. TypeReference type = null; Expression expr = null; initializerExpression = null; .)
+=
+	Expr&lt;out initializerExpression&gt;
+	| ArrayInitializer&lt;out initializerExpression&gt;
+	| &quot;stackalloc&quot; Type&lt;out type&gt; &quot;[&quot; Expr&lt;out expr&gt; &quot;]&quot; (. initializerExpression = new StackAllocExpression(type, expr); .)
+.
+
+OverloadableOperator&lt;out Token op&gt;
+=
+	(
+		&quot;+&quot;  | &quot;-&quot;  | &quot;!&quot;    | &quot;~&quot;
+		| &quot;++&quot; | &quot;--&quot; | &quot;true&quot; | &quot;false&quot;
+		| &quot;*&quot;  | &quot;/&quot;  | &quot;%&quot;    | &quot;&amp;&quot;
+		| &quot;|&quot;  | &quot;^&quot;  | &quot;&lt;&lt;&quot;   | &quot;&gt;&gt;&quot;
+		| &quot;==&quot; | &quot;!=&quot; | &quot;&gt;&quot;    | &quot;&lt;&quot;
+		| &quot;&gt;=&quot; | &quot;&lt;=&quot;
+	) (. op = t; .)
+.
+
+Argument&lt;out Expression argumentexpr&gt;
+(.
+	Expression expr;
+	FieldDirection fd = FieldDirection.None;
+.)
+=
+	[
+		&quot;ref&quot; (. fd = FieldDirection.Ref; .)
+		| &quot;out&quot; (. fd = FieldDirection.Out; .)
+	]
+	Expr&lt;out expr&gt; (. argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; .)
+.
+
+AssignmentOperator&lt;out AssignmentOperatorType op&gt;
+(. op = AssignmentOperatorType.None; .)
+=
+	&quot;=&quot;     (. op = AssignmentOperatorType.Assign; .)
+	| &quot;+=&quot;  (. op = AssignmentOperatorType.Add; .)
+	| &quot;-=&quot;  (. op = AssignmentOperatorType.Subtract; .)
+	| &quot;*=&quot;  (. op = AssignmentOperatorType.Multiply; .)
+	| &quot;/=&quot;  (. op = AssignmentOperatorType.Divide; .)
+	| &quot;%=&quot;  (. op = AssignmentOperatorType.Modulus; .)
+	| &quot;&amp;=&quot;  (. op = AssignmentOperatorType.BitwiseAnd; .)
+	| &quot;|=&quot;  (. op = AssignmentOperatorType.BitwiseOr; .)
+	| &quot;^=&quot;  (. op = AssignmentOperatorType.ExclusiveOr; .)
+	| &quot;&lt;&lt;=&quot; (. op = AssignmentOperatorType.ShiftLeft; .)
+	| &quot;&gt;&gt;=&quot; (. op = AssignmentOperatorType.ShiftRight; .)
+.
+
+ArrayInitializer&lt;out Expression outExpr&gt;
+(.
+	Expression expr = null;
+	ArrayInitializerExpression initializer = new ArrayInitializerExpression();
+.)
+=
+	&quot;{&quot;
+	[ VariableInitializer&lt;out expr&gt; (. initializer.CreateExpressions.Add(expr); .) { IF (NotFinalComma()) &quot;,&quot; VariableInitializer&lt;out expr&gt; (. initializer.CreateExpressions.Add(expr); .) } [ &quot;,&quot; ] ]
+	&quot;}&quot; (. outExpr = initializer; .)
+.
+
+LocalVariableDecl&lt;out Statement stmt&gt;
+(.
+	TypeReference type;
+	VariableDeclaration      var = null;
+	LocalVariableDeclaration localVariableDeclaration; 
+.)
+=
+	Type&lt;out type&gt; (. localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; .)
+	LocalVariableDeclarator&lt;out var&gt; (. localVariableDeclaration.Variables.Add(var); .)
+	{ &quot;,&quot; LocalVariableDeclarator&lt;out var&gt; (. localVariableDeclaration.Variables.Add(var); .) }
+	(. stmt = localVariableDeclaration; .)
+.
+
+LocalVariableDeclarator&lt;out VariableDeclaration var&gt;
+(. Expression expr = null; .)
+=
+	ident (. var = new VariableDeclaration(t.val); .) [ &quot;=&quot; LocalVariableInitializer&lt;out expr&gt; (. var.Initializer = expr; .) ]
+.
+
+LocalVariableInitializer&lt;out Expression expr&gt;
+(. expr = null; .)
+=
+	Expr&lt;out expr&gt;
+	| ArrayInitializer&lt;out expr&gt;
+.
+
+Statement
+(.
+	TypeReference type;
+	Expression expr;
+	Statement stmt;
+.)
+=
+	/*--- labeled statement: */
+	IF (IsLabel()) ident (. compilationUnit.AddChild(new LabelStatement(t.val)); .)
+	&quot;:&quot; Statement
+	/*--- local constant declaration: */
+	| &quot;const&quot; Type&lt;out type&gt; (. LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifier.Const); string ident = null; var.StartLocation = t.Location; .) 
+	  ident (. ident = t.val; .)
+	  &quot;=&quot; Expr&lt;out expr&gt; (. var.Variables.Add(new VariableDeclaration(ident, expr)); .)
+	  { &quot;,&quot; ident (. ident = t.val; .) &quot;=&quot; Expr&lt;out expr&gt; (. var.Variables.Add(new VariableDeclaration(ident, expr)); .) }
+	  &quot;;&quot; (. compilationUnit.AddChild(var); .)
+	/*--- local variable declaration: */
+	| IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt; &quot;;&quot; (. compilationUnit.AddChild(stmt); .)
+	| EmbeddedStatement&lt;out stmt&gt; (. compilationUnit.AddChild(stmt); .)
+	/* LL(1) confict: LocalVariableDecl *
+	 *            &lt;-&gt; StatementExpr     *
+	 * ident {&quot;.&quot; ident} { &quot;[&quot; Expr ... */
+.
+
+EmbeddedStatement&lt;out Statement statement&gt;
+(.
+	TypeReference type = null;
+	Expression expr = null;
+	Statement embeddedStatement = null;
+	statement = null;
+.)
+=
+	Block&lt;out statement&gt;
+	/*--- empty statement: */
+	| &quot;;&quot;                       (. statement = new EmptyStatement(); .)
+	/*--- checked / unchecked statement: */
+	| IF (UnCheckedAndLBrace()) (. Statement block; bool isChecked = true; .)
+	(&quot;checked&quot; | &quot;unchecked&quot;    (. isChecked = false;.) )
+	Block&lt;out block&gt;            (. statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); .)
+	/*--- expression statement: */
+	| StatementExpr&lt;out statement&gt; &quot;;&quot;
+	/*--- selection statements (if, switch): */
+	| &quot;if&quot;                      (. Statement elseStatement = null; .)
+	&quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt;
+	[ &quot;else&quot; EmbeddedStatement&lt;out elseStatement&gt; ]
+	                            (. statement = elseStatement != null ? (Statement)new IfElseStatement(expr, embeddedStatement, elseStatement) :  (Statement)new IfStatement(expr, embeddedStatement); .)
+	| &quot;switch&quot; (. ArrayList switchSections = new ArrayList(); .)
+	  &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	  &quot;{&quot; { SwitchSection&lt;out statement&gt; (. switchSections.Add(statement); .) } 
+	  &quot;}&quot;  (. statement = new SwitchStatement(expr, switchSections); .)
+	/*--- iteration statements (while, do, for, foreach): */
+	| &quot;while&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new WhileStatement(expr, embeddedStatement); .)
+	| &quot;do&quot; EmbeddedStatement&lt;out embeddedStatement&gt; &quot;while&quot;
+	&quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; &quot;;&quot;  (. statement = new DoWhileStatement(expr, embeddedStatement); .)
+	| &quot;for&quot; (. ArrayList initializer = null, iterator = null; .)
+	  &quot;(&quot; [ ForInitializer&lt;out initializer&gt; ] &quot;;&quot;
+	  [ Expr&lt;out expr&gt; ] &quot;;&quot;
+	  [ ForIterator&lt;out iterator&gt; ] &quot;)&quot;
+	  EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new ForStatement(initializer, expr, iterator, embeddedStatement); .)
+	| &quot;foreach&quot; &quot;(&quot; Type&lt;out type&gt; ident     (. string varName = t.val; Point start = t.Location;.)
+	&quot;in&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt; (.  statement = new ForeachStatement(type, varName , expr, embeddedStatement); 
+	                                             statement.EndLocation = t.EndLocation;
+	                                         .)
+	/*--- jump statements (break, contine, goto, return, throw): */
+	| &quot;break&quot; &quot;;&quot;               (. statement = new BreakStatement(); .)
+	| &quot;continue&quot; &quot;;&quot;            (. statement = new ContinueStatement(); .)
+	| GotoStatement&lt;out statement&gt;
+	| &quot;return&quot; [ Expr&lt;out expr&gt; ] &quot;;&quot;    (. statement = new ReturnStatement(expr); .)
+	| &quot;throw&quot; [ Expr&lt;out expr&gt; ] &quot;;&quot;     (. statement = new ThrowStatement(expr); .)
+	/*--- try statement: */
+	| TryStatement&lt;out statement&gt;
+	/*--- lock satement: */
+	| &quot;lock&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new LockStatement(expr, embeddedStatement); .)
+	/*--- using statement: */
+	| (.Statement resourceAcquisitionStmt = null; .)
+	&quot;using&quot; &quot;(&quot;
+	ResourceAcquisition&lt;out resourceAcquisitionStmt&gt; &quot;)&quot;
+	EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); .)
+	/*--- unsafe statement: */
+	| &quot;unsafe&quot; Block&lt;out embeddedStatement&gt;  (. statement = new UnsafeStatement(embeddedStatement); .)
+	/*--- fixed statement: */
+	| &quot;fixed&quot;
+	&quot;(&quot; Type&lt;out type&gt;     (. if (type.PointerNestingLevel == 0) Error(&quot;can only fix pointer types&quot;);
+	                          FixedStatement fxStmt = new FixedStatement(type);
+	                          string identifier = null;
+	                       .)
+	ident                  (. identifier = t.val; .)
+	&quot;=&quot; Expr&lt;out expr&gt;     (. fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
+	{
+		&quot;,&quot; ident          (. identifier = t.val; .)
+		&quot;=&quot; Expr&lt;out expr&gt; (. fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
+	}
+	&quot;)&quot; EmbeddedStatement&lt;out embeddedStatement&gt;  (. fxStmt.EmbeddedStatement = embeddedStatement; statement = fxStmt;.)
+.
+
+ForInitializer&lt;out ArrayList initializer&gt;
+(.
+	Statement stmt; 
+	initializer = new ArrayList();
+.)
+=
+	IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt; (. initializer.Add(stmt);.)
+	| StatementExpr&lt;out stmt&gt; (.initializer.Add(stmt);.) { &quot;,&quot; StatementExpr&lt;out stmt&gt; (. initializer.Add(stmt);.) } (. initializer.Add(stmt);.)
+.
+
+ForIterator&lt;out ArrayList iterator&gt;
+(.
+	Statement stmt; 
+	iterator = new ArrayList();
+.)
+=
+	StatementExpr&lt;out stmt&gt; (. iterator.Add(stmt);.) { &quot;,&quot; StatementExpr&lt;out stmt&gt; (. iterator.Add(stmt); .) }
+.
+
+SwitchSection&lt;out Statement stmt&gt;
+(.
+	SwitchSection switchSection = new SwitchSection();
+	Expression expr;
+.)
+=
+	SwitchLabel&lt;out expr&gt; (. switchSection.SwitchLabels.Add(expr); .) { SwitchLabel&lt;out expr&gt; (. switchSection.SwitchLabels.Add(expr); .) } 
+	(. compilationUnit.BlockStart(switchSection); .)
+	Statement { Statement }
+	(.
+		compilationUnit.BlockEnd();
+		stmt = switchSection;
+	.)
+.
+
+SwitchLabel&lt;out Expression expr&gt;
+ (. expr = null; .)
+=
+	&quot;case&quot; Expr&lt;out expr&gt; &quot;:&quot; 
+	| &quot;default&quot; &quot;:&quot;
+.
+
+TryStatement&lt;out Statement tryStatement&gt;
+(.
+	Statement blockStmt = null, finallyStmt = null;
+	ArrayList catchClauses = null;
+.)
+=
+	&quot;try&quot;  Block&lt;out blockStmt&gt;
+	(
+		CatchClauses&lt;out catchClauses&gt; [ &quot;finally&quot; Block&lt;out finallyStmt&gt; ]
+		| &quot;finally&quot; Block&lt;out finallyStmt&gt;
+	)
+	(.
+		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
+	
+	.)
+.
+
+CatchClauses&lt;out ArrayList catchClauses&gt;
+(.
+	catchClauses = new ArrayList();
+.)
+=
+	&quot;catch&quot; (. string name;
+	           string identifier;
+	           Statement stmt; 
+	        .)
+	/*--- general catch clause (as only catch clause) */
+	(
+		Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(stmt)); .)
+		/*--- specific catch clause */
+		| &quot;(&quot; ClassType&lt;out name&gt; (. identifier = null; .) [ ident (. identifier = t.val; .) ] &quot;)&quot; Block&lt;out stmt&gt;  (. catchClauses.Add(new CatchClause(name, identifier, stmt)); .)
+		{ IF (IsTypedCatch()) &quot;catch&quot; &quot;(&quot; ClassType&lt;out name&gt; (. identifier = null; .) [ ident (. identifier = t.val; .) ] &quot;)&quot; Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(name, identifier, stmt)); .) }
+		/*--- general catch clause (after specific catch clauses, optional) */
+		[ &quot;catch&quot; Block&lt;out stmt&gt; (. catchClauses.Add(new CatchClause(stmt)); .) ]
+	)
+.
+
+GotoStatement&lt;out Statement stmt&gt;
+(. Expression expr; stmt = null; .)
+=
+	&quot;goto&quot;
+	(
+		ident (. stmt = new GotoStatement(t.val); .) &quot;;&quot;
+		| &quot;case&quot; Expr&lt;out expr&gt;  &quot;;&quot; (. stmt = new GotoCaseStatement(expr); .)
+		| &quot;default&quot; &quot;;&quot; (. stmt = new GotoCaseStatement(null); .)
+	)
+.
+
+ResourceAcquisition&lt;out Statement stmt&gt;
+(.
+	stmt = null;
+	Expression expr;
+.)
+=
+	(
+		IF (IsLocalVarDecl()) LocalVariableDecl&lt;out stmt&gt;
+		| Expr&lt;out expr&gt; /* LL(1) conflict resoltion:                             *
+		                  * check if next is Qualident followed by ident          *
+		                  * ==&gt; LocalVariableDecl                                 *
+		                  * new problem: first set of ResourceAcquisition changes */
+		(. stmt = new StatementExpression(expr); .)
+	)
+.
+
+StatementExpr&lt;out Statement stmt&gt;
+=
+	/* We don't know why, but it's in the grammar. */
+	/* (see internal document: assignment.txt) */
+	(.
+		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
+		                        la.kind == Tokens.Not   || la.kind == Tokens.BitwiseComplement ||
+		                        la.kind == Tokens.Times || la.kind == Tokens.BitwiseAnd   || IsTypeCast();
+		Expression expr = null;
+	.)
+	
+	UnaryExpr&lt;out expr&gt;
+	/*--- assignment */
+	(
+		(. AssignmentOperatorType op; Expression val; .) AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
+		| (. if (mustBeAssignment) Error(&quot;error in assignment.&quot;); .)
+	) (. stmt = new StatementExpression(expr); .)
+.
+
+Expr&lt;out Expression expr&gt;
+(. expr = null; Expression expr1 = null, expr2 = null; .)
+=
+	UnaryExpr&lt;out expr&gt;
+	/*--- conditional expression: */
+	(
+		ConditionalOrExpr&lt;ref expr&gt; [ &quot;?&quot; Expr&lt;out expr1&gt; &quot;:&quot; Expr&lt;out expr2&gt; (. expr = new ConditionalExpression(expr, expr1, expr2);  .) ] 
+		/*--- assignment: */
+		| (. AssignmentOperatorType op; Expression val; .) AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
+	)
+.
+
+
+UnaryExpr&lt;out Expression uExpr&gt;
+(.
+	TypeReference type = null;
+	Expression expr;
+	ArrayList  expressions = new ArrayList();
+	uExpr = null;
+.)
+=
+	{
+		  &quot;+&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); .)
+		| &quot;-&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); .)
+		| &quot;!&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); .)
+		| &quot;~&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); .)
+		| &quot;*&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); .)
+		| &quot;++&quot; (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); .)
+		| &quot;--&quot; (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); .)
+		| &quot;&amp;&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); .)
+		
+		/*--- cast expression: */
+		/* Problem:  &quot;(&quot; Type &quot;)&quot; from here and                     *
+		 *           &quot;(&quot; Expr &quot;)&quot; from PrimaryExpr                  *
+		 *           are not distinguishable                        *
+		 * Solution: (in IsTypeCast())                              *
+		 * use external information from compiled assembly or guess */
+		| IF (IsTypeCast()) &quot;(&quot; Type&lt;out type&gt; &quot;)&quot;  (.  expressions.Add(new CastExpression(type)); .)
+	}
+	
+	PrimaryExpr&lt;out expr&gt; (. for (int i = 0; i &lt; expressions.Count; ++i) {
+	                         	Expression nextExpression = i + 1 &lt; expressions.Count ? (Expression)expressions[i + 1] : expr;
+	                         	if (expressions[i] is CastExpression) {
+	                         		((CastExpression)expressions[i]).Expression = nextExpression;
+	                         	} else {
+	                         		((UnaryOperatorExpression)expressions[i]).Expression = nextExpression;
+	                         	}
+	                         }
+	                         if (expressions.Count &gt; 0) {
+	                         	uExpr = (Expression)expressions[0];
+	                         } else {
+	                         	uExpr = expr;
+	                         }
+	                      .)
+.
+
+
+PrimaryExpr&lt;out Expression pexpr&gt;
+(.
+	TypeReference type = null;
+	bool isArrayCreation = false;
+	Expression expr;
+	pexpr = null;
+.)
+=
+	(
+		&quot;true&quot;                              (.pexpr = new PrimitiveExpression(true, &quot;true&quot;);  .)
+		| &quot;false&quot;                           (.pexpr = new PrimitiveExpression(false, &quot;false&quot;); .)
+		| &quot;null&quot;                            (.pexpr = new PrimitiveExpression(null, &quot;null&quot;);  .)          /* from literal token */
+		| literal                           (.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
+		/*--- simple name: */
+		| ident (. pexpr = new IdentifierExpression(t.val); .)
+		/*--- parenthesized expression: */
+		| &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new ParenthesizedExpression(expr); .)
+		| /*--- predefined type member access: */
+		(
+			&quot;bool&quot;   | &quot;byte&quot;   | &quot;char&quot; | &quot;decimal&quot; | &quot;double&quot;
+			| &quot;float&quot;  | &quot;int&quot;    | &quot;long&quot; | &quot;object&quot;  | &quot;sbyte&quot;
+			| &quot;short&quot;  | &quot;string&quot; | &quot;uint&quot; | &quot;ulong&quot;   | &quot;ushort&quot;
+		) (. string val = t.val; .) &quot;.&quot; ident (. pexpr = new FieldReferenceExpression(new TypeReferenceExpression(val), t.val); .)
+		/*--- this access: */
+		| &quot;this&quot;                              (. pexpr = new ThisReferenceExpression(); .)
+		/*--- base access: */
+		| &quot;base&quot;                              (. Expression retExpr = new BaseReferenceExpression(); .)
+		(
+			&quot;.&quot; ident                         (. retExpr = new FieldReferenceExpression(retExpr, t.val); .)
+			| &quot;[&quot; Expr&lt;out expr&gt;              (.ArrayList indices = new ArrayList(); indices.Add(expr); .)
+			{ &quot;,&quot; Expr&lt;out expr&gt;              (. indices.Add(expr); .) }
+			&quot;]&quot;                               (. retExpr = new IndexerExpression(retExpr, indices); .)
+		)                                     (. pexpr = retExpr; .)
+		| &quot;new&quot; NonArrayType&lt;out type&gt;                (. ArrayList parameters = new ArrayList(); .)
+		/*--- delegate / object creation expression: */
+		/* Note: a delegate creation expression allow only a single Expr  *
+		 *       not an argument list, but this is not distinguished here */
+		(
+			&quot;(&quot; (. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .) [ Argument&lt;out expr&gt;          (. parameters.Add(expr); .)
+			{ &quot;,&quot; Argument&lt;out expr&gt;          (. parameters.Add(expr); .) } ] &quot;)&quot; (. pexpr = oce; .)
+			/*--- array creation expression: */
+			| (. isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type); pexpr = ace; .)
+			&quot;[&quot; (. int dims = 0; ArrayList rank = new ArrayList(); ArrayList parameterExpression = new ArrayList(); .)
+			(
+				Expr&lt;out expr&gt; (. parameterExpression.Add(expr); .) { &quot;,&quot; Expr&lt;out expr&gt; (. parameterExpression.Add(expr); .) } &quot;]&quot; (. parameters.Add(new ArrayCreationParameter(parameterExpression)); ace.Parameters = parameters; .)
+				{ IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.rank.Add(dims); parameters.Add(new ArrayCreationParameter(dims)); .) &quot;]&quot; } 
+				(. if (rank.Count &gt; 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } .)
+				[ ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; .) ]
+				
+				| { &quot;,&quot; (.dims++;.) } (.parameters.Add(new ArrayCreationParameter(dims)); .)  &quot;]&quot; { IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.parameters.Add(new ArrayCreationParameter(dims)); .) &quot;]&quot; } ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; ace.Parameters = parameters; .)
+			)
+/*			| ArrayInitializer&lt;out expr&gt; (. if (!type.IsArrayType) { Error(&quot;() or [] expected&quot;); }  pexpr =  new ArrayCreateExpression(type, (ArrayInitializerExpression)expr); .)*/
+		)
+		| &quot;typeof&quot; &quot;(&quot;
+		(
+			IF (NotVoidPointer()) &quot;void&quot; (. type = new TypeReference(&quot;void&quot;); .)
+			| Type&lt;out type&gt;
+		) &quot;)&quot;                            (. pexpr = new TypeOfExpression(type); .)
+		| &quot;sizeof&quot; &quot;(&quot; Type&lt;out type&gt; &quot;)&quot; (. pexpr = new SizeOfExpression(type); .)
+		| &quot;checked&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new CheckedExpression(expr); .)
+		| &quot;unchecked&quot; &quot;(&quot; Expr&lt;out expr&gt; &quot;)&quot; (. pexpr = new CheckedExpression(expr); .)
+	)
+	{
+		(
+			&quot;++&quot;   (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); .)
+			| &quot;--&quot; (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); .)
+		)
+		/*--- member access */
+		| &quot;-&gt;&quot; ident (. pexpr = new PointerReferenceExpression(pexpr, t.val); .)
+		| &quot;.&quot; ident (. pexpr = new FieldReferenceExpression(pexpr, t.val);.)
+		/*--- invocation expression: */
+		| &quot;(&quot;                        (. ArrayList parameters = new ArrayList(); .)
+			[ Argument&lt;out expr&gt;     (. parameters.Add(expr); .)
+			{ &quot;,&quot; Argument&lt;out expr&gt; (. parameters.Add(expr); .)
+			} ] &quot;)&quot;                  (. pexpr = new InvocationExpression(pexpr, parameters); .)
+		/*--- element access */
+		|  (. if (isArrayCreation) Error(&quot;element access not allow on array creation&quot;);
+		      ArrayList indices = new ArrayList();
+		   .)
+		&quot;[&quot; Expr&lt;out expr&gt; (.indices.Add(expr); .)
+		{ &quot;,&quot; Expr&lt;out expr&gt; (. indices.Add(expr); .)
+		} &quot;]&quot; (. pexpr = new IndexerExpression(pexpr, indices); .)
+	}
+.
+
+ConditionalOrExpr&lt;ref Expression outExpr&gt;
+(. Expression expr;   .)
+=
+	ConditionalAndExpr&lt;ref outExpr&gt;  { &quot;||&quot; UnaryExpr&lt;out expr&gt; ConditionalAndExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  .) }
+.
+
+ConditionalAndExpr&lt;ref Expression outExpr&gt;
+(. Expression expr; .)
+=
+	InclusiveOrExpr&lt;ref outExpr&gt;  { &quot;&amp;&amp;&quot; UnaryExpr&lt;out expr&gt; InclusiveOrExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  .) }
+.
+
+InclusiveOrExpr&lt;ref Expression outExpr&gt;
+(. Expression expr; .)
+=
+	ExclusiveOrExpr&lt;ref outExpr&gt;  { &quot;|&quot; UnaryExpr&lt;out expr&gt; ExclusiveOrExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  .) }
+.
+
+ExclusiveOrExpr&lt;ref Expression outExpr&gt;
+(. Expression expr; .)
+=
+	AndExpr&lt;ref outExpr&gt;  { &quot;^&quot; UnaryExpr&lt;out expr&gt; AndExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  .) }
+.
+
+AndExpr&lt;ref Expression outExpr&gt;
+(. Expression expr; .)
+=
+	EqualityExpr&lt;ref outExpr&gt; { &quot;&amp;&quot; UnaryExpr&lt;out expr&gt; EqualityExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  .) }
+.
+
+EqualityExpr&lt;ref Expression outExpr&gt;
+(.
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	RelationalExpr&lt;ref outExpr&gt;
+	{
+		(
+			&quot;!=&quot;   (. op = BinaryOperatorType.InEquality; .)
+			| &quot;==&quot; (. op = BinaryOperatorType.Equality; .)
+		)
+		UnaryExpr&lt;out expr&gt; RelationalExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
+	}
+.
+
+RelationalExpr&lt;ref Expression outExpr&gt;
+(.
+	TypeReference type;
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	ShiftExpr&lt;ref outExpr&gt;
+	{
+		(
+			&quot;&lt;&quot;    (. op = BinaryOperatorType.LessThan; .)
+			| &quot;&gt;&quot;  (. op = BinaryOperatorType.GreaterThan; .)
+			| &quot;&lt;=&quot; (. op = BinaryOperatorType.LessThanOrEqual; .)
+			| &quot;&gt;=&quot; (. op = BinaryOperatorType.GreaterThanOrEqual; .)
+		)
+		UnaryExpr&lt;out expr&gt; ShiftExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
+		|
+		(
+			&quot;is&quot; (. op = BinaryOperatorType.IS; .)
+			| &quot;as&quot; (. op = BinaryOperatorType.AS; .)
+		)
+		Type&lt;out type&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, new TypeReferenceExpression(type)); .)
+	}
+.
+
+ShiftExpr&lt;ref Expression outExpr&gt;
+(.
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	AdditiveExpr&lt;ref outExpr&gt; 
+	{
+		(
+			&quot;&lt;&lt;&quot;   (. op = BinaryOperatorType.ShiftLeft; .)
+			| &quot;&gt;&gt;&quot; (. op = BinaryOperatorType.ShiftRight; .)
+		)
+		UnaryExpr&lt;out expr&gt; AdditiveExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
+	}
+.
+
+AdditiveExpr&lt;ref Expression outExpr&gt;
+(.
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	MultiplicativeExpr&lt;ref outExpr&gt;
+	{
+		(
+			&quot;+&quot;   (. op = BinaryOperatorType.Add; .)
+			| &quot;-&quot; (. op = BinaryOperatorType.Subtract; .)
+		)
+		UnaryExpr&lt;out expr&gt; MultiplicativeExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
+	}
+.
+
+MultiplicativeExpr&lt;ref Expression outExpr&gt;
+(.
+	Expression expr;
+	BinaryOperatorType op = BinaryOperatorType.None;
+.)
+=
+	{
+		(
+			&quot;*&quot;   (. op = BinaryOperatorType.Multiply; .)
+			| &quot;/&quot; (. op = BinaryOperatorType.Divide; .)
+			| &quot;%&quot; (. op = BinaryOperatorType.Modulus; .)
+		) 
+		UnaryExpr&lt;out expr&gt; (. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .) 
+	}
+.
+	
+END CS.

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/gen.bat
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/gen.bat	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/gen.bat	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,3 @@
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">+ at echo</A> off
+SharpCoco -namespace ICSharpCode.SharpRefactory.Parser cs.ATG
+del Parser.old.cs
\ No newline at end of file

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/ATGTokensSection.gen
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/ATGTokensSection.gen	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/ATGTokensSection.gen	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,133 @@
+/* START AUTOGENERATED TOKENS SECTION */
+TOKENS
+	/* ----- terminal classes ----- */
+	/* EOF is 0 */
+	ident
+	Literal
+
+	/* ----- special character ----- */
+	&quot;=&quot;
+	&quot;+&quot;
+	&quot;-&quot;
+	&quot;*&quot;
+	&quot;/&quot;
+	&quot;%&quot;
+	&quot;:&quot;
+	&quot;;&quot;
+	&quot;?&quot;
+	&quot;,&quot;
+	&quot;.&quot;
+	&quot;{&quot;
+	&quot;}&quot;
+	&quot;[&quot;
+	&quot;]&quot;
+	&quot;(&quot;
+	&quot;)&quot;
+	&quot;&gt;&quot;
+	&quot;&lt;&quot;
+	&quot;!&quot;
+	&quot;&amp;&amp;&quot;
+	&quot;||&quot;
+	&quot;~&quot;
+	&quot;&amp;&quot;
+	&quot;|&quot;
+	&quot;^&quot;
+	&quot;++&quot;
+	&quot;--&quot;
+	&quot;==&quot;
+	&quot;!=&quot;
+	&quot;&gt;=&quot;
+	&quot;&lt;=&quot;
+	&quot;&lt;&lt;&quot;
+	&quot;&gt;&gt;&quot;
+	&quot;+=&quot;
+	&quot;-=&quot;
+	&quot;*=&quot;
+	&quot;/=&quot;
+	&quot;%=&quot;
+	&quot;&amp;=&quot;
+	&quot;|=&quot;
+	&quot;^=&quot;
+	&quot;&lt;&lt;=&quot;
+	&quot;&gt;&gt;=&quot;
+	&quot;-&gt;&quot;
+
+	/* ----- keywords ----- */
+	&quot;abstract&quot;
+	&quot;as&quot;
+	&quot;base&quot;
+	&quot;bool&quot;
+	&quot;break&quot;
+	&quot;byte&quot;
+	&quot;case&quot;
+	&quot;catch&quot;
+	&quot;char&quot;
+	&quot;checked&quot;
+	&quot;class&quot;
+	&quot;const&quot;
+	&quot;continue&quot;
+	&quot;decimal&quot;
+	&quot;default&quot;
+	&quot;delegate&quot;
+	&quot;do&quot;
+	&quot;double&quot;
+	&quot;else&quot;
+	&quot;enum&quot;
+	&quot;event&quot;
+	&quot;explicit&quot;
+	&quot;extern&quot;
+	&quot;false&quot;
+	&quot;finally&quot;
+	&quot;fixed&quot;
+	&quot;float&quot;
+	&quot;for&quot;
+	&quot;foreach&quot;
+	&quot;goto&quot;
+	&quot;if&quot;
+	&quot;implicit&quot;
+	&quot;in&quot;
+	&quot;int&quot;
+	&quot;interface&quot;
+	&quot;internal&quot;
+	&quot;is&quot;
+	&quot;lock&quot;
+	&quot;long&quot;
+	&quot;namespace&quot;
+	&quot;new&quot;
+	&quot;null&quot;
+	&quot;object&quot;
+	&quot;operator&quot;
+	&quot;out&quot;
+	&quot;override&quot;
+	&quot;params&quot;
+	&quot;private&quot;
+	&quot;protected&quot;
+	&quot;public&quot;
+	&quot;readonly&quot;
+	&quot;ref&quot;
+	&quot;return&quot;
+	&quot;sbyte&quot;
+	&quot;sealed&quot;
+	&quot;short&quot;
+	&quot;sizeof&quot;
+	&quot;stackalloc&quot;
+	&quot;static&quot;
+	&quot;string&quot;
+	&quot;struct&quot;
+	&quot;switch&quot;
+	&quot;this&quot;
+	&quot;throw&quot;
+	&quot;true&quot;
+	&quot;try&quot;
+	&quot;typeof&quot;
+	&quot;uint&quot;
+	&quot;ulong&quot;
+	&quot;unchecked&quot;
+	&quot;unsafe&quot;
+	&quot;ushort&quot;
+	&quot;using&quot;
+	&quot;virtual&quot;
+	&quot;void&quot;
+	&quot;volatile&quot;
+	&quot;while&quot;
+/* END AUTOGENERATED TOKENS SECTION */

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/BuildKeywords.pl
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/BuildKeywords.pl	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/BuildKeywords.pl	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,227 @@
+#!/bin/perl
+
+# File names
+$keyword_file     = &quot;CSharpKeywordList.txt&quot;;
+$keywords_outfile = &quot;Keywords.cs&quot;;
+$tokens_outfile   = &quot;Tokens.cs&quot;;
+$ATGTokensSection = &quot;ATGTokensSection.gen&quot;;
+
+#read infile
+print &quot;\n&quot;;
+print &quot;Reading keyword definition from '$keyword_file'.\n&quot;;
+open(DAT, $keyword_file) || die(&quot;Could not open file!&quot;);
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">+ at raw_data</A>=&lt;DAT&gt;;
+close(DAT);
+print &quot;done.\n&quot;;
+
+#analyse infile
+print &quot;starting analysation ... this could take a few minutes.\n&quot;;
+
+foreach (@raw_data) {
+	if ($_=~/\A\s*\$(\w+)\s*=\s*(\S+)/) {
+		#properties form: $PROPERTY = &quot;VALUE&quot;
+		$properties{$1} = $2;
+	} elsif  ($_=~/\A\s*(\w+)\s*=\s*\&quot;(\S+)\&quot;/) {
+		#special characters form: name = &quot;VALUE&quot;
+		$special_chars[$#special_chars + 1] = $1;
+		$special_values[$#special_values + 1] = $2;
+	} elsif  ($_=~/\A\s*\&quot;(\S+)\s*\&quot;/) {
+		#special keywords form: &quot;VALUE&quot;
+		$keywords[$#keywords + 1] = $1
+	} elsif  ($_=~/\A\s*(\w+)\s*/) {
+		#special terminal classes form: name
+		$terminals[$#terminals + 1] = $1
+	}
+}
+
+for ($i=0; $i &lt;= $#keywords; $i++) {
+	$upperKeywords[$i] = uc $keywords[$i];
+}
+sort (ascend @upperKeywords);
+
+
+sort (ascend @keywords);
+print &quot;done.\n&quot;;
+
+#write output
+print &quot;writing output files.\nIf your computer doesn&#146;t respond, then press \&quot;Ctrl-Alt-Delete\&quot;\n&quot;;
+print &quot;\n&quot;;
+&amp;write_keywordfile;
+print &quot;\n&quot;;
+&amp;write_tokensfile;
+print &quot;\n&quot;;
+&amp;write_atgtokensfile;
+print &quot;\n&quot;;
+print &quot;finished.\n&quot;;
+
+sub write_keywordfile {
+	print &quot;  -&gt;Generating Keywords class to file '$keywords_outfile'\n&quot;;
+	open(DAT,&quot;&gt;$keywords_outfile&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
+	print DAT &quot;using System;\n&quot;;
+	print DAT &quot;using System.Collections;\n&quot;;
+	print DAT &quot;using System.Text;\n&quot;;
+	print DAT &quot;\n&quot;;
+	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
+	print DAT &quot;{\n&quot;;
+	print DAT &quot;	public class Keywords\n&quot;;
+	print DAT &quot;	{\n&quot;;
+	print DAT &quot;		static readonly string[] keywordList = {\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		for ($i=0; $i &lt;= $#upperKeywords; $i++) {
+			print DAT &quot;			\&quot;$upperKeywords[$i]\&quot;&quot;;
+			if ($i + 1 &lt;= $#upperKeywords) {
+				print DAT &quot;,&quot;;
+			}
+			print DAT &quot;\n&quot;;
+		}
+	} else {
+		for ($i=0; $i &lt;= $#keywords; $i++) {
+			print DAT &quot;			\&quot;$keywords[$i]\&quot;&quot;;
+			if ($i + 1 &lt;= $#keywords) {
+				print DAT &quot;,&quot;;
+			}
+			print DAT &quot;\n&quot;;
+		}
+	}
+	
+	print DAT &quot;		};\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		static Hashtable keywords = new Hashtable();\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		static Keywords()\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	print DAT &quot;			for (int i = 0; i &lt; keywordList.Length; ++i) {\n&quot;;
+	$up = ucfirst($keywords[0]);
+	print DAT &quot;				keywords.Add(keywordList[i], i + Tokens.$up);\n&quot;;
+	print DAT &quot;			}\n&quot;;
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		public static bool IsKeyword(string identifier)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		print DAT &quot;			return keywords[identifier.ToUpper()] != null;\n&quot;;
+	} else {
+		print DAT &quot;			return keywords[identifier] != null;\n&quot;;
+	}
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		public static int GetToken(string keyword)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		print DAT &quot;			return (int)keywords[keyword.ToUpper()];\n&quot;;
+	} else {
+		print DAT &quot;			return (int)keywords[keyword];\n&quot;;
+	}
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;	}\n&quot;;
+	print DAT &quot;}\n&quot;;
+	
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+
+sub write_token {
+	$formattedString = sprintf(&quot;%-20s&quot;, ucfirst($tokenName));
+	if ($tokenName eq &quot;GetType&quot;) {
+		print DAT &quot;		new public const int $formattedString = $tokenValue;&quot;;
+	} else {
+		print DAT &quot;		public const int $formattedString = $tokenValue;&quot;;
+	}
+	$tokenValue++;
+	
+}
+
+sub write_tokensfile {
+	print &quot;  -&gt;Generating Tokens class to file '$tokens_outfile'\n&quot;;
+	open(DAT,&quot;&gt;$tokens_outfile&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
+	print DAT &quot;using System;\n&quot;;
+	print DAT &quot;\n&quot;;
+	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
+	print DAT &quot;{\n&quot;;
+	print DAT &quot;	public sealed class Tokens\n&quot;;
+	print DAT &quot;	{\n&quot;;
+	$tokenValue = 0;
+	
+	print DAT &quot;		// ----- terminal classes -----\n&quot;;
+	foreach (@terminals) {
+		$tokenName = $_;
+		write_token();
+		print DAT &quot;\n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;		// ----- special character -----\n&quot;;
+	for ($i=0; $i &lt;= $#special_chars; $i++) {
+		$tokenName = $special_chars[$i];
+		write_token();
+		print DAT &quot; // $special_values[$i] \n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;		// ----- keywords -----\n&quot;;
+	foreach (@keywords) {
+		$tokenName = $_;
+		write_token();
+		print DAT &quot;\n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	
+	print DAT &quot;		public static string GetTokenString(int token)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	print DAT &quot;			switch (token) {\n&quot;;
+	for ($i = 0; $i &lt;= $#special_chars; $i++) {
+		print DAT &quot;				case $special_chars[$i]:\n&quot;;
+		print DAT &quot;					return \&quot;$special_values[$i]\&quot;;\n&quot;;
+	}
+	foreach (@keywords) {
+		$up = ucfirst($_);
+		print DAT &quot;				case $up:\n&quot;;
+		print DAT &quot;					return \&quot;$_\&quot;;\n&quot;;
+	}
+	
+	print DAT &quot;			}\n&quot;;
+	print DAT &quot;			throw new System.NotSupportedException(\&quot;Unknown token:\&quot; + token);\n&quot;;
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;	}\n&quot;;
+	
+	
+	
+	print DAT &quot;}\n&quot;;
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+
+sub write_atgtokensfile {
+	print &quot;  -&gt;Generating ATG TOKENS section and writing it to file '$ATGTokensSection'\n&quot;;
+	open(DAT,&quot;&gt;$ATGTokensSection&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;/* START AUTOGENERATED TOKENS SECTION */\n&quot;;
+	print DAT &quot;TOKENS\n&quot;;
+
+	print DAT &quot;	/* ----- terminal classes ----- */\n&quot;;
+	print DAT &quot;	/* EOF is 0 */\n&quot;;
+	foreach $term (@terminals) {
+		if ($term eq &quot;EOF&quot;) {
+		} elsif ($term eq &quot;Identifier&quot;) {
+			print DAT &quot;\tident\n&quot;;
+		} else {
+			print DAT &quot;\t$term\n&quot;;
+		}
+			
+	}
+	
+	print DAT &quot;\n&quot;;
+	print DAT &quot;	/* ----- special character ----- */\n&quot;;
+	foreach (@special_values) {
+		print DAT &quot;\t\&quot;$_\&quot;\n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;	/* ----- keywords ----- */\n&quot;;
+	foreach (@keywords) {
+		print DAT &quot;\t\&quot;$_\&quot;\n&quot;;
+	}
+
+	print DAT &quot;/* END AUTOGENERATED TOKENS SECTION */\n&quot;;
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/CSharpKeywordList.txt
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/CSharpKeywordList.txt	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/CSharpKeywordList.txt	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,151 @@
+# this list is used for autogeneration of:
+# - Keywords.cs
+# - Tokens.cs
+# - ATGTokensSection.txt - the TOKENS section of the ATG file
+
+# use BuildKeywords to generate the different lists.
+
+$Namespace=ICSharpCode.SharpRefactory.Parser
+$UpperCaseKeywords=False
+
+
+# TERMINAL_CLASSES
+EOF
+Identifier
+Literal
+
+# SPECIAL_CHARACTERS
+Assign = &quot;=&quot;
+Plus = &quot;+&quot;
+Minus = &quot;-&quot;
+Times = &quot;*&quot;
+Div = &quot;/&quot;
+Mod = &quot;%&quot;
+		
+Colon = &quot;:&quot;
+Semicolon = &quot;;&quot;
+Question = &quot;?&quot;
+Comma = &quot;,&quot;
+Dot = &quot;.&quot;
+	
+OpenCurlyBrace = &quot;{&quot;
+CloseCurlyBrace = &quot;}&quot;
+
+OpenSquareBracket = &quot;[&quot;
+CloseSquareBracket = &quot;]&quot;
+
+OpenParenthesis = &quot;(&quot;
+CloseParenthesis = &quot;)&quot;
+
+GreaterThan = &quot;&gt;&quot;
+LessThan = &quot;&lt;&quot;
+		
+Not = &quot;!&quot;
+LogicalAnd = &quot;&amp;&amp;&quot;
+LogicalOr = &quot;||&quot;
+		
+BitwiseComplement = &quot;~&quot;
+BitwiseAnd = &quot;&amp;&quot;
+BitwiseOr = &quot;|&quot;
+Xor = &quot;^&quot;
+
+Increment = &quot;++&quot;
+Decrement = &quot;--&quot;
+Equal = &quot;==&quot;
+NotEqual = &quot;!=&quot;
+GreaterEqual = &quot;&gt;=&quot;
+LessEqual = &quot;&lt;=&quot;
+		
+ShiftLeft = &quot;&lt;&lt;&quot;
+ShiftRight = &quot;&gt;&gt;&quot;
+		
+PlusAssign = &quot;+=&quot;
+MinusAssign = &quot;-=&quot;
+TimesAssign = &quot;*=&quot;
+DivAssign = &quot;/=&quot;
+ModAssign = &quot;%=&quot;
+BitwiseAndAssign = &quot;&amp;=&quot;
+BitwiseOrAssign = &quot;|=&quot;
+XorAssign = &quot;^=&quot;
+ShiftLeftAssign = &quot;&lt;&lt;=&quot;
+ShiftRightAssign = &quot;&gt;&gt;=&quot;
+Pointer = &quot;-&gt;&quot;
+
+# Keywordlist
+&quot;abstract&quot;
+&quot;as&quot;
+&quot;base&quot;
+&quot;bool&quot;
+&quot;break&quot;
+&quot;byte&quot;
+&quot;case&quot;
+&quot;catch&quot;
+&quot;char&quot;
+&quot;checked&quot;
+&quot;class&quot;
+&quot;const&quot;
+&quot;continue&quot;
+&quot;decimal&quot;
+&quot;default&quot;
+&quot;delegate&quot;
+&quot;do&quot;
+&quot;double&quot;
+&quot;else&quot;
+&quot;enum&quot;
+&quot;event&quot;
+&quot;explicit&quot;
+&quot;extern&quot;
+&quot;false&quot;
+&quot;finally&quot;
+&quot;fixed&quot;
+&quot;float&quot;
+&quot;for&quot;
+&quot;foreach&quot;
+&quot;goto&quot;
+&quot;if&quot;
+&quot;implicit&quot;
+&quot;in&quot;
+&quot;int&quot;
+&quot;interface&quot;
+&quot;internal&quot;
+&quot;is&quot;
+&quot;lock&quot;
+&quot;long&quot;
+&quot;namespace&quot;
+&quot;new&quot;
+&quot;null&quot;
+&quot;object&quot;
+&quot;operator&quot;
+&quot;out&quot;
+&quot;override&quot;
+&quot;params&quot;
+&quot;private&quot;
+&quot;protected&quot;
+&quot;public&quot;
+&quot;readonly&quot;
+&quot;ref&quot;
+&quot;return&quot;
+&quot;sbyte&quot;
+&quot;sealed&quot;
+&quot;short&quot;
+&quot;sizeof&quot;
+&quot;stackalloc&quot;
+&quot;static&quot;
+&quot;string&quot;
+&quot;struct&quot;
+&quot;switch&quot;
+&quot;this&quot;
+&quot;throw&quot;
+&quot;true&quot;
+&quot;try&quot;
+&quot;typeof&quot;
+&quot;uint&quot;
+&quot;ulong&quot;
+&quot;unchecked&quot;
+&quot;unsafe&quot;
+&quot;ushort&quot;
+&quot;using&quot;
+&quot;virtual&quot;
+&quot;void&quot;
+&quot;volatile&quot;
+&quot;while&quot;

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/Keywords.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/Keywords.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/Keywords.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,109 @@
+// this file was autogenerated by a tool.
+using System;
+using System.Collections;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class Keywords
+	{
+		static readonly string[] keywordList = {
+			&quot;abstract&quot;,
+			&quot;as&quot;,
+			&quot;base&quot;,
+			&quot;bool&quot;,
+			&quot;break&quot;,
+			&quot;byte&quot;,
+			&quot;case&quot;,
+			&quot;catch&quot;,
+			&quot;char&quot;,
+			&quot;checked&quot;,
+			&quot;class&quot;,
+			&quot;const&quot;,
+			&quot;continue&quot;,
+			&quot;decimal&quot;,
+			&quot;default&quot;,
+			&quot;delegate&quot;,
+			&quot;do&quot;,
+			&quot;double&quot;,
+			&quot;else&quot;,
+			&quot;enum&quot;,
+			&quot;event&quot;,
+			&quot;explicit&quot;,
+			&quot;extern&quot;,
+			&quot;false&quot;,
+			&quot;finally&quot;,
+			&quot;fixed&quot;,
+			&quot;float&quot;,
+			&quot;for&quot;,
+			&quot;foreach&quot;,
+			&quot;goto&quot;,
+			&quot;if&quot;,
+			&quot;implicit&quot;,
+			&quot;in&quot;,
+			&quot;int&quot;,
+			&quot;interface&quot;,
+			&quot;internal&quot;,
+			&quot;is&quot;,
+			&quot;lock&quot;,
+			&quot;long&quot;,
+			&quot;namespace&quot;,
+			&quot;new&quot;,
+			&quot;null&quot;,
+			&quot;object&quot;,
+			&quot;operator&quot;,
+			&quot;out&quot;,
+			&quot;override&quot;,
+			&quot;params&quot;,
+			&quot;private&quot;,
+			&quot;protected&quot;,
+			&quot;public&quot;,
+			&quot;readonly&quot;,
+			&quot;ref&quot;,
+			&quot;return&quot;,
+			&quot;sbyte&quot;,
+			&quot;sealed&quot;,
+			&quot;short&quot;,
+			&quot;sizeof&quot;,
+			&quot;stackalloc&quot;,
+			&quot;static&quot;,
+			&quot;string&quot;,
+			&quot;struct&quot;,
+			&quot;switch&quot;,
+			&quot;this&quot;,
+			&quot;throw&quot;,
+			&quot;true&quot;,
+			&quot;try&quot;,
+			&quot;typeof&quot;,
+			&quot;uint&quot;,
+			&quot;ulong&quot;,
+			&quot;unchecked&quot;,
+			&quot;unsafe&quot;,
+			&quot;ushort&quot;,
+			&quot;using&quot;,
+			&quot;virtual&quot;,
+			&quot;void&quot;,
+			&quot;volatile&quot;,
+			&quot;while&quot;
+		};
+		
+		static Hashtable keywords = new Hashtable();
+		
+		static Keywords()
+		{
+			for (int i = 0; i &lt; keywordList.Length; ++i) {
+				keywords.Add(keywordList[i], i + Tokens.Abstract);
+			}
+		}
+		
+		public static bool IsKeyword(string identifier)
+		{
+			return keywords[identifier] != null;
+		}
+		
+		public static int GetToken(string keyword)
+		{
+			return (int)keywords[keyword];
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/Tokens.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/Tokens.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/keywordlist/Tokens.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,390 @@
+// this file was autogenerated by a tool.
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public sealed class Tokens
+	{
+		// ----- terminal classes -----
+		public const int EOF                  = 0;
+		public const int Identifier           = 1;
+		public const int Literal              = 2;
+
+		// ----- special character -----
+		public const int Assign               = 3; // = 
+		public const int Plus                 = 4; // + 
+		public const int Minus                = 5; // - 
+		public const int Times                = 6; // * 
+		public const int Div                  = 7; // / 
+		public const int Mod                  = 8; // % 
+		public const int Colon                = 9; // : 
+		public const int Semicolon            = 10; // ; 
+		public const int Question             = 11; // ? 
+		public const int Comma                = 12; // , 
+		public const int Dot                  = 13; // . 
+		public const int OpenCurlyBrace       = 14; // { 
+		public const int CloseCurlyBrace      = 15; // } 
+		public const int OpenSquareBracket    = 16; // [ 
+		public const int CloseSquareBracket   = 17; // ] 
+		public const int OpenParenthesis      = 18; // ( 
+		public const int CloseParenthesis     = 19; // ) 
+		public const int GreaterThan          = 20; // &gt; 
+		public const int LessThan             = 21; // &lt; 
+		public const int Not                  = 22; // ! 
+		public const int LogicalAnd           = 23; // &amp;&amp; 
+		public const int LogicalOr            = 24; // || 
+		public const int BitwiseComplement    = 25; // ~ 
+		public const int BitwiseAnd           = 26; // &amp; 
+		public const int BitwiseOr            = 27; // | 
+		public const int Xor                  = 28; // ^ 
+		public const int Increment            = 29; // ++ 
+		public const int Decrement            = 30; // -- 
+		public const int Equal                = 31; // == 
+		public const int NotEqual             = 32; // != 
+		public const int GreaterEqual         = 33; // &gt;= 
+		public const int LessEqual            = 34; // &lt;= 
+		public const int ShiftLeft            = 35; // &lt;&lt; 
+		public const int ShiftRight           = 36; // &gt;&gt; 
+		public const int PlusAssign           = 37; // += 
+		public const int MinusAssign          = 38; // -= 
+		public const int TimesAssign          = 39; // *= 
+		public const int DivAssign            = 40; // /= 
+		public const int ModAssign            = 41; // %= 
+		public const int BitwiseAndAssign     = 42; // &amp;= 
+		public const int BitwiseOrAssign      = 43; // |= 
+		public const int XorAssign            = 44; // ^= 
+		public const int ShiftLeftAssign      = 45; // &lt;&lt;= 
+		public const int ShiftRightAssign     = 46; // &gt;&gt;= 
+		public const int Pointer              = 47; // -&gt; 
+
+		// ----- keywords -----
+		public const int Abstract             = 48;
+		public const int As                   = 49;
+		public const int Base                 = 50;
+		public const int Bool                 = 51;
+		public const int Break                = 52;
+		public const int Byte                 = 53;
+		public const int Case                 = 54;
+		public const int Catch                = 55;
+		public const int Char                 = 56;
+		public const int Checked              = 57;
+		public const int Class                = 58;
+		public const int Const                = 59;
+		public const int Continue             = 60;
+		public const int Decimal              = 61;
+		public const int Default              = 62;
+		public const int Delegate             = 63;
+		public const int Do                   = 64;
+		public const int Double               = 65;
+		public const int Else                 = 66;
+		public const int Enum                 = 67;
+		public const int Event                = 68;
+		public const int Explicit             = 69;
+		public const int Extern               = 70;
+		public const int False                = 71;
+		public const int Finally              = 72;
+		public const int Fixed                = 73;
+		public const int Float                = 74;
+		public const int For                  = 75;
+		public const int Foreach              = 76;
+		public const int Goto                 = 77;
+		public const int If                   = 78;
+		public const int Implicit             = 79;
+		public const int In                   = 80;
+		public const int Int                  = 81;
+		public const int Interface            = 82;
+		public const int Internal             = 83;
+		public const int Is                   = 84;
+		public const int Lock                 = 85;
+		public const int Long                 = 86;
+		public const int Namespace            = 87;
+		public const int New                  = 88;
+		public const int Null                 = 89;
+		public const int Object               = 90;
+		public const int Operator             = 91;
+		public const int Out                  = 92;
+		public const int Override             = 93;
+		public const int Params               = 94;
+		public const int Private              = 95;
+		public const int Protected            = 96;
+		public const int Public               = 97;
+		public const int Readonly             = 98;
+		public const int Ref                  = 99;
+		public const int Return               = 100;
+		public const int Sbyte                = 101;
+		public const int Sealed               = 102;
+		public const int Short                = 103;
+		public const int Sizeof               = 104;
+		public const int Stackalloc           = 105;
+		public const int Static               = 106;
+		public const int String               = 107;
+		public const int Struct               = 108;
+		public const int Switch               = 109;
+		public const int This                 = 110;
+		public const int Throw                = 111;
+		public const int True                 = 112;
+		public const int Try                  = 113;
+		public const int Typeof               = 114;
+		public const int Uint                 = 115;
+		public const int Ulong                = 116;
+		public const int Unchecked            = 117;
+		public const int Unsafe               = 118;
+		public const int Ushort               = 119;
+		public const int Using                = 120;
+		public const int Virtual              = 121;
+		public const int Void                 = 122;
+		public const int Volatile             = 123;
+		public const int While                = 124;
+
+		public static string GetTokenString(int token)
+		{
+			switch (token) {
+				case Assign:
+					return &quot;=&quot;;
+				case Plus:
+					return &quot;+&quot;;
+				case Minus:
+					return &quot;-&quot;;
+				case Times:
+					return &quot;*&quot;;
+				case Div:
+					return &quot;/&quot;;
+				case Mod:
+					return &quot;%&quot;;
+				case Colon:
+					return &quot;:&quot;;
+				case Semicolon:
+					return &quot;;&quot;;
+				case Question:
+					return &quot;?&quot;;
+				case Comma:
+					return &quot;,&quot;;
+				case Dot:
+					return &quot;.&quot;;
+				case OpenCurlyBrace:
+					return &quot;{&quot;;
+				case CloseCurlyBrace:
+					return &quot;}&quot;;
+				case OpenSquareBracket:
+					return &quot;[&quot;;
+				case CloseSquareBracket:
+					return &quot;]&quot;;
+				case OpenParenthesis:
+					return &quot;(&quot;;
+				case CloseParenthesis:
+					return &quot;)&quot;;
+				case GreaterThan:
+					return &quot;&gt;&quot;;
+				case LessThan:
+					return &quot;&lt;&quot;;
+				case Not:
+					return &quot;!&quot;;
+				case LogicalAnd:
+					return &quot;&amp;&amp;&quot;;
+				case LogicalOr:
+					return &quot;||&quot;;
+				case BitwiseComplement:
+					return &quot;~&quot;;
+				case BitwiseAnd:
+					return &quot;&amp;&quot;;
+				case BitwiseOr:
+					return &quot;|&quot;;
+				case Xor:
+					return &quot;^&quot;;
+				case Increment:
+					return &quot;++&quot;;
+				case Decrement:
+					return &quot;--&quot;;
+				case Equal:
+					return &quot;==&quot;;
+				case NotEqual:
+					return &quot;!=&quot;;
+				case GreaterEqual:
+					return &quot;&gt;=&quot;;
+				case LessEqual:
+					return &quot;&lt;=&quot;;
+				case ShiftLeft:
+					return &quot;&lt;&lt;&quot;;
+				case ShiftRight:
+					return &quot;&gt;&gt;&quot;;
+				case PlusAssign:
+					return &quot;+=&quot;;
+				case MinusAssign:
+					return &quot;-=&quot;;
+				case TimesAssign:
+					return &quot;*=&quot;;
+				case DivAssign:
+					return &quot;/=&quot;;
+				case ModAssign:
+					return &quot;%=&quot;;
+				case BitwiseAndAssign:
+					return &quot;&amp;=&quot;;
+				case BitwiseOrAssign:
+					return &quot;|=&quot;;
+				case XorAssign:
+					return &quot;^=&quot;;
+				case ShiftLeftAssign:
+					return &quot;&lt;&lt;=&quot;;
+				case ShiftRightAssign:
+					return &quot;&gt;&gt;=&quot;;
+				case Pointer:
+					return &quot;-&gt;&quot;;
+				case Abstract:
+					return &quot;abstract&quot;;
+				case As:
+					return &quot;as&quot;;
+				case Base:
+					return &quot;base&quot;;
+				case Bool:
+					return &quot;bool&quot;;
+				case Break:
+					return &quot;break&quot;;
+				case Byte:
+					return &quot;byte&quot;;
+				case Case:
+					return &quot;case&quot;;
+				case Catch:
+					return &quot;catch&quot;;
+				case Char:
+					return &quot;char&quot;;
+				case Checked:
+					return &quot;checked&quot;;
+				case Class:
+					return &quot;class&quot;;
+				case Const:
+					return &quot;const&quot;;
+				case Continue:
+					return &quot;continue&quot;;
+				case Decimal:
+					return &quot;decimal&quot;;
+				case Default:
+					return &quot;default&quot;;
+				case Delegate:
+					return &quot;delegate&quot;;
+				case Do:
+					return &quot;do&quot;;
+				case Double:
+					return &quot;double&quot;;
+				case Else:
+					return &quot;else&quot;;
+				case Enum:
+					return &quot;enum&quot;;
+				case Event:
+					return &quot;event&quot;;
+				case Explicit:
+					return &quot;explicit&quot;;
+				case Extern:
+					return &quot;extern&quot;;
+				case False:
+					return &quot;false&quot;;
+				case Finally:
+					return &quot;finally&quot;;
+				case Fixed:
+					return &quot;fixed&quot;;
+				case Float:
+					return &quot;float&quot;;
+				case For:
+					return &quot;for&quot;;
+				case Foreach:
+					return &quot;foreach&quot;;
+				case Goto:
+					return &quot;goto&quot;;
+				case If:
+					return &quot;if&quot;;
+				case Implicit:
+					return &quot;implicit&quot;;
+				case In:
+					return &quot;in&quot;;
+				case Int:
+					return &quot;int&quot;;
+				case Interface:
+					return &quot;interface&quot;;
+				case Internal:
+					return &quot;internal&quot;;
+				case Is:
+					return &quot;is&quot;;
+				case Lock:
+					return &quot;lock&quot;;
+				case Long:
+					return &quot;long&quot;;
+				case Namespace:
+					return &quot;namespace&quot;;
+				case New:
+					return &quot;new&quot;;
+				case Null:
+					return &quot;null&quot;;
+				case Object:
+					return &quot;object&quot;;
+				case Operator:
+					return &quot;operator&quot;;
+				case Out:
+					return &quot;out&quot;;
+				case Override:
+					return &quot;override&quot;;
+				case Params:
+					return &quot;params&quot;;
+				case Private:
+					return &quot;private&quot;;
+				case Protected:
+					return &quot;protected&quot;;
+				case Public:
+					return &quot;public&quot;;
+				case Readonly:
+					return &quot;readonly&quot;;
+				case Ref:
+					return &quot;ref&quot;;
+				case Return:
+					return &quot;return&quot;;
+				case Sbyte:
+					return &quot;sbyte&quot;;
+				case Sealed:
+					return &quot;sealed&quot;;
+				case Short:
+					return &quot;short&quot;;
+				case Sizeof:
+					return &quot;sizeof&quot;;
+				case Stackalloc:
+					return &quot;stackalloc&quot;;
+				case Static:
+					return &quot;static&quot;;
+				case String:
+					return &quot;string&quot;;
+				case Struct:
+					return &quot;struct&quot;;
+				case Switch:
+					return &quot;switch&quot;;
+				case This:
+					return &quot;this&quot;;
+				case Throw:
+					return &quot;throw&quot;;
+				case True:
+					return &quot;true&quot;;
+				case Try:
+					return &quot;try&quot;;
+				case Typeof:
+					return &quot;typeof&quot;;
+				case Uint:
+					return &quot;uint&quot;;
+				case Ulong:
+					return &quot;ulong&quot;;
+				case Unchecked:
+					return &quot;unchecked&quot;;
+				case Unsafe:
+					return &quot;unsafe&quot;;
+				case Ushort:
+					return &quot;ushort&quot;;
+				case Using:
+					return &quot;using&quot;;
+				case Virtual:
+					return &quot;virtual&quot;;
+				case Void:
+					return &quot;void&quot;;
+				case Volatile:
+					return &quot;volatile&quot;;
+				case While:
+					return &quot;while&quot;;
+			}
+			return &quot;&lt;unknown&gt;&quot;;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/Parser/generated/trace.txt
===================================================================

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/OutputFormatter.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/OutputFormatter.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/OutputFormatter.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,219 @@
+// OutputFormatter.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Text;
+using System.Collections;
+using System.Diagnostics;
+
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
+{
+	public class OutputFormatter
+	{
+		int           indentationLevel = 0;
+		StringBuilder text             = new StringBuilder();
+		Lexer         lexer; 
+		bool          indent       = true;
+		bool          doNewLine      = true;
+		bool          emitSemicolon = true;
+		public string Text {
+			get {
+				return text.ToString();
+			}
+		}
+		
+		public bool DoIndent {
+			get {
+				return indent;
+			}
+			set {
+				indent = value;
+			}
+		}
+		public bool DoNewLine {
+			get {
+				return doNewLine;
+			}
+			set {
+				doNewLine = value;
+			}
+		}
+		public bool EmitSemicolon {
+			get {
+				return emitSemicolon;
+			}
+			set {
+				emitSemicolon = value;
+			}
+		}
+		
+		public int IndentationLevel {
+			get {
+				return indentationLevel;
+			}
+			set {
+				indentationLevel = value;
+			}
+		}
+		Token token;
+		public OutputFormatter(string originalSourceFile)
+		{
+			lexer = new Lexer(new StringReader(originalSourceFile));
+//			token = lexer.NextToken();
+//			PrintSpecials(token.kind);
+		}
+		
+		public void Indent()
+		{
+			if (DoIndent) {
+				for (int i = 0; i &lt; indentationLevel; ++i) {
+					text.Append('\t');
+				}
+			}
+		}
+		
+		public void Space()
+		{
+			text.Append(' ');
+		}
+		bool gotBlankLine  = false;
+		int currentSpecial = 0;
+		
+		void PrintSpecials(int tokenKind)
+		{
+			if (currentSpecial &gt;= lexer.SpecialTracker.CurrentSpecials.Count) {
+				return;
+			}
+			object o = lexer.SpecialTracker.CurrentSpecials[currentSpecial++];
+			if (o is Comment) {
+//				Console.WriteLine(&quot;COMMENT &quot; + o);	
+				Comment comment = (Comment)o;
+				switch (comment.CommentType) {
+					case CommentType.SingleLine:
+						text.Append(&quot;//&quot;);	
+						text.Append(comment.CommentText);	
+						text.Append(&quot;\n&quot;);
+						Indent();
+						break;
+					case CommentType.Documentation:
+						text.Append(&quot;///&quot;);	
+						text.Append(comment.CommentText);	
+						text.Append(&quot;\n&quot;);	
+						Indent();
+						break;
+					case CommentType.Block:
+						text.Append(&quot;/*&quot;);	
+						text.Append(comment.CommentText);	
+						text.Append(&quot;*/\n&quot;);	
+						Indent();
+						break;
+				}
+				PrintSpecials(tokenKind);
+			} else if (o is BlankLine) {
+				if (!gotBlankLine) {
+//						text.Append(&quot;\n&quot;);
+//						Indent();
+				} 
+				gotBlankLine = false;
+				PrintSpecials(tokenKind);
+			} else if (o is PreProcessingDirective) { 
+//				Console.WriteLine(&quot;PPD:&quot; + o);	
+				text.Append(&quot;\n&quot;);
+				PreProcessingDirective ppd = (PreProcessingDirective)o;
+				text.Append(ppd.Cmd);
+				if (ppd.Arg != null &amp;&amp; ppd.Arg.Length &gt; 0) {
+					text.Append(&quot; &quot;);
+					text.Append(ppd.Arg);
+				}
+				text.Append(&quot;\n&quot;);
+				Indent();
+				PrintSpecials(tokenKind);
+			} else {
+				int kind = (int)o;
+//				Console.WriteLine(kind + &quot; -- &quot; + Tokens.GetTokenString(kind));
+				if (kind != tokenKind) {
+					PrintSpecials(tokenKind);
+				}
+			}
+		}
+		
+		public void NewLine()
+		{
+			if (DoNewLine) {
+				text.Append(&quot;\n&quot;);
+				gotBlankLine = true;
+			}
+		}
+		
+		public void EndFile()
+		{
+			while (this.token == null || this.token.kind &gt; 0) {
+				this.token = lexer.NextToken();
+				PrintSpecials(token.kind);
+			}
+			PrintSpecials(-1);
+//			foreach (object o in lexer.SpecialTracker.CurrentSpecials) {
+//				Console.WriteLine(o);
+//			}
+		}
+		
+		public void PrintTokenList(ArrayList tokenList)
+		{
+			ArrayList trackList = (ArrayList)tokenList.Clone();
+			while (this.token == null || trackList.Count &gt; 0) {
+				this.token = lexer.NextToken();
+				PrintSpecials(this.token.kind);
+				for (int i = 0; i &lt; trackList.Count; ++i) {
+					trackList.RemoveAt(i);
+					break;
+				}
+			}
+			foreach (int token in tokenList) {
+				text.Append(Tokens.GetTokenString(token));
+				Space();
+			}
+		}
+		
+		public void PrintToken(int token)
+		{
+//			Console.WriteLine(&quot;PRINT TOKEN:&quot; + token);
+			if (token == Tokens.Semicolon &amp;&amp; !EmitSemicolon) {
+				return;
+			}
+			while (this.token == null || this.token.kind &gt; 0) {
+				this.token = lexer.NextToken();
+				PrintSpecials(this.token.kind);
+				if (this.token.kind == token) {
+					break;
+				}
+			}
+			text.Append(Tokens.GetTokenString(token));
+			gotBlankLine = false;
+		}
+		
+		
+		public void PrintIdentifier(string identifier)
+		{
+			this.token = lexer.NextToken();
+			PrintSpecials(token.kind);
+			text.Append(identifier);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintData.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintData.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintData.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,208 @@
+&#239;&#187;&#191;// PrettyPrintData.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Text;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
+{
+	/*
+	public class PrettyPrintData
+	{
+		StringBuilder sourceText = new StringBuilder();
+		int indentationLevel     = 0;
+		IProperties properties   = new DefaultProperties();
+		bool appendedNewLine = false;
+		
+		public bool AppendedNewLine {
+			get {
+				return appendedNewLine;
+			}
+			set {
+				appendedNewLine = value;
+			}
+		}
+		
+		public int IndentationLevel {
+			get {
+				return indentationLevel;
+			}
+			set {
+				indentationLevel = value;
+			}
+		}
+		
+		public IProperties Properties {
+			get {
+				return properties;
+			}
+			set {
+				properties = value;
+			}
+		}
+		
+		public StringBuilder SourceText {
+			get {
+				return sourceText;
+			}
+			set {
+				sourceText = value;
+			}
+		}
+		
+		
+		public PrettyPrintData()
+		{
+			SetDefaultProperties();
+		}
+		
+		public void AppendIndentation()
+		{
+			for (int i = 0; i &lt; indentationLevel; ++i) {
+				AppendText(properties.GetProperty(&quot;IndentationString&quot;).ToString());
+			}
+		}
+		
+		public void AppendNewLine()
+		{
+			AppendText(&quot;\n&quot;);
+			appendedNewLine = true;
+		}
+		
+		public void AppendText(string text)
+		{
+			sourceText.Append(text);
+			appendedNewLine = false;
+		}
+		
+		public void SetDefaultProperties()
+		{
+			// Indent:
+			properties.SetProperty(&quot;IndentationString&quot;, &quot;\t&quot;);
+			properties.SetProperty(&quot;AlignMultilineParameter&quot;, true);
+			properties.SetProperty(&quot;AlignMultilineParameterInCalls&quot;, true);
+			properties.SetProperty(&quot;SpecialElseIfTreatment&quot;, false);
+			properties.SetProperty(&quot;IndentCasesFromSwitch&quot;, true);
+			
+			// Brace Styles:
+			properties.SetProperty(&quot;NamespaceBraceStyle&quot;, BraceStyle.NextLine); // I GET USED!
+			properties.SetProperty(&quot;ClassBraceStyle&quot;, BraceStyle.NextLine); // I GET USED!
+			properties.SetProperty(&quot;EnumBraceStyle&quot;, BraceStyle.EndOfLine); // I GET USED!
+			properties.SetProperty(&quot;MethodBraceStyle&quot;, BraceStyle.NextLine);  // I GET USED!
+			properties.SetProperty(&quot;PropertyBraceStyle&quot;, BraceStyle.EndOfLine); // I GET USED!
+			properties.SetProperty(&quot;InnerPropertyBraceStyle&quot;, BraceStyle.EndOfLine); // I GET USED!
+			properties.SetProperty(&quot;DefaultBraceStyle&quot;, BraceStyle.EndOfLine); // I GET USED!
+			
+			// New Line placement:
+			properties.SetProperty(&quot;ElseOnNewLine&quot;, false);
+			properties.SetProperty(&quot;WhileOnNewLine&quot;, false);
+			properties.SetProperty(&quot;CatchOnNewLine&quot;, false);
+			properties.SetProperty(&quot;FinallyOnNewLine&quot;, false);
+			
+			// Spaces before parentheses:
+			properties.SetProperty(&quot;SpacesBeforeMethodCallParentheses&quot;, false); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeMethodDeclarationParentheses&quot;, false); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeIfParentheses&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeWhileParentheses&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeForParentheses&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeCatchParentheses&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeSwitchParentheses&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeLockParentheses&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeFixedParentheses&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeUsingParentheses&quot;, true);
+			
+			// Spaces around operators:
+			properties.SetProperty(&quot;SpacesAroundAssignments&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesAroundLogicalOperators&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesAroundEqualityOperators&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesAroundRelationalOperators&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesAroundBitWiseOperators&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesAroundAdditiveOperators&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesAroundMulticativeOperators&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesAroundShiftOperators&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesAroundOtherOperators&quot;, true); // I GET USED!
+			
+			// Spaces before left brace:
+			properties.SetProperty(&quot;SpacesBeforeNamespaceBrace&quot;, true);// I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeClassBrace&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeEnumBrace&quot;, true); // I GET USED!
+			
+			properties.SetProperty(&quot;SpacesBeforeMethodDeclarationBrace&quot;, false); // I GET USED!
+			
+			properties.SetProperty(&quot;SpacesBeforeIfBrace&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeElseBrace&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeWhileBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeForBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeDoBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeSwitchBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeTryBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeCatchBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeFinallyBrace&quot;, true);
+			
+			properties.SetProperty(&quot;SpacesBeforeLockBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeFixedBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeUsingBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeCheckedBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeUncheckedBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeUnsafeBrace&quot;, true);
+			
+			properties.SetProperty(&quot;SpacesBeforePropertyBrace&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeGetBrace&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeSetBrace&quot;, true); // I GET USED!
+			properties.SetProperty(&quot;SpacesBeforeEventBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeAddBrace&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeRemoveBrace&quot;, true);
+		
+			// Within Parentheses:
+			properties.SetProperty(&quot;SpacesWithinParentheses&quot;, false); // I GET USED!
+			properties.SetProperty(&quot;SpacesWithinMethodCallParentheses&quot;, false); // I GET USED!
+			properties.SetProperty(&quot;SpacesWithinMethodDeclarationParentheses&quot;, false); // I GET USED!
+			properties.SetProperty(&quot;SpacesWithinIfParentheses&quot;, false);
+			properties.SetProperty(&quot;SpacesWithinWhileParentheses&quot;, false);
+			properties.SetProperty(&quot;SpacesWithinForParentheses&quot;, false);
+			properties.SetProperty(&quot;SpacesWithinCatchParentheses&quot;, false);
+			properties.SetProperty(&quot;SpacesWithinSwitchParentheses&quot;, false);
+			properties.SetProperty(&quot;SpacesWithinTypeCastParentheses&quot;, false);
+			properties.SetProperty(&quot;SpacesWithinLockParentheses&quot;, false);
+			properties.SetProperty(&quot;SpacesWithinUsingParentheses&quot;, false);
+			properties.SetProperty(&quot;SpacesWithinFixedParentheses&quot;, false);
+			
+			// Conditional operator:
+			properties.SetProperty(&quot;SpacesInConditionalBeforeInterr&quot;, true);
+			properties.SetProperty(&quot;SpacesInConditionalAfterInterr&quot;, true);
+			properties.SetProperty(&quot;SpacesInConditionalBeforeColon&quot;, true);
+			properties.SetProperty(&quot;SpacesInConditionalAfterColon&quot;, true);
+			
+			// Other spaces:
+			properties.SetProperty(&quot;SpacesWithinBrackets&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeComma&quot;, false);
+			properties.SetProperty(&quot;SpacesAfterComma&quot;, true);
+			properties.SetProperty(&quot;SpacesBeforeSemicolon&quot;, true);
+			properties.SetProperty(&quot;SpacesAfterSemicolon&quot;, true);
+			properties.SetProperty(&quot;SpacesAfterTypeCast&quot;, true);
+		}
+	}
+	
+	public enum BraceStyle {
+		EndOfLine,
+		NextLine,
+		NextLineShifted,
+		NextLineShifted2
+	}*/
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintUtil.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintUtil.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintUtil.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,358 @@
+&#239;&#187;&#191;// PrettyPrintUtil.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
+{
+	/*
+	public sealed class PrettyPrintUtil
+	{
+		PrettyPrintData prettyPrintData;
+		
+		public PrettyPrintUtil(PrettyPrintData prettyPrintData)
+		{
+			this.prettyPrintData = prettyPrintData;
+		}
+		
+		public void PrintBlock(PrettyPrintVisitor visitor, INode blockNode, string braceStyle, string spacesBeforeBrace)
+		{
+			PrintBlock(visitor, blockNode, braceStyle, spacesBeforeBrace, true);
+		}
+		
+		public void PrintBlock(PrettyPrintVisitor visitor, INode blockNode, string braceStyle, string spacesBeforeBrace, bool appendNewLine)
+		{
+			if (blockNode is BlockStatement &amp;&amp; !(blockNode is SwitchStatement)) {
+				int oldIndentLevel = prettyPrintData.IndentationLevel;
+				
+				new SpecialVisitor(prettyPrintData).VisitSpecial(blockNode.Specials[&quot;before&quot;], false);
+				
+				AppendBrace((BraceStyle)prettyPrintData.Properties.GetProperty(braceStyle),
+				            (bool)prettyPrintData.Properties.GetProperty(spacesBeforeBrace));
+				
+				if (blockNode.Children != null) {
+					foreach (INode node in blockNode.Children) {
+						node.AcceptVisitor(visitor, prettyPrintData);
+					}
+				}
+				new SpecialVisitor(prettyPrintData).VisitSpecial(blockNode.Specials[&quot;after&quot;]);
+				
+				AppendCloseBrace(braceStyle, oldIndentLevel, appendNewLine);
+			} else {
+				prettyPrintData.AppendNewLine();
+				++prettyPrintData.IndentationLevel;
+				blockNode.AcceptVisitor(visitor, prettyPrintData);
+				--prettyPrintData.IndentationLevel;
+				if (appendNewLine) {
+					prettyPrintData.AppendNewLine();
+				}
+			}
+		}
+		
+		
+		public void PrintBlockOrStatementOnSameLine(PrettyPrintVisitor visitor, INode blockNode, string braceStyle, string spacesBeforeBrace, bool appendNewLine)
+		{
+			if (blockNode is BlockStatement &amp;&amp; !(blockNode is SwitchStatement)) {
+				int oldIndentLevel = prettyPrintData.IndentationLevel;
+				
+				new SpecialVisitor(prettyPrintData).VisitSpecial(blockNode.Specials[&quot;before&quot;], false);
+				
+				AppendBrace((BraceStyle)prettyPrintData.Properties.GetProperty(braceStyle),
+				            (bool)prettyPrintData.Properties.GetProperty(spacesBeforeBrace));
+				
+				if (blockNode.Children != null) {
+					foreach (INode node in blockNode.Children) {
+						node.AcceptVisitor(visitor, prettyPrintData);
+					}
+				}
+				new SpecialVisitor(prettyPrintData).VisitSpecial(blockNode.Specials[&quot;after&quot;]);
+				
+				AppendCloseBrace(braceStyle, oldIndentLevel, appendNewLine);
+			} else {
+				//prettyPrintData.AppendNewLine();
+				//++prettyPrintData.IndentationLevel;
+				blockNode.AcceptVisitor(visitor, prettyPrintData);
+				//--prettyPrintData.IndentationLevel;
+				if (appendNewLine) {
+					prettyPrintData.AppendNewLine();
+				}
+			}
+		}
+		
+		public void PrintOptionalBlock(PrettyPrintVisitor visitor, INode parentNode, string braceStyle, string spacesBeforeBrace)
+		{
+			Debug.Assert(parentNode.Children.Count == 1);
+			PrintBlock(visitor, (INode)parentNode.Children[0], braceStyle, spacesBeforeBrace);
+		}
+		
+		public void PrintParameterDeclarationExpression(ParameterDeclarationExpression pde)
+		{
+			if (pde.ParamModifiers != ParamModifiers.In) {
+				prettyPrintData.AppendText(pde.ParamModifiers.ToString().ToLower());
+				prettyPrintData.AppendText(&quot; &quot;);
+			}
+			
+			prettyPrintData.AppendText(pde.TypeReference.Type);
+			prettyPrintData.AppendText(&quot; &quot;);
+			prettyPrintData.AppendText(pde.ParameterName);
+			
+		}
+		
+		public void PrintParameterList(ArrayList parameters, string spacesBeforeProperty, string spacesAfterProperty)
+		{
+			for (int i = 0; i &lt; parameters.Count; ++i) {
+				ParameterDeclarationExpression pde = (ParameterDeclarationExpression)parameters[i];
+				PrintParameterDeclarationExpression(pde);
+				
+				PrintOptionalComma(i, parameters.Count, spacesBeforeProperty, spacesAfterProperty);
+			}
+		}
+		
+		public void PrintOptionalComma(int currentIndex, int count, string spacesBeforeProperty, string spacesAfterProperty)
+		{
+			if (currentIndex + 1 &lt; count) {
+				if ((bool)prettyPrintData.Properties.GetProperty(&quot;SpacesBeforeComma&quot;)) {
+					prettyPrintData.AppendText(&quot; &quot;);
+				}
+				prettyPrintData.AppendText(&quot;,&quot;);
+				if ((bool)prettyPrintData.Properties.GetProperty(&quot;SpacesAfterComma&quot;)) {
+					prettyPrintData.AppendText(&quot; &quot;);
+				}
+			}
+		}
+		
+		public void PrintEqual()
+		{
+			bool insertSpaces = (bool)prettyPrintData.Properties.GetProperty(&quot;SpacesAroundAssignments&quot;);
+			if (insertSpaces) {
+				prettyPrintData.AppendText(&quot; = &quot;);
+			} else {
+				prettyPrintData.AppendText(&quot;=&quot;);
+			}
+		}
+		
+		public void AppendBrace(string braceStyleProperty, string putSpaceBeforeProperty)
+		{
+			AppendBrace((BraceStyle)prettyPrintData.Properties.GetProperty(braceStyleProperty), 
+			            (bool)prettyPrintData.Properties.GetProperty(putSpaceBeforeProperty));
+			
+		}
+		
+		public void AppendBrace(BraceStyle braceStyle, bool putSpaceBefore)
+		{
+			switch (braceStyle) {
+				case BraceStyle.EndOfLine:
+					if (putSpaceBefore) {
+						prettyPrintData.AppendText(&quot; &quot;);
+					}
+					++prettyPrintData.IndentationLevel;
+					prettyPrintData.AppendText(&quot;{&quot;);
+					prettyPrintData.AppendNewLine();
+					break;
+				case BraceStyle.NextLine:
+					prettyPrintData.AppendNewLine();
+					prettyPrintData.AppendIndentation();
+					++prettyPrintData.IndentationLevel;
+					prettyPrintData.AppendText(&quot;{&quot;);
+					prettyPrintData.AppendNewLine();
+					break;
+				case BraceStyle.NextLineShifted:
+					prettyPrintData.AppendNewLine();
+					++prettyPrintData.IndentationLevel;
+					prettyPrintData.AppendIndentation();
+					prettyPrintData.AppendText(&quot;{&quot;);
+					prettyPrintData.AppendNewLine();
+					break;
+				case BraceStyle.NextLineShifted2:
+					prettyPrintData.AppendNewLine();
+					++prettyPrintData.IndentationLevel;
+					prettyPrintData.AppendIndentation();
+					++prettyPrintData.IndentationLevel;
+					prettyPrintData.AppendText(&quot;{&quot;);
+					prettyPrintData.AppendNewLine();
+					break;
+			}
+		}
+		
+		public void AppendCloseBrace(string braceStyleProperty, int baseIndentLevel)
+		{
+			AppendCloseBrace((BraceStyle)prettyPrintData.Properties.GetProperty(braceStyleProperty), 
+			                 baseIndentLevel);
+		}
+		public void AppendCloseBrace(string braceStyleProperty, int baseIndentLevel, bool newLine)
+		{
+			AppendCloseBrace((BraceStyle)prettyPrintData.Properties.GetProperty(braceStyleProperty), 
+			                 baseIndentLevel,
+			                 newLine);
+		}
+		
+		public void AppendCloseBrace(BraceStyle braceStyle, int baseIndentLevel)
+		{
+			AppendCloseBrace(braceStyle, baseIndentLevel, true);
+		}
+		public void AppendCloseBrace(BraceStyle braceStyle, int baseIndentLevel, bool appendNewLine)
+		{
+			switch (braceStyle) {
+				case BraceStyle.EndOfLine:
+					prettyPrintData.IndentationLevel = baseIndentLevel;
+					prettyPrintData.AppendIndentation();prettyPrintData.AppendText(&quot;}&quot;);
+					if (appendNewLine) {
+						prettyPrintData.AppendNewLine();
+					}
+					break;
+				case BraceStyle.NextLine:
+					goto case BraceStyle.EndOfLine;
+				case BraceStyle.NextLineShifted:
+					prettyPrintData.IndentationLevel = baseIndentLevel + 1;
+					prettyPrintData.AppendIndentation();prettyPrintData.AppendText(&quot;}&quot;);
+					prettyPrintData.IndentationLevel = baseIndentLevel;
+					if (appendNewLine) {
+						prettyPrintData.AppendNewLine();
+					}
+					break;
+				case BraceStyle.NextLineShifted2:
+					goto case BraceStyle.NextLineShifted;
+			}
+		}
+		
+		public string GetModifierAttributes(Modifier attr)
+		{
+			if ((attr &amp; Modifier.Public) == Modifier.Public) {
+				return &quot;public &quot;;
+			}
+			
+			if ((attr &amp; Modifier.Private) == Modifier.Private) {
+				return &quot;private &quot;;
+			}
+			
+			if ((attr &amp; (Modifier.Protected | Modifier.Internal)) == (Modifier.Protected | Modifier.Internal) ) {
+				return &quot;protected internal &quot;;
+			}
+			
+			if ((attr &amp; Modifier.Internal)  == Modifier.Internal) {
+				return &quot;internal &quot;;
+			}
+			
+			if ((attr &amp; Modifier.Protected) == Modifier.Protected) {
+				return &quot;protected &quot;;
+			}
+			return String.Empty;
+		}
+		
+		public string GetOperator(BinaryOperatorType type)
+		{
+			switch (type) {
+				case BinaryOperatorType.Add:
+					return &quot;+&quot;;
+				case BinaryOperatorType.BitwiseAnd:
+					return &quot;&amp;&quot;;
+				case BinaryOperatorType.BitwiseOr:
+					return &quot;|&quot;;
+				case BinaryOperatorType.LogicalAnd:
+					return &quot;&amp;&amp;&quot;;
+				case BinaryOperatorType.LogicalOr:
+					return &quot;||&quot;;
+				case BinaryOperatorType.Divide:
+					return &quot;/&quot;;
+				case BinaryOperatorType.GreaterThan:
+					return &quot;&gt;&quot;;
+				case BinaryOperatorType.GreaterThanOrEqual:
+					return &quot;&gt;=&quot;;
+				case BinaryOperatorType.Equality:
+					return &quot;==&quot;;
+				case BinaryOperatorType.InEquality:
+					return &quot;!=&quot;;
+				case BinaryOperatorType.LessThan:
+					return &quot;&lt;&quot;;
+				case BinaryOperatorType.LessThanOrEqual:
+					return &quot;&lt;=&quot;;
+				case BinaryOperatorType.Modulus:
+					return &quot;%&quot;;
+				case BinaryOperatorType.Multiply:
+					return &quot;*&quot;;
+				case BinaryOperatorType.Subtract:
+					return &quot;-&quot;;
+				case BinaryOperatorType.ValueEquality:
+					return &quot;==&quot;;
+				case BinaryOperatorType.ShiftLeft:
+					return &quot;&lt;&lt;&quot;;
+				case BinaryOperatorType.ShiftRight:
+					return &quot;&gt;&gt;&quot;;
+				case BinaryOperatorType.IS:
+					return &quot;is&quot;;
+				case BinaryOperatorType.AS:
+					return &quot;as&quot;;
+				case BinaryOperatorType.ExclusiveOr:
+					return &quot;^&quot;;
+			}
+			return String.Empty;
+		}
+		
+		public bool IsLogicalOperator(BinaryOperatorType type)
+		{
+			return type == BinaryOperatorType.LogicalAnd ||
+			       type == BinaryOperatorType.LogicalOr;
+		
+		}
+		
+		public bool IsEqualityOperator(BinaryOperatorType type)
+		{
+			return type == BinaryOperatorType.ValueEquality ||
+			       type == BinaryOperatorType.Equality ||
+			       type == BinaryOperatorType.InEquality;
+		}
+		
+		public bool IsRelationalOperator(BinaryOperatorType type)
+		{
+			return type == BinaryOperatorType.GreaterThan || 
+			       type == BinaryOperatorType.GreaterThanOrEqual ||
+			       type == BinaryOperatorType.LessThan ||
+			       type == BinaryOperatorType.LessThanOrEqual;
+		}
+		
+		public bool IsBitWiseOperator(BinaryOperatorType type)
+		{
+			return type == BinaryOperatorType.BitwiseAnd || 
+			       type == BinaryOperatorType.BitwiseOr ||
+			       type == BinaryOperatorType.ExclusiveOr;
+		}
+		
+		public bool IsAdditiveOperator(BinaryOperatorType type)
+		{
+			return type == BinaryOperatorType.Add || 
+			       type == BinaryOperatorType.Subtract;
+		}
+		
+		public bool IsMultiplicativeOperator(BinaryOperatorType type)
+		{
+			return type == BinaryOperatorType.Multiply || 
+			       type == BinaryOperatorType.Divide ||
+			       type == BinaryOperatorType.Modulus;
+		}
+		
+		public bool IsShiftOperator(BinaryOperatorType type)
+		{
+			return type == BinaryOperatorType.ShiftLeft || 
+			       type == BinaryOperatorType.ShiftRight;
+		}
+	}*/
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintVisitor.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintVisitor.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/PrettyPrintVisitor.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,1570 @@
+// PrettyPrintVisitor.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Text;
+using System.Collections;
+using System.Diagnostics;
+
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
+{
+	public class PrettyPrintVisitor : AbstractASTVisitor
+	{
+		Errors  errors = new Errors();
+		OutputFormatter outputFormatter;
+		
+		public string Text {
+			get {
+				return outputFormatter.Text;
+			}
+		}
+		public Errors Errors {
+			get {
+				return errors;
+			}
+		}
+		
+		public PrettyPrintVisitor(string originalSourceFile)
+		{
+			outputFormatter = new OutputFormatter(originalSourceFile);
+		}
+		
+		public override object Visit(INode node, object data)
+		{
+			errors.Error(-1, -1, String.Format(&quot;Visited INode (should NEVER HAPPEN)&quot;));
+			Console.WriteLine(&quot;Visitor was: &quot; + this.GetType());
+			Console.WriteLine(&quot;Node was : &quot; + node.GetType());
+			return node.AcceptChildren(this, data);
+		}
+		
+		public override object Visit(AttributeSection section, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+			if (section.AttributeTarget != null &amp;&amp; section.AttributeTarget != String.Empty) {
+				outputFormatter.PrintIdentifier(section.AttributeTarget);
+				outputFormatter.PrintToken(Tokens.Colon);
+				outputFormatter.Space();
+			}
+			Debug.Assert(section.Attributes != null);
+			for (int j = 0; j &lt; section.Attributes.Count; ++j) {
+				ICSharpCode.SharpRefactory.Parser.AST.Attribute a = (ICSharpCode.SharpRefactory.Parser.AST.Attribute)section.Attributes[j];
+				outputFormatter.PrintIdentifier(a.Name);
+				outputFormatter.PrintToken(Tokens.OpenParenthesis);
+				this.AppendCommaSeparatedList(a.PositionalArguments);
+				
+				if (a.NamedArguments != null &amp;&amp; a.NamedArguments.Count &gt; 0) {
+					if (a.PositionalArguments.Count &gt; 0) {
+						outputFormatter.PrintToken(Tokens.Comma);
+						outputFormatter.Space();
+					}
+					for (int i = 0; i &lt; a.NamedArguments.Count; ++i) {
+						NamedArgument n = (NamedArgument)a.NamedArguments[i];
+						outputFormatter.PrintIdentifier(n.Name);
+						outputFormatter.Space();
+						outputFormatter.PrintToken(Tokens.Assign);
+						outputFormatter.Space();
+						n.Expr.AcceptVisitor(this, data);
+						if (i + 1 &lt; a.NamedArguments.Count) {
+							outputFormatter.PrintToken(Tokens.Comma);
+							outputFormatter.Space();
+						}
+					}
+				}
+				outputFormatter.PrintToken(Tokens.CloseParenthesis);
+				if (j + 1 &lt; section.Attributes.Count) {
+					outputFormatter.PrintToken(Tokens.Comma);
+					outputFormatter.Space();
+				}
+			}
+			outputFormatter.PrintToken(Tokens.CloseSquareBracket);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(CompilationUnit compilationUnit, object data)
+		{
+			compilationUnit.AcceptChildren(this, data);
+			outputFormatter.EndFile();
+			return null;
+		}
+		
+		public override object Visit(UsingDeclaration usingDeclaration, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Using);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(usingDeclaration.Namespace);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Using);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(usingAliasDeclaration.Alias);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.Assign);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(usingAliasDeclaration.Namespace);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Namespace);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(namespaceDeclaration.NameSpace);
+			outputFormatter.NewLine();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			namespaceDeclaration.AcceptChildren(this, data);
+			--outputFormatter.IndentationLevel;
+			
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		object VisitModifier(Modifier modifier)
+		{
+			ArrayList tokenList = new ArrayList();
+			if ((modifier &amp; Modifier.Unsafe) != 0) {
+				tokenList.Add(Tokens.Unsafe);
+			}
+			if ((modifier &amp; Modifier.Public) != 0) {
+				tokenList.Add(Tokens.Public);
+			}
+			if ((modifier &amp; Modifier.Private) != 0) {
+				tokenList.Add(Tokens.Private);
+			}
+			if ((modifier &amp; Modifier.Protected) != 0) {
+				tokenList.Add(Tokens.Protected);
+			}
+			if ((modifier &amp; Modifier.Static) != 0) {
+				tokenList.Add(Tokens.Static);
+			}
+			if ((modifier &amp; Modifier.Internal) != 0) {
+				tokenList.Add(Tokens.Internal);
+			}
+			if ((modifier &amp; Modifier.Override) != 0) {
+				tokenList.Add(Tokens.Override);
+			}
+			if ((modifier &amp; Modifier.Abstract) != 0) {
+				tokenList.Add(Tokens.Abstract);
+			}
+			if ((modifier &amp; Modifier.Virtual) != 0) {
+				tokenList.Add(Tokens.Virtual);
+			}
+			if ((modifier &amp; Modifier.New) != 0) {
+				tokenList.Add(Tokens.New);
+			}
+			if ((modifier &amp; Modifier.Sealed) != 0) {
+				tokenList.Add(Tokens.Sealed);
+			}
+			if ((modifier &amp; Modifier.Extern) != 0) {
+				tokenList.Add(Tokens.Extern);
+			}
+			if ((modifier &amp; Modifier.Const) != 0) {
+				tokenList.Add(Tokens.Const);
+			}
+			if ((modifier &amp; Modifier.Readonly) != 0) {
+				tokenList.Add(Tokens.Readonly);
+			}
+			if ((modifier &amp; Modifier.Volatile) != 0) {
+				tokenList.Add(Tokens.Volatile);
+			}
+			outputFormatter.PrintTokenList(tokenList);
+			return null;
+		}
+				
+		object VisitParamModifiers(ParamModifiers modifier)
+		{
+			switch (modifier) {
+				case ParamModifiers.Out:
+					outputFormatter.PrintToken(Tokens.Out);
+					break;
+				case ParamModifiers.Params:
+					outputFormatter.PrintToken(Tokens.Params);
+					break;
+				case ParamModifiers.Ref:
+					outputFormatter.PrintToken(Tokens.Ref);
+					break;
+			}
+			outputFormatter.Space();
+			return null;
+		}
+		
+		object VisitAttributes(ArrayList attributes, object data)
+		{
+			if (attributes == null || attributes.Count &lt;= 0) {
+				return null;
+			}
+			foreach (AttributeSection section in attributes) {
+				Visit(section, data);
+			}
+			return null;
+		}
+		
+		object Visit(TypeReference type, object data)
+		{
+			outputFormatter.PrintIdentifier(type.Type);
+			for (int i = 0; i &lt; type.PointerNestingLevel; ++i) {
+				outputFormatter.PrintToken(Tokens.Times);
+			}
+			if (type.IsArrayType) {
+				for (int i = 0; i &lt; type.RankSpecifier.Length; ++i) {
+					outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+					for (int j = 1; j &lt; type.RankSpecifier[i]; ++j) {
+						outputFormatter.PrintToken(Tokens.Comma);
+					}
+					outputFormatter.PrintToken(Tokens.CloseSquareBracket);
+				}
+			}
+			return null;
+		}
+		
+		object VisitEnumMembers(TypeDeclaration typeDeclaration, object data)
+		{
+			foreach (FieldDeclaration fieldDeclaration in typeDeclaration.Children) {
+				VariableDeclaration f = (VariableDeclaration)fieldDeclaration.Fields[0];
+				VisitAttributes(fieldDeclaration.Attributes, data);
+				outputFormatter.Indent();
+				outputFormatter.PrintIdentifier(f.Name);
+				if (f.Initializer != null) {
+					outputFormatter.Space();
+					outputFormatter.PrintToken(Tokens.Assign);
+					outputFormatter.Space();
+					f.Initializer.AcceptVisitor(this, data);
+				}
+				outputFormatter.PrintToken(Tokens.Comma);
+				outputFormatter.NewLine();
+			}
+			return null;
+		}
+		
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			VisitAttributes(typeDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(typeDeclaration.Modifier);
+			switch (typeDeclaration.Type) {
+				case Types.Class:
+					outputFormatter.PrintToken(Tokens.Class);
+					break;
+				case Types.Enum:
+					outputFormatter.PrintToken(Tokens.Enum);
+					break;
+				case Types.Interface:
+					outputFormatter.PrintToken(Tokens.Interface);
+					break;
+				case Types.Struct:
+					outputFormatter.PrintToken(Tokens.Struct);
+					break;
+			}
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(typeDeclaration.Name);
+			if (typeDeclaration.BaseTypes != null &amp;&amp; typeDeclaration.BaseTypes.Count &gt; 0) {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.Colon);
+				for (int i = 0; i &lt; typeDeclaration.BaseTypes.Count; ++i) {
+					outputFormatter.Space();
+					outputFormatter.PrintIdentifier(typeDeclaration.BaseTypes[i]);
+					if (i + 1 &lt; typeDeclaration.BaseTypes.Count) {
+						outputFormatter.PrintToken(Tokens.Comma);
+						outputFormatter.Space();
+					}
+				}
+			}
+			outputFormatter.NewLine();
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			
+			++outputFormatter.IndentationLevel;
+			if (typeDeclaration.Type == Types.Enum) {
+				VisitEnumMembers(typeDeclaration, data);
+			} else {
+				typeDeclaration.AcceptChildren(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			VisitAttributes(parameterDeclarationExpression.Attributes, data);
+			VisitParamModifiers(parameterDeclarationExpression.ParamModifiers);
+			Visit(parameterDeclarationExpression.TypeReference, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(parameterDeclarationExpression.ParameterName);
+			return null;
+		}
+		
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+			VisitAttributes(delegateDeclaration.Attributes, data);
+			VisitModifier(delegateDeclaration.Modifier);
+			outputFormatter.PrintToken(Tokens.Delegate);
+			outputFormatter.Space();
+			Visit(delegateDeclaration.ReturnType, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(delegateDeclaration.Name);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(delegateDeclaration.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			outputFormatter.PrintIdentifier(variableDeclaration.Name);
+			if (variableDeclaration.Initializer != null) {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.Assign);
+				outputFormatter.Space();
+				variableDeclaration.Initializer.AcceptVisitor(this, data);
+			}
+			return null;
+		}
+		
+		public void AppendCommaSeparatedList(IList list)
+		{
+			if (list != null) {
+				for (int i = 0; i &lt; list.Count; ++i) {
+					((INode)list[i]).AcceptVisitor(this, null);
+					if (i + 1 &lt; list.Count) {
+						outputFormatter.PrintToken(Tokens.Comma);
+						outputFormatter.Space();
+					}
+					if ((i + 1) % 10 == 0) {
+						outputFormatter.NewLine();
+						outputFormatter.Indent();
+					}
+				}
+			}
+		}
+		
+		public override object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			VisitAttributes(eventDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(eventDeclaration.Modifier);
+			outputFormatter.PrintToken(Tokens.Event);
+			outputFormatter.Space();
+			Visit(eventDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			
+			if (eventDeclaration.VariableDeclarators != null &amp;&amp; eventDeclaration.VariableDeclarators.Count &gt; 0) {
+				AppendCommaSeparatedList(eventDeclaration.VariableDeclarators);
+				outputFormatter.PrintToken(Tokens.Semicolon);
+				outputFormatter.NewLine();
+			} else {
+				outputFormatter.PrintIdentifier(eventDeclaration.Name);
+				if (eventDeclaration.AddRegion == null &amp;&amp; eventDeclaration.RemoveRegion == null) {
+					outputFormatter.PrintToken(Tokens.Semicolon);
+				} else {
+					outputFormatter.Space();
+					outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+					outputFormatter.NewLine();
+					++outputFormatter.IndentationLevel;
+					if (eventDeclaration.AddRegion != null) {
+						eventDeclaration.AddRegion.AcceptVisitor(this, data);
+					}
+					if (eventDeclaration.RemoveRegion != null) {
+						eventDeclaration.RemoveRegion.AcceptVisitor(this, data);
+					}
+					--outputFormatter.IndentationLevel;
+					outputFormatter.Indent();
+					outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+				}
+				outputFormatter.NewLine();
+			}
+			return null;
+		}
+		
+		public override object Visit(EventAddRegion addRegion, object data)
+		{
+			VisitAttributes(addRegion.Attributes, data);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(&quot;add&quot;);
+			if (addRegion.Block == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				addRegion.Block.AcceptChildren(this, false);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(EventRemoveRegion removeRegion, object data)
+		{
+			VisitAttributes(removeRegion.Attributes, data);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(&quot;remove&quot;);
+			if (removeRegion.Block == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				removeRegion.Block.AcceptChildren(this, false);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			VisitAttributes(fieldDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(fieldDeclaration.Modifier);
+			Visit(fieldDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			AppendCommaSeparatedList(fieldDeclaration.Fields);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			VisitAttributes(constructorDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(constructorDeclaration.Modifier);
+			outputFormatter.PrintIdentifier(constructorDeclaration.Name);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(constructorDeclaration.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			
+			if (constructorDeclaration.ConstructorInitializer != null) {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.Colon);
+				outputFormatter.Space();
+				if (constructorDeclaration.ConstructorInitializer.ConstructorInitializerType == ConstructorInitializerType.Base) {
+					outputFormatter.PrintToken(Tokens.Base);
+				} else {
+					outputFormatter.PrintToken(Tokens.This);
+				}
+				outputFormatter.PrintToken(Tokens.OpenParenthesis);
+				AppendCommaSeparatedList(constructorDeclaration.ConstructorInitializer.Arguments);
+				outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			}
+			
+			outputFormatter.NewLine();
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			constructorDeclaration.Body.AcceptChildren(this, data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(DestructorDeclaration destructorDeclaration, object data)
+		{
+			VisitAttributes(destructorDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(destructorDeclaration.Modifier);
+			outputFormatter.PrintToken(Tokens.BitwiseComplement);
+			outputFormatter.PrintIdentifier(destructorDeclaration.Name);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.NewLine();
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			destructorDeclaration.Body.AcceptChildren(this, data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			VisitAttributes(methodDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(methodDeclaration.Modifier);
+			Visit(methodDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(methodDeclaration.Name);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(methodDeclaration.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			if (methodDeclaration.Body == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.NewLine();
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				methodDeclaration.Body.AcceptChildren(this, data);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(IndexerDeclaration indexerDeclaration, object data)
+		{
+			VisitAttributes(indexerDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(indexerDeclaration.Modifier);
+			Visit(indexerDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			if (indexerDeclaration.NamespaceName != null &amp;&amp; indexerDeclaration.NamespaceName.Length &gt; 0) {
+				outputFormatter.PrintIdentifier(indexerDeclaration.NamespaceName);
+				outputFormatter.PrintToken(Tokens.Dot);
+			}
+			outputFormatter.PrintToken(Tokens.This);
+			outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+			AppendCommaSeparatedList(indexerDeclaration.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseSquareBracket);
+			outputFormatter.NewLine();
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (indexerDeclaration.GetRegion != null) {
+				indexerDeclaration.GetRegion.AcceptVisitor(this, data);
+			}
+			if (indexerDeclaration.SetRegion != null) {
+				indexerDeclaration.SetRegion.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			VisitAttributes(propertyDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(propertyDeclaration.Modifier);
+			Visit(propertyDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(propertyDeclaration.Name);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (propertyDeclaration.GetRegion != null) {
+				propertyDeclaration.GetRegion.AcceptVisitor(this, data);
+			}
+			if (propertyDeclaration.SetRegion != null) {
+				propertyDeclaration.SetRegion.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(PropertyGetRegion getRegion, object data)
+		{
+			this.VisitAttributes(getRegion.Attributes, data);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(&quot;get&quot;);
+			if (getRegion.Block == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				getRegion.Block.AcceptChildren(this, false);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(PropertySetRegion setRegion, object data)
+		{
+			this.VisitAttributes(setRegion.Attributes, data);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(&quot;set&quot;);
+			if (setRegion.Block == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				setRegion.Block.AcceptChildren(this, false);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(OperatorDeclaration operatorDeclaration, object data)
+		{
+			VisitAttributes(operatorDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(operatorDeclaration.Modifier);
+			switch (operatorDeclaration.OpratorDeclarator.OperatorType) {
+				case OperatorType.Explicit:
+					outputFormatter.PrintToken(Tokens.Explicit);
+					break;
+				case OperatorType.Implicit:
+					outputFormatter.PrintToken(Tokens.Implicit);
+					break;
+				default:
+					Visit(operatorDeclaration.OpratorDeclarator.TypeReference, data);
+					break;
+			}
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.Operator);
+			outputFormatter.Space();
+			if (!operatorDeclaration.OpratorDeclarator.IsConversion) {
+				outputFormatter.PrintIdentifier(Tokens.GetTokenString(operatorDeclaration.OpratorDeclarator.OverloadOperatorToken));
+			} else {
+				Visit(operatorDeclaration.OpratorDeclarator.TypeReference, data);
+			}
+			
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(operatorDeclaration.OpratorDeclarator.FirstParameterType, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(operatorDeclaration.OpratorDeclarator.FirstParameterName);
+			if (operatorDeclaration.OpratorDeclarator.OperatorType == OperatorType.Binary) {
+				outputFormatter.PrintToken(Tokens.Comma);
+				outputFormatter.Space();
+				Visit(operatorDeclaration.OpratorDeclarator.SecondParameterType, data);
+				outputFormatter.Space();
+				outputFormatter.PrintIdentifier(operatorDeclaration.OpratorDeclarator.SecondParameterName);
+			}
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			
+			if (operatorDeclaration.Body == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+				outputFormatter.NewLine();
+			} else {
+				outputFormatter.NewLine();
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				operatorDeclaration.Body.AcceptChildren(this, data);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+				outputFormatter.NewLine();
+			}
+			return null;
+		}
+		
+		public override object Visit(EmptyStatement emptyStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		public override object Visit(BlockStatement blockStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			blockStatement.AcceptChildren(this, true);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(ForStatement forStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.For);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			outputFormatter.DoIndent = false;
+			outputFormatter.DoNewLine = false;
+			outputFormatter.EmitSemicolon = false;
+			if (forStatement.Initializers != null &amp;&amp; forStatement.Initializers.Count &gt; 0) {
+				for (int i = 0; i &lt; forStatement.Initializers.Count; ++i) {
+					INode node = (INode)forStatement.Initializers[i];
+					node.AcceptVisitor(this, false);
+					if (i + 1 &lt; forStatement.Initializers.Count) {
+						outputFormatter.PrintToken(Tokens.Comma);
+					}
+				}
+			} 
+			outputFormatter.EmitSemicolon = true;
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.EmitSemicolon = false;
+			if (forStatement.Condition != null) {
+				outputFormatter.Space();
+				forStatement.Condition.AcceptVisitor(this, data);
+			}
+			outputFormatter.EmitSemicolon = true;
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.EmitSemicolon = false;
+			if (forStatement.Iterator != null &amp;&amp; forStatement.Iterator.Count &gt; 0) {
+				outputFormatter.Space();
+				for (int i = 0; i &lt; forStatement.Iterator.Count; ++i) {
+					INode node = (INode)forStatement.Iterator[i];
+					node.AcceptVisitor(this, false);
+					if (i + 1 &lt; forStatement.Iterator.Count) {
+						outputFormatter.PrintToken(Tokens.Comma);
+					}
+				}
+			}
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.EmitSemicolon = true;
+			outputFormatter.DoNewLine     = true;
+			outputFormatter.DoIndent      = true;
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (forStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)forStatement.EmbeddedStatement, false);
+			} else {
+				forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			return null;
+		}
+		
+		public override object Visit(ForeachStatement foreachStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Foreach);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(foreachStatement.TypeReference, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(foreachStatement.VariableName);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.In);
+			outputFormatter.Space();
+			foreachStatement.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (foreachStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)foreachStatement.EmbeddedStatement, false);
+			} else {
+				foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			return null;
+		}
+		
+		public override object Visit(WhileStatement whileStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.While);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			whileStatement.Condition.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (whileStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)whileStatement.EmbeddedStatement, false);
+			} else {
+				whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			return null;
+		}
+		
+		public override object Visit(DoWhileStatement doWhileStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Do);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (doWhileStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)doWhileStatement.EmbeddedStatement, false);
+			} else {
+				doWhileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.While);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			doWhileStatement.Condition.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(BreakStatement breakStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Break);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(ContinueStatement continueStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Continue);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(CheckedStatement checkedStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Checked);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			checkedStatement.Block.AcceptChildren(this, false);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(UncheckedStatement uncheckedStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Unchecked);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			uncheckedStatement.Block.AcceptVisitor(this, false);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(FixedStatement fixedStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Fixed);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(fixedStatement.TypeReference, data);
+			outputFormatter.Space();
+			AppendCommaSeparatedList(fixedStatement.PointerDeclarators);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (fixedStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)fixedStatement.EmbeddedStatement, false);
+			} else {
+				fixedStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Goto);
+			outputFormatter.Space();
+			if (gotoCaseStatement.IsDefaultCase) {
+				outputFormatter.PrintToken(Tokens.Default);
+			} else {
+				outputFormatter.PrintToken(Tokens.Case);
+				outputFormatter.Space();
+				gotoCaseStatement.CaseExpression.AcceptVisitor(this, data);
+			}
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(GotoStatement gotoStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Goto);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(gotoStatement.Label);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(IfElseStatement ifElseStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.If);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			ifElseStatement.Condition.AcceptVisitor(this,data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			ifElseStatement.EmbeddedStatement.AcceptVisitor(this,data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Else);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			ifElseStatement.EmbeddedElseStatement.AcceptVisitor(this,data);
+			--outputFormatter.IndentationLevel;
+			return null;
+		}
+		
+		public override object Visit(IfStatement ifStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.If);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			ifStatement.Condition.AcceptVisitor(this,data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			++outputFormatter.IndentationLevel;
+			ifStatement.EmbeddedStatement.AcceptVisitor(this,data);
+			--outputFormatter.IndentationLevel;
+			return null;
+		}
+		
+		public override object Visit(LabelStatement labelStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(labelStatement.Label);
+			outputFormatter.PrintToken(Tokens.Colon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(LockStatement lockStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Lock);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			lockStatement.LockExpression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			
+			++outputFormatter.IndentationLevel;
+			lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(ReturnStatement returnStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Return);
+			if (returnStatement.ReturnExpression != null) {
+				outputFormatter.Space();
+				returnStatement.ReturnExpression.AcceptVisitor(this, data);
+			}
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(SwitchStatement switchStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Switch);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			switchStatement.SwitchExpression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			foreach (SwitchSection section in switchStatement.SwitchSections) {
+				for (int i = 0; i &lt; section.SwitchLabels.Count; ++i) {
+					Expression label = (Expression)section.SwitchLabels[i];
+					if (label == null) {
+						outputFormatter.Indent();
+						outputFormatter.PrintToken(Tokens.Default);
+						outputFormatter.PrintToken(Tokens.Colon);
+						outputFormatter.NewLine();
+						continue;
+					}
+					
+					outputFormatter.Indent();
+					outputFormatter.PrintToken(Tokens.Case);
+					outputFormatter.Space();
+					label.AcceptVisitor(this, data);
+					outputFormatter.PrintToken(Tokens.Colon);
+					outputFormatter.NewLine();
+				}
+				
+				++outputFormatter.IndentationLevel;
+				section.AcceptChildren(this, data);
+				--outputFormatter.IndentationLevel;
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(ThrowStatement throwStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Throw);
+			if (throwStatement.ThrowExpression != null) {
+				outputFormatter.Space();
+				throwStatement.ThrowExpression.AcceptVisitor(this, data);
+			}
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Try);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			
+			++outputFormatter.IndentationLevel;
+			tryCatchStatement.StatementBlock.AcceptChildren(this, data);
+			--outputFormatter.IndentationLevel;
+			
+			if (tryCatchStatement.CatchClauses != null) {
+//				int generated = 0;
+				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
+					outputFormatter.Indent();
+					outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+					outputFormatter.Space();
+					outputFormatter.PrintToken(Tokens.Catch);
+					outputFormatter.Space();
+					if (catchClause.Type == null) {
+					} else {
+						outputFormatter.PrintToken(Tokens.OpenParenthesis);
+						outputFormatter.PrintIdentifier(catchClause.Type);
+						if (catchClause.VariableName != null) {
+							outputFormatter.Space();
+							outputFormatter.PrintIdentifier(catchClause.VariableName);
+						}
+						outputFormatter.PrintToken(Tokens.CloseParenthesis);
+					}
+					outputFormatter.Space();
+					outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+					outputFormatter.NewLine();
+					++outputFormatter.IndentationLevel;
+					catchClause.StatementBlock.AcceptChildren(this, data);
+					--outputFormatter.IndentationLevel;
+				}
+			}
+			
+			if (tryCatchStatement.FinallyBlock != null) {
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.Finally);
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				tryCatchStatement.FinallyBlock.AcceptChildren(this, data);
+				--outputFormatter.IndentationLevel;
+			}
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(UsingStatement usingStatement, object data)
+		{
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Using);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			outputFormatter.DoIndent = false;
+			outputFormatter.DoNewLine = false;
+			outputFormatter.EmitSemicolon = false;
+			
+			usingStatement.UsingStmnt.AcceptVisitor(this,data);
+			outputFormatter.DoIndent = true;
+			outputFormatter.DoNewLine = true;
+			outputFormatter.EmitSemicolon = true;
+			
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			
+			++outputFormatter.IndentationLevel;
+			usingStatement.EmbeddedStatement.AcceptVisitor(this,data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+//			Console.WriteLine(localVariableDeclaration);
+			outputFormatter.Indent();
+			VisitModifier(localVariableDeclaration.Modifier);
+			Visit(localVariableDeclaration.Type, data);
+			outputFormatter.Space();
+			this.AppendCommaSeparatedList(localVariableDeclaration.Variables);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+		public override object Visit(StatementExpression statementExpression, object data)
+		{
+			outputFormatter.Indent();
+			statementExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
+			return null;
+		}
+		
+#region Expressions
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.New);
+			outputFormatter.Space();
+			Visit(arrayCreateExpression.CreateType, null);
+			for (int i = 0; i &lt; arrayCreateExpression.Parameters.Count; ++i) {
+				outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+				ArrayCreationParameter creationParameter = (ArrayCreationParameter)arrayCreateExpression.Parameters[i];
+				if (creationParameter.IsExpressionList) {
+					AppendCommaSeparatedList(creationParameter.Expressions);
+				} else {
+					for (int j = 0; j &lt; creationParameter.Dimensions; ++j) {
+						outputFormatter.PrintToken(Tokens.Comma);
+					}
+				}
+				outputFormatter.PrintToken(Tokens.CloseSquareBracket);
+			}
+			
+			
+			if (arrayCreateExpression.ArrayInitializer != null) {
+				outputFormatter.Space();
+				arrayCreateExpression.ArrayInitializer.AcceptVisitor(this, null);
+			}
+			return null;
+		}
+		
+		public override object Visit(ArrayInitializerExpression arrayCreateExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			this.AppendCommaSeparatedList(arrayCreateExpression.CreateExpressions);
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			return null;
+		}
+		
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			assignmentExpression.Left.AcceptVisitor(this, data);
+			outputFormatter.Space();
+			switch (assignmentExpression.Op) {
+				case AssignmentOperatorType.Assign:
+					outputFormatter.PrintToken(Tokens.Assign);
+					break;
+				case AssignmentOperatorType.Add:
+					outputFormatter.PrintToken(Tokens.PlusAssign);
+					break;
+				case AssignmentOperatorType.Subtract:
+					outputFormatter.PrintToken(Tokens.MinusAssign);
+					break;
+				case AssignmentOperatorType.Multiply:
+					outputFormatter.PrintToken(Tokens.TimesAssign);
+					break;
+				case AssignmentOperatorType.Divide:
+					outputFormatter.PrintToken(Tokens.DivAssign);
+					break;
+				case AssignmentOperatorType.ShiftLeft:
+					outputFormatter.PrintToken(Tokens.ShiftLeftAssign);
+					break;
+				case AssignmentOperatorType.ShiftRight:
+					outputFormatter.PrintToken(Tokens.ShiftRightAssign);
+					break;
+				case AssignmentOperatorType.ExclusiveOr:
+					outputFormatter.PrintToken(Tokens.XorAssign);
+					break;
+				case AssignmentOperatorType.Modulus:
+					outputFormatter.PrintToken(Tokens.ModAssign);
+					break;
+				case AssignmentOperatorType.BitwiseAnd:
+					outputFormatter.PrintToken(Tokens.BitwiseAndAssign);
+					break;
+				case AssignmentOperatorType.BitwiseOr:
+					outputFormatter.PrintToken(Tokens.BitwiseOrAssign);
+					break;
+			}
+			outputFormatter.Space();
+			assignmentExpression.Right.AcceptVisitor(this, data);
+			return null;
+		}
+		
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.Base);
+			return null;
+		}
+		
+		public override object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			binaryOperatorExpression.Left.AcceptVisitor(this, data);
+			outputFormatter.Space();
+			switch (binaryOperatorExpression.Op) {
+				case BinaryOperatorType.Add:
+					outputFormatter.PrintToken(Tokens.Plus);
+					break;
+				
+				case BinaryOperatorType.Subtract:
+					outputFormatter.PrintToken(Tokens.Minus);
+					break;
+				
+				case BinaryOperatorType.Multiply:
+					outputFormatter.PrintToken(Tokens.Times);
+					break;
+				
+				case BinaryOperatorType.Divide:
+					outputFormatter.PrintToken(Tokens.Div);
+					break;
+				
+				case BinaryOperatorType.Modulus:
+					outputFormatter.PrintToken(Tokens.Mod);
+					break;
+				
+				case BinaryOperatorType.ShiftLeft:
+					outputFormatter.PrintToken(Tokens.ShiftLeft);
+					break;
+				
+				case BinaryOperatorType.ShiftRight:
+					outputFormatter.PrintToken(Tokens.ShiftRight);
+					break;
+				
+				case BinaryOperatorType.BitwiseAnd:
+					outputFormatter.PrintToken(Tokens.BitwiseAnd);
+					break;
+				case BinaryOperatorType.BitwiseOr:
+					outputFormatter.PrintToken(Tokens.BitwiseOr);
+					break;
+				case BinaryOperatorType.ExclusiveOr:
+					outputFormatter.PrintToken(Tokens.Xor);
+					break;
+				
+				case BinaryOperatorType.LogicalAnd:
+					outputFormatter.PrintToken(Tokens.LogicalAnd);
+					break;
+				case BinaryOperatorType.LogicalOr:
+					outputFormatter.PrintToken(Tokens.LogicalOr);
+					break;
+				
+				case BinaryOperatorType.AS:
+					outputFormatter.PrintToken(Tokens.As);
+					break;
+				
+				case BinaryOperatorType.IS:
+					outputFormatter.PrintToken(Tokens.Is);
+					break;
+				case BinaryOperatorType.Equality:
+					outputFormatter.PrintToken(Tokens.Equal);
+					break;
+				case BinaryOperatorType.GreaterThan:
+					outputFormatter.PrintToken(Tokens.GreaterThan);
+					break;
+				case BinaryOperatorType.GreaterThanOrEqual:
+					outputFormatter.PrintToken(Tokens.GreaterEqual);
+					break;
+				case BinaryOperatorType.InEquality:
+					outputFormatter.PrintToken(Tokens.NotEqual);
+					break;
+				case BinaryOperatorType.LessThan:
+					outputFormatter.PrintToken(Tokens.LessThan);
+					break;
+				case BinaryOperatorType.LessThanOrEqual:
+					outputFormatter.PrintToken(Tokens.LessEqual);
+					break;
+			}
+			outputFormatter.Space();
+			binaryOperatorExpression.Right.AcceptVisitor(this, data);
+			return null;
+		}
+		
+		public override object Visit(CastExpression castExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(castExpression.CastTo, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			castExpression.Expression.AcceptVisitor(this, data);
+			return null;
+		}
+		
+		public override object Visit(CheckedExpression checkedExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.Checked);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			checkedExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			return null;
+		}
+		
+		public override object Visit(ConditionalExpression conditionalExpression, object data)
+		{
+			conditionalExpression.TestCondition.AcceptVisitor(this, data);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.Question);
+			outputFormatter.Space();
+			conditionalExpression.TrueExpression.AcceptVisitor(this, data);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.Colon);
+			outputFormatter.Space();
+			conditionalExpression.FalseExpression.AcceptVisitor(this, data);
+			return null;
+		}
+		
+		public override object Visit(DirectionExpression directionExpression, object data)
+		{
+			switch (directionExpression.FieldDirection) {
+				case FieldDirection.Out:
+					outputFormatter.PrintToken(Tokens.Out);
+					outputFormatter.Space();
+					break;
+				case FieldDirection.Ref:
+					outputFormatter.PrintToken(Tokens.Ref);
+					outputFormatter.Space();
+					break;
+			}
+			directionExpression.Expression.AcceptVisitor(this, data);
+			return null;
+		}
+		
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		{
+			fieldReferenceExpression.TargetObject.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.Dot);
+			outputFormatter.PrintIdentifier(fieldReferenceExpression.FieldName);
+			return null;
+		}
+		
+		public override object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			outputFormatter.PrintIdentifier(identifierExpression.Identifier);
+			return null;
+		}
+		
+		public override object Visit(IndexerExpression indexerExpression, object data)
+		{
+			indexerExpression.TargetObject.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+			AppendCommaSeparatedList(indexerExpression.Indices);
+			outputFormatter.PrintToken(Tokens.CloseSquareBracket);
+			return null;
+		}
+		
+		public override object Visit(InvocationExpression invocationExpression, object data)
+		{
+			invocationExpression.TargetObject.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(invocationExpression.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			return null;
+		}
+		
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.New);
+			outputFormatter.Space();
+			this.Visit(objectCreateExpression.CreateType, data);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(objectCreateExpression.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			return null;
+		}
+		
+		public override object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			parenthesizedExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			return null;
+		}
+		
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		{
+			pointerReferenceExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.Pointer);
+			outputFormatter.PrintIdentifier(pointerReferenceExpression.Identifier);
+			return null;
+		}
+		
+		public override object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			outputFormatter.PrintIdentifier(primitiveExpression.StringValue);
+			return null;
+		}
+		
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.Sizeof);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(sizeOfExpression.TypeReference, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			return null;
+		}
+		
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.Stackalloc);
+			Visit(stackAllocExpression.Type, data);
+			outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+			stackAllocExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseSquareBracket);
+			return null;
+		}
+		
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.This);
+			return null;
+		}
+		
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.Typeof);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(typeOfExpression.TypeReference, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			return null;
+		}
+		
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			Visit(typeReferenceExpression.TypeReference, data);
+			return null;
+		}
+		
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.BitNot:
+					outputFormatter.PrintToken(Tokens.BitwiseComplement);
+					break;
+				case UnaryOperatorType.Decrement:
+					outputFormatter.PrintToken(Tokens.Decrement);
+					break;
+				case UnaryOperatorType.Increment:
+					outputFormatter.PrintToken(Tokens.Increment);
+					break;
+				case UnaryOperatorType.Minus:
+					outputFormatter.PrintToken(Tokens.Minus);
+					break;
+				case UnaryOperatorType.Not:
+					outputFormatter.PrintToken(Tokens.Not);
+					break;
+				case UnaryOperatorType.Plus:
+					outputFormatter.PrintToken(Tokens.Plus);
+					break;
+				case UnaryOperatorType.PostDecrement:
+					unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+					outputFormatter.PrintToken(Tokens.Decrement);
+					return null;
+				case UnaryOperatorType.PostIncrement:
+					unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+					outputFormatter.PrintToken(Tokens.Increment);
+					return null;
+				case UnaryOperatorType.Star:
+					outputFormatter.PrintToken(Tokens.Times);
+					break;
+				case UnaryOperatorType.BitWiseAnd:
+					outputFormatter.PrintToken(Tokens.BitwiseAnd);
+					break;
+			}
+			unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+			return null;
+		}
+		
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
+		{
+			outputFormatter.PrintToken(Tokens.Unchecked);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			uncheckedExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			return null;
+		}
+#endregion
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/SpecialVisitor.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/SpecialVisitor.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/PrettyPrinter/SpecialVisitor.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,96 @@
+// SpecialVisitor.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
+{
+//	
+//	public class SpecialVisitor
+//	{
+//		PrettyPrintData prettyPrintData;
+//		public SpecialVisitor(PrettyPrintData prettyPrintData)
+//		{
+//			this.prettyPrintData = prettyPrintData;
+//		}
+//		
+//		public void VisitSpecial(object obj)
+//		{
+//			VisitSpecial(obj, true);
+//		}
+//		public void VisitSpecial(object obj, bool indent)
+//		{
+//			/*
+//			if (obj == null) {
+//				return;
+//			}
+//			ArrayList specials = (ArrayList)obj;
+//			foreach (object special in specials) {
+//				if (special is BlankLine) {
+//					prettyPrintData.AppendNewLine();
+//				} else if (special is PreProcessingDirective) {
+//					PreProcessingDirective preProcessingDirective = (PreProcessingDirective)special;
+//					prettyPrintData.AppendText(&quot;#&quot;);
+//					prettyPrintData.AppendText(preProcessingDirective.Cmd);
+//					if (preProcessingDirective.Arg != null &amp;&amp; preProcessingDirective.Arg.Length &gt; 0) {
+//						prettyPrintData.AppendText(&quot; &quot;);
+//						prettyPrintData.AppendText(preProcessingDirective.Arg);
+//					}
+//					prettyPrintData.AppendNewLine();
+//				} else if (special is Comment) {
+//					Comment comment = (Comment)special;
+//					switch (comment.CommentType) {
+//						case CommentType.SingleLine:
+//							if (indent) {
+//								prettyPrintData.AppendIndentation();
+//							}
+//							prettyPrintData.AppendText(&quot;// &quot;);
+//							prettyPrintData.AppendText(comment.CommentText);
+//							if (indent) {
+//								prettyPrintData.AppendNewLine();
+//							}
+//							break;
+//						case CommentType.Documentation:
+//							if (indent) {
+//								prettyPrintData.AppendIndentation();
+//							}
+//							prettyPrintData.AppendText(&quot;/// &quot;);
+//							prettyPrintData.AppendText(comment.CommentText);
+//							prettyPrintData.AppendNewLine();
+//							break;
+//						case CommentType.Block:
+//							if (indent) {
+//								prettyPrintData.AppendIndentation();
+//							}
+//							prettyPrintData.AppendText(&quot;* &quot;);
+//							prettyPrintData.AppendText(comment.CommentText);
+//							prettyPrintData.AppendText(&quot; *&quot;);
+//							if (indent) {
+//								prettyPrintData.AppendNewLine();
+//							}
+//							break;
+//					}
+//				}
+//			}
+//		}
+//	}*/
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/VBNetRefactory.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/VBNetRefactory.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/VBNetRefactory.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,68 @@
+// VBNetVisitor.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Reflection;
+using System.CodeDom;
+using System.Text;
+using System.Collections;
+
+
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
+{
+	public class VBNetRefactory
+	{
+		Hashtable namespaces;
+		
+		public void Refactor(CompilationUnit compilationUnit)
+		{
+			namespaces = new Hashtable();
+			for (int i = 0; i &lt; compilationUnit.Children.Count; ++i) {
+				object o = compilationUnit.Children[i];
+				if (o is UsingDeclaration ) {
+					namespaces[((UsingDeclaration )o).Namespace] = &quot;&quot;;
+				} else if (o is NamespaceDeclaration) {
+					Refactor(compilationUnit, (NamespaceDeclaration)o);
+				}
+			}
+		}
+		
+		void Refactor(CompilationUnit compilationUnit, NamespaceDeclaration nsd)
+		{
+			for (int i = 0; i &lt; nsd.Children.Count; ++i) {
+				object o = nsd.Children[i];
+				if (o is UsingDeclaration) {
+					UsingDeclaration  ud = (UsingDeclaration) o;
+					if (namespaces[ud.Namespace] == null) {
+						namespaces[ud.Namespace] = &quot;&quot;;
+						compilationUnit.Children.Insert(0, ud);
+					}
+					nsd.Children.RemoveAt(i);
+					i = -1;
+				} else if (o is UsingAliasDeclaration) {
+					compilationUnit.Children.Insert(0, o);
+					nsd.Children.RemoveAt(i);
+					i = -1;
+				}
+			}
+		}
+	}
+}
+

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/VBNetVisitor.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/VBNetVisitor.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/VBConverter/VBNetVisitor.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,1598 @@
+// VBNetVisitor.cs
+// Copyright (C) 2003 Mike Krueger (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System;
+using System.Reflection;
+using System.CodeDom;
+using System.Text;
+using System.Collections;
+
+
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
+{
+	public class VBNetVisitor : AbstractASTVisitor
+	{
+		StringBuilder   sourceText  = new StringBuilder();
+		int             indentLevel = 0;
+		TypeDeclaration currentType = null;
+		bool            generateAttributeUnderScore = false;
+		Errors          errors      = new Errors();
+		public StringBuilder SourceText {
+			get {
+				return sourceText;
+			}
+		}
+		
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
+		public override object Visit(INode node, object data)
+		{
+			errors.Error(-1, -1, String.Format(&quot;Visited INode (should NEVER HAPPEN)&quot;));
+			Console.WriteLine(&quot;Visitor was: &quot; + this.GetType());
+			Console.WriteLine(&quot;Node was : &quot; + node.GetType());
+			return node.AcceptChildren(this, data);
+		}
+		
+		public void AppendIndentation()
+		{
+			for (int i = 0; i &lt; indentLevel; ++i) {
+				sourceText.Append(&quot;\t&quot;);
+			}
+		}
+		
+		public void AppendNewLine()
+		{
+			sourceText.Append(&quot;\n&quot;);
+		}
+		
+		void DebugOutput(object o)
+		{
+//			Console.WriteLine(o.ToString());
+		}
+		
+		public override object Visit(CompilationUnit compilationUnit, object data)
+		{
+			DebugOutput(compilationUnit);
+			new VBNetRefactory().Refactor(compilationUnit);
+			compilationUnit.AcceptChildren(this, data);
+			return null;
+		}
+		
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		{
+			DebugOutput(namespaceDeclaration);
+			AppendIndentation();sourceText.Append(&quot;Namespace &quot;);
+			sourceText.Append(namespaceDeclaration.NameSpace);
+			AppendNewLine();
+			++indentLevel;
+			namespaceDeclaration.AcceptChildren(this, data);
+			--indentLevel;
+			AppendIndentation();sourceText.Append(&quot;End Namespace&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(UsingDeclaration usingDeclaration, object data)
+		{
+			DebugOutput(usingDeclaration);
+			AppendIndentation();sourceText.Append(&quot;Imports &quot;);
+			sourceText.Append(usingDeclaration.Namespace);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		{
+			DebugOutput(usingAliasDeclaration);
+			AppendIndentation();sourceText.Append(&quot;Imports &quot;);
+			sourceText.Append(usingAliasDeclaration.Alias);
+			sourceText.Append(&quot; = &quot;);
+			sourceText.Append(usingAliasDeclaration.Namespace);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(AttributeSection attributeSection, object data)
+		{
+			DebugOutput(attributeSection);
+			AppendIndentation();sourceText.Append(&quot;&lt;&quot;);
+			if (attributeSection.AttributeTarget != null &amp;&amp; attributeSection.AttributeTarget.Length &gt; 0) {
+				sourceText.Append(attributeSection.AttributeTarget);
+				sourceText.Append(&quot;: &quot;);
+			}
+			for (int j = 0; j &lt; attributeSection.Attributes.Count; ++j) {
+				ICSharpCode.SharpRefactory.Parser.AST.Attribute attr = (ICSharpCode.SharpRefactory.Parser.AST.Attribute)attributeSection.Attributes[j];
+				
+				sourceText.Append(attr.Name);
+				sourceText.Append(&quot;(&quot;);
+				for (int i = 0; i &lt; attr.PositionalArguments.Count; ++i) {
+					Expression expr = (Expression)attr.PositionalArguments[i];
+					sourceText.Append(expr.AcceptVisitor(this, data).ToString());
+					if (i + 1 &lt; attr.PositionalArguments.Count) { 
+						sourceText.Append(&quot;, &quot;);
+					}
+				}
+				
+				for (int i = 0; i &lt; attr.NamedArguments.Count; ++i) {
+					NamedArgument named = (NamedArgument)attr.NamedArguments[i];
+					sourceText.Append(named.Name);
+					sourceText.Append(&quot;=&quot;);
+					sourceText.Append(named.Expr.AcceptVisitor(this, data).ToString());
+					if (i + 1 &lt; attr.NamedArguments.Count) { 
+						sourceText.Append(&quot;, &quot;);
+					}
+				}
+				sourceText.Append(&quot;)&quot;);
+				if (j + 1 &lt; attributeSection.Attributes.Count) {
+					sourceText.Append(&quot;, &quot;);
+				}
+			}
+			sourceText.Append(&quot;&gt; &quot;);
+			if (generateAttributeUnderScore) {
+				sourceText.Append(&quot;_&quot;);
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
+		{
+			DebugOutput(typeDeclaration);
+			AppendNewLine();
+			generateAttributeUnderScore = true;
+			AppendAttributes(typeDeclaration.Attributes);
+			string modifier =  GetModifier(typeDeclaration.Modifier);
+			string type = String.Empty;
+			
+			switch (typeDeclaration.Type) {
+				case Types.Class:
+					type = &quot;Class &quot;;
+					break;
+				case Types.Enum:
+					type = &quot;Enum &quot;;
+					break;
+				case Types.Interface:
+					type = &quot;Interface &quot;;
+					break;
+				case Types.Struct:
+					// this should be better in VBNetRefactory class because it is an AST transformation, but currently I'm too lazy
+					if (TypeHasOnlyStaticMembers(typeDeclaration)) {
+						goto case Types.Class;
+					}
+					type = &quot;Structure &quot;;
+					break;
+			}
+			AppendIndentation();sourceText.Append(modifier);
+			sourceText.Append(type);
+			sourceText.Append(typeDeclaration.Name);
+			AppendNewLine();
+			
+			if (typeDeclaration.BaseTypes != null) {
+				foreach (string baseType in typeDeclaration.BaseTypes) {
+					AppendIndentation();
+					
+					bool baseTypeIsInterface = baseType.StartsWith(&quot;I&quot;) &amp;&amp; (baseType.Length &lt;= 1 || Char.IsUpper(baseType[1]));
+					
+					if (!baseTypeIsInterface || typeDeclaration.Type == Types.Interface) {
+						sourceText.Append(&quot;Inherits &quot;); 
+					} else {
+						sourceText.Append(&quot;Implements &quot;); 
+					}
+					sourceText.Append(baseType); 
+					AppendNewLine();
+				}
+			}
+			
+			++indentLevel;
+			TypeDeclaration oldType = currentType;
+			currentType = typeDeclaration;
+			typeDeclaration.AcceptChildren(this, data);
+			currentType = oldType;
+			--indentLevel;
+			AppendIndentation();sourceText.Append(&quot;End &quot;);
+			sourceText.Append(type);
+			AppendNewLine();
+			generateAttributeUnderScore = false;
+			return null;
+		}
+		
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
+		{
+			DebugOutput(delegateDeclaration);
+			AppendNewLine();
+			AppendAttributes(delegateDeclaration.Attributes);
+			AppendIndentation();sourceText.Append(GetModifier(delegateDeclaration.Modifier));
+			sourceText.Append(&quot;Delegate &quot;);
+			bool isFunction = (delegateDeclaration.ReturnType.Type != &quot;void&quot;);
+			if (isFunction) {
+				sourceText.Append(&quot;Function &quot;);
+			} else {
+				sourceText.Append(&quot;Sub &quot;);
+			}
+			
+			sourceText.Append(delegateDeclaration.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(delegateDeclaration.Parameters);
+			sourceText.Append(&quot;)&quot;);
+			if (isFunction) {
+				sourceText.Append(&quot; As &quot;);
+				sourceText.Append(GetTypeString(delegateDeclaration.ReturnType));
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
+		{
+			// called inside ENUMS
+//			AppendAttributes(field.Attributes);
+			AppendIndentation();sourceText.Append(variableDeclaration.Name);
+			if (variableDeclaration.Initializer != null) {
+				sourceText.Append(&quot; = &quot;);
+				sourceText.Append(variableDeclaration.Initializer.AcceptVisitor(this, data));
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
+		{
+			DebugOutput(fieldDeclaration);
+			foreach (VariableDeclaration field in fieldDeclaration.Fields) {
+				AppendAttributes(fieldDeclaration.Attributes);
+				AppendIndentation();
+				if (fieldDeclaration.Modifier == Modifier.None) {
+					sourceText.Append(&quot; Private &quot;);
+				} else {
+					sourceText.Append(GetModifier(fieldDeclaration.Modifier));
+				}
+				sourceText.Append(field.Name);
+				sourceText.Append(&quot; As &quot;);
+				sourceText.Append(GetTypeString(fieldDeclaration.TypeReference));
+				if (field.Initializer != null) {
+					sourceText.Append(&quot; = &quot;);
+					sourceText.Append(field.Initializer.AcceptVisitor(this, data).ToString());
+				}
+				AppendNewLine();
+			}
+
+			return null;
+		}
+		
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
+		{
+			DebugOutput(methodDeclaration);
+			AppendNewLine();
+			AppendAttributes(methodDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(GetModifier(methodDeclaration.Modifier));
+			bool isFunction = methodDeclaration.TypeReference.Type != &quot;void&quot;;
+			string defStr   = isFunction ? &quot;Function&quot; : &quot;Sub&quot;;
+			sourceText.Append(defStr);
+			sourceText.Append(&quot; &quot;);
+			sourceText.Append(methodDeclaration.Name);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(methodDeclaration.Parameters);
+			sourceText.Append(&quot;)&quot;);
+			if (isFunction) {
+				sourceText.Append(&quot; As &quot;);
+				sourceText.Append(GetTypeString(methodDeclaration.TypeReference));
+			}
+			AppendNewLine();
+			
+			if (currentType.Type != Types.Interface) {
+				if (methodDeclaration.Body != null) {
+					++indentLevel;
+					methodDeclaration.Body.AcceptVisitor(this, data);
+					--indentLevel;
+				}
+				
+				AppendIndentation();sourceText.Append(&quot;End &quot;);sourceText.Append(defStr);
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
+		{
+			DebugOutput(propertyDeclaration);
+			AppendNewLine();
+			AppendAttributes(propertyDeclaration.Attributes);
+			AppendIndentation();sourceText.Append(GetModifier(propertyDeclaration.Modifier));
+			if (propertyDeclaration.IsReadOnly) {
+				sourceText.Append(&quot;ReadOnly &quot;);
+			} else if (propertyDeclaration.IsWriteOnly) {
+				sourceText.Append(&quot;WriteOnly &quot;);
+			}
+			sourceText.Append(&quot;Property &quot;);
+			sourceText.Append(propertyDeclaration.Name);
+			sourceText.Append(&quot;() As &quot;);
+			sourceText.Append(GetTypeString(propertyDeclaration.TypeReference));
+			AppendNewLine();
+			
+			if (currentType.Type != Types.Interface) {
+				if (propertyDeclaration.GetRegion != null) {
+					++indentLevel;
+					propertyDeclaration.GetRegion.AcceptVisitor(this, data);
+					--indentLevel;
+				}
+				
+				if (propertyDeclaration.SetRegion != null) {
+					++indentLevel;
+					propertyDeclaration.SetRegion.AcceptVisitor(this, data);
+					--indentLevel;
+				}
+				
+				AppendIndentation();sourceText.Append(&quot;End Property&quot;);
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public override object Visit(PropertyGetRegion propertyGetRegion, object data)
+		{
+			DebugOutput(propertyGetRegion);
+			AppendAttributes(propertyGetRegion.Attributes);
+			AppendIndentation();sourceText.Append(&quot;Get&quot;);
+			AppendNewLine();
+			
+			if (propertyGetRegion.Block != null) {
+				++indentLevel;
+				propertyGetRegion.Block.AcceptVisitor(this, data);
+				--indentLevel;
+			} 
+			AppendIndentation();sourceText.Append(&quot;End Get&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(PropertySetRegion propertySetRegion, object data)
+		{
+			DebugOutput(propertySetRegion);
+			AppendAttributes(propertySetRegion.Attributes);
+			AppendIndentation();sourceText.Append(&quot;Set&quot;);
+			AppendNewLine();
+			
+			if (propertySetRegion.Block != null) {
+				++indentLevel;
+				propertySetRegion.Block.AcceptVisitor(this, data);
+				--indentLevel;
+			}
+			
+			AppendIndentation();sourceText.Append(&quot;End Set&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(EventDeclaration eventDeclaration, object data)
+		{
+			DebugOutput(eventDeclaration);
+			AppendNewLine();
+			if (eventDeclaration.Name == null) { 
+				foreach (VariableDeclaration field in eventDeclaration.VariableDeclarators) {
+					AppendAttributes(eventDeclaration.Attributes);
+					AppendIndentation();
+					sourceText.Append(GetModifier(eventDeclaration.Modifier));
+					sourceText.Append(&quot;Event &quot;);
+					sourceText.Append(field.Name);
+					sourceText.Append(&quot; As &quot;);
+					sourceText.Append(GetTypeString(eventDeclaration.TypeReference));
+				}
+			} else {
+				AppendAttributes(eventDeclaration.Attributes);
+				AppendIndentation();
+				sourceText.Append(GetModifier(eventDeclaration.Modifier));
+				sourceText.Append(&quot;Event &quot;);
+				sourceText.Append(eventDeclaration.Name);
+				sourceText.Append(&quot; As &quot;);
+				sourceText.Append(GetTypeString(eventDeclaration.TypeReference));
+				if (eventDeclaration.HasAddRegion) {
+					errors.Error(-1, -1, String.Format(&quot;Event add region can't be converted&quot;));
+				}
+				if (eventDeclaration.HasRemoveRegion) {
+					errors.Error(-1, -1, String.Format(&quot;Event remove region can't be converted&quot;));
+				}
+			}
+			
+			AppendNewLine();
+			return data;
+		}
+		
+		public override object Visit(EventAddRegion eventAddRegion, object data)
+		{
+			// should never be called:
+			throw new System.NotSupportedException();
+		}
+		
+		public override object Visit(EventRemoveRegion eventRemoveRegion, object data)
+		{
+			// should never be called:
+			throw new System.NotSupportedException();
+		}
+		
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		{
+			DebugOutput(constructorDeclaration);
+			AppendNewLine();
+			AppendIndentation();sourceText.Append(GetModifier(constructorDeclaration.Modifier));
+			sourceText.Append(&quot;Sub New&quot;);
+			sourceText.Append(&quot;(&quot;);
+			AppendParameters(constructorDeclaration.Parameters);
+			sourceText.Append(&quot;)&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			constructorDeclaration.Body.AcceptChildren(this, data);
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;End Sub&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(DestructorDeclaration destructorDeclaration, object data)
+		{
+			DebugOutput(destructorDeclaration);
+			AppendNewLine();
+			AppendIndentation();sourceText.Append(&quot;Overrides Protected Sub Finalize()&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			destructorDeclaration.Body.AcceptChildren(this, data);
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;End Sub&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(OperatorDeclaration operatorDeclaration, object data)
+		{
+			errors.Error(-1, -1, String.Format(&quot;Operator overloading cannot be performed&quot;));
+			return null;
+		}
+		
+		public override object Visit(IndexerDeclaration indexerDeclaration, object data)
+		{
+			DebugOutput(indexerDeclaration);
+			
+			AppendNewLine();
+			AppendAttributes(indexerDeclaration.Attributes);
+			AppendIndentation();
+			sourceText.Append(&quot;Default &quot;);
+			sourceText.Append(GetModifier(indexerDeclaration.Modifier));
+			sourceText.Append(&quot;Property Blubber(&quot;);
+			AppendParameters(indexerDeclaration.Parameters);
+			sourceText.Append(&quot;) As &quot;);
+			sourceText.Append(GetTypeString(indexerDeclaration.TypeReference));
+			AppendNewLine();
+			
+			if (indexerDeclaration.GetRegion != null) {
+				++indentLevel;
+				indexerDeclaration.GetRegion.AcceptVisitor(this, data);
+				--indentLevel;
+			}
+			
+			if (indexerDeclaration.SetRegion != null) {
+				++indentLevel;
+				indexerDeclaration.SetRegion.AcceptVisitor(this, data);
+				--indentLevel;
+			}
+			
+			AppendIndentation();sourceText.Append(&quot;End Property&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(BlockStatement blockStatement, object data)
+		{
+			DebugOutput(blockStatement);
+			blockStatement.AcceptChildren(this, data);
+			return null;
+		}
+		
+		public override object Visit(StatementExpression statementExpression, object data)
+		{
+			DebugOutput(statementExpression);
+			AppendIndentation();sourceText.Append(statementExpression.Expression.AcceptVisitor(this, statementExpression).ToString());
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		{
+			DebugOutput(localVariableDeclaration);
+			foreach (VariableDeclaration localVar in localVariableDeclaration.Variables) {
+				AppendIndentation();sourceText.Append(GetModifier(localVariableDeclaration.Modifier));
+				ArrayCreateExpression ace = localVar.Initializer as ArrayCreateExpression;
+				if (ace != null &amp;&amp; (ace.ArrayInitializer == null || ace.ArrayInitializer.CreateExpressions == null)) {
+					string arrayParameters  = String.Empty;
+					foreach (Expression expr in ace.Parameters) {
+						arrayParameters += &quot;(&quot;;
+						arrayParameters += expr.AcceptVisitor(this, data);
+						arrayParameters += &quot; - 1)&quot;;
+					}
+					sourceText.Append(&quot;Dim &quot;);
+					sourceText.Append(localVar.Name);
+					sourceText.Append(arrayParameters);
+					sourceText.Append(&quot; As &quot;);
+					sourceText.Append(ConvertTypeString(ace.CreateType.Type));
+				} else {
+					sourceText.Append(&quot;Dim &quot;);
+					sourceText.Append(localVar.Name);
+					sourceText.Append(&quot; As &quot;);
+					sourceText.Append(GetTypeString(localVariableDeclaration.Type));
+					if (localVar.Initializer != null) {
+						sourceText.Append(&quot; = &quot;);
+						sourceText.Append(localVar.Initializer.AcceptVisitor(this, data).ToString());
+					}
+				}
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public override object Visit(EmptyStatement emptyStatement, object data)
+		{
+			DebugOutput(emptyStatement);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(ReturnStatement returnStatement, object data)
+		{
+			DebugOutput(returnStatement);
+			AppendIndentation();sourceText.Append(&quot;Return&quot;);
+			if (returnStatement.ReturnExpression != null) {
+				sourceText.Append(&quot; &quot;);
+				sourceText.Append(returnStatement.ReturnExpression.AcceptVisitor(this, data).ToString());
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(IfStatement ifStatement, object data)
+		{
+			DebugOutput(ifStatement);
+			AppendIndentation();
+			InvocationExpression ie = GetEventHandlerRaise(ifStatement);
+			
+			if (ie == null) {
+				sourceText.Append(&quot;If &quot;);
+				sourceText.Append(ifStatement.Condition.AcceptVisitor(this, data).ToString());
+				sourceText.Append(&quot; Then&quot;);
+				AppendNewLine();
+				
+				++indentLevel;
+				ifStatement.EmbeddedStatement.AcceptVisitor(this, data);
+				--indentLevel;
+				
+				AppendIndentation();sourceText.Append(&quot;End If&quot;);
+				AppendNewLine();
+			} else {
+				sourceText.Append(&quot;RaiseEvent &quot;);
+				sourceText.Append(ie.AcceptVisitor(this, data));
+				AppendNewLine();
+			}
+			return null;
+		}
+		
+		public override object Visit(IfElseStatement ifElseStatement, object data)
+		{
+			DebugOutput(ifElseStatement);
+			AppendIndentation();sourceText.Append(&quot;If &quot;);
+			sourceText.Append(ifElseStatement.Condition.AcceptVisitor(this, data).ToString());
+			sourceText.Append(&quot; Then&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			ifElseStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;Else&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			ifElseStatement.EmbeddedElseStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;End If&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(WhileStatement whileStatement, object data)
+		{
+			DebugOutput(whileStatement);
+			AppendIndentation();sourceText.Append(&quot;While &quot;);
+			sourceText.Append(whileStatement.Condition.AcceptVisitor(this, data).ToString());
+			AppendNewLine();
+			
+			++indentLevel;
+			whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;End While&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(DoWhileStatement doWhileStatement, object data)
+		{
+			DebugOutput(doWhileStatement);
+			AppendIndentation();sourceText.Append(&quot;Do While&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			doWhileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;Loop&quot;);
+			sourceText.Append(doWhileStatement.Condition.AcceptVisitor(this, data).ToString());
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(ForStatement forStatement, object data)
+		{
+			DebugOutput(forStatement);
+			if (forStatement.Initializers != null) {
+				foreach (object o in forStatement.Initializers) {
+					if (o is Expression) {
+						Expression expr = (Expression)o;
+						AppendIndentation();
+						sourceText.Append(expr.AcceptVisitor(this, data).ToString());
+						AppendNewLine();
+					}
+					if (o is Statement) {
+						((Statement)o).AcceptVisitor(this, data);
+					}
+				}
+			}
+			AppendIndentation();sourceText.Append(&quot;While &quot;);
+			if (forStatement.Condition == null) {
+				sourceText.Append(&quot;True &quot;);
+			} else {
+				sourceText.Append(forStatement.Condition.AcceptVisitor(this, data).ToString());
+			}
+			AppendNewLine();
+			
+			++indentLevel;
+			forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			if (forStatement.Iterator != null) {
+				foreach (Statement stmt in forStatement.Iterator) {
+					stmt.AcceptVisitor(this, data);
+				}
+			}
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;End While&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(LabelStatement labelStatement, object data)
+		{
+			DebugOutput(labelStatement);
+			AppendIndentation();sourceText.Append(labelStatement.Label);
+			sourceText.Append(&quot;:&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(GotoStatement gotoStatement, object data)
+		{
+			DebugOutput(gotoStatement);
+			AppendIndentation();sourceText.Append(&quot;Goto &quot;);
+			sourceText.Append(gotoStatement.Label);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(SwitchStatement switchStatement, object data)
+		{
+			DebugOutput(switchStatement);
+			AppendIndentation();sourceText.Append(&quot;Select &quot;);
+			sourceText.Append(switchStatement.SwitchExpression.AcceptVisitor(this, data).ToString());
+			AppendNewLine();
+			foreach (SwitchSection section in switchStatement.SwitchSections) {
+				AppendIndentation();sourceText.Append(&quot;Case &quot;);
+				
+				for (int i = 0; i &lt; section.SwitchLabels.Count; ++i) {
+					Expression label = (Expression)section.SwitchLabels[i];
+					if (label == null) {
+						sourceText.Append(&quot;Else&quot;);
+						continue;
+					}
+					sourceText.Append(label.AcceptVisitor(this, data));
+					if (i + 1 &lt; section.SwitchLabels.Count) {
+						sourceText.Append(&quot;, &quot;);
+					}
+				}
+				AppendNewLine();
+				
+				++indentLevel;
+				section.AcceptVisitor(this, data);
+				--indentLevel;
+			}
+			AppendIndentation();sourceText.Append(&quot;End Select &quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(BreakStatement breakStatement, object data)
+		{
+			DebugOutput(breakStatement);
+			AppendIndentation();sourceText.Append(&quot;' break&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(ContinueStatement continueStatement, object data)
+		{
+			DebugOutput(continueStatement);
+			AppendIndentation();sourceText.Append(&quot;' continue&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		{
+			DebugOutput(gotoCaseStatement);
+			AppendIndentation();sourceText.Append(&quot;' goto case &quot;);
+			if (gotoCaseStatement.CaseExpression == null) {
+				sourceText.Append(&quot;default&quot;);
+			} else {
+				sourceText.Append(gotoCaseStatement.CaseExpression.AcceptVisitor(this, data));
+			}
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(ForeachStatement foreachStatement, object data)
+		{
+			DebugOutput(foreachStatement);
+			AppendIndentation();sourceText.Append(&quot;For Each &quot;);
+			sourceText.Append(foreachStatement.VariableName);
+			sourceText.Append(&quot; As &quot;);
+			sourceText.Append(this.GetTypeString(foreachStatement.TypeReference));
+			sourceText.Append(&quot; In &quot;);
+			sourceText.Append(foreachStatement.Expression.AcceptVisitor(this, data));
+			AppendNewLine();
+			
+			++indentLevel;
+			foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;Next&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(LockStatement lockStatement, object data)
+		{
+			DebugOutput(lockStatement);
+			AppendIndentation();sourceText.Append(&quot;SyncLock &quot;);
+			sourceText.Append(lockStatement.LockExpression.AcceptVisitor(this, data));
+			AppendNewLine();
+			
+			++indentLevel;
+			lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			AppendIndentation();sourceText.Append(&quot;End SyncLock&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(UsingStatement usingStatement, object data)
+		{
+			DebugOutput(usingStatement);
+			// TODO : anything like this ?
+			AppendIndentation();sourceText.Append(&quot;' Using &quot;);AppendNewLine();
+			usingStatement.UsingStmnt.AcceptVisitor(this, data);
+			AppendIndentation();sourceText.Append(&quot;' Inside &quot;);AppendNewLine();
+			usingStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			AppendIndentation();sourceText.Append(&quot;' End Using&quot;);AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
+		{
+			DebugOutput(tryCatchStatement);
+			AppendIndentation();sourceText.Append(&quot;Try&quot;);
+			AppendNewLine();
+			
+			++indentLevel;
+			tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
+			--indentLevel;
+			
+			if (tryCatchStatement.CatchClauses != null) {
+				int generated = 0;
+				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
+					AppendIndentation();sourceText.Append(&quot;Catch &quot;);
+					if (catchClause.VariableName == null) {
+						sourceText.Append(&quot;generatedExceptionVariable&quot; + generated.ToString());
+						++generated;
+					} else {
+						sourceText.Append(catchClause.VariableName);
+					}
+					sourceText.Append(&quot; As &quot;);
+					sourceText.Append(catchClause.Type);
+					AppendNewLine();
+					++indentLevel;
+					catchClause.StatementBlock.AcceptVisitor(this, data);
+					--indentLevel;
+				}
+			}
+			
+			if (tryCatchStatement.FinallyBlock != null) {
+				AppendIndentation();sourceText.Append(&quot;Finally&quot;);
+				AppendNewLine();
+				
+				++indentLevel;
+				tryCatchStatement.FinallyBlock.AcceptVisitor(this, data);
+				--indentLevel;
+			}
+			AppendIndentation();sourceText.Append(&quot;End Try&quot;);
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(ThrowStatement throwStatement, object data)
+		{
+			DebugOutput(throwStatement);
+			AppendIndentation();sourceText.Append(&quot;Throw &quot;);
+			sourceText.Append(throwStatement.ThrowExpression.AcceptVisitor(this, data).ToString());
+			AppendNewLine();
+			return null;
+		}
+		
+		public override object Visit(FixedStatement fixedStatement, object data)
+		{
+			DebugOutput(fixedStatement);
+			errors.Error(-1, -1, String.Format(&quot;fixed statement not suported by VB.NET&quot;));
+			return null;
+		}
+		
+		public override object Visit(CheckedStatement checkedStatement, object data)
+		{
+			DebugOutput(checkedStatement);
+			errors.Error(-1, -1, String.Format(&quot;checked statement not suported by VB.NET&quot;));
+			return null;
+		}
+		
+		public override object Visit(UncheckedStatement uncheckedStatement, object data)
+		{
+			DebugOutput(uncheckedStatement);
+			errors.Error(-1, -1, String.Format(&quot;unchecked statement not suported by VB.NET&quot;));
+			return null;
+		}
+		
+		public override object Visit(PrimitiveExpression primitiveExpression, object data)
+		{
+			DebugOutput(primitiveExpression);
+			if (primitiveExpression.Value == null) {
+				return &quot;Nothing&quot;;
+			}
+			if (primitiveExpression.Value is bool) {
+				if ((bool)primitiveExpression.Value) {
+					return &quot;True&quot;;
+				}
+				return &quot;False&quot;;
+			}
+			
+			if (primitiveExpression.Value is string) {
+				return String.Concat('&quot;',
+				                     primitiveExpression.Value,
+				                     '&quot;');
+			}
+			
+			if (primitiveExpression.Value is char) {
+				return String.Concat(&quot;'&quot;,
+				                     primitiveExpression.Value,
+				                     &quot;'&quot;);
+			}
+			
+			return primitiveExpression.Value;
+		}
+		
+		public override object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		{
+			DebugOutput(binaryOperatorExpression);
+			string op = null;
+			string left = binaryOperatorExpression.Left.AcceptVisitor(this, data).ToString();
+			string right = binaryOperatorExpression.Right.AcceptVisitor(this, data).ToString();
+			
+			switch (binaryOperatorExpression.Op) {
+				case BinaryOperatorType.Add:
+					op = &quot; + &quot;;
+					break;
+				
+				case BinaryOperatorType.Subtract:
+					op = &quot; - &quot;;
+					break;
+				
+				case BinaryOperatorType.Multiply:
+					op = &quot; * &quot;;
+					break;
+				
+				case BinaryOperatorType.Divide:
+					op = &quot; / &quot;;
+					break;
+				
+				case BinaryOperatorType.Modulus:
+					op = &quot; Mod &quot;;
+					break;
+				
+				case BinaryOperatorType.ShiftLeft:
+					op = &quot; &lt;&lt; &quot;;
+					break;
+				
+				case BinaryOperatorType.ShiftRight:
+					op = &quot; &gt;&gt; &quot;;
+					break;
+				
+				case BinaryOperatorType.BitwiseAnd:
+					op = &quot; And &quot;;
+					break;
+				case BinaryOperatorType.BitwiseOr:
+					op = &quot; Or &quot;;
+					break;
+				case BinaryOperatorType.ExclusiveOr:
+					op = &quot; Xor &quot;;
+					break;
+				
+				case BinaryOperatorType.LogicalAnd:
+					op = &quot; AndAlso &quot;;
+					break;
+				case BinaryOperatorType.LogicalOr:
+					op = &quot; OrElse &quot;;
+					break;
+				
+				case BinaryOperatorType.AS:
+					return String.Concat(&quot;CType(ConversionHelpers.AsWorkaround(&quot;,
+					                     left,
+					                     &quot;, GetType(&quot;,
+					                     right,
+					                     &quot;)), &quot;,
+					                     right,
+					                     &quot;)&quot;);
+				case BinaryOperatorType.IS:
+					return String.Concat(&quot;TypeOf &quot;,
+					                     left,
+					                     &quot; Is &quot;,
+					                     right);
+				
+				case BinaryOperatorType.Equality:
+					op = &quot; = &quot;;
+					if (right == &quot;Nothing&quot;) {
+						op = &quot; Is &quot;;
+					}
+					break;
+				case BinaryOperatorType.GreaterThan:
+					op = &quot; &gt; &quot;;
+					break;
+				case BinaryOperatorType.GreaterThanOrEqual:
+					op = &quot; &gt;= &quot;;
+					break;
+				case BinaryOperatorType.InEquality:
+					if (right == &quot;Nothing&quot;) {
+						return String.Concat(&quot;Not (&quot;,
+						                     left,
+						                     &quot; Is &quot;,
+						                     right,
+						                     &quot;)&quot;);
+					} else {
+						return String.Concat(&quot;Not (&quot;,
+						                     left,
+						                     &quot; = &quot;,
+						                     right,
+						                     &quot;)&quot;);
+					}
+				case BinaryOperatorType.LessThan:
+					op = &quot; &lt; &quot;;
+					break;
+				case BinaryOperatorType.LessThanOrEqual:
+					op = &quot; &lt;= &quot;;
+					break;
+			}
+			
+			return String.Concat(left,
+			                     op,
+			                     right);
+		}
+		
+		public override object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		{
+			DebugOutput(parenthesizedExpression);
+			string innerExpr = parenthesizedExpression.Expression.AcceptVisitor(this, data).ToString();
+			
+			// parenthesized cast expressions evaluate to a single 'method call' and don't need
+			// to be parenthesized anymore like in C#. Parenthesized cast expresions may lead to
+			// a vb.net compiler error (method calls)
+			if (parenthesizedExpression.Expression is CastExpression) {
+				return innerExpr;
+			}
+			return String.Concat(&quot;(&quot;, innerExpr, &quot;)&quot;);
+		}
+		
+		public override object Visit(InvocationExpression invocationExpression, object data)
+		{
+			DebugOutput(invocationExpression);
+			string backString;
+			
+			if (invocationExpression.TargetObject is ObjectCreateExpression) {
+				backString = String.Concat(&quot;(&quot;,
+				                     invocationExpression.TargetObject.AcceptVisitor(this, data),
+				                     &quot;)&quot;,
+				                     GetParameters(invocationExpression.Parameters));
+			} else {
+				backString = String.Concat(invocationExpression.TargetObject.AcceptVisitor(this, data),
+				                     GetParameters(invocationExpression.Parameters));
+			}
+			//todo: invocationExpression, indexer ... etc.
+			Expression expr = invocationExpression.TargetObject;
+			while (expr is FieldReferenceExpression) {
+				expr = ((FieldReferenceExpression)expr).TargetObject;
+			}
+			
+			if (data is StatementExpression &amp;&amp; expr is ObjectCreateExpression) {
+				return String.Concat(&quot;call &quot;, backString);
+			}
+			return backString;
+		}
+		
+		public override object Visit(IdentifierExpression identifierExpression, object data)
+		{
+			DebugOutput(identifierExpression);
+			return identifierExpression.Identifier;
+		}
+		
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		{
+			DebugOutput(typeReferenceExpression);
+			return GetTypeString(typeReferenceExpression.TypeReference);
+		}
+		
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		{
+			DebugOutput(unaryOperatorExpression);
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.BitNot:
+					return String.Concat(&quot;Not &quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Decrement:
+					return String.Concat(&quot;ConversionHelpers.Decrement (&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Increment:
+					return String.Concat(&quot;ConversionHelpers.Increment (&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Minus:
+					return String.Concat(&quot;-&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Not:
+					return String.Concat(&quot;Not &quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data));
+				case UnaryOperatorType.Plus:
+					return unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+				case UnaryOperatorType.PostDecrement:
+					return String.Concat(&quot;ConversionHelpers.PostDecrement (&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.PostIncrement:
+					return String.Concat(&quot;ConversionHelpers.PostIncrement (&quot;, unaryOperatorExpression.Expression.AcceptVisitor(this, data), &quot;)&quot;);
+				case UnaryOperatorType.Star:
+				case UnaryOperatorType.BitWiseAnd:
+					break;
+			}
+			throw new System.NotSupportedException();
+		}
+		
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
+		{
+			DebugOutput(assignmentExpression);
+			string op   = null;
+			string left = assignmentExpression.Left.AcceptVisitor(this, data).ToString();
+			string right = assignmentExpression.Right.AcceptVisitor(this, data).ToString();
+			switch (assignmentExpression.Op) {
+				case AssignmentOperatorType.Assign:
+					op = &quot; = &quot;;
+					break;
+				case AssignmentOperatorType.Add:
+					op = &quot; += &quot;;
+					if (IsEventHandlerCreation(assignmentExpression.Right)) {
+						return String.Format(&quot;AddHandler {0}, AddressOf {1}&quot;, 
+						                     left, 
+						                     ((Expression)((ObjectCreateExpression)assignmentExpression.Right).Parameters[0]).AcceptVisitor(this, data).ToString());
+					}
+					break;
+				case AssignmentOperatorType.Subtract:
+					op = &quot; -= &quot;;
+					if (IsEventHandlerCreation(assignmentExpression.Right)) {
+						return String.Format(&quot;RemoveHandler {0}, AddressOf {1}&quot;, 
+						                     left, 
+						                     ((Expression)((ObjectCreateExpression)assignmentExpression.Right).Parameters[0]).AcceptVisitor(this, data).ToString());
+					}
+					break;
+				case AssignmentOperatorType.Multiply:
+					op = &quot; *= &quot;;
+					break;
+				case AssignmentOperatorType.Divide:
+					op = &quot; /= &quot;;
+					break;
+				case AssignmentOperatorType.ShiftLeft:
+					op = &quot; &lt;&lt;= &quot;;
+					break;
+				case AssignmentOperatorType.ShiftRight:
+					op = &quot; &gt;&gt;= &quot;;
+					break;
+				
+				case AssignmentOperatorType.ExclusiveOr:
+					return String.Format(&quot;{0} = {0} Xor ({1})&quot;, left, right);
+				case AssignmentOperatorType.Modulus:
+					return String.Format(&quot;{0} = {0} Mod ({1})&quot;, left, right);
+				case AssignmentOperatorType.BitwiseAnd:
+					return String.Format(&quot;{0} = {0} And ({1})&quot;, left, right);
+				case AssignmentOperatorType.BitwiseOr:
+					return String.Format(&quot;{0} = {0} Or ({1})&quot;, left, right);
+			}
+			return String.Concat(left,
+			                     op,
+			                     right);
+		}
+		
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
+		{
+			DebugOutput(sizeOfExpression);
+			errors.Error(-1, -1, String.Format(&quot;sizeof expression not suported by VB.NET&quot;));
+			return null;
+		}
+		
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
+		{
+			DebugOutput(typeOfExpression);
+			return String.Concat(&quot;GetType(&quot;,
+			                     GetTypeString(typeOfExpression.TypeReference),
+			                     &quot;)&quot;);
+		}
+		
+		public override object Visit(CheckedExpression checkedExpression, object data)
+		{
+			return String.Concat(&quot;'Checked expression (can't convert):&quot;,
+			                     checkedExpression.Expression.AcceptVisitor(this, data));
+		}
+		
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
+		{
+			return String.Concat(&quot;'Unhecked expression (can't convert):&quot;,
+			                     uncheckedExpression.Expression.AcceptVisitor(this, data));
+		}
+		
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		{
+			errors.Error(-1, -1, String.Format(&quot;pointer reference (-&gt;) not suported by VB.NET&quot;));
+			return String.Empty;
+		}
+		
+		public override object Visit(CastExpression castExpression, object data)
+		{
+			DebugOutput(castExpression);
+			return String.Format(&quot;CType({0}, {1})&quot;,
+			                     castExpression.Expression.AcceptVisitor(this, data).ToString(),
+			                     GetTypeString(castExpression.CastTo));
+		}
+		
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
+		{
+			errors.Error(-1, -1, String.Format(&quot;stack alloc expression not suported by VB.NET&quot;));
+			return String.Empty;
+		}
+		
+		public override object Visit(IndexerExpression indexerExpression, object data)
+		{
+			DebugOutput(indexerExpression);
+			return String.Concat(indexerExpression.TargetObject.AcceptVisitor(this, data),
+			                     GetParameters(indexerExpression.Indices));
+		}
+		
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		{
+			DebugOutput(thisReferenceExpression);
+			return &quot;Me&quot;;
+		}
+		
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		{
+			DebugOutput(baseReferenceExpression);
+			return &quot;MyBase&quot;;
+		}
+		
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		{
+			DebugOutput(objectCreateExpression);
+			if (IsEventHandlerCreation(objectCreateExpression)) {
+				Expression expr = (Expression)objectCreateExpression.Parameters[0];
+				string handler;
+				if (expr is FieldReferenceExpression) {
+					handler = ((FieldReferenceExpression)expr).FieldName;
+				} else {
+					handler = expr.AcceptVisitor(this, data).ToString();
+				}
+				return String.Format(&quot;AddressOf {0}&quot;, handler);
+			}
+			return String.Format(&quot;New {0} {1}&quot;,
+			                     GetTypeString(objectCreateExpression.CreateType),
+			                     GetParameters(objectCreateExpression.Parameters)
+			                     );
+		}
+		
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		{
+			DebugOutput(arrayCreateExpression);
+			string arrayInitializer = String.Empty;
+			string arrayParameters  = String.Empty;
+			
+			if (arrayCreateExpression.ArrayInitializer != null &amp;&amp; arrayCreateExpression.ArrayInitializer.CreateExpressions != null) {
+				arrayInitializer = String.Concat(&quot; {&quot;,
+				                                 GetExpressionList(arrayCreateExpression.ArrayInitializer.CreateExpressions),
+				                                 &quot;}&quot;);
+			}
+			
+			if (arrayCreateExpression.Parameters != null &amp;&amp; arrayCreateExpression.Parameters.Count &gt; 0) {
+				foreach (ArrayCreationParameter param in arrayCreateExpression.Parameters) {
+					// TODO: multidimensional arrays ?
+					foreach (Expression expr in param.Expressions) {
+						arrayParameters += &quot;(&quot;;
+						arrayParameters += expr.AcceptVisitor(this, data);
+						arrayParameters += &quot;)&quot;;
+					}
+				}
+			} else {
+				arrayParameters = &quot;()&quot;;
+			}
+			
+			return String.Format(&quot;New {0}{2} {1}&quot;,
+			                     GetTypeString(arrayCreateExpression.CreateType),
+			                     arrayInitializer,
+			                     arrayParameters
+			                     );
+		}
+		
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		{
+			// should never be called:
+			throw new System.NotImplementedException();
+		}
+		
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		{
+			DebugOutput(fieldReferenceExpression);
+			if (fieldReferenceExpression.TargetObject is ObjectCreateExpression) {
+				return String.Concat(&quot;(&quot;,
+				                     fieldReferenceExpression.TargetObject.AcceptVisitor(this, data),
+				                     &quot;).&quot;,
+				                     fieldReferenceExpression.FieldName);
+			}
+			return String.Concat(fieldReferenceExpression.TargetObject.AcceptVisitor(this, data),
+			                     &quot;.&quot;,
+			                     fieldReferenceExpression.FieldName);
+		}
+		
+		public override object Visit(DirectionExpression directionExpression, object data)
+		{
+			DebugOutput(directionExpression);
+			string fieldDirection = String.Empty;
+			// TODO: is this correct that there is nothing in a VB.NET method call for out &amp; ref ?
+//			switch (directionExpression.FieldDirection) {
+//				case FieldDirection.Out:
+//					break;
+//				case FieldDirection.Ref:
+//					break;
+//			}
+			return String.Concat(fieldDirection, directionExpression.Expression.AcceptVisitor(this, data));
+		}
+		
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		{
+			return String.Concat(&quot; {&quot;,
+			                     GetExpressionList(arrayInitializerExpression.CreateExpressions),
+			                     &quot;}&quot;);
+		}
+		
+		public override object Visit(ConditionalExpression conditionalExpression, object data)
+		{
+			errors.Error(-1, -1, String.Format(&quot;TODO: Conditionals :)&quot;));
+			return String.Empty;
+		}
+#endregion
+		string ConvertTypeString(string typeString)
+		{
+			switch (typeString) {
+				case &quot;bool&quot;:
+					return &quot;Boolean&quot;;
+				case &quot;string&quot;:
+					return &quot;String&quot;;
+				case &quot;char&quot;:
+					return &quot;Char&quot;;
+				case &quot;double&quot;:
+					return &quot;Double&quot;;
+				case &quot;float&quot;:
+					return &quot;Single&quot;;
+				case &quot;decimal&quot;:
+					return &quot;Decimal&quot;;
+				case &quot;System.DateTime&quot;:
+					return &quot;Date&quot;;
+				case &quot;long&quot;:
+					return &quot;Long&quot;;
+				case &quot;int&quot;:
+					return &quot;Integer&quot;;
+				case &quot;short&quot;:
+					return &quot;Short&quot;;
+				case &quot;byte&quot;:
+					return &quot;Byte&quot;;
+				case &quot;void&quot;:
+					return &quot;Void&quot;;
+				case &quot;object&quot;:
+					return &quot;Object&quot;;
+				case &quot;ulong&quot;:
+					return &quot;System.UInt64&quot;;
+				case &quot;uint&quot;:
+					return &quot;System.UInt32&quot;;
+				case &quot;ushort&quot;:
+					return &quot;System.UInt16&quot;;
+			}
+			return typeString;
+		}
+		string GetTypeString(TypeReference typeRef)
+		{
+			if (typeRef == null) {
+				errors.Error(-1, -1, String.Format(&quot;Got empty type string (internal error, check generated source code for empty types&quot;));
+				return String.Empty;
+			}
+			
+			string typeStr = ConvertTypeString(typeRef.Type);
+		
+			StringBuilder arrays = new StringBuilder();
+			if (typeRef.RankSpecifier != null) {
+				for (int i = 0; i &lt; typeRef.RankSpecifier.Length; ++i) {
+					arrays.Append(&quot;(&quot;);
+					for (int j = 1; j &lt; typeRef.RankSpecifier[i]; ++j) {
+						arrays.Append(&quot;,&quot;);
+					}
+					arrays.Append(&quot;)&quot;);
+				}
+			}
+			
+			if (typeRef.PointerNestingLevel &gt; 0) {
+				errors.Error(-1, -1, String.Format(&quot;Pointer types are not suported by VB.NET&quot;));
+			}
+			
+			return typeStr + arrays.ToString();
+		}
+		
+		string GetModifier(Modifier modifier)
+		{
+			StringBuilder builder = new StringBuilder();
+			
+			if ((modifier &amp; Modifier.Public) == Modifier.Public) {
+				builder.Append(&quot;Public &quot;);
+			} else if ((modifier &amp; Modifier.Private) == Modifier.Private) {
+				builder.Append(&quot;Private &quot;);
+			} else if ((modifier &amp; (Modifier.Protected | Modifier.Internal)) == (Modifier.Protected | Modifier.Internal)) {
+				builder.Append(&quot;Protected Friend &quot;);
+			} else if ((modifier &amp; Modifier.Internal) == Modifier.Internal) {
+				builder.Append(&quot;Friend &quot;);
+			} else if ((modifier &amp; Modifier.Protected) == Modifier.Protected) {
+				builder.Append(&quot;Protected &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.Static) == Modifier.Static) {
+				builder.Append(&quot;Shared &quot;);
+			}
+			if ((modifier &amp; Modifier.Virtual) == Modifier.Virtual) {
+				builder.Append(&quot;Overridable &quot;);
+			}
+			if ((modifier &amp; Modifier.Abstract) == Modifier.Abstract) {
+				builder.Append(&quot;MustOverride &quot;);
+			}
+			if ((modifier &amp; Modifier.Override) == Modifier.Override) {
+				builder.Append(&quot;Overloads Overrides &quot;);
+			}
+			if ((modifier &amp; Modifier.New) == Modifier.New) {
+				builder.Append(&quot;Shadows &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.Sealed) == Modifier.Sealed) {
+				builder.Append(&quot;NotInheritable &quot;);
+			}
+			
+			if ((modifier &amp; Modifier.Const) == Modifier.Const) {
+				builder.Append(&quot;Const &quot;);
+			}
+			if ((modifier &amp; Modifier.Readonly) == Modifier.Readonly) {
+				builder.Append(&quot;ReadOnly &quot;);
+			}
+			
+			// TODO : Extern 
+			if ((modifier &amp; Modifier.Extern) == Modifier.Extern) {
+				errors.Error(-1, -1, String.Format(&quot;'Extern' modifier not convertable&quot;));
+			}
+			// TODO : Volatile 
+			if ((modifier &amp; Modifier.Volatile) == Modifier.Volatile) {
+				errors.Error(-1, -1, String.Format(&quot;'Volatile' modifier not convertable&quot;));
+			}
+			// TODO : Unsafe 
+			if ((modifier &amp; Modifier.Unsafe) == Modifier.Unsafe) {
+				errors.Error(-1, -1, String.Format(&quot;'Unsafe' modifier not convertable&quot;));
+			}
+			return builder.ToString();
+		}
+		
+		string GetParameters(ArrayList list)
+		{
+			if (list == null || list.Count == 0) {
+				return String.Empty;
+			}
+			return String.Concat(&quot;(&quot;,
+			                     GetExpressionList(list),
+			                     &quot;)&quot;);
+		}
+		
+		string GetExpressionList(ArrayList list)
+		{
+			StringBuilder sb = new StringBuilder();
+			if (list != null) {
+				for (int i = 0; i &lt; list.Count; ++i) {
+					Expression exp = (Expression)list[i];
+					sb.Append(exp.AcceptVisitor(this, null));
+					if (i + 1 &lt; list.Count) {
+						sb.Append(&quot;, &quot;);
+					}
+				}
+			}
+			return sb.ToString();
+		}
+		public void AppendParameters(ArrayList parameters)
+		{
+			if (parameters == null) {
+				return;
+			}
+			for (int i = 0; i &lt; parameters.Count; ++i) {
+				ParameterDeclarationExpression pde = (ParameterDeclarationExpression)parameters[i];
+				AppendAttributes(pde.Attributes);
+				if ((pde.ParamModifiers &amp; ParamModifiers.Ref) == ParamModifiers.Ref) {
+					sourceText.Append(&quot;ByRef &quot;);
+				} else if ((pde.ParamModifiers &amp; ParamModifiers.Out) == ParamModifiers.Out) {
+					// TODO : is ByRef correct for out parameters ?
+					sourceText.Append(&quot;ByRef &quot;);
+				} else if ((pde.ParamModifiers &amp; ParamModifiers.Params) == ParamModifiers.Params) {
+					sourceText.Append(&quot;ParamArray &quot;);
+				} else {
+					sourceText.Append(&quot;ByVal &quot;);
+				}
+				sourceText.Append(pde.ParameterName);
+				sourceText.Append(&quot; As &quot;);
+				sourceText.Append(GetTypeString(pde.TypeReference));
+				if (i + 1 &lt; parameters.Count) {
+					sourceText.Append(&quot;, &quot;);
+				}
+			}
+		}
+		public void AppendAttributes(ArrayList attr)
+		{
+			if (attr != null) {
+				foreach (AttributeSection section in attr) {
+					section.AcceptVisitor(this, null);
+				}
+			}
+		}
+		
+		InvocationExpression GetEventHandlerRaise(IfStatement ifStatement)
+		{
+			BinaryOperatorExpression op = ifStatement.Condition as BinaryOperatorExpression;
+			if (op != null &amp;&amp; op.Op == BinaryOperatorType.InEquality) {
+				if (op.Left is IdentifierExpression &amp;&amp; op.Right is PrimitiveExpression &amp;&amp; ((PrimitiveExpression)op.Right).Value == null) {
+					string identifier = ((IdentifierExpression)op.Left).Identifier;
+					StatementExpression se = null;
+					if (ifStatement.EmbeddedStatement is StatementExpression) {
+						se = (StatementExpression)ifStatement.EmbeddedStatement;
+					} else if (ifStatement.EmbeddedStatement.Children.Count == 1) {
+						se = ifStatement.EmbeddedStatement.Children[0] as StatementExpression;
+					}
+					if (se != null) {
+						InvocationExpression ie = se.Expression as InvocationExpression;
+						if (ie != null) {
+							Expression ex = ie.TargetObject;
+							string methodName = null;
+							if (ex is IdentifierExpression) {
+								methodName = ((IdentifierExpression)ex).Identifier;
+							} else if (ex is FieldReferenceExpression) {
+								FieldReferenceExpression fre = (FieldReferenceExpression)ex;
+								if (fre.TargetObject is ThisReferenceExpression) {
+									methodName = fre.FieldName;
+								}
+							}
+							if (methodName != null &amp;&amp; methodName == identifier) {
+								foreach (object o in this.currentType.Children) {
+									EventDeclaration ed = o as EventDeclaration;
+									if (ed != null) {
+										if (ed.Name == methodName) {
+											return ie;
+										}
+										foreach (VariableDeclaration field in ed.VariableDeclarators) {
+											if (field.Name == methodName) {
+												return ie;
+											}
+										}
+									
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+			return null;
+		}
+		
+		bool IsEventHandlerCreation(Expression expr)
+		{
+			if (expr is ObjectCreateExpression) {
+				ObjectCreateExpression oce = (ObjectCreateExpression) expr;
+				if (oce.Parameters.Count == 1) {
+					expr = (Expression)oce.Parameters[0];
+					string methodName = null;
+					if (expr is IdentifierExpression) {
+						methodName = ((IdentifierExpression)expr).Identifier;
+					} else if (expr is FieldReferenceExpression) {
+						methodName = ((FieldReferenceExpression)expr).FieldName;
+					}
+					if (methodName != null) {
+						foreach (object o in this.currentType.Children) {
+							if (o is MethodDeclaration &amp;&amp; ((MethodDeclaration)o).Name == methodName) {
+								return true;
+							}
+						}
+					}
+					
+				}
+			}
+			
+			return false;
+		}
+		bool TypeHasOnlyStaticMembers(TypeDeclaration typeDeclaration)
+		{
+			foreach (object o in typeDeclaration.Children) {
+				if (o is MethodDeclaration) {
+					if ((((MethodDeclaration)o).Modifier &amp; Modifier.Static) != Modifier.Static) {
+						return false;
+					}
+				} else if (o is PropertyDeclaration) {
+					if ((((PropertyDeclaration)o).Modifier &amp; Modifier.Static) != Modifier.Static) {
+						return false;
+					}
+				} else if (o is FieldDeclaration) {
+					if ((((FieldDeclaration)o).Modifier &amp; Modifier.Static) != Modifier.Static) {
+						return false;
+					}
+				}else if (o is EventDeclaration) {
+					if ((((EventDeclaration)o).Modifier &amp; Modifier.Static) != Modifier.Static) {
+						return false;
+					}
+				}
+			}
+			return true;
+		}
+	}
+}
+

Added: branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/sharprefactory.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/sharprefactory.build	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/SharpRefactory/sharprefactory.build	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,18 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;project name=&quot;monodevelop.libraries.sharprefactory&quot; default=&quot;build&quot;&gt;
+    &lt;target name=&quot;build&quot; description=&quot;compiles the source code&quot;&gt;
+        &lt;csc target=&quot;library&quot; output=&quot;${path::combine(lib.dir, 'SharpRefactory.dll')}&quot; debug=&quot;${build.debug}&quot;&gt;
+            &lt;sources&gt;
+                &lt;include name=&quot;**/*.cs&quot;/&gt;
+                &lt;exclude name=&quot;Main.cs&quot;/&gt;
+                &lt;exclude name=&quot;Lexer/Tokens.cs&quot;/&gt;
+            &lt;/sources&gt;
+            &lt;!-- This reference exists to provide a Point class. It seems like
+                 it would make sense to use a different Point class to avoid
+                 this dep. --&gt;
+            &lt;references&gt;
+                &lt;include name=&quot;System.Drawing.dll&quot;/&gt;
+            &lt;/references&gt;
+        &lt;/csc&gt;
+    &lt;/target&gt;
+&lt;/project&gt;

Modified: branches/MonoDevelop-plan-43/src/Libraries/libraries.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/libraries.build	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Libraries/libraries.build	2004-08-15 21:12:38 UTC (rev 1945)
@@ -1,13 +1,15 @@
-&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;?xml version=&quot;1.0&quot;?&gt;
 &lt;project name=&quot;monodevelop.libraries&quot; default=&quot;build&quot;&gt;
     &lt;!-- cleanup build files --&gt;
     &lt;target name=&quot;clean&quot; description=&quot;remove all files created by the build task&quot;&gt;
         &lt;nant buildfile=&quot;Gdl/gdl.build&quot; target=&quot;clean&quot;/&gt;
+	&lt;nant buildfile=&quot;SharpRefactory/sharprefactory.build&quot; target=&quot;clean&quot;/&gt;
     &lt;/target&gt;
 
-    &lt;!-- build the project --&gt;
+    &lt;!-- build the project --&gt;
     &lt;target name=&quot;build&quot; description=&quot;compiles the source code&quot;&gt;
         &lt;!-- build Gdl library --&gt;
-        &lt;nant buildfile=&quot;Gdl/gdl.build&quot; target=&quot;build&quot;/&gt;
+        &lt;nant buildfile=&quot;Gdl/gdl.build&quot; target=&quot;build&quot;/&gt;
+	&lt;nant buildfile=&quot;SharpRefactory/sharprefactory.build&quot; target=&quot;build&quot;/&gt;
     &lt;/target&gt;
 &lt;/project&gt;

Modified: branches/MonoDevelop-plan-43/src/Plugins/CSharp/CSharpNodeViewer.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/CSharp/CSharpNodeViewer.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/CSharp/CSharpNodeViewer.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -86,7 +86,6 @@
 			string line;
 			buffer.Text = &quot;&quot;;
 			while ((line = sr.ReadLine ()) != null) {
-				log.Debug (line);
 				buffer.Text += line + &quot;\n&quot;;
 			}
 		}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ClassType.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ClassType.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ClassType.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,17 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public enum ClassType {
+		Class,
+		Enum,
+		Interface,
+		Struct,
+		Delegate
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/AttributeCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/AttributeCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/AttributeCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IAttribute'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IAttributeCollection'/&gt;
+	[Serializable()]
+	public class AttributeCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IAttributeCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public AttributeCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IAttributeCollection'/&gt; based on another &lt;see cref='.IAttributeCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IAttributeCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public AttributeCollection(AttributeCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IAttributeCollection'/&gt; containing any array of &lt;see cref='.IAttribute'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IAttribute'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public AttributeCollection(IAttribute[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IAttribute'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IAttribute this[int index] {
+			get {
+				return ((IAttribute)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IAttribute'/&gt; with the specified value to the
+		///    &lt;see cref='.IAttributeCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IAttribute'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IAttributeCollection.AddRange'/&gt;
+		public int Add(IAttribute value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IAttributeCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IAttribute'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IAttributeCollection.Add'/&gt;
+		public void AddRange(IAttribute[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IAttributeCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IAttributeCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IAttributeCollection.Add'/&gt;
+		public void AddRange(AttributeCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IAttributeCollection'/&gt; contains the specified &lt;see cref='.IAttribute'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IAttribute'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IAttribute'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IAttributeCollection.IndexOf'/&gt;
+		public bool Contains(IAttribute value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IAttributeCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IAttributeCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IAttributeCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IAttribute[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IAttribute'/&gt; in
+		///       the &lt;see cref='.IAttributeCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IAttribute'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IAttribute'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IAttributeCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IAttributeCollection.Contains'/&gt;
+		public int IndexOf(IAttribute value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IAttribute'/&gt; into the &lt;see cref='.IAttributeCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IAttribute'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IAttributeCollection.Add'/&gt;
+		public void Insert(int index, IAttribute value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IAttributeCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IAttributeEnumerator GetEnumerator() {
+			return new IAttributeEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IAttribute'/&gt; from the
+		///    &lt;see cref='.IAttributeCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IAttribute'/&gt; to remove from the &lt;see cref='.IAttributeCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IAttribute value) {
+			List.Remove(value);
+		}
+		
+		public class IAttributeEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IAttributeEnumerator(AttributeCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IAttribute Current {
+				get {
+					return ((IAttribute)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/AttributeSectionCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/AttributeSectionCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/AttributeSectionCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.AttributeSection'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.AttributeSectionCollection'/&gt;
+	[Serializable()]
+	public class AttributeSectionCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.AttributeSectionCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public AttributeSectionCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.AttributeSectionCollection'/&gt; based on another &lt;see cref='.AttributeSectionCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.AttributeSectionCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public AttributeSectionCollection(AttributeSectionCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.AttributeSectionCollection'/&gt; containing any array of &lt;see cref='.AttributeSection'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.AttributeSection'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public AttributeSectionCollection(IAttributeSection[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.AttributeSection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IAttributeSection this[int index] {
+			get {
+				return ((IAttributeSection)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.AttributeSection'/&gt; with the specified value to the
+		///    &lt;see cref='.AttributeSectionCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.AttributeSection'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.AttributeSectionCollection.AddRange'/&gt;
+		public int Add(IAttributeSection value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.AttributeSectionCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.AttributeSection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.AttributeSectionCollection.Add'/&gt;
+		public void AddRange(IAttributeSection[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.AttributeSectionCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.AttributeSectionCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.AttributeSectionCollection.Add'/&gt;
+		public void AddRange(AttributeSectionCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.AttributeSectionCollection'/&gt; contains the specified &lt;see cref='.AttributeSection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.AttributeSection'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.AttributeSection'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.AttributeSectionCollection.IndexOf'/&gt;
+		public bool Contains(IAttributeSection value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.AttributeSectionCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.AttributeSectionCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.AttributeSectionCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IAttributeSection[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.AttributeSection'/&gt; in
+		///       the &lt;see cref='.AttributeSectionCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.AttributeSection'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.AttributeSection'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.AttributeSectionCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.AttributeSectionCollection.Contains'/&gt;
+		public int IndexOf(IAttributeSection value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.AttributeSection'/&gt; into the &lt;see cref='.AttributeSectionCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.AttributeSection'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.AttributeSectionCollection.Add'/&gt;
+		public void Insert(int index, IAttributeSection value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.AttributeSectionCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new AttributeSectionEnumerator GetEnumerator() {
+			return new AttributeSectionEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.AttributeSection'/&gt; from the
+		///    &lt;see cref='.AttributeSectionCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.AttributeSection'/&gt; to remove from the &lt;see cref='.AttributeSectionCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IAttributeSection value) {
+			List.Remove(value);
+		}
+		
+		public class AttributeSectionEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public AttributeSectionEnumerator(AttributeSectionCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IAttributeSection Current {
+				get {
+					return ((IAttributeSection)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/ClassCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/ClassCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/ClassCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IClass'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IClassCollection'/&gt;
+	[Serializable()]
+	public class ClassCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IClassCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public ClassCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IClassCollection'/&gt; based on another &lt;see cref='.IClassCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IClassCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public ClassCollection(ClassCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IClassCollection'/&gt; containing any array of &lt;see cref='.IClass'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IClass'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public ClassCollection(IClass[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IClass'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IClass this[int index] {
+			get {
+				return ((IClass)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IClass'/&gt; with the specified value to the
+		///    &lt;see cref='.IClassCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IClass'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IClassCollection.AddRange'/&gt;
+		public int Add(IClass value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IClassCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IClass'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IClassCollection.Add'/&gt;
+		public void AddRange(IClass[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IClassCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IClassCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IClassCollection.Add'/&gt;
+		public void AddRange(ClassCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IClassCollection'/&gt; contains the specified &lt;see cref='.IClass'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IClass'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IClass'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IClassCollection.IndexOf'/&gt;
+		public bool Contains(IClass value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IClassCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IClassCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IClassCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IClass[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IClass'/&gt; in
+		///       the &lt;see cref='.IClassCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IClass'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IClass'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IClassCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IClassCollection.Contains'/&gt;
+		public int IndexOf(IClass value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IClass'/&gt; into the &lt;see cref='.IClassCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IClass'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IClassCollection.Add'/&gt;
+		public void Insert(int index, IClass value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IClassCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IClassEnumerator GetEnumerator() {
+			return new IClassEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IClass'/&gt; from the
+		///    &lt;see cref='.IClassCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IClass'/&gt; to remove from the &lt;see cref='.IClassCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IClass value) {
+			List.Remove(value);
+		}
+		
+		public class IClassEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IClassEnumerator(ClassCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IClass Current {
+				get {
+					return ((IClass)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/CommentCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/CommentCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/CommentCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.Comment'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.CommentCollection'/&gt;
+	[Serializable()]
+	public class CommentCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.CommentCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public CommentCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.CommentCollection'/&gt; based on another &lt;see cref='.CommentCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.CommentCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public CommentCollection(CommentCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.CommentCollection'/&gt; containing any array of &lt;see cref='.Comment'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.Comment'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public CommentCollection(Comment[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.Comment'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public Comment this[int index] {
+			get {
+				return ((Comment)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.Comment'/&gt; with the specified value to the
+		///    &lt;see cref='.CommentCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.Comment'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.CommentCollection.AddRange'/&gt;
+		public int Add(Comment value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.CommentCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.Comment'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.CommentCollection.Add'/&gt;
+		public void AddRange(Comment[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.CommentCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.CommentCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.CommentCollection.Add'/&gt;
+		public void AddRange(CommentCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.CommentCollection'/&gt; contains the specified &lt;see cref='.Comment'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.Comment'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.Comment'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.CommentCollection.IndexOf'/&gt;
+		public bool Contains(Comment value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.CommentCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.CommentCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.CommentCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(Comment[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.Comment'/&gt; in
+		///       the &lt;see cref='.CommentCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.Comment'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.Comment'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.CommentCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.CommentCollection.Contains'/&gt;
+		public int IndexOf(Comment value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.Comment'/&gt; into the &lt;see cref='.CommentCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.Comment'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.CommentCollection.Add'/&gt;
+		public void Insert(int index, Comment value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.CommentCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new CommentEnumerator GetEnumerator() {
+			return new CommentEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.Comment'/&gt; from the
+		///    &lt;see cref='.CommentCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.Comment'/&gt; to remove from the &lt;see cref='.CommentCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(Comment value) {
+			List.Remove(value);
+		}
+		
+		public class CommentEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public CommentEnumerator(CommentCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public Comment Current {
+				get {
+					return ((Comment)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/EventCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/EventCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/EventCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,236 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	
+	
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IEvent'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IEventCollection'/&gt;
+	[Serializable()]
+	public class EventCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IEventCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public EventCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IEventCollection'/&gt; based on another &lt;see cref='.IEventCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IEventCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public EventCollection(EventCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IEventCollection'/&gt; containing any array of &lt;see cref='.IEvent'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IEvent'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public EventCollection(IEvent[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IEvent'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IEvent this[int index] {
+			get {
+				return ((IEvent)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IEvent'/&gt; with the specified value to the
+		///    &lt;see cref='.IEventCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IEvent'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IEventCollection.AddRange'/&gt;
+		public int Add(IEvent value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IEventCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IEvent'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IEventCollection.Add'/&gt;
+		public void AddRange(IEvent[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IEventCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IEventCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IEventCollection.Add'/&gt;
+		public void AddRange(EventCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IEventCollection'/&gt; contains the specified &lt;see cref='.IEvent'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IEvent'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IEvent'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IEventCollection.IndexOf'/&gt;
+		public bool Contains(IEvent value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IEventCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IEventCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IEventCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IEvent[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IEvent'/&gt; in
+		///       the &lt;see cref='.IEventCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IEvent'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IEvent'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IEventCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IEventCollection.Contains'/&gt;
+		public int IndexOf(IEvent value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IEvent'/&gt; into the &lt;see cref='.IEventCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IEvent'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IEventCollection.Add'/&gt;
+		public void Insert(int index, IEvent value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IEventCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IEventEnumerator GetEnumerator() {
+			return new IEventEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IEvent'/&gt; from the
+		///    &lt;see cref='.IEventCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IEvent'/&gt; to remove from the &lt;see cref='.IEventCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IEvent value) {
+			List.Remove(value);
+		}
+		
+		public class IEventEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IEventEnumerator(EventCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IEvent Current {
+				get {
+					return ((IEvent)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/FieldCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/FieldCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/FieldCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IField'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IFieldCollection'/&gt;
+	[Serializable()]
+	public class FieldCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IFieldCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public FieldCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IFieldCollection'/&gt; based on another &lt;see cref='.IFieldCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IFieldCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public FieldCollection(FieldCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IFieldCollection'/&gt; containing any array of &lt;see cref='.IField'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IField'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public FieldCollection(IField[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IField'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IField this[int index] {
+			get {
+				return ((IField)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IField'/&gt; with the specified value to the
+		///    &lt;see cref='.IFieldCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IField'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IFieldCollection.AddRange'/&gt;
+		public int Add(IField value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IFieldCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IField'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IFieldCollection.Add'/&gt;
+		public void AddRange(IField[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IFieldCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IFieldCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IFieldCollection.Add'/&gt;
+		public void AddRange(FieldCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IFieldCollection'/&gt; contains the specified &lt;see cref='.IField'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IField'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IField'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IFieldCollection.IndexOf'/&gt;
+		public bool Contains(IField value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IFieldCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IFieldCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IFieldCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IField[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IField'/&gt; in
+		///       the &lt;see cref='.IFieldCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IField'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IField'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IFieldCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IFieldCollection.Contains'/&gt;
+		public int IndexOf(IField value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IField'/&gt; into the &lt;see cref='.IFieldCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IField'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IFieldCollection.Add'/&gt;
+		public void Insert(int index, IField value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IFieldCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IFieldEnumerator GetEnumerator() {
+			return new IFieldEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IField'/&gt; from the
+		///    &lt;see cref='.IFieldCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IField'/&gt; to remove from the &lt;see cref='.IFieldCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IField value) {
+			List.Remove(value);
+		}
+		
+		public class IFieldEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IFieldEnumerator(FieldCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IField Current {
+				get {
+					return ((IField)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/IUsingCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/IUsingCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/IUsingCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IUsing'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IUsingCollection'/&gt;
+	[Serializable()]
+	public class IUsingCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IUsingCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public IUsingCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IUsingCollection'/&gt; based on another &lt;see cref='.IUsingCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IUsingCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public IUsingCollection(IUsingCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IUsingCollection'/&gt; containing any array of &lt;see cref='.IUsing'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IUsing'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public IUsingCollection(IUsing[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IUsing'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IUsing this[int index] {
+			get {
+				return ((IUsing)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IUsing'/&gt; with the specified value to the
+		///    &lt;see cref='.IUsingCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IUsing'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IUsingCollection.AddRange'/&gt;
+		public int Add(IUsing value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IUsingCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IUsing'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IUsingCollection.Add'/&gt;
+		public void AddRange(IUsing[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IUsingCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IUsingCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IUsingCollection.Add'/&gt;
+		public void AddRange(IUsingCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IUsingCollection'/&gt; contains the specified &lt;see cref='.IUsing'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IUsing'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IUsing'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IUsingCollection.IndexOf'/&gt;
+		public bool Contains(IUsing value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IUsingCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IUsingCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IUsingCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IUsing[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IUsing'/&gt; in
+		///       the &lt;see cref='.IUsingCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IUsing'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IUsing'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IUsingCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IUsingCollection.Contains'/&gt;
+		public int IndexOf(IUsing value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IUsing'/&gt; into the &lt;see cref='.IUsingCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IUsing'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IUsingCollection.Add'/&gt;
+		public void Insert(int index, IUsing value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IUsingCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IUsingEnumerator GetEnumerator() {
+			return new IUsingEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IUsing'/&gt; from the
+		///    &lt;see cref='.IUsingCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IUsing'/&gt; to remove from the &lt;see cref='.IUsingCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IUsing value) {
+			List.Remove(value);
+		}
+		
+		public class IUsingEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IUsingEnumerator(IUsingCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IUsing Current {
+				get {
+					return ((IUsing)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/MethodCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/MethodCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/MethodCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IMethod'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IMethodCollection'/&gt;
+	[Serializable()]
+	public class MethodCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IMethodCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public MethodCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IMethodCollection'/&gt; based on another &lt;see cref='.IMethodCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IMethodCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public MethodCollection(MethodCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IMethodCollection'/&gt; containing any array of &lt;see cref='.IMethod'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IMethod'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public MethodCollection(IMethod[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IMethod'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IMethod this[int index] {
+			get {
+				return ((IMethod)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IMethod'/&gt; with the specified value to the
+		///    &lt;see cref='.IMethodCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IMethod'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IMethodCollection.AddRange'/&gt;
+		public int Add(IMethod value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IMethodCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IMethod'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IMethodCollection.Add'/&gt;
+		public void AddRange(IMethod[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IMethodCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IMethodCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IMethodCollection.Add'/&gt;
+		public void AddRange(MethodCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IMethodCollection'/&gt; contains the specified &lt;see cref='.IMethod'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IMethod'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IMethod'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IMethodCollection.IndexOf'/&gt;
+		public bool Contains(IMethod value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IMethodCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IMethodCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IMethodCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IMethod[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IMethod'/&gt; in
+		///       the &lt;see cref='.IMethodCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IMethod'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IMethod'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IMethodCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IMethodCollection.Contains'/&gt;
+		public int IndexOf(IMethod value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IMethod'/&gt; into the &lt;see cref='.IMethodCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IMethod'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IMethodCollection.Add'/&gt;
+		public void Insert(int index, IMethod value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IMethodCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IMethodEnumerator GetEnumerator() {
+			return new IMethodEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IMethod'/&gt; from the
+		///    &lt;see cref='.IMethodCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IMethod'/&gt; to remove from the &lt;see cref='.IMethodCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IMethod value) {
+			List.Remove(value);
+		}
+		
+		public class IMethodEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IMethodEnumerator(MethodCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IMethod Current {
+				get {
+					return ((IMethod)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/ParameterCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/ParameterCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/ParameterCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IParameter'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IParameterCollection'/&gt;
+	[Serializable()]
+	public class ParameterCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IParameterCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public ParameterCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IParameterCollection'/&gt; based on another &lt;see cref='.IParameterCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IParameterCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public ParameterCollection(ParameterCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IParameterCollection'/&gt; containing any array of &lt;see cref='.IParameter'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IParameter'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public ParameterCollection(IParameter[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IParameter'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IParameter this[int index] {
+			get {
+				return ((IParameter)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IParameter'/&gt; with the specified value to the
+		///    &lt;see cref='.IParameterCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IParameter'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IParameterCollection.AddRange'/&gt;
+		public int Add(IParameter value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IParameterCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IParameter'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IParameterCollection.Add'/&gt;
+		public void AddRange(IParameter[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IParameterCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IParameterCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IParameterCollection.Add'/&gt;
+		public void AddRange(ParameterCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IParameterCollection'/&gt; contains the specified &lt;see cref='.IParameter'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IParameter'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IParameter'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IParameterCollection.IndexOf'/&gt;
+		public bool Contains(IParameter value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IParameterCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IParameterCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IParameterCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IParameter[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IParameter'/&gt; in
+		///       the &lt;see cref='.IParameterCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IParameter'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IParameter'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IParameterCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IParameterCollection.Contains'/&gt;
+		public int IndexOf(IParameter value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IParameter'/&gt; into the &lt;see cref='.IParameterCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IParameter'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IParameterCollection.Add'/&gt;
+		public void Insert(int index, IParameter value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IParameterCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IParameterEnumerator GetEnumerator() {
+			return new IParameterEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IParameter'/&gt; from the
+		///    &lt;see cref='.IParameterCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IParameter'/&gt; to remove from the &lt;see cref='.IParameterCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IParameter value) {
+			List.Remove(value);
+		}
+		
+		public class IParameterEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IParameterEnumerator(ParameterCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IParameter Current {
+				get {
+					return ((IParameter)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/PropertyCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/PropertyCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/PropertyCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser 
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IProperty'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IPropertyCollection'/&gt;
+	[Serializable()]
+	public class PropertyCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IPropertyCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public PropertyCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IPropertyCollection'/&gt; based on another &lt;see cref='.IPropertyCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IPropertyCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public PropertyCollection(PropertyCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IPropertyCollection'/&gt; containing any array of &lt;see cref='.IProperty'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IProperty'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public PropertyCollection(IProperty[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IProperty'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IProperty this[int index] {
+			get {
+				return ((IProperty)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IProperty'/&gt; with the specified value to the
+		///    &lt;see cref='.IPropertyCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IProperty'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IPropertyCollection.AddRange'/&gt;
+		public int Add(IProperty value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IPropertyCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IProperty'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IPropertyCollection.Add'/&gt;
+		public void AddRange(IProperty[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IPropertyCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IPropertyCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IPropertyCollection.Add'/&gt;
+		public void AddRange(PropertyCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IPropertyCollection'/&gt; contains the specified &lt;see cref='.IProperty'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IProperty'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IProperty'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IPropertyCollection.IndexOf'/&gt;
+		public bool Contains(IProperty value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IPropertyCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IPropertyCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IPropertyCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IProperty[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IProperty'/&gt; in
+		///       the &lt;see cref='.IPropertyCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IProperty'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IProperty'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IPropertyCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IPropertyCollection.Contains'/&gt;
+		public int IndexOf(IProperty value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IProperty'/&gt; into the &lt;see cref='.IPropertyCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IProperty'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IPropertyCollection.Add'/&gt;
+		public void Insert(int index, IProperty value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IPropertyCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IPropertyEnumerator GetEnumerator() {
+			return new IPropertyEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IProperty'/&gt; from the
+		///    &lt;see cref='.IPropertyCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IProperty'/&gt; to remove from the &lt;see cref='.IPropertyCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IProperty value) {
+			List.Remove(value);
+		}
+		
+		public class IPropertyEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IPropertyEnumerator(PropertyCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IProperty Current {
+				get {
+					return ((IProperty)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/TagCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/TagCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/TagCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,237 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.Tag'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.TagCollection'/&gt;
+	
+	[Serializable()]
+	
+	public class TagCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.TagCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public TagCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.TagCollection'/&gt; based on another &lt;see cref='.TagCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.TagCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public TagCollection(TagCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.TagCollection'/&gt; containing any array of &lt;see cref='.Tag'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.Tag'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public TagCollection(Tag[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.Tag'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public Tag this[int index] {
+			get {
+				return ((Tag)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.Tag'/&gt; with the specified value to the
+		///    &lt;see cref='.TagCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.Tag'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.TagCollection.AddRange'/&gt;
+		public int Add(Tag value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.TagCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.Tag'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.TagCollection.Add'/&gt;
+		public void AddRange(Tag[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.TagCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.TagCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.TagCollection.Add'/&gt;
+		public void AddRange(TagCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.TagCollection'/&gt; contains the specified &lt;see cref='.Tag'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.Tag'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.Tag'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.TagCollection.IndexOf'/&gt;
+		public bool Contains(Tag value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.TagCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.TagCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.TagCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(Tag[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.Tag'/&gt; in
+		///       the &lt;see cref='.TagCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.Tag'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.Tag'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.TagCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.TagCollection.Contains'/&gt;
+		public int IndexOf(Tag value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.Tag'/&gt; into the &lt;see cref='.TagCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.Tag'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.TagCollection.Add'/&gt;
+		public void Insert(int index, Tag value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.TagCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new TagEnumerator GetEnumerator() {
+			return new TagEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.Tag'/&gt; from the
+		///    &lt;see cref='.TagCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.Tag'/&gt; to remove from the &lt;see cref='.TagCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(Tag value) {
+			List.Remove(value);
+		}
+		
+		public class TagEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			private IEnumerable temp;
+			
+			public TagEnumerator(TagCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public Tag Current {
+				get {
+					return ((Tag)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/TypedCSharpCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/TypedCSharpCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Collections/TypedCSharpCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,234 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.IIndexer'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.IIndexerCollection'/&gt;
+	[Serializable()]
+	public class IndexerCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IIndexerCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public IndexerCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IIndexerCollection'/&gt; based on another &lt;see cref='.IIndexerCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.IIndexerCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public IndexerCollection(IndexerCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.IIndexerCollection'/&gt; containing any array of &lt;see cref='.IIndexer'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.IIndexer'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public IndexerCollection(IIndexer[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.IIndexer'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public IIndexer this[int index] {
+			get {
+				return ((IIndexer)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.IIndexer'/&gt; with the specified value to the
+		///    &lt;see cref='.IIndexerCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IIndexer'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IIndexerCollection.AddRange'/&gt;
+		public int Add(IIndexer value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.IIndexerCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.IIndexer'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IIndexerCollection.Add'/&gt;
+		public void AddRange(IIndexer[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.IIndexerCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.IIndexerCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IIndexerCollection.Add'/&gt;
+		public void AddRange(IndexerCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.IIndexerCollection'/&gt; contains the specified &lt;see cref='.IIndexer'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IIndexer'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.IIndexer'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IIndexerCollection.IndexOf'/&gt;
+		public bool Contains(IIndexer value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.IIndexerCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.IIndexerCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.IIndexerCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(IIndexer[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.IIndexer'/&gt; in
+		///       the &lt;see cref='.IIndexerCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IIndexer'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.IIndexer'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.IIndexerCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.IIndexerCollection.Contains'/&gt;
+		public int IndexOf(IIndexer value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.IIndexer'/&gt; into the &lt;see cref='.IIndexerCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.IIndexer'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.IIndexerCollection.Add'/&gt;
+		public void Insert(int index, IIndexer value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.IIndexerCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new IIndexerEnumerator GetEnumerator() {
+			return new IIndexerEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.IIndexer'/&gt; from the
+		///    &lt;see cref='.IIndexerCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.IIndexer'/&gt; to remove from the &lt;see cref='.IIndexerCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(IIndexer value) {
+			List.Remove(value);
+		}
+		
+		public class IIndexerEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public IIndexerEnumerator(IndexerCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public IIndexer Current {
+				get {
+					return ((IIndexer)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Comment.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Comment.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Comment.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,44 @@
+&#239;&#187;&#191;// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class Comment : System.MarshalByRefObject
+	{
+		string commentString;
+		IRegion region;
+		
+		public string CommentString {
+			get {
+				return commentString;
+			}
+			set {
+				commentString = value;
+			}
+		}
+		
+		public IRegion Region {
+			get {
+				return region;
+			}
+			set {
+				region = value;
+			}
+		}
+		
+		public Comment(IRegion region)
+		{
+			this.region = region;
+		}
+		public Comment (IRegion region, string comment) : this(region)
+		{
+			commentString = comment;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IAttribute.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IAttribute.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IAttribute.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,49 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IAttributeSection: IComparable
+	{
+		AttributeTarget AttributeTarget {
+			get;
+		}
+		AttributeCollection Attributes {
+			get;
+		}
+	}
+
+	public interface IAttribute: IComparable
+	{
+		string Name {
+			get;
+		}
+		ArrayList PositionalArguments { // [expression]
+			get;
+		}
+		SortedList NamedArguments { // string/expression
+			get;
+		}
+	}
+
+	public enum AttributeTarget
+	{
+		None,
+		Assembly,
+		Field,
+		Event,
+		Method,
+		Module,
+		Param,
+		Property,
+		Return,
+		Type
+	}
+
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IClass.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IClass.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IClass.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,77 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IClass : IDecoration
+	{
+		string FullyQualifiedName {
+			get;
+		}
+		
+		string Name {
+			get;
+		}
+
+		string Namespace {
+			get;
+		}
+		
+		ClassType ClassType {
+			get;
+		}		
+		
+		ICompilationUnit CompilationUnit {
+			get;
+		}
+		
+		IRegion Region {
+			get;
+		}
+		
+		IRegion BodyRegion {
+			get;
+		}
+		
+		StringCollection BaseTypes {
+			get;
+		}
+		
+		ClassCollection InnerClasses {
+			get;
+		}
+
+		FieldCollection Fields {
+			get;
+		}
+
+		PropertyCollection Properties {
+			get;
+		}
+
+		IndexerCollection Indexer {
+			get;
+		}
+
+		MethodCollection Methods {
+			get;
+		}
+
+		EventCollection Events {
+			get;
+		}
+
+		object DeclaredIn {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IComment.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IComment.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IComment.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,29 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System.Collections.Specialized;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IComment
+	{
+		bool IsBlockComment {
+			get;
+		}
+		
+		string CommentTag {
+			get;
+		}
+		
+		string CommentText {
+			get;
+		}
+		
+		IRegion Region {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ICompilationUnit.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ICompilationUnit.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ICompilationUnit.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,43 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System.Collections;
+using System.Collections.Specialized;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface ICompilationUnit : ICompilationUnitBase
+	{
+		IUsingCollection Usings {
+			get;
+		}
+		
+		AttributeSectionCollection Attributes {
+			get;
+		}
+		
+		ClassCollection Classes {
+			get;
+		}
+		
+		CommentCollection MiscComments {
+			get;
+		}
+		
+		CommentCollection DokuComments {
+			get;
+		}
+		
+		TagCollection TagComments {
+			get;
+		}
+		
+		ArrayList FoldingRegions {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ICompilationUnitBase.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ICompilationUnitBase.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ICompilationUnitBase.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,30 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System.Collections;
+using System.Collections.Specialized;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface ICompilationUnitBase
+	{
+		bool ErrorsDuringCompile {
+			get;
+			set;
+		}
+
+		string ErrorOutput {
+			get;
+			set;
+		}
+		
+		object Tag {
+			get;
+			set;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IDecoration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IDecoration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IDecoration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,92 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IDecoration: IComparable
+	{
+		ModifierEnum Modifiers {
+			get;
+		}
+
+		AttributeSectionCollection Attributes {
+			get;
+		}
+		
+		string Documentation {
+			get;
+		}
+
+		bool IsAbstract {
+			get;
+		}
+
+		bool IsSealed {
+			get;
+		}
+
+		bool IsStatic {
+			get;
+		}
+
+		bool IsVirtual {
+			get;
+		}
+
+		bool IsPublic {
+			get;
+		}
+
+		bool IsProtected {
+			get;
+		}
+
+		bool IsPrivate {
+			get;
+		}
+
+
+		bool IsInternal {
+			get;
+		}
+
+		bool IsFinal {
+			get;
+		}
+
+		bool IsSpecialName {
+			get;
+		}
+
+		bool IsReadonly {
+			get;
+		}
+
+		bool IsProtectedAndInternal {
+			get;
+		}
+
+		bool IsProtectedOrInternal {
+			get;
+		}
+
+		bool IsLiteral {
+			get;
+		}
+
+		bool IsOverride {
+			get;
+		}
+		
+		bool IsNew {
+			get;
+		}
+
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IEvent.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IEvent.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IEvent.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,30 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IEvent : IMember
+	{
+		IRegion BodyRegion {
+			get;
+		}
+		
+		IMethod AddMethod {
+			get;
+		}
+		
+		IMethod RemoveMethod {
+			get;
+		}
+		
+		IMethod RaiseMethod {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IExpressionFinder.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IExpressionFinder.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IExpressionFinder.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,19 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IExpressionFinder
+	{
+		/// &lt;summary&gt;
+		/// Finds an expression before the current offset.
+		/// &lt;/summary&gt;
+		string FindExpression(string text, int offset);
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IField.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IField.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IField.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,16 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IField : IMember
+	{
+
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IIndexer.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IIndexer.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IIndexer.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,29 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IIndexer: IMember
+	{
+		IRegion BodyRegion {
+			get;
+		}
+		
+		IRegion GetterRegion {
+			get;
+		}
+
+		IRegion SetterRegion {
+			get;
+		}
+
+		ParameterCollection Parameters {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IMember.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IMember.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IMember.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,37 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IMember : IDecoration
+	{
+		string FullyQualifiedName {
+			get;
+		}
+		IRegion Region {
+			get;
+		}
+
+		string Name {
+			get;
+		}
+
+		string Namespace {
+			get;
+		}
+
+		IReturnType ReturnType {
+			get;
+		}
+
+		IClass DeclaringType {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IMethod.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IMethod.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IMethod.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,26 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IMethod : IMember
+	{
+		IRegion BodyRegion {
+			get;
+		}
+		
+		ParameterCollection Parameters {
+			get;
+		}
+
+		bool IsConstructor {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IParameter.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IParameter.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IParameter.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,47 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+
+	public interface IParameter: IComparable
+	{
+		string Name {
+			get;
+		}
+
+		IReturnType ReturnType {
+			get;
+		}
+
+		AttributeCollection AttributeCollection {
+			get;
+		}
+
+		ParameterModifier Modifier {
+			get;
+		}
+
+		string Documentation {
+			get;
+		}
+
+		bool IsOut {
+			get;
+		}
+
+		bool IsRef {
+			get;
+		}
+
+		bool IsParams {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IParser.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IParser.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IParser.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,148 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#131;&#194;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+
+using MonoDevelop.Services;
+using MonoDevelop.Internal.Project;
+
+namespace MonoDevelop.Internal.Parser
+{
+//	[Flags]
+//	public enum ShowMembers {
+//		Public     = 1,
+//		Protected  = 2,
+//		Private    = 4,
+//		Static     = 8
+//	}
+	
+	public class ResolveResult
+	{
+		IClass type;
+		ArrayList members;
+		StringCollection namespaces;
+		
+		public IClass Type {
+			get {
+				return type;
+			}
+		}
+		
+		public ArrayList Members {
+			get {
+				return members;
+			}
+		}
+		
+		public StringCollection Namespaces {
+			get {
+				return namespaces;
+			}
+		}
+		
+		public ResolveResult(string[] namespaces) {
+			this.namespaces = new StringCollection();
+			this.namespaces.AddRange(namespaces);
+			members = new ArrayList();
+		}
+		
+		public ResolveResult(string[] namespaces, ArrayList classes) {
+			this.namespaces = new StringCollection();
+			this.namespaces.AddRange(namespaces);
+			members = classes;
+		}
+		
+		public ResolveResult(StringCollection namespaces) {
+			this.namespaces = namespaces;
+			members = new ArrayList();
+		}
+		
+		public ResolveResult(IClass type, ArrayList members) {
+			this.type = type;
+			this.members = members;
+			namespaces = new StringCollection();
+		}
+//		object[]    resolveContents;
+//		ShowMembers showMembers;
+//		
+//		public bool ShowPublic {
+//			get {
+//				return (showMembers &amp; ShowMembers.Public) == ShowMembers.Public;
+//			}
+//		}
+//
+//		public bool ShowProtected {
+//			get {
+//				return (showMembers &amp; ShowMembers.Protected) == ShowMembers.Protected;
+//			}
+//		}
+//		
+//		public bool ShowPrivate {
+//			get {
+//				return (showMembers &amp; ShowMembers.Private) == ShowMembers.Private;
+//			}
+//		}
+//
+//		public bool ShowStatic {
+//			get {
+//				return (showMembers &amp; ShowMembers.Static) == ShowMembers.Static;
+//			}
+//		}
+//		
+//		public object[] ResolveContents {
+//			get {
+//				return resolveContents;
+//			}
+//		}
+//		
+//		public ShowMembers ShowMembers {
+//			get {
+//				return showMembers;
+//			}
+//		}
+//		
+//		public ResolveResult(object[] resolveContents, ShowMembers showMembers)
+//		{
+//			this.resolveContents = resolveContents;
+//			this.showMembers     = showMembers;
+//		}
+	}
+	
+	public interface IParser {
+		
+		string[] LexerTags {
+			set;
+		}
+		
+		IExpressionFinder ExpressionFinder {
+			get;
+		}
+		
+		ICompilationUnitBase Parse(string fileName);
+		ICompilationUnitBase Parse(string fileName, string fileContent);
+		
+		/// &lt;summary&gt;
+		/// Resolves an expression.
+		/// The caretLineNumber and caretColumn is 1 based.
+		/// &lt;/summary&gt;
+		ResolveResult Resolve(IParserService parserService, 
+							  IProject project,
+		                      string expression, 
+		                      int caretLineNumber, 
+		                      int caretColumn, 
+		                      string fileName,
+		                      string fileContent);
+
+		string MonodocResolver (IParserService parserService, IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+
+		ArrayList IsAsResolve (IParserService parserService, IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+		
+		ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName);
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IProperty.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IProperty.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IProperty.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,46 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IProperty : IMember
+	{
+		IRegion BodyRegion {
+			get;
+		}
+		
+		IRegion GetterRegion {
+			get;
+		}
+
+		IRegion SetterRegion {
+			get;
+		}
+
+		bool CanGet {
+			get;
+		}
+
+		bool CanSet {
+			get;
+		}
+		
+		IMethod GetterMethod {
+			get;
+		}
+
+		IMethod SetterMethod {
+			get;
+		}
+		
+		ParameterCollection Parameters {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IRegion.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IRegion.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IRegion.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,38 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IRegion: IComparable
+	{
+		int BeginLine {
+			get;
+		}
+
+		int BeginColumn {
+			get;
+		}
+
+		int EndColumn {
+			get;
+			set;
+		}
+
+		int EndLine {
+			get;
+			set;
+		}
+		
+		string FileName {
+			get;
+			set;
+		}
+
+		bool IsInside(int row, int column);
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IReturnType.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IReturnType.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IReturnType.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,40 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IReturnType: IComparable
+	{
+		string FullyQualifiedName {
+			get;
+		}
+
+		string Name {
+			get;
+		}
+
+		string Namespace {
+			get;
+		}
+
+		int PointerNestingLevel {
+			get;
+		}
+		int ArrayCount { // ArrayDimensions.Length
+			get;
+		}
+		int[] ArrayDimensions {
+			get;
+		}
+		
+		object DeclaredIn {
+			get;
+		}
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/IUsing.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/IUsing.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/IUsing.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,28 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public interface IUsing
+	{
+		IRegion Region {
+			get;
+		}
+
+		StringCollection Usings {
+			get;
+		}
+
+		SortedList Aliases {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractAttribute.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractAttribute.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractAttribute.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,99 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+using System.Collections.Utility;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class AbstractAttributeSection : IAttributeSection
+	{
+		protected AttributeTarget     attributeTarget;
+		protected AttributeCollection attributes = new AttributeCollection();
+
+		public virtual AttributeTarget AttributeTarget {
+			get {
+				return attributeTarget;
+			}
+			set {
+				attributeTarget = value;
+			}
+		}
+
+		public virtual AttributeCollection Attributes {
+			get {
+				return attributes;
+			}
+		}
+		
+		public virtual int CompareTo(IAttributeSection value) {
+			int cmp;
+			
+			if(0 != (cmp = (int)(AttributeTarget - value.AttributeTarget)))
+				return cmp;
+			
+			return DiffUtility.Compare(Attributes, value.Attributes);
+		}
+		
+		int IComparable.CompareTo(object value) {
+			return CompareTo((IAttributeSection)value);
+		}
+	}
+	
+	public abstract class AbstractAttribute : IAttribute
+	{
+		protected string name;
+		protected ArrayList positionalArguments = new ArrayList();
+		protected SortedList namedArguments = new SortedList();
+
+		public virtual string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+		public virtual ArrayList PositionalArguments { // [expression]
+			get {
+				return positionalArguments;
+			}
+			set {
+				positionalArguments = value;
+			}
+		}
+		public virtual SortedList NamedArguments { // string/expression
+			get {
+				return namedArguments;
+			}
+			set {
+				namedArguments = value;
+			}
+		}
+		
+		public virtual int CompareTo(IAttribute value) {
+			int cmp;
+			
+			cmp = Name.CompareTo(value.Name);
+			if (cmp != 0) {
+				return cmp;
+			}
+			
+			cmp = DiffUtility.Compare(PositionalArguments, value.PositionalArguments);
+			if (cmp != 0) {
+				return cmp;
+			}
+			
+			return DiffUtility.Compare(NamedArguments, value.NamedArguments);
+		}
+		
+		int IComparable.CompareTo(object value) {
+			return CompareTo((IAttribute)value);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractClass.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractClass.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractClass.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,164 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Collections.Utility;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public abstract class AbstractClass : AbstractNamedEntity, IClass, IComparable
+	{
+		protected ClassType        classType;
+		protected IRegion          region;
+		protected IRegion          bodyRegion;
+		protected object           declaredIn;
+
+		protected StringCollection baseTypes       = new StringCollection();
+
+		protected ClassCollection    innerClasses = new ClassCollection();
+		protected FieldCollection    fields       = new FieldCollection();
+		protected PropertyCollection properties   = new PropertyCollection();
+		protected MethodCollection   methods      = new MethodCollection();
+		protected EventCollection    events       = new EventCollection();
+		protected IndexerCollection  indexer      = new IndexerCollection();
+
+		public abstract ICompilationUnit CompilationUnit {
+			get;
+		}
+
+		public virtual ClassType ClassType {
+			get {
+				return classType;
+			}
+		}
+
+		public virtual IRegion Region {
+			get {
+				return region;
+			}
+		}
+		
+		public virtual IRegion BodyRegion {
+			get {
+				return bodyRegion;
+			}
+		}
+
+		public object DeclaredIn {
+			get {
+				return declaredIn;
+			}
+		}
+
+		public virtual StringCollection BaseTypes {
+			get {
+				return baseTypes;
+			}
+		}
+		
+		public virtual ClassCollection InnerClasses {
+			get {
+				return innerClasses;
+			}
+		}
+
+		public virtual FieldCollection Fields {
+			get {
+				return fields;
+			}
+		}
+
+		public virtual PropertyCollection Properties {
+			get {
+				return properties;
+			}
+		}
+
+		public IndexerCollection Indexer {
+			get {
+				return indexer;
+			}
+		}
+
+		public virtual MethodCollection Methods {
+			get {
+				return methods;
+			}
+		}
+
+		public virtual EventCollection Events {
+			get {
+				return events;
+			}
+		}
+
+
+		public virtual int CompareTo(IClass value)
+		{
+			int cmp;
+			
+			if(0 != (cmp = base.CompareTo((IDecoration)value))) {
+				return cmp;
+			}
+			
+			if (FullyQualifiedName != null) {
+				cmp = FullyQualifiedName.CompareTo(value.FullyQualifiedName);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (Region != null) {
+				cmp = Region.CompareTo(value.Region);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			cmp = DiffUtility.Compare(BaseTypes, value.BaseTypes);
+			if(cmp != 0)
+				return cmp;
+			
+			cmp = DiffUtility.Compare(InnerClasses, value.InnerClasses);
+			if(cmp != 0)
+				return cmp;
+			
+			cmp = DiffUtility.Compare(Fields, value.Fields);
+			if(cmp != 0)
+				return cmp;
+			
+			cmp = DiffUtility.Compare(Properties, value.Properties);
+			if(cmp != 0)
+				return cmp;
+			
+			cmp = DiffUtility.Compare(Indexer, value.Indexer);
+			if(cmp != 0)
+				return cmp;
+			
+			cmp = DiffUtility.Compare(Methods, value.Methods);
+			if(cmp != 0)
+				return cmp;
+			
+			return DiffUtility.Compare(Events, value.Events);
+		}
+		
+		int IComparable.CompareTo(object o) 
+		{
+			return CompareTo((IClass)o);
+		}
+		
+		protected override bool CanBeSubclass {
+			get {
+				return true;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractComment.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractComment.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractComment.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,44 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections.Specialized;
+
+namespace MonoDevelop.Internal.Parser {
+
+	[Serializable]
+	public abstract class AbstractComment : System.MarshalByRefObject, IComment
+	{
+		protected bool    isBlockComment;
+		protected string  commentTag;
+		protected string  commentText;
+		protected IRegion region;
+
+		public virtual bool IsBlockComment {
+			get {
+				return isBlockComment;
+			}
+		}
+
+		public virtual string CommentTag {
+			get {
+				return commentTag;
+			}
+		}
+
+		public virtual string CommentText {
+			get {
+				return commentText;
+			}
+		}
+
+		public virtual IRegion Region {
+			get {
+				return region;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractCompilationUnit.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractCompilationUnit.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractCompilationUnit.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,111 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+using System.Collections.Specialized;
+
+namespace MonoDevelop.Internal.Parser
+{
+	public class FoldingRegion
+	{
+		string  name;
+		IRegion region;
+		
+		public string Name {
+			get {
+				return name;
+			}
+		}
+		
+		public IRegion Region {
+			get {
+				return region;
+			}
+		}
+		
+		public FoldingRegion(string name, IRegion region)
+		{
+			this.name = name;
+			this.region = region;
+		}
+	}
+	
+	[Serializable]
+	public abstract class AbstractCompilationUnit : ICompilationUnit
+	{
+		protected IUsingCollection usings = new IUsingCollection();
+		protected ClassCollection classes = new ClassCollection();
+		protected AttributeSectionCollection attributes = new AttributeSectionCollection();
+		protected bool errorsDuringCompile = false;
+		protected object tag               = null;
+		protected ArrayList foldingRegions = new ArrayList();
+		protected string erroroutput = String.Empty;
+		
+		public bool ErrorsDuringCompile {
+			get {
+				return errorsDuringCompile;
+			}
+			set {
+				errorsDuringCompile = value;
+			}
+		}
+
+		public string ErrorOutput {
+			get {
+				return erroroutput;
+			}
+			set {
+				erroroutput = value;
+			}
+		}
+		
+		public object Tag {
+			get {
+				return tag;
+			}
+			set {
+				tag = value;
+			}
+		}
+		
+		public virtual IUsingCollection Usings {
+			get {
+				return usings;
+			}
+		}
+
+		public virtual AttributeSectionCollection Attributes {
+			get {
+				return attributes;
+			}
+		}
+
+		public virtual ClassCollection Classes {
+			get {
+				return classes;
+			}
+		}
+		
+		public ArrayList FoldingRegions {
+			get {
+				return foldingRegions;
+			}
+		}
+
+		public abstract CommentCollection MiscComments {
+			get;
+		}
+
+		public abstract CommentCollection DokuComments {
+			get;
+		}
+
+		public abstract TagCollection TagComments {
+			get;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractDecoration.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractDecoration.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractDecoration.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,166 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+using System.Collections.Utility;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public abstract class AbstractDecoration : MarshalByRefObject, IDecoration
+	{
+		protected ModifierEnum               modifiers     = ModifierEnum.None;
+		protected AttributeSectionCollection attributes    = null;
+		string documentation;
+		static Hashtable documentationHashtable = new Hashtable();
+		
+		
+		public virtual ModifierEnum Modifiers {
+			get {
+				return modifiers;
+			}
+		}
+
+		public virtual AttributeSectionCollection Attributes {
+			get {
+				if (attributes == null) {
+					attributes = new AttributeSectionCollection();
+				}
+				return attributes;
+			}
+		}
+
+		public string Documentation {
+			get {
+				return documentation == null ? &quot;&quot; : documentation;
+			}
+			set {
+				if (value == null)
+					documentation = null;
+				else {
+					string sharedVal = documentationHashtable [value] as string;
+					if (sharedVal == null) {
+						documentationHashtable [value] = value;
+						documentation = value;
+					}
+					else
+						documentation = sharedVal;
+				}
+			}
+		}
+		
+		public bool IsAbstract {
+			get {
+				return (modifiers &amp; ModifierEnum.Abstract) == ModifierEnum.Abstract;
+			}
+		}
+
+		public bool IsSealed {
+			get {
+				return (modifiers &amp; ModifierEnum.Sealed) == ModifierEnum.Sealed;
+			}
+		}
+
+		public bool IsStatic {
+			get {
+				return (modifiers &amp; ModifierEnum.Static) == ModifierEnum.Static;
+			}
+		}
+
+		public bool IsVirtual {
+			get {
+				return (modifiers &amp; ModifierEnum.Virtual) == ModifierEnum.Virtual;
+			}
+		}
+
+		public bool IsPublic {
+			get {
+				return (modifiers &amp; ModifierEnum.Public) == ModifierEnum.Public;
+			}
+		}
+
+		public bool IsProtected {
+			get {
+				return (modifiers &amp; ModifierEnum.Protected) == ModifierEnum.Protected;
+			}
+		}
+
+		public bool IsPrivate {
+			get {
+				return (modifiers &amp; ModifierEnum.Private) == ModifierEnum.Private;
+			}
+		}
+
+		public bool IsInternal {
+			get {
+				return (modifiers &amp; ModifierEnum.Internal) == ModifierEnum.Internal;
+			}
+		}
+
+		public bool IsProtectedAndInternal {
+			get {
+				return (modifiers &amp; (ModifierEnum.Internal | ModifierEnum.Protected)) == (ModifierEnum.Internal | ModifierEnum.Protected);
+			}
+		}
+
+		public bool IsProtectedOrInternal {
+			get {
+				return (modifiers &amp; ModifierEnum.ProtectedOrInternal) == ModifierEnum.ProtectedOrInternal;
+			}
+		}
+
+		public bool IsLiteral {
+			get {
+				return (modifiers &amp; ModifierEnum.Const) == ModifierEnum.Const;
+			}
+		}
+
+		public bool IsReadonly {
+			get {
+				return (modifiers &amp; ModifierEnum.Readonly) == ModifierEnum.Readonly;
+			}
+		}
+
+		public bool IsOverride {
+			get {
+				return (modifiers &amp; ModifierEnum.Override) == ModifierEnum.Override;
+			}
+		}
+
+		public bool IsFinal {
+			get {
+				return (modifiers &amp; ModifierEnum.Final) == ModifierEnum.Final;
+			}
+		}
+
+		public bool IsSpecialName {
+			get {
+				return (modifiers &amp; ModifierEnum.SpecialName) == ModifierEnum.SpecialName;
+			}
+		}
+
+		public bool IsNew {
+			get {
+				return (modifiers &amp; ModifierEnum.New) == ModifierEnum.New;
+			}
+		}
+		
+		public virtual int CompareTo(IDecoration value) {
+			int cmp;
+			
+			if(0 != (cmp = (int)(Modifiers - value.Modifiers)))
+				return cmp;
+			
+			return DiffUtility.Compare(Attributes, value.Attributes);
+		}
+		
+		int IComparable.CompareTo(object value) {
+			return CompareTo((IDecoration)value);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractEvent.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractEvent.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractEvent.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,80 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+using System.Collections.Utility;
+
+namespace MonoDevelop.Internal.Parser {
+	[Serializable]
+	public abstract class AbstractEvent : AbstractMember, IEvent
+	{
+		protected IRegion          bodyRegion;
+		protected EventAttributes  eventAttributes;
+		protected IMethod          addMethod;
+		protected IMethod          removeMethod;
+		protected IMethod          raiseMethod;
+		
+		public virtual IRegion BodyRegion {
+			get {
+				return bodyRegion;
+			}
+		}
+		
+
+		public virtual EventAttributes EventAttributes {
+			get {
+				return eventAttributes;
+			}
+		}
+
+		public virtual int CompareTo(IEvent value) {
+			int cmp;
+			
+			if(0 != (cmp = base.CompareTo((IDecoration)value)))
+				return cmp;
+			
+			if (FullyQualifiedName != null) {
+				cmp = FullyQualifiedName.CompareTo(value.FullyQualifiedName);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (ReturnType != null) {
+				cmp = ReturnType.CompareTo(value.ReturnType);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+						
+			return Region.CompareTo(value.Region);
+		}
+		
+		int IComparable.CompareTo(object value) {
+			return CompareTo((IEvent)value);
+		}
+		
+		public virtual IMethod AddMethod {
+			get {
+				return addMethod;
+			}
+		}
+		
+		public virtual IMethod RemoveMethod {
+			get {
+				return removeMethod;
+			}
+		}
+		
+		public virtual IMethod RaiseMethod {
+			get {
+				return raiseMethod;
+			}
+		}
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractField.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractField.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractField.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,55 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections.Utility;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser {
+	[Serializable]
+	public abstract class AbstractField : AbstractMember, IField
+	{
+		public virtual int CompareTo(IField field) 
+		{
+			int cmp;
+			
+			cmp = base.CompareTo((IDecoration)field);
+			if (cmp != 0) {
+				return cmp;
+			}
+			
+			if (FullyQualifiedName != null) {
+				cmp = FullyQualifiedName.CompareTo(field.FullyQualifiedName);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (FullyQualifiedName != null) {
+				cmp = FullyQualifiedName.CompareTo(field.FullyQualifiedName);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (ReturnType != null) {
+				cmp = ReturnType.CompareTo(field.ReturnType);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			if (Region != null) {
+				return Region.CompareTo(field.Region);
+			}
+			return 0;
+		}
+		
+		int IComparable.CompareTo(object value)
+		{
+			return CompareTo((IField)value);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractIndexer.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractIndexer.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractIndexer.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,94 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections.Utility;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public abstract class AbstractIndexer : AbstractMember, IIndexer
+	{
+		protected IRegion             bodyRegion;
+		protected IRegion             getterRegion;
+		protected IRegion             setterRegion;
+		protected ParameterCollection parameters = new ParameterCollection();
+		
+		public virtual IRegion BodyRegion {
+			get {
+				return bodyRegion;
+			}
+		}
+
+
+		public IRegion GetterRegion {
+			get {
+				return getterRegion;
+			}
+		}
+
+		public IRegion SetterRegion {
+			get {
+				return setterRegion;
+			}
+		}
+
+		public virtual ParameterCollection Parameters {
+			get {
+				return parameters;
+			}
+		}
+		
+		public virtual int CompareTo(IIndexer value) {
+			int cmp;
+			cmp = base.CompareTo((IDecoration)value);
+			if (cmp != 0) {
+				return cmp;
+			}
+			
+			if (FullyQualifiedName != null) {
+				cmp = FullyQualifiedName.CompareTo(value.FullyQualifiedName);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (ReturnType != null) {
+				cmp = ReturnType.CompareTo(value.ReturnType);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (Region != null) {
+				cmp = Region.CompareTo(value.Region);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (GetterRegion != null) {
+				cmp = GetterRegion.CompareTo(value.GetterRegion);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (SetterRegion != null) {
+				cmp = SetterRegion.CompareTo(value.SetterRegion);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			return DiffUtility.Compare(Parameters, value.Parameters);
+		}
+		
+		int IComparable.CompareTo(object value) {
+			return CompareTo((IIndexer)value);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractMember.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractMember.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractMember.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,40 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;?&quot; email=&quot;?&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public abstract class AbstractMember : AbstractNamedEntity, IMember
+	{
+		protected IClass declaringType;
+		protected IReturnType returnType;
+		protected IRegion          region;
+		
+		public virtual IRegion Region {
+			get {
+				return region;
+			}
+		}
+		
+		public IClass DeclaringType {
+			get {
+				return declaringType;
+			}
+		}
+		
+		public IReturnType ReturnType {
+			get {
+				return returnType;
+			}
+			set {
+				returnType = value;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractMethod.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractMethod.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractMethod.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,92 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+using System.Collections.Utility;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public abstract class AbstractMethod : AbstractMember, IMethod
+	{
+		protected IRegion bodyRegion;
+		
+		protected ParameterCollection parameters = new ParameterCollection();
+
+		public virtual IRegion BodyRegion {
+			get {
+				return bodyRegion;
+			}
+		}
+		
+		public virtual ParameterCollection Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+
+		public virtual bool IsConstructor {
+			get {
+				return returnType == null || Name == &quot;ctor&quot;;
+			}
+		}
+
+		public override string ToString()
+		{
+			return String.Format(&quot;[AbstractMethod: FullyQualifiedName={0}, ReturnType = {1}, IsConstructor={2}, Modifier={3}]&quot;,
+			                     FullyQualifiedName,
+			                     ReturnType,
+			                     IsConstructor,
+			                     base.Modifiers);
+		}
+		
+		public virtual int CompareTo(IMethod value)
+		{
+			int cmp;
+			
+			cmp = base.CompareTo((IDecoration)value);
+			
+			if (cmp != 0) {
+				return cmp;
+			}
+			
+			if (FullyQualifiedName != null) {
+				cmp = FullyQualifiedName.CompareTo(value.FullyQualifiedName);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (ReturnType != null) {
+				cmp = ReturnType.CompareTo(value.ReturnType);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (Region != null) {
+				cmp = Region.CompareTo(value.Region);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			return DiffUtility.Compare(Parameters, value.Parameters);
+		}
+		
+		int IComparable.CompareTo(object value)
+		{
+			if (value == null) {
+				return 0;
+			}
+			return CompareTo((IMethod)value);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractNamedEntity.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractNamedEntity.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractNamedEntity.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,81 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;?&quot; email=&quot;?&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public abstract class AbstractNamedEntity : AbstractDecoration
+	{
+		public static Hashtable fullyQualifiedNames = new Hashtable();
+		string fqname;
+		
+		public virtual string FullyQualifiedName {
+			get {
+				return fqname;
+			}
+			set {
+				if (value == null)
+					fqname = null;
+				else {
+					string sharedVal = fullyQualifiedNames[value] as string;
+					if (sharedVal != null)
+						fqname = sharedVal;
+					else {
+						fullyQualifiedNames[value] = value;
+						fqname = value;
+					}
+				}
+			}
+		}
+
+		public virtual string Name {
+			get {
+				if (FullyQualifiedName != null) {
+					int lastIndex;
+					
+					if (CanBeSubclass) {
+						lastIndex = FullyQualifiedName.LastIndexOfAny
+							(new char[] { '.', '+' });
+					} else {
+						lastIndex = FullyQualifiedName.LastIndexOf('.');
+					}
+					
+					if (lastIndex &lt; 0) {
+						return FullyQualifiedName;
+					} else {
+						return FullyQualifiedName.Substring(lastIndex + 1);
+					}
+				}
+				return null;
+			}
+		}
+
+		public virtual string Namespace {
+			get {
+				if (FullyQualifiedName != null) {
+					int lastIndex = FullyQualifiedName.LastIndexOf('.');
+					
+					if (lastIndex &lt; 0) {
+						return String.Empty;
+					} else {
+						return FullyQualifiedName.Substring(0, lastIndex);
+					}
+				}
+				return null;
+			}
+		}
+		
+		protected virtual bool CanBeSubclass {
+			get {
+				return false;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractParameter.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractParameter.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractParameter.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,103 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+using System.Collections.Utility;
+
+namespace MonoDevelop.Internal.Parser
+{
+
+	[Serializable]
+	public abstract class AbstractParameter : System.MarshalByRefObject, IParameter
+	{
+		protected string              name;
+		protected string              documentation;
+
+		protected IReturnType         returnType;
+		protected ParameterModifier   modifier;
+		protected AttributeCollection attributeCollection = new AttributeCollection();
+
+		public bool IsOut {
+			get {
+				return (modifier &amp; ParameterModifier.Out) == ParameterModifier.Out;
+			}
+		}
+		public bool IsRef {
+			get {
+				return (modifier &amp; ParameterModifier.Ref) == ParameterModifier.Ref;
+			}
+		}
+		public bool IsParams {
+			get {
+				return (modifier &amp; ParameterModifier.Params) == ParameterModifier.Params;
+			}
+		}
+
+		public virtual string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+			}
+		}
+
+		public virtual IReturnType ReturnType {
+			get {
+				return returnType;
+			}
+			set {
+				returnType = value;
+			}
+		}
+
+		public virtual AttributeCollection AttributeCollection {
+			get {
+				return attributeCollection;
+			}
+		}
+
+		public virtual ParameterModifier Modifier {
+			get {
+				return modifier;
+			}
+			set {
+				modifier = value;
+			}
+		}
+
+		public string Documentation {
+			get {
+				return documentation == null ? &quot;&quot; : documentation;
+			}
+		}
+		
+		public virtual int CompareTo(IParameter value) {
+			int cmp;
+			
+			if (Name != null) {
+				cmp = Name.CompareTo(value.Name);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			if (ReturnType != null) {
+				if(0 != (cmp = ReturnType.CompareTo(value.ReturnType)))
+					return cmp;
+			}
+			
+			if(0 != (cmp = (int)(Modifier - value.Modifier)))
+				return cmp;
+			
+			return DiffUtility.Compare(AttributeCollection, value.AttributeCollection);
+		}
+		
+		int IComparable.CompareTo(object value) {
+			return CompareTo((IParameter)value);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractProperty.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractProperty.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractProperty.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,117 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+
+namespace MonoDevelop.Internal.Parser {
+
+	[Serializable]
+	public abstract class AbstractProperty : AbstractMember, IProperty
+	{
+		protected IRegion bodyRegion;
+		
+		protected IRegion     getterRegion;
+		protected IRegion     setterRegion;
+
+		protected IMethod     getterMethod;
+		protected IMethod     setterMethod;
+		protected ParameterCollection parameters = new ParameterCollection();
+		
+		public virtual IRegion BodyRegion {
+			get {
+				return bodyRegion;
+			}
+		}
+
+
+		public virtual ParameterCollection Parameters {
+			get {
+				return parameters;
+			}
+			set {
+				parameters = value;
+			}
+		}
+
+		public IRegion GetterRegion {
+			get {
+				return getterRegion;
+			}
+		}
+
+		public IRegion SetterRegion {
+			get {
+				return setterRegion;
+			}
+		}
+
+		public IMethod GetterMethod {
+			get {
+				return getterMethod;
+			}
+		}
+
+		public IMethod SetterMethod {
+			get {
+				return setterMethod;
+			}
+		}
+
+		public virtual bool CanGet {
+			get {
+				return GetterRegion != null;
+			}
+		}
+
+		public virtual bool CanSet {
+			get {
+				return SetterRegion != null;
+			}
+		}
+
+		public virtual int CompareTo(IProperty value)
+		{
+			int cmp;
+			
+			if(0 != (cmp = base.CompareTo((IDecoration)value)))
+				return cmp;
+			
+			if (FullyQualifiedName != null) {
+				cmp = FullyQualifiedName.CompareTo(value.FullyQualifiedName);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			if (ReturnType != null) {
+				if(0 != (cmp = ReturnType.CompareTo(value.ReturnType)))
+					return cmp;
+			}
+			
+			if(0 != (cmp = Region.CompareTo(value.Region)))
+				return cmp;
+			
+			if(SetterRegion != null &amp;&amp; value.SetterRegion == null)
+				return 1;
+			
+			if(SetterRegion == null &amp;&amp; value.SetterRegion != null)
+				return -1;
+			
+			if(GetterRegion != null &amp;&amp; value.GetterRegion == null)
+				return 1;
+			
+			if(GetterRegion == null &amp;&amp; value.GetterRegion != null)
+				return -1;
+			
+			return 0;
+		}
+		
+		int IComparable.CompareTo(object value) {
+			return CompareTo((IProperty)value);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractReturnType.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractReturnType.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractReturnType.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,108 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections.Utility;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public abstract class AbstractReturnType : System.MarshalByRefObject, IReturnType
+	{
+		protected int    pointerNestingLevel;
+		protected int[]  arrayDimensions;
+		protected object declaredin = null;
+		string fname;
+		
+		public virtual string FullyQualifiedName {
+			get {
+				return fname;
+			}
+			set {
+				if (value == null)
+					fname = value;
+				else {
+					string sharedName = (string) AbstractNamedEntity.fullyQualifiedNames [value];
+					if (sharedName == null) {
+						AbstractNamedEntity.fullyQualifiedNames [value] = value;
+						fname = value;
+					}
+					else
+						fname = sharedName;
+				}
+			}
+		}
+
+		public virtual string Name {
+			get {
+				if (FullyQualifiedName == null) {
+					return null;
+				}
+				string[] name = FullyQualifiedName.Split(new char[] {'.'});
+				return name[name.Length - 1];
+			}
+		}
+
+		public virtual string Namespace {
+			get {
+				if (FullyQualifiedName == null) {
+					return null;
+				}
+				int index = FullyQualifiedName.LastIndexOf('.');
+				return index &lt; 0 ? String.Empty : FullyQualifiedName.Substring(0, index);
+			}
+		}
+
+		public virtual int PointerNestingLevel {
+			get {
+				return pointerNestingLevel;
+			}
+		}
+
+		public int ArrayCount {
+			get {
+				return ArrayDimensions.Length;
+			}
+		}
+
+		public virtual int[] ArrayDimensions {
+			get {
+				if (arrayDimensions == null) return new int[0];
+				return arrayDimensions;
+			}
+		}
+
+		public virtual int CompareTo(IReturnType value) {
+			int cmp;
+			
+			if (FullyQualifiedName != null) {
+				cmp = FullyQualifiedName.CompareTo(value.FullyQualifiedName);
+				if (cmp != 0) {
+					return cmp;
+				}
+			}
+			
+			cmp = (PointerNestingLevel - value.PointerNestingLevel);
+			if (cmp != 0) {
+				return cmp;
+			}
+			
+			return DiffUtility.Compare(ArrayDimensions, value.ArrayDimensions);
+		}
+		
+		int IComparable.CompareTo(object value)
+		{
+			return CompareTo((IReturnType)value);
+		}
+		
+		public virtual object DeclaredIn {
+			get {
+				return declaredin;
+			}
+		}
+	}
+	
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractUsing.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractUsing.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/AbstractUsing.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,52 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Text;
+using System.Collections;
+using System.Collections.Specialized;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public abstract class AbstractUsing : MarshalByRefObject, IUsing
+	{
+		protected IRegion region;
+		
+		protected StringCollection usings  = new StringCollection();
+		protected SortedList       aliases = new SortedList();
+		
+		public IRegion Region {
+			get {
+				return region;
+			}
+		}
+		
+		public StringCollection Usings {
+			get {
+				return usings;
+			}
+		}
+		
+		public SortedList Aliases {
+			get {
+				return aliases;
+			}
+		}
+		
+		public override string ToString()
+		{
+			StringBuilder builder = new StringBuilder(&quot;[AbstractUsing: using list=&quot;);
+			foreach (string str in usings) {
+				builder.Append(str);
+				builder.Append(&quot;, &quot;);
+			}
+			builder.Append(&quot;]&quot;);
+			return builder.ToString();
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/DefaultRegion.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/DefaultRegion.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Implementations/DefaultRegion.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,131 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Diagnostics;
+
+namespace MonoDevelop.Internal.Parser {
+	
+	[Serializable]
+	public class DefaultRegion : System.MarshalByRefObject, IRegion
+	{
+		protected int beginLine = -1;
+		protected int endLine = -1;
+		protected int beginColumn = -1;
+		protected int endColumn = -1;
+		protected string fileName;
+
+		public virtual int BeginLine {
+			get {
+				return beginLine;
+			}
+		}
+
+		public virtual int BeginColumn {
+			get {
+				return beginColumn;
+			}
+		}
+
+		/// &lt;value&gt;
+		/// if the end column is == -1 the end line is -1 too
+		/// this stands for an unknwon end
+		/// &lt;/value&gt;
+		public virtual int EndColumn {
+			get {
+				return endColumn;
+			}
+			set {
+				endColumn = value;
+			}
+		}
+
+		/// &lt;value&gt;
+		/// if the end line is == -1 the end column is -1 too
+		/// this stands for an unknwon end
+		/// &lt;/value&gt;
+		public virtual int EndLine {
+			get {
+				return endLine;
+			}
+			set {
+				endLine = value;
+			}
+		}
+
+		public string FileName {
+			get { 
+				return fileName; 
+			}
+			set {
+				fileName = value;
+			}
+		}
+		
+		public DefaultRegion(Point start, Point end) : this(start.Y, start.X, end.Y, end.X)
+		{
+		}
+		
+		public DefaultRegion(int beginLine, int beginColumn)
+		{
+			this.beginLine   = beginLine;
+			this.beginColumn = beginColumn;
+		}
+
+		public DefaultRegion(int beginLine, int beginColumn, int endLine, int endColumn)
+		{
+			this.beginLine   = beginLine;
+			this.beginColumn = beginColumn;
+			this.endLine     = endLine;
+			this.endColumn   = endColumn;
+		}
+
+		/// &lt;remarks&gt;
+		/// Returns true, if the given coordinates (row, column) are in the region.
+		/// This method assumes that for an unknown end the end line is == -1
+		/// &lt;/remarks&gt;
+		public bool IsInside(int row, int column)
+		{
+			return row &gt;= BeginLine &amp;&amp;
+			      (row &lt;= EndLine   || EndLine == -1) &amp;&amp;
+			      (row != BeginLine || column &gt;= BeginColumn) &amp;&amp;
+			      (row != EndLine   || column &lt;= EndColumn);
+		}
+
+		public override string ToString()
+		{
+			return String.Format(&quot;[Region: BeginLine = {0}, EndLine = {1}, BeginColumn = {2}, EndColumn = {3}]&quot;,
+			                     beginLine,
+			                     endLine,
+			                     beginColumn,
+			                     endColumn);
+		}
+		
+		public virtual int CompareTo(IRegion value)
+		{
+			int cmp;
+			if (0 != (cmp = (BeginLine - value.BeginLine))) {
+				return cmp;
+			}
+			
+			if (0 != (cmp = (BeginColumn - value.BeginColumn))) {
+				return cmp;
+			}
+			
+			if (0 != (cmp = (EndLine - value.EndLine))) {
+				return cmp;
+			}
+			
+			return EndColumn - value.EndColumn;
+		}
+		
+		int IComparable.CompareTo(object value) {
+			return CompareTo((IRegion)value);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ModifierEnum.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ModifierEnum.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ModifierEnum.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,44 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Flags]
+	public enum ModifierEnum : uint {
+		None       = 0,
+		
+		// Access 
+		Private   = 0x0001,
+		Internal  = 0x0002,
+		Protected = 0x0004,
+		Public    = 0x0008,
+		
+		// Scope
+		Abstract  = 0x0010, 
+		Virtual   = 0x0020,
+		Sealed    = 0x0040,
+		Static    = 0x0080,
+		Override  = 0x0100,
+		Readonly  = 0x0200,
+		Const	  = 0X0400,
+		New       = 0x0800,
+		
+		// Special 
+		Extern    = 0x1000,
+		Volatile  = 0x2000,
+		Unsafe    = 0x4000,
+		
+		ProtectedAndInternal = Internal | Protected,
+		ProtectedOrInternal = 0x8000,
+//		Literal             = 0x10000, &lt;-- == Const now!!!
+		SpecialName         = 0x20000,
+		
+		Final               = 0x40000,
+	}
+}
+

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParameterModifier.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParameterModifier.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParameterModifier.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,20 @@
+&#239;&#187;&#191;// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	[Flags]
+	public enum ParameterModifier : byte {
+		None   = 0,
+		Out    = (1 &lt;&lt; 0),
+		Ref    = (1 &lt;&lt; 1),
+		Params = (1 &lt;&lt; 2)
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/AssemblyInformation.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/AssemblyInformation.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/AssemblyInformation.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,127 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Collections;
+using System.Threading;
+using System.Xml;
+using MonoDevelop.Internal.Parser;
+
+//using ICSharpCode.SharpAssembly.Metadata.Rows;
+//using ICSharpCode.SharpAssembly.Metadata;
+//using ICSharpCode.SharpAssembly.PE;
+//using ICSharpCode.SharpAssembly;
+using System.Reflection;
+using MonoDevelop.Services;
+using MonoDevelop.Core.Services;
+
+
+namespace MonoDevelop.Services {
+	
+	/// &lt;summary&gt;
+	/// This class loads an assembly and converts all types from this assembly
+	/// to a parser layer Class Collection.
+	/// &lt;/summary&gt;
+	[Serializable]
+	public class AssemblyInformation : MarshalByRefObject
+	{
+		ClassCollection classes = new ClassCollection();
+		string fileName;
+		
+		/// &lt;value&gt;
+		/// A &lt;code&gt;ClassColection&lt;/code&gt; that contains all loaded classes.
+		/// &lt;/value&gt;
+		public ClassCollection Classes {
+			get {
+				return classes;
+			}
+		}
+		
+		public string FileName
+		{
+			get { return fileName; }
+		}
+		
+		public AssemblyInformation()
+		{
+		}
+		
+		byte[] GetBytes(string fileName)
+		{
+			Console.WriteLine (fileName);
+			FileStream fs = System.IO.File.OpenRead(fileName);
+			long size = fs.Length;
+			byte[] outArray = new byte[size];
+			fs.Read(outArray, 0, (int)size);
+			fs.Close();
+			return outArray;
+		}
+		
+		public void Load(string fileName, bool nonLocking)
+		{
+//			AssemblyReader assembly = new AssemblyReader();
+//			assembly.Load(fileName);
+//			
+//			TypeDef[] typeDefTable = (TypeDef[])assembly.MetadataTable.Tables[TypeDef.TABLE_ID];
+//			
+//			for (int i = 0; i &lt; typeDefTable.Length; ++i) {
+//				Console.WriteLine(&quot;ADD &quot; + i);
+//				classes.Add(new SharpAssemblyClass(assembly, typeDefTable, i));
+//			}
+			
+			// read xml documentation for the assembly
+			/*XmlDocument doc        = null;
+			Hashtable   docuNodes  = new Hashtable();
+			string      xmlDocFile = System.IO.Path.ChangeExtension(fileName, &quot;.xml&quot;);
+			
+			string   localizedXmlDocFile = System.IO.Path.GetDirectoryName(fileName) + System.IO.Path.DirectorySeparatorChar +
+			                               Thread.CurrentThread.CurrentUICulture.TwoLetterISOLanguageName + System.IO.Path.DirectorySeparatorChar +
+								           System.IO.Path.ChangeExtension(System.IO.Path.GetFileName(fileName), &quot;.xml&quot;);
+			if (System.IO.File.Exists(localizedXmlDocFile)) {
+				xmlDocFile = localizedXmlDocFile;
+			}
+			
+			if (System.IO.File.Exists(xmlDocFile)) {
+				doc = new XmlDocument();
+				doc.Load(xmlDocFile);
+				
+				// convert the XmlDocument into a hash table
+				if (doc.DocumentElement != null &amp;&amp; doc.DocumentElement[&quot;members&quot;] != null) {
+					foreach (XmlNode node in doc.DocumentElement[&quot;members&quot;].ChildNodes) {
+						if (node != null &amp;&amp; node.Attributes != null &amp;&amp; node.Attributes[&quot;name&quot;] != null) {
+							docuNodes[node.Attributes[&quot;name&quot;].InnerText] = node;
+						}
+					}
+				}
+				}*/
+
+			//FIXME: Re-enable this code when the mono bug goes away, 0.32
+			//hopefully
+			//System.Reflection.Assembly asm = nonLocking ? Assembly.Load(GetBytes(fileName)) : Assembly.LoadFrom(fileName);
+			
+			this.fileName = fileName;
+			
+			Assembly asm = null;		
+			try {
+				asm = Assembly.LoadFrom (fileName);
+				if (asm == null)
+					Assembly.LoadWithPartialName (Path.GetFileNameWithoutExtension (fileName));
+			} catch {
+			}
+			if(asm == null) {
+				Console.WriteLine (&quot;Unable to load {0}&quot;, fileName);
+				return;
+			}
+			foreach (Type type in asm.GetTypes()) {
+				if (!type.FullName.StartsWith(&quot;&lt;&quot;) &amp;&amp; !type.IsSpecialName &amp;&amp; type.IsPublic) {
+					classes.Add(new ReflectionClass(type));
+				}
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassInformationEventHandler.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassInformationEventHandler.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassInformationEventHandler.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,47 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+using System.IO;
+
+using MonoDevelop.Core.AddIns;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Services
+{
+	public delegate void ClassInformationEventHandler(object sender, ClassInformationEventArgs e);
+	
+	public class ClassInformationEventArgs : EventArgs
+	{
+		string fileName;
+		ClassUpdateInformation classInformation;
+				
+		public string FileName {
+			get {
+				return fileName;
+			}
+		}
+		
+		public ClassUpdateInformation ClassInformation {
+			get {
+				return classInformation;
+			}
+		}
+		
+		public ClassInformationEventArgs(string fileName, ClassUpdateInformation classInformation)
+		{
+			this.fileName         = fileName;
+			this.classInformation = classInformation;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassProxy.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassProxy.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassProxy.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,156 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#131;&#194;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Drawing;
+using System.Collections;
+using System.Collections.Specialized;
+using System.Diagnostics;
+using System.IO;
+
+using MonoDevelop.Core.AddIns;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Services
+{
+	public class ClassProxy : AbstractNamedEntity, IComparable, IClass
+	{
+		uint offset = 0;
+		ClassType classType;
+		
+		public uint Offset {
+			get {
+				return offset;
+			}
+			set {
+				offset = value;
+			}
+		}
+		
+		public ClassType ClassType {
+			get {
+				return classType;
+			}
+			set {
+				classType = value;
+			}
+		}
+		
+		/// &lt;value&gt;
+		/// Class Proxies clases don't have a compilation unit.
+		/// &lt;/value&gt;
+		public ICompilationUnit CompilationUnit {
+			get {
+				return null;
+			}
+		}
+		
+		public int CompareTo(object obj)
+		{
+			return FullyQualifiedName.CompareTo(((ClassProxy)obj).FullyQualifiedName);
+		}
+		
+		public ClassProxy(BinaryReader reader)
+		{
+			FullyQualifiedName = reader.ReadString();
+			Documentation      = reader.ReadString();
+			offset             = reader.ReadUInt32();
+			modifiers          = (ModifierEnum)reader.ReadUInt32();
+			classType          = (ClassType)reader.ReadInt16();
+		}
+		
+		public void WriteTo(BinaryWriter writer)
+		{
+			writer.Write(FullyQualifiedName);
+			writer.Write(Documentation);
+			writer.Write(offset);
+			writer.Write((uint)modifiers);
+			writer.Write((short)classType);
+		}
+		
+		public ClassProxy(IClass c)
+		{
+			this.FullyQualifiedName  = c.FullyQualifiedName;
+			this.Documentation       = c.Documentation;
+			this.modifiers           = c.Modifiers;
+			this.classType           = c.ClassType;
+		}
+		
+		/// unnecessary stuff
+		public IRegion Region {
+			get {
+				return new DefaultRegion(Point.Empty, Point.Empty);
+			}
+		}
+		
+		public IRegion BodyRegion {
+			get {
+				return new DefaultRegion(Point.Empty, Point.Empty);
+			}
+		}
+		
+		public StringCollection BaseTypes {
+			get {
+				return new StringCollection();
+			}
+		}
+		
+		public ClassCollection InnerClasses {
+			get {
+				return new ClassCollection();
+			}
+		}
+
+		public FieldCollection Fields {
+			get {
+				return new FieldCollection();
+			}
+		}
+
+		public PropertyCollection Properties {
+			get {
+				return new PropertyCollection();
+			}
+		}
+
+		public IndexerCollection Indexer {
+			get {
+				return new IndexerCollection();
+			}
+		}
+
+		public MethodCollection Methods {
+			get {
+				return new MethodCollection();
+			}
+		}
+
+		public EventCollection Events {
+			get {
+				return new EventCollection();
+			}
+		}
+
+		public IEnumerable ClassInheritanceTree {
+			get {
+				return null;
+			}
+		}
+		
+		public object DeclaredIn {
+			get {
+				return null;
+			}
+		}
+		///
+		
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassProxyCollection.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassProxyCollection.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ClassProxyCollection.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,244 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.ClassProxy'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.ClassProxyCollection'/&gt;
+	[Serializable()]
+	public class ClassProxyCollection : CollectionBase 
+	{
+		Hashtable nameHashtable                = new Hashtable();
+		Hashtable caseInsensitiveNameHashtable = new Hashtable();
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.ClassProxyCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public ClassProxyCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.ClassProxyCollection'/&gt; based on another &lt;see cref='.ClassProxyCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.ClassProxyCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public ClassProxyCollection(ClassProxyCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.ClassProxyCollection'/&gt; containing any array of &lt;see cref='.ClassProxy'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.ClassProxy'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public ClassProxyCollection(ClassProxy[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.ClassProxy'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public ClassProxy this[int index] {
+			get {
+				return (ClassProxy)List[index];
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.ClassProxy'/&gt; with the specified value to the
+		///    &lt;see cref='.ClassProxyCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.ClassProxy'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.ClassProxyCollection.AddRange'/&gt;
+		public int Add(ClassProxy value) 
+		{
+			nameHashtable[value.FullyQualifiedName.GetHashCode()]                          = Count;
+			caseInsensitiveNameHashtable[value.FullyQualifiedName.ToLower().GetHashCode()] = Count;
+			
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.ClassProxyCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.ClassProxy'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.ClassProxyCollection.Add'/&gt;
+		public void AddRange(ClassProxy[] value) 
+		{
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.ClassProxyCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.ClassProxyCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.ClassProxyCollection.Add'/&gt;
+		public void AddRange(ClassProxyCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the
+		///    &lt;see cref='.ClassProxyCollection'/&gt; contains the specified &lt;see cref='.ClassProxy'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.ClassProxy'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.ClassProxy'/&gt; is contained in the collection;
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.ClassProxyCollection.IndexOf'/&gt;
+		public bool Contains(ClassProxy value) 
+		{
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.ClassProxyCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.ClassProxyCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.ClassProxyCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(ClassProxy[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.ClassProxy'/&gt; in
+		///       the &lt;see cref='.ClassProxyCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.ClassProxy'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.ClassProxy'/&gt; of &lt;paramref name='value'/&gt; in the
+		/// &lt;see cref='.ClassProxyCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.ClassProxyCollection.Contains'/&gt;
+		public int IndexOf(ClassProxy value) 
+		{
+			return List.IndexOf(value);
+		}
+		
+		public int IndexOf(string fullyQualifiedName, bool caseSensitive)
+		{
+			object o = caseSensitive ? nameHashtable[fullyQualifiedName.GetHashCode()] : caseInsensitiveNameHashtable[fullyQualifiedName.ToLower().GetHashCode()];
+			if (o != null) {
+				return (int)o;
+			}
+			return -1;
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through
+		///       the &lt;see cref='.ClassProxyCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new ClassProxyEnumerator GetEnumerator() 
+		{
+			return new ClassProxyEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.ClassProxy'/&gt; from the
+		///    &lt;see cref='.ClassProxyCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.ClassProxy'/&gt; to remove from the &lt;see cref='.ClassProxyCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(ClassProxy value) 
+		{
+			List.Remove(value);
+		}
+		
+		public class ClassProxyEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public ClassProxyEnumerator(ClassProxyCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public ClassProxy Current {
+				get {
+					return ((ClassProxy)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/CodeCompletionDatabase.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/CodeCompletionDatabase.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/CodeCompletionDatabase.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,1187 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Lluis Sanchez Gual&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">lluis at ximian.com</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Diagnostics;
+using System.Threading;
+using System.IO;
+using System.Collections;
+using System.Runtime.Serialization;
+using System.Runtime.Serialization.Formatters.Binary;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Parser;
+using System.Reflection;
+
+namespace MonoDevelop.Services
+{
+	internal class CodeCompletionDatabase
+	{
+		static readonly int MAX_ACTIVE_COUNT = 100;
+		static readonly int MIN_ACTIVE_COUNT = 50;
+		static protected readonly int FORMAT_VERSION = 3;
+		
+		NamespaceEntry rootNamespace;
+		protected ArrayList references;
+		protected Hashtable files;
+		protected DefaultParserService parserService;
+		protected Hashtable headers;
+		
+		BinaryReader datareader;
+		FileStream datafile;
+		int currentGetTime = 0;
+		bool modified;
+		
+		string basePath;
+		string dataFile;
+		
+		protected Object rwlock = new Object ();
+		
+		public CodeCompletionDatabase (DefaultParserService parserService)
+		{
+			this.parserService = parserService;
+			rootNamespace = new NamespaceEntry ();
+			files = new Hashtable ();
+			references = new ArrayList ();
+			headers = new Hashtable ();
+		}
+		
+		public string DataFile
+		{
+			get { return dataFile; }
+		}
+		
+		protected void SetLocation (string basePath, string name)
+		{
+			dataFile = Path.Combine (basePath, name + &quot;.pidb&quot;);
+			this.basePath = basePath;
+		}
+		
+		public void Rename (string name)
+		{
+			lock (rwlock)
+			{
+				Flush ();
+				string oldDataFile = dataFile;
+				dataFile = Path.Combine (basePath, name + &quot;.pidb&quot;);
+
+				CloseReader ();
+				
+				if (File.Exists (oldDataFile))
+					File.Move (oldDataFile, dataFile);
+			}
+		}
+		
+		public virtual void Read ()
+		{
+			if (basePath == null)
+				throw new InvalidOperationException (&quot;Location not set&quot;);
+				
+			if (!File.Exists (dataFile)) return;
+			
+			lock (rwlock)
+			{
+				FileStream ifile = null;
+				try 
+				{
+					modified = false;
+					currentGetTime = 0;
+					CloseReader ();
+					
+					Console.WriteLine (&quot;Reading &quot; + dataFile);
+					ifile = new FileStream (dataFile, FileMode.Open, FileAccess.Read, FileShare.Read);
+					BinaryFormatter bf = new BinaryFormatter ();
+					
+					// Read the headers
+					headers = (Hashtable) bf.Deserialize (ifile);
+					int ver = (int) headers[&quot;Version&quot;];
+					if (ver != FORMAT_VERSION)
+						throw new Exception (&quot;Expected version &quot; + FORMAT_VERSION + &quot;, found version &quot; + ver);
+					
+					// Move to the index offset and read the index
+					BinaryReader br = new BinaryReader (ifile);
+					long indexOffset = br.ReadInt64 ();
+					ifile.Position = indexOffset;
+					
+					object[] data = (object[]) bf.Deserialize (ifile);
+					Queue dataQueue = new Queue (data);
+					references = (ArrayList) dataQueue.Dequeue ();
+					rootNamespace = (NamespaceEntry)  dataQueue.Dequeue ();
+					files = (Hashtable)  dataQueue.Dequeue ();
+					DeserializeData (dataQueue);
+
+					ifile.Close ();
+					
+				}
+				catch (Exception ex)
+				{
+					if (ifile != null) ifile.Close ();
+					Console.WriteLine (&quot;PIDB file '&quot; + dataFile + &quot;' couldn not be loaded: '&quot; + ex.Message + &quot;'. The file will be recreated&quot;);
+					rootNamespace = new NamespaceEntry ();
+					files = new Hashtable ();
+					references = new ArrayList ();
+					headers = new Hashtable ();
+				}
+			}
+		}
+		
+		public static Hashtable ReadHeaders (string baseDir, string name)
+		{
+			string file = Path.Combine (baseDir, name + &quot;.pidb&quot;);
+			FileStream ifile = new FileStream (file, FileMode.Open, FileAccess.Read, FileShare.Read);
+			BinaryFormatter bf = new BinaryFormatter ();
+			Hashtable headers = (Hashtable) bf.Deserialize (ifile);
+			ifile.Close ();
+			return headers;
+		}
+		
+		public virtual void Write ()
+		{
+			lock (rwlock)
+			{
+				if (!modified) return;
+				modified = false;
+				headers[&quot;Version&quot;] = FORMAT_VERSION;
+							
+				Console.WriteLine (&quot;Writing &quot; + dataFile);
+				
+				string tmpDataFile = dataFile + &quot;.tmp&quot;;
+				FileStream dfile = new FileStream (tmpDataFile, FileMode.Create, FileAccess.Write, FileShare.Write);
+				
+				BinaryFormatter bf = new BinaryFormatter ();
+				BinaryWriter bw = new BinaryWriter (dfile);
+				
+				// The headers are the first thing to write, so they can be read
+				// without deserializing the whole file.
+				bf.Serialize (dfile, headers);
+				
+				// The position of the index will be written here
+				long indexOffsetPos = dfile.Position;
+				bw.Write ((long)0);
+				
+				MemoryStream buffer = new MemoryStream ();
+				BinaryWriter bufWriter = new BinaryWriter (buffer);
+				
+				// Write all class data
+				foreach (FileEntry fe in files.Values) 
+				{
+					ClassEntry ce = fe.FirstClass;
+					while (ce != null)
+					{
+						IClass c = ce.Class;
+						byte[] data;
+						int len;
+						
+						if (c == null) {
+							// Copy the data from the source file
+							if (datareader == null) {
+								datafile = new FileStream (dataFile, FileMode.Open, FileAccess.Read, FileShare.Read);
+								datareader = new BinaryReader (datafile);
+							}
+							datafile.Position = ce.Position;
+							len = datareader.ReadInt32 ();
+							data = new byte[len];
+							datafile.Read (data, 0, len);
+						}
+						else {
+							buffer.Position = 0;
+							PersistentClass.WriteTo (c, bufWriter, parserService.DefaultNameEncoder);
+							data = buffer.GetBuffer ();
+							len = (int)buffer.Position;
+						}
+						
+						ce.Position = dfile.Position;
+						bw.Write (len);
+						bw.Write (data, 0, len);
+						ce = ce.NextInFile;
+					}
+				}
+				
+				// Write the index
+				long indexOffset = dfile.Position;
+				
+				Queue dataQueue = new Queue ();
+				dataQueue.Enqueue (references);
+				dataQueue.Enqueue (rootNamespace);
+				dataQueue.Enqueue (files);
+				SerializeData (dataQueue);
+				bf.Serialize (dfile, dataQueue.ToArray ());
+				
+				dfile.Position = indexOffsetPos;
+				bw.Write (indexOffset);
+				
+				bw.Close ();
+				dfile.Close ();
+				
+				CloseReader ();
+				
+				if (File.Exists (dataFile))
+					File.Delete (dataFile);
+					
+				File.Move (tmpDataFile, dataFile);
+			}
+		}
+		
+		protected virtual void SerializeData (Queue dataQueue)
+		{
+		}
+		
+		protected virtual void DeserializeData (Queue dataQueue)
+		{
+		}
+				
+		void Flush ()
+		{
+			int activeCount = 0;
+			
+			foreach (FileEntry fe in files.Values) {
+				ClassEntry ce = fe.FirstClass;
+				while (ce != null) { 
+					if (ce.Class != null) activeCount++;
+					ce = ce.NextInFile;
+				}
+			}
+			
+			if (activeCount &lt;= MAX_ACTIVE_COUNT) return;
+			
+			Write ();
+			
+			foreach (FileEntry fe in files.Values) {
+				ClassEntry ce = fe.FirstClass;
+				while (ce != null) { 
+					if (ce.LastGetTime &lt; currentGetTime - MIN_ACTIVE_COUNT)
+						ce.Class = null;
+					ce = ce.NextInFile;
+				}
+			}
+		}
+		
+		IClass ReadClass (ClassEntry ce)
+		{
+			if (datareader == null) {
+				datafile = new FileStream (dataFile, FileMode.Open, FileAccess.Read, FileShare.Read);
+				datareader = new BinaryReader (datafile);
+			}
+			datafile.Position = ce.Position;
+			datareader.ReadInt32 ();	// Length of data
+			return PersistentClass.Read (datareader, parserService.DefaultNameDecoder);
+		}
+		
+		void CloseReader ()
+		{
+			if (datareader != null) {
+				datareader.Close ();
+				datareader = null;
+			}
+		}
+		
+		public void Clear ()
+		{
+			rootNamespace = new NamespaceEntry ();
+			files = new Hashtable ();
+			references = new ArrayList ();
+			headers = new Hashtable ();
+		}
+		
+		public IClass GetClass (string typeName, bool caseSensitive)
+		{
+			lock (rwlock)
+			{
+//				Console.WriteLine (&quot;GET CLASS &quot; + typeName + &quot; in &quot; + dataFile);
+				string[] path = typeName.Split ('.');
+				int len = path.Length - 1;
+				
+				NamespaceEntry nst;
+				int nextPos;
+				
+				if (GetBestNamespaceEntry (path, len, false, caseSensitive, out nst, out nextPos)) 
+				{
+					ClassEntry ce = nst.GetClass (path[len], caseSensitive);
+					if (ce == null) return null;
+					return GetClass (ce);
+				}
+				else
+				{
+					// It may be an inner class
+					ClassEntry ce = nst.GetClass (path[nextPos++], caseSensitive);
+					if (ce == null) return null;
+					
+					len++;	// Now include class name
+					IClass c = GetClass (ce);
+					
+					while (nextPos &lt; len) {
+						IClass nextc = null;
+						for (int n=0; n&lt;c.InnerClasses.Count &amp;&amp; nextc == null; n++) {
+							IClass innerc = c.InnerClasses[n];
+							if (string.Compare (innerc.Name, path[nextPos], !caseSensitive) == 0)
+								nextc = innerc;
+						}
+						if (nextc == null) return null;
+						c = nextc;
+						nextPos++;
+					}
+					return c;
+				}
+			}
+		}
+		
+		IClass GetClass (ClassEntry ce)
+		{
+			ce.LastGetTime = currentGetTime++;
+			if (ce.Class != null) return ce.Class;
+			
+			// Read the class from the file
+			
+			ce.Class = ReadClass (ce);
+			return ce.Class;
+		}		
+		
+		public void CheckModifiedFiles ()
+		{
+			lock (rwlock)
+			{
+				foreach (FileEntry file in files.Values)
+				{
+					if (!File.Exists (file.FileName)) continue;
+					FileInfo fi = new FileInfo (file.FileName);
+					if (fi.LastWriteTime &gt; file.LastParseTime || file.ParseErrorRetries &gt; 0) 
+					{
+						// Change date now, to avoid reparsing if CheckModifiedFiles is called again
+						// before the parse job is executed
+						
+						file.LastParseTime = fi.LastWriteTime;
+						parserService.QueueParseJob (new WaitCallback (ParseCallback), file.FileName);
+					}
+				}
+			}
+		}
+		
+		void ParseCallback (object ob)
+		{
+			lock (rwlock)
+			{
+				ParseFile ((string)ob);
+			}
+		}
+		
+		protected virtual void ParseFile (string fileName)
+		{
+		}
+		
+		public void ParseAll ()
+		{
+			lock (rwlock)
+			{
+				foreach (FileEntry fe in files.Values) 
+					ParseFile (fe.FileName);
+			}
+		}
+		
+		protected void AddReference (string uri)
+		{
+			lock (rwlock)
+			{
+				ReferenceEntry re = new ReferenceEntry (uri);
+				references.Add (re);
+				modified = true;
+			}
+		}
+		
+		protected void RemoveReference (string uri)
+		{
+			lock (rwlock)
+			{
+				for (int n=0; n&lt;references.Count; n++)
+				{
+					if (((ReferenceEntry)references[n]).Uri == uri) {
+						references.RemoveAt (n);
+						modified = true;
+						return;
+					}
+				}
+			}
+		}
+		
+		protected bool HasReference (string uri)
+		{
+			for (int n=0; n&lt;references.Count; n++) {
+				ReferenceEntry re = (ReferenceEntry) references[n];
+				if (((ReferenceEntry) references[n]).Uri == uri)
+					return true;
+			}
+			return false;
+		}
+		
+		public void AddFile (string fileName)
+		{
+			lock (rwlock)
+			{
+				FileEntry fe = new FileEntry (fileName);
+				files [fileName] = fe;
+				modified = true;
+			}
+		}
+		
+		public void RemoveFile (string fileName)
+		{
+			lock (rwlock)
+			{
+				FileEntry fe = files [fileName] as FileEntry;
+				if (fe == null) return;
+				
+				ClassEntry ce = fe.FirstClass;
+				while (ce != null) {
+					ce.NamespaceRef.Remove (ce.Name);
+					ce = ce.NextInFile;
+				}
+				
+				files.Remove (fileName);
+				modified = true;
+			}
+		}
+		
+		public ClassUpdateInformation UpdateClassInformation (ClassCollection newClasses, string fileName)
+		{
+			lock (rwlock)
+			{
+				ClassUpdateInformation res = new ClassUpdateInformation ();
+				
+				FileEntry fe = files [fileName] as FileEntry;
+				if (fe == null) return null;
+				
+				bool[] added = new bool [newClasses.Count];
+				NamespaceEntry[] newNss = new NamespaceEntry [newClasses.Count];
+				for (int n=0; n&lt;newClasses.Count; n++) {
+					string[] path = newClasses[n].Namespace.Split ('.');
+					newNss[n] = GetNamespaceEntry (path, path.Length, true, true);
+				}
+				
+				ArrayList newFileClasses = new ArrayList ();
+				
+				if (fe != null)
+				{
+					ClassEntry ce = fe.FirstClass;
+					while (ce != null)
+					{
+						IClass newClass = null;
+						for (int n=0; n&lt;newClasses.Count &amp;&amp; newClass == null; n++) {
+							IClass uc = newClasses [n];
+							if (uc.Name == ce.Name &amp;&amp; newNss[n] == ce.NamespaceRef) {
+								newClass = uc;
+								added[n] = true;
+							}
+						}
+						
+						if (newClass != null) {
+							// Class found, replace it
+							ce.Class = CopyClass (newClass);
+							ce.LastGetTime = currentGetTime++;
+							newFileClasses.Add (ce);
+							res.Modified.Add (ce.Class);
+						}
+						else {
+							// Class not found, it has to be deleted, unless it has
+							// been added in another file
+							if (ce.FileEntry == fe) {
+								IClass c = ce.Class;
+								if (c == null) c = ReadClass (ce);
+								res.Removed.Add (c);
+								ce.NamespaceRef.Remove (ce.Name);
+							}
+						}
+						ce = ce.NextInFile;
+					}
+				}
+				
+				if (fe == null) {
+					fe = new FileEntry (fileName);
+					files [fileName] = fe;
+				}
+				
+				for (int n=0; n&lt;newClasses.Count; n++) {
+					if (!added[n]) {
+						IClass c = CopyClass (newClasses[n]);
+						ClassEntry ce = new ClassEntry (c, fe, newNss[n]);
+						ce.LastGetTime = currentGetTime++;
+						newNss[n].Add (c.Name, ce);
+						newFileClasses.Add (ce);
+						res.Added.Add (c);
+					}
+				}
+				
+				fe.SetClasses (newFileClasses);
+				rootNamespace.Clean ();
+				fe.LastParseTime = DateTime.Now;
+				modified = true;
+				Flush ();
+				
+				return res;
+			}
+		}
+		
+		public void GetNamespaceContents (ArrayList list, string subNameSpace, bool caseSensitive)
+		{
+			lock (rwlock)
+			{
+				string[] path = subNameSpace.Split ('.');
+				NamespaceEntry tns = GetNamespaceEntry (path, path.Length, false, caseSensitive);
+				if (tns == null) return;
+				
+				foreach (DictionaryEntry en in tns.Contents) {
+					if (en.Value is NamespaceEntry)
+						list.Add (en.Key);
+					else
+						list.Add (GetClass ((ClassEntry)en.Value));
+				}
+			}
+		}
+		
+		public void GetNamespaceList (ArrayList list, string subNameSpace, bool caseSensitive)
+		{
+			lock (rwlock)
+			{
+				string[] path = subNameSpace.Split ('.');
+				NamespaceEntry tns = GetNamespaceEntry (path, path.Length, false, caseSensitive);
+				if (tns == null) return;
+				
+				foreach (DictionaryEntry en in tns.Contents) {
+					if (en.Value is NamespaceEntry)
+						list.Add (en.Key);
+				}
+			}
+		}
+		
+		public bool NamespaceExists (string name, bool caseSensitive)
+		{
+			lock (rwlock)
+			{
+				string[] path = name.Split ('.');
+				NamespaceEntry tns = GetNamespaceEntry (path, path.Length, false, caseSensitive);
+				return tns != null;
+			}
+		}
+		
+		public ICollection References
+		{
+			get { return references; }
+		}
+		
+		IClass CopyClass (IClass cls)
+		{
+			MemoryStream ms = new MemoryStream ();
+			BinaryWriter bw = new BinaryWriter (ms);
+			PersistentClass.WriteTo (cls, bw, parserService.DefaultNameEncoder);
+			bw.Flush ();
+			ms.Position = 0;
+			BinaryReader br = new BinaryReader (ms);
+			return PersistentClass.Read (br, parserService.DefaultNameDecoder);
+		}
+		
+		bool GetBestNamespaceEntry (string[] path, int length, bool createPath, bool caseSensitive, out NamespaceEntry lastEntry, out int numMatched)
+		{
+			lastEntry = rootNamespace;
+
+			if (length == 0 || (length == 1 &amp;&amp; path[0] == &quot;&quot;)) {
+				numMatched = length;
+				return true;
+			}
+			else
+			{
+				for (int n=0; n&lt;length; n++) {
+					NamespaceEntry nh = lastEntry.GetNamespace (path[n], caseSensitive);
+					if (nh == null) {
+						if (!createPath) {
+							numMatched = n;
+							return false;
+						}
+						
+						nh = new NamespaceEntry ();
+						lastEntry.Add (path[n], nh);
+					}
+					lastEntry = nh;
+				}
+				numMatched = length;
+				return true;
+			}
+		}
+		
+		NamespaceEntry GetNamespaceEntry (string[] path, int length, bool createPath, bool caseSensitive)
+		{
+			NamespaceEntry nst;
+			int matched;
+			
+			if (GetBestNamespaceEntry (path, length, createPath, caseSensitive, out nst, out matched))
+				return nst;
+			else
+				return null;
+		}
+	}
+	
+	internal class ProjectCodeCompletionDatabase: CodeCompletionDatabase
+	{
+		IProject project;
+		
+		public ProjectCodeCompletionDatabase (IProject project, DefaultParserService parserService)
+		: base (parserService)
+		{
+			SetLocation (project.BaseDirectory, project.Name);
+			
+			this.project = project;
+			Read ();
+			
+			UpdateFromProject ();
+		}
+		
+		public void UpdateFromProject ()
+		{
+			Hashtable fs = new Hashtable ();
+			foreach (ProjectFile file in project.ProjectFiles)
+			{
+				if (file.BuildAction != BuildAction.Compile) continue;
+				FileEntry fe = files[file.Name] as FileEntry;
+				if (fe == null) AddFile (file.Name);
+				fs [file.Name] = null;
+			}
+			
+			ArrayList keys = new ArrayList ();
+			keys.AddRange (files.Keys);
+			foreach (string file in keys)
+			{
+				if (!fs.Contains (file))
+					RemoveFile (file);
+			}
+			
+			fs.Clear ();
+			foreach (ProjectReference pr in project.ProjectReferences)
+			{
+				string refId = pr.ReferenceType == ReferenceType.Project ? &quot;Project&quot; : &quot;Assembly&quot;;
+				refId += &quot;:&quot; + pr.Reference;
+
+				if (pr.ReferenceType == ReferenceType.Gac &amp;&amp; refId.ToLower().EndsWith (&quot;.dll&quot;))
+					refId = refId.Substring (0, refId.Length - 4);
+
+				fs[refId] = null;
+				if (!HasReference (refId))
+					AddReference (refId);
+			}
+			
+			keys.Clear();
+			keys.AddRange (references);
+			foreach (ReferenceEntry re in keys)
+			{
+				if (!fs.Contains (re.Uri))
+					RemoveReference (re.Uri);
+			}
+		}
+		
+		protected override void ParseFile (string fileName)
+		{
+			IParseInformation parserInfo = parserService.DoParseFile ((string)fileName, null);
+			if (parserInfo != null) {
+				ICompilationUnit cu = (ICompilationUnit)parserInfo.BestCompilationUnit;
+				
+				ClassUpdateInformation res = UpdateFromParseInfo (parserInfo, fileName);
+				if (res != null) parserService.NotifyParseInfoChange (fileName, res);
+			}
+		}
+		
+		public ClassUpdateInformation UpdateFromParseInfo (IParseInformation parserInfo, string fileName)
+		{
+			ICompilationUnit cu = (ICompilationUnit)parserInfo.BestCompilationUnit;
+
+			ClassCollection resolved;
+			bool allResolved = parserService.ResolveTypes (project, cu, cu.Classes, out resolved);
+			ClassUpdateInformation res = UpdateClassInformation (resolved, fileName);
+			
+			FileEntry file = files [fileName] as FileEntry;
+			if (file == null) return res;
+			
+			if (!allResolved) {
+				if (file.ParseErrorRetries &gt; 0) {
+					file.ParseErrorRetries--;
+				}
+				else
+					file.ParseErrorRetries = 3;
+			}
+			else
+				file.ParseErrorRetries = 0;
+
+			return res;
+		}
+	}
+	
+	internal class AssemblyCodeCompletionDatabase: CodeCompletionDatabase
+	{
+		bool useExternalProcess = true;
+		string baseDir;
+		string assemblyName;
+		
+		public AssemblyCodeCompletionDatabase (string baseDir, string assemblyName, DefaultParserService parserService)
+		: base (parserService)
+		{
+			string assemblyFile;
+			string name;
+			Assembly asm = null;
+			
+			if (assemblyName.ToLower().EndsWith (&quot;.dll&quot;)) 
+			{
+				name = assemblyName.Substring (0, assemblyName.Length - 4);
+				name = name.Replace(',','_').Replace(&quot; &quot;,&quot;&quot;).Replace('/','_');
+				assemblyFile = assemblyName;
+				try {
+					asm = Assembly.LoadFrom (assemblyFile);
+				}
+				catch {}
+				
+				if (asm == null) {
+					Console.WriteLine (&quot;Could not load assembly: &quot; + assemblyFile);
+					return;
+				}
+			}
+			else 
+			{
+				asm = FindAssembly (assemblyName);
+				
+				if (asm == null) {
+					Console.WriteLine (&quot;Could not load assembly: &quot; + assemblyName);
+					return;
+				}
+				
+				assemblyName = asm.GetName().FullName;
+				name = EncodeGacAssemblyName (assemblyName);
+				assemblyFile = asm.Location;
+			}
+			
+			this.assemblyName = assemblyName;
+			this.baseDir = baseDir;
+			
+			SetLocation (baseDir, name);
+
+			Read ();
+			
+			if (files [assemblyFile] == null) {
+				AddFile (assemblyFile);
+				headers [&quot;CheckFile&quot;] = assemblyFile;
+			}
+			
+			// Update references to other assemblies
+			
+			Hashtable rs = new Hashtable ();
+			foreach (AssemblyName aname in asm.GetReferencedAssemblies ()) {
+				string uri = &quot;Assembly:&quot; + aname.ToString();
+				rs[uri] = null;
+				if (!HasReference (uri))
+					AddReference (uri);
+			}
+			
+			ArrayList keys = new ArrayList ();
+			keys.AddRange (references);
+			foreach (ReferenceEntry re in keys)
+			{
+				if (!rs.Contains (re.Uri))
+					RemoveReference (re.Uri);
+			}
+		}
+		
+		public static string GetFullAssemblyName (string s)
+		{
+			if (s.ToLower().EndsWith (&quot;.dll&quot;)) 
+				return s;
+				
+			Assembly asm = FindAssembly (s);
+			
+			if (asm != null)
+				return asm.GetName().FullName;
+			else
+				return s;
+		}
+		
+		public static Assembly FindAssembly (string name)
+		{
+			Assembly asm = null;
+			try {
+				asm = Assembly.Load (name);
+			}
+			catch {}
+			
+			if (asm == null) {
+				try {
+					asm = Assembly.LoadWithPartialName (name);
+				}
+				catch {}
+			}
+			return asm;
+		}
+		
+		string EncodeGacAssemblyName (string assemblyName)
+		{
+			string[] assemblyPieces = assemblyName.Split(',');
+			string res = &quot;&quot;;
+			foreach (string item in assemblyPieces) {
+				string[] pieces = item.Trim ().Split (new char[] { '=' }, 2);
+				if(pieces.Length == 1)
+					res += pieces[0];
+				else if (!(pieces[0] == &quot;Culture&quot; &amp;&amp; pieces[1] != &quot;Neutral&quot;))
+					res += &quot;_&quot; + pieces[1];
+			}
+			return res;
+		}
+		
+		public string AssemblyName
+		{
+			get { return assemblyName; }
+		}
+		
+		protected override void ParseFile (string fileName)
+		{
+			if (useExternalProcess)
+			{
+				string dbgen = Path.Combine (AppDomain.CurrentDomain.BaseDirectory, &quot;dbgen.exe&quot;);
+				Process proc = Process.Start (&quot;mono &quot; + dbgen, &quot;\&quot;&quot; + baseDir + &quot;\&quot; \&quot;&quot; + assemblyName + &quot;\&quot;&quot;);
+				proc.WaitForExit ();
+				Read ();
+			}
+			else
+			{
+				Console.WriteLine (&quot;Parsing assembly: &quot; + fileName);
+				AssemblyInformation ainfo = new AssemblyInformation();
+				ainfo.Load (fileName, false);
+				UpdateClassInformation (ainfo.Classes, fileName);
+			}
+		}
+		
+		public bool ParseInExternalProcess
+		{
+			get { return useExternalProcess; }
+			set { useExternalProcess = value; }
+		}
+		
+		public static void CleanDatabase (string baseDir, string name)
+		{
+			// Read the headers of the file without fully loading the database
+			Hashtable headers = ReadHeaders (baseDir, name);
+			string checkFile = (string) headers [&quot;CheckFile&quot;];
+			int version = (int) headers [&quot;Version&quot;];
+			if (!File.Exists (checkFile) || version != FORMAT_VERSION) {
+				string dataFile = Path.Combine (baseDir, name + &quot;.pidb&quot;);
+				File.Delete (dataFile);
+				Console.WriteLine (&quot;Deleted &quot; + dataFile);
+			}
+		}
+	}
+	
+	internal class SimpleCodeCompletionDatabase: CodeCompletionDatabase
+	{
+		string file = &quot;_currentFile&quot;;
+		
+		public SimpleCodeCompletionDatabase (string file, DefaultParserService parserService)
+		: base (parserService)
+		{
+			AddFile (file);
+			this.file = file;
+		}
+		
+		public ClassUpdateInformation UpdateFromParseInfo (IParseInformation parserInfo)
+		{
+			ICompilationUnit cu = (ICompilationUnit)parserInfo.BestCompilationUnit;
+			ClassCollection resolved;
+			parserService.ResolveTypes (null, cu, cu.Classes, out resolved);
+			return UpdateClassInformation (resolved, file);
+		}
+		
+		public override void Read () {}
+		public override void Write () {}
+	}
+	
+
+	public interface INameEncoder
+	{
+		int GetStringId (string text);
+	}
+	
+	public interface INameDecoder
+	{
+		string GetStringValue (int id);
+	}
+	
+	
+	public class StringNameTable: INameEncoder, INameDecoder
+	{
+		string[] table;
+		
+		public StringNameTable (string[] names)
+		{
+			table = names;
+			Array.Sort (table);
+		}
+		
+		public string GetStringValue (int id)
+		{
+			return table [id];
+		}
+		
+		public int GetStringId (string text)
+		{
+			int i = Array.BinarySearch (table, text);
+			if (i &gt;= 0) return i;
+			else return -1;
+		}
+	}
+	
+	[Serializable]
+	class NamespaceEntry
+	{
+		Hashtable contents = new Hashtable ();
+		
+		// This is the case insensitive version of the hashtable.
+		// It is constructed only when needed.
+		[NonSerialized] Hashtable contents_ci;
+		
+		// All methods with the caseSensitive parameter, first check for an
+		// exact match, and if not found, they try with the case insensitive table.
+		
+		public NamespaceEntry GetNamespace (string ns, bool caseSensitive)
+		{
+			NamespaceEntry ne = contents[ns] as NamespaceEntry;
+			if (ne != null || caseSensitive) return ne;
+			
+			if (contents_ci == null) BuildCaseInsensitiveTable ();
+			return contents_ci[ns] as NamespaceEntry;
+		}
+		
+		public ClassEntry GetClass (string name, bool caseSensitive)
+		{
+			ClassEntry ne = contents[name] as ClassEntry;
+			if (ne != null || caseSensitive) return ne;
+			
+			if (contents_ci == null) BuildCaseInsensitiveTable ();
+			return contents_ci[name] as ClassEntry;
+		}
+		
+		public void Add (string name, object value)
+		{
+			contents [name] = value;
+			if (contents_ci != null)
+				contents_ci [name] = value;
+		}
+		
+		public void Remove (string name)
+		{
+			contents.Remove (name);
+			contents_ci = null;
+		}
+		
+		public ICollection Contents
+		{
+			get { return contents; }
+		}
+		
+		public int ContentCount
+		{
+			get { return contents.Count; }
+		}
+		
+		public void Clean ()
+		{
+			ArrayList todel = new ArrayList ();
+			foreach (DictionaryEntry en in contents)
+			{
+				NamespaceEntry h = en.Value as NamespaceEntry;
+				if (h != null) {
+					h.Clean ();
+					if (h.ContentCount == 0) todel.Add (en.Key);
+				}
+			}
+			
+			if (todel.Count &gt; 0)
+			{
+				contents_ci = null;
+				foreach (string key in todel)
+					contents.Remove (key);
+			}
+		}
+		
+		void BuildCaseInsensitiveTable ()
+		{
+			contents_ci = new Hashtable (CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);
+			foreach (DictionaryEntry en in contents)
+				contents_ci.Add (en.Key, en.Value);
+		}
+	}
+
+	[Serializable]
+	class ClassEntry
+	{
+		long position;
+		NamespaceEntry namespaceRef;
+		string name;
+		FileEntry fileEntry;
+		ClassEntry nextInFile;
+		
+		[NonSerialized]
+		int lastGetTime;
+		
+		[NonSerialized]
+		public IClass cls;
+		
+		public ClassEntry (IClass cls, FileEntry fileEntry, NamespaceEntry namespaceRef)
+		{
+			this.cls = cls;
+			this.fileEntry = fileEntry;
+			this.namespaceRef = namespaceRef;
+			this.name = cls.Name;
+			position = -1;
+		}
+		
+		public long Position
+		{
+			get { return position; }
+			set { position = value; }
+		}
+		
+		public IClass Class
+		{
+			get { 
+				return cls; 
+			}
+			set {
+				cls = value; 
+				if (cls != null) {
+					name = cls.Name; 
+					position = -1; 
+				}
+			}
+		}
+		
+		public string Name
+		{
+			get { return name; }
+		}
+		
+		public NamespaceEntry NamespaceRef
+		{
+			get { return namespaceRef; }
+		}
+		
+		public FileEntry FileEntry
+		{
+			get { return fileEntry; }
+			set { fileEntry = value; }
+		}
+		
+		public int LastGetTime
+		{
+			get { return lastGetTime; }
+			set { lastGetTime = value; }
+		}
+		
+		public ClassEntry NextInFile
+		{
+			get { return nextInFile; }
+			set { nextInFile = value; }
+		}
+	}
+	
+	[Serializable]
+	class FileEntry
+	{
+		string filePath;
+		DateTime parseTime;
+		ClassEntry firstClass;
+		int parseErrorRetries;
+		
+		public FileEntry (string path)
+		{
+			filePath = path;
+			parseTime = DateTime.MinValue;
+		}
+		
+		public string FileName
+		{
+			get { return filePath; }
+		}
+		
+		public DateTime LastParseTime
+		{
+			get { return parseTime; }
+			set { parseTime = value; }
+		}
+		
+		public ClassEntry FirstClass
+		{
+			get { return firstClass; }
+		}
+		
+		public int ParseErrorRetries
+		{
+			get { return parseErrorRetries; }
+			set { parseErrorRetries = value; }
+		}
+		
+		public void SetClasses (ArrayList list)
+		{
+			firstClass = null;
+			foreach (ClassEntry ce in list)
+				AddClass (ce);
+		}
+		
+		public void AddClass (ClassEntry ce)
+		{
+			if (ce.FileEntry != null)
+				ce.FileEntry.RemoveClass (ce);
+				
+			ce.NextInFile = firstClass;
+			firstClass = ce;
+		}
+		
+		public void RemoveClass (ClassEntry ce)
+		{
+			ClassEntry oldent = null;
+			ClassEntry curent = firstClass;
+			
+			while (curent != null &amp;&amp; curent != ce) {
+				oldent = curent;
+				curent = curent.NextInFile;
+			}
+			
+			if (curent == null) 
+				return;
+			else if (oldent == null)
+				firstClass = curent.NextInFile;
+			else
+				oldent.NextInFile = curent.NextInFile;
+				
+			ce.FileEntry = null;
+		}
+		
+		public bool IsAssembly
+		{
+			get { return filePath.ToLower().EndsWith (&quot;.dll&quot;); }
+		}
+	}
+	
+	[Serializable]
+	class ReferenceEntry
+	{
+		string databaseUri;
+		
+		public ReferenceEntry (string dbUri)
+		{
+			databaseUri = dbUri;
+		}
+		
+		public string Uri
+		{
+			get { return databaseUri; }
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/DefaultParserService.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/DefaultParserService.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/DefaultParserService.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,1344 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Krger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Collections;
+using System.Collections.Utility;
+using System.Diagnostics;
+using System.Reflection;
+using System.Runtime.Serialization;
+using System.Runtime.Serialization.Formatters;
+using System.Runtime.Serialization.Formatters.Binary;
+using System.Security;
+using System.Security.Permissions;
+using System.Security.Policy;
+using System.Xml;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Services
+{
+	public class DefaultParserService : IParserService
+	{
+		CodeCompletionDatabase coreDatabase;
+		
+		const int MAX_PARSING_CACHE_SIZE = 10;
+		const int MAX_SINGLEDB_CACHE_SIZE = 10;
+		string CoreDB;
+
+		class ParsingCacheEntry
+		{
+			   public ParseInformation ParseInformation;
+			   public string FileName;
+			   public DateTime AccessTime;
+		}
+		
+		class SingleFileCacheEntry
+		{
+			   public SimpleCodeCompletionDatabase Database;
+			   public DateTime AccessTime;
+		}
+		
+		class ParsingJob
+		{
+			public object Data;
+			public WaitCallback ParseCallback;
+		}
+
+		class CompilationUnitTypeResolver: ITypeResolver
+		{
+			public IClass CallingClass;
+			IProject project;
+			ICompilationUnit unit;
+			DefaultParserService parserService;
+			bool allResolved;
+			
+			public CompilationUnitTypeResolver (IProject project, ICompilationUnit unit, DefaultParserService parserService)
+			{
+				this.project = project;
+				this.unit = unit;
+				this.parserService = parserService;
+			}
+			
+			public string Resolve (string typeName)
+			{
+				IClass c = parserService.SearchType (project, typeName, CallingClass, unit);
+				if (c != null)
+					return c.FullyQualifiedName;
+				else {
+					allResolved = false;
+					return typeName;
+				}
+			}
+			
+			public bool AllResolved
+			{
+				get { return allResolved; }
+				set { allResolved = value; }
+			}
+		}
+		
+		Hashtable lastUpdateSize = new Hashtable();
+		Hashtable parsings = new Hashtable ();
+		
+		CombineEntryEventHandler combineEntryAddedHandler;
+		CombineEntryEventHandler combineEntryRemovedHandler;
+
+		public static Queue parseQueue = new Queue();
+		
+		string codeCompletionPath;
+
+		Hashtable databases = new Hashtable();
+		Hashtable singleDatabases = new Hashtable ();
+		
+		IParser[] parser;
+		
+		readonly static string[] assemblyList = {
+			&quot;Microsoft.VisualBasic&quot;,
+			&quot;mscorlib&quot;,
+			&quot;System.Data&quot;,
+			&quot;System.Design&quot;,
+			&quot;System.Drawing.Design&quot;,
+			&quot;System.Drawing&quot;,
+			&quot;System.Runtime.Remoting&quot;,
+			&quot;System.Security&quot;,
+			&quot;System.ServiceProcess&quot;,
+			&quot;System.Web.Services&quot;,
+			&quot;System.Web&quot;,
+			&quot;System&quot;,
+			&quot;System.Xml&quot;,
+			&quot;glib-sharp&quot;,
+			&quot;atk-sharp&quot;,
+			&quot;pango-sharp&quot;,
+			&quot;gdk-sharp&quot;,
+			&quot;gtk-sharp&quot;,
+			&quot;gnome-sharp&quot;,
+			&quot;gconf-sharp&quot;,
+			&quot;gtkhtml-sharp&quot;,
+			//&quot;System.Windows.Forms&quot;,
+			//&quot;Microsoft.JScript&quot;,
+		};
+		
+		StringNameTable nameTable;
+		
+		string[] sharedNameTable = new string[] {
+			&quot;System.String&quot;, &quot;System.Boolean&quot;, &quot;System.Int32&quot;, &quot;System.Attribute&quot;,
+			&quot;System.Delegate&quot;, &quot;System.Enum&quot;, &quot;System.Exception&quot;, &quot;System.MarshalByRefObject&quot;,
+			&quot;System.Object&quot;, &quot;SerializableAttribtue&quot;, &quot;System.Type&quot;, &quot;System.ValueType&quot;,
+			&quot;System.ICloneable&quot;, &quot;System.IDisposable&quot;, &quot;System.IConvertible&quot;, &quot;System.Byte&quot;,
+			&quot;System.Char&quot;, &quot;System.DateTime&quot;, &quot;System.Decimal&quot;, &quot;System.Double&quot;, &quot;System.Int16&quot;,
+			&quot;System.Int64&quot;, &quot;System.IntPtr&quot;, &quot;System.SByte&quot;, &quot;System.Single&quot;, &quot;System.TimeSpan&quot;,
+			&quot;System.UInt16&quot;, &quot;System.UInt32&quot;, &quot;System.UInt64&quot;, &quot;System.Void&quot;
+		};
+		
+		public DefaultParserService()
+		{
+			combineEntryAddedHandler = new CombineEntryEventHandler (OnCombineEntryAdded);
+			combineEntryRemovedHandler = new CombineEntryEventHandler (OnCombineEntryRemoved);
+			nameTable = new StringNameTable (sharedNameTable);
+		}
+		
+		public string LoadAssemblyFromGac (string name) {
+			MethodInfo gac_get = typeof (System.Environment).GetMethod (&quot;internalGetGacPath&quot;, BindingFlags.Static|BindingFlags.NonPublic);
+			
+			if (name == &quot;mscorlib&quot;)
+				return typeof(object).Assembly.Location;
+				
+			Assembly asm;
+			try {
+				asm = Assembly.Load (name);
+			}
+			catch {
+				asm = Assembly.LoadWithPartialName (name);
+			}
+			if (asm == null) {
+				Console.WriteLine (&quot;Could not find: &quot; + name);
+				return string.Empty;
+			}
+			
+			return asm.Location;
+		}
+		
+		string sys_version;
+		string GetSysVersion () {
+			if (sys_version != null)
+				return sys_version;
+			sys_version = typeof (object).Assembly.GetName ().Version.ToString ();
+			return sys_version;
+		}
+		
+
+		public void GenerateAssemblyDatabase (string baseDir, string name)
+		{
+			AssemblyCodeCompletionDatabase db = new AssemblyCodeCompletionDatabase (baseDir, name, this);
+			db.ParseInExternalProcess = false;
+			db.ParseAll ();
+			db.Write ();
+		}
+		
+		void SetDefaultCompletionFileLocation()
+		{
+			PropertyService propertyService = (PropertyService)ServiceManager.GetService(typeof(PropertyService));
+			FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService (typeof (FileUtilityService));
+			string path = propertyService.GetProperty(&quot;SharpDevelop.CodeCompletion.DataDirectory&quot;, String.Empty).ToString();
+			if (path == String.Empty) {
+                        	path = Path.Combine (fileUtilityService.GetDirectoryNameWithSeparator(propertyService.ConfigDirectory), &quot;CodeCompletionData&quot;);
+				propertyService.SetProperty (&quot;SharpDevelop.CodeCompletion.DataDirectory&quot;, path);
+				propertyService.SaveProperties ();
+			}
+                        if (!Directory.Exists (path))
+                                Directory.CreateDirectory (path);
+
+			codeCompletionPath = fileUtilityService.GetDirectoryNameWithSeparator(path);
+		}
+
+		public override void InitializeService()
+		{
+			parser = (IParser[])(AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/Workspace/Parser&quot;).BuildChildItems(this)).ToArray(typeof(IParser));
+			
+			SetDefaultCompletionFileLocation();
+			DeleteObsoleteDatabases ();
+
+			string coreName = typeof(object).Assembly.GetName().ToString ();
+			CoreDB = &quot;Assembly:&quot; + coreName;
+			coreDatabase = new AssemblyCodeCompletionDatabase (codeCompletionPath, coreName, this);
+			databases [CoreDB] = coreDatabase;
+			
+			IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.GetService(typeof(IProjectService));
+			projectService.CombineOpened += new CombineEventHandler(OnCombineOpened);
+			projectService.CombineClosed += new CombineEventHandler(OnCombineClosed);
+			projectService.FileRemovedFromProject += new ProjectFileEventHandler (OnProjectFilesChanged);
+			projectService.FileAddedToProject += new ProjectFileEventHandler (OnProjectFilesChanged);
+			projectService.ReferenceAddedToProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
+			projectService.ReferenceRemovedFromProject += new ProjectReferenceEventHandler (OnProjectReferencesChanged);
+			projectService.ProjectRenamed += new ProjectRenameEventHandler(OnProjectRenamed);
+		}
+		
+		internal CodeCompletionDatabase GetDatabase (string uri)
+		{
+			return GetDatabase (null, uri);
+		}
+		
+		internal ProjectCodeCompletionDatabase GetProjectDatabase (IProject project)
+		{
+			if (project == null) return null;
+			return (ProjectCodeCompletionDatabase) GetDatabase (null, &quot;Project:&quot; + project.Name);
+		}
+		
+		internal CodeCompletionDatabase GetDatabase (string baseDir, string uri)
+		{
+			lock (databases)
+			{
+				if (baseDir == null) baseDir = codeCompletionPath;
+				CodeCompletionDatabase db = (CodeCompletionDatabase) databases [uri];
+				if (db == null) 
+				{
+					// Create/load the database
+
+					if (uri.StartsWith (&quot;Assembly:&quot;))
+					{
+						string file = uri.Substring (9);
+						
+						// We may be trying to load an assembly db using a partial name.
+						// In this case we get the full name to avoid database conflicts
+						file = AssemblyCodeCompletionDatabase.GetFullAssemblyName (file);
+						string realUri = &quot;Assembly:&quot; + file;
+						db = (CodeCompletionDatabase) databases [realUri];
+						if (db != null) {
+							databases [uri] = db;
+							return db;
+						}
+						
+						AssemblyCodeCompletionDatabase adb;
+						db = adb = new AssemblyCodeCompletionDatabase (baseDir, file, this);
+						databases [realUri] = adb;
+						if (uri != realUri)
+							databases [uri] = adb;
+						
+						// Load referenced databases
+						foreach (ReferenceEntry re in db.References)
+							GetDatabase (baseDir, re.Uri);
+					}
+				}
+				return db;
+			}
+		}
+		
+		internal SimpleCodeCompletionDatabase GetSingleFileDatabase (string file)
+		{
+			lock (singleDatabases)
+			{
+				SingleFileCacheEntry entry = singleDatabases [file] as SingleFileCacheEntry;
+				if (entry != null) {
+					entry.AccessTime = DateTime.Now;
+					return entry.Database;
+				}
+				else 
+				{
+					if (singleDatabases.Count &gt;= MAX_SINGLEDB_CACHE_SIZE)
+					{
+						DateTime tim = DateTime.MaxValue;
+						string toDelete = null;
+						foreach (DictionaryEntry pce in singleDatabases)
+						{
+							DateTime ptim = ((SingleFileCacheEntry)pce.Value).AccessTime;
+							if (ptim &lt; tim) {
+								tim = ptim;
+								toDelete = pce.Key.ToString();
+							}
+						}
+						singleDatabases.Remove (toDelete);
+					}
+				
+					SimpleCodeCompletionDatabase db = new SimpleCodeCompletionDatabase (file, this);
+					entry = new SingleFileCacheEntry ();
+					entry.Database = db;
+					entry.AccessTime = DateTime.Now;
+					singleDatabases [file] = entry;
+					return db;
+				}
+			}
+		}
+		
+		void LoadProjectDatabase (IProject project)
+		{
+			lock (databases)
+			{
+				string uri = &quot;Project:&quot; + project.Name;
+				if (databases.Contains (uri)) return;
+				
+				ProjectCodeCompletionDatabase db = new ProjectCodeCompletionDatabase (project, this);
+				databases [uri] = db;
+				
+				foreach (ReferenceEntry re in db.References)
+				{
+					GetDatabase (re.Uri);
+				}
+			}
+		}
+		
+		void UnloadDatabase (string uri)
+		{
+			if (uri == CoreDB) return;
+			lock (databases)
+			{
+				CodeCompletionDatabase db = databases [uri] as CodeCompletionDatabase;
+				if (db != null) {
+					db.Write ();
+					databases.Remove (uri);
+				}
+			}
+		}
+		
+		void UnloadProjectDatabase (IProject project)
+		{
+			string uri = &quot;Project:&quot; + project.Name;
+			UnloadDatabase (uri);
+		}
+		
+		void CleanUnusedDatabases ()
+		{
+			lock (databases)
+			{
+				Hashtable references = new Hashtable ();
+				foreach (CodeCompletionDatabase db in databases.Values)
+				{
+					if (db is ProjectCodeCompletionDatabase) {
+						foreach (ReferenceEntry re in ((ProjectCodeCompletionDatabase)db).References)
+							references [re.Uri] = null;
+					}
+				}
+				
+				ArrayList todel = new ArrayList ();
+				foreach (DictionaryEntry en in databases)
+				{
+					if (!(en.Value is ProjectCodeCompletionDatabase) &amp;&amp; !references.Contains (en.Key))
+						todel.Add (en.Key);
+				}
+				
+				foreach (string uri in todel)
+					UnloadDatabase (uri);
+			}
+		}
+		
+		public void LoadCombineDatabases (Combine combine)
+		{
+			ArrayList projects = Combine.GetAllProjects(combine);
+			foreach (ProjectCombineEntry entry in projects) {
+				LoadProjectDatabase (entry.Project);
+			}
+		}
+		
+		public void UnloadCombineDatabases (Combine combine)
+		{
+			ArrayList projects = Combine.GetAllProjects(combine);
+			foreach (ProjectCombineEntry entry in projects) {
+				UnloadProjectDatabase (entry.Project);
+			}
+		}
+		
+		public void OnCombineOpened(object sender, CombineEventArgs e)
+		{
+			LoadCombineDatabases (e.Combine);
+			e.Combine.EntryAdded += combineEntryAddedHandler;
+			e.Combine.EntryRemoved += combineEntryRemovedHandler;
+		}
+		
+		public void OnCombineClosed (object sender, CombineEventArgs e)
+		{
+			UnloadCombineDatabases (e.Combine);
+			CleanUnusedDatabases ();
+			e.Combine.EntryAdded -= combineEntryAddedHandler;
+			e.Combine.EntryRemoved -= combineEntryRemovedHandler;
+		}
+		
+		void OnProjectRenamed (object sender, ProjectRenameEventArgs args)
+		{
+			ProjectCodeCompletionDatabase db = GetProjectDatabase (args.Project);
+			if (db == null) return;
+			
+			db.Rename (args.NewName);
+			databases.Remove (&quot;Project:&quot; + args.OldName);
+			databases [&quot;Project:&quot; + args.NewName] = db;
+			RefreshProjectDatabases ();
+			CleanUnusedDatabases ();
+		}
+		
+		void OnCombineEntryAdded (object sender, CombineEntryEventArgs args)
+		{
+			if (args.CombineEntry is ProjectCombineEntry)
+				LoadProjectDatabase (((ProjectCombineEntry)args.CombineEntry).Project);
+			else if (args.CombineEntry is CombineCombineEntry)
+				LoadCombineDatabases (((CombineCombineEntry)args.CombineEntry).Combine);
+		}
+		
+		void OnCombineEntryRemoved (object sender, CombineEntryEventArgs args)
+		{
+			if (args.CombineEntry is ProjectCombineEntry)
+				UnloadProjectDatabase (((ProjectCombineEntry)args.CombineEntry).Project);
+			else if (args.CombineEntry is CombineCombineEntry)
+				UnloadCombineDatabases (((CombineCombineEntry)args.CombineEntry).Combine);
+			CleanUnusedDatabases ();
+		}
+		
+		void OnProjectFilesChanged (object sender, ProjectFileEventArgs args)
+		{
+			ProjectCodeCompletionDatabase db = GetProjectDatabase (args.Project);
+			if (db != null) db.UpdateFromProject ();
+		}
+		
+		void OnProjectReferencesChanged (object sender, ProjectReferenceEventArgs args)
+		{
+			ProjectCodeCompletionDatabase db = GetProjectDatabase (args.Project);
+			if (db != null) {
+				db.UpdateFromProject ();
+				foreach (ReferenceEntry re in db.References)
+				{
+					// Make sure the db is loaded
+					GetDatabase (re.Uri);
+				}
+			}
+		}
+		
+		void RefreshProjectDatabases ()
+		{
+			foreach (CodeCompletionDatabase db in databases.Values)
+			{
+				ProjectCodeCompletionDatabase pdb = db as ProjectCodeCompletionDatabase;
+				if (pdb != null)
+					pdb.UpdateFromProject ();
+			}
+		}
+		
+		internal void QueueParseJob (WaitCallback callback, object data)
+		{
+			ParsingJob job = new ParsingJob ();
+			job.ParseCallback = callback;
+			job.Data = data;
+			lock (parseQueue)
+			{
+				parseQueue.Enqueue (job);
+			}
+		}
+		
+		void DeleteObsoleteDatabases ()
+		{
+			string[] files = Directory.GetFiles (codeCompletionPath, &quot;*.pidb&quot;);
+			foreach (string file in files)
+			{
+				string name = Path.GetFileNameWithoutExtension (file);
+				string baseDir = Path.GetDirectoryName (file);
+				AssemblyCodeCompletionDatabase.CleanDatabase (baseDir, name);
+			}
+		}
+		
+		public void StartParserThread()
+		{
+			Thread t = new Thread(new ThreadStart(ParserUpdateThread));
+			t.IsBackground  = true;
+			t.Start();
+		}
+		
+		
+		void ParserUpdateThread()
+		{
+			int loop = 0;
+			while (true)
+			{
+				Thread.Sleep(500);
+				
+				ParseCurrentFile ();
+				
+				ConsumeParsingQueue ();
+				
+				if (loop % 10 == 0)
+					CheckModifiedFiles ();
+				
+				loop++;
+			}
+		}
+		
+		void CheckModifiedFiles ()
+		{
+			// Check databases following a bottom-up strategy in the dependency
+			// tree. This will help resolving parsed classes.
+			
+			ArrayList list = new ArrayList ();
+			lock (databases) 
+			{
+				// There may be several uris for the same db
+				foreach (object ob in databases.Values)
+					if (!list.Contains (ob))
+						list.Add (ob);
+			}
+			
+			ArrayList done = new ArrayList ();
+			while (list.Count &gt; 0) 
+			{
+				CodeCompletionDatabase readydb = null;
+				CodeCompletionDatabase bestdb = null;
+				int bestRefCount = int.MaxValue;
+				
+				// Look for a db with all references resolved
+				for (int n=0; n&lt;list.Count &amp;&amp; readydb==null; n++)
+				{
+					CodeCompletionDatabase db = (CodeCompletionDatabase)list[n];
+
+					bool allDone = true;
+					foreach (ReferenceEntry re in db.References) {
+						CodeCompletionDatabase refdb = GetDatabase (re.Uri);
+						if (!done.Contains (refdb)) {
+							allDone = false;
+							break;
+						}
+					}
+					
+					if (allDone)
+						readydb = db;
+					else if (db.References.Count &lt; bestRefCount) {
+						bestdb = db;
+						bestRefCount = db.References.Count;
+					}
+				}
+
+				// It may not find any db without resolved references if there
+				// are circular dependencies. In this case, take the one with
+				// less references
+				
+				if (readydb == null)
+					readydb = bestdb;
+					
+				readydb.CheckModifiedFiles ();
+				list.Remove (readydb);
+				done.Add (readydb);
+			}
+		}
+		
+		void ConsumeParsingQueue ()
+		{
+			int pending;
+			do {
+				ParsingJob job = null;
+				lock (parseQueue)
+				{
+					if (parseQueue.Count &gt; 0)
+						job = (ParsingJob) parseQueue.Dequeue ();
+				}
+				
+				if (job != null)
+					job.ParseCallback (job.Data);
+				
+				lock (parseQueue)
+					pending = parseQueue.Count;
+				
+			}
+			while (pending &gt; 0);
+		}
+		
+		
+		void ParseCurrentFile()
+		{
+			try {
+				IWorkbenchWindow win = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+				if (win == null || win.ActiveViewContent == null) return;
+				
+				IEditable editable = win.ActiveViewContent as IEditable;
+				if (editable == null) return;
+				
+				string fileName = null;
+				
+				IViewContent viewContent = win.ViewContent;
+				IParseableContent parseableContent = win.ActiveViewContent as IParseableContent;
+				
+				if (parseableContent != null) {
+					fileName = parseableContent.ParseableContentName;
+				} else {
+					fileName = viewContent.IsUntitled ? viewContent.UntitledName : viewContent.ContentName;
+				}
+				
+				if (fileName == null || fileName.Length == 0) return;
+				
+				string text = editable.Text;
+				if (text == null) return;
+					
+				IParseInformation parseInformation = null;
+				bool updated = false;
+				lock (parsings) {
+				
+					if (lastUpdateSize[fileName] == null || (int)lastUpdateSize[fileName] != text.GetHashCode()) {
+						parseInformation = DoParseFile(fileName, text);
+						if (parseInformation == null) return;
+						
+						if (viewContent.Project != null) {
+							ProjectCodeCompletionDatabase db = GetProjectDatabase (viewContent.Project);
+							ClassUpdateInformation res = db.UpdateFromParseInfo (parseInformation, fileName);
+							if (res != null) NotifyParseInfoChange (fileName, res);
+						}
+						else {
+							SimpleCodeCompletionDatabase db = GetSingleFileDatabase (fileName);
+							db.UpdateFromParseInfo (parseInformation);
+						}
+
+						lastUpdateSize[fileName] = text.GetHashCode();
+						updated = true;
+					}
+				}
+				if (updated &amp;&amp; parseInformation != null &amp;&amp; editable is IParseInformationListener) {
+					((IParseInformationListener)editable).ParseInformationUpdated(parseInformation);
+				}
+			} catch (Exception e) {
+				try {
+					Console.WriteLine(e.ToString());
+				} catch {}
+			}
+		}
+		
+		CodeCompletionDatabase GetActiveFileDatabase()
+		{
+			IWorkbenchWindow win = WorkbenchSingleton.Workbench.ActiveWorkbenchWindow;
+			if (win == null || win.ActiveViewContent == null) return null;
+			
+			IEditable editable = win.ActiveViewContent as IEditable;
+			if (editable == null) return null;
+			
+			string fileName = null;
+			
+			IViewContent viewContent = win.ViewContent;
+			IParseableContent parseableContent = win.ActiveViewContent as IParseableContent;
+			
+			if (parseableContent != null) {
+				fileName = parseableContent.ParseableContentName;
+			} else {
+				fileName = viewContent.IsUntitled ? viewContent.UntitledName : viewContent.ContentName;
+			}
+			
+			if (fileName == null || fileName.Length == 0) return null;
+			return GetSingleFileDatabase (fileName);
+		}
+		
+#region Default Parser Layer dependent functions
+
+		public IClass GetClass (IProject project, string typeName)
+		{
+			return GetClass(project, typeName, false, true);
+		}
+		
+		public IClass GetClass (IProject project, string typeName, bool deepSearchReferences, bool caseSensitive)
+		{
+			if (deepSearchReferences)
+				return DeepGetClass (project, typeName, caseSensitive);
+			else
+				return GetClass (project, typeName, caseSensitive);
+		}
+		
+		public IClass GetClass (IProject project, string typeName, bool caseSensitive)
+		{
+			CodeCompletionDatabase db = project != null ? GetProjectDatabase (project) : GetActiveFileDatabase ();
+			if (db != null) {
+				IClass c = db.GetClass (typeName, caseSensitive);
+				if (c != null) return c;
+				foreach (ReferenceEntry re in db.References)
+				{
+					CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+					if (cdb == null) continue;
+					c = cdb.GetClass (typeName, caseSensitive);
+					if (c != null) return c;
+				}
+			}
+			
+			db = GetDatabase (CoreDB);
+			return db.GetClass (typeName, caseSensitive);
+		}
+		
+		public IClass DeepGetClass (IProject project, string typeName, bool caseSensitive)
+		{
+			CodeCompletionDatabase db = (project != null) ? GetProjectDatabase (project) : GetActiveFileDatabase ();
+			
+			ArrayList visited = new ArrayList ();
+			IClass c = DeepGetClassRec (visited, db, typeName, caseSensitive);
+			if (c != null) return c;
+
+			db = GetDatabase (CoreDB);
+			return db.GetClass (typeName, caseSensitive);
+		}
+		
+		internal IClass DeepGetClassRec (ArrayList visitedDbs, CodeCompletionDatabase db, string typeName, bool caseSensitive)
+		{
+			if (db == null) return null;
+			if (visitedDbs.Contains (db)) return null;
+			
+			visitedDbs.Add (db);
+			
+			IClass c = db.GetClass (typeName, caseSensitive);
+			if (c != null) return c;
+			
+			foreach (ReferenceEntry re in db.References)
+			{
+				CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+				if (cdb == null) continue;
+				c = DeepGetClassRec (visitedDbs, cdb, typeName, caseSensitive);
+				if (c != null) return c;
+			}
+			return null;
+		}
+		
+		public string[] GetNamespaceList (IProject project, string subNameSpace)
+		{
+			return GetNamespaceList (project, subNameSpace, true);
+		}
+		
+		public string[] GetNamespaceList (IProject project, string subNameSpace, bool caseSensitive)
+		{
+			ArrayList contents = new ArrayList ();
+			
+			CodeCompletionDatabase db = (project != null) ? GetProjectDatabase (project) : GetActiveFileDatabase ();
+			if (db != null) {
+				db.GetNamespaceList (contents, subNameSpace, caseSensitive);
+				foreach (ReferenceEntry re in db.References)
+				{
+					CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+					if (cdb == null) continue;
+					cdb.GetNamespaceList (contents, subNameSpace, caseSensitive);
+				}
+			}
+			
+			db = GetDatabase (CoreDB);
+			db.GetNamespaceList (contents, subNameSpace, caseSensitive);
+			
+			return (string[]) contents.ToArray (typeof(string));
+		}
+		
+		public ArrayList GetNamespaceContents (IProject project, string namspace, bool includeReferences)
+		{
+			return GetNamespaceContents (project, namspace, includeReferences, true);
+		}
+		
+		public ArrayList GetNamespaceContents (IProject project, string namspace, bool includeReferences, bool caseSensitive)
+		{
+			ArrayList contents = new ArrayList ();
+			
+			CodeCompletionDatabase db = (project != null) ? GetProjectDatabase (project) : GetActiveFileDatabase ();
+			if (db != null) {
+				db.GetNamespaceContents (contents, namspace, caseSensitive);
+				if (includeReferences) {
+					foreach (ReferenceEntry re in db.References)
+					{
+						CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+						if (cdb == null) continue;
+						cdb.GetNamespaceContents (contents, namspace, caseSensitive);
+					}
+				}
+			}
+			
+			if (includeReferences) {
+				db = GetDatabase (CoreDB);
+				db.GetNamespaceContents (contents, namspace, caseSensitive);
+			}
+			
+			return contents;
+		}
+		
+		public bool NamespaceExists(IProject project, string name)
+		{
+			return NamespaceExists(project, name, true);
+		}
+		
+		public bool NamespaceExists(IProject project, string name, bool caseSensitive)
+		{
+			CodeCompletionDatabase db = (project != null) ? GetProjectDatabase (project) : GetActiveFileDatabase ();
+			if (db != null) {
+				if (db.NamespaceExists (name, caseSensitive)) return true;
+				foreach (ReferenceEntry re in db.References)
+				{
+					CodeCompletionDatabase cdb = GetDatabase (re.Uri);
+					if (cdb == null) continue;
+					if (cdb.NamespaceExists (name, caseSensitive)) return true;
+				}
+			}
+			
+			db = GetDatabase (CoreDB);
+			return db.NamespaceExists (name, caseSensitive);
+			}
+
+		public string SearchNamespace(IProject project, IUsing usin, string partitialNamespaceName)
+		{
+			return SearchNamespace(project, usin, partitialNamespaceName, true);
+		}
+		
+		public string SearchNamespace(IProject project, IUsing usin, string partitialNamespaceName, bool caseSensitive)
+		{
+//			Console.WriteLine(&quot;SearchNamespace : &gt;{0}&lt;&quot;, partitialNamespaceName);
+			if (NamespaceExists(project, partitialNamespaceName, caseSensitive)) {
+				return partitialNamespaceName;
+			}
+			
+			// search for partitial namespaces
+			string declaringNamespace = (string)usin.Aliases[&quot;&quot;];
+			if (declaringNamespace != null) {
+				while (declaringNamespace.Length &gt; 0) {
+					if ((caseSensitive ? declaringNamespace.EndsWith(partitialNamespaceName) : declaringNamespace.ToLower().EndsWith(partitialNamespaceName.ToLower()) ) &amp;&amp; NamespaceExists(project, declaringNamespace, caseSensitive)) {
+						return declaringNamespace;
+					}
+					int index = declaringNamespace.IndexOf('.');
+					if (index &gt; 0) {
+						declaringNamespace = declaringNamespace.Substring(0, index);
+					} else {
+						break;
+					}
+				}
+			}
+			
+			// Remember:
+			//     Each namespace has an own using object
+			//     The namespace name is an alias which has the key &quot;&quot;
+			foreach (DictionaryEntry entry in usin.Aliases) {
+				string aliasString = entry.Key.ToString();
+				if (caseSensitive ? partitialNamespaceName.StartsWith(aliasString) : partitialNamespaceName.ToLower().StartsWith(aliasString.ToLower())) {
+					if (aliasString.Length &gt;= 0) {
+						string nsName = nsName = String.Concat(entry.Value.ToString(), partitialNamespaceName.Remove(0, aliasString.Length));
+						if (NamespaceExists (project, nsName, caseSensitive)) {
+							return nsName;
+						}
+					}
+				}
+			}
+			return null;
+		}
+
+		/// &lt;remarks&gt;
+		/// use the usings and the name of the namespace to find a class
+		/// &lt;/remarks&gt;
+		public IClass SearchType (IProject project, string name, IClass callingClass, ICompilationUnit unit)
+		{
+			if (name == null || name == String.Empty)
+				return null;
+				
+			IClass c;
+			c = GetClass(project, name);
+			if (c != null)
+				return c;
+
+			if (unit != null) {
+				foreach (IUsing u in unit.Usings) {
+					if (u != null) {
+						c = SearchType(project, u, name);
+						if (c != null) {
+							return c;
+						}
+					}
+				}
+			}
+			if (callingClass == null) {
+				return null;
+			}
+			string fullname = callingClass.FullyQualifiedName;
+			string[] namespaces = fullname.Split(new char[] {'.'});
+			string curnamespace = &quot;&quot;;
+			int i = 0;
+			
+			do {
+				curnamespace += namespaces[i] + '.';
+				c = GetClass(project, curnamespace + name);
+				if (c != null) {
+					return c;
+				}
+				i++;
+			}
+			while (i &lt; namespaces.Length);
+			
+			return null;
+		}
+		
+		public IClass SearchType(IProject project, IUsing iusing, string partitialTypeName)
+		{
+			return SearchType(project, iusing, partitialTypeName, true);
+		}
+		
+		public IClass SearchType(IProject project, IUsing iusing, string partitialTypeName, bool caseSensitive)
+		{
+//			Console.WriteLine(&quot;Search type : &gt;{0}&lt;&quot;, partitialTypeName);
+			IClass c = GetClass(project, partitialTypeName, caseSensitive);
+			if (c != null) {
+				return c;
+			}
+			
+			foreach (string str in iusing.Usings) {
+				string possibleType = String.Concat(str, &quot;.&quot;, partitialTypeName);
+//				Console.WriteLine(&quot;looking for &quot; + possibleType);
+				c = GetClass(project, possibleType, caseSensitive);
+				if (c != null) {
+//					Console.WriteLine(&quot;Found!&quot;);
+					return c;
+				}
+			}
+			
+			// search class in partitial namespaces
+			string declaringNamespace = (string)iusing.Aliases[&quot;&quot;];
+			if (declaringNamespace != null) {
+				while (declaringNamespace.Length &gt; 0) {
+					string className = String.Concat(declaringNamespace, &quot;.&quot;, partitialTypeName);
+//					Console.WriteLine(&quot;looking for &quot; + className);
+					c = GetClass(project, className, caseSensitive);
+					if (c != null) {
+//						Console.WriteLine(&quot;Found!&quot;);
+						return c;
+					}
+					int index = declaringNamespace.IndexOf('.');
+					if (index &gt; 0) {
+						declaringNamespace = declaringNamespace.Substring(0, index);
+					} else {
+						break;
+					}
+				}
+			}
+			
+			foreach (DictionaryEntry entry in iusing.Aliases) {
+				string aliasString = entry.Key.ToString();
+				if (caseSensitive ? partitialTypeName.StartsWith(aliasString) : partitialTypeName.ToLower().StartsWith(aliasString.ToLower())) {
+					string className = null;
+					if (aliasString.Length &gt; 0) {
+						className = String.Concat(entry.Value.ToString(), partitialTypeName.Remove(0, aliasString.Length));
+//						Console.WriteLine(&quot;looking for &quot; + className);
+						c = GetClass(project, className, caseSensitive);
+						if (c != null) {
+//							Console.WriteLine(&quot;Found!&quot;);
+							return c;
+						}
+					}
+				}
+			}
+			
+			return null;
+		}
+		
+		public bool ResolveTypes (IProject project, ICompilationUnit unit, ClassCollection types, out ClassCollection result)
+		{
+			CompilationUnitTypeResolver tr = new CompilationUnitTypeResolver (project, unit, this);
+			
+			bool allResolved = true;
+			result = new ClassCollection ();
+			foreach (IClass c in types) {
+				tr.CallingClass = c;
+				tr.AllResolved = true;
+				result.Add (PersistentClass.Resolve (c, tr));
+				allResolved = allResolved &amp;&amp; tr.AllResolved;
+			}
+				
+			return allResolved;
+		}
+		
+		public IEnumerable GetClassInheritanceTree (IProject project, IClass cls)
+		{
+			return new ClassInheritanceEnumerator (this, project, cls);
+		}
+		
+#endregion
+		
+		public IParseInformation ParseFile(string fileName)
+		{
+			return ParseFile(fileName, null);
+		}
+		
+		public IParseInformation ParseFile (string fileName, string fileContent)
+		{
+			return DoParseFile (fileName, fileContent);
+		}
+		
+		public IParseInformation DoParseFile (string fileName, string fileContent)
+		{
+			IParser parser = GetParser(fileName);
+			
+			if (parser == null) {
+				return null;
+			}
+			
+			parser.LexerTags = new string[] { &quot;HACK&quot;, &quot;TODO&quot;, &quot;UNDONE&quot;, &quot;FIXME&quot; };
+			
+			ICompilationUnitBase parserOutput = null;
+			
+			if (fileContent == null) {
+				IProjectService projectService = (IProjectService)MonoDevelop.Core.Services.ServiceManager.GetService(typeof(IProjectService));
+				if (projectService.CurrentOpenCombine != null) {
+					ArrayList projects = Combine.GetAllProjects(projectService.CurrentOpenCombine);
+					foreach (ProjectCombineEntry entry in projects) {
+						if (entry.Project.IsFileInProject(fileName)) {
+							fileContent = entry.Project.GetParseableFileContent(fileName);
+						}
+					}
+				}
+			}
+			
+			if (fileContent != null) {
+				parserOutput = parser.Parse(fileName, fileContent);
+			} else {
+				parserOutput = parser.Parse(fileName);
+			}
+			
+			ParseInformation parseInformation = GetCachedParseInformation (fileName);
+			bool newInfo = false;
+			
+			if (parseInformation == null) {
+				parseInformation = new ParseInformation();
+				newInfo = true;
+			}
+			
+			if (parserOutput.ErrorsDuringCompile) {
+				parseInformation.DirtyCompilationUnit = parserOutput;
+			} else {
+				parseInformation.ValidCompilationUnit = parserOutput;
+				parseInformation.DirtyCompilationUnit = null;
+			}
+			
+			if (newInfo) {
+				AddToCache (parseInformation, fileName);
+			}
+			
+			OnParseInformationChanged (new ParseInformationEventArgs (fileName, parseInformation));
+			return parseInformation;
+		}
+		
+		ParseInformation GetCachedParseInformation (string fileName)
+		{
+			lock (parsings) 
+			{
+				ParsingCacheEntry en = parsings [fileName] as ParsingCacheEntry;
+				if (en != null) {
+					en.AccessTime = DateTime.Now;
+					return en.ParseInformation;
+				}
+				else
+					return null;
+			}
+		}
+		
+		void AddToCache (ParseInformation info, string fileName)
+		{
+			lock (parsings) 
+			{
+				if (parsings.Count &gt;= MAX_PARSING_CACHE_SIZE)
+				{
+					DateTime tim = DateTime.MaxValue;
+					string toDelete = null;
+					foreach (DictionaryEntry pce in parsings)
+					{
+						DateTime ptim = ((ParsingCacheEntry)pce.Value).AccessTime;
+						if (ptim &lt; tim) {
+							tim = ptim;
+							toDelete = pce.Key.ToString();
+						}
+					}
+					parsings.Remove (toDelete);
+				}
+				
+				ParsingCacheEntry en = new ParsingCacheEntry();
+				en.ParseInformation = info;
+				en.AccessTime = DateTime.Now;
+				parsings [fileName] = en;
+			}
+		}
+
+		public IParseInformation GetParseInformation(string fileName)
+		{
+			if (fileName == null || fileName.Length == 0) {
+				return null;
+			}
+			
+			IParseInformation info = GetCachedParseInformation (fileName);
+			if (info != null) return info;
+			else return ParseFile(fileName);
+		}
+		
+		public IExpressionFinder GetExpressionFinder(string fileName)
+		{
+			IParser parser = GetParser(fileName);
+			if (parser != null) {
+				return parser.ExpressionFinder;
+			}
+			return null;
+		}
+		public virtual IParser GetParser(string fileName)
+		{
+			// HACK: I'm too lazy to do it 'right'
+			if (fileName != null) {
+				if (Path.GetExtension(fileName).ToUpper() == &quot;.CS&quot;) {
+					return parser[0];
+				}
+				if (Path.GetExtension(fileName).ToUpper() == &quot;.VB&quot;) {
+					return parser[1];
+				}
+			}
+			return null;
+		}
+		
+		////////////////////////////////////
+		
+		public ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName)
+		{
+			IParser parser = GetParser(fileName);
+			if (parser != null) {
+				return parser.CtrlSpace(parserService, project, caretLine, caretColumn, fileName);
+			}
+			return null;
+		}
+
+		public ArrayList IsAsResolve (IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			try {
+				IParser parser = GetParser (fileName);
+				if (parser != null) {
+					return parser.IsAsResolve (this, project, expression, caretLineNumber, caretColumn, fileName, fileContent);
+				}
+				return null;
+			} catch {
+				return null;
+			}
+		}
+		
+		public ResolveResult Resolve(IProject project,
+									 string expression, 
+		                             int caretLineNumber,
+		                             int caretColumn,
+		                             string fileName,
+		                             string fileContent)
+		{
+			// added exception handling here to prevent silly parser exceptions from
+			// being thrown and corrupting the textarea control
+			try {
+				IParser parser = GetParser(fileName);
+				//Console.WriteLine(&quot;Parse info : &quot; + GetParseInformation(fileName).MostRecentCompilationUnit.Tag);
+				if (parser != null) {
+					return parser.Resolve(this, project, expression, caretLineNumber, caretColumn, fileName, fileContent);
+				}
+				return null;
+			} catch {
+				return null;
+			}
+		}
+		
+		internal INameEncoder DefaultNameEncoder {
+			get { return nameTable; }
+		}
+
+		internal INameDecoder DefaultNameDecoder {
+			get { return nameTable; }
+		}
+		
+		public string MonodocResolver (IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent)
+		{
+			try {
+				IParser parser = GetParser (fileName);
+				if (parser != null) {
+					return parser.MonodocResolver (this, project, expression, caretLineNumber, caretColumn, fileName, fileContent);
+				}
+				return null;
+			} catch {
+				return null;
+			}
+		}
+		
+		public void NotifyParseInfoChange (string file, ClassUpdateInformation res)
+		{
+			ClassInformationEventArgs args = new ClassInformationEventArgs (file, res);
+			OnClassInformationChanged (args);
+		}
+
+		protected virtual void OnParseInformationChanged(ParseInformationEventArgs e)
+		{
+			if (ParseInformationChanged != null) {
+				ParseInformationChanged(this, e);
+			}
+		}
+		
+		protected virtual void OnClassInformationChanged(ClassInformationEventArgs e)
+		{
+			if (ClassInformationChanged != null) {
+				ClassInformationChanged(this, e);
+			}
+		}
+		
+		public event ParseInformationEventHandler ParseInformationChanged;
+		public event ClassInformationEventHandler ClassInformationChanged;
+	}
+	
+	[Serializable]
+	public class DummyCompilationUnit : AbstractCompilationUnit
+	{
+		CommentCollection miscComments = new CommentCollection();
+		CommentCollection dokuComments = new CommentCollection();
+		TagCollection     tagComments  = new TagCollection();
+		
+		public override CommentCollection MiscComments {
+			get {
+				return miscComments;
+			}
+		}
+		
+		public override CommentCollection DokuComments {
+			get {
+				return dokuComments;
+			}
+		}
+		
+		public override TagCollection TagComments {
+			get {
+				return tagComments;
+			}
+		}
+	}
+	
+	public class ClassInheritanceEnumerator : IEnumerator, IEnumerable
+	{
+		DefaultParserService parserService;
+		IClass topLevelClass;
+		IClass currentClass  = null;
+		Queue  baseTypeQueue = new Queue();
+		IProject project;
+
+		internal ClassInheritanceEnumerator(DefaultParserService parserService, IProject project, IClass topLevelClass)
+		{
+			this.parserService = parserService;
+			this.project = project;
+			this.topLevelClass = topLevelClass;
+			baseTypeQueue.Enqueue(topLevelClass.FullyQualifiedName);
+			PutBaseClassesOnStack(topLevelClass);
+			baseTypeQueue.Enqueue(&quot;System.Object&quot;);
+		}
+		public IEnumerator GetEnumerator()
+		{
+			return this;
+		}
+
+		void PutBaseClassesOnStack(IClass c)
+		{
+			foreach (string baseTypeName in c.BaseTypes)
+				baseTypeQueue.Enqueue(baseTypeName);
+		}
+
+		public IClass Current {
+			get {
+				return currentClass;
+			}
+		}
+
+		object IEnumerator.Current {
+			get {
+				return currentClass;
+			}
+		}
+
+		public bool MoveNext()
+		{
+			if (baseTypeQueue.Count == 0) {
+				return false;
+			}
+			string baseTypeName = baseTypeQueue.Dequeue().ToString();
+
+			IClass baseType = parserService.DeepGetClass (project, baseTypeName, true);
+			if (baseType == null) {
+				ICompilationUnit unit = currentClass == null ? null : currentClass.CompilationUnit;
+				if (unit != null) {
+					foreach (IUsing u in unit.Usings) {
+						baseType = parserService.SearchType(project, u, baseTypeName);
+						if (baseType != null) {
+							break;
+						}
+					}
+				}
+			}
+
+			if (baseType != null) {
+				currentClass = baseType;
+				PutBaseClassesOnStack(currentClass);
+			}
+			
+			return baseType != null;
+		}
+
+		public void Reset()
+		{
+			baseTypeQueue.Clear();
+			baseTypeQueue.Enqueue(topLevelClass.FullyQualifiedName);
+			PutBaseClassesOnStack(topLevelClass);
+			baseTypeQueue.Enqueue(&quot;System.Object&quot;);
+		}
+	}	
+	
+	public class ClassUpdateInformation
+	{
+		ClassCollection added = new ClassCollection ();
+		ClassCollection removed = new ClassCollection ();
+		ClassCollection modified = new ClassCollection ();
+		
+		public ClassCollection Added
+		{
+			get { return added; }
+		}
+		
+		public ClassCollection Removed
+		{
+			get { return removed; }
+		}
+		
+		public ClassCollection Modified
+		{
+			get { return modified; }
+		}
+	}
+	
+	public interface ITypeResolver
+	{
+		string Resolve (string typeName);
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/IParserService.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/IParserService.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/IParserService.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,88 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Collections;
+using System.Diagnostics;
+using System.IO;
+
+using MonoDevelop.Core.AddIns;
+
+using MonoDevelop.Internal.Parser;
+using MonoDevelop.Internal.Project;
+
+using MonoDevelop.Gui;
+
+namespace MonoDevelop.Services
+{
+	public interface IParseInformation
+	{
+		ICompilationUnitBase ValidCompilationUnit {
+			get;
+		}
+		ICompilationUnitBase DirtyCompilationUnit {
+			get;
+		}
+
+		ICompilationUnitBase BestCompilationUnit {
+			get;
+		}
+
+		ICompilationUnitBase MostRecentCompilationUnit {
+			get;
+		}
+	}
+
+	public interface IParserService
+	{
+		IParseInformation ParseFile(string fileName);
+		IParseInformation ParseFile(string fileName, string fileContent);
+		
+		IParseInformation GetParseInformation(string fileName);
+		
+		IParser GetParser(string fileName);
+		IExpressionFinder GetExpressionFinder(string fileName);
+		
+		// Default Parser Layer dependent functions
+		IClass    GetClass(IProject project, string typeName);
+		string[]  GetNamespaceList(IProject project, string subNameSpace);
+		ArrayList GetNamespaceContents(IProject project, string subNameSpace, bool includeReferences);
+		bool      NamespaceExists(IProject project, string name);
+		string    SearchNamespace(IProject project, IUsing iusing, string partitialNamespaceName);
+		IClass    SearchType(IProject project, IUsing iusing, string partitialTypeName);
+		
+		IClass    GetClass(IProject project, string typeName, bool deepSearchReferences, bool caseSensitive);
+		string[]  GetNamespaceList(IProject project, string subNameSpace, bool caseSensitive);
+		ArrayList GetNamespaceContents(IProject project, string subNameSpace, bool includeReferences, bool caseSensitive);
+		bool      NamespaceExists(IProject project, string name, bool caseSensitive);
+		string    SearchNamespace(IProject project, IUsing iusing, string partitialNamespaceName, bool caseSensitive);
+		IClass    SearchType(IProject project, IUsing iusing, string partitialTypeName, bool caseSensitive);
+		IClass    SearchType (IProject project, string name, IClass callingClass, ICompilationUnit unit);
+		
+		IEnumerable GetClassInheritanceTree (IProject project, IClass cls);
+		
+		////////////////////////////////////////////
+
+		/// &lt;summary&gt;
+		/// Resolves an expression.
+		/// The caretLineNumber and caretColumn is 1 based.
+		/// &lt;/summary&gt;
+		ResolveResult Resolve(IProject project,
+							  string expression,
+		                      int caretLineNumber,
+		                      int caretColumn,
+		                      string fileName,
+		                      string fileContent);
+		string MonodocResolver (IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+		ArrayList IsAsResolve (IProject project, string expression, int caretLineNumber, int caretColumn, string fileName, string fileContent);
+		ArrayList CtrlSpace(IParserService parserService, IProject project, int caretLine, int caretColumn, string fileName);
+		string LoadAssemblyFromGac (string name);
+
+		event ParseInformationEventHandler ParseInformationChanged;
+		event ClassInformationEventHandler ClassInformationChanged;
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ParseInformation.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ParseInformation.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ParserService/ParseInformation.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,68 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Collections;
+using System.Diagnostics;
+using System.Reflection;
+using System.Runtime.Serialization;
+using System.Runtime.Serialization.Formatters;
+using System.Runtime.Serialization.Formatters.Binary;
+using System.Xml;
+
+using MonoDevelop.Core.Properties;
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Internal.Project;
+using MonoDevelop.Gui;
+using MonoDevelop.Internal.Parser;
+
+namespace MonoDevelop.Services
+{
+	/// &lt;summary&gt;
+	/// 
+	/// 
+	/// &lt;/summary&gt;
+	public class ParseInformation : IParseInformation
+	{
+		ICompilationUnitBase validCompilationUnit;
+		ICompilationUnitBase dirtyCompilationUnit;
+		
+		public ICompilationUnitBase ValidCompilationUnit {
+			get {
+				return validCompilationUnit;
+			}
+			set {
+				validCompilationUnit = value;
+			}
+		}
+		
+		public ICompilationUnitBase DirtyCompilationUnit {
+			get {
+				return dirtyCompilationUnit;
+			}
+			set {
+				dirtyCompilationUnit = value;
+			}
+		}
+		
+		public ICompilationUnitBase BestCompilationUnit {
+			get {
+				return validCompilationUnit == null ? dirtyCompilationUnit : validCompilationUnit;
+			}
+		}
+		
+		public ICompilationUnitBase MostRecentCompilationUnit {
+			get {
+				return dirtyCompilationUnit == null ? validCompilationUnit : dirtyCompilationUnit;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentClass.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentClass.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentClass.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,225 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using System;
+using System.Diagnostics;
+using System.IO;
+using System.Reflection;
+using System.Collections;
+using System.Collections.Specialized;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public sealed class PersistentClass : AbstractClass
+	{
+		public override ICompilationUnit CompilationUnit {
+			get {
+				return null;
+			}
+		}
+
+		public static PersistentClass Resolve (IClass sclass, ITypeResolver typeResolver)
+		{
+			PersistentClass cls = new PersistentClass ();
+			
+			cls.FullyQualifiedName = sclass.FullyQualifiedName;
+			cls.Documentation = sclass.Documentation;
+			
+			cls.modifiers          = sclass.Modifiers;
+			cls.classType          = sclass.ClassType;
+
+			foreach (string t in sclass.BaseTypes)
+				cls.baseTypes.Add (typeResolver.Resolve (t));
+			
+			foreach (IClass c in sclass.InnerClasses)
+				cls.innerClasses.Add (PersistentClass.Resolve (c,typeResolver));
+
+			foreach (IField f in sclass.Fields)
+				cls.fields.Add (PersistentField.Resolve (f, typeResolver));
+
+			foreach (IProperty p in sclass.Properties)
+				cls.properties.Add (PersistentProperty.Resolve (p, typeResolver));
+
+			foreach (IMethod m in sclass.Methods)
+				cls.methods.Add (PersistentMethod.Resolve (m, typeResolver));
+
+			foreach (IEvent e in sclass.Events)
+				cls.events.Add (PersistentEvent.Resolve (e, typeResolver));
+
+			foreach (IIndexer i in sclass.Indexer)
+				cls.indexer.Add (PersistentIndexer.Resolve (i, typeResolver));
+			
+			cls.region = sclass.Region;
+			return cls;
+		}
+		
+		public static PersistentClass Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			PersistentClass cls = new PersistentClass ();
+			
+			cls.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			cls.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			
+			cls.modifiers          = (ModifierEnum)reader.ReadUInt32();
+			cls.classType          = (ClassType)reader.ReadInt16();
+
+			uint count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				cls.baseTypes.Add (PersistentHelper.ReadString (reader, nameTable));
+			}
+			
+			count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				cls.innerClasses.Add(PersistentClass.Read (reader, nameTable));
+			}
+
+			count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				cls.fields.Add(PersistentField.Read (reader, nameTable));
+			}
+
+			count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				cls.properties.Add(PersistentProperty.Read (reader, nameTable));
+			}
+
+			count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				IMethod m = PersistentMethod.Read (reader, nameTable);
+				cls.methods.Add(m);
+			}
+
+			count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				cls.events.Add(PersistentEvent.Read (reader, nameTable));
+			}
+
+			count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				cls.indexer.Add(PersistentIndexer.Read (reader, nameTable));
+			}
+			
+			cls.region = PersistentRegion.Read (reader, nameTable);
+			return cls;
+		}
+
+		public static void WriteTo (IClass cls, BinaryWriter writer, INameEncoder nameTable)
+		{
+			PersistentHelper.WriteString (cls.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (cls.Documentation, writer, nameTable);
+				
+			writer.Write((uint)cls.Modifiers);
+			writer.Write((short)cls.ClassType);
+
+			writer.Write((uint)(cls.BaseTypes.Count));
+			foreach (string baseType in cls.BaseTypes)
+				PersistentHelper.WriteString (baseType, writer, nameTable);
+
+			writer.Write((uint)cls.InnerClasses.Count);
+			foreach (IClass innerClass in cls.InnerClasses) {
+				PersistentClass.WriteTo (innerClass, writer, nameTable);
+			}
+
+			writer.Write((uint)cls.Fields.Count);
+			foreach (IField field in cls.Fields) {
+				PersistentField.WriteTo (field, writer, nameTable);
+			}
+
+			writer.Write((uint)cls.Properties.Count);
+			foreach (IProperty property in cls.Properties) {
+				PersistentProperty.WriteTo (property, writer, nameTable);
+			}
+
+			writer.Write((uint)cls.Methods.Count);
+			foreach (IMethod method in cls.Methods) {
+				PersistentMethod.WriteTo (method, writer, nameTable);
+			}
+
+			writer.Write((uint)cls.Events.Count);
+			foreach (IEvent e in cls.Events) {
+				PersistentEvent.WriteTo (e, writer, nameTable);
+			}
+
+			writer.Write((uint)cls.Indexer.Count);
+			foreach (IIndexer ind in cls.Indexer) {
+				PersistentIndexer.WriteTo (ind, writer, nameTable);
+			}
+			
+			PersistentRegion.WriteTo (cls.Region, writer, nameTable);
+		}
+	}
+	
+	public class PersistentRegion: DefaultRegion
+	{
+		public PersistentRegion (): base (-1,-1)
+		{
+		}
+		
+		public static PersistentRegion Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			if (PersistentHelper.ReadNull (reader)) return null;
+			
+			PersistentRegion reg = new PersistentRegion ();
+			reg.FileName = PersistentHelper.ReadString (reader, nameTable);
+			reg.beginLine = reader.ReadInt32 ();
+			reg.endLine = reader.ReadInt32 ();
+			reg.beginColumn = reader.ReadInt32 ();
+			reg.endColumn = reader.ReadInt32 ();
+			return reg;
+		}
+		
+		public static void WriteTo (IRegion reg, BinaryWriter writer, INameEncoder nameTable)
+		{
+			if (PersistentHelper.WriteNull (reg, writer)) return;
+			
+			PersistentHelper.WriteString (reg.FileName, writer, nameTable);
+			writer.Write (reg.BeginLine);
+			writer.Write (reg.BeginColumn);
+			writer.Write (reg.EndColumn);
+			writer.Write (reg.EndLine);
+		}
+	}
+	
+	public class PersistentHelper
+	{
+		public static void WriteString (string s, BinaryWriter writer, INameEncoder nameTable)
+		{
+			if (s == null)
+				writer.Write (-2);
+			else {
+				int id = nameTable.GetStringId (s);
+				writer.Write (id);
+				if (id == -1)
+					writer.Write (s);
+			}
+		}
+		
+		public static string ReadString (BinaryReader reader, INameDecoder nameTable)
+		{
+			int id = reader.ReadInt32 ();
+			if (id == -1)
+				return reader.ReadString ();
+			else if (id == -2)
+				return null;
+			else
+				return nameTable.GetStringValue (id);
+		}
+		
+		public static bool WriteNull (object ob, BinaryWriter writer)
+		{
+			writer.Write (ob==null);
+			return ob==null;
+		}
+		
+		public static bool ReadNull (BinaryReader reader)
+		{
+			return reader.ReadBoolean ();
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentEvent.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentEvent.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentEvent.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,48 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.IO;
+using System.Reflection;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public sealed class PersistentEvent : AbstractEvent
+	{
+		public static PersistentEvent Resolve (IEvent source, ITypeResolver typeResolver)
+		{
+			PersistentEvent ev = new PersistentEvent();
+			ev.FullyQualifiedName = source.FullyQualifiedName;
+			ev.Documentation = source.Documentation;
+			ev.modifiers = source.Modifiers;
+			ev.returnType = PersistentReturnType.Resolve (source.ReturnType, typeResolver);
+			ev.region = source.Region;
+			return ev;
+		}
+		
+		public static PersistentEvent Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			PersistentEvent ev = new PersistentEvent();
+			ev.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			ev.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			ev.modifiers = (ModifierEnum)reader.ReadUInt32();
+			ev.returnType = PersistentReturnType.Read (reader, nameTable);
+			ev.region = PersistentRegion.Read (reader, nameTable);
+			return ev;
+		}
+
+		public static void WriteTo (IEvent ev, BinaryWriter writer, INameEncoder nameTable)
+		{
+			PersistentHelper.WriteString (ev.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (ev.Documentation, writer, nameTable);
+			writer.Write ((uint)ev.Modifiers);
+			PersistentReturnType.WriteTo (ev.ReturnType, writer, nameTable);
+			PersistentRegion.WriteTo (ev.Region, writer, nameTable);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentField.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentField.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentField.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,48 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.IO;
+using System.Reflection;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public sealed class PersistentField : AbstractField
+	{
+		public static PersistentField Resolve (IField source, ITypeResolver typeResolver)
+		{
+			PersistentField field = new PersistentField ();
+			field.FullyQualifiedName = source.FullyQualifiedName;
+			field.Documentation = source.Documentation;
+			field.modifiers = source.Modifiers;
+			field.returnType = PersistentReturnType.Resolve (source.ReturnType, typeResolver);
+			field.region = source.Region;
+			return field;
+		}
+		
+		public static PersistentField Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			PersistentField field = new PersistentField ();
+			field.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			field.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			field.modifiers = (ModifierEnum)reader.ReadUInt32();
+			field.returnType = PersistentReturnType.Read (reader, nameTable);
+			field.region = PersistentRegion.Read (reader, nameTable);
+			return field;
+		}
+		
+		public static void WriteTo (IField field, BinaryWriter writer, INameEncoder nameTable)
+		{
+			PersistentHelper.WriteString (field.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (field.Documentation, writer, nameTable);
+			writer.Write ((uint)field.Modifiers);
+			PersistentReturnType.WriteTo (field.ReturnType, writer, nameTable);
+			PersistentRegion.WriteTo (field.Region, writer, nameTable);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentIndexer.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentIndexer.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentIndexer.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,63 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.IO;
+using System.Reflection;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public sealed class PersistentIndexer : AbstractIndexer
+	{
+		public static PersistentIndexer Resolve (IIndexer source, ITypeResolver typeResolver)
+		{
+			PersistentIndexer ind = new PersistentIndexer();
+			ind.FullyQualifiedName = source.FullyQualifiedName;
+			ind.Documentation = source.Documentation;
+			ind.modifiers = source.Modifiers;
+			ind.returnType = PersistentReturnType.Resolve (source.ReturnType, typeResolver);
+
+			foreach (IParameter p in source.Parameters)
+				ind.parameters.Add (PersistentParameter.Resolve (p, typeResolver));
+
+			ind.region = source.Region;
+			return ind;
+		}
+		
+		public static PersistentIndexer Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			PersistentIndexer ind = new PersistentIndexer();
+			ind.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			ind.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			ind.modifiers = (ModifierEnum)reader.ReadUInt32();
+			ind.returnType = PersistentReturnType.Read (reader, nameTable);
+			
+			uint count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				ind.parameters.Add (PersistentParameter.Read (reader, nameTable));
+			}
+			ind.region = PersistentRegion.Read (reader, nameTable);
+			return ind;
+		}
+		
+		public static void WriteTo (IIndexer ind, BinaryWriter writer, INameEncoder nameTable)
+		{
+			PersistentHelper.WriteString (ind.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (ind.Documentation, writer, nameTable);
+			
+			writer.Write((uint)ind.Modifiers);
+			PersistentReturnType.WriteTo (ind.ReturnType, writer, nameTable);
+			
+			writer.Write ((uint)ind.Parameters.Count);
+			foreach (IParameter p in ind.Parameters) {
+				PersistentParameter.WriteTo (p, writer, nameTable);
+			}
+			PersistentRegion.WriteTo (ind.Region, writer, nameTable);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentMethod.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentMethod.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentMethod.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,65 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.IO;
+
+using System.Reflection;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public sealed class PersistentMethod : AbstractMethod
+	{
+		public static PersistentMethod Resolve (IMethod source, ITypeResolver typeResolver)
+		{
+			PersistentMethod met = new PersistentMethod ();
+			met.FullyQualifiedName = source.FullyQualifiedName;
+			met.Documentation = source.Documentation;
+			met.modifiers = source.Modifiers;
+			met.returnType = PersistentReturnType.Resolve (source.ReturnType, typeResolver);
+			
+			foreach (IParameter p in source.Parameters)
+				met.parameters.Add (PersistentParameter.Resolve (p, typeResolver));
+
+			met.region = source.Region;
+			return met;
+		}
+		
+		public static PersistentMethod Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			PersistentMethod met = new PersistentMethod ();
+			met.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			met.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			
+			met.modifiers = (ModifierEnum)reader.ReadUInt32();
+			met.returnType = PersistentReturnType.Read (reader, nameTable);
+			
+			uint count = reader.ReadUInt32();
+			for (uint i = 0; i &lt; count; ++i) {
+				met.parameters.Add (PersistentParameter.Read (reader, nameTable));
+			}
+			met.region = PersistentRegion.Read (reader, nameTable);
+			return met;
+		}
+		
+		public static void WriteTo (IMethod met, BinaryWriter writer, INameEncoder nameTable)
+		{
+			PersistentHelper.WriteString (met.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (met.Documentation, writer, nameTable);
+			
+			writer.Write ((uint)met.Modifiers);
+			PersistentReturnType.WriteTo (met.ReturnType, writer, nameTable);
+			
+			writer.Write (met.Parameters != null ? (uint)met.Parameters.Count : (uint)0);
+			foreach (IParameter p in met.Parameters) {
+				PersistentParameter.WriteTo (p, writer, nameTable);
+			}
+			PersistentRegion.WriteTo (met.Region, writer, nameTable);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentParameter.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentParameter.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentParameter.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,45 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.IO;
+using System.Reflection;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public sealed class PersistentParameter : AbstractParameter
+	{
+		public static PersistentParameter Resolve (IParameter source, ITypeResolver typeResolver)
+		{
+			PersistentParameter par = new PersistentParameter ();
+			par.name = source.Name;
+			par.documentation = source.Documentation;
+			par.modifier = source.Modifier;
+			par.returnType = PersistentReturnType.Resolve (source.ReturnType, typeResolver);
+			return par;
+		}
+		
+		public static PersistentParameter Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			PersistentParameter par = new PersistentParameter ();
+			par.name = PersistentHelper.ReadString (reader, nameTable);
+			par.documentation = PersistentHelper.ReadString (reader, nameTable);
+			par.modifier = (ParameterModifier)reader.ReadByte();
+			par.returnType = PersistentReturnType.Read (reader, nameTable);
+			return par;
+		}
+		
+		public static void WriteTo (IParameter p, BinaryWriter writer, INameEncoder nameTable)
+		{
+			PersistentHelper.WriteString (p.Name, writer, nameTable);
+			PersistentHelper.WriteString (p.Documentation, writer, nameTable);
+			writer.Write((byte)p.Modifier);
+			PersistentReturnType.WriteTo (p.ReturnType, writer, nameTable);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentProperty.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentProperty.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentProperty.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,71 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.IO;
+using System.Reflection;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public sealed class PersistentProperty : AbstractProperty
+	{
+		const uint canGetFlag = (uint)(1 &lt;&lt; 29);
+		const uint canSetFlag = (uint)(1 &lt;&lt; 30);
+		
+		bool canGet = false;
+		bool canSet = false;
+		
+		public override bool CanGet {
+			get {
+				return canGet;
+			}
+		}
+		
+		public override bool CanSet {
+			get {
+				return canSet;
+			}
+		}
+		
+		public static PersistentProperty Resolve (IProperty source, ITypeResolver typeResolver)
+		{
+			PersistentProperty pro = new PersistentProperty ();
+			pro.FullyQualifiedName = source.FullyQualifiedName;
+			pro.Documentation = source.Documentation;
+			pro.modifiers = source.Modifiers;
+			pro.returnType = PersistentReturnType.Resolve (source.ReturnType, typeResolver);
+			pro.canGet = source.CanGet;
+			pro.canSet = source.CanSet;
+			pro.region = source.Region;
+			return pro;
+		}
+		
+		public static PersistentProperty Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			PersistentProperty pro = new PersistentProperty ();
+			pro.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+			pro.Documentation = PersistentHelper.ReadString (reader, nameTable);
+			uint m = reader.ReadUInt32();
+			pro.modifiers = (ModifierEnum)(m &amp; (canGetFlag - 1));
+			pro.canGet = (m &amp; canGetFlag) == canGetFlag;
+			pro.canSet = (m &amp; canSetFlag) == canSetFlag;
+			pro.returnType = PersistentReturnType.Read (reader, nameTable);
+			pro.region = PersistentRegion.Read (reader, nameTable);
+			return pro;
+		}
+		
+		public static void WriteTo (IProperty p, BinaryWriter writer, INameEncoder nameTable)
+		{
+			PersistentHelper.WriteString (p.FullyQualifiedName, writer, nameTable);
+			PersistentHelper.WriteString (p.Documentation, writer, nameTable);
+			writer.Write((uint)p.Modifiers + (p.CanGet ? canGetFlag : 0) + (p.CanSet ? canSetFlag : 0));
+			PersistentReturnType.WriteTo (p.ReturnType, writer, nameTable);
+			PersistentRegion.WriteTo (p.Region, writer, nameTable);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentReturnType.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentReturnType.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/PersistenceLayer/PersistentReturnType.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,61 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.IO;
+using MonoDevelop.Services;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public sealed class PersistentReturnType : AbstractReturnType
+	{
+		public static PersistentReturnType Resolve (IReturnType source, ITypeResolver typeResolver)
+		{
+			if (source == null) return null;
+			
+			PersistentReturnType rt = new PersistentReturnType ();
+			rt.FullyQualifiedName = typeResolver.Resolve (source.FullyQualifiedName);
+			rt.pointerNestingLevel = source.PointerNestingLevel;
+			rt.arrayDimensions = source.ArrayDimensions;
+			return rt;
+		}
+
+		public static PersistentReturnType Read (BinaryReader reader, INameDecoder nameTable)
+		{
+			if (PersistentHelper.ReadNull (reader)) return null;
+			
+			PersistentReturnType rt = new PersistentReturnType ();
+			rt.FullyQualifiedName = PersistentHelper.ReadString (reader, nameTable);
+
+			rt.pointerNestingLevel = reader.ReadInt32();
+
+			uint count = reader.ReadUInt32();
+			rt.arrayDimensions = new int[count];
+			for (uint i = 0; i &lt; rt.arrayDimensions.Length; ++i) {
+				rt.arrayDimensions[i] = reader.ReadInt32();
+			}
+			return rt;
+		}
+
+		public static void WriteTo (IReturnType rt, BinaryWriter writer, INameEncoder nameTable)
+		{
+			if (PersistentHelper.WriteNull (rt, writer)) return;
+			
+			PersistentHelper.WriteString (rt.FullyQualifiedName, writer, nameTable);
+
+			writer.Write (rt.PointerNestingLevel);
+			if (rt.ArrayDimensions == null) {
+				writer.Write((uint)0);
+			} else {
+				writer.Write((uint)rt.ArrayDimensions.Length);
+				for (uint i = 0; i &lt; rt.ArrayDimensions.Length; ++i) {
+					writer.Write (rt.ArrayDimensions[i]);
+				}
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionClass.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionClass.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionClass.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,182 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+
+using MonoDevelop.Services;
+using MonoDevelop.Core.Services;
+
+using System;
+using System.Collections;
+using System.Xml;
+using System.Reflection;
+using System.Collections.Specialized;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class ReflectionClass : AbstractClass
+	{
+		BindingFlags flags = BindingFlags.Instance  | 
+		                     BindingFlags.Static    | 
+//		                     BindingFlags.DeclaredOnly |
+		                     BindingFlags.NonPublic |
+		                     BindingFlags.Public;
+		
+		/// &lt;value&gt;
+		/// A reflection class doesn't have a compilation unit (because
+		/// it is not parsed the information is gathered using reflection)
+		/// &lt;/value&gt;
+		public override ICompilationUnit CompilationUnit {
+			get {
+				return null;
+			}
+		}
+		
+		public static bool IsDelegate(Type type)
+		{
+			return type.IsSubclassOf(typeof(Delegate)) &amp;&amp; type != typeof(MulticastDelegate);
+		}
+		
+		public ReflectionClass(Type type)
+		{
+
+			if (type == null)
+				type = Type.GetType (&quot;System.Object&quot;);
+			
+
+			FullyQualifiedName = type.FullName;
+
+			MonodocService docservice = ((MonodocService)ServiceManager.GetService (typeof (MonodocService)));
+			XmlDocument docs = docservice != null ? docservice.GetHelpXml (FullyQualifiedName) : null;
+			if (docs != null) {
+				XmlNode node = docs.SelectSingleNode (&quot;/Type/Docs/summary&quot;);
+				if (node != null) {
+					Documentation = node.InnerXml;
+				}
+			}
+			
+			FullyQualifiedName = FullyQualifiedName.Replace(&quot;+&quot;, &quot;.&quot;);
+			
+			// set classtype
+			if (IsDelegate(type)) {
+				classType = ClassType.Delegate;
+				MethodInfo invoke          = type.GetMethod(&quot;Invoke&quot;);
+				ReflectionMethod newMethod = new ReflectionMethod(invoke, null);
+				methods.Add(newMethod);
+			} else if (type.IsInterface) {
+				classType = ClassType.Interface;
+			} else if (type.IsEnum) {
+				classType = ClassType.Enum;
+			} else if (type.IsValueType) {
+				classType = ClassType.Struct;
+			} else {
+				classType = ClassType.Class;
+			}
+			
+			modifiers = ModifierEnum.None;
+			
+			if (type.IsNestedAssembly) {
+				modifiers |= ModifierEnum.Internal;
+			}
+			
+			if (type.IsSealed) {
+				modifiers |= ModifierEnum.Sealed;
+			}
+			if (type.IsAbstract) {
+				modifiers |= ModifierEnum.Abstract;
+			}
+			
+			if (type.IsNestedPrivate ) { // I assume that private is used most and public last (at least should be)
+				modifiers |= ModifierEnum.Private;
+			} else if (type.IsNestedFamily ) {
+				modifiers |= ModifierEnum.Protected;
+			} else if (type.IsNestedPublic || type.IsPublic) {
+				modifiers |= ModifierEnum.Public;
+			} else if (type.IsNotPublic) {
+				modifiers |= ModifierEnum.Internal;
+			} else if (type.IsNestedFamORAssem) {
+				modifiers |= ModifierEnum.ProtectedOrInternal;
+			} else if (type.IsNestedFamANDAssem) {
+				modifiers |= ModifierEnum.Protected;
+				modifiers |= ModifierEnum.Internal;
+			}
+			
+			// set base classes
+			if (type.BaseType != null) { // it's null for System.Object ONLY !!!
+				baseTypes.Add(type.BaseType.FullName);
+			}
+			
+			if (classType != ClassType.Delegate) {
+				// add members
+				foreach (Type iface in type.GetInterfaces()) {
+					baseTypes.Add(iface.FullName);
+				}
+				
+				foreach (Type nestedType in type.GetNestedTypes(flags)) {
+					innerClasses.Add(new ReflectionClass(nestedType));
+				}
+				
+				foreach (FieldInfo field in type.GetFields(flags)) {
+//					if (!field.IsSpecialName) {
+					IField newField = new ReflectionField(field, docs);
+					if (!newField.IsInternal) {
+						fields.Add(newField);
+					}
+//					}
+				}
+				
+				foreach (PropertyInfo propertyInfo in type.GetProperties(flags)) {
+//					if (!propertyInfo.IsSpecialName) {
+					ParameterInfo[] p = null;
+					
+					// we may not get the permission to access the index parameters
+					try {
+						p = propertyInfo.GetIndexParameters();
+					} catch (Exception) {}
+					if (p == null || p.Length == 0) {
+						IProperty newProperty = new ReflectionProperty(propertyInfo, docs);
+						if (!newProperty.IsInternal) {
+							properties.Add(newProperty);
+						}
+					} else {
+						IIndexer newIndexer = new ReflectionIndexer(propertyInfo, docs);
+						if (!newIndexer.IsInternal) {
+							indexer.Add(newIndexer);
+						}
+					}
+//					}
+				}
+				
+				foreach (MethodInfo methodInfo in type.GetMethods(flags)) {
+					if (!methodInfo.IsSpecialName) {
+						IMethod newMethod = new ReflectionMethod(methodInfo, docs);
+						
+						if (!newMethod.IsInternal) {
+							methods.Add(newMethod);
+						}
+					}
+				}
+				
+				foreach (ConstructorInfo constructorInfo in type.GetConstructors(flags)) {
+					IMethod newMethod = new ReflectionMethod(constructorInfo, docs);
+					if (!newMethod.IsInternal) {
+						methods.Add(newMethod);
+					}
+				}
+				
+				foreach (EventInfo eventInfo in type.GetEvents(flags)) {
+//					if (!eventInfo.IsSpecialName) {
+					IEvent newEvent = new ReflectionEvent(eventInfo, docs);
+					
+					if (!newEvent.IsInternal) {
+						events.Add(newEvent);
+					}
+//					}
+				}
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionEvent.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionEvent.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionEvent.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,68 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+using System.Reflection;
+using System.Xml;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class ReflectionEvent : AbstractEvent
+	{
+		public ReflectionEvent(EventInfo eventInfo, XmlDocument docs)
+		{
+			FullyQualifiedName = String.Concat(eventInfo.DeclaringType.FullName, &quot;.&quot;, eventInfo.Name);
+
+			if (docs != null) {
+				XmlNode node = docs.SelectSingleNode (&quot;/Type/Members/Member[@MemberName='&quot; + eventInfo.Name + &quot;']/Docs/summary&quot;);
+				if (node != null) {
+					Documentation = node.InnerXml;
+				}
+			}
+
+			// get modifiers
+			MethodInfo methodBase = null;
+			try {
+				methodBase = eventInfo.GetAddMethod(true);
+			} catch (Exception) {}
+			
+			if (methodBase == null) {
+				try {
+					methodBase = eventInfo.GetRemoveMethod(true);
+				} catch (Exception) {}
+			}
+			
+			if (methodBase != null) {
+				if (methodBase.IsStatic) {
+					modifiers |= ModifierEnum.Static;
+				}
+				
+				if (methodBase.IsAssembly) {
+					modifiers |= ModifierEnum.Internal;
+				}
+				
+				if (methodBase.IsPrivate) { // I assume that private is used most and public last (at least should be)
+					modifiers |= ModifierEnum.Private;
+				} else if (methodBase.IsFamily) {
+					modifiers |= ModifierEnum.Protected;
+				} else if (methodBase.IsPublic) {
+					modifiers |= ModifierEnum.Public;
+				} else if (methodBase.IsFamilyOrAssembly) {
+					modifiers |= ModifierEnum.ProtectedOrInternal;
+				} else if (methodBase.IsFamilyAndAssembly) {
+					modifiers |= ModifierEnum.Protected;
+					modifiers |= ModifierEnum.Internal;
+				}
+			} else { // assume public property, if no methodBase could be get.
+				modifiers = ModifierEnum.Public;
+			}
+			
+			returnType = new ReflectionReturnType(eventInfo.EventHandlerType );			
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionField.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionField.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionField.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,62 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+using System.Diagnostics;
+using System.Reflection;
+using System.Xml;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class ReflectionField : AbstractField
+	{
+		public ReflectionField(FieldInfo fieldInfo, XmlDocument docs)
+		{
+			System.Diagnostics.Debug.Assert(fieldInfo != null);
+			FullyQualifiedName = String.Concat(fieldInfo.DeclaringType.FullName, &quot;.&quot;, fieldInfo.Name);
+
+			if (docs != null) {
+				XmlNode node = docs.SelectSingleNode (&quot;/Type/Members/Member[@MemberName='&quot; + fieldInfo.Name + &quot;']/Docs/summary&quot;);
+				if (node != null) {
+					Documentation = node.InnerXml;
+				}
+			}
+			
+			if (fieldInfo.IsInitOnly) {
+				modifiers |= ModifierEnum.Readonly;
+			}
+			
+			if (fieldInfo.IsStatic) {
+				modifiers |= ModifierEnum.Static;
+			}
+			
+			if (fieldInfo.IsAssembly) {
+				modifiers |= ModifierEnum.Internal;
+			}
+			
+			if (fieldInfo.IsPrivate) { // I assume that private is used most and public last (at least should be)
+				modifiers |= ModifierEnum.Private;
+			} else if (fieldInfo.IsFamily) {
+				modifiers |= ModifierEnum.Protected;
+			} else if (fieldInfo.IsPublic) {
+				modifiers |= ModifierEnum.Public;
+			} else if (fieldInfo.IsFamilyOrAssembly) {
+				modifiers |= ModifierEnum.ProtectedOrInternal;
+			} else if (fieldInfo.IsFamilyAndAssembly) {
+				modifiers |= ModifierEnum.Protected;
+				modifiers |= ModifierEnum.Internal;
+			}
+			
+			if (fieldInfo.IsLiteral) {
+				modifiers |= ModifierEnum.Const;
+			}
+			
+			returnType = new ReflectionReturnType(fieldInfo.FieldType);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionIndexer.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionIndexer.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionIndexer.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,105 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+using System.Text;
+using System.Reflection;
+using System.Xml;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class ReflectionIndexer : AbstractIndexer
+	{
+		string GetIndexerName(PropertyInfo propertyInfo)
+		{
+			StringBuilder propertyName = new StringBuilder(&quot;Item(&quot;);
+			ParameterInfo[] p = propertyInfo.GetIndexParameters();
+			for (int i = 0; i &lt; p.Length; ++i) {
+				propertyName.Append(p[i].ParameterType.FullName);
+				if (i + 1 &lt; p.Length) {
+					propertyName.Append(',');
+				}
+			}
+			propertyName.Append(')');
+			return propertyName.ToString();
+		}
+		
+		public ReflectionIndexer(PropertyInfo propertyInfo, XmlDocument docs)
+		{
+			// indexers does have the same name as the object that declare the indexers
+			FullyQualifiedName = propertyInfo.DeclaringType.FullName;
+			
+			// show the abstract layer that we have getter &amp; setters
+			if (propertyInfo.CanRead) {
+				getterRegion = new DefaultRegion(0, 0, 0, 0);
+			} else {
+				getterRegion = null;
+			}
+			
+			if (propertyInfo.CanWrite) {
+				setterRegion = new DefaultRegion(0, 0, 0, 0);
+			} else {
+				setterRegion = null;
+			}
+
+			XmlNode node = null;
+			if (docs != null) {
+				node = docs.SelectSingleNode (&quot;/Type/Members/Member[@MemberName='&quot; + propertyInfo.Name + &quot;']&quot;);
+				if (node != null) {
+					XmlNode docNode = node.SelectSingleNode (&quot;Docs/summary&quot;);
+					if (docNode != null) {
+						Documentation = node.InnerXml;
+					}
+				}
+			}
+			
+			returnType = new ReflectionReturnType(propertyInfo.PropertyType);
+			
+			MethodInfo methodBase = null;
+			try {
+				methodBase = propertyInfo.GetGetMethod(true);
+			} catch (Exception) {}
+			
+			if (methodBase == null) {
+				try {
+					methodBase = propertyInfo.GetSetMethod(true);
+				} catch (Exception) {}
+			}
+			
+			if (methodBase != null) {
+				if (methodBase.IsStatic) {
+					modifiers |= ModifierEnum.Static;
+				}
+				
+				if (methodBase.IsAssembly) {
+					modifiers |= ModifierEnum.Internal;
+				}
+				
+				if (methodBase.IsPrivate) { // I assume that private is used most and public last (at least should be)
+					modifiers |= ModifierEnum.Private;
+				} else if (methodBase.IsFamily) {
+					modifiers |= ModifierEnum.Protected;
+				} else if (methodBase.IsPublic) {
+					modifiers |= ModifierEnum.Public;
+				} else if (methodBase.IsFamilyOrAssembly) {
+					modifiers |= ModifierEnum.ProtectedOrInternal;
+				} else if (methodBase.IsFamilyAndAssembly) {
+					modifiers |= ModifierEnum.Protected;
+					modifiers |= ModifierEnum.Internal;
+				}
+			} else { // assume public property, if no methodBase could be get.
+				modifiers = ModifierEnum.Public;
+			}
+			
+			ParameterInfo[] p = propertyInfo.GetIndexParameters();
+			foreach (ParameterInfo parameterInfo in p) {
+				parameters.Add(new ReflectionParameter(parameterInfo, node));
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionMethod.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionMethod.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionMethod.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,122 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Text;
+using System.Collections;
+using System.Reflection;
+using System.Xml;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class ReflectionMethod : AbstractMethod 
+	{
+		string GetParamList(MethodBase methodBase)
+		{
+			StringBuilder propertyName = new StringBuilder(&quot;(&quot;);
+			ParameterInfo[] p = methodBase.GetParameters();
+			if (p.Length == 0) {
+				return String.Empty;
+			}
+			for (int i = 0; i &lt; p.Length; ++i) {
+				propertyName.Append(p[i].ParameterType.FullName);
+				if (i + 1 &lt; p.Length) {
+					propertyName.Append(',');
+				}
+			}
+			propertyName.Append(')');
+			return propertyName.ToString();
+		}
+
+		XmlNode FindMatch (XmlNodeList nodes, MethodBase methodBase)
+		{
+			ParameterInfo[] p = methodBase.GetParameters ();
+			string s = &quot;&quot;;
+			foreach (XmlNode node in nodes) {
+				XmlNodeList paramList = node.SelectNodes (&quot;Parameters/*&quot;);
+				s += paramList.Count + &quot; - &quot; + p.Length + &quot;\n&quot;;
+				if (p.Length == 0 &amp;&amp; paramList.Count == 0) return node;
+				if (p.Length != paramList.Count) continue;
+				bool matched = true;
+				for (int i = 0; i &lt; p.Length; i++) {
+					if (p[i].ParameterType.ToString () != paramList[i].Attributes[&quot;Type&quot;].Value) {
+						matched = false;
+					}
+				}
+				if (matched)
+					return node;
+			}
+			return null;
+		}
+		
+		public ReflectionMethod(MethodBase methodBase, XmlDocument docs)
+		{
+			string name = methodBase.Name;
+			
+			if (methodBase is ConstructorInfo) {
+				name = &quot;.ctor&quot;;
+			}
+			FullyQualifiedName = String.Concat(methodBase.DeclaringType.FullName, &quot;.&quot;, name);
+			
+			XmlNode node = null;
+
+			if (docs != null) {
+				XmlNodeList nodes = docs.SelectNodes (&quot;/Type/Members/Member[@MemberName='&quot; + name + &quot;']&quot;);
+				if (nodes != null &amp;&amp; nodes.Count &gt; 0) {
+					if (nodes.Count == 1) {
+						node = nodes[0];
+					} else {
+						node = FindMatch (nodes, methodBase);
+					}
+					if (node != null) {
+						XmlNode docNode = node.SelectSingleNode (&quot;Docs/summary&quot;);
+						if (docNode != null) {
+							Documentation = docNode.InnerXml;
+						}
+					}
+				}
+			}	
+			
+			modifiers = ModifierEnum.None;
+			if (methodBase.IsStatic) {
+				modifiers |= ModifierEnum.Static;
+			}
+			if (methodBase.IsAssembly) {
+				modifiers |= ModifierEnum.Internal;
+			}
+			if (methodBase.IsPrivate) { // I assume that private is used most and public last (at least should be)
+				modifiers |= ModifierEnum.Private;
+			} else if (methodBase.IsFamily) {
+				modifiers |= ModifierEnum.Protected;
+			} else if (methodBase.IsPublic) {
+				modifiers |= ModifierEnum.Public;
+			} else if (methodBase.IsFamilyOrAssembly) {
+				modifiers |= ModifierEnum.ProtectedOrInternal;
+			} else if (methodBase.IsFamilyAndAssembly) {
+				modifiers |= ModifierEnum.Protected;
+				modifiers |= ModifierEnum.Internal;
+			}
+			
+			if (methodBase.IsVirtual) {
+				modifiers |= ModifierEnum.Virtual;
+			}
+			if (methodBase.IsAbstract) {
+				modifiers |= ModifierEnum.Abstract;
+			}
+			
+			foreach (ParameterInfo paramInfo in methodBase.GetParameters()) {
+				parameters.Add(new ReflectionParameter(paramInfo, node));
+			}
+			
+			if (methodBase is MethodInfo) {
+				returnType = new ReflectionReturnType(((MethodInfo)methodBase).ReturnType);
+			} else {
+				returnType = null;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionParameter.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionParameter.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionParameter.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,43 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Reflection;
+using System.Xml;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class ReflectionParameter : AbstractParameter
+	{
+		public ReflectionParameter(ParameterInfo parameterInfo, XmlNode methodNode)
+		{
+			name       = parameterInfo.Name;
+			returnType = new ReflectionReturnType(parameterInfo.ParameterType);
+			
+			if (parameterInfo.IsOut) {
+				modifier |= ParameterModifier.Out;
+			}
+			
+			Type type = parameterInfo.ParameterType;
+			if (type.IsArray &amp;&amp; type != typeof(Array) &amp;&amp; Attribute.IsDefined(parameterInfo, typeof(ParamArrayAttribute), true)) {
+				modifier |= ParameterModifier.Params;
+			}
+			
+			// seems there is no other way to determine a ref parameter
+			if (type.Name.EndsWith(&quot;&amp;&quot;)) {
+				modifier |= ParameterModifier.Ref;
+			}
+			
+			if (methodNode != null) {
+				XmlNode paramDocu = methodNode.SelectSingleNode(&quot;Docs/param[@name='&quot; + parameterInfo.Name + &quot;']&quot;);
+				if (paramDocu != null) {
+					documentation = paramDocu.InnerXml;
+				}
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionProperty.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionProperty.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionProperty.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,89 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+using System.Reflection;
+using System.Xml;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class ReflectionProperty : AbstractProperty 
+	{
+		public ReflectionProperty(PropertyInfo propertyInfo, XmlDocument docs)
+		{
+			FullyQualifiedName = String.Concat(propertyInfo.DeclaringType.FullName, &quot;.&quot;, propertyInfo.Name);
+			
+			// show the abstract layer that we have getter &amp; setters
+			if (propertyInfo.CanRead) {
+				getterRegion = new DefaultRegion(0, 0, 0, 0);
+			} else {
+				getterRegion = null;
+			}
+			
+			if (propertyInfo.CanWrite) {
+				setterRegion = new DefaultRegion(0, 0, 0, 0);
+			} else {
+				setterRegion = null;
+			}
+
+			if (docs != null) {
+				XmlNode node = docs.SelectSingleNode (&quot;/Type/Members/Member[@MemberName='&quot; + propertyInfo.Name + &quot;']/Docs/summary&quot;);
+				if (node != null) {
+					Documentation = node.InnerXml;
+				}
+			}
+
+			returnType = new ReflectionReturnType(propertyInfo.PropertyType);
+			
+			MethodInfo methodBase = null;
+			try {
+				methodBase = propertyInfo.GetGetMethod(true);
+			} catch (Exception) {}
+			
+			if (methodBase == null) {
+				try {
+					methodBase = propertyInfo.GetSetMethod(true);
+				} catch (Exception) {}
+			}
+			
+			if (methodBase != null) {
+				if (methodBase.IsStatic) {
+					modifiers |= ModifierEnum.Static;
+				}
+				
+				if (methodBase.IsAssembly) {
+					modifiers |= ModifierEnum.Internal;
+				}
+				
+				if (methodBase.IsPrivate) { // I assume that private is used most and public last (at least should be)
+					modifiers |= ModifierEnum.Private;
+				} else if (methodBase.IsFamily) {
+					modifiers |= ModifierEnum.Protected;
+				} else if (methodBase.IsPublic) {
+					modifiers |= ModifierEnum.Public;
+				} else if (methodBase.IsFamilyOrAssembly) {
+					modifiers |= ModifierEnum.ProtectedOrInternal;
+				} else if (methodBase.IsFamilyAndAssembly) {
+					modifiers |= ModifierEnum.Protected;
+					modifiers |= ModifierEnum.Internal;
+				}
+				
+				if (methodBase.IsVirtual) {
+					modifiers |= ModifierEnum.Virtual;
+				}
+				if (methodBase.IsAbstract) {
+					modifiers |= ModifierEnum.Abstract;
+				}
+				
+			} else { // assume public property, if no methodBase could be get.
+				modifiers = ModifierEnum.Public;
+			}
+			
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionReturnType.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionReturnType.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/ReflectionLayer/ReflectionReturnType.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,49 @@
+// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Mike Kr&#195;&#188;ger&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">mike at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+using System.Collections;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class ReflectionReturnType : AbstractReturnType
+	{
+		public ReflectionReturnType(Type type)
+		{
+			string fullyQualifiedName = type.FullName.Replace(&quot;+&quot;, &quot;.&quot;).Trim('&amp;');
+			
+			while (fullyQualifiedName.EndsWith(&quot;[&quot;) ||
+			       fullyQualifiedName.EndsWith(&quot;]&quot;) ||
+			       fullyQualifiedName.EndsWith(&quot;,&quot;) ||
+			       fullyQualifiedName.EndsWith(&quot;*&quot;)) {
+				fullyQualifiedName = fullyQualifiedName.Substring(0, fullyQualifiedName.Length - 1);
+			}
+			base.FullyQualifiedName = fullyQualifiedName;
+			
+			SetPointerNestingLevel(type);
+			SetArrayDimensions(type);
+			arrayDimensions = (int[])arrays.ToArray(typeof(int));
+		}
+		
+		ArrayList arrays = new ArrayList();
+		void SetArrayDimensions(Type type)
+		{
+			if (type.IsArray &amp;&amp; type != typeof(Array)) {
+				SetArrayDimensions(type.GetElementType());
+				arrays.Insert(0, type.GetArrayRank());
+			}
+		}
+		
+		void SetPointerNestingLevel(Type type)
+		{
+			if (type.IsPointer) {
+				SetPointerNestingLevel(type.GetElementType());
+				++pointerNestingLevel;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/Tag.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/Tag.cs	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/Tag.cs	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,27 @@
+&#239;&#187;&#191;// &lt;file&gt;
+//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt&quot;/">prj:///doc/copyright.txt&quot;/</A>&gt;
+//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt&quot;/">prj:///doc/license.txt&quot;/</A>&gt;
+//     &lt;owner name=&quot;Andrea Paatz&quot; email=&quot;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">andrea at icsharpcode.net</A>&quot;/&gt;
+//     &lt;version value=&quot;$version&quot;/&gt;
+// &lt;/file&gt;
+using System;
+
+namespace MonoDevelop.Internal.Parser
+{
+	[Serializable]
+	public class Tag : Comment
+	{
+		string key;
+		
+		public string Key {
+			get {
+				return key;
+			}
+		}
+		
+		public Tag(string key, IRegion region) : base(region)
+		{
+			this.key = key;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Plugins/Parser/parser.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/Parser/parser.build	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/Parser/parser.build	2004-08-15 21:12:38 UTC (rev 1945)
@@ -0,0 +1,14 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;project name=&quot;monodevelop.plugins.parser&quot; default=&quot;build&quot;&gt;
+    &lt;target name=&quot;build&quot; description=&quot;compiles the source code&quot;&gt;
+        &lt;csc target=&quot;library&quot; output=&quot;${path::combine(plugin.dir, 'parser.dll')}&quot; debug=&quot;${build.debug}&quot;&gt;
+            &lt;sources&gt;
+                &lt;include name=&quot;**/*.cs&quot;/&gt;
+            &lt;/sources&gt;
+            &lt;!-- As with SharpRefactory, the System.Drawing ref is for Point --&gt;
+            &lt;references&gt;
+                &lt;include name=&quot;System.Drawing.dll&quot;/&gt;
+            &lt;/references&gt;
+        &lt;/csc&gt;
+    &lt;/target&gt;
+&lt;/project&gt;

Modified: branches/MonoDevelop-plan-43/src/Plugins/plugins.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Plugins/plugins.build	2004-08-15 12:27:11 UTC (rev 1944)
+++ branches/MonoDevelop-plan-43/src/Plugins/plugins.build	2004-08-15 21:12:38 UTC (rev 1945)
@@ -1,26 +1,28 @@
 &lt;?xml version=&quot;1.0&quot;?&gt;
 &lt;project name=&quot;monodevelop.plugins&quot; default=&quot;build&quot;&gt;
     &lt;property name=&quot;plugin.dir&quot; value=&quot;${path::combine(lib.dir, 'monodevelop')}&quot;/&gt;
-    &lt;property name=&quot;ui.dir&quot; value=&quot;${path::combine(share.dir, 'ui')}&quot;/&gt;
+    &lt;property name=&quot;ui.dir&quot; value=&quot;${path::combine(share.dir, 'ui')}&quot;/&gt;
 
     &lt;!-- cleanup build files --&gt;
     &lt;target name=&quot;clean&quot; description=&quot;remove all files created by the build task&quot;&gt;
         &lt;delete dir=&quot;${plugin.dir}&quot; failonerror=&quot;false&quot;/&gt;
     &lt;/target&gt;
 
-    &lt;!-- build the project --&gt;
+    &lt;!-- build the project --&gt;
     &lt;target name=&quot;build&quot; description=&quot;compiles the source code&quot;&gt;
         &lt;!-- create directories --&gt;
         &lt;mkdir dir=&quot;${plugin.dir}&quot;/&gt;
         &lt;!-- build MonoDevelop.Node assembly --&gt;
-        &lt;nant buildfile=&quot;Node/node.build&quot; target=&quot;build&quot;/&gt;
+        &lt;nant buildfile=&quot;Node/node.build&quot; target=&quot;build&quot;/&gt;
         &lt;!-- build MonoDevelop.Workbench assembly --&gt;
-        &lt;nant buildfile=&quot;Workbench/workbench.build&quot; target=&quot;build&quot;/&gt;
+        &lt;nant buildfile=&quot;Workbench/workbench.build&quot; target=&quot;build&quot;/&gt;
         &lt;!-- build MonoDevelop.Content assembly --&gt;
-        &lt;nant buildfile=&quot;Content/content.build&quot; target=&quot;build&quot;/&gt;
+        &lt;nant buildfile=&quot;Content/content.build&quot; target=&quot;build&quot;/&gt;
         &lt;!-- build MonoDevelop.Editor assembly --&gt;
-        &lt;nant buildfile=&quot;Editor/editor.build&quot; target=&quot;build&quot;/&gt;
+        &lt;nant buildfile=&quot;Editor/editor.build&quot; target=&quot;build&quot;/&gt;
+        &lt;!-- build MonoDevelop.Parser assembly --&gt;
+        &lt;!-- &lt;nant buildfile=&quot;Parser/parser.build&quot; target=&quot;build&quot;/&gt; --&gt;
         &lt;!-- build MonoDevelop.CSharp assembly --&gt;
-        &lt;nant buildfile=&quot;CSharp/csharp.build&quot; target=&quot;build&quot;/&gt;
+        &lt;nant buildfile=&quot;CSharp/csharp.build&quot; target=&quot;build&quot;/&gt;
     &lt;/target&gt;
 &lt;/project&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001551.html">[Monodevelop-patches-list] r1944 - in branches/MonoDevelop-plan-43: . src/Plugins src/Plugins/CSharp src/Plugins/Editor
</A></li>
	<LI>Next message: <A HREF="001553.html">[Monodevelop-patches-list] r1946 - in branches/MonoDevelop-plan-43: . src/Plugins/Content src/Plugins/Node src/Plugins/Workbench
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1552">[ date ]</a>
              <a href="thread.html#1552">[ thread ]</a>
              <a href="subject.html#1552">[ subject ]</a>
              <a href="author.html#1552">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
