<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1931 - in branches/MonoDevelop-plan-43: . src src/Libraries src/Libraries/Gdl src/Plugins src/Plugins/Content src/Plugins/Editor src/Plugins/Node src/Plugins/Workbench
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1931%20-%20in%20branches/MonoDevelop-plan-43%3A%20.%20src%20src/Libraries%20src/Libraries/Gdl%20src/Plugins%20src/Plugins/Content%20src/Plugins/Editor%20src/Plugins/Node%20src/Plugins/Workbench&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001537.html">
   <LINK REL="Next"  HREF="001539.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1931 - in branches/MonoDevelop-plan-43: . src src/Libraries src/Libraries/Gdl src/Plugins src/Plugins/Content src/Plugins/Editor src/Plugins/Node src/Plugins/Workbench</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1931%20-%20in%20branches/MonoDevelop-plan-43%3A%20.%20src%20src/Libraries%20src/Libraries/Gdl%20src/Plugins%20src/Plugins/Content%20src/Plugins/Editor%20src/Plugins/Node%20src/Plugins/Workbench&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1931 - in branches/MonoDevelop-plan-43: . src src/Libraries src/Libraries/Gdl src/Plugins src/Plugins/Content src/Plugins/Editor src/Plugins/Node src/Plugins/Workbench">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Wed Aug 11 09:49:39 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001537.html">[Monodevelop-patches-list] r1930 - in branches/MonoDevelop-plan-43: . build/bin build/lib/monodevelop src src/Content src/Core src/Editor src/Node src/Workbench
</A></li>
        <LI>Next message: <A HREF="001539.html">[Monodevelop-patches-list] r1932 - in branches/MonoDevelop-plan-43: . src/Libraries src/Libraries/Gdl src/Plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1538">[ date ]</a>
              <a href="thread.html#1538">[ thread ]</a>
              <a href="subject.html#1538">[ subject ]</a>
              <a href="author.html#1538">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jzwart
Date: 2004-08-11 09:49:39 -0400 (Wed, 11 Aug 2004)
New Revision: 1931

Added:
   branches/MonoDevelop-plan-43/src/Libraries/
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/AssemblyInfo.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DetachedHandler.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/Dock.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockBar.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItem.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItemBehavior.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItemGrip.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockLayout.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockMaster.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockNotebook.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockObject.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockObjectFlags.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPaned.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockParamFlags.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPlaceholder.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPlacement.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockRequest.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockedHandler.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/GdlDockTest.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/Stock.cs
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/gdl.build
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-close-12.png
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-menu-left-12.png
   branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-menu-right-12.png
   branches/MonoDevelop-plan-43/src/Libraries/libraries.build
   branches/MonoDevelop-plan-43/src/Plugins/
   branches/MonoDevelop-plan-43/src/Plugins/Content/
   branches/MonoDevelop-plan-43/src/Plugins/Content/ContentManager.cs
   branches/MonoDevelop-plan-43/src/Plugins/Content/content.build
   branches/MonoDevelop-plan-43/src/Plugins/Editor/
   branches/MonoDevelop-plan-43/src/Plugins/Editor/editor.build
   branches/MonoDevelop-plan-43/src/Plugins/Node/
   branches/MonoDevelop-plan-43/src/Plugins/Node/FileNode.cs
   branches/MonoDevelop-plan-43/src/Plugins/Node/node.build
   branches/MonoDevelop-plan-43/src/Plugins/Workbench/
   branches/MonoDevelop-plan-43/src/Plugins/Workbench/workbench.build
   branches/MonoDevelop-plan-43/src/Plugins/plugins.build
Removed:
   branches/MonoDevelop-plan-43/src/Content/
   branches/MonoDevelop-plan-43/src/Editor/
   branches/MonoDevelop-plan-43/src/Node/
   branches/MonoDevelop-plan-43/src/Plugins/Content/ContentManager.cs
   branches/MonoDevelop-plan-43/src/Plugins/Content/content.build
   branches/MonoDevelop-plan-43/src/Plugins/Editor/editor.build
   branches/MonoDevelop-plan-43/src/Plugins/Node/FileNode.cs
   branches/MonoDevelop-plan-43/src/Plugins/Node/node.build
   branches/MonoDevelop-plan-43/src/Plugins/Workbench/workbench.build
   branches/MonoDevelop-plan-43/src/Workbench/
   branches/MonoDevelop-plan-43/src/plugins.build
Modified:
   branches/MonoDevelop-plan-43/ChangeLog
Log:
2004-08-11  Jeroen Zwartepoorte  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;

	Move plugins to src/Plugins directory and add a new src/Libaries dir
	which contains the Gdl library only for now.



Modified: branches/MonoDevelop-plan-43/ChangeLog
===================================================================
--- branches/MonoDevelop-plan-43/ChangeLog	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/ChangeLog	2004-08-11 13:49:39 UTC (rev 1931)
@@ -1,5 +1,10 @@
 2004-08-11  Jeroen Zwartepoorte  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
 
+	Move plugins to src/Plugins directory and add a new src/Libaries dir
+	which contains the Gdl library only for now.
+
+2004-08-11  Jeroen Zwartepoorte  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
+
 	Start keeping a ChangeLog. This revision should compile with the latest
 	nant nightly build: 20040811. This version is required because of the
 	&lt;replacetokens&gt; filterchain changes.

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/AssemblyInfo.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/AssemblyInfo.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/AssemblyInfo.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,32 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+
+[assembly: AssemblyTitle(&quot;&quot;)]
+[assembly: AssemblyDescription(&quot;&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;1.0.*&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DetachedHandler.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DetachedHandler.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DetachedHandler.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,21 @@
+using System;
+
+namespace Gdl
+{
+	public delegate void DetachedHandler (object o, DetachedArgs args);
+	
+	public class DetachedArgs : EventArgs {
+		private bool recursive;
+	
+		public DetachedArgs (bool recursive)
+		{
+			this.recursive = recursive;
+		}
+	
+		public bool Recursive {
+			get {
+				return recursive;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/Dock.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/Dock.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/Dock.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,589 @@
+// created on 05/06/2004 at 11:21 A
+
+using System;
+using System.Collections;
+using Gtk;
+
+namespace Gdl
+{
+	public class Dock : DockObject
+	{
+		private readonly float SplitRatio = 0.3f;
+		private DockObject root = null;
+		private bool floating;
+		private Widget window;
+		private bool autoTitle;
+		private int floatX;
+		private int floatY;
+		private int width = -1;
+		private int height = -1;
+		private Gdk.GC xorGC;
+		private string title;
+
+		protected Dock (IntPtr raw) : base (raw) { }
+
+		public Dock () : this (null, false)
+		{
+		}
+
+		public Dock (Dock original, bool floating)
+			: this (original, floating, 0, 0, -1, -1)
+		{
+		}
+
+		public Dock (Dock original, bool floating, int x, int y, int width, int height)
+		{
+			floatX = x;
+			floatY = y;
+			this.width = width;
+			this.height = height;
+			this.floating = floating;
+			
+			SetFlag (WidgetFlags.NoWindow);
+			if (original != null)
+				Bind (original.Master);
+
+			/* create a master for the dock if none was provided */
+			if (Master == null) {
+				DockObjectFlags &amp;= ~(DockObjectFlags.Automatic);
+				Bind (new DockMaster ());
+			}
+
+			if (floating) {
+				/* create floating window for this dock */
+				window = new Window (WindowType.Toplevel);
+				Window wnd = window as Window;
+
+				/* set position and default size */
+				wnd.WindowPosition = WindowPosition.Mouse;
+				wnd.SetDefaultSize (width, height);
+				wnd.TypeHint = Gdk.WindowTypeHint.Normal;
+				
+				/* metacity ignores this */
+				wnd.Move (floatX, floatY);
+
+				/* connect to the configure event so we can track down window geometry */
+				wnd.ConfigureEvent += new ConfigureEventHandler (OnFloatingConfigure);
+				
+				/* set the title */
+				SetWindowTitle ();
+
+				/* set transient for the first dock if that is a non-floating dock */
+				DockObject controller = Master.Controller;
+				if (controller != null &amp;&amp; controller is Dock) {
+					if (!((Dock)controller).Floating) {
+						if (controller.Toplevel != null &amp;&amp; controller.Toplevel is Window) {
+							wnd.TransientFor = (Window)controller.Toplevel;
+						}
+					}
+				}
+				
+				wnd.Add (this);
+				wnd.DeleteEvent += new DeleteEventHandler (OnFloatingDelete);
+			}
+
+			DockObjectFlags |= DockObjectFlags.Attached;
+		}
+		
+		public bool Floating {
+			get {
+				return floating;
+			}
+			set {
+				floating = value;
+			}
+		}
+		
+		public int FloatX {
+			get {
+				return floatX;
+			}
+			set {
+				floatX = value;
+				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
+					((Window)window).Resize (width, height);
+			}
+		}
+		
+		public int FloatY {
+			get {
+				return floatY;
+			}
+			set {
+				floatY = value;
+				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
+					((Window)window).Resize (width, height);
+			}
+		}
+		
+		public int Height {
+			get {
+				return height;
+			}
+			set {
+				height = value;
+				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
+					((Window)window).Resize (width, height);
+			}
+		}
+		
+		private bool IsController {
+			get {
+				if (Master == null)
+					return false;
+				return Master.Controller == this;
+			}
+		}
+
+		public ICollection NamedItems {
+			get {
+				return Master.DockObjects;
+			}
+		}
+		
+		public DockObject Root {
+			get {
+				return root;
+			}
+			set {
+				root = value;
+			}
+		}
+		
+		public string Title {
+			get {
+				return title;
+			}
+			set {
+				title = value;
+			}
+		}
+		
+		public int Width {
+			get { return width; }
+			set {
+				width = value;
+				if (floating &amp;&amp; window != null &amp;&amp; window is Window)
+					((Window)window).Resize (width, height);
+			}
+		}
+		
+		protected override void OnSizeRequested (ref Requisition requisition)
+		{
+			requisition.Width = 2 * (int)BorderWidth;
+			requisition.Height = 2 * (int)BorderWidth;
+
+			if (root != null &amp;&amp; root.Visible) {
+				Requisition rootReq = root.SizeRequest ();
+				requisition.Width += rootReq.Width;
+				requisition.Height += rootReq.Height;
+			}			
+		}
+		
+		protected override void OnSizeAllocated (Gdk.Rectangle allocation)
+		{
+			base.OnSizeAllocated (allocation);
+		
+			if (root != null &amp;&amp; root.Visible) {
+				int bw = (int)BorderWidth;
+				Gdk.Rectangle childAlloc;
+			
+				childAlloc.X = allocation.X + bw;
+				childAlloc.Y = allocation.Y + bw;
+				childAlloc.Width = Math.Max (1, allocation.Width - 2 * bw);
+				childAlloc.Height = Math.Max (1, allocation.Height - 2 * bw);
+			
+				root.SizeAllocate (childAlloc);
+			}
+		}
+		
+		protected override void OnMapped ()
+		{
+			base.OnMapped ();
+
+			if (root != null &amp;&amp; root.Visible &amp;&amp; !root.IsMapped)
+				root.Map ();
+		}
+		
+		protected override void OnUnmapped ()
+		{
+			base.OnUnmapped ();
+
+			if (root != null &amp;&amp; root.Visible &amp;&amp; root.IsMapped)
+				root.Unmap ();
+
+			if (window != null)
+				window.Unmap ();
+		}
+		
+		protected override void OnShown ()
+		{
+			base.OnShown ();
+
+			if (floating &amp;&amp; window != null)
+				window.ShowAll ();
+
+			if (IsController) {
+				foreach (DockObject item in Master.TopLevelDocks) {
+					if (item == this)
+						continue;
+					if (item.IsAutomatic)
+						item.Show ();
+				}
+			}
+		}
+		
+		protected override void OnHidden ()
+		{
+			base.OnHidden ();
+			
+			if (floating &amp;&amp; window != null)
+				window.Hide ();
+
+			if (IsController) {
+				foreach (DockObject item in Master.TopLevelDocks) {
+					if (item == this)
+						continue;
+					if (item.IsAutomatic)
+						item.Hide ();
+				}
+			}
+		}
+
+		protected override void OnDestroyed ()
+		{
+			if (window != null) {
+				window.Destroy ();
+				floating = false;
+				window = null;
+			}
+
+			if (xorGC != null)
+				xorGC = null;
+
+			base.OnDestroyed ();
+		}
+		
+		protected override void OnAdded (Widget widget)
+		{
+			DockItem child = widget as DockItem;
+			AddItem (child, DockPlacement.Top);
+		}
+		
+		protected override void OnRemoved (Widget widget)
+		{
+			bool wasVisible = widget.Visible;
+
+			if (root == widget) {
+				root.DockObjectFlags &amp;= ~(DockObjectFlags.Attached);
+				root = null;
+				widget.Unparent ();
+
+				if (wasVisible &amp;&amp; Visible)
+					QueueResize ();
+			}
+		}
+		
+		protected override void ForAll (bool include_internals, CallbackInvoker invoker)
+		{
+			if (root != null)
+				invoker.Invoke (root);
+		}
+		
+		public override void OnDetached (bool recursive)
+		{
+			if (recursive &amp;&amp; root != null)
+				root.Detach (recursive);
+
+			DockObjectFlags &amp;= ~(DockObjectFlags.Attached);
+		}
+		
+		public override void OnReduce ()
+		{
+			if (root != null)
+				return;
+
+			if (IsAutomatic) {
+				Destroy ();
+			} else if (!IsAttached) {
+				if (floating)
+					Hide ();
+				else if (Parent != null &amp;&amp; Parent is Container)
+					((Container)Parent).Remove (this);
+			}
+		}
+		
+		public override bool OnDockRequest (int x, int y, ref DockRequest request)
+		{
+			bool mayDock = false;
+		
+			/* we get (x,y) in our allocation coordinates system */
+			
+			/* Get dock size. */
+			Gdk.Rectangle alloc = Allocation;
+			int bw = (int)BorderWidth;
+
+			/* Get coordinates relative to our allocation area. */
+			int relX = x - alloc.X;
+			int relY = y - alloc.Y;
+
+			/* Check if coordinates are in GdlDock widget. */
+			if (relX &gt; 0 &amp;&amp; relX &lt; alloc.Width &amp;&amp;
+			    relY &gt; 0 &amp;&amp; relY &lt; alloc.Height) {
+			    
+				/* It's inside our area. */
+				mayDock = true;
+
+				/* Set docking indicator rectangle to the Dock size. */
+				request.X = alloc.X + bw;
+				request.Y = alloc.Y + bw;
+				request.Width = alloc.Width - 2 * bw;
+				request.Height = alloc.Height - 2 * bw;
+				
+				/* If Dock has no root item yet, set the dock
+				   itself as possible target. */
+				if (root == null) {
+					request.Position = DockPlacement.Top;
+					request.Target = this;
+				} else {
+					request.Target = root;
+					
+					/* See if it's in the BorderWidth band. */
+					if (relX &lt; bw) {
+						request.Position = DockPlacement.Left;
+						request.Width = (int)(request.Width * SplitRatio);
+					} else if (relX &gt; alloc.Width - bw) {
+						request.Position = DockPlacement.Right;
+						request.X += (int)(request.Width * (1 - SplitRatio));
+						request.Width = (int)(request.Width * SplitRatio);
+					} else if (relY &lt; bw) {
+						request.Position = DockPlacement.Top;
+						request.Height = (int)(request.Height * SplitRatio);
+					} else if (relY &gt; alloc.Height - bw) {
+						request.Position = DockPlacement.Bottom;
+						request.Y += (int)(request.Height * (1 - SplitRatio));
+						request.Height = (int)(request.Height * SplitRatio);
+					} else {
+						/* Otherwise try our children. */
+						/* give them allocation coordinates
+						   (we are a NoWindow widget) */
+						mayDock = root.OnDockRequest (x, y, ref request);
+					}
+				}
+			}
+			
+			return mayDock;
+		}
+		
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
+		{
+			/* only dock items allowed at this time */
+			if (!(requestor is DockItem))
+				return;
+
+			if (position == DockPlacement.Floating) {
+				int x = 0, y = 0, width = -1, height = -1;
+				if (data != null &amp;&amp; data is Gdk.Rectangle) {
+					Gdk.Rectangle rect = (Gdk.Rectangle)data;
+					x = rect.X;
+					y = rect.Y;
+					width = rect.Width;
+					height = rect.Height;
+				}
+				
+				AddFloatingItem ((DockItem)requestor, x, y, width, height);
+			} else if (root != null) {
+				/* This is somewhat a special case since we know
+				   which item to pass the request on because we only
+				   have one child */
+				root.Dock (requestor, position, null);
+				SetWindowTitle ();
+			} else { /* Item about to be added is root item. */
+				root = requestor;
+				root.DockObjectFlags |= DockObjectFlags.Attached;
+				root.Parent = this;
+				((DockItem)root).ShowGrip ();
+				
+				/* Realize the item (create its corresponding GdkWindow)
+			           when the Dock has been realized. */
+				if (IsRealized)
+					root.Realize ();
+				
+				/* Map the widget if it's visible and the parent is
+			           visible and has been mapped. This is done to make
+			           sure that the GdkWindow is visible. */
+				if (Visible &amp;&amp; root.Visible) {
+					if (IsMapped)
+						root.Map ();
+					
+					/* Make the widget resize. */
+					root.QueueResize ();
+				}
+				
+				SetWindowTitle ();
+			}
+		}
+		
+		public override bool OnReorder (DockObject requestor, DockPlacement position, object data)
+		{
+			if (Floating &amp;&amp; position == DockPlacement.Floating &amp;&amp; root == requestor) {
+				if (window != null &amp;&amp; data != null &amp;&amp; data is Gdk.Rectangle) {
+					Gdk.Rectangle rect = (Gdk.Rectangle)data;
+					((Window)window).Move (rect.X, rect.Y);
+					return true;
+				}
+			}
+
+			return false;
+		}
+		
+		public override bool OnChildPlacement (DockObject child, ref DockPlacement placement)
+		{
+			if (root == child) {
+				if (placement == DockPlacement.None ||
+				    placement == DockPlacement.Floating)
+					placement = DockPlacement.Top;
+				return true;
+			}
+				
+			return false;
+		}
+		
+		public override void OnPresent (DockObject child)
+		{
+			if (Floating &amp;&amp; window != null &amp;&amp; window is Window)
+				((Window)window).Present ();
+		}
+		
+		public void AddItem (DockItem item, DockPlacement placement)
+		{
+			if (item == null)
+				return;
+
+			if (placement == DockPlacement.Floating)
+				AddFloatingItem (item, 0, 0, -1, -1);
+			else
+				Dock (item, placement, null);
+		}
+		
+		public void AddFloatingItem (DockItem item, int x, int y, int width, int height)
+		{
+			Dock dock = new Dock (this, true, x, y, width, height);
+			
+			if (Visible) {
+				dock.Show ();
+				if (IsMapped)
+					dock.Map ();
+				dock.QueueResize ();
+			}
+			
+			dock.AddItem (item, DockPlacement.Top);
+		}
+		
+		public DockItem GetItemByName (string name)
+		{
+			if (name == null)
+				return null;
+
+			DockObject found = Master.GetObject (name);
+			if (found != null &amp;&amp; found is DockItem)
+				return (DockItem)found;
+			else
+				return null;
+		}
+		
+		public DockPlaceholder GetPlaceholderByName (string name)
+		{
+			if (name == null)
+				return null;
+
+			DockObject found = Master.GetObject (name);
+			if (found != null &amp;&amp; found is DockPlaceholder)
+				return (DockPlaceholder)found;
+			else
+				return null;
+		}
+		
+		public static Dock GetTopLevel (DockObject obj)
+		{
+			DockObject parent = obj;
+			while (parent != null &amp;&amp; !(parent is Dock))
+				parent = parent.ParentObject;
+
+			return parent != null ? (Dock)parent : null;
+		}
+		
+		public void XorRect (Gdk.Rectangle rect)
+		{
+			if (xorGC == null) {
+				if (IsRealized) {
+					Gdk.GCValues values = new Gdk.GCValues ();
+					values.Function = Gdk.Function.Invert;
+					values.SubwindowMode = Gdk.SubwindowMode.IncludeInferiors;
+					xorGC = new Gdk.GC (GdkWindow);
+					xorGC.SetValues (values, Gdk.GCValuesMask.Function |
+							 Gdk.GCValuesMask.Subwindow);
+				} else {
+					return;
+				}
+			}
+
+			xorGC.SetLineAttributes (1, Gdk.LineStyle.OnOffDash,
+						 Gdk.CapStyle.NotLast,
+						 Gdk.JoinStyle.Bevel);
+			xorGC.SetDashes (1, new sbyte[] { 1, 1}, 2);
+			
+			GdkWindow.DrawRectangle (xorGC, false, rect.X, rect.Y,
+						 rect.Width, rect.Height);
+
+			xorGC.SetDashes (0, new sbyte[] { 1, 1}, 2);
+
+			GdkWindow.DrawRectangle (xorGC, false, rect.X + 1,
+						 rect.Y + 1, rect.Width - 2,
+						 rect.Height - 2);
+		}
+		
+		private void SetWindowTitle ()
+		{
+			if (window == null)
+				return;
+		
+			if (!autoTitle &amp;&amp; LongName != null)
+				title = LongName;
+			else if (Master != null)
+				title = Master.DefaultTitle;
+			
+			if (title == null &amp;&amp; root != null)
+				title = root.LongName;
+			
+			if (title == null) {
+				autoTitle = true;
+				title = &quot;Dock &quot; + Master.DockNumber++;
+				LongName = title;
+			}
+			
+			((Window)window).Title = title;
+		}
+
+		[GLib.ConnectBefore]
+		private void OnFloatingConfigure (object o, ConfigureEventArgs e)
+		{
+			floatX = e.Event.X;
+			floatY = e.Event.Y;
+			width = e.Event.Width;
+			height = e.Event.Height;
+
+			e.RetVal = false;
+		}
+
+		private void OnFloatingDelete (object o, DeleteEventArgs e)
+		{
+			if (root != null)
+				/* this will call reduce on ourselves, hiding
+				   the window if appropiate */
+				((DockItem)root).HideItem ();
+
+			e.RetVal = true;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockBar.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockBar.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockBar.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,85 @@
+// created on 6/24/2004 at 7:43 PM
+
+using System;
+using System.Collections;
+using Gtk;
+
+namespace Gdl
+{
+	public class DockBar : VBox
+	{
+		DockMaster master;
+		Tooltips tooltips = new Tooltips ();
+		
+		public DockBar (Dock dock)
+		{
+			Console.WriteLine (&quot;new dockbar&quot;);
+			master = dock.Master;
+		}
+		
+		public DockMaster Master {
+			get {
+				return master;
+			}
+			set {
+				master = value;
+			}
+		}
+		
+		public void AddItem (DockItem item)
+		{
+			Console.WriteLine (&quot;adding item to dockbar&quot;);
+			Button button = new Button ();
+			button.Relief = ReliefStyle.None;
+			Image image = new Image (item.StockId, IconSize.SmallToolbar);
+			button.Add (image);
+			button.Clicked += OnDockButtonClicked;
+			// check if already there
+			tooltips.SetTip (button, item.Name, item.Name);
+			item.DockBar = this;
+			item.DockBarButton = button;
+			this.PackStart (button, false, false, 0);
+			button.ShowAll ();
+		}
+		
+		public void Attach (DockMaster master)
+		{
+			this.master = master;
+			master.LayoutChanged += OnLayoutChanged;
+		}
+		
+		public void RemoveItem (DockItem item)
+		{
+			// check if there
+			this.Remove (item.DockBarButton);
+		}
+		
+		void UpdateDockItems ()
+		{
+			foreach (DockItem item in master.DockObjects)
+			{
+				if (item.Iconified)
+					this.AddItem (item);
+				else
+					this.RemoveItem (item);
+			}
+		}
+		
+		void OnLayoutChanged (object o, EventArgs args)
+		{
+			UpdateDockItems ();
+		}
+		
+		void OnDockButtonClicked (object o, EventArgs args)
+		{
+			DockItem item = (DockItem) o;  //FIXME: o is a Button
+			DockObject controller = item.Master.Controller;
+			item.DockBar = null;
+			// remove Iconified flag
+			item.Flags |= (int) DockObjectFlags.Iconified;
+			item.Show ();
+			this.RemoveItem (item);
+			controller.QueueResize ();
+		}
+	}
+}
\ No newline at end of file

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItem.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItem.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItem.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,947 @@
+// created on 06/06/2004 at 10:09 P
+using System;
+using Gtk;
+
+namespace Gdl
+{
+	public delegate void DockItemMotionHandler (DockItem o, int x, int y);
+	public delegate void DockItemDragBeginHandler (DockItem o);
+	public delegate void DockItemDragEndHandler (DockItem o, bool cancelled);
+	
+	public class DockItem : DockObject
+	{
+		private readonly float SplitRatio = 0.4f;
+		private Widget child = null;
+		private DockItemBehavior behavior = DockItemBehavior.Normal;
+		private Orientation orientation = Orientation.Vertical;
+		private bool resize = false;
+		private int dragoffX = 0;
+		private int dragoffY = 0;
+		private Menu menu = null;
+		private DockBar dockBar;
+		private DockItemGrip grip;
+		private Button dockButton;
+		private uint gripSize;
+		private Widget tabLabel = null;
+		private int preferredWidth = -1;
+		private int preferredHeight = -1;
+		private DockPlaceholder ph = null;
+		private int startX;
+		private int startY;
+		
+		public event DockItemMotionHandler DockItemMotion;
+		public event DockItemDragBeginHandler DockItemDragBegin;
+		public event DockItemDragEndHandler DockItemDragEnd;		
+				
+		static DockItem ()
+		{
+			Rc.ParseString (&quot;style \&quot;gdl-dock-item-default\&quot; {\n&quot; +
+						&quot;xthickness = 0\n&quot; +
+						&quot;ythickness = 0\n&quot; + 
+					&quot;}\n&quot; + 
+					&quot;class \&quot;Gdl_DockItem\&quot; &quot; +
+					&quot;style : gtk \&quot;gdl-dock-item-default\&quot;\n&quot;);
+		}
+		
+		protected DockItem ()
+		{
+			Flags |= (int)WidgetFlags.NoWindow;
+		
+			if (HasGrip) {
+				grip = new DockItemGrip (this);
+				grip.Parent = this;
+				grip.Show ();
+			}
+		}
+
+		protected DockItem (IntPtr raw) : base (raw) { }
+		
+		public DockItem (string name, string longName, DockItemBehavior behavior) : this ()
+		{
+			Name = name;
+			LongName = longName;
+			Behavior = behavior;
+		}
+		
+		public DockItem (string name, string longName, string stockid,
+				 DockItemBehavior behavior) : this (name, longName, behavior)
+		{
+			StockId = stockid;
+		}
+		
+		public DockItemBehavior Behavior {
+			get {
+				return behavior;
+			}
+			set {
+				DockItemBehavior oldBehavior = behavior;
+				behavior = value;
+				if (((oldBehavior ^ behavior) &amp; DockItemBehavior.Locked) != 0) {
+					if (Master != null)
+						Master.EmitLayoutChangedEvent ();
+				}
+				EmitPropertyEvent (&quot;Behavior&quot;);
+			}
+		}
+		
+		public bool CantClose {
+			get {
+				return ((Behavior &amp; DockItemBehavior.CantClose) != 0);
+			}
+		}
+		
+		public bool CantIconify {
+			get {
+				return ((Behavior &amp; DockItemBehavior.CantIconify) != 0);
+			}
+		}
+		
+		public new Widget Child {
+			get {
+				return child;
+			}
+			set {
+				child = value;
+			}
+		}
+		
+		public DockBar DockBar {
+			get {
+				return dockBar;
+			}
+			set {
+				dockBar = value;	
+			}
+		}
+		
+		public Button DockBarButton {
+			get {
+				return dockButton;
+			}
+			set {
+				dockButton = value;	
+			}
+		}
+		
+		public int DragOffX {
+			get {
+				return dragoffX;
+			}
+			set {
+				dragoffX = value; 
+			}
+		}
+		
+		public int DragOffY {
+			get {
+				return dragoffY;
+			}
+			set {
+				dragoffY = value;
+			}
+		}
+		
+		public bool GripShown {
+			get {
+				return (HasGrip &amp;&amp; !Locked &amp;&amp; grip.Visible);
+			}
+		}
+		
+		public virtual bool HasGrip {
+			get {
+				return true;
+			}
+		}
+		
+		public bool Iconified {
+			get {
+				return ((DockObjectFlags &amp; DockObjectFlags.Iconified) != 0);
+			}
+		}
+		
+		public bool InDrag {
+			get {
+				return ((DockObjectFlags &amp; DockObjectFlags.InDrag) != 0);
+			}
+		}
+		
+		public bool InPreDrag {
+			get {
+				return ((DockObjectFlags &amp; DockObjectFlags.InPreDrag) != 0);
+			}
+		}
+		
+		public override bool IsCompound {
+			get {
+				return false;
+			}
+		}
+		
+		public bool Locked {
+			get {
+				return ((behavior &amp; DockItemBehavior.Locked) != 0);
+			}
+			set {
+				DockItemBehavior oldBehavior = behavior;
+				if (value)
+					behavior |= DockItemBehavior.Locked;
+				else
+					behavior &amp;= ~(DockItemBehavior.Locked);
+
+				if ((oldBehavior ^ behavior) != 0) {
+					if (Master != null)
+						Master.EmitLayoutChangedEvent ();
+					EmitPropertyEvent (&quot;Locked&quot;);
+				}
+			}
+		}
+		
+		public Orientation Orientation {
+			get {
+				return orientation;
+			}
+			set {
+				SetOrientation (value);
+				EmitPropertyEvent (&quot;Orientation&quot;);
+			}
+		}
+		
+		public int PreferredHeight {
+			get {
+				return preferredHeight;
+			}
+			set {
+				preferredHeight = value;
+			}
+		}
+		
+		public int PreferredWidth {
+			get {
+				return preferredWidth;
+			}
+			set {
+				preferredWidth = value;
+			}
+		}
+		
+		public Requisition PreferredSize {
+			get {
+				Requisition req = new Requisition ();
+				req.Width = Math.Max (preferredWidth, Allocation.Width);
+				req.Height = Math.Max (preferredHeight, Allocation.Height);
+				return req;
+			}
+		}
+		
+		public bool Resize {
+			get {
+				return resize;
+			}
+			set {
+				resize = value;
+				QueueResize ();
+				EmitPropertyEvent (&quot;Resize&quot;);
+			}
+		}
+		
+		public Widget TabLabel {
+			get {
+				return tabLabel;
+			}
+			set {
+				tabLabel = value;
+			}
+		}
+		
+		public bool UserAction {
+			get {
+				return ((DockObjectFlags &amp; DockObjectFlags.UserAction) != 0);
+			}
+		}
+		
+		protected override void OnAdded (Widget widget)
+		{
+			if (widget is DockObject) {
+				Console.WriteLine (&quot;You can't add a DockObject to a DockItem&quot;);
+				return;
+			}
+			
+			if (Child != null) {
+				Console.WriteLine (&quot;This DockItem already has a child&quot;);
+				return;
+			}
+			
+			widget.Parent = this;
+			Child = widget;
+		}
+		
+		protected override void OnRemoved (Widget widget)
+		{
+			bool wasVisible = widget.Visible;
+
+			if (grip == widget) {
+				widget.Unparent ();
+				grip = null;
+				if (wasVisible)
+					QueueResize ();
+				return;
+			} else if (widget != Child) {
+				return;
+			}
+
+			if (InDrag)
+				EndDrag (true);
+			
+			widget.Unparent ();
+			Child = null;
+			
+			if (wasVisible)
+				QueueResize ();
+		}
+		
+		protected override void ForAll (bool include_internals, CallbackInvoker invoker)
+		{
+			if (include_internals &amp;&amp; grip != null)
+				invoker.Invoke (grip);
+			if (Child != null)
+				invoker.Invoke (Child);
+		}
+		
+		protected override void OnSizeRequested (ref Requisition requisition)
+		{
+			requisition.Width = ((int)BorderWidth + Style.XThickness) * 2;
+			requisition.Height = ((int)BorderWidth + Style.YThickness) * 2;
+		
+			Requisition childReq;
+			if (Child != null &amp;&amp; Child.Visible) {
+				childReq = Child.SizeRequest ();
+			} else {
+				childReq.Width = 0;
+				childReq.Height = 0;
+			}
+
+			Requisition gripReq;
+			gripReq.Width = gripReq.Height = 0;
+
+			if (Orientation == Orientation.Horizontal) {
+				if (GripShown) {
+					gripReq = grip.SizeRequest ();
+					requisition.Width += gripReq.Width;
+				}
+				
+				if (Child != null) {
+					requisition.Width += childReq.Width;
+					requisition.Height += Math.Max (childReq.Height,
+									gripReq.Height);
+				}
+			} else {
+				if (GripShown) {
+					gripReq = grip.SizeRequest ();
+					requisition.Height += gripReq.Height;
+				}
+				
+				if (Child != null) {
+					requisition.Width += Math.Max (childReq.Width,
+								       gripReq.Width);
+					requisition.Height += childReq.Height;
+				}
+			}
+		}
+		
+		protected override void OnSizeAllocated (Gdk.Rectangle allocation)
+		{
+			base.OnSizeAllocated (allocation);
+			
+			if (IsRealized) {
+				GdkWindow.MoveResize (allocation.X, allocation.Y,
+						      allocation.Width, allocation.Height);
+			}
+			
+			if (Child != null &amp;&amp; Child.Visible) {
+				int bw = (int)BorderWidth;
+				Gdk.Rectangle childAlloc;
+				
+				childAlloc.X = bw + Style.XThickness;
+				childAlloc.Y = bw + Style.YThickness;
+				childAlloc.Width = allocation.Width - 2 * (bw + Style.XThickness);
+				childAlloc.Height = allocation.Height - 2 * (bw + Style.YThickness);
+				
+				if (GripShown) {
+					Gdk.Rectangle gripAlloc = childAlloc;
+					Requisition gripReq = grip.SizeRequest ();
+					
+					if (Orientation == Orientation.Horizontal) {
+						childAlloc.X += gripReq.Width;
+						childAlloc.Width -= gripReq.Width;
+						gripAlloc.Width = gripReq.Width;
+					} else {
+						childAlloc.Y += gripReq.Height;
+						childAlloc.Height -= gripReq.Height;
+						gripAlloc.Height = gripReq.Height;
+					}
+					
+					grip.SizeAllocate (gripAlloc);
+				}
+
+				Child.SizeAllocate (childAlloc);
+			}
+		}
+		
+		protected override void OnMapped ()
+		{
+			SetFlag (WidgetFlags.Mapped);
+			
+			GdkWindow.Show ();
+
+			if (Child != null &amp;&amp; Child.Visible &amp;&amp; !Child.IsMapped)
+				Child.Map ();
+			if (grip != null &amp;&amp; grip.Visible &amp;&amp; !grip.IsMapped)
+				grip.Map ();
+		}
+		
+		protected override void OnUnmapped ()
+		{
+			ClearFlag (WidgetFlags.Mapped);
+			
+			GdkWindow.Hide ();
+			
+			if (grip != null)
+				grip.Unmap ();
+		}
+		
+		protected override void OnRealized ()
+		{
+			Flags |= (int)WidgetFlags.Realized;
+			
+			Gdk.WindowAttr attributes = new Gdk.WindowAttr ();
+			attributes.X = Allocation.X;
+			attributes.Y = Allocation.Y;
+			attributes.Height = Allocation.Height;
+			attributes.Width = Allocation.Width;
+			attributes.WindowType = Gdk.WindowType.Child;
+			attributes.Wclass = Gdk.WindowClass.InputOutput;
+			attributes.visual = Visual;
+			attributes.colormap = Colormap;
+			attributes.EventMask = (int)(Events |
+				Gdk.EventMask.ExposureMask |
+				Gdk.EventMask.Button1MotionMask |
+				Gdk.EventMask.ButtonPressMask |
+				Gdk.EventMask.ButtonReleaseMask);
+		
+			Gdk.WindowAttributesType attributes_mask =
+				Gdk.WindowAttributesType.X |
+				Gdk.WindowAttributesType.Y |
+				Gdk.WindowAttributesType.Colormap |
+				Gdk.WindowAttributesType.Visual;
+			GdkWindow = new Gdk.Window (ParentWindow, attributes, (int)attributes_mask);
+			GdkWindow.UserData = Handle;
+			
+			Style = Style.Attach (GdkWindow);
+			Style.SetBackground (GdkWindow, State);
+			
+			GdkWindow.SetBackPixmap (null, true);
+			
+			if (Child != null)
+				Child.ParentWindow = GdkWindow;
+			if (grip != null)
+				grip.ParentWindow = GdkWindow;
+		}
+		
+		protected override void OnStyleSet (Style style)
+		{
+			if (IsRealized &amp;&amp; !IsNoWindow) {
+				Style.SetBackground (GdkWindow, State);
+				if (IsDrawable)
+					GdkWindow.Clear ();
+			}
+		}
+
+		/*protected override void OnDestroyed ()
+		{
+			if (tabLabel != null)
+				tabLabel = null;
+			if (menu != null) {
+				menu.Detach ();
+				menu = null;
+			}
+			if (grip != null) {
+				Remove (grip);
+				grip = null;
+			}
+			if (ph != null) {
+				ph = null;
+			}
+			base.OnDestroyed ();
+		}*/
+		
+		protected override bool OnExposeEvent (Gdk.EventExpose evnt)
+		{
+			if (IsDrawable &amp;&amp; evnt.Window == GdkWindow) {
+				Style.PaintBox (Style, GdkWindow, State,
+						ShadowType.None, evnt.Area, this,
+						&quot;dockitem&quot;, 0, 0, -1, -1);
+				base.OnExposeEvent (evnt);
+			}
+
+			return false;
+		}
+		
+		protected override bool OnButtonPressEvent (Gdk.EventButton evnt)
+		{
+			if (!EventInGripWindow (evnt) || Locked)
+				return false;
+			
+			bool eventHandled = false;
+			bool inHandle;
+			Gdk.Cursor cursor = null;
+			
+			/* Check if user clicked on the drag handle. */      
+			switch (Orientation) {
+			case Orientation.Horizontal:
+				inHandle = evnt.X &lt; grip.Allocation.Width;
+				break;
+			case Orientation.Vertical:
+				inHandle = evnt.Y &lt; grip.Allocation.Height;
+				break;
+			default:
+				inHandle = false;
+				break;
+			}
+			
+			/* Left mousebutton click on dockitem. */
+			if (evnt.Button == 1 &amp;&amp; evnt.Type == Gdk.EventType.ButtonPress) {
+				/* Set in_drag flag, grab pointer and call begin drag operation. */
+				if (inHandle) {
+					startX = (int)evnt.X;
+					startY = (int)evnt.Y;
+					DockObjectFlags |= DockObjectFlags.InPreDrag;
+					cursor = new Gdk.Cursor (Display, Gdk.CursorType.Fleur);
+					grip.TitleWindow.Cursor = cursor;
+					eventHandled = true;
+				}
+			} else if (evnt.Type == Gdk.EventType.ButtonRelease &amp;&amp; evnt.Button == 1) {
+				if (InDrag) {
+					/* User dropped widget somewhere. */
+					EndDrag (false);
+					eventHandled = true;
+				} else if (InPreDrag) {
+					DockObjectFlags &amp;= ~(DockObjectFlags.InPreDrag);
+					eventHandled = true;
+				}
+				
+				/* we check the window since if the item was redocked it's
+				   been unrealized and maybe it's not realized again yet */
+				if (grip.TitleWindow != null) {
+					cursor = new Gdk.Cursor (Display, Gdk.CursorType.Hand2);
+					grip.TitleWindow.Cursor = cursor;
+				}
+			} else if (evnt.Button == 3 &amp;&amp; evnt.Type == Gdk.EventType.ButtonPress &amp;&amp; inHandle) {
+				DockPopupMenu (evnt.Button, evnt.Time);
+				eventHandled = true;
+			}
+
+			return eventHandled;
+		}
+		
+		protected override bool OnButtonReleaseEvent (Gdk.EventButton evnt)
+		{
+			return OnButtonPressEvent (evnt);
+		}
+		
+		protected override bool OnMotionNotifyEvent (Gdk.EventMotion evnt)
+		{
+			if (!EventInGripWindow (evnt))
+				return false;
+
+			if (InPreDrag) {
+				if (Drag.CheckThreshold (this, startX, startY,
+							 (int)evnt.X, (int)evnt.Y)) {
+					DockObjectFlags &amp;= ~(DockObjectFlags.InPreDrag);
+					dragoffX = startX;
+					dragoffY = startY;
+					StartDrag ();
+				}
+			}
+			
+			if (!InDrag)
+				return false;
+			
+			int newX = (int)evnt.XRoot;
+			int newY = (int)evnt.YRoot;
+			
+			OnDragMotion (newX, newY);
+			DockItemMotionHandler handler = DockItemMotion;
+			if (handler != null)
+				handler (this, newX, newY);
+			
+			return true;
+		}
+		
+		protected override bool OnKeyPressEvent (Gdk.EventKey evnt)
+		{
+			if (InDrag &amp;&amp; evnt.Key == Gdk.Key.Escape) {
+				EndDrag (false);
+				return true;
+			}
+			
+			return base.OnKeyPressEvent (evnt);
+		}
+		
+		public override bool OnDockRequest (int x, int y, ref DockRequest request)
+		{
+			/* we get (x,y) in our allocation coordinates system */
+			
+			/* Get item's allocation. */
+			Gdk.Rectangle alloc = Allocation;
+
+			/* Get coordinates relative to our window. */
+			int relX = x - alloc.X;
+			int relY = y - alloc.Y;
+			
+			/* Location is inside. */
+			if (relX &gt; 0 &amp;&amp; relX &lt; alloc.Width &amp;&amp;
+			    relY &gt; 0 &amp;&amp; relY &lt; alloc.Height) {
+				int divider = -1;
+				
+				/* these are for calculating the extra docking parameter */
+				Requisition other = ((DockItem)request.Applicant).PreferredSize;
+				Requisition my = PreferredSize;
+				
+				/* Calculate location in terms of the available space (0-100%). */
+				float rx = (float) relX / alloc.Width;
+				float ry = (float) relY / alloc.Height;
+				
+				/* Determine dock location. */
+				if (rx &lt; SplitRatio) {
+					request.Position = DockPlacement.Left;
+					divider = other.Width;
+				} else if (rx &gt; (1 - SplitRatio)) {
+					request.Position = DockPlacement.Right;
+					rx = 1 - rx;
+					divider = Math.Max (0, my.Width - other.Width);
+				} else if (ry &lt; SplitRatio &amp;&amp; ry &lt; rx) {
+					request.Position = DockPlacement.Top;
+					divider = other.Height;
+				} else if (ry &gt; (1 - SplitRatio) &amp;&amp; (1 - ry) &lt; rx) {
+					request.Position = DockPlacement.Bottom;
+					divider = Math.Max (0, my.Height - other.Height);
+				} else {
+					request.Position = DockPlacement.Center;
+				}
+				
+				/* Reset rectangle coordinates to entire item. */
+				request.X = 0;
+				request.Y = 0;
+				request.Width = alloc.Width;
+				request.Height = alloc.Height;
+				
+				/* Calculate docking indicator rectangle size for new locations.
+				   Only do this when we're not over the item's current location. */
+				if (request.Applicant != this) {
+					switch (request.Position) {
+					case DockPlacement.Top:
+						request.Height = (int)(request.Height * SplitRatio);
+						break;
+					case DockPlacement.Bottom:
+						request.Y += (int)(request.Height * (1 - SplitRatio));
+						request.Height = (int)(request.Height * SplitRatio);
+						break;
+					case DockPlacement.Left:
+						request.Width = (int)(request.Width * SplitRatio);
+						break;
+					case DockPlacement.Right:
+						request.X += (int)(request.Width * (1 - SplitRatio));
+						request.Width = (int)(request.Width * SplitRatio);
+						break;
+					case DockPlacement.Center:
+						request.X = (int)(request.Width * SplitRatio / 2);
+						request.Y = (int)(request.Height * SplitRatio / 2);
+						request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;
+						request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;
+						break;
+					default:
+						break;
+					}
+				}
+				
+				/* adjust returned coordinates so they have the same
+				   origin as our window */
+				request.X += alloc.X;
+				request.Y += alloc.Y;
+				
+				/* Set possible target location and return true. */
+				request.Target = this;
+
+				/* fill-in other dock information */
+				if (request.Position != DockPlacement.Center &amp;&amp; divider &gt;= 0)
+					request.Extra = divider;
+
+				return true;
+			} else { /* No docking possible at this location. */
+				return false;
+			}
+		}
+		
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
+		{
+			DockObject parent = ParentObject;
+			DockObject newParent = null;
+			bool addOurselvesFirst;
+			
+			switch (position) {
+			case DockPlacement.Top:
+			case DockPlacement.Bottom:
+				newParent = new DockPaned (Orientation.Vertical);
+				addOurselvesFirst = (position == DockPlacement.Bottom);
+				break;
+			case DockPlacement.Left:
+			case DockPlacement.Right:
+				newParent = new DockPaned (Orientation.Horizontal);
+				addOurselvesFirst = (position == DockPlacement.Right);
+				break;
+			case DockPlacement.Center:
+				newParent = new DockNotebook ();
+				addOurselvesFirst = true;
+				break;
+			default:
+				Console.WriteLine (&quot;Unsupported docking strategy&quot;);
+				return;
+			}
+			
+			if (parent != null)
+				parent.Freeze ();
+
+			DockObjectFlags |= DockObjectFlags.InReflow;
+			Detach (false);
+			newParent.Freeze ();
+			newParent.Bind (Master);
+			
+			if (addOurselvesFirst) {
+				newParent.Add (this);
+				newParent.Add (requestor);
+			} else {
+				newParent.Add (requestor);
+				newParent.Add (this);
+			}
+			
+			if (parent != null)
+				parent.Add (newParent);
+			
+			if (Visible)
+				newParent.Show ();
+			
+			if (position != DockPlacement.Center &amp;&amp; data != null &amp;&amp;
+			    data is System.Int32) {
+				//PORT THIS:
+				//g_object_set (G_OBJECT (newParent), &quot;position&quot;, g_value_get_uint (other_data), NULL);
+			}
+			
+			DockObjectFlags &amp;= ~(DockObjectFlags.InReflow);
+
+			newParent.Thaw ();
+			if (parent != null)
+				parent.Thaw ();
+		}
+		
+		protected virtual void OnDragBegin ()
+		{
+		}
+		
+		protected virtual void OnDragEnd (bool cancelled)
+		{
+		}
+		
+		protected virtual void OnDragMotion (int x, int y)
+		{
+		}
+		
+		private void DetachMenu (Widget item, Menu menu)
+		{
+			if (item is DockItem)
+				((DockItem)item).menu = null;
+		}
+		
+		public void DockPopupMenu (uint button, uint time)
+		{
+			if (menu == null) {
+				menu = new Menu ();
+				menu.AttachToWidget (this, new MenuDetachFunc (DetachMenu));
+				
+				MenuItem mitem = new MenuItem (&quot;Hide&quot;);
+				mitem.Activated += new EventHandler (ItemHideCb);
+				menu.Append (mitem);
+			}
+			menu.ShowAll ();
+			menu.Popup (null, null, null, IntPtr.Zero, button, time);
+			
+		}
+		
+		private void ItemHideCb (object o, EventArgs e)
+		{
+			HideItem ();
+		}
+		
+		private void StartDrag ()
+		{
+			if (!IsRealized)
+				Realize ();
+			
+			DockObjectFlags |= DockObjectFlags.InDrag;
+			
+			/* grab the pointer so we receive all mouse events */
+			Gdk.Cursor fleur = new Gdk.Cursor (Gdk.CursorType.Fleur);
+			
+			/* grab the keyboard &amp; pointer */
+			Grab.Add (this);
+			
+			OnDragBegin ();
+			DockItemDragBeginHandler handler = DockItemDragBegin;
+			if (handler != null)
+				handler (this);
+		}
+		
+		private void EndDrag (bool cancel)
+		{
+			/* Release pointer &amp; keyboard. */
+			Grab.Remove (Grab.Current);
+			
+			OnDragEnd (cancel);
+			DockItemDragEndHandler handler = DockItemDragEnd;
+			if (handler != null)
+				handler (this, cancel);
+			
+			DockObjectFlags &amp;= ~(DockObjectFlags.InDrag);
+		}
+		
+		private void ShowHideGrip ()
+		{
+			if (grip != null) {
+				if (GripShown)
+					grip.Show ();
+				else
+					grip.Hide ();
+			}
+			QueueResize ();
+		}
+		
+		public void DockTo (DockItem target, DockPlacement position)
+		{
+			if (target == null &amp;&amp; position != DockPlacement.Floating)
+				return;
+
+			if (position == DockPlacement.Floating || target == null) {
+				if (!IsBound) {
+					Console.WriteLine (&quot;Attempting to bind an unbound item&quot;);
+					return;
+				}
+				
+				dragoffX = dragoffY = 0;
+				((Dock)Master.Controller).AddFloatingItem (this, 0, 0, -1, -1);
+			} else {
+				target.Dock (this, position, null);
+			}
+		}
+		
+		public virtual void SetOrientation (Orientation orientation)
+		{
+			if (Orientation != orientation) {
+				this.orientation = orientation;
+				if (IsDrawable)
+					QueueDraw ();
+				QueueResize ();
+				EmitPropertyEvent (&quot;orientation&quot;);
+			}
+		}
+		
+		public void HideGrip ()
+		{
+			if (GripShown)
+				ShowHideGrip ();
+		}
+		
+		public void ShowGrip ()
+		{
+			if (!GripShown)
+				ShowHideGrip ();
+		}
+		
+		public void Bind (Dock dock)
+		{
+			if (dock == null)
+				return;
+			
+			Bind (dock.Master);
+		}
+		
+		public void HideItem ()
+		{
+			if (!IsAttached)
+				/* already hidden/detached */
+				return;
+			
+			/* if the object is manual, create a new placeholder to be
+			   able to restore the position later */
+			if (!IsAutomatic)
+				ph = new DockPlaceholder (this, false);
+			
+			Freeze ();
+
+			/* hide our children first, so they can also set placeholders */
+			if (IsCompound)
+				Foreach (new Callback (HideChildItem));
+			
+			Detach (true);
+			Thaw ();
+		}
+		
+		private void HideChildItem (Widget widget)
+		{
+			if (!(widget is DockItem))
+				return;
+
+			DockItem item = widget as DockItem;
+			item.HideItem ();
+		}
+		
+		public void IconifyItem ()
+		{
+			DockObjectFlags |= DockObjectFlags.Iconified;
+			HideItem ();
+		}
+		
+		public void ShowItem ()
+		{
+			DockObjectFlags &amp;= ~(DockObjectFlags.Iconified);
+			
+			if (ph != null) {
+				ph.Add (this);
+				ph = null;
+			} else if (IsBound) {
+				if (Master.Controller != null) {
+					Master.Controller.Dock (this, DockPlacement.Floating, null);
+				}
+			}
+		}
+		
+		public virtual void SetDefaultPosition (DockObject reference)
+		{
+			ph = null;
+			
+			if (reference != null &amp;&amp; reference.IsAttached) {
+				if (reference is DockPlaceholder) {
+					ph = (DockPlaceholder)reference;
+				} else {
+					ph = new DockPlaceholder (reference, true);
+				}
+			}
+		}
+
+		private bool EventInGripWindow (Gdk.Event evnt)
+		{
+			if (grip != null &amp;&amp; grip.TitleWindow == evnt.Window)
+				return true;
+			else
+				return false;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItemBehavior.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItemBehavior.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItemBehavior.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,21 @@
+using System;
+
+namespace Gdl
+{
+	[Flags]
+	public enum DockItemBehavior
+	{
+		Normal,
+		NeverFloating = 1 &lt;&lt; 0,
+		NeverVertical = 1 &lt;&lt; 1,
+		NeverHorizontal = 1 &lt;&lt; 2,
+		Locked = 1 &lt;&lt; 3,
+		CantDockTop = 1 &lt;&lt; 4,
+		CantDockBottom = 1 &lt;&lt; 5,
+		CantDockLeft = 1 &lt;&lt; 6,
+		CantDockRight = 1 &lt;&lt; 7,
+		CantDockCenter = 1 &lt;&lt; 8,
+		CantClose = 1 &lt;&lt; 9,
+		CantIconify = 1 &lt;&lt; 10,
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItemGrip.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItemGrip.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockItemGrip.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,448 @@
+// created on 07/06/2004 at 2:52 P
+
+using System;
+using Gtk;
+
+namespace Gdl
+{
+	public class DockItemGrip : Container
+	{
+		private DockItem item;
+		private Gdk.Window titleWindow;
+		private Button closeButton;
+		private Button iconifyButton;
+		private Tooltips tooltips;
+		private Gdk.Pixbuf icon = null;
+		private string title;
+		private Pango.Layout layout = null;
+
+		protected DockItemGrip (IntPtr raw) : base (raw) { }
+		
+		protected DockItemGrip ()
+		{
+			Flags |= (int)WidgetFlags.NoWindow;
+			
+			Widget.PushCompositeChild ();
+			closeButton = new Button ();
+			Widget.PopCompositeChild ();
+			
+			closeButton.Flags &amp;= ~(int)WidgetFlags.CanFocus;
+			closeButton.Parent = this;
+			closeButton.Relief = ReliefStyle.None;
+			closeButton.Show ();
+			
+			Image image = new Image (Gdl.Stock.Close, IconSize.Menu);
+			closeButton.Add (image);
+			image.Show ();
+			
+			closeButton.Clicked += new EventHandler (CloseClicked);
+			
+			Widget.PushCompositeChild ();
+			iconifyButton = new Button ();
+			Widget.PopCompositeChild ();
+			
+			iconifyButton.Flags &amp;= ~(int)(WidgetFlags.CanFocus);
+			iconifyButton.Parent = this;
+			iconifyButton.Relief = ReliefStyle.None;
+			iconifyButton.Show ();
+			
+			image = new Image (Gdl.Stock.MenuLeft, IconSize.Menu);
+			iconifyButton.Add (image);
+			image.Show ();
+			
+			iconifyButton.Clicked += new EventHandler (IconifyClicked);
+			
+			tooltips = new Tooltips ();
+			tooltips.SetTip (iconifyButton, &quot;Iconify&quot;, &quot;Iconify this dock&quot;);
+			tooltips.SetTip (closeButton, &quot;Close&quot;, &quot;Close this dock&quot;);
+		}
+		
+		public DockItemGrip (DockItem item) : this ()
+		{
+			if (item == null)
+				throw new ArgumentNullException (&quot;A valid DockItem must be given&quot;);
+			Item = item;
+		}
+		
+		private Gdk.Pixbuf Icon {
+			get {
+				if (icon == null &amp;&amp; item.StockId != null)
+					icon = RenderIcon (item.StockId, IconSize.Menu, &quot;&quot;);
+				return icon;
+			}
+		}
+		
+		public DockItem Item {
+			get {
+				return item;
+			}
+			set {
+				item = value;
+				item.PropertyChanged += OnPropertyChanged;
+				
+				if (!item.CantClose)
+					closeButton.Show ();
+				else
+					closeButton.Hide ();
+
+				if (!item.CantIconify)
+					iconifyButton.Show ();
+				else
+					iconifyButton.Hide ();
+
+				icon = null;
+				layout = null;
+				title = null;
+			}
+		}
+		
+		private Pango.Layout Layout {
+			get {
+				if (layout == null) {
+					layout = CreatePangoLayout (Title);
+					layout.SingleParagraphMode = true;
+				}
+				return layout;
+			}
+		}
+		
+		private string Title {
+			get {
+				if (title == null) {
+					if (item.LongName != null)
+						title = item.LongName;
+					else
+						title = &quot;&quot;;
+				}
+				return title;
+			}
+			set {
+				title = value;
+				if (layout != null)
+					layout.SetText (Title);
+			}
+		}
+		
+		private Gdk.Rectangle TitleArea {
+			get {
+				Gdk.Rectangle area;
+				int bw = (int)BorderWidth;
+				int height, width;
+				
+				area.Width = Allocation.Width - 2 * bw;
+				
+				Layout.GetPixelSize (out width, out height);
+				
+				if (closeButton.Visible) {
+					height = Math.Max (height, closeButton.Allocation.Height);
+					area.Width -= closeButton.Allocation.Width;
+				}
+				
+				if (iconifyButton.Visible) {
+					height = Math.Max (height, iconifyButton.Allocation.Height);
+					area.Width -= iconifyButton.Allocation.Width;
+				}
+				
+				area.X = Allocation.X + bw;
+				area.Y = Allocation.Y + bw;
+				area.Height = height;
+				
+				if (Direction == TextDirection.Rtl)
+					area.X += (Allocation.Width - 2 * bw) - area.Width;
+					
+				return area;
+			}
+		}
+		
+		public Gdk.Window TitleWindow {
+			get {
+				return titleWindow;
+			}
+			set {
+				titleWindow = value;
+			}
+		}
+		
+		private void OnPropertyChanged (object o, string name)
+		{
+			switch (name) {
+			case &quot;StockId&quot;:
+				icon = RenderIcon (item.StockId, IconSize.Menu, &quot;&quot;);
+				break;
+			case &quot;LongName&quot;:
+				Title = item.LongName;
+				break;
+			case &quot;Behavior&quot;:
+				if (!item.CantClose)
+					closeButton.Show ();
+				else
+					closeButton.Hide ();
+
+				if (!item.CantIconify)
+					iconifyButton.Show ();
+				else
+					iconifyButton.Hide ();
+				break;
+			default:
+				break;
+			}
+		}
+
+		/*protected override void OnDestroyed ()
+		{
+			if (layout != null)
+				layout = null;
+			if (icon != null)
+				icon = null;
+			if (tooltips != null)
+				tooltips = null;
+			if (item != null) {
+				//TODO: Disconnect future signal handlers for notify.
+			}
+			item = null;
+			base.OnDestroyed ();
+		}*/
+	
+		protected override bool OnExposeEvent (Gdk.EventExpose evnt)
+		{
+			Gdk.Rectangle titleArea = TitleArea;
+			Gdk.Rectangle exposeArea;
+			
+			if (Icon != null) {
+				Gdk.Rectangle pixbufRect;
+				pixbufRect.Width = icon.Width;
+				pixbufRect.Height = icon.Height;
+				
+				if (Direction == TextDirection.Rtl) {
+					pixbufRect.X = titleArea.X + titleArea.Width - pixbufRect.Width;
+				} else {
+					pixbufRect.X = titleArea.X;
+					titleArea.X += pixbufRect.Width + 1;
+				}
+				
+				titleArea.Width -= pixbufRect.Width - 1;
+				pixbufRect.Y = titleArea.Y + (titleArea.Height - pixbufRect.Height) / 2;
+
+				if (evnt.Area.Intersect (pixbufRect, out exposeArea)) {
+					Gdk.GC gc = Style.BackgroundGC (State);
+					GdkWindow.DrawPixbuf (gc, icon, 0, 0, pixbufRect.X,
+							      pixbufRect.Y, pixbufRect.Width,
+							      pixbufRect.Height, Gdk.RgbDither.None,
+							      0, 0);
+				}
+			}
+
+			if (titleArea.Intersect (evnt.Area, out exposeArea)) {
+				int width, height, textX, textY;
+				Layout.GetPixelSize (out width, out height);
+				
+				if (Direction == TextDirection.Rtl)
+					textX = titleArea.X + titleArea.Width - width;
+				else
+					textX = titleArea.X;
+
+				textY = titleArea.Y + (titleArea.Height - height) / 2;
+	
+				Style.PaintLayout (Style, GdkWindow, State, true,
+						   exposeArea, this, null, textX,
+						   textY, layout);
+			}
+			
+			return base.OnExposeEvent (evnt);
+		}
+		
+		private void CloseClicked (object o, EventArgs e)
+		{
+			item.HideItem ();
+		}
+		
+		private void IconifyClicked (object o, EventArgs e)
+		{
+			item.IconifyItem ();
+			iconifyButton.InButton = false;
+			iconifyButton.Leave ();
+		}
+		
+		protected override void OnRealized ()
+		{
+			base.OnRealized ();
+
+			if (titleWindow == null) {
+				Gdk.WindowAttr attributes = new Gdk.WindowAttr ();
+				Gdk.Rectangle area = TitleArea;
+				
+				attributes.X = area.X;
+				attributes.Y = area.Y;
+				attributes.Width = area.Width;
+				attributes.Height = area.Height;
+				attributes.WindowType = Gdk.WindowType.Temp;
+				attributes.Wclass = Gdk.WindowClass.InputOnly;
+				attributes.OverrideRedirect = true;
+				attributes.EventMask = (int) (Events |
+					Gdk.EventMask.ButtonPressMask |
+					Gdk.EventMask.ButtonReleaseMask |
+					Gdk.EventMask.ButtonMotionMask);
+	
+				titleWindow = new Gdk.Window (ParentWindow, attributes,
+					(int) (Gdk.WindowAttributesType.X |
+					Gdk.WindowAttributesType.Y |
+					Gdk.WindowAttributesType.Noredir));
+
+				titleWindow.UserData = Handle;
+				titleWindow.Cursor = new Gdk.Cursor (Display, Gdk.CursorType.Hand2);
+			}
+		}
+		
+		protected override void OnUnrealized ()
+		{
+			if (titleWindow != null) {
+				titleWindow.UserData = IntPtr.Zero;
+				titleWindow.Destroy ();
+				titleWindow = null;
+			}
+
+			base.OnUnrealized ();
+		}
+		
+		protected override void OnMapped ()
+		{
+			base.OnMapped ();
+
+			if (titleWindow != null)
+				titleWindow.Show ();
+		}
+		
+		protected override void OnUnmapped ()
+		{
+			if (titleWindow != null)
+				titleWindow.Hide ();
+
+			base.OnUnmapped ();
+		}
+		
+		protected override void OnSizeRequested (ref Requisition requisition)
+		{
+			requisition.Width = (int)BorderWidth * 2;
+			requisition.Height = (int)BorderWidth * 2;
+
+			if (closeButton.Visible) {
+				Requisition childReq = closeButton.SizeRequest ();
+				requisition.Width += childReq.Width;
+				requisition.Height = Math.Max (requisition.Height,
+							       childReq.Height);
+			}
+			
+			if (iconifyButton.Visible) {
+				Requisition childReq = iconifyButton.SizeRequest ();
+				requisition.Width += childReq.Width;
+				requisition.Height = Math.Max (requisition.Height,
+							       childReq.Height);
+			}
+			
+			if (Icon != null) {
+				requisition.Width += icon.Width + 1;
+				requisition.Height = Math.Max (requisition.Height,
+							       icon.Height);
+			}
+		}
+		
+		private void EllipsizeLayout (int width)
+		{
+			if (width &lt;= 0) {
+				layout.SetText (&quot;&quot;);
+				return;
+			}
+			
+			int w, h, ell_w, ell_h, x, empty;
+			layout.GetPixelSize (out w, out h);
+			if (w &lt;= width) return;
+			
+			Pango.Layout ell = layout.Copy ();
+			ell.SetText (&quot;...&quot;);
+			ell.GetPixelSize (out ell_w, out ell_h);
+			if (width &lt; ell_w) {
+				layout.SetText (&quot;&quot;);
+				return;
+			}
+			
+			width -= ell_w;
+			Pango.LayoutLine line = layout.GetLine (0);
+			string text = layout.Text;
+			if (line.XToIndex (width * 1024, out x, out empty)) {
+				layout.SetText (text.Substring (0, x) + &quot;...&quot;);
+			}
+		}
+		
+		protected override void OnSizeAllocated (Gdk.Rectangle allocation)
+		{
+			base.OnSizeAllocated (allocation);
+
+			Gdk.Rectangle childAlloc;
+			int bw = (int)BorderWidth;
+			
+			if (Direction == TextDirection.Rtl)
+				childAlloc.X = allocation.X + bw;
+			else
+				childAlloc.X = allocation.X + allocation.Width - bw;
+			childAlloc.Y = allocation.Y + bw;
+			
+			if (closeButton.Visible) {
+				Requisition buttonReq = closeButton.SizeRequest ();
+
+				if (Direction != TextDirection.Rtl) 
+					childAlloc.X -= buttonReq.Width;
+				childAlloc.Width = buttonReq.Width;
+				childAlloc.Height = buttonReq.Height;
+				
+				closeButton.SizeAllocate (childAlloc);
+				
+				if (Direction == TextDirection.Rtl)
+					childAlloc.X += buttonReq.Width;
+			}
+			
+			if (iconifyButton.Visible) {
+				Requisition buttonReq = iconifyButton.SizeRequest ();
+				
+				if (Direction != TextDirection.Rtl)
+					childAlloc.X -= buttonReq.Width;
+				childAlloc.Width = buttonReq.Width;
+				childAlloc.Height = buttonReq.Height;
+				
+				iconifyButton.SizeAllocate (childAlloc);
+				
+				if (Direction == TextDirection.Rtl)
+					childAlloc.X += buttonReq.Width;
+			}
+			
+			if (TitleWindow != null) {
+				layout.SetText (title);
+
+				Gdk.Rectangle area = TitleArea;
+				titleWindow.MoveResize (area.X, area.Y,area.Width, area.Height);
+				
+				if (Icon != null)
+					area.Width -= icon.Width + 1;
+				
+				EllipsizeLayout (area.Width);
+			}
+		}
+		
+		protected override void OnAdded (Widget widget)
+		{
+			Console.WriteLine (&quot;You can't add a widget to DockItemGrip directly&quot;);
+		}
+		
+		protected override void OnRemoved (Widget widget)
+		{
+			Console.WriteLine (&quot;You can't remove a widget from DockItemGrip directly&quot;);
+		}
+		
+		protected override void ForAll (bool include_internals, CallbackInvoker invoker)
+		{
+			if (include_internals) {
+				invoker.Invoke (closeButton);
+				invoker.Invoke (iconifyButton);
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockLayout.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockLayout.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockLayout.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,84 @@
+// created on 6/24/2004 at 7:39 PM
+
+using System;
+using System.Collections;
+using Gtk;
+
+namespace Gdl
+{
+	// stub so I can compile in MD
+	public class DockLayout
+	{
+		DockMaster master;
+		Widget itemsui;
+		Widget layoutsui;
+		string[] layouts;
+		bool dirty;
+	
+		public DockLayout (Dock dock)
+		{
+		}
+		
+		public DockMaster Master {
+			get {
+				return master;
+			}
+			set {
+				master = value;
+			}
+		}
+		
+		// generated had Dirty and IsDirty
+		public bool IsDirty {
+			get {
+				return dirty;
+			}
+		}
+		
+		public Widget ItemsUi { 
+			get {
+				return itemsui;
+			}
+		}
+		
+		public Widget LayoutsUi { 
+			get {
+				return layoutsui;
+			}
+		}
+		
+		public void Attach (DockMaster master)
+		{
+			this.master = master;
+		}
+		
+		public void DeleteLayout (string name)
+		{
+		}
+	
+		public string[] GetLayouts (bool includeDefault)
+		{
+			return layouts;
+		}
+		
+		public void LoadLayout (string newLayout)
+		{
+		}
+		
+		public void LoadFromFile (string configFile)
+		{
+		}
+		
+		public void RunManager ()
+		{
+		}
+		
+		public void SaveLayout (string currentLayout)
+		{
+		}
+		
+		public void SaveToFile (string file)
+		{
+		}
+	}
+}
\ No newline at end of file

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockMaster.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockMaster.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockMaster.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,425 @@
+// created on 05/06/2004 at 11:14 A
+using System;
+using System.Collections;
+using Gtk;
+
+namespace Gdl
+{
+	public class DockMaster
+	{
+		private object obj;
+		private Hashtable dockObjects = new Hashtable ();
+		private ArrayList toplevelDocks = new ArrayList ();
+		private DockObject controller = null;
+		private int dockNumber = 1;
+		private int number = 1;
+		private string defaultTitle;
+		private Gdk.GC rootXorGC;
+		private bool rectDrawn;
+		private Dock rectOwner;
+		private DockRequest request;
+		private uint idle_layout_changed_id;
+		private Hashtable lockedItems = new Hashtable ();
+		private Hashtable unlockedItems = new Hashtable ();
+		
+		public event EventHandler LayoutChanged;
+
+		public DockMaster () 
+		{
+		}
+		
+		public string DefaultTitle {
+			get {
+				return defaultTitle;
+			}
+			set {
+				defaultTitle = value;
+			}
+		}
+		
+		public int DockNumber {
+			get {
+				return dockNumber;
+			}
+			set {
+				dockNumber = value;
+			}
+		}
+		
+		public ICollection DockObjects {
+			get {
+				return dockObjects.Values;
+			}
+		}
+		
+		public int Locked {
+			get {
+				if (unlockedItems.Count == 0)
+					return 1;
+				if (lockedItems.Count == 0)
+					return 0;
+				return -1;
+			}
+			set {
+				if (value &gt;= 0)
+					LockUnlock (value &gt; 0);
+			}
+		}
+		
+		public ArrayList TopLevelDocks {
+			get {
+				return toplevelDocks;
+			}
+		}
+		
+		protected void ForeachLockUnlock (DockItem item, bool locked)
+		{
+			item.Locked = locked;
+			if (item.IsCompound) {
+				/*PORT THIS: Container.Foreach doesnt take the arg i need it to take.
+				        gtk_container_foreach (GTK_CONTAINER (item),
+                               (GtkCallback) ForeachLockUnlock,
+                               (gpointer) locked);*/
+			}
+		}
+		
+		public void LockUnlock (bool locked)
+		{
+			foreach (Dock dock in toplevelDocks) {
+				if (dock.Root != null &amp;&amp; dock.Root is DockItem)
+					ForeachLockUnlock ((DockItem)dock.Root, locked);
+			}
+			/*PORT THIS:
+			    // just to be sure hidden items are set too
+    gdl_dock_master_foreach (master,
+                             (GFunc) ForeachLockUnlock,
+                             (gpointer) locked);*/
+		}
+		
+		public void Add (DockObject obj)
+		{
+			if (obj == null)
+				return;
+
+			if (!obj.IsAutomatic) {
+				/* create a name for the object if it doesn't have one */
+				if (obj.Name == null)
+					obj.Name = &quot;__dock_&quot; + number++;
+
+				/* add the object to our hash list */
+				if (dockObjects.Contains (obj.Name))
+					Console.WriteLine (&quot;Unable to add object, name \&quot;{0}\&quot; taken&quot;, obj.Name);
+				else
+					dockObjects.Add (obj.Name, obj);
+			}
+			
+			if (obj is Dock) {
+				/* if this is the first toplevel we are adding, name it controller */
+				if (toplevelDocks.Count == 0)
+					controller = obj;
+				
+				/* add dock to the toplevel list */
+				if (((Dock)obj).Floating)
+					toplevelDocks.Insert (0, obj);
+				else
+					toplevelDocks.Add (obj);
+				
+				/* we are interested in the dock request this toplevel
+				 * receives to update the layout */
+				obj.Docked += OnItemDocked;
+			} else if (obj is DockItem) {
+				DockItem item = obj as DockItem;
+				
+				/* we need to connect the item's events */
+				item.Detached += OnItemDetached;
+				item.Docked += OnItemDocked;
+				item.DockItemDragBegin += OnDragBegin;
+				item.DockItemMotion += OnDragMotion;
+				item.DockItemDragEnd += OnDragEnd;
+
+				/* register to &quot;locked&quot; notification if the item has a grip,
+				 * and add the item to the corresponding hash */
+				item.PropertyChanged += OnItemPropertyChanged;
+
+				/* post a layout_changed emission if the item is not automatic
+				 * (since it should be added to the items model) */
+				if (!item.IsAutomatic) {
+					// FIXME: Emit a LayoutChanged event?
+				}
+			}
+		}
+		
+		public void Remove (DockObject obj)
+		{
+			if (obj == null)
+				return;
+	
+			/*if (obj is DockItem &amp;&amp; ((DockItem)obj).HasGrip) {
+				int locked = Locked;
+				if (lockedItems.Contains (obj)) {
+					lockedItems.Remove (obj);
+					if (Locked != locked) {
+						//g_object_notify (G_OBJECT (this), &quot;locked&quot;);
+					}
+				}
+				if (unlockedItems.Contains (obj)) {
+					lockedItems.Remove (obj);
+					if (Locked != locked) {
+						//g_object_notify (G_OBJECT (this), &quot;locked&quot;);
+					}
+				}
+			}*/
+			
+			if (obj is Dock) {
+				toplevelDocks.Remove (obj);
+
+				if (obj == controller) {
+					DockObject newController = null;
+					ArrayList reversed = toplevelDocks;
+					reversed.Reverse ();
+					foreach (DockObject item in reversed) {
+						if (!item.IsAutomatic) {
+							newController = item;
+							break;
+						}
+					}
+					if (newController != null) {
+						controller = newController;
+					} else {
+						controller = null;
+					}
+				}
+			}
+			
+			if (obj is DockItem) {
+				DockItem item = obj as DockItem;
+				item.Detached -= OnItemDetached;
+				item.Docked -= OnItemDocked;
+				item.DockItemDragBegin -= OnDragBegin;
+				item.DockItemMotion -= OnDragMotion;
+				item.DockItemDragEnd -= OnDragEnd;
+			}
+			
+			if (obj.Name != null &amp;&amp; dockObjects.Contains (obj.Name))
+				dockObjects.Remove (obj.Name);
+			
+			/* post a layout_changed emission if the item is not automatic
+			 * (since it should be removed from the items model) */
+			if (!obj.IsAutomatic)
+				EmitLayoutChangedEvent ();
+		}
+		
+		public DockObject GetObject (string name)
+		{
+			if (name == null)
+				return null;
+			return (DockObject)dockObjects[name];
+		}
+		
+		public DockObject Controller {
+			get { return controller; }
+			set {
+				if (value != null) {
+					if (value.IsAutomatic)
+						Console.WriteLine (&quot;New controller is automatic, only manual dock objects should be named controller&quot;);
+					if (!toplevelDocks.Contains (value))
+						Add (value);
+					controller = value;
+				} else {
+					controller = null;
+				}
+			}
+		}
+		
+		internal void EmitLayoutChangedEvent ()
+		{
+			// FIXME: emit the LayoutChanged event here.
+		}
+		
+		private void OnItemDetached (object o, DetachedArgs args)
+		{
+		}
+		
+		private void OnItemDocked (object o, DockedArgs args)
+		{
+		}
+		
+		private void OnItemPropertyChanged (object o, string name)
+		{
+		}
+		
+		private void OnDragBegin (DockItem item)
+		{
+			/* Set the target to itself so it won't go floating with just a click. */
+			request = new DockRequest ();
+			request.Applicant = item;
+			request.Target = item;
+			request.Position = DockPlacement.Floating;
+			request.Extra = IntPtr.Zero;
+
+			rectDrawn = false;
+			rectOwner = null;
+		}
+		
+		private void OnDragEnd (DockItem item, bool cancelled)
+		{
+			if (item != request.Applicant)  {
+				Console.WriteLine (&quot;Dragged item is not the same as the one we started with&quot;);
+				return;
+			}
+			
+			/* Erase previously drawn rectangle */
+			if (rectDrawn)
+				XorRect ();
+			
+			/* cancel conditions */
+			if (cancelled || request.Applicant == request.Target)
+				return;
+
+			request.Target.Dock (request.Applicant,
+					     request.Position,
+					     request.Extra);
+			
+			EmitLayoutChangedEvent ();
+		}
+		
+		private void OnDragMotion (DockItem item, int rootX, int rootY)
+		{
+			Dock dock = null;
+			int winX, winY;
+			int x, y;
+			bool mayDock = false;
+			DockRequest myRequest = new DockRequest (request);
+
+			if (item != request.Applicant)  {
+				Console.WriteLine (&quot;Dragged item is not the same as the one we started with&quot;);
+				return;
+			}
+			
+			/* first look under the pointer */
+			Gdk.Window window = Gdk.Window.AtPointer (out winX, out winY);
+			if (window != null &amp;&amp; window.UserData != IntPtr.Zero) {
+				/* ok, now get the widget who owns that window and see if we can
+				   get to a Dock by walking up the hierarchy */
+				Widget widget = GLib.Object.GetObject (window.UserData, false) as Widget;
+				while (widget != null &amp;&amp; (!(widget is Dock) ||
+				       (widget is DockObject &amp;&amp; ((DockObject)widget).Master != this)))
+						widget = widget.Parent;
+				
+				if (widget != null) {
+					int winW, winH, depth;
+					
+					/* verify that the pointer is still in that dock
+					   (the user could have moved it) */
+					widget.GdkWindow.GetGeometry (out winX, out winY,
+								      out winW, out winH,
+								      out depth);
+					widget.GdkWindow.GetOrigin (out winX, out winY);
+					if (rootX &gt;= winX &amp;&amp; rootX &lt; winX + winW &amp;&amp;
+					    rootY &gt;= winY &amp;&amp; rootY &lt; winY + winH)
+						dock = widget as Dock;
+				}
+			}
+			
+			if (dock != null) {
+				/* translate root coordinates into dock object coordinates
+				   (i.e. widget coordinates) */
+				dock.GdkWindow.GetOrigin (out winX, out winY);
+				x = rootX - winX;
+				y = rootY - winY;
+				mayDock = dock.OnDockRequest (x, y, ref myRequest);
+			} else {
+				/* try to dock the item in all the docks in the ring in turn */
+				foreach (Dock topDock in toplevelDocks) {
+					if (topDock.GdkWindow == null)
+						Console.WriteLine (&quot;Dock has no GdkWindow: {0}, {1}&quot;, topDock.Name, topDock);
+					/* translate root coordinates into dock object
+					   coordinates (i.e. widget coordinates) */
+					topDock.GdkWindow.GetOrigin (out winX, out winY);
+					x = rootX - winX;
+					y = rootY - winY;
+					mayDock = topDock.OnDockRequest (x, y, ref myRequest);
+					if (mayDock)
+						break;
+				}
+			}
+
+			if (!mayDock) {
+				dock = null;
+				
+				myRequest.Target = Dock.GetTopLevel (item);
+				myRequest.Position = DockPlacement.Floating;
+				Requisition preferredSize = item.PreferredSize;
+				myRequest.Width = preferredSize.Width;
+				myRequest.Height = preferredSize.Height;
+				myRequest.X = rootX - item.DragOffX;
+				myRequest.Y = rootY - item.DragOffY;
+				
+				Gdk.Rectangle rect = new Gdk.Rectangle (myRequest.X,
+									myRequest.Y,
+									myRequest.Width,
+									myRequest.Height);
+				myRequest.Extra = rect;
+			}
+			
+			if (!(myRequest.X == request.X &amp;&amp;
+			      myRequest.Y == request.Y &amp;&amp;
+			      myRequest.Width == request.Width &amp;&amp;
+			      myRequest.Height == request.Height &amp;&amp;
+			      dock == rectOwner)) {
+			      
+				/* erase the previous rectangle */
+				if (rectDrawn)
+					XorRect ();
+			}
+			
+			request = myRequest;
+			rectOwner = dock;
+			
+			/* draw the previous rectangle */
+			if (!rectDrawn)
+				XorRect ();
+		}
+
+		private void XorRect ()
+		{
+			rectDrawn = !rectDrawn;
+
+			if (rectOwner != null) {
+				Gdk.Rectangle rect = new Gdk.Rectangle (request.X,
+								        request.Y,
+								        request.Width,
+								        request.Height);
+				rectOwner.XorRect (rect);
+				return;
+			}
+			
+			Gdk.Window window = Gdk.Global.DefaultRootWindow;
+			
+			if (rootXorGC == null) {
+				Gdk.GCValues values = new Gdk.GCValues ();
+				values.Function = Gdk.Function.Invert;
+				values.SubwindowMode = Gdk.SubwindowMode.IncludeInferiors;
+
+				rootXorGC = new Gdk.GC (window);
+				rootXorGC.SetValues (values, Gdk.GCValuesMask.Function |
+						     Gdk.GCValuesMask.Subwindow);
+			}
+			
+			rootXorGC.SetLineAttributes (1, Gdk.LineStyle.OnOffDash,
+						     Gdk.CapStyle.NotLast,
+						     Gdk.JoinStyle.Bevel);
+
+			rootXorGC.SetDashes (1, new sbyte[] {1, 1}, 2);
+			
+			window.DrawRectangle (rootXorGC, false, request.X, request.Y,
+					      request.Width, request.Height);
+			
+			rootXorGC.SetDashes (0, new sbyte[] {1, 1}, 2);
+
+			window.DrawRectangle (rootXorGC, false, request.X + 1,
+					      request.Y + 1, request.Width - 2,
+					      request.Height - 2);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockNotebook.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockNotebook.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockNotebook.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,195 @@
+// created on 07/06/2004 at 5:44 P
+
+using System;
+using Gtk;
+
+namespace Gdl
+{
+	public class DockNotebook : DockItem
+	{
+		private struct DockInfo
+		{
+			public DockPlacement position;
+			public object data;
+			
+			public DockInfo (DockPlacement position, object data)
+			{
+				this.position = position;
+				this.data = data;
+			}
+		}
+		
+		private DockInfo dockInfo;
+		private CallbackInvoker storedInvoker;
+
+		protected DockNotebook (IntPtr raw) : base (raw) { }
+
+		static DockNotebook ()
+		{
+			Rc.ParseString (&quot;style \&quot;gdl-dock-notebook-default\&quot; {\n&quot; +
+			                    &quot;xthickness = 2\n&quot; +
+			                    &quot;ythickness = 2\n&quot; +
+			                    &quot;}\n&quot; +
+			                    &quot;widget_class \&quot;*.GtkNotebook.Gdl_DockItem\&quot; &quot; +
+			                    &quot;style : gtk \&quot;gdl-dock-notebook-default\&quot;\n&quot;);
+		}
+		
+		public DockNotebook ()
+		{
+			Child = new Notebook ();
+			Child.Parent = this;
+			((Notebook)Child).TabPos = PositionType.Bottom;
+			//((Notebook)Child).SwitchPage += new SwitchPageHandler (SwitchPageCb);
+			//((Notebook)Child).ButtonPressEvent += new ButtonPressEvent (ButtonPressCb);
+			//((Notebook)Child).ButtonReleaseEvent += new ButtonReleaseEvent (ButtonReleaseCb);
+			((Notebook)Child).Scrollable = true;
+			Child.Show ();
+			DockObjectFlags &amp;= DockObjectFlags.Automatic;
+		}
+		
+		protected void SwitchPageHandler (object o, SwitchPageArgs e)
+		{
+			//Does this code need to be ported at all?
+		}
+
+		/*protected override void OnDestroyed ()
+		{
+			base.OnDestroyed ();
+			if (Child != null) {
+				Child.Unparent ();
+				Child = null;
+			}
+		}*/
+		
+		protected override void OnAdded (Widget widget)
+		{
+			if (widget == null || !(widget is DockItem))
+				return;
+
+			Dock ((DockObject)widget, DockPlacement.Center, null);
+		}
+		
+		protected override void ForAll (bool includeInternals, CallbackInvoker invoker)
+		{
+			if (includeInternals) {
+				base.ForAll (includeInternals, invoker);
+			} else {
+				if (Child != null) {
+					storedInvoker = invoker;
+					((Notebook)Child).Foreach (new Callback (ChildForAll));
+				}
+			}
+		}
+		
+		private void ChildForAll (Widget widget)
+		{
+			storedInvoker.Invoke (widget);
+		}
+		
+		private void DockChild (Widget w)
+		{
+			if (w is DockObject)
+				Dock ((DockObject)w, dockInfo.position, dockInfo.data);
+		}
+		
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
+		{
+			/* we only add support for DockPlacement.Center docking
+			   strategy here... for the rest use our parent class' method */
+			if (position == DockPlacement.Center) {
+				/* we can only dock simple (not compound) items */
+				if (requestor.IsCompound) {
+					requestor.Freeze ();
+					dockInfo = new DockInfo (position, data);
+					requestor.Foreach (new Callback (DockChild));
+					requestor.Thaw ();
+				} else {
+					DockItem requestorItem = requestor as DockItem;
+					Widget label = requestorItem.TabLabel;
+					if (label == null) {
+						label = new Label (requestorItem.LongName);
+						requestorItem.TabLabel = label;
+					}
+					
+					int tabPosition = -1;
+					if (data is Int32)
+						tabPosition = Convert.ToInt32 (data);
+					((Notebook)Child).InsertPage (requestor, label, tabPosition);
+					requestor.DockObjectFlags |= DockObjectFlags.Attached;
+				}
+			} else {
+				base.OnDocked (requestor, position, data);
+			}
+		}
+		
+		public override void SetOrientation (Orientation orientation)
+		{
+			if (Child != null &amp;&amp; Child is Notebook) {
+				if (orientation == Orientation.Horizontal)
+					((Notebook)Child).TabPos = PositionType.Top;
+				else
+					((Notebook)Child).TabPos = PositionType.Left;
+			}
+			base.SetOrientation (orientation);
+		}
+		
+		public override bool OnChildPlacement (DockObject child, ref DockPlacement position)
+		{
+			DockPlacement pos = DockPlacement.None;
+			if (Child != null) {
+				foreach (Widget widget in ((Notebook)Child).Children) {
+					if (widget == child) {
+						pos = DockPlacement.Center;
+						break;
+					}
+				}
+			}
+			if (pos != DockPlacement.None) {
+				position = pos;
+				return true;
+			}
+			return false;
+		}
+		
+		public override void OnPresent (DockObject child)
+		{
+			Notebook nb = Child as Notebook;
+			
+			int i = nb.PageNum (child);
+			if (i &gt;= 0)
+				nb.CurrentPage = i;
+
+			base.OnPresent (child);
+		}
+		
+		public override bool OnReorder (DockObject requestor, DockPlacement position, object other_data)
+		{
+			bool handled = false;
+			int current_position, new_pos = -1;
+			
+			if (Child != null &amp;&amp; position == DockPlacement.Center) {
+				current_position = ((Notebook)Child).PageNum (requestor);
+				if (current_position &gt;= 0) {
+					handled = true;
+					if (other_data is Int32)
+						new_pos = Convert.ToInt32 (other_data);
+					((Notebook)Child).ReorderChild (requestor, new_pos);
+				}
+			}
+			return handled;
+		}
+		
+		public override bool IsCompound {
+			get { return true; }
+		}
+		
+		public int Page {
+			get { return ((Notebook)Child).CurrentPage; }
+			set { ((Notebook)Child).CurrentPage = value; }
+		}
+		
+		public override bool HasGrip {
+			get { return false; }
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockObject.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockObject.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockObject.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,405 @@
+// project created on 04/06/2004 at 6:37 P
+using System;
+using Gtk;
+
+namespace Gdl
+{
+	public delegate void PropertyChangedHandler (object o, string name);
+
+	public class DockObject : Container
+	{	
+		private DockObjectFlags flags = DockObjectFlags.Automatic;
+		private int freezeCount = 0;
+		private DockMaster master;
+		private string name;
+		private string longName;
+		private string stockid;
+		private bool reducePending;
+		
+		public event DetachedHandler Detached;
+		public event DockedHandler Docked;
+		public event PropertyChangedHandler PropertyChanged;
+
+		protected DockObject (IntPtr raw) : base (raw) { }
+		protected DockObject () : base () { }
+		
+		public DockObjectFlags DockObjectFlags {
+			get {
+				return flags;
+			}
+			set {
+				flags = value;
+				EmitPropertyEvent (&quot;DockObjectFlags&quot;);
+			}
+		}
+		
+		public bool InDetach {
+			get {
+				return ((flags &amp; DockObjectFlags.InDetach) != 0);
+			}
+		}
+		
+		public bool InReflow {
+			get {
+				return ((flags &amp; DockObjectFlags.InReflow) != 0);
+			}
+		}
+		
+		public bool IsAttached {
+			get {
+				return ((flags &amp; DockObjectFlags.Attached) != 0);
+			}
+		}
+		
+		public bool IsAutomatic {
+			get {
+				return ((flags &amp; DockObjectFlags.Automatic) != 0);
+			}
+		}
+		
+		public bool IsBound {
+			get {
+				return master != null;
+			}
+		}
+		
+		public virtual bool IsCompound {
+			get {
+				return true;
+			}
+		}
+		
+		public bool IsFrozen {
+			get {
+				return freezeCount &gt; 0;
+			}
+		}
+		
+		public string LongName {
+			get {
+				return longName;
+			}
+			set {
+				longName = value;
+				EmitPropertyEvent (&quot;LongName&quot;);
+			}
+		}
+		
+		public DockMaster Master {
+			get {
+				return master;
+			}
+			set {
+				if (value != null)
+					Bind (master);
+				else
+					Unbind ();
+				EmitPropertyEvent (&quot;Master&quot;);
+			}
+		}
+		
+		public new string Name {
+			get {
+				return name;
+			}
+			set {
+				name = value;
+				EmitPropertyEvent (&quot;Name&quot;);
+			}
+		}
+		
+		public DockObject ParentObject {
+			get {
+				Widget parent = Parent;
+				while (parent != null &amp;&amp; !(parent is DockObject)) {
+					parent = parent.Parent;
+				}
+				return parent != null ? (DockObject)parent : null;
+			}
+		}
+
+		public string StockId {
+			get {
+				return stockid;
+			}
+			set {
+				stockid = value;
+				EmitPropertyEvent (&quot;StockId&quot;);
+			}
+		}
+
+		protected override void OnDestroyed ()
+		{
+			if (IsCompound) {
+				/* detach our dock object children if we have some, and even
+				   if we are not attached, so they can get notification */
+				Freeze ();
+				foreach (DockObject child in Children)
+					child.Detach (true);
+				reducePending = false;
+				Thaw ();
+			}
+
+			if (IsAttached)
+				/* detach ourselves */
+				Detach (false);
+
+			if (Master != null)
+				/* finally unbind us */
+				Unbind ();
+
+			base.OnDestroyed ();
+		}
+		
+		protected override void OnShown ()
+		{
+			if (IsCompound)
+				foreach (Widget child in Children)
+					child.Show ();
+
+			base.OnShown ();
+		}
+		
+		protected override void OnHidden ()
+		{
+			if (IsCompound)
+				foreach (Widget child in Children)
+					child.Hide ();
+
+			base.OnHidden ();
+		}
+		
+		public virtual void OnDetached (bool recursive)
+		{
+			/* detach children */
+			if (recursive &amp;&amp; IsCompound) {
+				foreach (DockObject child in Children) {
+					child.Detach (recursive);
+				}
+			}
+			
+			/* detach the object itself */
+			flags &amp;= ~(DockObjectFlags.Attached);
+			DockObject parent = ParentObject;
+			if (Parent != null &amp;&amp; Parent is Container)
+				((Container)Parent).Remove (this);
+
+			if (parent != null)
+				parent.Reduce ();
+		}
+		
+		public virtual void OnReduce ()
+		{
+			if (!IsCompound)
+				return;
+				
+			DockObject parent = ParentObject;
+			Widget[] children = Children;
+			if (children.Length &lt;= 1) {
+				if (parent != null)
+					parent.Freeze ();
+
+				Freeze ();
+				Detach (false);
+
+				foreach (Widget widget in children) {
+					DockObject child = widget as DockObject;
+					child.flags |= DockObjectFlags.InReflow;
+					child.Detach (false);
+					if (parent != null)
+						parent.Add (child);
+					child.flags &amp;= ~(DockObjectFlags.InReflow);
+				}
+				
+				reducePending = false;
+
+				Thaw ();
+				if (parent != null)
+					parent.Thaw ();
+			}
+		}
+		
+		public virtual bool OnDockRequest (int x, int y, ref DockRequest request)
+		{
+			return false;
+		}
+		
+		public virtual void OnDocked (DockObject requestor, DockPlacement position, object data)
+		{
+		}
+		
+		public virtual bool OnReorder (DockObject child, DockPlacement new_position, object data)
+		{
+			return false;
+		}
+		
+		public virtual void OnPresent (DockObject child)
+		{
+			Show ();			
+		}
+		
+		public virtual bool OnChildPlacement (DockObject child, ref DockPlacement placement)
+		{
+			return false;
+		}
+		
+		public bool ChildPlacement (DockObject child, ref DockPlacement placement)
+		{
+			if (!IsCompound)
+				return false;
+			
+			return OnChildPlacement (child, ref placement);
+		}
+		
+		public void Detach (bool recursive)
+		{
+			if (!IsAttached)
+				return;
+				
+			/* freeze the object to avoid reducing while detaching children */
+			Freeze ();
+			
+			DockObjectFlags |= DockObjectFlags.InDetach;
+			OnDetached (recursive);
+			DetachedHandler handler = Detached;
+			if (handler != null) {
+				DetachedArgs args = new DetachedArgs (recursive);
+				handler (this, args);
+			}
+			DockObjectFlags &amp;= ~(DockObjectFlags.InDetach);
+
+			Thaw ();		
+		}
+		
+		public void Dock (DockObject requestor, DockPlacement position, object data)
+		{
+			if (requestor == null || requestor == this)
+				return;
+				
+			if (master == null) {
+				Console.WriteLine (&quot;Dock operation requested in a non-bound object {}.&quot;, this);
+				Console.WriteLine (&quot;This might break.&quot;);
+			}
+
+			if (!requestor.IsBound)
+				requestor.Bind (Master);
+
+			if (requestor.Master != Master) {
+				Console.WriteLine (&quot;Cannot dock {0} to {1} as they belong to different masters.&quot;,
+						   requestor, this);
+				return;
+			}
+
+			/* first, see if we can optimize things by reordering */
+			if (position != DockPlacement.None) {
+				DockObject parent = ParentObject;
+				if (OnReorder (requestor, position, data) ||
+				    (parent != null &amp;&amp; parent.OnReorder (requestor, position, data)))
+					return;
+			}
+
+			/* freeze the object, since under some conditions it might
+			   be destroyed when detaching the requestor */
+			Freeze ();
+
+			/* detach the requestor before docking */
+			if (requestor.IsAttached)
+				requestor.Detach (false);
+
+			/* notify interested parties that an object has been docked. */
+			if (position != DockPlacement.None) {
+				OnDocked (requestor, position, data);
+				DockedHandler handler = Docked;
+				if (handler != null) {
+					DockedArgs args = new DockedArgs (requestor, position);
+					handler (this, args);
+				}
+			}
+			
+			Thaw ();
+		}
+		
+		public void Present (DockObject child)
+		{
+			if (ParentObject != null)
+				/* chain the call to our parent */
+				ParentObject.Present (this);
+			
+			OnPresent (child);
+		}
+
+		public void Reduce ()
+		{
+			if (IsFrozen) {
+				reducePending = true;
+				return;
+			}
+
+			OnReduce ();		
+		}
+
+		public void Freeze ()
+		{
+			freezeCount++;
+		}
+		
+		public void Thaw ()
+		{
+			if (freezeCount &lt; 0) {
+				Console.WriteLine (&quot;DockObject.Thaw: freezeCount &lt; 0&quot;);
+				return;
+			}
+
+			freezeCount--;
+
+			if (freezeCount == 0 &amp;&amp; reducePending) {
+				reducePending = false;
+				Reduce ();
+			}
+		}
+		
+		public void Bind (DockMaster master)
+		{
+			if (master == null) {
+				Console.WriteLine (&quot;Passed master is null&quot;);
+				Console.WriteLine (System.Environment.StackTrace);
+				return;
+			}
+			if (this.master == master) {
+				Console.WriteLine (&quot;Passed master is this master&quot;);
+				return;
+			}
+			if (this.master != null) {
+				Console.WriteLine (&quot;Attempt to bind an already bound object&quot;);
+				return;
+			}
+			
+			master.Add (this);
+			this.master = master;
+			EmitPropertyEvent (&quot;Master&quot;);
+		}
+		
+		public void Unbind ()
+		{
+			if (IsAttached)
+				Detach (true);
+
+			if (master != null) {
+				DockMaster _master = master;
+				master = null;
+				_master.Remove (this);
+				EmitPropertyEvent (&quot;Master&quot;);
+			}
+		}
+		
+		protected void EmitPropertyEvent (string name)
+		{
+			// Make a local assignment of the handler here to prevent
+			// any race conditions if the PropertyChanged value changes
+			// to null after the != null check.
+			PropertyChangedHandler handler = PropertyChanged;
+			if (handler != null)
+				handler (this, name);
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockObjectFlags.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockObjectFlags.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockObjectFlags.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,17 @@
+using System;
+
+namespace Gdl
+{
+	[Flags]
+	public enum DockObjectFlags
+	{
+		Automatic = 1 &lt;&lt; 0,
+		Attached = 1 &lt;&lt; 1,
+		InReflow = 1 &lt;&lt; 2,
+		InDetach = 1 &lt;&lt; 3,
+		InDrag = 1 &lt;&lt; 4,
+		InPreDrag = 1 &lt;&lt; 5,
+		Iconified = 1 &lt;&lt; 6,
+		UserAction = 1 &lt;&lt; 7 
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPaned.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPaned.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPaned.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,261 @@
+// created on 07/06/2004 at 5:43 P
+
+using System;
+using Gtk;
+
+namespace Gdl
+{
+	public class DockPaned : DockItem
+	{
+		private readonly float SplitRatio = 0.3f;
+		private bool positionChanged = false;
+
+		protected DockPaned (IntPtr raw) : base (raw) { }
+
+		public DockPaned (Orientation orientation)
+		{
+			CreateChild (orientation);
+		}
+		
+		public override bool HasGrip {
+			get {
+				return false;
+			}
+		}
+		
+		public override bool IsCompound {
+			get {
+				return true;
+			}
+		}
+		
+		public int Position {
+			get {
+				if (Child != null &amp;&amp; Child is Paned) {
+					return ((Paned)Child).Position;
+				}
+				return 0;
+			}
+			set {
+				if (Child != null &amp;&amp; Child is Paned) {
+					((Paned)Child).Position = value;
+				}
+			}
+		}
+		
+		private void CreateChild (Orientation orientation)
+		{
+			if (Child != null)
+				Child.Unparent ();
+			
+			Orientation = orientation;
+
+			/* create the container paned */
+			if (orientation == Orientation.Horizontal)
+				Child = new HPaned ();
+			else
+				Child = new VPaned ();
+			
+			// FIXME: Register signal handlers.						
+												
+			Child.Parent = this;
+			Child.Show ();
+		}
+		
+		protected override void OnAdded (Widget widget)
+		{
+			if (Child == null)
+				return;
+		
+			Paned paned = Child as Paned;
+			if (paned.Child1 != null &amp;&amp; paned.Child2 != null)
+				return;
+			
+			DockItem item = widget as DockItem;
+			DockPlacement pos = DockPlacement.None;			
+			if (paned.Child1 == null)
+				pos = (Orientation == Orientation.Horizontal ?
+				       DockPlacement.Left : DockPlacement.Top);
+			else
+				pos = (Orientation == Orientation.Horizontal ?
+				       DockPlacement.Right : DockPlacement.Bottom);
+			
+			if (pos != DockPlacement.None)
+				Dock (item, pos, null);
+		}
+		
+		private void childForAll (Widget widget)
+		{
+			stored_invoker.Invoke (widget);
+		}
+
+		/*protected override void OnDestroyed ()
+		{
+			base.OnDestroyed ();
+			if (Child != null) {
+				Child.Unparent ();
+				Child = null;
+			}
+		}*/	
+	
+		private CallbackInvoker stored_invoker;
+		protected override void ForAll (bool include_internals, CallbackInvoker invoker)
+		{
+			if (include_internals) {
+				base.ForAll (include_internals, invoker);
+			} else {
+				if (Child != null) {
+					stored_invoker = invoker;
+					((Paned)Child).Foreach (new Callback (childForAll));
+				}
+			}
+		}
+		
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
+		{
+			if (Child == null)
+				return;
+		
+			Paned paned = (Paned)Child;
+			bool done = false;
+			
+			/* see if we can dock the item in our paned */
+			switch (Orientation) {
+			case Orientation.Horizontal:
+				if (paned.Child1 == null &amp;&amp; position == DockPlacement.Left) {
+					paned.Pack1 (requestor, false, false);
+					done = true;
+				} else if (paned.Child2 == null &amp;&amp; position == DockPlacement.Right) {
+					paned.Pack2 (requestor, true, false);
+					done = true;
+				}
+				break;
+			case Orientation.Vertical:
+				if (paned.Child1 == null &amp;&amp; position == DockPlacement.Top) {
+					paned.Pack1 (requestor, false, false);
+					done = true;
+				} else if (paned.Child2 == null &amp;&amp; position == DockPlacement.Bottom) {
+					paned.Pack2 (requestor, true, false);
+					done = true;
+				}
+				break;
+			}
+			
+			if (!done) {
+				/* this will create another paned and reparent us there */
+				base.OnDocked (requestor, position, data);
+			} else {
+				((DockItem)requestor).ShowGrip ();
+				requestor.DockObjectFlags |= DockObjectFlags.Attached;
+			}
+		}
+		
+		public override bool OnDockRequest (int x, int y, ref DockRequest request)
+		{
+			bool mayDock = false;
+
+			/* we get (x,y) in our allocation coordinates system */
+			
+			/* Get item's allocation. */
+			Gdk.Rectangle alloc = Allocation;
+			int bw = (int)BorderWidth;
+
+			/* Get coordinates relative to our window. */
+			int relX = x - alloc.X;
+			int relY = y - alloc.Y;
+			
+			/* Location is inside. */
+			if (relX &gt; 0 &amp;&amp; relX &lt; alloc.Width &amp;&amp;
+			    relY &gt; 0 &amp;&amp; relY &lt; alloc.Height) {
+			    	int divider = -1;
+			    
+				/* It's inside our area. */
+				mayDock = true;
+
+				/* these are for calculating the extra docking parameter */
+				Requisition other = ((DockItem)request.Applicant).PreferredSize;
+				Requisition my = PreferredSize;
+				
+				/* Set docking indicator rectangle to the Dock size. */
+				request.X = bw;
+				request.Y = bw;
+				request.Width = alloc.Width - 2 * bw;
+				request.Height = alloc.Height - 2 * bw;
+				request.Target = this;
+
+				/* See if it's in the BorderWidth band. */
+				if (relX &lt; bw) {
+					request.Position = DockPlacement.Left;
+					request.Width = (int)(request.Width * SplitRatio);
+					divider = other.Width;
+				} else if (relX &gt; alloc.Width - bw) {
+					request.Position = DockPlacement.Right;
+					request.X += (int)(request.Width * (1 - SplitRatio));
+					request.Width = (int)(request.Width * SplitRatio);
+					divider = Math.Max (0, my.Width - other.Width);
+				} else if (relY &lt; bw) {
+					request.Position = DockPlacement.Top;
+					request.Height = (int)(request.Height * SplitRatio);
+					divider = other.Height;
+				} else if (relY &gt; alloc.Height - bw) {
+					request.Position = DockPlacement.Bottom;
+					request.Y += (int)(request.Height * (1 - SplitRatio));
+					request.Height = (int)(request.Height * SplitRatio);
+					divider = Math.Max (0, my.Height - other.Height);
+				} else { /* Otherwise try our children. */
+					mayDock = false;
+					DockRequest myRequest = new DockRequest (request);
+					foreach (DockObject item in Children) {
+						if (item.OnDockRequest (relX, relY, ref myRequest)) {
+							mayDock = true;
+							request = myRequest;
+							break;
+						}
+					}
+					
+					if (!mayDock) {
+						/* the pointer is on the handle, so snap
+						   to top/bottom or left/right */
+						mayDock = true;
+						
+						if (Orientation == Orientation.Horizontal) {
+							if (relY &lt; alloc.Height / 2) {
+								request.Position = DockPlacement.Top;
+								request.Height = (int)(request.Height * SplitRatio);
+								divider = other.Height;
+							} else {
+								request.Position = DockPlacement.Bottom;
+								request.Y += (int)(request.Height * (1 - SplitRatio));
+								request.Height = (int)(request.Height * SplitRatio);
+								divider = Math.Max (0, my.Height - other.Height);
+							}
+						} else {
+							if (relX &lt; alloc.Width / 2) {
+								request.Position = DockPlacement.Left;
+								request.Width = (int)(request.Width * SplitRatio);
+								divider = other.Width;
+							} else {
+								request.Position = DockPlacement.Right;
+								request.X += (int)(request.Width * (1 - SplitRatio));
+								request.Width = (int)(request.Width * SplitRatio);
+								divider = Math.Max (0, my.Width - other.Width);
+							}
+						}
+					}
+				}
+				
+				if (divider &gt;= 0 &amp;&amp; request.Position != DockPlacement.Center)
+					request.Extra = divider;
+
+				if (mayDock) {				
+					/* adjust returned coordinates so they are
+					   relative to our allocation */
+					request.X += alloc.X;
+					request.Y += alloc.Y;
+				}
+			}
+
+			return mayDock;
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockParamFlags.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockParamFlags.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockParamFlags.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,10 @@
+using System;
+
+namespace Gdl
+{
+	public enum DockParamFlags
+	{
+		Export = 1,
+		After = 2,
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPlaceholder.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPlaceholder.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPlaceholder.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,182 @@
+// created on 07/06/2004 at 5:43 P
+
+using System;
+using System.Collections;
+using Gtk;
+
+namespace Gdl
+{
+	public class DockPlaceholder : DockObject
+	{
+		private DockObject host;
+		private bool sticky;
+		private ArrayList placementStack;
+		private int hostDetachHandler;
+		private int hostDockHandler;
+
+		protected DockPlaceholder (IntPtr raw) : base (raw) { }
+		
+		public DockPlaceholder (string name, DockObject obj,
+					DockPlacement position, bool sticky)
+		{
+			Flags |= (int)WidgetFlags.NoWindow;
+			Flags &amp;= ~((int)WidgetFlags.CanFocus);
+
+			Sticky = sticky;
+			Name = name;
+
+			if (obj != null) {
+				Attach (obj);
+
+				if (position == DockPlacement.None)
+					position = DockPlacement.Center;
+
+				NextPlacement = position;
+				if (obj is Dock)
+					NextPlacement = DockPlacement.Center;
+
+				DoExcursion ();
+			}
+		}
+		
+		public DockPlaceholder (DockObject obj, bool sticky) :
+			this (obj.Name, obj, DockPlacement.None, sticky) { }
+		
+		public DockObject Host {
+			get {
+				return host;
+			}
+			set {
+				Attach (value);
+				EmitPropertyEvent (&quot;Host&quot;);
+			}
+		}
+		
+		public DockPlacement NextPlacement {
+			get {
+				if (placementStack != null &amp;&amp; placementStack.Count != 0)
+					return (DockPlacement)placementStack[0];
+				return DockPlacement.Center;
+			}
+			set { 
+				if (placementStack == null)
+					placementStack = new ArrayList ();
+				placementStack.Insert (0, value);
+			}
+		}
+
+		public bool Sticky {
+			get {
+				return sticky;
+			}
+			set {
+				sticky = value;
+				EmitPropertyEvent (&quot;Sticky&quot;);
+			}
+		}
+		
+		/*protected override void OnDestroyed ()
+		{
+			if (host != null)
+				OnDetached (false);
+			base.OnDestroyed ();
+		}*/
+		
+		protected override void OnAdded (Widget widget)
+		{
+			if (!(widget is DockItem))
+				return;
+
+			Dock ((DockItem)widget, NextPlacement, null);
+		}
+		
+		public override void OnDetached (bool recursive)
+		{
+			DisconnectHost ();
+			placementStack = null;
+			DockObjectFlags &amp;= ~(DockObjectFlags.Attached);
+		}
+		
+		public override void OnReduce ()
+		{
+		}
+		
+		public override void OnDocked (DockObject requestor, DockPlacement position, object data)
+		{
+			if (host != null) {
+				host.Dock (requestor, position, data);
+			} else {
+				if (!IsBound) {
+					Console.WriteLine (&quot;Attempt to dock a dock object to an unbound placeholder&quot;);
+					return;
+				}
+				Master.Controller.Dock (requestor, DockPlacement.Floating, null);
+			}
+		}
+		
+		public override void OnPresent (DockObject child)
+		{
+		}
+		
+		public void DoExcursion ()
+		{
+			if (host != null &amp;&amp; !Sticky &amp;&amp; placementStack != null &amp;&amp; host.IsCompound) {
+				DockPlacement pos;
+				DockPlacement stack_pos = NextPlacement;
+				foreach (Widget child in host.Children) {
+					DockObject item = child as DockObject;
+					if (item == null)
+						continue;
+					pos = stack_pos;
+					
+					host.ChildPlacement (item, ref pos);
+					if (pos == stack_pos) {
+						placementStack.RemoveAt (0);
+						DisconnectHost ();
+						ConnectHost (item);
+						
+						if (!item.InReflow)
+							DoExcursion ();
+						break;
+					}
+				}
+			}
+		}
+		
+		private void DisconnectHost ()
+		{
+			//Disconnect from host detach and dock events here.
+			host = null;
+		}
+		
+		private void ConnectHost (DockObject new_host)
+		{
+			if (host != null)
+				DisconnectHost ();
+			host = new_host;
+			//Connect to host detach and dock events here.
+		}
+		
+		public void Attach (DockObject objekt)
+		{
+			if (objekt == null)
+				return;
+			
+			if (!IsBound)
+				Bind(objekt.Master);
+			
+			if (objekt.Master != Master)
+				return;
+			
+			Freeze ();
+			
+			if (host != null)
+				Detach (false);
+			
+			ConnectHost (objekt);
+			
+			DockObjectFlags |= DockObjectFlags.Attached;
+			Thaw ();
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPlacement.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPlacement.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockPlacement.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,20 @@
+// This file was generated by the Gtk# code generator.
+// Any changes made will be lost if regenerated.
+
+namespace Gdl {
+
+	using System;
+
+#region Autogenerated code
+	public enum DockPlacement {
+
+		None,
+		Top,
+		Bottom,
+		Right,
+		Left,
+		Center,
+		Floating,
+	}
+#endregion
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockRequest.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockRequest.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockRequest.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,90 @@
+// created on 04/06/2004 at 6:59 P
+
+using System;
+using Gtk;
+using Gdk;
+
+namespace Gdl
+{
+	public class DockRequest
+	{
+		private DockObject applicant;
+		private DockObject target;
+		private DockPlacement position;
+		private int x, y, width, height;
+		private object extra;
+		
+		public DockRequest ()
+		{
+		}
+		
+		public DockRequest (DockRequest copy)
+		{
+			applicant = copy.Applicant;
+			target = copy.Target;
+			x = copy.X;
+			y = copy.Y;
+			width = copy.Width;
+			height = copy.Height;
+			position = copy.Position;
+			
+			extra = copy.Extra;
+		}
+		
+		public DockObject Applicant {
+			get { return applicant; }
+			set { applicant = value; }
+		}
+		
+		public DockObject Target {
+			get { return target; }
+			set { target = value; }
+		}
+		
+		public DockPlacement Position {
+			get { return position; }
+			set { position = value; }
+		}
+
+		public int X {
+			get {
+				return x;
+			}
+			set {
+				x = value;
+			}
+		}
+		
+		public int Y {
+			get {
+				return y;
+			}
+			set {
+				y = value;
+			}
+		}
+		
+		public int Width {
+			get {
+				return width;
+			}
+			set {
+				width = value;
+			}
+		}
+		
+		public int Height {
+			get {
+				return height;
+			}
+			set {
+				height = value;
+			}
+		}
+						
+		public object Extra {
+			get { return extra; }
+			set { extra = value; }
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockedHandler.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockedHandler.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/DockedHandler.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,29 @@
+using System;
+
+namespace Gdl
+{
+	public delegate void DockedHandler (object o, DockedArgs args);
+	
+	public class DockedArgs : EventArgs {
+		private DockObject requestor;
+		private DockPlacement position;
+	
+		public DockedArgs (DockObject requestor, DockPlacement position)
+		{
+			this.requestor = requestor;
+			this.position = position;
+		}
+	
+		public DockObject Requestor {
+			get {
+				return requestor;
+			}
+		}
+		
+		public DockPlacement Position {
+			get {
+				return position;
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/GdlDockTest.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/GdlDockTest.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/GdlDockTest.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,116 @@
+using System;
+using Gtk;
+using Gdl;
+
+class T
+{
+	static void Main (string[] args)
+	{
+		new T (args);
+	}
+	
+	T (string[] args)
+	{
+		Application.Init ();
+		Window app = new Window (&quot;test&quot;);
+		app.SetDefaultSize (400, 400);
+		app.DeleteEvent += new DeleteEventHandler (OnAppDelete);
+		
+		Box table = new VBox (false, 5);
+		table.BorderWidth = 10;
+		app.Add (table);
+		
+		Dock dock = new Dock ();		
+		DockLayout layout = new DockLayout (dock);
+		DockBar dockbar = new DockBar (dock);
+		
+		Box box = new HBox (false, 5);
+		box.PackStart (dockbar, false, false, 0);
+		box.PackEnd (dock, true, true, 0);
+		table.PackStart (box, true, true, 0);
+
+		DockItem di = new DockItem (&quot;item1&quot;, &quot;Item #1&quot;, DockItemBehavior.Locked);
+		di.Add (CreateTextView ());
+		dock.AddItem (di, DockPlacement.Top);
+		
+		DockItem di2 = new DockItem (&quot;item2&quot;, &quot;Item #2 has some large title&quot;,
+					     Gtk.Stock.Execute, DockItemBehavior.Normal);
+		di2.Add (new Button (&quot;Button 2&quot;));
+		dock.AddItem (di2, DockPlacement.Right);
+
+		DockItem di3 = new DockItem (&quot;item3&quot;, &quot;Item #3 has accented characters&quot;,/* (&#225;&#233;&#237;&#243;&#250;&#241;)&quot;,*/
+					     Gtk.Stock.Convert, DockItemBehavior.Normal |
+					     DockItemBehavior.CantClose);
+		di3.Add (new Button (&quot;Button 3&quot;));
+		dock.AddItem (di3, DockPlacement.Bottom);
+
+		DockItem[] items = new DockItem[4];
+		items[0] = new DockItem (&quot;item4&quot;, &quot;Item #4&quot;, Gtk.Stock.JustifyFill,
+					 DockItemBehavior.Normal | DockItemBehavior.CantIconify);
+		items[0].Add (CreateTextView ());
+		dock.AddItem (items[0], DockPlacement.Bottom);
+		
+		for (int i = 1; i &lt; 3; i++) {
+			string name = &quot;Item #&quot; + (i + 4);
+			items[i] = new DockItem (name, name, Gtk.Stock.New,
+						 DockItemBehavior.Normal);
+			items[i].Add (CreateTextView ());
+			items[i].Show ();
+
+	    		items[0].Dock (items[i], DockPlacement.Center, null);	    
+		}
+
+		di3.DockTo (di, DockPlacement.Top);
+		di2.DockTo (di3, DockPlacement.Right);
+		di2.DockTo (di3, DockPlacement.Left);
+		di2.DockTo (null, DockPlacement.Floating);
+
+		box = new HBox (true, 5);
+		table.PackEnd (box, false, false, 0);
+		
+		Button button = new Button (Gtk.Stock.Save);
+		button.Clicked += OnSaveLayout;
+		box.PackEnd (button, false, true, 0);
+		
+		button = new Button (&quot;Layout Manager&quot;);
+		button.Clicked += OnRunLayoutManager;
+		box.PackEnd (button, false, true, 0);
+
+		button = new Button (&quot;Dump XML&quot;);
+		button.Clicked += OnDumpXML;
+		box.PackEnd (button, false, true, 0);
+
+		app.ShowAll ();
+		Application.Run ();
+	}
+	
+	private Widget CreateTextView ()
+	{
+		ScrolledWindow sw = new ScrolledWindow (null, null);
+		sw.ShadowType = ShadowType.In;
+		sw.HscrollbarPolicy = PolicyType.Automatic;
+		sw.VscrollbarPolicy = PolicyType.Automatic;
+		TextView tv = new TextView ();
+		sw.Add (tv);
+		sw.ShowAll ();
+
+		return sw;
+	}
+	
+	private void OnSaveLayout (object o, EventArgs args)
+	{
+	}
+	
+	private void OnRunLayoutManager (object o, EventArgs args)
+	{
+	}
+	
+	private void OnDumpXML (object o, EventArgs args)
+	{
+	}
+	
+	private void OnAppDelete (object o, DeleteEventArgs args)
+	{
+		Application.Quit ();
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/Stock.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/Gdl/Stock.cs	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/Gdl/Stock.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,47 @@
+namespace Gdl {
+
+	using System;
+	using System.Collections;
+	using System.Runtime.InteropServices;
+	using Gtk;
+
+	public class Stock {
+
+		static Gtk.IconFactory stock = new Gtk.IconFactory ();
+
+		public static string Close {
+			 get { return &quot;gdl-close&quot;; }
+		}
+		public static string MenuLeft {
+			 get { return &quot;gdl-menu-left&quot;; }
+		}
+		public static string MenuRight {
+			 get { return &quot;gdl-menu-right&quot;; }
+		}
+		
+		static Stock ()
+		{
+			AddIcon (&quot;gdl-close&quot;, &quot;stock-close-12.png&quot;);
+			AddIcon (&quot;gdl-menu-left&quot;, &quot;stock-menu-left-12.png&quot;);
+			AddIcon (&quot;gdl-menu-right&quot;, &quot;stock-menu-right-12.png&quot;);
+			
+			stock.AddDefault ();
+		}
+		
+		static void AddIcon (string stockid, string file)
+		{
+			Gtk.IconSet iconset = stock.Lookup (stockid);
+			
+			if (iconset == null) {
+				iconset = new Gtk.IconSet ();
+				Gdk.Pixbuf img = new Gdk.Pixbuf (file);
+				IconSource source = new IconSource ();
+				source.Size = Gtk.IconSize.Menu;
+				source.SizeWildcarded = false;
+				source.Pixbuf = img;
+				iconset.AddSource (source);
+				stock.Add (stockid, iconset);
+			}
+		}
+	}
+}

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/gdl.build
===================================================================

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-close-12.png
===================================================================
(Binary files differ)


Property changes on: branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-close-12.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-menu-left-12.png
===================================================================
(Binary files differ)


Property changes on: branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-menu-left-12.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-menu-right-12.png
===================================================================
(Binary files differ)


Property changes on: branches/MonoDevelop-plan-43/src/Libraries/Gdl/stock-menu-right-12.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/MonoDevelop-plan-43/src/Libraries/libraries.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Libraries/libraries.build	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/Libraries/libraries.build	2004-08-11 13:49:39 UTC (rev 1931)
@@ -0,0 +1,3 @@
+&lt;?xml version=&quot;1.0&quot;?&gt;
+&lt;project name=&quot;monodevelop.libraries&quot; default=&quot;build&quot;&gt;
+&lt;/project&gt;

Copied: branches/MonoDevelop-plan-43/src/Plugins/Content (from rev 1929, branches/MonoDevelop-plan-43/src/Content)

Deleted: branches/MonoDevelop-plan-43/src/Plugins/Content/ContentManager.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Content/ContentManager.cs	2004-08-10 05:09:51 UTC (rev 1929)
+++ branches/MonoDevelop-plan-43/src/Plugins/Content/ContentManager.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -1,126 +0,0 @@
-//
-// ContentManager.cs: ContentManager (one instance per Workbench window) manages 
-// the display of open files in the Content Pane by providing one tab per file,
-// where each tab represents a ContentView that in turn uses one or more
-// NodeViewers to display the file content.
-//
-// Author:
-//   Jeroen Zwartepoorte &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
-//
-// (C) Copyright Jeroen Zwartepoorte 2004
-//
-
-using System;
-using System.Collections;
-using System.Reflection;
-using Gtk;
-using Gnome.Vfs;
-using log4net;
-using MonoDevelop.Node;
-using MonoDevelop.Workbench;
-
-namespace MonoDevelop.Content {
-	public class ContentManager : Notebook {
-		private static readonly ILog log = LogManager.GetLogger (typeof (ContentManager));
-		private static ArrayList factories = new ArrayList ();
-
-		public ContentManager ()
-		{
-			AddActions ();
-		}
-		
-		private void AddActions ()
-		{
-			ActionGroup group = new ActionGroup (&quot;ContentManager&quot;);
-			Action action;
-			
-			action = new Action (&quot;FileOpenAction&quot;, &quot;_Open...&quot;,
-					     &quot;Open a file&quot;, Gtk.Stock.Open);
-			action.Activated += new EventHandler (OnFileOpen);
-			group.Add (action);
-		
-			Workbench.Workbench.AddActionGroup (group);
-			Workbench.Workbench.AddUiFromFile (&quot;content.ui&quot;);
-		}
-
-		////////////////////////////////////////////////////////////////////////
-		// Event handlers
-		////////////////////////////////////////////////////////////////////////
-
-		private void OnFileOpen (object obj, EventArgs e)
-		{
-			// Ask the user which file to open.
-			FileChooserDialog fcd = new FileChooserDialog (&quot;Open File&quot;,
-								       (Window)Workbench.Workbench.ActiveWorkbench,
-								       FileChooserAction.Open,
-								       &quot;gnome-vfs&quot;);
-			fcd.AddButton (Stock.Cancel, ResponseType.Cancel);
-			fcd.AddButton (Stock.Open, ResponseType.Ok);
-			fcd.DefaultResponse = ResponseType.Ok;
-			int resp = fcd.Run ();
-			fcd.Hide ();
-			
-			if (resp != (int)ResponseType.Ok)
-				return;
-
-			string mimetype = Mime.GetMimeType (fcd.Filename);
-			log.Debug (&quot;Mimetype for &quot; + fcd.Filename + &quot; is &quot; + mimetype);
-
-			// Find a FileNode Type for the specified mimetype.
-			FileNodeEntry entry = FileNode.FindFileNodeType (mimetype);
-			if (entry == null) {
-				log.Debug (&quot;No matching FileNode found for mimetype \&quot;&quot; + mimetype + &quot;\&quot;&quot;);
-				return;
-			}
-
-			// Create a new FileNode for the specified file.
-			log.Debug (&quot;Found FileNode type: &quot; + entry.Type);
-			Type[] types = new Type[3];
-			types[0] = typeof (Project);
-			types[1] = typeof (Node);
-			types[2] = typeof (string);
-			ConstructorInfo ci = entry.Type.GetConstructor (BindingFlags.Instance | BindingFlags.Public,
-									null, CallingConventions.HasThis,
-									types, null);
-			object[] args = new object[3];
-			args[0] = null;
-			args[1] = null;
-			args[2] = fcd.Filename;
-			FileNode fn = (FileNode)ci.Invoke (args);
-			
-			// Find a suitable INodeViewer which can display the file.
-			foreach (INodeViewerFactory factory in factories) {
-				if (factory.CanDisplayNode (fn)) {
-					log.Debug (&quot;&quot; + factory + &quot; can display node &quot; + fn);
-					INodeViewer viewer = factory.CreateNodeViewer (fn);
-					AppendPage (viewer.ViewerWidget, new Label (fn.DisplayName));
-					viewer.ViewerWidget.ShowAll ();
-					break;
-				}
-			}
-		}
-	
-		////////////////////////////////////////////////////////////////////////
-		// Static methods
-		////////////////////////////////////////////////////////////////////////
-	
-		public static void AddNodeViewerFactory (INodeViewerFactory factory)
-		{
-			factories.Add (factory);
-		}
-	
-		public static void RemoveNodeViewerFactory (INodeViewerFactory factory)
-		{
-			factories.Remove (factory);
-		}
-		
-		public static void InitializePlugin (byte major, byte minor)
-		{
-			Workbench.Workbench.AddWidgetFactory (new ContentManagerWidgetFactory ());
-		}
-		
-		public static void FinalizePlugin ()
-		{
-		}
-	}
-}

Copied: branches/MonoDevelop-plan-43/src/Plugins/Content/ContentManager.cs (from rev 1930, branches/MonoDevelop-plan-43/src/Content/ContentManager.cs)

Deleted: branches/MonoDevelop-plan-43/src/Plugins/Content/content.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Content/content.build	2004-08-10 05:09:51 UTC (rev 1929)
+++ branches/MonoDevelop-plan-43/src/Plugins/Content/content.build	2004-08-11 13:49:39 UTC (rev 1931)
@@ -1,29 +0,0 @@
-&lt;?xml version=&quot;1.0&quot;?&gt;
-&lt;project name=&quot;monodevelop.plugins.content&quot; default=&quot;build&quot;&gt;
-    &lt;!-- build the project --&gt;
-    &lt;target name=&quot;build&quot; description=&quot;compiles the source code&quot;&gt;
-        &lt;property name=&quot;assemblyfile&quot; value=&quot;${path::combine(plugin.dir, 'content.dll')}&quot;/&gt;
-        &lt;csc target=&quot;library&quot; output=&quot;${assemblyfile}&quot; debug=&quot;${build.debug}&quot;&gt;
-            &lt;arg value=&quot;${gnome-sharp.libs}&quot;/&gt;
-            &lt;arg value=&quot;-r:/usr/lib/gnome-vfs-sharp.dll&quot;/&gt;
-            &lt;sources&gt;
-                &lt;include name=&quot;*.cs&quot;/&gt;
-            &lt;/sources&gt;
-            &lt;references basedir=&quot;${build.dir}&quot;&gt;
-                &lt;include name=&quot;bin/monodevelop.exe&quot;/&gt;
-                &lt;include name=&quot;lib/gdl-sharp.dll&quot;/&gt;
-                &lt;include name=&quot;lib/log4net.dll&quot;/&gt;
-                &lt;include name=&quot;lib/monodevelop/node.dll&quot;/&gt;
-                &lt;include name=&quot;lib/monodevelop/workbench.dll&quot;/&gt;
-            &lt;/references&gt;
-        &lt;/csc&gt;
-        
-        &lt;!-- install the plugin file --&gt;
-        &lt;copy file=&quot;content.plugin.in&quot; tofile=&quot;content.plugin&quot;/&gt;
-        &lt;replaceregex match=&quot;@assembly@&quot; replace=&quot;${assemblyfile}&quot; file=&quot;content.plugin&quot; byline=&quot;true&quot; /&gt;
-        &lt;move file=&quot;content.plugin&quot; todir=&quot;${plugin.dir}&quot;/&gt;
-        
-        &lt;!-- install the ui file --&gt;
-        &lt;copy file=&quot;content.ui&quot; todir=&quot;${ui.dir}&quot;/&gt;
-    &lt;/target&gt;
-&lt;/project&gt;

Copied: branches/MonoDevelop-plan-43/src/Plugins/Content/content.build (from rev 1930, branches/MonoDevelop-plan-43/src/Content/content.build)

Copied: branches/MonoDevelop-plan-43/src/Plugins/Editor (from rev 1929, branches/MonoDevelop-plan-43/src/Editor)

Deleted: branches/MonoDevelop-plan-43/src/Plugins/Editor/editor.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Editor/editor.build	2004-08-10 05:09:51 UTC (rev 1929)
+++ branches/MonoDevelop-plan-43/src/Plugins/Editor/editor.build	2004-08-11 13:49:39 UTC (rev 1931)
@@ -1,29 +0,0 @@
-&lt;?xml version=&quot;1.0&quot;?&gt;
-&lt;project name=&quot;monodevelop.plugins.editor&quot; default=&quot;build&quot;&gt;
-    &lt;!-- build the project --&gt;
-    &lt;target name=&quot;build&quot; description=&quot;compiles the source code&quot;&gt;
-        &lt;property name=&quot;assemblyfile&quot; value=&quot;${path::combine(plugin.dir, 'editor.dll')}&quot;/&gt;
-        &lt;csc target=&quot;library&quot; output=&quot;${assemblyfile}&quot; debug=&quot;${build.debug}&quot;&gt;
-            &lt;arg value=&quot;${gnome-sharp.libs}&quot;/&gt;
-            &lt;sources&gt;
-                &lt;include name=&quot;*.cs&quot;/&gt;
-            &lt;/sources&gt;
-            &lt;references basedir=&quot;${build.dir}&quot;&gt;
-                &lt;include name=&quot;bin/monodevelop.exe&quot;/&gt;
-                &lt;include name=&quot;lib/gdl-sharp.dll&quot;/&gt;
-                &lt;include name=&quot;lib/log4net.dll&quot;/&gt;
-                &lt;include name=&quot;lib/monodevelop/content.dll&quot;/&gt;
-                &lt;include name=&quot;lib/monodevelop/node.dll&quot;/&gt;
-                &lt;include name=&quot;lib/monodevelop/workbench.dll&quot;/&gt;
-            &lt;/references&gt;
-        &lt;/csc&gt;
-        
-        &lt;!-- install the plugin file --&gt;
-        &lt;copy file=&quot;editor.plugin.in&quot; tofile=&quot;editor.plugin&quot;/&gt;
-        &lt;replaceregex match=&quot;@assembly@&quot; replace=&quot;${assemblyfile}&quot; file=&quot;editor.plugin&quot; byline=&quot;true&quot; /&gt;
-        &lt;move file=&quot;editor.plugin&quot; todir=&quot;${plugin.dir}&quot;/&gt;
-        
-        &lt;!-- install the ui file --&gt;
-        &lt;copy file=&quot;editor.ui&quot; todir=&quot;${ui.dir}&quot;/&gt;
-    &lt;/target&gt;
-&lt;/project&gt;

Copied: branches/MonoDevelop-plan-43/src/Plugins/Editor/editor.build (from rev 1930, branches/MonoDevelop-plan-43/src/Editor/editor.build)

Copied: branches/MonoDevelop-plan-43/src/Plugins/Node (from rev 1929, branches/MonoDevelop-plan-43/src/Node)

Deleted: branches/MonoDevelop-plan-43/src/Plugins/Node/FileNode.cs
===================================================================
--- branches/MonoDevelop-plan-43/src/Node/FileNode.cs	2004-08-10 05:09:51 UTC (rev 1929)
+++ branches/MonoDevelop-plan-43/src/Plugins/Node/FileNode.cs	2004-08-11 13:49:39 UTC (rev 1931)
@@ -1,262 +0,0 @@
-//
-// FileNode.cs: Abstract base class from which all nodes must inherit.
-//
-// Author:
-//   Jeroen Zwartepoorte &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jeroen at xs4all.nl</A>&gt;
-//
-// (C) Copyright Jeroen Zwartepoorte 2004
-//
-
-using System;
-using System.Collections;
-using System.IO;
-using System.Reflection;
-using Gdk;
-using Gnome.Vfs;
-using log4net;
-
-namespace MonoDevelop.Node {
-	public class FileNode : Node {
-		static private readonly ILog log = LogManager.GetLogger (typeof (FileNode));
-		static private Hashtable fileNodeTypes = new Hashtable ();
-	
-		private Node parent;
-		private Project project;
-		private Gnome.Vfs.Uri uri;
-		private Gnome.Vfs.FileInfo info;
-
-		public FileNode (Project project, Node parent, string uri)
-		{
-			this.project = project;
-			this.parent = parent;
-			this.uri = new Gnome.Vfs.Uri (uri);
-		}
-		
-		public override bool CanDelete {
-			get {
-				return uri.Exists &amp;&amp; 
-				       ((File.GetAttributes (filename) &amp;
-				         FileAttributes.ReadOnly) != FileAttributes.ReadOnly);
-			}
-		}
-		
-		public override bool CanRename {
-			get {
-				return uri.Exists &amp;&amp; 
-				       ((File.GetAttributes (filename) &amp;
-				         FileAttributes.ReadOnly) != FileAttributes.ReadOnly);
-			}
-		}
-		
-		public override bool CanRevert {
-			get {
-				return Vfs.Exists (filename);
-			}
-		}
-		
-		public override bool CanSave {
-			get {
-				return !uri.Exists || 
-				       (uri.Exists &amp;&amp; 
-				        ((File.GetAttributes (filename) &amp;
-				          FileAttributes.ReadOnly) != FileAttributes.ReadOnly));
-			}
-		}
-		
-		public override bool CanSaveAs {
-			get {
-				return true;
-			}
-		}
-		
-		public override Node[] Children {
-			get {
-				return null;
-			}
-		}
-		
-		public override Node[] DisplayChildren {
-			get {
-				return null;
-			}
-		}
-		
-		public override Pixbuf DisplayIcon {
-			get {
-				return null;
-			}
-		}
-		
-		public override string DisplayName {
-			get {
-				return Path.GetFileName (filename);
-			}
-		}
-		
-		public override bool HasChildren {
-			get {
-				return false;
-			}
-		}
-		
-		public override bool HasDisplayChildren {
-			get {
-				return false;
-			}
-		}
-		
-		public override string LongDisplayName {
-			get {
-				return Path.GetFullPath (filename);
-			}
-		}
-		
-		public string MimeType {
-			get {
-				return mimetype;
-			}
-		}
-		
-		public override Node Parent {
-			get {
-				return parent;
-			}
-			set {
-			}
-		}
-		
-		public override bool Modified {
-			get {
-				return false;
-			}
-		}
-		
-		public override bool Persistent {
-			get {
-				return false;
-			}
-		}
-		
-		public override Project Project {
-			get {
-				return project;
-			}
-		}
-		
-		protected Gnome.Vfs.FileInfo FileInfo {
-			get {
-				if (info == null)
-					info = new Gnome.Vfs.FileInfo (uri);
-				return info;
-			}
-		}
-		
-		public override void Delete ()
-		{
-		}
-		
-		public override void MakePersistent ()
-		{
-		}
-
-		public override void Rename ()
-		{
-		}
-		
-		public override void Revert ()
-		{
-		}
-		
-		public override void Save ()
-		{
-		}
-		
-		public override void SaveAndDelete ()
-		{
-		}
-		
-		public override void SaveAs ()
-		{
-		}
-		
-		////////////////////////////////////////////////////////////////////////
-		// Static methods
-		////////////////////////////////////////////////////////////////////////
-	
-		static public FileNodeEntry FindFileNodeType (string mimetype)
-		{
-			if (fileNodeTypes.Contains (mimetype)) {
-				ArrayList types = fileNodeTypes[mimetype] as ArrayList;
-				return types[0] as FileNodeEntry;
-			} else {
-				Console.WriteLine (&quot;doesn't contain {0}&quot;, mimetype);
-				return null;
-			}
-		}
-		
-		static public void RegisterFileNodeType (string mimetype,
-							 string description,
-							 Type type,
-							 Pixbuf icon)
-		{
-			ArrayList types;
-			
-			log.Debug (&quot;Registering filenode: &quot; + mimetype);
-
-			if (fileNodeTypes.Contains (mimetype)) {
-				types = fileNodeTypes[mimetype] as ArrayList;
-				types.Add (new FileNodeEntry (mimetype,
-							      description,
-							      type, icon));			
-				fileNodeTypes[mimetype] = types;
-			} else {
-				types = new ArrayList ();
-				types.Add (new FileNodeEntry (mimetype,
-							      description,
-							      type, icon));			
-				fileNodeTypes.Add (mimetype, types);
-			}
-
-		}
-	}
-	
-	public class FileNodeEntry {
-		private string mimetype;
-		private string description;
-		private Type type;
-		private Pixbuf icon;
-		
-		public string MimeType {
-			get {
-				return mimetype;
-			}
-		}
-		
-		public string Description {
-			get {
-				return description;
-			}
-		}
-		
-		public Type Type {
-			get {
-				return type;
-			}
-		}
-		
-		public Pixbuf Icon {
-			get {
-				return icon;
-			}
-		}
-	
-		public FileNodeEntry (string mimetype, string description,
-				      Type type, Pixbuf icon)
-		{
-			this.mimetype = mimetype;
-			this.description = description;
-			this.type = type;
-			this.icon = icon;
-		}
-	}
-}

Copied: branches/MonoDevelop-plan-43/src/Plugins/Node/FileNode.cs (from rev 1930, branches/MonoDevelop-plan-43/src/Node/FileNode.cs)

Deleted: branches/MonoDevelop-plan-43/src/Plugins/Node/node.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Node/node.build	2004-08-10 05:09:51 UTC (rev 1929)
+++ branches/MonoDevelop-plan-43/src/Plugins/Node/node.build	2004-08-11 13:49:39 UTC (rev 1931)
@@ -1,23 +0,0 @@
-&lt;?xml version=&quot;1.0&quot;?&gt;
-&lt;project name=&quot;monodevelop.plugins.node&quot; default=&quot;build&quot;&gt;
-    &lt;!-- build the project --&gt;
-    &lt;target name=&quot;build&quot; description=&quot;compiles the source code&quot;&gt;
-        &lt;property name=&quot;assemblyfile&quot; value=&quot;${path::combine(plugin.dir, 'node.dll')}&quot;/&gt;
-        &lt;csc target=&quot;library&quot; output=&quot;${assemblyfile}&quot; debug=&quot;${build.debug}&quot;&gt;
-            &lt;arg value=&quot;${gtk-sharp.libs}&quot;/&gt;
-            &lt;arg value=&quot;${gnome-vfs-sharp.libs}&quot;/&gt;
-            &lt;sources&gt;
-                &lt;include name=&quot;*.cs&quot;/&gt;
-            &lt;/sources&gt;
-            &lt;references basedir=&quot;${build.dir}&quot;&gt;
-                &lt;include name=&quot;lib/log4net.dll&quot;/&gt;
-                &lt;include name=&quot;bin/monodevelop.exe&quot;/&gt;
-            &lt;/references&gt;
-        &lt;/csc&gt;
-        
-        &lt;!-- install the plugin file --&gt;
-        &lt;copy file=&quot;node.plugin.in&quot; tofile=&quot;node.plugin&quot;/&gt;
-        &lt;replaceregex match=&quot;@assembly@&quot; replace=&quot;${assemblyfile}&quot; file=&quot;node.plugin&quot; byline=&quot;true&quot; /&gt;
-        &lt;move file=&quot;node.plugin&quot; todir=&quot;${plugin.dir}&quot;/&gt;
-    &lt;/target&gt;
-&lt;/project&gt;

Copied: branches/MonoDevelop-plan-43/src/Plugins/Node/node.build (from rev 1930, branches/MonoDevelop-plan-43/src/Node/node.build)

Copied: branches/MonoDevelop-plan-43/src/Plugins/Workbench (from rev 1929, branches/MonoDevelop-plan-43/src/Workbench)

Deleted: branches/MonoDevelop-plan-43/src/Plugins/Workbench/workbench.build
===================================================================
--- branches/MonoDevelop-plan-43/src/Workbench/workbench.build	2004-08-10 05:09:51 UTC (rev 1929)
+++ branches/MonoDevelop-plan-43/src/Plugins/Workbench/workbench.build	2004-08-11 13:49:39 UTC (rev 1931)
@@ -1,26 +0,0 @@
-&lt;?xml version=&quot;1.0&quot;?&gt;
-&lt;project name=&quot;monodevelop.plugins.workbench&quot; default=&quot;build&quot;&gt;
-    &lt;!-- build the project --&gt;
-    &lt;target name=&quot;build&quot; description=&quot;compiles the source code&quot;&gt;
-        &lt;property name=&quot;assemblyfile&quot; value=&quot;${path::combine(plugin.dir, 'workbench.dll')}&quot;/&gt;
-        &lt;csc target=&quot;library&quot; output=&quot;${assemblyfile}&quot; debug=&quot;${build.debug}&quot;&gt;
-            &lt;arg value=&quot;${gnome-sharp.libs}&quot;/&gt;
-            &lt;sources&gt;
-                &lt;include name=&quot;*.cs&quot;/&gt;
-            &lt;/sources&gt;
-            &lt;references basedir=&quot;${build.dir}&quot;&gt;
-                &lt;include name=&quot;lib/gdl-sharp.dll&quot;/&gt;
-                &lt;include name=&quot;lib/log4net.dll&quot;/&gt;
-                &lt;include name=&quot;bin/monodevelop.exe&quot;/&gt;
-            &lt;/references&gt;
-        &lt;/csc&gt;
-        
-        &lt;!-- install the plugin file --&gt;
-        &lt;copy file=&quot;workbench.plugin.in&quot; tofile=&quot;workbench.plugin&quot;/&gt;
-        &lt;replaceregex match=&quot;@assembly@&quot; replace=&quot;${assemblyfile}&quot; file=&quot;workbench.plugin&quot; byline=&quot;true&quot; /&gt;
-        &lt;move file=&quot;workbench.plugin&quot; todir=&quot;${plugin.dir}&quot;/&gt;
-        
-        &lt;!-- install the ui file --&gt;
-        &lt;copy file=&quot;workbench.ui&quot; todir=&quot;${ui.dir}&quot;/&gt;
-    &lt;/target&gt;
-&lt;/project&gt;

Copied: branches/MonoDevelop-plan-43/src/Plugins/Workbench/workbench.build (from rev 1930, branches/MonoDevelop-plan-43/src/Workbench/workbench.build)

Copied: branches/MonoDevelop-plan-43/src/Plugins/plugins.build (from rev 1930, branches/MonoDevelop-plan-43/src/plugins.build)

Deleted: branches/MonoDevelop-plan-43/src/plugins.build
===================================================================
--- branches/MonoDevelop-plan-43/src/plugins.build	2004-08-11 11:31:15 UTC (rev 1930)
+++ branches/MonoDevelop-plan-43/src/plugins.build	2004-08-11 13:49:39 UTC (rev 1931)
@@ -1,79 +0,0 @@
-&lt;?xml version=&quot;1.0&quot;?&gt;
-&lt;project name=&quot;monodevelop.plugins&quot; default=&quot;build&quot;&gt;
-    &lt;property name=&quot;plugin.dir&quot; value=&quot;${path::combine(lib.dir, 'monodevelop')}&quot;/&gt;
-    &lt;property name=&quot;ui.dir&quot; value=&quot;${path::combine(share.dir, 'ui')}&quot;/&gt;
-
-    &lt;!-- check for pkg-config dependencies and initialize properties --&gt;
-    &lt;target name=&quot;init&quot; description=&quot;initializes build properties&quot;&gt;
-        &lt;!-- check for gtk-sharp-2.0 --&gt;
-        &lt;if test=&quot;${pkg-config::exists('gtk-sharp-2.0')}&quot;&gt;
-            &lt;if test=&quot;${pkg-config::is-atleast-version('gtk-sharp-2.0', '1.2.99')}&quot;&gt;
-                &lt;property name=&quot;gtk-sharp.libs&quot; value=&quot;${pkg-config::get-link-flags('gtk-sharp-2.0')}&quot;/&gt;
-            &lt;/if&gt;
-        &lt;/if&gt;
-        &lt;!-- check for gnome-vfs-sharp-2.0 --&gt;
-        &lt;if test=&quot;${pkg-config::exists('gnome-vfs-sharp-2.0')}&quot;&gt;
-            &lt;if test=&quot;${pkg-config::is-atleast-version('gnome-vfs-sharp-2.0', '1.2.99')}&quot;&gt;
-                &lt;property name=&quot;gnome-vfs-sharp.libs&quot; value=&quot;${pkg-config::get-link-flags('gnome-vfs-sharp-2.0')}&quot;/&gt;
-            &lt;/if&gt;
-        &lt;/if&gt;
-        &lt;!-- check for gnome-sharp --&gt;
-        &lt;if test=&quot;${pkg-config::exists('gnome-sharp-2.0')}&quot;&gt;
-            &lt;if test=&quot;${pkg-config::is-atleast-version('gnome-sharp-2.0', '1.2.99')}&quot;&gt;
-                &lt;property name=&quot;gnome-sharp.libs&quot; value=&quot;${pkg-config::get-link-flags('gnome-sharp-2.0')}&quot;/&gt;
-            &lt;/if&gt;
-        &lt;/if&gt;
-        &lt;!-- check for gtksourceview-sharp --&gt;
-        &lt;if test=&quot;${pkg-config::exists('gtksourceview-sharp')}&quot;&gt;
-            &lt;if test=&quot;${pkg-config::is-atleast-version('gtksourceview-sharp', '0.3')}&quot;&gt;
-                &lt;property name=&quot;gtksourceview-sharp.libs&quot; value=&quot;${pkg-config::get-link-flags('gtksourceview-sharp')}&quot;/&gt;
-            &lt;/if&gt;
-        &lt;/if&gt;
-        
-        &lt;!-- output a message about required dependencies if not all dependencies exist --&gt;
-        &lt;if test=&quot;${not(property::exists('gtk-sharp.libs'))}&quot;&gt;
-            &lt;call target=&quot;dependencies&quot;/&gt;
-            &lt;fail message=&quot;gtk-sharp dependency not found&quot;/&gt;
-        &lt;/if&gt;
-        &lt;if test=&quot;${not(property::exists('gnome-vfs-sharp.libs'))}&quot;&gt;
-            &lt;call target=&quot;dependencies&quot;/&gt;
-            &lt;fail message=&quot;gnome-vfs-sharp dependency not found&quot;/&gt;
-        &lt;/if&gt;
-        &lt;if test=&quot;${not(property::exists('gnome-sharp.libs'))}&quot;&gt;
-            &lt;call target=&quot;dependencies&quot;/&gt;
-            &lt;fail message=&quot;gnome-sharp dependency not found&quot;/&gt;
-        &lt;/if&gt;
-        &lt;if test=&quot;${not(property::exists('gtksourceview-sharp.libs'))}&quot;&gt;
-            &lt;call target=&quot;dependencies&quot;/&gt;
-            &lt;fail message=&quot;gtksourceview-sharp dependency not found&quot;/&gt;
-        &lt;/if&gt;
-    &lt;/target&gt;
-
-    &lt;!-- output a list of required dependencies --&gt;
-    &lt;target name=&quot;dependencies&quot; description=&quot;outputs a list of required dependencies&quot;&gt;
-        &lt;echo message=&quot;MonoDevelop requires the following dependencies:&quot;/&gt;
-        &lt;echo message=&quot;    gtk-sharp-2.0 &gt;= 1.2.99&quot;/&gt;
-        &lt;echo message=&quot;    gtksourceview-sharp &gt;= 0.4&quot;/&gt;
-        &lt;echo message=&quot;&quot;/&gt;
-        &lt;echo message=&quot;Install these packages first before building MonoDevelop&quot;/&gt;
-    &lt;/target&gt;
-
-    &lt;!-- cleanup build files --&gt;
-    &lt;target name=&quot;clean&quot; description=&quot;remove all files created by the build task&quot;&gt;
-        &lt;delete dir=&quot;${plugin.dir}&quot; failonerror=&quot;false&quot;/&gt;
-    &lt;/target&gt;
-
-    &lt;!-- build the project --&gt;
-    &lt;target name=&quot;build&quot; depends=&quot;init&quot; description=&quot;compiles the source code&quot;&gt;
-        &lt;!-- create directories --&gt;
-        &lt;mkdir dir=&quot;${plugin.dir}&quot;/&gt;
-        &lt;!-- build MonoDevelop.Node assembly --&gt;
-        &lt;nant buildfile=&quot;Node/node.build&quot; target=&quot;build&quot;/&gt;
-        &lt;!-- build MonoDevelop.Workbench assembly --&gt;
-        &lt;nant buildfile=&quot;Workbench/workbench.build&quot; target=&quot;build&quot;/&gt;
-        &lt;!-- build MonoDevelop.Content assembly --&gt;
-        &lt;nant buildfile=&quot;Content/content.build&quot; target=&quot;build&quot;/&gt;
-        &lt;!-- build MonoDevelop.Editor assembly --&gt;
-        &lt;nant buildfile=&quot;Editor/editor.build&quot; target=&quot;build&quot;/&gt;
-    &lt;/target&gt;
-&lt;/project&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001537.html">[Monodevelop-patches-list] r1930 - in branches/MonoDevelop-plan-43: . build/bin build/lib/monodevelop src src/Content src/Core src/Editor src/Node src/Workbench
</A></li>
	<LI>Next message: <A HREF="001539.html">[Monodevelop-patches-list] r1932 - in branches/MonoDevelop-plan-43: . src/Libraries src/Libraries/Gdl src/Plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1538">[ date ]</a>
              <a href="thread.html#1538">[ thread ]</a>
              <a href="subject.html#1538">[ subject ]</a>
              <a href="author.html#1538">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
