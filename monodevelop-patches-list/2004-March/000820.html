<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1213 - in trunk/MonoDevelop/src: AddIns/BackendBindings/CSharpBinding AddIns/BackendBindings/CSharpBinding/Parser AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree Libraries/SharpRefactory Libraries/SharpRefactory/src Libraries/SharpRefactory/src/CodeDOM Libraries/SharpRefactory/src/Lexer Libraries/SharpRefactory/src/Lexer/Reader Libraries/SharpRefactory/src/Lexer/Specials Libraries/SharpRefactory/src/Parser/AST Libraries/SharpRefactory/src/Parser/AST/Expressions Libraries/SharpRefactory/src/Parser/AST/GlobalScope Libraries/SharpRefactory/src/Parser/AST/Statements Libraries/SharpRefactory/src/Parser/AST/TypeLevel Libraries/SharpRefactory/src/Parser/generated Libraries/SharpRefactory/src/Parser/generated/keywordlist Libraries/SharpRefactory/src/PrettyPrinter Libraries/SharpRefactory/src/VBConverter Main/Base Main/Base/Commands/VBConverter Main/Base/Services
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1213%20-%20in%20trunk/MonoDevelop/src%3A%20AddIns/BackendBindings/CSharpBinding%20AddIns/BackendBindings/CSharpBinding/Parser%20AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree%20Libraries/SharpRefactory%20Libraries/SharpRefactory/src%20Libraries/SharpRefactory/src/CodeDOM%20Libraries/SharpRefactory/src/Lexer%20Libraries/SharpRefactory/src/Lexer/Reader%20Libraries/SharpRefactory/src/Lexer/Specials%20Libraries/SharpRefactory/src/Parser/AST%20Libraries/SharpRefactory/src/Parser/AST/Expressions%20Libraries/SharpRefactory/src/Parser/AST/GlobalScope%20Libraries/SharpRefactory/src/Parser/AST/Statements%20Libraries/SharpRefactory/src/Parser/AST/TypeLevel%20Libraries/SharpRefactory/src/Parser/generated%20Libraries/SharpRefactory/src/Parser/generated/keywordlist%20Libraries/SharpRefactory/src/PrettyPrinter%20Libraries/SharpRefactory/src/VBConverter%20Main/Base%20Main/Base/Commands/VBConverter%20Main/Base/Services&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000819.html">
   <LINK REL="Next"  HREF="000821.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1213 - in trunk/MonoDevelop/src: AddIns/BackendBindings/CSharpBinding AddIns/BackendBindings/CSharpBinding/Parser AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree Libraries/SharpRefactory Libraries/SharpRefactory/src Libraries/SharpRefactory/src/CodeDOM Libraries/SharpRefactory/src/Lexer Libraries/SharpRefactory/src/Lexer/Reader Libraries/SharpRefactory/src/Lexer/Specials Libraries/SharpRefactory/src/Parser/AST Libraries/SharpRefactory/src/Parser/AST/Expressions Libraries/SharpRefactory/src/Parser/AST/GlobalScope Libraries/SharpRefactory/src/Parser/AST/Statements Libraries/SharpRefactory/src/Parser/AST/TypeLevel Libraries/SharpRefactory/src/Parser/generated Libraries/SharpRefactory/src/Parser/generated/keywordlist Libraries/SharpRefactory/src/PrettyPrinter Libraries/SharpRefactory/src/VBConverter Main/Base Main/Base/Commands/VBConverter Main/Base/Services</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1213%20-%20in%20trunk/MonoDevelop/src%3A%20AddIns/BackendBindings/CSharpBinding%20AddIns/BackendBindings/CSharpBinding/Parser%20AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree%20Libraries/SharpRefactory%20Libraries/SharpRefactory/src%20Libraries/SharpRefactory/src/CodeDOM%20Libraries/SharpRefactory/src/Lexer%20Libraries/SharpRefactory/src/Lexer/Reader%20Libraries/SharpRefactory/src/Lexer/Specials%20Libraries/SharpRefactory/src/Parser/AST%20Libraries/SharpRefactory/src/Parser/AST/Expressions%20Libraries/SharpRefactory/src/Parser/AST/GlobalScope%20Libraries/SharpRefactory/src/Parser/AST/Statements%20Libraries/SharpRefactory/src/Parser/AST/TypeLevel%20Libraries/SharpRefactory/src/Parser/generated%20Libraries/SharpRefactory/src/Parser/generated/keywordlist%20Libraries/SharpRefactory/src/PrettyPrinter%20Libraries/SharpRefactory/src/VBConverter%20Main/Base%20Main/Base/Commands/VBConverter%20Main/Base/Services&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1213 - in trunk/MonoDevelop/src: AddIns/BackendBindings/CSharpBinding AddIns/BackendBindings/CSharpBinding/Parser AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree Libraries/SharpRefactory Libraries/SharpRefactory/src Libraries/SharpRefactory/src/CodeDOM Libraries/SharpRefactory/src/Lexer Libraries/SharpRefactory/src/Lexer/Reader Libraries/SharpRefactory/src/Lexer/Specials Libraries/SharpRefactory/src/Parser/AST Libraries/SharpRefactory/src/Parser/AST/Expressions Libraries/SharpRefactory/src/Parser/AST/GlobalScope Libraries/SharpRefactory/src/Parser/AST/Statements Libraries/SharpRefactory/src/Parser/AST/TypeLevel Libraries/SharpRefactory/src/Parser/generated Libraries/SharpRefactory/src/Parser/generated/keywordlist Libraries/SharpRefactory/src/PrettyPrinter Libraries/SharpRefactory/src/VBConverter Main/Base Main/Base/Commands/VBConverter Main/Base/Services">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Sun Mar 21 01:22:29 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000819.html">[Monodevelop-patches-list] r1212 - in trunk/MonoDevelop: . src/AddIns/DisplayBindings/SourceEditor/Search
</A></li>
        <LI>Next message: <A HREF="000821.html">[Monodevelop-patches-list] r1214 - in trunk/MonoDevelop/src/Main/Base: . Commands
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#820">[ date ]</a>
              <a href="thread.html#820">[ thread ]</a>
              <a href="subject.html#820">[ subject ]</a>
              <a href="author.html#820">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tberman
Date: 2004-03-21 01:22:28 -0500 (Sun, 21 Mar 2004)
New Revision: 1213

Added:
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/ChangeLog
   trunk/MonoDevelop/src/Libraries/SharpRefactory/ChangeLog
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/ATGTokensSection.gen
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/BuildKeywords.pl
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/CSharpKeywordList.txt
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/Keywords.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/Tokens.cs
   trunk/MonoDevelop/src/Main/Base/ChangeLog
Modified:
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/CSharpVisitor.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Class.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Constructor.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Event.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Field.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Indexer.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Method.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Property.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/ReturnType.cs
   trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/TypeVisitor.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/Makefile.am
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/CodeDOM/CodeDOMVisitor.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Lexer.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/FileReader.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/IReader.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/StringReader.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/BlankLine.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/Comment.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/CommentType.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/PreProcessingDirective.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/SpecialTracker.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/SpecialType.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Main.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractASTVisitor.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractNode.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AttributeTargets.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/CompilationUnit.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/DebugASTVisitor.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Enums.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ArrayCreateExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ArrayInitializerExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/AssignmentExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/BaseReferenceExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/BinaryOperatorExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/CastExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/CheckedExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ConditionalExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/DirectionExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/Expression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/FieldReferenceExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/IdentifierExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/IndexerExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/InvocationExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ObjectCreateExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ParenthesizedExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/PointerReferenceExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/PrimitiveExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/SizeOfExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/StackAllocExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ThisReferenceExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/TypeOfExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/TypeReferenceExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/UnaryOperatorExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/UncheckedExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/AttributeSection.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/DelegateDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/TypeDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/UsingAliasDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/UsingDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/IASTVisitor.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/INode.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/LookupTableVisitor.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Modifier.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/BlockStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/BreakStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/CheckedStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ContinueStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/DoWhileStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/EmptyStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/FixedStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ForStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ForeachStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/GotoCaseStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/GotoStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/IfElseStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/IfStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LabelStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LocalVariableDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LockStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ReturnStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/Statement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/StatementExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/SwitchStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ThrowStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/TryCatchStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UncheckedStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UnsafeStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UsingStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/WhileStatement.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/DestructorDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventAddRegion.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventRemoveRegion.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/FieldDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/IndexerDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/MethodDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/OperatorDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/ParameterDeclarationExpression.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertyDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertyGetRegion.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertySetRegion.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/TypeReference.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/VariableDeclaration.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Error.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Modifiers.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Parser.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/ParserUtil.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/cs.ATG
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/OutputFormatter.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintData.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintUtil.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintVisitor.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/SpecialVisitor.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/SharpRefactory.prjx
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/VBConverter/VBNetRefactory.cs
   trunk/MonoDevelop/src/Libraries/SharpRefactory/src/VBConverter/VBNetVisitor.cs
   trunk/MonoDevelop/src/Main/Base/Commands/VBConverter/ConvertBuffer.cs
   trunk/MonoDevelop/src/Main/Base/Commands/VBConverter/ConvertProject.cs
   trunk/MonoDevelop/src/Main/Base/Services/MonodocService.cs
Log:
merged over new parser stuff from #D, should be working, report bugs pronto


Added: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/ChangeLog
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/ChangeLog	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/ChangeLog	2004-03-21 06:22:28 UTC (rev 1213)
@@ -0,0 +1,15 @@
+2004-04-21  Todd Berman &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
+
+	* Parser/Parser.cs:
+	* Parser/CSharpVisitor.cs:
+	* Parser/Resolver.cs:
+	* Parser/TypeVisitor.cs:
+	* Parser/SharpDevelopTree/Indexer.cs:
+	* Parser/SharpDevelopTree/Method.cs:
+	* Parser/SharpDevelopTree/Event.cs:
+	* Parser/SharpDevelopTree/ReturnType.cs:
+	* Parser/SharpDevelopTree/Field.cs:
+	* Parser/SharpDevelopTree/Property.cs:
+	* Parser/SharpDevelopTree/Constructor.cs:
+	* Parser/SharpDevelopTree/Class.cs: changes to reflect brand spankin
+	new parser. (from #D)

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/CSharpVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/CSharpVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/CSharpVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -4,8 +4,8 @@
 using System.Diagnostics;
 using System.Collections;
 
-using RefParser = MonoDevelop.SharpRefactory.Parser;
-using AST = MonoDevelop.SharpRefactory.Parser.AST;
+using RefParser = ICSharpCode.SharpRefactory.Parser;
+using AST = ICSharpCode.SharpRefactory.Parser.AST;
 using SharpDevelop.Internal.Parser;
 using CSharpBinding.Parser.SharpDevelopTree;
 

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Parser.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -8,7 +8,7 @@
 using MonoDevelop.Services;
 using SharpDevelop.Internal.Parser;
 using CSharpBinding.Parser.SharpDevelopTree;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser
 {
@@ -24,7 +24,7 @@
 		
 		public ICompilationUnitBase Parse(string fileName)
 		{
-			MonoDevelop.SharpRefactory.Parser.Parser p = new MonoDevelop.SharpRefactory.Parser.Parser();
+			ICSharpCode.SharpRefactory.Parser.Parser p = new ICSharpCode.SharpRefactory.Parser.Parser();
 			
 			p.Parse(new Lexer(new FileReader(fileName)));
 			
@@ -36,7 +36,7 @@
 		
 		public ICompilationUnitBase Parse(string fileName, string fileContent)
 		{
-			MonoDevelop.SharpRefactory.Parser.Parser p = new MonoDevelop.SharpRefactory.Parser.Parser();
+			ICSharpCode.SharpRefactory.Parser.Parser p = new ICSharpCode.SharpRefactory.Parser.Parser();
 			p.Parse(new Lexer(new StringReader(fileContent)));
 			
 			CSharpVisitor visitor = new CSharpVisitor();

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/Resolver.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -12,8 +12,8 @@
 using MonoDevelop.Services;
 using SharpDevelop.Internal.Parser;
 using CSharpBinding.Parser.SharpDevelopTree;
-using MonoDevelop.SharpRefactory.Parser.AST;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser
 {
@@ -96,7 +96,7 @@
 			this.parserService = parserService;
 			IParseInformation parseInfo = parserService.GetParseInformation (fileName, fileContent);
 			
-			MonoDevelop.SharpRefactory.Parser.AST.CompilationUnit fileCompilationUnit = parseInfo.MostRecentCompilationUnit.Tag as MonoDevelop.SharpRefactory.Parser.AST.CompilationUnit;
+			ICSharpCode.SharpRefactory.Parser.AST.CompilationUnit fileCompilationUnit = parseInfo.MostRecentCompilationUnit.Tag as ICSharpCode.SharpRefactory.Parser.AST.CompilationUnit;
 			if (fileCompilationUnit == null) {
 //				MonoDevelop.SharpRefactory.Parser.Parser fileParser = new MonoDevelop.SharpRefactory.Parser.Parser();
 //				fileParser.Parse(new Lexer(new StringReader(fileContent)));
@@ -106,7 +106,7 @@
 			
 			
 			Lexer l = new Lexer(new StringReader(expression));
-			MonoDevelop.SharpRefactory.Parser.Parser p = new MonoDevelop.SharpRefactory.Parser.Parser();
+			ICSharpCode.SharpRefactory.Parser.Parser p = new ICSharpCode.SharpRefactory.Parser.Parser();
 			Expression expr = p.ParseExpression(l);
 			
 			

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Class.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Class.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Class.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -3,7 +3,7 @@
 using System.Diagnostics;
 
 using SharpDevelop.Internal.Parser;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser.SharpDevelopTree
 {

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Constructor.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Constructor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Constructor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 // created on 06.08.2003 at 12:35
 
 using SharpDevelop.Internal.Parser;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser.SharpDevelopTree
 {

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Event.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Event.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Event.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 // created on 06.08.2003 at 12:30
 
 using SharpDevelop.Internal.Parser;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser.SharpDevelopTree
 {

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Field.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Field.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Field.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 // created on 04.08.2003 at 18:06
 
 using SharpDevelop.Internal.Parser;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser.SharpDevelopTree
 {

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Indexer.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Indexer.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Indexer.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 // created on 06.08.2003 at 12:34
 
 using SharpDevelop.Internal.Parser;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser.SharpDevelopTree
 {

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Method.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Method.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Method.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 // created on 06.08.2003 at 12:35
 using System;
 using SharpDevelop.Internal.Parser;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser.SharpDevelopTree
 {

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Property.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Property.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/Property.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 // created on 06.08.2003 at 12:36
 
 using SharpDevelop.Internal.Parser;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace CSharpBinding.Parser.SharpDevelopTree
 {

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/ReturnType.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/ReturnType.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/SharpDevelopTree/ReturnType.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -36,7 +36,7 @@
 			this.pointerNestingLevel = pointerNestingLevel;
 		}
 		
-		public ReturnType(MonoDevelop.SharpRefactory.Parser.AST.TypeReference type)
+		public ReturnType(ICSharpCode.SharpRefactory.Parser.AST.TypeReference type)
 		{
 			base.fullyQualifiedName  = type.SystemType;
 			base.arrayDimensions     = type.RankSpecifier == null ? new int[] { } : type.RankSpecifier;

Modified: trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/TypeVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/TypeVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/AddIns/BackendBindings/CSharpBinding/Parser/TypeVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -3,8 +3,8 @@
 using System;
 using System.Collections;
 
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 using CSharpBinding.Parser.SharpDevelopTree;
 
 using SharpDevelop.Internal.Parser;

Added: trunk/MonoDevelop/src/Libraries/SharpRefactory/ChangeLog
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/ChangeLog	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/ChangeLog	2004-03-21 06:22:28 UTC (rev 1213)
@@ -0,0 +1,3 @@
+2004-04-21  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
+
+	* src/*: Merged in sync with #D parser. Renamespace to ICSharpCode

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/Makefile.am
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/Makefile.am	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/Makefile.am	2004-03-21 06:22:28 UTC (rev 1213)
@@ -96,6 +96,8 @@
 ./src/Parser/generated/Modifiers.cs \
 ./src/Parser/generated/Parser.cs \
 ./src/Parser/generated/Error.cs \
+./src/Parser/generated/keywordlist/Tokens.cs \
+./src/Parser/generated/keywordlist/Keywords.cs \
 ./src/PrettyPrinter/OutputFormatter.cs \
 ./src/PrettyPrinter/PrettyPrintVisitor.cs \
 ./src/PrettyPrinter/PrettyPrintUtil.cs \

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/CodeDOM/CodeDOMVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/CodeDOM/CodeDOMVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/CodeDOM/CodeDOMVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -21,16 +21,19 @@
 using System.Text;
 using System.Collections;
 
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
-	public class CodeDOMVisitor : IASTVisitor
+	public class CodeDOMVisitor : AbstractASTVisitor
 	{
 		Stack namespaceDeclarations = new Stack();
 		Stack typeDeclarations     = new Stack();
-		CodeMemberMethod currentMethod = null;
+		Stack codeStack  = new Stack();
 		TypeDeclaration currentTypeDeclaration;
+
+		// dummy collection used to swallow statements
+		System.CodeDom.CodeStatementCollection NullStmtCollection = new CodeStatementCollection();
 		
 		public CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
 		public ArrayList namespaces = new ArrayList();
@@ -63,6 +66,7 @@
 				typeConversionTable[typeConversionList[i, 1]] = typeConversionList[i, 0];
 			}
 		}
+
 		string ConvType(string type) 
 		{
 			if (typeConversionTable[type] != null) {
@@ -71,14 +75,94 @@
 			return type;
 		}
 
-#region MonoDevelop.SharpRefactory.Parser.IASTVisitor interface implementation
-		public object Visit(INode node, object data)
+		void AddStmt(System.CodeDom.CodeStatement stmt)
 		{
-			return null;
+			System.CodeDom.CodeStatementCollection stmtCollection = codeStack.Peek() as System.CodeDom.CodeStatementCollection;
+			if (stmtCollection != null) {
+				stmtCollection.Add(stmt);
+			}
 		}
-		
-		public object Visit(CompilationUnit compilationUnit, object data)
+
+		void AddStmt(System.CodeDom.CodeExpression expr)
 		{
+			System.CodeDom.CodeStatementCollection stmtCollection = codeStack.Peek() as System.CodeDom.CodeStatementCollection;
+			if (stmtCollection != null) {
+				stmtCollection.Add(expr);
+			}
+		}
+
+		// FIXME: map all modifiers correctly
+		MemberAttributes ConvMemberAttributes(Modifier modifier) 
+		{
+			MemberAttributes attr = (MemberAttributes)0;
+
+			if ((modifier &amp; Modifier.Abstract) != 0)
+				attr |=  MemberAttributes.Abstract;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.AccessMask;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.Assembly;
+			if ((modifier &amp; Modifier.Const) != 0)
+				attr |=  MemberAttributes.Const;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.Family;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.FamilyAndAssembly;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.FamilyOrAssembly;
+			if ((modifier &amp; Modifier.Sealed) != 0)
+				attr |=  MemberAttributes.Final;
+			if ((modifier &amp; Modifier.New) != 0)
+				attr |=  MemberAttributes.New;
+			if ((modifier &amp; Modifier.Virtual) != 0)
+				attr |=  MemberAttributes.Overloaded;
+			if ((modifier &amp; Modifier.Override) != 0)
+				attr |=  MemberAttributes.Override;
+			if ((modifier &amp; Modifier.Private) != 0)
+				attr |=  MemberAttributes.Private;
+			if ((modifier &amp; Modifier.Public) != 0)
+				attr |=  MemberAttributes.Public;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.ScopeMask;
+			if ((modifier &amp; Modifier.Static) != 0)
+				attr |=  MemberAttributes.Static;
+//			if ((modifier &amp; Modifier.None) != 0)
+//				attr |=  MemberAttributes.VTableMask;
+
+			return attr;
+		}
+
+		void ProcessSpecials(Hashtable specials)
+		{
+			if (specials == null) {
+				return;
+			}
+			
+			foreach (object special in specials) {
+				if (special is BlankLine) {
+					AddStmt(new CodeSnippetStatement());
+				} else if (special is PreProcessingDirective) {
+					// TODO
+				} else if (special is Comment) {
+					Comment comment = (Comment)special;
+					switch (comment.CommentType) {
+						case CommentType.SingleLine:
+							AddStmt(new CodeCommentStatement(comment.CommentText, false));
+							break;
+						case CommentType.Documentation:
+							AddStmt(new CodeCommentStatement(comment.CommentText, true));
+							break;
+						case CommentType.Block:
+							AddStmt(new CodeCommentStatement(comment.CommentText, false));
+							break;
+					}
+				}
+			}
+		}
+
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
+		public override object Visit(CompilationUnit compilationUnit, object data)
+		{
 			CodeNamespace globalNamespace = new CodeNamespace(&quot;Global&quot;);
 			namespaces.Add(globalNamespace);
 			namespaceDeclarations.Push(globalNamespace);
@@ -87,8 +171,10 @@
 			return globalNamespace;
 		}
 		
-		public object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
 		{
+			ProcessSpecials(namespaceDeclaration.Specials);
+
 			CodeNamespace currentNamespace = new CodeNamespace(namespaceDeclaration.NameSpace);
 			namespaces.Add(currentNamespace);
 			// add imports from mother namespace
@@ -104,24 +190,28 @@
 			return null;
 		}
 		
-		public object Visit(UsingDeclaration usingDeclaration, object data)
+		public override object Visit(UsingDeclaration usingDeclaration, object data)
 		{
+			ProcessSpecials(usingDeclaration.Specials);
+
 			((CodeNamespace)namespaceDeclarations.Peek()).Imports.Add(new CodeNamespaceImport(usingDeclaration.Namespace));
 			return null;
 		}
 		
-		public object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		public override object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(AttributeSection attributeSection, object data)
+		public override object Visit(AttributeSection attributeSection, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(TypeDeclaration typeDeclaration, object data)
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
 		{
+			ProcessSpecials(typeDeclaration.Specials);
+
 			this.currentTypeDeclaration = typeDeclaration;
 			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(typeDeclaration.Name);
 			codeTypeDeclaration.IsClass     = typeDeclaration.Type == Types.Class;
@@ -146,7 +236,7 @@
 			return null;
 		}
 		
-		public object Visit(DelegateDeclaration delegateDeclaration, object data)
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
 		{
 //			CodeTypeDelegate codeTypeDelegate = new CodeTypeDelegate(delegateDeclaration.Name);
 //			codeTypeDelegate.Parameters
@@ -155,17 +245,21 @@
 			return null;
 		}
 		
-		public object Visit(VariableDeclaration variableDeclaration, object data)
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(FieldDeclaration fieldDeclaration, object data)
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
 		{
-			for (int i = 0; i &lt; fieldDeclaration.Fields.Count; ++i) {
+			ProcessSpecials(fieldDeclaration.Specials);
+
+			for (int i = 0; i &lt; fieldDeclaration.Fields.Count; ++i) 
+			{
 				VariableDeclaration field = (VariableDeclaration)fieldDeclaration.Fields[i];
 				
 				CodeMemberField memberField = new CodeMemberField(new CodeTypeReference(ConvType(fieldDeclaration.TypeReference.Type)), field.Name);
+				memberField.Attributes = ConvMemberAttributes(fieldDeclaration.Modifier);
 				if (field.Initializer != null) {
 					memberField.InitExpression =  (CodeExpression)((INode)field.Initializer).AcceptVisitor(this, data);
 				}
@@ -176,92 +270,105 @@
 			return null;
 		}
 		
-		public object Visit(MethodDeclaration methodDeclaration, object data)
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
 		{
+			ProcessSpecials(methodDeclaration.Specials);
+
 			CodeMemberMethod memberMethod = new CodeMemberMethod();
 			memberMethod.Name = methodDeclaration.Name;
-			currentMethod = memberMethod;
+			memberMethod.Attributes = ConvMemberAttributes(methodDeclaration.Modifier);
+			
+			codeStack.Push(memberMethod.Statements);
+
 			((CodeTypeDeclaration)typeDeclarations.Peek()).Members.Add(memberMethod);
-//			if (memberMethod.Name == &quot;InitializeComponent&quot;) {
-				methodDeclaration.Body.AcceptChildren(this, data);
-//			}
-			currentMethod = null;
+
+			// Add Method Parameters
+			foreach (ParameterDeclarationExpression parameter in methodDeclaration.Parameters)
+			{
+				memberMethod.Parameters.Add((CodeParameterDeclarationExpression)Visit(parameter, data));
+			}
+
+			methodDeclaration.Body.AcceptChildren(this, data);
+
+			codeStack.Pop();
+
 			return null;
 		}
 		
-		public object Visit(PropertyDeclaration propertyDeclaration, object data)
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(PropertyGetRegion propertyGetRegion, object data)
+		public override object Visit(PropertyGetRegion propertyGetRegion, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(PropertySetRegion PropertySetRegion, object data)
+		public override object Visit(PropertySetRegion PropertySetRegion, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(EventDeclaration eventDeclaration, object data)
+		public override object Visit(EventDeclaration eventDeclaration, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(EventAddRegion eventAddRegion, object data)
+		public override object Visit(EventAddRegion eventAddRegion, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(EventRemoveRegion eventRemoveRegion, object data)
+		public override object Visit(EventRemoveRegion eventRemoveRegion, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
 		{
+			ProcessSpecials(constructorDeclaration.Specials);
+
 			CodeMemberMethod memberMethod = new CodeConstructor();
-			currentMethod = memberMethod;
+
+			codeStack.Push(memberMethod.Statements);
 			((CodeTypeDeclaration)typeDeclarations.Peek()).Members.Add(memberMethod);
 //			constructorDeclaration.AcceptChildren(this, data);
-			currentMethod = null;
+			codeStack.Pop();
+
 			return null;
 		}
 		
-		public object Visit(DestructorDeclaration destructorDeclaration, object data)
+		public override object Visit(DestructorDeclaration destructorDeclaration, object data)
 		{
 			return null;
 		}
-		
-		public object Visit(OperatorDeclaration operatorDeclaration, object data)
+
+		public override object Visit(OperatorDeclaration operatorDeclaration, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(IndexerDeclaration indexerDeclaration, object data)
+		public override object Visit(IndexerDeclaration indexerDeclaration, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(BlockStatement blockStatement, object data)
+		public override object Visit(BlockStatement blockStatement, object data)
 		{
+			ProcessSpecials(blockStatement.Specials);
+
 			blockStatement.AcceptChildren(this, data);
 			return null;
 		}
 		
-		public object Visit(StatementExpression statementExpression, object data)
+		public override object Visit(StatementExpression statementExpression, object data)
 		{
-			CodeExpression expr = (CodeExpression)statementExpression.Expression.AcceptVisitor(this, data);
-			if (expr == null) {
-				if (!(statementExpression.Expression is AssignmentExpression)) {
-					Console.WriteLine(&quot;NULL EXPRESSION : &quot; + statementExpression.Expression);
-				}
-			} else {
-				currentMethod.Statements.Add(new CodeExpressionStatement(expr));
+			object exp = statementExpression.Expression.AcceptVisitor(this, data);
+			if (exp is CodeExpression) {
+				AddStmt(new CodeExpressionStatement((CodeExpression)exp));
 			}
-			
-			return null;
+			return exp;
 		}
 		
 		public string Convert(TypeReference typeRef)
@@ -285,131 +392,276 @@
 			return builder.ToString();
 		}
 		
-		public object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
 		{
+			CodeVariableDeclarationStatement declStmt = null;
+
 			CodeTypeReference type = new CodeTypeReference(Convert(localVariableDeclaration.Type));
 			
 			foreach (VariableDeclaration var in localVariableDeclaration.Variables) {
 				if (var.Initializer != null) {
-					currentMethod.Statements.Add(new CodeVariableDeclarationStatement(type,
-					                                                                  var.Name,
-					                                                                  (CodeExpression)((INode)var.Initializer).AcceptVisitor(this, data)));
+					declStmt = new CodeVariableDeclarationStatement(type,
+					                                             var.Name,
+					                                             (CodeExpression)((INode)var.Initializer).AcceptVisitor(this, data));
 				} else {
-					currentMethod.Statements.Add(new CodeVariableDeclarationStatement(type,
-					                                                                  var.Name));
+					declStmt = new CodeVariableDeclarationStatement(type,
+					                                             var.Name);
 				}
 			}
-			return null;
+
+			AddStmt(declStmt);
+
+			return declStmt;
 		}
 		
-		public object Visit(EmptyStatement emptyStatement, object data)
+		public override object Visit(EmptyStatement emptyStatement, object data)
 		{
-			return null;
+			CodeSnippetStatement emptyStmt = new CodeSnippetStatement();
+
+			AddStmt(emptyStmt);
+
+			return emptyStmt;
 		}
 		
-		public object Visit(ReturnStatement returnStatement, object data)
+		public override object Visit(ReturnStatement returnStatement, object data)
 		{
-			return null;
+			ProcessSpecials(returnStatement.Specials);
+
+			CodeMethodReturnStatement returnStmt = new CodeMethodReturnStatement((CodeExpression)returnStatement.ReturnExpression.AcceptVisitor(this,data));
+
+			AddStmt(returnStmt);
+
+			return returnStmt;
 		}
 		
-		public object Visit(IfStatement ifStatement, object data)
+		public override object Visit(IfStatement ifStatement, object data)
 		{
-			return null;
+			ProcessSpecials(ifStatement.Specials);
+
+			CodeConditionStatement ifStmt = new CodeConditionStatement();
+			
+			ifStmt.Condition = (CodeExpression)ifStatement.Condition.AcceptVisitor(this, data);
+
+			codeStack.Push(ifStmt.TrueStatements);
+			ifStatement.EmbeddedStatement.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			AddStmt(ifStmt);
+
+			return ifStmt;
 		}
 		
-		public object Visit(IfElseStatement ifElseStatement, object data)
+		public override object Visit(IfElseStatement ifElseStatement, object data)
 		{
-			return null;
+			ProcessSpecials(ifElseStatement.Specials);
+
+			CodeConditionStatement ifStmt = new CodeConditionStatement();
+
+			ifStmt.Condition = (CodeExpression)ifElseStatement.Condition.AcceptVisitor(this, data);
+
+			codeStack.Push(ifStmt.TrueStatements);
+			ifElseStatement.EmbeddedStatement.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			codeStack.Push(ifStmt.FalseStatements);
+			ifElseStatement.EmbeddedElseStatement.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			AddStmt(ifStmt);
+
+			return ifStmt;
 		}
 		
-		public object Visit(WhileStatement whileStatement, object data)
+		public override object Visit(WhileStatement whileStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(DoWhileStatement doWhileStatement, object data)
+		public override object Visit(DoWhileStatement doWhileStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(ForStatement forStatement, object data)
+		public override object Visit(ForStatement forStatement, object data)
 		{
-			return null;
+			CodeIterationStatement forLoop = new CodeIterationStatement();
+
+			if (forStatement.Initializers != null) 
+			{
+				if (forStatement.Initializers.Count &gt; 1)
+				{
+					throw new NotSupportedException(&quot;CodeDom does not support Multiple For-Loop Initializer Statements&quot;);
+				}
+
+				foreach (object o in forStatement.Initializers)
+				{
+					if (o is Expression) 
+					{
+						forLoop.InitStatement = new CodeExpressionStatement((CodeExpression)((Expression)o).AcceptVisitor(this,data));
+					}
+					if (o is Statement) 
+					{
+						codeStack.Push(NullStmtCollection);
+						forLoop.InitStatement = (CodeStatement)((Statement)o).AcceptVisitor(this, data);
+						codeStack.Pop();
+					}
+				}
+			}
+
+			if (forStatement.Condition == null) 
+			{
+				forLoop.TestExpression = new CodePrimitiveExpression(true);
+			} 
+			else 
+			{
+				forLoop.TestExpression = (CodeExpression)forStatement.Condition.AcceptVisitor(this, data);
+			}
+
+			codeStack.Push(forLoop.Statements);
+			forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			codeStack.Pop();
+
+			if (forStatement.Iterator != null) 
+			{
+				if (forStatement.Initializers.Count &gt; 1)
+				{
+					throw new NotSupportedException(&quot;CodeDom does not support Multiple For-Loop Iterator Statements&quot;);
+				}
+
+				foreach (Statement stmt in forStatement.Iterator) 
+				{
+					forLoop.IncrementStatement = (CodeStatement)stmt.AcceptVisitor(this, data);
+				}
+			}
+
+			AddStmt(forLoop);
+
+			return forLoop;
 		}
 		
-		public object Visit(LabelStatement labelStatement, object data)
+		public override object Visit(LabelStatement labelStatement, object data)
 		{
-			return null;
+			ProcessSpecials(labelStatement.Specials);
+
+			System.CodeDom.CodeLabeledStatement labelStmt = new CodeLabeledStatement(labelStatement.Label,(CodeStatement)labelStatement.AcceptVisitor(this, data));
+
+			// Add Statement to Current Statement Collection
+			AddStmt(labelStmt);
+
+			return labelStmt;
 		}
 		
-		public object Visit(GotoStatement gotoStatement, object data)
+		public override object Visit(GotoStatement gotoStatement, object data)
 		{
-			return null;
+			ProcessSpecials(gotoStatement.Specials);
+
+			System.CodeDom.CodeGotoStatement gotoStmt = new CodeGotoStatement(gotoStatement.Label);
+
+			// Add Statement to Current Statement Collection
+			AddStmt(gotoStmt);
+
+			return gotoStmt;
 		}
 		
-		public object Visit(SwitchStatement switchStatement, object data)
+		public override object Visit(SwitchStatement switchStatement, object data)
 		{
-			return null;
+			throw new NotSupportedException(&quot;CodeDom does not support Switch Statement&quot;);
 		}
 		
-		public object Visit(BreakStatement breakStatement, object data)
+		public override object Visit(BreakStatement breakStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(ContinueStatement continueStatement, object data)
+		public override object Visit(ContinueStatement continueStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		public override object Visit(GotoCaseStatement gotoCaseStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(ForeachStatement foreachStatement, object data)
+		public override object Visit(ForeachStatement foreachStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(LockStatement lockStatement, object data)
+		public override object Visit(LockStatement lockStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(UsingStatement usingStatement, object data)
+		public override object Visit(UsingStatement usingStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(TryCatchStatement tryCatchStatement, object data)
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
 		{
-			return null;
+			ProcessSpecials(tryCatchStatement.Specials);
+
+			// add a try-catch-finally
+			CodeTryCatchFinallyStatement tryStmt = new CodeTryCatchFinallyStatement();
+
+			codeStack.Push(tryStmt.TryStatements);
+			ProcessSpecials(tryCatchStatement.StatementBlock.Specials);
+			tryCatchStatement.StatementBlock.AcceptChildren(this, data);
+			codeStack.Pop();
+
+			if (tryCatchStatement.FinallyBlock != null)
+			{
+				codeStack.Push(tryStmt.FinallyStatements);
+				ProcessSpecials(tryCatchStatement.FinallyBlock.Specials);
+				tryCatchStatement.FinallyBlock.AcceptChildren(this,data);
+				codeStack.Pop();
+			}
+
+			if (tryCatchStatement.CatchClauses != null) 
+			{
+				foreach (CatchClause clause in tryCatchStatement.CatchClauses) 
+				{
+					CodeCatchClause catchClause = new CodeCatchClause(clause.VariableName);
+					catchClause.CatchExceptionType = new CodeTypeReference(clause.Type);
+					tryStmt.CatchClauses.Add(catchClause);
+
+					codeStack.Push(catchClause.Statements);
+					ProcessSpecials(clause.StatementBlock.Specials);
+					clause.StatementBlock.AcceptChildren(this, data);
+					codeStack.Pop();
+				}
+			}
+
+			// Add Statement to Current Statement Collection
+			AddStmt(tryStmt);
+
+			return tryStmt;
 		}
 		
-		public object Visit(ThrowStatement throwStatement, object data)
+		public override object Visit(ThrowStatement throwStatement, object data)
 		{
-			return new CodeThrowExceptionStatement((CodeExpression)throwStatement.ThrowExpression.AcceptVisitor(this, data));
+			ProcessSpecials(throwStatement.Specials);
+
+			CodeThrowExceptionStatement throwStmt = new CodeThrowExceptionStatement((CodeExpression)throwStatement.ThrowExpression.AcceptVisitor(this, data));
+
+			// Add Statement to Current Statement Collection
+			AddStmt(throwStmt);
+
+			return throwStmt;
 		}
 		
-		public object Visit(FixedStatement fixedStatement, object data)
+		public override object Visit(FixedStatement fixedStatement, object data)
 		{
-			return null;
+			throw new NotSupportedException(&quot;CodeDom does not support Fixed Statement&quot;);
 		}
 		
-		public object Visit(PrimitiveExpression expression, object data)
+		public override object Visit(PrimitiveExpression expression, object data)
 		{
-//			if (expression.Value is string) {
-//				return new CodePrimitiveExpression(expression.Value);
-//			} else if (expression.Value is char) {
-//				return new CodePrimitiveExpression((char)expression.Value);
-//			} else if (expression.Value == null) {
-//				return new CodePrimitiveExpression(null);
-//			}
 			return new CodePrimitiveExpression(expression.Value);
 		}
 		
-		public object Visit(BinaryOperatorExpression expression, object data)
+		public override object Visit(BinaryOperatorExpression expression, object data)
 		{
 			CodeBinaryOperatorType op = CodeBinaryOperatorType.Add;
 			switch (expression.Op) {
@@ -485,12 +737,12 @@
 			                                        (CodeExpression)expression.Right.AcceptVisitor(this, data));
 		}
 		
-		public object Visit(ParenthesizedExpression expression, object data)
+		public override object Visit(ParenthesizedExpression expression, object data)
 		{
 			return expression.Expression.AcceptVisitor(this, data);
 		}
 		
-		public object Visit(InvocationExpression invocationExpression, object data)
+		public override object Visit(InvocationExpression invocationExpression, object data)
 		{
 			Expression     target     = invocationExpression.TargetObject;
 			CodeExpression targetExpr;
@@ -500,6 +752,17 @@
 			} else if (target is FieldReferenceExpression) {
 				FieldReferenceExpression fRef = (FieldReferenceExpression)target;
 				targetExpr = (CodeExpression)fRef.TargetObject.AcceptVisitor(this, data);
+				if (fRef.TargetObject is FieldReferenceExpression) {
+					FieldReferenceExpression fRef2 = (FieldReferenceExpression)fRef.TargetObject;
+					if (fRef2.FieldName != null &amp;&amp; Char.IsUpper(fRef2.FieldName[0])) {
+						// an exception is thrown if it doesn't end in an indentifier exception
+						// for example for : this.MyObject.MyMethod() leads to an exception, which 
+						// is correct in this case ... I know this is really HACKY :)
+						try {
+							targetExpr = ConvertToIdentifier(fRef2);
+						} catch (Exception) {}
+					}
+				}
 				methodName = fRef.FieldName;
 			} else {
 				targetExpr = (CodeExpression)target.AcceptVisitor(this, data);
@@ -507,7 +770,7 @@
 			return new CodeMethodInvokeExpression(targetExpr, methodName, GetExpressionList(invocationExpression.Parameters));
 		}
 		
-		public object Visit(IdentifierExpression expression, object data)
+		public override object Visit(IdentifierExpression expression, object data)
 		{
 			if (IsField(expression.Identifier)) {
 				return new CodeFieldReferenceExpression(new CodeThisReferenceExpression(),
@@ -516,13 +779,15 @@
 			return new CodeVariableReferenceExpression(expression.Identifier);
 		}
 		
-		public object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
 		{
 			return null;
 		}
-		
-		public object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
 		{
+			CodeExpression var;
+
 			switch (unaryOperatorExpression.Op) {
 				case UnaryOperatorType.Minus:
 					if (unaryOperatorExpression.Expression is PrimitiveExpression) {
@@ -546,11 +811,48 @@
 			                                        (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data));
 				case UnaryOperatorType.Plus:
 					return unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+				case UnaryOperatorType.PostIncrement:
+					// emulate i++, with i = i + 1
+					var = (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+					return new CodeAssignStatement(var,
+									new CodeBinaryOperatorExpression(var,
+																	 CodeBinaryOperatorType.Add,
+																	 new CodePrimitiveExpression(1)));
+
+				case UnaryOperatorType.PostDecrement:
+					// emulate i--, with i = i - 1
+					var = (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+					return new CodeAssignStatement(var,
+						new CodeBinaryOperatorExpression(var,
+						CodeBinaryOperatorType.Subtract,
+						new CodePrimitiveExpression(1)));
+
+				case UnaryOperatorType.Decrement:
+					// emulate --i, with i = i - 1
+					var = (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+					return new CodeAssignStatement(var,
+						new CodeBinaryOperatorExpression(var,
+						CodeBinaryOperatorType.Subtract,
+						new CodePrimitiveExpression(1)));
+
+				case UnaryOperatorType.Increment:
+					// emulate ++i, with i = i + 1
+					var = (CodeExpression)unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+
+					return new CodeAssignStatement(var,
+						new CodeBinaryOperatorExpression(var,
+						CodeBinaryOperatorType.Add,
+						new CodePrimitiveExpression(1)));
+
 			}
 			return null;
 		}
 		bool methodReference = false;
-		public object Visit(AssignmentExpression assignmentExpression, object data)
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
 		{
 			if (assignmentExpression.Op == AssignmentOperatorType.Add) {
 				
@@ -558,89 +860,89 @@
 				CodeExpression methodInvoker = (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null);
 				methodReference = false;
 					
-				if (assignmentExpression.Left is IdentifierExpression) {
-					currentMethod.Statements.Add(new CodeAttachEventStatement(new CodeEventReferenceExpression(new CodeThisReferenceExpression(), ((IdentifierExpression)assignmentExpression.Left).Identifier),
+				if (assignmentExpression.Left is IdentifierExpression) 
+				{
+					AddStmt(new CodeAttachEventStatement(new CodeEventReferenceExpression(new CodeThisReferenceExpression(), ((IdentifierExpression)assignmentExpression.Left).Identifier),
 					                                                          methodInvoker));
 				} else {
 					FieldReferenceExpression fr = (FieldReferenceExpression)assignmentExpression.Left;
 					
-					currentMethod.Statements.Add(new CodeAttachEventStatement(new CodeEventReferenceExpression((CodeExpression)fr.TargetObject.AcceptVisitor(this, data), fr.FieldName),
+					AddStmt(new CodeAttachEventStatement(new CodeEventReferenceExpression((CodeExpression)fr.TargetObject.AcceptVisitor(this, data), fr.FieldName),
 					                                                          methodInvoker));
 				}
 			} else {
 				if (assignmentExpression.Left is IdentifierExpression) {
-					currentMethod.Statements.Add(new CodeAssignStatement((CodeExpression)assignmentExpression.Left.AcceptVisitor(this, null), (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null)));
+					AddStmt(new CodeAssignStatement((CodeExpression)assignmentExpression.Left.AcceptVisitor(this, null), (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null)));
 				} else {
-					currentMethod.Statements.Add(new CodeAssignStatement((CodeExpression)assignmentExpression.Left.AcceptVisitor(this, null), (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null)));
-					
+					AddStmt(new CodeAssignStatement((CodeExpression)assignmentExpression.Left.AcceptVisitor(this, null), (CodeExpression)assignmentExpression.Right.AcceptVisitor(this, null)));
 				}
 			}
 			return null;
 		}
-		public virtual object Visit(CheckedStatement checkedStatement, object data)
+		
+		public override object Visit(CheckedStatement checkedStatement, object data)
 		{
 			return null;
 		}
-		public virtual object Visit(UncheckedStatement uncheckedStatement, object data)
+		
+		public override object Visit(UncheckedStatement uncheckedStatement, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(SizeOfExpression sizeOfExpression, object data)
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(TypeOfExpression typeOfExpression, object data)
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
 		{
 			return new CodeTypeOfExpression(ConvType(typeOfExpression.TypeReference.Type));
 		}
 		
-		public object Visit(CheckedExpression checkedExpression, object data)
+		public override object Visit(CheckedExpression checkedExpression, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(UncheckedExpression uncheckedExpression, object data)
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
 		{
 			return null;
 		}
 		
-		public object Visit(CastExpression castExpression, object data)
+		public override object Visit(CastExpression castExpression, object data)
 		{
 			string typeRef = castExpression.CastTo.Type;
-			
-			
-			return new CodeCastExpression(ConvType(typeRef), (CodeExpression)castExpression.Expression.AcceptVisitor(this, data));
+			return new CodeCastExpression(typeRef, (CodeExpression)castExpression.Expression.AcceptVisitor(this, data));
 		}
 		
-		public object Visit(StackAllocExpression stackAllocExpression, object data)
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
 		{
 			// TODO
 			return null;
 		}
 		
-		public object Visit(IndexerExpression indexerExpression, object data)
+		public override object Visit(IndexerExpression indexerExpression, object data)
 		{
 			return new CodeIndexerExpression((CodeExpression)indexerExpression.TargetObject.AcceptVisitor(this, data), GetExpressionList(indexerExpression.Indices));
 		}
 		
-		public object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
 		{
 			return new CodeThisReferenceExpression();
 		}
 		
-		public object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
 		{
 			return new CodeBaseReferenceExpression();
 		}
 		
-		public object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
 		{
 			if (arrayCreateExpression.ArrayInitializer == null) {
 				if (arrayCreateExpression.Rank != null &amp;&amp; arrayCreateExpression.Rank.Length &gt; 0) {
@@ -654,13 +956,13 @@
 			                                     GetExpressionList(arrayCreateExpression.ArrayInitializer.CreateExpressions));
 		}
 		
-		public object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
 		{
 			return new CodeObjectCreateExpression(ConvType(objectCreateExpression.CreateType.Type),
 			                                      objectCreateExpression.Parameters == null ? null : GetExpressionList(objectCreateExpression.Parameters));
 		}
 		
-		public object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
 		{
 			return new CodeParameterDeclarationExpression(new CodeTypeReference(ConvType(parameterDeclarationExpression.TypeReference.Type)), parameterDeclarationExpression.ParameterName);
 		}
@@ -677,10 +979,10 @@
 				t = asm.GetType(type);
 			}
 			
-			if (t == null) {
-				//asm = typeof(System.Windows.Forms.Control).Assembly;
-				//t = asm.GetType(type);
-			}
+			//if (t == null) {
+			//	asm = typeof(System.Windows.Forms.Control).Assembly;
+			//	t = asm.GetType(type);
+			//}
 			
 			if (t == null) {
 				asm = typeof(System.String).Assembly;
@@ -707,7 +1009,7 @@
 			return false; //Char.IsLower(fieldReferenceExpression.FieldName[0]);
 		}
 		
-		public object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
 		{
 			if (methodReference) {
 				return new CodeMethodReferenceExpression((CodeExpression)fieldReferenceExpression.TargetObject.AcceptVisitor(this, data), fieldReferenceExpression.FieldName);
@@ -734,15 +1036,16 @@
 				                                           fieldReferenceExpression.FieldName);
 			}
 		}
-		public object Visit(DirectionExpression directionExpression, object data)
+		
+		public override object Visit(DirectionExpression directionExpression, object data)
 		{
 			return null;
 		}
-		public object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
 		{
 			return null;
 		}
-		public object Visit(ConditionalExpression conditionalExpression, object data)
+		public override object Visit(ConditionalExpression conditionalExpression, object data)
 		{
 			return null;
 		}
@@ -813,7 +1116,7 @@
 			}
 			return list;
 		}
-
+		
 		Type GetType(string typeName)
 		{
 			foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies()) 
@@ -826,6 +1129,5 @@
 			}
 			return Type.GetType(typeName);
 		}
-
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Lexer.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Lexer.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Lexer.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -11,18 +11,21 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.Text;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser;
 
-namespace MonoDevelop.SharpRefactory.Parser {
-	public struct Token {
-		public readonly int kind;
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class Token
+	{
+		public int kind;
 		
-		public readonly int col;
-		public readonly int line;
+		public int col;
+		public int line;
 		
-		public readonly object literalValue;
-		public readonly string val;
-
+		public object literalValue = null;
+		public string val;
+		public Token  next;
+		
 		public Point EndLocation {
 			get {
 				return new Point(col + val.Length, line);
@@ -34,22 +37,28 @@
 			}
 		}
 		
+		public Token()
+		{
+		}
+		
 		public Token(int kind)
 		{
 			this.kind = kind;
-			this.col  = 0;
-			this.line = 0;
-			this.val  = null;
-			this.literalValue = null;
 		}
 		
+//		public Token(Tokens kind, int col, int line)
+//		{
+//			this.kind = kind;
+//			this.col  = col;
+//			this.line = line;
+//		}
+		
 		public Token(int kind, int col, int line, string val)
 		{
 			this.kind = kind;
 			this.col  = col;
 			this.line = line;
 			this.val  = val;
-			this.literalValue = null;
 		}
 		
 		public Token(int kind, int col, int line, string val, object literalValue)
@@ -62,31 +71,25 @@
 		}
 	}
 	
-
-	
 	public class Lexer
 	{
 		IReader reader;
-		static  Hashtable keywords = new Hashtable();
 		
 		int col  = 1;
 		int line = 1;
 		
-		Errors errors   = new Errors();
-		class TokenLink {
-			public Token t;
-			public TokenLink next;
-			
-			public TokenLink (Token t) { this.t = t; }
+		Errors         errors   = new Errors();
+		SpecialTracker specialTracker = new SpecialTracker();
+		Token          lastToken = null;
+		Token          curToken  = null;
+		Token          peekToken = null;
+		
+		public SpecialTracker SpecialTracker {
+			get {
+				return specialTracker;
+			}
 		}
 		
-//		SpecialTracker specialTracker = new SpecialTracker();
-		
-		TokenLink lastToken = null;
-		TokenLink curToken  = null;
-		TokenLink peekToken = null;
-		TokenLink reuse;
-		
 		public Errors Errors {
 			get {
 				return errors;
@@ -95,13 +98,13 @@
 		
 		public Token Token {
 			get {
-				return lastToken.t;
+				return lastToken;
 			}
 		}
 		
 		public Token LookAhead {
 			get {
-				return curToken.t;
+				return curToken;
 			}
 		}
 		
@@ -113,134 +116,32 @@
 		public Token Peek()
 		{
 			if (peekToken.next == null) {
-				if (reuse != null) {
-					reuse.t = Next ();
-					peekToken.next = reuse;
-					reuse = null;
-				} else
-					peekToken.next = new TokenLink (Next());
+				peekToken.next = Next();
+				specialTracker.InformToken(peekToken.next.kind);
 			}
-				
 			peekToken = peekToken.next;
-			return peekToken.t;
+			return peekToken;
 		}
 		
 		public Token NextToken()
 		{
 			if (curToken == null) {
-				curToken = new TokenLink (Next());
-				return curToken.t;
+				curToken = Next();
+				specialTracker.InformToken(curToken.kind);
+				return curToken;
 			}
 			
-			reuse = lastToken;
-			// make sure we dont keep a chain around
-			if (reuse != null)
-				reuse.next = null;
-			
 			lastToken = curToken;
 			
 			if (curToken.next == null) {
-				
-				if (reuse != null) {
-					reuse.t = Next ();
-					curToken.next = reuse;
-					reuse = null;
-				} else
-					curToken.next = new TokenLink (Next());
+				curToken.next = Next();
+				specialTracker.InformToken(curToken.next.kind);
 			}
 			
 			curToken  = curToken.next;
-			return curToken.t;
+			return curToken;
 		}
-
 		
-		static string[] keywordStrings = {
-			&quot;abstract&quot;,
-			&quot;as&quot;,
-			&quot;base&quot;,
-			&quot;bool&quot;,
-			&quot;break&quot;,
-			&quot;byte&quot;,
-			&quot;case&quot;,
-			&quot;catch&quot;,
-			&quot;char&quot;,
-			&quot;checked&quot;,
-			&quot;class&quot;,
-			&quot;const&quot;,
-			&quot;continue&quot;,
-			&quot;decimal&quot;,
-			&quot;default&quot;,
-			&quot;delegate&quot;,
-			&quot;do&quot;,
-			&quot;double&quot;,
-			&quot;else&quot;,
-			&quot;enum&quot;,
-			&quot;event&quot;,
-			&quot;explicit&quot;,
-			&quot;extern&quot;,
-			&quot;false&quot;,
-			&quot;finally&quot;,
-			&quot;fixed&quot;,
-			&quot;float&quot;,
-			&quot;for&quot;,
-			&quot;foreach&quot;,
-			&quot;goto&quot;,
-			&quot;if&quot;,
-			&quot;implicit&quot;,
-			&quot;in&quot;,
-			&quot;int&quot;,
-			&quot;interface&quot;,
-			&quot;internal&quot;,
-			&quot;is&quot;,
-			&quot;lock&quot;,
-			&quot;long&quot;,
-			&quot;namespace&quot;,
-			&quot;new&quot;,
-			&quot;null&quot;,
-			&quot;object&quot;,
-			&quot;operator&quot;,
-			&quot;out&quot;,
-			&quot;override&quot;,
-			&quot;params&quot;,
-			&quot;private&quot;,
-			&quot;protected&quot;,
-			&quot;public&quot;,
-			&quot;readonly&quot;,
-			&quot;ref&quot;,
-			&quot;return&quot;,
-			&quot;sbyte&quot;,
-			&quot;sealed&quot;,
-			&quot;short&quot;,
-			&quot;sizeof&quot;,
-			&quot;stackalloc&quot;,
-			&quot;static&quot;,
-			&quot;string&quot;,
-			&quot;struct&quot;,
-			&quot;switch&quot;,
-			&quot;this&quot;,
-			&quot;throw&quot;,
-			&quot;true&quot;,
-			&quot;try&quot;,
-			&quot;typeof&quot;,
-			&quot;uint&quot;,
-			&quot;ulong&quot;,
-			&quot;unchecked&quot;,
-			&quot;unsafe&quot;,
-			&quot;ushort&quot;,
-			&quot;using&quot;,
-			&quot;virtual&quot;,
-			&quot;void&quot;,
-			&quot;volatile&quot;,
-			&quot;while&quot;,
-		};
-		
-		static Lexer()
-		{
-			for (int i = 0 ; i &lt; keywordStrings.Length; ++i) {
-				keywords.Add(keywordStrings[i], i + Tokens.Abstract);
-			}
-		}
-		
 		public Lexer(IReader reader)
 		{
 			this.reader = reader;
@@ -255,7 +156,7 @@
 					++col;
 					
 					if (ch == '\n') {
-//						specialTracker.AddEndOfLine();
+						specialTracker.AddEndOfLine();
 						++line;
 						col = 1;
 					}
@@ -266,8 +167,8 @@
 					int x = col;
 					int y = line;
 					string s = ReadIdent(ch);
-					if (keywords[s] != null) {
-						return new Token((int)keywords[s], x, y, s);
+					if (Keywords.IsKeyword(s)) {
+						return new Token(Keywords.GetToken(s), x, y, s);
 					}
 					return new Token(Tokens.Identifier, x, y, s);
 				}
@@ -283,10 +184,11 @@
 						continue;
 					}
 				} else if (ch == '#') {
+					Point start = new Point(col, line);
 					++col;
 					string directive = ReadIdent('#');
 					string argument  = ReadToEOL();
-//					this.specialTracker.AddPreProcessingDirective(directive, argument);
+					this.specialTracker.AddPreProcessingDirective(directive, argument, start, new Point(start.X + directive.Length + argument.Length, start.Y));
 					continue;
 				}
 				
@@ -317,7 +219,7 @@
 				Token token = ReadOperator(ch);
 				
 				// try error recovery :)
-				if (token.kind == -1) {
+				if (token == null) {
 					return Next();
 				}
 				return token;
@@ -326,27 +228,18 @@
 			return new Token(Tokens.EOF, col, line, String.Empty);
 		}
 		
-		const int max_id_size = 512;
-		char [] id_builder = new char [max_id_size];
-		
 		string ReadIdent(char ch)
 		{
-			int pos = 0;
-			
-			id_builder [pos ++] = ch;
+			StringBuilder s = new StringBuilder(ch.ToString());
 			++col;
 			while (!reader.Eos() &amp;&amp; (Char.IsLetterOrDigit(ch = reader.GetNext()) || ch == '_')) {
-				if (pos == max_id_size) {
-					errors.Error(col, line, &quot;identifier too long&quot;);
-				}
-				
-				id_builder [pos ++] = ch;
+				s.Append(ch.ToString());
 				++col;
 			}
 			if (!reader.Eos()) {
 				reader.UnGet();
 			}
-			return new String (id_builder, 0, pos);
+			return s.ToString();
 		}
 		
 		Token ReadDigit(char ch, int x)
@@ -354,6 +247,8 @@
 			int y = line;
 			++col;
 			StringBuilder sb = new StringBuilder(ch.ToString());
+			StringBuilder prefix = new StringBuilder();
+			StringBuilder suffix = new StringBuilder();
 			
 			bool ishex      = false;
 			bool isunsigned = false;
@@ -371,6 +266,7 @@
 					++col;
 				}
 				ishex = true;
+				prefix.Append(&quot;0x&quot;);
 			} else {
 				while (Char.IsDigit(reader.Peek())) {
 					sb.Append(reader.GetNext());
@@ -408,29 +304,35 @@
 			}
 			
 			if (Char.ToUpper(reader.Peek()) == 'F') { // float value
+				suffix.Append(reader.Peek());
 				reader.GetNext();
 				++col;
 				isfloat = true;
 			} else if (Char.ToUpper(reader.Peek()) == 'M') { // double type suffix (obsolete, double is default)
+				suffix.Append(reader.Peek());
 				reader.GetNext();
 				++col;
 				isdouble = true;
 			} else if (Char.ToUpper(reader.Peek()) == 'D') { // decimal value
+				suffix.Append(reader.Peek());
 				reader.GetNext();
 				++col;
 				isdecimal = true;
 			} else if (!isdouble) {
 				if (Char.ToUpper(reader.Peek()) == 'U') {
+					suffix.Append(reader.Peek());
 					reader.GetNext();
 					++col;
 					isunsigned = true;
 				}
 				
 				if (Char.ToUpper(reader.Peek()) == 'L') {
+					suffix.Append(reader.Peek());
 					reader.GetNext();
 					++col;
 					islong = true;
 					if (!isunsigned &amp;&amp; Char.ToUpper(reader.Peek()) == 'U') {
+						suffix.Append(reader.Peek());
 						reader.GetNext();
 						++col;
 						isunsigned = true;
@@ -439,74 +341,67 @@
 			}
 			
 			string digit = sb.ToString();
+			string stringValue = String.Concat(prefix.ToString(), digit, suffix.ToString());
 			if (isfloat) {
 				try {
 					NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
 					numberFormatInfo.CurrencyDecimalSeparator = &quot;.&quot;;
-					return new Token(Tokens.Literal, x, y, digit, Single.Parse(digit, numberFormatInfo));
+					return new Token(Tokens.Literal, x, y, stringValue, Single.Parse(digit, numberFormatInfo));
 				} catch (Exception) {
 					errors.Error(y, x, String.Format(&quot;Can't parse float {0}&quot;, digit));
-					return new Token(Tokens.Literal, x, y, digit, 0f);
+					return new Token(Tokens.Literal, x, y, stringValue, 0f);
 				}
 			}
 			if (isdecimal) {
 				try {
 					NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
 					numberFormatInfo.CurrencyDecimalSeparator = &quot;.&quot;;
-					return new Token(Tokens.Literal, x, y, digit, Decimal.Parse(digit, numberFormatInfo));
+					return new Token(Tokens.Literal, x, y, stringValue, Decimal.Parse(digit, numberFormatInfo));
 				} catch (Exception) {
 					errors.Error(y, x, String.Format(&quot;Can't parse decimal {0}&quot;, digit));
-					return new Token(Tokens.Literal, x, y, digit, 0m);
+					return new Token(Tokens.Literal, x, y, stringValue, 0m);
 				}
 			}
 			if (isdouble) {
 				try {
 					NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
 					numberFormatInfo.CurrencyDecimalSeparator = &quot;.&quot;;
-					return new Token(Tokens.Literal, x, y, digit, Double.Parse(digit, numberFormatInfo));
+					return new Token(Tokens.Literal, x, y, stringValue, Double.Parse(digit, numberFormatInfo));
 				} catch (Exception) {
 					errors.Error(y, x, String.Format(&quot;Can't parse double {0}&quot;, digit));
-					return new Token(Tokens.Literal, x, y, digit, 0d);
+					return new Token(Tokens.Literal, x, y, stringValue, 0d);
 				}
 			}
 			if (islong) {
 				if (isunsigned) {
 					try {
-						return new Token(Tokens.Literal, x, y, digit, UInt64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+						return new Token(Tokens.Literal, x, y, stringValue, UInt64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
 					} catch (Exception) {
 						errors.Error(y, x, String.Format(&quot;Can't parse unsigned long {0}&quot;, digit));
-						return new Token(Tokens.Literal, x, y, digit, 0UL);
+						return new Token(Tokens.Literal, x, y, stringValue, 0UL);
 					}
 				} else {
 					try {
-						return new Token(Tokens.Literal, x, y, digit, Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+						return new Token(Tokens.Literal, x, y, stringValue, Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
 					} catch (Exception) {
 						errors.Error(y, x, String.Format(&quot;Can't parse long {0}&quot;, digit));
-						return new Token(Tokens.Literal, x, y, digit, 0L);
+						return new Token(Tokens.Literal, x, y, stringValue, 0L);
 					}
 				}
 			} else {
 				if (isunsigned) {
 					try {
-						return new Token(Tokens.Literal, x, y, digit, UInt32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+						return new Token(Tokens.Literal, x, y, stringValue, UInt32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
 					} catch (Exception) {
 						errors.Error(y, x, String.Format(&quot;Can't parse unsigned int {0}&quot;, digit));
-						return new Token(Tokens.Literal, x, y, digit, 0U);
+						return new Token(Tokens.Literal, x, y, stringValue, 0U);
 					}
 				} else {
 					try {
-						return new Token(Tokens.Literal, x, y, digit, Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
+						return new Token(Tokens.Literal, x, y, stringValue, Int32.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
 					} catch (Exception) {
-						try {
-							return new Token(Tokens.Literal, x, y, digit, Int64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
-						} catch {}
-							
-						try {
-							return new Token(Tokens.Literal, x, y, digit, UInt64.Parse(digit, ishex ? NumberStyles.HexNumber : NumberStyles.Number));
-						} catch {}
-						
 						errors.Error(y, x, String.Format(&quot;Can't parse int {0}&quot;, digit));
-						return new Token(Tokens.Literal, x, y, digit, 0);
+						return new Token(Tokens.Literal, x, y, stringValue, 0);
 					}
 				}
 			}
@@ -548,7 +443,14 @@
 			int y = line;
 			char ch = '\0';
 			StringBuilder s = new StringBuilder();
-			while (!reader.Eos() &amp;&amp; (ch = reader.GetNext()) != '&quot;') {
+			while (!reader.Eos()) {
+				ch = reader.GetNext();
+				if (ch == '&quot;') {
+					if (reader.Peek() != '&quot;') {
+						break;
+					}
+					reader.GetNext();
+				}
 				++col;
 				if (ch == '\n') {
 					++line;
@@ -886,7 +788,7 @@
 					return new Token(Tokens.OpenCurlyBrace, x, y, &quot;{&quot;);
 				default:
 					--col;
-					return new Token (-1);
+					return null;
 			}
 		}
 		
@@ -934,33 +836,21 @@
 		
 		void ReadSingleLineComment(CommentType commentType)
 		{
-			if (!reader.Eos()) {
-				char ch = reader.GetNext();
-				while (!reader.Eos()) {
-					if (ch == '\n') {
-						++line;
-						col = 1;
-						return;
-					}
-					ch = reader.GetNext();
-					++col;
-				}
-			}
-//			specialTracker.StartComment(commentType, new Point(line, col));
-//			specialTracker.AddString(ReadToEOL());
-//			specialTracker.FinishComment();
+			specialTracker.StartComment(commentType, new Point(line, col));
+			specialTracker.AddString(ReadToEOL());
+			specialTracker.FinishComment();
 		}
 		
 		void ReadMultiLineComment()
 		{
-//			specialTracker.StartComment(CommentType.Block, new Point(line, col));
+			specialTracker.StartComment(CommentType.Block, new Point(line, col));
 			int x = col;
 			int y = line;
 			while (!reader.Eos()) {
 				char ch;
 				switch (ch = reader.GetNext()) {
 					case '\n':
-//						specialTracker.AddChar('\n');
+						specialTracker.AddChar('\n');
 						++line;
 						col = 1;
 						break;
@@ -970,19 +860,19 @@
 							case '/':
 								reader.GetNext();
 								++col;
-//								specialTracker.FinishComment();
+								specialTracker.FinishComment();
 								return;
 							default:
-//								specialTracker.AddChar('*');
+								specialTracker.AddChar('*');
 								continue;
 						}
 					default:
-//						specialTracker.AddChar(ch);
+						specialTracker.AddChar(ch);
 						++col;
 						break;
 				}
 			}
-//			specialTracker.FinishComment();
+			specialTracker.FinishComment();
 		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/FileReader.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/FileReader.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/FileReader.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -8,7 +8,7 @@
 using System;
 using System.IO;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public class FileReader : IReader
 	{
@@ -17,7 +17,6 @@
 		
 		public FileReader(string filename)
 		{
-			Console.WriteLine(&quot;open file name &quot; + filename);
 			StreamReader sreader = File.OpenText(filename);
 			file = sreader.ReadToEnd();
 			sreader.Close();

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/IReader.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/IReader.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/IReader.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -5,7 +5,7 @@
 //     &lt;version value=&quot;$version&quot;/&gt;
 // &lt;/file&gt;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public interface IReader
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/StringReader.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/StringReader.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Reader/StringReader.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -8,7 +8,7 @@
 using System;
 using System.IO;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public class StringReader : IReader
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/BlankLine.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/BlankLine.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/BlankLine.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -3,7 +3,7 @@
 using System.CodeDom;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public class BlankLine
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/Comment.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/Comment.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/Comment.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -4,7 +4,7 @@
 using System.Collections;
 using System.Drawing;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public class Comment
 	{
@@ -45,5 +45,12 @@
 			this.comment       = comment;
 			this.startPosition = startPosition;
 		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[Comment: CommentType = {0}]&quot;,
+			                     CommentType);
+		}
+		
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/CommentType.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/CommentType.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/CommentType.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -3,7 +3,7 @@
 using System.CodeDom;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public enum CommentType
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/PreProcessingDirective.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/PreProcessingDirective.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/PreProcessingDirective.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,15 +1,36 @@
 using System;
+using System.Drawing;
 using System.Text;
 using System.CodeDom;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public class PreProcessingDirective
 	{
 		string cmd;
 		string arg;
+		Point  start;
+		Point  end;
 		
+		public Point Start {
+			get {
+				return start;
+			}
+			set {
+				start = value;
+			}
+		}
+		
+		public Point End {
+			get {
+				return end;
+			}
+			set {
+				end = value;
+			}
+		}
+		
 		public string Cmd {
 			get {
 				return cmd;
@@ -27,11 +48,19 @@
 				arg = value;
 			}
 		}
+		public override string ToString()
+		{
+			return String.Format(&quot;[PreProcessingDirective: Cmd = {0}, Arg = {1}]&quot;,
+			                     Cmd,
+			                     Arg);
+		}
 		
-		public PreProcessingDirective(string cmd, string arg)
+		public PreProcessingDirective(string cmd, string arg, Point start, Point end)
 		{
 			this.cmd = cmd;
 			this.arg = arg;
+			this.start = start;
+			this.end = end;
 		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/SpecialTracker.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/SpecialTracker.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/SpecialTracker.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -4,7 +4,7 @@
 using System.Collections;
 using System.Drawing;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public class SpecialTracker
 	{
@@ -20,6 +20,11 @@
 			}
 		}
 		
+		public void InformToken(int kind)
+		{
+			currentSpecials.Add(kind);
+		}
+		
 		public ArrayList RetrieveSpecials()
 		{
 			ArrayList tmp = currentSpecials;
@@ -32,9 +37,9 @@
 			currentSpecials.Add(new BlankLine());
 		}
 		
-		public void AddPreProcessingDirective(string cmd, string arg)
+		public void AddPreProcessingDirective(string cmd, string arg, Point start, Point end)
 		{
-			currentSpecials.Add(new PreProcessingDirective(cmd, arg));
+			currentSpecials.Add(new PreProcessingDirective(cmd, arg, start, end));
 		}
 		
 		// used for comment tracking

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/SpecialType.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/SpecialType.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Lexer/Specials/SpecialType.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -3,7 +3,7 @@
 using System.CodeDom;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public enum SpecialType {
 		SingleLine,

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Main.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Main.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Main.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,85 +1,100 @@
 // project created on 09.08.2003 at 10:16
 using System;
+using System.Collections.Specialized;
 using System.IO;
 using System.CodeDom;
 using System.CodeDom.Compiler;
 using Microsoft.CSharp;
 
-using MonoDevelop.SharpRefactory.PrettyPrinter;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.PrettyPrinter;
+using ICSharpCode.SharpRefactory.Parser;
 
 
 class MainClass
 {
-//	static void A()
-//	{
-//		Lexer lexer = new Lexer(new MonoDevelop.SharpRefactory.Lexer.StringReader(&quot;(int)i&quot;));
-//		for (int i = 0; i &lt; 10; ++i) {
-//			Console.WriteLine(i + &quot; ----&gt; &quot; + lexer.Peek(i).kind);
-//		}
-//		lexer.NextToken();
-//		Console.WriteLine(&quot;1.&quot; + lexer.LookAhead.kind + &quot; -- &quot; + Tokens.OpenParenthesis);
-//		lexer.NextToken();
-//		Console.WriteLine(&quot;2.&quot; + lexer.LookAhead.kind + &quot; -- &quot; + Tokens.Int);
-//		lexer.NextToken();
-//		Console.WriteLine(&quot;3.&quot; + lexer.LookAhead.kind + &quot; -- &quot; + Tokens.CloseParenthesis);
-//		lexer.NextToken();
-//		Console.WriteLine(&quot;4.&quot; + lexer.LookAhead.kind + &quot; -- &quot; + Tokens.Identifier);
-//		lexer.NextToken();
-//		Console.WriteLine(&quot;5.&quot; + lexer.LookAhead.kind + &quot; -- &quot; + Tokens.EOF);
-//	}
+	public static StringCollection SearchDirectory(string directory, string filemask)
+	{
+		return SearchDirectory(directory, filemask, true);
+	}
 	
+	public static StringCollection SearchDirectory(string directory, string filemask, bool searchSubdirectories)
+	{
+		StringCollection collection = new StringCollection();
+		SearchDirectory(directory, filemask, collection, searchSubdirectories);
+		return collection;
+	}
+	
+	/// &lt;summary&gt;
+	/// Finds all files which are valid to the mask &lt;code&gt;filemask&lt;/code&gt; in the path
+	/// &lt;code&gt;directory&lt;/code&gt; and all subdirectories (if searchSubdirectories
+	/// is true. The found files are added to the StringCollection 
+	/// &lt;code&gt;collection&lt;/code&gt;.
+	/// &lt;/summary&gt;
+	static void SearchDirectory(string directory, string filemask, StringCollection collection, bool searchSubdirectories)
+	{
+		try {
+			string[] file = Directory.GetFiles(directory, filemask);
+			foreach (string f in file) {
+				collection.Add(f);
+			}
+			
+			if (searchSubdirectories) {
+				string[] dir = Directory.GetDirectories(directory);
+				foreach (string d in dir) {
+					SearchDirectory(d, filemask, collection, searchSubdirectories);
+				}
+			}
+		} catch (Exception) {
+		}
+	}
+	
+	static void PrettyPrintDirectories()
+	{
+		StringCollection files = SearchDirectory(&quot;C:\\b&quot;, &quot;*.cs&quot;);
+		foreach (string fileName in files) {
+			Parser p = new Parser();
+			Console.Write(&quot;Converting : &quot; + fileName);
+			p.Parse(new Lexer(new FileReader(fileName)));
+			if (p.Errors.count == 0) {
+				StreamReader sr = File.OpenText(fileName);
+				string content = sr.ReadToEnd();
+				sr.Close();
+				PrettyPrintVisitor ppv = new PrettyPrintVisitor(content);
+				ppv.Visit(p.compilationUnit, null);
+				
+				StreamWriter sw = new StreamWriter(fileName);
+				sw.Write(ppv.Text);
+				sw.Close();
+				
+				Console.WriteLine(&quot; done.&quot;);
+			} else {
+				Console.Write(&quot; Source code errors:&quot;);
+				Console.WriteLine(p.Errors.ErrorOutput);
+			}
+		}
+		Console.ReadLine();
+	}
+
 	public static void Main (string[] args)
 	{
-//		Lexer lexer = new Lexer(new FileReader(&quot;C:\\test.cs&quot;));
-//		Token t = lexer.NextToken();
-//		while (t != null &amp;&amp; t.kind != Tokens.EOF) {
-//			Console.WriteLine(&quot;Token : {0}, value={1}, literalValue={2}&quot;, t.kind, t.val, t.literalValue);
-//			t = lexer.NextToken();
-//		}
-//		if (t != null) {
-//			Console.WriteLine(&quot;Token : {0}, value={1}, literalValue={2}&quot;, t.kind, t.val, t.literalValue);
-//		} else {
-//			Console.WriteLine(&quot;NULL&quot;);
-//		}
-		
+//		PrettyPrintDirectories();
 		Parser p = new Parser();
-		p.Parse(new Lexer(new FileReader(args [0])));
+		string fileName = &quot;C:\\a.cs&quot;;
+		Console.Write(&quot;Converting : &quot; + fileName);
+		p.Parse(new Lexer(new FileReader(fileName)));
 		if (p.Errors.count == 0) {
-			LookupTableVisitor lookupTableVisitor = new LookupTableVisitor();
-			lookupTableVisitor.Visit(p.compilationUnit, null);
+			StreamReader sr = File.OpenText(fileName);
+			string content = sr.ReadToEnd();
+			sr.Close();
+			PrettyPrintVisitor ppv = new PrettyPrintVisitor(content);
+			ppv.Visit(p.compilationUnit, null);
 			
-			new DebugASTVisitor().Visit(p.compilationUnit, null);
-			PrettyPrintVisitor ppv = new PrettyPrintVisitor();
-			ppv.Visit(p.compilationUnit, null);
-			Console.WriteLine(ppv.Text.ToString());
+			Console.WriteLine(ppv.Text);
+			
+			Console.WriteLine(&quot; done.&quot;);
 		} else {
-			Console.WriteLine(&quot;Source code errors:&quot;);
+			Console.Write(&quot; Source code errors:&quot;);
 			Console.WriteLine(p.Errors.ErrorOutput);
 		}
-			
-//		
-//		Scanner.Init(fileName);
-//		Console.WriteLine(&quot;Parsing source file {0}&quot;, fileName);
-//		Parser.Parse();
-//		
-		
-//			
-//			CodeDOMVisitor cdom = new CodeDOMVisitor();
-//			
-//			cdom.Visit(Parser.compilationUnit, null);
-//			
-//			Microsoft.CSharp.CSharpCodeProvider provider = new CSharpCodeProvider();
-//			// Call the CodeDomProvider.CreateGenerator() method to obtain an ICodeGenerator from the provider.
-//			System.CodeDom.Compiler.ICodeGenerator generator = provider.CreateGenerator();
-//			generator.GenerateCodeFromCompileUnit(cdom.codeCompileUnit, Console.Out, null);
-//			
-//			VBNetVisitor vbv = new VBNetVisitor();
-//			
-//			vbv.Visit(Parser.compilationUnit, null);
-//			StreamWriter sw = new StreamWriter(@&quot;C:\testform.vb&quot;);
-//			sw.Write(vbv.SourceText.ToString());
-//			sw.Close();
-//			Console.WriteLine(&quot;converted.&quot;);
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractASTVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractASTVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractASTVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,8 +1,8 @@
 using System;
 using System.Collections;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public abstract class AbstractASTVisitor : IASTVisitor
 	{
@@ -17,10 +17,12 @@
 			}
 		}
 		
-#region MonoDevelop.SharpRefactory.Parser.IASTVisitor interface implementation
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
 		public virtual object Visit(INode node, object data)
 		{
 			Console.WriteLine(&quot;Warning: INode visited&quot;);
+			Console.WriteLine(&quot;Visitor was: &quot; + this.GetType());
+			Console.WriteLine(&quot;Node was : &quot; + node.GetType());
 			return node.AcceptChildren(this, data);
 		}
 		
@@ -72,8 +74,8 @@
 			return data;
 		}
 #endregion
-		
-#region Global Scope
+
+#region Type level
 		public virtual object Visit(VariableDeclaration variableDeclaration, object data)
 		{
 			if (variableDeclaration.Initializer != null) {
@@ -340,22 +342,19 @@
 		public virtual object Visit(ForStatement forStatement, object data)
 		{
 			object ret = data;
-			if (forStatement.Initializers != null) { 
+			if (forStatement.Initializers != null) {
 				foreach(INode n in forStatement.Initializers) {
-					if (n != null) n.AcceptVisitor(this, data);
+					n.AcceptVisitor(this, data);
 				}
 			}
-			
 			if (forStatement.Condition != null) {
 				ret = forStatement.Condition.AcceptVisitor(this, data);
 			}
-			
 			if (forStatement.Iterator != null) {
 				foreach(INode n in forStatement.Iterator) {
-					if (n != null) n.AcceptVisitor(this, data);
+					n.AcceptVisitor(this, data);
 				}
 			}
-			
 			if (forStatement.EmbeddedStatement == null) {
 				return ret;
 			}
@@ -449,11 +448,18 @@
 		}
 		public virtual object Visit(TryCatchStatement tryCatchStatement, object data)
 		{
+			if (tryCatchStatement == null) {
+				return data;
+			}
 			if (tryCatchStatement.StatementBlock != null) {
 				tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
 			}
-			foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
-				catchClause.StatementBlock.AcceptVisitor(this, data);
+			if (tryCatchStatement.CatchClauses != null) {
+				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
+					if (catchClause != null) {
+						catchClause.StatementBlock.AcceptVisitor(this, data);
+					}
+				}
 			}
 			if (tryCatchStatement.FinallyBlock != null) {
 				return tryCatchStatement.FinallyBlock.AcceptVisitor(this, data);
@@ -587,11 +593,22 @@
 			}
 			return data;
 		}
+		
+		public virtual object Visit(ArrayCreationParameter arrayCreationParameter, object data)
+		{
+			if (arrayCreationParameter.Expressions != null) {
+				foreach (Expression e in arrayCreationParameter.Expressions) {
+					e.AcceptVisitor(this, data);
+				}
+			}
+			return data;
+		}
+		
 		public virtual object Visit(ArrayCreateExpression arrayCreateExpression, object data)
 		{
 			if (arrayCreateExpression.Parameters != null) {
-				foreach (Expression p in arrayCreateExpression.Parameters) {
-					p.AcceptVisitor(this, data);
+				foreach (INode node in arrayCreateExpression.Parameters) {
+					node.AcceptVisitor(this, data);
 				}
 			}
 			if (arrayCreateExpression.ArrayInitializer != null) {

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractNode.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractNode.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AbstractNode.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -21,12 +21,12 @@
 
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public abstract class AbstractNode : INode
 	{
 		INode     parent;
-		ArrayList children;
+		ArrayList children = new ArrayList();
 		Hashtable specials;
 		Point     startLocation;
 		Point     endLocation;
@@ -69,17 +69,12 @@
 		
 		public ArrayList Children {
 			get {
-				if (children == null)
-					return children = new ArrayList (1);
 				return children;
 			}
 		}
 		
 		public virtual void AddChild(INode childNode)
 		{
-			if (children == null)
-				children = new ArrayList ();
-			
 			children.Add(childNode);
 		}
 		
@@ -90,9 +85,6 @@
 		
 		public object AcceptChildren(IASTVisitor visitor, object data)
 		{
-			if (children == null)
-				return data;
-			
 			foreach (INode child in children) {
 				if (child != null) {
 					child.AcceptVisitor(visitor, data);

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AttributeTargets.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AttributeTargets.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/AttributeTargets.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -2,7 +2,7 @@
 using System.Collections;
 using System.Text;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	[Flags]
 	public enum AttributeTarget

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/CompilationUnit.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/CompilationUnit.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/CompilationUnit.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,7 +19,7 @@
 using System.Threading;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class CompilationUnit : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/DebugASTVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/DebugASTVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/DebugASTVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,65 +1,60 @@
 using System;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
-	public class DebugASTVisitor : IASTVisitor
+	public class DebugASTVisitor : AbstractASTVisitor
 	{
-#region MonoDevelop.SharpRefactory.Parser.IASTVisitor interface implementation
-		public virtual object Visit(CompilationUnit compilationUnit, object data)
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
+		public override object Visit(CompilationUnit compilationUnit, object data)
 		{
 			Console.WriteLine(compilationUnit.ToString());
 			return compilationUnit.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(FieldDeclaration fieldDeclaration, object data)
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
 		{
 			Console.WriteLine(fieldDeclaration.ToString());
 			return fieldDeclaration.AcceptChildren(this, data);
 		}
-		public virtual object Visit(INode node, object data)
-		{
-			Console.WriteLine(&quot;!!! PURE NODE --- SHOULD NEVER HAPPEN!!!&quot;);
-			return node.AcceptChildren(this, data);
-		}
 		
-		public virtual object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
 		{
 			Console.WriteLine(namespaceDeclaration.ToString());
 			return namespaceDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(UsingDeclaration usingDeclaration, object data)
+		public override object Visit(UsingDeclaration usingDeclaration, object data)
 		{
 			Console.WriteLine(usingDeclaration.ToString());
 			return usingDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		public override object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
 		{
 			Console.WriteLine(usingAliasDeclaration.ToString());
 			return usingAliasDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(TypeDeclaration typeDeclaration, object data)
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
 		{
 			Console.WriteLine(typeDeclaration.ToString());
 			return typeDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(DelegateDeclaration delegateDeclaration, object data)
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
 		{
 			Console.WriteLine(delegateDeclaration.ToString());
 			return delegateDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(VariableDeclaration variableDeclaration, object data)
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
 		{
 			Console.WriteLine(variableDeclaration.ToString());
 			return variableDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(MethodDeclaration methodDeclaration, object data)
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
 		{
 			Console.WriteLine(methodDeclaration.ToString());
 			if (methodDeclaration.Body != null) {
@@ -68,360 +63,360 @@
 			return methodDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(AttributeSection attributeSection, object data)
+		public override object Visit(AttributeSection attributeSection, object data)
 		{
 			Console.WriteLine(attributeSection.ToString());
 			return attributeSection.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
 		{
 			Console.WriteLine(fieldReferenceExpression.ToString());
 			return fieldReferenceExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
 		{
 			Console.WriteLine(constructorDeclaration.ToString());
 			return constructorDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(DestructorDeclaration destructorDeclaration, object data)
+		public override object Visit(DestructorDeclaration destructorDeclaration, object data)
 		{
 			Console.WriteLine(destructorDeclaration.ToString());
 			return destructorDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(OperatorDeclaration operatorDeclaration, object data)
+		public override object Visit(OperatorDeclaration operatorDeclaration, object data)
 		{
 			Console.WriteLine(operatorDeclaration.ToString());
 			return operatorDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(IndexerDeclaration indexerDeclaration, object data)
+		public override object Visit(IndexerDeclaration indexerDeclaration, object data)
 		{
 			Console.WriteLine(indexerDeclaration.ToString());
 			return indexerDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
 		{
 			Console.WriteLine(parameterDeclarationExpression.ToString());
 			return parameterDeclarationExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(FixedStatement fixedStatement, object data)
+		public override object Visit(FixedStatement fixedStatement, object data)
 		{
 			Console.WriteLine(fixedStatement.ToString());
 			return fixedStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(PropertyDeclaration propertyDeclaration, object data)
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
 		{
 			Console.WriteLine(propertyDeclaration.ToString());
 			return propertyDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(PropertyGetRegion propertyGetRegion, object data)
+		public override object Visit(PropertyGetRegion propertyGetRegion, object data)
 		{
 			Console.WriteLine(propertyGetRegion.ToString());
 			return propertyGetRegion.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(PropertySetRegion PropertySetRegion, object data)
+		public override object Visit(PropertySetRegion PropertySetRegion, object data)
 		{
 			Console.WriteLine(PropertySetRegion.ToString());
 			return PropertySetRegion.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(EventDeclaration eventDeclaration, object data)
+		public override object Visit(EventDeclaration eventDeclaration, object data)
 		{
 			Console.WriteLine(eventDeclaration.ToString());
 			return eventDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(EventAddRegion eventAddRegion, object data)
+		public override object Visit(EventAddRegion eventAddRegion, object data)
 		{
 			Console.WriteLine(eventAddRegion.ToString());
 			return eventAddRegion.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(EventRemoveRegion eventRemoveRegion, object data)
+		public override object Visit(EventRemoveRegion eventRemoveRegion, object data)
 		{
 			Console.WriteLine(eventRemoveRegion.ToString());
 			return eventRemoveRegion.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(BlockStatement blockStatement, object data)
+		public override object Visit(BlockStatement blockStatement, object data)
 		{
 			Console.WriteLine(blockStatement.ToString());
 			return blockStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(StatementExpression statementExpression, object data)
+		public override object Visit(StatementExpression statementExpression, object data)
 		{
 			Console.WriteLine(statementExpression.ToString());
 			return statementExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
 		{
 			Console.WriteLine(localVariableDeclaration.ToString());
 			return localVariableDeclaration.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(EmptyStatement emptyStatement, object data)
+		public override object Visit(EmptyStatement emptyStatement, object data)
 		{
 			Console.WriteLine(emptyStatement.ToString());
 			return emptyStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ReturnStatement returnStatement, object data)
+		public override object Visit(ReturnStatement returnStatement, object data)
 		{
 			Console.WriteLine(returnStatement.ToString());
 			return returnStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(IfStatement ifStatement, object data)
+		public override object Visit(IfStatement ifStatement, object data)
 		{
 			Console.WriteLine(ifStatement.ToString());
 			return ifStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(IfElseStatement ifElseStatement, object data)
+		public override object Visit(IfElseStatement ifElseStatement, object data)
 		{
 			Console.WriteLine(ifElseStatement.ToString());
 			return ifElseStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(WhileStatement whileStatement, object data)
+		public override object Visit(WhileStatement whileStatement, object data)
 		{
 			Console.WriteLine(whileStatement.ToString());
 			return whileStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(DoWhileStatement doWhileStatement, object data)
+		public override object Visit(DoWhileStatement doWhileStatement, object data)
 		{
 			Console.WriteLine(doWhileStatement.ToString());
 			return doWhileStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ForStatement forStatement, object data)
+		public override object Visit(ForStatement forStatement, object data)
 		{
 			Console.WriteLine(forStatement.ToString());
 			return forStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(LabelStatement labelStatement, object data)
+		public override object Visit(LabelStatement labelStatement, object data)
 		{
 			Console.WriteLine(labelStatement.ToString());
 			return labelStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(GotoStatement gotoStatement, object data)
+		public override object Visit(GotoStatement gotoStatement, object data)
 		{
 			Console.WriteLine(gotoStatement.ToString());
 			return gotoStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(SwitchStatement switchStatement, object data)
+		public override object Visit(SwitchStatement switchStatement, object data)
 		{
 			Console.WriteLine(switchStatement.ToString());
 			return switchStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(BreakStatement breakStatement, object data)
+		public override object Visit(BreakStatement breakStatement, object data)
 		{
 			Console.WriteLine(breakStatement.ToString());
 			return breakStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ContinueStatement continueStatement, object data)
+		public override object Visit(ContinueStatement continueStatement, object data)
 		{
 			Console.WriteLine(continueStatement.ToString());
 			return continueStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		public override object Visit(GotoCaseStatement gotoCaseStatement, object data)
 		{
 			Console.WriteLine(gotoCaseStatement.ToString());
 			return gotoCaseStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ForeachStatement foreachStatement, object data)
+		public override object Visit(ForeachStatement foreachStatement, object data)
 		{
 			Console.WriteLine(foreachStatement.ToString());
 			return foreachStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(LockStatement lockStatement, object data)
+		public override object Visit(LockStatement lockStatement, object data)
 		{
 			Console.WriteLine(lockStatement.ToString());
 			return lockStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(UsingStatement usingStatement, object data)
+		public override object Visit(UsingStatement usingStatement, object data)
 		{
 			Console.WriteLine(usingStatement.ToString());
 			return usingStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(TryCatchStatement tryCatchStatement, object data)
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
 		{
 			Console.WriteLine(tryCatchStatement.ToString());
 			return tryCatchStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ThrowStatement throwStatement, object data)
+		public override object Visit(ThrowStatement throwStatement, object data)
 		{
 			Console.WriteLine(throwStatement.ToString());
 			return throwStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(CheckedStatement checkedStatement, object data)
+		public override object Visit(CheckedStatement checkedStatement, object data)
 		{
 			Console.WriteLine(checkedStatement.ToString());
 			return checkedStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(UncheckedStatement uncheckedStatement, object data)
+		public override object Visit(UncheckedStatement uncheckedStatement, object data)
 		{
 			Console.WriteLine(uncheckedStatement.ToString());
 			return uncheckedStatement.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(PrimitiveExpression expression, object data)
+		public override object Visit(PrimitiveExpression expression, object data)
 		{
 			Console.WriteLine(expression.ToString());
 			return expression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(BinaryOperatorExpression expression, object data)
+		public override object Visit(BinaryOperatorExpression expression, object data)
 		{
 			Console.WriteLine(expression.ToString());
 			return expression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ParenthesizedExpression expression, object data)
+		public override object Visit(ParenthesizedExpression expression, object data)
 		{
 			Console.WriteLine(expression.ToString());
 			return expression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(InvocationExpression invocationExpression, object data)
+		public override object Visit(InvocationExpression invocationExpression, object data)
 		{
 			Console.WriteLine(invocationExpression.ToString());
 			return invocationExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(IdentifierExpression expression, object data)
+		public override object Visit(IdentifierExpression expression, object data)
 		{
 			Console.WriteLine(expression.ToString());
 			return expression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
 		{
 			Console.WriteLine(typeReferenceExpression.ToString());
 			return typeReferenceExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
 		{
 			Console.WriteLine(unaryOperatorExpression.ToString());
 			return unaryOperatorExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(AssignmentExpression assignmentExpression, object data)
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
 		{
 			Console.WriteLine(assignmentExpression.ToString());
 			return assignmentExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(SizeOfExpression sizeOfExpression, object data)
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
 		{
 			Console.WriteLine(sizeOfExpression.ToString());
 			return sizeOfExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(TypeOfExpression typeOfExpression, object data)
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
 		{
 			Console.WriteLine(typeOfExpression.ToString());
 			return typeOfExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(CheckedExpression checkedExpression, object data)
+		public override object Visit(CheckedExpression checkedExpression, object data)
 		{
 			Console.WriteLine(checkedExpression.ToString());
 			return checkedExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(UncheckedExpression uncheckedExpression, object data)
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
 		{
 			Console.WriteLine(uncheckedExpression.ToString());
 			return uncheckedExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
 		{
 			Console.WriteLine(pointerReferenceExpression.ToString());
 			return pointerReferenceExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(CastExpression castExpression, object data)
+		public override object Visit(CastExpression castExpression, object data)
 		{
 			Console.WriteLine(castExpression.ToString());
 			return castExpression.AcceptChildren(this, data);
 		}
 		
 		
-		public virtual object Visit(StackAllocExpression stackAllocExpression, object data)
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
 		{
 			Console.WriteLine(stackAllocExpression.ToString());
 			return stackAllocExpression.AcceptChildren(this, data);
 		}
 		
 		
-		public virtual object Visit(IndexerExpression indexerExpression, object data)
+		public override object Visit(IndexerExpression indexerExpression, object data)
 		{
 			Console.WriteLine(indexerExpression.ToString());
 			return indexerExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
 		{
 			Console.WriteLine(thisReferenceExpression.ToString());
 			return thisReferenceExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
 		{
 			Console.WriteLine(baseReferenceExpression.ToString());
 			return baseReferenceExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
 		{
 			Console.WriteLine(objectCreateExpression.ToString());
 			return objectCreateExpression.AcceptChildren(this, data);
 		}
 		
-		public virtual object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
 		{
 			Console.WriteLine(arrayCreateExpression.ToString());
 			return arrayCreateExpression.AcceptChildren(this, data);
 		}
-		public virtual object Visit(DirectionExpression directionExpression, object data)
+		public override object Visit(DirectionExpression directionExpression, object data)
 		{
 			Console.WriteLine(directionExpression.ToString());
 			return directionExpression.AcceptChildren(this, data);
 		}
-		public virtual object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
 		{
 			Console.WriteLine(arrayInitializerExpression.ToString());
 			return arrayInitializerExpression.AcceptChildren(this, data);
 		}
-		public virtual object Visit(ConditionalExpression conditionalExpression, object data)
+		public override object Visit(ConditionalExpression conditionalExpression, object data)
 		{
 			Console.WriteLine(conditionalExpression.ToString());
 			return conditionalExpression.AcceptChildren(this, data);

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Enums.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Enums.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Enums.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,6 +1,6 @@
 using System;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	/// &lt;summary&gt;
 	/// Summary description for Class1.

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ArrayCreateExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ArrayCreateExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ArrayCreateExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,12 +1,64 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
+	public class ArrayCreationParameter : AbstractNode 
+	{
+		ArrayList expressions = null;
+		int       dimensions  = -1;
+		
+		public bool IsExpressionList {
+			get {
+				return expressions != null;
+			}
+		}
+		
+		public ArrayList Expressions {
+			get {
+				return expressions;
+			}
+			set {
+				expressions = value;
+			}
+		}
+		
+		public int Dimensions {
+			get {
+				return dimensions;
+			}
+			set {
+				dimensions = value;
+			}
+		}
+		
+		public ArrayCreationParameter(ArrayList expressions)
+		{
+			this.expressions = expressions;
+		}
+		
+		public ArrayCreationParameter(int dimensions)
+		{
+			this.dimensions = dimensions;
+		}
+		
+		public override object AcceptVisitor(IASTVisitor visitor, object data)
+		{
+			return visitor.Visit(this, data);
+		}
+		
+		public override string ToString()
+		{
+			return String.Format(&quot;[ArrayCreationParameter: Dimensions={0}, Expressions={1}&quot;,
+			                     dimensions,
+			                     GetCollectionString(expressions));
+		}
+	}
+	
 	public class ArrayCreateExpression : Expression
 	{
 		TypeReference              createType       = null;
-		ArrayList                  parameters       = null; // Expressions
+		ArrayList                  parameters       = null; // ArrayCreationParameter
 		int[]                      rank             = null;
 		ArrayInitializerExpression arrayInitializer = null; // Array Initializer OR NULL
 		
@@ -46,17 +98,16 @@
 			}
 		}
 		
-		public ArrayCreateExpression(TypeReference createType, ArrayList parameters)
+		public ArrayCreateExpression(TypeReference createType)
 		{
 			this.createType = createType;
-			this.parameters = parameters;
 		}
 		
-		public ArrayCreateExpression(TypeReference createType, ArrayInitializerExpression arrayInitializer)
-		{
-			this.createType = createType;
-			this.arrayInitializer = arrayInitializer;
-		}
+//		public ArrayCreateExpression(TypeReference createType, ArrayInitializerExpression arrayInitializer)
+//		{
+//			this.createType = createType;
+//			this.arrayInitializer = arrayInitializer;
+//		}
 		
 		
 		public override object AcceptVisitor(IASTVisitor visitor, object data)

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ArrayInitializerExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ArrayInitializerExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ArrayInitializerExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST {
+namespace ICSharpCode.SharpRefactory.Parser.AST {
 	
 	public class ArrayInitializerExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/AssignmentExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/AssignmentExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/AssignmentExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class AssignmentExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/BaseReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/BaseReferenceExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/BaseReferenceExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class BaseReferenceExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/BinaryOperatorExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/BinaryOperatorExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/BinaryOperatorExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class BinaryOperatorExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/CastExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/CastExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/CastExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class CastExpression : Expression
 	{
@@ -27,6 +27,11 @@
 			}
 		}
 		
+		public CastExpression(TypeReference castTo)
+		{
+			this.castTo = castTo;
+		}
+		
 		public CastExpression(TypeReference castTo, Expression expression)
 		{
 			this.castTo = castTo;

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/CheckedExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/CheckedExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/CheckedExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class CheckedExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ConditionalExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ConditionalExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ConditionalExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST {
+namespace ICSharpCode.SharpRefactory.Parser.AST {
 	
 	public class ConditionalExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/DirectionExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/DirectionExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/DirectionExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST {
+namespace ICSharpCode.SharpRefactory.Parser.AST {
 	
 	public class DirectionExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/Expression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/Expression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/Expression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class Expression : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/FieldReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/FieldReferenceExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/FieldReferenceExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST {
+namespace ICSharpCode.SharpRefactory.Parser.AST {
 	
 	public class FieldReferenceExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/IdentifierExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/IdentifierExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/IdentifierExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class IdentifierExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/IndexerExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/IndexerExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/IndexerExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class IndexerExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/InvocationExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/InvocationExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/InvocationExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST {
+namespace ICSharpCode.SharpRefactory.Parser.AST {
 	
 	public class InvocationExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ObjectCreateExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ObjectCreateExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ObjectCreateExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class ObjectCreateExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ParenthesizedExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ParenthesizedExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ParenthesizedExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class ParenthesizedExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/PointerReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/PointerReferenceExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/PointerReferenceExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class PointerReferenceExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/PrimitiveExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/PrimitiveExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/PrimitiveExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -2,7 +2,7 @@
 using System.Collections;
 using System.Globalization;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST {
+namespace ICSharpCode.SharpRefactory.Parser.AST {
 	
 	public class PrimitiveExpression : Expression
 	{
@@ -33,7 +33,7 @@
 			this.stringValue = stringValue;
 		}
 		
-		static NumberFormatInfo nfi = CultureInfo.InvariantCulture.NumberFormat;
+		static NumberFormatInfo nfi = new CultureInfo( &quot;en-US&quot;, false ).NumberFormat;
 
 		public override object AcceptVisitor(IASTVisitor visitor, object data)
 		{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/SizeOfExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/SizeOfExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/SizeOfExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class SizeOfExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/StackAllocExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/StackAllocExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/StackAllocExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class StackAllocExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ThisReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ThisReferenceExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/ThisReferenceExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class ThisReferenceExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/TypeOfExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/TypeOfExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/TypeOfExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class TypeOfExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/TypeReferenceExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/TypeReferenceExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/TypeReferenceExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST {
+namespace ICSharpCode.SharpRefactory.Parser.AST {
 	
 	public class TypeReferenceExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/UnaryOperatorExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/UnaryOperatorExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/UnaryOperatorExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class UnaryOperatorExpression : Expression
 	{
@@ -25,6 +25,11 @@
 			}
 		}
 		
+		public UnaryOperatorExpression(UnaryOperatorType op)
+		{
+			this.op    = op;
+		}
+		
 		public UnaryOperatorExpression(Expression expression, UnaryOperatorType op)
 		{
 			this.expression  = expression;

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/UncheckedExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/UncheckedExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Expressions/UncheckedExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class UncheckedExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/AttributeSection.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/AttributeSection.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/AttributeSection.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class NamedArgument : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/DelegateDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/DelegateDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/DelegateDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class DelegateDeclaration : AbstractNode
 	{
@@ -73,15 +73,6 @@
 			}
 		}
 		
-//		public DelegateDeclaration(string name, Modifier modifier, TypeReference returnType, ArrayList parameters, ArrayList attributes)
-//		{
-//			this.name = name;
-//			this.modifier = modifier;
-//			this.returnType = returnType;
-//			this.parameters = parameters;
-//			this.attributes = attributes;
-//		}
-		
 		public override object AcceptVisitor(IASTVisitor visitor, object data)
 		{
 			return visitor.Visit(this, data);

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/NamespaceDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class NamespaceDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/TypeDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/TypeDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/TypeDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,7 +19,7 @@
 using System.Collections;
 using System.Collections.Specialized;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class TypeDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/UsingAliasDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/UsingAliasDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/UsingAliasDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class UsingAliasDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/UsingDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/UsingDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/GlobalScope/UsingDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class UsingDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/IASTVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/IASTVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/IASTVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public interface IASTVisitor
 	{
@@ -80,6 +80,7 @@
 		object Visit(ThisReferenceExpression thisReferenceExpression, object data);
 		object Visit(BaseReferenceExpression baseReferenceExpression, object data);
 		object Visit(ObjectCreateExpression objectCreateExpression, object data);
+		object Visit(ArrayCreationParameter arrayCreationParameter, object data);
 		object Visit(ArrayCreateExpression arrayCreateExpression, object data);
 		object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data);
 		object Visit(FieldReferenceExpression fieldReferenceExpression, object data);

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/INode.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/INode.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/INode.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,7 +19,7 @@
 using System.Drawing;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public interface INode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/LookupTableVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/LookupTableVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/LookupTableVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -2,9 +2,9 @@
 using System.Drawing;
 using System.Collections;
 
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public class LocalLookupVariable
 	{
@@ -71,7 +71,13 @@
 			            foreachStatement.VariableName,
 			            foreachStatement.StartLocation,
 			            foreachStatement.EndLocation);
-			return data;
+			if (foreachStatement.Expression != null) {
+				foreachStatement.Expression.AcceptVisitor(this, data);
+			}
+			if (foreachStatement.EmbeddedStatement == null) {
+				return data;
+			}
+			return foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
 		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Modifier.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Modifier.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Modifier.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,6 +1,6 @@
 using System;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	[Flags]
 	public enum Modifier

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/BlockStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/BlockStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/BlockStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class BlockStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/BreakStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/BreakStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/BreakStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class BreakStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/CheckedStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/CheckedStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/CheckedStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class CheckedStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ContinueStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ContinueStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ContinueStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class ContinueStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/DoWhileStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/DoWhileStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/DoWhileStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class DoWhileStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/EmptyStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/EmptyStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/EmptyStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class EmptyStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/FixedStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/FixedStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/FixedStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class FixedStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ForStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ForStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ForStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class ForStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ForeachStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ForeachStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ForeachStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class ForeachStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/GotoCaseStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/GotoCaseStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/GotoCaseStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class GotoCaseStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/GotoStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/GotoStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/GotoStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class GotoStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/IfElseStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/IfElseStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/IfElseStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class IfElseStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/IfStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/IfStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/IfStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class IfStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LabelStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LabelStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LabelStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class LabelStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LocalVariableDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LocalVariableDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LocalVariableDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class LocalVariableDeclaration : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LockStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LockStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/LockStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class LockStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ReturnStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ReturnStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ReturnStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class ReturnStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/Statement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/Statement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/Statement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class Statement : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/StatementExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/StatementExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/StatementExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class StatementExpression : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/SwitchStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/SwitchStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/SwitchStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class SwitchStatement : BlockStatement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ThrowStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ThrowStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/ThrowStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class ThrowStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/TryCatchStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/TryCatchStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/TryCatchStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class TryCatchStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UncheckedStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UncheckedStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UncheckedStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class UncheckedStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UnsafeStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UnsafeStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UnsafeStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class UnsafeStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UsingStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UsingStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/UsingStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class UsingStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/WhileStatement.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/WhileStatement.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/Statements/WhileStatement.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST 
+namespace ICSharpCode.SharpRefactory.Parser.AST 
 {
 	public class WhileStatement : Statement
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/ConstructorDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class ConstructorDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/DestructorDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/DestructorDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/DestructorDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class DestructorDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventAddRegion.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventAddRegion.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventAddRegion.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class EventAddRegion : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,7 +19,7 @@
 using System.Drawing;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class EventDeclaration : AbstractNode
 	{
@@ -122,8 +122,9 @@
 		public EventDeclaration()
 		{}
 		
-		public EventDeclaration(ArrayList attributes)
+		public EventDeclaration(Modifier modifier, ArrayList attributes)
 		{
+			this.modifier = modifier;
 			this.attributes = attributes;
 		}
 		

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventRemoveRegion.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventRemoveRegion.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/EventRemoveRegion.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class EventRemoveRegion : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/FieldDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/FieldDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/FieldDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class FieldDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/IndexerDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/IndexerDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/IndexerDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,7 +19,7 @@
 using System.Drawing;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class IndexerDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/MethodDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/MethodDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/MethodDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class MethodDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/OperatorDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/OperatorDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/OperatorDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,14 +18,14 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class OperatorDeclaration : AbstractNode
 	{
 		OperatorDeclarator opratorDeclarator;
 		Modifier           modifier;
 		ArrayList          attributes = new ArrayList();
-		BlockStatement     body;
+		Statement     body;
 		
 		// TODO: delegate OperatorDeclarator Members
 		public OperatorDeclarator OpratorDeclarator {
@@ -55,7 +55,7 @@
 			}
 		}
 		
-		public BlockStatement Body {
+		public Statement Body {
 			get {
 				return body;
 			}set {
@@ -85,9 +85,9 @@
 	
 	public class OperatorDeclarator
 	{
-		OperatorType operatorType;
+		OperatorType  operatorType;
 		TypeReference typeReference;
-		string overloadOperator;
+		int           overloadOperatorToken;
 		
 		TypeReference firstParameterType;
 		string firstParameterName;
@@ -103,6 +103,11 @@
 				operatorType = value;
 			}
 		}
+		public bool IsConversion {
+			get {
+				return operatorType == OperatorType.Implicit || operatorType == OperatorType.Explicit;
+			}
+		}
 		
 		public TypeReference TypeReference {
 			get {
@@ -112,14 +117,16 @@
 				typeReference = value;
 			}
 		}
-		public string OverloadOperator {
+		
+		public int OverloadOperatorToken {
 			get {
-				return overloadOperator;
+				return overloadOperatorToken;
 			}
 			set {
-				overloadOperator = value;
+				overloadOperatorToken = value;
 			}
 		}
+		
 		public TypeReference FirstParameterType {
 			get {
 				return firstParameterType;
@@ -153,31 +160,21 @@
 			}
 		}
 		
-		public OperatorDeclarator(TypeReference typeReference, string overloadOperator, TypeReference firstParameterType, string firstParameterName)
+		public OperatorDeclarator(OperatorType operatorType, TypeReference typeReference, int overloadOperatorToken, TypeReference firstParameterType, string firstParameterName, TypeReference secondParameterType, string secondParameterName)
 		{
-			operatorType = OperatorType.Unary;
+			this.operatorType = operatorType;
 			this.typeReference = typeReference;
-			this.overloadOperator = overloadOperator;
+			this.overloadOperatorToken = overloadOperatorToken;
 			this.firstParameterType = firstParameterType;
 			this.firstParameterName = firstParameterName;
-		}
-		
-		public OperatorDeclarator(TypeReference typeReference, string overloadOperator, TypeReference firstParameterType, string firstParameterName, TypeReference secondParameterType, string secondParameterName)
-		{
-			operatorType = OperatorType.Binary;
-			this.typeReference = typeReference;
-			this.overloadOperator = overloadOperator;
-			this.firstParameterType = firstParameterType;
-			this.firstParameterName = firstParameterName;
 			this.secondParameterType = secondParameterType;
 			this.secondParameterName = secondParameterName;
 		}
 		
-		public OperatorDeclarator(OperatorType operatorType,TypeReference typeReference,  string overloadOperator, TypeReference firstParameterType, string firstParameterName)
+		public OperatorDeclarator(OperatorType operatorType,TypeReference typeReference,  TypeReference firstParameterType, string firstParameterName)
 		{
-			this.operatorType = operatorType;
-			this.typeReference = typeReference;
-			this.overloadOperator = overloadOperator;
+			this.operatorType       = operatorType;
+			this.typeReference      = typeReference;
 			this.firstParameterType = firstParameterType;
 			this.firstParameterName = firstParameterName;
 		}

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/ParameterDeclarationExpression.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/ParameterDeclarationExpression.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/ParameterDeclarationExpression.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST {
+namespace ICSharpCode.SharpRefactory.Parser.AST {
 	
 	public class ParameterDeclarationExpression : Expression
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertyDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertyDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertyDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,7 +19,7 @@
 using System.Drawing;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class PropertyDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertyGetRegion.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertyGetRegion.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertyGetRegion.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class PropertyGetRegion : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertySetRegion.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertySetRegion.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/PropertySetRegion.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class PropertySetRegion : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/TypeReference.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/TypeReference.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/TypeReference.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,7 +19,7 @@
 using System.Collections;
 using System.Text;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class TypeReference
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/VariableDeclaration.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/VariableDeclaration.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/AST/TypeLevel/VariableDeclaration.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -18,7 +18,7 @@
 using System;
 using System.Collections;
 
-namespace MonoDevelop.SharpRefactory.Parser.AST
+namespace ICSharpCode.SharpRefactory.Parser.AST
 {
 	public class VariableDeclaration : AbstractNode
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Error.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Error.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Error.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,7 +1,7 @@
 using System;
 using System.Text;
 
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public delegate void ErrorCodeProc(int line, int col, int n);
 	public delegate void ErrorMsgProc(int line, int col, string msg);

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Modifiers.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Modifiers.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Modifiers.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,4 +1,4 @@
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public class Modifiers
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Parser.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Parser.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/Parser.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -4,12 +4,12 @@
 using System.Collections;
 using System.Collections.Specialized;
 using System.Text;
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 using System;
 using System.Reflection;
 
-namespace MonoDevelop.SharpRefactory.Parser {
+namespace ICSharpCode.SharpRefactory.Parser {
 
 
 
@@ -338,7 +338,7 @@
 /* True, if lookahead is a primitive type keyword, or *
  * if it is a type declaration followed by an ident   */
 bool IsLocalVarDecl () {
-	if (ParserUtil.IsTypeKW(la) || la.kind == Tokens.Void) return true;
+	if ((ParserUtil.IsTypeKW(la) &amp;&amp; Peek(1).kind != Tokens.Dot) || la.kind == Tokens.Void) return true;
 	
 	StartPeek();
 	Token pt = la ;  // peek token
@@ -517,17 +517,17 @@
 	}
 
 	void GlobalAttributeSection() {
+		Expect(16);
 
-#line  551 &quot;cs.ATG&quot; 
+#line  552 &quot;cs.ATG&quot; 
 		Point startPos = t.Location; 
-		Expect(16);
 		Expect(1);
 
 #line  552 &quot;cs.ATG&quot; 
 		if (t.val != &quot;assembly&quot;) Error(&quot;global attribute target specifier (\&quot;assembly\&quot;) expected&quot;);
 		string attributeTarget = t.val;
 		ArrayList attributes = new ArrayList();
-		MonoDevelop.SharpRefactory.Parser.AST.Attribute attribute;
+		ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
 		
 		Expect(9);
 		Attribute(
@@ -644,7 +644,7 @@
 
 	void Attribute(
 #line  567 &quot;cs.ATG&quot; 
-out MonoDevelop.SharpRefactory.Parser.AST.Attribute attribute) {
+out ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute) {
 
 #line  568 &quot;cs.ATG&quot; 
 		string qualident; 
@@ -664,7 +664,7 @@
 		}
 
 #line  574 &quot;cs.ATG&quot; 
-		attribute  = new MonoDevelop.SharpRefactory.Parser.AST.Attribute(name, positional, named);
+		attribute  = new ICSharpCode.SharpRefactory.Parser.AST.Attribute(name, positional, named);
 	}
 
 	void AttributeArguments(
@@ -730,40 +730,43 @@
 	}
 
 	void Expr(
-#line  1684 &quot;cs.ATG&quot; 
+#line  1714 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1685 &quot;cs.ATG&quot; 
-		expr = new Expression(); 
+#line  1715 &quot;cs.ATG&quot; 
+		expr = null; Expression expr1 = null, expr2 = null; 
 		UnaryExpr(
-#line  1687 &quot;cs.ATG&quot; 
+#line  1717 &quot;cs.ATG&quot; 
 out expr);
 		if (StartOf(5)) {
 			ConditionalOrExpr(
-#line  1690 &quot;cs.ATG&quot; 
+#line  1720 &quot;cs.ATG&quot; 
 ref expr);
 			if (la.kind == 11) {
 				lexer.NextToken();
 				Expr(
-#line  1690 &quot;cs.ATG&quot; 
-out expr);
+#line  1720 &quot;cs.ATG&quot; 
+out expr1);
 				Expect(9);
 				Expr(
-#line  1690 &quot;cs.ATG&quot; 
-out expr);
+#line  1720 &quot;cs.ATG&quot; 
+out expr2);
+
+#line  1720 &quot;cs.ATG&quot; 
+				expr = new ConditionalExpression(expr, expr1, expr2);  
 			}
 		} else if (StartOf(6)) {
 
-#line  1692 &quot;cs.ATG&quot; 
+#line  1722 &quot;cs.ATG&quot; 
 			AssignmentOperatorType op; Expression val; 
 			AssignmentOperator(
-#line  1692 &quot;cs.ATG&quot; 
+#line  1722 &quot;cs.ATG&quot; 
 out op);
 			Expr(
-#line  1692 &quot;cs.ATG&quot; 
+#line  1722 &quot;cs.ATG&quot; 
 out val);
 
-#line  1692 &quot;cs.ATG&quot; 
+#line  1722 &quot;cs.ATG&quot; 
 			expr = new AssignmentExpression(expr, op, val); 
 		} else SynErr(128);
 	}
@@ -775,7 +778,7 @@
 #line  611 &quot;cs.ATG&quot; 
 		string attributeTarget = &quot;&quot;;
 		ArrayList attributes = new ArrayList();
-		MonoDevelop.SharpRefactory.Parser.AST.Attribute attribute;
+		ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
 		
 		
 		Expect(16);
@@ -947,7 +950,7 @@
 			}
 
 #line  685 &quot;cs.ATG&quot; 
-			newType.EndLocation = t.EndLocation; 
+			newType.EndLocation = t.Location; 
 			compilationUnit.BlockEnd();
 			
 		} else if (StartOf(7)) {
@@ -986,7 +989,7 @@
 				}
 
 #line  699 &quot;cs.ATG&quot; 
-				newType.EndLocation = t.EndLocation; 
+				newType.EndLocation = t.Location; 
 				compilationUnit.BlockEnd();
 				
 			} else if (la.kind == 82) {
@@ -1020,7 +1023,7 @@
 				}
 
 #line  712 &quot;cs.ATG&quot; 
-				newType.EndLocation = t.EndLocation; 
+				newType.EndLocation = t.Location; 
 				compilationUnit.BlockEnd();
 				
 			} else if (la.kind == 67) {
@@ -1057,7 +1060,7 @@
 				}
 
 #line  728 &quot;cs.ATG&quot; 
-				newType.EndLocation = t.EndLocation; 
+				newType.EndLocation = t.Location; 
 				compilationUnit.BlockEnd();
 				
 			} else {
@@ -1101,7 +1104,7 @@
 				Expect(10);
 
 #line  743 &quot;cs.ATG&quot; 
-				delegateDeclr.EndLocation = t.EndLocation;
+				delegateDeclr.EndLocation = t.Location;
 				compilationUnit.AddChild(delegateDeclr);
 				
 			}
@@ -1618,23 +1621,23 @@
 	}
 
 	void ClassMemberDecl(
-#line  1153 &quot;cs.ATG&quot; 
+#line  1178 &quot;cs.ATG&quot; 
 Modifiers m, ArrayList attributes) {
 
-#line  1154 &quot;cs.ATG&quot; 
+#line  1179 &quot;cs.ATG&quot; 
 		Statement stmt = null; 
 		if (StartOf(16)) {
 			StructMemberDecl(
-#line  1156 &quot;cs.ATG&quot; 
+#line  1181 &quot;cs.ATG&quot; 
 m, attributes);
 		} else if (la.kind == 25) {
 
-#line  1157 &quot;cs.ATG&quot; 
+#line  1182 &quot;cs.ATG&quot; 
 			m.Check(Modifier.Destructors); Point startPos = t.Location; 
 			lexer.NextToken();
 			Expect(1);
 
-#line  1158 &quot;cs.ATG&quot; 
+#line  1183 &quot;cs.ATG&quot; 
 			DestructorDeclaration d = new DestructorDeclaration(t.val, attributes); 
 			d.Modifier = m.Modifier;
 			d.StartLocation = startPos;
@@ -1643,13 +1646,13 @@
 			Expect(19);
 			if (la.kind == 14) {
 				Block(
-#line  1162 &quot;cs.ATG&quot; 
+#line  1187 &quot;cs.ATG&quot; 
 out stmt);
 			} else if (la.kind == 10) {
 				lexer.NextToken();
 			} else SynErr(139);
 
-#line  1162 &quot;cs.ATG&quot; 
+#line  1187 &quot;cs.ATG&quot; 
 			d.EndLocation = t.EndLocation; 
 			d.Body = (BlockStatement)stmt;
 			compilationUnit.AddChild(d);
@@ -1662,7 +1665,7 @@
 Modifiers m, ArrayList attributes) {
 
 #line  972 &quot;cs.ATG&quot; 
-		string qualident;
+		string qualident = null;
 		TypeReference type;
 		Expression expr;
 		ArrayList p = new ArrayList();
@@ -1765,7 +1768,7 @@
 			lexer.NextToken();
 
 #line  1012 &quot;cs.ATG&quot; 
-			EventDeclaration eventDecl = new EventDeclaration(attributes);
+			EventDeclaration eventDecl = new EventDeclaration(m.Modifier, attributes);
 			eventDecl.StartLocation = t.Location;
 			compilationUnit.AddChild(eventDecl);
 			compilationUnit.BlockStart(eventDecl);
@@ -1872,70 +1875,102 @@
 #line  1050 &quot;cs.ATG&quot; 
 			m.Check(Modifier.Operators);
 			if (m.isNone) Error(&quot;at least one modifier must be set&quot;); 
+			bool isImplicit = true;
 			
 			if (la.kind == 79) {
 				lexer.NextToken();
 			} else {
 				lexer.NextToken();
+
+#line  1054 &quot;cs.ATG&quot; 
+				isImplicit = false; 
 			}
 			Expect(91);
 			Type(
-#line  1053 &quot;cs.ATG&quot; 
+#line  1055 &quot;cs.ATG&quot; 
 out type);
+
+#line  1055 &quot;cs.ATG&quot; 
+			TypeReference operatorType = type; 
 			Expect(18);
 			Type(
-#line  1053 &quot;cs.ATG&quot; 
+#line  1056 &quot;cs.ATG&quot; 
 out type);
 			Expect(1);
+
+#line  1056 &quot;cs.ATG&quot; 
+			string varName = t.val; 
 			Expect(19);
 			if (la.kind == 14) {
 				Block(
-#line  1053 &quot;cs.ATG&quot; 
+#line  1056 &quot;cs.ATG&quot; 
 out stmt);
 			} else if (la.kind == 10) {
 				lexer.NextToken();
+
+#line  1056 &quot;cs.ATG&quot; 
+				stmt = null; 
 			} else SynErr(144);
+
+#line  1059 &quot;cs.ATG&quot; 
+			OperatorDeclarator operatorDeclarator = new OperatorDeclarator(isImplicit ? OperatorType.Implicit : OperatorType.Explicit,
+			                                                              operatorType,
+			                                                              type,
+			                                                              varName);
+			OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+			operatorDeclaration.Body = stmt;
+			compilationUnit.AddChild(operatorDeclaration);
+			
 		} else if (StartOf(17)) {
 			TypeDecl(
-#line  1056 &quot;cs.ATG&quot; 
+#line  1069 &quot;cs.ATG&quot; 
 m, attributes);
 		} else if (StartOf(8)) {
 			Type(
-#line  1057 &quot;cs.ATG&quot; 
+#line  1070 &quot;cs.ATG&quot; 
 out type);
 
-#line  1057 &quot;cs.ATG&quot; 
+#line  1070 &quot;cs.ATG&quot; 
 			Point startPos = t.Location; 
 			if (la.kind == 91) {
 
-#line  1059 &quot;cs.ATG&quot; 
+#line  1072 &quot;cs.ATG&quot; 
 				Token op;
 				m.Check(Modifier.Operators);
 				if (m.isNone) Error(&quot;at least one modifier must be set&quot;);
 				
 				lexer.NextToken();
 				OverloadableOperator(
-#line  1063 &quot;cs.ATG&quot; 
+#line  1076 &quot;cs.ATG&quot; 
 out op);
+
+#line  1076 &quot;cs.ATG&quot; 
+				TypeReference firstType, secondType = null; string secondName = null; 
 				Expect(18);
 				Type(
-#line  1064 &quot;cs.ATG&quot; 
-out type);
+#line  1077 &quot;cs.ATG&quot; 
+out firstType);
 				Expect(1);
+
+#line  1077 &quot;cs.ATG&quot; 
+				string firstName = t.val; 
 				if (la.kind == 12) {
 					lexer.NextToken();
 					Type(
-#line  1065 &quot;cs.ATG&quot; 
-out type);
+#line  1078 &quot;cs.ATG&quot; 
+out secondType);
 					Expect(1);
 
-#line  1065 &quot;cs.ATG&quot; 
-					if (ParserUtil.IsUnaryOperator(op))
+#line  1078 &quot;cs.ATG&quot; 
+					secondName = t.val; 
+
+#line  1078 &quot;cs.ATG&quot; 
+					if (ParserUtil.IsUnaryOperator(op) &amp;&amp; !ParserUtil.IsBinaryOperator(op))
 					Error(&quot;too many operands for unary operator&quot;); 
 					
 				} else if (la.kind == 19) {
 
-#line  1068 &quot;cs.ATG&quot; 
+#line  1081 &quot;cs.ATG&quot; 
 					if (ParserUtil.IsBinaryOperator(op))
 					Error(&quot;too few operands for binary operator&quot;);
 					
@@ -1943,49 +1978,62 @@
 				Expect(19);
 				if (la.kind == 14) {
 					Block(
-#line  1072 &quot;cs.ATG&quot; 
+#line  1085 &quot;cs.ATG&quot; 
 out stmt);
 				} else if (la.kind == 10) {
 					lexer.NextToken();
 				} else SynErr(146);
+
+#line  1087 &quot;cs.ATG&quot; 
+				OperatorDeclarator operatorDeclarator = new OperatorDeclarator(secondType != null ? OperatorType.Binary : OperatorType.Unary, 
+				                                                              type,
+				                                                              op.kind,
+				                                                              firstType,
+				                                                              firstName,
+				                                                              secondType,
+				                                                              secondName);
+				OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+				operatorDeclaration.Body = stmt;
+				compilationUnit.AddChild(operatorDeclaration);
+				
 			} else if (
-#line  1075 &quot;cs.ATG&quot; 
+#line  1100 &quot;cs.ATG&quot; 
 IsVarDecl()) {
 
-#line  1075 &quot;cs.ATG&quot; 
+#line  1100 &quot;cs.ATG&quot; 
 				m.Check(Modifier.Fields); 
 				FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
 				fd.StartLocation = startPos; 
 				
 				VariableDeclarator(
-#line  1079 &quot;cs.ATG&quot; 
+#line  1104 &quot;cs.ATG&quot; 
 variableDeclarators);
 				while (la.kind == 12) {
 					lexer.NextToken();
 					VariableDeclarator(
-#line  1080 &quot;cs.ATG&quot; 
+#line  1105 &quot;cs.ATG&quot; 
 variableDeclarators);
 				}
 				Expect(10);
 
-#line  1081 &quot;cs.ATG&quot; 
+#line  1106 &quot;cs.ATG&quot; 
 				fd.EndLocation = t.EndLocation; fd.Fields = variableDeclarators; compilationUnit.AddChild(fd); 
 			} else if (la.kind == 110) {
 
-#line  1084 &quot;cs.ATG&quot; 
+#line  1109 &quot;cs.ATG&quot; 
 				m.Check(Modifier.Indexers); 
 				lexer.NextToken();
 				Expect(16);
 				FormalParameterList(
-#line  1085 &quot;cs.ATG&quot; 
+#line  1110 &quot;cs.ATG&quot; 
 out p);
 				Expect(17);
 
-#line  1085 &quot;cs.ATG&quot; 
+#line  1110 &quot;cs.ATG&quot; 
 				Point endLocation = t.EndLocation; 
 				Expect(14);
 
-#line  1086 &quot;cs.ATG&quot; 
+#line  1111 &quot;cs.ATG&quot; 
 				IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
 				indexer.StartLocation = startPos;
 				indexer.EndLocation   = endLocation;
@@ -1994,11 +2042,11 @@
 				PropertySetRegion setRegion;
 				
 				AccessorDecls(
-#line  1093 &quot;cs.ATG&quot; 
+#line  1118 &quot;cs.ATG&quot; 
 out getRegion, out setRegion);
 				Expect(15);
 
-#line  1094 &quot;cs.ATG&quot; 
+#line  1119 &quot;cs.ATG&quot; 
 				indexer.BodyEnd    = t.EndLocation;
 				indexer.GetRegion = getRegion;
 				indexer.SetRegion = setRegion;
@@ -2006,25 +2054,25 @@
 				
 			} else if (la.kind == 1) {
 				Qualident(
-#line  1099 &quot;cs.ATG&quot; 
+#line  1124 &quot;cs.ATG&quot; 
 out qualident);
 
-#line  1099 &quot;cs.ATG&quot; 
+#line  1124 &quot;cs.ATG&quot; 
 				Point qualIdentEndLocation = t.EndLocation; 
 				if (la.kind == 14 || la.kind == 18) {
 					if (la.kind == 18) {
 
-#line  1102 &quot;cs.ATG&quot; 
+#line  1127 &quot;cs.ATG&quot; 
 						m.Check(Modifier.PropertysEventsMethods); 
 						lexer.NextToken();
 						if (StartOf(9)) {
 							FormalParameterList(
-#line  1103 &quot;cs.ATG&quot; 
+#line  1128 &quot;cs.ATG&quot; 
 out p);
 						}
 						Expect(19);
 
-#line  1103 &quot;cs.ATG&quot; 
+#line  1128 &quot;cs.ATG&quot; 
 						MethodDeclaration methodDeclaration = new MethodDeclaration(qualident, 
 						                                                     m.Modifier, 
 						                                                     type, 
@@ -2036,18 +2084,18 @@
 						  
 						if (la.kind == 14) {
 							Block(
-#line  1112 &quot;cs.ATG&quot; 
+#line  1137 &quot;cs.ATG&quot; 
 out stmt);
 						} else if (la.kind == 10) {
 							lexer.NextToken();
 						} else SynErr(147);
 
-#line  1112 &quot;cs.ATG&quot; 
+#line  1137 &quot;cs.ATG&quot; 
 						methodDeclaration.Body  = (BlockStatement)stmt; 
 					} else {
 						lexer.NextToken();
 
-#line  1115 &quot;cs.ATG&quot; 
+#line  1140 &quot;cs.ATG&quot; 
 						PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
 						pDecl.StartLocation = startPos;
 						pDecl.EndLocation   = qualIdentEndLocation;
@@ -2056,11 +2104,11 @@
 						PropertySetRegion setRegion;
 						
 						AccessorDecls(
-#line  1122 &quot;cs.ATG&quot; 
+#line  1147 &quot;cs.ATG&quot; 
 out getRegion, out setRegion);
 						Expect(15);
 
-#line  1124 &quot;cs.ATG&quot; 
+#line  1149 &quot;cs.ATG&quot; 
 						pDecl.GetRegion = getRegion;
 						pDecl.SetRegion = setRegion;
 						pDecl.BodyEnd = t.EndLocation;
@@ -2069,17 +2117,17 @@
 					}
 				} else if (la.kind == 13) {
 
-#line  1132 &quot;cs.ATG&quot; 
+#line  1157 &quot;cs.ATG&quot; 
 					m.Check(Modifier.Indexers); 
 					lexer.NextToken();
 					Expect(110);
 					Expect(16);
 					FormalParameterList(
-#line  1133 &quot;cs.ATG&quot; 
+#line  1158 &quot;cs.ATG&quot; 
 out p);
 					Expect(17);
 
-#line  1134 &quot;cs.ATG&quot; 
+#line  1159 &quot;cs.ATG&quot; 
 					IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
 					indexer.StartLocation = startPos;
 					indexer.EndLocation   = t.EndLocation;
@@ -2089,14 +2137,14 @@
 					
 					Expect(14);
 
-#line  1141 &quot;cs.ATG&quot; 
+#line  1166 &quot;cs.ATG&quot; 
 					Point bodyStart = t.Location; 
 					AccessorDecls(
-#line  1142 &quot;cs.ATG&quot; 
+#line  1167 &quot;cs.ATG&quot; 
 out getRegion, out setRegion);
 					Expect(15);
 
-#line  1143 &quot;cs.ATG&quot; 
+#line  1168 &quot;cs.ATG&quot; 
 					indexer.BodyStart = bodyStart;
 					indexer.BodyEnd   = t.EndLocation;
 					indexer.GetRegion = getRegion;
@@ -2110,7 +2158,7 @@
 
 	void InterfaceMemberDecl() {
 
-#line  1170 &quot;cs.ATG&quot; 
+#line  1195 &quot;cs.ATG&quot; 
 		TypeReference type;
 		ArrayList p;
 		AttributeSection section;
@@ -2120,124 +2168,145 @@
 		string name;
 		PropertyGetRegion getBlock;
 		PropertySetRegion setBlock;
+		Point startLocation = new Point(-1, -1);
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1181 &quot;cs.ATG&quot; 
+#line  1207 &quot;cs.ATG&quot; 
 out section);
 
-#line  1181 &quot;cs.ATG&quot; 
+#line  1207 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (la.kind == 88) {
 			lexer.NextToken();
 
-#line  1182 &quot;cs.ATG&quot; 
-			mod = Modifier.New; 
+#line  1208 &quot;cs.ATG&quot; 
+			mod = Modifier.New; startLocation = t.Location; 
 		}
 		if (
-#line  1185 &quot;cs.ATG&quot; 
+#line  1211 &quot;cs.ATG&quot; 
 NotVoidPointer()) {
 			Expect(122);
+
+#line  1211 &quot;cs.ATG&quot; 
+			if (startLocation.X == -1) startLocation = t.Location; 
 			Expect(1);
 
-#line  1185 &quot;cs.ATG&quot; 
+#line  1211 &quot;cs.ATG&quot; 
 			name = t.val; 
 			Expect(18);
 			if (StartOf(9)) {
 				FormalParameterList(
-#line  1186 &quot;cs.ATG&quot; 
-out p);
+#line  1212 &quot;cs.ATG&quot; 
+out parameters);
 			}
 			Expect(19);
 			Expect(10);
 
-#line  1186 &quot;cs.ATG&quot; 
+#line  1212 &quot;cs.ATG&quot; 
 			MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference(&quot;void&quot;), parameters, attributes);
+			md.StartLocation = startLocation;
 			md.EndLocation = t.EndLocation;
 			compilationUnit.AddChild(md);
 			
 		} else if (StartOf(18)) {
 			if (StartOf(8)) {
 				Type(
-#line  1191 &quot;cs.ATG&quot; 
+#line  1218 &quot;cs.ATG&quot; 
 out type);
+
+#line  1218 &quot;cs.ATG&quot; 
+				if (startLocation.X == -1) startLocation = t.Location; 
 				if (la.kind == 1) {
 					lexer.NextToken();
 
-#line  1193 &quot;cs.ATG&quot; 
-					name = t.val; 
+#line  1220 &quot;cs.ATG&quot; 
+					name = t.val; Point qualIdentEndLocation = t.EndLocation; 
 					if (la.kind == 18) {
 						lexer.NextToken();
 						if (StartOf(9)) {
 							FormalParameterList(
-#line  1196 &quot;cs.ATG&quot; 
+#line  1223 &quot;cs.ATG&quot; 
 out parameters);
 						}
 						Expect(19);
 						Expect(10);
 
-#line  1196 &quot;cs.ATG&quot; 
+#line  1223 &quot;cs.ATG&quot; 
 						MethodDeclaration md = new MethodDeclaration(name, mod, type, parameters, attributes);
+						md.StartLocation = startLocation;
 						md.EndLocation = t.EndLocation;
 						compilationUnit.AddChild(md);
 						
 					} else if (la.kind == 14) {
 
-#line  1201 &quot;cs.ATG&quot; 
+#line  1229 &quot;cs.ATG&quot; 
 						PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); 
 						lexer.NextToken();
+
+#line  1230 &quot;cs.ATG&quot; 
+						Point bodyStart = t.Location;
 						InterfaceAccessors(
-#line  1202 &quot;cs.ATG&quot; 
+#line  1230 &quot;cs.ATG&quot; 
 out getBlock, out setBlock);
 						Expect(15);
 
-#line  1202 &quot;cs.ATG&quot; 
-						pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.EndLocation = t.EndLocation; 
+#line  1230 &quot;cs.ATG&quot; 
+						pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; 
 					} else SynErr(151);
 				} else if (la.kind == 110) {
 					lexer.NextToken();
 					Expect(16);
 					FormalParameterList(
-#line  1205 &quot;cs.ATG&quot; 
+#line  1233 &quot;cs.ATG&quot; 
 out p);
 					Expect(17);
 
-#line  1205 &quot;cs.ATG&quot; 
+#line  1233 &quot;cs.ATG&quot; 
+					Point bracketEndLocation = t.EndLocation; 
+
+#line  1233 &quot;cs.ATG&quot; 
 					IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); 
 					Expect(14);
+
+#line  1234 &quot;cs.ATG&quot; 
+					Point bodyStart = t.Location;
 					InterfaceAccessors(
-#line  1206 &quot;cs.ATG&quot; 
+#line  1234 &quot;cs.ATG&quot; 
 out getBlock, out setBlock);
 					Expect(15);
 
-#line  1206 &quot;cs.ATG&quot; 
-					id.GetRegion = getBlock; id.SetRegion = setBlock; id.EndLocation = t.EndLocation; 
+#line  1234 &quot;cs.ATG&quot; 
+					id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;
 				} else SynErr(152);
 			} else {
 				lexer.NextToken();
+
+#line  1237 &quot;cs.ATG&quot; 
+				if (startLocation.X == -1) startLocation = t.Location; 
 				Type(
-#line  1209 &quot;cs.ATG&quot; 
+#line  1237 &quot;cs.ATG&quot; 
 out type);
 				Expect(1);
 
-#line  1209 &quot;cs.ATG&quot; 
+#line  1237 &quot;cs.ATG&quot; 
 				EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
 				compilationUnit.AddChild(ed);
 				
 				Expect(10);
 
-#line  1212 &quot;cs.ATG&quot; 
-				ed.EndLocation = t.EndLocation; 
+#line  1240 &quot;cs.ATG&quot; 
+				ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; 
 			}
 		} else SynErr(153);
 	}
 
 	void EnumMemberDecl(
-#line  1217 &quot;cs.ATG&quot; 
+#line  1245 &quot;cs.ATG&quot; 
 out FieldDeclaration f) {
 
-#line  1219 &quot;cs.ATG&quot; 
+#line  1247 &quot;cs.ATG&quot; 
 		Expression expr = null;
 		ArrayList attributes = new ArrayList();
 		AttributeSection section = null;
@@ -2245,15 +2314,15 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1225 &quot;cs.ATG&quot; 
+#line  1253 &quot;cs.ATG&quot; 
 out section);
 
-#line  1225 &quot;cs.ATG&quot; 
+#line  1253 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		Expect(1);
 
-#line  1226 &quot;cs.ATG&quot; 
+#line  1254 &quot;cs.ATG&quot; 
 		f = new FieldDeclaration(attributes);
 		varDecl         = new VariableDeclaration(t.val);
 		f.Fields.Add(varDecl);
@@ -2262,10 +2331,10 @@
 		if (la.kind == 3) {
 			lexer.NextToken();
 			Expr(
-#line  1231 &quot;cs.ATG&quot; 
+#line  1259 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1231 &quot;cs.ATG&quot; 
+#line  1259 &quot;cs.ATG&quot; 
 			varDecl.Initializer = expr; 
 		}
 	}
@@ -2387,11 +2456,11 @@
 	}
 
 	void Block(
-#line  1335 &quot;cs.ATG&quot; 
+#line  1363 &quot;cs.ATG&quot; 
 out Statement stmt) {
 		Expect(14);
 
-#line  1337 &quot;cs.ATG&quot; 
+#line  1365 &quot;cs.ATG&quot; 
 		BlockStatement blockStmt = new BlockStatement();
 		blockStmt.StartLocation = t.Location;
 		compilationUnit.BlockStart(blockStmt);
@@ -2401,7 +2470,7 @@
 		}
 		Expect(15);
 
-#line  1342 &quot;cs.ATG&quot; 
+#line  1370 &quot;cs.ATG&quot; 
 		stmt = blockStmt;
 		blockStmt.EndLocation = t.EndLocation;
 		compilationUnit.BlockEnd();
@@ -2409,34 +2478,34 @@
 	}
 
 	void VariableDeclarator(
-#line  1328 &quot;cs.ATG&quot; 
+#line  1356 &quot;cs.ATG&quot; 
 ArrayList fieldDeclaration) {
 
-#line  1329 &quot;cs.ATG&quot; 
+#line  1357 &quot;cs.ATG&quot; 
 		Expression expr = null; 
 		Expect(1);
 
-#line  1331 &quot;cs.ATG&quot; 
+#line  1359 &quot;cs.ATG&quot; 
 		VariableDeclaration f = new VariableDeclaration(t.val); 
 		if (la.kind == 3) {
 			lexer.NextToken();
 			VariableInitializer(
-#line  1332 &quot;cs.ATG&quot; 
+#line  1360 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1332 &quot;cs.ATG&quot; 
+#line  1360 &quot;cs.ATG&quot; 
 			f.Initializer = expr; 
 		}
 
-#line  1332 &quot;cs.ATG&quot; 
+#line  1360 &quot;cs.ATG&quot; 
 		fieldDeclaration.Add(f); 
 	}
 
 	void EventAccessorDecls(
-#line  1277 &quot;cs.ATG&quot; 
+#line  1305 &quot;cs.ATG&quot; 
 out EventAddRegion addBlock, out EventRemoveRegion removeBlock) {
 
-#line  1278 &quot;cs.ATG&quot; 
+#line  1306 &quot;cs.ATG&quot; 
 		AttributeSection section;
 		ArrayList attributes = new ArrayList();
 		Statement stmt;
@@ -2445,102 +2514,102 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1285 &quot;cs.ATG&quot; 
+#line  1313 &quot;cs.ATG&quot; 
 out section);
 
-#line  1285 &quot;cs.ATG&quot; 
+#line  1313 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (
-#line  1287 &quot;cs.ATG&quot; 
+#line  1315 &quot;cs.ATG&quot; 
 IdentIsAdd()) {
 
-#line  1287 &quot;cs.ATG&quot; 
+#line  1315 &quot;cs.ATG&quot; 
 			addBlock = new EventAddRegion(attributes); 
 			AddAccessorDecl(
-#line  1288 &quot;cs.ATG&quot; 
+#line  1316 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1288 &quot;cs.ATG&quot; 
+#line  1316 &quot;cs.ATG&quot; 
 			attributes = new ArrayList(); addBlock.Block = (BlockStatement)stmt; 
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1289 &quot;cs.ATG&quot; 
+#line  1317 &quot;cs.ATG&quot; 
 out section);
 
-#line  1289 &quot;cs.ATG&quot; 
+#line  1317 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			RemoveAccessorDecl(
-#line  1290 &quot;cs.ATG&quot; 
+#line  1318 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1290 &quot;cs.ATG&quot; 
+#line  1318 &quot;cs.ATG&quot; 
 			removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; 
 		} else if (
-#line  1291 &quot;cs.ATG&quot; 
+#line  1319 &quot;cs.ATG&quot; 
 IdentIsRemove()) {
 			RemoveAccessorDecl(
-#line  1292 &quot;cs.ATG&quot; 
+#line  1320 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1292 &quot;cs.ATG&quot; 
+#line  1320 &quot;cs.ATG&quot; 
 			removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new ArrayList(); 
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1293 &quot;cs.ATG&quot; 
+#line  1321 &quot;cs.ATG&quot; 
 out section);
 
-#line  1293 &quot;cs.ATG&quot; 
+#line  1321 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			AddAccessorDecl(
-#line  1294 &quot;cs.ATG&quot; 
+#line  1322 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1294 &quot;cs.ATG&quot; 
+#line  1322 &quot;cs.ATG&quot; 
 			addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; 
 		} else if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1295 &quot;cs.ATG&quot; 
+#line  1323 &quot;cs.ATG&quot; 
 			Error(&quot;add or remove accessor declaration expected&quot;); 
 		} else SynErr(156);
 	}
 
 	void ConstructorInitializer(
-#line  1364 &quot;cs.ATG&quot; 
+#line  1392 &quot;cs.ATG&quot; 
 out ConstructorInitializer ci) {
 
-#line  1365 &quot;cs.ATG&quot; 
+#line  1393 &quot;cs.ATG&quot; 
 		Expression expr; ci = new ConstructorInitializer(); 
 		Expect(9);
 		if (la.kind == 50) {
 			lexer.NextToken();
 
-#line  1369 &quot;cs.ATG&quot; 
+#line  1397 &quot;cs.ATG&quot; 
 			ci.ConstructorInitializerType = ConstructorInitializerType.Base; 
 		} else if (la.kind == 110) {
 			lexer.NextToken();
 
-#line  1370 &quot;cs.ATG&quot; 
+#line  1398 &quot;cs.ATG&quot; 
 			ci.ConstructorInitializerType = ConstructorInitializerType.This; 
 		} else SynErr(157);
 		Expect(18);
 		if (StartOf(21)) {
 			Argument(
-#line  1373 &quot;cs.ATG&quot; 
+#line  1401 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1373 &quot;cs.ATG&quot; 
+#line  1401 &quot;cs.ATG&quot; 
 			ci.Arguments.Add(expr); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Argument(
-#line  1373 &quot;cs.ATG&quot; 
+#line  1401 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1373 &quot;cs.ATG&quot; 
+#line  1401 &quot;cs.ATG&quot; 
 				ci.Arguments.Add(expr); 
 			}
 		}
@@ -2548,7 +2617,7 @@
 	}
 
 	void OverloadableOperator(
-#line  1385 &quot;cs.ATG&quot; 
+#line  1413 &quot;cs.ATG&quot; 
 out Token op) {
 		switch (la.kind) {
 		case 4: {
@@ -2642,15 +2711,15 @@
 		default: SynErr(158); break;
 		}
 
-#line  1394 &quot;cs.ATG&quot; 
+#line  1422 &quot;cs.ATG&quot; 
 		op = t; 
 	}
 
 	void AccessorDecls(
-#line  1235 &quot;cs.ATG&quot; 
+#line  1263 &quot;cs.ATG&quot; 
 out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
 
-#line  1237 &quot;cs.ATG&quot; 
+#line  1265 &quot;cs.ATG&quot; 
 		ArrayList attributes = new ArrayList(); 
 		AttributeSection section;
 		getBlock = null;
@@ -2658,136 +2727,136 @@
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1243 &quot;cs.ATG&quot; 
+#line  1271 &quot;cs.ATG&quot; 
 out section);
 
-#line  1243 &quot;cs.ATG&quot; 
+#line  1271 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (
-#line  1245 &quot;cs.ATG&quot; 
+#line  1273 &quot;cs.ATG&quot; 
 IdentIsGet()) {
 			GetAccessorDecl(
-#line  1246 &quot;cs.ATG&quot; 
+#line  1274 &quot;cs.ATG&quot; 
 out getBlock, attributes);
 			if (la.kind == 1 || la.kind == 16) {
 
-#line  1247 &quot;cs.ATG&quot; 
+#line  1275 &quot;cs.ATG&quot; 
 				attributes = new ArrayList(); 
 				while (la.kind == 16) {
 					AttributeSection(
-#line  1248 &quot;cs.ATG&quot; 
+#line  1276 &quot;cs.ATG&quot; 
 out section);
 
-#line  1248 &quot;cs.ATG&quot; 
+#line  1276 &quot;cs.ATG&quot; 
 					attributes.Add(section); 
 				}
 				SetAccessorDecl(
-#line  1249 &quot;cs.ATG&quot; 
+#line  1277 &quot;cs.ATG&quot; 
 out setBlock, attributes);
 			}
 		} else if (
-#line  1251 &quot;cs.ATG&quot; 
+#line  1279 &quot;cs.ATG&quot; 
 IdentIsSet()) {
 			SetAccessorDecl(
-#line  1252 &quot;cs.ATG&quot; 
+#line  1280 &quot;cs.ATG&quot; 
 out setBlock, attributes);
 			if (la.kind == 1 || la.kind == 16) {
 
-#line  1253 &quot;cs.ATG&quot; 
+#line  1281 &quot;cs.ATG&quot; 
 				attributes = new ArrayList(); 
 				while (la.kind == 16) {
 					AttributeSection(
-#line  1254 &quot;cs.ATG&quot; 
+#line  1282 &quot;cs.ATG&quot; 
 out section);
 
-#line  1254 &quot;cs.ATG&quot; 
+#line  1282 &quot;cs.ATG&quot; 
 					attributes.Add(section); 
 				}
 				GetAccessorDecl(
-#line  1255 &quot;cs.ATG&quot; 
+#line  1283 &quot;cs.ATG&quot; 
 out getBlock, attributes);
 			}
 		} else if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1257 &quot;cs.ATG&quot; 
+#line  1285 &quot;cs.ATG&quot; 
 			Error(&quot;get or set accessor declaration expected&quot;); 
 		} else SynErr(159);
 	}
 
 	void InterfaceAccessors(
-#line  1299 &quot;cs.ATG&quot; 
+#line  1327 &quot;cs.ATG&quot; 
 out PropertyGetRegion getBlock, out PropertySetRegion setBlock) {
 
-#line  1301 &quot;cs.ATG&quot; 
+#line  1329 &quot;cs.ATG&quot; 
 		AttributeSection section;
 		ArrayList attributes = new ArrayList();
 		getBlock = null; setBlock = null;
 		
 		while (la.kind == 16) {
 			AttributeSection(
-#line  1306 &quot;cs.ATG&quot; 
+#line  1334 &quot;cs.ATG&quot; 
 out section);
 
-#line  1306 &quot;cs.ATG&quot; 
+#line  1334 &quot;cs.ATG&quot; 
 			attributes.Add(section); 
 		}
 		if (
-#line  1308 &quot;cs.ATG&quot; 
+#line  1336 &quot;cs.ATG&quot; 
 IdentIsGet()) {
 			Expect(1);
 
-#line  1308 &quot;cs.ATG&quot; 
+#line  1336 &quot;cs.ATG&quot; 
 			getBlock = new PropertyGetRegion(null, attributes); 
 		} else if (
-#line  1309 &quot;cs.ATG&quot; 
+#line  1337 &quot;cs.ATG&quot; 
 IdentIsSet()) {
 			Expect(1);
 
-#line  1309 &quot;cs.ATG&quot; 
+#line  1337 &quot;cs.ATG&quot; 
 			setBlock = new PropertySetRegion(null, attributes); 
 		} else if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1310 &quot;cs.ATG&quot; 
+#line  1338 &quot;cs.ATG&quot; 
 			Error(&quot;set or get expected&quot;); 
 		} else SynErr(160);
 		Expect(10);
 
-#line  1312 &quot;cs.ATG&quot; 
+#line  1340 &quot;cs.ATG&quot; 
 		attributes = new ArrayList(); 
 		if (la.kind == 1 || la.kind == 16) {
 			while (la.kind == 16) {
 				AttributeSection(
-#line  1314 &quot;cs.ATG&quot; 
+#line  1342 &quot;cs.ATG&quot; 
 out section);
 
-#line  1314 &quot;cs.ATG&quot; 
+#line  1342 &quot;cs.ATG&quot; 
 				attributes.Add(section); 
 			}
 			if (
-#line  1316 &quot;cs.ATG&quot; 
+#line  1344 &quot;cs.ATG&quot; 
 IdentIsGet()) {
 				Expect(1);
 
-#line  1316 &quot;cs.ATG&quot; 
+#line  1344 &quot;cs.ATG&quot; 
 				if (getBlock != null) Error(&quot;get already declared&quot;);
 				else getBlock = new PropertyGetRegion(null, attributes);
 				
 			} else if (
-#line  1319 &quot;cs.ATG&quot; 
+#line  1347 &quot;cs.ATG&quot; 
 IdentIsSet()) {
 				Expect(1);
 
-#line  1319 &quot;cs.ATG&quot; 
+#line  1347 &quot;cs.ATG&quot; 
 				if (setBlock != null) Error(&quot;set already declared&quot;);
 				else setBlock = new PropertySetRegion(null, attributes);
 				
 			} else if (la.kind == 1) {
 				lexer.NextToken();
 
-#line  1322 &quot;cs.ATG&quot; 
+#line  1350 &quot;cs.ATG&quot; 
 				Error(&quot;set or get expected&quot;); 
 			} else SynErr(161);
 			Expect(10);
@@ -2795,187 +2864,187 @@
 	}
 
 	void GetAccessorDecl(
-#line  1261 &quot;cs.ATG&quot; 
+#line  1289 &quot;cs.ATG&quot; 
 out PropertyGetRegion getBlock, ArrayList attributes) {
 
-#line  1262 &quot;cs.ATG&quot; 
+#line  1290 &quot;cs.ATG&quot; 
 		Statement stmt = null; 
 		Expect(1);
 
-#line  1265 &quot;cs.ATG&quot; 
+#line  1293 &quot;cs.ATG&quot; 
 		if (t.val != &quot;get&quot;) Error(&quot;get expected&quot;); 
 		if (la.kind == 14) {
 			Block(
-#line  1266 &quot;cs.ATG&quot; 
+#line  1294 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 		} else SynErr(162);
 
-#line  1266 &quot;cs.ATG&quot; 
+#line  1294 &quot;cs.ATG&quot; 
 		getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes); 
 	}
 
 	void SetAccessorDecl(
-#line  1269 &quot;cs.ATG&quot; 
+#line  1297 &quot;cs.ATG&quot; 
 out PropertySetRegion setBlock, ArrayList attributes) {
 
-#line  1270 &quot;cs.ATG&quot; 
+#line  1298 &quot;cs.ATG&quot; 
 		Statement stmt = null; 
 		Expect(1);
 
-#line  1273 &quot;cs.ATG&quot; 
+#line  1301 &quot;cs.ATG&quot; 
 		if (t.val != &quot;set&quot;) Error(&quot;set expected&quot;); 
 		if (la.kind == 14) {
 			Block(
-#line  1274 &quot;cs.ATG&quot; 
+#line  1302 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 		} else SynErr(163);
 
-#line  1274 &quot;cs.ATG&quot; 
+#line  1302 &quot;cs.ATG&quot; 
 		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes); 
 	}
 
 	void AddAccessorDecl(
-#line  1348 &quot;cs.ATG&quot; 
+#line  1376 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1349 &quot;cs.ATG&quot; 
+#line  1377 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expect(1);
 
-#line  1352 &quot;cs.ATG&quot; 
+#line  1380 &quot;cs.ATG&quot; 
 		if (t.val != &quot;add&quot;) Error(&quot;add expected&quot;); 
 		Block(
-#line  1353 &quot;cs.ATG&quot; 
+#line  1381 &quot;cs.ATG&quot; 
 out stmt);
 	}
 
 	void RemoveAccessorDecl(
-#line  1356 &quot;cs.ATG&quot; 
+#line  1384 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1357 &quot;cs.ATG&quot; 
+#line  1385 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expect(1);
 
-#line  1360 &quot;cs.ATG&quot; 
+#line  1388 &quot;cs.ATG&quot; 
 		if (t.val != &quot;remove&quot;) Error(&quot;remove expected&quot;); 
 		Block(
-#line  1361 &quot;cs.ATG&quot; 
+#line  1389 &quot;cs.ATG&quot; 
 out stmt);
 	}
 
 	void VariableInitializer(
-#line  1377 &quot;cs.ATG&quot; 
+#line  1405 &quot;cs.ATG&quot; 
 out Expression initializerExpression) {
 
-#line  1378 &quot;cs.ATG&quot; 
+#line  1406 &quot;cs.ATG&quot; 
 		TypeReference type = null; Expression expr = null; initializerExpression = null; 
 		if (StartOf(4)) {
 			Expr(
-#line  1380 &quot;cs.ATG&quot; 
+#line  1408 &quot;cs.ATG&quot; 
 out initializerExpression);
 		} else if (la.kind == 14) {
 			ArrayInitializer(
-#line  1381 &quot;cs.ATG&quot; 
+#line  1409 &quot;cs.ATG&quot; 
 out initializerExpression);
 		} else if (la.kind == 105) {
 			lexer.NextToken();
 			Type(
-#line  1382 &quot;cs.ATG&quot; 
+#line  1410 &quot;cs.ATG&quot; 
 out type);
 			Expect(16);
 			Expr(
-#line  1382 &quot;cs.ATG&quot; 
+#line  1410 &quot;cs.ATG&quot; 
 out expr);
 			Expect(17);
 
-#line  1382 &quot;cs.ATG&quot; 
+#line  1410 &quot;cs.ATG&quot; 
 			initializerExpression = new StackAllocExpression(type, expr); 
 		} else SynErr(164);
 	}
 
 	void Statement() {
 
-#line  1465 &quot;cs.ATG&quot; 
+#line  1493 &quot;cs.ATG&quot; 
 		TypeReference type;
 		Expression expr;
 		Statement stmt;
 		
 		if (
-#line  1471 &quot;cs.ATG&quot; 
+#line  1499 &quot;cs.ATG&quot; 
 IsLabel()) {
 			Expect(1);
 
-#line  1471 &quot;cs.ATG&quot; 
+#line  1499 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(new LabelStatement(t.val)); 
 			Expect(9);
 			Statement();
 		} else if (la.kind == 59) {
 			lexer.NextToken();
 			Type(
-#line  1474 &quot;cs.ATG&quot; 
+#line  1502 &quot;cs.ATG&quot; 
 out type);
 
-#line  1474 &quot;cs.ATG&quot; 
+#line  1502 &quot;cs.ATG&quot; 
 			LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifier.Const); string ident = null; var.StartLocation = t.Location; 
 			Expect(1);
 
-#line  1475 &quot;cs.ATG&quot; 
+#line  1503 &quot;cs.ATG&quot; 
 			ident = t.val; 
 			Expect(3);
 			Expr(
-#line  1476 &quot;cs.ATG&quot; 
+#line  1504 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1476 &quot;cs.ATG&quot; 
+#line  1504 &quot;cs.ATG&quot; 
 			var.Variables.Add(new VariableDeclaration(ident, expr)); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1477 &quot;cs.ATG&quot; 
+#line  1505 &quot;cs.ATG&quot; 
 				ident = t.val; 
 				Expect(3);
 				Expr(
-#line  1477 &quot;cs.ATG&quot; 
+#line  1505 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1477 &quot;cs.ATG&quot; 
+#line  1505 &quot;cs.ATG&quot; 
 				var.Variables.Add(new VariableDeclaration(ident, expr)); 
 			}
 			Expect(10);
 
-#line  1478 &quot;cs.ATG&quot; 
+#line  1506 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(var); 
 		} else if (
-#line  1480 &quot;cs.ATG&quot; 
+#line  1508 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1480 &quot;cs.ATG&quot; 
+#line  1508 &quot;cs.ATG&quot; 
 out stmt);
 			Expect(10);
 
-#line  1480 &quot;cs.ATG&quot; 
+#line  1508 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(stmt); 
 		} else if (StartOf(22)) {
 			EmbeddedStatement(
-#line  1481 &quot;cs.ATG&quot; 
+#line  1509 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1481 &quot;cs.ATG&quot; 
+#line  1509 &quot;cs.ATG&quot; 
 			compilationUnit.AddChild(stmt); 
 		} else SynErr(165);
 	}
 
 	void Argument(
-#line  1397 &quot;cs.ATG&quot; 
+#line  1425 &quot;cs.ATG&quot; 
 out Expression argumentexpr) {
 
-#line  1399 &quot;cs.ATG&quot; 
+#line  1427 &quot;cs.ATG&quot; 
 		Expression expr;
 		FieldDirection fd = FieldDirection.None;
 		
@@ -2983,48 +3052,48 @@
 			if (la.kind == 99) {
 				lexer.NextToken();
 
-#line  1404 &quot;cs.ATG&quot; 
+#line  1432 &quot;cs.ATG&quot; 
 				fd = FieldDirection.Ref; 
 			} else {
 				lexer.NextToken();
 
-#line  1405 &quot;cs.ATG&quot; 
+#line  1433 &quot;cs.ATG&quot; 
 				fd = FieldDirection.Out; 
 			}
 		}
 		Expr(
-#line  1407 &quot;cs.ATG&quot; 
+#line  1435 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1407 &quot;cs.ATG&quot; 
+#line  1435 &quot;cs.ATG&quot; 
 		argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; 
 	}
 
 	void ArrayInitializer(
-#line  1426 &quot;cs.ATG&quot; 
+#line  1454 &quot;cs.ATG&quot; 
 out Expression outExpr) {
 
-#line  1428 &quot;cs.ATG&quot; 
+#line  1456 &quot;cs.ATG&quot; 
 		Expression expr = null;
 		ArrayInitializerExpression initializer = new ArrayInitializerExpression();
 		
 		Expect(14);
 		if (StartOf(23)) {
 			VariableInitializer(
-#line  1433 &quot;cs.ATG&quot; 
+#line  1461 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1433 &quot;cs.ATG&quot; 
+#line  1461 &quot;cs.ATG&quot; 
 			initializer.CreateExpressions.Add(expr); 
 			while (
-#line  1433 &quot;cs.ATG&quot; 
+#line  1461 &quot;cs.ATG&quot; 
 NotFinalComma()) {
 				Expect(12);
 				VariableInitializer(
-#line  1433 &quot;cs.ATG&quot; 
+#line  1461 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1433 &quot;cs.ATG&quot; 
+#line  1461 &quot;cs.ATG&quot; 
 				initializer.CreateExpressions.Add(expr); 
 			}
 			if (la.kind == 12) {
@@ -3033,91 +3102,91 @@
 		}
 		Expect(15);
 
-#line  1434 &quot;cs.ATG&quot; 
+#line  1462 &quot;cs.ATG&quot; 
 		outExpr = initializer; 
 	}
 
 	void AssignmentOperator(
-#line  1410 &quot;cs.ATG&quot; 
+#line  1438 &quot;cs.ATG&quot; 
 out AssignmentOperatorType op) {
 
-#line  1411 &quot;cs.ATG&quot; 
+#line  1439 &quot;cs.ATG&quot; 
 		op = AssignmentOperatorType.None; 
 		switch (la.kind) {
 		case 3: {
 			lexer.NextToken();
 
-#line  1413 &quot;cs.ATG&quot; 
+#line  1441 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Assign; 
 			break;
 		}
 		case 37: {
 			lexer.NextToken();
 
-#line  1414 &quot;cs.ATG&quot; 
+#line  1442 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Add; 
 			break;
 		}
 		case 38: {
 			lexer.NextToken();
 
-#line  1415 &quot;cs.ATG&quot; 
+#line  1443 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Subtract; 
 			break;
 		}
 		case 39: {
 			lexer.NextToken();
 
-#line  1416 &quot;cs.ATG&quot; 
+#line  1444 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Multiply; 
 			break;
 		}
 		case 40: {
 			lexer.NextToken();
 
-#line  1417 &quot;cs.ATG&quot; 
+#line  1445 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Divide; 
 			break;
 		}
 		case 41: {
 			lexer.NextToken();
 
-#line  1418 &quot;cs.ATG&quot; 
+#line  1446 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.Modulus; 
 			break;
 		}
 		case 42: {
 			lexer.NextToken();
 
-#line  1419 &quot;cs.ATG&quot; 
+#line  1447 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.BitwiseAnd; 
 			break;
 		}
 		case 43: {
 			lexer.NextToken();
 
-#line  1420 &quot;cs.ATG&quot; 
+#line  1448 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.BitwiseOr; 
 			break;
 		}
 		case 44: {
 			lexer.NextToken();
 
-#line  1421 &quot;cs.ATG&quot; 
+#line  1449 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ExclusiveOr; 
 			break;
 		}
 		case 45: {
 			lexer.NextToken();
 
-#line  1422 &quot;cs.ATG&quot; 
+#line  1450 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ShiftLeft; 
 			break;
 		}
 		case 46: {
 			lexer.NextToken();
 
-#line  1423 &quot;cs.ATG&quot; 
+#line  1451 &quot;cs.ATG&quot; 
 			op = AssignmentOperatorType.ShiftRight; 
 			break;
 		}
@@ -3126,83 +3195,83 @@
 	}
 
 	void LocalVariableDecl(
-#line  1437 &quot;cs.ATG&quot; 
+#line  1465 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1439 &quot;cs.ATG&quot; 
+#line  1467 &quot;cs.ATG&quot; 
 		TypeReference type;
 		VariableDeclaration      var = null;
 		LocalVariableDeclaration localVariableDeclaration; 
 		
 		Type(
-#line  1444 &quot;cs.ATG&quot; 
+#line  1472 &quot;cs.ATG&quot; 
 out type);
 
-#line  1444 &quot;cs.ATG&quot; 
+#line  1472 &quot;cs.ATG&quot; 
 		localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; 
 		LocalVariableDeclarator(
-#line  1445 &quot;cs.ATG&quot; 
+#line  1473 &quot;cs.ATG&quot; 
 out var);
 
-#line  1445 &quot;cs.ATG&quot; 
+#line  1473 &quot;cs.ATG&quot; 
 		localVariableDeclaration.Variables.Add(var); 
 		while (la.kind == 12) {
 			lexer.NextToken();
 			LocalVariableDeclarator(
-#line  1446 &quot;cs.ATG&quot; 
+#line  1474 &quot;cs.ATG&quot; 
 out var);
 
-#line  1446 &quot;cs.ATG&quot; 
+#line  1474 &quot;cs.ATG&quot; 
 			localVariableDeclaration.Variables.Add(var); 
 		}
 
-#line  1447 &quot;cs.ATG&quot; 
+#line  1475 &quot;cs.ATG&quot; 
 		stmt = localVariableDeclaration; 
 	}
 
 	void LocalVariableDeclarator(
-#line  1450 &quot;cs.ATG&quot; 
+#line  1478 &quot;cs.ATG&quot; 
 out VariableDeclaration var) {
 
-#line  1451 &quot;cs.ATG&quot; 
+#line  1479 &quot;cs.ATG&quot; 
 		Expression expr = null; 
 		Expect(1);
 
-#line  1453 &quot;cs.ATG&quot; 
+#line  1481 &quot;cs.ATG&quot; 
 		var = new VariableDeclaration(t.val); 
 		if (la.kind == 3) {
 			lexer.NextToken();
 			LocalVariableInitializer(
-#line  1453 &quot;cs.ATG&quot; 
+#line  1481 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1453 &quot;cs.ATG&quot; 
+#line  1481 &quot;cs.ATG&quot; 
 			var.Initializer = expr; 
 		}
 	}
 
 	void LocalVariableInitializer(
-#line  1456 &quot;cs.ATG&quot; 
+#line  1484 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1457 &quot;cs.ATG&quot; 
+#line  1485 &quot;cs.ATG&quot; 
 		expr = null; 
 		if (StartOf(4)) {
 			Expr(
-#line  1459 &quot;cs.ATG&quot; 
+#line  1487 &quot;cs.ATG&quot; 
 out expr);
 		} else if (la.kind == 14) {
 			ArrayInitializer(
-#line  1460 &quot;cs.ATG&quot; 
+#line  1488 &quot;cs.ATG&quot; 
 out expr);
 		} else SynErr(167);
 	}
 
 	void EmbeddedStatement(
-#line  1487 &quot;cs.ATG&quot; 
+#line  1515 &quot;cs.ATG&quot; 
 out Statement statement) {
 
-#line  1489 &quot;cs.ATG&quot; 
+#line  1517 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		Expression expr = null;
 		Statement embeddedStatement = null;
@@ -3210,523 +3279,525 @@
 		
 		if (la.kind == 14) {
 			Block(
-#line  1495 &quot;cs.ATG&quot; 
+#line  1523 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 10) {
 			lexer.NextToken();
 
-#line  1497 &quot;cs.ATG&quot; 
+#line  1525 &quot;cs.ATG&quot; 
 			statement = new EmptyStatement(); 
 		} else if (
-#line  1499 &quot;cs.ATG&quot; 
+#line  1527 &quot;cs.ATG&quot; 
 UnCheckedAndLBrace()) {
 
-#line  1499 &quot;cs.ATG&quot; 
+#line  1527 &quot;cs.ATG&quot; 
 			Statement block; bool isChecked = true; 
 			if (la.kind == 57) {
 				lexer.NextToken();
 			} else if (la.kind == 117) {
 				lexer.NextToken();
 
-#line  1500 &quot;cs.ATG&quot; 
+#line  1528 &quot;cs.ATG&quot; 
 				isChecked = false;
 			} else SynErr(168);
 			Block(
-#line  1501 &quot;cs.ATG&quot; 
+#line  1529 &quot;cs.ATG&quot; 
 out block);
 
-#line  1501 &quot;cs.ATG&quot; 
+#line  1529 &quot;cs.ATG&quot; 
 			statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); 
 		} else if (StartOf(4)) {
 			StatementExpr(
-#line  1503 &quot;cs.ATG&quot; 
+#line  1531 &quot;cs.ATG&quot; 
 out statement);
 			Expect(10);
 		} else if (la.kind == 78) {
 			lexer.NextToken();
 
-#line  1505 &quot;cs.ATG&quot; 
+#line  1533 &quot;cs.ATG&quot; 
 			Statement elseStatement = null; 
 			Expect(18);
 			Expr(
-#line  1506 &quot;cs.ATG&quot; 
+#line  1534 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1507 &quot;cs.ATG&quot; 
+#line  1535 &quot;cs.ATG&quot; 
 out embeddedStatement);
 			if (la.kind == 66) {
 				lexer.NextToken();
 				EmbeddedStatement(
-#line  1508 &quot;cs.ATG&quot; 
+#line  1536 &quot;cs.ATG&quot; 
 out elseStatement);
 			}
 
-#line  1509 &quot;cs.ATG&quot; 
+#line  1537 &quot;cs.ATG&quot; 
 			statement = elseStatement != null ? (Statement)new IfElseStatement(expr, embeddedStatement, elseStatement) :  (Statement)new IfStatement(expr, embeddedStatement); 
 		} else if (la.kind == 109) {
 			lexer.NextToken();
 
-#line  1510 &quot;cs.ATG&quot; 
+#line  1538 &quot;cs.ATG&quot; 
 			ArrayList switchSections = new ArrayList(); 
 			Expect(18);
 			Expr(
-#line  1511 &quot;cs.ATG&quot; 
+#line  1539 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			Expect(14);
 			while (la.kind == 54 || la.kind == 62) {
 				SwitchSection(
-#line  1512 &quot;cs.ATG&quot; 
+#line  1540 &quot;cs.ATG&quot; 
 out statement);
 
-#line  1512 &quot;cs.ATG&quot; 
+#line  1540 &quot;cs.ATG&quot; 
 				switchSections.Add(statement); 
 			}
 			Expect(15);
 
-#line  1513 &quot;cs.ATG&quot; 
+#line  1541 &quot;cs.ATG&quot; 
 			statement = new SwitchStatement(expr, switchSections); 
 		} else if (la.kind == 124) {
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1515 &quot;cs.ATG&quot; 
+#line  1543 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1516 &quot;cs.ATG&quot; 
+#line  1544 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1516 &quot;cs.ATG&quot; 
+#line  1544 &quot;cs.ATG&quot; 
 			statement = new WhileStatement(expr, embeddedStatement); 
 		} else if (la.kind == 64) {
 			lexer.NextToken();
 			EmbeddedStatement(
-#line  1517 &quot;cs.ATG&quot; 
+#line  1545 &quot;cs.ATG&quot; 
 out embeddedStatement);
 			Expect(124);
 			Expect(18);
 			Expr(
-#line  1518 &quot;cs.ATG&quot; 
+#line  1546 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			Expect(10);
 
-#line  1518 &quot;cs.ATG&quot; 
+#line  1546 &quot;cs.ATG&quot; 
 			statement = new DoWhileStatement(expr, embeddedStatement); 
 		} else if (la.kind == 75) {
 			lexer.NextToken();
 
-#line  1519 &quot;cs.ATG&quot; 
+#line  1547 &quot;cs.ATG&quot; 
 			ArrayList initializer = null, iterator = null; 
 			Expect(18);
 			if (StartOf(4)) {
 				ForInitializer(
-#line  1520 &quot;cs.ATG&quot; 
+#line  1548 &quot;cs.ATG&quot; 
 out initializer);
 			}
 			Expect(10);
 			if (StartOf(4)) {
 				Expr(
-#line  1521 &quot;cs.ATG&quot; 
+#line  1549 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 			if (StartOf(4)) {
 				ForIterator(
-#line  1522 &quot;cs.ATG&quot; 
+#line  1550 &quot;cs.ATG&quot; 
 out iterator);
 			}
 			Expect(19);
 			EmbeddedStatement(
-#line  1523 &quot;cs.ATG&quot; 
+#line  1551 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1523 &quot;cs.ATG&quot; 
+#line  1551 &quot;cs.ATG&quot; 
 			statement = new ForStatement(initializer, expr, iterator, embeddedStatement); 
 		} else if (la.kind == 76) {
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1524 &quot;cs.ATG&quot; 
+#line  1552 &quot;cs.ATG&quot; 
 out type);
 			Expect(1);
 
-#line  1524 &quot;cs.ATG&quot; 
-			string varName = t.val; 
+#line  1552 &quot;cs.ATG&quot; 
+			string varName = t.val; Point start = t.Location;
 			Expect(80);
 			Expr(
-#line  1525 &quot;cs.ATG&quot; 
+#line  1553 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1526 &quot;cs.ATG&quot; 
+#line  1554 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1526 &quot;cs.ATG&quot; 
+#line  1554 &quot;cs.ATG&quot; 
 			statement = new ForeachStatement(type, varName , expr, embeddedStatement); 
+			statement.EndLocation = t.EndLocation;
+			
 		} else if (la.kind == 52) {
 			lexer.NextToken();
 			Expect(10);
 
-#line  1528 &quot;cs.ATG&quot; 
+#line  1558 &quot;cs.ATG&quot; 
 			statement = new BreakStatement(); 
 		} else if (la.kind == 60) {
 			lexer.NextToken();
 			Expect(10);
 
-#line  1529 &quot;cs.ATG&quot; 
+#line  1559 &quot;cs.ATG&quot; 
 			statement = new ContinueStatement(); 
 		} else if (la.kind == 77) {
 			GotoStatement(
-#line  1530 &quot;cs.ATG&quot; 
+#line  1560 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 100) {
 			lexer.NextToken();
 			if (StartOf(4)) {
 				Expr(
-#line  1531 &quot;cs.ATG&quot; 
+#line  1561 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 
-#line  1531 &quot;cs.ATG&quot; 
+#line  1561 &quot;cs.ATG&quot; 
 			statement = new ReturnStatement(expr); 
 		} else if (la.kind == 111) {
 			lexer.NextToken();
 			if (StartOf(4)) {
 				Expr(
-#line  1532 &quot;cs.ATG&quot; 
+#line  1562 &quot;cs.ATG&quot; 
 out expr);
 			}
 			Expect(10);
 
-#line  1532 &quot;cs.ATG&quot; 
+#line  1562 &quot;cs.ATG&quot; 
 			statement = new ThrowStatement(expr); 
 		} else if (la.kind == 113) {
 			TryStatement(
-#line  1534 &quot;cs.ATG&quot; 
+#line  1564 &quot;cs.ATG&quot; 
 out statement);
 		} else if (la.kind == 85) {
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1536 &quot;cs.ATG&quot; 
+#line  1566 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 			EmbeddedStatement(
-#line  1537 &quot;cs.ATG&quot; 
+#line  1567 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1537 &quot;cs.ATG&quot; 
+#line  1567 &quot;cs.ATG&quot; 
 			statement = new LockStatement(expr, embeddedStatement); 
 		} else if (la.kind == 120) {
 
-#line  1539 &quot;cs.ATG&quot; 
+#line  1569 &quot;cs.ATG&quot; 
 			Statement resourceAcquisitionStmt = null; 
 			lexer.NextToken();
 			Expect(18);
 			ResourceAcquisition(
-#line  1541 &quot;cs.ATG&quot; 
+#line  1571 &quot;cs.ATG&quot; 
 out resourceAcquisitionStmt);
 			Expect(19);
 			EmbeddedStatement(
-#line  1542 &quot;cs.ATG&quot; 
+#line  1572 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1542 &quot;cs.ATG&quot; 
+#line  1572 &quot;cs.ATG&quot; 
 			statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); 
 		} else if (la.kind == 118) {
 			lexer.NextToken();
 			Block(
-#line  1544 &quot;cs.ATG&quot; 
+#line  1574 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1544 &quot;cs.ATG&quot; 
+#line  1574 &quot;cs.ATG&quot; 
 			statement = new UnsafeStatement(embeddedStatement); 
 		} else if (la.kind == 73) {
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1547 &quot;cs.ATG&quot; 
+#line  1577 &quot;cs.ATG&quot; 
 out type);
 
-#line  1547 &quot;cs.ATG&quot; 
+#line  1577 &quot;cs.ATG&quot; 
 			if (type.PointerNestingLevel == 0) Error(&quot;can only fix pointer types&quot;);
 			FixedStatement fxStmt = new FixedStatement(type);
 			string identifier = null;
 			
 			Expect(1);
 
-#line  1551 &quot;cs.ATG&quot; 
+#line  1581 &quot;cs.ATG&quot; 
 			identifier = t.val; 
 			Expect(3);
 			Expr(
-#line  1552 &quot;cs.ATG&quot; 
+#line  1582 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1552 &quot;cs.ATG&quot; 
+#line  1582 &quot;cs.ATG&quot; 
 			fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); 
 			while (la.kind == 12) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1554 &quot;cs.ATG&quot; 
+#line  1584 &quot;cs.ATG&quot; 
 				identifier = t.val; 
 				Expect(3);
 				Expr(
-#line  1555 &quot;cs.ATG&quot; 
+#line  1585 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1555 &quot;cs.ATG&quot; 
+#line  1585 &quot;cs.ATG&quot; 
 				fxStmt.PointerDeclarators.Add(new VariableDeclaration(identifier, expr)); 
 			}
 			Expect(19);
 			EmbeddedStatement(
-#line  1557 &quot;cs.ATG&quot; 
+#line  1587 &quot;cs.ATG&quot; 
 out embeddedStatement);
 
-#line  1557 &quot;cs.ATG&quot; 
+#line  1587 &quot;cs.ATG&quot; 
 			fxStmt.EmbeddedStatement = embeddedStatement; statement = fxStmt;
 		} else SynErr(169);
 	}
 
 	void StatementExpr(
-#line  1665 &quot;cs.ATG&quot; 
+#line  1695 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1670 &quot;cs.ATG&quot; 
+#line  1700 &quot;cs.ATG&quot; 
 		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
 		                       la.kind == Tokens.Not   || la.kind == Tokens.BitwiseComplement ||
 		                       la.kind == Tokens.Times || la.kind == Tokens.BitwiseAnd   || IsTypeCast();
 		Expression expr = null;
 		
 		UnaryExpr(
-#line  1676 &quot;cs.ATG&quot; 
+#line  1706 &quot;cs.ATG&quot; 
 out expr);
 		if (StartOf(6)) {
 
-#line  1679 &quot;cs.ATG&quot; 
+#line  1709 &quot;cs.ATG&quot; 
 			AssignmentOperatorType op; Expression val; 
 			AssignmentOperator(
-#line  1679 &quot;cs.ATG&quot; 
+#line  1709 &quot;cs.ATG&quot; 
 out op);
 			Expr(
-#line  1679 &quot;cs.ATG&quot; 
+#line  1709 &quot;cs.ATG&quot; 
 out val);
 
-#line  1679 &quot;cs.ATG&quot; 
+#line  1709 &quot;cs.ATG&quot; 
 			expr = new AssignmentExpression(expr, op, val); 
 		} else if (la.kind == 10 || la.kind == 12 || la.kind == 19) {
 
-#line  1680 &quot;cs.ATG&quot; 
+#line  1710 &quot;cs.ATG&quot; 
 			if (mustBeAssignment) Error(&quot;error in assignment.&quot;); 
 		} else SynErr(170);
 
-#line  1681 &quot;cs.ATG&quot; 
+#line  1711 &quot;cs.ATG&quot; 
 		stmt = new StatementExpression(expr); 
 	}
 
 	void SwitchSection(
-#line  1579 &quot;cs.ATG&quot; 
+#line  1609 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1581 &quot;cs.ATG&quot; 
+#line  1611 &quot;cs.ATG&quot; 
 		SwitchSection switchSection = new SwitchSection();
 		Expression expr;
 		
 		SwitchLabel(
-#line  1585 &quot;cs.ATG&quot; 
+#line  1615 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1585 &quot;cs.ATG&quot; 
+#line  1615 &quot;cs.ATG&quot; 
 		switchSection.SwitchLabels.Add(expr); 
 		while (la.kind == 54 || la.kind == 62) {
 			SwitchLabel(
-#line  1585 &quot;cs.ATG&quot; 
+#line  1615 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1585 &quot;cs.ATG&quot; 
+#line  1615 &quot;cs.ATG&quot; 
 			switchSection.SwitchLabels.Add(expr); 
 		}
 
-#line  1586 &quot;cs.ATG&quot; 
+#line  1616 &quot;cs.ATG&quot; 
 		compilationUnit.BlockStart(switchSection); 
 		Statement();
 		while (StartOf(20)) {
 			Statement();
 		}
 
-#line  1589 &quot;cs.ATG&quot; 
+#line  1619 &quot;cs.ATG&quot; 
 		compilationUnit.BlockEnd();
 		stmt = switchSection;
 		
 	}
 
 	void ForInitializer(
-#line  1560 &quot;cs.ATG&quot; 
+#line  1590 &quot;cs.ATG&quot; 
 out ArrayList initializer) {
 
-#line  1562 &quot;cs.ATG&quot; 
+#line  1592 &quot;cs.ATG&quot; 
 		Statement stmt; 
 		initializer = new ArrayList();
 		
 		if (
-#line  1566 &quot;cs.ATG&quot; 
+#line  1596 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1566 &quot;cs.ATG&quot; 
+#line  1596 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1566 &quot;cs.ATG&quot; 
+#line  1596 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
 		} else if (StartOf(4)) {
 			StatementExpr(
-#line  1567 &quot;cs.ATG&quot; 
+#line  1597 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1567 &quot;cs.ATG&quot; 
+#line  1597 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
 			while (la.kind == 12) {
 				lexer.NextToken();
 				StatementExpr(
-#line  1567 &quot;cs.ATG&quot; 
+#line  1597 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1567 &quot;cs.ATG&quot; 
+#line  1597 &quot;cs.ATG&quot; 
 				initializer.Add(stmt);
 			}
 
-#line  1567 &quot;cs.ATG&quot; 
+#line  1597 &quot;cs.ATG&quot; 
 			initializer.Add(stmt);
 		} else SynErr(171);
 	}
 
 	void ForIterator(
-#line  1570 &quot;cs.ATG&quot; 
+#line  1600 &quot;cs.ATG&quot; 
 out ArrayList iterator) {
 
-#line  1572 &quot;cs.ATG&quot; 
+#line  1602 &quot;cs.ATG&quot; 
 		Statement stmt; 
 		iterator = new ArrayList();
 		
 		StatementExpr(
-#line  1576 &quot;cs.ATG&quot; 
+#line  1606 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1576 &quot;cs.ATG&quot; 
+#line  1606 &quot;cs.ATG&quot; 
 		iterator.Add(stmt);
 		while (la.kind == 12) {
 			lexer.NextToken();
 			StatementExpr(
-#line  1576 &quot;cs.ATG&quot; 
+#line  1606 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1576 &quot;cs.ATG&quot; 
+#line  1606 &quot;cs.ATG&quot; 
 			iterator.Add(stmt); 
 		}
 	}
 
 	void GotoStatement(
-#line  1638 &quot;cs.ATG&quot; 
+#line  1668 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1639 &quot;cs.ATG&quot; 
+#line  1669 &quot;cs.ATG&quot; 
 		Expression expr; stmt = null; 
 		Expect(77);
 		if (la.kind == 1) {
 			lexer.NextToken();
 
-#line  1643 &quot;cs.ATG&quot; 
+#line  1673 &quot;cs.ATG&quot; 
 			stmt = new GotoStatement(t.val); 
 			Expect(10);
 		} else if (la.kind == 54) {
 			lexer.NextToken();
 			Expr(
-#line  1644 &quot;cs.ATG&quot; 
+#line  1674 &quot;cs.ATG&quot; 
 out expr);
 			Expect(10);
 
-#line  1644 &quot;cs.ATG&quot; 
+#line  1674 &quot;cs.ATG&quot; 
 			stmt = new GotoCaseStatement(expr); 
 		} else if (la.kind == 62) {
 			lexer.NextToken();
 			Expect(10);
 
-#line  1645 &quot;cs.ATG&quot; 
+#line  1675 &quot;cs.ATG&quot; 
 			stmt = new GotoCaseStatement(null); 
 		} else SynErr(172);
 	}
 
 	void TryStatement(
-#line  1601 &quot;cs.ATG&quot; 
+#line  1631 &quot;cs.ATG&quot; 
 out Statement tryStatement) {
 
-#line  1603 &quot;cs.ATG&quot; 
+#line  1633 &quot;cs.ATG&quot; 
 		Statement blockStmt = null, finallyStmt = null;
 		ArrayList catchClauses = null;
 		
 		Expect(113);
 		Block(
-#line  1607 &quot;cs.ATG&quot; 
+#line  1637 &quot;cs.ATG&quot; 
 out blockStmt);
 		if (la.kind == 55) {
 			CatchClauses(
-#line  1609 &quot;cs.ATG&quot; 
+#line  1639 &quot;cs.ATG&quot; 
 out catchClauses);
 			if (la.kind == 72) {
 				lexer.NextToken();
 				Block(
-#line  1609 &quot;cs.ATG&quot; 
+#line  1639 &quot;cs.ATG&quot; 
 out finallyStmt);
 			}
 		} else if (la.kind == 72) {
 			lexer.NextToken();
 			Block(
-#line  1610 &quot;cs.ATG&quot; 
+#line  1640 &quot;cs.ATG&quot; 
 out finallyStmt);
 		} else SynErr(173);
 
-#line  1613 &quot;cs.ATG&quot; 
+#line  1643 &quot;cs.ATG&quot; 
 		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
 			
 	}
 
 	void ResourceAcquisition(
-#line  1649 &quot;cs.ATG&quot; 
+#line  1679 &quot;cs.ATG&quot; 
 out Statement stmt) {
 
-#line  1651 &quot;cs.ATG&quot; 
+#line  1681 &quot;cs.ATG&quot; 
 		stmt = null;
 		Expression expr;
 		
 		if (
-#line  1656 &quot;cs.ATG&quot; 
+#line  1686 &quot;cs.ATG&quot; 
 IsLocalVarDecl()) {
 			LocalVariableDecl(
-#line  1656 &quot;cs.ATG&quot; 
+#line  1686 &quot;cs.ATG&quot; 
 out stmt);
 		} else if (StartOf(4)) {
 			Expr(
-#line  1657 &quot;cs.ATG&quot; 
+#line  1687 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1661 &quot;cs.ATG&quot; 
+#line  1691 &quot;cs.ATG&quot; 
 			stmt = new StatementExpression(expr); 
 		} else SynErr(174);
 	}
 
 	void SwitchLabel(
-#line  1594 &quot;cs.ATG&quot; 
+#line  1624 &quot;cs.ATG&quot; 
 out Expression expr) {
 
-#line  1595 &quot;cs.ATG&quot; 
+#line  1625 &quot;cs.ATG&quot; 
 		expr = null; 
 		if (la.kind == 54) {
 			lexer.NextToken();
 			Expr(
-#line  1597 &quot;cs.ATG&quot; 
+#line  1627 &quot;cs.ATG&quot; 
 out expr);
 			Expect(9);
 		} else if (la.kind == 62) {
@@ -3736,192 +3807,197 @@
 	}
 
 	void CatchClauses(
-#line  1618 &quot;cs.ATG&quot; 
+#line  1648 &quot;cs.ATG&quot; 
 out ArrayList catchClauses) {
 
-#line  1620 &quot;cs.ATG&quot; 
+#line  1650 &quot;cs.ATG&quot; 
 		catchClauses = new ArrayList();
 		
 		Expect(55);
 
-#line  1623 &quot;cs.ATG&quot; 
+#line  1653 &quot;cs.ATG&quot; 
 		string name;
 		string identifier;
 		Statement stmt; 
 		
 		if (la.kind == 14) {
 			Block(
-#line  1629 &quot;cs.ATG&quot; 
+#line  1659 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1629 &quot;cs.ATG&quot; 
+#line  1659 &quot;cs.ATG&quot; 
 			catchClauses.Add(new CatchClause(stmt)); 
 		} else if (la.kind == 18) {
 			lexer.NextToken();
 			ClassType(
-#line  1631 &quot;cs.ATG&quot; 
+#line  1661 &quot;cs.ATG&quot; 
 out name);
 
-#line  1631 &quot;cs.ATG&quot; 
+#line  1661 &quot;cs.ATG&quot; 
 			identifier = null; 
 			if (la.kind == 1) {
 				lexer.NextToken();
 
-#line  1631 &quot;cs.ATG&quot; 
+#line  1661 &quot;cs.ATG&quot; 
 				identifier = t.val; 
 			}
 			Expect(19);
 			Block(
-#line  1631 &quot;cs.ATG&quot; 
+#line  1661 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1631 &quot;cs.ATG&quot; 
+#line  1661 &quot;cs.ATG&quot; 
 			catchClauses.Add(new CatchClause(name, identifier, stmt)); 
 			while (
-#line  1632 &quot;cs.ATG&quot; 
+#line  1662 &quot;cs.ATG&quot; 
 IsTypedCatch()) {
 				Expect(55);
 				Expect(18);
 				ClassType(
-#line  1632 &quot;cs.ATG&quot; 
+#line  1662 &quot;cs.ATG&quot; 
 out name);
 
-#line  1632 &quot;cs.ATG&quot; 
+#line  1662 &quot;cs.ATG&quot; 
 				identifier = null; 
 				if (la.kind == 1) {
 					lexer.NextToken();
 
-#line  1632 &quot;cs.ATG&quot; 
+#line  1662 &quot;cs.ATG&quot; 
 					identifier = t.val; 
 				}
 				Expect(19);
 				Block(
-#line  1632 &quot;cs.ATG&quot; 
+#line  1662 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1632 &quot;cs.ATG&quot; 
+#line  1662 &quot;cs.ATG&quot; 
 				catchClauses.Add(new CatchClause(name, identifier, stmt)); 
 			}
 			if (la.kind == 55) {
 				lexer.NextToken();
 				Block(
-#line  1634 &quot;cs.ATG&quot; 
+#line  1664 &quot;cs.ATG&quot; 
 out stmt);
 
-#line  1634 &quot;cs.ATG&quot; 
+#line  1664 &quot;cs.ATG&quot; 
 				catchClauses.Add(new CatchClause(stmt)); 
 			}
 		} else SynErr(176);
 	}
 
 	void UnaryExpr(
-#line  1697 &quot;cs.ATG&quot; 
+#line  1727 &quot;cs.ATG&quot; 
 out Expression uExpr) {
 
-#line  1699 &quot;cs.ATG&quot; 
+#line  1729 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		Expression expr;
-		UnaryOperatorType uop = UnaryOperatorType.None;
-		bool isUOp = false;
-		bool isCast = false;
+		ArrayList  expressions = new ArrayList();
+		uExpr = null;
 		
 		while (StartOf(24) || 
-#line  1722 &quot;cs.ATG&quot; 
+#line  1751 &quot;cs.ATG&quot; 
 IsTypeCast()) {
 			if (la.kind == 4) {
 				lexer.NextToken();
 
-#line  1707 &quot;cs.ATG&quot; 
-				uop = UnaryOperatorType.Plus; isUOp = true; 
+#line  1736 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); 
 			} else if (la.kind == 5) {
 				lexer.NextToken();
 
-#line  1708 &quot;cs.ATG&quot; 
-				uop = UnaryOperatorType.Minus; isUOp = true; 
+#line  1737 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); 
 			} else if (la.kind == 22) {
 				lexer.NextToken();
 
-#line  1709 &quot;cs.ATG&quot; 
-				uop = UnaryOperatorType.Not;  isUOp = true;
+#line  1738 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); 
 			} else if (la.kind == 25) {
 				lexer.NextToken();
 
-#line  1710 &quot;cs.ATG&quot; 
-				uop = UnaryOperatorType.BitNot; isUOp = true; 
+#line  1739 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); 
 			} else if (la.kind == 6) {
 				lexer.NextToken();
 
-#line  1711 &quot;cs.ATG&quot; 
-				uop = UnaryOperatorType.Star;  isUOp = true; 
+#line  1740 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); 
 			} else if (la.kind == 29) {
 				lexer.NextToken();
 
-#line  1712 &quot;cs.ATG&quot; 
-				uop = UnaryOperatorType.Increment; isUOp = true; 
+#line  1741 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); 
 			} else if (la.kind == 30) {
 				lexer.NextToken();
 
-#line  1713 &quot;cs.ATG&quot; 
-				uop = UnaryOperatorType.Decrement; isUOp = true; 
+#line  1742 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); 
 			} else if (la.kind == 26) {
 				lexer.NextToken();
 
-#line  1714 &quot;cs.ATG&quot; 
-				uop = UnaryOperatorType.BitWiseAnd; isUOp = true; 
+#line  1743 &quot;cs.ATG&quot; 
+				expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); 
 			} else {
 				Expect(18);
 				Type(
-#line  1722 &quot;cs.ATG&quot; 
+#line  1751 &quot;cs.ATG&quot; 
 out type);
 				Expect(19);
 
-#line  1722 &quot;cs.ATG&quot; 
-				isCast = true; 
+#line  1751 &quot;cs.ATG&quot; 
+				expressions.Add(new CastExpression(type)); 
 			}
 		}
 		PrimaryExpr(
-#line  1724 &quot;cs.ATG&quot; 
+#line  1754 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1724 &quot;cs.ATG&quot; 
-		if (isUOp) { 
-		   uExpr = new UnaryOperatorExpression(expr, uop);
-		} else if (isCast) {
-		    uExpr = new CastExpression(type, expr);
+#line  1754 &quot;cs.ATG&quot; 
+		for (int i = 0; i &lt; expressions.Count; ++i) {
+		Expression nextExpression = i + 1 &lt; expressions.Count ? (Expression)expressions[i + 1] : expr;
+		if (expressions[i] is CastExpression) {
+			((CastExpression)expressions[i]).Expression = nextExpression;
 		} else {
-		    uExpr = expr;
+			((UnaryOperatorExpression)expressions[i]).Expression = nextExpression;
 		}
+		}
+		if (expressions.Count &gt; 0) {
+			uExpr = (Expression)expressions[0];
+		} else {
+			uExpr = expr;
+		}
 		
 	}
 
 	void ConditionalOrExpr(
-#line  1820 &quot;cs.ATG&quot; 
+#line  1856 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1821 &quot;cs.ATG&quot; 
-		Expression expr; 
+#line  1857 &quot;cs.ATG&quot; 
+		Expression expr;   
 		ConditionalAndExpr(
-#line  1823 &quot;cs.ATG&quot; 
+#line  1859 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 24) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1823 &quot;cs.ATG&quot; 
+#line  1859 &quot;cs.ATG&quot; 
 out expr);
 			ConditionalAndExpr(
-#line  1823 &quot;cs.ATG&quot; 
+#line  1859 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1823 &quot;cs.ATG&quot; 
+#line  1859 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  
 		}
 	}
 
 	void PrimaryExpr(
-#line  1735 &quot;cs.ATG&quot; 
+#line  1771 &quot;cs.ATG&quot; 
 out Expression pexpr) {
 
-#line  1737 &quot;cs.ATG&quot; 
+#line  1773 &quot;cs.ATG&quot; 
 		TypeReference type = null;
 		bool isArrayCreation = false;
 		Expression expr;
@@ -3931,46 +4007,46 @@
 		case 112: {
 			lexer.NextToken();
 
-#line  1744 &quot;cs.ATG&quot; 
+#line  1780 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(true, &quot;true&quot;);  
 			break;
 		}
 		case 71: {
 			lexer.NextToken();
 
-#line  1745 &quot;cs.ATG&quot; 
+#line  1781 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(false, &quot;false&quot;); 
 			break;
 		}
 		case 89: {
 			lexer.NextToken();
 
-#line  1746 &quot;cs.ATG&quot; 
+#line  1782 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(null, &quot;null&quot;);  
 			break;
 		}
 		case 2: {
 			lexer.NextToken();
 
-#line  1747 &quot;cs.ATG&quot; 
+#line  1783 &quot;cs.ATG&quot; 
 			pexpr = new PrimitiveExpression(t.literalValue, t.val);  
 			break;
 		}
 		case 1: {
 			lexer.NextToken();
 
-#line  1749 &quot;cs.ATG&quot; 
+#line  1785 &quot;cs.ATG&quot; 
 			pexpr = new IdentifierExpression(t.val); 
 			break;
 		}
 		case 18: {
 			lexer.NextToken();
 			Expr(
-#line  1751 &quot;cs.ATG&quot; 
+#line  1787 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1751 &quot;cs.ATG&quot; 
+#line  1787 &quot;cs.ATG&quot; 
 			pexpr = new ParenthesizedExpression(expr); 
 			break;
 		}
@@ -4038,177 +4114,186 @@
 			}
 			}
 
-#line  1757 &quot;cs.ATG&quot; 
+#line  1793 &quot;cs.ATG&quot; 
 			string val = t.val; 
 			Expect(13);
 			Expect(1);
 
-#line  1757 &quot;cs.ATG&quot; 
+#line  1793 &quot;cs.ATG&quot; 
 			pexpr = new FieldReferenceExpression(new TypeReferenceExpression(val), t.val); 
 			break;
 		}
 		case 110: {
 			lexer.NextToken();
 
-#line  1759 &quot;cs.ATG&quot; 
+#line  1795 &quot;cs.ATG&quot; 
 			pexpr = new ThisReferenceExpression(); 
 			break;
 		}
 		case 50: {
 			lexer.NextToken();
 
-#line  1761 &quot;cs.ATG&quot; 
+#line  1797 &quot;cs.ATG&quot; 
 			Expression retExpr = new BaseReferenceExpression(); 
 			if (la.kind == 13) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1763 &quot;cs.ATG&quot; 
+#line  1799 &quot;cs.ATG&quot; 
 				retExpr = new FieldReferenceExpression(retExpr, t.val); 
 			} else if (la.kind == 16) {
 				lexer.NextToken();
 				Expr(
-#line  1764 &quot;cs.ATG&quot; 
+#line  1800 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1764 &quot;cs.ATG&quot; 
+#line  1800 &quot;cs.ATG&quot; 
 				ArrayList indices = new ArrayList(); indices.Add(expr); 
 				while (la.kind == 12) {
 					lexer.NextToken();
 					Expr(
-#line  1765 &quot;cs.ATG&quot; 
+#line  1801 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1765 &quot;cs.ATG&quot; 
+#line  1801 &quot;cs.ATG&quot; 
 					indices.Add(expr); 
 				}
 				Expect(17);
 
-#line  1766 &quot;cs.ATG&quot; 
+#line  1802 &quot;cs.ATG&quot; 
 				retExpr = new IndexerExpression(retExpr, indices); 
 			} else SynErr(177);
 
-#line  1767 &quot;cs.ATG&quot; 
+#line  1803 &quot;cs.ATG&quot; 
 			pexpr = retExpr; 
 			break;
 		}
 		case 88: {
 			lexer.NextToken();
 			NonArrayType(
-#line  1768 &quot;cs.ATG&quot; 
+#line  1804 &quot;cs.ATG&quot; 
 out type);
 
-#line  1768 &quot;cs.ATG&quot; 
+#line  1804 &quot;cs.ATG&quot; 
 			ArrayList parameters = new ArrayList(); 
 			if (la.kind == 18) {
 				lexer.NextToken();
 
-#line  1773 &quot;cs.ATG&quot; 
+#line  1809 &quot;cs.ATG&quot; 
 				ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); 
 				if (StartOf(21)) {
 					Argument(
-#line  1773 &quot;cs.ATG&quot; 
+#line  1809 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1773 &quot;cs.ATG&quot; 
+#line  1809 &quot;cs.ATG&quot; 
 					parameters.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Argument(
-#line  1774 &quot;cs.ATG&quot; 
+#line  1810 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1774 &quot;cs.ATG&quot; 
+#line  1810 &quot;cs.ATG&quot; 
 						parameters.Add(expr); 
 					}
 				}
 				Expect(19);
 
-#line  1774 &quot;cs.ATG&quot; 
+#line  1810 &quot;cs.ATG&quot; 
 				pexpr = oce; 
 			} else if (la.kind == 16) {
 
-#line  1776 &quot;cs.ATG&quot; 
-				isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type, parameters); pexpr = ace; 
+#line  1812 &quot;cs.ATG&quot; 
+				isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type); pexpr = ace; 
 				lexer.NextToken();
 
-#line  1777 &quot;cs.ATG&quot; 
-				int dims = 0; ArrayList rank = new ArrayList(); 
+#line  1813 &quot;cs.ATG&quot; 
+				int dims = 0; ArrayList rank = new ArrayList(); ArrayList parameterExpression = new ArrayList(); 
 				if (StartOf(4)) {
 					Expr(
-#line  1779 &quot;cs.ATG&quot; 
+#line  1815 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1779 &quot;cs.ATG&quot; 
-					parameters.Add(expr); 
+#line  1815 &quot;cs.ATG&quot; 
+					parameterExpression.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Expr(
-#line  1779 &quot;cs.ATG&quot; 
+#line  1815 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1779 &quot;cs.ATG&quot; 
-						parameters.Add(expr); 
+#line  1815 &quot;cs.ATG&quot; 
+						parameterExpression.Add(expr); 
 					}
 					Expect(17);
+
+#line  1815 &quot;cs.ATG&quot; 
+					parameters.Add(new ArrayCreationParameter(parameterExpression)); ace.Parameters = parameters; 
 					while (
-#line  1780 &quot;cs.ATG&quot; 
+#line  1816 &quot;cs.ATG&quot; 
 IsDims()) {
 						Expect(16);
 
-#line  1780 &quot;cs.ATG&quot; 
+#line  1816 &quot;cs.ATG&quot; 
 						dims =0;
 						while (la.kind == 12) {
 							lexer.NextToken();
 
-#line  1780 &quot;cs.ATG&quot; 
+#line  1816 &quot;cs.ATG&quot; 
 							dims++;
 						}
 
-#line  1780 &quot;cs.ATG&quot; 
-						rank.Add(dims); 
+#line  1816 &quot;cs.ATG&quot; 
+						rank.Add(dims); parameters.Add(new ArrayCreationParameter(dims)); 
 						Expect(17);
 					}
 
-#line  1781 &quot;cs.ATG&quot; 
+#line  1817 &quot;cs.ATG&quot; 
 					if (rank.Count &gt; 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } 
 					if (la.kind == 14) {
 						ArrayInitializer(
-#line  1782 &quot;cs.ATG&quot; 
+#line  1818 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1782 &quot;cs.ATG&quot; 
+#line  1818 &quot;cs.ATG&quot; 
 						ace.ArrayInitializer = (ArrayInitializerExpression)expr; 
 					}
 				} else if (la.kind == 12 || la.kind == 17) {
 					while (la.kind == 12) {
 						lexer.NextToken();
+
+#line  1820 &quot;cs.ATG&quot; 
+						dims++;
 					}
+
+#line  1820 &quot;cs.ATG&quot; 
+					parameters.Add(new ArrayCreationParameter(dims)); 
 					Expect(17);
 					while (
-#line  1784 &quot;cs.ATG&quot; 
+#line  1820 &quot;cs.ATG&quot; 
 IsDims()) {
 						Expect(16);
 
-#line  1784 &quot;cs.ATG&quot; 
+#line  1820 &quot;cs.ATG&quot; 
 						dims =0;
 						while (la.kind == 12) {
 							lexer.NextToken();
 
-#line  1784 &quot;cs.ATG&quot; 
+#line  1820 &quot;cs.ATG&quot; 
 							dims++;
 						}
 
-#line  1784 &quot;cs.ATG&quot; 
-						parameters.Add(dims); 
+#line  1820 &quot;cs.ATG&quot; 
+						parameters.Add(new ArrayCreationParameter(dims)); 
 						Expect(17);
 					}
 					ArrayInitializer(
-#line  1784 &quot;cs.ATG&quot; 
+#line  1820 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1784 &quot;cs.ATG&quot; 
-					ace.ArrayInitializer = (ArrayInitializerExpression)expr; 
+#line  1820 &quot;cs.ATG&quot; 
+					ace.ArrayInitializer = (ArrayInitializerExpression)expr; ace.Parameters = parameters; 
 				} else SynErr(178);
 			} else SynErr(179);
 			break;
@@ -4217,20 +4302,20 @@
 			lexer.NextToken();
 			Expect(18);
 			if (
-#line  1790 &quot;cs.ATG&quot; 
+#line  1826 &quot;cs.ATG&quot; 
 NotVoidPointer()) {
 				Expect(122);
 
-#line  1790 &quot;cs.ATG&quot; 
+#line  1826 &quot;cs.ATG&quot; 
 				type = new TypeReference(&quot;void&quot;); 
 			} else if (StartOf(8)) {
 				Type(
-#line  1791 &quot;cs.ATG&quot; 
+#line  1827 &quot;cs.ATG&quot; 
 out type);
 			} else SynErr(180);
 			Expect(19);
 
-#line  1792 &quot;cs.ATG&quot; 
+#line  1828 &quot;cs.ATG&quot; 
 			pexpr = new TypeOfExpression(type); 
 			break;
 		}
@@ -4238,11 +4323,11 @@
 			lexer.NextToken();
 			Expect(18);
 			Type(
-#line  1793 &quot;cs.ATG&quot; 
+#line  1829 &quot;cs.ATG&quot; 
 out type);
 			Expect(19);
 
-#line  1793 &quot;cs.ATG&quot; 
+#line  1829 &quot;cs.ATG&quot; 
 			pexpr = new SizeOfExpression(type); 
 			break;
 		}
@@ -4250,11 +4335,11 @@
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1794 &quot;cs.ATG&quot; 
+#line  1830 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1794 &quot;cs.ATG&quot; 
+#line  1830 &quot;cs.ATG&quot; 
 			pexpr = new CheckedExpression(expr); 
 			break;
 		}
@@ -4262,11 +4347,11 @@
 			lexer.NextToken();
 			Expect(18);
 			Expr(
-#line  1795 &quot;cs.ATG&quot; 
+#line  1831 &quot;cs.ATG&quot; 
 out expr);
 			Expect(19);
 
-#line  1795 &quot;cs.ATG&quot; 
+#line  1831 &quot;cs.ATG&quot; 
 			pexpr = new CheckedExpression(expr); 
 			break;
 		}
@@ -4277,350 +4362,350 @@
 				if (la.kind == 29) {
 					lexer.NextToken();
 
-#line  1799 &quot;cs.ATG&quot; 
+#line  1835 &quot;cs.ATG&quot; 
 					pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); 
 				} else if (la.kind == 30) {
 					lexer.NextToken();
 
-#line  1800 &quot;cs.ATG&quot; 
+#line  1836 &quot;cs.ATG&quot; 
 					pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); 
 				} else SynErr(182);
 			} else if (la.kind == 47) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1803 &quot;cs.ATG&quot; 
+#line  1839 &quot;cs.ATG&quot; 
 				pexpr = new PointerReferenceExpression(pexpr, t.val); 
 			} else if (la.kind == 13) {
 				lexer.NextToken();
 				Expect(1);
 
-#line  1804 &quot;cs.ATG&quot; 
+#line  1840 &quot;cs.ATG&quot; 
 				pexpr = new FieldReferenceExpression(pexpr, t.val);
 			} else if (la.kind == 18) {
 				lexer.NextToken();
 
-#line  1806 &quot;cs.ATG&quot; 
+#line  1842 &quot;cs.ATG&quot; 
 				ArrayList parameters = new ArrayList(); 
 				if (StartOf(21)) {
 					Argument(
-#line  1807 &quot;cs.ATG&quot; 
+#line  1843 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1807 &quot;cs.ATG&quot; 
+#line  1843 &quot;cs.ATG&quot; 
 					parameters.Add(expr); 
 					while (la.kind == 12) {
 						lexer.NextToken();
 						Argument(
-#line  1808 &quot;cs.ATG&quot; 
+#line  1844 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1808 &quot;cs.ATG&quot; 
+#line  1844 &quot;cs.ATG&quot; 
 						parameters.Add(expr); 
 					}
 				}
 				Expect(19);
 
-#line  1809 &quot;cs.ATG&quot; 
+#line  1845 &quot;cs.ATG&quot; 
 				pexpr = new InvocationExpression(pexpr, parameters); 
 			} else {
 
-#line  1811 &quot;cs.ATG&quot; 
+#line  1847 &quot;cs.ATG&quot; 
 				if (isArrayCreation) Error(&quot;element access not allow on array creation&quot;);
 				ArrayList indices = new ArrayList();
 				
 				lexer.NextToken();
 				Expr(
-#line  1814 &quot;cs.ATG&quot; 
+#line  1850 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1814 &quot;cs.ATG&quot; 
+#line  1850 &quot;cs.ATG&quot; 
 				indices.Add(expr); 
 				while (la.kind == 12) {
 					lexer.NextToken();
 					Expr(
-#line  1815 &quot;cs.ATG&quot; 
+#line  1851 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1815 &quot;cs.ATG&quot; 
+#line  1851 &quot;cs.ATG&quot; 
 					indices.Add(expr); 
 				}
 				Expect(17);
 
-#line  1816 &quot;cs.ATG&quot; 
+#line  1852 &quot;cs.ATG&quot; 
 				pexpr = new IndexerExpression(pexpr, indices); 
 			}
 		}
 	}
 
 	void ConditionalAndExpr(
-#line  1826 &quot;cs.ATG&quot; 
+#line  1862 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1827 &quot;cs.ATG&quot; 
+#line  1863 &quot;cs.ATG&quot; 
 		Expression expr; 
 		InclusiveOrExpr(
-#line  1829 &quot;cs.ATG&quot; 
+#line  1865 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 23) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1829 &quot;cs.ATG&quot; 
+#line  1865 &quot;cs.ATG&quot; 
 out expr);
 			InclusiveOrExpr(
-#line  1829 &quot;cs.ATG&quot; 
+#line  1865 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1829 &quot;cs.ATG&quot; 
+#line  1865 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  
 		}
 	}
 
 	void InclusiveOrExpr(
-#line  1832 &quot;cs.ATG&quot; 
+#line  1868 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1833 &quot;cs.ATG&quot; 
+#line  1869 &quot;cs.ATG&quot; 
 		Expression expr; 
 		ExclusiveOrExpr(
-#line  1835 &quot;cs.ATG&quot; 
+#line  1871 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 27) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1835 &quot;cs.ATG&quot; 
+#line  1871 &quot;cs.ATG&quot; 
 out expr);
 			ExclusiveOrExpr(
-#line  1835 &quot;cs.ATG&quot; 
+#line  1871 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1835 &quot;cs.ATG&quot; 
+#line  1871 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  
 		}
 	}
 
 	void ExclusiveOrExpr(
-#line  1838 &quot;cs.ATG&quot; 
+#line  1874 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1839 &quot;cs.ATG&quot; 
+#line  1875 &quot;cs.ATG&quot; 
 		Expression expr; 
 		AndExpr(
-#line  1841 &quot;cs.ATG&quot; 
+#line  1877 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 28) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1841 &quot;cs.ATG&quot; 
+#line  1877 &quot;cs.ATG&quot; 
 out expr);
 			AndExpr(
-#line  1841 &quot;cs.ATG&quot; 
+#line  1877 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1841 &quot;cs.ATG&quot; 
+#line  1877 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  
 		}
 	}
 
 	void AndExpr(
-#line  1844 &quot;cs.ATG&quot; 
+#line  1880 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1845 &quot;cs.ATG&quot; 
+#line  1881 &quot;cs.ATG&quot; 
 		Expression expr; 
 		EqualityExpr(
-#line  1847 &quot;cs.ATG&quot; 
+#line  1883 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 26) {
 			lexer.NextToken();
 			UnaryExpr(
-#line  1847 &quot;cs.ATG&quot; 
+#line  1883 &quot;cs.ATG&quot; 
 out expr);
 			EqualityExpr(
-#line  1847 &quot;cs.ATG&quot; 
+#line  1883 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1847 &quot;cs.ATG&quot; 
+#line  1883 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  
 		}
 	}
 
 	void EqualityExpr(
-#line  1850 &quot;cs.ATG&quot; 
+#line  1886 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1852 &quot;cs.ATG&quot; 
+#line  1888 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		RelationalExpr(
-#line  1856 &quot;cs.ATG&quot; 
+#line  1892 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 31 || la.kind == 32) {
 			if (la.kind == 32) {
 				lexer.NextToken();
 
-#line  1859 &quot;cs.ATG&quot; 
+#line  1895 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.InEquality; 
 			} else {
 				lexer.NextToken();
 
-#line  1860 &quot;cs.ATG&quot; 
+#line  1896 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Equality; 
 			}
 			UnaryExpr(
-#line  1862 &quot;cs.ATG&quot; 
+#line  1898 &quot;cs.ATG&quot; 
 out expr);
 			RelationalExpr(
-#line  1862 &quot;cs.ATG&quot; 
+#line  1898 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1862 &quot;cs.ATG&quot; 
+#line  1898 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void RelationalExpr(
-#line  1866 &quot;cs.ATG&quot; 
+#line  1902 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1868 &quot;cs.ATG&quot; 
+#line  1904 &quot;cs.ATG&quot; 
 		TypeReference type;
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		ShiftExpr(
-#line  1873 &quot;cs.ATG&quot; 
+#line  1909 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (StartOf(26)) {
 			if (StartOf(27)) {
 				if (la.kind == 21) {
 					lexer.NextToken();
 
-#line  1876 &quot;cs.ATG&quot; 
+#line  1912 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.LessThan; 
 				} else if (la.kind == 20) {
 					lexer.NextToken();
 
-#line  1877 &quot;cs.ATG&quot; 
+#line  1913 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.GreaterThan; 
 				} else if (la.kind == 34) {
 					lexer.NextToken();
 
-#line  1878 &quot;cs.ATG&quot; 
+#line  1914 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.LessThanOrEqual; 
 				} else if (la.kind == 33) {
 					lexer.NextToken();
 
-#line  1879 &quot;cs.ATG&quot; 
+#line  1915 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.GreaterThanOrEqual; 
 				} else SynErr(183);
 				UnaryExpr(
-#line  1881 &quot;cs.ATG&quot; 
+#line  1917 &quot;cs.ATG&quot; 
 out expr);
 				ShiftExpr(
-#line  1881 &quot;cs.ATG&quot; 
+#line  1917 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1881 &quot;cs.ATG&quot; 
+#line  1917 &quot;cs.ATG&quot; 
 				outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 			} else {
 				if (la.kind == 84) {
 					lexer.NextToken();
 
-#line  1884 &quot;cs.ATG&quot; 
+#line  1920 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.IS; 
 				} else if (la.kind == 49) {
 					lexer.NextToken();
 
-#line  1885 &quot;cs.ATG&quot; 
+#line  1921 &quot;cs.ATG&quot; 
 					op = BinaryOperatorType.AS; 
 				} else SynErr(184);
 				Type(
-#line  1887 &quot;cs.ATG&quot; 
+#line  1923 &quot;cs.ATG&quot; 
 out type);
 
-#line  1887 &quot;cs.ATG&quot; 
+#line  1923 &quot;cs.ATG&quot; 
 				outExpr = new BinaryOperatorExpression(outExpr, op, new TypeReferenceExpression(type)); 
 			}
 		}
 	}
 
 	void ShiftExpr(
-#line  1891 &quot;cs.ATG&quot; 
+#line  1927 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1893 &quot;cs.ATG&quot; 
+#line  1929 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		AdditiveExpr(
-#line  1897 &quot;cs.ATG&quot; 
+#line  1933 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 35 || la.kind == 36) {
 			if (la.kind == 35) {
 				lexer.NextToken();
 
-#line  1900 &quot;cs.ATG&quot; 
+#line  1936 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.ShiftLeft; 
 			} else {
 				lexer.NextToken();
 
-#line  1901 &quot;cs.ATG&quot; 
+#line  1937 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.ShiftRight; 
 			}
 			UnaryExpr(
-#line  1903 &quot;cs.ATG&quot; 
+#line  1939 &quot;cs.ATG&quot; 
 out expr);
 			AdditiveExpr(
-#line  1903 &quot;cs.ATG&quot; 
+#line  1939 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1903 &quot;cs.ATG&quot; 
+#line  1939 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void AdditiveExpr(
-#line  1907 &quot;cs.ATG&quot; 
+#line  1943 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1909 &quot;cs.ATG&quot; 
+#line  1945 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
 		MultiplicativeExpr(
-#line  1913 &quot;cs.ATG&quot; 
+#line  1949 &quot;cs.ATG&quot; 
 ref outExpr);
 		while (la.kind == 4 || la.kind == 5) {
 			if (la.kind == 4) {
 				lexer.NextToken();
 
-#line  1916 &quot;cs.ATG&quot; 
+#line  1952 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Add; 
 			} else {
 				lexer.NextToken();
 
-#line  1917 &quot;cs.ATG&quot; 
+#line  1953 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Subtract; 
 			}
 			UnaryExpr(
-#line  1919 &quot;cs.ATG&quot; 
+#line  1955 &quot;cs.ATG&quot; 
 out expr);
 			MultiplicativeExpr(
-#line  1919 &quot;cs.ATG&quot; 
+#line  1955 &quot;cs.ATG&quot; 
 ref expr);
 
-#line  1919 &quot;cs.ATG&quot; 
+#line  1955 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr);  
 		}
 	}
 
 	void MultiplicativeExpr(
-#line  1923 &quot;cs.ATG&quot; 
+#line  1959 &quot;cs.ATG&quot; 
 ref Expression outExpr) {
 
-#line  1925 &quot;cs.ATG&quot; 
+#line  1961 &quot;cs.ATG&quot; 
 		Expression expr;
 		BinaryOperatorType op = BinaryOperatorType.None;
 		
@@ -4628,24 +4713,24 @@
 			if (la.kind == 6) {
 				lexer.NextToken();
 
-#line  1931 &quot;cs.ATG&quot; 
+#line  1967 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Multiply; 
 			} else if (la.kind == 7) {
 				lexer.NextToken();
 
-#line  1932 &quot;cs.ATG&quot; 
+#line  1968 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Divide; 
 			} else {
 				lexer.NextToken();
 
-#line  1933 &quot;cs.ATG&quot; 
+#line  1969 &quot;cs.ATG&quot; 
 				op = BinaryOperatorType.Modulus; 
 			}
 			UnaryExpr(
-#line  1935 &quot;cs.ATG&quot; 
+#line  1971 &quot;cs.ATG&quot; 
 out expr);
 
-#line  1935 &quot;cs.ATG&quot; 
+#line  1971 &quot;cs.ATG&quot; 
 			outExpr = new BinaryOperatorExpression(outExpr, op, expr); 
 		}
 	}

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/ParserUtil.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/ParserUtil.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/ParserUtil.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,4 +1,4 @@
-namespace MonoDevelop.SharpRefactory.Parser
+namespace ICSharpCode.SharpRefactory.Parser
 {
 	public sealed class ParserUtil
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/cs.ATG
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/cs.ATG	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/cs.ATG	2004-03-21 06:22:28 UTC (rev 1213)
@@ -312,7 +312,7 @@
 /* True, if lookahead is a primitive type keyword, or *
  * if it is a type declaration followed by an ident   */
 bool IsLocalVarDecl () {
-	if (ParserUtil.IsTypeKW(la) || la.kind == Tokens.Void) return true;
+	if ((ParserUtil.IsTypeKW(la) &amp;&amp; Peek(1).kind != Tokens.Dot) || la.kind == Tokens.Void) return true;
 	
 	StartPeek();
 	Token pt = la ;  // peek token
@@ -548,8 +548,8 @@
 
 GlobalAttributeSection
 =
-	(. Point startPos = t.Location; .)
-	&quot;[&quot; ident                   (. if (t.val != &quot;assembly&quot;) Error(&quot;global attribute target specifier (\&quot;assembly\&quot;) expected&quot;);
+	
+	&quot;[&quot; (. Point startPos = t.Location; .) ident                   (. if (t.val != &quot;assembly&quot;) Error(&quot;global attribute target specifier (\&quot;assembly\&quot;) expected&quot;);
 	                               string attributeTarget = t.val;
 	                               ArrayList attributes = new ArrayList();
 	                               ICSharpCode.SharpRefactory.Parser.AST.Attribute attribute;
@@ -682,7 +682,7 @@
 	ident                           (. newType.Name = t.val; .)
 	[ ClassBase&lt;out names&gt;          (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
 	ClassBody
-	[ &quot;;&quot; ]                         (. newType.EndLocation = t.EndLocation; 
+	[ &quot;;&quot; ]                         (. newType.EndLocation = t.Location; 
 	                                   compilationUnit.BlockEnd();
 	                                .)
 	| /*--- struct declaration: */  (. m.Check(Modifier.StructsInterfacesEnumsDelegates); .)
@@ -696,7 +696,7 @@
 	ident                            (. newType.Name = t.val; .)
 	[ StructInterfaces&lt;out names&gt;    (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
 	StructBody
-	[ &quot;;&quot; ]                          (. newType.EndLocation = t.EndLocation; 
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
 	                                    compilationUnit.BlockEnd();
 	                                 .)
 	| /*--- interface declaration: */ 
@@ -709,7 +709,7 @@
 	ident                            (. newType.Name = t.val; .)
 	[ InterfaceBase&lt;out names&gt;       (. newType.BaseTypes = names; .) ] (. newType.StartLocation = t.EndLocation; .)
 	InterfaceBody
-	[ &quot;;&quot; ]                          (. newType.EndLocation = t.EndLocation; 
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
 	                                    compilationUnit.BlockEnd();
 	                                 .)
 	| /*--- enumeration declaration: */
@@ -725,7 +725,7 @@
 	                                 .)
 	]                                (. newType.StartLocation = t.EndLocation; .)
 	EnumBody 
-	[ &quot;;&quot; ]                          (. newType.EndLocation = t.EndLocation; 
+	[ &quot;;&quot; ]                          (. newType.EndLocation = t.Location; 
 	                                    compilationUnit.BlockEnd();
 	                                 .)
 	| /*--- delegate declaration: */
@@ -740,7 +740,7 @@
 	ident                            (. delegateDeclr.Name = t.val; .)
 	&quot;(&quot; [ FormalParameterList&lt;out p&gt; (. delegateDeclr.Parameters = p; .)
 	] &quot;)&quot;
-	&quot;;&quot;                              (. delegateDeclr.EndLocation = t.EndLocation;
+	&quot;;&quot;                              (. delegateDeclr.EndLocation = t.Location;
 	                                    compilationUnit.AddChild(delegateDeclr);
 	                                 .)
 	)
@@ -969,7 +969,7 @@
 
 StructMemberDecl&lt;Modifiers m, ArrayList attributes&gt;
 (.
-	string qualident;
+	string qualident = null;
 	TypeReference type;
 	Expression expr;
 	ArrayList p = new ArrayList();
@@ -1009,7 +1009,7 @@
 	                                       .)
 	
 	| /*--- event declaration: */          (. m.Check(Modifier.PropertysEventsMethods); .)
-	&quot;event&quot;                                (. EventDeclaration eventDecl = new EventDeclaration(attributes);
+	&quot;event&quot;                                (. EventDeclaration eventDecl = new EventDeclaration(m.Modifier, attributes);
 	                                          eventDecl.StartLocation = t.Location;
 	                                          compilationUnit.AddChild(eventDecl);
 	                                          compilationUnit.BlockStart(eventDecl);
@@ -1049,8 +1049,21 @@
 	/*--- conversion operator declaration: */
 	|                                      (. m.Check(Modifier.Operators);
 	                                          if (m.isNone) Error(&quot;at least one modifier must be set&quot;); 
+	                                          bool isImplicit = true;
 	                                       .)
-	( &quot;implicit&quot; | &quot;explicit&quot; ) &quot;operator&quot; Type&lt;out type&gt; &quot;(&quot; Type&lt;out type&gt; ident &quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; )
+	( &quot;implicit&quot; | &quot;explicit&quot; (. isImplicit = false; .) ) 
+	&quot;operator&quot; Type&lt;out type&gt; (. TypeReference operatorType = type; .) 
+	&quot;(&quot; Type&lt;out type&gt; ident (. string varName = t.val; .) &quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; (. stmt = null; .) )
+	(.
+		
+		OperatorDeclarator operatorDeclarator = new OperatorDeclarator(isImplicit ? OperatorType.Implicit : OperatorType.Explicit,
+		                                                               operatorType,
+		                                                               type,
+		                                                               varName);
+		OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+		operatorDeclaration.Body = stmt;
+		compilationUnit.AddChild(operatorDeclaration);
+	.)
 	
 	/*--- inner type declaration: */
 	| TypeDecl&lt;m, attributes&gt;
@@ -1060,9 +1073,9 @@
 		                                      m.Check(Modifier.Operators);
 		                                      if (m.isNone) Error(&quot;at least one modifier must be set&quot;);
 		                                   .)
-		&quot;operator&quot; OverloadableOperator&lt;out op&gt; 
-		&quot;(&quot; Type&lt;out type&gt; ident 
-		( &quot;,&quot; Type&lt;out type&gt; ident         (. if (ParserUtil.IsUnaryOperator(op))
+		&quot;operator&quot; OverloadableOperator&lt;out op&gt; (. TypeReference firstType, secondType = null; string secondName = null; .)
+		&quot;(&quot; Type&lt;out firstType&gt; ident (. string firstName = t.val; .)
+		( &quot;,&quot; Type&lt;out secondType&gt; ident (. secondName = t.val; .)        (. if (ParserUtil.IsUnaryOperator(op) &amp;&amp; !ParserUtil.IsBinaryOperator(op))
 		                                      Error(&quot;too many operands for unary operator&quot;); 
 		                                   .)
 		| /* empty */                      (. if (ParserUtil.IsBinaryOperator(op))
@@ -1070,6 +1083,18 @@
 		                                   .)
 		)
 		&quot;)&quot; ( Block&lt;out stmt&gt; | &quot;;&quot; )
+		(.
+			OperatorDeclarator operatorDeclarator = new OperatorDeclarator(secondType != null ? OperatorType.Binary : OperatorType.Unary, 
+			                                                               type,
+			                                                               op.kind,
+			                                                               firstType,
+			                                                               firstName,
+			                                                               secondType,
+			                                                               secondName);
+			OperatorDeclaration operatorDeclaration = new OperatorDeclaration(operatorDeclarator, m.Modifier, attributes);
+			operatorDeclaration.Body = stmt;
+			compilationUnit.AddChild(operatorDeclaration);
+		.)
 		
 		/*--- field declaration: */
 		| IF (IsVarDecl())                 (. m.Check(Modifier.Fields); 
@@ -1176,40 +1201,43 @@
 	string name;
 	PropertyGetRegion getBlock;
 	PropertySetRegion setBlock;
+	Point startLocation = new Point(-1, -1);
 .)
 =
 	{ AttributeSection&lt;out section&gt;     (. attributes.Add(section); .)}
-	[ &quot;new&quot; (. mod = Modifier.New; .) ]
+	[ &quot;new&quot; (. mod = Modifier.New; startLocation = t.Location; .) ]
 	(
 		/*--- interface void method (procedure) declaration: */
-		IF (NotVoidPointer()) &quot;void&quot; ident (. name = t.val; .)
-		&quot;(&quot; [ FormalParameterList&lt;out p&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference(&quot;void&quot;), parameters, attributes);
+		IF (NotVoidPointer()) &quot;void&quot; (. if (startLocation.X == -1) startLocation = t.Location; .) ident (. name = t.val; .)
+		&quot;(&quot; [ FormalParameterList&lt;out parameters&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, new TypeReference(&quot;void&quot;), parameters, attributes);
+		                                              md.StartLocation = startLocation;
 		                                              md.EndLocation = t.EndLocation;
 		                                              compilationUnit.AddChild(md);
 		                                           .)
 		| (
-			Type&lt;out type&gt;
+			Type&lt;out type&gt; (. if (startLocation.X == -1) startLocation = t.Location; .)
 			(
-				ident                  (. name = t.val; .)
+				ident                  (. name = t.val; Point qualIdentEndLocation = t.EndLocation; .)
 				(
 					/*--- interface &quot;not void&quot; method (function) declaration: */
 					&quot;(&quot; [ FormalParameterList&lt;out parameters&gt; ] &quot;)&quot; &quot;;&quot; (. MethodDeclaration md = new MethodDeclaration(name, mod, type, parameters, attributes);
+					                                              md.StartLocation = startLocation;
 					                                              md.EndLocation = t.EndLocation;
 					                                              compilationUnit.AddChild(md);
 					                                           .)
 					/*--- interface property declaration: */
 					|                   (. PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); .)
-					&quot;{&quot; InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.EndLocation = t.EndLocation; .)
+					&quot;{&quot; (. Point bodyStart = t.Location;.) InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; .)
 				)
 				/*--- interface indexer declaration: */
-				| &quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (. IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); .)
-				&quot;{&quot; InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. id.GetRegion = getBlock; id.SetRegion = setBlock; id.EndLocation = t.EndLocation; .)
+				| &quot;this&quot; &quot;[&quot; FormalParameterList&lt;out p&gt; &quot;]&quot; (.Point bracketEndLocation = t.EndLocation; .)  (. IndexerDeclaration id = new IndexerDeclaration(type, p, mod, attributes); compilationUnit.AddChild(id); .)
+				&quot;{&quot; (. Point bodyStart = t.Location;.) InterfaceAccessors&lt;out getBlock, out setBlock&gt; &quot;}&quot; (. id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;.)
 			)
 			/*--- interface event declaration: */
-			| &quot;event&quot; Type&lt;out type&gt; ident (. EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
+			| &quot;event&quot; (. if (startLocation.X == -1) startLocation = t.Location; .) Type&lt;out type&gt; ident (. EventDeclaration ed = new EventDeclaration(type, t.val, mod, attributes);
 			                                  compilationUnit.AddChild(ed);
 			                               .)
-			&quot;;&quot;                            (. ed.EndLocation = t.EndLocation; .)
+			&quot;;&quot;                            (. ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; .)
 		)
 	)
 .
@@ -1521,9 +1549,11 @@
 	  [ Expr&lt;out expr&gt; ] &quot;;&quot;
 	  [ ForIterator&lt;out iterator&gt; ] &quot;)&quot;
 	  EmbeddedStatement&lt;out embeddedStatement&gt; (. statement = new ForStatement(initializer, expr, iterator, embeddedStatement); .)
-	| &quot;foreach&quot; &quot;(&quot; Type&lt;out type&gt; ident     (. string varName = t.val; .)
+	| &quot;foreach&quot; &quot;(&quot; Type&lt;out type&gt; ident     (. string varName = t.val; Point start = t.Location;.)
 	&quot;in&quot; Expr&lt;out expr&gt; &quot;)&quot;
-	EmbeddedStatement&lt;out embeddedStatement&gt; (.  statement = new ForeachStatement(type, varName , expr, embeddedStatement); .)
+	EmbeddedStatement&lt;out embeddedStatement&gt; (.  statement = new ForeachStatement(type, varName , expr, embeddedStatement); 
+	                                             statement.EndLocation = t.EndLocation;
+	                                         .)
 	/*--- jump statements (break, contine, goto, return, throw): */
 	| &quot;break&quot; &quot;;&quot;               (. statement = new BreakStatement(); .)
 	| &quot;continue&quot; &quot;;&quot;            (. statement = new ContinueStatement(); .)
@@ -1682,12 +1712,12 @@
 .
 
 Expr&lt;out Expression expr&gt;
-(. expr = new Expression(); .)
+(. expr = null; Expression expr1 = null, expr2 = null; .)
 =
 	UnaryExpr&lt;out expr&gt;
 	/*--- conditional expression: */
 	(
-		ConditionalOrExpr&lt;ref expr&gt; [ &quot;?&quot; Expr&lt;out expr&gt; &quot;:&quot; Expr&lt;out expr&gt; ]
+		ConditionalOrExpr&lt;ref expr&gt; [ &quot;?&quot; Expr&lt;out expr1&gt; &quot;:&quot; Expr&lt;out expr2&gt; (. expr = new ConditionalExpression(expr, expr1, expr2);  .) ] 
 		/*--- assignment: */
 		| (. AssignmentOperatorType op; Expression val; .) AssignmentOperator&lt;out op&gt; Expr&lt;out val&gt; (. expr = new AssignmentExpression(expr, op, val); .)
 	)
@@ -1698,20 +1728,19 @@
 (.
 	TypeReference type = null;
 	Expression expr;
-	UnaryOperatorType uop = UnaryOperatorType.None;
-	bool isUOp = false;
-	bool isCast = false;
+	ArrayList  expressions = new ArrayList();
+	uExpr = null;
 .)
 =
 	{
-		  &quot;+&quot;  (. uop = UnaryOperatorType.Plus; isUOp = true; .)
-		| &quot;-&quot;  (. uop = UnaryOperatorType.Minus; isUOp = true; .)
-		| &quot;!&quot;  (. uop = UnaryOperatorType.Not;  isUOp = true;.)
-		| &quot;~&quot;  (. uop = UnaryOperatorType.BitNot; isUOp = true; .)
-		| &quot;*&quot;  (. uop = UnaryOperatorType.Star;  isUOp = true; .)
-		| &quot;++&quot; (. uop = UnaryOperatorType.Increment; isUOp = true; .)
-		| &quot;--&quot; (. uop = UnaryOperatorType.Decrement; isUOp = true; .)
-		| &quot;&amp;&quot;  (. uop = UnaryOperatorType.BitWiseAnd; isUOp = true; .)
+		  &quot;+&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); .)
+		| &quot;-&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); .)
+		| &quot;!&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); .)
+		| &quot;~&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); .)
+		| &quot;*&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); .)
+		| &quot;++&quot; (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); .)
+		| &quot;--&quot; (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); .)
+		| &quot;&amp;&quot;  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); .)
 		
 		/*--- cast expression: */
 		/* Problem:  &quot;(&quot; Type &quot;)&quot; from here and                     *
@@ -1719,14 +1748,21 @@
 		 *           are not distinguishable                        *
 		 * Solution: (in IsTypeCast())                              *
 		 * use external information from compiled assembly or guess */
-		| IF (IsTypeCast()) &quot;(&quot; Type&lt;out type&gt; &quot;)&quot;  (. isCast = true; .)
+		| IF (IsTypeCast()) &quot;(&quot; Type&lt;out type&gt; &quot;)&quot;  (.  expressions.Add(new CastExpression(type)); .)
 	}
-	PrimaryExpr&lt;out expr&gt; (. if (isUOp) { 
-	                             uExpr = new UnaryOperatorExpression(expr, uop);
-	                         } else if (isCast) {
-	                             uExpr = new CastExpression(type, expr);
+	
+	PrimaryExpr&lt;out expr&gt; (. for (int i = 0; i &lt; expressions.Count; ++i) {
+	                         	Expression nextExpression = i + 1 &lt; expressions.Count ? (Expression)expressions[i + 1] : expr;
+	                         	if (expressions[i] is CastExpression) {
+	                         		((CastExpression)expressions[i]).Expression = nextExpression;
+	                         	} else {
+	                         		((UnaryOperatorExpression)expressions[i]).Expression = nextExpression;
+	                         	}
+	                         }
+	                         if (expressions.Count &gt; 0) {
+	                         	uExpr = (Expression)expressions[0];
 	                         } else {
-	                             uExpr = expr;
+	                         	uExpr = expr;
 	                         }
 	                      .)
 .
@@ -1773,15 +1809,15 @@
 			&quot;(&quot; (. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .) [ Argument&lt;out expr&gt;          (. parameters.Add(expr); .)
 			{ &quot;,&quot; Argument&lt;out expr&gt;          (. parameters.Add(expr); .) } ] &quot;)&quot; (. pexpr = oce; .)
 			/*--- array creation expression: */
-			| (. isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type, parameters); pexpr = ace; .)
-			&quot;[&quot; (. int dims = 0; ArrayList rank = new ArrayList(); .)
+			| (. isArrayCreation = true; ArrayCreateExpression ace = new ArrayCreateExpression(type); pexpr = ace; .)
+			&quot;[&quot; (. int dims = 0; ArrayList rank = new ArrayList(); ArrayList parameterExpression = new ArrayList(); .)
 			(
-				Expr&lt;out expr&gt; (. parameters.Add(expr); .) { &quot;,&quot; Expr&lt;out expr&gt; (. parameters.Add(expr); .) } &quot;]&quot;
-				{ IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.rank.Add(dims); .) &quot;]&quot; } 
+				Expr&lt;out expr&gt; (. parameterExpression.Add(expr); .) { &quot;,&quot; Expr&lt;out expr&gt; (. parameterExpression.Add(expr); .) } &quot;]&quot; (. parameters.Add(new ArrayCreationParameter(parameterExpression)); ace.Parameters = parameters; .)
+				{ IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.rank.Add(dims); parameters.Add(new ArrayCreationParameter(dims)); .) &quot;]&quot; } 
 				(. if (rank.Count &gt; 0) { ace.Rank = (int[])rank.ToArray(typeof (int)); } .)
 				[ ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; .) ]
 				
-				| { &quot;,&quot; } &quot;]&quot; { IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.parameters.Add(dims); .) &quot;]&quot; } ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; .)
+				| { &quot;,&quot; (.dims++;.) } (.parameters.Add(new ArrayCreationParameter(dims)); .)  &quot;]&quot; { IF (IsDims()) &quot;[&quot; (.dims =0;.) { &quot;,&quot; (.dims++;.) } (.parameters.Add(new ArrayCreationParameter(dims)); .) &quot;]&quot; } ArrayInitializer&lt;out expr&gt; (. ace.ArrayInitializer = (ArrayInitializerExpression)expr; ace.Parameters = parameters; .)
 			)
 /*			| ArrayInitializer&lt;out expr&gt; (. if (!type.IsArrayType) { Error(&quot;() or [] expected&quot;); }  pexpr =  new ArrayCreateExpression(type, (ArrayInitializerExpression)expr); .)*/
 		)
@@ -1818,7 +1854,7 @@
 .
 
 ConditionalOrExpr&lt;ref Expression outExpr&gt;
-(. Expression expr; .)
+(. Expression expr;   .)
 =
 	ConditionalAndExpr&lt;ref outExpr&gt;  { &quot;||&quot; UnaryExpr&lt;out expr&gt; ConditionalAndExpr&lt;ref expr&gt; (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  .) }
 .

Added: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/ATGTokensSection.gen
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/ATGTokensSection.gen	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/ATGTokensSection.gen	2004-03-21 06:22:28 UTC (rev 1213)
@@ -0,0 +1,133 @@
+/* START AUTOGENERATED TOKENS SECTION */
+TOKENS
+	/* ----- terminal classes ----- */
+	/* EOF is 0 */
+	ident
+	Literal
+
+	/* ----- special character ----- */
+	&quot;=&quot;
+	&quot;+&quot;
+	&quot;-&quot;
+	&quot;*&quot;
+	&quot;/&quot;
+	&quot;%&quot;
+	&quot;:&quot;
+	&quot;;&quot;
+	&quot;?&quot;
+	&quot;,&quot;
+	&quot;.&quot;
+	&quot;{&quot;
+	&quot;}&quot;
+	&quot;[&quot;
+	&quot;]&quot;
+	&quot;(&quot;
+	&quot;)&quot;
+	&quot;&gt;&quot;
+	&quot;&lt;&quot;
+	&quot;!&quot;
+	&quot;&amp;&amp;&quot;
+	&quot;||&quot;
+	&quot;~&quot;
+	&quot;&amp;&quot;
+	&quot;|&quot;
+	&quot;^&quot;
+	&quot;++&quot;
+	&quot;--&quot;
+	&quot;==&quot;
+	&quot;!=&quot;
+	&quot;&gt;=&quot;
+	&quot;&lt;=&quot;
+	&quot;&lt;&lt;&quot;
+	&quot;&gt;&gt;&quot;
+	&quot;+=&quot;
+	&quot;-=&quot;
+	&quot;*=&quot;
+	&quot;/=&quot;
+	&quot;%=&quot;
+	&quot;&amp;=&quot;
+	&quot;|=&quot;
+	&quot;^=&quot;
+	&quot;&lt;&lt;=&quot;
+	&quot;&gt;&gt;=&quot;
+	&quot;-&gt;&quot;
+
+	/* ----- keywords ----- */
+	&quot;abstract&quot;
+	&quot;as&quot;
+	&quot;base&quot;
+	&quot;bool&quot;
+	&quot;break&quot;
+	&quot;byte&quot;
+	&quot;case&quot;
+	&quot;catch&quot;
+	&quot;char&quot;
+	&quot;checked&quot;
+	&quot;class&quot;
+	&quot;const&quot;
+	&quot;continue&quot;
+	&quot;decimal&quot;
+	&quot;default&quot;
+	&quot;delegate&quot;
+	&quot;do&quot;
+	&quot;double&quot;
+	&quot;else&quot;
+	&quot;enum&quot;
+	&quot;event&quot;
+	&quot;explicit&quot;
+	&quot;extern&quot;
+	&quot;false&quot;
+	&quot;finally&quot;
+	&quot;fixed&quot;
+	&quot;float&quot;
+	&quot;for&quot;
+	&quot;foreach&quot;
+	&quot;goto&quot;
+	&quot;if&quot;
+	&quot;implicit&quot;
+	&quot;in&quot;
+	&quot;int&quot;
+	&quot;interface&quot;
+	&quot;internal&quot;
+	&quot;is&quot;
+	&quot;lock&quot;
+	&quot;long&quot;
+	&quot;namespace&quot;
+	&quot;new&quot;
+	&quot;null&quot;
+	&quot;object&quot;
+	&quot;operator&quot;
+	&quot;out&quot;
+	&quot;override&quot;
+	&quot;params&quot;
+	&quot;private&quot;
+	&quot;protected&quot;
+	&quot;public&quot;
+	&quot;readonly&quot;
+	&quot;ref&quot;
+	&quot;return&quot;
+	&quot;sbyte&quot;
+	&quot;sealed&quot;
+	&quot;short&quot;
+	&quot;sizeof&quot;
+	&quot;stackalloc&quot;
+	&quot;static&quot;
+	&quot;string&quot;
+	&quot;struct&quot;
+	&quot;switch&quot;
+	&quot;this&quot;
+	&quot;throw&quot;
+	&quot;true&quot;
+	&quot;try&quot;
+	&quot;typeof&quot;
+	&quot;uint&quot;
+	&quot;ulong&quot;
+	&quot;unchecked&quot;
+	&quot;unsafe&quot;
+	&quot;ushort&quot;
+	&quot;using&quot;
+	&quot;virtual&quot;
+	&quot;void&quot;
+	&quot;volatile&quot;
+	&quot;while&quot;
+/* END AUTOGENERATED TOKENS SECTION */

Added: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/BuildKeywords.pl
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/BuildKeywords.pl	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/BuildKeywords.pl	2004-03-21 06:22:28 UTC (rev 1213)
@@ -0,0 +1,227 @@
+#!/bin/perl
+
+# File names
+$keyword_file     = &quot;CSharpKeywordList.txt&quot;;
+$keywords_outfile = &quot;Keywords.cs&quot;;
+$tokens_outfile   = &quot;Tokens.cs&quot;;
+$ATGTokensSection = &quot;ATGTokensSection.gen&quot;;
+
+#read infile
+print &quot;\n&quot;;
+print &quot;Reading keyword definition from '$keyword_file'.\n&quot;;
+open(DAT, $keyword_file) || die(&quot;Could not open file!&quot;);
<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">+ at raw_data</A>=&lt;DAT&gt;;
+close(DAT);
+print &quot;done.\n&quot;;
+
+#analyse infile
+print &quot;starting analysation ... this could take a few minutes.\n&quot;;
+
+foreach (@raw_data) {
+	if ($_=~/\A\s*\$(\w+)\s*=\s*(\S+)/) {
+		#properties form: $PROPERTY = &quot;VALUE&quot;
+		$properties{$1} = $2;
+	} elsif  ($_=~/\A\s*(\w+)\s*=\s*\&quot;(\S+)\&quot;/) {
+		#special characters form: name = &quot;VALUE&quot;
+		$special_chars[$#special_chars + 1] = $1;
+		$special_values[$#special_values + 1] = $2;
+	} elsif  ($_=~/\A\s*\&quot;(\S+)\s*\&quot;/) {
+		#special keywords form: &quot;VALUE&quot;
+		$keywords[$#keywords + 1] = $1
+	} elsif  ($_=~/\A\s*(\w+)\s*/) {
+		#special terminal classes form: name
+		$terminals[$#terminals + 1] = $1
+	}
+}
+
+for ($i=0; $i &lt;= $#keywords; $i++) {
+	$upperKeywords[$i] = uc $keywords[$i];
+}
+sort (ascend @upperKeywords);
+
+
+sort (ascend @keywords);
+print &quot;done.\n&quot;;
+
+#write output
+print &quot;writing output files.\nIf your computer doesn&#146;t respond, then press \&quot;Ctrl-Alt-Delete\&quot;\n&quot;;
+print &quot;\n&quot;;
+&amp;write_keywordfile;
+print &quot;\n&quot;;
+&amp;write_tokensfile;
+print &quot;\n&quot;;
+&amp;write_atgtokensfile;
+print &quot;\n&quot;;
+print &quot;finished.\n&quot;;
+
+sub write_keywordfile {
+	print &quot;  -&gt;Generating Keywords class to file '$keywords_outfile'\n&quot;;
+	open(DAT,&quot;&gt;$keywords_outfile&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
+	print DAT &quot;using System;\n&quot;;
+	print DAT &quot;using System.Collections;\n&quot;;
+	print DAT &quot;using System.Text;\n&quot;;
+	print DAT &quot;\n&quot;;
+	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
+	print DAT &quot;{\n&quot;;
+	print DAT &quot;	public class Keywords\n&quot;;
+	print DAT &quot;	{\n&quot;;
+	print DAT &quot;		static readonly string[] keywordList = {\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		for ($i=0; $i &lt;= $#upperKeywords; $i++) {
+			print DAT &quot;			\&quot;$upperKeywords[$i]\&quot;&quot;;
+			if ($i + 1 &lt;= $#upperKeywords) {
+				print DAT &quot;,&quot;;
+			}
+			print DAT &quot;\n&quot;;
+		}
+	} else {
+		for ($i=0; $i &lt;= $#keywords; $i++) {
+			print DAT &quot;			\&quot;$keywords[$i]\&quot;&quot;;
+			if ($i + 1 &lt;= $#keywords) {
+				print DAT &quot;,&quot;;
+			}
+			print DAT &quot;\n&quot;;
+		}
+	}
+	
+	print DAT &quot;		};\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		static Hashtable keywords = new Hashtable();\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		static Keywords()\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	print DAT &quot;			for (int i = 0; i &lt; keywordList.Length; ++i) {\n&quot;;
+	$up = ucfirst($keywords[0]);
+	print DAT &quot;				keywords.Add(keywordList[i], i + Tokens.$up);\n&quot;;
+	print DAT &quot;			}\n&quot;;
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		public static bool IsKeyword(string identifier)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		print DAT &quot;			return keywords[identifier.ToUpper()] != null;\n&quot;;
+	} else {
+		print DAT &quot;			return keywords[identifier] != null;\n&quot;;
+	}
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;		\n&quot;;
+	print DAT &quot;		public static int GetToken(string keyword)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	if ($properties{'UpperCaseKeywords'} eq &quot;True&quot;) {
+		print DAT &quot;			return (int)keywords[keyword.ToUpper()];\n&quot;;
+	} else {
+		print DAT &quot;			return (int)keywords[keyword];\n&quot;;
+	}
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;	}\n&quot;;
+	print DAT &quot;}\n&quot;;
+	
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+
+sub write_token {
+	$formattedString = sprintf(&quot;%-20s&quot;, ucfirst($tokenName));
+	if ($tokenName eq &quot;GetType&quot;) {
+		print DAT &quot;		new public const int $formattedString = $tokenValue;&quot;;
+	} else {
+		print DAT &quot;		public const int $formattedString = $tokenValue;&quot;;
+	}
+	$tokenValue++;
+	
+}
+
+sub write_tokensfile {
+	print &quot;  -&gt;Generating Tokens class to file '$tokens_outfile'\n&quot;;
+	open(DAT,&quot;&gt;$tokens_outfile&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;// this file was autogenerated by a tool.\n&quot;;
+	print DAT &quot;using System;\n&quot;;
+	print DAT &quot;\n&quot;;
+	print DAT &quot;namespace &quot; . $properties{'Namespace'} . &quot;\n&quot;;
+	print DAT &quot;{\n&quot;;
+	print DAT &quot;	public sealed class Tokens\n&quot;;
+	print DAT &quot;	{\n&quot;;
+	$tokenValue = 0;
+	
+	print DAT &quot;		// ----- terminal classes -----\n&quot;;
+	foreach (@terminals) {
+		$tokenName = $_;
+		write_token();
+		print DAT &quot;\n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;		// ----- special character -----\n&quot;;
+	for ($i=0; $i &lt;= $#special_chars; $i++) {
+		$tokenName = $special_chars[$i];
+		write_token();
+		print DAT &quot; // $special_values[$i] \n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;		// ----- keywords -----\n&quot;;
+	foreach (@keywords) {
+		$tokenName = $_;
+		write_token();
+		print DAT &quot;\n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	
+	print DAT &quot;		public static string GetTokenString(int token)\n&quot;;
+	print DAT &quot;		{\n&quot;;
+	print DAT &quot;			switch (token) {\n&quot;;
+	for ($i = 0; $i &lt;= $#special_chars; $i++) {
+		print DAT &quot;				case $special_chars[$i]:\n&quot;;
+		print DAT &quot;					return \&quot;$special_values[$i]\&quot;;\n&quot;;
+	}
+	foreach (@keywords) {
+		$up = ucfirst($_);
+		print DAT &quot;				case $up:\n&quot;;
+		print DAT &quot;					return \&quot;$_\&quot;;\n&quot;;
+	}
+	
+	print DAT &quot;			}\n&quot;;
+	print DAT &quot;			throw new System.NotSupportedException(\&quot;Unknown token:\&quot; + token);\n&quot;;
+	print DAT &quot;		}\n&quot;;
+	print DAT &quot;	}\n&quot;;
+	
+	
+	
+	print DAT &quot;}\n&quot;;
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+
+sub write_atgtokensfile {
+	print &quot;  -&gt;Generating ATG TOKENS section and writing it to file '$ATGTokensSection'\n&quot;;
+	open(DAT,&quot;&gt;$ATGTokensSection&quot;) || die(&quot;Cannot Open File&quot;);
+	print DAT &quot;/* START AUTOGENERATED TOKENS SECTION */\n&quot;;
+	print DAT &quot;TOKENS\n&quot;;
+
+	print DAT &quot;	/* ----- terminal classes ----- */\n&quot;;
+	print DAT &quot;	/* EOF is 0 */\n&quot;;
+	foreach $term (@terminals) {
+		if ($term eq &quot;EOF&quot;) {
+		} elsif ($term eq &quot;Identifier&quot;) {
+			print DAT &quot;\tident\n&quot;;
+		} else {
+			print DAT &quot;\t$term\n&quot;;
+		}
+			
+	}
+	
+	print DAT &quot;\n&quot;;
+	print DAT &quot;	/* ----- special character ----- */\n&quot;;
+	foreach (@special_values) {
+		print DAT &quot;\t\&quot;$_\&quot;\n&quot;;
+	}
+	print DAT &quot;\n&quot;;
+	print DAT &quot;	/* ----- keywords ----- */\n&quot;;
+	foreach (@keywords) {
+		print DAT &quot;\t\&quot;$_\&quot;\n&quot;;
+	}
+
+	print DAT &quot;/* END AUTOGENERATED TOKENS SECTION */\n&quot;;
+	close(DAT);
+	print &quot;  -&gt;done.\n&quot;;
+}
+

Added: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/CSharpKeywordList.txt
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/CSharpKeywordList.txt	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/CSharpKeywordList.txt	2004-03-21 06:22:28 UTC (rev 1213)
@@ -0,0 +1,151 @@
+# this list is used for autogeneration of:
+# - Keywords.cs
+# - Tokens.cs
+# - ATGTokensSection.txt - the TOKENS section of the ATG file
+
+# use BuildKeywords to generate the different lists.
+
+$Namespace=ICSharpCode.SharpRefactory.Parser
+$UpperCaseKeywords=False
+
+
+# TERMINAL_CLASSES
+EOF
+Identifier
+Literal
+
+# SPECIAL_CHARACTERS
+Assign = &quot;=&quot;
+Plus = &quot;+&quot;
+Minus = &quot;-&quot;
+Times = &quot;*&quot;
+Div = &quot;/&quot;
+Mod = &quot;%&quot;
+		
+Colon = &quot;:&quot;
+Semicolon = &quot;;&quot;
+Question = &quot;?&quot;
+Comma = &quot;,&quot;
+Dot = &quot;.&quot;
+	
+OpenCurlyBrace = &quot;{&quot;
+CloseCurlyBrace = &quot;}&quot;
+
+OpenSquareBracket = &quot;[&quot;
+CloseSquareBracket = &quot;]&quot;
+
+OpenParenthesis = &quot;(&quot;
+CloseParenthesis = &quot;)&quot;
+
+GreaterThan = &quot;&gt;&quot;
+LessThan = &quot;&lt;&quot;
+		
+Not = &quot;!&quot;
+LogicalAnd = &quot;&amp;&amp;&quot;
+LogicalOr = &quot;||&quot;
+		
+BitwiseComplement = &quot;~&quot;
+BitwiseAnd = &quot;&amp;&quot;
+BitwiseOr = &quot;|&quot;
+Xor = &quot;^&quot;
+
+Increment = &quot;++&quot;
+Decrement = &quot;--&quot;
+Equal = &quot;==&quot;
+NotEqual = &quot;!=&quot;
+GreaterEqual = &quot;&gt;=&quot;
+LessEqual = &quot;&lt;=&quot;
+		
+ShiftLeft = &quot;&lt;&lt;&quot;
+ShiftRight = &quot;&gt;&gt;&quot;
+		
+PlusAssign = &quot;+=&quot;
+MinusAssign = &quot;-=&quot;
+TimesAssign = &quot;*=&quot;
+DivAssign = &quot;/=&quot;
+ModAssign = &quot;%=&quot;
+BitwiseAndAssign = &quot;&amp;=&quot;
+BitwiseOrAssign = &quot;|=&quot;
+XorAssign = &quot;^=&quot;
+ShiftLeftAssign = &quot;&lt;&lt;=&quot;
+ShiftRightAssign = &quot;&gt;&gt;=&quot;
+Pointer = &quot;-&gt;&quot;
+
+# Keywordlist
+&quot;abstract&quot;
+&quot;as&quot;
+&quot;base&quot;
+&quot;bool&quot;
+&quot;break&quot;
+&quot;byte&quot;
+&quot;case&quot;
+&quot;catch&quot;
+&quot;char&quot;
+&quot;checked&quot;
+&quot;class&quot;
+&quot;const&quot;
+&quot;continue&quot;
+&quot;decimal&quot;
+&quot;default&quot;
+&quot;delegate&quot;
+&quot;do&quot;
+&quot;double&quot;
+&quot;else&quot;
+&quot;enum&quot;
+&quot;event&quot;
+&quot;explicit&quot;
+&quot;extern&quot;
+&quot;false&quot;
+&quot;finally&quot;
+&quot;fixed&quot;
+&quot;float&quot;
+&quot;for&quot;
+&quot;foreach&quot;
+&quot;goto&quot;
+&quot;if&quot;
+&quot;implicit&quot;
+&quot;in&quot;
+&quot;int&quot;
+&quot;interface&quot;
+&quot;internal&quot;
+&quot;is&quot;
+&quot;lock&quot;
+&quot;long&quot;
+&quot;namespace&quot;
+&quot;new&quot;
+&quot;null&quot;
+&quot;object&quot;
+&quot;operator&quot;
+&quot;out&quot;
+&quot;override&quot;
+&quot;params&quot;
+&quot;private&quot;
+&quot;protected&quot;
+&quot;public&quot;
+&quot;readonly&quot;
+&quot;ref&quot;
+&quot;return&quot;
+&quot;sbyte&quot;
+&quot;sealed&quot;
+&quot;short&quot;
+&quot;sizeof&quot;
+&quot;stackalloc&quot;
+&quot;static&quot;
+&quot;string&quot;
+&quot;struct&quot;
+&quot;switch&quot;
+&quot;this&quot;
+&quot;throw&quot;
+&quot;true&quot;
+&quot;try&quot;
+&quot;typeof&quot;
+&quot;uint&quot;
+&quot;ulong&quot;
+&quot;unchecked&quot;
+&quot;unsafe&quot;
+&quot;ushort&quot;
+&quot;using&quot;
+&quot;virtual&quot;
+&quot;void&quot;
+&quot;volatile&quot;
+&quot;while&quot;

Added: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/Keywords.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/Keywords.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/Keywords.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -0,0 +1,109 @@
+// this file was autogenerated by a tool.
+using System;
+using System.Collections;
+using System.Text;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public class Keywords
+	{
+		static readonly string[] keywordList = {
+			&quot;abstract&quot;,
+			&quot;as&quot;,
+			&quot;base&quot;,
+			&quot;bool&quot;,
+			&quot;break&quot;,
+			&quot;byte&quot;,
+			&quot;case&quot;,
+			&quot;catch&quot;,
+			&quot;char&quot;,
+			&quot;checked&quot;,
+			&quot;class&quot;,
+			&quot;const&quot;,
+			&quot;continue&quot;,
+			&quot;decimal&quot;,
+			&quot;default&quot;,
+			&quot;delegate&quot;,
+			&quot;do&quot;,
+			&quot;double&quot;,
+			&quot;else&quot;,
+			&quot;enum&quot;,
+			&quot;event&quot;,
+			&quot;explicit&quot;,
+			&quot;extern&quot;,
+			&quot;false&quot;,
+			&quot;finally&quot;,
+			&quot;fixed&quot;,
+			&quot;float&quot;,
+			&quot;for&quot;,
+			&quot;foreach&quot;,
+			&quot;goto&quot;,
+			&quot;if&quot;,
+			&quot;implicit&quot;,
+			&quot;in&quot;,
+			&quot;int&quot;,
+			&quot;interface&quot;,
+			&quot;internal&quot;,
+			&quot;is&quot;,
+			&quot;lock&quot;,
+			&quot;long&quot;,
+			&quot;namespace&quot;,
+			&quot;new&quot;,
+			&quot;null&quot;,
+			&quot;object&quot;,
+			&quot;operator&quot;,
+			&quot;out&quot;,
+			&quot;override&quot;,
+			&quot;params&quot;,
+			&quot;private&quot;,
+			&quot;protected&quot;,
+			&quot;public&quot;,
+			&quot;readonly&quot;,
+			&quot;ref&quot;,
+			&quot;return&quot;,
+			&quot;sbyte&quot;,
+			&quot;sealed&quot;,
+			&quot;short&quot;,
+			&quot;sizeof&quot;,
+			&quot;stackalloc&quot;,
+			&quot;static&quot;,
+			&quot;string&quot;,
+			&quot;struct&quot;,
+			&quot;switch&quot;,
+			&quot;this&quot;,
+			&quot;throw&quot;,
+			&quot;true&quot;,
+			&quot;try&quot;,
+			&quot;typeof&quot;,
+			&quot;uint&quot;,
+			&quot;ulong&quot;,
+			&quot;unchecked&quot;,
+			&quot;unsafe&quot;,
+			&quot;ushort&quot;,
+			&quot;using&quot;,
+			&quot;virtual&quot;,
+			&quot;void&quot;,
+			&quot;volatile&quot;,
+			&quot;while&quot;
+		};
+		
+		static Hashtable keywords = new Hashtable();
+		
+		static Keywords()
+		{
+			for (int i = 0; i &lt; keywordList.Length; ++i) {
+				keywords.Add(keywordList[i], i + Tokens.Abstract);
+			}
+		}
+		
+		public static bool IsKeyword(string identifier)
+		{
+			return keywords[identifier] != null;
+		}
+		
+		public static int GetToken(string keyword)
+		{
+			return (int)keywords[keyword];
+		}
+	}
+}

Added: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/Tokens.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/Tokens.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/Parser/generated/keywordlist/Tokens.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -0,0 +1,390 @@
+// this file was autogenerated by a tool.
+using System;
+
+namespace ICSharpCode.SharpRefactory.Parser
+{
+	public sealed class Tokens
+	{
+		// ----- terminal classes -----
+		public const int EOF                  = 0;
+		public const int Identifier           = 1;
+		public const int Literal              = 2;
+
+		// ----- special character -----
+		public const int Assign               = 3; // = 
+		public const int Plus                 = 4; // + 
+		public const int Minus                = 5; // - 
+		public const int Times                = 6; // * 
+		public const int Div                  = 7; // / 
+		public const int Mod                  = 8; // % 
+		public const int Colon                = 9; // : 
+		public const int Semicolon            = 10; // ; 
+		public const int Question             = 11; // ? 
+		public const int Comma                = 12; // , 
+		public const int Dot                  = 13; // . 
+		public const int OpenCurlyBrace       = 14; // { 
+		public const int CloseCurlyBrace      = 15; // } 
+		public const int OpenSquareBracket    = 16; // [ 
+		public const int CloseSquareBracket   = 17; // ] 
+		public const int OpenParenthesis      = 18; // ( 
+		public const int CloseParenthesis     = 19; // ) 
+		public const int GreaterThan          = 20; // &gt; 
+		public const int LessThan             = 21; // &lt; 
+		public const int Not                  = 22; // ! 
+		public const int LogicalAnd           = 23; // &amp;&amp; 
+		public const int LogicalOr            = 24; // || 
+		public const int BitwiseComplement    = 25; // ~ 
+		public const int BitwiseAnd           = 26; // &amp; 
+		public const int BitwiseOr            = 27; // | 
+		public const int Xor                  = 28; // ^ 
+		public const int Increment            = 29; // ++ 
+		public const int Decrement            = 30; // -- 
+		public const int Equal                = 31; // == 
+		public const int NotEqual             = 32; // != 
+		public const int GreaterEqual         = 33; // &gt;= 
+		public const int LessEqual            = 34; // &lt;= 
+		public const int ShiftLeft            = 35; // &lt;&lt; 
+		public const int ShiftRight           = 36; // &gt;&gt; 
+		public const int PlusAssign           = 37; // += 
+		public const int MinusAssign          = 38; // -= 
+		public const int TimesAssign          = 39; // *= 
+		public const int DivAssign            = 40; // /= 
+		public const int ModAssign            = 41; // %= 
+		public const int BitwiseAndAssign     = 42; // &amp;= 
+		public const int BitwiseOrAssign      = 43; // |= 
+		public const int XorAssign            = 44; // ^= 
+		public const int ShiftLeftAssign      = 45; // &lt;&lt;= 
+		public const int ShiftRightAssign     = 46; // &gt;&gt;= 
+		public const int Pointer              = 47; // -&gt; 
+
+		// ----- keywords -----
+		public const int Abstract             = 48;
+		public const int As                   = 49;
+		public const int Base                 = 50;
+		public const int Bool                 = 51;
+		public const int Break                = 52;
+		public const int Byte                 = 53;
+		public const int Case                 = 54;
+		public const int Catch                = 55;
+		public const int Char                 = 56;
+		public const int Checked              = 57;
+		public const int Class                = 58;
+		public const int Const                = 59;
+		public const int Continue             = 60;
+		public const int Decimal              = 61;
+		public const int Default              = 62;
+		public const int Delegate             = 63;
+		public const int Do                   = 64;
+		public const int Double               = 65;
+		public const int Else                 = 66;
+		public const int Enum                 = 67;
+		public const int Event                = 68;
+		public const int Explicit             = 69;
+		public const int Extern               = 70;
+		public const int False                = 71;
+		public const int Finally              = 72;
+		public const int Fixed                = 73;
+		public const int Float                = 74;
+		public const int For                  = 75;
+		public const int Foreach              = 76;
+		public const int Goto                 = 77;
+		public const int If                   = 78;
+		public const int Implicit             = 79;
+		public const int In                   = 80;
+		public const int Int                  = 81;
+		public const int Interface            = 82;
+		public const int Internal             = 83;
+		public const int Is                   = 84;
+		public const int Lock                 = 85;
+		public const int Long                 = 86;
+		public const int Namespace            = 87;
+		public const int New                  = 88;
+		public const int Null                 = 89;
+		public const int Object               = 90;
+		public const int Operator             = 91;
+		public const int Out                  = 92;
+		public const int Override             = 93;
+		public const int Params               = 94;
+		public const int Private              = 95;
+		public const int Protected            = 96;
+		public const int Public               = 97;
+		public const int Readonly             = 98;
+		public const int Ref                  = 99;
+		public const int Return               = 100;
+		public const int Sbyte                = 101;
+		public const int Sealed               = 102;
+		public const int Short                = 103;
+		public const int Sizeof               = 104;
+		public const int Stackalloc           = 105;
+		public const int Static               = 106;
+		public const int String               = 107;
+		public const int Struct               = 108;
+		public const int Switch               = 109;
+		public const int This                 = 110;
+		public const int Throw                = 111;
+		public const int True                 = 112;
+		public const int Try                  = 113;
+		public const int Typeof               = 114;
+		public const int Uint                 = 115;
+		public const int Ulong                = 116;
+		public const int Unchecked            = 117;
+		public const int Unsafe               = 118;
+		public const int Ushort               = 119;
+		public const int Using                = 120;
+		public const int Virtual              = 121;
+		public const int Void                 = 122;
+		public const int Volatile             = 123;
+		public const int While                = 124;
+
+		public static string GetTokenString(int token)
+		{
+			switch (token) {
+				case Assign:
+					return &quot;=&quot;;
+				case Plus:
+					return &quot;+&quot;;
+				case Minus:
+					return &quot;-&quot;;
+				case Times:
+					return &quot;*&quot;;
+				case Div:
+					return &quot;/&quot;;
+				case Mod:
+					return &quot;%&quot;;
+				case Colon:
+					return &quot;:&quot;;
+				case Semicolon:
+					return &quot;;&quot;;
+				case Question:
+					return &quot;?&quot;;
+				case Comma:
+					return &quot;,&quot;;
+				case Dot:
+					return &quot;.&quot;;
+				case OpenCurlyBrace:
+					return &quot;{&quot;;
+				case CloseCurlyBrace:
+					return &quot;}&quot;;
+				case OpenSquareBracket:
+					return &quot;[&quot;;
+				case CloseSquareBracket:
+					return &quot;]&quot;;
+				case OpenParenthesis:
+					return &quot;(&quot;;
+				case CloseParenthesis:
+					return &quot;)&quot;;
+				case GreaterThan:
+					return &quot;&gt;&quot;;
+				case LessThan:
+					return &quot;&lt;&quot;;
+				case Not:
+					return &quot;!&quot;;
+				case LogicalAnd:
+					return &quot;&amp;&amp;&quot;;
+				case LogicalOr:
+					return &quot;||&quot;;
+				case BitwiseComplement:
+					return &quot;~&quot;;
+				case BitwiseAnd:
+					return &quot;&amp;&quot;;
+				case BitwiseOr:
+					return &quot;|&quot;;
+				case Xor:
+					return &quot;^&quot;;
+				case Increment:
+					return &quot;++&quot;;
+				case Decrement:
+					return &quot;--&quot;;
+				case Equal:
+					return &quot;==&quot;;
+				case NotEqual:
+					return &quot;!=&quot;;
+				case GreaterEqual:
+					return &quot;&gt;=&quot;;
+				case LessEqual:
+					return &quot;&lt;=&quot;;
+				case ShiftLeft:
+					return &quot;&lt;&lt;&quot;;
+				case ShiftRight:
+					return &quot;&gt;&gt;&quot;;
+				case PlusAssign:
+					return &quot;+=&quot;;
+				case MinusAssign:
+					return &quot;-=&quot;;
+				case TimesAssign:
+					return &quot;*=&quot;;
+				case DivAssign:
+					return &quot;/=&quot;;
+				case ModAssign:
+					return &quot;%=&quot;;
+				case BitwiseAndAssign:
+					return &quot;&amp;=&quot;;
+				case BitwiseOrAssign:
+					return &quot;|=&quot;;
+				case XorAssign:
+					return &quot;^=&quot;;
+				case ShiftLeftAssign:
+					return &quot;&lt;&lt;=&quot;;
+				case ShiftRightAssign:
+					return &quot;&gt;&gt;=&quot;;
+				case Pointer:
+					return &quot;-&gt;&quot;;
+				case Abstract:
+					return &quot;abstract&quot;;
+				case As:
+					return &quot;as&quot;;
+				case Base:
+					return &quot;base&quot;;
+				case Bool:
+					return &quot;bool&quot;;
+				case Break:
+					return &quot;break&quot;;
+				case Byte:
+					return &quot;byte&quot;;
+				case Case:
+					return &quot;case&quot;;
+				case Catch:
+					return &quot;catch&quot;;
+				case Char:
+					return &quot;char&quot;;
+				case Checked:
+					return &quot;checked&quot;;
+				case Class:
+					return &quot;class&quot;;
+				case Const:
+					return &quot;const&quot;;
+				case Continue:
+					return &quot;continue&quot;;
+				case Decimal:
+					return &quot;decimal&quot;;
+				case Default:
+					return &quot;default&quot;;
+				case Delegate:
+					return &quot;delegate&quot;;
+				case Do:
+					return &quot;do&quot;;
+				case Double:
+					return &quot;double&quot;;
+				case Else:
+					return &quot;else&quot;;
+				case Enum:
+					return &quot;enum&quot;;
+				case Event:
+					return &quot;event&quot;;
+				case Explicit:
+					return &quot;explicit&quot;;
+				case Extern:
+					return &quot;extern&quot;;
+				case False:
+					return &quot;false&quot;;
+				case Finally:
+					return &quot;finally&quot;;
+				case Fixed:
+					return &quot;fixed&quot;;
+				case Float:
+					return &quot;float&quot;;
+				case For:
+					return &quot;for&quot;;
+				case Foreach:
+					return &quot;foreach&quot;;
+				case Goto:
+					return &quot;goto&quot;;
+				case If:
+					return &quot;if&quot;;
+				case Implicit:
+					return &quot;implicit&quot;;
+				case In:
+					return &quot;in&quot;;
+				case Int:
+					return &quot;int&quot;;
+				case Interface:
+					return &quot;interface&quot;;
+				case Internal:
+					return &quot;internal&quot;;
+				case Is:
+					return &quot;is&quot;;
+				case Lock:
+					return &quot;lock&quot;;
+				case Long:
+					return &quot;long&quot;;
+				case Namespace:
+					return &quot;namespace&quot;;
+				case New:
+					return &quot;new&quot;;
+				case Null:
+					return &quot;null&quot;;
+				case Object:
+					return &quot;object&quot;;
+				case Operator:
+					return &quot;operator&quot;;
+				case Out:
+					return &quot;out&quot;;
+				case Override:
+					return &quot;override&quot;;
+				case Params:
+					return &quot;params&quot;;
+				case Private:
+					return &quot;private&quot;;
+				case Protected:
+					return &quot;protected&quot;;
+				case Public:
+					return &quot;public&quot;;
+				case Readonly:
+					return &quot;readonly&quot;;
+				case Ref:
+					return &quot;ref&quot;;
+				case Return:
+					return &quot;return&quot;;
+				case Sbyte:
+					return &quot;sbyte&quot;;
+				case Sealed:
+					return &quot;sealed&quot;;
+				case Short:
+					return &quot;short&quot;;
+				case Sizeof:
+					return &quot;sizeof&quot;;
+				case Stackalloc:
+					return &quot;stackalloc&quot;;
+				case Static:
+					return &quot;static&quot;;
+				case String:
+					return &quot;string&quot;;
+				case Struct:
+					return &quot;struct&quot;;
+				case Switch:
+					return &quot;switch&quot;;
+				case This:
+					return &quot;this&quot;;
+				case Throw:
+					return &quot;throw&quot;;
+				case True:
+					return &quot;true&quot;;
+				case Try:
+					return &quot;try&quot;;
+				case Typeof:
+					return &quot;typeof&quot;;
+				case Uint:
+					return &quot;uint&quot;;
+				case Ulong:
+					return &quot;ulong&quot;;
+				case Unchecked:
+					return &quot;unchecked&quot;;
+				case Unsafe:
+					return &quot;unsafe&quot;;
+				case Ushort:
+					return &quot;ushort&quot;;
+				case Using:
+					return &quot;using&quot;;
+				case Virtual:
+					return &quot;virtual&quot;;
+				case Void:
+					return &quot;void&quot;;
+				case Volatile:
+					return &quot;volatile&quot;;
+				case While:
+					return &quot;while&quot;;
+			}
+			return &quot;&lt;unknown&gt;&quot;;
+		}
+	}
+}

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/OutputFormatter.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/OutputFormatter.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/OutputFormatter.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -20,22 +20,50 @@
 using System.Collections;
 using System.Diagnostics;
 
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.PrettyPrinter
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
 {
 	public class OutputFormatter
 	{
-		int indentationLevel     = 0;
-		StringBuilder text       = new StringBuilder();
-		
+		int           indentationLevel = 0;
+		StringBuilder text             = new StringBuilder();
+		Lexer         lexer; 
+		bool          indent       = true;
+		bool          doNewLine      = true;
+		bool          emitSemicolon = true;
 		public string Text {
 			get {
 				return text.ToString();
 			}
 		}
 		
+		public bool DoIndent {
+			get {
+				return indent;
+			}
+			set {
+				indent = value;
+			}
+		}
+		public bool DoNewLine {
+			get {
+				return doNewLine;
+			}
+			set {
+				doNewLine = value;
+			}
+		}
+		public bool EmitSemicolon {
+			get {
+				return emitSemicolon;
+			}
+			set {
+				emitSemicolon = value;
+			}
+		}
+		
 		public int IndentationLevel {
 			get {
 				return indentationLevel;
@@ -44,11 +72,20 @@
 				indentationLevel = value;
 			}
 		}
+		Token token;
+		public OutputFormatter(string originalSourceFile)
+		{
+			lexer = new Lexer(new StringReader(originalSourceFile));
+//			token = lexer.NextToken();
+//			PrintSpecials(token.kind);
+		}
 		
 		public void Indent()
 		{
-			for (int i = 0; i &lt; indentationLevel; ++i) {
-				text.Append('\t');
+			if (DoIndent) {
+				for (int i = 0; i &lt; indentationLevel; ++i) {
+					text.Append('\t');
+				}
 			}
 		}
 		
@@ -56,24 +93,127 @@
 		{
 			text.Append(' ');
 		}
+		bool gotBlankLine  = false;
+		int currentSpecial = 0;
 		
+		void PrintSpecials(int tokenKind)
+		{
+			if (currentSpecial &gt;= lexer.SpecialTracker.CurrentSpecials.Count) {
+				return;
+			}
+			object o = lexer.SpecialTracker.CurrentSpecials[currentSpecial++];
+			if (o is Comment) {
+//				Console.WriteLine(&quot;COMMENT &quot; + o);	
+				Comment comment = (Comment)o;
+				switch (comment.CommentType) {
+					case CommentType.SingleLine:
+						text.Append(&quot;//&quot;);	
+						text.Append(comment.CommentText);	
+						text.Append(&quot;\n&quot;);
+						Indent();
+						break;
+					case CommentType.Documentation:
+						text.Append(&quot;///&quot;);	
+						text.Append(comment.CommentText);	
+						text.Append(&quot;\n&quot;);	
+						Indent();
+						break;
+					case CommentType.Block:
+						text.Append(&quot;/*&quot;);	
+						text.Append(comment.CommentText);	
+						text.Append(&quot;*/\n&quot;);	
+						Indent();
+						break;
+				}
+				PrintSpecials(tokenKind);
+			} else if (o is BlankLine) {
+				if (!gotBlankLine) {
+//						text.Append(&quot;\n&quot;);
+//						Indent();
+				} 
+				gotBlankLine = false;
+				PrintSpecials(tokenKind);
+			} else if (o is PreProcessingDirective) { 
+//				Console.WriteLine(&quot;PPD:&quot; + o);	
+				text.Append(&quot;\n&quot;);
+				PreProcessingDirective ppd = (PreProcessingDirective)o;
+				text.Append(ppd.Cmd);
+				if (ppd.Arg != null &amp;&amp; ppd.Arg.Length &gt; 0) {
+					text.Append(&quot; &quot;);
+					text.Append(ppd.Arg);
+				}
+				text.Append(&quot;\n&quot;);
+				Indent();
+				PrintSpecials(tokenKind);
+			} else {
+				int kind = (int)o;
+//				Console.WriteLine(kind + &quot; -- &quot; + Tokens.GetTokenString(kind));
+				if (kind != tokenKind) {
+					PrintSpecials(tokenKind);
+				}
+			}
+		}
+		
 		public void NewLine()
 		{
-			text.Append(&quot;\n&quot;);
+			if (DoNewLine) {
+				text.Append(&quot;\n&quot;);
+				gotBlankLine = true;
+			}
 		}
 		
+		public void EndFile()
+		{
+			while (this.token == null || this.token.kind &gt; 0) {
+				this.token = lexer.NextToken();
+				PrintSpecials(token.kind);
+			}
+			PrintSpecials(-1);
+//			foreach (object o in lexer.SpecialTracker.CurrentSpecials) {
+//				Console.WriteLine(o);
+//			}
+		}
+		
+		public void PrintTokenList(ArrayList tokenList)
+		{
+			ArrayList trackList = (ArrayList)tokenList.Clone();
+			while (this.token == null || trackList.Count &gt; 0) {
+				this.token = lexer.NextToken();
+				PrintSpecials(this.token.kind);
+				for (int i = 0; i &lt; trackList.Count; ++i) {
+					trackList.RemoveAt(i);
+					break;
+				}
+			}
+			foreach (int token in tokenList) {
+				text.Append(Tokens.GetTokenString(token));
+				Space();
+			}
+		}
+		
 		public void PrintToken(int token)
 		{
+//			Console.WriteLine(&quot;PRINT TOKEN:&quot; + token);
+			if (token == Tokens.Semicolon &amp;&amp; !EmitSemicolon) {
+				return;
+			}
+			while (this.token == null || this.token.kind &gt; 0) {
+				this.token = lexer.NextToken();
+				PrintSpecials(this.token.kind);
+				if (this.token.kind == token) {
+					break;
+				}
+			}
+			text.Append(Tokens.GetTokenString(token));
+			gotBlankLine = false;
 		}
 		
+		
 		public void PrintIdentifier(string identifier)
 		{
+			this.token = lexer.NextToken();
+			PrintSpecials(token.kind);
 			text.Append(identifier);
 		}
-		
-		public void PrintTrailingComment()
-		{
-			
-		}
 	}
 }

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintData.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintData.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintData.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -17,10 +17,10 @@
 
 using System;
 using System.Text;
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.PrettyPrinter
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
 {
 	/*
 	public class PrettyPrintData

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintUtil.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintUtil.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintUtil.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,10 +19,10 @@
 using System.Collections;
 using System.Diagnostics;
 
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.PrettyPrinter
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
 {
 	/*
 	public sealed class PrettyPrintUtil

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/PrettyPrintVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -20,15 +20,15 @@
 using System.Collections;
 using System.Diagnostics;
 
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.PrettyPrinter
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
 {
-	public class PrettyPrintVisitor : IASTVisitor
+	public class PrettyPrintVisitor : AbstractASTVisitor
 	{
 		Errors  errors = new Errors();
-		OutputFormatter outputFormatter = new OutputFormatter();
+		OutputFormatter outputFormatter;
 		
 		public string Text {
 			get {
@@ -41,13 +41,20 @@
 			}
 		}
 		
-		public object Visit(INode node, object data)
+		public PrettyPrintVisitor(string originalSourceFile)
 		{
-			errors.Error(-1, -1, String.Format(&quot;Visited INode (should NEVER HAPPEN) Node was : {0} &quot;, node));
+			outputFormatter = new OutputFormatter(originalSourceFile);
+		}
+		
+		public override object Visit(INode node, object data)
+		{
+			errors.Error(-1, -1, String.Format(&quot;Visited INode (should NEVER HAPPEN)&quot;));
+			Console.WriteLine(&quot;Visitor was: &quot; + this.GetType());
+			Console.WriteLine(&quot;Node was : &quot; + node.GetType());
 			return node.AcceptChildren(this, data);
 		}
 		
-		public object Visit(AttributeSection section, object data)
+		public override object Visit(AttributeSection section, object data)
 		{
 			outputFormatter.Indent();
 			outputFormatter.PrintToken(Tokens.OpenSquareBracket);
@@ -57,7 +64,8 @@
 				outputFormatter.Space();
 			}
 			Debug.Assert(section.Attributes != null);
-			foreach (MonoDevelop.SharpRefactory.Parser.AST.Attribute a in section.Attributes) {
+			for (int j = 0; j &lt; section.Attributes.Count; ++j) {
+				ICSharpCode.SharpRefactory.Parser.AST.Attribute a = (ICSharpCode.SharpRefactory.Parser.AST.Attribute)section.Attributes[j];
 				outputFormatter.PrintIdentifier(a.Name);
 				outputFormatter.PrintToken(Tokens.OpenParenthesis);
 				this.AppendCommaSeparatedList(a.PositionalArguments);
@@ -81,32 +89,35 @@
 					}
 				}
 				outputFormatter.PrintToken(Tokens.CloseParenthesis);
+				if (j + 1 &lt; section.Attributes.Count) {
+					outputFormatter.PrintToken(Tokens.Comma);
+					outputFormatter.Space();
+				}
 			}
 			outputFormatter.PrintToken(Tokens.CloseSquareBracket);
-			outputFormatter.PrintTrailingComment();
 			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(CompilationUnit compilationUnit, object data)
+		public override object Visit(CompilationUnit compilationUnit, object data)
 		{
 			compilationUnit.AcceptChildren(this, data);
+			outputFormatter.EndFile();
 			return null;
 		}
 		
-		public object Visit(UsingDeclaration usingDeclaration, object data)
+		public override object Visit(UsingDeclaration usingDeclaration, object data)
 		{
 			outputFormatter.Indent();
 			outputFormatter.PrintToken(Tokens.Using);
 			outputFormatter.Space();
 			outputFormatter.PrintIdentifier(usingDeclaration.Namespace);
 			outputFormatter.PrintToken(Tokens.Semicolon);
-			outputFormatter.PrintTrailingComment();
 			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		public override object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
 		{
 			outputFormatter.Indent();
 			outputFormatter.PrintToken(Tokens.Using);
@@ -117,12 +128,11 @@
 			outputFormatter.Space();
 			outputFormatter.PrintIdentifier(usingAliasDeclaration.Namespace);
 			outputFormatter.PrintToken(Tokens.Semicolon);
-			outputFormatter.PrintTrailingComment();
 			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
 		{
 			outputFormatter.Indent();
 			outputFormatter.PrintToken(Tokens.Namespace);
@@ -143,49 +153,53 @@
 		
 		object VisitModifier(Modifier modifier)
 		{
+			ArrayList tokenList = new ArrayList();
 			if ((modifier &amp; Modifier.Unsafe) != 0) {
-				outputFormatter.PrintToken(Tokens.Unsafe);
+				tokenList.Add(Tokens.Unsafe);
 			}
 			if ((modifier &amp; Modifier.Public) != 0) {
-				outputFormatter.PrintToken(Tokens.Public);
+				tokenList.Add(Tokens.Public);
 			}
 			if ((modifier &amp; Modifier.Private) != 0) {
-				outputFormatter.PrintToken(Tokens.Private);
+				tokenList.Add(Tokens.Private);
 			}
 			if ((modifier &amp; Modifier.Protected) != 0) {
-				outputFormatter.PrintToken(Tokens.Protected);
+				tokenList.Add(Tokens.Protected);
 			}
 			if ((modifier &amp; Modifier.Static) != 0) {
-				outputFormatter.PrintToken(Tokens.Static);
+				tokenList.Add(Tokens.Static);
 			}
 			if ((modifier &amp; Modifier.Internal) != 0) {
-				outputFormatter.PrintToken(Tokens.Internal);
+				tokenList.Add(Tokens.Internal);
 			}
 			if ((modifier &amp; Modifier.Override) != 0) {
-				outputFormatter.PrintToken(Tokens.Override);
+				tokenList.Add(Tokens.Override);
 			}
 			if ((modifier &amp; Modifier.Abstract) != 0) {
-				outputFormatter.PrintToken(Tokens.Abstract);
+				tokenList.Add(Tokens.Abstract);
 			}
+			if ((modifier &amp; Modifier.Virtual) != 0) {
+				tokenList.Add(Tokens.Virtual);
+			}
 			if ((modifier &amp; Modifier.New) != 0) {
-				outputFormatter.PrintToken(Tokens.New);
+				tokenList.Add(Tokens.New);
 			}
 			if ((modifier &amp; Modifier.Sealed) != 0) {
-				outputFormatter.PrintToken(Tokens.Sealed);
+				tokenList.Add(Tokens.Sealed);
 			}
 			if ((modifier &amp; Modifier.Extern) != 0) {
-				outputFormatter.PrintToken(Tokens.Extern);
+				tokenList.Add(Tokens.Extern);
 			}
 			if ((modifier &amp; Modifier.Const) != 0) {
-				outputFormatter.PrintToken(Tokens.Const);
+				tokenList.Add(Tokens.Const);
 			}
 			if ((modifier &amp; Modifier.Readonly) != 0) {
-				outputFormatter.PrintToken(Tokens.Readonly);
+				tokenList.Add(Tokens.Readonly);
 			}
 			if ((modifier &amp; Modifier.Volatile) != 0) {
-				outputFormatter.PrintToken(Tokens.Volatile);
+				tokenList.Add(Tokens.Volatile);
 			}
-			outputFormatter.Space();
+			outputFormatter.PrintTokenList(tokenList);
 			return null;
 		}
 				
@@ -254,9 +268,10 @@
 			return null;
 		}
 		
-		public object Visit(TypeDeclaration typeDeclaration, object data)
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
 		{
 			VisitAttributes(typeDeclaration.Attributes, data);
+			outputFormatter.Indent();
 			VisitModifier(typeDeclaration.Modifier);
 			switch (typeDeclaration.Type) {
 				case Types.Class:
@@ -275,10 +290,15 @@
 			outputFormatter.Space();
 			outputFormatter.PrintIdentifier(typeDeclaration.Name);
 			if (typeDeclaration.BaseTypes != null &amp;&amp; typeDeclaration.BaseTypes.Count &gt; 0) {
+				outputFormatter.Space();
 				outputFormatter.PrintToken(Tokens.Colon);
 				for (int i = 0; i &lt; typeDeclaration.BaseTypes.Count; ++i) {
 					outputFormatter.Space();
 					outputFormatter.PrintIdentifier(typeDeclaration.BaseTypes[i]);
+					if (i + 1 &lt; typeDeclaration.BaseTypes.Count) {
+						outputFormatter.PrintToken(Tokens.Comma);
+						outputFormatter.Space();
+					}
 				}
 			}
 			outputFormatter.NewLine();
@@ -299,7 +319,7 @@
 			return null;
 		}
 		
-		public object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
 		{
 			VisitAttributes(parameterDeclarationExpression.Attributes, data);
 			VisitParamModifiers(parameterDeclarationExpression.ParamModifiers);
@@ -309,7 +329,7 @@
 			return null;
 		}
 		
-		public object Visit(DelegateDeclaration delegateDeclaration, object data)
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
 		{
 			VisitAttributes(delegateDeclaration.Attributes, data);
 			VisitModifier(delegateDeclaration.Modifier);
@@ -326,7 +346,7 @@
 			return null;
 		}
 		
-		public object Visit(VariableDeclaration variableDeclaration, object data)
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
 		{
 			outputFormatter.PrintIdentifier(variableDeclaration.Name);
 			if (variableDeclaration.Initializer != null) {
@@ -347,976 +367,1202 @@
 						outputFormatter.PrintToken(Tokens.Comma);
 						outputFormatter.Space();
 					}
+					if ((i + 1) % 10 == 0) {
+						outputFormatter.NewLine();
+						outputFormatter.Indent();
+					}
 				}
 			}
 		}
 		
-		public object Visit(EventDeclaration eventDeclaration, object data)
+		public override object Visit(EventDeclaration eventDeclaration, object data)
 		{
-//			VisitAttributes(eventDeclaration.Attributes, data);
-//			VisitModifier(eventDeclaration.Modifier);
-//			text.Append(&quot;event &quot;);
-//			Visit(eventDeclaration.TypeReference, data);
-//			text.Append(' ');
-//			if (eventDeclaration.VariableDeclarators != null &amp;&amp; eventDeclaration.VariableDeclarators.Count &gt; 0) {
-//				AppendCommaSeparatedList(eventDeclaration.VariableDeclarators);
-//				text.Append(&quot;;\n&quot;);
-//			} else {
-//				text.Append(eventDeclaration.Name);
-//				text.Append(&quot; {\n&quot;);
-//				++indentationLevel;
-//				if (eventDeclaration.AddRegion != null) {
-//					eventDeclaration.AddRegion.AcceptVisitor(this, data);
-//				}
-//				if (eventDeclaration.RemoveRegion != null) {
-//					eventDeclaration.RemoveRegion.AcceptVisitor(this, data);
-//				}
-//				--indentationLevel;
-//				Indent();
-//				text.Append(&quot;}\n&quot;);
-//			}
+			VisitAttributes(eventDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(eventDeclaration.Modifier);
+			outputFormatter.PrintToken(Tokens.Event);
+			outputFormatter.Space();
+			Visit(eventDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			
+			if (eventDeclaration.VariableDeclarators != null &amp;&amp; eventDeclaration.VariableDeclarators.Count &gt; 0) {
+				AppendCommaSeparatedList(eventDeclaration.VariableDeclarators);
+				outputFormatter.PrintToken(Tokens.Semicolon);
+				outputFormatter.NewLine();
+			} else {
+				outputFormatter.PrintIdentifier(eventDeclaration.Name);
+				if (eventDeclaration.AddRegion == null &amp;&amp; eventDeclaration.RemoveRegion == null) {
+					outputFormatter.PrintToken(Tokens.Semicolon);
+				} else {
+					outputFormatter.Space();
+					outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+					outputFormatter.NewLine();
+					++outputFormatter.IndentationLevel;
+					if (eventDeclaration.AddRegion != null) {
+						eventDeclaration.AddRegion.AcceptVisitor(this, data);
+					}
+					if (eventDeclaration.RemoveRegion != null) {
+						eventDeclaration.RemoveRegion.AcceptVisitor(this, data);
+					}
+					--outputFormatter.IndentationLevel;
+					outputFormatter.Indent();
+					outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+				}
+				outputFormatter.NewLine();
+			}
 			return null;
 		}
 		
-		public object Visit(EventAddRegion addRegion, object data)
+		public override object Visit(EventAddRegion addRegion, object data)
 		{
-//			this.VisitAttributes(addRegion.Attributes, data);
-//			Indent();
-//			VisitAttributes(addRegion.Attributes, data);
-//			text.Append(&quot;add {\n&quot;);
-//			++indentationLevel;
-//			addRegion.Block.AcceptVisitor(this, false);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			VisitAttributes(addRegion.Attributes, data);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(&quot;add&quot;);
+			if (addRegion.Block == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				addRegion.Block.AcceptChildren(this, false);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(EventRemoveRegion removeRegion, object data)
+		public override object Visit(EventRemoveRegion removeRegion, object data)
 		{
-//			this.VisitAttributes(removeRegion.Attributes, data);
-//			Indent();
-//			VisitAttributes(removeRegion.Attributes, data);
-//			text.Append(&quot;remove {\n&quot;);
-//			++indentationLevel;
-//			removeRegion.Block.AcceptVisitor(this, false);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			VisitAttributes(removeRegion.Attributes, data);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(&quot;remove&quot;);
+			if (removeRegion.Block == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				removeRegion.Block.AcceptChildren(this, false);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(FieldDeclaration fieldDeclaration, object data)
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
 		{
-//			VisitAttributes(fieldDeclaration.Attributes, data);
-//			VisitModifier(fieldDeclaration.Modifier);
-//			Visit(fieldDeclaration.TypeReference, data);
-//			text.Append(' ');
-//			AppendCommaSeparatedList(fieldDeclaration.Fields);
-//			text.Append(&quot;;\n&quot;);
+			VisitAttributes(fieldDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(fieldDeclaration.Modifier);
+			Visit(fieldDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			AppendCommaSeparatedList(fieldDeclaration.Fields);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
 		{
-//			VisitAttributes(constructorDeclaration.Attributes, data);
-//			VisitModifier(constructorDeclaration.Modifier);
-//			text.Append(constructorDeclaration.Name);
-//			text.Append('(');
-//			AppendCommaSeparatedList(constructorDeclaration.Parameters);
-//			text.Append(&quot;)\n&quot;);
-//			Indent();
-//			text.Append(&quot;{\n&quot;);
-//			++indentationLevel;
-//			constructorDeclaration.Body.AcceptChildren(this, data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			VisitAttributes(constructorDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(constructorDeclaration.Modifier);
+			outputFormatter.PrintIdentifier(constructorDeclaration.Name);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(constructorDeclaration.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			
+			if (constructorDeclaration.ConstructorInitializer != null) {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.Colon);
+				outputFormatter.Space();
+				if (constructorDeclaration.ConstructorInitializer.ConstructorInitializerType == ConstructorInitializerType.Base) {
+					outputFormatter.PrintToken(Tokens.Base);
+				} else {
+					outputFormatter.PrintToken(Tokens.This);
+				}
+				outputFormatter.PrintToken(Tokens.OpenParenthesis);
+				AppendCommaSeparatedList(constructorDeclaration.ConstructorInitializer.Arguments);
+				outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			}
+			
+			outputFormatter.NewLine();
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			constructorDeclaration.Body.AcceptChildren(this, data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(DestructorDeclaration destructorDeclaration, object data)
+		public override object Visit(DestructorDeclaration destructorDeclaration, object data)
 		{
-//			VisitAttributes(destructorDeclaration.Attributes, data);
-//			VisitModifier(destructorDeclaration.Modifier);
-//			text.Append('~');
-//			text.Append(destructorDeclaration.Name);
-//			text.Append('(');
-//			text.Append(&quot;)\n&quot;);
-//			Indent();
-//			text.Append(&quot;{\n&quot;);
-//			++indentationLevel;
-//			destructorDeclaration.Body.AcceptChildren(this, data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			VisitAttributes(destructorDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(destructorDeclaration.Modifier);
+			outputFormatter.PrintToken(Tokens.BitwiseComplement);
+			outputFormatter.PrintIdentifier(destructorDeclaration.Name);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.NewLine();
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			destructorDeclaration.Body.AcceptChildren(this, data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(MethodDeclaration methodDeclaration, object data)
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
 		{
-//			VisitAttributes(methodDeclaration.Attributes, data);
-//			VisitModifier(methodDeclaration.Modifier);
-//			Visit(methodDeclaration.TypeReference, data);
-//			text.Append(' ');
-//			text.Append(methodDeclaration.Name);
-//			text.Append('(');
-//			AppendCommaSeparatedList(methodDeclaration.Parameters);
-//			text.Append(&quot;)\n&quot;);
-//			Indent();
-//			text.Append(&quot;{\n&quot;);
-//			++indentationLevel;
-//			methodDeclaration.Body.AcceptChildren(this, data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			VisitAttributes(methodDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(methodDeclaration.Modifier);
+			Visit(methodDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(methodDeclaration.Name);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(methodDeclaration.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			if (methodDeclaration.Body == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.NewLine();
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				methodDeclaration.Body.AcceptChildren(this, data);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(IndexerDeclaration indexerDeclaration, object data)
+		public override object Visit(IndexerDeclaration indexerDeclaration, object data)
 		{
-//			VisitAttributes(indexerDeclaration.Attributes, data);
-//			VisitModifier(indexerDeclaration.Modifier);
-//			Visit(indexerDeclaration.TypeReference, data);
-//			text.Append(' ');
-//			if (indexerDeclaration.NamespaceName != null &amp;&amp; indexerDeclaration.NamespaceName.Length &gt; 0) {
-//				text.Append(indexerDeclaration.NamespaceName);
-//				text.Append('.');
-//			}
-//			text.Append(&quot;this[&quot;);
-//			AppendCommaSeparatedList(indexerDeclaration.Parameters);
-//			text.Append(&quot;]\n&quot;);
-//			Indent();
-//			text.Append(&quot;{\n&quot;);
-//			++indentationLevel;
-//			if (indexerDeclaration.GetRegion != null) {
-//				indexerDeclaration.GetRegion.AcceptVisitor(this, data);
-//			}
-//			if (indexerDeclaration.SetRegion != null) {
-//				indexerDeclaration.SetRegion.AcceptVisitor(this, data);
-//			}
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			VisitAttributes(indexerDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(indexerDeclaration.Modifier);
+			Visit(indexerDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			if (indexerDeclaration.NamespaceName != null &amp;&amp; indexerDeclaration.NamespaceName.Length &gt; 0) {
+				outputFormatter.PrintIdentifier(indexerDeclaration.NamespaceName);
+				outputFormatter.PrintToken(Tokens.Dot);
+			}
+			outputFormatter.PrintToken(Tokens.This);
+			outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+			AppendCommaSeparatedList(indexerDeclaration.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseSquareBracket);
+			outputFormatter.NewLine();
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (indexerDeclaration.GetRegion != null) {
+				indexerDeclaration.GetRegion.AcceptVisitor(this, data);
+			}
+			if (indexerDeclaration.SetRegion != null) {
+				indexerDeclaration.SetRegion.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(PropertyDeclaration propertyDeclaration, object data)
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
 		{
-//			VisitAttributes(propertyDeclaration.Attributes, data);
-//			VisitModifier(propertyDeclaration.Modifier);
-//			Visit(propertyDeclaration.TypeReference, data);
-//			text.Append(' ');
-//			text.Append(propertyDeclaration.Name);
-//			text.Append(&quot; {\n&quot;);
-//			++indentationLevel;
-//			if (propertyDeclaration.GetRegion != null) {
-//				propertyDeclaration.GetRegion.AcceptVisitor(this, data);
-//			}
-//			if (propertyDeclaration.SetRegion != null) {
-//				propertyDeclaration.SetRegion.AcceptVisitor(this, data);
-//			}
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			VisitAttributes(propertyDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(propertyDeclaration.Modifier);
+			Visit(propertyDeclaration.TypeReference, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(propertyDeclaration.Name);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (propertyDeclaration.GetRegion != null) {
+				propertyDeclaration.GetRegion.AcceptVisitor(this, data);
+			}
+			if (propertyDeclaration.SetRegion != null) {
+				propertyDeclaration.SetRegion.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(PropertyGetRegion getRegion, object data)
+		public override object Visit(PropertyGetRegion getRegion, object data)
 		{
-//			this.VisitAttributes(getRegion.Attributes, data);
-//			Indent();
-//			text.Append(&quot;get {\n&quot;);
-//			++indentationLevel;
-//			getRegion.Block.AcceptVisitor(this, false);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			this.VisitAttributes(getRegion.Attributes, data);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(&quot;get&quot;);
+			if (getRegion.Block == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				getRegion.Block.AcceptChildren(this, false);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(PropertySetRegion setRegion, object data)
+		public override object Visit(PropertySetRegion setRegion, object data)
 		{
-//			this.VisitAttributes(setRegion.Attributes, data);
-//			Indent();
-//			text.Append(&quot;set {\n&quot;);
-//			++indentationLevel;
-//			setRegion.Block.AcceptVisitor(this, false);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			this.VisitAttributes(setRegion.Attributes, data);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(&quot;set&quot;);
+			if (setRegion.Block == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+			} else {
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				setRegion.Block.AcceptChildren(this, false);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			}
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		// TODO : Add operator declaration to the parser ... 
-		public object Visit(OperatorDeclaration operatorDeclaration, object data)
+		public override object Visit(OperatorDeclaration operatorDeclaration, object data)
 		{
-//			VisitAttributes(operatorDeclaration.Attributes, data);
-//			VisitModifier(operatorDeclaration.Modifier);
-////			Visit(operatorDeclaration.TypeReference, data);
-//			text.Append(' ');
-////			if (operatorDeclaration.OperatorType == OperatorType.Explicit) {
-////				text.Append(&quot;explicit&quot;);
-////			} else if (operatorDeclaration.OperatorType == OperatorType.Implicit) {
-////				text.Append(&quot;implicit&quot;);
-////			} else {
-////				text.Append(operatorDeclaration.overloadOperator)
-////			}
-//			text.Append('(');
-////			text.Append(operatorDeclaration.FirstParameterType);
-//			text.Append(' ');
-////			text.Append(operatorDeclaration.FirstParameterName);
-////			if (operatorDeclaration.OperatorType == OperatorType.Binary) {
-//				text.Append(&quot;, &quot;);
-////				text.Append(operatorDeclaration.SecondParameterType);
-//				text.Append(' ');
-////				text.Append(operatorDeclaration.SecondParameterName);
-////			}
-//			text.Append(&quot;)\n&quot;);
-//			Indent();
-//			text.Append(&quot;{\n&quot;);
-//			++indentationLevel;
-//			operatorDeclaration.AcceptChildren(this, data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			VisitAttributes(operatorDeclaration.Attributes, data);
+			outputFormatter.Indent();
+			VisitModifier(operatorDeclaration.Modifier);
+			switch (operatorDeclaration.OpratorDeclarator.OperatorType) {
+				case OperatorType.Explicit:
+					outputFormatter.PrintToken(Tokens.Explicit);
+					break;
+				case OperatorType.Implicit:
+					outputFormatter.PrintToken(Tokens.Implicit);
+					break;
+				default:
+					Visit(operatorDeclaration.OpratorDeclarator.TypeReference, data);
+					break;
+			}
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.Operator);
+			outputFormatter.Space();
+			if (!operatorDeclaration.OpratorDeclarator.IsConversion) {
+				outputFormatter.PrintIdentifier(Tokens.GetTokenString(operatorDeclaration.OpratorDeclarator.OverloadOperatorToken));
+			} else {
+				Visit(operatorDeclaration.OpratorDeclarator.TypeReference, data);
+			}
+			
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(operatorDeclaration.OpratorDeclarator.FirstParameterType, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(operatorDeclaration.OpratorDeclarator.FirstParameterName);
+			if (operatorDeclaration.OpratorDeclarator.OperatorType == OperatorType.Binary) {
+				outputFormatter.PrintToken(Tokens.Comma);
+				outputFormatter.Space();
+				Visit(operatorDeclaration.OpratorDeclarator.SecondParameterType, data);
+				outputFormatter.Space();
+				outputFormatter.PrintIdentifier(operatorDeclaration.OpratorDeclarator.SecondParameterName);
+			}
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			
+			if (operatorDeclaration.Body == null) {
+				outputFormatter.PrintToken(Tokens.Semicolon);
+				outputFormatter.NewLine();
+			} else {
+				outputFormatter.NewLine();
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				operatorDeclaration.Body.AcceptChildren(this, data);
+				--outputFormatter.IndentationLevel;
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+				outputFormatter.NewLine();
+			}
 			return null;
 		}
 		
-		public object Visit(EmptyStatement emptyStatement, object data)
+		public override object Visit(EmptyStatement emptyStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;;\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
-		
-		public object Visit(BlockStatement blockStatement, object data)
+		public override object Visit(BlockStatement blockStatement, object data)
 		{
-//			bool appendBrace = true;
-//			if (data is bool) {
-//				appendBrace = (bool)data;
-//			}
-//			if (appendBrace) {
-//				Indent();
-//				text.Append(&quot;{\n&quot;);
-//				++indentationLevel;
-//			}
-//			blockStatement.AcceptChildren(this, true);
-//			if (appendBrace) {
-//				--indentationLevel;
-//				Indent();
-//				text.Append(&quot;}\n&quot;);
-//			}
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			blockStatement.AcceptChildren(this, true);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(ForStatement forStatement, object data)
+		public override object Visit(ForStatement forStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;for (&quot;);
-//			if (forStatement.Initializers != null &amp;&amp; forStatement.Initializers.Count &gt; 0) {
-//				foreach (INode node in forStatement.Initializers) {
-//					node.AcceptVisitor(this, false);
-//					text.Append(',');
-//				}
-//			}
-//			text.Append(';');
-//			if (forStatement.Condition != null) {
-//				forStatement.Condition.AcceptVisitor(this, data);
-//			}
-//			text.Append(';');
-//			if (forStatement.Iterator != null &amp;&amp; forStatement.Iterator.Count &gt; 0) {
-//				foreach (INode node in forStatement.Iterator) {
-//					node.AcceptVisitor(this, false);
-//					text.Append(',');
-//				}
-//			}
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			if (forStatement.EmbeddedStatement is BlockStatement) {
-//				Visit((BlockStatement)forStatement.EmbeddedStatement, false);
-//			} else {
-//				forStatement.EmbeddedStatement.AcceptVisitor(this, data);
-//			}
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.For);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			outputFormatter.DoIndent = false;
+			outputFormatter.DoNewLine = false;
+			outputFormatter.EmitSemicolon = false;
+			if (forStatement.Initializers != null &amp;&amp; forStatement.Initializers.Count &gt; 0) {
+				for (int i = 0; i &lt; forStatement.Initializers.Count; ++i) {
+					INode node = (INode)forStatement.Initializers[i];
+					node.AcceptVisitor(this, false);
+					if (i + 1 &lt; forStatement.Initializers.Count) {
+						outputFormatter.PrintToken(Tokens.Comma);
+					}
+				}
+			} 
+			outputFormatter.EmitSemicolon = true;
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.EmitSemicolon = false;
+			if (forStatement.Condition != null) {
+				outputFormatter.Space();
+				forStatement.Condition.AcceptVisitor(this, data);
+			}
+			outputFormatter.EmitSemicolon = true;
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.EmitSemicolon = false;
+			if (forStatement.Iterator != null &amp;&amp; forStatement.Iterator.Count &gt; 0) {
+				outputFormatter.Space();
+				for (int i = 0; i &lt; forStatement.Iterator.Count; ++i) {
+					INode node = (INode)forStatement.Iterator[i];
+					node.AcceptVisitor(this, false);
+					if (i + 1 &lt; forStatement.Iterator.Count) {
+						outputFormatter.PrintToken(Tokens.Comma);
+					}
+				}
+			}
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.EmitSemicolon = true;
+			outputFormatter.DoNewLine     = true;
+			outputFormatter.DoIndent      = true;
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (forStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)forStatement.EmbeddedStatement, false);
+			} else {
+				forStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
 			return null;
 		}
 		
-		public object Visit(ForeachStatement foreachStatement, object data)
+		public override object Visit(ForeachStatement foreachStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;foreach (&quot;);
-//			Visit(foreachStatement.TypeReference, data);
-//			text.Append(' ');
-//			text.Append(foreachStatement.VariableName);
-//			text.Append(&quot; in &quot;);
-//			foreachStatement.Expression.AcceptVisitor(this, data);
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			if (foreachStatement.EmbeddedStatement is BlockStatement) {
-//				Visit((BlockStatement)foreachStatement.EmbeddedStatement, false);
-//			} else {
-//				foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
-//			}
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Foreach);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(foreachStatement.TypeReference, data);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(foreachStatement.VariableName);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.In);
+			outputFormatter.Space();
+			foreachStatement.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (foreachStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)foreachStatement.EmbeddedStatement, false);
+			} else {
+				foreachStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
 			return null;
 		}
 		
-		public object Visit(WhileStatement whileStatement, object data)
+		public override object Visit(WhileStatement whileStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;while (&quot;);
-//			whileStatement.Condition.AcceptVisitor(this, data);
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			if (whileStatement.EmbeddedStatement is BlockStatement) {
-//				Visit((BlockStatement)whileStatement.EmbeddedStatement, false);
-//			} else {
-//				whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
-//			}
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.While);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			whileStatement.Condition.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (whileStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)whileStatement.EmbeddedStatement, false);
+			} else {
+				whileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
 			return null;
 		}
 		
-		public object Visit(DoWhileStatement doWhileStatement, object data)
+		public override object Visit(DoWhileStatement doWhileStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;do {\n&quot;);
-//			++indentationLevel;
-//			if (doWhileStatement.EmbeddedStatement is BlockStatement) {
-//				Visit((BlockStatement)doWhileStatement.EmbeddedStatement, false);
-//			} else {
-//				doWhileStatement.EmbeddedStatement.AcceptVisitor(this, data);
-//			}
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;} while (&quot;);
-//			doWhileStatement.Condition.AcceptVisitor(this, data);
-//			text.Append(&quot;);\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Do);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (doWhileStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)doWhileStatement.EmbeddedStatement, false);
+			} else {
+				doWhileStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.While);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			doWhileStatement.Condition.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(BreakStatement breakStatement, object data)
+		public override object Visit(BreakStatement breakStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;break;\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Break);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(ContinueStatement continueStatement, object data)
+		public override object Visit(ContinueStatement continueStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;continue;\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Continue);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(CheckedStatement checkedStatement, object data)
+		public override object Visit(CheckedStatement checkedStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;checked {\n&quot;);
-//			++indentationLevel;
-//			checkedStatement.Block.AcceptVisitor(this, false);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Checked);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			checkedStatement.Block.AcceptChildren(this, false);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(UncheckedStatement uncheckedStatement, object data)
+		public override object Visit(UncheckedStatement uncheckedStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;unchecked {\n&quot;);
-//			++indentationLevel;
-//			uncheckedStatement.Block.AcceptVisitor(this, false);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Unchecked);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			uncheckedStatement.Block.AcceptVisitor(this, false);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(FixedStatement fixedStatement, object data)
+		public override object Visit(FixedStatement fixedStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;fixed (&quot;);
-//			Visit(fixedStatement.TypeReference, data);
-//			text.Append(' ');
-//			AppendCommaSeparatedList(fixedStatement.PointerDeclarators);
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			if (fixedStatement.EmbeddedStatement is BlockStatement) {
-//				Visit((BlockStatement)fixedStatement.EmbeddedStatement, false);
-//			} else {
-//				fixedStatement.EmbeddedStatement.AcceptVisitor(this, data);
-//			}
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Fixed);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(fixedStatement.TypeReference, data);
+			outputFormatter.Space();
+			AppendCommaSeparatedList(fixedStatement.PointerDeclarators);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			if (fixedStatement.EmbeddedStatement is BlockStatement) {
+				Visit((BlockStatement)fixedStatement.EmbeddedStatement, false);
+			} else {
+				fixedStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		public override object Visit(GotoCaseStatement gotoCaseStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;goto &quot;);
-//			if (gotoCaseStatement.IsDefaultCase) {
-//				text.Append(&quot;default&quot;);
-//			} else {
-//				text.Append(&quot;case &quot;);
-//				gotoCaseStatement.CaseExpression.AcceptVisitor(this, data);
-//			}
-//			text.Append(&quot;;\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Goto);
+			outputFormatter.Space();
+			if (gotoCaseStatement.IsDefaultCase) {
+				outputFormatter.PrintToken(Tokens.Default);
+			} else {
+				outputFormatter.PrintToken(Tokens.Case);
+				outputFormatter.Space();
+				gotoCaseStatement.CaseExpression.AcceptVisitor(this, data);
+			}
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(GotoStatement gotoStatement, object data)
+		public override object Visit(GotoStatement gotoStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;goto &quot;);
-//			text.Append(gotoStatement.Label);
-//			text.Append(&quot;;\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Goto);
+			outputFormatter.Space();
+			outputFormatter.PrintIdentifier(gotoStatement.Label);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(IfElseStatement ifElseStatement, object data)
+		public override object Visit(IfElseStatement ifElseStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;if (&quot;);
-//			ifElseStatement.Condition.AcceptVisitor(this,data);
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			ifElseStatement.EmbeddedStatement.AcceptVisitor(this,data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;} else {\n&quot;);
-//			++indentationLevel;
-//			ifElseStatement.EmbeddedElseStatement.AcceptVisitor(this,data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.If);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			ifElseStatement.Condition.AcceptVisitor(this,data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			ifElseStatement.EmbeddedStatement.AcceptVisitor(this,data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Else);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			ifElseStatement.EmbeddedElseStatement.AcceptVisitor(this,data);
+			--outputFormatter.IndentationLevel;
 			return null;
 		}
 		
-		public object Visit(IfStatement ifStatement, object data)
+		public override object Visit(IfStatement ifStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;if (&quot;);
-//			ifStatement.Condition.AcceptVisitor(this,data);
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			ifStatement.EmbeddedStatement.AcceptVisitor(this,data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.If);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			ifStatement.Condition.AcceptVisitor(this,data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			++outputFormatter.IndentationLevel;
+			ifStatement.EmbeddedStatement.AcceptVisitor(this,data);
+			--outputFormatter.IndentationLevel;
 			return null;
 		}
 		
-		public object Visit(LabelStatement labelStatement, object data)
+		public override object Visit(LabelStatement labelStatement, object data)
 		{
-//			Indent();
-//			text.Append(labelStatement.Label);
-//			text.Append(&quot;:\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintIdentifier(labelStatement.Label);
+			outputFormatter.PrintToken(Tokens.Colon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(LockStatement lockStatement, object data)
+		public override object Visit(LockStatement lockStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;lock (&quot;);
-//			lockStatement.LockExpression.AcceptVisitor(this, data);
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Lock);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			lockStatement.LockExpression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			
+			++outputFormatter.IndentationLevel;
+			lockStatement.EmbeddedStatement.AcceptVisitor(this, data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(ReturnStatement returnStatement, object data)
+		public override object Visit(ReturnStatement returnStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;return&quot;);
-//			if (returnStatement.ReturnExpression != null) {
-//				text.Append(&quot; &quot;);
-//				returnStatement.ReturnExpression.AcceptVisitor(this, data);
-//			}
-//			text.Append(&quot;;\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Return);
+			if (returnStatement.ReturnExpression != null) {
+				outputFormatter.Space();
+				returnStatement.ReturnExpression.AcceptVisitor(this, data);
+			}
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(SwitchStatement switchStatement, object data)
+		public override object Visit(SwitchStatement switchStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;switch (&quot;);
-//			switchStatement.SwitchExpression.AcceptVisitor(this, data);
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			foreach (SwitchSection section in switchStatement.SwitchSections) {
-//				Indent();
-//				text.Append(&quot;case &quot;);
-//				
-//				for (int i = 0; i &lt; section.SwitchLabels.Count; ++i) {
-//					Expression label = (Expression)section.SwitchLabels[i];
-//					if (label == null) {
-//						text.Append(&quot;default:&quot;);
-//						continue;
-//					}
-//					label.AcceptVisitor(this, data);
-//					text.Append(&quot;:\n&quot;);
-//				}
-//				
-//				++indentationLevel;
-//				section.AcceptVisitor(this, data);
-//				--indentationLevel;
-//			}
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Switch);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			switchStatement.SwitchExpression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			++outputFormatter.IndentationLevel;
+			foreach (SwitchSection section in switchStatement.SwitchSections) {
+				for (int i = 0; i &lt; section.SwitchLabels.Count; ++i) {
+					Expression label = (Expression)section.SwitchLabels[i];
+					if (label == null) {
+						outputFormatter.Indent();
+						outputFormatter.PrintToken(Tokens.Default);
+						outputFormatter.PrintToken(Tokens.Colon);
+						outputFormatter.NewLine();
+						continue;
+					}
+					
+					outputFormatter.Indent();
+					outputFormatter.PrintToken(Tokens.Case);
+					outputFormatter.Space();
+					label.AcceptVisitor(this, data);
+					outputFormatter.PrintToken(Tokens.Colon);
+					outputFormatter.NewLine();
+				}
+				
+				++outputFormatter.IndentationLevel;
+				section.AcceptChildren(this, data);
+				--outputFormatter.IndentationLevel;
+			}
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(ThrowStatement throwStatement, object data)
+		public override object Visit(ThrowStatement throwStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;throw &quot;);
-//			throwStatement.ThrowExpression.AcceptVisitor(this, data);
-//			text.Append(&quot;;\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Throw);
+			if (throwStatement.ThrowExpression != null) {
+				outputFormatter.Space();
+				throwStatement.ThrowExpression.AcceptVisitor(this, data);
+			}
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(TryCatchStatement tryCatchStatement, object data)
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;try {\n&quot;);
-//			
-//			++indentationLevel;
-//			tryCatchStatement.StatementBlock.AcceptVisitor(this, data);
-//			--indentationLevel;
-//			
-//			if (tryCatchStatement.CatchClauses != null) {
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Try);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			
+			++outputFormatter.IndentationLevel;
+			tryCatchStatement.StatementBlock.AcceptChildren(this, data);
+			--outputFormatter.IndentationLevel;
+			
+			if (tryCatchStatement.CatchClauses != null) {
 //				int generated = 0;
-//				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
-//					Indent();
-//					text.Append(&quot;} catch (&quot;);
-//					text.Append(catchClause.Type);
-//					text.Append(' ');
-//					if (catchClause.VariableName == null) {
-//						text.Append(&quot;generatedExceptionVariable&quot; + generated.ToString());
-//						++generated;
-//					} else {
-//						text.Append(catchClause.VariableName);
-//					}
-//					text.Append(&quot;) {\n&quot;);
-//					++indentationLevel;
-//					catchClause.StatementBlock.AcceptVisitor(this, data);
-//					--indentationLevel;
-//				}
-//			}
-//			
-//			if (tryCatchStatement.FinallyBlock != null) {
-//				Indent();
-//				text.Append(&quot;} finally {\n&quot;);
-//				++indentationLevel;
-//				tryCatchStatement.FinallyBlock.AcceptVisitor(this, data);
-//				--indentationLevel;
-//			}
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+				foreach (CatchClause catchClause in tryCatchStatement.CatchClauses) {
+					outputFormatter.Indent();
+					outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+					outputFormatter.Space();
+					outputFormatter.PrintToken(Tokens.Catch);
+					outputFormatter.Space();
+					if (catchClause.Type == null) {
+					} else {
+						outputFormatter.PrintToken(Tokens.OpenParenthesis);
+						outputFormatter.PrintIdentifier(catchClause.Type);
+						if (catchClause.VariableName != null) {
+							outputFormatter.Space();
+							outputFormatter.PrintIdentifier(catchClause.VariableName);
+						}
+						outputFormatter.PrintToken(Tokens.CloseParenthesis);
+					}
+					outputFormatter.Space();
+					outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+					outputFormatter.NewLine();
+					++outputFormatter.IndentationLevel;
+					catchClause.StatementBlock.AcceptChildren(this, data);
+					--outputFormatter.IndentationLevel;
+				}
+			}
+			
+			if (tryCatchStatement.FinallyBlock != null) {
+				outputFormatter.Indent();
+				outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.Finally);
+				outputFormatter.Space();
+				outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+				outputFormatter.NewLine();
+				++outputFormatter.IndentationLevel;
+				tryCatchStatement.FinallyBlock.AcceptChildren(this, data);
+				--outputFormatter.IndentationLevel;
+			}
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(UsingStatement usingStatement, object data)
+		public override object Visit(UsingStatement usingStatement, object data)
 		{
-//			Indent();
-//			text.Append(&quot;using (&quot;);
-//			usingStatement.UsingStmnt.AcceptVisitor(this,data);
-//			text.Append(&quot;) {\n&quot;);
-//			++indentationLevel;
-//			usingStatement.EmbeddedStatement.AcceptVisitor(this,data);
-//			--indentationLevel;
-//			Indent();
-//			text.Append(&quot;}\n&quot;);
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.Using);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			outputFormatter.DoIndent = false;
+			outputFormatter.DoNewLine = false;
+			outputFormatter.EmitSemicolon = false;
+			
+			usingStatement.UsingStmnt.AcceptVisitor(this,data);
+			outputFormatter.DoIndent = true;
+			outputFormatter.DoNewLine = true;
+			outputFormatter.EmitSemicolon = true;
+			
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			outputFormatter.NewLine();
+			
+			++outputFormatter.IndentationLevel;
+			usingStatement.EmbeddedStatement.AcceptVisitor(this,data);
+			--outputFormatter.IndentationLevel;
+			outputFormatter.Indent();
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
 		{
-//			Indent();
-//			VisitModifier(localVariableDeclaration.Modifier);
-//			text.Append(&quot; &quot;);
-//			Visit(localVariableDeclaration.Type, data);
-//			this.AppendCommaSeparatedList(localVariableDeclaration.Variables);
-//			text.Append(&quot;;\n&quot;);
+//			Console.WriteLine(localVariableDeclaration);
+			outputFormatter.Indent();
+			VisitModifier(localVariableDeclaration.Modifier);
+			Visit(localVariableDeclaration.Type, data);
+			outputFormatter.Space();
+			this.AppendCommaSeparatedList(localVariableDeclaration.Variables);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
-		public object Visit(StatementExpression statementExpression, object data)
+		public override object Visit(StatementExpression statementExpression, object data)
 		{
-//			Indent();
-//			statementExpression.Expression.AcceptVisitor(this, data);
-//			text.Append(&quot;;\n&quot;);
+			outputFormatter.Indent();
+			statementExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.Semicolon);
+			outputFormatter.NewLine();
 			return null;
 		}
 		
 #region Expressions
-		public object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
 		{
-//			text.Append(&quot;new &quot;);
-//			Visit(arrayCreateExpression.CreateType, null);
-//			foreach (object o in arrayCreateExpression.Parameters) {
-//				text.Append(&quot;[&quot;);
-//				if (o is int) {
-//					int num = (int)o;
-//					for (int i = 0; i &lt; num; ++i) {
-//						text.Append(&quot;,&quot;);
-//					}
-//				} else {
-//					((Expression)o).AcceptVisitor(this, null);
-//				}
-//				text.Append(&quot;]&quot;);
-//			}
-//			
-//			if (arrayCreateExpression.Parameters.Count == 0) {
-//				text.Append(&quot;[]&quot;);
-//			}
-//			
-//			if (arrayCreateExpression.ArrayInitializer != null) {
-//				text.Append(&quot; &quot;);
-//				arrayCreateExpression.ArrayInitializer.AcceptVisitor(this, null);
-//			}
+			outputFormatter.PrintToken(Tokens.New);
+			outputFormatter.Space();
+			Visit(arrayCreateExpression.CreateType, null);
+			for (int i = 0; i &lt; arrayCreateExpression.Parameters.Count; ++i) {
+				outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+				ArrayCreationParameter creationParameter = (ArrayCreationParameter)arrayCreateExpression.Parameters[i];
+				if (creationParameter.IsExpressionList) {
+					AppendCommaSeparatedList(creationParameter.Expressions);
+				} else {
+					for (int j = 0; j &lt; creationParameter.Dimensions; ++j) {
+						outputFormatter.PrintToken(Tokens.Comma);
+					}
+				}
+				outputFormatter.PrintToken(Tokens.CloseSquareBracket);
+			}
+			
+			
+			if (arrayCreateExpression.ArrayInitializer != null) {
+				outputFormatter.Space();
+				arrayCreateExpression.ArrayInitializer.AcceptVisitor(this, null);
+			}
 			return null;
 		}
 		
-		public object Visit(ArrayInitializerExpression arrayCreateExpression, object data)
+		public override object Visit(ArrayInitializerExpression arrayCreateExpression, object data)
 		{
-//			text.Append(&quot;{&quot;);
-//			this.AppendCommaSeparatedList(arrayCreateExpression.CreateExpressions);
-//			text.Append(&quot;}&quot;);
+			outputFormatter.PrintToken(Tokens.OpenCurlyBrace);
+			this.AppendCommaSeparatedList(arrayCreateExpression.CreateExpressions);
+			outputFormatter.PrintToken(Tokens.CloseCurlyBrace);
 			return null;
 		}
 		
-		public object Visit(AssignmentExpression assignmentExpression, object data)
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
 		{
-//			assignmentExpression.Left.AcceptVisitor(this, data);
-//			switch (assignmentExpression.Op) {
-//				case AssignmentOperatorType.Assign:
-//					text.Append(&quot; = &quot;);
-//					break;
-//				case AssignmentOperatorType.Add:
-//					text.Append(&quot; += &quot;);
-//					break;
-//				case AssignmentOperatorType.Subtract:
-//					text.Append(&quot; -= &quot;);
-//					break;
-//				case AssignmentOperatorType.Multiply:
-//					text.Append(&quot; *= &quot;);
-//					break;
-//				case AssignmentOperatorType.Divide:
-//					text.Append(&quot; /= &quot;);
-//					break;
-//				case AssignmentOperatorType.ShiftLeft:
-//					text.Append(&quot; &lt;&lt;= &quot;);
-//					break;
-//				case AssignmentOperatorType.ShiftRight:
-//					text.Append(&quot; &gt;&gt;= &quot;);
-//					break;
-//				case AssignmentOperatorType.ExclusiveOr:
-//					text.Append(&quot; ^= &quot;);
-//					break;
-//				case AssignmentOperatorType.Modulus:
-//					text.Append(&quot; %= &quot;);
-//					break;
-//				case AssignmentOperatorType.BitwiseAnd:
-//					text.Append(&quot; &amp;= &quot;);
-//					break;
-//				case AssignmentOperatorType.BitwiseOr:
-//					text.Append(&quot; |= &quot;);
-//					break;
-//			}
-//			assignmentExpression.Right.AcceptVisitor(this, data);
-//			
+			assignmentExpression.Left.AcceptVisitor(this, data);
+			outputFormatter.Space();
+			switch (assignmentExpression.Op) {
+				case AssignmentOperatorType.Assign:
+					outputFormatter.PrintToken(Tokens.Assign);
+					break;
+				case AssignmentOperatorType.Add:
+					outputFormatter.PrintToken(Tokens.PlusAssign);
+					break;
+				case AssignmentOperatorType.Subtract:
+					outputFormatter.PrintToken(Tokens.MinusAssign);
+					break;
+				case AssignmentOperatorType.Multiply:
+					outputFormatter.PrintToken(Tokens.TimesAssign);
+					break;
+				case AssignmentOperatorType.Divide:
+					outputFormatter.PrintToken(Tokens.DivAssign);
+					break;
+				case AssignmentOperatorType.ShiftLeft:
+					outputFormatter.PrintToken(Tokens.ShiftLeftAssign);
+					break;
+				case AssignmentOperatorType.ShiftRight:
+					outputFormatter.PrintToken(Tokens.ShiftRightAssign);
+					break;
+				case AssignmentOperatorType.ExclusiveOr:
+					outputFormatter.PrintToken(Tokens.XorAssign);
+					break;
+				case AssignmentOperatorType.Modulus:
+					outputFormatter.PrintToken(Tokens.ModAssign);
+					break;
+				case AssignmentOperatorType.BitwiseAnd:
+					outputFormatter.PrintToken(Tokens.BitwiseAndAssign);
+					break;
+				case AssignmentOperatorType.BitwiseOr:
+					outputFormatter.PrintToken(Tokens.BitwiseOrAssign);
+					break;
+			}
+			outputFormatter.Space();
+			assignmentExpression.Right.AcceptVisitor(this, data);
 			return null;
 		}
 		
-		public object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
 		{
-//			text.Append(&quot;base&quot;);
+			outputFormatter.PrintToken(Tokens.Base);
 			return null;
 		}
 		
-		public object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		public override object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
 		{
-//			binaryOperatorExpression.Left.AcceptVisitor(this, data);
-//			switch (binaryOperatorExpression.Op) {
-//				case BinaryOperatorType.Add:
-//					text.Append(&quot; + &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.Subtract:
-//					text.Append(&quot; - &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.Multiply:
-//					text.Append(&quot; * &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.Divide:
-//					text.Append(&quot; / &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.Modulus:
-//					text.Append(&quot; % &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.ShiftLeft:
-//					text.Append(&quot; &lt;&lt; &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.ShiftRight:
-//					text.Append(&quot; &gt;&gt; &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.BitwiseAnd:
-//					text.Append(&quot; &amp; &quot;);
-//					break;
-//				case BinaryOperatorType.BitwiseOr:
-//					text.Append(&quot; | &quot;);
-//					break;
-//				case BinaryOperatorType.ExclusiveOr:
-//					text.Append(&quot; ^ &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.LogicalAnd:
-//					text.Append(&quot; &amp;&amp; &quot;);
-//					break;
-//				case BinaryOperatorType.LogicalOr:
-//					text.Append(&quot; || &quot;);
-//					break;
-//				
-//				case BinaryOperatorType.AS:
-//					text.Append(&quot; as &quot;);
-//					break;
-//				case BinaryOperatorType.IS:
-//					text.Append(&quot; is &quot;);
-//					break;
-//				case BinaryOperatorType.Equality:
-//					text.Append(&quot; == &quot;);
-//					break;
-//				case BinaryOperatorType.GreaterThan:
-//					text.Append(&quot; &gt; &quot;);
-//					break;
-//				case BinaryOperatorType.GreaterThanOrEqual:
-//					text.Append(&quot; &gt;= &quot;);
-//					break;
-//				case BinaryOperatorType.InEquality:
-//					text.Append(&quot; != &quot;);
-//					break;
-//				case BinaryOperatorType.LessThan:
-//					text.Append(&quot; &lt; &quot;);
-//					break;
-//				case BinaryOperatorType.LessThanOrEqual:
-//					text.Append(&quot; &lt;= &quot;);
-//					break;
-//			}
-//			
-//			binaryOperatorExpression.Right.AcceptVisitor(this, data);
+			binaryOperatorExpression.Left.AcceptVisitor(this, data);
+			outputFormatter.Space();
+			switch (binaryOperatorExpression.Op) {
+				case BinaryOperatorType.Add:
+					outputFormatter.PrintToken(Tokens.Plus);
+					break;
+				
+				case BinaryOperatorType.Subtract:
+					outputFormatter.PrintToken(Tokens.Minus);
+					break;
+				
+				case BinaryOperatorType.Multiply:
+					outputFormatter.PrintToken(Tokens.Times);
+					break;
+				
+				case BinaryOperatorType.Divide:
+					outputFormatter.PrintToken(Tokens.Div);
+					break;
+				
+				case BinaryOperatorType.Modulus:
+					outputFormatter.PrintToken(Tokens.Mod);
+					break;
+				
+				case BinaryOperatorType.ShiftLeft:
+					outputFormatter.PrintToken(Tokens.ShiftLeft);
+					break;
+				
+				case BinaryOperatorType.ShiftRight:
+					outputFormatter.PrintToken(Tokens.ShiftRight);
+					break;
+				
+				case BinaryOperatorType.BitwiseAnd:
+					outputFormatter.PrintToken(Tokens.BitwiseAnd);
+					break;
+				case BinaryOperatorType.BitwiseOr:
+					outputFormatter.PrintToken(Tokens.BitwiseOr);
+					break;
+				case BinaryOperatorType.ExclusiveOr:
+					outputFormatter.PrintToken(Tokens.Xor);
+					break;
+				
+				case BinaryOperatorType.LogicalAnd:
+					outputFormatter.PrintToken(Tokens.LogicalAnd);
+					break;
+				case BinaryOperatorType.LogicalOr:
+					outputFormatter.PrintToken(Tokens.LogicalOr);
+					break;
+				
+				case BinaryOperatorType.AS:
+					outputFormatter.PrintToken(Tokens.As);
+					break;
+				
+				case BinaryOperatorType.IS:
+					outputFormatter.PrintToken(Tokens.Is);
+					break;
+				case BinaryOperatorType.Equality:
+					outputFormatter.PrintToken(Tokens.Equal);
+					break;
+				case BinaryOperatorType.GreaterThan:
+					outputFormatter.PrintToken(Tokens.GreaterThan);
+					break;
+				case BinaryOperatorType.GreaterThanOrEqual:
+					outputFormatter.PrintToken(Tokens.GreaterEqual);
+					break;
+				case BinaryOperatorType.InEquality:
+					outputFormatter.PrintToken(Tokens.NotEqual);
+					break;
+				case BinaryOperatorType.LessThan:
+					outputFormatter.PrintToken(Tokens.LessThan);
+					break;
+				case BinaryOperatorType.LessThanOrEqual:
+					outputFormatter.PrintToken(Tokens.LessEqual);
+					break;
+			}
+			outputFormatter.Space();
+			binaryOperatorExpression.Right.AcceptVisitor(this, data);
 			return null;
 		}
 		
-		public object Visit(CastExpression castExpression, object data)
+		public override object Visit(CastExpression castExpression, object data)
 		{
-//			text.Append(&quot;(&quot;);
-//			Visit(castExpression.CastTo, data);
-//			text.Append(&quot;)&quot;);
-//			castExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(castExpression.CastTo, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
+			castExpression.Expression.AcceptVisitor(this, data);
 			return null;
 		}
 		
-		public object Visit(CheckedExpression checkedExpression, object data)
+		public override object Visit(CheckedExpression checkedExpression, object data)
 		{
-//			text.Append(&quot;checked(&quot;);
-//			checkedExpression.Expression.AcceptVisitor(this, data);
-//			text.Append(&quot;)&quot;);
+			outputFormatter.PrintToken(Tokens.Checked);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			checkedExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
 			return null;
 		}
 		
-		public object Visit(ConditionalExpression conditionalExpression, object data)
+		public override object Visit(ConditionalExpression conditionalExpression, object data)
 		{
-//			conditionalExpression.TestCondition.AcceptVisitor(this, data);
-//			text.Append(&quot; ? &quot;);
-//			conditionalExpression.TrueExpression.AcceptVisitor(this, data);
-//			text.Append(&quot; : &quot;);
-//			conditionalExpression.FalseExpression.AcceptVisitor(this, data);
+			conditionalExpression.TestCondition.AcceptVisitor(this, data);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.Question);
+			outputFormatter.Space();
+			conditionalExpression.TrueExpression.AcceptVisitor(this, data);
+			outputFormatter.Space();
+			outputFormatter.PrintToken(Tokens.Colon);
+			outputFormatter.Space();
+			conditionalExpression.FalseExpression.AcceptVisitor(this, data);
 			return null;
 		}
 		
-		public object Visit(DirectionExpression directionExpression, object data)
+		public override object Visit(DirectionExpression directionExpression, object data)
 		{
-//			switch (directionExpression.FieldDirection) {
-//				case FieldDirection.Out:
-//					text.Append(&quot;out &quot;);
-//					break;
-//				case FieldDirection.Ref:
-//					text.Append(&quot;ref &quot;);
-//					break;
-//			}
-//			directionExpression.Expression.AcceptVisitor(this, data);
+			switch (directionExpression.FieldDirection) {
+				case FieldDirection.Out:
+					outputFormatter.PrintToken(Tokens.Out);
+					outputFormatter.Space();
+					break;
+				case FieldDirection.Ref:
+					outputFormatter.PrintToken(Tokens.Ref);
+					outputFormatter.Space();
+					break;
+			}
+			directionExpression.Expression.AcceptVisitor(this, data);
 			return null;
 		}
 		
-		public object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
 		{
-//			fieldReferenceExpression.TargetObject.AcceptVisitor(this, data);
-//			text.Append(&quot;.&quot;);
-//			text.Append(fieldReferenceExpression.FieldName);
+			fieldReferenceExpression.TargetObject.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.Dot);
+			outputFormatter.PrintIdentifier(fieldReferenceExpression.FieldName);
 			return null;
 		}
 		
-		public object Visit(IdentifierExpression identifierExpression, object data)
+		public override object Visit(IdentifierExpression identifierExpression, object data)
 		{
-//			text.Append(identifierExpression.Identifier);
+			outputFormatter.PrintIdentifier(identifierExpression.Identifier);
 			return null;
 		}
 		
-		public object Visit(IndexerExpression indexerExpression, object data)
+		public override object Visit(IndexerExpression indexerExpression, object data)
 		{
-//			indexerExpression.TargetObject.AcceptVisitor(this, data);
-//			text.Append(&quot;[&quot;);
-//			AppendCommaSeparatedList(indexerExpression.Indices);
-//			text.Append(&quot;]&quot;);
+			indexerExpression.TargetObject.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+			AppendCommaSeparatedList(indexerExpression.Indices);
+			outputFormatter.PrintToken(Tokens.CloseSquareBracket);
 			return null;
 		}
 		
-		public object Visit(InvocationExpression invocationExpression, object data)
+		public override object Visit(InvocationExpression invocationExpression, object data)
 		{
-//			invocationExpression.TargetObject.AcceptVisitor(this, data);
-//			text.Append(&quot;(&quot;);
-//			AppendCommaSeparatedList(invocationExpression.Parameters);
-//			text.Append(&quot;)&quot;);
+			invocationExpression.TargetObject.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(invocationExpression.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
 			return null;
 		}
 		
-		public object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
 		{
-//			text.Append(&quot;new &quot;);
-//			this.Visit(objectCreateExpression.CreateType, data);
-//			text.Append(&quot;(&quot;);
-//			AppendCommaSeparatedList(objectCreateExpression.Parameters);
-//			text.Append(&quot;)&quot;);
+			outputFormatter.PrintToken(Tokens.New);
+			outputFormatter.Space();
+			this.Visit(objectCreateExpression.CreateType, data);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			AppendCommaSeparatedList(objectCreateExpression.Parameters);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
 			return null;
 		}
 		
-		public object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		public override object Visit(ParenthesizedExpression parenthesizedExpression, object data)
 		{
-//			text.Append(&quot;(&quot;);
-//			parenthesizedExpression.Expression.AcceptVisitor(this, data);
-//			text.Append(&quot;)&quot;);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			parenthesizedExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
 			return null;
 		}
 		
-		public object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
 		{
-//			pointerReferenceExpression.Expression.AcceptVisitor(this, data);
-//			text.Append(&quot;-&gt;&quot;);
-//			text.Append(pointerReferenceExpression.Identifier);
+			pointerReferenceExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.Pointer);
+			outputFormatter.PrintIdentifier(pointerReferenceExpression.Identifier);
 			return null;
 		}
 		
-		public object Visit(PrimitiveExpression primitiveExpression, object data)
+		public override object Visit(PrimitiveExpression primitiveExpression, object data)
 		{
-//			text.Append(primitiveExpression.StringValue);
+			outputFormatter.PrintIdentifier(primitiveExpression.StringValue);
 			return null;
 		}
 		
-		public object Visit(SizeOfExpression sizeOfExpression, object data)
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
 		{
-//			text.Append(&quot;sizeof(&quot;);
-//			Visit(sizeOfExpression.TypeReference, data);
-//			text.Append(&quot;)&quot;);
+			outputFormatter.PrintToken(Tokens.Sizeof);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(sizeOfExpression.TypeReference, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
 			return null;
 		}
 		
-		public object Visit(StackAllocExpression stackAllocExpression, object data)
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
 		{
-//			text.Append(&quot;stackalloc &quot;);
-//			Visit(stackAllocExpression.Type, data);
-//			text.Append(&quot;[&quot;);
-//			stackAllocExpression.Expression.AcceptVisitor(this, data);
-//			text.Append(&quot;]&quot;);
+			outputFormatter.PrintToken(Tokens.Stackalloc);
+			Visit(stackAllocExpression.Type, data);
+			outputFormatter.PrintToken(Tokens.OpenSquareBracket);
+			stackAllocExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseSquareBracket);
 			return null;
 		}
 		
-		public object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
 		{
-//			text.Append(&quot;this&quot;);
+			outputFormatter.PrintToken(Tokens.This);
 			return null;
 		}
 		
-		public object Visit(TypeOfExpression typeOfExpression, object data)
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
 		{
-//			text.Append(&quot;typeof(&quot;);
-//			Visit(typeOfExpression.TypeReference, data);
-//			text.Append(&quot;)&quot;);
+			outputFormatter.PrintToken(Tokens.Typeof);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			Visit(typeOfExpression.TypeReference, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
 			return null;
 		}
 		
-		public object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
 		{
-//			Visit(typeReferenceExpression.TypeReference, data);
+			Visit(typeReferenceExpression.TypeReference, data);
 			return null;
 		}
 		
-		public object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
 		{
-//			switch (unaryOperatorExpression.Op) {
-//				case UnaryOperatorType.BitNot:
-//					text.Append(&quot;~&quot;);
-//					break;
-//				case UnaryOperatorType.Decrement:
-//					text.Append(&quot;--&quot;);
-//					break;
-//				case UnaryOperatorType.Increment:
-//					text.Append(&quot;++&quot;);
-//					break;
-//				case UnaryOperatorType.Minus:
-//					text.Append(&quot;-&quot;);
-//					break;
-//				case UnaryOperatorType.Not:
-//					text.Append(&quot;!&quot;);
-//					break;
-//				case UnaryOperatorType.Plus:
-//					text.Append(&quot;+&quot;);
-//					break;
-//				case UnaryOperatorType.PostDecrement:
-//					unaryOperatorExpression.Expression.AcceptVisitor(this, data);
-//					text.Append(&quot;--&quot;);
-//					return null;
-//				case UnaryOperatorType.PostIncrement:
-//					unaryOperatorExpression.Expression.AcceptVisitor(this, data);
-//					text.Append(&quot;++&quot;);
-//					return null;
-//				case UnaryOperatorType.Star:
-//					text.Append(&quot;*&quot;);
-//					break;
-//				case UnaryOperatorType.BitWiseAnd:
-//					text.Append(&quot;&amp;&quot;);
-//					break;
-//			}
-//			unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+			switch (unaryOperatorExpression.Op) {
+				case UnaryOperatorType.BitNot:
+					outputFormatter.PrintToken(Tokens.BitwiseComplement);
+					break;
+				case UnaryOperatorType.Decrement:
+					outputFormatter.PrintToken(Tokens.Decrement);
+					break;
+				case UnaryOperatorType.Increment:
+					outputFormatter.PrintToken(Tokens.Increment);
+					break;
+				case UnaryOperatorType.Minus:
+					outputFormatter.PrintToken(Tokens.Minus);
+					break;
+				case UnaryOperatorType.Not:
+					outputFormatter.PrintToken(Tokens.Not);
+					break;
+				case UnaryOperatorType.Plus:
+					outputFormatter.PrintToken(Tokens.Plus);
+					break;
+				case UnaryOperatorType.PostDecrement:
+					unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+					outputFormatter.PrintToken(Tokens.Decrement);
+					return null;
+				case UnaryOperatorType.PostIncrement:
+					unaryOperatorExpression.Expression.AcceptVisitor(this, data);
+					outputFormatter.PrintToken(Tokens.Increment);
+					return null;
+				case UnaryOperatorType.Star:
+					outputFormatter.PrintToken(Tokens.Times);
+					break;
+				case UnaryOperatorType.BitWiseAnd:
+					outputFormatter.PrintToken(Tokens.BitwiseAnd);
+					break;
+			}
+			unaryOperatorExpression.Expression.AcceptVisitor(this, data);
 			return null;
 		}
 		
-		public object Visit(UncheckedExpression uncheckedExpression, object data)
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
 		{
-//			text.Append(&quot;unchecked(&quot;);
-//			uncheckedExpression.Expression.AcceptVisitor(this, data);
-//			text.Append(&quot;)&quot;);
+			outputFormatter.PrintToken(Tokens.Unchecked);
+			outputFormatter.PrintToken(Tokens.OpenParenthesis);
+			uncheckedExpression.Expression.AcceptVisitor(this, data);
+			outputFormatter.PrintToken(Tokens.CloseParenthesis);
 			return null;
 		}
 #endregion

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/SpecialVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/SpecialVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/PrettyPrinter/SpecialVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -19,10 +19,10 @@
 using System.Collections;
 using System.Diagnostics;
 
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.PrettyPrinter
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
 {
 //	
 //	public class SpecialVisitor

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/SharpRefactory.prjx
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/SharpRefactory.prjx	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/SharpRefactory.prjx	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,157 +1,160 @@
-&lt;Project name=&quot;SharpRefactory&quot; description=&quot;rfewewrwerewrwe&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
-  &lt;Contents&gt;
-    &lt;File name=&quot;.\Main.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\AssemblyInfo.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\AbstractASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\AttributeTargets.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\IASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\AbstractNode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\GlobalScope\AttributeSection.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\CompilationUnit.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\ConstructorDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\GlobalScope\DelegateDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\DestructorDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\EventAddRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\EventDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\EventRemoveRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\VariableDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\FieldDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\IndexerDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\INode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\MethodDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\GlobalScope\NamespaceDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\OperatorDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertyDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertyGetRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertySetRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\GlobalScope\TypeDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\TypeReference.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\GlobalScope\UsingAliasDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\GlobalScope\UsingDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\AssignmentExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\BaseReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\BinaryOperatorExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\CastExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\CheckedExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\ConditionalExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\DirectionExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\Expression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\FieldReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\IdentifierExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\IndexerExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\InvocationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\ObjectCreateExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel\ParameterDeclarationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\ParenthesizedExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\PointerReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\PrimitiveExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\SizeOfExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\StackAllocExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\ThisReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\TypeOfExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\TypeReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\UnaryOperatorExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\UncheckedExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\BlockStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\BreakStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\CheckedStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\ContinueStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\DoWhileStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\EmptyStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\FixedStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\ForeachStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\ForStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\GotoCaseStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\GotoStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\IfElseStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\IfStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\LabelStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\LockStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\ReturnStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\Statement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\StatementExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\SwitchStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\ThrowStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\TryCatchStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\UncheckedStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\UnsafeStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\UsingStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\LocalVariableDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Statements\WhileStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\TypeLevel&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\GlobalScope&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Enums.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\cs.ATG&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\gen.bat&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\Parser.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\Parser.frame&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\Scanner.frame&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\trace.txt&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Modifier.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\PrettyPrinter&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\PrettyPrinter\PrettyPrintVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\PrettyPrinter\PrettyPrintData.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\PrettyPrinter\PrettyPrintUtil.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\PrettyPrinter\SpecialVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\CodeDOM&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\CodeDOM\CodeDOMVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\DebugASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\ArrayInitializerExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\Expressions\ArrayCreateExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\Scanner.cs.gen&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\Scanner.frame~&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\VBConverter&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\VBConverter\VBNetVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\VBConverter\VBNetRefactory.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\cs.ATG~&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\Parser.frame~&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Reader\IReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Reader\FileReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Reader\StringReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Reader&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Lexer.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\Error.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\Modifiers.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\generated\ParserUtil.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Specials\SpecialTracker.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Specials&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Specials\SpecialType.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Specials\PreProcessingDirective.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Specials\Comment.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Specials\BlankLine.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Specials\CommentType.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Parser\AST\LookupTableVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\PrettyPrinter\OutputFormatter.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-    &lt;File name=&quot;.\Lexer\Tokens.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
-  &lt;/Contents&gt;
-  &lt;References /&gt;
-  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
-  &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
-    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
-    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
-    &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactory&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
-  &lt;/Configuration&gt;
-  &lt;Configurations active=&quot;Release&quot;&gt;
-    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
-      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Module&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
-      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
-      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactory&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;.\Parser\generated\gen.bat&quot; executeAfterBuild=&quot;&quot; /&gt;
-    &lt;/Configuration&gt;
-    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
-      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
-      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
-      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactory&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
-    &lt;/Configuration&gt;
-    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug2&quot;&gt;
-      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Exe&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
-      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
-      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;SharpRefactory&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
-    &lt;/Configuration&gt;
-    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;New Configuration&quot;&gt;
-      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Exe&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
-      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
-      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;SharpRefactory&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
-    &lt;/Configuration&gt;
-  &lt;/Configurations&gt;
+&lt;Project name=&quot;SharpRefactory&quot; standardNamespace=&quot;NewProject&quot; description=&quot;rfewewrwerewrwe&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
+  &lt;Contents&gt;
+    &lt;File name=&quot;.\Main.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\AssemblyInfo.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\AbstractASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\AttributeTargets.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\IASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\AbstractNode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\AttributeSection.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\CompilationUnit.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\ConstructorDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\DelegateDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\DestructorDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\EventAddRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\EventDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\EventRemoveRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\VariableDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\FieldDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\IndexerDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\INode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\MethodDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\NamespaceDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\OperatorDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertyDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertyGetRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\PropertySetRegion.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\TypeDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\TypeReference.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\UsingAliasDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope\UsingDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\AssignmentExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\BaseReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\BinaryOperatorExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\CastExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\CheckedExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ConditionalExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\DirectionExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\Expression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\FieldReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\IdentifierExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\IndexerExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\InvocationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ObjectCreateExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel\ParameterDeclarationExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ParenthesizedExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\PointerReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\PrimitiveExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\SizeOfExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\StackAllocExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ThisReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\TypeOfExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\TypeReferenceExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\UnaryOperatorExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\UncheckedExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\BlockStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\BreakStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\CheckedStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ContinueStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\DoWhileStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\EmptyStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\FixedStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ForeachStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ForStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\GotoCaseStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\GotoStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\IfElseStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\IfStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\LabelStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\LockStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ReturnStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\Statement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\StatementExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\SwitchStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\ThrowStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\TryCatchStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\UncheckedStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\UnsafeStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\UsingStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\LocalVariableDeclaration.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Statements\WhileStatement.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\TypeLevel&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\GlobalScope&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Enums.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\cs.ATG&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\gen.bat&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Parser.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Parser.frame&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Scanner.frame&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\trace.txt&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Modifier.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\PrettyPrinter&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\PrettyPrinter\PrettyPrintVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\PrettyPrinter\PrettyPrintData.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\PrettyPrinter\PrettyPrintUtil.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\PrettyPrinter\SpecialVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\CodeDOM&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\CodeDOM\CodeDOMVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\DebugASTVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ArrayInitializerExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\Expressions\ArrayCreateExpression.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Scanner.cs.gen&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Scanner.frame~&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\VBConverter&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\VBConverter\VBNetVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\VBConverter\VBNetRefactory.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\cs.ATG~&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Parser.frame~&quot; subtype=&quot;Code&quot; buildaction=&quot;Exclude&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\IReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\FileReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader\StringReader.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Reader&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Lexer.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Error.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\Modifiers.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\ParserUtil.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\SpecialTracker.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\SpecialType.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\PreProcessingDirective.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\Comment.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\BlankLine.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Lexer\Specials\CommentType.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\AST\LookupTableVisitor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\PrettyPrinter\OutputFormatter.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\Tokens.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\CSharpKeywordList.txt&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;.\Parser\generated\keywordlist\Keywords.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+  &lt;/Contents&gt;
+  &lt;References /&gt;
+  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
+  &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+    &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactory&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;.\Parser\generated\gen.bat&quot; executeAfterBuild=&quot;&quot; /&gt;
+  &lt;/Configuration&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactory&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;.\Parser\generated\gen.bat&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;0&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactory&quot; executeScript=&quot;..\..\..\..\bin\SharpDevelop.exe&quot; executeBeforeBuild=&quot;.\Parser\generated\gen.bat&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Executable&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Exe&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactory&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Executable/withoutATGGen&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Exe&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;..\..\..\..\bin&quot; assembly=&quot;ICSharpCode.SharpRefactory&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
 &lt;/Project&gt;
\ No newline at end of file

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/VBConverter/VBNetRefactory.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/VBConverter/VBNetRefactory.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/VBConverter/VBNetRefactory.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -22,10 +22,10 @@
 using System.Collections;
 
 
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.PrettyPrinter
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
 {
 	public class VBNetRefactory
 	{

Modified: trunk/MonoDevelop/src/Libraries/SharpRefactory/src/VBConverter/VBNetVisitor.cs
===================================================================
--- trunk/MonoDevelop/src/Libraries/SharpRefactory/src/VBConverter/VBNetVisitor.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Libraries/SharpRefactory/src/VBConverter/VBNetVisitor.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -22,12 +22,12 @@
 using System.Collections;
 
 
-using MonoDevelop.SharpRefactory.Parser;
-using MonoDevelop.SharpRefactory.Parser.AST;
+using ICSharpCode.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.Parser.AST;
 
-namespace MonoDevelop.SharpRefactory.PrettyPrinter
+namespace ICSharpCode.SharpRefactory.PrettyPrinter
 {
-	public class VBNetVisitor : IASTVisitor
+	public class VBNetVisitor : AbstractASTVisitor
 	{
 		StringBuilder   sourceText  = new StringBuilder();
 		int             indentLevel = 0;
@@ -40,11 +40,13 @@
 			}
 		}
 		
-#region MonoDevelop.SharpRefactory.Parser.IASTVisitor interface implementation
-		public object Visit(INode node, object data)
+#region ICSharpCode.SharpRefactory.Parser.IASTVisitor interface implementation
+		public override object Visit(INode node, object data)
 		{
-			errors.Error(-1, -1, String.Format(&quot;visited unknown node '{0}' &quot;, node));
-			return String.Empty;
+			errors.Error(-1, -1, String.Format(&quot;Visited INode (should NEVER HAPPEN)&quot;));
+			Console.WriteLine(&quot;Visitor was: &quot; + this.GetType());
+			Console.WriteLine(&quot;Node was : &quot; + node.GetType());
+			return node.AcceptChildren(this, data);
 		}
 		
 		public void AppendIndentation()
@@ -64,7 +66,7 @@
 //			Console.WriteLine(o.ToString());
 		}
 		
-		public object Visit(CompilationUnit compilationUnit, object data)
+		public override object Visit(CompilationUnit compilationUnit, object data)
 		{
 			DebugOutput(compilationUnit);
 			new VBNetRefactory().Refactor(compilationUnit);
@@ -72,7 +74,7 @@
 			return null;
 		}
 		
-		public object Visit(NamespaceDeclaration namespaceDeclaration, object data)
+		public override object Visit(NamespaceDeclaration namespaceDeclaration, object data)
 		{
 			DebugOutput(namespaceDeclaration);
 			AppendIndentation();sourceText.Append(&quot;Namespace &quot;);
@@ -86,7 +88,7 @@
 			return null;
 		}
 		
-		public object Visit(UsingDeclaration usingDeclaration, object data)
+		public override object Visit(UsingDeclaration usingDeclaration, object data)
 		{
 			DebugOutput(usingDeclaration);
 			AppendIndentation();sourceText.Append(&quot;Imports &quot;);
@@ -95,7 +97,7 @@
 			return null;
 		}
 		
-		public object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
+		public override object Visit(UsingAliasDeclaration usingAliasDeclaration, object data)
 		{
 			DebugOutput(usingAliasDeclaration);
 			AppendIndentation();sourceText.Append(&quot;Imports &quot;);
@@ -106,7 +108,7 @@
 			return null;
 		}
 		
-		public object Visit(AttributeSection attributeSection, object data)
+		public override object Visit(AttributeSection attributeSection, object data)
 		{
 			DebugOutput(attributeSection);
 			AppendIndentation();sourceText.Append(&quot;&lt;&quot;);
@@ -115,7 +117,7 @@
 				sourceText.Append(&quot;: &quot;);
 			}
 			for (int j = 0; j &lt; attributeSection.Attributes.Count; ++j) {
-				MonoDevelop.SharpRefactory.Parser.AST.Attribute attr = (MonoDevelop.SharpRefactory.Parser.AST.Attribute)attributeSection.Attributes[j];
+				ICSharpCode.SharpRefactory.Parser.AST.Attribute attr = (ICSharpCode.SharpRefactory.Parser.AST.Attribute)attributeSection.Attributes[j];
 				
 				sourceText.Append(attr.Name);
 				sourceText.Append(&quot;(&quot;);
@@ -126,7 +128,7 @@
 						sourceText.Append(&quot;, &quot;);
 					}
 				}
-
+				
 				for (int i = 0; i &lt; attr.NamedArguments.Count; ++i) {
 					NamedArgument named = (NamedArgument)attr.NamedArguments[i];
 					sourceText.Append(named.Name);
@@ -149,7 +151,7 @@
 			return null;
 		}
 		
-		public object Visit(TypeDeclaration typeDeclaration, object data)
+		public override object Visit(TypeDeclaration typeDeclaration, object data)
 		{
 			DebugOutput(typeDeclaration);
 			AppendNewLine();
@@ -210,7 +212,7 @@
 			return null;
 		}
 		
-		public object Visit(DelegateDeclaration delegateDeclaration, object data)
+		public override object Visit(DelegateDeclaration delegateDeclaration, object data)
 		{
 			DebugOutput(delegateDeclaration);
 			AppendNewLine();
@@ -236,7 +238,7 @@
 			return null;
 		}
 		
-		public object Visit(VariableDeclaration variableDeclaration, object data)
+		public override object Visit(VariableDeclaration variableDeclaration, object data)
 		{
 			// called inside ENUMS
 //			AppendAttributes(field.Attributes);
@@ -249,7 +251,7 @@
 			return null;
 		}
 		
-		public object Visit(FieldDeclaration fieldDeclaration, object data)
+		public override object Visit(FieldDeclaration fieldDeclaration, object data)
 		{
 			DebugOutput(fieldDeclaration);
 			foreach (VariableDeclaration field in fieldDeclaration.Fields) {
@@ -273,7 +275,7 @@
 			return null;
 		}
 		
-		public object Visit(MethodDeclaration methodDeclaration, object data)
+		public override object Visit(MethodDeclaration methodDeclaration, object data)
 		{
 			DebugOutput(methodDeclaration);
 			AppendNewLine();
@@ -307,7 +309,7 @@
 			return null;
 		}
 		
-		public object Visit(PropertyDeclaration propertyDeclaration, object data)
+		public override object Visit(PropertyDeclaration propertyDeclaration, object data)
 		{
 			DebugOutput(propertyDeclaration);
 			AppendNewLine();
@@ -343,7 +345,7 @@
 			return null;
 		}
 		
-		public object Visit(PropertyGetRegion propertyGetRegion, object data)
+		public override object Visit(PropertyGetRegion propertyGetRegion, object data)
 		{
 			DebugOutput(propertyGetRegion);
 			AppendAttributes(propertyGetRegion.Attributes);
@@ -360,7 +362,7 @@
 			return null;
 		}
 		
-		public object Visit(PropertySetRegion propertySetRegion, object data)
+		public override object Visit(PropertySetRegion propertySetRegion, object data)
 		{
 			DebugOutput(propertySetRegion);
 			AppendAttributes(propertySetRegion.Attributes);
@@ -378,7 +380,7 @@
 			return null;
 		}
 		
-		public object Visit(EventDeclaration eventDeclaration, object data)
+		public override object Visit(EventDeclaration eventDeclaration, object data)
 		{
 			DebugOutput(eventDeclaration);
 			AppendNewLine();
@@ -412,19 +414,19 @@
 			return data;
 		}
 		
-		public object Visit(EventAddRegion eventAddRegion, object data)
+		public override object Visit(EventAddRegion eventAddRegion, object data)
 		{
 			// should never be called:
 			throw new System.NotSupportedException();
 		}
 		
-		public object Visit(EventRemoveRegion eventRemoveRegion, object data)
+		public override object Visit(EventRemoveRegion eventRemoveRegion, object data)
 		{
 			// should never be called:
 			throw new System.NotSupportedException();
 		}
 		
-		public object Visit(ConstructorDeclaration constructorDeclaration, object data)
+		public override object Visit(ConstructorDeclaration constructorDeclaration, object data)
 		{
 			DebugOutput(constructorDeclaration);
 			AppendNewLine();
@@ -444,7 +446,7 @@
 			return null;
 		}
 		
-		public object Visit(DestructorDeclaration destructorDeclaration, object data)
+		public override object Visit(DestructorDeclaration destructorDeclaration, object data)
 		{
 			DebugOutput(destructorDeclaration);
 			AppendNewLine();
@@ -460,13 +462,13 @@
 			return null;
 		}
 		
-		public object Visit(OperatorDeclaration operatorDeclaration, object data)
+		public override object Visit(OperatorDeclaration operatorDeclaration, object data)
 		{
 			errors.Error(-1, -1, String.Format(&quot;Operator overloading cannot be performed&quot;));
 			return null;
 		}
 		
-		public object Visit(IndexerDeclaration indexerDeclaration, object data)
+		public override object Visit(IndexerDeclaration indexerDeclaration, object data)
 		{
 			DebugOutput(indexerDeclaration);
 			
@@ -498,14 +500,14 @@
 			return null;
 		}
 		
-		public object Visit(BlockStatement blockStatement, object data)
+		public override object Visit(BlockStatement blockStatement, object data)
 		{
 			DebugOutput(blockStatement);
 			blockStatement.AcceptChildren(this, data);
 			return null;
 		}
 		
-		public object Visit(StatementExpression statementExpression, object data)
+		public override object Visit(StatementExpression statementExpression, object data)
 		{
 			DebugOutput(statementExpression);
 			AppendIndentation();sourceText.Append(statementExpression.Expression.AcceptVisitor(this, statementExpression).ToString());
@@ -513,7 +515,7 @@
 			return null;
 		}
 		
-		public object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
+		public override object Visit(LocalVariableDeclaration localVariableDeclaration, object data)
 		{
 			DebugOutput(localVariableDeclaration);
 			foreach (VariableDeclaration localVar in localVariableDeclaration.Variables) {
@@ -546,14 +548,14 @@
 			return null;
 		}
 		
-		public object Visit(EmptyStatement emptyStatement, object data)
+		public override object Visit(EmptyStatement emptyStatement, object data)
 		{
 			DebugOutput(emptyStatement);
 			AppendNewLine();
 			return null;
 		}
 		
-		public object Visit(ReturnStatement returnStatement, object data)
+		public override object Visit(ReturnStatement returnStatement, object data)
 		{
 			DebugOutput(returnStatement);
 			AppendIndentation();sourceText.Append(&quot;Return&quot;);
@@ -565,7 +567,7 @@
 			return null;
 		}
 		
-		public object Visit(IfStatement ifStatement, object data)
+		public override object Visit(IfStatement ifStatement, object data)
 		{
 			DebugOutput(ifStatement);
 			AppendIndentation();
@@ -591,7 +593,7 @@
 			return null;
 		}
 		
-		public object Visit(IfElseStatement ifElseStatement, object data)
+		public override object Visit(IfElseStatement ifElseStatement, object data)
 		{
 			DebugOutput(ifElseStatement);
 			AppendIndentation();sourceText.Append(&quot;If &quot;);
@@ -615,7 +617,7 @@
 			return null;
 		}
 		
-		public object Visit(WhileStatement whileStatement, object data)
+		public override object Visit(WhileStatement whileStatement, object data)
 		{
 			DebugOutput(whileStatement);
 			AppendIndentation();sourceText.Append(&quot;While &quot;);
@@ -631,7 +633,7 @@
 			return null;
 		}
 		
-		public object Visit(DoWhileStatement doWhileStatement, object data)
+		public override object Visit(DoWhileStatement doWhileStatement, object data)
 		{
 			DebugOutput(doWhileStatement);
 			AppendIndentation();sourceText.Append(&quot;Do While&quot;);
@@ -647,7 +649,7 @@
 			return null;
 		}
 		
-		public object Visit(ForStatement forStatement, object data)
+		public override object Visit(ForStatement forStatement, object data)
 		{
 			DebugOutput(forStatement);
 			if (forStatement.Initializers != null) {
@@ -685,7 +687,7 @@
 			return null;
 		}
 		
-		public object Visit(LabelStatement labelStatement, object data)
+		public override object Visit(LabelStatement labelStatement, object data)
 		{
 			DebugOutput(labelStatement);
 			AppendIndentation();sourceText.Append(labelStatement.Label);
@@ -694,7 +696,7 @@
 			return null;
 		}
 		
-		public object Visit(GotoStatement gotoStatement, object data)
+		public override object Visit(GotoStatement gotoStatement, object data)
 		{
 			DebugOutput(gotoStatement);
 			AppendIndentation();sourceText.Append(&quot;Goto &quot;);
@@ -703,7 +705,7 @@
 			return null;
 		}
 		
-		public object Visit(SwitchStatement switchStatement, object data)
+		public override object Visit(SwitchStatement switchStatement, object data)
 		{
 			DebugOutput(switchStatement);
 			AppendIndentation();sourceText.Append(&quot;Select &quot;);
@@ -734,7 +736,7 @@
 			return null;
 		}
 		
-		public object Visit(BreakStatement breakStatement, object data)
+		public override object Visit(BreakStatement breakStatement, object data)
 		{
 			DebugOutput(breakStatement);
 			AppendIndentation();sourceText.Append(&quot;' break&quot;);
@@ -742,7 +744,7 @@
 			return null;
 		}
 		
-		public object Visit(ContinueStatement continueStatement, object data)
+		public override object Visit(ContinueStatement continueStatement, object data)
 		{
 			DebugOutput(continueStatement);
 			AppendIndentation();sourceText.Append(&quot;' continue&quot;);
@@ -750,7 +752,7 @@
 			return null;
 		}
 		
-		public object Visit(GotoCaseStatement gotoCaseStatement, object data)
+		public override object Visit(GotoCaseStatement gotoCaseStatement, object data)
 		{
 			DebugOutput(gotoCaseStatement);
 			AppendIndentation();sourceText.Append(&quot;' goto case &quot;);
@@ -763,7 +765,7 @@
 			return null;
 		}
 		
-		public object Visit(ForeachStatement foreachStatement, object data)
+		public override object Visit(ForeachStatement foreachStatement, object data)
 		{
 			DebugOutput(foreachStatement);
 			AppendIndentation();sourceText.Append(&quot;For Each &quot;);
@@ -783,7 +785,7 @@
 			return null;
 		}
 		
-		public object Visit(LockStatement lockStatement, object data)
+		public override object Visit(LockStatement lockStatement, object data)
 		{
 			DebugOutput(lockStatement);
 			AppendIndentation();sourceText.Append(&quot;SyncLock &quot;);
@@ -799,7 +801,7 @@
 			return null;
 		}
 		
-		public object Visit(UsingStatement usingStatement, object data)
+		public override object Visit(UsingStatement usingStatement, object data)
 		{
 			DebugOutput(usingStatement);
 			// TODO : anything like this ?
@@ -811,7 +813,7 @@
 			return null;
 		}
 		
-		public object Visit(TryCatchStatement tryCatchStatement, object data)
+		public override object Visit(TryCatchStatement tryCatchStatement, object data)
 		{
 			DebugOutput(tryCatchStatement);
 			AppendIndentation();sourceText.Append(&quot;Try&quot;);
@@ -853,7 +855,7 @@
 			return null;
 		}
 		
-		public object Visit(ThrowStatement throwStatement, object data)
+		public override object Visit(ThrowStatement throwStatement, object data)
 		{
 			DebugOutput(throwStatement);
 			AppendIndentation();sourceText.Append(&quot;Throw &quot;);
@@ -862,28 +864,28 @@
 			return null;
 		}
 		
-		public object Visit(FixedStatement fixedStatement, object data)
+		public override object Visit(FixedStatement fixedStatement, object data)
 		{
 			DebugOutput(fixedStatement);
 			errors.Error(-1, -1, String.Format(&quot;fixed statement not suported by VB.NET&quot;));
 			return null;
 		}
 		
-		public virtual object Visit(CheckedStatement checkedStatement, object data)
+		public override object Visit(CheckedStatement checkedStatement, object data)
 		{
 			DebugOutput(checkedStatement);
 			errors.Error(-1, -1, String.Format(&quot;checked statement not suported by VB.NET&quot;));
 			return null;
 		}
 		
-		public virtual object Visit(UncheckedStatement uncheckedStatement, object data)
+		public override object Visit(UncheckedStatement uncheckedStatement, object data)
 		{
 			DebugOutput(uncheckedStatement);
 			errors.Error(-1, -1, String.Format(&quot;unchecked statement not suported by VB.NET&quot;));
 			return null;
 		}
 		
-		public object Visit(PrimitiveExpression primitiveExpression, object data)
+		public override object Visit(PrimitiveExpression primitiveExpression, object data)
 		{
 			DebugOutput(primitiveExpression);
 			if (primitiveExpression.Value == null) {
@@ -911,7 +913,7 @@
 			return primitiveExpression.Value;
 		}
 		
-		public object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
+		public override object Visit(BinaryOperatorExpression binaryOperatorExpression, object data)
 		{
 			DebugOutput(binaryOperatorExpression);
 			string op = null;
@@ -969,7 +971,7 @@
 					                     left,
 					                     &quot;, GetType(&quot;,
 					                     right,
-					                     &quot;), &quot;,
+					                     &quot;)), &quot;,
 					                     right,
 					                     &quot;)&quot;);
 				case BinaryOperatorType.IS:
@@ -1017,7 +1019,7 @@
 			                     right);
 		}
 		
-		public object Visit(ParenthesizedExpression parenthesizedExpression, object data)
+		public override object Visit(ParenthesizedExpression parenthesizedExpression, object data)
 		{
 			DebugOutput(parenthesizedExpression);
 			string innerExpr = parenthesizedExpression.Expression.AcceptVisitor(this, data).ToString();
@@ -1031,7 +1033,7 @@
 			return String.Concat(&quot;(&quot;, innerExpr, &quot;)&quot;);
 		}
 		
-		public object Visit(InvocationExpression invocationExpression, object data)
+		public override object Visit(InvocationExpression invocationExpression, object data)
 		{
 			DebugOutput(invocationExpression);
 			string backString;
@@ -1057,19 +1059,19 @@
 			return backString;
 		}
 		
-		public object Visit(IdentifierExpression identifierExpression, object data)
+		public override object Visit(IdentifierExpression identifierExpression, object data)
 		{
 			DebugOutput(identifierExpression);
 			return identifierExpression.Identifier;
 		}
 		
-		public object Visit(TypeReferenceExpression typeReferenceExpression, object data)
+		public override object Visit(TypeReferenceExpression typeReferenceExpression, object data)
 		{
 			DebugOutput(typeReferenceExpression);
 			return GetTypeString(typeReferenceExpression.TypeReference);
 		}
 		
-		public object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
+		public override object Visit(UnaryOperatorExpression unaryOperatorExpression, object data)
 		{
 			DebugOutput(unaryOperatorExpression);
 			switch (unaryOperatorExpression.Op) {
@@ -1096,7 +1098,7 @@
 			throw new System.NotSupportedException();
 		}
 		
-		public object Visit(AssignmentExpression assignmentExpression, object data)
+		public override object Visit(AssignmentExpression assignmentExpression, object data)
 		{
 			DebugOutput(assignmentExpression);
 			string op   = null;
@@ -1149,14 +1151,14 @@
 			                     right);
 		}
 		
-		public object Visit(SizeOfExpression sizeOfExpression, object data)
+		public override object Visit(SizeOfExpression sizeOfExpression, object data)
 		{
 			DebugOutput(sizeOfExpression);
 			errors.Error(-1, -1, String.Format(&quot;sizeof expression not suported by VB.NET&quot;));
 			return null;
 		}
 		
-		public object Visit(TypeOfExpression typeOfExpression, object data)
+		public override object Visit(TypeOfExpression typeOfExpression, object data)
 		{
 			DebugOutput(typeOfExpression);
 			return String.Concat(&quot;GetType(&quot;,
@@ -1164,25 +1166,25 @@
 			                     &quot;)&quot;);
 		}
 		
-		public object Visit(CheckedExpression checkedExpression, object data)
+		public override object Visit(CheckedExpression checkedExpression, object data)
 		{
 			return String.Concat(&quot;'Checked expression (can't convert):&quot;,
 			                     checkedExpression.Expression.AcceptVisitor(this, data));
 		}
 		
-		public object Visit(UncheckedExpression uncheckedExpression, object data)
+		public override object Visit(UncheckedExpression uncheckedExpression, object data)
 		{
 			return String.Concat(&quot;'Unhecked expression (can't convert):&quot;,
 			                     uncheckedExpression.Expression.AcceptVisitor(this, data));
 		}
 		
-		public object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
+		public override object Visit(PointerReferenceExpression pointerReferenceExpression, object data)
 		{
 			errors.Error(-1, -1, String.Format(&quot;pointer reference (-&gt;) not suported by VB.NET&quot;));
 			return String.Empty;
 		}
 		
-		public object Visit(CastExpression castExpression, object data)
+		public override object Visit(CastExpression castExpression, object data)
 		{
 			DebugOutput(castExpression);
 			return String.Format(&quot;CType({0}, {1})&quot;,
@@ -1190,32 +1192,32 @@
 			                     GetTypeString(castExpression.CastTo));
 		}
 		
-		public object Visit(StackAllocExpression stackAllocExpression, object data)
+		public override object Visit(StackAllocExpression stackAllocExpression, object data)
 		{
 			errors.Error(-1, -1, String.Format(&quot;stack alloc expression not suported by VB.NET&quot;));
 			return String.Empty;
 		}
 		
-		public object Visit(IndexerExpression indexerExpression, object data)
+		public override object Visit(IndexerExpression indexerExpression, object data)
 		{
 			DebugOutput(indexerExpression);
 			return String.Concat(indexerExpression.TargetObject.AcceptVisitor(this, data),
 			                     GetParameters(indexerExpression.Indices));
 		}
 		
-		public object Visit(ThisReferenceExpression thisReferenceExpression, object data)
+		public override object Visit(ThisReferenceExpression thisReferenceExpression, object data)
 		{
 			DebugOutput(thisReferenceExpression);
 			return &quot;Me&quot;;
 		}
 		
-		public object Visit(BaseReferenceExpression baseReferenceExpression, object data)
+		public override object Visit(BaseReferenceExpression baseReferenceExpression, object data)
 		{
 			DebugOutput(baseReferenceExpression);
 			return &quot;MyBase&quot;;
 		}
 		
-		public object Visit(ObjectCreateExpression objectCreateExpression, object data)
+		public override object Visit(ObjectCreateExpression objectCreateExpression, object data)
 		{
 			DebugOutput(objectCreateExpression);
 			if (IsEventHandlerCreation(objectCreateExpression)) {
@@ -1234,7 +1236,7 @@
 			                     );
 		}
 		
-		public object Visit(ArrayCreateExpression arrayCreateExpression, object data)
+		public override object Visit(ArrayCreateExpression arrayCreateExpression, object data)
 		{
 			DebugOutput(arrayCreateExpression);
 			string arrayInitializer = String.Empty;
@@ -1247,10 +1249,13 @@
 			}
 			
 			if (arrayCreateExpression.Parameters != null &amp;&amp; arrayCreateExpression.Parameters.Count &gt; 0) {
-				foreach (Expression expr in arrayCreateExpression.Parameters) {
-					arrayParameters += &quot;(&quot;;
-					arrayParameters += expr.AcceptVisitor(this, data);
-					arrayParameters += &quot;)&quot;;
+				foreach (ArrayCreationParameter param in arrayCreateExpression.Parameters) {
+					// TODO: multidimensional arrays ?
+					foreach (Expression expr in param.Expressions) {
+						arrayParameters += &quot;(&quot;;
+						arrayParameters += expr.AcceptVisitor(this, data);
+						arrayParameters += &quot;)&quot;;
+					}
 				}
 			} else {
 				arrayParameters = &quot;()&quot;;
@@ -1263,13 +1268,13 @@
 			                     );
 		}
 		
-		public object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
+		public override object Visit(ParameterDeclarationExpression parameterDeclarationExpression, object data)
 		{
 			// should never be called:
 			throw new System.NotImplementedException();
 		}
 		
-		public object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
+		public override object Visit(FieldReferenceExpression fieldReferenceExpression, object data)
 		{
 			DebugOutput(fieldReferenceExpression);
 			if (fieldReferenceExpression.TargetObject is ObjectCreateExpression) {
@@ -1283,7 +1288,7 @@
 			                     fieldReferenceExpression.FieldName);
 		}
 		
-		public object Visit(DirectionExpression directionExpression, object data)
+		public override object Visit(DirectionExpression directionExpression, object data)
 		{
 			DebugOutput(directionExpression);
 			string fieldDirection = String.Empty;
@@ -1297,14 +1302,14 @@
 			return String.Concat(fieldDirection, directionExpression.Expression.AcceptVisitor(this, data));
 		}
 		
-		public object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
+		public override object Visit(ArrayInitializerExpression arrayInitializerExpression, object data)
 		{
 			return String.Concat(&quot; {&quot;,
 			                     GetExpressionList(arrayInitializerExpression.CreateExpressions),
 			                     &quot;}&quot;);
 		}
 		
-		public object Visit(ConditionalExpression conditionalExpression, object data)
+		public override object Visit(ConditionalExpression conditionalExpression, object data)
 		{
 			errors.Error(-1, -1, String.Format(&quot;TODO: Conditionals :)&quot;));
 			return String.Empty;
@@ -1411,10 +1416,6 @@
 				builder.Append(&quot;NotInheritable &quot;);
 			}
 			
-			if ((modifier &amp; Modifier.Sealed) == Modifier.Sealed) {
-				builder.Append(&quot;NotInheritable &quot;);
-			}
-			
 			if ((modifier &amp; Modifier.Const) == Modifier.Const) {
 				builder.Append(&quot;Const &quot;);
 			}
@@ -1422,10 +1423,6 @@
 				builder.Append(&quot;ReadOnly &quot;);
 			}
 			
-			if ((modifier &amp; Modifier.Const) == Modifier.Const) {
-				builder.Append(&quot;Const &quot;);
-			}
-			
 			// TODO : Extern 
 			if ((modifier &amp; Modifier.Extern) == Modifier.Extern) {
 				errors.Error(-1, -1, String.Format(&quot;'Extern' modifier not convertable&quot;));
@@ -1506,7 +1503,6 @@
 			if (op != null &amp;&amp; op.Op == BinaryOperatorType.InEquality) {
 				if (op.Left is IdentifierExpression &amp;&amp; op.Right is PrimitiveExpression &amp;&amp; ((PrimitiveExpression)op.Right).Value == null) {
 					string identifier = ((IdentifierExpression)op.Left).Identifier;
-					Console.WriteLine(ifStatement.EmbeddedStatement);
 					StatementExpression se = null;
 					if (ifStatement.EmbeddedStatement is StatementExpression) {
 						se = (StatementExpression)ifStatement.EmbeddedStatement;
@@ -1527,7 +1523,6 @@
 								}
 							}
 							if (methodName != null &amp;&amp; methodName == identifier) {
-								Console.WriteLine(methodName);
 								foreach (object o in this.currentType.Children) {
 									EventDeclaration ed = o as EventDeclaration;
 									if (ed != null) {

Added: trunk/MonoDevelop/src/Main/Base/ChangeLog
===================================================================
--- trunk/MonoDevelop/src/Main/Base/ChangeLog	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Main/Base/ChangeLog	2004-03-21 06:22:28 UTC (rev 1213)
@@ -0,0 +1,4 @@
+2004-04-21  Todd Berman  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">tberman at sevenl.net</A>&gt;
+
+	* Commands/VBConverter/ConvertProject.cs:
+	* Commands/VBConverter/ConvertBuffer.cs: Changed to use new parser

Modified: trunk/MonoDevelop/src/Main/Base/Commands/VBConverter/ConvertBuffer.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Commands/VBConverter/ConvertBuffer.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Main/Base/Commands/VBConverter/ConvertBuffer.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -26,8 +26,8 @@
 using MonoDevelop.Gui.Dialogs;
 using MonoDevelop.Services;
 
-using MonoDevelop.SharpRefactory.PrettyPrinter;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.PrettyPrinter;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace MonoDevelop.Commands
 {
@@ -40,7 +40,7 @@
 			if (window != null &amp;&amp; window.ViewContent is IEditable) {
 				
 				Parser p = new Parser();
-				p.Parse(new Lexer(new MonoDevelop.SharpRefactory.Parser.StringReader(((IEditable)window.ViewContent).Text)));
+				p.Parse(new Lexer(new ICSharpCode.SharpRefactory.Parser.StringReader(((IEditable)window.ViewContent).Text)));
 				
 				if (p.Errors.count &gt; 0) {
 					IMessageService messageService =(IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));

Modified: trunk/MonoDevelop/src/Main/Base/Commands/VBConverter/ConvertProject.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Commands/VBConverter/ConvertProject.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Main/Base/Commands/VBConverter/ConvertProject.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -26,8 +26,8 @@
 using MonoDevelop.Gui.Dialogs;
 using MonoDevelop.Services;
 
-using MonoDevelop.SharpRefactory.PrettyPrinter;
-using MonoDevelop.SharpRefactory.Parser;
+using ICSharpCode.SharpRefactory.PrettyPrinter;
+using ICSharpCode.SharpRefactory.Parser;
 
 namespace MonoDevelop.Commands
 {

Modified: trunk/MonoDevelop/src/Main/Base/Services/MonodocService.cs
===================================================================
--- trunk/MonoDevelop/src/Main/Base/Services/MonodocService.cs	2004-03-21 06:19:29 UTC (rev 1212)
+++ trunk/MonoDevelop/src/Main/Base/Services/MonodocService.cs	2004-03-21 06:22:28 UTC (rev 1213)
@@ -1,4 +1,5 @@
 using System;
+using System.Xml;
 
 using Monodoc;
 
@@ -21,6 +22,8 @@
 			get { return helpTree; }
 		}
 
+		//public XmlDocument GetHelpXml (string type) {
+		//	return helpTree.GetHelpXml (&quot;T:&quot; + type);
+		//}
 	}
-
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000819.html">[Monodevelop-patches-list] r1212 - in trunk/MonoDevelop: . src/AddIns/DisplayBindings/SourceEditor/Search
</A></li>
	<LI>Next message: <A HREF="000821.html">[Monodevelop-patches-list] r1214 - in trunk/MonoDevelop/src/Main/Base: . Commands
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#820">[ date ]</a>
              <a href="thread.html#820">[ thread ]</a>
              <a href="subject.html#820">[ subject ]</a>
              <a href="author.html#820">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
