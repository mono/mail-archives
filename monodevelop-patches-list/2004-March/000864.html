<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-patches-list] r1257 - in trunk/MonoDevelop: . build/AddIns src/AddIns src/AddIns/BackendBindings/JavaBinding src/AddIns/Nunit src/AddIns/Nunit/Commands src/AddIns/Nunit/Gui src/AddIns/Nunit/Services
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1257%20-%20in%20trunk/MonoDevelop%3A%20.%20build/AddIns%20src/AddIns%20src/AddIns/BackendBindings/JavaBinding%20src/AddIns/Nunit%20src/AddIns/Nunit/Commands%20src/AddIns/Nunit/Gui%20src/AddIns/Nunit/Services&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000863.html">
   <LINK REL="Next"  HREF="000865.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-patches-list] r1257 - in trunk/MonoDevelop: . build/AddIns src/AddIns src/AddIns/BackendBindings/JavaBinding src/AddIns/Nunit src/AddIns/Nunit/Commands src/AddIns/Nunit/Gui src/AddIns/Nunit/Services</H1>
    <B>commit-watcher at mono-cvs.ximian.com</B> 
    <A HREF="mailto:monodevelop-patches-list%40lists.ximian.com?Subject=%5BMonodevelop-patches-list%5D%20r1257%20-%20in%20trunk/MonoDevelop%3A%20.%20build/AddIns%20src/AddIns%20src/AddIns/BackendBindings/JavaBinding%20src/AddIns/Nunit%20src/AddIns/Nunit/Commands%20src/AddIns/Nunit/Gui%20src/AddIns/Nunit/Services&In-Reply-To="
       TITLE="[Monodevelop-patches-list] r1257 - in trunk/MonoDevelop: . build/AddIns src/AddIns src/AddIns/BackendBindings/JavaBinding src/AddIns/Nunit src/AddIns/Nunit/Commands src/AddIns/Nunit/Gui src/AddIns/Nunit/Services">commit-watcher at mono-cvs.ximian.com
       </A><BR>
    <I>Fri Mar 26 15:22:28 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000863.html">[Monodevelop-patches-list] r1256 - in trunk/md-website: . tutorials
</A></li>
        <LI>Next message: <A HREF="000865.html">[Monodevelop-patches-list] r1258 - in trunk/MonoDevelop: . src/AddIns src/AddIns/Nunit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#864">[ date ]</a>
              <a href="thread.html#864">[ thread ]</a>
              <a href="subject.html#864">[ subject ]</a>
              <a href="author.html#864">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jluke
Date: 2004-03-26 15:22:28 -0500 (Fri, 26 Mar 2004)
New Revision: 1257

Added:
   trunk/MonoDevelop/src/AddIns/Nunit/
   trunk/MonoDevelop/src/AddIns/Nunit/AssemblyInfo.cs
   trunk/MonoDevelop/src/AddIns/Nunit/ChangeLog
   trunk/MonoDevelop/src/AddIns/Nunit/Commands/
   trunk/MonoDevelop/src/AddIns/Nunit/Commands/NunitCommands.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Gui/
   trunk/MonoDevelop/src/AddIns/Nunit/Gui/NunitResultTree.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Gui/NunitTestTree.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Makefile.am
   trunk/MonoDevelop/src/AddIns/Nunit/MonoDevelopNunit.addin
   trunk/MonoDevelop/src/AddIns/Nunit/README
   trunk/MonoDevelop/src/AddIns/Nunit/Services/
   trunk/MonoDevelop/src/AddIns/Nunit/Services/AssemblyStore.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/CancelTestsException.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/CircleRenderer.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/Delegates.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/FixtureAddedEventArgs.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/FixtureLoadErrorEventArgs.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/NunitService.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedEvent.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedSuiteFinish.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedSuiteStart.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestEvent.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestFinish.cs
   trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestStart.cs
   trunk/MonoDevelop/src/AddIns/Nunit/TODO
Modified:
   trunk/MonoDevelop/build/AddIns/
   trunk/MonoDevelop/configure.in
   trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding/
Log:
initial gnunit port,
note it does not even almost work



Property changes on: trunk/MonoDevelop/build/AddIns
___________________________________________________________________
Name: svn:ignore
   - Makefile
Makefile.in
MonoDevelop.Debugger.dll
MonoDevelopDebugger.addin

   + Makefile
Makefile.in
MonoDevelop.Debugger.dll
MonoDevelopDebugger.addin
MonoDevelop.Nunit.dll
MonoDevelopNunit.addin


Modified: trunk/MonoDevelop/configure.in
===================================================================
--- trunk/MonoDevelop/configure.in	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/configure.in	2004-03-26 20:22:28 UTC (rev 1257)
@@ -166,6 +166,7 @@
 src/AddIns/DebuggerAddIn/AssemblyInfo.cs
 src/AddIns/DisplayBindings/SourceEditor/AssemblyInfo.cs
 src/AddIns/Misc/StartPage/AssemblyInfo.cs
+src/AddIns/Nunit/Makefile
 src/Main/StartUp/AssemblyInfo.cs
 src/Main/Base/AssemblyInfo.cs
 src/Libraries/MonoDevelop.Gui.Widgets/AssemblyInfo.cs


Property changes on: trunk/MonoDevelop/src/AddIns/BackendBindings/JavaBinding
___________________________________________________________________
Name: svn:ignore
   - Makefile
Makefile.am
*.dll

   + Makefile
Makefile.in
*.dll



Property changes on: trunk/MonoDevelop/src/AddIns/Nunit
___________________________________________________________________
Name: svn:ignore
   + Makefile
Makefile.in
*.dll


Added: trunk/MonoDevelop/src/AddIns/Nunit/AssemblyInfo.cs
===================================================================

Added: trunk/MonoDevelop/src/AddIns/Nunit/ChangeLog
===================================================================

Added: trunk/MonoDevelop/src/AddIns/Nunit/Commands/NunitCommands.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Commands/NunitCommands.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Commands/NunitCommands.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,38 @@
+using System;
+using System.IO;
+using Gtk;
+
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Services;
+using MonoDevelop.Core.Services;
+
+namespace MonoDevelop.Commands
+{
+	public class NunitLoadAssembly : AbstractMenuCommand
+	{
+		public override void Run ()
+		{
+			NunitService nunitService = (NunitService) MonoDevelop.Core.Services.ServiceManager.Services.GetService (typeof (NunitService));
+
+			using (FileSelection fs = new FileSelection (&quot;Load test assembly&quot;)) {
+				string defaultPath = Path.Combine (Environment.GetEnvironmentVariable (&quot;HOME&quot;), &quot;MonoDevelopProjects&quot;);
+				fs.Complete (defaultPath);
+
+				if (fs.Run () == (int) Gtk.ResponseType.Ok)
+				{
+					nunitService.LoadAssembly (fs.Filename);
+				}
+
+				fs.Hide ();
+			}
+		}
+	}
+
+	public class NunitRunTests : AbstractMenuCommand
+	{
+		public override void Run ()
+		{
+			Console.WriteLine (&quot;Not implemented&quot;);
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Gui/NunitResultTree.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Gui/NunitResultTree.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Gui/NunitResultTree.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,42 @@
+//
+// NunitPad - Pad to embed nunit-gtk
+//
+// Author: John Luke &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jluke at cfl.rr.com</A>&gt;
+//
+// (C) 2004 John Luke
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Text;
+using Gtk;
+
+using MonoDevelop.Gui;
+using MonoDevelop.Services;
+using MonoDevelop.Services.Nunit;
+using MonoDevelop.Core.Services;
+using NUnit.Core;
+
+namespace MonoDevelop.Nunit.Gui
+{
+	public class ResultTree : AbstractViewContent
+	{
+		TreeView resultTree = new TreeView ();
+
+		public ResultTree ()
+		{
+
+		}
+
+		public override Widget Control
+		{
+			get {
+				return resultTree;
+			}
+		}
+
+		public override void Load (string content)
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Gui/NunitTestTree.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Gui/NunitTestTree.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Gui/NunitTestTree.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,324 @@
+//
+// NunitPad - Pad to embed nunit-gtk
+//
+// Author: John Luke &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jluke at cfl.rr.com</A>&gt;
+//
+// (C) 2004 John Luke
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Text;
+using Gtk;
+
+using MonoDevelop.Gui;
+using MonoDevelop.Services;
+using MonoDevelop.Services.Nunit;
+using MonoDevelop.Core.Services;
+using NUnit.Core;
+
+namespace MonoDevelop.Nunit.Gui
+{
+	public class TestTree : AbstractPadContent, EventListener
+	{
+		NunitService ns = (NunitService) ServiceManager.Services.GetService (typeof (NunitService));
+		IStatusBarService sbs = (IStatusBarService) ServiceManager.Services.GetService (typeof (IStatusBarService));
+
+		ScrolledWindow sw = new ScrolledWindow ();
+		Notebook notebook;
+
+		Label [] nbLabels;
+		Label failuresLabel = new Label ();
+		Label stderrLabel = new Label ();
+		Label stdoutLabel = new Label ();
+		Label notRunLabel = new Label ();
+		Label runStatus = new Label ();
+
+		TreeView failures = new TreeView ();
+		TreeView notRun = new TreeView ();
+		TextView stdoutTV = new TextView ();
+		TextView stderrTV = new TextView ();
+		TreeView assemblyView = new TreeView ();
+
+		AssemblyStore store;
+		TreeStore notRunStore;
+		TreeStore failuresStore;
+		TreeViewColumn nameCol;
+
+		Hashtable errorIters;
+		TextWriter origStdout = Console.Out;
+        TextWriter origStderr = Console.Error;
+        StringWriter stdout = new StringWriter ();
+        StringWriter stderr = new StringWriter ();
+
+		CellRendererPixbuf pr;
+		CellRendererText tr;
+
+		int ntests;
+		int finishedTests;
+        int ignoredTests;
+        int errorTests;
+		long startTime;
+		long lastTick = -1;
+		
+		// FIXME: obviously the icon is a placeholder
+		public TestTree () : base (&quot;NUnit&quot;, Gtk.Stock.Help)
+		{
+			pr = new CellRendererPixbuf ();
+			tr = new CellRendererText ();
+			assemblyView.PopupMenu += new PopupMenuHandler (OnPopupMenu);
+			store = ns.AssemblyStore;
+
+
+			nameCol = new TreeViewColumn ();
+            nameCol.PackStart (pr, false);
+            nameCol.SetCellDataFunc (pr, CircleRenderer.CellDataFunc, IntPtr.Zero, null);
+            nameCol.PackStart (tr, false);
+            nameCol.AddAttribute (tr, &quot;text&quot;, 1);
+            assemblyView.AppendColumn (nameCol);
+
+			sw.Add (assemblyView);
+		}
+		
+		public override Gtk.Widget Control
+		{
+			get { return sw; }
+		}
+
+		void OnPopupMenu (object o, PopupMenuArgs args)
+		{
+			ShowPopup ();
+		}
+
+		void ShowPopup ()
+		{
+			Menu menu = new Menu ();
+			MenuItem load = new MenuItem (&quot;Load assembly&quot;);
+			load.Activated += new EventHandler (OnLoadActivated);
+			menu.Append (load);
+			menu.Popup (null, null, null, IntPtr.Zero, 3, Global.CurrentEventTime);
+			menu.ShowAll ();
+		}
+
+		void OnLoadActivated (object o, EventArgs args)
+		{
+		}
+
+		// assemblyView events
+        void OnTestActivated (object sender, RowActivatedArgs args)
+        {
+            if (store == null)
+                return;
+
+            TreeView tv = (TreeView) sender;
+            tv.ExpandRow (args.Path, true);
+            if (!store.Running) {
+                PrepareRun ();
+                store.RunTestAtPath (args.Path, this, ref ntests);
+            }
+        }
+
+		void PrepareRun ()
+        {
+            if (errorIters != null)
+                errorIters.Clear ();
+
+            if (notRunStore != null)
+                notRunStore.Clear ();
+
+            if (failuresStore != null)
+                failuresStore.Clear ();
+
+            stdoutTV.Buffer.Clear ();
+            stderrTV.Buffer.Clear ();
+            foreach (Label l in nbLabels)
+                SetColorLabel (l, false);
+
+            errorTests = 0;
+            ignoredTests = 0;
+
+            ntests = -1;
+            finishedTests = 0;
+            sbs.ProgressMonitor.Worked (0.0, &quot;&quot;);
+
+			sbs.SetMessage (&quot;Running tests...&quot;);
+            SetStringWriters ();
+            ToggleMenues (false);
+            startTime = DateTime.Now.Ticks;
+            ClockUpdater (this, EventArgs.Empty);
+        }
+
+		void SetStringWriters ()
+        {
+            Console.SetOut (stdout);
+            Console.SetError (stderr);
+        }
+
+		void ToggleMenues (bool saveAs)
+        {/*
+            if (btnStop.Sensitive) {
+                btnOpen.Sensitive = true;
+                btnSaveAs.Sensitive = saveAs;
+                menuSaveAs.Sensitive = saveAs;
+                btnRun.Sensitive = true;
+                btnExit.Sensitive = true;
+                btnStop.Sensitive = false;
+                menubar.Sensitive = true;
+            } else {
+                btnOpen.Sensitive = false;
+                btnSaveAs.Sensitive = false;
+                menuSaveAs.Sensitive = false;
+                btnRun.Sensitive = false;
+                btnExit.Sensitive = false;
+                btnStop.Sensitive = true;
+                menubar.Sensitive = false;
+            } */
+        }
+
+		void CheckWriters ()
+        {
+            StringBuilder sb = stdout.GetStringBuilder ();
+            if (sb.Length != 0) {
+                InsertOutText (stdoutTV, sb.ToString ());
+                sb.Length = 0;
+                SetColorLabel (stdoutLabel, true);
+            }
+
+            sb = stderr.GetStringBuilder ();
+            if (sb.Length != 0) {
+                stderrTV.Buffer.InsertAtCursor (sb.ToString ());
+                sb.Length = 0;
+                SetColorLabel (stderrLabel, true);
+            }
+        }
+
+		void ClockUpdater (object o, EventArgs args)
+        {
+            long now = DateTime.Now.Ticks;
+            if (!store.Running || now - lastTick &gt;= 10000 * 100) { // 100ms
+                lastTick = now;
+                string fmt = new TimeSpan (now - startTime).ToString ();
+                int i = fmt.IndexOf ('.');
+                if (i &gt; 0 &amp;&amp; fmt.Length - i &gt; 2)
+                    fmt = fmt.Substring (0, i + 2);
+
+                //clock.Text = String.Format (&quot;Elapsed time: {0}&quot;, fmt);
+            }
+        }
+
+		// Interface NUnit.Core.EventListener
+		void EventListener.TestStarted (TestCase testCase)
+        {
+            //frameLabel.Text = &quot;Test: &quot; + testCase.FullName;
+        }
+
+		void EventListener.TestFinished (TestCaseResult result)
+        {
+            sbs.ProgressMonitor.Worked (++finishedTests / (double) ntests, String.Format (&quot;{0}/{1}&quot;, finishedTests, ntests));
+
+            if (result.Executed == false) {
+                AddIgnored (result.Test.FullName, result.Test.IgnoreReason);
+            } else if (result.IsFailure) {
+                AddError (result);
+			}
+
+            CheckWriters ();
+            UpdateRunStatus ();
+            ClockUpdater (this, EventArgs.Empty);
+        }
+
+		void EventListener.SuiteStarted (TestSuite suite)
+        {
+            //frameLabel.Text = &quot;Suite: &quot; + suite.FullName;
+        }
+
+        void EventListener.SuiteFinished (TestSuiteResult result)
+        {
+            ClockUpdater (this, EventArgs.Empty);
+        }
+
+		void AddError (TestCaseResult result)
+        {
+            errorTests++;
+            if (failuresStore == null) {
+                failuresStore = new TreeStore (typeof (string));
+                CellRendererText tr = new CellRendererText ();
+                TreeViewColumn col = new TreeViewColumn ();
+                col.PackStart (tr, false);
+                col.AddAttribute (tr, &quot;text&quot;, 0);
+                failures.AppendColumn (col);
+                failures.Model = failuresStore;
+                failures.ShowAll ();
+            }
+
+            if (errorIters == null)
+                errorIters = new Hashtable ();
+
+            int dot;
+            TreeIter main = TreeIter.Zero;
+            TreeIter iter;
+            string fullname = result.Test.FullName;
+            if ((dot = fullname.LastIndexOf ('.')) != -1) {
+                string key = fullname.Substring (0, dot);
+				if (!errorIters.ContainsKey (key)) {
+                    main = failuresStore.AppendValues (key);
+                    errorIters [key] = main;
+                } else {
+                    main = (TreeIter) errorIters [key];
+                    failuresStore.SetValue (main, 0, key);
+                }
+            } else {
+                main = failuresStore.AppendValues (fullname);
+                errorIters [fullname] = main;
+            }
+
+            iter = failuresStore.AppendValues (main, result.Test.Name);
+            iter = failuresStore.AppendValues (iter, result.Message);
+            iter = failuresStore.AppendValues (iter, result.StackTrace);
+
+            SetColorLabel (failuresLabel, true);
+        }
+
+		void AddIgnored (string name, string reason)
+        {
+            ignoredTests++;
+            if (notRunStore == null) {
+                notRunStore = new TreeStore (typeof (string));
+                CellRendererText tr = new CellRendererText ();
+                TreeViewColumn col = new TreeViewColumn ();
+                col.PackStart (tr, false);
+                col.AddAttribute (tr, &quot;text&quot;, 0);
+                notRun.AppendColumn (col);
+                notRun.Model = notRunStore;
+                notRun.ShowAll ();
+            }
+
+            TreeIter iter;
+            iter = notRunStore.AppendValues (name);
+            iter = notRunStore.AppendValues (iter, reason);
+
+            SetColorLabel (notRunLabel, true);
+        }
+
+		void UpdateRunStatus ()
+        {
+            runStatus.Markup = String.Format (&quot;Tests: {0} Ignored: {1} Failures: {2}&quot;,
+            	finishedTests, ignoredTests, errorTests);
+        }
+
+		void SetColorLabel (Label label, bool color)
+        {
+            string text = label.Text;
+            if (color)
+                label.Markup = String.Format (&quot;&lt;span foreground=\&quot;blue\&quot;&gt;{0}&lt;/span&gt;&quot;, text);
+            else
+                label.Markup = text;
+        }
+
+		void InsertOutText (TextView tv, string str)
+        {
+            TextBuffer buf = tv.Buffer;
+            buf.InsertAtCursor (str);
+        }
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Makefile.am
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Makefile.am	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Makefile.am	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,44 @@
+
+CSC = mcs /debug
+ASSEMBLY = MonoDevelop.Nunit.dll
+ADDIN = MonoDevelopNunit.addin
+
+DLLS = /r:NUnit.Framework.dll \
+	/r:gtk-sharp.dll /r:glib-sharp.dll /r:gdk-sharp.dll \
+	/r:../../../build/bin/MonoDevelop.Core.dll \
+	/r:../../../build/bin/MonoDevelop.Base.dll
+
+FILES = AssemblyInfo.cs \
+./Commands/NunitCommands.cs \
+./Gui/NunitTestTree.cs \
+./Gui/NunitResultTree.cs \
+./Services/AssemblyStore.cs \
+./Services/CancelTestsException.cs \
+./Services/CircleRenderer.cs \
+./Services/Delegates.cs \
+./Services/FixtureAddedEventArgs.cs \
+./Services/FixtureLoadErrorEventArgs.cs \
+./Services/NunitService.cs \
+./Services/QueuedEvent.cs \
+./Services/QueuedSuiteFinish.cs \
+./Services/QueuedSuiteStart.cs \
+./Services/QueuedTestEvent.cs \
+./Services/QueuedTestFinish.cs \
+./Services/QueuedTestStart.cs
+
+all: $(ASSEMBLY)
+
+../../../build/AddIns/$(ADDIN): $(ADDIN)
+	cp $(ADDIN) ../../../build/AddIns/$(ADDIN)
+
+$(ASSEMBLY): ../../../build/AddIns/$(ADDIN) $(FILES)
+	$(CSC) $(DLLS) $(FILES) /out:$(ASSEMBLY) /target:library \
+	&amp;&amp; cp $(ASSEMBLY) ../../../build/AddIns/.
+
+addindir = $(libdir)/monodevelop/AddIns
+addin_DATA = $(ASSEMBLY) $(ADDIN)
+
+CLEANFILES = $(ASSEMBLY)
+
+EXTRA_DIST = $(FILES) $(ADDIN)
+

Added: trunk/MonoDevelop/src/AddIns/Nunit/MonoDevelopNunit.addin
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/MonoDevelopNunit.addin	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/MonoDevelopNunit.addin	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,40 @@
+&lt;AddIn name	 = &quot;MonoDevelop Nunit&quot;
+       author	 = &quot;John Luke&quot;
+       copyright = &quot;GPL&quot;
+       url       = &quot;<A HREF="http://monodevelop.com&quot;">http://monodevelop.com&quot;</A>
+       description = &quot;NUnit testing tool&quot;
+       version   = &quot;0.2&quot;&gt;
+
+	&lt;Runtime&gt;
+		&lt;Import assembly=&quot;MonoDevelop.Nunit.dll&quot;/&gt;
+	&lt;/Runtime&gt;
+
+	&lt;Extension path=&quot;/Workspace/Services&quot;&gt;
+		&lt;Class id = &quot;NunitService&quot;
+		    class = &quot;MonoDevelop.Services.NunitService&quot;/&gt;
+	&lt;/Extension&gt;
+
+	&lt;Extension path=&quot;/SharpDevelop/Workbench/Views&quot;&gt;
+		&lt;Class id    = &quot;NunitTestTree&quot;
+		       class = &quot;MonoDevelop.Nunit.Gui.TestTree&quot;/&gt;
+	&lt;/Extension&gt;
+
+	&lt;Extension path=&quot;/SharpDevelop/Workbench/DisplayBinding&quot;&gt;
+		&lt;Class id    = &quot;NunitResultTree&quot;
+		       class = &quot;MonoDevelop.Nunit.Gui.ResultTree&quot;/&gt;
+	&lt;/Extension&gt;
+
+	&lt;Extension path=&quot;/SharpDevelop/Workbench/MainMenu/Tools&quot;&gt;
+		&lt;MenuItem id = &quot;NunitMenu&quot; label = &quot;NUnit&quot; insertafter = &quot;ExternalTools&quot; insertbefore = &quot;Options&quot;&gt;
+			&lt;MenuItem id = &quot;LoadTestAssembly&quot;
+	                  label = &quot;Load Assembly&quot;
+			          shortcut = &quot;&quot;
+		              class = &quot;MonoDevelop.Commands.NunitLoadAssembly&quot; /&gt;
+			&lt;MenuItem id = &quot;NunitRunTests&quot;
+	                  label = &quot;Run Tests&quot;
+			          shortcut = &quot;&quot;
+		              class = &quot;MonoDevelop.Commands.NunitRunTests&quot; /&gt;
+		&lt;/MenuItem&gt;
+	&lt;/Extension&gt;
+
+&lt;/AddIn&gt;

Added: trunk/MonoDevelop/src/AddIns/Nunit/README
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/README	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/README	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,3 @@
+This is a port of Gonzalo's gnunit
+from mono cvs, so he deserves the copyright, credit, etc
+

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/AssemblyStore.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/AssemblyStore.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/AssemblyStore.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,398 @@
+using System;
+using System.Collections;
+using System.Reflection;
+using System.Threading;
+using Gtk;
+using NUnit.Core;
+
+namespace MonoDevelop.Services.Nunit
+{
+	public class AssemblyStore : TreeStore, EventListener
+    {
+		static GLib.GType gtype;
+        string assemblyName;
+        Hashtable iters;
+        TestSuite rootTS;
+        TestResult lastResult;
+        int totalTests;
+        int currentTest;
+
+        bool runningTest;
+        bool cancelled;
+        EventListener listener;
+        Test test;
+        System.Threading.ManualResetEvent idle;
+        Queue pending;
+        System.Threading.Thread th;
+        string location;
+
+        Exception exception;
+		event FixtureAddedEventHandler FixtureAdded;
+        event FixtureLoadErrorHandler FixtureLoadError;
+        public event EventHandler FinishedRunning;
+        public event EventHandler FinishedLoad;
+        public event EventHandler IdleCallback;
+
+		public static new GLib.GType GType
+		{
+			get {
+				if (gtype == GLib.GType.Invalid) 
+					gtype = RegisterGType (typeof (AssemblyStore));
+				return gtype;
+			}
+		}	
+
+        public AssemblyStore (string assemblyName)
+            : base (typeof (int), typeof (string))
+        {
+            if (assemblyName == null)
+                throw new ArgumentNullException (&quot;assemblyName&quot;);
+
+            this.assemblyName = assemblyName;
+            location = &quot;&quot;;
+        }
+	
+		public string Location {
+            get { return location; }
+        }
+
+        public bool Running {
+            get { return runningTest; }
+        }
+
+        public bool CancelRequest {
+            set {
+                if (runningTest) {
+                    th.Abort ();
+                }
+            }
+        }
+
+        public bool Cancelled {
+            get { return cancelled; }
+        }
+
+		public TestResult LastResult {
+            get { return lastResult; }
+        }
+                                                                                
+        public int SearchColumn {
+            get { return 1; }
+        }
+
+        public void Load ()
+        {
+            // I don't like this...
+            Assembly a;
+            try {
+                a = Assembly.Load (assemblyName);
+                location = a.Location;
+            } catch (Exception e) {
+                Console.WriteLine (e);
+                try {
+                    a = Assembly.LoadFrom (assemblyName);
+                    location = a.Location;
+                } catch {
+                    location = &quot;&quot;;
+				}
+			}
+
+			GLib.Idle.Add (new GLib.IdleHandler (Populate));
+		}
+
+		void GrayOut (TreeIter iter)
+        {
+            SetValue (iter, 0, (int) CircleColor.None);
+            TreeIter child;
+            if (!IterChildren (out child, iter))
+                return;
+
+            do {
+                GrayOut (child);
+            } while (IterNext (out child));
+        }
+
+        public void RunTestAtIter (TreeIter iter, EventListener listener, ref int ntests)
+        {
+            if (iter.Equals (TreeIter.Zero))
+                return;
+
+            RunTestAtPath (GetPath (iter), listener, ref ntests);
+        }
+
+		public void RunTestAtPath (TreePath path, EventListener listener, ref int ntests)
+        {
+            if (runningTest)
+                throw new InvalidOperationException (&quot;Already running some test(s).&quot;);
+
+            cancelled = false;
+            if (idle == null) {
+                idle = new ManualResetEvent (false);
+                pending = new Queue ();
+            }
+
+            TreeIter iter;
+            GetIter (out iter, path);
+            GrayOut (iter);
+
+            if (iter.Equals (TreeIter.Zero))
+                return;
+
+            string p = GetPath (iter).ToString ();
+            if (p == null || p == &quot;&quot;)
+			    return;
+                                                                                
+            test = LookForTestByPath (p, null);
+            if (test == null)
+				return;
+
+            ntests = test.CountTestCases;
+            runningTest = true;
+            this.listener = listener;
+            th = new System.Threading.Thread (new ThreadStart (InternalRunTest));
+            th.IsBackground = true;
+            th.Start ();
+            GLib.Idle.Add (new GLib.IdleHandler (Updater));
+        }
+
+        public new void Clear ()
+        {
+            base.Clear ();
+            iters = null;
+            lastResult = null;
+        }
+
+		void DoPending ()
+        {
+            QueuedEvent [] events;
+            lock (pending) {
+                events = new QueuedEvent [pending.Count];
+                pending.CopyTo (events, 0);
+                pending.Clear ();
+            }
+
+            foreach (QueuedEvent e in events)
+                e.DoCallback ();
+        }
+
+        bool Updater ()
+        {
+            if (!idle.WaitOne (0, true)) {
+                if (IdleCallback != null)
+                    IdleCallback (this, EventArgs.Empty);
+                                                                                
+                return true;
+            }
+
+            DoPending ();
+			if (runningTest == false) {
+                DoPending ();
+                OnFinishedRunning ();
+            }
+
+            idle.Reset ();
+            return runningTest;
+        }
+
+        void InternalRunTest ()
+        {
+            lastResult = null;
+            try {
+                lastResult = test.Run (this);
+            } catch (ThreadAbortException) {
+                Thread.ResetAbort ();
+                cancelled = true;
+            } finally {
+                runningTest = false;
+                idle.Set ();
+            }
+        }
+
+		Test LookForTestByPath (string path, Test t)
+        {
+            string [] parts = path.Split (':');
+            if (t == null) {
+                if (parts.Length &gt; 1)
+                    return LookForTestByPath (String.Join (&quot;:&quot;, parts, 1, parts.Length - 1), rootTS);
+
+                return rootTS;
+            }
+
+            Test ret;
+            if (parts.Length == 1) {
+                ret = (Test) t.Tests [Int32.Parse (path)];
+                return ret;
+            }
+
+            ret = (Test) t.Tests [Int32.Parse (parts [0])];
+			return LookForTestByPath (String.Join (&quot;:&quot;, parts, 1, parts.Length - 1), ret);
+
+        }
+
+        TreeIter AddFixture (TreeIter parent, string fullName)
+        {
+            string typeName = fullName;
+            string [] parts = typeName.Split ('.');
+            string index = &quot;&quot;;
+
+            foreach (string s in parts) {
+                if (index == &quot;&quot;)
+                    index = s;
+                else
+                    index += &quot;.&quot; + s;
+
+                if (iters.ContainsKey (index)) {
+                    parent = (TreeIter) iters [index];
+                    continue;
+                }
+
+                parent = AppendValues (parent, (int) CircleColor.None, s);
+				iters [index] = parent;
+            }
+
+            return parent;
+        }
+
+        void AddSuite (TreeIter parent, TestSuite suite)
+        {
+            TreeIter next;
+            foreach (Test t in suite.Tests) {
+                next = AddFixture (parent, t.FullName);
+                while (GLib.MainContext.Iteration ());
+                if (t.IsSuite)
+                    AddSuite (next, (TestSuite) t);
+                else if (FixtureAdded != null)
+                    FixtureAdded (this, new FixtureAddedEventArgs (++currentTest, totalTests));
+
+            }
+        }
+
+		bool Populate ()
+        {
+            Clear ();
+            iters = new Hashtable ();
+            TreeIter first;
+            Append (out first);
+            SetValue (first, 0, (int) CircleColor.None);
+            SetValue (first, 1, assemblyName);
+            iters [assemblyName] = first;
+            ResolveEventHandler reh = new ResolveEventHandler (TryLoad);
+            AppDomain.CurrentDomain.AssemblyResolve += reh;
+
+            try {
+                rootTS = new TestSuiteBuilder ().Build (assemblyName);
+            } catch (Exception e) {
+                if (FixtureLoadError != null) {
+                    exception = e;
+                    GLib.Idle.Add (new GLib.IdleHandler (TriggerError));
+                }
+                return false;
+            } finally {
+                AppDomain.CurrentDomain.AssemblyResolve -= reh;
+            }
+
+			currentTest = 0;
+            totalTests = rootTS.CountTestCases;
+            AddSuite (first, rootTS);
+            OnFinishedLoad ();
+
+            return false;
+        }
+
+        void OnFinishedLoad ()
+        {
+            if (FinishedLoad != null)
+                FinishedLoad (this, EventArgs.Empty);
+        }
+
+        void OnFinishedRunning ()
+        {
+            if (FinishedRunning != null)
+                FinishedRunning (this, EventArgs.Empty);
+        }
+
+		bool TriggerError ()
+        {
+            FixtureLoadError (this, new FixtureLoadErrorEventArgs (assemblyName, exception));
+            exception = null;
+            return false;
+        }
+
+        Assembly TryLoad (object sender, ResolveEventArgs args)
+        {
+            try {
+                // NUnit2 uses Assembly.Load on the filename without extension.
+                // This is done just to allow loading from a full path name.
+                return Assembly.LoadFrom (assemblyName);
+            } catch { }
+
+            return null;
+        }
+
+		// Interface NUnit.Core.EventListener
+        void EventListener.TestStarted (TestCase testCase)
+        {
+            if (listener != null) {
+                Monitor.Enter (pending);
+                pending.Enqueue (new QueuedTestStart (new TestStartHandler (listener.TestStarted), testCase));
+                Monitor.Exit (pending);
+                idle.Set ();
+            }
+        }
+
+        void EventListener.TestFinished (TestCaseResult result)
+        {
+            Monitor.Enter (pending);
+            if (listener != null)
+                pending.Enqueue (new QueuedTestFinish (new TestFinishHandler (listener.TestFinished), result));
+
+            pending.Enqueue (new QueuedTestEvent (new TestCaseResultHandler (SetIconFromResult), result));
+            Monitor.Exit (pending);
+            idle.Set ();
+		}
+
+		void EventListener.SuiteStarted (TestSuite suite)
+        {
+            if (listener != null) {
+                Monitor.Enter (pending);
+                pending.Enqueue (new QueuedSuiteStart (new SuiteStartHandler (listener.SuiteStarted), suite));
+                Monitor.Exit (pending);
+                idle.Set ();
+            }
+        }
+
+        void EventListener.SuiteFinished (TestSuiteResult result)
+        {
+            System.Threading.Monitor.Enter (pending);
+            if (listener != null)
+                pending.Enqueue (new QueuedSuiteFinish (new SuiteFinishHandler (listener.SuiteFinished), result));
+
+            pending.Enqueue (new QueuedTestEvent (new TestCaseResultHandler (SetIconFromResult), result));
+            Monitor.Exit (pending);
+            idle.Set ();
+        }
+
+		void SetIconFromResult (TestResult result)
+        {
+            CircleColor color;
+            if (!result.Executed)
+                color = CircleColor.NotRun;
+            else if (result.IsFailure)
+                color = CircleColor.Failure;
+            else if (result.IsSuccess)
+                color = CircleColor.Success;
+            else {
+                Console.WriteLine (&quot;Warning: unexpected combination.&quot;);
+                color = CircleColor.None;
+            }
+
+            string fullname = result.Test.FullName;
+            if (iters.ContainsKey (fullname)) {
+                TreeIter iter = (TreeIter) iters [fullname];
+                SetValue (iter, 0, (int) color);
+            } else {
+                Console.WriteLine (&quot;Don't know anything about {0}&quot;, fullname);
+            }
+        }	
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/CancelTestsException.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/CancelTestsException.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/CancelTestsException.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,11 @@
+using System;
+
+namespace MonoDevelop.Services.Nunit
+{
+	public class CancelTestsException : ApplicationException
+	{
+		public CancelTestsException (string msg) : base (msg)
+		{
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/CircleRenderer.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/CircleRenderer.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/CircleRenderer.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,69 @@
+//
+// CircleRenderer.cs
+//
+// Authors:
+//	Gonzalo Paniagua Javier (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">gonzalo at ximian.com</A>)
+//
+// (C) 2003 Ximian, Inc (<A HREF="http://www.ximian.com">http://www.ximian.com</A>)
+//
+using System;
+using GLib;
+using Gdk;
+using Gtk;
+
+using MonoDevelop.Services;
+using MonoDevelop.Core.Services;
+
+namespace MonoDevelop.Services.Nunit
+{
+	enum CircleColor
+	{
+		None,
+		Failure,
+		NotRun,
+		Success
+	}
+
+	class CircleRenderer
+	{
+		static TreeCellDataFunc dataFunc = null;
+		static Pixbuf [] circles = null;
+		static string [] colors = null;
+		static ResourceService resourceService = (ResourceService) ServiceManager.Services.GetService (typeof (ResourceService));
+
+		static void Init ()
+		{
+			if (circles != null)
+				return;
+
+			circles = new Pixbuf [4];
+			circles [(int) CircleColor.None] = resourceService.GetIcon (&quot;MonoDevelop.Nunit.None.png&quot;);
+			circles [(int) CircleColor.Failure] = resourceService.GetIcon (&quot;MonoDevelop.Nunit.Red.png&quot;);
+			circles [(int) CircleColor.NotRun] = resourceService.GetIcon (&quot;MonoDevelop.Nunit.Yellow.png&quot;);
+			circles [(int) CircleColor.Success] = resourceService.GetIcon (&quot;MonoDevelop.Nuint.Green.png&quot;);
+		}
+		
+		static void SetCellData (TreeViewColumn col, CellRenderer cell, TreeModel model, TreeIter iter)
+		{
+			try {
+				CellRendererPixbuf cr = (CellRendererPixbuf) cell;
+				cr.Pixbuf = circles [(int) model.GetValue (iter, 0)];
+			} catch (Exception e) {
+				Console.WriteLine (e);
+				Console.WriteLine ();
+			}
+		}
+
+		public static Gtk.TreeCellDataFunc CellDataFunc {
+			get {
+				if (dataFunc == null) {
+					dataFunc = new TreeCellDataFunc (SetCellData);
+					Init ();
+				}
+
+				return dataFunc;
+			}
+		}
+	}
+}
+

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/Delegates.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/Delegates.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/Delegates.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,13 @@
+using System;
+using NUnit.Core;
+
+namespace MonoDevelop.Services.Nunit
+{
+	delegate void FixtureAddedEventHandler (object sender, FixtureAddedEventArgs args);
+    delegate void FixtureLoadErrorHandler (object sender, FixtureLoadErrorEventArgs args);
+    delegate void TestStartHandler (TestCase test);
+    delegate void TestFinishHandler (TestCaseResult result);
+    delegate void SuiteStartHandler (TestSuite test);
+    delegate void SuiteFinishHandler (TestSuiteResult result);
+    delegate void TestCaseResultHandler (TestResult result);
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/FixtureAddedEventArgs.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/FixtureAddedEventArgs.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/FixtureAddedEventArgs.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,24 @@
+using System;
+
+namespace MonoDevelop.Services.Nunit
+{
+	class FixtureAddedEventArgs : EventArgs
+	{
+		int total;
+		int current;
+
+		public FixtureAddedEventArgs (int current, int total)
+		{
+			this.total = total;
+			this.current = current;
+		}
+
+		public int Total {
+			get { return total; }
+		}
+
+		public int Current {
+			get { return current; }
+		}
+	}
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/FixtureLoadErrorEventArgs.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/FixtureLoadErrorEventArgs.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/FixtureLoadErrorEventArgs.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,24 @@
+using System;
+
+namespace MonoDevelop.Services.Nunit
+{
+	class FixtureLoadErrorEventArgs : EventArgs
+    {
+        string message;
+        string filename;
+
+        public FixtureLoadErrorEventArgs (string filename, Exception e)
+        {
+            this.filename = filename;
+            message = e.Message;
+        }
+
+        public string FileName {
+            get { return filename; }
+        }
+
+        public string Message {
+            get { return message; }
+        }
+    }
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/NunitService.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/NunitService.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/NunitService.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,38 @@
+//
+// Author: John Luke  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">jluke at cfl.rr.com</A>&gt;
+//
+// Copyright 2004 John Luke
+//
+
+using System;
+using System.Reflection;
+
+using NUnit.Core;
+using MonoDevelop.Services.Nunit;
+using MonoDevelop.Core.Services;
+
+namespace MonoDevelop.Services
+{
+	public class NunitService : AbstractService
+	{
+		event EventHandler FixtureAdded;
+		AssemblyStore assemblyStore;
+
+		public NunitService () : base ()
+		{
+		}
+
+		public void LoadAssembly (string path)
+		{
+			assemblyStore = new AssemblyStore (path);
+			if (FixtureAdded != null)
+				FixtureAdded (this, EventArgs.Empty);
+		}
+
+		public AssemblyStore AssemblyStore
+		{
+			get { return assemblyStore; }
+		}
+	}
+}
+

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedEvent.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedEvent.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedEvent.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,11 @@
+using System;
+
+using NUnit.Core;
+
+namespace MonoDevelop.Services.Nunit
+{
+	public abstract class QueuedEvent
+    {
+        public abstract void DoCallback ();
+    }
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedSuiteFinish.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedSuiteFinish.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedSuiteFinish.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,23 @@
+using System;
+
+using NUnit.Core;
+
+namespace MonoDevelop.Services.Nunit
+{
+	class QueuedSuiteFinish : QueuedEvent
+    {
+        SuiteFinishHandler handler;
+        TestSuiteResult result;
+
+        public QueuedSuiteFinish (SuiteFinishHandler handler, TestSuiteResult result)
+        {
+            this.handler = handler;
+            this.result = result;
+        }
+
+        public override void DoCallback ()
+        {
+            handler (result);
+        }
+    }
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedSuiteStart.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedSuiteStart.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedSuiteStart.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,23 @@
+using System;
+using NUnit.Core;
+
+namespace MonoDevelop.Services.Nunit
+{
+	class QueuedSuiteStart : QueuedEvent
+    {
+        SuiteStartHandler handler;
+        TestSuite suite;
+
+        public QueuedSuiteStart (SuiteStartHandler handler, TestSuite suite)
+        {
+            this.handler = handler;
+            this.suite = suite;
+        }
+
+        public override void DoCallback ()
+        {
+            handler (suite);
+        }
+    }
+}
+

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestEvent.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestEvent.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestEvent.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,23 @@
+using System;
+
+using NUnit.Core;
+
+namespace MonoDevelop.Services.Nunit
+{
+	class QueuedTestEvent : QueuedEvent
+    {
+        Delegate te;
+        object arg;
+
+        public QueuedTestEvent (TestCaseResultHandler te, object arg)
+        {
+            this.te = te;
+            this.arg = arg;
+        }
+
+        public override void DoCallback ()
+        {
+            te.DynamicInvoke (new object [] {arg});
+        }
+    }
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestFinish.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestFinish.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestFinish.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,23 @@
+using System;
+
+using NUnit.Core;
+
+namespace MonoDevelop.Services.Nunit
+{
+	class QueuedTestFinish : QueuedEvent
+    {
+        TestFinishHandler handler;
+        TestCaseResult result;
+
+        public QueuedTestFinish (TestFinishHandler handler, TestCaseResult result)
+        {
+            this.handler = handler;
+            this.result = result;
+        }
+
+        public override void DoCallback ()
+        {
+            handler (result);
+        }
+    }
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestStart.cs
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestStart.cs	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/Services/QueuedTestStart.cs	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,23 @@
+using System;
+
+using NUnit.Core;
+
+namespace MonoDevelop.Services.Nunit
+{
+	class QueuedTestStart : QueuedEvent
+    {
+        TestStartHandler handler;
+        TestCase test;
+
+        public QueuedTestStart (TestStartHandler handler, TestCase test)
+        {
+            this.handler = handler;
+            this.test = test;
+        }
+
+        public override void DoCallback ()
+        {
+            handler (test);
+        }
+    }
+}

Added: trunk/MonoDevelop/src/AddIns/Nunit/TODO
===================================================================
--- trunk/MonoDevelop/src/AddIns/Nunit/TODO	2004-03-26 16:46:27 UTC (rev 1256)
+++ trunk/MonoDevelop/src/AddIns/Nunit/TODO	2004-03-26 20:22:28 UTC (rev 1257)
@@ -0,0 +1,10 @@
+ResultTree
+TestTree
+save the results to xml
+hook up progress/status
+
+what about the other tabs
+(gnunit had 4)
+
+integrate test with the projects
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000863.html">[Monodevelop-patches-list] r1256 - in trunk/md-website: . tutorials
</A></li>
	<LI>Next message: <A HREF="000865.html">[Monodevelop-patches-list] r1258 - in trunk/MonoDevelop: . src/AddIns src/AddIns/Nunit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#864">[ date ]</a>
              <a href="thread.html#864">[ thread ]</a>
              <a href="subject.html#864">[ subject ]</a>
              <a href="author.html#864">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-patches-list">More information about the Monodevelop-patches-list
mailing list</a><br>
</body></html>
