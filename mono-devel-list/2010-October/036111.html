<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Adding privatekey support to X509Store
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Adding%20privatekey%20support%20to%20X509Store&In-Reply-To=AANLkTimUMbwXG73oxr2jSyJX8RmCc%3DxZRcU7BwfZx1Q3%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="036110.html">
   <LINK REL="Next"  HREF="036112.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Adding privatekey support to X509Store</H1>
    <B>Sebastien Pouliot</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Adding%20privatekey%20support%20to%20X509Store&In-Reply-To=AANLkTimUMbwXG73oxr2jSyJX8RmCc%3DxZRcU7BwfZx1Q3%40mail.gmail.com"
       TITLE="[Mono-dev] Adding privatekey support to X509Store">sebastien.pouliot at gmail.com
       </A><BR>
    <I>Wed Oct 20 15:31:32 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="036110.html">[Mono-dev] Adding privatekey support to X509Store
</A></li>
        <LI>Next message: <A HREF="036112.html">[Mono-dev] Adding privatekey support to X509Store
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36111">[ date ]</a>
              <a href="thread.html#36111">[ thread ]</a>
              <a href="subject.html#36111">[ subject ]</a>
              <a href="author.html#36111">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Pablo,

It's a bit long and (likely) boring but history lessons are rarely fun
(and I'm not the kind of guy to try to rewrite history to make it better
or even funnier ;-)

On Wed, 2010-10-20 at 19:52 +0200, Pablo Ruiz wrote:
&gt;<i> Here's another question to the list:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>       * What's exactly the purpose of KeyPairPersistence is? It looks
</I>&gt;<i>         like some sort of pseudo KeyContainer implementation which
</I>&gt;<i>         it's used by RSACryptoServiceProvider to save keys to disk..
</I>&gt;<i>         however I'm still trying to look it's relationship to
</I>&gt;<i>         X509Stores..
</I>
Hehe, you have to go back to CryptoAPI 1.0 days to see this
relationship ;-) i.e. before x.509 support there was only keypairs
persistence service offered by the (windows) OS (via CAPI).

By some (likely unrelated) circumstances the .NET framework 1.0 (and
1.1) also only exposed this via CspParameters class (even if CryptoAPI
2.0 was available on all .NET platforms at the time).

Once CryptoAPI 2.0 (supporting X509) became available new (similar in
design) certificate stores where exposed. The same stores were also
exposed (much later) in .NET 2.0.

A design decision was made (likely for compatibility) that the
certificates private keys (when available) were to be stored in the
&quot;original&quot; keypair stores. However this is (mostly) done by magic - i.e.
it's not exposed by the API, the association process is a black box.

That bit of magic gets exposed when you (under windows) loads a
certificate (e.g. a .cer, without a private key, form disk) and
&quot;automagically&quot; get the private key to sign (if available because the
certificate also exists in a store and the private key was available
when it was installed). It seems benign but quite a few applications
depends on this. 

More details inline...

&gt;<i> On Wed, Oct 20, 2010 at 4:06 PM, Pablo Ruiz &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">pablo.ruiz at gmail.com</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i>         Hi Sebastien,
</I>&gt;<i>         
</I>&gt;<i>         
</I>&gt;<i>         Great you replied, as you were the first one on my (short)
</I>&gt;<i>         list of 'people to ask in case of emergency' ;)
</I>&gt;<i>         
</I>&gt;<i>         
</I>&gt;<i>         Actually my (medium-long term) goal it's adding support for
</I>&gt;<i>         non-software based crypto devices to mono, however I know this
</I>&gt;<i>         it's not a simple task to undertake, so I will try to
</I>&gt;<i>         implement it on a step-by-step basis. 
</I>
Key/cert store association is unlikely to help this scenario. By that I
mean the solution for this HSM scenario is to shield even more the
private key from the software side (while the association will require
the opposite). Of course you're welcome to implement both :-)

&gt;<i>         In fact, here it's, an initial short list of what I would like
</I>&gt;<i>         to do, it's an initial list of goals, which has not
</I>&gt;<i>         been analyzed in deep.. so any comment/ideas/proposals would
</I>&gt;<i>         be great:
</I>&gt;<i>               * Adding (software-based) privateKey support to
</I>&gt;<i>                 X509Stores, so one can get an X509Certificate2 from an
</I>&gt;<i>                 store and sign with it, just the same way it works in
</I>&gt;<i>                 MS.Net.
</I>
X509Certificate2 is smart enough to do this with PKCS12 files - which is
a store by itself (and IMO a much better one since it is, or can be,
password protected and nothing gets hidden into store that the user
cannot see, nor manage efficiently).

&gt;<i>               * Adding privateKey support to X509Stores, but using
</I>&gt;<i>                 some sort of provider model, similar to what has been
</I>&gt;<i>                 done at mono's System.Messaging, allowing user to
</I>&gt;<i>                 switch certificate store's (or
</I>&gt;<i>                 *CryptoServiceProvider's) implementation.. (and or
</I>&gt;<i>                 allowing us to have different x509store mechanism on
</I>&gt;<i>                 different OSs)
</I>
That's mostly all existing. What's missing is the final glue between the
CspParameters, the KeyPersistence and the X509 stores. Most importantly
is making sure the tooling exists to replace the &quot;magic&quot; of windows ;-)

&gt;<i>               * Implementing one of such x509store/CSP sub-systems
</I>&gt;<i>                 which allows to use a hardware HSM, maybe by using
</I>&gt;<i>                 pkcs11 or openssl-engine under the hood. 
</I>
This should be done via the CspParameters class keeping this, source
wise, as close as possible with windows (for application code). This is
where the previous &quot;glue&quot; should be refactored (along the existing code)
as the default (managed) implementation.

&gt;<i>         I already have knowledge on x509 programing on both win32 (c
</I>&gt;<i>         ++/.net) and linux/openssl, however, as you said, how things
</I>&gt;<i>         are assembled in mono can be challenging as AFAIK there's also
</I>&gt;<i>         support for MacOSX/iPhone/etc. 
</I>
That's not the real challenge. Right now we're missing few features, but
we're compatible with existing .net code. So the key is to fill the
missing features, without breaking existing feature compatibility and
ensuring the new feature do not require mono-specific code (inside
applications).

Otherwise it's much simpler to start from scratch and develop a custom
RSA class on top of your HSM.

&gt;<i>         
</I>&gt;<i>         As such, being able to add support for (software based)
</I>&gt;<i>         privateKey handling to X509Stores looks like an not-so-hard
</I>&gt;<i>         initial task
</I>
agreed, it should not be hard since pkcs12 already provides that :)

&gt;<i>          which will allow me to start hacking around Mono.Security &amp;
</I>&gt;<i>         System.Security so I can learn how all those bits are put in
</I>&gt;<i>         place on mono. 
</I>
Try to avoid touching Mono.Security.dll. Most of it (X509 wise) was
designed to fill the missing features in FX 1.x for Mono itself. Fx 2.0
introduced (very similar*) classes to do most of the same things. For
compatibility (both to Mono.Security.dll users and FX2+ apps) most of
the code should reside in the new namespaces (and not in Mono.Security).

* I'd like to claim genius but honesty compels me to say our original
model was to be compatible with windows so... ;-)

&gt;<i>         I have already started hacking a bit, and by now I have it's
</I>&gt;<i>         just added (to Mono.Security.dll) the ability to store private
</I>&gt;<i>         key's along with public x509 certificate files, however I have
</I>&gt;<i>         a few doubts which:
</I>&gt;<i>         
</I>&gt;<i>         
</I>&gt;<i>               * My initial idea was extending
</I>&gt;<i>                 Mono.Security.X509.X509Store::Import so if a
</I>&gt;<i>                 certificate with
</I>
warning! you cannot change the public API (beside adding new overloads)
of Mono.Security.dll

&gt;<i>               *  exportable parameters are passed as input, it will
</I>&gt;<i>                 create (along with the DER certificate file) a new
</I>&gt;<i>                 file ($UniqueName$.key), which will contain the PKCS8
</I>&gt;<i>                 privateKey (encrypted using ProtectedData.Protect).
</I>&gt;<i>                 Obviously when accessing the certificate, the oposite
</I>&gt;<i>                 operation will be done to return a certificate with
</I>&gt;<i>                 it's corresponding privateKey if available.. However,
</I>&gt;<i>                 I'm not completelly sure about this approach.. &#191;any
</I>&gt;<i>                 recomendation in this area?
</I>
KeyPersistance should be used and a link (well likely a file for windows
compatibility) should point from the cert store to the key store.

&gt;<i>               * Also, I would like to control which key's cannot be
</I>&gt;<i>                 exported (just the same as on win32), where would you
</I>&gt;<i>                 store this infomartion (a bool or something indicating
</I>&gt;<i>                 that a key it's exportable).. &#191;a $UniqueName$.xml file
</I>&gt;<i>                 along with cert and key? 
</I>
Key export is a gray area - at least for the default store. i.e. we can
flag keys (as non-exportable) but we have no way (e.g. reflection) to
enforce the condition. IMO we better clearly states this is not
supported than &quot;faking&quot; the feature (and being &quot;transparently&quot; insecure
to applications).

I suggest that the API provide the possibility (for future store) but
simply throws NotSupportedException on the default managed/software
stores.

&gt;<i>               * Also, I have doubts about how to associate certs and
</I>&gt;<i>                 privateKeys within the store. My current solution
</I>&gt;<i>                 looks great for software based privateKey, however,
</I>&gt;<i>                 if/when at some point we do support hardware based
</I>&gt;<i>                 privateKey.. how can our X509Store know that a
</I>&gt;<i>                 certificate's privateKey it's 'usable' by using one
</I>&gt;<i>                 specific x509-provider? Just storing this info on an
</I>&gt;<i>                 &#191;XML? file along with the certificate itself seems a
</I>&gt;<i>                 viable solution, but I would like to share ideas with
</I>&gt;<i>                 others..
</I>
The CspParameters information should (well even must) be enough to
complete the association. That's the only way to provide compatibility
for applications.

Of course some configuration/mapping options can be available on the
mono side.

&gt;<i>               * As far as I can see, a few Mono.Security's classes
</I>&gt;<i>                 (X509Store among them) are duplicated at
</I>&gt;<i>                 mcs/class/corlib/Mono.Security.X509/.. &#191;should I copy
</I>&gt;<i>                 my updated classes back to corlib/Mono.Security.X509? 
</I>
That was a workaround for some build/cvs limitations we had 5 years ago.
For the time being you'll need (for testing) to duplicate them. However
this is something I think we can fix.

&gt;<i>               * Regarding RSAManaged and RSACryptoServiceProvider, I
</I>&gt;<i>                 know that on MS side of things, X509Certificate2 has a
</I>&gt;<i>                 CAPI binding (via PrivateKey property) to the CSP
</I>&gt;<i>                 store which holds the certificate (and it's
</I>&gt;<i>                 privateKey).. Right now I have not made a deep
</I>&gt;<i>                 analisys of what it's the best path to provide the
</I>&gt;<i>                 same functionality, and any pointer on this subject
</I>&gt;<i>                 would be great ;)
</I>
It's a bit more complex. The original FX had a very good crypto design
but, at some point (and for reasons I can only guess) they decided to
ignore it*. In this case it means that RSACSP has severe limitations
(like not providing EncryptValue) that requires us (e.g. when running
Mono.Security on .NET/windows) to use RSAManaged.

Anyway this should not be a showstopper (but something to keep in
mind ;-)

* There was a whole crypto class that simply did not work on FX 1.x
because RSACryptoServiceManager did not use it.

&gt;<i>         This is what I have by now.. but undoubtly more issues will
</I>&gt;<i>         come.. ;)
</I>
I suggest you define a complete scenario (or a few ones) before
modifying too much code. Past experiences (with pkcs11 and capi/csp) has
prove to me that they don't map very well in many cases (or at least
that theory about them is much easier than hacking them ;-)

IOW I think it would be better (and much easier for you) to know which
HSM (or at least API) you want to bind with first, then refactor the
existing key/cert store code based on this (and community feedback).

&gt;<i>         I'm also available at irc (#mono) and I guess I will ask you
</I>&gt;<i>         some questions there at some point, however, I will submit of
</I>&gt;<i>         our conclusions here, of course ;)
</I>
Great :) let's leave a trace of this for future generations ;-)

Sebastien

&gt;<i>         
</I>&gt;<i>         Greets.
</I>&gt;<i>         
</I>&gt;<i>         
</I>&gt;<i>         On Wed, Oct 20, 2010 at 2:33 PM, Sebastien Pouliot
</I>&gt;<i>         &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien.pouliot at gmail.com</A>&gt; wrote:
</I>&gt;<i>                 Hello Pablo,
</I>&gt;<i>                 
</I>&gt;<i>                 
</I>&gt;<i>                 On Wed, 2010-10-20 at 00:23 +0200, Pablo Ruiz wrote:
</I>&gt;<i>                 &gt; Hi,
</I>&gt;<i>                 &gt;
</I>&gt;<i>                 &gt;
</I>&gt;<i>                 &gt; I'm thinking on adding privateKey support for
</I>&gt;<i>                 Mono.Security.X509Store,
</I>&gt;<i>                 &gt; so it can be (later) used as part of
</I>&gt;<i>                 &gt; System.Security.Cryptography.X509Certificates (on
</I>&gt;<i>                 2.0+). This is one
</I>&gt;<i>                 &gt; of the x509 related improvements I would like to add
</I>&gt;<i>                 to mono's trunk.
</I>&gt;<i>                 &gt;
</I>&gt;<i>                 &gt;
</I>&gt;<i>                 &gt; However, I would like to discuss (by email and/or
</I>&gt;<i>                 irc?) some of the
</I>&gt;<i>                 &gt; details first with some core member (some sort of
</I>&gt;<i>                 mentoring) in order
</I>&gt;<i>                 &gt; to start in a good direction.
</I>&gt;<i>                 
</I>&gt;<i>                 
</I>&gt;<i>                 You can either discuss this here, on this
</I>&gt;<i>                 mailing-list, since it will
</I>&gt;<i>                 leave a google-able trace of the discussion. Otherwise
</I>&gt;<i>                 you can try to
</I>&gt;<i>                 ping me on IRC (e.g. #monodev on GIMPNet) and we can
</I>&gt;<i>                 post a resume later
</I>&gt;<i>                 here.
</I>&gt;<i>                 
</I>&gt;<i>                 There are quite a few things to be aware in order to
</I>&gt;<i>                 implement this
</I>&gt;<i>                 (since it involves OS level features, tools and the
</I>&gt;<i>                 class libraries). I
</I>&gt;<i>                 think the best step would be, for you, to describe
</I>&gt;<i>                 your understanding of
</I>&gt;<i>                 the issues and I'll fill the blanks (in any :-).
</I>&gt;<i>                 
</I>&gt;<i>                 Thanks,
</I>&gt;<i>                 Sebastien
</I>&gt;<i>                 
</I>&gt;<i>                 
</I>&gt;<i>         
</I>&gt;<i>         
</I>&gt;<i> 
</I>&gt;<i> 
</I>

</PRE>












<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="036110.html">[Mono-dev] Adding privatekey support to X509Store
</A></li>
	<LI>Next message: <A HREF="036112.html">[Mono-dev] Adding privatekey support to X509Store
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36111">[ date ]</a>
              <a href="thread.html#36111">[ thread ]</a>
              <a href="subject.html#36111">[ subject ]</a>
              <a href="author.html#36111">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
