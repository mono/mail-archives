<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Mono Continuations and MicroThreads
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Mono%20Continuations%20and%20MicroThreads&In-Reply-To=Pine.LNX.4.64.0604211016340.13861%40baal.bat.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018321.html">
   <LINK REL="Next"  HREF="018324.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Mono Continuations and MicroThreads</H1>
    <B>Denis ERCHOFF</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Mono%20Continuations%20and%20MicroThreads&In-Reply-To=Pine.LNX.4.64.0604211016340.13861%40baal.bat.org"
       TITLE="[Mono-dev] Mono Continuations and MicroThreads">d_erchoff at hotmail.com
       </A><BR>
    <I>Fri Apr 21 04:07:40 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018321.html">[Mono-dev] Mono Continuations and MicroThreads
</A></li>
        <LI>Next message: <A HREF="018324.html">[Mono-dev] Mono Continuations and MicroThreads
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18322">[ date ]</a>
              <a href="thread.html#18322">[ thread ]</a>
              <a href="subject.html#18322">[ subject ]</a>
              <a href="author.html#18322">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

The perfect thread scheduler is the one that give the same execution 
period time for all threads :)

So a first ( incomplete ) idea is coming to me :

If :

* You define a maximum time of execution foreach microthread.
* the scheduler call the microthread run method.
* An OS thread loop until the max time is reached for the current 
microthread or the current microthread returns. If the microthread 
didn't return before the defined max time, the scheduler force this 
microthread to save his stack and it switch to an another microthread.

I hope this is not to hard to implement :) .

p.s. : for more functional idea, look at Fair thread -&gt; 
<A HREF="http://www-sop.inria.fr/mimosa/rp/">http://www-sop.inria.fr/mimosa/rp/</A>

Tomi Valkeinen a &#233;crit :
&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;&gt;<i> As i remember, previous version of your scheduler class has a &quot;strong 
</I>&gt;&gt;<i> reference&quot; to the socket manager class.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What about an application does not using sockets ?
</I>&gt;&gt;<i> What about another socket implementation ( my case ) ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is not a crucial fix, but i think it is better to keep out the 
</I>&gt;&gt;<i> Socket management. A programmer will use a microthread to update his 
</I>&gt;&gt;<i> socket ;).
</I>&gt;<i>
</I>&gt;<i> The socket manager does not prevent you from doing anything. If you 
</I>&gt;<i> don't use the included socket implementation, the manager does not do 
</I>&gt;<i> anything, so you can as well use standard .Net sockets in your code. 
</I>&gt;<i> However, then you have to do all the work in non-blocking way, because 
</I>&gt;<i> if you block one microthread, all microthreads are frozen. You have to 
</I>&gt;<i> remember that microthreads are not OS threads =).
</I>&gt;<i>
</I>&gt;<i> I've thought of implementing a generic way to add these &quot;managers&quot; to 
</I>&gt;<i> the scheduler, so you could implement blocking code (blocking in 
</I>&gt;<i> microthread sense, not in OS thread sense) similar to the socket 
</I>&gt;<i> implementation I have. But that's not so simple:
</I>&gt;<i>
</I>&gt;<i> The basic problem here is about events. If we don't want to run in a 
</I>&gt;<i> busy loop, constantly polling for new events and using 100% of the 
</I>&gt;<i> CPU, there has to be some place where we wait for events or sleep for 
</I>&gt;<i> a certain time. Sleeping is not good because we can't know when the 
</I>&gt;<i> next event will come, and we would usually sleep too long.
</I>&gt;<i>
</I>&gt;<i> In my current code this place, where we wait, is in the socket manager 
</I>&gt;<i> when we Select() the sockets. This works because currently socket 
</I>&gt;<i> events are the only events the microthreads react to. If we'd like to 
</I>&gt;<i> add a new type of event, for example input from console, we'd be in 
</I>&gt;<i> trouble as there's no way we could wait for events both from sockets 
</I>&gt;<i> and from console in the same place. Currently you'd have to have a 
</I>&gt;<i> microthread that polls the console input in a loop and sleeps for some 
</I>&gt;<i> milliseconds between the polls.
</I>&gt;<i>
</I>&gt;<i> I'm not sure yet how to solve this event problem. Perhaps a separate 
</I>&gt;<i> OS thread that listens to the event, and notifies the OS thread where 
</I>&gt;<i> microthreads run via a socket.
</I>&gt;<i>
</I>&gt;<i>  Tomi
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018321.html">[Mono-dev] Mono Continuations and MicroThreads
</A></li>
	<LI>Next message: <A HREF="018324.html">[Mono-dev] Mono Continuations and MicroThreads
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18322">[ date ]</a>
              <a href="thread.html#18322">[ thread ]</a>
              <a href="subject.html#18322">[ subject ]</a>
              <a href="author.html#18322">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
