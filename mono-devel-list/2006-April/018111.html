<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] patch for reading assemblies 
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20patch%20for%20reading%20assemblies%20&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018178.html">
   <LINK REL="Next"  HREF="018113.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] patch for reading assemblies </H1>
    <B>Eyal Alaluf</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20patch%20for%20reading%20assemblies%20&In-Reply-To="
       TITLE="[Mono-dev] patch for reading assemblies ">eyala at mainsoft.com
       </A><BR>
    <I>Sun Apr  9 09:11:58 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018178.html">[Mono-dev] FAMWatcher race condition patch
</A></li>
        <LI>Next message: <A HREF="018113.html">[Mono-dev] patch for reading assemblies 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18111">[ date ]</a>
              <a href="thread.html#18111">[ thread ]</a>
              <a href="subject.html#18111">[ subject ]</a>
              <a href="author.html#18111">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi, JB.

We have a toold that generates assemblies and when running Cecil to read assemblies
generated by this tool we hit a bug in Cecil. The bug is that Cecil code in
Mono.Cecil.ReflectionRead.VisitTypeDefinitionCollection assumed that an outer class
must appear nt the type reference table before its inner classes.
The attached patch fixes this issue.
Please review.

Eyal.
-------------- next part --------------
Index: Mono.Cecil/ReflectionReader.cs

===================================================================

--- Mono.Cecil/ReflectionReader.cs	(revision 59261)

+++ Mono.Cecil/ReflectionReader.cs	(working copy)

@@ -398,36 +398,7 @@

 				m_typeRefs = new TypeReference [typesRef.Rows.Count];
 
 				for (int i = 0; i &lt; typesRef.Rows.Count; i++) {
-					TypeRefRow type = typesRef [i];
-					IMetadataScope scope = null;
-					TypeReference parent = null;
-					switch (type.ResolutionScope.TokenType) {
-					case TokenType.AssemblyRef :
-						scope = m_module.AssemblyReferences [(int) type.ResolutionScope.RID - 1];
-						break;
-					case TokenType.ModuleRef :
-						scope = m_module.ModuleReferences [(int) type.ResolutionScope.RID - 1];
-						break;
-					case TokenType.Module :
-						scope = m_module.Assembly.Modules [(int) type.ResolutionScope.RID - 1];
-						break;
-					case TokenType.TypeRef :
-						parent = GetTypeRefAt (type.ResolutionScope.RID);
-						scope = parent.Scope;
-						break;
-					}
-
-					TypeReference t = new TypeReference (
-						m_root.Streams.StringsHeap [type.Name],
-						m_root.Streams.StringsHeap [type.Namespace],
-						scope);
-					t.MetadataToken = MetadataToken.FromMetadataRow (TokenType.TypeRef, i);
-
-					if (parent != null)
-						t.DeclaringType = parent;
-
-					m_typeRefs [i] = t;
-					m_module.TypeReferences.Add (t);
+					AddTypeRef(typesRef, i);
 				}
 
 			} else
@@ -451,6 +422,45 @@

 			ReadMemberReferences ();
 		}
 
+		void AddTypeRef(TypeRefTable typesRef, int i)
+		{
+			// Check if index has been already added.
+			if (m_typeRefs[i] != null)
+				return;
+
+			TypeRefRow type = typesRef [i];
+			IMetadataScope scope = null;
+			TypeReference parent = null;
+			switch (type.ResolutionScope.TokenType) {
+			case TokenType.AssemblyRef :
+				scope = m_module.AssemblyReferences [(int) type.ResolutionScope.RID - 1];
+				break;
+			case TokenType.ModuleRef :
+				scope = m_module.ModuleReferences [(int) type.ResolutionScope.RID - 1];
+				break;
+			case TokenType.Module :
+				scope = m_module.Assembly.Modules [(int) type.ResolutionScope.RID - 1];
+				break;
+			case TokenType.TypeRef :
+				AddTypeRef(typesRef, (int)type.ResolutionScope.RID - 1);
+				parent = GetTypeRefAt (type.ResolutionScope.RID);
+				scope = parent.Scope;
+				break;
+			}
+
+			TypeReference t = new TypeReference (
+				m_root.Streams.StringsHeap [type.Name],
+				m_root.Streams.StringsHeap [type.Namespace],
+				scope);
+			t.MetadataToken = MetadataToken.FromMetadataRow (TokenType.TypeRef, i);
+
+			if (parent != null)
+				t.DeclaringType = parent;
+
+			m_typeRefs [i] = t;
+			m_module.TypeReferences.Add (t);
+		}
+
 		void ReadTypeSpecs ()
 		{
 			if (!m_tHeap.HasTable (typeof (TypeSpecTable)))
Index: ChangeLog

===================================================================

--- ChangeLog	(revision 59261)

+++ ChangeLog	(working copy)

@@ -1,3 +1,8 @@

+2006-04-09  Eyal Alaluf  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
+    * Mono.Cecil/ReflectionReader.cs
+	    Cannot assume that TypeRefs are ordered is such a way that an outer
+		class index comes always before all its inner classes.
+
 2006-04-06  Jb Evain  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jbevain at gmail.com</A>&gt;
 
 	* Mono.Cecil/ReflectionWriter.cs
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018178.html">[Mono-dev] FAMWatcher race condition patch
</A></li>
	<LI>Next message: <A HREF="018113.html">[Mono-dev] patch for reading assemblies 
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18111">[ date ]</a>
              <a href="thread.html#18111">[ thread ]</a>
              <a href="subject.html#18111">[ subject ]</a>
              <a href="author.html#18111">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
