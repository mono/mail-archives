<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Profiler Idea
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Profiler%20Idea&In-Reply-To=1074029197.4393.103.camel%40Ben">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003590.html">
   <LINK REL="Next"  HREF="003609.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Profiler Idea</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Profiler%20Idea&In-Reply-To=1074029197.4393.103.camel%40Ben"
       TITLE="[Mono-devel-list] Profiler Idea">lupus at ximian.com
       </A><BR>
    <I>Wed Jan 14 11:26:24 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="003590.html">[Mono-devel-list] Profiler Idea
</A></li>
        <LI>Next message: <A HREF="003609.html">[Mono-devel-list] Profiler Idea
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3607">[ date ]</a>
              <a href="thread.html#3607">[ thread ]</a>
              <a href="subject.html#3607">[ subject ]</a>
              <a href="author.html#3607">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/13/04 Ben Maurer wrote:
&gt;<i> &gt; &gt; Now, obviously, I have seen this method before. But for the first time
</I>&gt;<i> &gt; &gt; today, I reflected on how useless this data was. You get no idea *WHO*
</I>&gt;<i> &gt; &gt; is calling the method.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The first part of the profile output has the call info, so you just need
</I>&gt;<i> &gt; to see which methods call ToCharArray(int,int).
</I>&gt;<i> yes, however this gets really hard to do, and makes it hard to get a
</I>&gt;<i> general overview of things.
</I>
Hence the suggestion I made in my mail.

&gt;<i> Well, the idea is to detect `who is causing the most space to be
</I>&gt;<i> allocated in the hashtable.' For example this code:
</I>&gt;<i> 
</I>&gt;<i> for (..) {
</I>&gt;<i> 	for (..) {
</I>&gt;<i> 		ht.Add (...);
</I>&gt;<i> 	}
</I>&gt;<i> 	ht.Clear ();
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> is much better than:
</I>&gt;<i> 
</I>&gt;<i> for (..) {
</I>&gt;<i> 	for (..) {
</I>&gt;<i> 		ht.Add (...);
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>
The code does different things semantically, so saying it's much better
doen't make sense.

&gt;<i> &gt; &gt;       * For other select methods and classes, we shall apply a similar
</I>&gt;<i> &gt; &gt;         rule. For example, ToCharArray would be attributed to the method
</I>&gt;<i> &gt; &gt;         that called the 0 args overload.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I don't think adding special case hacks is a good thing.
</I>&gt;<i> &gt; It would be better if, for each method, we could also output the total
</I>&gt;<i> &gt; amount of memory allocated (by the method and by the called methods as
</I>&gt;<i> &gt; well).
</I>&gt;<i> Hmmm, i am on the fence about including child methods. On the one hand,
</I>&gt;<i> I usually try to catch single methods that are causing problems, but
</I>&gt;<i> this method also provides a good approach.
</I>
Calculating the memory allocated in called methods doesn't prevent
displaying the amount of memory allocated directly.

&gt;<i> class Driver {
</I>&gt;<i> 	static void Main () {
</I>&gt;<i> 		for (int i = 0; i &lt; 500; i ++) Foo ();
</I>&gt;<i> 	}
</I>&gt;<i> 	
</I>&gt;<i> 	static void Foo () {
</I>&gt;<i> 		MyList l = new MyList (3);
</I>&gt;<i> 		Bar ();
</I>&gt;<i> 		...
</I>&gt;<i> 	}
</I>&gt;<i> 	static void Bar () {
</I>&gt;<i> 		MyList l = new MyList (50000);
</I>&gt;<i> 
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> In this code, Bar is obviously taking up the most memory. With your
</I>&gt;<i> suggestion, It would be easy for Bar to get lost in the shuffle, if it
</I>&gt;<i> were only responsible for 10% of the allocations of Foo. Right now, you
</I>
If Bar() allocates 10% of the total amount of memory allocated by Foo(),
it's correct for it to be less prominent in the profile, that's the
point of the memory profiler. On the other hand if really Bar() is
allocating most of the memory allocated by Foo(), they will be close at
the top of the profile, ie, exactly what the profiler should give.

&gt;<i> cant tell the difference between Foo and Bar becuase they make the same
</I>&gt;<i> number of calls to the ctor. The kind of data that would be most useful
</I>&gt;<i> in this case is:
</I>&gt;<i> 
</I>&gt;<i> #######################
</I>&gt;<i> Driver::Bar
</I>&gt;<i>              500 object [] (xxxxxxxx KB) (via MyList.ctor)
</I>
Keeping that level of detail is very expensive. Distributing the
allocated amount using call arcs provides a good enough picture of what
is happening.

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003590.html">[Mono-devel-list] Profiler Idea
</A></li>
	<LI>Next message: <A HREF="003609.html">[Mono-devel-list] Profiler Idea
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3607">[ date ]</a>
              <a href="thread.html#3607">[ thread ]</a>
              <a href="subject.html#3607">[ subject ]</a>
              <a href="author.html#3607">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
