<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Profiler Idea
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Profiler%20Idea&In-Reply-To=20040113195508.GO7092%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003587.html">
   <LINK REL="Next"  HREF="003607.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Profiler Idea</H1>
    <B>Ben Maurer</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Profiler%20Idea&In-Reply-To=20040113195508.GO7092%40debian.org"
       TITLE="[Mono-devel-list] Profiler Idea">bmaurer at users.sourceforge.net
       </A><BR>
    <I>Tue Jan 13 16:26:37 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="003587.html">[Mono-devel-list] Profiler Idea
</A></li>
        <LI>Next message: <A HREF="003607.html">[Mono-devel-list] Profiler Idea
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3590">[ date ]</a>
              <a href="thread.html#3590">[ thread ]</a>
              <a href="subject.html#3590">[ subject ]</a>
              <a href="author.html#3590">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Tue, 2004-01-13 at 14:55, Paolo Molaro wrote:
&gt;<i> On 01/13/04 Ben Maurer wrote:
</I>&gt;<i> &gt; Recently, while doing a profile, I saw the following lines:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt;      433 KB System.String::ToCharArray(int,int)
</I>&gt;<i> &gt; &gt;          433 KB      247 System.Char[]                                   
</I>&gt;<i> &gt; &gt;   Callers (with count) that contribute at least for 1%:
</I>&gt;<i> &gt; &gt;          247  100 % System.String::ToCharArray()
</I>&gt;<i> &gt; &gt; ########################
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Now, obviously, I have seen this method before. But for the first time
</I>&gt;<i> &gt; today, I reflected on how useless this data was. You get no idea *WHO*
</I>&gt;<i> &gt; is calling the method.
</I>&gt;<i> 
</I>&gt;<i> The first part of the profile output has the call info, so you just need
</I>&gt;<i> to see which methods call ToCharArray(int,int).
</I>yes, however this gets really hard to do, and makes it hard to get a
general overview of things.

&gt;<i> 
</I>&gt;<i> &gt; So, I was thinking `maybe we should make a list of common allocators
</I>&gt;<i> &gt; like that that are just called by other methods.' For example, in
</I>&gt;<i> &gt; Hashtable, you often get profiles like:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt;      316 KB System.Collections.Hashtable::Rehash()
</I>&gt;<i> &gt; &gt;          316 KB       29 .Slot[]                                         
</I>&gt;<i> &gt; &gt;   Callers (with count) that contribute at least for 1%:
</I>&gt;<i> &gt; &gt;           29  100 % System.Collections.Hashtable::PutImpl(object,object,bool)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; However, it is hard to track down who is causing the rehashes because
</I>&gt;<i> &gt; not all calls to PutImpl cause a rehash.
</I>&gt;<i> 
</I>&gt;<i> It does not matter which specific call causes the rehash, since the
</I>&gt;<i> rehash is implementation dependent. You can just look at which method
</I>&gt;<i> causes the most items to be added to the hash. But usually it doesn't
</I>&gt;<i> make sense to reduce the number of items added to an hash table. In most
</I>&gt;<i> cases, instead, you should check that the hash functions are good enough
</I>&gt;<i> so that the keys are spread evenly over the internal array.
</I>
Well, the idea is to detect `who is causing the most space to be
allocated in the hashtable.' For example this code:

for (..) {
	for (..) {
		ht.Add (...);
	}
	ht.Clear ();
}

is much better than:


for (..) {
	for (..) {
		ht.Add (...);
	}
}

if the bounds of the for loop are the same in both cases. However, there
is no way to see that right now.


&gt;<i> &gt;       * For other select methods and classes, we shall apply a similar
</I>&gt;<i> &gt;         rule. For example, ToCharArray would be attributed to the method
</I>&gt;<i> &gt;         that called the 0 args overload.
</I>&gt;<i> 
</I>&gt;<i> I don't think adding special case hacks is a good thing.
</I>&gt;<i> It would be better if, for each method, we could also output the total
</I>&gt;<i> amount of memory allocated (by the method and by the called methods as
</I>&gt;<i> well).
</I>Hmmm, i am on the fence about including child methods. On the one hand,
I usually try to catch single methods that are causing problems, but
this method also provides a good approach.

For example, take the following code:

class MyList {
	object [] stuff;

	public MyList (int sz) { stuff = new Object [sz]; }
	void Add (object) {...}
	object Get (int) { ... } 
}

class Driver {
	static void Main () {
		for (int i = 0; i &lt; 500; i ++) Foo ();
	}
	
	static void Foo () {
		MyList l = new MyList (3);
		Bar ();
		...
	}
	static void Bar () {
		MyList l = new MyList (50000);

	}
}

In this code, Bar is obviously taking up the most memory. With your
suggestion, It would be easy for Bar to get lost in the shuffle, if it
were only responsible for 10% of the allocations of Foo. Right now, you
cant tell the difference between Foo and Bar becuase they make the same
number of calls to the ctor. The kind of data that would be most useful
in this case is:



#######################
Driver::Bar
             500 object [] (xxxxxxxx KB) (via MyList.ctor)
...

#######################
Driver::Foo
             500 object [] (xxx KB) (via MyList.ctor)
...

The allocations from MyList are attributed to the caller, because
MyList.ctor is allocating resources for the MyList object, which was
created by its caller.

Maybe we need a profiler dedicated to memory profiling. The type of data
that is useful for memory profiling work isnt really provided right now.

-- Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003587.html">[Mono-devel-list] Profiler Idea
</A></li>
	<LI>Next message: <A HREF="003607.html">[Mono-devel-list] Profiler Idea
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3590">[ date ]</a>
              <a href="thread.html#3590">[ thread ]</a>
              <a href="subject.html#3590">[ subject ]</a>
              <a href="author.html#3590">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
