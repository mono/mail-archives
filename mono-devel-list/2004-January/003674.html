<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Patch for Bug 45976
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20Bug%2045976&In-Reply-To=400C2187.7060105%40softhome.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003665.html">
   <LINK REL="Next"  HREF="003666.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Patch for Bug 45976</H1>
    <B>Marco Craveiro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20Bug%2045976&In-Reply-To=400C2187.7060105%40softhome.net"
       TITLE="[Mono-devel-list] Patch for Bug 45976">marco_craveiro at oceanus.plus.com
       </A><BR>
    <I>Mon Jan 19 17:08:23 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="003665.html">[Mono-devel-list] Patch for Bug 45976
</A></li>
        <LI>Next message: <A HREF="003666.html">[Mono-devel-list] Patch for Bug 45976
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3674">[ date ]</a>
              <a href="thread.html#3674">[ thread ]</a>
              <a href="subject.html#3674">[ subject ]</a>
              <a href="author.html#3674">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>hello Francois,

thanks for your time and for the favorable comments, its my first patch 
:<i>-) i can't read Uma's patch (strange encoding) but i've got one
</I>question regarding your mail:

&gt;<i> I attach the patch of Marco ( with a little modifcation in the new 
</I>&gt;<i> method Interval::Intersect ) and the regression test.
</I>
what modification is it? can't see the difference in Intersects... 

at any rate, since System.Text.RegularExpressions seems to be in very
good hands i'll probably search for another bug to squash :-)

cheers,

marco

On Mon, 2004-01-19 at 18:27, Francois Beauchemin wrote:
&gt;<i> Hi !
</I>&gt;<i> 
</I>&gt;<i> Marco Cravairo has posted another patch for this bug.  ( See : 
</I>&gt;<i> <A HREF="http://lists.ximian.com/archives/public/mono-list/2004-January/017642.html">http://lists.ximian.com/archives/public/mono-list/2004-January/017642.html</A> )
</I>&gt;<i> 
</I>&gt;<i> I've just reviewed his patch and it work well. A quick look to your 
</I>&gt;<i> patch show you adressed the problem at a different angle. You modified 
</I>&gt;<i> the interpreter and Marco has modified the CaracterClass class to adjust 
</I>&gt;<i> a range to contain Uppercase and lower-case char when using ignore case.
</I>&gt;<i> 
</I>&gt;<i> I've done a little regression test ( attached ) and your patch does not 
</I>&gt;<i> pass one test.
</I>&gt;<i> 
</I>&gt;<i> I attach the patch of Marco ( with a little modifcation in the new 
</I>&gt;<i> method Interval::Intersect ) and the regression test.
</I>&gt;<i> 
</I>&gt;<i> In my opinion, your approach  is more optimized but at least one case is 
</I>&gt;<i> not adressed
</I>&gt;<i> 
</I>&gt;<i> For example the regex [A-a] should match the string &quot;[&quot; since [ is 
</I>&gt;<i> between uppercase and lowercase char in the asscii table ...
</I>&gt;<i> 
</I>&gt;<i> Francois Beauchemin
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ______________________________________________________________________
</I>&gt;<i> Index: RegexBugs.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> RCS file: /mono/mcs/class/System/Test/System.Text.RegularExpressions/RegexBugs.cs,v
</I>&gt;<i> retrieving revision 1.3
</I>&gt;<i> diff -u -r1.3 RegexBugs.cs
</I>&gt;<i> --- RegexBugs.cs	7 Jan 2004 18:24:11 -0000	1.3
</I>&gt;<i> +++ RegexBugs.cs	19 Jan 2004 15:55:03 -0000
</I>&gt;<i> @@ -70,5 +70,30 @@
</I>&gt;<i>  			AssertEquals (&quot;MEG #12&quot;, true, Regex.IsMatch(str, @&quot;(something|dog|)*$&quot;));
</I>&gt;<i>  
</I>&gt;<i>  		}
</I>&gt;<i> +
</I>&gt;<i> +                [Test]
</I>&gt;<i> +                public void RangeIgnoreCase() // bug 45976
</I>&gt;<i> +                {
</I>&gt;<i> +                        string str = &quot;AAABBBBAAA&quot; ;
</I>&gt;<i> +                        AssertEquals(&quot;RIC #01&quot;, true, Regex.IsMatch(str, @&quot;[A-F]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +                        AssertEquals(&quot;RIC #02&quot;, true, Regex.IsMatch(str, @&quot;[a-f]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +                        AssertEquals(&quot;RIC #03&quot;, true, Regex.IsMatch(str, @&quot;[A-Fa-f]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +                        AssertEquals(&quot;RIC #04&quot;, true, Regex.IsMatch(str, @&quot;[AB]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +                        AssertEquals(&quot;RIC #05&quot;, true, Regex.IsMatch(str, @&quot;[A-B]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +
</I>&gt;<i> +                        str = &quot;AaaBBBaAa&quot; ;
</I>&gt;<i> +                        AssertEquals(&quot;RIC #06&quot;, true, Regex.IsMatch(str, @&quot;[A-F]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +                        AssertEquals(&quot;RIC #07&quot;, true, Regex.IsMatch(str, @&quot;[a-f]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +                        AssertEquals(&quot;RIC #08&quot;, true, Regex.IsMatch(str, @&quot;[A-Fa-f]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +                        AssertEquals(&quot;RIC #09&quot;, true, Regex.IsMatch(str, @&quot;[AB]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +                        AssertEquals(&quot;RIC #10&quot;, true, Regex.IsMatch(str, @&quot;[A-B]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +
</I>&gt;<i> +			str = &quot;Aaa[&quot;;
</I>&gt;<i> +			AssertEquals(&quot;RIC #11&quot;, true, Regex.IsMatch(str, @&quot;[A-a]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +			
</I>&gt;<i> +			str = &quot;Ae&quot;;
</I>&gt;<i> +			AssertEquals(&quot;RIC #12&quot;, false, Regex.IsMatch(str, @&quot;[A-a]+&quot;, RegexOptions.IgnoreCase));
</I>&gt;<i> +
</I>&gt;<i> +                }
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i> 
</I>&gt;<i> ______________________________________________________________________
</I>&gt;<i> ? regexIgnoreCase.patch
</I>&gt;<i> ? regexUnified.patch
</I>&gt;<i> ? regexUnified2.patch
</I>&gt;<i> Index: interval.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> RCS file: /mono/mcs/class/System/System.Text.RegularExpressions/interval.cs,v
</I>&gt;<i> retrieving revision 1.1
</I>&gt;<i> diff -u -r1.1 interval.cs
</I>&gt;<i> --- interval.cs	31 Jan 2002 08:00:16 -0000	1.1
</I>&gt;<i> +++ interval.cs	19 Jan 2004 15:16:22 -0000
</I>&gt;<i> @@ -95,6 +95,14 @@
</I>&gt;<i>  			return low &lt;= i &amp;&amp; i &lt;= high;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public bool Intersects (Interval i) {
</I>&gt;<i> + 			if (IsEmpty || i.IsEmpty)
</I>&gt;<i> + 				return false;
</I>&gt;<i> + 			
</I>&gt;<i> + 			return ((Contains (i.low) &amp;&amp; !Contains (i.high)) ||
</I>&gt;<i> +				(Contains (i.high) &amp;&amp; !Contains (i.low)));
</I>&gt;<i> + 		}	
</I>&gt;<i> +
</I>&gt;<i>  		public void Merge (Interval i) {
</I>&gt;<i>  			if (i.IsEmpty)
</I>&gt;<i>  				return;
</I>&gt;<i> Index: syntax.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> RCS file: /mono/mcs/class/System/System.Text.RegularExpressions/syntax.cs,v
</I>&gt;<i> retrieving revision 1.1
</I>&gt;<i> diff -u -r1.1 syntax.cs
</I>&gt;<i> --- syntax.cs	31 Jan 2002 08:00:16 -0000	1.1
</I>&gt;<i> +++ syntax.cs	19 Jan 2004 15:16:23 -0000
</I>&gt;<i> @@ -779,11 +779,39 @@
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public void AddCharacter (char c) {
</I>&gt;<i> -			intervals.Add (new Interval (c, c));
</I>&gt;<i> +			// TODO: this is certainly not the most efficient way of doing things 
</I>&gt;<i> + 			// TODO: but at least it produces correct results. 
</I>&gt;<i> + 			AddRange (c, c);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public void AddRange (char lo, char hi) {
</I>&gt;<i> -			intervals.Add (new Interval (lo, hi));
</I>&gt;<i> +			Interval new_interval = new Interval (lo, hi);
</I>&gt;<i> + 
</I>&gt;<i> + 			// ignore case is on. we must make sure our interval does not
</I>&gt;<i> + 			// use upper case. if it does, we must normalize the upper case
</I>&gt;<i> + 			// characters into lower case. 
</I>&gt;<i> + 			if (ignore) {
</I>&gt;<i> + 				if (upper_case_characters.Intersects (new_interval)) {
</I>&gt;<i> + 					Interval partial_new_interval;
</I>&gt;<i> + 
</I>&gt;<i> + 					if (new_interval.low &lt; upper_case_characters.low) {
</I>&gt;<i> + 						partial_new_interval = new Interval (upper_case_characters.low + distance_between_upper_and_lower_case, 
</I>&gt;<i> + 										     new_interval.high +  distance_between_upper_and_lower_case);
</I>&gt;<i> + 						new_interval.high = upper_case_characters.low - 1;
</I>&gt;<i> + 					}
</I>&gt;<i> + 					else {
</I>&gt;<i> + 						partial_new_interval = new Interval (new_interval.low + distance_between_upper_and_lower_case, 
</I>&gt;<i> + 										     upper_case_characters.high + distance_between_upper_and_lower_case);
</I>&gt;<i> + 						new_interval.low = upper_case_characters.high + 1;
</I>&gt;<i> + 					}
</I>&gt;<i> + 					intervals.Add (partial_new_interval);
</I>&gt;<i> + 				}
</I>&gt;<i> + 				else if (upper_case_characters.Contains (new_interval)) {
</I>&gt;<i> + 					new_interval.high += distance_between_upper_and_lower_case;
</I>&gt;<i> + 					new_interval.low += distance_between_upper_and_lower_case;
</I>&gt;<i> + 				}
</I>&gt;<i> + 			}
</I>&gt;<i> + 			intervals.Add (new_interval);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public override void Compile (ICompiler cmp, bool reverse) {
</I>&gt;<i> @@ -871,6 +899,8 @@
</I>&gt;<i>  				return 3;					// Range
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		private static Interval upper_case_characters = new Interval ((char)65, (char)90);
</I>&gt;<i> + 		private const int distance_between_upper_and_lower_case = 32;
</I>&gt;<i>  		private bool negate, ignore;
</I>&gt;<i>  		private bool[] pos_cats, neg_cats;
</I>&gt;<i>  		private IntervalCollection intervals;
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003665.html">[Mono-devel-list] Patch for Bug 45976
</A></li>
	<LI>Next message: <A HREF="003666.html">[Mono-devel-list] Patch for Bug 45976
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3674">[ date ]</a>
              <a href="thread.html#3674">[ thread ]</a>
              <a href="subject.html#3674">[ subject ]</a>
              <a href="author.html#3674">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
