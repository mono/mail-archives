<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] ANNOUNCE: mono build tool demo
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20ANNOUNCE%3A%20mono%20build%20tool%20demo&In-Reply-To=20040106172233.GC11002%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003470.html">
   <LINK REL="Next"  HREF="003477.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] ANNOUNCE: mono build tool demo</H1>
    <B>Peter Williams</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20ANNOUNCE%3A%20mono%20build%20tool%20demo&In-Reply-To=20040106172233.GC11002%40debian.org"
       TITLE="[Mono-devel-list] ANNOUNCE: mono build tool demo">peter at newton.cx
       </A><BR>
    <I>Tue Jan  6 13:28:30 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="003470.html">[Mono-devel-list] ANNOUNCE: mono build tool demo
</A></li>
        <LI>Next message: <A HREF="003477.html">[Mono-devel-list] ANNOUNCE: mono build tool demo
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3474">[ date ]</a>
              <a href="thread.html#3474">[ thread ]</a>
              <a href="subject.html#3474">[ subject ]</a>
              <a href="author.html#3474">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Paolo,

On Tue, 2004-01-06 at 12:22, Paolo Molaro wrote:
&gt;<i> The mbuild document and the look of the Buildfile is nice (though
</I>&gt;<i> there are some rough edges like the &quot;inside&quot; keyword, or the verbose
</I>&gt;<i> EXTRA_DIST handling). But since everyone seems over-excited, I'll play
</I>&gt;<i> the devil's advocate.
</I>
No problem :-)

&gt;<i> 
</I>&gt;<i> The autotools cover a very large range of issues:
</I>&gt;<i> aclocal: config and feature code snippets
</I>&gt;<i> autoconf: feature detection and configuration
</I>&gt;<i> automake: makefile simplification
</I>&gt;<i> make: build tool
</I>&gt;<i> libtool: library and link tool
</I>&gt;<i> 
</I>&gt;<i> For historical reasons it's quite a mess: many different tools,
</I>&gt;<i> many different implementation languages, ugly syntax and so on.
</I>&gt;<i> But it's also something that works fairly well, it's portable
</I>&gt;<i> (well on windows it's so slow to be unusable, but that is really the
</I>&gt;<i> fault of the windows OS) and has many advanced features.
</I>&gt;<i> There is also an additional issue: the tools work best when they are all
</I>&gt;<i> used together, so any replacement must solve the same set of issues to
</I>&gt;<i> be useful.
</I>&gt;<i> 
</I>&gt;<i> As it is explained in the mbuild docs, mbuild has a (nice) design to
</I>&gt;<i> solve some of the same issues that make and automake solve. There is
</I>&gt;<i> nothing in the docs that suggest it has a design to replace autoconf,
</I>&gt;<i> for example, or libtool (and, if it has, is the solution better then
</I>&gt;<i> what we have now?).
</I>
There is a design. The rough idea is that certain targets are in a
'Configuration' group, and the tool has a mode that lets you view and
modify all of their values. Examples would be /config/want_foofeature or
/config/cc_program. Ideally, the developer could add annotations useful
to the end user:

want_foofeature = UserConfigurableBool [
	default = true
	truedesc = &quot;Use the Foobulator (recommended)&quot;
	falsedesc = &quot;Don't use the Foobulator (reduces executable size)&quot;
]

Then the build tool could even generate a .po file from all the build
files and you could have translatable build configury ...

Similarly, there would be a 'Prerequisite' group, and the build tool
would shout at you if the targets in that group failed to build. With a
decent suite of operations (along the lines of AC_TRY_COMPILE,
AC_CHECK_LIB, etc) I think this setup would provide a good framework for
replacing autoconf checks, and the integration with the build tool would
be a big win.

&gt;<i> Portability-wise, mbuild seems to be a step back that people would be
</I>&gt;<i> willing to pay if it solved the other issues in a better way.
</I>&gt;<i> Some of the solved issues are:
</I>&gt;<i> * nice syntax (no whitespace significance and not overly verbose as the
</I>&gt;<i> xml-based tools)
</I>&gt;<i> * make dist/clean
</I>&gt;<i> 
</I>&gt;<i> But at this point the lacking features over make/automake are too many
</I>&gt;<i> to list, so we need time for the tool to mature (simply because it takes
</I>&gt;<i> a lot of time to implement the advanced stuff: -j support, revision
</I>&gt;<i> controlled dependencies, etc.).
</I>
Portability is of course an issue. The way I figure it, it won't be
insanely difficult to get it as portable as Mono... and not relying on
the shell might make some other portability issues a lot easier to deal
with. Beyond that, I don't think anyone imagines that MBuild will be
running on Vax machines any time soon.

As you said, we definitely need time for things to mature. I certainly
don't want to replace the MCS or Mono build systems. I just wanted to
put the basic ideas out there.

&gt;<i> There is one feature, though, that should be considered from the start
</I>&gt;<i> and this is the one feature where all the make replacements failed
</I>&gt;<i> in some way or the other: expansibility of the rules implementation.
</I>&gt;<i> make just executes the command with a shell, so people that write
</I>&gt;<i> makefiles have a fairly rich programming environment (well, as unix
</I>&gt;<i> shells go, I'll ignore the poor windows users).
</I>&gt;<i> Some build tools provide a limited set of builtin actions that can be
</I>&gt;<i> somehow combined with some verbose syntax. Others expose the language
</I>&gt;<i> they were implemented in (typically perl, python or scheme), because
</I>&gt;<i> they were create more for language evangelization than as a build tool.
</I>&gt;<i> Others expose yet another limited and otherwise usless custom
</I>&gt;<i> programming language. Some others require to write complex modules
</I>&gt;<i> that will be loaded at runtime by the build tool (or, worse, at
</I>&gt;<i> build-tool compile time!).
</I>&gt;<i> The rules in mini/Makefile.am are an example of rules that many build
</I>&gt;<i> tools would require me to walk on my head for what automake/make
</I>&gt;<i> requires just one simple line of code.
</I>&gt;<i> 
</I>&gt;<i> None of the make replacements, imho, succeded in creating the right
</I>&gt;<i> balance between syntax clarity, expansibility and easy of use that would
</I>&gt;<i> make them a compelling replacement for make. They failed because this is
</I>&gt;<i> a really hard issue to address, so I'm not blaming anyone, but I'm also
</I>&gt;<i> not expecting mbuild to have a solution for it that satisfies the 95% of
</I>&gt;<i> developers that still use the autotools and make. Of course, I'd love to
</I>&gt;<i> be proved wrong.
</I>
I am totally aware of this. I'm not sure how to approach this problem.
Initially, I wrote a small Lisp interpreter and tried to express all the
build rules through it; it's a cute idea, since build rules are more or
less functional, but the syntax would scare a lot of people and I want
to be able to compile rules into assemblies ... writing a Lisp -&gt; IL
compiler is not my idea of a good way to get things moving :-)

However, once the infrastructure is in place, I think I might take
another look at the Lisp foundation. If I can figure out a good way to
bind to preexisting rules, I think it could make a workable solution. I
know that there will be at least two major subsystems: something for
executing external programs, and another for processing text files a la
grep, sed, cat, etc. With the right hooks, I think the majority of
custom build rules could be implemented fairly easily.

The other ideas that I can see are either inventing a small procedural
scripting language or using some kind of CodeBehind system. Once I write
enough build rules, the infrastructure might be stable enough for the
latter system to make sense. On the other hand, I've always felt that
CodeBehind is sort of a lame idea. On the third hand, I've never used
it, and the current build rules do involve a reasonable amount of
boilerplate code, so it might make sense.

Peter

-- 
Peter Williams                          <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">peter at newton.cx</A>

&quot;[Ninjas] are cool; and by cool, I mean totally sweet.&quot;
                              -- REAL Ultimate Power


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003470.html">[Mono-devel-list] ANNOUNCE: mono build tool demo
</A></li>
	<LI>Next message: <A HREF="003477.html">[Mono-devel-list] ANNOUNCE: mono build tool demo
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3474">[ date ]</a>
              <a href="thread.html#3474">[ thread ]</a>
              <a href="subject.html#3474">[ subject ]</a>
              <a href="author.html#3474">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
