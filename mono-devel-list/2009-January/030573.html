<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] C++, COM interop
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20C%2B%2B%2C%20COM%20interop&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030736.html">
   <LINK REL="Next"  HREF="030577.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] C++, COM interop</H1>
    <B>BGB</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20C%2B%2B%2C%20COM%20interop&In-Reply-To="
       TITLE="[Mono-dev] C++, COM interop">cr88192 at hotmail.com
       </A><BR>
    <I>Tue Jan 20 19:07:14 EST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="030736.html">[Mono-dev]  C++, COM interop
</A></li>
        <LI>Next message: <A HREF="030577.html">[Mono-dev] C++, COM interop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30573">[ date ]</a>
              <a href="thread.html#30573">[ thread ]</a>
              <a href="subject.html#30573">[ subject ]</a>
              <a href="author.html#30573">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
----- Original Message ----- 
From: &quot;QbProg&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">tholag at gmail.com</A>&gt;
To: &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>&gt;
Sent: Wednesday, January 21, 2009 7:22 AM
Subject: [Mono-dev] C++, COM interop


&gt;<i>
</I>&gt;<i> Hello Mono users and developers!
</I>&gt;<i>
</I>&gt;<i> I have a native C++ class library , a COM wrapper written in ATL and a 
</I>&gt;<i> .NET
</I>&gt;<i> wrapper written in C++/CLI.
</I>&gt;<i> Now, I'm thinking how it would be possible to write a mono wrapper that 
</I>&gt;<i> runs
</I>&gt;<i> mainly in LINUX.
</I>&gt;<i> Basically I see two suggested ways:
</I>&gt;<i> - Write a flatten &quot;C&quot; version on the library and use P/Invoke
</I>&gt;<i> - Use SWIG to do such a thing
</I>&gt;<i>
</I>&gt;<i> I don't like neither of these, since the wrapper has many functions and
</I>&gt;<i> classes.
</I>&gt;<i> I see a better in using a sort of COM / XPCOM interfaces.
</I>&gt;<i>
</I>&gt;<i> I have no problems in making the wrapper based on interfaces (like I did 
</I>&gt;<i> for
</I>&gt;<i> the COM one). The only thing that I can not use are class factories since
</I>&gt;<i> COM is not available in Windows. Hoever , I've got no problem in 
</I>&gt;<i> eventually
</I>&gt;<i> writing a custom factory for required COM Classes.
</I>&gt;<i>
</I>&gt;<i> I see that there is a main difference between COM and XPCOM interop. (?)
</I>&gt;<i> In com you can write
</I>&gt;<i> CClass c = new cClass ()
</I>&gt;<i>
</I>&gt;<i> and the COM layer will call the relative class factory. In XPCOm you have 
</I>&gt;<i> to
</I>&gt;<i> call manually a function to create the class.
</I>&gt;<i>
</I>&gt;<i> The question is : is there a way to redirect the &quot;new&quot; for a COM class (in
</I>&gt;<i> linux) so I can directly call a custom class factory function (this time
</I>&gt;<i> &quot;internal&quot;) ?
</I>&gt;<i> I.e.
</I>&gt;<i> COMClass C = new COMClass;
</I>&gt;<i>
</I>&gt;<i> i.e. instead of calling CoCreateObject should call an internal function
</I>&gt;<i> CreateCOMClass ?
</I>&gt;<i>
</I>&gt;<i> I don't know if I made it clear...
</I>&gt;<i>
</I>&gt;<i> I'll continue trying, and I'll share my experience, so maybe users can 
</I>&gt;<i> find
</I>&gt;<i> an additional way to wrap C++ classes.
</I>&gt;<i>
</I>

I am not sure if others would agree here, but personally I feel a much 
&quot;better&quot; approach (or, at least it avoids COM...) would be to write an 
autowrapper tool to automatically generate either a plain C-based API, or a 
JNI-based API, and another tool to emit the code needed to import all of 
this back into .NET (via P/Invoke) or similar...

in such a tool, each class is converted to a raw/&quot;incomplete&quot; pointer, and 
each method is converted into a function with a mangled name accepting the 
class as the first argument. the whole mass would be C++, but all functions 
are declared with &quot;extern C&quot;.

a pair tool would generate all the interface code in C++/CLI or C# or 
similar (treating the C++ classes as unmanaged pointers and calling the 
wrapper functions via P/Invoke...).


of course, this would be fairly similar to what SWIG does, assuming SWIG 
does not do this already (I have not looked into SWIG that much 
personally...).

but, in any case, assuming the C++ headers are fairly &quot;clean&quot;, the tool need 
not even fully understand C++ syntax to pull this off (AKA: a dumb tool 
representing a state machine and processing 1 line at a time, ignoring 
anything it doesn't recognize).


although not for C++ (mostly I use C for various reasons, mainly that it is 
much easier to &quot;tool&quot; than C++ ...), a few of the major tools in my codebase 
work similar to this (mostly because I am too lazy to bother with keeping 
headers up to date, I find it more convinient to just write the code and 
make use of a special tool to write many of the headers for me...).

I had also decided long ago I would not make use of a language which I could 
not within reasonable effort implement automated tools for, and so I stick 
mostly to C. OTOH many people use C++ for most things, and end up with 
codebases which are not easily ammended to the use of automated tools, is 
not exactly standardized at the level of generated machine code, object 
layout, ... (2 independent C++ compilers tending to produce code which will 
not link, ...).


(actually, if such a tool were implemented, would it be reasonable to 
package it with Mono?...).

or, maybe this already exists and I missed it (I don't have this problem, so 
I didn't look...).

actually, this kind of a thing is a major reason why I use C-based APIs for 
all my libs (even if internally they use C++). as such, any C++ based API is 
then implemented as a wrapper over the C-based one (a library can be written 
in C++, and there is an external C++ - based API as well, but they do not 
directly communicate as such, which also helps promote abstraction between 
the frontend and the library internals...).


or such...


&gt;<i> Thank you.
</I>&gt;<i> QbProg
</I>&gt;<i> -- 
</I>&gt;<i> View this message in context: 
</I>&gt;<i> <A HREF="http://www.nabble.com/C%2B%2B%2C-COM-interop-tp21539294p21539294.html">http://www.nabble.com/C%2B%2B%2C-COM-interop-tp21539294p21539294.html</A>
</I>&gt;<i> Sent from the Mono - Dev mailing list archive at Nabble.com.
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> 
</I>
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030736.html">[Mono-dev]  C++, COM interop
</A></li>
	<LI>Next message: <A HREF="030577.html">[Mono-dev] C++, COM interop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30573">[ date ]</a>
              <a href="thread.html#30573">[ thread ]</a>
              <a href="subject.html#30573">[ subject ]</a>
              <a href="author.html#30573">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
