<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Question	about	TransformFinalBlock	with	SymmetricAlgorithms and CBC
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Question%0A%09about%09TransformFinalBlock%09with%09SymmetricAlgorithms%20and%20CBC&In-Reply-To=49835A32.1010902%40ufl.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030711.html">
   <LINK REL="Next"  HREF="030713.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Question	about	TransformFinalBlock	with	SymmetricAlgorithms and CBC</H1>
    <B>Sebastien Pouliot</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Question%0A%09about%09TransformFinalBlock%09with%09SymmetricAlgorithms%20and%20CBC&In-Reply-To=49835A32.1010902%40ufl.edu"
       TITLE="[Mono-dev] Question	about	TransformFinalBlock	with	SymmetricAlgorithms and CBC">sebastien.pouliot at gmail.com
       </A><BR>
    <I>Fri Jan 30 15:07:09 EST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="030711.html">[Mono-dev] Question about TransformFinalBlock	with	SymmetricAlgorithms and CBC
</A></li>
        <LI>Next message: <A HREF="030713.html">[Mono-dev] Question about	TransformFinalBlock	with	SymmetricAlgorithms and CBC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30712">[ date ]</a>
              <a href="thread.html#30712">[ thread ]</a>
              <a href="subject.html#30712">[ subject ]</a>
              <a href="author.html#30712">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2009-01-30 at 14:51 -0500, David Wolinsky wrote:
&gt;<i> Sebastien Pouliot wrote:
</I>&gt;<i> &gt; On Fri, 2009-01-30 at 13:59 -0500, David Wolinsky wrote:
</I>&gt;<i> &gt;   
</I>&gt;<i> &gt;&gt; Sebastien Pouliot wrote:
</I>&gt;<i> &gt;&gt;     
</I>&gt;<i> &gt;&gt;&gt; On Fri, 2009-01-30 at 12:27 -0500, David Wolinsky wrote:
</I>&gt;<i> &gt;&gt;&gt;   
</I>&gt;<i> &gt;&gt;&gt;       
</I>&gt;<i> &gt;&gt;&gt;&gt; Hey guys,
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; Just wanted to let you know a behavioral difference between .Net and 
</I>&gt;<i> &gt;&gt;&gt;&gt; Mono and potentially get advice from you.  The method 
</I>&gt;<i> &gt;&gt;&gt;&gt; SA.CreateEncryptor.TransformFinalBlock() differs on the two platforms.  
</I>&gt;<i> &gt;&gt;&gt;&gt; Specifically, Mono appears to continue from where the last one ended, 
</I>&gt;<i> &gt;&gt;&gt;&gt; whereas .Net repeats itself (i.e. the IV is the same IV you inserted 
</I>&gt;<i> &gt;&gt;&gt;&gt; when the ICryptoTransform was created).
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; Below is a sample.
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; using System;
</I>&gt;<i> &gt;&gt;&gt;&gt; using System.Security.Cryptography;
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; public class tdes_test {
</I>&gt;<i> &gt;&gt;&gt;&gt;   public static void Main() {
</I>&gt;<i> &gt;&gt;&gt;&gt;     RijndaelManaged rm = new RijndaelManaged();
</I>&gt;<i> &gt;&gt;&gt;&gt;     byte[] key = new byte[rm.KeySize / 8];
</I>&gt;<i> &gt;&gt;&gt;&gt;     for(int i = 0; i &lt; key.Length; i++) {
</I>&gt;<i> &gt;&gt;&gt;&gt;       key[i] = (byte) i;
</I>&gt;<i> &gt;&gt;&gt;&gt;     }
</I>&gt;<i> &gt;&gt;&gt;&gt;     byte[] iv = new byte[rm.BlockSize / 8];
</I>&gt;<i> &gt;&gt;&gt;&gt;     for(int i = 0; i &lt; iv.Length; i++) {
</I>&gt;<i> &gt;&gt;&gt;&gt;       iv[i] = (byte) i;
</I>&gt;<i> &gt;&gt;&gt;&gt;     }
</I>&gt;<i> &gt;&gt;&gt;&gt;     ICryptoTransform encryptor = rm.CreateEncryptor(key, iv);
</I>&gt;<i> &gt;&gt;&gt;&gt;     byte[] data = new byte[111];
</I>&gt;<i> &gt;&gt;&gt;&gt;     for(int i = 0; i &lt; data.Length; i++) {
</I>&gt;<i> &gt;&gt;&gt;&gt;       data[i] = (byte) i;
</I>&gt;<i> &gt;&gt;&gt;&gt;     }
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;     byte[] encrypted_data = encryptor.TransformFinalBlock(data, 0, 
</I>&gt;<i> &gt;&gt;&gt;&gt; data.Length);
</I>&gt;<i> &gt;&gt;&gt;&gt;     for(int i = 0; i &lt; encrypted_data.Length; i++) {
</I>&gt;<i> &gt;&gt;&gt;&gt;       Console.Write(encrypted_data[i]);
</I>&gt;<i> &gt;&gt;&gt;&gt;     }
</I>&gt;<i> &gt;&gt;&gt;&gt;     Console.WriteLine(&quot;\n&quot;);
</I>&gt;<i> &gt;&gt;&gt;&gt;     encrypted_data = encryptor.TransformFinalBlock(data, 0, data.Length);
</I>&gt;<i> &gt;&gt;&gt;&gt;     for(int i = 0; i &lt; encrypted_data.Length; i++) {
</I>&gt;<i> &gt;&gt;&gt;&gt;       Console.Write(encrypted_data[i]);
</I>&gt;<i> &gt;&gt;&gt;&gt;     }
</I>&gt;<i> &gt;&gt;&gt;&gt;   }
</I>&gt;<i> &gt;&gt;&gt;&gt; }
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; We're currently using this on a datagram security system and on Mono 
</I>&gt;<i> &gt;&gt;&gt;&gt; (not sure if .Net is the same) creation of Encryptors and Decryptors is 
</I>&gt;<i> &gt;&gt;&gt;&gt; expensive.  Any thoughts or suggestions?
</I>&gt;<i> &gt;&gt;&gt;&gt;     
</I>&gt;<i> &gt;&gt;&gt;&gt;         
</I>&gt;<i> &gt;&gt;&gt; Your code should always* look at ICryptoTransform.CanReuseTransform
</I>&gt;<i> &gt;&gt;&gt; before reusing a transform. If false then it cannot be reused.
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; * since you should be using the factory methods to create ciphers
</I>&gt;<i> &gt;&gt;&gt; (e.g. &#65279;Rijndael.Create) and you can't be sure what exact class the
</I>&gt;<i> &gt;&gt;&gt; runtime will instantiate (nor it's behavior).
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; Sebastien
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;   
</I>&gt;<i> &gt;&gt;&gt;       
</I>&gt;<i> &gt;&gt; Thanks for the reply.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; In our deployed code, I actually use SymmetricAlgorithm.Create(string), 
</I>&gt;<i> &gt;&gt; and it is a cleaner API, this was just a test.
</I>&gt;<i> &gt;&gt;     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Great :)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i> &gt;&gt; Now on to the &quot;ReuseTransform&quot; part.  We'd expect the same result in 
</I>&gt;<i> &gt;&gt; both .Net and Mono, but it is different.  .Net returns true, while Mono 
</I>&gt;<i> &gt;&gt; returns false.  (This is both with and without Rijndael.Create).  Am I 
</I>&gt;<i> &gt;&gt; wrong in expecting the same behavior from both platforms?
</I>&gt;<i> &gt;&gt;     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yes and no. We generally tend to do the exact same (good or bad) thing -
</I>&gt;<i> &gt; but this one is an exception because you should not expect any specific
</I>&gt;<i> &gt; value, either true or false *even* on MS platforms alone. That's
</I>&gt;<i> &gt; because:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; (a) it could change in the future (e.g. the default &#65279;&#65279;Rijndael could be
</I>&gt;<i> &gt; provided by a CSP or CNG provider in future frameworks). This is less
</I>&gt;<i> &gt; likely for &#65279;RijndaelManaged but you can't be sure this is what you'll
</I>&gt;<i> &gt; receive when using the factory methods; 
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 	or more likely (i.e. it could occur today)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; (b) someone could have an alternative implementation (e.g. native or
</I>&gt;<i> &gt; hardware acceleration) and have its machine.config redirect the
</I>&gt;<i> &gt; &quot;default&quot; &#65279;Rijndael implementation to some custom code.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; In both case you cannot assume if you can, or can't, reuse a transform
</I>&gt;<i> &gt; without checking the property. So yes Mono has a different default value
</I>&gt;<i> &gt; - but this is not the real (or the major) issue.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sebastien
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i> Thanks for the wealth of information and making it clear.  I agree this 
</I>&gt;<i> is not the issue, obviously we cannot use the TransformFinalBlock 
</I>&gt;<i> without a) creating decryptors and encryptors each time or b) force 
</I>&gt;<i> users to use a frozen mono version.  So back to the original question...
</I>&gt;<i> 
</I>&gt;<i> &quot;We're currently using this on a datagram security system and on Mono 
</I>&gt;<i> (not sure if .Net is the same) creation of Encryptors and Decryptors is 
</I>&gt;<i> expensive. Any thoughts or suggestions?&quot;
</I>
&#65279;First make sure if this is the creation of transforms that is costly
(something that you could save by resetting the transform) or if it is
the cipher initialization (that you can't save anyway by resetting the
transform). It's likely a bit of both... but that will tell you what
options is best.

&gt;<i> Could we yank out the guts of Mono's FinalEncrypt/FinalDecrypt and just 
</I>&gt;<i> use the TransformBlock instead of the internal calls without worries?  
</I>
Yes you can. All the code is available, MIT licensed. The existing API
has limitations (it's not very memory friendly) so you could adapt the
code to use an API without any memory allocations (beside the initial
buffers) which could help performance - at least if this fits your
application.

&gt;<i> Is there another approach that I am blind to?
</I>
You could also use machine.config support to use a native implementation
of AES (I assume this is the &#65279;&#65279;Rijndael mode you're using anyway).
You'll find hand-optimized assembly implementation of most existing CPU.

In this case you'll need to write a C# wrapper around it and ensure it's
registered in machine.config (if you want to replace the default).
Alternatively you could have your C# code do a fallback to the existing
managed code if the native library is unavailable (and show a warning to
the end-users).

Sebastien

</PRE>






























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030711.html">[Mono-dev] Question about TransformFinalBlock	with	SymmetricAlgorithms and CBC
</A></li>
	<LI>Next message: <A HREF="030713.html">[Mono-dev] Question about	TransformFinalBlock	with	SymmetricAlgorithms and CBC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30712">[ date ]</a>
              <a href="thread.html#30712">[ thread ]</a>
              <a href="subject.html#30712">[ subject ]</a>
              <a href="author.html#30712">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
