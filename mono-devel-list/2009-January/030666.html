<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] Enable TLS for PPC32/64
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Enable%20TLS%20for%20PPC32/64&In-Reply-To=497CFFDA.1040104%40us.ibm.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030645.html">
   <LINK REL="Next"  HREF="030669.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] Enable TLS for PPC32/64</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Enable%20TLS%20for%20PPC32/64&In-Reply-To=497CFFDA.1040104%40us.ibm.com"
       TITLE="[Mono-dev] [PATCH] Enable TLS for PPC32/64">lupus at ximian.com
       </A><BR>
    <I>Wed Jan 28 10:46:44 EST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="030645.html">[Mono-dev] [PATCH] Enable TLS for PPC32/64
</A></li>
        <LI>Next message: <A HREF="030669.html">[Mono-dev] [PATCH] Enable TLS for PPC32/64
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30666">[ date ]</a>
              <a href="thread.html#30666">[ thread ]</a>
              <a href="subject.html#30666">[ subject ]</a>
              <a href="author.html#30666">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/25/09 Steven Munroe wrote:
&gt;<i> What you consider superfluous addresses an annoying bug where the
</I>&gt;<i> mkbundle generates code that can never be assembled and results in a 2GB
</I>&gt;<i> a.out file. This is a result of brain-dead code the than can't handle
</I>&gt;<i> biarch builds (where the build is for the non-default arch).
</I>&gt;<i> 
</I>&gt;<i> Has far I can tell mkbundle is disabled for PPC32 and has been for some
</I>&gt;<i> time ...
</I>
mkbundle used to work on linux and osx on ppc32. IIRC it was disabled
because for some reason that I didn't investigate, the pkg-config call
failed while running make test on the POS that is OSX, while it worked
when the test was executed standalone.
So there should be no reason to disable it on ppc64: if there is an
actual bug it needs to be fixed.

&gt;<i> 2009-01-24  Steven Munroe  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">munroesj at us.ibm.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> This patch is contributed under the terms of the MIT/X11 license
</I>&gt;<i> 
</I>&gt;<i> 	* exceptions-ppc.c (mono_arch_get_restore_context): Correct
</I>&gt;<i> 	g_assert test.
</I>&gt;<i> 	* tramp-ppc.c (mono_arch_create_trampoline_code): Use
</I>&gt;<i> 	MONO_PPC_32_64_CASE to set tramp_size for 64-bit.
</I>&gt;<i> 
</I>&gt;<i> 	* Makefile.am: Disable mkbundle for POWERPC64.
</I>&gt;<i> 
</I>&gt;<i> diff -urN mono-svn0/mono/mono/mini/exceptions-ppc.c mono-svn-fix/mono/mono/mini/exceptions-ppc.c
</I>&gt;<i> --- mono-svn0/mono/mono/mini/exceptions-ppc.c	2009-01-23 17:05:56.000000000 -0600
</I>&gt;<i> +++ mono-svn-fix/mono/mono/mini/exceptions-ppc.c	2009-01-24 12:21:08.000000000 -0600
</I>&gt;<i> @@ -218,7 +218,7 @@
</I>&gt;<i>  	/* never reached */
</I>&gt;<i>  	ppc_break (code);
</I>&gt;<i>  
</I>&gt;<i> -	g_assert ((code - start) &lt; size);
</I>&gt;<i> +	g_assert ((code - start) &lt;= size);
</I>&gt;<i>  	mono_arch_flush_icache (start, code - start);
</I>&gt;<i>  	return start;
</I>&gt;<i>  }
</I>&gt;<i> diff -urN mono-svn0/mono/mono/mini/tramp-ppc.c mono-svn-fix/mono/mono/mini/tramp-ppc.c
</I>&gt;<i> --- mono-svn0/mono/mono/mini/tramp-ppc.c	2009-01-23 17:05:56.000000000 -0600
</I>&gt;<i> +++ mono-svn-fix/mono/mono/mini/tramp-ppc.c	2009-01-24 12:22:03.000000000 -0600
</I>&gt;<i> @@ -504,7 +504,7 @@
</I>&gt;<i>  	guint8 *jump;
</I>&gt;<i>  	int tramp_size;
</I>&gt;<i>  
</I>&gt;<i> -	tramp_size = 32;
</I>&gt;<i> +	tramp_size = MONO_PPC_32_64_CASE (32, 44);
</I>&gt;<i>  
</I>&gt;<i>  	code = buf = mono_global_codeman_reserve (tramp_size);
</I>&gt;<i>  
</I>
This part is ok to commit.

&gt;<i> 009-01-24  Steven Munroe  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">munroesj at us.ibm.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> This patch is contributed under the terms of the MIT/X11 license
</I>&gt;<i> 
</I>&gt;<i> 	* ppc-codegen.h: Make operand order and case consistent
</I>&gt;<i> 	(assembler order) for ppc_load_reg_update,
</I>&gt;<i> 	ppc_load_multiple_regs, ppc_store_multiple_regs, ppc_lwz,
</I>&gt;<i> 	ppc_lhz, ppc_lbz, ppc_stw,ppc_sth, ppc_stb, ppc_stwu, ppc_lbzu,
</I>&gt;<i> 	ppc_lfdu, ppc_lfsu, ppc_lfsux, ppc_lfsx, ppc_lha, ppc_lhau,
</I>&gt;<i> 	ppc_lhzu, ppc_lmw, ppc_lwzu, ppc_stbu, ppc_stfdu, ppc_stfsu,
</I>&gt;<i> 	ppc_sthu, ppc_stmw.
</I>&gt;<i> 	Use &quot;i&quot; or &quot;ui&quot; instead of &quot;d&quot; for immediated operands to
</I>&gt;<i> 	immediate arthimetic and logical instructions in macros
</I>&gt;<i> 	ppc_addi, ppc_addis, ppc_ori, ppc_addic, ppc_addicd, ppc_andid,
</I>&gt;<i> 	ppc_andisd.
</I>&gt;<i> 	[__mono_ppc64__]: Make operand order and case consistent
</I>&gt;<i> 	(assembler order) for ppc_load_multiple_regs,
</I>&gt;<i> 	ppc_store_multiple_regs.
</I>&gt;<i> 	Simplify the DS form and make them consistent with D forms for
</I>&gt;<i> 	ppc_load_reg, ppc_load_reg_update,  ppc_store_reg,
</I>&gt;<i> 	ppc_store_reg_update. ppc_ld, ppc_lwa, ppc_ldu, ppc_std,
</I>&gt;<i> 	ppc_stdu.
</I>&gt;<i> 	Define ppc_lwax and ppc_lwaux.
</I>&gt;<i> 
</I>&gt;<i> 	* exceptions-ppc.c (restore_regs_from_context): Correct operand
</I>&gt;<i> 	order (offset then base reg) for ppc_load_multiple_regs.
</I>&gt;<i> 	(emit_save_saved_regs) Correct operand order for
</I>&gt;<i> 	ppc_store_multiple_regs.
</I>&gt;<i> 	(mono_arch_get_call_filter): Correct operand order for
</I>&gt;<i> 	ppc_load_multiple_regs.
</I>&gt;<i> 	* mini-ppc.c (emit_memcpy): Fix operand order for
</I>&gt;<i> 	ppc_load_reg_update and ppc_store_reg_update.
</I>&gt;<i> 	(mono_arch_output_basic_block): Correct operand order for
</I>&gt;<i> 	ppc_lha.
</I>&gt;<i> 	(mono_arch_emit_epilog): Correct operand order for
</I>&gt;<i> 	ppc_load_multiple_regs.
</I>&gt;<i> 	* tramp-ppc.c (mono_arch_create_trampoline_code): Correct
</I>&gt;<i> 	operand order for ppc_store_multiple_regs and
</I>&gt;<i> 	ppc_load_multiple_regs.
</I>
This patch is fine.

&gt;<i> 2009-01-24  Steven Munroe  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">munroesj at us.ibm.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> This patch is contributed under the terms of the MIT/X11 license
</I>&gt;<i> 
</I>&gt;<i> 	* ppc-codegen.h: Change ppc_is_imm16 and ppc_is_imm32 to avoid
</I>&gt;<i> 	compiler warnings in 64-bit. 
</I>
Will this generate warnings on ppc32 instead?

&gt;<i> 	* mini-ppc.c (emit_memcpy): Use type long instead of int for
</I>&gt;<i> 	values used to large immediate fields to eliminate range
</I>&gt;<i> 	warnings.
</I>&gt;<i> 	(mono_arch_emit_outarg_vt) [__APPLE__]: Declare size.
</I>&gt;<i> 	(emit_float_to_int); Change vars offset and sub_offset to type
</I>&gt;<i> 	long.
</I>&gt;<i> 	(emit_load_volatile_arguments) [__APPLE__]: Declare size.
</I>&gt;<i> 	(emit_reserve_param_area): 
</I>&gt;<i> 	(emit_unreserve_param_area: Change var size to type long.
</I>&gt;<i> 	(mono_arch_output_basic_block): Copy cfg-&gt;stack_usage to local
</I>&gt;<i> 	type long to avoid warnings.  Also compute LR save offset
</I>&gt;<i> 	in a local long ret_offset.
</I>&gt;<i> 	[!__mono_ppc64__]: Use smaller ppc_load_sequence const value if
</I>&gt;<i> 	32-bit.
</I>&gt;<i> 	(mono_arch_emit_prolog): Change vars alloc_size, pos,
</I>&gt;<i> 	max_offset to type long. Add &quot;l&quot; modifier to g_print for operand
</I>&gt;<i> 	pos. 
</I>&gt;<i> 	[!__mono_ppc64__]: Use smaller ppc_load_sequence const value if
</I>&gt;<i> 	32-bit.
</I>&gt;<i> 	(mono_arch_emit_epilog): Copy cfg-&gt;stack_usage to local
</I>&gt;<i> 	type long to avoid warnings.
</I>&gt;<i> 	(try_offset_access): #if 0 away.
</I>&gt;<i> 
</I>&gt;<i> diff -urN mono-svn64-gen/mono/mono/mini/mini-ppc.c mono-svn64-warn/mono/mono/mini/mini-ppc.c
</I>&gt;<i> --- mono-svn64-gen/mono/mono/mini/mini-ppc.c	2009-01-24 14:24:34.000000000 -0600
</I>&gt;<i> +++ mono-svn64-warn/mono/mono/mini/mini-ppc.c	2009-01-25 12:29:19.000000000 -0600
</I>&gt;<i> @@ -137,9 +137,9 @@
</I>&gt;<i>  {
</I>&gt;<i>  	/* unrolled, use the counter in big */
</I>&gt;<i>  	if (size &gt; sizeof (gpointer) * 5) {
</I>&gt;<i> -		int shifted = size &gt;&gt; MONO_PPC_32_64_CASE (2, 3);
</I>&gt;<i> +		long shifted = size &gt;&gt; MONO_PPC_32_64_CASE (2, 3);
</I>&gt;<i>  		guint8 *copy_loop_start, *copy_loop_jump;
</I>&gt;<i> -
</I>&gt;<i> +		
</I>
Please don't introduce whitespace damage.

&gt;<i>  		ppc_load (code, ppc_r0, shifted);
</I>&gt;<i>  		ppc_mtctr (code, ppc_r0);
</I>&gt;<i>  		g_assert (sreg == ppc_r11);
</I>&gt;<i> @@ -1499,9 +1499,9 @@
</I>&gt;<i>  	int i, soffset, dreg;
</I>&gt;<i>  
</I>&gt;<i>  	if (ainfo-&gt;regtype == RegTypeStructByVal) {
</I>&gt;<i> -		guint32 size = 0;
</I>&gt;<i>  		soffset = 0;
</I>&gt;<i>  #ifdef __APPLE__
</I>&gt;<i> +		guint32 size = 0;
</I>
This introduces declarations after code: while accepted by recent
compilers, such cases shouldn't be used in mono.

&gt;<i> @@ -3546,7 +3548,7 @@
</I>&gt;<i>  			break;
</I>&gt;<i>  		case OP_JMP: {
</I>&gt;<i>  			int i, pos;
</I>&gt;<i> -			
</I>&gt;<i> +			long stack_usage = cfg-&gt;stack_usage;
</I>
It seems to me it would be more sensible to declare cfg-&gt;stack_usage as
long instead of adding the locals.


&gt;<i> 2009-01-24  Steven Munroe  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">munroesj at us.ibm.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> This patch is contributed under the terms of the MIT/X11 license
</I>&gt;<i> 
</I>&gt;<i> 	* ppc-codegen.h [__mono_ppc64__]: Define ppc_is_imm48 and
</I>&gt;<i> 	ppc_load48. Update ppc_load to use ppc_is_imm48 and ppc_load48
</I>&gt;<i> 	to allow for a shorter sequence for most address constants.
</I>&gt;<i> 
</I>&gt;<i> 	* mini-ppc.c: Add includes to get at Aux vector definitions..
</I>&gt;<i> 	[__linux__]: Define functions linux_find_auxv, linux_get_auxv,
</I>&gt;<i> 	linux_auxv_init_once, linux_query_auxv, linux_init_ppc_SMP,
</I>&gt;<i> 	linux_init_ppc_platform.
</I>&gt;<i> 	Define flags/values auxv_once_control, linux_ppc_hwcap,
</I>&gt;<i> 	linux_ppc_platform, linux_ppc_ISA2x, linux_ppc_ISA2x_mask,
</I>&gt;<i> 	linux_ppc_SMP, linux_ppc_LSUs, linux_ppc_FXUs, linux_ppc_FPUs.
</I>&gt;<i> 	Define macros HAS_ICACHE_SNOOP.
</I>&gt;<i> 	(emit_memcpy): Generate optimized code for longer moves where
</I>&gt;<i> 	linux_ppc_LSUs is 2 or more.
</I>&gt;<i> 	(mono_arch_cpu_init) [__linux__]: Add calls to linux_auxv_init_once
</I>&gt;<i> 	and linux_init_ppc_platform.
</I>&gt;<i> 	(mono_arch_flush_icache) [__linux__]: Use linux_query_auxv
</I>&gt;<i> 	(AT_DCACHEBSIZE) and set cachelineinc and cachelinesize.
</I>&gt;<i> 	Optimize using HAS_ICACHE_SNOOP, linux_ppc_SMP, and
</I>&gt;<i> 	linux_ppc_ISA2x.
</I>&gt;<i> 	(mono_arch_output_basic_block)[__mono_ppc64__]: Replace
</I>&gt;<i> 	lwz/lwzx/extsw sequence with lwa/lwax.
</I>&gt;<i> 	(mono_arch_output_basic_block): Replace ppc_addic with ppc_addi
</I>&gt;<i> 	for case OP_JMP.
</I>&gt;<i> 	(mono_arch_emit_epilog): Replace ppc_addic with ppc_addi for
</I>&gt;<i> 	unstacking frames.
</I>&gt;<i> 	* mini-ppc.h (MONO_ARCH_HAVE_TLS_GET): Defined.
</I>&gt;<i> 	(MONO_ARCH_ENABLE_MONITOR_IL_FASTPATH): Likewise.
</I>&gt;<i> 	(PPC_THREAD_PTR_REG): Likewise.
</I>
This patch mixes some optimizations with other stuff that is not needed,
so it should be split.

&gt;<i> diff -urN mono-svn64-warn/mono/mono/arch/ppc/ppc-codegen.h mono-svn64-opt/mono/mono/arch/ppc/ppc-codegen.h
</I>&gt;<i> --- mono-svn64-warn/mono/mono/arch/ppc/ppc-codegen.h	2009-01-24 15:07:17.000000000 -0600
</I>&gt;<i> +++ mono-svn64-opt/mono/mono/arch/ppc/ppc-codegen.h	2009-01-24 16:57:11.000000000 -0600
</I>&gt;<i> @@ -719,12 +719,22 @@
</I>&gt;<i>  #define PPC_LOAD_SEQUENCE_LENGTH	20
</I>&gt;<i>  
</I>&gt;<i>  #define ppc_is_imm32(val) (((((long)val)&gt;&gt; 31) == 0) || ((((long)val)&gt;&gt; 31) == -1))
</I>&gt;<i> +#define ppc_is_imm48(val) (((((long)val)&gt;&gt; 47) == 0) || ((((long)val)&gt;&gt; 47) == -1))
</I>&gt;<i>  
</I>&gt;<i> +#define ppc_load48(c,D,v) G_STMT_START {	\
</I>&gt;<i> +		ppc_li   ((c), (D), ((gint64)(v) &gt;&gt; 32) &amp; 0xffff);	\
</I>&gt;<i> +		ppc_sldi ((c), (D), (D), 32); \
</I>&gt;<i> +		ppc_oris ((c), (D), (D), ((guint64)(v) &gt;&gt; 16) &amp; 0xffff);	\
</I>&gt;<i> +		ppc_ori  ((c), (D), (D),  (guint64)(v)        &amp; 0xffff);	\
</I>&gt;<i> +	} G_STMT_END
</I>&gt;<i> +	
</I>&gt;<i>  #define ppc_load(c,D,v) G_STMT_START {	\
</I>&gt;<i>  		if (ppc_is_imm16 ((gulong)(v)))	{	\
</I>&gt;<i>  			ppc_li ((c), (D), (guint16)(guint64)(v));	\
</I>&gt;<i>  		} else if (ppc_is_imm32 ((gulong)(v))) {	\
</I>&gt;<i>  			ppc_load32 ((c), (D), (guint32)(guint64)(v)); \
</I>&gt;<i> +		} else if (ppc_is_imm48 ((gulong)(v))) {	\
</I>&gt;<i> +			ppc_load48 ((c), (D), (guint64)(v)); \
</I>&gt;<i>  		} else {	\
</I>&gt;<i>  			ppc_load_sequence ((c), (D), (guint64)(v)); \
</I>&gt;<i>  		}	\
</I>
This part is fine to commit.

&gt;<i> diff -urN mono-svn64-warn/mono/mono/mini/mini-ppc.c mono-svn64-opt/mono/mono/mini/mini-ppc.c
</I>&gt;<i> --- mono-svn64-warn/mono/mono/mini/mini-ppc.c	2009-01-25 12:29:19.000000000 -0600
</I>&gt;<i> +++ mono-svn64-opt/mono/mono/mini/mini-ppc.c	2009-01-25 16:24:57.000000000 -0600
</I>&gt;<i> @@ -11,6 +11,17 @@
</I>&gt;<i>   */
</I>&gt;<i>  #include &quot;mini.h&quot;
</I>&gt;<i>  #include &lt;string.h&gt;
</I>&gt;<i> +#include &lt;unistd.h&gt;
</I>&gt;<i> +#include &lt;fcntl.h&gt;
</I>&gt;<i> +#include &lt;errno.h&gt;
</I>&gt;<i> +#include &lt;elf.h&gt;
</I>&gt;<i> +#include &lt;link.h&gt;
</I>&gt;<i> +#include &lt;pthread.h&gt;
</I>
Headers included without proper checks, besides, pthread is not needed
here, elf.h can be simply avoided (there was already a structure to
represent the auxv data that you deleted).

&gt;<i> +volatile static ElfW(auxv_t) *linux_auxv_buf = NULL;
</I>
We don't want to keep this data duplicated in memory: there is no use
except using more memory.

&gt;<i> +static ElfW(auxv_t) * 
</I>&gt;<i> +linux_get_auxv(void)
</I>&gt;<i> +{
</I>&gt;<i> +	ElfW(auxv_t) *auxv_temp = (ElfW(auxv_t) *)linux_auxv_buf;
</I>&gt;<i> +	int auxv_f;
</I>&gt;<i> +	size_t page_size = getpagesize();
</I>&gt;<i> +	ssize_t bytes;
</I>&gt;<i> +
</I>&gt;<i> +	/* If the /proc/self/auxv file has not been copied into the heap
</I>&gt;<i> +	   yet, then do it */
</I>&gt;<i> +
</I>&gt;<i> +	if(auxv_temp == NULL)
</I>&gt;<i> +	{
</I>&gt;<i> +		auxv_f = open(&quot;/proc/self/auxv&quot;, O_RDONLY);
</I>&gt;<i> +
</I>&gt;<i> +		if(auxv_f == -1) {
</I>
Mark already pointed out that you're not following the mono coding
sstyle.

&gt;<i> +		/* Older kernels did not support /proc/&lt;PID&gt;/auxv. But
</I>&gt;<i> +		   the auvx table does exist in the process address
</I>&gt;<i> +		   space following the env table. So try scanning over
</I>&gt;<i> +		   the environment table to find the auxv. */
</I>&gt;<i> +			if (errno == ENOENT) {
</I>&gt;<i> +				auxv_temp = (ElfW(auxv_t)*) linux_find_auxv();
</I>&gt;<i> +		/* If someone has done a setenv() the __environ pointer
</I>&gt;<i> +		   may have been moved and the assumption that the auxv
</I>&gt;<i> +		   follows is not true. So look at the first entry and
</I>&gt;<i> +		   verify that it is an auxv entry. */
</I>
If this detection is not reliable we should simply not do it. We can
document that users should have a 2.6 kernel.

&gt;<i> +			} else {
</I>&gt;<i> +				perror(&quot;Error opening file for reading&quot;);
</I>
We don't want to bother users with an error message that is both
non-informative and that they can't do anything about.

&gt;<i> +static pthread_once_t auxv_once_control = PTHREAD_ONCE_INIT;
</I>
There is no need to use pthread_once_t: just doing the setup in the init
call is ok.

&gt;<i> +static unsigned long	linux_ppc_hwcap;
</I>&gt;<i> +static char 		*linux_ppc_platform;
</I>&gt;<i> +static int		linux_ppc_ISA2x; /* PowerISA-2.0 or newer */
</I>&gt;<i> +static unsigned long	linux_ppc_ISA2x_mask = 0
</I>&gt;<i> +#ifdef PPC_FEATURE_POWER4 /* PowerISA-2.01 */
</I>&gt;<i> +			| PPC_FEATURE_POWER4
</I>&gt;<i> +#endif
</I>&gt;<i> +#ifdef PPC_FEATURE_POWER5 /* PowerISA-2.03 */
</I>&gt;<i> +			| PPC_FEATURE_POWER5
</I>&gt;<i> +#endif
</I>&gt;<i> +#ifdef PPC_FEATURE_POWER5_PLUS  /* PowerISA-2.04 */
</I>&gt;<i> +			| PPC_FEATURE_POWER5_PLUS
</I>&gt;<i> +#endif
</I>&gt;<i> +#ifdef PPC_FEATURE_CELL
</I>&gt;<i> +			| PPC_FEATURE_CELL
</I>&gt;<i> +#endif
</I>&gt;<i> +#ifdef PPC_FEATURE_PA6T
</I>&gt;<i> +			| PPC_FEATURE_PA6T
</I>&gt;<i> +#endif
</I>&gt;<i> +#ifdef PPC_FEATURE_ARCH_2_05
</I>&gt;<i> +			| PPC_FEATURE_ARCH_2_05
</I>&gt;<i> +#endif
</I>&gt;<i> +	; /* it took a while to figure out that the AT_HWCAP should represent
</I>&gt;<i> +	     ISA versions and optional categories/features and the AT_PLATFORM 
</I>&gt;<i> +	     should represent the CHIP design and specific micro-architecture.
</I>&gt;<i> +	     Which explains the mess above.*/
</I>&gt;<i> +
</I>&gt;<i> +/* Default to SMP true in case we can't find out.  */
</I>&gt;<i> +static int		linux_ppc_SMP = 1;
</I>&gt;<i> +
</I>&gt;<i> +/* Number of independent load store pipes in each core. */
</I>&gt;<i> +static int		linux_ppc_LSUs = 0;
</I>&gt;<i> +/* Number of independent fixed point pipes in each core. */
</I>&gt;<i> +static int		linux_ppc_FXUs = 0;
</I>&gt;<i> +/* Number of independent floating point pipes in each core. */
</I>&gt;<i> +static int		linux_ppc_FPUs = 0;
</I>
A single uint bitmask can replace all of the above for the jit usage.
Besides, having one or more load/store units is not a linux property,
so the names of the variables is incorrect.

&gt;<i> +#ifdef PPC_FEATURE_ICACHE_SNOOP
</I>&gt;<i> +#define HAS_ICACHE_SNOOP (linux_ppc_hwcap &amp; PPC_FEATURE_ICACHE_SNOOP)
</I>&gt;<i> +#else
</I>&gt;<i> +#define HAS_ICACHE_SNOOP 0
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static int
</I>&gt;<i> +linux_init_ppc_SMP(void)
</I>&gt;<i> +{
</I>&gt;<i> +	struct utsname u;
</I>&gt;<i> +	/* FIXME For 2.6.26 kernels we can try to use sysfs
</I>&gt;<i> +	   /sys/devices/system/cpu/possible,  but we would have to fall
</I>&gt;<i> +	   back to uname for early kernels anyway. */
</I>&gt;<i> +
</I>&gt;<i> +	if (uname(&amp;u) != 0) {
</I>&gt;<i> +		perror(&quot;Error uname syscall failer\n&quot;);
</I>&gt;<i> +		return 1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (strstr(u.version, &quot;SMP&quot;))
</I>&gt;<i> +		return 1;
</I>&gt;<i> +	else {
</I>&gt;<i> +		if (strstr(u.version, &quot;smp&quot;))
</I>&gt;<i> +			return 1;
</I>&gt;<i> +		else
</I>&gt;<i> +			return 0;
</I>
This doesn't look like a reliable way. We have already utility calls to
get the number of processors and that should be enough.

&gt;<i> +static void
</I>&gt;<i> +linux_init_ppc_platform(void)
</I>&gt;<i> +{
</I>&gt;<i> +	linux_ppc_hwcap = (unsigned long) linux_query_auxv (AT_HWCAP);
</I>&gt;<i> +	linux_ppc_platform = (char*) linux_query_auxv (AT_PLATFORM);
</I>&gt;<i> +	linux_ppc_ISA2x = (linux_ppc_hwcap &amp; linux_ppc_ISA2x_mask) != 0L;
</I>&gt;<i> +	linux_ppc_SMP = linux_init_ppc_SMP();
</I>&gt;<i> +	
</I>&gt;<i> +	if ((strcmp(linux_ppc_platform, &quot;power4&quot;) &gt;= 0)
</I>&gt;<i> +	&amp;&amp;  (strcmp(linux_ppc_platform, &quot;power6x&quot;) &lt;= 0)) {
</I>&gt;<i> +		linux_ppc_LSUs = 2;
</I>&gt;<i> +		linux_ppc_FXUs = 2;
</I>&gt;<i> +		linux_ppc_FPUs = 2;
</I>&gt;<i> +	} else if  (strcmp(linux_ppc_platform, &quot;ppc970&quot;) == 0) {
</I>&gt;<i> +		linux_ppc_LSUs = 2;
</I>&gt;<i> +		linux_ppc_FXUs = 2;
</I>&gt;<i> +		linux_ppc_FPUs = 2;
</I>&gt;<i> +	} else if  (strcmp(linux_ppc_platform, &quot;cell&quot;) == 0) {
</I>&gt;<i> +		linux_ppc_LSUs = 1;
</I>&gt;<i> +		linux_ppc_FXUs = 1;
</I>&gt;<i> +		linux_ppc_FPUs = 1;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i>  /* this function overwrites r0, r11, r12 */
</I>&gt;<i>  static guint8*
</I>&gt;<i>  emit_memcpy (guint8 *code, int size, int dreg, int doffset, int sreg, int soffset)
</I>&gt;<i> @@ -156,6 +367,20 @@
</I>&gt;<i>  		dreg = ppc_r12;
</I>&gt;<i>  	}
</I>&gt;<i>  #ifdef __mono_ppc64__
</I>&gt;<i> +	/* the hardware has multiple load/store units and the move is long
</I>&gt;<i> +	   enough to use more then one regiester, then use load/load/store/store
</I>&gt;<i> +	   to execute 2 instructions per cycle. */
</I>&gt;<i> +	if ((linux_ppc_LSUs &gt; 1) &amp;&amp; (dreg != ppc_r12) &amp;&amp; (sreg != ppc_r12)) { 
</I>&gt;<i> +		while (size &gt;= 16) {
</I>&gt;<i> +			ppc_load_reg (code, ppc_r0, soffset, sreg);
</I>&gt;<i> +			ppc_load_reg (code, ppc_r12, soffset+8, sreg);
</I>&gt;<i> +			ppc_store_reg (code, ppc_r0, doffset, dreg);
</I>&gt;<i> +			ppc_store_reg (code, ppc_r12, doffset+8, dreg);
</I>&gt;<i> +			size -= 16;
</I>&gt;<i> +			soffset += 16;
</I>&gt;<i> +			doffset += 16; 
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i>  	while (size &gt;= 8) {
</I>&gt;<i>  		ppc_load_reg (code, ppc_r0, soffset, sreg);
</I>&gt;<i>  		ppc_store_reg (code, ppc_r0, doffset, dreg);
</I>&gt;<i> @@ -163,6 +388,18 @@
</I>&gt;<i>  		soffset += 8;
</I>&gt;<i>  		doffset += 8;
</I>&gt;<i>  	}
</I>&gt;<i> +#else
</I>&gt;<i> +	if ((linux_ppc_LSUs &gt; 1) &amp;&amp; (dreg != ppc_r12) &amp;&amp; (sreg != ppc_r12)) { 
</I>&gt;<i> +		while (size &gt;= 8) {
</I>&gt;<i> +			ppc_load_reg (code, ppc_r0, soffset, sreg);
</I>&gt;<i> +			ppc_load_reg (code, ppc_r12, soffset+4, sreg);
</I>&gt;<i> +			ppc_store_reg (code, ppc_r0, doffset, dreg);
</I>&gt;<i> +			ppc_store_reg (code, ppc_r12, doffset+4, dreg);
</I>&gt;<i> +			size -= 8;
</I>&gt;<i> +			soffset += 8;
</I>&gt;<i> +			doffset += 8; 
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>
This optimization should be in its own separate patch (together with
numbers that show it's worthwhile).

&gt;<i> @@ -664,21 +890,29 @@
</I>&gt;<i>  		isync
</I>&gt;<i>  	}
</I>&gt;<i>  #else
</I>&gt;<i> -	if (1) {
</I>&gt;<i> -		for (p = start; p &lt; endp; p += cachelineinc) {
</I>&gt;<i> -			asm (&quot;dcbf 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
</I>&gt;<i> +	/* For POWER5/6 with ICACHE_SNOOP the dcbst/icbi is not required.  */
</I>&gt;<i> +	if (!HAS_ICACHE_SNOOP) {
</I>&gt;<i> +		if (linux_ppc_SMP) {
</I>&gt;<i> +			for (p = start; p &lt; endp; p += cachelineinc) {
</I>&gt;<i> +				asm (&quot;dcbf 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
</I>&gt;<i> +			}
</I>&gt;<i> +		} else {
</I>&gt;<i> +			for (p = start; p &lt; endp; p += cachelineinc) {
</I>&gt;<i> +				asm (&quot;dcbst 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
</I>&gt;<i> +			}
</I>
The changes to icache flush should be a separate patch. As I said already
on irc, though, unless there is a bug in the code, changes to it should
be done only if there are hard numbers showing that the change is a
performance benefit in some real-world case. The code as it is written
fixed some random crashes happening a few years ago, so there must be
very strong reasons to change it even a single instruction.

&gt;<i> 2009-01-24  Steven Munroe  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">munroesj at us.ibm.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> This patch is contributed under the terms of the MIT/X11 license
</I>&gt;<i> 
</I>&gt;<i> 	* mini-ppc.c (emit_nptl_tls): Define for __mono_ppc64__ and
</I>&gt;<i> 	!__mono_ppc64__.
</I>&gt;<i> 	(emit_tls_access): Update to use emit_nptl_tls.
</I>&gt;<i> 	(mono_arch_emit_prolog): Use G_STRUCT_OFFSET(MonoJitTlsData, lmf)
</I>&gt;<i> 	only if !TLS_MODE_NPTL.
</I>&gt;<i> 	(setup_tls_access)[__linux__ &amp; _CS_GNU_LIBPTHREAD_VERSION]: 
</I>&gt;<i> 	Use confstr to determine pthread implementation for TLS.
</I>&gt;<i> 	Use mono_domain_get_tls_offset() to set monodomain_key.
</I>&gt;<i> 	Use mono_get_lmf_addr_tls_offset() to set lmf_pthread_key.
</I>&gt;<i> 	Use mono_thread_get_tls_offset() to set monothread_key.
</I>&gt;<i> 	* mini-ppc.h (MONO_ARCH_HAVE_TLS_GET): Defined.
</I>&gt;<i> 	(MONO_ARCH_ENABLE_MONITOR_IL_FASTPATH): Likewise.
</I>&gt;<i> 	(PPC_THREAD_PTR_REG): Likewise.
</I>&gt;<i> 
</I>&gt;<i> 	* mono-compiler.h: Define MONO_TLS_FAST and
</I>&gt;<i> 	MONO_THREAD_VAR_OFFSET.
</I>&gt;<i> 
</I>&gt;<i> diff -urN mono-svn64-opt/mono/mono/mini/mini-ppc.c mono-svn64-tls/mono/mono/mini/mini-ppc.c
</I>&gt;<i> --- mono-svn64-opt/mono/mono/mini/mini-ppc.c	2009-01-25 16:24:57.000000000 -0600
</I>&gt;<i> +++ mono-svn64-tls/mono/mono/mini/mini-ppc.c	2009-01-25 16:40:28.000000000 -0600
</I>&gt;<i> @@ -92,9 +92,36 @@
</I>&gt;<i>  		if ((dreg) != ppc_r3) ppc_mr ((code), ppc_r3, ppc_r11);	\
</I>&gt;<i>  	} while (0);
</I>&gt;<i>  
</I>&gt;<i> +#ifdef __mono_ppc64__
</I>&gt;<i> +#define emit_nptl_tls(code,dreg,key) do { \
</I>&gt;<i> +		int off1 = key; \
</I>&gt;<i> +		int off2 = key &gt;&gt; 15; \
</I>&gt;<i> +		if ((off2 == 0) || (off2 == -1)) { \
</I>&gt;<i> +			ppc_load_reg ((code), (dreg), off1, ppc_r13);	\
</I>&gt;<i> +		} else { \
</I>&gt;<i> +			int off3 = (off2 + 1) &gt; 1; \
</I>&gt;<i> +			ppc_addis ((code), ppc_r11, ppc_r13, off3); \
</I>&gt;<i> +			ppc_load_reg ((code), (dreg), off1, ppc_r11);	\
</I>&gt;<i> +		} \
</I>&gt;<i> +	} while (0);
</I>&gt;<i> +#else
</I>&gt;<i> +#define emit_nptl_tls(code,dreg,key) do { \
</I>&gt;<i> +		int off1 = key; \
</I>&gt;<i> +		int off2 = key &gt;&gt; 15; \
</I>&gt;<i> +		if ((off2 == 0) || (off2 == -1)) { \
</I>&gt;<i> +			ppc_load_reg ((code), (dreg), off1, ppc_r2);	\
</I>&gt;<i> +		} else { \
</I>&gt;<i> +			int off3 = (off2 + 1) &gt; 1; \
</I>&gt;<i> +			ppc_addis ((code), ppc_r11, ppc_r2, off3); \
</I>&gt;<i> +			ppc_load_reg ((code), (dreg), off1, ppc_r11);	\
</I>&gt;<i> +		} \
</I>&gt;<i> +	} while (0);
</I>&gt;<i> +#endif
</I>
If I didn't miss something, the only difference between the two macros
is the register, so you should unify them and use the PPC_THREAD_PTR_REG
you introduce below.
Please incorporate also Mark's changes and suggestions (I didn't check
if he made changes to your code besides splitting it up).

Thanks, nice work!

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better
</PRE>















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030645.html">[Mono-dev] [PATCH] Enable TLS for PPC32/64
</A></li>
	<LI>Next message: <A HREF="030669.html">[Mono-dev] [PATCH] Enable TLS for PPC32/64
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30666">[ date ]</a>
              <a href="thread.html#30666">[ thread ]</a>
              <a href="subject.html#30666">[ subject ]</a>
              <a href="author.html#30666">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
