<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] Implement internal Encodings	usingunified	code base
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Implement%20internal%20Encodings%0A%09usingunified%09code%20base&In-Reply-To=001001c88b46%245433c670%249b6e26c3%40kornelpal.hu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027241.html">
   <LINK REL="Next"  HREF="027249.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] Implement internal Encodings	usingunified	code base</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Implement%20internal%20Encodings%0A%09usingunified%09code%20base&In-Reply-To=001001c88b46%245433c670%249b6e26c3%40kornelpal.hu"
       TITLE="[Mono-dev] [PATCH] Implement internal Encodings	usingunified	code base">lupus at ximian.com
       </A><BR>
    <I>Fri Mar 21 13:38:18 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027241.html">[Mono-dev] [PATCH] Implement internal Encodings usingunified	code base
</A></li>
        <LI>Next message: <A HREF="027249.html">[Mono-dev] [PATCH] Implement internal	Encodingsusingunified	code base
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27248">[ date ]</a>
              <a href="thread.html#27248">[ thread ]</a>
              <a href="subject.html#27248">[ subject ]</a>
              <a href="author.html#27248">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/21/08 Korn&#233;l P&#225;l wrote:
&gt;<i> &gt;From: &quot;Paolo Molaro&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>&gt;
</I>&gt;<i> &gt;Sure, the existing unsafe methods are perfectly fine, there is no need
</I>&gt;<i> &gt;to add more virtual unsafe methods (this is about 2.0). In 1.1 the
</I>&gt;<i> &gt;unsafe methods would simply become internal.
</I>&gt;<i> 
</I>&gt;<i> This is unfortunately unture because we cannot call the public unsafe 
</I>&gt;<i> methods because it would result in the problems described in bug 363713. To 
</I>&gt;<i> fix bug 363713 a private (actually internal) unsafe implementation is 
</I>&gt;<i> required.
</I>
This patch fixes the GetByteCount() issue described in the bug:

Index: System.Text/Encoding.cs
===================================================================
--- System.Text/Encoding.cs	(revision 98527)
+++ System.Text/Encoding.cs	(working copy)
@@ -1150,7 +1150,7 @@
 		for (int p = 0; p &lt; count; p++)
 			c [p] = chars [p];
 
-		return GetByteCount (c);
+		return GetByteCount (c, 0, count);
 	}
 
 	[CLSCompliantAttribute(false)]

For the case of GetByteCount (), the GetByteCount (char[],int,int)
overload is the only one that needs to be implemented by a subclass.
Efficient implementations can implement the unsafe variant and that will
avoid the array creation. The MS people likely did this to not break
compatibility and allow non-unsafe derived classes of Encoding.
All our internal implementations can override the unsafe variant.
If there is another issue related to GetByteCount() I'd like to know
otherwise we can continue and examine the other buggy cases.

&gt;<i> Also note that by having private implementations code of Encoding 
</I>&gt;<i> and Encoder/Decoder methods can be shared as well by passing state 
</I>&gt;<i> information to these four methods (and passing zero or initial state when 
</I>&gt;<i> called from the stateless Encoding).
</I>
Sure, this is a separate issue about the implementation of the unsafe
variants and there is no difference related to your design in it.
It is likely that the implementation for most complex encodings should
be into the encoder classes. We'd have to write a few tests to make sure
if it is a requirement.

&gt;<i> To fix bug 363713 we have to take slower code paths (the same that MS.NET
</I>&gt;<i> uses) for some methods that will result in buffer copy operations. This bug
</I>&gt;<i> only affects inherited encodings (but there are a lot of inheritable
</I>&gt;<i> encoding classes). This is why I introduced the IsInternal property;
</I>&gt;<i> instances of internal classes can take faster code paths, while instances of
</I>&gt;<i> inherited classes will take MS compatible (slower) code paths. I decided to
</I>
I have no objections to a mechanism like IsInternal.

&gt;<i> implement this code path redirection in Encoding.cs and call the four
</I>&gt;<i> internal virtual (in fact internally must-implement) unsafe methods. This
</I>&gt;<i> way the source code of inherited encoding classes will have a clean look
</I>&gt;<i> because only four methods has to be implemented the other ones will only
</I>&gt;<i> call the ...Internal implementations in Encoding.cs that does all the work.
</I>
Well, the issue is that in this case &quot;all the work&quot; is basically
argument checking + a call to the different virtual unsafe method.
Argument checking I already showed that having static methods to share
the code has the same property of removing duplication and the advantage
of making visible what is exactly checked at the point where the data is
entering the unsafe user code -&gt; trusted runtime code boundary.
And when you have implemented the checks in common static methods, the
new unsafe virtual calls have basically no need to exist and they become
both a runtime burden and an additional issue when auditing the code.

&gt;<i> Because of fallbacks the actual required byte cound depends on the fallback 
</I>&gt;<i> buffer as well. Also note that UnicodeEncoding in MS.NET 2.0 has support for 
</I>&gt;<i> surrogates and can detect invalid surrogate sequences that means that the 
</I>&gt;<i> fallback buffer will be used to replace invalid input data. If you don't 
</I>&gt;<i> have a single implementation for GetByteCount you will have to duplicate 
</I>&gt;<i> code for strings, char arrays and char pointers as well. So having a single 
</I>
I never proposed having duplicated code for those cases, quite the
opposite, so this whole argument of yours is moot.

&gt;<i> Your proposed solution (that would be just as much change in the
</I>&gt;<i> infrastructure) is to use static implementation for these four methods in
</I>&gt;<i> contrast to virtual methods.
</I>&gt;<i> This would need more code in individual encoding classes:
</I>&gt;<i> - Argument checking (can be implemented using static methods in Encoding.cs)
</I>
I don't see how my proposal to have common static methods to do argument
checking amounts to code duplication.

&gt;<i> - IsInternal checks: not much code but can easily go out of sync (some 
</I>&gt;<i> methods require it while others not because the method is overridden in all 
</I>&gt;<i> internal Encoding classes)
</I>
Not an issue as you say.

&gt;<i> - calling MS compatible slow implementation (could be a static method in 
</I>&gt;<i> Encoding.cs)
</I>
Not an issue. The slow code path can go into separate common methods,
but this so so trivial that it may not even be worth it.

&gt;<i> - Array-to-pointer conversions has to be done in each encoding class 
</I>&gt;<i> (because of calling static internal implementations)
</I>
No issue here as well.

&gt;<i> Your proposed design avoids the four internal virtual unsafe methods but 
</I>&gt;<i> treads the gain for the above mentioned extra code. Your desing probably has 
</I>&gt;<i> some performance benefits, but there will be a lot of redundant code (in 
</I>&gt;<i> nearly each method of each encoding class). This code will look similar (or 
</I>&gt;<i> the same) in source code but because of calling different static methods in 
</I>&gt;<i> each class the compiled code will be different so the code has to be copied. 
</I>&gt;<i> That means that if someone only modifies a single encoding class (by fixing 
</I>&gt;<i> a bug) the others will go out of sync.
</I>
See above, there is no code duplication except trivial calls to helper
static methods. When you analyze the memory cost you need to have an
idea of how much each different solution costs in terms of bytes.
The calls is my proposal about to the generated code that performs the
call, say 20 bytes for a method with 3 arguments. The additional virtual
unsafe method itself would be 50 bytes just in additional metadata
and virtual table costs. So the amounts are small, but they are
definitely not a benefit of your design.

&gt;<i> Sure, both designs fix bug 363713 but as a conclusion I believe that my 
</I>&gt;<i> proposed desing will result in code that is much easier to maintain. So I 
</I>&gt;<i> would not trade it for yours unless you have some serious reason(s) not to 
</I>&gt;<i> use it.
</I>
I already explained the reasons: the unnecessary complexity of additional
virtual unsafe methods.

&gt;<i> Fixing bug 363713 requires infrastructural changes because the current call 
</I>&gt;<i> sequence causes the bug. In a lot of cases (see the test attached to the 
</I>&gt;<i> bug) we cannot call the right public methods for other public methods 
</I>&gt;<i> because MS.NET uses different code paths. For methods expected not to call 
</I>&gt;<i> public methods we either have to have a private implementation that is 
</I>&gt;<i> called by public methods or copy the same implementation to each public 
</I>&gt;<i> method. For method that take slower code paths we have to use a technique 
</I>&gt;<i> like the IsInternal property if we want to provide better performance. I 
</I>&gt;<i> consider these changes being infrastructural because all of the Encodings 
</I>&gt;<i> have to be modified similarly.
</I>
See my patch above for the fix to the GetByteCount case.
The other cases should be very similar. On top of the fixes we can then
implement the proper IsInternal-based optimizations.

&gt;<i> duplicated code. For example in ASCII and Latin-1 encodings. Applying the 
</I>&gt;<i> desing pattern you suggest would result in an infrastructural change as well 
</I>&gt;<i> but the implementation would be distributed and copied across source files 
</I>&gt;<i> while mine would be centralized to Encoding.cs.
</I>
See above where your points about non-existent duplication in my
proposal are rebutted.
Everything your proposal does can be implemented with static methods
instead of virtual unsafe methods. Static methods may not be the cool
new thing of the day, but they are more efficient and allow us to
immediately check where potentialy ostile data is manipulated.

&gt;<i> I am open to modifications of my proposed desing but as I see your proposed 
</I>&gt;<i> desing would introduce a lot of code duplication while there still would be 
</I>&gt;<i> unsafe methods and a lot of unsafe code paths, and these code paths would be 
</I>&gt;<i> copied in each encoding that would require to maintain each encoding 
</I>&gt;<i> separatedly. With my desing there would be only four methods with unsafe 
</I>&gt;<i> code per encoding.
</I>
See above, there is no relevant code duplication in my proposal.
The difference is basically the following, for, say, GetByteCount.
Your proposal:
	encoding-specific impl:
		call virtual common implementation
	virtual common implementation:
		argument checks + basic manipulation
		call virtual specific implementation

My proposal:
	encoding-specific impl:
		call common static argcheck + basic manipulation method
		call static/instance specific implementation (or even inline)
	common static code:
		argument checks + basic manipulation

So the only high-level difference is that my version avoids doing
unnecessary virtual calls and that potentially the code can be inline
exactly where it is used without hard to follow flows (important both
for performance and for security checks).

&gt;<i> Some fact sheets I have created in 2006 about Encoding methods of MS.NET. 
</I>&gt;<i> This is based on the actual implementation of MS.NET (using a test like the 
</I>&gt;<i> one in bug 363713):
</I>[...]

Thanks, this is useful in developing individual test cases for the
bugs we have in our implementation.
I suggest writing individual test cases that exploit the current bugs in
a format suitable for adding to our test suite.
Once we have individual test cases we can reason better about the way to
fix them. And once we are bug-free we can look at implementing the
IsInternal checks to speedup things.
Thanks!

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027241.html">[Mono-dev] [PATCH] Implement internal Encodings usingunified	code base
</A></li>
	<LI>Next message: <A HREF="027249.html">[Mono-dev] [PATCH] Implement internal	Encodingsusingunified	code base
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27248">[ date ]</a>
              <a href="thread.html#27248">[ thread ]</a>
              <a href="subject.html#27248">[ subject ]</a>
              <a href="author.html#27248">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
