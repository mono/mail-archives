<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] Implement internal Encodings using	unified	code base
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Implement%20internal%20Encodings%20using%0A%09unified%09code%20base&In-Reply-To=002701c88a97%244c79e1d0%248c6e26c3%40kornelpal.hu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027235.html">
   <LINK REL="Next"  HREF="027241.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] Implement internal Encodings using	unified	code base</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Implement%20internal%20Encodings%20using%0A%09unified%09code%20base&In-Reply-To=002701c88a97%244c79e1d0%248c6e26c3%40kornelpal.hu"
       TITLE="[Mono-dev] [PATCH] Implement internal Encodings using	unified	code base">lupus at ximian.com
       </A><BR>
    <I>Thu Mar 20 11:59:18 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027235.html">[Mono-dev] [PATCH] Implement internal Encodings using unified	code base
</A></li>
        <LI>Next message: <A HREF="027241.html">[Mono-dev] [PATCH] Implement internal Encodings usingunified	code base
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27238">[ date ]</a>
              <a href="thread.html#27238">[ thread ]</a>
              <a href="subject.html#27238">[ subject ]</a>
              <a href="author.html#27238">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/20/08 Korn&#233;l P&#225;l wrote:
&gt;<i> - Unsafe code is required anyway because Encoding has public unsafe methods. 
</I>&gt;<i> Handling strings and character arrays in a single function requires unsafe 
</I>&gt;<i> code as well. Using a single implementation avoids accidental differences 
</I>&gt;<i> between string, array and pointer based public methods.
</I>
Sure, the existing unsafe methods are perfectly fine, there is no need
to add more virtual unsafe methods (this is about 2.0). In 1.1 the
unsafe methods would simply become internal.

&gt;<i> - All argument checks are done in the abstract Encoding.cs and encoding 
</I>&gt;<i> implementations only have to provide the actual implementation. I believe 
</I>&gt;<i> that this is more secure than using different checks is each encoding 
</I>&gt;<i> implementation because they can easily go out of sync.
</I>
Non-argument as the complex checks in my proposal would go into common code in
static methods.

&gt;<i> - Argument validation could be moved to static methods in Encoding.cs that 
</I>&gt;<i> could result in better security (by not exposing unchecked unsafe code) but 
</I>&gt;<i> Microsoft implementation has bad desingn. There are a lot of unnecessary 
</I>&gt;<i> buffer copy operations (mostly related to string &lt;-&gt; char[] conversion). To 
</I>&gt;<i> fix <A HREF="https://bugzilla.novell.com/show_bug.cgi?id=363713">https://bugzilla.novell.com/show_bug.cgi?id=363713</A> while avoiding 
</I>&gt;<i> unecessary buffer copy operations there has to be some internal virtual 
</I>&gt;<i> methods with a check like in IsInternal property.
</I>
I don't see any need for a different infrastructure to fix that bug,
it's simply a bug in our implementation. In 2.0 all the GetByteCount ()
overloads must call the unsafe overload to do the work. There is no need
for additional virtual methods, because the method is there already.
Look at UTF8Encoding for GetByteCount(): it does already mostly the right
thing (it calls the internal implementation directly instead of going
through the virtual unsafe method, trivially fixable).

&gt;<i> - After a lot of brainstorming I think that having these four virtual unsafe 
</I>&gt;<i> methods provides the solution. (GetStringImpl is required in .NET 1.x only 
</I>&gt;<i> because a bug in MS implementation.) Only single implementation per method 
</I>&gt;<i> per encoding is required, argument checks are shared between encodings, and 
</I>
Ok, let's see the different cases.
GetByteCount() can be implemented this way without infrastructure
changes. GetCharCount() looks like the same. Same with GetChars ().
And I see nothing in the GetBytes() interface that would prevent it.
This is all with the assumption that the 363713 bug report suggests that
all the overloads are expected to call the unsafe virtual variant for
the actual implementation in the end (though it is likely that, for
example, GetBytes(char[]) would call GetBytes(char[],int,int), this
doesn't change the conclusion).
Is this assumption not correct?
So please make a concrete example that would require the different
infrastructure as I don't see the need (though you're definitely right
that our Encoding classes need fixes).

&gt;<i> Encoding.cs can call faster code paths than MS.NET does without overriding 
</I>&gt;<i> methods not overridden in MS.NET.
</I>
Concrete examples where this would apply, please.

&gt;<i> - Also note that I have plans to integrate Encoders/Decoders to this 
</I>&gt;<i> infrastructure by adding an Encoder/Decoder parameter at the end of the 
</I>&gt;<i> argument list of these four ...Impl methods that will let us use 
</I>&gt;<i> Encoder/Decoder as a state store rather than having actual code 
</I>&gt;<i> implementation.
</I>
Please describe why we'd need this.

&gt;<i> These goals could only be achieved without these four virtual unsafe methods 
</I>&gt;<i> by adding some more internal virtual (not unsafe) methods and having a lot 
</I>&gt;<i> of duplicate code. This would be much more difficult to maintain so I 
</I>
I don't see where the duplicate code would come from.

&gt;<i> Currently our implementations has weak fallback support. For example 
</I>&gt;<i> UnicodeEncoding has none while MS.NET has.
</I>&gt;<i> Eventually we will have to say goodby to count * 2 because that is not 
</I>&gt;<i> compatible with fallbacks.
</I>&gt;<i> .NET 1.x has no fallback support so there could be some performance gain by 
</I>&gt;<i> avoiding GetByteCountInternal but I think having a centralized 
</I>&gt;<i> implementation is worth to have little performance loss on .NET 1.x because 
</I>&gt;<i> people will eventually use later versions instead.
</I>
Let's talk with a concrete example and assume that for
UnicodeEncoding.GetByteCount() we need to do something more complicated
than count * 2. What is the advantage of doing it in a separate function
instead of in the actual method?

&gt;<i> This is the only simple bug fix:
</I>&gt;<i> &gt;&gt; - if (charCount &lt; 0 || charIndex + charCount &gt; s.Length)
</I>&gt;<i> &gt;&gt; + if (charCount &lt; 0 || charIndex &gt; (s.Length - charCount))
</I>&gt;<i> 
</I>&gt;<i> If you approve it, I'll commit it.
</I>
Sure, this bugfix shuld be committed, both in trunk and in the 1.9
branch. Thanks.

&gt;<i> I tried to defend the infrastructure proposed by me. I see that the one 
</I>&gt;<i> proposed by you is cleaner but I think that it does not address all the 
</I>&gt;<i> issuse that mine does and extending it to address all the issues would 
</I>
Please make a concrete example of a bug that requires an infrastructure
change. 363713 I have already shown that is simply a bug in our
implementation and it doesn't require a new infrastructure.

&gt;<i> result in a lot of extra code. I believe that having four internal virtual 
</I>&gt;<i> unsafe methods is not a big problem. If it is a big issue sorry for wasting 
</I>&gt;<i> time but I didn't get your reasons against them.
</I>
With more unsafe code and unsafe code codepaths the effort required to
review the code for security issues increases. It's as simple as that.
Then of course is the issue that if we don't really need them, we
shouldn't make the code more complex by using them, even if they were
non-unsafe.
If a valid case is presented where we might need them, we will
reconsider.
Thanks.

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027235.html">[Mono-dev] [PATCH] Implement internal Encodings using unified	code base
</A></li>
	<LI>Next message: <A HREF="027241.html">[Mono-dev] [PATCH] Implement internal Encodings usingunified	code base
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27238">[ date ]</a>
              <a href="thread.html#27238">[ thread ]</a>
              <a href="subject.html#27238">[ subject ]</a>
              <a href="author.html#27238">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
