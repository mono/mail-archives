<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Embedding Mono in a Virtual World
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Embedding%20Mono%20in%20a%20Virtual%20World&In-Reply-To=20050126231753.67964.qmail%40web25010.mail.ukl.yahoo.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010074.html">
   <LINK REL="Next"  HREF="010125.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Embedding Mono in a Virtual World</H1>
    <B>Tim Fries</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Embedding%20Mono%20in%20a%20Virtual%20World&In-Reply-To=20050126231753.67964.qmail%40web25010.mail.ukl.yahoo.com"
       TITLE="[Mono-devel-list] Embedding Mono in a Virtual World">timf at dicecorp.com
       </A><BR>
    <I>Thu Jan 27 09:23:12 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010074.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
        <LI>Next message: <A HREF="010125.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10103">[ date ]</a>
              <a href="thread.html#10103">[ thread ]</a>
              <a href="subject.html#10103">[ subject ]</a>
              <a href="author.html#10103">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>Yes, which means that it may require lots of changes
</I>&gt;<i>to the rest of the system to support calls from
</I>&gt;<i>multiple threads.
</I>
In my experience with Microsoft's .NET runtime in a scenario almost
identical to your virtual world plans -- the overhead of locking and
synchronization, especially with user-supplied code, is easily going to
overwhelm you.  Plus, you won't be able to scale up linearly to &quot;one thread
per task&quot; as you've already realized, because at some point you're going to
run out of address space for those thread stacks.  I haven't done any
testing on Mono yet, but I assume the same problems would present.

I ended up deciding on a more traditional single-thread approach, with a
couple twists; briefly summarized:

All I/O is, of course, asynchronous. This shouldn't be a surprise, and the
Framework makes this easy.  User input parsing can even take place on the
ThreadPool asynchronous callbacks; but is limited in order to avoid
unnecessary context switches from doing too much work in extra threads.

The work queue processing is not *strictly* single-threaded; instead, the
virtual world is divided into &quot;regions&quot; of which contained objects are not
likely to interact with objects in a different region. Each region can have
its own work thread, or as I've found more performant: regions and threads
can be m/n (with the number of threads limited by the number of physical
processors in the machine), with a task running regularly to migrate the
regions around to keep the load spread evenly across the available CPUs.
Any time an &quot;inter-region&quot; task needs to be performed, which should be
relatively rare, the appropriate threads (more accurately, the regions
within their owner threads) can synchronize long enough for that to happen.

Certain types of common inter-region tasks, such as chat, can be special
cased to avoid having to synchronize across threads.

The threads, and the regions within them, cooperatively multitask; for the
scalability reasons already described -- and because preemptive multitasking
is incredibly expensive.

Making this all work with user-supplied code is a hurdle I haven't had to
overcome, myself; but it *is* a problem that MUDs have already explored
rather exhaustively.  My initial instinct would be to go along the
interpreted scripts model; with maybe some perf counters to JIT commonly
used scripts into DynamicMethods.  The tricky part is keeping their run
times short enough to not gum up the cooperative environment without having
to thrust that problem onto the authors of the user scripts; but
interpreting/compiling as a state machine that you can enter and exit at
will would probably solve that problem well enough.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010074.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
	<LI>Next message: <A HREF="010125.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10103">[ date ]</a>
              <a href="thread.html#10103">[ thread ]</a>
              <a href="subject.html#10103">[ subject ]</a>
              <a href="author.html#10103">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
