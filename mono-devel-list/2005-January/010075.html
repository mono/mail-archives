<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Alias analysis
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Alias%20analysis&In-Reply-To=1106781351.4237.161.camel%40matrix">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010072.html">
   <LINK REL="Next"  HREF="010076.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Alias analysis</H1>
    <B>Zoltan Varga</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Alias%20analysis&In-Reply-To=1106781351.4237.161.camel%40matrix"
       TITLE="[Mono-devel-list] Alias analysis">vargaz at gmail.com
       </A><BR>
    <I>Wed Jan 26 18:44:54 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010072.html">[Mono-devel-list] Alias analysis
</A></li>
        <LI>Next message: <A HREF="010076.html">[Mono-devel-list] Alias analysis
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10075">[ date ]</a>
              <a href="thread.html#10075">[ thread ]</a>
              <a href="subject.html#10075">[ subject ]</a>
              <a href="author.html#10075">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>                                               Hi,

 Wouldn't be easier to just disable optimizations on variables whose address is
taken ? It usually happens in unsafe code, and with taking addresses
of valuetypes.

                                                            Zoltan

On Thu, 27 Jan 2005 00:15:51 +0100, Massimiliano Mantione
&lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">massi at ximian.com</A>&gt; wrote:
&gt;<i> 
</I>&gt;<i> This is a possible plan to implement alias analysis.
</I>&gt;<i> Those interested can read, and comment on it so that I have
</I>&gt;<i> some feedback...
</I>&gt;<i> 
</I>&gt;<i> Purpose of alias analysis: understand the operations performed
</I>&gt;<i> on local variables, so that SSA can be enabled, and liveness
</I>&gt;<i> information will be not only &quot;conservatively correct&quot;, but as
</I>&gt;<i> accurate as possible.
</I>&gt;<i> This means we are (in this step) only interested in the aliasing
</I>&gt;<i> of local variables, and not of storage locations external to the
</I>&gt;<i> current method (analyzing aliasing of those locations could lead
</I>&gt;<i> to the elimination of redundant operations on them, or other
</I>&gt;<i> optimizations, but this is not the goal now).
</I>&gt;<i> 
</I>&gt;<i> So, what should alias analysis do?
</I>&gt;<i> 
</I>&gt;<i> [1] Detect when local variables are aliased.
</I>&gt;<i> Basically, this means watching when the address of a variable
</I>&gt;<i> is taken.
</I>&gt;<i> 
</I>&gt;<i> [2] Understand where the address that has been taken goes.
</I>&gt;<i> This is important for the effectiveness of the next step:
</I>&gt;<i> 
</I>&gt;<i> [3] Whenever an address is used, if the address is actually an
</I>&gt;<i> alias, this means that the aliased variable is used. The use
</I>&gt;<i> could be a load or a store (according to how the pointer is
</I>&gt;<i> used, for reading or writing).
</I>&gt;<i> The key point is that we should be accurate.
</I>&gt;<i> Being conservative, one could say that whenever a pointer is
</I>&gt;<i> used, all variables are potentially used. This would produce
</I>&gt;<i> correct code, but would not help much in optimizing it.
</I>&gt;<i> Instead, we should reason in the following way: every time a
</I>&gt;<i> pointer is used, only the variables potentially aliased by that
</I>&gt;<i> pointer are potentially used.
</I>&gt;<i> In fact, a variable whose address is never taken is not aliased.
</I>&gt;<i> And also a variable whose address *has* been taken is obviously
</I>&gt;<i> unaffected by operations on *other* addresses: this is why step
</I>&gt;<i> two is important, so that step three will be more accurate.
</I>&gt;<i> 
</I>&gt;<i> Now, how should this be implemented?
</I>&gt;<i> This raises another question, which in fact is more important:
</I>&gt;<i> how would the JIT code make use of the aliasing data?
</I>&gt;<i> 
</I>&gt;<i> Before answering this, let's look at what the code does now.
</I>&gt;<i> 
</I>&gt;<i> Currently there is an enum that states which kind of operation
</I>&gt;<i> is performed on local variables, and every instruction is flagged
</I>&gt;<i> with one of the values (MONO_SSA_NOP is the default):
</I>&gt;<i> 
</I>&gt;<i> /* values for MonoInst.ssa_op */
</I>&gt;<i> enum {
</I>&gt;<i> MONO_SSA_NOP,
</I>&gt;<i> MONO_SSA_LOAD,
</I>&gt;<i> MONO_SSA_STORE,
</I>&gt;<i> MONO_SSA_MAYBE_LOAD,
</I>&gt;<i> MONO_SSA_MAYBE_STORE
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> The LOAD and STORE values are widely used, often (always?) with
</I>&gt;<i> the assumption that &quot;inst-&gt;inst_i0-&gt;inst_c0&quot; is a valid variable
</I>&gt;<i> index. IMHO, when reworking these flags, it would be wise not to
</I>&gt;<i> break this assumption. Basically, these values flag pure &quot;read&quot;
</I>&gt;<i> and &quot;write&quot; accesses to local variables or arguments.
</I>&gt;<i> 
</I>&gt;<i> The MONO_SSA_NOP value, as said, is the default.
</I>&gt;<i> It is used explicitly only when making a MonoInst a NOP inside
</I>&gt;<i> the ssa code, and it is tested only in one place, in local copy
</I>&gt;<i> propagation. The test is the following: if a MonoInst is a store,
</I>&gt;<i> but it is flagged MONO_SSA_NOP, assume that we do not know where
</I>&gt;<i> it is stored, so invalidate the state of *all* local variables
</I>&gt;<i> (because all of them have now a potentially unknown value).
</I>&gt;<i> 
</I>&gt;<i> The MONO_SSA_MAYBE_LOAD value has a misleading name.
</I>&gt;<i> It is set in each MonoInst that takes the address of a local (or
</I>&gt;<i> argument). Note that this operation is not really a load, the
</I>&gt;<i> variable value is not used and the variable itself is unchanged.
</I>&gt;<i> And, after such an instruction, the address could in fact be used
</I>&gt;<i> to write to the variable instead of reading (this is why the name
</I>&gt;<i> is misleading IMHO).
</I>&gt;<i> This value is tested for in a couple of places in SSA construction
</I>&gt;<i> and destruction code, simply because it points to a use of the
</I>&gt;<i> variable (taking the address is a form of use after all), and SSA
</I>&gt;<i> must rename all variables in all places where they are used.
</I>&gt;<i> It is also used in SSA based copyprop, but IMHO in the wrong way
</I>&gt;<i> (and SSA based copyprop seems broken anyway).
</I>&gt;<i> What is important about MONO_SSA_MAYBE_LOAD is that it already
</I>&gt;<i> flags *all* the places where an alias is created (because taking
</I>&gt;<i> the address of a variable means creating an alias).
</I>&gt;<i> 
</I>&gt;<i> The MONO_SSA_MAYBE_STORE value is never used, so it can disappear.
</I>&gt;<i> 
</I>&gt;<i> OK, so this is the current state of the code, where do we go from
</I>&gt;<i> here?
</I>&gt;<i> 
</I>&gt;<i> The idea is to work on the MonoInst.ssa_op values we have seen,
</I>&gt;<i> making them represent also operations that happen through aliases
</I>&gt;<i> so that we can properly track them.
</I>&gt;<i> 
</I>&gt;<i> Since MonoInst.ssa_op has three bits, we could use them fully in
</I>&gt;<i> the following way:
</I>&gt;<i> 
</I>&gt;<i> /* values for MonoInst.ssa_op */
</I>&gt;<i> enum {
</I>&gt;<i> MONO_SSA_NOP = 0,
</I>&gt;<i> MONO_SSA_ADDRESS_TAKEN = 1,
</I>&gt;<i> MONO_SSA_LOAD = 2,
</I>&gt;<i> MONO_SSA_STORE = 4,
</I>&gt;<i> MONO_SSA_INDIRECT_LOAD = MONO_SSA_LOAD|MONO_SSA_ADDRESS_TAKEN,
</I>&gt;<i> MONO_SSA_INDIRECT_STORE = MONO_SSA_STORE|MONO_SSA_ADDRESS_TAKEN,
</I>&gt;<i> MONO_SSA_INDIRECT_LOAD_STORE =
</I>&gt;<i> MONO_SSA_LOAD|MONO_SSA_STORE|MONO_SSA_ADDRESS_TAKEN
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> In the existing code, all occurrences of MONO_SSA_LOAD and
</I>&gt;<i> MONO_SSA_STORE would work unchanged, and MONO_SSA_MAYBE_LOAD would
</I>&gt;<i> be replaced by MONO_SSA_ADDRESS_TAKEN.
</I>&gt;<i> Also MONO_SSA_NOP would work as before, with the exception of the
</I>&gt;<i> single place where it is tested... how this would change will be
</I>&gt;<i> clear afterwords.
</I>&gt;<i> 
</I>&gt;<i> The new &quot;*_INDIRECT_*&quot; values would mark operations performed
</I>&gt;<i> through aliases, which basically belong to one of the following
</I>&gt;<i> categories:
</I>&gt;<i> - CEE_STIND_* instructions that store to something that could be
</I>&gt;<i>   an alias (instead of storing to a local or arg), these should
</I>&gt;<i>   be marked MONO_SSA_INDIRECT_STORE.
</I>&gt;<i> - CEE_LDIND_* instructions that read from something that could be
</I>&gt;<i>   an alias (instead of reading from a local or arg), these should
</I>&gt;<i>   be marked MONO_SSA_INDIRECT_LOAD.
</I>&gt;<i> - CALL instructions that have at least one parameter that is passed
</I>&gt;<i>   by reference (it could either point to a local, or be an alias),
</I>&gt;<i>   these should be marked MONO_SSA_INDIRECT_LOAD_STORE.
</I>&gt;<i> 
</I>&gt;<i> The real issue, then is: which values are aliases?
</I>&gt;<i> This is why step [2] above is so important: every value that is
</I>&gt;<i> the address of a local variable is an alias, so we should track
</I>&gt;<i> all MONO_SSA_ADDRESS_TAKEN instructions, and see where they put
</I>&gt;<i> the address.
</I>&gt;<i> 
</I>&gt;<i> There are not many alternatives for this, the possible places
</I>&gt;<i> where an alias can end up are the following:
</I>&gt;<i> 
</I>&gt;<i> [a] An OP_OUTARG instruction (so the alias is passed to a called
</I>&gt;<i> method, which can use it for reading, writing, or both).
</I>&gt;<i> [b] A local variable (or an argument).
</I>&gt;<i> [c] A field of an object. The field could be static, and the object
</I>&gt;<i> could be a value type (instead of a class instance), but in this
</I>&gt;<i> first analysis we will ignore the differences between these cases.
</I>&gt;<i> 
</I>&gt;<i> Note that in verifiable code only [a] is allowed (see Partition I,
</I>&gt;<i> section 12.4.1.5.2 of the ECMA standard for CIL).
</I>&gt;<i> This is very important, because we expect the vast majority of
</I>&gt;<i> the code we will run to be verifiable, and case [a] is very easy
</I>&gt;<i> to handle.
</I>&gt;<i> In contrast, case [b] is harder (we have full control of local
</I>&gt;<i> variables, but tracking them is in any case nontrivial), and case
</I>&gt;<i> [c] is likely to be unsolvable.
</I>&gt;<i> 
</I>&gt;<i> So, an initial approach would be to handle case [a] accurately,
</I>&gt;<i> and cases [b] and [c] conservatively.
</I>&gt;<i> 
</I>&gt;<i> - Case [a] (verifiable code)
</I>&gt;<i> 
</I>&gt;<i> To handle case [a], we must examine the MonoCallInst, and follow
</I>&gt;<i> in parallel the arguments (eventually skipping the &quot;this&quot;) and
</I>&gt;<i> their parameter declarations in the signature.
</I>&gt;<i> For each &quot;byref&quot; parameter, we should see if we can determine
</I>&gt;<i> which local or argument has been passed. For each of them, the
</I>&gt;<i> combined &quot;LOAD+STORE&quot; operation applies.
</I>&gt;<i> If what is passed to one byref parameter is not just the address
</I>&gt;<i> of a local, we have some trouble... basically this method call
</I>&gt;<i> behaves like an operation of kind [b] or [c] (we must handle it
</I>&gt;<i> conservatively).
</I>&gt;<i> 
</I>&gt;<i> - Cases [b] and [c]
</I>&gt;<i> 
</I>&gt;<i> Basically, when flagging instructions as MONO_SSA_ADDRESS_TAKEN,
</I>&gt;<i> if the generated alias is of kind [b] or [c] we should also flag
</I>&gt;<i> the local (or argument), stating that its address has been taken.
</I>&gt;<i> Since local variables have a MonoInst as well, and since their
</I>&gt;<i> MonoInst.ssa_op makes no sense (they are not real operations), it
</I>&gt;<i> could make sense to flag them exactly setting that field to
</I>&gt;<i> MONO_SSA_ADDRESS_TAKEN :-)
</I>&gt;<i> Then, we just know that each instruction flagged as
</I>&gt;<i> MONO_SSA_INDIRECT_LOAD or MONO_SSA_INDIRECT_STORE that operates
</I>&gt;<i> on an unknown value will potentially affect all variables flagged
</I>&gt;<i> as MONO_SSA_ADDRESS_TAKEN that have a type which is compatible
</I>&gt;<i> with the type of the operation.
</I>&gt;<i> Maybe it would be worth adding a flag to MonoCompile that is true
</I>&gt;<i> if at leas one variable is potentially aliased, this would allow
</I>&gt;<i> to avoid scanning the whole array of variables to find the ones
</I>&gt;<i> that are potentially aliased.
</I>&gt;<i> Or maybe we could keep one list of MonoInst for each primitive
</I>&gt;<i> type, and put in there the aliased variables... but these are just
</I>&gt;<i> implementation details.
</I>&gt;<i> 
</I>&gt;<i> OK, this seems all...
</I>&gt;<i> If you made it that far... congratulations ;-)
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010072.html">[Mono-devel-list] Alias analysis
</A></li>
	<LI>Next message: <A HREF="010076.html">[Mono-devel-list] Alias analysis
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10075">[ date ]</a>
              <a href="thread.html#10075">[ thread ]</a>
              <a href="subject.html#10075">[ subject ]</a>
              <a href="author.html#10075">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
