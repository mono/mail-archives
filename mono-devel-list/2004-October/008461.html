<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] AMD64, PInvoke + Native Exceptions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20AMD64%2C%20PInvoke%20%2B%20Native%20Exceptions&In-Reply-To=25477.1098645624%40www52.gmx.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008455.html">
   <LINK REL="Next"  HREF="008462.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] AMD64, PInvoke + Native Exceptions</H1>
    <B>Zoltan Varga</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20AMD64%2C%20PInvoke%20%2B%20Native%20Exceptions&In-Reply-To=25477.1098645624%40www52.gmx.net"
       TITLE="[Mono-devel-list] AMD64, PInvoke + Native Exceptions">vargaz at gmail.com
       </A><BR>
    <I>Sun Oct 24 17:25:39 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="008455.html">[Mono-devel-list] AMD64, PInvoke + Native Exceptions
</A></li>
        <LI>Next message: <A HREF="008462.html">[Mono-devel-list] AMD64, PInvoke + Native Exceptions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8461">[ date ]</a>
              <a href="thread.html#8461">[ thread ]</a>
              <a href="subject.html#8461">[ subject ]</a>
              <a href="author.html#8461">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>                                       Hi,

On Sun, 24 Oct 2004 21:20:24 +0200 (MEST), Willibald Krenn
&lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">willibald.krenn at gmx.at</A>&gt; wrote:
&gt;<i> 
</I>&gt;<i> J&#243; napot!
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; exceptions thrown in e.g. a g++ compiled .so,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This will not be implemented in the near future.
</I>&gt;<i> 
</I>&gt;<i> I see. But it should be possible to catch those exceptions by implementing a
</I>&gt;<i> custom personality routine for exception handling - if I'm not mistaken.
</I>&gt;<i> Will look into that.
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; BTW: LMF seems pretty senseless on AMD64, or have I missed something..
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; LMF is used to return to the last managed method in case the unmanaged
</I>&gt;<i> &gt; method
</I>&gt;<i> &gt; threw an exception. This is used when the internal runtime code throws
</I>&gt;<i> &gt; an .NET exception,
</I>&gt;<i> &gt; for example. It is also used when there is a segmentation fault in
</I>&gt;<i> &gt; unmanaged code.
</I>&gt;<i> 
</I>&gt;<i> Just to see, if I understand that correctly: In case I can come up with a
</I>&gt;<i> custom personality routine, LMF should not be needed on AMD64 because
</I>&gt;<i>  -&gt; c runtime will search the DWARF info for a catch handler
</I>&gt;<i>  -&gt; it will find the custom personality routine from the stub that
</I>&gt;<i> encapsulated the call to the internal runtime code / native code.
</I>&gt;<i>  -&gt; the personality routine will do mono style exception handling..
</I>&gt;<i>     (As mono uses plain stack-frames and has all the meta information at
</I>&gt;<i> hands the exception handling should be doable by the personality routine..)
</I>&gt;<i> 
</I>&gt;<i> BTW: Throwing a C++ exception in native code just aborts mono because the C
</I>&gt;<i> runtime can not find any valid catch handler. So how should Mono be ever
</I>&gt;<i> able to use the LMF in case of an exception thrown in native code? (I guess,
</I>&gt;<i> I'm missing something here: Signals are another story for sure.)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; Another question that arose has to do with OP_CHECK_THIS: Am I right
</I>&gt;<i> &gt; that
</I>&gt;<i> &gt; &gt; this is not fully implemented yet?
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; OP_CHECK_THIS works by loading the value pointed to by the given this
</I>&gt;<i> &gt; variable. If
</I>&gt;<i> &gt; the variable is null, a SIGSEGV is sent to the thread, which will be
</I>&gt;<i> &gt; converted to a
</I>&gt;<i> &gt; NullReferenceException by the exception handling code.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Well, so how does that work in the following case:
</I>&gt;<i> [... Next, the code will call the constructor of the
</I>&gt;<i> System.NotImplementedException  class, thereby passing the 'this' (self)
</I>&gt;<i> pointer as argument in %rdi.
</I>&gt;<i>  Interestingly enough, the pointer is compared to NULL, but no conditional
</I>&gt;<i>  jump can be found before the callq opcode.
</I>&gt;<i>  Essentially, the cmp opcode comes from an OP_CHECK_THIS(?) mono
</I>&gt;<i> intermediate instruction and should issue an exception when 'this' is found
</I>&gt;<i> to be NULL. The check, however, does not seem to be completely implemented
</I>&gt;<i> yet.]
</I>
The SIGSEGV will be sent by the processor itself when %r15 is 0, and the
runtime will convert this to a NullReferenceException.

&gt;<i>   35:   49 8b ff                mov    %r15,%rdi
</I>&gt;<i>   38:   49 83 3f 00             cmpq   $0x0,(%r15)
</I>&gt;<i>   3c:   49 bb 30 6b f0 96 2a    mov    $0x2a96f06b30,%r11
</I>&gt;<i>   43:   00 00 00
</I>&gt;<i>   46:   49 ff d3                callq  *%r11
</I>&gt;<i> 
</I>&gt;<i> By looking at the code above, it's pretty obvious that mono issues calls on
</I>&gt;<i> AMD64 by a &quot;mov IMM8, reg\n  call *reg&quot; opcode combination. You've a fixme
</I>&gt;<i> in the codegen header at this position IIRC: Does that mean you want to use
</I>&gt;<i> the IP-relative imm4 version, if the call target is in reach?
</I>&gt;<i> 
</I>
This could be optimized but this is not done yet. Mostly because originally
methods make calls to trampolines which call back into the JIT to compile the
method, then the call site is patched to call the newly compiled method. If the
trampoline can be called with a 32 bit offset, but the newly compiled method
can't, then the call site can't be patched which could lead to perf problems.

                Zoltan

&gt;<i> 
</I>&gt;<i> &gt; &gt; And the last one: When stepping through code with ddd, I often get SIG35
</I>&gt;<i> &gt; &gt; exceptions.. Anything I can do about that?
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; Some signals are used by the runtime/libgc for suspending/aborting
</I>&gt;<i> &gt; threads etc. These
</I>&gt;<i> &gt; can be ignored during debugging by the gdb 'handle' command.
</I>&gt;<i> 
</I>&gt;<i> Ah, ok. Thanks!
</I>&gt;<i> I already disabled PWR and another signal, but was not aware that there are
</I>&gt;<i> more signals to ignore.
</I>&gt;<i> 
</I>&gt;<i> Willi
</I>&gt;<i> 
</I>&gt;<i> --
</I>&gt;<i> Geschenkt: 3 Monate GMX ProMail + 3 Ausgaben der TV Movie mit DVD
</I>&gt;<i> ++++ Jetzt anmelden und testen <A HREF="http://www.gmx.net/de/go/mail">http://www.gmx.net/de/go/mail</A> ++++
</I>&gt;<i> 
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008455.html">[Mono-devel-list] AMD64, PInvoke + Native Exceptions
</A></li>
	<LI>Next message: <A HREF="008462.html">[Mono-devel-list] AMD64, PInvoke + Native Exceptions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8461">[ date ]</a>
              <a href="thread.html#8461">[ thread ]</a>
              <a href="subject.html#8461">[ subject ]</a>
              <a href="author.html#8461">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
