<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Overcoming PInvoke limitations in e.g. Mono.Posix
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Overcoming%20PInvoke%20limitations%20in%20e.g.%20Mono.Posix&In-Reply-To=1097198188.1127.65.camel%40melchior">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008273.html">
   <LINK REL="Next"  HREF="008277.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Overcoming PInvoke limitations in e.g. Mono.Posix</H1>
    <B>Alan Jenkins</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Overcoming%20PInvoke%20limitations%20in%20e.g.%20Mono.Posix&In-Reply-To=1097198188.1127.65.camel%40melchior"
       TITLE="[Mono-devel-list] Overcoming PInvoke limitations in e.g. Mono.Posix">sourcejedi at phonecoop.coop
       </A><BR>
    <I>Fri Oct  8 03:24:06 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="008273.html">[Mono-devel-list] Overcoming PInvoke limitations in e.g.	Mono.Posix
</A></li>
        <LI>Next message: <A HREF="008277.html">[Mono-devel-list] Overcoming PInvoke limitations in e.g.	Mono.Posix
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8274">[ date ]</a>
              <a href="thread.html#8274">[ thread ]</a>
              <a href="subject.html#8274">[ subject ]</a>
              <a href="author.html#8274">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Friday 08 October 2004 02:16, Jonathan Pryor wrote:
&gt;<i> On Thu, 2004-10-07 at 14:45, Alan Jenkins wrote:
</I>&gt;<i> &gt; PInvoke is convenient, but it relies on binary compatability.
</I>&gt;<i>
</I>&gt;<i> It should be noted that *any* interop layer will rely on binary
</I>&gt;<i> compatibility, *unless* you distribute only as source code (and require
</I>&gt;<i> that your users have a compiler available at install- or run-time for
</I>&gt;<i> source compatibility).
</I>Yup.  The *nix way.  Binary compatability is virtually nonexistant, even on 
diferent versions of the same platform, so you write a powerful as possible 
source level interop layer (like autoconf, which this would have to play well 
with), and distribute binaries for given platforms.  This is no different to 
writing C interop layers by hand - they also need to be compiled on the same 
platform as they run.  I admit this doesn't sound much like &quot;write once, run 
anywhere&quot;, but in order for that to happen you have to have a &quot;write many 
times&quot; somewhere.  If its possible to write a program to do that, then why 
not?

&gt;<i> &gt; E.g. much
</I>&gt;<i> &gt; Posix specifications define symbolic constants for C programs which do
</I>&gt;<i> &gt; not have a fixed value across all platforms.
</I>&gt;<i>
</I>&gt;<i> Mono.Posix has a code generator to handle this.  See make-map.cs.  It
</I>&gt;<i> generates C code which maps between the managed value and the unmanaged
</I>&gt;<i> value.
</I>&gt;<i>
</I>&gt;<i> &gt; The layout of structures also
</I>&gt;<i> &gt; varies between platforms.  PInvoke is sufficient for the microsoft world,
</I>&gt;<i> &gt; but Mono really needs more.  As far as I know the current Mono.Posix
</I>&gt;<i> &gt; implementation doesn't have a complete solution - although I don't know
</I>&gt;<i> &gt; anything about the SDL or GTK bindings.
</I>&gt;<i>
</I>&gt;<i> Define &quot;complete solution.&quot;  It has *a* solution, which offers a
</I>&gt;<i> framework for future expansion.  Granted, *all* of POSIX isn't wrapped
</I>&gt;<i> yet, but it's fairly straightforward to add more support.
</I>&gt;<i>
</I>&gt;<i> &gt; I propose a Mono.InteropServices namespace, with tools to write structs
</I>&gt;<i> &gt; and enums in C# from annotated (with attributes) C# code, with C code as
</I>&gt;<i> &gt; an intermediate step.
</I>&gt;<i>
</I>&gt;<i> Eh?  So...  You write C# code, which contains attributes, which you run
</I>&gt;<i> through a code generator, which generates more C# code?  Have I got that
</I>&gt;<i> right?
</I>&gt;<i>
</I>&gt;<i> Actually, Mono.Posix OEE's make-map.cs does that, mostly because I was
</I>&gt;<i> too lazy to keep the C# and C enum mapping declarations in sync.  Then I
</I>&gt;<i> broke this support by adding non-enum methods to PosixConvert (for
</I>&gt;<i> DateTime conversions).  Partial classes would be good for this, though.
</I>&gt;<i>
</I>&gt;<i> &gt; The C code would be relatively portable, but the generated
</I>&gt;<i> &gt; C# code would be platform specific.
</I>&gt;<i>
</I>&gt;<i> BAD idea.  Horribly bad.  Platform-specific C# code requires compiling
</I>&gt;<i> it for all target platforms, which implies that you need a C# compiler
</I>&gt;<i> to be present on those platforms.  This can make bootstrapping
</I>&gt;<i> difficult.
</I>
Surely thats not a problem so long as the C# compiler doesn't require the code 
in question?  And if the code generation tools are only provided with Mono, 
(as opposed to with all .NET runtime environments), then the compiler must 
not depend on them in order to maintian portability anywhere?
I confess I have zero practical knowledge on bootstrapping difficulties.

&gt;<i> Worse is coping with standardization, or lack thereof.  Consider the
</I>&gt;<i> dirent structure (see readdir(3)).  The man page says that only d_name
</I>&gt;<i> can be assumed, and d_ino is an XSI extension.  Meanwhile linux also has
</I>&gt;<i> members d_off, d_reclen, and d_type.  AIX has others.
</I>
Three solutions.  One: generate only the fields which can be assumed to be 
there (bail out if they aren't).  Two: generate all fields, and have programs 
check explicitly (through reflection) that they exist.  Three: generate 
properties for the fields which don't exist which throw exceptions, and 
include programatic ways to check which fields are really available.

&gt;<i> Even worse, is that there's *actually* a dirent and a dirent64
</I>&gt;<i> structure.  The primary difference being the types of the d_ino and
</I>&gt;<i> d_off members (32 vs 64 bits).  Ditto for the stat and flock
</I>&gt;<i> structures.  I'm sure there are others (I just haven't hit them yet).
</I>
Um... use your &quot;typedef&quot; method for the fields.  I thought this was always 
necessary anyway - sizes of C integers are not fixed, just given minimums 
(char=8, int=16, long=32, long long=64).

&gt;<i> What this *really* means is that, for platform-specific C# code, on some
</I>&gt;<i> platforms your structure members will be of type `long', and on others
</I>&gt;<i> it will be `int'.  How you can have platform-independent code which uses
</I>&gt;<i> this platform specific code is beyond me.
</I>
Again, this is something you have to cope with already e.g. &quot;size_t&quot; varies 
with the platform.  I think this can be made to work with private member 
variables and public operators (casting and arithmetic)

&gt;<i> I'm sure I'm biased, but the Mono.Posix approach is much more sane.
</I>
Good.  Bias is allowable, prejudgement not (to paraphrase Frank Herbert).  If 
I can present a solution which appeals to you, then other people in the same 
situation are likely to find it useful.

&gt;<i> Keep the C# side fixed, and vary the C side to map arguments to the
</I>&gt;<i> corresponding C# structures.
</I>
For simple situations, you can do without native glue code using my model.

&gt;<i> &lt;snip/&gt;
</I>&gt;<i>
</I>&gt;<i> &gt; Stop me if this is already being worked on - I know its obvious, it's
</I>&gt;<i> &gt; just nobody seems to have got around to it yet!  Unless I've missed
</I>&gt;<i> &gt; something.
</I>&gt;<i>
</I>&gt;<i> You're missing the details. :-)
</I>&gt;<i>
</I>&gt;<i> Which I've been hitting.  I had been thinking that there has to be a
</I>&gt;<i> better way with Mono.Posix, but I was convincing myself that it was a
</I>&gt;<i> terribly difficult problem.  Because it is.
</I>
Yup.  Everything would be much easier if it wasn't for all those pesky 
details :).

&gt;<i> However, your discussion has brought up some ideas for future
</I>&gt;<i> implementation.  Basically:
</I>&gt;<i>
</I>&gt;<i>   - Keep all declarations in C#
</I>&gt;<i>   - Tag everything that needs to have mapping C code generated
</I>&gt;<i>     (similar to the [Map] attribute used by make-map.cs)
</I>&gt;<i>   - Tag methods that have 64-bit &quot;overloads&quot; as well.
</I>&gt;<i>
</I>&gt;<i> A possible example:
</I>&gt;<i>
</I>&gt;<i>  [Map, Native (&quot;stat&quot;), Has64 (&quot;stat64&quot;)]
</I>&gt;<i>  public struct Stat {
</I>&gt;<i>   [Native (&quot;dev_t&quot;)] public ulong st_dev;
</I>&gt;<i>   [Native (&quot;ino_t&quot;)] public ulong st_ino;
</I>&gt;<i>   [Native (&quot;mode_t&quot;)] public uint st_mode;
</I>&gt;<i>   // ...
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>  public static class Syscall {
</I>&gt;<i>   [Map, Has64 (&quot;stat64&quot;),
</I>&gt;<i>   DllImport (&quot;HelperLib&quot;, SetLastError=true,
</I>&gt;<i>    EntryPoint=&quot;my_stat&quot;)]
</I>&gt;<i>   public static extern int stat (string file_name,
</I>&gt;<i>    out Stat buf);
</I>&gt;<i>   // ...
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> Your code generator could then pick out all the elements marked with
</I>&gt;<i> [Map], generate appropriate C intermediate structures, and generate
</I>&gt;<i> appropriate function definitions for the intermediate layers.
</I>
I was hoping I could get away without mangling the function calls, just the 
data structures which they use.

&gt;<i> The Has64 attribute is needed so that the code generator knows what the
</I>&gt;<i> appropriate 64-bit function to call, if necessary.  Alas, you can't just
</I>&gt;<i> append &quot;64&quot; to the function name, as readdir_r(P) is readdir64_r().
</I>&gt;<i> Sigh.
</I>
But I guess its necessary in order to change the imported function

&gt;<i> Of course, that's a lot of attributes to keep track of and ensure is
</I>&gt;<i> consistent.  Better the code generator than me, I guess...
</I>&gt;<i>
</I>&gt;<i> It won't be easy.  I wish you luck. :-)
</I>&gt;<i>
</I>&gt;<i>  - Jon
</I>&gt;<i>
</I>Thanks for a reality check :).  I think you may have misinterpreted me on some 
points: I really think that native glue code can be avoided.  I 
underestimated the job; looks like function calls need to be handled as well 
as data types, at least for Mono.Posix.  I think I'm best off expressing my 
ideas through code right now, so I'll try to make it as clear &amp; well 
commented as possible.  Til then!

Alan

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008273.html">[Mono-devel-list] Overcoming PInvoke limitations in e.g.	Mono.Posix
</A></li>
	<LI>Next message: <A HREF="008277.html">[Mono-devel-list] Overcoming PInvoke limitations in e.g.	Mono.Posix
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8274">[ date ]</a>
              <a href="thread.html#8274">[ thread ]</a>
              <a href="subject.html#8274">[ subject ]</a>
              <a href="author.html#8274">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
