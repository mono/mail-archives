<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Cross application domain call optimization, Take 2.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Cross%20application%20domain%20call%20optimization%2C%20Take%202.&In-Reply-To=1098795269.6193.8.camel%40portatil.aticatac">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008513.html">
   <LINK REL="Next"  HREF="008552.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Cross application domain call optimization, Take 2.</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Cross%20application%20domain%20call%20optimization%2C%20Take%202.&In-Reply-To=1098795269.6193.8.camel%40portatil.aticatac"
       TITLE="[Mono-devel-list] Cross application domain call optimization, Take 2.">lupus at ximian.com
       </A><BR>
    <I>Thu Oct 28 11:59:11 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="008513.html">[Mono-devel-list] Cross application domain call optimization, Take 2.
</A></li>
        <LI>Next message: <A HREF="008552.html">[Mono-devel-list] Cross application domain call optimization,	Take 2.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8551">[ date ]</a>
              <a href="thread.html#8551">[ thread ]</a>
              <a href="subject.html#8551">[ subject ]</a>
              <a href="author.html#8551">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/26/04 Lluis Sanchez wrote:
&gt;<i> +				do {
</I>&gt;<i> +					try {
</I>&gt;<i> +						MemoryStream ms = new MemoryStream ();
</I>&gt;<i> +						_serializationFormatter.Serialize (ms, ex);
</I>&gt;<i> +						return ms.ToArray ();
</I>&gt;<i> +					}
</I>&gt;<i> +					catch (Exception e) {
</I>&gt;<i> +						if (e is ThreadAbortException) {
</I>&gt;<i> +							Thread.ResetAbort ();
</I>&gt;<i> +							retry = 5;
</I>&gt;<i> +							ex = e;
</I>&gt;<i> +						}
</I>&gt;<i> +						else if (retry == 2) {
</I>
the catch clause should be in the same line as the '}'. Same for the else
clause here and in other places below.

&gt;<i> --- mono/metadata/marshal.c	20 Oct 2004 01:01:56 -0000	1.210
</I>&gt;<i> +++ mono/metadata/marshal.c	26 Oct 2004 11:09:39 -0000
</I>[...]
&gt;<i> +	if (!module_initialized) {
</I>&gt;<i> +		klass = mono_class_from_name (mono_defaults.corlib, &quot;System.Runtime.Remoting&quot;, &quot;RemotingServices&quot;);
</I>&gt;<i> +		method_rs_serialize = mono_class_get_method_from_name (klass, &quot;SerializeCallData&quot;, -1);
</I>&gt;<i> +		method_rs_deserialize = mono_class_get_method_from_name (klass, &quot;DeserializeCallData&quot;, -1);
</I>&gt;<i> +		method_rs_serialize_exc = mono_class_get_method_from_name (klass, &quot;SerializeExceptionData&quot;, -1);
</I>&gt;<i> +	
</I>&gt;<i> +		klass = mono_class_from_name (mono_defaults.corlib, &quot;System.Runtime.Remoting.Proxies&quot;, &quot;RealProxy&quot;);
</I>&gt;<i> +		method_rs_appdomain_target = mono_class_get_method_from_name (klass, &quot;GetAppDomainTarget&quot;, -1);
</I>&gt;<i> +	
</I>&gt;<i> +		klass = mono_class_from_name (mono_defaults.corlib, &quot;System&quot;, &quot;Exception&quot;);
</I>&gt;<i> +		method_exc_fixexc = mono_class_get_method_from_name (klass, &quot;FixRemotingException&quot;, -1);
</I>&gt;<i> +	
</I>&gt;<i> +		klass = mono_class_from_name (mono_defaults.corlib, &quot;System.Threading&quot;, &quot;Thread&quot;);
</I>&gt;<i> +		method_reset_datastore = mono_class_get_method_from_name (klass, &quot;ResetDataStoreStatus&quot;, -1);
</I>&gt;<i> +		method_restore_datastore = mono_class_get_method_from_name (klass, &quot;RestoreDataStoreStatus&quot;, -1);
</I>&gt;<i> +		method_get_context = mono_class_get_method_from_name (klass, &quot;get_CurrentContext&quot;, -1);
</I>&gt;<i> +	
</I>&gt;<i> +		klass = mono_class_from_name (mono_defaults.corlib, &quot;System&quot;, &quot;AppDomain&quot;);
</I>
Exception, Thread and AppDomain are a&#242;lreay in mono_Defaults, no need to look them up again.

&gt;<i> +static inline MonoMethod*
</I>&gt;<i> +mono_marshal_remoting_find_in_cache (MonoMethod *method, int wrapper_type)
</I>&gt;<i> +{
</I>&gt;<i> +	MonoMethod *res = NULL;
</I>&gt;<i> +	MonoRemotingMethods *wrps;
</I>&gt;<i> +
</I>&gt;<i> +	EnterCriticalSection (&amp;marshal_mutex);
</I>&gt;<i> +	wrps = (MonoRemotingMethods*) g_hash_table_lookup (method-&gt;klass-&gt;image-&gt;remoting_invoke_cache, method);
</I>
There is no need for the cast, it makes for cleaner code without it, IMHO.

&gt;<i> +	if (*res == NULL) {
</I>&gt;<i> +		/* This does not acquire any locks */
</I>&gt;<i> +		*res = mono_mb_create_method (mb, sig, max_stack);
</I>&gt;<i> +		mono_g_hash_table_insert (wrapper_hash, *res, key);
</I>&gt;<i> +	}
</I>&gt;<i> +	else
</I>&gt;<i> +		/* Somebody created it before us */
</I>&gt;<i> +		;
</I>
Please remove these three lines.

&gt;<i> +/* mono_get_xdomain_marshal_type()
</I>&gt;<i> + * Returns the kind of marshalling that a type needs for cross domain calls.
</I>&gt;<i> + */
</I>&gt;<i> +static MonoXDomainMarshalType
</I>&gt;<i> +mono_get_xdomain_marshal_type (MonoType *t)
</I>&gt;<i> +{
</I>&gt;<i> +	switch (t-&gt;type) {
</I>
Can you ever get a byref type here?

&gt;<i> +/* mono_marshal_emit_load_domain_method ()
</I>&gt;<i> + * Loads into the stack a pointer to the code of the provided method for
</I>&gt;<i> + * the current domain.
</I>&gt;<i> + */
</I>&gt;<i> +static void
</I>&gt;<i> +mono_marshal_emit_load_domain_method (MonoMethodBuilder *mb, MonoMethod *method)
</I>&gt;<i> +{
</I>&gt;<i> +	static MonoMethodSignature *csig = NULL;
</I>&gt;<i> +	if (!csig) {
</I>&gt;<i> +		csig = mono_metadata_signature_alloc (mono_defaults.corlib, 1);
</I>&gt;<i> +		csig-&gt;params [0] = &amp;mono_defaults.int_class-&gt;byval_arg;
</I>&gt;<i> +		csig-&gt;ret = &amp;mono_defaults.int_class-&gt;byval_arg;
</I>&gt;<i> +		csig-&gt;pinvoke = 1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	mono_mb_emit_byte (mb, MONO_CUSTOM_PREFIX);
</I>&gt;<i> +	mono_mb_emit_byte (mb, CEE_MONO_LDPTR);
</I>&gt;<i> +	mono_mb_emit_i4 (mb, mono_mb_add_data (mb, method));
</I>&gt;<i> +	mono_mb_emit_native_call (mb, csig, mono_compile_method);
</I>
Why do you need to compile the method? It seems unusual. Maybe you can just use LDFTN?

&gt;<i> +	for (i = 0; i &lt; sig-&gt;param_count; i++)
</I>&gt;<i> +		if (marshal_types [i] != MONO_MARSHAL_SERIALIZE)
</I>&gt;<i> +			csig-&gt;params [j++] = sig-&gt;params [i];
</I>
This copies also the attributes of the params: is that the intended behaviour?
Also, if the statement inside the loop is not a one-liner, it's better to use braces:

	for (...) {
		if (cond)
			stmt;
	}

&gt;<i> +	/* Main exception catch */
</I>&gt;<i> +	main_clause-&gt;flags = MONO_EXCEPTION_CLAUSE_FILTER;
</I>&gt;<i> +	main_clause-&gt;try_len = mb-&gt;pos - main_clause-&gt;try_offset;
</I>&gt;<i> +	main_clause-&gt;token_or_filter = mb-&gt;pos;
</I>&gt;<i> +	/* filter code */
</I>&gt;<i> +	mono_mb_emit_byte (mb, CEE_POP);
</I>&gt;<i> +	mono_mb_emit_byte (mb, CEE_LDC_I4_1);
</I>&gt;<i> +	mono_mb_emit_byte (mb, CEE_PREFIX1);
</I>&gt;<i> +	mono_mb_emit_byte (mb, CEE_ENDFILTER);
</I>
Why do you need a filter that always catches the exception?

&gt;<i> +void
</I>&gt;<i> +mono_array_full_copy (MonoArray *src, MonoArray *dest)
</I>&gt;<i> +{
</I>&gt;<i> +	int size, i;
</I>&gt;<i> +	MonoClass *klass = src-&gt;obj.vtable-&gt;klass;
</I>&gt;<i> +
</I>&gt;<i> +	MONO_ARCH_SAVE_REGS;
</I>&gt;<i> +
</I>&gt;<i> +	g_assert (klass == dest-&gt;obj.vtable-&gt;klass);
</I>&gt;<i> +
</I>&gt;<i> +	if (src-&gt;bounds == NULL) {
</I>&gt;<i> +		size = mono_array_length (src);
</I>&gt;<i> +		g_assert (size == mono_array_length (dest));
</I>&gt;<i> +		size *= mono_array_element_size (klass);
</I>&gt;<i> +		memcpy (&amp;dest-&gt;vector, &amp;src-&gt;vector, size);
</I>&gt;<i> +		return;
</I>&gt;<i> +	}
</I>&gt;<i> +	
</I>&gt;<i> +	size = mono_array_element_size (klass);
</I>&gt;<i> +	for (i = 0; i &lt; klass-&gt;rank; ++i) {
</I>&gt;<i> +		g_assert (src-&gt;bounds [i].length == dest-&gt;bounds [i].length);
</I>&gt;<i> +		size *= src-&gt;bounds [i].length;
</I>&gt;<i> +	}
</I>&gt;<i> +	memcpy (&amp;dest-&gt;vector, &amp;src-&gt;vector, size);
</I>
mono_array_length (src)  should already have the total size, so the loop is
not needed and the above code for SZARRAY is fine.

Thanks!

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008513.html">[Mono-devel-list] Cross application domain call optimization, Take 2.
</A></li>
	<LI>Next message: <A HREF="008552.html">[Mono-devel-list] Cross application domain call optimization,	Take 2.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8551">[ date ]</a>
              <a href="thread.html#8551">[ thread ]</a>
              <a href="subject.html#8551">[ subject ]</a>
              <a href="author.html#8551">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
