<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] System.Data.DataSet.ReadXml reimplementation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20System.Data.DataSet.ReadXml%20reimplementation&In-Reply-To=42A46E0C.7030004%40mainsoft.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012325.html">
   <LINK REL="Next"  HREF="012641.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] System.Data.DataSet.ReadXml reimplementation</H1>
    <B>Atsushi Eno</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20System.Data.DataSet.ReadXml%20reimplementation&In-Reply-To=42A46E0C.7030004%40mainsoft.com"
       TITLE="[Mono-devel-list] System.Data.DataSet.ReadXml reimplementation">atsushi at ximian.com
       </A><BR>
    <I>Mon Jun  6 13:56:36 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="012325.html">[Mono-devel-list] System.Data.DataSet.ReadXml reimplementation
</A></li>
        <LI>Next message: <A HREF="012641.html">[Mono-devel-list] System.Data.DataSet.ReadXml reimplementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12329">[ date ]</a>
              <a href="thread.html#12329">[ thread ]</a>
              <a href="subject.html#12329">[ subject ]</a>
              <a href="author.html#12329">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Boris,

&gt;&gt;&gt;<i> Hello all
</I>&gt;&gt;&gt;<i> We're currently working on reimplementation of DataSet.ReadXml.
</I>&gt;&gt;&gt;<i> The need for this fist raised as a result of xml serialization bugs 
</I>&gt;&gt;&gt;<i> in our System.WebServices testsiute, and supported by the will to 
</I>&gt;&gt;&gt;<i> provide
</I>&gt;&gt;&gt;<i> more &quot;clean&quot; implementation.
</I>
Having clean implementation is a nice idea, yes.

&gt;&gt;&gt;<i> Attached is a diff with current svn version.
</I>&gt;&gt;&gt;<i> The current implementation deals with the task by inspecting some 
</I>&gt;&gt;&gt;<i> pieces of xml while reading it and invoking the corresponding actions 
</I>&gt;&gt;&gt;<i> (read xml, infer schema etc.) if needed. It looks that there is a 
</I>&gt;&gt;&gt;<i> collection of solutions for a lot of private cases (each eliminated 
</I>&gt;&gt;&gt;<i> by some test) threated.
</I>
Sorry but I cannot understand this line, maybe especially
&quot;private cases&quot; treated.

&gt;&gt;&gt;<i> The main idea of new implementation is to loop through the xml reader 
</I>&gt;&gt;&gt;<i> (until we're on the same depth level), collect its attributes and 
</I>&gt;&gt;&gt;<i> nodes into root of xml document, and after _all_ the data is 
</I>&gt;&gt;&gt;<i> collected - act accordingly. The diffgram and schema at first element 
</I>&gt;&gt;&gt;<i> are threated in special manner.
</I>
&gt;&gt;&gt;<i> What is your opinion about the new implementation?
</I>
Well, I don't really understand why you needed to read all the data
into XmlDocument before filling the data into DataSet. It will harm
performance so significantly, in case that it does not invoke
InferXmlSchema() internally. That complexity is not to read all
the content up into DOM unnecessarily.

Besides that idea, there seems some reorganization of switching
(if () {...} ... and switch () {...}) which looks nice to me.

&gt;&gt;&gt;<i> Once again : this is not a ready patch, so do not apply it on your 
</I>&gt;&gt;&gt;<i> working copy, but on the &quot;standalone&quot; one.
</I>
Ok...so I wonder how it makes sense but I put some comments inline:


&gt;<i> -			// FIXME: We need more decent code here, but for now
</I>&gt;<i> -			// I don't know the precise MS.NET behavior, I just
</I>&gt;<i> -			// delegate to specific read process.
</I>&gt;<i> -			switch (mode) {
</I>&gt;<i> -			case XmlReadMode.IgnoreSchema:
</I>&gt;<i> -				return ReadXmlIgnoreSchema (input, mode, true);
</I>&gt;<i> -			case XmlReadMode.ReadSchema:
</I>&gt;<i> -				return ReadXmlReadSchema (input, mode, true);
</I>&gt;<i> +			if (reader is XmlTextReader) {
</I>&gt;<i> +				((XmlTextReader) reader).WhitespaceHandling = WhitespaceHandling.None;
</I>
Why did you add that part?

&gt;<i> +			// If diffgram, then read the first element as diffgram 
</I>&gt;<i> +			if (reader.LocalName == &quot;diffgram&quot; &amp;&amp; reader.NamespaceURI == XmlConstants.DiffgrNamespace) {
</I>&gt;<i> +				switch (mode) {
</I>&gt;<i> +					case XmlReadMode.Auto:
</I>&gt;<i> +					case XmlReadMode.DiffGram:
</I>&gt;<i> +						if (DiffLoader == null)
</I>&gt;<i> +							DiffLoader = new XmlDiffLoader (this);
</I>&gt;<i> +						DiffLoader.Load (reader);
</I>&gt;<i> +						// (and leave rest of the reader as is)
</I>&gt;<i> +						return  XmlReadMode.DiffGram;
</I>&gt;<i> +					case XmlReadMode.Fragment:
</I>&gt;<i> +						reader.Skip ();
</I>&gt;<i> +						// (and continue to read)
</I>&gt;<i> +						break;
</I>&gt;<i> +					default:
</I>&gt;<i> +						reader.Skip ();
</I>&gt;<i> +						// (and leave rest of the reader as is)
</I>&gt;<i> +						return mode;
</I>
Pull one indent level down here (and every other places like that).

&gt;<i> +				if (reader.LocalName == &quot;schema&quot; &amp;&amp; reader.NamespaceURI == XmlSchema.Namespace) {
</I>&gt;<i> +					switch (mode) {
</I>&gt;<i> +						case XmlReadMode.IgnoreSchema:
</I>&gt;<i> +						case XmlReadMode.InferSchema:
</I>&gt;<i> +							reader.Skip ();
</I>&gt;<i> +							break;
</I>&gt;<i> +						
</I>&gt;<i> +						default:
</I>&gt;<i> +							ReadXmlSchema (reader);
</I>&gt;<i> +							retMode = XmlReadMode.ReadSchema;
</I>&gt;<i> +							schemaLoaded = true;
</I>&gt;<i> +							// (and leave rest of the reader as is)
</I>&gt;<i> +							break;
</I>&gt;<i> +					}
</I>
Are you sure that XML Schema inside data content is handled to
define data structure definition, while it already started filling
the data?

&gt;<i> +				if ((reader.LocalName == &quot;diffgram&quot;) &amp;&amp; (reader.NamespaceURI == XmlConstants.DiffgrNamespace)) {
</I>&gt;<i> +					if ((mode == XmlReadMode.DiffGram) || (mode == XmlReadMode.IgnoreSchema)
</I>&gt;<i> +						|| mode == XmlReadMode.Auto) {
</I>&gt;<i> +						if (DiffLoader == null)
</I>&gt;<i> +							DiffLoader = new XmlDiffLoader (this);
</I>&gt;<i> +						DiffLoader.Load (reader);
</I>&gt;<i> +						// (and leave rest of the reader as is)
</I>&gt;<i> +						retMode = XmlReadMode.DiffGram;
</I>&gt;<i> +					}
</I>&gt;<i> +					else
</I>&gt;<i> +						reader.Skip();
</I>
And the same discussion applies to diffgram.

&gt;<i> @@ -1166,7 +1118,7 @@
</I>&gt;<i>  		
</I>&gt;<i>  		protected virtual void ReadXmlSerializable (XmlReader reader)
</I>&gt;<i>  		{
</I>&gt;<i> -			ReadXml (reader);
</I>&gt;<i> +			ReadXml (reader, XmlReadMode.DiffGram);
</I>&gt;<i>  		}
</I>
Is this correct?

Atsushi Eno

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012325.html">[Mono-devel-list] System.Data.DataSet.ReadXml reimplementation
</A></li>
	<LI>Next message: <A HREF="012641.html">[Mono-devel-list] System.Data.DataSet.ReadXml reimplementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12329">[ date ]</a>
              <a href="thread.html#12329">[ thread ]</a>
              <a href="subject.html#12329">[ subject ]</a>
              <a href="author.html#12329">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
