<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Double-locking and thread safety
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Double-locking%20and%20thread%20safety&In-Reply-To=023701c57815%2490422ef0%240100a8c0%40kornelpal.hu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012892.html">
   <LINK REL="Next"  HREF="012759.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Double-locking and thread safety</H1>
    <B>Ben Maurer</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Double-locking%20and%20thread%20safety&In-Reply-To=023701c57815%2490422ef0%240100a8c0%40kornelpal.hu"
       TITLE="[Mono-devel-list] Double-locking and thread safety">bmaurer at ximian.com
       </A><BR>
    <I>Thu Jun 23 13:12:20 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="012892.html">[Mono-devel-list] [PATCH] Reworked unified Locale classes
</A></li>
        <LI>Next message: <A HREF="012759.html">[Mono-devel-list] Double-locking and thread safety
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12758">[ date ]</a>
              <a href="thread.html#12758">[ thread ]</a>
              <a href="subject.html#12758">[ subject ]</a>
              <a href="author.html#12758">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 2005-06-23 at 19:03 +0200, Korn&#233;l P&#225;l wrote:
&gt;<i> 1. Declaring &quot;a&quot; as volatile would solve the problem but it results in
</I>&gt;<i> performance loss because of memory barriers for each read.
</I>
Well, the performance loss here isn't all that bad. On an x86 machine
there is basically no loss. 

&gt;<i> 2. Removing the check outside the lock would solve the problem but it
</I>&gt;<i> results in performance loss because of memory barriers for each read.
</I>
The real problem is that the lock can result in contention which is
orders of magnitude worse than a memory barrier.

&gt;<i> I think using a lock is better than constructing a new instance because the
</I>&gt;<i> new instance would be dropped if it's already created as we want to use a
</I>&gt;<i> single instance so it's better to suspend the thread by doing a wait than
</I>&gt;<i> creating a new instance because the CPU time can be used for useful
</I>&gt;<i> operations instead of wating time.
</I>
That issue only happens in the *VERY* rare case that two threads are
contending. 

&gt;<i> <A HREF="http://blogs.msdn.com/cbrumme/archive/2003/05/17/51445.aspx:">http://blogs.msdn.com/cbrumme/archive/2003/05/17/51445.aspx:</A>
</I>&gt;<i> &quot;Realize that synchronization is expensive.  The full fence implied by
</I>&gt;<i> Interlocked.Increment can be many 100&#8217;s of cycles on modern hardware.  That
</I>&gt;<i> penalty may continue to grow, in relative terms.&quot;
</I>&gt;<i> 
</I>&gt;<i> I think this applies to Interlocked.CompareExchange as well.
</I>
But that only gets run once per program. Anyways the cost of reading a
page in from the disk to do the Locale stuff is orders of magnitude more
expensive.

&gt;<i> So I suggest to use this model instead of Interlocked.CompareExchange.
</I>&gt;<i> Furthermore I think using two Thread.MemoryBarrier() is less effective than
</I>&gt;<i> using lock and and a single Thread.MemoryBarrier() because there will be not
</I>&gt;<i> useless object creation, Thread.MemoryBarrier() allways does a full barrier
</I>&gt;<i> while lock does acrique at the begining and release at the end and
</I>&gt;<i> Interlocked.CompareExchange does barriers as well so there are more barriers
</I>&gt;<i> and thus locks in your &quot;lock-free&quot; code than in the locked code.
</I>
It depends on how commonly this code is used. The code is going to
become horrible to maintain if we have MemoryBarriers scattered around.
We should really stick to obvious locking patterns except where
performance is an issue. Now, given that this code is only used in
exceptional code paths (and in SWF -- but there, speed is measured in UI
responsiveness, and none of the solutions are slow enough to make a
difference there), the simple lock-then-check should suffice for now.

-- Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012892.html">[Mono-devel-list] [PATCH] Reworked unified Locale classes
</A></li>
	<LI>Next message: <A HREF="012759.html">[Mono-devel-list] Double-locking and thread safety
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12758">[ date ]</a>
              <a href="thread.html#12758">[ thread ]</a>
              <a href="subject.html#12758">[ subject ]</a>
              <a href="author.html#12758">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
