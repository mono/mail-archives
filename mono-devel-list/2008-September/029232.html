<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Patch: Fast virtual generic method calls
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Patch%3A%20Fast%20virtual%20generic%20method%20calls&In-Reply-To=8cca42d80809251921l2251b7ddgd19c97ba946b7d4c%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029231.html">
   <LINK REL="Next"  HREF="029227.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Patch: Fast virtual generic method calls</H1>
    <B>Mark Probst</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Patch%3A%20Fast%20virtual%20generic%20method%20calls&In-Reply-To=8cca42d80809251921l2251b7ddgd19c97ba946b7d4c%40mail.gmail.com"
       TITLE="[Mono-dev] Patch: Fast virtual generic method calls">mark.probst at gmail.com
       </A><BR>
    <I>Fri Sep 26 02:29:09 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="029231.html">[Mono-dev] Patch: Fast virtual generic method calls
</A></li>
        <LI>Next message: <A HREF="029227.html">[Mono-dev]  How to: Run tar command from c# app
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29232">[ date ]</a>
              <a href="thread.html#29232">[ thread ]</a>
              <a href="subject.html#29232">[ subject ]</a>
              <a href="author.html#29232">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Rodrigo,

&gt;<i> Makes sense, the space is already these. Does it handle dispatching of
</I>&gt;<i> interface generic methods? The code in method-to-ir.c suggests not.
</I>
No, it doesn't.  I don't think interfaces should be too hard, though.
All we need to do is to pass the fully instantiated MonoMethod* as the
key.  Not sure how this plays together with non-generic interface
methods, though.

&gt;<i> Since you have a hashtable with the expansions, what about introducing a
</I>&gt;<i> limit
</I>&gt;<i> on the number of trunks per method, this change should not be hard.
</I>
What would it buy me, though?  I'd suggest, without any hard data,
that methods with more instantiations are more heavily used, so
limiting them doesn't make much sense.  Unless we use an LRU schema
for selecting which instantiations make it into the thunk, but I think
that can easily lead to thunks which are constantly re-compiled
because the &quot;working set&quot; changes periodically.

&gt;<i> Have you thought about using something else than a MonoMethod as key?
</I>
Actually, the key is not the MonoMethod but the method_inst.

&gt;<i> Right now it's only possible to share if all instantiations are reference
</I>&gt;<i> types. I guess we
</I>&gt;<i> can determine if the method is shareable on first compilation, which is
</I>&gt;<i> before any trunk code
</I>&gt;<i> is generated.
</I>&gt;<i>
</I>&gt;<i> Given that we know this, we could store in the upper bit of the tokens used
</I>&gt;<i> for resolving the trunk
</I>&gt;<i> if they refer to a sharable instantiation. Then on trunk code, if the method
</I>&gt;<i> is sharable
</I>&gt;<i> we check this bit and avoid generating tons of trunks.
</I>
Whether the method is sharable can be determined in the thunk-table
builder, as well.  However, there's no point in doing that because
unfortunately we can't use one thunk entry for all shared
instantiations.  It's true that those instantiations share the same
native code, but on the other hand, each of them needs to be passed a
different MRGCTX.  This is currently implemented by jumping not to the
method directly but to a static RGCTX invoke wrapper for the method,
which passes the MRGCTX.

&gt;<i> But even with that we would still need to generate trunks. If we generate
</I>&gt;<i> then partially, as you suggest,
</I>&gt;<i> for each decision node, I can't think how the current scheme would allow for
</I>&gt;<i> making it balanced.
</I>
My suggestion was to build a new decision-tree every time a new item
was added, like now, with the only difference of using lots of small
code pieces to implement it instead of one big one.  I wasn't
suggesting updating the code-tree, like you would update a search
tree.

&gt;<i> I guess it would be doable if we stored the keys in an array not part of the
</I>&gt;<i> code, as sorting it would not
</I>&gt;<i> mean doing a lot of code modification, so no icache flushes unless we wanted
</I>&gt;<i> to link a new trunk block
</I>&gt;<i> in the tree and each trunk block could be a 15 entries decision tree.
</I>
I'm not sure I understand what you mean.  Could you give an example?

Thanks for the feedback!

Mark
</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029231.html">[Mono-dev] Patch: Fast virtual generic method calls
</A></li>
	<LI>Next message: <A HREF="029227.html">[Mono-dev]  How to: Run tar command from c# app
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29232">[ date ]</a>
              <a href="thread.html#29232">[ thread ]</a>
              <a href="subject.html#29232">[ subject ]</a>
              <a href="author.html#29232">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
