<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Lang Theory Question
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Lang%20Theory%20Question&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026782.html">
   <LINK REL="Next"  HREF="026786.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Lang Theory Question</H1>
    <B>Scott Peterson</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Lang%20Theory%20Question&In-Reply-To="
       TITLE="[Mono-dev] Lang Theory Question">lunchtimemama at gmail.com
       </A><BR>
    <I>Fri Feb  1 20:56:47 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="026782.html">[Mono-dev] [Mono-patches] r94530 -	trunk/mcs/class/System.Core/System.Linq.Expressions
</A></li>
        <LI>Next message: <A HREF="026786.html">[Mono-dev] Lang Theory Question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26784">[ date ]</a>
              <a href="thread.html#26784">[ thread ]</a>
              <a href="subject.html#26784">[ subject ]</a>
              <a href="author.html#26784">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'm a sucker for syntactic sugar. There is one little trick which I've
been trying and failing to do - it turns about to be impossible - but
as a language theory exercise, I thought I'd work out what would be
needed to let me do this thing.

One nice thing about nullable types is the non-standard behavior of
the assignment (=) operator. For example:

int? val = 5;
val = 6;

is shorthand for:

Nullable&lt;int&gt; val = new Nullable&lt;int&gt; (5);
val.Value = 6;

I am working with a struc similar to Nullable and I'd like to be able
to use the assignment operator in a similar way. Unfortunately, the
assignment (=) operator cannot be overloaded. The struct, SchemaEntry,
is used to store and retrieve configuration data from some backend
(gconf, the Windows registry, an XML file, &amp;c.). Here's essentially
how I currently use the struct:

SchemaEntry&lt;int&gt; entry = new SchemaEntry&lt;int&gt; (&quot;DbVersion&quot;);
int version = entry.Get ();
if (version &lt; 2) {
    MigrateDb ();
    entry.Set (2);
}

I would like to be able to do the above with this code:

SchemaEntry&lt;int&gt; entry = new SchemaEntry&lt;int&gt; (&quot;DbVersion&quot;);
int version = entry;
if (version &lt; 2) {
    MigrateDb ();
    entry = 2;
}

This is how I envision writing the code to allow me to do that:

public struct SchemaEntry&lt;T&gt;
{
    public SchemaEntry (string name)
    {
        //...
    }

    //...

    public static SchemaEntry&lt;T&gt; operator =(SchemaEntry&lt;T&gt; entry, T value)
    {
        entry.Set (value);
        return entry;
    }

    public static implicit operator T (SchemaEntry&lt;T&gt; entry)
    {
        return entry.Get ();
    }
}

This is obviously not possible because C# forbids overloading =. A
potential problem is as follows:

SchemaEntry&lt;int&gt; entry = 5;

As you can see in the outline of SchemaEntry above, there is no
parameterless constructor, so this code is clearly problematic. One
solution to treat this as:

SchemaEntry&lt;int&gt; entry.Set(5);

and throw a &quot;use of unassigned variable&quot; compiler error. If you wanted
to allow this syntax (in the way that Nullable uses this syntax), you
could allow for overloading of the &quot;new&quot; operator like so:

public static Nullable&lt;T&gt; operator new(T value)
{
    return new Nullable&lt;T&gt;(value);
}

Another problem is allowing overloading assignment between the same type:

public class Foo
{
    public static Foo operator =(Foo f1, Foo f2)
    {
        f1 = f2; // recursive fail
    }
}

I can think of a few possible solutions:
1) Require that the two parameters to the overload function be of
different types. This would still allow the safe use of generics (as
with SchemaEntry).
2) Stipulate that any use of the assignment operator inside of an
assignment operator overload function will perform a standard bitwise
copy.
3) I had other solutions, but I actually think these two cover it pretty nicely.

I prefer solution 1. I've given it a little think and no problems jump
out at me. So I post this to solicit counter cases. If you'd like to
tell me that this kind of syntax is a) confusing, b) unnecessary, c)
evil, d) all of the above, have at me, but I am more interested in
disastrous corner case in my above proposal. And if you too yearn to
save yourself precious parenthesis, feel free to chime in too!

-- 
Scott.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026782.html">[Mono-dev] [Mono-patches] r94530 -	trunk/mcs/class/System.Core/System.Linq.Expressions
</A></li>
	<LI>Next message: <A HREF="026786.html">[Mono-dev] Lang Theory Question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26784">[ date ]</a>
              <a href="thread.html#26784">[ thread ]</a>
              <a href="subject.html#26784">[ subject ]</a>
              <a href="author.html#26784">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
