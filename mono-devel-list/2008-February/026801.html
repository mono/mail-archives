<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] New code to build interface vtables
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20New%20code%20to%20build%20interface%20vtables&In-Reply-To=20080204142241.GG5889%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026800.html">
   <LINK REL="Next"  HREF="026802.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] New code to build interface vtables</H1>
    <B>Massimiliano Mantione</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20New%20code%20to%20build%20interface%20vtables&In-Reply-To=20080204142241.GG5889%40debian.org"
       TITLE="[Mono-dev] New code to build interface vtables">massi at ximian.com
       </A><BR>
    <I>Mon Feb  4 11:39:05 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="026800.html">[Mono-dev] New code to build interface vtables
</A></li>
        <LI>Next message: <A HREF="026802.html">[Mono-dev] New code to build interface vtables
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26801">[ date ]</a>
              <a href="thread.html#26801">[ thread ]</a>
              <a href="subject.html#26801">[ subject ]</a>
              <a href="author.html#26801">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Mon, 2008-02-04 at 15:22 +0100, Paolo Molaro wrote:
&gt;<i> Did you run the corlib tests, too?
</I>
I run &quot;make check&quot; in mono, which runs just about everything,
also after a full rebuild (done with the new code).

&gt;<i> &gt; +		// Check if this interface is explicitly implemented (instead of just inherited)
</I>&gt;<i> &gt; +		if (parent != NULL) {
</I>&gt;<i> &gt; +			int implemented_interfaces_index;
</I>&gt;<i> &gt; +			interface_is_explicitly_implemented_by_class = FALSE;
</I>&gt;<i> &gt; +			for (implemented_interfaces_index = 0; implemented_interfaces_index &lt; class-&gt;interface_count; implemented_interfaces_index++) {
</I>&gt;<i> &gt; +				if (ic == class-&gt;interfaces [implemented_interfaces_index]) {
</I>&gt;<i> &gt; +					interface_is_explicitly_implemented_by_class = TRUE;
</I>&gt;<i> &gt; +					break;
</I>&gt;<i> &gt; +				}
</I>&gt;<i> &gt; +			}
</I>&gt;<i> 
</I>&gt;<i> You likely need to loop other all the hierarchy here, right? Because
</I>&gt;<i> this is not restricted to just the immediate parent.
</I>
Well, in section 2, 12.2, the standard says &quot;If this class explicitly
specifies that it implements the interface (i.e., the interfaces that
appear in this class&#8217;s InterfaceImpl table, &#167;22.23)&quot;.
In the code, &quot;interface_is_explicitly_implemented_by_class&quot; wants to
flag this condition, so I only look in &quot;class-&gt;interfaces&quot;.

&gt;<i> &gt; +						/* Why do we need this? */
</I>&gt;<i> &gt; +						if (vtable [im_slot]-&gt;slot &lt; 0) {
</I>&gt;<i> &gt; +							vtable [im_slot]-&gt;slot = im_slot;
</I>&gt;<i> &gt; +						}
</I>&gt;<i> 
</I>&gt;<i> It's much simpler to use:
</I>&gt;<i> 	if (cm-&gt;slot &lt; 0)
</I>&gt;<i> 		cm-&gt;slot = im_slot;
</I>
Yes, right :-)

&gt;<i> &gt; +				// If the slot is still empty, look in all the inherited virtual methods...
</I>&gt;<i> &gt; +				if ((vtable [im_slot] == NULL) &amp;&amp; class-&gt;parent != NULL) {
</I>&gt;<i> &gt; +					MonoClass *parent = class-&gt;parent;
</I>&gt;<i> 
</I>&gt;<i> I think you need to loop over all the parents here. Please write the
</I>&gt;<i> appropriate test cases where the interface method is implemented by
</I>&gt;<i> a non-immediate parent.
</I>&gt;<i> 
</I>&gt;<i> &gt; +					// Reverse order, so that last added methods are preferred
</I>&gt;<i> &gt; +					for (cm_index = parent-&gt;vtable_size - 1; cm_index &gt;= 0; cm_index--) {
</I>&gt;<i> &gt; +						MonoMethod *cm = parent-&gt;vtable [cm_index];
</I>
Always in section 2, 12.2, the standard says &quot;If there are any virtual
methods in the interface that still have empty slots, see if there are
any public virtual methods, but not public virtual newslot methods,
available on this class (directly or inherited)...&quot;.
My interpretation is that since we are looking for virtual methods they
must be in the vtable, and &quot;parent-&gt;vtable&quot; contains all of them (also
the inherited ones), so one single loop is OK.
The methods of &quot;class&quot; are already covered by the previous loop.

Just to be on the safe side, I modified iface4.cs to test this as
well (maybe there was already a test like that somewhere, but it was
easier adding it anyway), and it passes.

&gt;<i> &gt; +				if (vtable [im_slot] == NULL) {
</I>&gt;<i> &gt; +					int index;
</I>&gt;<i> &gt; +					char *method_signature;
</I>&gt;<i> &gt; +					for (index = 0; index &lt; onum; ++index) {
</I>&gt;<i> &gt; +						g_print (&quot; at slot %d: %s (%d) overrides %s (%d)\n&quot;, im_slot, overrides [index*2+1]-&gt;name, 
</I>&gt;<i> &gt; +							 overrides [index*2+1]-&gt;slot, overrides [index*2]-&gt;name, overrides [index*2]-&gt;slot);
</I>&gt;<i> &gt; +					}
</I>&gt;<i> &gt; +					method_signature = mono_signature_get_desc (mono_method_signature (im), FALSE);
</I>&gt;<i> &gt; +					printf (&quot;no implementation for interface method %s::%s(%s) in class %s.%s\n&quot;,
</I>&gt;<i> &gt; +						mono_type_get_name (&amp;ic-&gt;byval_arg), im-&gt;name, method_signature, class-&gt;name_space, class-&gt;name);
</I>&gt;<i> &gt; +					g_free (method_signature);
</I>&gt;<i> &gt; +					for (index = 0; index &lt; class-&gt;method.count; ++index) {
</I>&gt;<i> &gt; +						MonoMethod *cm = class-&gt;methods [index];
</I>&gt;<i> &gt; +						method_signature = mono_signature_get_desc (mono_method_signature (cm), TRUE);
</I>&gt;<i> &gt; +						
</I>&gt;<i> &gt; +						printf (&quot;METHOD %s(%s)\n&quot;, cm-&gt;name, method_signature);
</I>&gt;<i> &gt; +						g_free (method_signature);
</I>&gt;<i> &gt; +					}
</I>&gt;<i> 
</I>&gt;<i> Move this debugging code to it's own external function so it doesn't
</I>&gt;<i> clutter the code.
</I>
OK.

The last question: should I leave

#define USE_NEW_INTERFACE_VTABLE_CODE 1

in place (with the old code) for a few days after committing (just in
case, for debugging), or should I commit it directly clean?

Thanks a lot!
  Massi



</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026800.html">[Mono-dev] New code to build interface vtables
</A></li>
	<LI>Next message: <A HREF="026802.html">[Mono-dev] New code to build interface vtables
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26801">[ date ]</a>
              <a href="thread.html#26801">[ thread ]</a>
              <a href="subject.html#26801">[ subject ]</a>
              <a href="author.html#26801">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
