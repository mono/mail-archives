<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [patch] Add DSA support to CryptConvert
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5Bpatch%5D%20Add%20DSA%20support%20to%20CryptConvert&In-Reply-To=463FAFA7.9060504%40tausq.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023488.html">
   <LINK REL="Next"  HREF="023503.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [patch] Add DSA support to CryptConvert</H1>
    <B>Sebastien Pouliot</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5Bpatch%5D%20Add%20DSA%20support%20to%20CryptConvert&In-Reply-To=463FAFA7.9060504%40tausq.org"
       TITLE="[Mono-dev] [patch] Add DSA support to CryptConvert">sebastien.pouliot at gmail.com
       </A><BR>
    <I>Tue May  8 16:40:36 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023488.html">[Mono-dev] [patch] Add DSA support to CryptConvert
</A></li>
        <LI>Next message: <A HREF="023503.html">[Mono-dev] [patch] Add DSA support to CryptConvert
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23502">[ date ]</a>
              <a href="thread.html#23502">[ thread ]</a>
              <a href="subject.html#23502">[ subject ]</a>
              <a href="author.html#23502">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Randolph,

On Tue, 2007-05-08 at 07:00 +0800, Randolph Chung wrote:
&gt;<i> The attached patch adds support to convert DSA blobs in
</I>&gt;<i> Mono.Security.CryptoConvert. Once this is in, minor and obvious changes
</I>&gt;<i> to System.Security.Cryptography.DSACryptoServiceProvider can be made to
</I>&gt;<i> implement the ImportCspBlob and ExportCspBlob() methods.
</I>
It looks great. There are only some minor coding style issue, maybe
editor related, that should be fixed before committing this into SVN.

<A HREF="http://www.mono-project.com/Coding_Guidelines">http://www.mono-project.com/Coding_Guidelines</A>

&gt;<i> Comments appreciated :)
</I>
Thanks for supplying unit tests with your work!

&gt;<i> randolph
</I>&gt;<i> 
</I>&gt;<i> plain text document attachment (mono-dsa.diff)
</I>&gt;<i> 2007-05-07  Randolph Chung  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">tausq at debian.org</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> 	* CryptoConvert.cs: Implement DSA blob conversion functions.
</I>&gt;<i> 
</I>&gt;<i> Index: class/Mono.Security/Mono.Security.Cryptography/CryptoConvert.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Security/Mono.Security.Cryptography/CryptoConvert.cs	(revision 76866)
</I>&gt;<i> +++ class/Mono.Security/Mono.Security.Cryptography/CryptoConvert.cs	(working copy)
</I>&gt;<i> @@ -183,6 +183,70 @@
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		static public DSA FromCapiPrivateKeyBlobDSA(byte[] blob)
</I>
missing space before (

&gt;<i> +		{
</I>&gt;<i> +			return FromCapiPrivateKeyBlobDSA(blob, 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		static public DSA FromCapiPrivateKeyBlobDSA(byte[] blob, int offset)
</I>&gt;<i> +		{
</I>&gt;<i> +			if (blob == null)
</I>&gt;<i> +				throw new ArgumentNullException(&quot;blob&quot;);
</I>&gt;<i> +			if (offset &gt;= blob.Length)
</I>&gt;<i> +				throw new ArgumentException(&quot;blob is too small.&quot;);
</I>&gt;<i> +
</I>&gt;<i> +			try
</I>&gt;<i> +			{
</I>
{ on the same line as try

&gt;<i> +				if ((blob[offset] != 0x07) ||				// PRIVATEKEYBLOB (0x07)
</I>&gt;<i> +				    (blob[offset + 1] != 0x02) ||				// Version (0x02)
</I>&gt;<i> +				    (blob[offset + 2] != 0x00) ||				// Reserved (word)
</I>&gt;<i> +				    (blob[offset + 3] != 0x00) ||
</I>&gt;<i> +				    (ToUInt32LE(blob, offset + 8) != 0x32535344))	// DWORD magic
</I>&gt;<i> +					throw new CryptographicException(&quot;Invalid blob header&quot;);
</I>&gt;<i> +
</I>&gt;<i> +				int bitlen = ToInt32LE(blob, offset + 12);
</I>&gt;<i> +				DSAParameters dsap = new DSAParameters();
</I>&gt;<i> +				int bytelen = bitlen &gt;&gt; 3;
</I>&gt;<i> +				int pos = offset + 16;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.P = new byte[bytelen];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.P, 0, bytelen);
</I>&gt;<i> +				Array.Reverse(dsap.P);
</I>&gt;<i> +				pos += bytelen;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.Q = new byte[20];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.Q, 0, 20);
</I>&gt;<i> +				Array.Reverse(dsap.Q);
</I>&gt;<i> +				pos += 20;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.G = new byte[bytelen];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.G, 0, bytelen);
</I>&gt;<i> +				Array.Reverse(dsap.G);
</I>&gt;<i> +				pos += bytelen;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.X = new byte[20];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.X, 0, 20);
</I>&gt;<i> +				Array.Reverse(dsap.X);
</I>&gt;<i> +				pos += 20;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.Counter = ToInt32LE(blob, pos);
</I>&gt;<i> +				pos += 4;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.Seed = new byte[20];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.Seed, 0, 20);
</I>&gt;<i> +				Array.Reverse(dsap.Seed);
</I>&gt;<i> +				pos += 20;
</I>&gt;<i> +
</I>&gt;<i> +				DSA dsa = (DSA)DSA.Create();
</I>&gt;<i> +				dsa.ImportParameters(dsap);
</I>&gt;<i> +				return dsa;
</I>&gt;<i> +			}
</I>&gt;<i> +			catch (Exception e)
</I>&gt;<i> +			{
</I>
{ on the same line as catch

&gt;<i> +				throw new CryptographicException(&quot;Invalid blob.&quot;, e);
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		static public byte[] ToCapiPrivateKeyBlob (RSA rsa) 
</I>&gt;<i>  		{
</I>&gt;<i>  			RSAParameters p = rsa.ExportParameters (true);
</I>&gt;<i> @@ -255,6 +319,60 @@
</I>&gt;<i>  			return blob;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		static public byte[] ToCapiPrivateKeyBlob(DSA dsa)
</I>&gt;<i> +		{
</I>&gt;<i> +			DSAParameters p = dsa.ExportParameters(true);
</I>&gt;<i> +			int keyLength = p.P.Length; // in bytes
</I>&gt;<i> +
</I>&gt;<i> +			// header + P + Q + G + X + count + seed
</I>&gt;<i> +			byte[] blob = new byte[16 + keyLength + 20 + keyLength + 20 + 4 + 20];
</I>&gt;<i> +
</I>&gt;<i> +			blob[0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
</I>&gt;<i> +			blob[1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
</I>&gt;<i> +			// [2], [3]		// RESERVED - Always 0
</I>&gt;<i> +			blob[5] = 0x22;	// ALGID
</I>&gt;<i> +			blob[8] = 0x44;	// Magic
</I>&gt;<i> +			blob[9] = 0x53;
</I>&gt;<i> +			blob[10] = 0x53;
</I>&gt;<i> +			blob[11] = 0x32;
</I>&gt;<i> +
</I>&gt;<i> +			byte[] bitlen = GetBytesLE(keyLength &lt;&lt; 3);
</I>&gt;<i> +			blob[12] = bitlen[0];
</I>&gt;<i> +			blob[13] = bitlen[1];
</I>&gt;<i> +			blob[14] = bitlen[2];
</I>&gt;<i> +			blob[15] = bitlen[3];
</I>&gt;<i> +
</I>&gt;<i> +			int pos = 16;
</I>&gt;<i> +			byte[] part = p.P;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, keyLength);
</I>&gt;<i> +			pos += keyLength;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.Q;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, 20);
</I>&gt;<i> +			pos += 20;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.G;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, keyLength);
</I>&gt;<i> +			pos += keyLength;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.X;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, 20);
</I>&gt;<i> +			pos += 20;
</I>&gt;<i> +
</I>&gt;<i> +			Buffer.BlockCopy(GetBytesLE(p.Counter), 0, blob, pos, 4);
</I>&gt;<i> +			pos += 4;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.Seed;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, 20);
</I>&gt;<i> +
</I>&gt;<i> +			return blob;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		static public RSA FromCapiPublicKeyBlob (byte[] blob) 
</I>&gt;<i>  		{
</I>&gt;<i>  			return FromCapiPublicKeyBlob (blob, 0);
</I>&gt;<i> @@ -316,6 +434,70 @@
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		static public DSA FromCapiPublicKeyBlobDSA(byte[] blob)
</I>&gt;<i> +		{
</I>&gt;<i> +			return FromCapiPublicKeyBlobDSA(blob, 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		static public DSA FromCapiPublicKeyBlobDSA(byte[] blob, int offset)
</I>&gt;<i> +		{
</I>&gt;<i> +			if (blob == null)
</I>&gt;<i> +				throw new ArgumentNullException(&quot;blob&quot;);
</I>&gt;<i> +			if (offset &gt;= blob.Length)
</I>&gt;<i> +				throw new ArgumentException(&quot;blob is too small.&quot;);
</I>&gt;<i> +
</I>&gt;<i> +			try
</I>&gt;<i> +			{
</I>&gt;<i> +				if ((blob[offset] != 0x06) ||				// PUBLICKEYBLOB (0x06)
</I>&gt;<i> +				    (blob[offset + 1] != 0x02) ||				// Version (0x02)
</I>&gt;<i> +				    (blob[offset + 2] != 0x00) ||				// Reserved (word)
</I>&gt;<i> +				    (blob[offset + 3] != 0x00) ||
</I>&gt;<i> +				    (ToUInt32LE(blob, offset + 8) != 0x31535344))	// DWORD magic
</I>&gt;<i> +					throw new CryptographicException(&quot;Invalid blob header&quot;);
</I>&gt;<i> +
</I>&gt;<i> +				int bitlen = ToInt32LE(blob, offset + 12);
</I>&gt;<i> +				DSAParameters dsap = new DSAParameters();
</I>&gt;<i> +				int bytelen = bitlen &gt;&gt; 3;
</I>&gt;<i> +				int pos = offset + 16;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.P = new byte[bytelen];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.P, 0, bytelen);
</I>&gt;<i> +				Array.Reverse(dsap.P);
</I>&gt;<i> +				pos += bytelen;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.Q = new byte[20];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.Q, 0, 20);
</I>&gt;<i> +				Array.Reverse(dsap.Q);
</I>&gt;<i> +				pos += 20;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.G = new byte[bytelen];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.G, 0, bytelen);
</I>&gt;<i> +				Array.Reverse(dsap.G);
</I>&gt;<i> +				pos += bytelen;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.Y = new byte[bytelen];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.Y, 0, bytelen);
</I>&gt;<i> +				Array.Reverse(dsap.Y);
</I>&gt;<i> +				pos += bytelen;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.Counter = ToInt32LE(blob, pos);
</I>&gt;<i> +				pos += 4;
</I>&gt;<i> +
</I>&gt;<i> +				dsap.Seed = new byte[20];
</I>&gt;<i> +				Buffer.BlockCopy(blob, pos, dsap.Seed, 0, 20);
</I>&gt;<i> +				Array.Reverse(dsap.Seed);
</I>&gt;<i> +				pos += 20;
</I>&gt;<i> +
</I>&gt;<i> +				DSA dsa = (DSA)DSA.Create();
</I>&gt;<i> +				dsa.ImportParameters(dsap);
</I>&gt;<i> +				return dsa;
</I>&gt;<i> +			}
</I>&gt;<i> +			catch (Exception e)
</I>&gt;<i> +			{
</I>&gt;<i> +				throw new CryptographicException(&quot;Invalid blob.&quot;, e);
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		static public byte[] ToCapiPublicKeyBlob (RSA rsa) 
</I>&gt;<i>  		{
</I>&gt;<i>  			RSAParameters p = rsa.ExportParameters (false);
</I>&gt;<i> @@ -352,6 +534,62 @@
</I>&gt;<i>  			return blob;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		static public byte[] ToCapiPublicKeyBlob(DSA dsa)
</I>&gt;<i> +		{
</I>&gt;<i> +			DSAParameters p = dsa.ExportParameters(false);
</I>&gt;<i> +			int keyLength = p.P.Length; // in bytes
</I>&gt;<i> +
</I>&gt;<i> +			// header + P + Q + G + Y + count + seed
</I>&gt;<i> +			byte[] blob = new byte[16 + keyLength + 20 + keyLength + keyLength + 4 + 20];
</I>&gt;<i> +
</I>&gt;<i> +			blob[0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
</I>&gt;<i> +			blob[1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
</I>&gt;<i> +			// [2], [3]		// RESERVED - Always 0
</I>&gt;<i> +			blob[5] = 0x22;	// ALGID
</I>&gt;<i> +			blob[8] = 0x44;	// Magic
</I>&gt;<i> +			blob[9] = 0x53;
</I>&gt;<i> +			blob[10] = 0x53;
</I>&gt;<i> +			blob[11] = 0x31;
</I>&gt;<i> +
</I>&gt;<i> +			byte[] bitlen = GetBytesLE(keyLength &lt;&lt; 3);
</I>&gt;<i> +			blob[12] = bitlen[0];
</I>&gt;<i> +			blob[13] = bitlen[1];
</I>&gt;<i> +			blob[14] = bitlen[2];
</I>&gt;<i> +			blob[15] = bitlen[3];
</I>&gt;<i> +
</I>&gt;<i> +			int pos = 16;
</I>&gt;<i> +			byte[] part;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.P;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, keyLength);
</I>&gt;<i> +			pos += keyLength;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.Q;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, 20);
</I>&gt;<i> +			pos += 20;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.G;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, keyLength);
</I>&gt;<i> +			pos += keyLength;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.Y;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, keyLength);
</I>&gt;<i> +			pos += keyLength;
</I>&gt;<i> +
</I>&gt;<i> +			Buffer.BlockCopy(GetBytesLE(p.Counter), 0, blob, pos, 4);
</I>&gt;<i> +			pos += 4;
</I>&gt;<i> +
</I>&gt;<i> +			part = p.Seed;
</I>&gt;<i> +			Array.Reverse(part);
</I>&gt;<i> +			Buffer.BlockCopy(part, 0, blob, pos, 20);
</I>&gt;<i> +
</I>&gt;<i> +			return blob;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		// PRIVATEKEYBLOB
</I>&gt;<i>  		// PUBLICKEYBLOB
</I>&gt;<i>  		static public RSA FromCapiKeyBlob (byte[] blob) 
</I>&gt;<i> @@ -382,6 +620,28 @@
</I>&gt;<i>  			throw new CryptographicException (&quot;Unknown blob format.&quot;);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		static public DSA FromCapiKeyBlobDSA(byte[] blob)
</I>&gt;<i> +		{
</I>&gt;<i> +			return FromCapiKeyBlobDSA(blob, 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		static public DSA FromCapiKeyBlobDSA(byte[] blob, int offset)
</I>&gt;<i> +		{
</I>&gt;<i> +			if (blob == null)
</I>&gt;<i> +				throw new ArgumentNullException(&quot;blob&quot;);
</I>&gt;<i> +			if (offset &gt;= blob.Length)
</I>&gt;<i> +				throw new ArgumentException(&quot;blob is too small.&quot;);
</I>&gt;<i> +
</I>&gt;<i> +			switch (blob[offset])
</I>&gt;<i> +			{
</I>
{ on the same line as switch

&gt;<i> +				case 0x06:
</I>
case at the same tab-level as switch

&gt;<i> +					return FromCapiPublicKeyBlobDSA(blob, offset);
</I>&gt;<i> +				case 0x07:
</I>&gt;<i> +					return FromCapiPrivateKeyBlobDSA(blob, offset);
</I>&gt;<i> +			}
</I>&gt;<i> +			throw new CryptographicException(&quot;Unknown blob format.&quot;);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		static public byte[] ToCapiKeyBlob (AsymmetricAlgorithm keypair, bool includePrivateKey) 
</I>&gt;<i>  		{
</I>&gt;<i>  			if (keypair == null)
</I>&gt;<i> @@ -390,6 +650,8 @@
</I>&gt;<i>  			// check between RSA and DSA (and potentially others like DH)
</I>&gt;<i>  			if (keypair is RSA)
</I>&gt;<i>  				return ToCapiKeyBlob ((RSA)keypair, includePrivateKey);
</I>&gt;<i> +			else if (keypair is DSA)
</I>&gt;<i> +				return ToCapiKeyBlob((DSA)keypair, includePrivateKey);
</I>&gt;<i>  			else
</I>&gt;<i>  				return null;	// TODO
</I>&gt;<i>  		}
</I>&gt;<i> @@ -405,6 +667,17 @@
</I>&gt;<i>  				return ToCapiPublicKeyBlob (rsa);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		static public byte[] ToCapiKeyBlob(DSA dsa, bool includePrivateKey)
</I>&gt;<i> +		{
</I>&gt;<i> +			if (dsa == null)
</I>&gt;<i> +				throw new ArgumentNullException(&quot;dsa&quot;);
</I>&gt;<i> +
</I>&gt;<i> +			if (includePrivateKey)
</I>&gt;<i> +				return ToCapiPrivateKeyBlob(dsa);
</I>&gt;<i> +			else
</I>&gt;<i> +				return ToCapiPublicKeyBlob(dsa);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		static public string ToHex (byte[] input) 
</I>&gt;<i>  		{
</I>&gt;<i>  			if (input == null)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 2007-05-07  Randolph Chung  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">tausq at debian.org</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> 	* CryptoConvertTest.cs: Implement DSA blob conversion tests.
</I>&gt;<i> 
</I>&gt;<i> Index: class/Mono.Security/Test/Mono.Security.Cryptography/CryptoConvertTest.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Security/Test/Mono.Security.Cryptography/CryptoConvertTest.cs	(revision 76712)
</I>&gt;<i> +++ class/Mono.Security/Test/Mono.Security.Cryptography/CryptoConvertTest.cs	(working copy)
</I>&gt;<i> @@ -264,10 +264,10 @@
</I>&gt;<i>  			byte[] publicKey = CryptoConvert.ToCapiKeyBlob (rsa, false);
</I>&gt;<i>  			AssertEquals (&quot;RSA-PublicKey&quot;, BitConverter.ToString (strongNamePublicKey, 12), BitConverter.ToString (publicKey));
</I>&gt;<i>  			
</I>&gt;<i> -			// TODO dsa (not implemented yet)
</I>&gt;<i>  			AsymmetricAlgorithm dsa = DSA.Create ();
</I>&gt;<i> -			AssertNull (&quot;DSA-KeyPair&quot;, CryptoConvert.ToCapiKeyBlob (dsa, true));
</I>&gt;<i> -			AssertNull (&quot;DSA-PublicKey&quot;, CryptoConvert.ToCapiKeyBlob (dsa, false));
</I>&gt;<i> +			dsa.FromXmlString(dsaKeyPairString);
</I>&gt;<i> +			AssertEquals(&quot;DSA-KeyPair&quot;, dsaPrivBlob, CryptoConvert.ToCapiKeyBlob(dsa, true));
</I>&gt;<i> +			AssertEquals(&quot;DSA-PublicKey&quot;, BitConverter.ToString(dsaPubBlob), BitConverter.ToString(CryptoConvert.ToCapiKeyBlob(dsa, false)));
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		[Test]
</I>&gt;<i> @@ -330,7 +330,233 @@
</I>&gt;<i>  			AssertEquals (&quot;PublicKey-2&quot;, BitConverter.ToString (strongNamePublicKey, 12), BitConverter.ToString (publicKey));
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		/* DSA key tests */
</I>&gt;<i> +		static byte[] dsaPrivBlob = { 7, 2, 0, 0, 0, 34, 0, 0, 68, 83,
</I>&gt;<i> +			83, 50, 0, 4, 0, 0, 69, 144, 99, 249,
</I>&gt;<i> +			41, 174, 97, 185, 66, 236, 179, 197, 182, 101,
</I>&gt;<i> +			146, 165, 47, 36, 234, 199, 170, 99, 97, 8,
</I>&gt;<i> +			224, 141, 189, 97, 86, 96, 240, 53, 69, 135,
</I>&gt;<i> +			123, 169, 165, 64, 50, 51, 144, 131, 158, 151,
</I>&gt;<i> +			218, 224, 159, 194, 166, 107, 132, 201, 148, 74,
</I>&gt;<i> +			38, 62, 231, 221, 157, 216, 239, 66, 248, 68,
</I>&gt;<i> +			26, 23, 123, 253, 157, 123, 65, 199, 109, 138,
</I>&gt;<i> +			231, 217, 247, 170, 81, 51, 43, 252, 66, 210,
</I>&gt;<i> +			75, 127, 68, 147, 141, 213, 174, 251, 109, 152,
</I>&gt;<i> +			244, 113, 14, 194, 198, 222, 69, 157, 146, 154,
</I>&gt;<i> +			224, 158, 46, 181, 204, 251, 10, 124, 153, 26,
</I>&gt;<i> +			239, 105, 199, 53, 43, 51, 255, 118, 213, 58,
</I>&gt;<i> +			111, 212, 166, 235, 29, 143, 53, 193, 210, 7,
</I>&gt;<i> +			78, 198, 7, 3, 219, 0, 57, 81, 179, 46,
</I>&gt;<i> +			58, 180, 61, 222, 145, 109, 165, 23, 119, 162,
</I>&gt;<i> +			91, 55, 48, 230, 133, 54, 103, 58, 139, 99,
</I>&gt;<i> +			146, 149, 90, 197, 167, 60, 164, 35, 90, 168,
</I>&gt;<i> +			150, 138, 107, 17, 219, 191, 163, 4, 98, 13,
</I>&gt;<i> +			109, 98, 122, 178, 247, 46, 73, 124, 53, 228,
</I>&gt;<i> +			137, 21, 20, 45, 214, 217, 202, 51, 87, 45,
</I>&gt;<i> +			78, 190, 19, 209, 249, 13, 31, 88, 52, 108,
</I>&gt;<i> +			196, 110, 54, 19, 252, 189, 80, 216, 191, 222,
</I>&gt;<i> +			192, 10, 112, 231, 67, 104, 154, 205, 1, 172,
</I>&gt;<i> +			194, 226, 187, 60, 252, 104, 176, 27, 87, 244,
</I>&gt;<i> +			217, 166, 140, 245, 97, 187, 64, 188, 103, 129,
</I>&gt;<i> +			194, 56, 206, 61, 169, 66, 171, 49, 234, 206,
</I>&gt;<i> +			29, 141, 249, 110, 171, 127, 135, 23, 20, 58,
</I>&gt;<i> +			156, 16, 252, 185, 148, 20, 202, 87, 124, 160,
</I>&gt;<i> +			65, 169, 243, 32, 164, 19, 59, 58, 188, 109,
</I>&gt;<i> +			43, 1, 150, 0, 0, 0, 203, 217, 189, 181,
</I>&gt;<i> +			208, 230, 19, 165, 199, 206, 44, 204, 209, 156,
</I>&gt;<i> +			80, 26, 199, 66, 198, 13 };
</I>&gt;<i> +
</I>&gt;<i> +		static byte[] dsaPubBlob = { 6, 2, 0, 0, 0, 34, 0, 0, 68, 83,
</I>&gt;<i> +			83, 49, 0, 4, 0, 0, 69, 144, 99, 249,
</I>&gt;<i> +			41, 174, 97, 185, 66, 236, 179, 197, 182, 101,
</I>&gt;<i> +			146, 165, 47, 36, 234, 199, 170, 99, 97, 8,
</I>&gt;<i> +			224, 141, 189, 97, 86, 96, 240, 53, 69, 135,
</I>&gt;<i> +			123, 169, 165, 64, 50, 51, 144, 131, 158, 151,
</I>&gt;<i> +			218, 224, 159, 194, 166, 107, 132, 201, 148, 74,
</I>&gt;<i> +			38, 62, 231, 221, 157, 216, 239, 66, 248, 68,
</I>&gt;<i> +			26, 23, 123, 253, 157, 123, 65, 199, 109, 138,
</I>&gt;<i> +			231, 217, 247, 170, 81, 51, 43, 252, 66, 210,
</I>&gt;<i> +			75, 127, 68, 147, 141, 213, 174, 251, 109, 152,
</I>&gt;<i> +			244, 113, 14, 194, 198, 222, 69, 157, 146, 154,
</I>&gt;<i> +			224, 158, 46, 181, 204, 251, 10, 124, 153, 26,
</I>&gt;<i> +			239, 105, 199, 53, 43, 51, 255, 118, 213, 58,
</I>&gt;<i> +			111, 212, 166, 235, 29, 143, 53, 193, 210, 7,
</I>&gt;<i> +			78, 198, 7, 3, 219, 0, 57, 81, 179, 46,
</I>&gt;<i> +			58, 180, 61, 222, 145, 109, 165, 23, 119, 162,
</I>&gt;<i> +			91, 55, 48, 230, 133, 54, 103, 58, 139, 99,
</I>&gt;<i> +			146, 149, 90, 197, 167, 60, 164, 35, 90, 168,
</I>&gt;<i> +			150, 138, 107, 17, 219, 191, 163, 4, 98, 13,
</I>&gt;<i> +			109, 98, 122, 178, 247, 46, 73, 124, 53, 228,
</I>&gt;<i> +			137, 21, 20, 45, 214, 217, 202, 51, 87, 45,
</I>&gt;<i> +			78, 190, 19, 209, 249, 13, 31, 88, 52, 108,
</I>&gt;<i> +			196, 110, 54, 19, 252, 189, 80, 216, 191, 222,
</I>&gt;<i> +			192, 10, 112, 231, 67, 104, 154, 205, 1, 172,
</I>&gt;<i> +			194, 226, 187, 60, 252, 104, 176, 27, 87, 244,
</I>&gt;<i> +			217, 166, 140, 245, 97, 187, 64, 188, 103, 129,
</I>&gt;<i> +			194, 56, 206, 61, 169, 66, 171, 49, 234, 206,
</I>&gt;<i> +			29, 141, 249, 110, 171, 127, 135, 23, 20, 58,
</I>&gt;<i> +			156, 16, 185, 163, 1, 154, 216, 44, 43, 101,
</I>&gt;<i> +			67, 65, 35, 30, 70, 97, 44, 194, 46, 9,
</I>&gt;<i> +			182, 125, 162, 93, 231, 223, 50, 55, 14, 218,
</I>&gt;<i> +			93, 6, 176, 10, 195, 91, 83, 98, 73, 65,
</I>&gt;<i> +			88, 250, 7, 120, 0, 155, 35, 138, 54, 37,
</I>&gt;<i> +			80, 125, 44, 51, 25, 29, 198, 18, 107, 84,
</I>&gt;<i> +			60, 27, 227, 218, 32, 74, 62, 76, 222, 6,
</I>&gt;<i> +			76, 129, 254, 197, 53, 189, 4, 243, 203, 94,
</I>&gt;<i> +			73, 190, 102, 196, 88, 170, 17, 199, 119, 180,
</I>&gt;<i> +			205, 151, 184, 12, 168, 236, 81, 117, 49, 223,
</I>&gt;<i> +			204, 69, 50, 246, 230, 124, 57, 208, 75, 5,
</I>&gt;<i> +			178, 58, 7, 193, 224, 103, 60, 233, 2, 242,
</I>&gt;<i> +			82, 53, 252, 157, 202, 146, 231, 255, 250, 38,
</I>&gt;<i> +			150, 0, 0, 0, 203, 217, 189, 181, 208, 230,
</I>&gt;<i> +			19, 165, 199, 206, 44, 204, 209, 156, 80, 26,
</I>&gt;<i> +			199, 66, 198, 13 };
</I>&gt;<i> +
</I>&gt;<i> +		static string dsaKeyPairString = &quot;&lt;DSAKeyValue&gt;&lt;P&gt;66bUbzrVdv8zKzXHae8amXwK+8y1Lp7gmpKdRd7Gwg5x9Jht+67VjZNEf0vSQvwrM1Gq99nnim3HQXud/XsXGkT4Qu/Ynd3nPiZKlMmEa6bCn+Dal56DkDMyQKWpe4dFNfBgVmG9jeAIYWOqx+okL6WSZbbFs+xCuWGuKfljkEU=&lt;/P&gt;&lt;Q&gt;3j20Oi6zUTkA2wMHxk4H0sE1jx0=&lt;/Q&gt;&lt;G&gt;EJw6FBeHf6tu+Y0dzuoxq0KpPc44woFnvEC7YfWMptn0VxuwaPw8u+LCrAHNmmhD53AKwN6/2FC9/BM2bsRsNFgfDfnRE75OLVczytnWLRQVieQ1fEku97J6Ym0NYgSjv9sRa4qWqFojpDynxVqVkmOLOmc2heYwN1uidxelbZE=&lt;/G&gt;&lt;Y&gt;Jvr/55LKnfw1UvIC6Txn4MEHOrIFS9A5fOb2MkXM3zF1UeyoDLiXzbR3xxGqWMRmvkley/MEvTXF/oFMBt5MPkog2uMbPFRrEsYdGTMsfVAlNoojmwB4B/pYQUliU1vDCrAGXdoONzLf512ifbYJLsIsYUYeI0FDZSss2JoBo7k=&lt;/Y&gt;&lt;Seed&gt;DcZCxxpQnNHMLM7HpRPm0LW92cs=&lt;/Seed&gt;&lt;PgenCounter&gt;lg==&lt;/PgenCounter&gt;&lt;X&gt;ASttvDo7E6Qg86lBoHxXyhSUufw=&lt;/X&gt;&lt;/DSAKeyValue&gt;&quot;;
</I>&gt;<i> +		static string dsaPubKeyString =  &quot;&lt;DSAKeyValue&gt;&lt;P&gt;66bUbzrVdv8zKzXHae8amXwK+8y1Lp7gmpKdRd7Gwg5x9Jht+67VjZNEf0vSQvwrM1Gq99nnim3HQXud/XsXGkT4Qu/Ynd3nPiZKlMmEa6bCn+Dal56DkDMyQKWpe4dFNfBgVmG9jeAIYWOqx+okL6WSZbbFs+xCuWGuKfljkEU=&lt;/P&gt;&lt;Q&gt;3j20Oi6zUTkA2wMHxk4H0sE1jx0=&lt;/Q&gt;&lt;G&gt;EJw6FBeHf6tu+Y0dzuoxq0KpPc44woFnvEC7YfWMptn0VxuwaPw8u+LCrAHNmmhD53AKwN6/2FC9/BM2bsRsNFgfDfnRE75OLVczytnWLRQVieQ1fEku97J6Ym0NYgSjv9sRa4qWqFojpDynxVqVkmOLOmc2heYwN1uidxelbZE=&lt;/G&gt;&lt;Y&gt;Jvr/55LKnfw1UvIC6Txn4MEHOrIFS9A5fOb2MkXM3zF1UeyoDLiXzbR3xxGqWMRmvkley/MEvTXF/oFMBt5MPkog2uMbPFRrEsYdGTMsfVAlNoojmwB4B/pYQUliU1vDCrAGXdoONzLf512ifbYJLsIsYUYeI0FDZSss2JoBo7k=&lt;/Y&gt;&lt;Seed&gt;DcZCxxpQnNHMLM7HpRPm0LW92cs=&lt;/Seed&gt;&lt;PgenCounter&gt;lg==&lt;/PgenCounter&gt;&lt;/DSAKeyValue&gt;&quot;;
</I>&gt;<i> +
</I>&gt;<i>  		[Test]
</I>&gt;<i> +		public void FromCapiKeyBlobDSA()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiKeyBlobDSA(dsaPrivBlob);
</I>&gt;<i> +			AssertEquals(&quot;KeyPair&quot;, dsaKeyPairString, dsa.ToXmlString(true));
</I>&gt;<i> +			AssertEquals(&quot;PublicKey&quot;, dsaPubKeyString, dsa.ToXmlString(false));
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(ArgumentNullException))]
</I>&gt;<i> +		public void FromCapiKeyBlobDSA_Null()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiKeyBlobDSA(null);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(ArgumentException))]
</I>&gt;<i> +		public void FromCapiKeyBlobDSA_InvalidOffset()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiKeyBlobDSA(new byte[0], 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(CryptographicException))]
</I>&gt;<i> +		public void FromCapiKeyBlobDSA_UnknownBlob()
</I>&gt;<i> +		{
</I>&gt;<i> +			byte[] blob = new byte[334];
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiKeyBlobDSA(blob, 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		public void FromCapiPrivateKeyBlobDSA()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiPrivateKeyBlobDSA(dsaPrivBlob, 0);
</I>&gt;<i> +			AssertEquals(&quot;KeyPair&quot;, dsaKeyPairString, dsa.ToXmlString(true));
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(ArgumentNullException))]
</I>&gt;<i> +		public void FromCapiPrivateKeyBlobDSA_Null()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiPrivateKeyBlobDSA(null);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(ArgumentException))]
</I>&gt;<i> +		public void FromCapiPrivateKeyBlobDSA_InvalidOffset()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiPrivateKeyBlobDSA(new byte[0], 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(CryptographicException))]
</I>&gt;<i> +		public void FromCapiPrivateKeyBlobDSA_Invalid()
</I>&gt;<i> +		{
</I>&gt;<i> +			byte[] blob = new byte[334];
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiPrivateKeyBlobDSA(blob, 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		public void FromCapiPublicKeyBlobDSA()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiPublicKeyBlobDSA(dsaPubBlob, 0);
</I>&gt;<i> +			AssertEquals(&quot;PublicKey&quot;, dsaPubKeyString, dsa.ToXmlString(false));
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(ArgumentNullException))]
</I>&gt;<i> +		public void FromCapiPublicKeyBlobDSA_Null()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiPublicKeyBlobDSA(null);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(ArgumentException))]
</I>&gt;<i> +		public void FromCapiPublicKeyBlobDSA_InvalidOffset()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiPublicKeyBlobDSA(new byte[0], 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(CryptographicException))]
</I>&gt;<i> +		public void FromCapiPublicKeyBlobDSA_Invalid()
</I>&gt;<i> +		{
</I>&gt;<i> +			byte[] blob = new byte[400];
</I>&gt;<i> +			DSA dsa = CryptoConvert.FromCapiPublicKeyBlobDSA(blob, 0);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		public void ToCapiKeyBlob_DSA()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = DSA.Create();
</I>&gt;<i> +			dsa.FromXmlString(dsaKeyPairString);
</I>&gt;<i> +			byte[] keypair = CryptoConvert.ToCapiKeyBlob(dsa, true);
</I>&gt;<i> +			AssertEquals(&quot;KeyPair&quot;, dsaPrivBlob, keypair);
</I>&gt;<i> +
</I>&gt;<i> +			byte[] pubkey = CryptoConvert.ToCapiKeyBlob(dsa, false);
</I>&gt;<i> +			AssertEquals(&quot;PublicKey&quot;, BitConverter.ToString(dsaPubBlob), BitConverter.ToString(pubkey));
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(ArgumentNullException))]
</I>&gt;<i> +		public void ToCapiKeyBlob_DSANull()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = null;
</I>&gt;<i> +			CryptoConvert.ToCapiKeyBlob(dsa, false);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		public void ToCapiPrivateKeyBlob_DSA()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = DSA.Create();
</I>&gt;<i> +			dsa.FromXmlString(dsaKeyPairString);
</I>&gt;<i> +			byte[] keypair = CryptoConvert.ToCapiPrivateKeyBlob(dsa);
</I>&gt;<i> +			AssertEquals(&quot;KeyPair&quot;, dsaPrivBlob, keypair);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		[ExpectedException(typeof(CryptographicException))]
</I>&gt;<i> +		public void ToCapiPrivateKeyBlob_PublicKeyOnly_DSA()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = DSA.Create();
</I>&gt;<i> +			dsa.FromXmlString(dsaPubKeyString);
</I>&gt;<i> +			byte[] pubkey = CryptoConvert.ToCapiPrivateKeyBlob(dsa);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i> +		public void ToCapiPublicKeyBlob_DSA()
</I>&gt;<i> +		{
</I>&gt;<i> +			DSA dsa = DSA.Create();
</I>&gt;<i> +			// full keypair
</I>&gt;<i> +			dsa.FromXmlString(dsaKeyPairString);
</I>&gt;<i> +			byte[] pubkey = CryptoConvert.ToCapiPublicKeyBlob(dsa);
</I>&gt;<i> +			AssertEquals(&quot;PublicKey-1&quot;, BitConverter.ToString(dsaPubBlob), BitConverter.ToString(pubkey));
</I>&gt;<i> +
</I>&gt;<i> +			// public key only
</I>&gt;<i> +			dsa.FromXmlString(dsaPubKeyString);
</I>&gt;<i> +			pubkey = CryptoConvert.ToCapiPublicKeyBlob(dsa);
</I>&gt;<i> +			AssertEquals(&quot;PublicKey-2&quot;, BitConverter.ToString(dsaPubBlob), BitConverter.ToString(pubkey));
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		[Test]
</I>&gt;<i>  		public void FromHex () 
</I>&gt;<i>  		{
</I>&gt;<i>  			AssertNull (&quot;FromHex(null)&quot;, CryptoConvert.FromHex (null));
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>-- 
Sebastien Pouliot  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>&gt;
Blog: <A HREF="http://pages.infinit.net/ctech/">http://pages.infinit.net/ctech/</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023488.html">[Mono-dev] [patch] Add DSA support to CryptConvert
</A></li>
	<LI>Next message: <A HREF="023503.html">[Mono-dev] [patch] Add DSA support to CryptConvert
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23502">[ date ]</a>
              <a href="thread.html#23502">[ thread ]</a>
              <a href="subject.html#23502">[ subject ]</a>
              <a href="author.html#23502">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
