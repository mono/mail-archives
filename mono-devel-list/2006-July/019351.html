<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Action&lt;T&gt; used
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Action%3CT%3E%20used&In-Reply-To=44B36431.9080208%40yahoo.es">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019344.html">
   <LINK REL="Next"  HREF="019355.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Action&lt;T&gt; used</H1>
    <B>Jonathan Gilbert</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Action%3CT%3E%20used&In-Reply-To=44B36431.9080208%40yahoo.es"
       TITLE="[Mono-dev] Action&lt;T&gt; used">2a5gjx302 at sneakemail.com
       </A><BR>
    <I>Tue Jul 11 13:23:06 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="019344.html">[Mono-dev] Action&lt;T&gt; used
</A></li>
        <LI>Next message: <A HREF="019355.html">[Mono-dev] Action&lt;T&gt; used
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19351">[ date ]</a>
              <a href="thread.html#19351">[ thread ]</a>
              <a href="subject.html#19351">[ subject ]</a>
              <a href="author.html#19351">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Just a little clean-up for any readers who don't already understand the
techniques being used:

At 10:41 AM 11/07/2006 +0200, Alejandro Serrano wrote:
&gt;<i>public void ForEach (Node node, Action&lt;Node&gt; action)
</I>&gt;<i>{
</I>&gt;<i>    action (node)
</I>
;

&gt;<i>    foreach (Node child in this.Subnodes) ForEach (child, action);
</I>&gt;<i>}
</I>
This method could also be made an instance method of the &quot;Node&quot; class. I
think this is actually what the original poster had in mind:

public class Node
{
  ...

  public void ForEach(Action&lt;Node&gt; action)
  {
    action(this);

    foreach (Node child in Subnodes)
      child.ForEach(action);
  }
}

The original method shown for counting nodes shows a breadth-first search,
while this recursion will give a depth-first search. To do a ForEach with
breadth-first order, one uses a queue instead of a stack:

public class Node
{
  ...

  public void ForEach(Action&lt;Node&gt; action)
  {
    Queue&lt;Node&gt; remaining = new Queue&lt;Node&gt;();

    remaining.Enqueue(this);

    while (remaining.Count &gt; 0)
    {
      Node node = remaining.Dequeue();

      action(node);

      foreach (Node child in node.Subnodes)
        remaining.Enqueue(child);
    }
  }
}

&gt;<i>Hope this helps ;-)
</I>&gt;<i>
</I>&gt;<i>Other solution would be using IEnumerable
</I>&gt;<i>
</I>&gt;<i>public class Node : IEnumerable&lt;Node&gt;
</I>
Implementing this interface here has nothing to do with being able to add
an arbitrary member that returns IEnumerator&lt;Node&gt;. It is not necessary for
EnumerateDescendents() and forces only a GetEnumerator() with the
IEnumerator&lt;Node&gt; return type.

&gt;<i>{
</I>&gt;<i>    ...
</I>&gt;<i>
</I>&gt;<i>    public IEnumerator&lt;Node&gt; EnumerateDescendants ()
</I>&gt;<i>    {
</I>&gt;<i>       Queue&lt;Node&gt; todo = new Queue&lt;Node&gt; ();
</I>&gt;<i>       todo.Enqueue (this);
</I>&gt;<i>       while (todo.Count &gt; 0)
</I>&gt;<i>       {
</I>&gt;<i>          Node node = todo.Enqueue ();
</I>
I'm pretty sure this should be a call to .Dequeue() :-)

&gt;<i>          yield node;
</I>
yield return node;

&gt;<i>          foreach (Node child in node.Subnodes) todo.Enqueue (child);
</I>&gt;<i>       }
</I>&gt;<i>    }
</I>&gt;<i>}
</I>&gt;<i>
</I>&gt;<i>Now you can use:
</I>&gt;<i>
</I>&gt;<i>foreach (Node node in firstNode.EnumerateDescendants ())
</I>&gt;<i>    doWhatYouWant (node);
</I>&gt;<i>
</I>&gt;<i>Alejandro Serrano
</I>
This enumerator could also be implemented recursively:

public class Node
{
  ...

  public IEnumerator&lt;Node&gt; EnumerateDescendents()
  {
    yield return this;
    foreach (Node child in Subnodes)
      foreach (Node descendent in child.EnumerateDescendents())
        yield return descendent;
  }
}

The code is shorter, and despite the foreach nesting it isn't really an
O(n^2) loop since the subtrees are disjoint. Overhead will be somewhat
higher, though, as the recursive call to EnumerateDescendents entails the
creation of a new object for maintaining the state of the enumeration, and
then every call to .MoveNext on the top-level enumerator will recurse down
along the path to the next child node to be returned, only to discard those
stack frames in order to return the node. Such is the penalty for faking
coroutines with state machines. :-)

The recursive implementation will return the nodes in a depth-first tree
walk order, while the queue-based approach will return the nodes in a
breadth-first tree walk order.

Jonathan Gilbert

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019344.html">[Mono-dev] Action&lt;T&gt; used
</A></li>
	<LI>Next message: <A HREF="019355.html">[Mono-dev] Action&lt;T&gt; used
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19351">[ date ]</a>
              <a href="thread.html#19351">[ thread ]</a>
              <a href="subject.html#19351">[ subject ]</a>
              <a href="author.html#19351">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
