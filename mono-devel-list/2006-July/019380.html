<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Incremental C# compiler
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Incremental%20C%23%20compiler&In-Reply-To=e93943%24md%241%40sea.gmane.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019378.html">
   <LINK REL="Next"  HREF="019393.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Incremental C# compiler</H1>
    <B>Jonathan Gilbert</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Incremental%20C%23%20compiler&In-Reply-To=e93943%24md%241%40sea.gmane.org"
       TITLE="[Mono-dev] Incremental C# compiler">2a5gjx302 at sneakemail.com
       </A><BR>
    <I>Wed Jul 12 14:16:41 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="019378.html">[Mono-dev] Incremental C# compiler
</A></li>
        <LI>Next message: <A HREF="019393.html">[Mono-dev] Incremental C# compiler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19380">[ date ]</a>
              <a href="thread.html#19380">[ thread ]</a>
              <a href="subject.html#19380">[ subject ]</a>
              <a href="author.html#19380">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>t 06:48 PM 12/07/2006 +0200, Robert Jordan wrote:
&gt;<i>Jonathan Gilbert wrote:
</I>&gt;&gt;<i> One other possibility which should not be discounted out-of-hand, I think,
</I>&gt;&gt;<i> is the possibility of resurrecting the interpreter and bringing it
</I>&gt;&gt;<i> up-to-date. Certainly the hardest part of edit-and-continue of a running
</I>&gt;<i>
</I>&gt;<i>Edit-and-continue is best suited to debug/analyze/fix long running
</I>&gt;<i>applications and/or apps with a long start-up time.
</I>&gt;<i>The interpreter would kill all benefits of edit-and-continue.
</I>
I disagree with this. The majority of situations where I have seen
edit-and-continue employed (and have employed it myself) involve GUI
applications where the logic behind a short event handler is broken. See
below.

&gt;<i>Of course, for dudes who use to &quot;massage a method until it works&quot; (TM)
</I>&gt;<i>the interpreter would be okay, but for those usage patterns
</I>&gt;<i>I won't implement edit-and-continue ;-)
</I>
Like I said, I don't think the option should be discounted out-of-hand.
Consider the following:

1. The interpreter would only be used for the case where the method being
edited is *currently executing* on some thread.

2. The interpreter would be used to take over only that invocation of the
method. Thus, any lost speed benefits apply only to code within that
function for the duration of that call. Situations where a single method is
in a massively long loop and needs to be edited at runtime are more than
likely corner cases. Yes, I've written them before, but I've used
edit-and-continue far more often in GUI applications where the broken code
is, say, a button click handler that gets an item index from the wrong
place, or doesn't handle a possible null reference. It's certainly true
that it's no more than a convenience in this situation, but it's a
convenience that can greatly reduce development time, since you don't have
to bring the GUI up to the point of the bug every time you make a change to
the code.

3. Edit-and-continue has never been intended by anyone who has developed it
to be more than a stopgap measure, a means to test a fix quickly without
restarting the application. Once the fix has been verified to work, the
application will inevitably need to be rebuilt at some point. I don't think
I would feel comfortable using edit-and-continue on a long-running
application and then running it through to its finish on the &quot;hacked&quot; code.
I would feel even more uncomfortable running a network server on
edited-and-continued code.

4. The alternative to using an interpreter is very difficult to code. It
would probably take longer to get right than an entire functional
interpreter coded from scratch. In essence, it's a choice between having
the ability to edit methods that are running and not.

5. An implementation using an interpreter need not be permanent. It would
fill an important niche until a developer had the time &amp; expertise to write
the code to munge the native execution context of the new JIT output.

6. An implementation using an interpreter would be inherently
platform-independent, whereas the &quot;ideal&quot; native version would, as far as I
can tell, tend to be platform-specific. Even if the native version were
implemented on some platforms, an interpreter-based implementation could be
a fallback for the alternative on platforms for which it had not yet been
written.

I also happen to think that it's a little bit arrogant to refuse to
implement a feature on the basis that some people would use it in a pattern
you disapprove of. It would be a little bit like refusing to implement
intellisense on the grounds that people only use it because they're too
lazy to memorize the framework.

Jonathan Gilbert


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019378.html">[Mono-dev] Incremental C# compiler
</A></li>
	<LI>Next message: <A HREF="019393.html">[Mono-dev] Incremental C# compiler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19380">[ date ]</a>
              <a href="thread.html#19380">[ thread ]</a>
              <a href="subject.html#19380">[ subject ]</a>
              <a href="author.html#19380">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
