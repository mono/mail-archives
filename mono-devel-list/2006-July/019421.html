<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] COM Interop Patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20COM%20Interop%20Patch&In-Reply-To=295e750a0607140833nc30bfd9ya6a48c5cfe9cbdc5%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019418.html">
   <LINK REL="Next"  HREF="019422.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] COM Interop Patch</H1>
    <B>Jon Chambers</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20COM%20Interop%20Patch&In-Reply-To=295e750a0607140833nc30bfd9ya6a48c5cfe9cbdc5%40mail.gmail.com"
       TITLE="[Mono-dev] COM Interop Patch">joncham at gmail.com
       </A><BR>
    <I>Fri Jul 14 13:44:19 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="019418.html">[Mono-dev] COM Interop Patch
</A></li>
        <LI>Next message: <A HREF="019422.html">[Mono-dev] COM Interop Patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19421">[ date ]</a>
              <a href="thread.html#19421">[ thread ]</a>
              <a href="subject.html#19421">[ subject ]</a>
              <a href="author.html#19421">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for the review Zoltan. I am addressing the issues you brought up. The
only issue is with the two methods needed for a COM call and their caching.
The first method (the one that calls the other generated method) is the one
I need to cache. You said I shouldn't mark it as wrapper type
MONO_WRAPPER_MANAGED_TO_NATIVE, which makes sense. I'll mark it
MONO_WRAPPER_COMINTEROP. The second generated method I'll mark
MONO_WRAPPER_MANAGED_TO_NATIVE, since it is. The second method never needs
looked up, so I will remove that cache. However, what cache should I put the
first method into; the native_wrapper_cache or a specific cache for
cominterop (I can use the cache I was using for the second emitted method,
since those methods don't need it).

Thanks,
Jonathan

On 7/14/06, Zoltan Varga &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">vargaz at gmail.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i>                                          Hi,
</I>&gt;<i>
</I>&gt;<i>   Here are my comments:
</I>&gt;<i> &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
</I>&gt;<i> - class.c OK
</I>&gt;<i> - loader.c:
</I>&gt;<i>         - why is signature-&gt;cominterop needed, ie IS_IMPORT (m-&gt;klass) can
</I>&gt;<i> be
</I>&gt;<i> used instead ?
</I>&gt;<i> - domain.c: OK
</I>&gt;<i> - image.c: OK
</I>&gt;<i> - metadata.c:
</I>&gt;<i>   - The comment of mono_metadata_type_dup_mp is incorrect, also:
</I>&gt;<i>   - mono_stats.generics_metadata_size += sizeof (MonoType);
</I>&gt;<i>     is not needed
</I>&gt;<i>   - this is not needed:
</I>&gt;<i> +       r-&gt;attrs = original-&gt;attrs;
</I>&gt;<i> +       r-&gt;byref = original-&gt;byref;
</I>&gt;<i> - metadata-internals.h: OK
</I>&gt;<i> - the declaration of mono_metadata_type_dup_mp () should go to
</I>&gt;<i> metadata-internals.h to avoid making it public
</I>&gt;<i> - object.c OK
</I>&gt;<i> - class-internals.h OK
</I>&gt;<i> - object-internals.h OK
</I>&gt;<i>   - move the '#endregion' in RealProxy.cs to encompass all the
</I>&gt;<i> fields,  add a
</I>&gt;<i>     comment saying that other classes visible to the runtime inherit from
</I>&gt;<i> this
</I>&gt;<i>     class so all new fields should be added between #region-#endregion.
</I>&gt;<i> - marshal.c:
</I>&gt;<i>   - the comment for cominterop_get_method_interface is wrong
</I>&gt;<i>   - in cominterop_get_native_wrapper_adjusted (), the created method is
</I>&gt;<i> put
</I>&gt;<i>     into the cache, but never looked up, so either the lookup is missing,
</I>&gt;<i> or
</I>&gt;<i>     the cache is not really needed.
</I>&gt;<i>   - in cominterop_get_native_wrapper (), no need to set save_lmf.
</I>&gt;<i> Also, the wrapper type shouldn't be MONO_WRAPPER_MANAGED_TO_NATIVE,
</I>&gt;<i> since this calls another managed method, not native code.
</I>&gt;<i>   - in cominterop_get_invoke (), sig = signature_no_pinvoke () should be
</I>&gt;<i>     moved after the if ((res = mono_marshal_find_in_cached ()))
</I>&gt;<i> otherwise it is leaked. This means the if (!sig-&gt;hasthis) line needs
</I>&gt;<i> to changed as well.
</I>&gt;<i>   - in cominterop_get_invoke (), no need to set save_lmf. Also, no
</I>&gt;<i> need for emit_thread_interrupt_checkpoint ().
</I>&gt;<i> - marshal.h OK
</I>&gt;<i> - icall.c: The ComObject icalls should be moved to marshal.c.
</I>&gt;<i>
</I>&gt;<i> - Marshal.cs: I think the [MonoTODO]s should remain, since these methods
</I>&gt;<i> can
</I>&gt;<i>   still throw NotImplementedException ().
</I>&gt;<i> - __ComObject.cs: This should use #region-#endregion to mark which fields
</I>&gt;<i> are
</I>&gt;<i>   visible from unmanaged code.
</I>&gt;<i> - ActivationService.cs: This could use Type.IsImport.
</I>&gt;<i>
</I>&gt;<i> - need to increase corlib version in appdomain.c and
</I>&gt;<i> System/Environment.cs.
</I>&gt;<i> - it would be nice to add the design comments in your mail to the wiki
</I>&gt;<i> page about COM Interop and to the code, like the reasoning behind the
</I>&gt;<i> _adjusted methods.
</I>&gt;<i> &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
</I>&gt;<i>
</I>&gt;<i> Other than these, the code look ok to me. Good Work !
</I>&gt;<i>
</I>&gt;<i>              Zoltan
</I>&gt;<i>
</I>&gt;<i> On 7/12/06, Jon Chambers &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">joncham at gmail.com</A>&gt; wrote:
</I>&gt;<i> &gt; Here is another attempt at a COM Interop patch. First, all
</I>&gt;<i> &gt; changes/contributions are MIT X11. Now, for a brief overview ;-).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I implemented COM Interop on top of the current remoting infrastructure.
</I>&gt;<i> &gt; This allows for two main things. 1. Forwarding of method calls to the
</I>&gt;<i> &gt; underlying unmanaged COM object. 2. Casting RCW (Runtime Callable
</I>&gt;<i> Wrappers -
</I>&gt;<i> &gt; the managed wrapper around the unmanaged COM object) to interfaces not
</I>&gt;<i> &gt; specified as implemented in metadata. This can occur if a QueryInterface
</I>&gt;<i> for
</I>&gt;<i> &gt; that interface's Guid (IID) succeeds on the underlying object.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So, when a user says &quot;MyComObj obj = new MyComObj()&quot; the runtime creates
</I>&gt;<i> a
</I>&gt;<i> &gt; ComInteropProxy and returns it's TransparentProxy. However, instead of
</I>&gt;<i> &gt; forwarding methods via the remoting invoke mechanism using messages, I
</I>&gt;<i> &gt; shortcut to a Com Interop invoke. The is a great performance boost (by a
</I>&gt;<i> few
</I>&gt;<i> &gt; orders of magnitude if I recall). I first emit the invoke call, which
</I>&gt;<i> &gt; transitions the call from a call on the transparent proxy, into a call
</I>&gt;<i> on
</I>&gt;<i> &gt; the actuall RCW.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The method implementation is done by cominterop_get_native_wrapper. This
</I>&gt;<i> &gt; emits a method whose signature matches the managed method. The emitted
</I>&gt;<i> &gt; method calls a final emitted method created by
</I>&gt;<i> &gt; cominterop_get_native_wrapper_adjusted. The two methods,
</I>&gt;<i> &gt; created by cominterop_get_native_wrapper and
</I>&gt;<i> &gt; cominterop_get_native_wrapper_adjusted are 1-1. The
</I>&gt;<i> &gt; adjusted method matches the unmanaged signature, and as thus can reuse
</I>&gt;<i> all
</I>&gt;<i> &gt; the existing unmanaged calling functionality provided by
</I>&gt;<i> &gt; mono_marshal_emit_native_wrapper. The only small change to
</I>&gt;<i> &gt; mono_marshal_emit_native_wrapper was that the function
</I>&gt;<i> &gt; pointer is push onto the stack at call time, rather than when the method
</I>&gt;<i> is
</I>&gt;<i> &gt; emitted since the function pointer depends on the object making the call
</I>&gt;<i> &gt; (different objects implementing the same interface could have different
</I>&gt;<i> &gt; implementations, and thus vtables, thus function pointers).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Another minor note is the internal calls added to __ComObject. This is
</I>&gt;<i> so I
</I>&gt;<i> &gt; can store a hashtable of COM interfaces and later release them in the
</I>&gt;<i> &gt; finalizer to ensure proper reference counting. I had a Hashtable in
</I>&gt;<i> managed
</I>&gt;<i> &gt; code intially but couldn't access it in my finalizer.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I also implemented a series of COM Interop related methods in the
</I>&gt;<i> Marshal
</I>&gt;<i> &gt; class.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On windows you should be able to run some basic tests. I added a few to
</I>&gt;<i> the
</I>&gt;<i> &gt; cominterop.cs test file but disabled them for the moment. COM is a
</I>&gt;<i> binary
</I>&gt;<i> &gt; standard and I wasn't sure what vtable layouts would be like on Solaris,
</I>&gt;<i> &gt; ARM, etc. (I know HP is different) and didn't want to cause regressions
</I>&gt;<i> on
</I>&gt;<i> &gt; those platforms. But, on windows/linux x86/64 you can enable them and
</I>&gt;<i> run
</I>&gt;<i> &gt; them. Or more excitingly you can add a reference to an interop assembly
</I>&gt;<i> on
</I>&gt;<i> &gt; MS and test run real COM objects (Internet Explorer for example). The
</I>&gt;<i> &gt; largest thing missing right now is the marshalling of com objects. So,
</I>&gt;<i> you
</I>&gt;<i> &gt; can't call any methods that have parameters/return value of COM objects.
</I>&gt;<i> &gt; This will be the next thing I work on.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm sure there are some issues, so please review and I'll fix them ASAP.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Thanks,
</I>&gt;<i> &gt; Jonathan
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-devel-list mailing list
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20060714/aa38a80c/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20060714/aa38a80c/attachment.html</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019418.html">[Mono-dev] COM Interop Patch
</A></li>
	<LI>Next message: <A HREF="019422.html">[Mono-dev] COM Interop Patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19421">[ date ]</a>
              <a href="thread.html#19421">[ thread ]</a>
              <a href="subject.html#19421">[ subject ]</a>
              <a href="author.html#19421">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
