<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Announce: Mono.Fuse 0.2.0 (+ Required mcs &amp; mono	patches)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Announce%3A%20Mono.Fuse%200.2.0%20%28%2B%20Required%20mcs%20%26%20mono%0A%09patches%29&In-Reply-To=1157110997.4260.95.camel%40melchior.magi">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020262.html">
   <LINK REL="Next"  HREF="020413.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Announce: Mono.Fuse 0.2.0 (+ Required mcs &amp; mono	patches)</H1>
    <B>Valient Gough</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Announce%3A%20Mono.Fuse%200.2.0%20%28%2B%20Required%20mcs%20%26%20mono%0A%09patches%29&In-Reply-To=1157110997.4260.95.camel%40melchior.magi"
       TITLE="[Mono-dev] Announce: Mono.Fuse 0.2.0 (+ Required mcs &amp; mono	patches)">valient at gmail.com
       </A><BR>
    <I>Mon Sep 11 00:07:10 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020262.html">[Mono-dev] Announce: Mono.Fuse 0.2.0 (+ Required mcs &amp; mono patches)
</A></li>
        <LI>Next message: <A HREF="020413.html">[Mono-dev] [Mono-list] Announce: Mono.Fuse 0.2.0	(+	Required	mcs &amp; mono patches)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20406">[ date ]</a>
              <a href="thread.html#20406">[ thread ]</a>
              <a href="subject.html#20406">[ subject ]</a>
              <a href="author.html#20406">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I've been busy for a while, but wanted to follow up eventually.  I
thought I'd seen an 0.2.1 announcement, but this is the latest
announcement I see in my mail archive.

On 9/1/06, Jonathan Pryor &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jonpryor at vt.edu</A>&gt; wrote:
&gt;<i> Mono.Fuse is a binding for the FUSE library, permitting user-space
</I>&gt;<i> file systems to be written in C#.
</I>
&gt;<i>   I think paths are easier to deal with, and Valient Gough
</I>&gt;<i>       believes inodes are.
</I>
Uggg..  I don't think we're communicating very well, because this has
no resemblance to what I said.   What I said is that I find these
low-level APIs less then exciting, and mostly of interest as a
stepping stone for building more interesting APIs.  And it is easier
to build a high-level interface on top of the inode API rather then
the path based API. (1)

But rather then just be annoyed with our inability to communicate,
I've added a simple wrapper to the inode based interface to your code.
 It is available at
<A HREF="http://arg0.net/vgough/download/fuse-lowlevel-0.2.1.tgz">http://arg0.net/vgough/download/fuse-lowlevel-0.2.1.tgz</A>

The low-level wrapper is really only tested well enough to run the
included HelloFS example - it hasn't even been used as a base for a
real filesystem.  My thought was to eventually port the high-level
interface (aka the other parts of Sulf project) to use either this or
the SWIG wrappers as the low-level backend.  However this is a
spare-time project since my employers are more interested in that
language which starts with a 'J'.

If you don't want these lowlevel API wrappers in your archive, it
would be great if you split some of the helper functions out of
FileSystem.cs into other files so they can be reused by other classes
(which is why Filesystem.cs is different in my archive then in the
original).

thanks,
Valient

(1) The reason it is harder to use the path-based API for a complex
filesystem has nothing to do with lines of code.  The problem is due
to the data model, what I tried to explain before - with the path
based API, libfuse is remapping the primary key (the kernel supplied
inode numbers) to a mutable / non-unique key (a path) and then using
that as the primary key.  When you construct a complex filesystem
which handles writes, I suggest letting the following programs write
to it:  rsync, tar, mutt, evolution.  Those will demonstrate lots of
interesting issues having to do with path based APIs (like deleting a
file while it is still open, renaming files while open, renaming on
top of open files, renaming directories while files inside the
directories are open, etc).  Those operations don't change the real
primary key (the inode number), but they change the path in the middle
of accessing files.   It isn't impossible to get right - I like to
think Encfs does a good job, but it isn't trivial and introduces
operation ordering requirements which are otherwise unnecessary.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020262.html">[Mono-dev] Announce: Mono.Fuse 0.2.0 (+ Required mcs &amp; mono patches)
</A></li>
	<LI>Next message: <A HREF="020413.html">[Mono-dev] [Mono-list] Announce: Mono.Fuse 0.2.0	(+	Required	mcs &amp; mono patches)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20406">[ date ]</a>
              <a href="thread.html#20406">[ thread ]</a>
              <a href="subject.html#20406">[ subject ]</a>
              <a href="author.html#20406">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
