<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Thread safety of readonly data members?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Thread%20safety%20of%20readonly%20data%20members%3F&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004131.html">
   <LINK REL="Next"  HREF="004099.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Thread safety of readonly data members?</H1>
    <B>Michi Henning</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Thread%20safety%20of%20readonly%20data%20members%3F&In-Reply-To="
       TITLE="[Mono-devel-list] Thread safety of readonly data members?">michi at zeroc.com
       </A><BR>
    <I>Wed Feb 18 14:24:49 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="004131.html">[Mono-devel-list] Thread safety of readonly data members?
</A></li>
        <LI>Next message: <A HREF="004099.html">[Mono-devel-list] sparc mini
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4136">[ date ]</a>
              <a href="thread.html#4136">[ thread ]</a>
              <a href="subject.html#4136">[ subject ]</a>
              <a href="author.html#4136">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jonathan Pyor wrote:

&gt;<i> I would think whether or not the lock is required, in either
</I>&gt;<i> environment, would depend on how you create your class instances.  Do
</I>&gt;<i> you allow your code to possibly invoke both the constructor and the
</I>&gt;<i> method at the same time?
</I>
No -- construction and access can't overlap. getVal() is called by
another thread some time after construction completes.

&gt;<i> So no, the lock is NOT necessary in C++.
</I>
Uh, sorry, but that's not correct. On SMP machines, things can happen
in the following order:

- Thread 1, running on CPU 1, reads a variable. This loads a cache line
  on CPU 1 containing the variable. It is possible for the instance of
Class1
  to be adjacent in memory to the variable just read by Thread 1, and to
  be loaded into the cache on CPU 1 as well, because a single cache line
  can hold more than one variable.

- Thread 2 constructs the Class1 instance and initializes the _val member.

- Thread 1 calls getVal() on the instance. Because the corresponding
  memory location is in the cache, it is served from the cache, and
  thread 1 reads whatever garbage is in that memory location.

Without a memory barrier, there is no way for Thread 1 to know that
Thread 2 has modified the contents of the memory that holds _val.

So, I guess another way to phrase my question is to ask whether
C# guarantees to insert a memory barrier at the end of the
constructor if readonly members were initialized by that constructor.

&gt;<i> Moving on to Mono, one major problem is that the CLI standard, as
</I>&gt;<i> currently specified, uses effectively the same memory consistency model
</I>&gt;<i> as Java.  Meaning, C++ techniques such as double-checked locking ARE NOT
</I>&gt;<i> VALID:
</I>
Aha. OK -- that answers my question, thanks!

Could you point me at where the CLI memory consistency model is defined?
I couldn't find any such thing in the C# documentation.

&gt;<i>
</I>&gt;<i> private static Class1 foo;
</I>&gt;<i>
</I>&gt;<i> public static Foo {
</I>&gt;<i> get {
</I>&gt;<i> // This will likely work on most platforms, such
</I>&gt;<i> // as x86, but it is NOT guaranteed to work on
</I>&gt;<i> // all potential hardware platforms.
</I>&gt;<i> if (foo == null) {
</I>&gt;<i> lock (typeof(Something)) {
</I>&gt;<i> if (foo == null)
</I>&gt;<i> foo = new Class1();
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> In C++, you could use code similar to the above, and you WOULD NOT need
</I>&gt;<i> to lock both the class constructor and the accessor methods, as the
</I>&gt;<i> calling code ensures that the class has properly constructed before
</I>&gt;<i> invoking any member functions.
</I>&gt;<i>
</I>&gt;<i> The problem is that double-checked locking isn't really portable in
</I>&gt;<i> .NET, so you either need to (a) always lock the code that will construct
</I>&gt;<i> the object, or (b) use the static loader lock, described below.
</I>&gt;<i>
</I>&gt;<i> &gt; What if the member variable is not readonly (but will
</I>&gt;<i> &gt; never be modified, except for the initial assignment
</I>&gt;<i> &gt; in the constructor)? Is accessing the value thread-safe
</I>&gt;<i> &gt; without a lock in that case?
</I>&gt;<i>
</I>&gt;<i> I would expect that this is similar/identical to the readonly variable
</I>&gt;<i> case.  &quot;readonly&quot; only means that the compiler will check your code to
</I>&gt;<i> ensure that the variables don't change after you've initialized them in
</I>&gt;<i> the constructor.  The runtime may do some checking on them, but I'm not
</I>&gt;<i> entirely sure about that.
</I>&gt;<i>
</I>&gt;<i> &gt; What about const members? Is access to those safe without
</I>&gt;<i> &gt; a lock?
</I>&gt;<i>
</I>&gt;<i> Const members are safe, as these are &quot;burned&quot; into the CIL, and cannot
</I>&gt;<i> be changed without recompiling.  They're just like enumeration members.
</I>&gt;<i> You can't change enumeration values after you've compiled. :-)
</I>
Hmmm... Even those wouldn't be necessarily safe. The would be
safe only if the language definition guarantees that const members
end up in the initialized data segment. However, an equally valid
implementation for const members would be to initialize them
at run time, during program startup. In that case, all bets would
be off. So, does the CLR or C# guarantee that const members
are in the initialized data segment?

&gt;<i> &gt; And what about static members that are (conceptually)
</I>&gt;<i> &gt; immutable (only initialized in the constructor and
</I>&gt;<i> &gt; never assigned again)? Is the lock required there?
</I>&gt;<i>
</I>&gt;<i> No.  Static members are initialized by the class constructor (&quot;.cctor&quot;),
</I>&gt;<i> and the runtime has an internal lock to ensure that only one thread
</I>&gt;<i> executes the class constructor.
</I>
Right. But without the reading thread grabbing the lock, there is
nothing to tell the hardware that the thread may be reading
inconsistent memory, I would think.

&gt;<i> // Initializing static members either &quot;inline&quot; or in the static
</I>&gt;<i> // class constructor is *always* thread safe.
</I>&gt;<i> public static readonly string Hello = &quot;Hello&quot;;
</I>&gt;<i> public static readonly Class1 Something;
</I>&gt;<i> static MyClass ()
</I>&gt;<i> {
</I>&gt;<i> Something = new Class1 ();
</I>&gt;<i> }
</I>
Hmmm. So if another thread reads Something, what ensures
that the second thread doesn't read from a stale cache line?

Cheers,

Michi.
--
Michi Henning              Ph: +61 4 1118-2700
ZeroC, Inc.                <A HREF="http://www.zeroc.com">http://www.zeroc.com</A>



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004131.html">[Mono-devel-list] Thread safety of readonly data members?
</A></li>
	<LI>Next message: <A HREF="004099.html">[Mono-devel-list] sparc mini
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4136">[ date ]</a>
              <a href="thread.html#4136">[ thread ]</a>
              <a href="subject.html#4136">[ subject ]</a>
              <a href="author.html#4136">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
