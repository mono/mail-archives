<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Performance w/ boxing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Performance%20w/%20boxing&In-Reply-To=6343-10384%40sneakemail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004169.html">
   <LINK REL="Next"  HREF="004184.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Performance w/ boxing</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Performance%20w/%20boxing&In-Reply-To=6343-10384%40sneakemail.com"
       TITLE="[Mono-devel-list] Performance w/ boxing">jonpryor at vt.edu
       </A><BR>
    <I>Fri Feb 20 21:24:31 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="004169.html">[Mono-devel-list] Performance w/ boxing
</A></li>
        <LI>Next message: <A HREF="004184.html">[Mono-devel-list] Performance w/ boxing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4181">[ date ]</a>
              <a href="thread.html#4181">[ thread ]</a>
              <a href="subject.html#4181">[ subject ]</a>
              <a href="author.html#4181">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Below...

On Fri, 2004-02-20 at 17:33, Jonathan Gilbert wrote:
&gt;<i> At 07:36 AM 20/02/2004 -0500, Jonathan Pryor jonpryor-at-vt.edu |mono-list
</I>&gt;<i> subscription| wrote:
</I>&lt;snip/&gt;
&gt;<i> &gt;That's not quite what the original poster (Jaroslaw Kowalski) wanted. 
</I>&gt;<i> &gt;He wanted a way to check for either (a) null, or (b) a boxed integer.  A
</I>&gt;<i> &gt;&quot;ref&quot; or &quot;out&quot; integer can never be null.
</I>&gt;<i> 
</I>&gt;<i> This isn't quite right. An 'out' parameter is in fact uninitialized and
</I>&gt;<i> does not carry any value at all.
</I>
Not quite.  The value to which the parameter refers to is (can be)
uninitialized.  The parameter itself is initialized to a well-known
value.

The best way to think of this is to use C++. :-)

The original poster wanted to be able to use a pointer, so that null (no
object) could be passed:

	void function (int* value) {/* ... */}

&quot;Safe&quot; C# does not permit that.  (You can always insert a few unsafe
keywords and use raw pointers, but we're avoiding that for now.)  In C#
(and probably the CLS), &quot;ref&quot; and &quot;out&quot; are equivalent to a C++
reference:

	void function (int&amp; value) {/* ... */}

At the compiler/runtime level, a reference is *really* a pointer, same
as above, but with the language guarantee that the pointer can never be
the null pointer (outside of reinterpret_cast).

C# ref and out is similar.  At the IL level, a manage pointer is
actually being passed, which could be null.  The language requires that
null never be passed, just like a C++ reference, and adds additional
semantic requirements (&quot;ref&quot; objects must be initialized before the
call, &quot;out&quot; objects must be initialized before function return).

&gt;<i> A 'ref' parameter must not be
</I>&gt;<i> uninitialized in the calling context when it is passed to the function, but
</I>&gt;<i> it may be initialized to 'null'.
</I>
See above.  I'm referring to the pointer itself, not what the pointer
refers to.  The pointer *cannot* be null in C#, but what the pointer
refers to certainly can be null.

&gt;<i>  'null' is not an uninitialized value, it
</I>&gt;<i> is explicit initialization to a null reference. If 'null' cannot be passed
</I>&gt;<i> for a 'ref object' parameter, then '0' cannot be passed for a 'ref int'
</I>&gt;<i> parameter :-)
</I>
And, actually, 0 cannot be passed for a `ref int' parameter:

	static void Foo (ref int n) {}
	static void Main () {
		Foo (0);
	}

Under mcs, I get:

	error CS1503: Argument 0: Cannot convert from 'int' to 'ref int&amp;'

The same should be true for `ref object' and `null'.

See above: `ref' and `out' mean `pointer' at the IL level, and the
`pointer' must be non-null and refer to a modifiable object.

&gt;<i> Remember that the reference that 'ref' refers to is a
</I>&gt;<i> reference to the variable in the calling context, and not to the object to
</I>&gt;<i> which that variable refers. Whew, too many 'ref's in that sentence :-)
</I>
Which is why you introduce new terminology, to clear up the sentence. 
Hopefully I've cleared things up, though comparing things to C++ might
not actually clear things up. :-)

&gt;<i> An 'object' can be checked for a boxed value type with the 'is' operator.
</I>&gt;<i> However, it isn't possible to restrict the type of the object that may be
</I>&gt;<i> boxed for a given call, not in C# or CIL, because it's impossible to tell
</I>&gt;<i> what an 'object' reference variable will refer to at compile time. 
</I>
Indeed, but CIL does permit you to say &quot;this is a managed pointer to
&lt;some type/&gt;, which could be null&quot;.  For example, managed C++ permits
you to pass a boxed int directly to a function, and have the function
accept a boxed int.

What actually happens in Managed C++ is that you can get a managed
pointer *into* a boxed int.  Syntax is similar to (from memory):

	void Foo (int __gc* n);
	int n = 42;
	System::Object __gc* o = &amp;n;
	// this might need a different cast syntax; i can't remember
	int __gc* pn = (int __gc*) o;
	Foo (pn);

The neat thing is that Managed C++ allows you to refer to the the
integer *inside* the boxed integer, allowing cool things like that.  CIL
permits it as well, but C# has no syntax to expose the functionality.

Remember, CIL embodies the union of all (well, many) language features. 
Not all languages support all features, though, so we have the CTS which
defines a common subset of CIL which all languages should support.  For
example, CIL permits module-level functions (functions outside of a
class), which is useful for C++, but C# couldn't consume them.

&gt;<i> That
</I>&gt;<i> said, the function can always complain at runtime, which is about as good
</I>&gt;<i> as it gets.
</I>
Indeed.  For C#.

&lt;snip/&gt;

 - Jon



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004169.html">[Mono-devel-list] Performance w/ boxing
</A></li>
	<LI>Next message: <A HREF="004184.html">[Mono-devel-list] Performance w/ boxing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4181">[ date ]</a>
              <a href="thread.html#4181">[ thread ]</a>
              <a href="subject.html#4181">[ subject ]</a>
              <a href="author.html#4181">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
