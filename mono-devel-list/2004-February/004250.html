<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [PATCH] String speedup
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20String%20speedup&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004249.html">
   <LINK REL="Next"  HREF="004251.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [PATCH] String speedup</H1>
    <B>Ben Maurer</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20String%20speedup&In-Reply-To="
       TITLE="[Mono-devel-list] [PATCH] String speedup">05mauben at hawken.edu
       </A><BR>
    <I>Tue Feb 24 13:32:40 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="004249.html">[Mono-devel-list] AMD64 support patch (interpreter).
</A></li>
        <LI>Next message: <A HREF="004251.html">[Mono-devel-list] [PATCH] String speedup
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4250">[ date ]</a>
              <a href="thread.html#4250">[ thread ]</a>
              <a href="subject.html#4250">[ subject ]</a>
              <a href="author.html#4250">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hrm, i guess I tried too hard :-).

Even though your new version beats the ICall in most cases, I'd really like to see a cheaper way to make the call to memcpy and other such methods.

I was talking with Miguel about this and he suggested working around the exception handling helpers.

Last night, I told the JIT not to make a wrapper for CPBLK. I instantly got a huge perf boost. However, I dont think we can do it for cpblk out of correctness (what if you try to copy 10 bytes from NULL to NULL, what would happen to the exception without the unwind info?)

However, for internal calls, we can make some assumptions about the validity of memory. What I was thinking was to provide the following methods to the framework:

System.Buffer:
internal void memcpy (void* src, void* dest, int cb);
internal void memmove (void* src, void* dest, int cb);

It would the be caller's responsibility to ensure that the said methods were only passed valid addresses with a valid count.

In the jit, we would just implement these as direct calls to the glibc functions. Since there are no exceptions, it would be just as fast as doing the call from C code.

Thus, we get the benefit of the tuned-to-death memcpy et al while not having the overhead of an ICall.

I remember a MS blogger writing about something similar in their framework. They had two calling conventions, one that created a stub (much like today's icall interface) and one that did a direct call.

-- Ben

&gt;&gt;&gt;<i> Paolo Molaro &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>&gt; 02/24/04 12:12 PM &gt;&gt;&gt;
</I>
On 02/23/04 Ben Maurer wrote:
&gt;<i> This tests the speed of copying strings of various lengths. On my box, the results were:
</I>&gt;<i> Length + Before ---+ After ---+
</I>&gt;<i>    2   |   .388 s  |   .273 s |
</I>&gt;<i>    5   |   .426 s  |   .436 s |
</I>&gt;<i>    8   |   .419 s  |   .421 s |
</I>[...]
&gt;<i>   47   |   .536 s  |   .937 s |
</I>&gt;<i> -------+-----------+----------+
</I>&gt;<i> 
</I>&gt;<i> My implementation of memcpy/memove is attached, with a little test driver.
</I>&gt;<i> 
</I>&gt;<i> So, it looks like right now, after len 2 strings, the cost of the icall
</I>&gt;<i> becomes lower than the benefit of memcpy.
</I>
What about a different explanation? Because to me it looks like that
with a crippled memcpy managed implementation you can get as bad results 
as you want. Attached a first cut that doesn't try to optimize away the
unaligned accesses. It beats the icall on my system until about 50-55
and is about 10% slower with lengths between 80-100 (and 10% is
definitely within the improvements we can gain in the jit). Also note
that it takes 3 80-char copies with the icall to gain back the time lost
with a single 10-char copy. Note it doesn't handle overlap, so I'm not
going to commit it: the few calls in stringbuilder that do need overlap
should be changed to call another function so the common case is handled
faster. I had hoped you would do that, but it looks like you wanted to
show how to write orrible and slow code instead.

&gt;<i> One other thought I had was somehow using the CPBLK instruction. We
</I>&gt;<i> could make method that was transformed into CPBLK by the jit. This way,
</I>&gt;<i> we just have to optimize that opcode. Note, that Mono runs the CPBLK
</I>&gt;<i> bench mark 3x slower than MS does, so we may have to do some work. Also,
</I>
Trivially optimized with about 5 lines of C code. Anyone out there who
wants to start some jit hacking? No asm knowledge required, the results
should look something like:
Old:
$ mono -O=all,-intrins benchmark/bulkcpy.exe
Elapsed : 4046 ms.
New:
$ mono -O=all benchmark/bulkcpy.exe
Elapsed : 1359 ms.

On 02/23/04 Ben Maurer wrote:
&gt;<i> Some greping shows that the old JIT had code generation for CPBLK, and
</I>&gt;<i> it looked pretty fast. Maybe we can port that over?
</I>
Nope. Well, you're free to spend your time porting it, maybe you'll
learn something. Once you have ported it we'll show you why it is not
needed.

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better
_______________________________________________
Mono-devel-list mailing list
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004249.html">[Mono-devel-list] AMD64 support patch (interpreter).
</A></li>
	<LI>Next message: <A HREF="004251.html">[Mono-devel-list] [PATCH] String speedup
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4250">[ date ]</a>
              <a href="thread.html#4250">[ thread ]</a>
              <a href="subject.html#4250">[ subject ]</a>
              <a href="author.html#4250">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
