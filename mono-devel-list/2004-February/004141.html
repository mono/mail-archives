<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Thread safety of readonly data members?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Thread%20safety%20of%20readonly%20data%20members%3F&In-Reply-To=40341037.9030204%40zeroc.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004140.html">
   <LINK REL="Next"  HREF="004142.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Thread safety of readonly data members?</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Thread%20safety%20of%20readonly%20data%20members%3F&In-Reply-To=40341037.9030204%40zeroc.com"
       TITLE="[Mono-devel-list] Thread safety of readonly data members?">jonpryor at vt.edu
       </A><BR>
    <I>Thu Feb 19 06:52:24 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="004140.html">[Mono-devel-list] Thread safety of readonly data members?
</A></li>
        <LI>Next message: <A HREF="004142.html">[Mono-devel-list] Performance w/ boxing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4141">[ date ]</a>
              <a href="thread.html#4141">[ thread ]</a>
              <a href="subject.html#4141">[ subject ]</a>
              <a href="author.html#4141">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Below...

On Wed, 2004-02-18 at 20:24, Michi Henning wrote:

&lt;snip/&gt;

&gt;<i> Hmmm... It's not uncommon for one thread to hold a pointer to a stack-
</I>&gt;<i> allocated variable in another thread, so I guess the problem could
</I>&gt;<i> arise in that case.
</I>
I've never seen this, and consider it an bizarre idea.  The whole point
of having stack-allocated objects is so that you *don't* have to
lock/share them.  Plus, I'd expect that you'd have difficulties ensuring
the the stack-allocated object lives long enough for the other thread to
*not* corrupt memory when the function exits scope...

&lt;snip/&gt;

&gt;<i> If Thread 2 previously has read a variable on the heap and
</I>&gt;<i> the cache line containing that variable also happens to contain
</I>&gt;<i> the instance of Class1, Thread 2 can read a stale value of _val
</I>&gt;<i> when it calls getVal(), no?
</I>
Answer: no.  I would suggest you pick up a book on hardware
architecture.  I used &quot;Parallel Computer Architecture: A
Hardware/Software Approach&quot; by David E. Culler and Jaswinder Pal Singh
in my Computer Architecture classes.  I won't call it wonderful (the
index is lacking in some ways), but it's thorough.

There are several ways for the hardware to ensure that stale values
don't remain within the cache lines, including:
  - Bus Snooping
  - Three-State MSI (Modified, Shared, Invalid) Write-Back Invalidation 
    Protocol
  - Four-State MESI (Modified, Exclusive-Clean, Shared, Invalid)
    Write-Back Invalidation Protocol, which is used by all Pentium-Pro
    and above Intel processors.

The hardware is designed to help you with cache coherence.  The scenario
you're describing SHOULD NOT happen.

What you do need to worry about is that you have memory barriers when
you want them.  It was my understanding that reading/writing to volatile
memory was a way of inserting memory barriers in C++.

&lt;snip/&gt;

&gt;<i> I've never been comfortable with the semantics of volatile. I agree,
</I>&gt;<i> things should work correctly if something is marked as volatile,
</I>&gt;<i> but I'm not sure the C++ standard actually guarantees that a memory
</I>&gt;<i> barrier will be placed around a volatile access by the compiler.
</I>&gt;<i> I think all that volatile guarantees is that memory will be read
</I>&gt;<i> on access, so things will work correctly, for example, for memory-
</I>&gt;<i> mapped registers. But I'm not sure that volatile guarantees memory
</I>&gt;<i> consistency.
</I>
I don't think C++ provides any other mechanism within the standard.

Then again, C++ wasn't originally designed for a threaded environment,
and I keep reading articles implying that the next major version (C++
0x) will have additional features for threading, though they may just be
referring to the boost::threading libraries.

&gt;<i> And, of course, in C#, there is no volatile keyword, so I guess
</I>&gt;<i> I still have to use a hard lock.
</I>
I see you answered this yourself already.

&lt;snip/&gt;

&gt;<i> Hmmm... Doesn't the language spec say that things will be initialized
</I>&gt;<i> some time before they are accessed, but not necessarily on program
</I>&gt;<i> startup? If the compiler generates code to do lazy initialization, I
</I>&gt;<i> think things could still go wrong?
</I>
What the runtime does is out of our (the programmers) hands.  So if the
runtime does the wrong thing, it's a runtime bug.  The programmer needs
some assurance that const members will actually be initialized before
first use, or it's *impossible* to do *anything* reliably.

The runtime *must* ensure that const members are initialized in a
thread-safe manner, so that programs can't see the value change.

&lt;snip/&gt;

&gt;<i> Sure, but I'm not concerned about accessing the instance before it is
</I>&gt;<i> constructed, but about accessing the contents of the instance after
</I>&gt;<i> construction without holding a lock. In that case, I don't think the
</I>&gt;<i> hardware can know that I might possibly be reading stale memory.
</I>
The hardware can know, as I alluded to above.

 - Jon



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004140.html">[Mono-devel-list] Thread safety of readonly data members?
</A></li>
	<LI>Next message: <A HREF="004142.html">[Mono-devel-list] Performance w/ boxing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4141">[ date ]</a>
              <a href="thread.html#4141">[ thread ]</a>
              <a href="subject.html#4141">[ subject ]</a>
              <a href="author.html#4141">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
