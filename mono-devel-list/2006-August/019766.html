<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Keep-alive connection with Remoting?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Keep-alive%20connection%20with%20Remoting%3F&In-Reply-To=dd99b8c80608100718y4d70355eh40430b19d61e4d91%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019756.html">
   <LINK REL="Next"  HREF="019761.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Keep-alive connection with Remoting?</H1>
    <B>Ympostor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Keep-alive%20connection%20with%20Remoting%3F&In-Reply-To=dd99b8c80608100718y4d70355eh40430b19d61e4d91%40mail.gmail.com"
       TITLE="[Mono-dev] Keep-alive connection with Remoting?">Ympostor at clix.pt
       </A><BR>
    <I>Thu Aug 10 17:30:27 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="019756.html">[Mono-dev] Keep-alive connection with Remoting?
</A></li>
        <LI>Next message: <A HREF="019761.html">[Mono-dev] Keep-alive connection with Remoting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19766">[ date ]</a>
              <a href="thread.html#19766">[ thread ]</a>
              <a href="subject.html#19766">[ subject ]</a>
              <a href="author.html#19766">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I have misplaced my last message on the thread, so I will re-send it
with the correct quotes (sorry) and include some more info:

Rafael Teixeira wrote:
&gt;<i> inline
</I>&gt;&gt;<i> - If I had to deal with scalability issues, how could I use a not
</I>&gt;&gt;<i> long-living service without loosing the connection with the clients?
</I>&gt;<i> 
</I>&gt;<i> It all depends on the frequency with which your clients make requests
</I>&gt;<i> to the server, if they space it in the tenths of second, you probably
</I>&gt;<i> can easily pay the price of reconnecting each time.
</I>&gt;<i> 
</I>&gt;&gt;<i> I am thinking of ordering them to disconnect and reconnect again but,
</I>&gt;&gt;<i> wouldn't this consume so many resources and processor cycles (and time
</I>&gt;&gt;<i> in which the server is not available for incoming connections) if we are
</I>&gt;&gt;<i> treating with ~1000 clients...?
</I>&gt;<i> 
</I>&gt;&gt;<i>From my experience disconnecting and reconnecting means that ~1000
</I>&gt;<i> clients can be served by a Pentium 3 recycling just some 100-200
</I>&gt;<i> connections (TCP/IP open sockets), with acceptable performance except
</I>&gt;<i> if all of then want to download/upload megabytes of data at the same
</I>&gt;<i> time.
</I>&gt;<i> 
</I>&gt;<i> I've experienced (on Windows 2003 Server running IIS 6, to be clear),
</I>&gt;<i> good performance (in truth the bottleneck was the database) recycling
</I>&gt;<i> 380 connections on Dual Zeons for some 30000 simultaneous clients.
</I>&gt;<i> 
</I>&gt;<i> Trying to keep 30000 open TCP connections is something you simply
</I>&gt;<i> can't do with affordable hardware, no matter the framework/language
</I>&gt;<i> you use.
</I>
Very interesting numbers; but I think I am considering a &quot;clustered&quot;
solution similar to the one proposed by Brian.

Anyway, I think I will give up with the Reachability library, it seems
very unstable and I have found out that it's much slower than the
original solution proposed by Ingo Rammer; so I am testing it, I have
specified the same clientProviders/serverProviders parameters so as to
make it work with FW2.0 and now I get a weird behaviour: if I try the
demo between client and servers on the local machine, it works
perfectly, but if I place the client on other machine (changing the URL
of the server in the config file, of course), I get:

Called main thread 'MainThread'
---- Testing sync calls / SAO ----
Registered connection #0 as 172.16.0.43:9999. Count: 1
Registered connection #0 as bc305056-1a3c-4a4f-9d9a-5889713d8325. Count: 2
OUTGOING to 172.16.0.70:4259 --&gt; 172.16.0.43:9999
Got sync result: Testing
---- Testing sync calls / CAO ----
Closing connection #0 to 172.16.0.43:9999
Unregistered connection #0 as bc305056-1a3c-4a4f-9d9a-5889713d8325. Count: 1
Unregistered connection #0 as 172.16.0.43:9999 . Count: 0

Unhandled Exception:
System.Runtime.Serialization.SerializationException: Binary
  stream '0' does not contain a valid BinaryHeader. Possible causes are
invalid stream or object version change between serialization and
deserialization.

Server stack trace:
    at System.Runtime.Serialization.Formatters.Binary.__BinaryParser.Run()
    at
System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize(He
aderHandler handler, __BinaryParser serParser, Boolean fCheck, Boolean
isCrossAppDomain, IMethodCallMessage methodCallMessage)
    at
System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize
(Stream serializationStream, HeaderHandler handler, Boolean fCheck,
Boolean isCrossAppDomain, IMethodCallMessage methodCallMessage)
    at
System.Runtime.Remoting.Channels.CoreChannel.DeserializeBinaryResponseMess
age(Stream inputStream, IMethodCallMessage reqMsg, Boolean bStrictBinding)
    at
System.Runtime.Remoting.Channels.BinaryClientFormatterSink.SyncProcessMess
age(IMessage msg)

Exception rethrown at [0]:
    at
System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage
reqMsg, IMessage retMsg)
    at
System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp;
msgData, Int32 type)
    at
System.Runtime.Remoting.Activation.IActivator.Activate(IConstructionCallMe
ssage msg)
    at
System.Runtime.Remoting.Activation.LocalActivator.DoRemoteActivation
(IConstructionCallMessage ctorMsg)
    at
System.Runtime.Remoting.Activation.LocalActivator.Activate(IConstructionCa
llMessage ctorMsg)
    at
System.Runtime.Remoting.Activation.AppDomainLevelActivator.Activate
(IConstructionCallMessage ctorMsg)
    at
System.Runtime.Remoting.Messaging.ClientContextTerminatorSink.SyncProcessM
essage(IMessage reqMsg)
    at System.Runtime.Remoting.Activation.ActivationServices.Activate
(RemotingProxy remProxy, IConstructionCallMessage ctorMsg)
    at System.Runtime.Remoting.Proxies.RemotingProxy.Invoke(IMessage reqMsg)
    at
System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp;
msgData, Int32 type)
    at Service.SomeCAO..ctor()
    at Client.Client.Main(String[] args) in C:\Documents and
Settings\Ympostor\Desktop\Software\BidirectionalTCPChannel\BidirectionalTCPChannel\TestClient\Clien
t.cs:line 70

Which seems a very strange problem because both machines are running the
same runtime.

I have found yet another solution for bidirectional remoting:

<A HREF="http://g2.fit.qut.edu.au/G2/HomePage/G2P2P/Utilities/TcpExChannel.html">http://g2.fit.qut.edu.au/G2/HomePage/G2P2P/Utilities/TcpExChannel.html</A>

The thing I am afraid about this one (I haven't tried it out) is that it
lacks also 2.0 support (which could lead me to more exceptions, as well
as is happening with the one from Ingo) and that it seems to have some bugs:

<A HREF="http://www.gotdotnet.com/Community/UserSamples/Details.aspx?SampleGuid=3F46C102-9970-48B1-9225-8758C38905B1">http://www.gotdotnet.com/Community/UserSamples/Details.aspx?SampleGuid=3F46C102-9970-48B1-9225-8758C38905B1</A>

(Although they seem to be corrected as stated on the &quot;Updates&quot; paragraph
of the first link.)


&gt;&gt;<i> However, my main concern now is to make it work and then lately solve
</I>&gt;&gt;<i> any scalability issues. And then, my update about the progress, if
</I>&gt;&gt;<i> anyone is interested:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As I said, I already changed the sources to 2.0 API and to work with
</I>&gt;&gt;<i> long-living connections, but now I am stuck with a very stupid problem:
</I>&gt;&gt;<i> I just want to implement a similar method to &quot;SendMessage&quot; but that
</I>&gt;&gt;<i> sends a file to the client, but I don't know why it works only sometimes:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - In the same host, one client and one server, it works (the file is
</I>&gt;&gt;<i> received).
</I>&gt;&gt;<i> - Same host, two clients and one server, one client receives the file
</I>&gt;&gt;<i> and the other client receives the first notification but doesn't end the
</I>&gt;&gt;<i> method to save the file. :?
</I>&gt;<i> 
</I>&gt;<i> Looks like some timeout in the request processing for the second
</I>&gt;<i> thread, as some I/O contention or locks in your code, may preclude
</I>&gt;<i> processing to occur in parallel at least with good performance.
</I>&gt;<i> 
</I>&gt;<i> Avoid synchrionization locks, and if I/O is really time consuming
</I>&gt;<i> adjust the timeouts for conclusion of each request processing.
</I>&gt;<i> 
</I>&gt;&gt;<i> - Host A with server, host B with client. If I send a normal message the
</I>&gt;&gt;<i> communication works, but if I try to send the file, there is no
</I>&gt;&gt;<i> communication. :?
</I>&gt;<i> 
</I>&gt;<i> Having no code to look at I can't verify what may be happening. How
</I>&gt;<i> are you returning the file? as byte array (byte[])? that may mean that
</I>&gt;<i> you have to read it entirely in memory and send it as a whole in the
</I>&gt;<i> remoting channel, performance would be terrible for big files (&gt; 8 K)
</I>&gt;<i> and so the request timeouts would stompit.
</I>&gt;<i> 
</I>&gt;<i> For large files transfer , the best solution is to send them on a
</I>&gt;<i> dedicated (separate) socket, using a buffered stream to read the file
</I>&gt;<i> and another to write in the socket (that is what MSN Messenger and
</I>&gt;<i> similar programs do),
</I>&gt;<i> 
</I>&gt;<i> But if you really don't wan't to escape out of remoting at least use a
</I>&gt;<i> blocked approach:
</I>&gt;<i> 
</I>&gt;<i> class MyMarshallByRefObject : MarshallByRefObject {
</I>&gt;<i> 
</I>&gt;<i> ...
</I>&gt;<i> 
</I>&gt;<i> public int StartDownload (string filename) // returns a transfer ID
</I>&gt;<i> 
</I>&gt;<i> public byte[] ReadBlock(int transferID) // returns fixed size or limited blocks
</I>&gt;<i> 
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> in the client
</I>&gt;<i> 
</I>&gt;<i> MyMarshallByRefObject x = CreateIt(...);
</I>&gt;<i> int myTransfer = x.StartDownload(&quot;somefile&quot;);
</I>&gt;<i> while (true) {
</I>&gt;<i>     byte[] buffer = x.ReadBlock(myTransfer);
</I>&gt;<i>     if (buffer == null)
</I>&gt;<i>         exit;
</I>&gt;<i>     processBlock(buffer); // may write to some file
</I>&gt;<i>          // this time spent processing each buffer received
</I>&gt;<i>          // may give time for other clients to be serviced
</I>&gt;<i> }
</I>

Many thanks about this advice for sending the file. I know that
sending the whole file in a single call would be terrific for large
files, but I just wanted to do the proof of concept (in fact, locally,
it worked perfectly for 8MB files!, remotelly it wouldn't receive the
call at all, and no time-outs were involved because I was making the
call just after launching the server and the client).

Regards.

-- 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019756.html">[Mono-dev] Keep-alive connection with Remoting?
</A></li>
	<LI>Next message: <A HREF="019761.html">[Mono-dev] Keep-alive connection with Remoting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19766">[ date ]</a>
              <a href="thread.html#19766">[ thread ]</a>
              <a href="subject.html#19766">[ subject ]</a>
              <a href="author.html#19766">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
