<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] CIL to CIL optimizer
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20CIL%20to%20CIL%20optimizer&In-Reply-To=44E0B561.4080008%40imf.au.dk">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019829.html">
   <LINK REL="Next"  HREF="019840.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] CIL to CIL optimizer</H1>
    <B>Massimiliano Mantione</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20CIL%20to%20CIL%20optimizer&In-Reply-To=44E0B561.4080008%40imf.au.dk"
       TITLE="[Mono-dev] CIL to CIL optimizer">massi at ximian.com
       </A><BR>
    <I>Mon Aug 14 17:30:08 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="019829.html">[Mono-dev] CIL to CIL optimizer
</A></li>
        <LI>Next message: <A HREF="019840.html">[Mono-dev] CIL to CIL optimizer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19838">[ date ]</a>
              <a href="thread.html#19838">[ thread ]</a>
              <a href="subject.html#19838">[ subject ]</a>
              <a href="author.html#19838">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Again, first thing first: I am replying just to share knowledge,
as you said, both a CCO and an optimizing JIT have their place
in the world...

On Mon, 2006-08-14 at 19:39 +0200, Bjarke Hammersholt Roune wrote:
&gt;<i> 3. A CCO can decrease the size of an assembly by such optimizations as 
</I>&gt;<i> dead code/function/class elimination (the last two only in the absence 
</I>&gt;<i> of reflection), better use of the stack, better instruction selection, 
</I>&gt;<i> redundancy elimination, better ordering of basic blocks and so on. This 
</I>&gt;<i> decreases start up time.
</I>
I'd like to understand better what you mean by &quot;class elimination&quot;
(I guess &quot;function elimination&quot; menas &quot;inline&quot;...)?
And also, what does &quot;instruction selection&quot; mean at CIL level?

&gt;<i> 5. Some optimizations, like dead code elimination, can be done in a CCO 
</I>&gt;<i> and then the JIT does not have to do them (or does not have to do them 
</I>&gt;<i> as much). The CCO could embed some metadata in the assembly to indicate 
</I>&gt;<i> which optimizations have already been performed. The same trick applies 
</I>&gt;<i> to the results of expensive analyzes, though relying on that information 
</I>&gt;<i> without checking it could be unsafe.
</I>
The problem is that most optimizations should be run anyway, see
below...

&gt;<i> 6. A CCO can output data that enables the JIT to start up faster and 
</I>&gt;<i> optimize better. An example is SafeTSA which is a Java-equivalent 
</I>&gt;<i> bytecode format where the code is already in SSA form and where some 
</I>&gt;<i> array bounds checks and some null checks can be safely eliminated. On 
</I>&gt;<i> top of this the SafeTSA format actually takes up less space then the 
</I>&gt;<i> normal Java bytecode format. Another example is a paper I read that 
</I>&gt;<i> explained how to annotate Java bytecode so that the JIT could do fast 
</I>&gt;<i> and high quality register allocation in little time. This scheme is, 
</I>&gt;<i> surprisingly, independent of the number of registers on the target machine.
</I>
Now *this* is interesting, and has been in my wild dreams for a while...
but it'll have to wait until what is *really* needed in the JIT is done.
I was especially thinking of doing some kind of global, interprocedural
analysis with a sort of CCO which would not really change the code, just
write some custom attributes that tell the JIT interesting things like
&quot;this method is free of side effects&quot;, or &quot;this method only modifies the
'this' object&quot;, or &quot;const&quot; annotations, or similar things.


&gt;<i> I cannot foresee how problematical the natural barrier to optimization 
</I>&gt;<i> in a CCO that Miguel mentions will be. It is certainly there in the 
</I>&gt;<i> sense that a JIT can do more optimization than a CCO if it had all the 
</I>&gt;<i> time in the world. I guess I will have to write a CCO and see what 
</I>&gt;<i> happens to find out.
</I>
This is probably the most interesting topic.
I give you some examples of things that a CCO cannot do as effectively
as a JIT, so the JIT must (well, should...) do them anyway.
[1] Dead code elimination: some code is generated internally by the
    JIT, so the CCO cannot even see it. This is particularly true with
    inlining (unless you also do inlining in the CCO itself, which is
    tricky because it is likely to break things like tracing, debugging
    and AOP frameworks).
[2] Redundancy elimination: again, some code sequences are totally
    invisible in CIL (array element and field address computations, or
    locals initializations, and, if we get smart, vtable accesses...).
    Moreover, redundancy elimination is really tricky to get right, and
    it can easily turn into an arch dependent issue.
    I have been badly burnt by the SSAPRE experience in the JIT about
    this: on paper, PRE is always a win, and my SSAPRE implementation
    does nothing else than removing redundancies, yet it can *easily*
    make the code *worse* :-(
    The problem is that sometimes storage (especially registers!) is
    more valuable than computational CPU cycles, so PRE is a tradeoff,
    and you must get it right on each architecture...
[3] Well, this is really minor, but there are cases when something is
    constant at JIT time, but it was not before, so also SCCP must be
    done again in the JIT.
I'm sure that thinking long enough one could find more examples, but
these should be enough to give you an idea of the issues.
And of course advanced things like register promotion require that you
have a strong optimization framework already, and they can be only in
the JIT...


&gt;<i> &gt; Then, about the CFG shape and issues when try[/catch]/finally clauses
</I>&gt;<i> &gt; are present, this discussion already reached mono-devel-list:
</I>&gt;<i> &gt; <A HREF="http://marc.theaimsgroup.com/?l=mono-devel-list&amp;m=111336503228737&amp;w=2">http://marc.theaimsgroup.com/?l=mono-devel-list&amp;m=111336503228737&amp;w=2</A>
</I>&gt;<i> &gt; I'd really like you to comment on that thread.
</I>&gt;<i> &gt; 
</I>&gt;<i> I think that discussion is a good example of how the different 
</I>&gt;<i> constraints on JITs and CCOs play out.
</I>
Yep!
Now I see why I had so many problems &quot;seeing&quot; your example :-)
BTW, it's hard for me to comment on it specifically because is seems
to show a JIT bug :-(

Anyway in general I'm skeptical about &quot;omnicomprehensive&quot; approaches
like the one you describe, not because they are not feasible, but
because I have the impression that they are not worth the effort.
I mean, when the control flow reaches the catch/finally, you do not
know the specific path it took to get there, so even in the perfect
case you will have very &quot;large&quot; phi functions where you cannot know
which of the arguments is the &quot;right&quot; one (because statically none
of them is &quot;right&quot;), so you cannot make inferences on the phi value.
In the end, having a dummy store statement instead of the phi is the
same thing IMHO, but cheaper.

&gt;<i> As a practical matter, I also think that it will take less effort to
</I>&gt;<i> implement optimizations in ML than in C. On a personal note I have been
</I>&gt;<i> programming a Groebner Basis computation program for quite a while in 
</I>&gt;<i> C++, and I am looking forward to programming in a functional-style 
</I>&gt;<i> language again.
</I>
Yep, but, as a practical matter, the runtime is written in C for
good reasons, and the JIT is part of it... even if I perfectly see
that other languages are *much* more productive and elegant!

Ciao,
  Massi



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019829.html">[Mono-dev] CIL to CIL optimizer
</A></li>
	<LI>Next message: <A HREF="019840.html">[Mono-dev] CIL to CIL optimizer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19838">[ date ]</a>
              <a href="thread.html#19838">[ thread ]</a>
              <a href="subject.html#19838">[ subject ]</a>
              <a href="author.html#19838">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
