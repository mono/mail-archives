<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Keep-alive connection with Remoting?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Keep-alive%20connection%20with%20Remoting%3F&In-Reply-To=44DB34E3.6030309%40clix.pt">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019752.html">
   <LINK REL="Next"  HREF="019756.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Keep-alive connection with Remoting?</H1>
    <B>Rafael Teixeira</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Keep-alive%20connection%20with%20Remoting%3F&In-Reply-To=44DB34E3.6030309%40clix.pt"
       TITLE="[Mono-dev] Keep-alive connection with Remoting?">monoman at gmail.com
       </A><BR>
    <I>Thu Aug 10 10:18:08 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="019752.html">[Mono-dev] Keep-alive connection with Remoting?
</A></li>
        <LI>Next message: <A HREF="019756.html">[Mono-dev] Keep-alive connection with Remoting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19755">[ date ]</a>
              <a href="thread.html#19755">[ thread ]</a>
              <a href="subject.html#19755">[ subject ]</a>
              <a href="author.html#19755">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>inline

On 8/10/06, Ympostor &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ympostor at clix.pt</A>&gt; wrote:
&gt;<i> Rafael Teixeira wrote:
</I>&gt;<i> &gt; You have to choose the server state-model and configure the Lifetime
</I>&gt;<i> &gt; policy in the server. The default even for the singleton state-model
</I>&gt;<i> &gt; is to kill the server object after a few minutes and recreate on the
</I>&gt;<i> &gt; next request from the client.
</I>&gt;<i>
</I>&gt;<i> Thanks for the guidance. I said that I had overriden the LifeTimeService
</I>&gt;<i> method in the clients. I made it on the server with no luck, but after
</I>&gt;<i> that I realised that I had to do it also on the MarshalByRefObject
</I>&gt;<i> object used in the Reachability sources, then all time-out problems
</I>&gt;<i> disappeared.
</I>
Yes that is what I intended to say. All MBROs not to use the default
LifeTimeService.

&gt;<i>
</I>&gt;<i> Really interesting thoughts but I have some questions:
</I>&gt;<i>
</I>&gt;<i> - If long-living service is used, are you saying that its dead objects
</I>&gt;<i> won't never be collected until the service dies for any reason?
</I>
The remoting server will have a reference to the objects and as its
LifeTimeService doesn't say when to release it it will keep it up and
GC won't be able to collect it.

You can overcome this by having some remote finalization method the
client calls, and the MBRO then sinalizes a specialized
LifeTimeService that the server instance can be released.

&gt;<i> - If I had to deal with scalability issues, how could I use a not
</I>&gt;<i> long-living service without loosing the connection with the clients?
</I>
It all depends on the frequency with which your clients make requests
to the server, if they space it in the tenths of second, you probably
can easily pay the price of reconnecting each time.

&gt;<i> I am thinking of ordering them to disconnect and reconnect again but,
</I>&gt;<i> wouldn't this consume so many resources and processor cycles (and time
</I>&gt;<i> in which the server is not available for incoming connections) if we are
</I>&gt;<i> treating with ~1000 clients...?
</I>
&gt;<i>From my experience disconnecting and reconnecting means that ~1000
</I>clients can be served by a Pentium 3 recycling just some 100-200
connections (TCP/IP open sockets), with acceptable performance except
if all of then want to download/upload megabytes of data at the same
time.

I've experienced (on Windows 2003 Server running IIS 6, to be clear),
good performance (in truth the bottleneck was the database) recycling
380 connections on Dual Zeons for some 30000 simultaneous clients.

Trying to keep 30000 open TCP connections is something you simply
can't do with affordable hardware, no matter the framework/language
you use.

&gt;<i> However, my main concern now is to make it work and then lately solve
</I>&gt;<i> any scalability issues. And then, my update about the progress, if
</I>&gt;<i> anyone is interested:
</I>&gt;<i>
</I>&gt;<i> As I said, I already changed the sources to 2.0 API and to work with
</I>&gt;<i> long-living connections, but now I am stuck with a very stupid problem:
</I>&gt;<i> I just want to implement a similar method to &quot;SendMessage&quot; but that
</I>&gt;<i> sends a file to the client, but I don't know why it works only sometimes:
</I>&gt;<i>
</I>&gt;<i> - In the same host, one client and one server, it works (the file is
</I>&gt;<i> received).
</I>&gt;<i> - Same host, two clients and one server, one client receives the file
</I>&gt;<i> and the other client receives the first notification but doesn't end the
</I>&gt;<i> method to save the file. :?
</I>
Looks like some timeout in the request processing for the second
thread, as some I/O contention or locks in your code, may preclude
processing to occur in parallel at least with good performance.

Avoid synchrionization locks, and if I/O is really time consuming
adjust the timeouts for conclusion of each request processing.

&gt;<i> - Host A with server, host B with client. If I send a normal message the
</I>&gt;<i> communication works, but if I try to send the file, there is no
</I>&gt;<i> communication. :?
</I>
Having no code to look at I can't verify what may be happening. How
are you returning the file? as byte array (byte[])? that may mean that
you have to read it entirely in memory and send it as a whole in the
remoting channel, performance would be terrible for big files (&gt; 8 K)
and so the request timeouts would stompit.

For large files transfer , the best solution is to send them on a
dedicated (separate) socket, using a buffered stream to read the file
and another to write in the socket (that is what MSN Messenger and
similar programs do),

But if you really don't wan't to escape out of remoting at least use a
blocked approach:

class MyMarshallByRefObject : MarshallByRefObject {

...

public int StartDownload (string filename) // returns a transfer ID

public byte[] ReadBlock(int transferID) // returns fixed size or limited blocks

}


in the client

MyMarshallByRefObject x = CreateIt(...);
int myTransfer = x.StartDownload(&quot;somefile&quot;);
while (true) {
    byte[] buffer = x.ReadBlock(myTransfer);
    if (buffer == null)
        exit;
    processBlock(buffer); // may write to some file
         // this time spent processing each buffer received
         // may give time for other clients to be serviced
}


Hope it helps,

&gt;<i> I am becoming crazy... Perhaps in the end this is not a very stable
</I>&gt;<i> solution.
</I>&gt;<i>
</I>&gt;<i> BTW I have found two more solutions:
</I>&gt;<i>
</I>&gt;<i> a) PeerChannel [
</I>&gt;<i> <A HREF="http://www.mailframe.net/Products/PeerChannel/default.aspx">http://www.mailframe.net/Products/PeerChannel/default.aspx</A> ]
</I>&gt;<i>
</I>&gt;<i> It seems to be free but:
</I>&gt;<i> - I haven't managed to make it work yet (NullReferenceException thrown
</I>&gt;<i> at the middleware channels, not in the client or server...? perhaps
</I>&gt;<i> again due to 1.1 vs 2.0 problems...).
</I>&gt;<i> - Not all source is attached in the ZIP. There is a
</I>&gt;<i> MailFrameDataStructures.dll that doesn't come with the source!
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> b) DotNetRemoting SDK [ <A HREF="http://www.dotnetremoting.com/">http://www.dotnetremoting.com/</A> ]
</I>&gt;<i>
</I>&gt;<i> Again, commercial, and seems not to be very popular (I have read some
</I>&gt;<i> criticism about this library...).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Regards.
</I>
Hope it helps,

-- 
Rafael &quot;Monoman&quot; Teixeira
---------------------------------------
&quot;The reasonable man adapts himself to the world; the unreasonable one
persists in trying to adapt the world to himself. Therefore all
progress depends on the unreasonable man.&quot; George Bernard Shaw

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019752.html">[Mono-dev] Keep-alive connection with Remoting?
</A></li>
	<LI>Next message: <A HREF="019756.html">[Mono-dev] Keep-alive connection with Remoting?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19755">[ date ]</a>
              <a href="thread.html#19755">[ thread ]</a>
              <a href="subject.html#19755">[ subject ]</a>
              <a href="author.html#19755">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
