<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [Patch] Extern alias (with modifications)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPatch%5D%20Extern%20alias%20%28with%20modifications%29&In-Reply-To=1128552220.23110.10.camel%40localhost.localdomain">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015211.html">
   <LINK REL="Next"  HREF="015210.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [Patch] Extern alias (with modifications)</H1>
    <B>Marek Safar</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPatch%5D%20Extern%20alias%20%28with%20modifications%29&In-Reply-To=1128552220.23110.10.camel%40localhost.localdomain"
       TITLE="[Mono-dev] [Patch] Extern alias (with modifications)">marek.safar at seznam.cz
       </A><BR>
    <I>Thu Oct  6 05:30:16 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="015211.html">[Mono-dev] [Patch] Extern alias (with modifications)
</A></li>
        <LI>Next message: <A HREF="015210.html">[Mono-dev] Mono.Cairo Memory Leak
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15215">[ date ]</a>
              <a href="thread.html#15215">[ thread ]</a>
              <a href="subject.html#15215">[ subject ]</a>
              <a href="author.html#15215">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Carlos,

Do you have tests for this? I am expecially wondering about CS1679, CS1680.

BTW: Hari's comments are very good.

Marek

&gt;<i>Hey,
</I>&gt;<i>
</I>&gt;<i>I applied the corrections made by Hari and all my tests are working
</I>&gt;<i>fine. 
</I>&gt;<i>
</I>&gt;<i>Comments and suggestions are welcome.
</I>&gt;<i>
</I>&gt;<i>Carlos.
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>Index: typemanager.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- typemanager.cs	(revisi&#243;n: 51315)
</I>&gt;<i>+++ typemanager.cs	(copia de trabajo)
</I>&gt;<i>@@ -215,6 +215,8 @@
</I>&gt;<i> 	// &lt;/remarks&gt;
</I>&gt;<i> 	static Assembly [] assemblies;
</I>&gt;<i> 
</I>&gt;<i>+	static Hashtable external_aliases;
</I>&gt;<i>+
</I>&gt;<i> 	// &lt;remarks&gt;
</I>&gt;<i> 	//  Keeps a list of modules. We used this to do lookups
</I>&gt;<i> 	//  on the module using GetType -- needed for arrays
</I>&gt;<i>@@ -278,6 +280,7 @@
</I>&gt;<i> 		// Lets get everything clean so that we can collect before generating code
</I>&gt;<i> 		assemblies = null;
</I>&gt;<i> 		modules = null;
</I>&gt;<i>+		external_aliases = null;
</I>&gt;<i> 		builder_to_declspace = null;
</I>&gt;<i> 		builder_to_member_cache = null;
</I>&gt;<i> 		builder_to_ifaces = null;
</I>&gt;<i>@@ -379,6 +382,7 @@
</I>&gt;<i> 		assemblies = new Assembly [0];
</I>&gt;<i> 		modules = null;
</I>&gt;<i> 		
</I>&gt;<i>+		external_aliases = new Hashtable ();
</I>&gt;<i> 		builder_to_declspace = new PtrHashtable ();
</I>&gt;<i> 		builder_to_member_cache = new PtrHashtable ();
</I>&gt;<i> 		builder_to_method = new PtrHashtable ();
</I>&gt;<i>@@ -504,11 +508,22 @@
</I>&gt;<i> 		assemblies = n;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i>+	public static void AddExternAlias (string alias, Assembly a)
</I>&gt;<i>+	{
</I>&gt;<i>+		// Keep the new as the chosen one
</I>&gt;<i>+		external_aliases [alias] = a;
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i>         public static Assembly [] GetAssemblies ()
</I>&gt;<i>         {
</I>&gt;<i>                 return assemblies;
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i>+	public static Assembly GetExternAlias (string alias)
</I>&gt;<i>+	{
</I>&gt;<i>+		return (Assembly) external_aliases [alias];
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i> 	///  Registers a module builder to lookup types from
</I>&gt;<i> 	/// &lt;/summary&gt;
</I>&gt;<i>@@ -578,60 +593,33 @@
</I>&gt;<i> 		return (Type) ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i>-	public static Type LookupTypeReflection (string name, Location loc)
</I>&gt;<i>+	public static Type LookupTypeInModules (string name)
</I>&gt;<i> 	{
</I>&gt;<i>-		Type found_type = null;
</I>&gt;<i>-
</I>&gt;<i>-		foreach (Assembly a in assemblies) {
</I>&gt;<i>-			Type t = a.GetType (name);
</I>&gt;<i>-			if (t == null)
</I>&gt;<i>-				continue;
</I>&gt;<i>-
</I>&gt;<i>-			if (t.IsPointer)
</I>&gt;<i>-				throw new InternalErrorException (&quot;Use GetPointerType() to get a pointer&quot;);
</I>&gt;<i>-
</I>&gt;<i>-			TypeAttributes ta = t.Attributes &amp; TypeAttributes.VisibilityMask;
</I>&gt;<i>-			if (ta != TypeAttributes.NotPublic &amp;&amp; ta != TypeAttributes.NestedPrivate &amp;&amp;
</I>&gt;<i>-				ta != TypeAttributes.NestedAssembly &amp;&amp; ta != TypeAttributes.NestedFamANDAssem) {
</I>&gt;<i>-				if (found_type == null) {
</I>&gt;<i>-					found_type = t;
</I>&gt;<i>-					continue;
</I>&gt;<i>-				}
</I>&gt;<i>-
</I>&gt;<i>-				Report.SymbolRelatedToPreviousError (found_type);
</I>&gt;<i>-				Report.SymbolRelatedToPreviousError (t);
</I>&gt;<i>-				Report.Error (433, loc, &quot;The imported type `{0}' is defined multiple times&quot;, name);
</I>&gt;<i>-				return found_type;
</I>&gt;<i>-			}
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i> 		foreach (Module mb in modules) {
</I>&gt;<i> 			Type t = mb.GetType (name);
</I>&gt;<i>-			if (t == null)
</I>&gt;<i>-				continue;
</I>&gt;<i>-			
</I>&gt;<i>-			if (found_type == null) {
</I>&gt;<i>-				found_type = t;
</I>&gt;<i>-				continue;
</I>&gt;<i>-			}
</I>&gt;<i>-
</I>&gt;<i>-			Report.SymbolRelatedToPreviousError (t);
</I>&gt;<i>-			Report.SymbolRelatedToPreviousError (found_type);
</I>&gt;<i>-			Report.Warning (436, 2, loc, &quot;Ignoring imported type `{0}' since the current assembly already has a declaration with the same name&quot;,
</I>&gt;<i>-				TypeManager.CSharpName (t));
</I>&gt;<i>-			return t;
</I>&gt;<i>+			if (t != null)
</I>&gt;<i>+				return t;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>-		return found_type;
</I>&gt;<i>+		return null;
</I>&gt;<i> 	}
</I>&gt;<i>+	
</I>&gt;<i>+	//
</I>&gt;<i>+	// We use this for retrieving GetNamespaces method if avalaible
</I>&gt;<i>+	//
</I>&gt;<i>+	static MethodInfo assembly_get_namespaces;
</I>&gt;<i> 
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i> 	///   Computes the namespaces that we import from the assemblies we reference.
</I>&gt;<i> 	/// &lt;/summary&gt;
</I>&gt;<i> 	public static void ComputeNamespaces ()
</I>&gt;<i> 	{
</I>&gt;<i>-		MethodInfo assembly_get_namespaces = typeof (Assembly).GetMethod (&quot;GetNamespaces&quot;, BindingFlags.Instance|BindingFlags.NonPublic);
</I>&gt;<i>+		if (assembly_get_namespaces == null)
</I>&gt;<i>+			assembly_get_namespaces = typeof (Assembly).GetMethod (&quot;GetNamespaces&quot;, BindingFlags.Instance|BindingFlags.NonPublic);
</I>&gt;<i> 
</I>&gt;<i>+		foreach (Assembly assembly in assemblies)
</I>&gt;<i>+			Namespace.Root.AddAssemblyReference (assembly);
</I>&gt;<i>+		
</I>&gt;<i> 		Hashtable cache = null;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i>@@ -682,8 +670,43 @@
</I>&gt;<i> 				cache.Add (ns, null);
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i>+	public static Namespace ComputeNamespacesForAlias (string name)
</I>&gt;<i>+	{
</I>&gt;<i>+		Assembly assembly = (Assembly) external_aliases [name];
</I>&gt;<i>+		if (assembly == null)
</I>&gt;<i>+			return null;
</I>&gt;<i>+		
</I>&gt;<i>+		if (assembly_get_namespaces == null)
</I>&gt;<i>+			assembly_get_namespaces = typeof (Assembly).GetMethod (&quot;GetNamespaces&quot;, BindingFlags.Instance|BindingFlags.NonPublic);
</I>&gt;<i>+		
</I>&gt;<i>+		Namespace retval = Namespace.DefineRootNamespace (name, assembly);
</I>&gt;<i>+		if (assembly_get_namespaces != null) {
</I>&gt;<i>+			string [] namespaces = (string []) assembly_get_namespaces.Invoke (assembly, null);
</I>&gt;<i>+			foreach (string ns in namespaces) {
</I>&gt;<i>+				if (ns.Length == 0)
</I>&gt;<i>+					continue;
</I>&gt;<i>+				
</I>&gt;<i>+				retval.GetNamespace (ns, true);
</I>&gt;<i>+			}
</I>&gt;<i>+		} else {
</I>&gt;<i>+			Hashtable alias_cache = new Hashtable ();
</I>&gt;<i>+			alias_cache.Add (&quot;&quot;, null);
</I>&gt;<i>+			foreach (Type t in assembly.GetExportedTypes ()) {
</I>&gt;<i>+				string ns = t.Namespace;
</I>&gt;<i>+				if (ns == null || alias_cache.Contains (ns))
</I>&gt;<i>+					continue;
</I>&gt;<i>+
</I>&gt;<i>+				retval.GetNamespace (ns, true);
</I>&gt;<i>+				alias_cache.Add (ns, null);
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		return retval;
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i> 	/// Fills static table with exported types from all referenced assemblies.
</I>&gt;<i> 	/// This information is required for CLS Compliance tests.
</I>&gt;<i>Index: namespace.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- namespace.cs	(revisi&#243;n: 51315)
</I>&gt;<i>+++ namespace.cs	(copia de trabajo)
</I>&gt;<i>@@ -9,9 +9,101 @@
</I>&gt;<i> using System;
</I>&gt;<i> using System.Collections;
</I>&gt;<i> using System.Collections.Specialized;
</I>&gt;<i>+using System.Reflection;
</I>&gt;<i> 
</I>&gt;<i> namespace Mono.CSharp {
</I>&gt;<i> 
</I>&gt;<i>+	public class RootNamespace : Namespace
</I>&gt;<i>+	{
</I>&gt;<i>+		Assembly referenced_assembly;
</I>&gt;<i>+
</I>&gt;<i>+		public RootNamespace (Assembly assembly) : base (null, String.Empty)
</I>&gt;<i>+		{
</I>&gt;<i>+			this.referenced_assembly = assembly;
</I>&gt;<i>+			this.root = this;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public virtual Type LookupTypeReflection (string name, Location loc)
</I>&gt;<i>+		{
</I>&gt;<i>+			Console.WriteLine (&quot;Looking for type = {0} in assembly = {1}&quot;, name, referenced_assembly.FullName);
</I>&gt;<i>+			Type t = referenced_assembly.GetType (name);
</I>&gt;<i>+			if (t == null)
</I>&gt;<i>+				return null;
</I>&gt;<i>+
</I>&gt;<i>+			if (t.IsPointer)
</I>&gt;<i>+				throw new InternalErrorException (&quot;Use GetPointerType() to get a pointer&quot;);
</I>&gt;<i>+			
</I>&gt;<i>+			TypeAttributes ta = t.Attributes &amp; TypeAttributes.VisibilityMask;
</I>&gt;<i>+			if (ta != TypeAttributes.NotPublic &amp;&amp; ta != TypeAttributes.NestedPrivate &amp;&amp;
</I>&gt;<i>+					ta != TypeAttributes.NestedAssembly &amp;&amp; ta != TypeAttributes.NestedFamANDAssem)
</I>&gt;<i>+				return t;
</I>&gt;<i>+
</I>&gt;<i>+			return null;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i>+	public class GlobalRootNamespace : RootNamespace
</I>&gt;<i>+	{
</I>&gt;<i>+		Assembly [] assemblies;
</I>&gt;<i>+		
</I>&gt;<i>+		public GlobalRootNamespace () : base (null)
</I>&gt;<i>+		{
</I>&gt;<i>+			assemblies = new Assembly [0];
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public void AddAssemblyReference (Assembly assembly)
</I>&gt;<i>+		{
</I>&gt;<i>+			Assembly [] tmp = new Assembly [assemblies.Length + 1];
</I>&gt;<i>+			Array.Copy (assemblies, 0, tmp, 0, assemblies.Length);
</I>&gt;<i>+			tmp [assemblies.Length] = assembly;
</I>&gt;<i>+
</I>&gt;<i>+			assemblies = tmp;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public override Type LookupTypeReflection (string name, Location loc)
</I>&gt;<i>+		{
</I>&gt;<i>+			Type found_type = null;
</I>&gt;<i>+		
</I>&gt;<i>+			foreach (Assembly a in assemblies) {
</I>&gt;<i>+				Type t = a.GetType (name);
</I>&gt;<i>+				if (t == null)
</I>&gt;<i>+					continue;
</I>&gt;<i>+				
</I>&gt;<i>+				if (t.IsPointer)
</I>&gt;<i>+					throw new InternalErrorException (&quot;Use GetPointerType() to get a pointer&quot;);
</I>&gt;<i>+			
</I>&gt;<i>+				TypeAttributes ta = t.Attributes &amp; TypeAttributes.VisibilityMask;
</I>&gt;<i>+				if (ta != TypeAttributes.NotPublic &amp;&amp; ta != TypeAttributes.NestedPrivate &amp;&amp;
</I>&gt;<i>+						ta != TypeAttributes.NestedAssembly &amp;&amp; ta != TypeAttributes.NestedFamANDAssem) {
</I>&gt;<i>+					if (found_type == null) {
</I>&gt;<i>+						found_type = t;
</I>&gt;<i>+						continue;
</I>&gt;<i>+					}
</I>&gt;<i>+				
</I>&gt;<i>+					Report.SymbolRelatedToPreviousError (found_type);
</I>&gt;<i>+					Report.SymbolRelatedToPreviousError (t);
</I>&gt;<i>+					Report.Error (433, loc, &quot;The imported type `{0}' is defined multiple times&quot;, name);
</I>&gt;<i>+					return found_type;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			Type t2 = TypeManager.LookupTypeInModules (name);
</I>&gt;<i>+			if (t2 != null) {
</I>&gt;<i>+				if (found_type != null) {
</I>&gt;<i>+					Report.SymbolRelatedToPreviousError (t2);
</I>&gt;<i>+					Report.SymbolRelatedToPreviousError (found_type);
</I>&gt;<i>+					Report.Warning (436, 2, loc, &quot;Ignoring imported type `{0}' since the current assembly already has a declaration with the same name&quot;,
</I>&gt;<i>+							TypeManager.CSharpName (t2));
</I>&gt;<i>+				}
</I>&gt;<i>+
</I>&gt;<i>+				return t2;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			return found_type;
</I>&gt;<i>+		}
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i> 	///   Keeps track of the namespaces defined in the C# code.
</I>&gt;<i> 	///
</I>&gt;<i>@@ -21,6 +113,7 @@
</I>&gt;<i> 	public class Namespace : FullNamedExpression {
</I>&gt;<i> 		static ArrayList all_namespaces;
</I>&gt;<i> 		static Hashtable namespaces_map;
</I>&gt;<i>+		static Hashtable root_namespaces;
</I>&gt;<i> 		
</I>&gt;<i> 		Namespace parent;
</I>&gt;<i> 		string fullname;
</I>&gt;<i>@@ -28,10 +121,11 @@
</I>&gt;<i> 		Hashtable namespaces;
</I>&gt;<i> 		IDictionary declspaces;
</I>&gt;<i> 		Hashtable cached_types;
</I>&gt;<i>+		protected RootNamespace root;
</I>&gt;<i> 
</I>&gt;<i> 		public readonly MemberName MemberName;
</I>&gt;<i> 
</I>&gt;<i>-		public static Namespace Root;
</I>&gt;<i>+		public static GlobalRootNamespace Root;
</I>&gt;<i> 
</I>&gt;<i> 		static Namespace ()
</I>&gt;<i> 		{
</I>&gt;<i>@@ -42,8 +136,9 @@
</I>&gt;<i> 		{
</I>&gt;<i> 			all_namespaces = new ArrayList ();
</I>&gt;<i> 			namespaces_map = new Hashtable ();
</I>&gt;<i>+			root_namespaces = new Hashtable ();
</I>&gt;<i> 
</I>&gt;<i>-			Root = new Namespace (null, &quot;&quot;);
</I>&gt;<i>+			Root = new GlobalRootNamespace ();
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		/// &lt;summary&gt;
</I>&gt;<i>@@ -60,6 +155,12 @@
</I>&gt;<i> 
</I>&gt;<i> 			this.parent = parent;
</I>&gt;<i> 
</I>&gt;<i>+			if (parent != null)
</I>&gt;<i>+				if (parent is RootNamespace)
</I>&gt;<i>+					this.root = parent as RootNamespace;
</I>&gt;<i>+				else
</I>&gt;<i>+					this.root = parent.root;
</I>&gt;<i>+			
</I>&gt;<i> 			string pname = parent != null ? parent.Name : &quot;&quot;;
</I>&gt;<i> 				
</I>&gt;<i> 			if (pname == &quot;&quot;)
</I>&gt;<i>@@ -81,10 +182,12 @@
</I>&gt;<i> 			namespaces = new Hashtable ();
</I>&gt;<i> 			cached_types = new Hashtable ();
</I>&gt;<i> 
</I>&gt;<i>-			all_namespaces.Add (this);
</I>&gt;<i>-			if (namespaces_map.Contains (fullname))
</I>&gt;<i>-				return;
</I>&gt;<i>-			namespaces_map [fullname] = true;
</I>&gt;<i>+			if (this.root == Root) {
</I>&gt;<i>+				all_namespaces.Add (this);
</I>&gt;<i>+				if (namespaces_map.Contains (fullname))
</I>&gt;<i>+					return;
</I>&gt;<i>+				namespaces_map [fullname] = true;
</I>&gt;<i>+			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		public override Expression DoResolve (EmitContext ec)
</I>&gt;<i>@@ -138,6 +241,16 @@
</I>&gt;<i> 			return Root.GetNamespace (name, create);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		public static RootNamespace DefineRootNamespace (string name, Assembly assembly)
</I>&gt;<i>+		{
</I>&gt;<i>+			RootNamespace retval = (RootNamespace) root_namespaces [name];
</I>&gt;<i>+			if (retval != null)
</I>&gt;<i>+				return retval;
</I>&gt;<i>+
</I>&gt;<i>+			retval = new RootNamespace (assembly);
</I>&gt;<i>+			return retval;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		TypeExpr LookupType (string name, Location loc)
</I>&gt;<i> 		{
</I>&gt;<i> 			if (cached_types.Contains (name))
</I>&gt;<i>@@ -161,7 +274,7 @@
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 			string lookup = t != null ? t.FullName : (fullname == &quot;&quot; ? name : fullname + &quot;.&quot; + name);
</I>&gt;<i>-			Type rt = TypeManager.LookupTypeReflection (lookup, loc);
</I>&gt;<i>+			Type rt = root.LookupTypeReflection (lookup, loc);
</I>&gt;<i> 			if (t == null)
</I>&gt;<i> 				t = rt;
</I>&gt;<i> 
</I>&gt;<i>@@ -256,6 +369,7 @@
</I>&gt;<i> 		Hashtable aliases;
</I>&gt;<i> 		ArrayList using_clauses;
</I>&gt;<i> 		public bool DeclarationFound = false;
</I>&gt;<i>+		public bool UsingFound;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i> 		// This class holds the location where a using definition is
</I>&gt;<i>@@ -304,24 +418,34 @@
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>-		public class AliasEntry {
</I>&gt;<i>+		public abstract class AliasEntry {
</I>&gt;<i> 			public readonly string Name;
</I>&gt;<i> 			public readonly Expression Alias;
</I>&gt;<i> 			public readonly NamespaceEntry NamespaceEntry;
</I>&gt;<i> 			public readonly Location Location;
</I>&gt;<i> 			
</I>&gt;<i>-			public AliasEntry (NamespaceEntry entry, string name, MemberName alias, Location loc)
</I>&gt;<i>+			protected AliasEntry (NamespaceEntry entry, string name, MemberName alias, Location loc)
</I>&gt;<i> 			{
</I>&gt;<i> 				Name = name;
</I>&gt;<i>-				Alias = alias.GetTypeExpression ();
</I>&gt;<i>+				Alias = alias != null ? alias.GetTypeExpression () : null;
</I>&gt;<i> 				NamespaceEntry = entry;
</I>&gt;<i> 				Location = loc;
</I>&gt;<i> 			}
</I>&gt;<i>+			
</I>&gt;<i>+			protected FullNamedExpression resolved;
</I>&gt;<i> 
</I>&gt;<i>-			FullNamedExpression resolved;
</I>&gt;<i>+			public abstract FullNamedExpression Resolve ();
</I>&gt;<i>+		}
</I>&gt;<i> 
</I>&gt;<i>-			public FullNamedExpression Resolve ()
</I>&gt;<i>+		public class LocalAliasEntry : AliasEntry
</I>&gt;<i>+		{
</I>&gt;<i>+			public LocalAliasEntry (NamespaceEntry entry, string name, MemberName alias, Location loc) :
</I>&gt;<i>+				base (entry, name, alias, loc)
</I>&gt;<i> 			{
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			public override FullNamedExpression Resolve ()
</I>&gt;<i>+			{
</I>&gt;<i> 				if (resolved != null)
</I>&gt;<i> 					return resolved;
</I>&gt;<i> 
</I>&gt;<i>@@ -334,6 +458,24 @@
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		public class ExternAliasEntry : AliasEntry 
</I>&gt;<i>+		{
</I>&gt;<i>+			public ExternAliasEntry (NamespaceEntry entry, string name, Location loc) :
</I>&gt;<i>+				base (entry, name, null, loc)
</I>&gt;<i>+			{
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			public override FullNamedExpression Resolve ()
</I>&gt;<i>+			{
</I>&gt;<i>+				if (resolved != null)
</I>&gt;<i>+					return resolved;
</I>&gt;<i>+
</I>&gt;<i>+				resolved = TypeManager.ComputeNamespacesForAlias (Name);
</I>&gt;<i>+				
</I>&gt;<i>+				return resolved;
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		public NamespaceEntry (NamespaceEntry parent, SourceFile file, string name, Location loc)
</I>&gt;<i> 		{
</I>&gt;<i> 			this.parent = parent;
</I>&gt;<i>@@ -431,6 +573,7 @@
</I>&gt;<i> 
</I>&gt;<i> 			UsingEntry ue = new UsingEntry (Doppelganger, name, loc);
</I>&gt;<i> 			using_clauses.Add (ue);
</I>&gt;<i>+			UsingFound = true;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		public void UsingAlias (string name, MemberName alias, Location loc)
</I>&gt;<i>@@ -456,9 +599,36 @@
</I>&gt;<i> 				Report.Warning (440, loc, &quot;An alias named `global' will not be used when resolving 'global::';&quot; +
</I>&gt;<i> 					&quot; the global namespace will be used instead&quot;);
</I>&gt;<i> 
</I>&gt;<i>-			aliases [name] = new AliasEntry (Doppelganger, name, alias, loc);
</I>&gt;<i>+			aliases [name] = new LocalAliasEntry (Doppelganger, name, alias, loc);
</I>&gt;<i>+			UsingFound = true;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		public void UsingExternalAlias (string name, Location loc)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (UsingFound || DeclarationFound) {
</I>&gt;<i>+				Report.Error (439, loc, &quot;An extern alias declaration must precede all other elements&quot;);
</I>&gt;<i>+				return;
</I>&gt;<i>+			}
</I>&gt;<i>+			
</I>&gt;<i>+			if (aliases == null)
</I>&gt;<i>+				aliases = new Hashtable ();
</I>&gt;<i>+			
</I>&gt;<i>+			if (aliases.Contains (name)) {
</I>&gt;<i>+				AliasEntry ae = (AliasEntry) aliases [name];
</I>&gt;<i>+				Report.SymbolRelatedToPreviousError (ae.Location, ae.Name);
</I>&gt;<i>+				Report.Error (1537, loc, &quot;The using alias `&quot; + name +
</I>&gt;<i>+					      &quot;' appeared previously in this namespace&quot;);
</I>&gt;<i>+				return;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			if (name == &quot;global&quot;) {
</I>&gt;<i>+				Report.Error (1681, loc, &quot;You cannot redefine the global extern alias&quot;);
</I>&gt;<i>+				return;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			aliases [name] = new ExternAliasEntry (Doppelganger, name, loc);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		public FullNamedExpression LookupNamespaceOrType (DeclSpace ds, string name, Location loc, bool ignore_cs0104)
</I>&gt;<i> 		{
</I>&gt;<i> 			// Precondition: Only simple names (no dots) will be looked up with this function.
</I>&gt;<i>@@ -641,7 +811,12 @@
</I>&gt;<i> 				foreach (DictionaryEntry de in aliases) {
</I>&gt;<i> 					AliasEntry alias = (AliasEntry) de.Value;
</I>&gt;<i> 					if (alias.Resolve () == null)
</I>&gt;<i>-						Error_NamespaceNotFound (alias.Location, alias.Alias.ToString ());
</I>&gt;<i>+						if (alias is LocalAliasEntry)
</I>&gt;<i>+							Error_NamespaceNotFound (alias.Location, alias.Alias.ToString ());
</I>&gt;<i>+						else if (alias is ExternAliasEntry) {
</I>&gt;<i>+							Report.Error (430, alias.Location, &quot;The extern alias '&quot; + alias.Name +
</I>&gt;<i>+									&quot;' was not specified in a /reference option&quot;);
</I>&gt;<i>+						}
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i>Index: cs-parser.jay
</I>&gt;<i>===================================================================
</I>&gt;<i>--- cs-parser.jay	(revisi&#243;n: 51315)
</I>&gt;<i>+++ cs-parser.jay	(copia de trabajo)
</I>&gt;<i>@@ -309,10 +309,31 @@
</I>&gt;<i>         ;
</I>&gt;<i>  
</I>&gt;<i> outer_declaration
</I>&gt;<i>-        : using_directive
</I>&gt;<i>+	: extern_alias_directive
</I>&gt;<i>+        | using_directive 
</I>&gt;<i>         | namespace_member_declaration
</I>&gt;<i>         ;
</I>&gt;<i>-  
</I>&gt;<i>+
</I>&gt;<i>+extern_alias_directives
</I>&gt;<i>+	: extern_alias_directive
</I>&gt;<i>+	| extern_alias_directives extern_alias_directive;
</I>&gt;<i>+
</I>&gt;<i>+extern_alias_directive
</I>&gt;<i>+	: EXTERN IDENTIFIER IDENTIFIER SEMICOLON
</I>&gt;<i>+	  {
</I>&gt;<i>+		LocatedToken lt = (LocatedToken) $2;
</I>&gt;<i>+		string s = lt.Value;
</I>&gt;<i>+		if (s != &quot;alias&quot;){
</I>&gt;<i>+			Report.Error (1003, lt.Location, &quot;'alias' expected&quot;);
</I>&gt;<i>+		} else if (RootContext.Version == LanguageVersion.ISO_1) {
</I>&gt;<i>+			Report.FeatureIsNotStandardized (lt.Location, &quot;external alias&quot;);
</I>&gt;<i>+		} else {
</I>&gt;<i>+			lt = (LocatedToken) $3; 
</I>&gt;<i>+			current_namespace.UsingExternalAlias (lt.Value, lt.Location);
</I>&gt;<i>+		}
</I>&gt;<i>+	  }
</I>&gt;<i>+	;
</I>&gt;<i>+ 
</I>&gt;<i> using_directives
</I>&gt;<i> 	: using_directive 
</I>&gt;<i> 	| using_directives using_directive
</I>&gt;<i>@@ -393,6 +414,7 @@
</I>&gt;<i> 		if (RootContext.Documentation != null)
</I>&gt;<i> 			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i>+	  opt_extern_alias_directives
</I>&gt;<i> 	  opt_using_directives
</I>&gt;<i> 	  opt_namespace_member_declarations
</I>&gt;<i> 	  CLOSE_BRACE
</I>&gt;<i>@@ -403,6 +425,11 @@
</I>&gt;<i> 	| using_directives
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>+opt_extern_alias_directives
</I>&gt;<i>+	: /* empty */
</I>&gt;<i>+	| extern_alias_directives
</I>&gt;<i>+	;
</I>&gt;<i>+
</I>&gt;<i> opt_namespace_member_declarations
</I>&gt;<i> 	: /* empty */
</I>&gt;<i> 	| namespace_member_declarations
</I>&gt;<i>Index: driver.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- driver.cs	(revisi&#243;n: 51315)
</I>&gt;<i>+++ driver.cs	(copia de trabajo)
</I>&gt;<i>@@ -42,7 +42,12 @@
</I>&gt;<i> 		//
</I>&gt;<i> 		static ArrayList soft_references;
</I>&gt;<i> 
</I>&gt;<i>+		// 
</I>&gt;<i>+		// External aliases for assemblies.
</I>&gt;<i> 		//
</I>&gt;<i>+		static Hashtable external_aliases;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i> 		// Modules to be linked
</I>&gt;<i> 		//
</I>&gt;<i> 		static ArrayList modules;
</I>&gt;<i>@@ -305,6 +310,11 @@
</I>&gt;<i> 
</I>&gt;<i> 		static public void LoadAssembly (string assembly, bool soft)
</I>&gt;<i> 		{
</I>&gt;<i>+			LoadAssembly (assembly, null, soft);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		static public void LoadAssembly (string assembly, string alias, bool soft)
</I>&gt;<i>+		{
</I>&gt;<i> 			Assembly a;
</I>&gt;<i> 			string total_log = &quot;&quot;;
</I>&gt;<i> 
</I>&gt;<i>@@ -319,7 +329,11 @@
</I>&gt;<i> 						ass = assembly.Substring (0, assembly.Length - 4);
</I>&gt;<i> 					a = Assembly.Load (ass);
</I>&gt;<i> 				}
</I>&gt;<i>-				TypeManager.AddAssembly (a);
</I>&gt;<i>+				// Extern aliased refs require special handling
</I>&gt;<i>+				if (alias == null)
</I>&gt;<i>+					TypeManager.AddAssembly (a);
</I>&gt;<i>+				else
</I>&gt;<i>+					TypeManager.AddExternAlias (alias, a);
</I>&gt;<i> 
</I>&gt;<i> 			} catch (FileNotFoundException){
</I>&gt;<i> 				foreach (string dir in link_paths){
</I>&gt;<i>@@ -329,7 +343,10 @@
</I>&gt;<i> 
</I>&gt;<i> 					try {
</I>&gt;<i> 						a = Assembly.LoadFrom (full_path);
</I>&gt;<i>-						TypeManager.AddAssembly (a);
</I>&gt;<i>+						if (alias == null)
</I>&gt;<i>+							TypeManager.AddAssembly (a);
</I>&gt;<i>+						else
</I>&gt;<i>+							TypeManager.AddExternAlias (alias, a);
</I>&gt;<i> 						return;
</I>&gt;<i> 					} catch (FileNotFoundException ff) {
</I>&gt;<i> 						total_log += ff.FusionLog;
</I>&gt;<i>@@ -405,6 +422,9 @@
</I>&gt;<i> 
</I>&gt;<i> 			foreach (string r in soft_references)
</I>&gt;<i> 				LoadAssembly (r, true);
</I>&gt;<i>+
</I>&gt;<i>+			foreach (DictionaryEntry entry in external_aliases)
</I>&gt;<i>+				LoadAssembly ((string) entry.Value, (string) entry.Key, false);
</I>&gt;<i> 			
</I>&gt;<i> 			return;
</I>&gt;<i> 		}
</I>&gt;<i>@@ -800,7 +820,25 @@
</I>&gt;<i> 					Environment.Exit (1);
</I>&gt;<i> 				}
</I>&gt;<i> 				
</I>&gt;<i>-				references.Add (args [++i]);
</I>&gt;<i>+				string val = args [++i];
</I>&gt;<i>+				int idx = val.IndexOf ('=');
</I>&gt;<i>+				if (idx &gt; -1) {
</I>&gt;<i>+					string alias = val.Substring (0, idx);
</I>&gt;<i>+					string assembly = val.Substring (idx + 1);
</I>&gt;<i>+					if (assembly.Length == 0) {
</I>&gt;<i>+						Report.Error (1680, &quot;Invalid reference alias '&quot; + alias + &quot;='. Missing filename&quot;);
</I>&gt;<i>+						Environment.Exit (1);
</I>&gt;<i>+					}
</I>&gt;<i>+					if (!IsExternAliasValid (alias)) {
</I>&gt;<i>+						Report.Error (1679, &quot;Invalid extern alias for /reference. Alias '&quot; + alias + &quot;' is not a valid identifier&quot;);
</I>&gt;<i>+						Environment.Exit (1);
</I>&gt;<i>+					}
</I>&gt;<i>+					external_aliases [alias] = assembly;
</I>&gt;<i>+					val = assembly;
</I>&gt;<i>+					return true;
</I>&gt;<i>+				}
</I>&gt;<i>+
</I>&gt;<i>+				references.Add (val);
</I>&gt;<i> 				return true;
</I>&gt;<i> 				
</I>&gt;<i> 			case &quot;-L&quot;:
</I>&gt;<i>@@ -1092,7 +1130,24 @@
</I>&gt;<i> 
</I>&gt;<i> 				string [] refs = value.Split (new char [] { ';', ',' });
</I>&gt;<i> 				foreach (string r in refs){
</I>&gt;<i>-					references.Add (r);
</I>&gt;<i>+					string val = r;
</I>&gt;<i>+					int index = val.IndexOf (&quot;=&quot;);
</I>&gt;<i>+					if (index &gt; -1) {
</I>&gt;<i>+						string alias = r.Substring (0, index);
</I>&gt;<i>+						string assembly = r.Substring (index + 1);
</I>&gt;<i>+						if (assembly.Length == 0) {
</I>&gt;<i>+							Report.Error (1680, &quot;Invalid reference alias '&quot; + alias + &quot;='. Missing filename&quot;);
</I>&gt;<i>+							Environment.Exit (1);
</I>&gt;<i>+						}
</I>&gt;<i>+						if (!IsExternAliasValid (alias)) {
</I>&gt;<i>+							Report.Error (1679, &quot;Invalid extern alias for /reference. Alias '&quot; + alias + &quot;' is not a valid identifier&quot;);
</I>&gt;<i>+							Environment.Exit (1);
</I>&gt;<i>+						}
</I>&gt;<i>+						external_aliases [alias] = assembly;
</I>&gt;<i>+						val = assembly;
</I>&gt;<i>+						return true;
</I>&gt;<i>+					}
</I>&gt;<i>+					references.Add (val);
</I>&gt;<i> 				}
</I>&gt;<i> 				return true;
</I>&gt;<i> 			}
</I>&gt;<i>@@ -1351,6 +1406,28 @@
</I>&gt;<i> 
</I>&gt;<i> 			return new_args;
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		static bool IsExternAliasValid (string identifier)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (identifier.Length == 0)
</I>&gt;<i>+				return false;
</I>&gt;<i>+			if (identifier [0] != '_' &amp;&amp; !Char.IsLetter (identifier [0]))
</I>&gt;<i>+				return false;
</I>&gt;<i>+
</I>&gt;<i>+			for (int i = 1; i &lt; identifier.Length; i++) {
</I>&gt;<i>+				char c = identifier [i];
</I>&gt;<i>+				if (Char.IsLetter (c) || Char.IsDigit (c))
</I>&gt;<i>+					continue;
</I>&gt;<i>+
</I>&gt;<i>+				UnicodeCategory category = Char.GetUnicodeCategory (c);
</I>&gt;<i>+				if (category != UnicodeCategory.Format || category != UnicodeCategory.NonSpacingMark ||
</I>&gt;<i>+						category != UnicodeCategory.SpacingCombiningMark ||
</I>&gt;<i>+						category != UnicodeCategory.ConnectorPunctuation)
</I>&gt;<i>+					return false;
</I>&gt;<i>+			}
</I>&gt;<i>+			
</I>&gt;<i>+			return true;
</I>&gt;<i>+		}
</I>&gt;<i> 		
</I>&gt;<i> 		/// &lt;summary&gt;
</I>&gt;<i> 		///    Parses the arguments, and drives the compilation
</I>&gt;<i>@@ -1377,6 +1454,7 @@
</I>&gt;<i> 			encoding = default_encoding;
</I>&gt;<i> 
</I>&gt;<i> 			references = new ArrayList ();
</I>&gt;<i>+			external_aliases = new Hashtable ();
</I>&gt;<i> 			soft_references = new ArrayList ();
</I>&gt;<i> 			modules = new ArrayList ();
</I>&gt;<i> 			link_paths = new ArrayList ();
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>_______________________________________________
</I>&gt;<i>Mono-devel-list mailing list
</I>&gt;<i><A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i><A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>  
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015211.html">[Mono-dev] [Patch] Extern alias (with modifications)
</A></li>
	<LI>Next message: <A HREF="015210.html">[Mono-dev] Mono.Cairo Memory Leak
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15215">[ date ]</a>
              <a href="thread.html#15215">[ thread ]</a>
              <a href="subject.html#15215">[ subject ]</a>
              <a href="author.html#15215">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
