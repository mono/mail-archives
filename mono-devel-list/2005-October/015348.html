<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Extern alias patch (latest modifications)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Extern%20alias%20patch%20%28latest%20modifications%29&In-Reply-To=1129181921.28056.10.camel%40localhost.localdomain">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015334.html">
   <LINK REL="Next"  HREF="015395.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Extern alias patch (latest modifications)</H1>
    <B>Marek Safar</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Extern%20alias%20patch%20%28latest%20modifications%29&In-Reply-To=1129181921.28056.10.camel%40localhost.localdomain"
       TITLE="[Mono-dev] Extern alias patch (latest modifications)">marek.safar at seznam.cz
       </A><BR>
    <I>Fri Oct 14 04:25:47 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="015334.html">[Mono-dev] Extern alias patch (latest modifications)
</A></li>
        <LI>Next message: <A HREF="015395.html">[Mono-dev] Extern alias patch (latest modifications)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15348">[ date ]</a>
              <a href="thread.html#15348">[ thread ]</a>
              <a href="subject.html#15348">[ subject ]</a>
              <a href="author.html#15348">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

&gt;<i>The attached patch contains the impl of extern alias, and also the clean
</I>&gt;<i>ups to the original code needed for my patch, as required by Hari.
</I>&gt;<i>
</I>&gt;<i>I'm also attaching some tests and tests for errors (observe that cs1679
</I>&gt;<i>and cs1780 are receiving an error, since it looks like '=' in the comp
</I>&gt;<i>options is not handled). Errors 1769 and 1680 are handled since my first
</I>&gt;<i>patch, but hadn't included tests for them ;-) (as required by Marek).
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>Sorry, but without complete error test suite I am not going to approve.

         public string GetSignatureForError ()
         {
-            if (NS == Namespace.Root)
+            if (NS == GlobalRootNamespace.Global)
                 return &quot;::global&quot;;
             else
                 return ns.Name;
@@ -656,7 +927,7 @@
 
         public override string ToString ()
         {
-            if (NS == Namespace.Root)
+            if (NS == GlobalRootNamespace.Global)
                 return &quot;NamespaceEntry (&lt;root&gt;)&quot;;
             else
                 return String.Format (&quot;NamespaceEntry ({0},{1},{2})&quot;, 
ns.Name, IsImplicit, ID);

It should be enough to use NS.GetSignatureForError () and NS.ToString ()


+                    string val = r;
+                    int index = val.IndexOf (&quot;=&quot;);
+                    if (index &gt; -1) {
+                        string alias = r.Substring (0, index);
+                        string assembly = r.Substring (index + 1);
+                        if (assembly.Length == 0) {
+                            Report.Error (1680, &quot;Invalid reference 
alias '&quot; + alias + &quot;='. Missing filename&quot;);
+                            Environment.Exit (1);
+                        }
+                        if (!IsExternAliasValid (alias)) {
+                            Report.Error (1679, &quot;Invalid extern alias 
for /reference. Alias '&quot; + alias + &quot;' is not a valid identifier&quot;);
+                            Environment.Exit (1);
+                        }
+                        external_aliases [alias] = assembly;
+                        val = assembly;
+                        return true;
+                    }
+                    references.Add (val);

Ouch, this is 20 lines copy&amp;paste.

Marek

&gt;<i>By the way, all the tests are running fine.
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>Index: typemanager.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- typemanager.cs	(revisi&#243;n: 51651)
</I>&gt;<i>+++ typemanager.cs	(copia de trabajo)
</I>&gt;<i>@@ -215,6 +215,8 @@
</I>&gt;<i> 	// &lt;/remarks&gt;
</I>&gt;<i> 	static Assembly [] assemblies;
</I>&gt;<i> 
</I>&gt;<i>+	static Hashtable external_aliases;
</I>&gt;<i>+
</I>&gt;<i> 	// &lt;remarks&gt;
</I>&gt;<i> 	//  Keeps a list of modules. We used this to do lookups
</I>&gt;<i> 	//  on the module using GetType -- needed for arrays
</I>&gt;<i>@@ -278,6 +280,7 @@
</I>&gt;<i> 		// Lets get everything clean so that we can collect before generating code
</I>&gt;<i> 		assemblies = null;
</I>&gt;<i> 		modules = null;
</I>&gt;<i>+		external_aliases = null;
</I>&gt;<i> 		builder_to_declspace = null;
</I>&gt;<i> 		builder_to_member_cache = null;
</I>&gt;<i> 		builder_to_ifaces = null;
</I>&gt;<i>@@ -379,6 +382,7 @@
</I>&gt;<i> 		assemblies = new Assembly [0];
</I>&gt;<i> 		modules = null;
</I>&gt;<i> 		
</I>&gt;<i>+		external_aliases = new Hashtable ();
</I>&gt;<i> 		builder_to_declspace = new PtrHashtable ();
</I>&gt;<i> 		builder_to_member_cache = new PtrHashtable ();
</I>&gt;<i> 		builder_to_method = new PtrHashtable ();
</I>&gt;<i>@@ -504,11 +508,22 @@
</I>&gt;<i> 		assemblies = n;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i>+	public static void AddExternAlias (string alias, Assembly a)
</I>&gt;<i>+	{
</I>&gt;<i>+		// Keep the new as the chosen one
</I>&gt;<i>+		external_aliases [alias] = a;
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i>         public static Assembly [] GetAssemblies ()
</I>&gt;<i>         {
</I>&gt;<i>                 return assemblies;
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i>+	public static Assembly GetExternAlias (string alias)
</I>&gt;<i>+	{
</I>&gt;<i>+		return (Assembly) external_aliases [alias];
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i> 	///  Registers a module builder to lookup types from
</I>&gt;<i> 	/// &lt;/summary&gt;
</I>&gt;<i>@@ -578,110 +593,26 @@
</I>&gt;<i> 		return (Type) ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i>-	public static Type LookupTypeReflection (string name, Location loc)
</I>&gt;<i>-	{
</I>&gt;<i>-		Type found_type = null;
</I>&gt;<i>-
</I>&gt;<i>-		foreach (Assembly a in assemblies) {
</I>&gt;<i>-			Type t = a.GetType (name);
</I>&gt;<i>-			if (t == null)
</I>&gt;<i>-				continue;
</I>&gt;<i>-
</I>&gt;<i>-			if (t.IsPointer)
</I>&gt;<i>-				throw new InternalErrorException (&quot;Use GetPointerType() to get a pointer&quot;);
</I>&gt;<i>-
</I>&gt;<i>-			TypeAttributes ta = t.Attributes &amp; TypeAttributes.VisibilityMask;
</I>&gt;<i>-			if (ta != TypeAttributes.NotPublic &amp;&amp; ta != TypeAttributes.NestedPrivate &amp;&amp;
</I>&gt;<i>-				ta != TypeAttributes.NestedAssembly &amp;&amp; ta != TypeAttributes.NestedFamANDAssem) {
</I>&gt;<i>-				if (found_type == null) {
</I>&gt;<i>-					found_type = t;
</I>&gt;<i>-					continue;
</I>&gt;<i>-				}
</I>&gt;<i>-
</I>&gt;<i>-				Report.SymbolRelatedToPreviousError (found_type);
</I>&gt;<i>-				Report.SymbolRelatedToPreviousError (t);
</I>&gt;<i>-				Report.Error (433, loc, &quot;The imported type `{0}' is defined multiple times&quot;, name);
</I>&gt;<i>-				return found_type;
</I>&gt;<i>-			}
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i>-		foreach (Module mb in modules) {
</I>&gt;<i>-			Type t = mb.GetType (name);
</I>&gt;<i>-			if (t == null)
</I>&gt;<i>-				continue;
</I>&gt;<i>-			
</I>&gt;<i>-			if (found_type == null) {
</I>&gt;<i>-				found_type = t;
</I>&gt;<i>-				continue;
</I>&gt;<i>-			}
</I>&gt;<i>-
</I>&gt;<i>-			Report.SymbolRelatedToPreviousError (t);
</I>&gt;<i>-			Report.SymbolRelatedToPreviousError (found_type);
</I>&gt;<i>-			Report.Warning (436, 2, loc, &quot;Ignoring imported type `{0}' since the current assembly already has a declaration with the same name&quot;,
</I>&gt;<i>-				TypeManager.CSharpName (t));
</I>&gt;<i>-			return t;
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i>-		return found_type;
</I>&gt;<i>-	}
</I>&gt;<i>-
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i> 	///   Computes the namespaces that we import from the assemblies we reference.
</I>&gt;<i> 	/// &lt;/summary&gt;
</I>&gt;<i> 	public static void ComputeNamespaces ()
</I>&gt;<i> 	{
</I>&gt;<i>-		MethodInfo assembly_get_namespaces = typeof (Assembly).GetMethod (&quot;GetNamespaces&quot;, BindingFlags.Instance|BindingFlags.NonPublic);
</I>&gt;<i>+		foreach (Assembly assembly in assemblies)
</I>&gt;<i>+			GlobalRootNamespace.Global.AddAssemblyReference (assembly);
</I>&gt;<i>+		
</I>&gt;<i>+		foreach (Module m in modules)
</I>&gt;<i>+			GlobalRootNamespace.Global.AddModuleReference (m);
</I>&gt;<i> 
</I>&gt;<i>-		Hashtable cache = null;
</I>&gt;<i>+	}
</I>&gt;<i> 
</I>&gt;<i>-		//
</I>&gt;<i>-		// First add the assembly namespaces
</I>&gt;<i>-		//
</I>&gt;<i>-		if (assembly_get_namespaces != null){
</I>&gt;<i>-			int count = assemblies.Length;
</I>&gt;<i>-
</I>&gt;<i>-			for (int i = 0; i &lt; count; i++){
</I>&gt;<i>-				Assembly a = assemblies [i];
</I>&gt;<i>-				string [] namespaces = (string []) assembly_get_namespaces.Invoke (a, null);
</I>&gt;<i>-				foreach (string ns in namespaces){
</I>&gt;<i>-					if (ns.Length == 0)
</I>&gt;<i>-						continue;
</I>&gt;<i>-					Namespace.LookupNamespace (ns, true);
</I>&gt;<i>-				}
</I>&gt;<i>-			}
</I>&gt;<i>-		} else {
</I>&gt;<i>-			cache = new Hashtable ();
</I>&gt;<i>-			cache.Add (&quot;&quot;, null);
</I>&gt;<i>-			foreach (Assembly a in assemblies) {
</I>&gt;<i>-				foreach (Type t in a.GetExportedTypes ()) {
</I>&gt;<i>-					string ns = t.Namespace;
</I>&gt;<i>-					if (ns == null || cache.Contains (ns))
</I>&gt;<i>-						continue;
</I>&gt;<i>-
</I>&gt;<i>-					Namespace.LookupNamespace (ns, true);
</I>&gt;<i>-					cache.Add (ns, null);
</I>&gt;<i>-				}
</I>&gt;<i>-			}
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i>-		//
</I>&gt;<i>-		// Then add module namespaces
</I>&gt;<i>-		//
</I>&gt;<i>-		foreach (Module m in modules) {
</I>&gt;<i>-			if (m == CodeGen.Module.Builder)
</I>&gt;<i>-				continue;
</I>&gt;<i>-			if (cache == null) {
</I>&gt;<i>-				cache = new Hashtable ();
</I>&gt;<i>-				cache.Add (&quot;&quot;, null);
</I>&gt;<i>-			}
</I>&gt;<i>-			foreach (Type t in m.GetTypes ()) {
</I>&gt;<i>-				string ns = t.Namespace;
</I>&gt;<i>-				if (ns == null || cache.Contains (ns))
</I>&gt;<i>-					continue;
</I>&gt;<i>-				Namespace.LookupNamespace (ns, true);
</I>&gt;<i>-				cache.Add (ns, null);
</I>&gt;<i>-			}
</I>&gt;<i>-		}
</I>&gt;<i>+	public static Namespace ComputeNamespacesForAlias (string name)
</I>&gt;<i>+	{
</I>&gt;<i>+		Assembly assembly = (Assembly) external_aliases [name];
</I>&gt;<i>+		if (assembly == null)
</I>&gt;<i>+			return null;
</I>&gt;<i>+		
</I>&gt;<i>+		return GlobalRootNamespace.DefineRootNamespace (name, assembly);
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i>@@ -700,7 +631,7 @@
</I>&gt;<i> 
</I>&gt;<i> 	public static bool NamespaceClash (string name, Location loc)
</I>&gt;<i> 	{
</I>&gt;<i>-		if (Namespace.LookupNamespace (name, false) == null)
</I>&gt;<i>+		if (GlobalRootNamespace.Global.GetNamespace (name, false) == null)
</I>&gt;<i> 			return false;
</I>&gt;<i> 
</I>&gt;<i> 		Report.Error (519, loc, String.Format (&quot;`{0}' clashes with a predefined namespace&quot;, name));
</I>&gt;<i>@@ -835,7 +766,7 @@
</I>&gt;<i> 	/// &lt;/summary&gt;
</I>&gt;<i> 	static Type CoreLookupType (string ns_name, string name)
</I>&gt;<i> 	{
</I>&gt;<i>-		Namespace ns = Namespace.LookupNamespace (ns_name, true);
</I>&gt;<i>+		Namespace ns = GlobalRootNamespace.Global.GetNamespace (ns_name, true);
</I>&gt;<i> 		FullNamedExpression fne = ns.Lookup (RootContext.Tree.Types, name, Location.Null);
</I>&gt;<i> 		Type t = fne == null ? null : fne.Type;
</I>&gt;<i> 		if (t == null)
</I>&gt;<i>Index: namespace.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- namespace.cs	(revisi&#243;n: 51651)
</I>&gt;<i>+++ namespace.cs	(copia de trabajo)
</I>&gt;<i>@@ -9,9 +9,248 @@
</I>&gt;<i> using System;
</I>&gt;<i> using System.Collections;
</I>&gt;<i> using System.Collections.Specialized;
</I>&gt;<i>+using System.Reflection;
</I>&gt;<i> 
</I>&gt;<i> namespace Mono.CSharp {
</I>&gt;<i> 
</I>&gt;<i>+	public class RootNamespace : Namespace
</I>&gt;<i>+	{
</I>&gt;<i>+		static MethodInfo get_namespaces_method;
</I>&gt;<i>+
</I>&gt;<i>+		Assembly referenced_assembly;
</I>&gt;<i>+		Hashtable cached_namespaces;
</I>&gt;<i>+		
</I>&gt;<i>+		static RootNamespace ()
</I>&gt;<i>+		{
</I>&gt;<i>+			get_namespaces_method = typeof (Assembly).GetMethod (&quot;GetNamespaces&quot;, BindingFlags.Instance | BindingFlags.NonPublic);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public RootNamespace (Assembly assembly) : base (null, String.Empty)
</I>&gt;<i>+		{
</I>&gt;<i>+			this.referenced_assembly = assembly;
</I>&gt;<i>+			this.cached_namespaces = new Hashtable ();
</I>&gt;<i>+			this.cached_namespaces.Add (&quot;&quot;, null);
</I>&gt;<i>+
</I>&gt;<i>+			if (this.referenced_assembly != null)
</I>&gt;<i>+				ComputeNamespacesForAssembly (this.referenced_assembly);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public virtual Type LookupTypeReflection (string name, Location loc)
</I>&gt;<i>+		{
</I>&gt;<i>+			return GetTypeInAssembly (referenced_assembly, name);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public virtual void RegisterNamespace (Namespace ns)
</I>&gt;<i>+		{
</I>&gt;<i>+			// Do nothing.
</I>&gt;<i>+		}
</I>&gt;<i>+		
</I>&gt;<i>+		protected void ComputeNamespacesForAssembly (Assembly assembly)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (get_namespaces_method != null) {
</I>&gt;<i>+				string [] namespaces = (string []) get_namespaces_method.Invoke (assembly, null);
</I>&gt;<i>+				foreach (string ns in namespaces) {
</I>&gt;<i>+					if (ns.Length == 0)
</I>&gt;<i>+						continue;
</I>&gt;<i>+
</I>&gt;<i>+					// Method from parent class Namespace
</I>&gt;<i>+					GetNamespace (ns, true);
</I>&gt;<i>+				}
</I>&gt;<i>+			} else {
</I>&gt;<i>+				//cached_namespaces.Add (&quot;&quot;, null);
</I>&gt;<i>+				foreach (Type t in assembly.GetExportedTypes ()) {
</I>&gt;<i>+					string ns = t.Namespace;
</I>&gt;<i>+					if (ns == null || cached_namespaces.Contains (ns))
</I>&gt;<i>+						continue;
</I>&gt;<i>+
</I>&gt;<i>+					// Method from parent class Namespace
</I>&gt;<i>+					GetNamespace (ns, true);
</I>&gt;<i>+					cached_namespaces.Add (ns, null);
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+		
</I>&gt;<i>+		protected Type GetTypeInAssembly (Assembly assembly, string name)
</I>&gt;<i>+		{
</I>&gt;<i>+			Type t = assembly.GetType (name);
</I>&gt;<i>+			if (t == null)
</I>&gt;<i>+				return null;
</I>&gt;<i>+
</I>&gt;<i>+			if (t.IsPointer)
</I>&gt;<i>+				throw new InternalErrorException (&quot;Use GetPointerType() to get a pointer&quot;);
</I>&gt;<i>+			
</I>&gt;<i>+			TypeAttributes ta = t.Attributes &amp; TypeAttributes.VisibilityMask;
</I>&gt;<i>+			if (ta != TypeAttributes.NotPublic &amp;&amp; ta != TypeAttributes.NestedPrivate &amp;&amp;
</I>&gt;<i>+					ta != TypeAttributes.NestedAssembly &amp;&amp; ta != TypeAttributes.NestedFamANDAssem)
</I>&gt;<i>+				return t;
</I>&gt;<i>+
</I>&gt;<i>+			return null;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		protected Hashtable CachedNamespaces {
</I>&gt;<i>+			get {
</I>&gt;<i>+				return cached_namespaces;
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i>+	public class GlobalRootNamespace : RootNamespace
</I>&gt;<i>+	{
</I>&gt;<i>+		static ArrayList all_namespaces;
</I>&gt;<i>+		static Hashtable namespaces_map;
</I>&gt;<i>+		static Hashtable root_namespaces;
</I>&gt;<i>+		public static GlobalRootNamespace Global;
</I>&gt;<i>+		
</I>&gt;<i>+		Assembly [] assemblies;
</I>&gt;<i>+		Module [] modules;
</I>&gt;<i>+		
</I>&gt;<i>+		public static void Reset ()
</I>&gt;<i>+		{
</I>&gt;<i>+			all_namespaces = new ArrayList ();
</I>&gt;<i>+			namespaces_map = new Hashtable ();
</I>&gt;<i>+			root_namespaces = new Hashtable ();
</I>&gt;<i>+			
</I>&gt;<i>+			Global = new GlobalRootNamespace ();
</I>&gt;<i>+		}
</I>&gt;<i>+		
</I>&gt;<i>+		static GlobalRootNamespace ()
</I>&gt;<i>+		{
</I>&gt;<i>+			Reset ();
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public GlobalRootNamespace () : base (null)
</I>&gt;<i>+		{
</I>&gt;<i>+			assemblies = new Assembly [0];
</I>&gt;<i>+			modules = new Module [0];
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public void AddAssemblyReference (Assembly assembly)
</I>&gt;<i>+		{
</I>&gt;<i>+			Assembly [] tmp = new Assembly [assemblies.Length + 1];
</I>&gt;<i>+			Array.Copy (assemblies, 0, tmp, 0, assemblies.Length);
</I>&gt;<i>+			tmp [assemblies.Length] = assembly;
</I>&gt;<i>+
</I>&gt;<i>+			assemblies = tmp;
</I>&gt;<i>+			ComputeNamespacesForAssembly (assembly);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public void AddModuleReference (Module module)
</I>&gt;<i>+		{
</I>&gt;<i>+			Module [] tmp = new Module [modules.Length + 1];
</I>&gt;<i>+			Array.Copy (modules, 0, tmp, 0, modules.Length);
</I>&gt;<i>+			tmp [modules.Length] = module;
</I>&gt;<i>+
</I>&gt;<i>+			modules = tmp;
</I>&gt;<i>+			
</I>&gt;<i>+			if (module != CodeGen.Module.Builder)
</I>&gt;<i>+				ComputeNamespacesForModule (module);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		void ComputeNamespacesForModule (Module module)
</I>&gt;<i>+		{
</I>&gt;<i>+			foreach (Type t in module.GetTypes ()) {
</I>&gt;<i>+				string ns = t.Namespace;
</I>&gt;<i>+				if (ns == null || CachedNamespaces.Contains (ns))
</I>&gt;<i>+					continue;
</I>&gt;<i>+
</I>&gt;<i>+				GetNamespace (ns, true);
</I>&gt;<i>+				CachedNamespaces.Add (ns, null);
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public override Type LookupTypeReflection (string name, Location loc)
</I>&gt;<i>+		{
</I>&gt;<i>+			Type found_type = null;
</I>&gt;<i>+		
</I>&gt;<i>+			foreach (Assembly a in assemblies) {
</I>&gt;<i>+				Type t = GetTypeInAssembly (a, name);
</I>&gt;<i>+				if (t == null)
</I>&gt;<i>+					continue;
</I>&gt;<i>+					
</I>&gt;<i>+				if (found_type == null) {
</I>&gt;<i>+					found_type = t;
</I>&gt;<i>+					continue;
</I>&gt;<i>+				}
</I>&gt;<i>+
</I>&gt;<i>+				Report.SymbolRelatedToPreviousError (found_type);
</I>&gt;<i>+				Report.SymbolRelatedToPreviousError (t);
</I>&gt;<i>+				Report.Error (433, loc, &quot;The imported type `{0}' is defined multiple times&quot;, name);
</I>&gt;<i>+					
</I>&gt;<i>+				return found_type;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			foreach (Module module in modules) {
</I>&gt;<i>+				Type t = module.GetType (name);
</I>&gt;<i>+				if (t == null)
</I>&gt;<i>+					continue;
</I>&gt;<i>+
</I>&gt;<i>+				if (found_type == null) {
</I>&gt;<i>+					found_type = t;
</I>&gt;<i>+					continue;
</I>&gt;<i>+				}
</I>&gt;<i>+					
</I>&gt;<i>+				Report.SymbolRelatedToPreviousError (t);
</I>&gt;<i>+				Report.SymbolRelatedToPreviousError (found_type);
</I>&gt;<i>+				Report.Warning (436, 2, loc, &quot;Ignoring imported type `{0}' since the current assembly already has a declaration with the same name&quot;,
</I>&gt;<i>+							TypeManager.CSharpName (t));
</I>&gt;<i>+				return t;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			return found_type;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public override void RegisterNamespace (Namespace child)
</I>&gt;<i>+		{
</I>&gt;<i>+			all_namespaces.Add (child);
</I>&gt;<i>+			if (namespaces_map.Contains (child.Name))
</I>&gt;<i>+				return;
</I>&gt;<i>+			namespaces_map [child.Name] = true;
</I>&gt;<i>+		}
</I>&gt;<i>+		
</I>&gt;<i>+		public static RootNamespace DefineRootNamespace (string name, Assembly assembly)
</I>&gt;<i>+		{
</I>&gt;<i>+			RootNamespace retval = (RootNamespace) root_namespaces [name];
</I>&gt;<i>+			if (retval != null)
</I>&gt;<i>+				return retval;
</I>&gt;<i>+
</I>&gt;<i>+			retval = new RootNamespace (assembly);
</I>&gt;<i>+			return retval;
</I>&gt;<i>+		}
</I>&gt;<i>+		
</I>&gt;<i>+		public static bool IsNamespace (string name)
</I>&gt;<i>+		{
</I>&gt;<i>+			return namespaces_map [name] != null;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public static ArrayList UserDefinedNamespaces {
</I>&gt;<i>+			get { return all_namespaces; }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public static void VerifyUsingForAll ()
</I>&gt;<i>+		{
</I>&gt;<i>+			foreach (Namespace ns in all_namespaces)
</I>&gt;<i>+				ns.VerifyUsing ();
</I>&gt;<i>+		}
</I>&gt;<i>+		
</I>&gt;<i>+		public static void DefineNamespacesForAll (SymbolWriter symwriter)
</I>&gt;<i>+		{
</I>&gt;<i>+			foreach (Namespace ns in all_namespaces)
</I>&gt;<i>+				ns.DefineNamespaces (symwriter);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public override string ToString ()
</I>&gt;<i>+		{
</I>&gt;<i>+			return &quot;Namespace (&lt;root&gt;)&quot;;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public override string GetSignatureForError ()
</I>&gt;<i>+		{
</I>&gt;<i>+			return &quot;::global&quot;;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i> 	///   Keeps track of the namespaces defined in the C# code.
</I>&gt;<i> 	///
</I>&gt;<i>@@ -19,8 +258,6 @@
</I>&gt;<i> 	///   compiler parse/intermediate tree during name resolution.
</I>&gt;<i> 	/// &lt;/summary&gt;
</I>&gt;<i> 	public class Namespace : FullNamedExpression {
</I>&gt;<i>-		static ArrayList all_namespaces;
</I>&gt;<i>-		static Hashtable namespaces_map;
</I>&gt;<i> 		
</I>&gt;<i> 		Namespace parent;
</I>&gt;<i> 		string fullname;
</I>&gt;<i>@@ -28,24 +265,10 @@
</I>&gt;<i> 		Hashtable namespaces;
</I>&gt;<i> 		IDictionary declspaces;
</I>&gt;<i> 		Hashtable cached_types;
</I>&gt;<i>+		RootNamespace root;
</I>&gt;<i> 
</I>&gt;<i> 		public readonly MemberName MemberName;
</I>&gt;<i> 
</I>&gt;<i>-		public static Namespace Root;
</I>&gt;<i>-
</I>&gt;<i>-		static Namespace ()
</I>&gt;<i>-		{
</I>&gt;<i>-			Reset ();
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i>-		public static void Reset ()
</I>&gt;<i>-		{
</I>&gt;<i>-			all_namespaces = new ArrayList ();
</I>&gt;<i>-			namespaces_map = new Hashtable ();
</I>&gt;<i>-
</I>&gt;<i>-			Root = new Namespace (null, &quot;&quot;);
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i> 		/// &lt;summary&gt;
</I>&gt;<i> 		///   Constructor Takes the current namespace and the
</I>&gt;<i> 		///   name.  This is bootstrapped with parent == null
</I>&gt;<i>@@ -60,6 +283,14 @@
</I>&gt;<i> 
</I>&gt;<i> 			this.parent = parent;
</I>&gt;<i> 
</I>&gt;<i>+			if (parent != null)
</I>&gt;<i>+				this.root = parent.root;
</I>&gt;<i>+			else
</I>&gt;<i>+				this.root = this as RootNamespace;
</I>&gt;<i>+
</I>&gt;<i>+			if (this.root == null)
</I>&gt;<i>+				throw new InternalErrorException (&quot;Root namespaces must be created using RootNamespace&quot;);
</I>&gt;<i>+			
</I>&gt;<i> 			string pname = parent != null ? parent.Name : &quot;&quot;;
</I>&gt;<i> 				
</I>&gt;<i> 			if (pname == &quot;&quot;)
</I>&gt;<i>@@ -81,10 +312,7 @@
</I>&gt;<i> 			namespaces = new Hashtable ();
</I>&gt;<i> 			cached_types = new Hashtable ();
</I>&gt;<i> 
</I>&gt;<i>-			all_namespaces.Add (this);
</I>&gt;<i>-			if (namespaces_map.Contains (fullname))
</I>&gt;<i>-				return;
</I>&gt;<i>-			namespaces_map [fullname] = true;
</I>&gt;<i>+			root.RegisterNamespace (this);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		public override Expression DoResolve (EmitContext ec)
</I>&gt;<i>@@ -97,14 +325,9 @@
</I>&gt;<i> 			throw new InternalErrorException (&quot;Expression tree referenced namespace &quot; + fullname + &quot; during Emit ()&quot;);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>-		public static bool IsNamespace (string name)
</I>&gt;<i>-		{
</I>&gt;<i>-			return namespaces_map [name] != null;
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i> 		public override string GetSignatureForError ()
</I>&gt;<i> 		{
</I>&gt;<i>-			return Name.Length == 0 ? &quot;::global&quot; : Name;
</I>&gt;<i>+			return Name;
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public Namespace GetNamespace (string name, bool create)
</I>&gt;<i>@@ -133,11 +356,6 @@
</I>&gt;<i> 			return ns;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>-		public static Namespace LookupNamespace (string name, bool create)
</I>&gt;<i>-		{
</I>&gt;<i>-			return Root.GetNamespace (name, create);
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i> 		TypeExpr LookupType (string name, Location loc)
</I>&gt;<i> 		{
</I>&gt;<i> 			if (cached_types.Contains (name))
</I>&gt;<i>@@ -161,7 +379,7 @@
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 			string lookup = t != null ? t.FullName : (fullname == &quot;&quot; ? name : fullname + &quot;.&quot; + name);
</I>&gt;<i>-			Type rt = TypeManager.LookupTypeReflection (lookup, loc);
</I>&gt;<i>+			Type rt = root.LookupTypeReflection (lookup, loc);
</I>&gt;<i> 			if (t == null)
</I>&gt;<i> 				t = rt;
</I>&gt;<i> 
</I>&gt;<i>@@ -195,10 +413,22 @@
</I>&gt;<i> 			declspaces.Add (name, ds);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>-		static public ArrayList UserDefinedNamespaces {
</I>&gt;<i>-			get { return all_namespaces; }
</I>&gt;<i>+		/// &lt;summary&gt;
</I>&gt;<i>+		///   Used to validate that all the using clauses are correct
</I>&gt;<i>+		///   after we are finished parsing all the files.  
</I>&gt;<i>+		/// &lt;/summary&gt;
</I>&gt;<i>+		public void VerifyUsing ()
</I>&gt;<i>+		{
</I>&gt;<i>+			foreach (NamespaceEntry entry in entries)
</I>&gt;<i>+				entry.VerifyUsing ();
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		public void DefineNamespaces (SymbolWriter symwriter)
</I>&gt;<i>+		{
</I>&gt;<i>+			foreach (NamespaceEntry entry in entries)
</I>&gt;<i>+				entry.DefineNamespace (symwriter);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		/// &lt;summary&gt;
</I>&gt;<i> 		///   The qualified name of the current namespace
</I>&gt;<i> 		/// &lt;/summary&gt;
</I>&gt;<i>@@ -218,32 +448,9 @@
</I>&gt;<i> 			get { return parent; }
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>-		public static void DefineNamespaces (SymbolWriter symwriter)
</I>&gt;<i>-		{
</I>&gt;<i>-			foreach (Namespace ns in all_namespaces) {
</I>&gt;<i>-				foreach (NamespaceEntry entry in ns.entries)
</I>&gt;<i>-					entry.DefineNamespace (symwriter);
</I>&gt;<i>-			}
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i>-		/// &lt;summary&gt;
</I>&gt;<i>-		///   Used to validate that all the using clauses are correct
</I>&gt;<i>-		///   after we are finished parsing all the files.  
</I>&gt;<i>-		/// &lt;/summary&gt;
</I>&gt;<i>-		public static void VerifyUsing ()
</I>&gt;<i>-		{
</I>&gt;<i>-			foreach (Namespace ns in all_namespaces) {
</I>&gt;<i>-				foreach (NamespaceEntry entry in ns.entries)
</I>&gt;<i>-					entry.VerifyUsing ();
</I>&gt;<i>-			}
</I>&gt;<i>-		}
</I>&gt;<i>-
</I>&gt;<i> 		public override string ToString ()
</I>&gt;<i> 		{
</I>&gt;<i>-			if (this == Root)
</I>&gt;<i>-				return &quot;Namespace (&lt;root&gt;)&quot;;
</I>&gt;<i>-			else
</I>&gt;<i>-				return String.Format (&quot;Namespace ({0})&quot;, Name);
</I>&gt;<i>+			return String.Format (&quot;Namespace ({0})&quot;, Name);
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i>@@ -256,6 +463,7 @@
</I>&gt;<i> 		Hashtable aliases;
</I>&gt;<i> 		ArrayList using_clauses;
</I>&gt;<i> 		public bool DeclarationFound = false;
</I>&gt;<i>+		public bool UsingFound = false;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i> 		// This class holds the location where a using definition is
</I>&gt;<i>@@ -304,24 +512,35 @@
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>-		public class AliasEntry {
</I>&gt;<i>+		public abstract class AliasEntry {
</I>&gt;<i> 			public readonly string Name;
</I>&gt;<i>-			public readonly Expression Alias;
</I>&gt;<i> 			public readonly NamespaceEntry NamespaceEntry;
</I>&gt;<i> 			public readonly Location Location;
</I>&gt;<i> 			
</I>&gt;<i>-			public AliasEntry (NamespaceEntry entry, string name, MemberName alias, Location loc)
</I>&gt;<i>+			protected AliasEntry (NamespaceEntry entry, string name, Location loc)
</I>&gt;<i> 			{
</I>&gt;<i> 				Name = name;
</I>&gt;<i>-				Alias = alias.GetTypeExpression ();
</I>&gt;<i> 				NamespaceEntry = entry;
</I>&gt;<i> 				Location = loc;
</I>&gt;<i> 			}
</I>&gt;<i>+			
</I>&gt;<i>+			protected FullNamedExpression resolved;
</I>&gt;<i> 
</I>&gt;<i>-			FullNamedExpression resolved;
</I>&gt;<i>+			public abstract FullNamedExpression Resolve ();
</I>&gt;<i>+		}
</I>&gt;<i> 
</I>&gt;<i>-			public FullNamedExpression Resolve ()
</I>&gt;<i>+		public class LocalAliasEntry : AliasEntry
</I>&gt;<i>+		{
</I>&gt;<i>+			public readonly Expression Alias;
</I>&gt;<i>+			
</I>&gt;<i>+			public LocalAliasEntry (NamespaceEntry entry, string name, MemberName alias, Location loc) :
</I>&gt;<i>+				base (entry, name, loc)
</I>&gt;<i> 			{
</I>&gt;<i>+				Alias = alias.GetTypeExpression ();
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			public override FullNamedExpression Resolve ()
</I>&gt;<i>+			{
</I>&gt;<i> 				if (resolved != null)
</I>&gt;<i> 					return resolved;
</I>&gt;<i> 
</I>&gt;<i>@@ -334,6 +553,28 @@
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		public class ExternAliasEntry : AliasEntry 
</I>&gt;<i>+		{
</I>&gt;<i>+			public ExternAliasEntry (NamespaceEntry entry, string name, Location loc) :
</I>&gt;<i>+				base (entry, name, loc)
</I>&gt;<i>+			{
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			public override FullNamedExpression Resolve ()
</I>&gt;<i>+			{
</I>&gt;<i>+				if (resolved != null)
</I>&gt;<i>+					return resolved;
</I>&gt;<i>+
</I>&gt;<i>+				resolved = TypeManager.ComputeNamespacesForAlias (Name);
</I>&gt;<i>+				if (resolved == null) {
</I>&gt;<i>+					Report.Error (430, Location, &quot;The extern alias '&quot; + Name +
</I>&gt;<i>+									&quot;' was not specified in a /reference option&quot;);
</I>&gt;<i>+				}
</I>&gt;<i>+				
</I>&gt;<i>+				return resolved;
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		public NamespaceEntry (NamespaceEntry parent, SourceFile file, string name, Location loc)
</I>&gt;<i> 		{
</I>&gt;<i> 			this.parent = parent;
</I>&gt;<i>@@ -344,9 +585,10 @@
</I>&gt;<i> 			if (parent != null)
</I>&gt;<i> 				ns = parent.NS.GetNamespace (name, true);
</I>&gt;<i> 			else if (name != null)
</I>&gt;<i>-				ns = Namespace.LookupNamespace (name, true);
</I>&gt;<i>+				ns = GlobalRootNamespace.Global.GetNamespace (name, true);
</I>&gt;<i> 			else
</I>&gt;<i>-				ns = Namespace.Root;
</I>&gt;<i>+				ns = GlobalRootNamespace.Global;
</I>&gt;<i>+			
</I>&gt;<i> 			ns.AddNamespaceEntry (this);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>@@ -456,9 +698,35 @@
</I>&gt;<i> 				Report.Warning (440, loc, &quot;An alias named `global' will not be used when resolving 'global::';&quot; +
</I>&gt;<i> 					&quot; the global namespace will be used instead&quot;);
</I>&gt;<i> 
</I>&gt;<i>-			aliases [name] = new AliasEntry (Doppelganger, name, alias, loc);
</I>&gt;<i>+			aliases [name] = new LocalAliasEntry (Doppelganger, name, alias, loc);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		public void UsingExternalAlias (string name, Location loc)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (UsingFound || DeclarationFound) {
</I>&gt;<i>+				Report.Error (439, loc, &quot;An extern alias declaration must precede all other elements&quot;);
</I>&gt;<i>+				return;
</I>&gt;<i>+			}
</I>&gt;<i>+			
</I>&gt;<i>+			if (aliases == null)
</I>&gt;<i>+				aliases = new Hashtable ();
</I>&gt;<i>+			
</I>&gt;<i>+			if (aliases.Contains (name)) {
</I>&gt;<i>+				AliasEntry ae = (AliasEntry) aliases [name];
</I>&gt;<i>+				Report.SymbolRelatedToPreviousError (ae.Location, ae.Name);
</I>&gt;<i>+				Report.Error (1537, loc, &quot;The using alias `&quot; + name +
</I>&gt;<i>+					      &quot;' appeared previously in this namespace&quot;);
</I>&gt;<i>+				return;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			if (name == &quot;global&quot;) {
</I>&gt;<i>+				Report.Error (1681, loc, &quot;You cannot redefine the global extern alias&quot;);
</I>&gt;<i>+				return;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			aliases [name] = new ExternAliasEntry (Doppelganger, name, loc);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		public FullNamedExpression LookupNamespaceOrType (DeclSpace ds, string name, Location loc, bool ignore_cs0104)
</I>&gt;<i> 		{
</I>&gt;<i> 			// Precondition: Only simple names (no dots) will be looked up with this function.
</I>&gt;<i>@@ -641,14 +909,17 @@
</I>&gt;<i> 				foreach (DictionaryEntry de in aliases) {
</I>&gt;<i> 					AliasEntry alias = (AliasEntry) de.Value;
</I>&gt;<i> 					if (alias.Resolve () == null)
</I>&gt;<i>-						Error_NamespaceNotFound (alias.Location, alias.Alias.ToString ());
</I>&gt;<i>+						if (alias is LocalAliasEntry) {
</I>&gt;<i>+							LocalAliasEntry local = alias as LocalAliasEntry;
</I>&gt;<i>+							Error_NamespaceNotFound (local.Location, local.Alias.ToString ());
</I>&gt;<i>+						}
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		public string GetSignatureForError ()
</I>&gt;<i> 		{
</I>&gt;<i>-			if (NS == Namespace.Root)
</I>&gt;<i>+			if (NS == GlobalRootNamespace.Global)
</I>&gt;<i> 				return &quot;::global&quot;;
</I>&gt;<i> 			else
</I>&gt;<i> 				return ns.Name;
</I>&gt;<i>@@ -656,7 +927,7 @@
</I>&gt;<i> 
</I>&gt;<i> 		public override string ToString ()
</I>&gt;<i> 		{
</I>&gt;<i>-			if (NS == Namespace.Root)
</I>&gt;<i>+			if (NS == GlobalRootNamespace.Global)
</I>&gt;<i> 				return &quot;NamespaceEntry (&lt;root&gt;)&quot;;
</I>&gt;<i> 			else
</I>&gt;<i> 				return String.Format (&quot;NamespaceEntry ({0},{1},{2})&quot;, ns.Name, IsImplicit, ID);
</I>&gt;<i>Index: ecore.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- ecore.cs	(revisi&#243;n: 51651)
</I>&gt;<i>+++ ecore.cs	(copia de trabajo)
</I>&gt;<i>@@ -2212,7 +2212,7 @@
</I>&gt;<i> 				lookup_name = name.Substring (0, pos);
</I>&gt;<i> 			}
</I>&gt;<i> 
</I>&gt;<i>-			FullNamedExpression resolved = Namespace.Root.Lookup (ec.DeclSpace, lookup_name, Location.Null);
</I>&gt;<i>+			FullNamedExpression resolved = GlobalRootNamespace.Global.Lookup (ec.DeclSpace, lookup_name, Location.Null);
</I>&gt;<i> 
</I>&gt;<i> 			if (resolved != null &amp;&amp; rest != null) {
</I>&gt;<i> 				// Now handle the rest of the the name.
</I>&gt;<i>Index: delegate.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- delegate.cs	(revisi&#243;n: 51651)
</I>&gt;<i>+++ delegate.cs	(copia de trabajo)
</I>&gt;<i>@@ -82,7 +82,7 @@
</I>&gt;<i> 			ec = new EmitContext (this, this, Location, null, null, ModFlags, false);
</I>&gt;<i> 
</I>&gt;<i> 			if (TypeManager.multicast_delegate_type == null &amp;&amp; !RootContext.StdLib) {
</I>&gt;<i>-				Namespace system = Namespace.LookupNamespace (&quot;System&quot;, true);
</I>&gt;<i>+				Namespace system = GlobalRootNamespace.Global.GetNamespace (&quot;System&quot;, true);
</I>&gt;<i> 				TypeExpr expr = system.Lookup (this, &quot;MulticastDelegate&quot;, Location) as TypeExpr;
</I>&gt;<i> 				TypeManager.multicast_delegate_type = expr.ResolveType (ec);
</I>&gt;<i> 			}
</I>&gt;<i>@@ -239,7 +239,7 @@
</I>&gt;<i> 			}
</I>&gt;<i> 			if (Parameters.ArrayParameter != null){
</I>&gt;<i> 				if (TypeManager.param_array_type == null &amp;&amp; !RootContext.StdLib) {
</I>&gt;<i>-					Namespace system = Namespace.LookupNamespace (&quot;System&quot;, true);
</I>&gt;<i>+					Namespace system = GlobalRootNamespace.Global.GetNamespace (&quot;System&quot;, true);
</I>&gt;<i> 					TypeExpr expr = system.Lookup (this, &quot;ParamArrayAttribute&quot;, Location) as TypeExpr;
</I>&gt;<i> 					TypeManager.param_array_type = expr.ResolveType (ec);
</I>&gt;<i> 				}
</I>&gt;<i>Index: cs-parser.jay
</I>&gt;<i>===================================================================
</I>&gt;<i>--- cs-parser.jay	(revisi&#243;n: 51651)
</I>&gt;<i>+++ cs-parser.jay	(copia de trabajo)
</I>&gt;<i>@@ -309,10 +309,31 @@
</I>&gt;<i>         ;
</I>&gt;<i>  
</I>&gt;<i> outer_declaration
</I>&gt;<i>-        : using_directive
</I>&gt;<i>+	: extern_alias_directive
</I>&gt;<i>+        | using_directive 
</I>&gt;<i>         | namespace_member_declaration
</I>&gt;<i>         ;
</I>&gt;<i>-  
</I>&gt;<i>+
</I>&gt;<i>+extern_alias_directives
</I>&gt;<i>+	: extern_alias_directive
</I>&gt;<i>+	| extern_alias_directives extern_alias_directive;
</I>&gt;<i>+
</I>&gt;<i>+extern_alias_directive
</I>&gt;<i>+	: EXTERN IDENTIFIER IDENTIFIER SEMICOLON
</I>&gt;<i>+	  {
</I>&gt;<i>+		LocatedToken lt = (LocatedToken) $2;
</I>&gt;<i>+		string s = lt.Value;
</I>&gt;<i>+		if (s != &quot;alias&quot;){
</I>&gt;<i>+			Report.Error (1003, lt.Location, &quot;'alias' expected&quot;);
</I>&gt;<i>+		} else if (RootContext.Version == LanguageVersion.ISO_1) {
</I>&gt;<i>+			Report.FeatureIsNotStandardized (lt.Location, &quot;external alias&quot;);
</I>&gt;<i>+		} else {
</I>&gt;<i>+			lt = (LocatedToken) $3; 
</I>&gt;<i>+			current_namespace.UsingExternalAlias (lt.Value, lt.Location);
</I>&gt;<i>+		}
</I>&gt;<i>+	  }
</I>&gt;<i>+	;
</I>&gt;<i>+ 
</I>&gt;<i> using_directives
</I>&gt;<i> 	: using_directive 
</I>&gt;<i> 	| using_directives using_directive
</I>&gt;<i>@@ -337,6 +358,7 @@
</I>&gt;<i> 	  {
</I>&gt;<i> 		LocatedToken lt = (LocatedToken) $2;
</I>&gt;<i> 		current_namespace.UsingAlias (lt.Value, (MemberName) $4, (Location) $1);
</I>&gt;<i>+		current_namespace.UsingFound = true;
</I>&gt;<i> 	  }
</I>&gt;<i> 	| USING error {
</I>&gt;<i> 		CheckIdentifierToken (yyToken, GetLocation ($2));
</I>&gt;<i>@@ -347,6 +369,7 @@
</I>&gt;<i> 	: USING namespace_name SEMICOLON 
</I>&gt;<i> 	  {
</I>&gt;<i> 		current_namespace.Using ((MemberName) $2, (Location) $1);
</I>&gt;<i>+		current_namespace.UsingFound = true;
</I>&gt;<i>           }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -393,6 +416,7 @@
</I>&gt;<i> 		if (RootContext.Documentation != null)
</I>&gt;<i> 			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i>+	  opt_extern_alias_directives
</I>&gt;<i> 	  opt_using_directives
</I>&gt;<i> 	  opt_namespace_member_declarations
</I>&gt;<i> 	  CLOSE_BRACE
</I>&gt;<i>@@ -403,6 +427,11 @@
</I>&gt;<i> 	| using_directives
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>+opt_extern_alias_directives
</I>&gt;<i>+	: /* empty */
</I>&gt;<i>+	| extern_alias_directives
</I>&gt;<i>+	;
</I>&gt;<i>+
</I>&gt;<i> opt_namespace_member_declarations
</I>&gt;<i> 	: /* empty */
</I>&gt;<i> 	| namespace_member_declarations
</I>&gt;<i>Index: driver.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- driver.cs	(revisi&#243;n: 51651)
</I>&gt;<i>+++ driver.cs	(copia de trabajo)
</I>&gt;<i>@@ -42,7 +42,12 @@
</I>&gt;<i> 		//
</I>&gt;<i> 		static ArrayList soft_references;
</I>&gt;<i> 
</I>&gt;<i>+		// 
</I>&gt;<i>+		// External aliases for assemblies.
</I>&gt;<i> 		//
</I>&gt;<i>+		static Hashtable external_aliases;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i> 		// Modules to be linked
</I>&gt;<i> 		//
</I>&gt;<i> 		static ArrayList modules;
</I>&gt;<i>@@ -305,6 +310,11 @@
</I>&gt;<i> 
</I>&gt;<i> 		static public void LoadAssembly (string assembly, bool soft)
</I>&gt;<i> 		{
</I>&gt;<i>+			LoadAssembly (assembly, null, soft);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		static public void LoadAssembly (string assembly, string alias, bool soft)
</I>&gt;<i>+		{
</I>&gt;<i> 			Assembly a;
</I>&gt;<i> 			string total_log = &quot;&quot;;
</I>&gt;<i> 
</I>&gt;<i>@@ -319,7 +329,11 @@
</I>&gt;<i> 						ass = assembly.Substring (0, assembly.Length - 4);
</I>&gt;<i> 					a = Assembly.Load (ass);
</I>&gt;<i> 				}
</I>&gt;<i>-				TypeManager.AddAssembly (a);
</I>&gt;<i>+				// Extern aliased refs require special handling
</I>&gt;<i>+				if (alias == null)
</I>&gt;<i>+					TypeManager.AddAssembly (a);
</I>&gt;<i>+				else
</I>&gt;<i>+					TypeManager.AddExternAlias (alias, a);
</I>&gt;<i> 
</I>&gt;<i> 			} catch (FileNotFoundException){
</I>&gt;<i> 				foreach (string dir in link_paths){
</I>&gt;<i>@@ -329,7 +343,10 @@
</I>&gt;<i> 
</I>&gt;<i> 					try {
</I>&gt;<i> 						a = Assembly.LoadFrom (full_path);
</I>&gt;<i>-						TypeManager.AddAssembly (a);
</I>&gt;<i>+						if (alias == null)
</I>&gt;<i>+							TypeManager.AddAssembly (a);
</I>&gt;<i>+						else
</I>&gt;<i>+							TypeManager.AddExternAlias (alias, a);
</I>&gt;<i> 						return;
</I>&gt;<i> 					} catch (FileNotFoundException ff) {
</I>&gt;<i> 						total_log += ff.FusionLog;
</I>&gt;<i>@@ -405,6 +422,9 @@
</I>&gt;<i> 
</I>&gt;<i> 			foreach (string r in soft_references)
</I>&gt;<i> 				LoadAssembly (r, true);
</I>&gt;<i>+
</I>&gt;<i>+			foreach (DictionaryEntry entry in external_aliases)
</I>&gt;<i>+				LoadAssembly ((string) entry.Value, (string) entry.Key, false);
</I>&gt;<i> 			
</I>&gt;<i> 			return;
</I>&gt;<i> 		}
</I>&gt;<i>@@ -800,7 +820,25 @@
</I>&gt;<i> 					Environment.Exit (1);
</I>&gt;<i> 				}
</I>&gt;<i> 				
</I>&gt;<i>-				references.Add (args [++i]);
</I>&gt;<i>+				string val = args [++i];
</I>&gt;<i>+				int idx = val.IndexOf ('=');
</I>&gt;<i>+				if (idx &gt; -1) {
</I>&gt;<i>+					string alias = val.Substring (0, idx);
</I>&gt;<i>+					string assembly = val.Substring (idx + 1);
</I>&gt;<i>+					if (assembly.Length == 0) {
</I>&gt;<i>+						Report.Error (1680, &quot;Invalid reference alias '&quot; + alias + &quot;='. Missing filename&quot;);
</I>&gt;<i>+						Environment.Exit (1);
</I>&gt;<i>+					}
</I>&gt;<i>+					if (!IsExternAliasValid (alias)) {
</I>&gt;<i>+						Report.Error (1679, &quot;Invalid extern alias for /reference. Alias '&quot; + alias + &quot;' is not a valid identifier&quot;);
</I>&gt;<i>+						Environment.Exit (1);
</I>&gt;<i>+					}
</I>&gt;<i>+					external_aliases [alias] = assembly;
</I>&gt;<i>+					val = assembly;
</I>&gt;<i>+					return true;
</I>&gt;<i>+				}
</I>&gt;<i>+
</I>&gt;<i>+				references.Add (val);
</I>&gt;<i> 				return true;
</I>&gt;<i> 				
</I>&gt;<i> 			case &quot;-L&quot;:
</I>&gt;<i>@@ -1092,7 +1130,24 @@
</I>&gt;<i> 
</I>&gt;<i> 				string [] refs = value.Split (new char [] { ';', ',' });
</I>&gt;<i> 				foreach (string r in refs){
</I>&gt;<i>-					references.Add (r);
</I>&gt;<i>+					string val = r;
</I>&gt;<i>+					int index = val.IndexOf (&quot;=&quot;);
</I>&gt;<i>+					if (index &gt; -1) {
</I>&gt;<i>+						string alias = r.Substring (0, index);
</I>&gt;<i>+						string assembly = r.Substring (index + 1);
</I>&gt;<i>+						if (assembly.Length == 0) {
</I>&gt;<i>+							Report.Error (1680, &quot;Invalid reference alias '&quot; + alias + &quot;='. Missing filename&quot;);
</I>&gt;<i>+							Environment.Exit (1);
</I>&gt;<i>+						}
</I>&gt;<i>+						if (!IsExternAliasValid (alias)) {
</I>&gt;<i>+							Report.Error (1679, &quot;Invalid extern alias for /reference. Alias '&quot; + alias + &quot;' is not a valid identifier&quot;);
</I>&gt;<i>+							Environment.Exit (1);
</I>&gt;<i>+						}
</I>&gt;<i>+						external_aliases [alias] = assembly;
</I>&gt;<i>+						val = assembly;
</I>&gt;<i>+						return true;
</I>&gt;<i>+					}
</I>&gt;<i>+					references.Add (val);
</I>&gt;<i> 				}
</I>&gt;<i> 				return true;
</I>&gt;<i> 			}
</I>&gt;<i>@@ -1351,6 +1406,28 @@
</I>&gt;<i> 
</I>&gt;<i> 			return new_args;
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		static bool IsExternAliasValid (string identifier)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (identifier.Length == 0)
</I>&gt;<i>+				return false;
</I>&gt;<i>+			if (identifier [0] != '_' &amp;&amp; !Char.IsLetter (identifier [0]))
</I>&gt;<i>+				return false;
</I>&gt;<i>+
</I>&gt;<i>+			for (int i = 1; i &lt; identifier.Length; i++) {
</I>&gt;<i>+				char c = identifier [i];
</I>&gt;<i>+				if (Char.IsLetter (c) || Char.IsDigit (c))
</I>&gt;<i>+					continue;
</I>&gt;<i>+
</I>&gt;<i>+				UnicodeCategory category = Char.GetUnicodeCategory (c);
</I>&gt;<i>+				if (category != UnicodeCategory.Format || category != UnicodeCategory.NonSpacingMark ||
</I>&gt;<i>+						category != UnicodeCategory.SpacingCombiningMark ||
</I>&gt;<i>+						category != UnicodeCategory.ConnectorPunctuation)
</I>&gt;<i>+					return false;
</I>&gt;<i>+			}
</I>&gt;<i>+			
</I>&gt;<i>+			return true;
</I>&gt;<i>+		}
</I>&gt;<i> 		
</I>&gt;<i> 		/// &lt;summary&gt;
</I>&gt;<i> 		///    Parses the arguments, and drives the compilation
</I>&gt;<i>@@ -1377,6 +1454,7 @@
</I>&gt;<i> 			encoding = default_encoding;
</I>&gt;<i> 
</I>&gt;<i> 			references = new ArrayList ();
</I>&gt;<i>+			external_aliases = new Hashtable ();
</I>&gt;<i> 			soft_references = new ArrayList ();
</I>&gt;<i> 			modules = new ArrayList ();
</I>&gt;<i> 			link_paths = new ArrayList ();
</I>&gt;<i>@@ -1612,7 +1690,7 @@
</I>&gt;<i> 			//
</I>&gt;<i> 			// Verify using aliases now
</I>&gt;<i> 			//
</I>&gt;<i>-			Namespace.VerifyUsing ();
</I>&gt;<i>+			GlobalRootNamespace.VerifyUsingForAll ();
</I>&gt;<i> 			
</I>&gt;<i> 			if (Report.Errors &gt; 0){
</I>&gt;<i> 				return false;
</I>&gt;<i>@@ -1825,7 +1903,7 @@
</I>&gt;<i> 			Report.Reset ();
</I>&gt;<i> 			TypeManager.Reset ();
</I>&gt;<i> 			TypeHandle.Reset ();
</I>&gt;<i>-			Namespace.Reset ();
</I>&gt;<i>+			GlobalRootNamespace.Reset ();
</I>&gt;<i> 			CodeGen.Reset ();
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i>Index: expression.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- expression.cs	(revisi&#243;n: 51651)
</I>&gt;<i>+++ expression.cs	(copia de trabajo)
</I>&gt;<i>@@ -7339,7 +7339,7 @@
</I>&gt;<i> 		public override FullNamedExpression ResolveAsTypeStep (EmitContext ec, bool silent)
</I>&gt;<i> 		{
</I>&gt;<i> 			if (alias == &quot;global&quot;)
</I>&gt;<i>-				return new MemberAccess (Namespace.Root, identifier, loc).ResolveAsTypeStep (ec, silent);
</I>&gt;<i>+				return new MemberAccess (GlobalRootNamespace.Global, identifier, loc).ResolveAsTypeStep (ec, silent);
</I>&gt;<i> 
</I>&gt;<i> 			int errors = Report.Errors;
</I>&gt;<i> 			FullNamedExpression fne = ec.DeclSpace.NamespaceEntry.LookupAlias (alias);
</I>&gt;<i>@@ -7360,7 +7360,7 @@
</I>&gt;<i> 		{
</I>&gt;<i> 			FullNamedExpression fne;
</I>&gt;<i> 			if (alias == &quot;global&quot;) {
</I>&gt;<i>-				fne = Namespace.Root;
</I>&gt;<i>+				fne = GlobalRootNamespace.Global;
</I>&gt;<i> 			} else {
</I>&gt;<i> 				int errors = Report.Errors;
</I>&gt;<i> 				fne = ec.DeclSpace.NamespaceEntry.LookupAlias (alias);
</I>&gt;<i>Index: symbolwriter.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- symbolwriter.cs	(revisi&#243;n: 51651)
</I>&gt;<i>+++ symbolwriter.cs	(copia de trabajo)
</I>&gt;<i>@@ -51,7 +51,7 @@
</I>&gt;<i> 				typeof (GetGuidFunc), mi);
</I>&gt;<i> 
</I>&gt;<i> 			Location.DefineSymbolDocuments (this);
</I>&gt;<i>-			Namespace.DefineNamespaces (this);
</I>&gt;<i>+			GlobalRootNamespace.DefineNamespacesForAll (this);
</I>&gt;<i> 
</I>&gt;<i> 			return true;
</I>&gt;<i> 		}
</I>&gt;<i>Index: doc.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- doc.cs	(revisi&#243;n: 51651)
</I>&gt;<i>+++ doc.cs	(copia de trabajo)
</I>&gt;<i>@@ -594,7 +594,7 @@
</I>&gt;<i> 			}
</I>&gt;<i> 
</I>&gt;<i> 			// don't use identifier here. System[] is not alloed.
</I>&gt;<i>-			if (Namespace.IsNamespace (name)) {
</I>&gt;<i>+			if (GlobalRootNamespace.IsNamespace (name)) {
</I>&gt;<i> 				xref.SetAttribute (&quot;cref&quot;, &quot;N:&quot; + name);
</I>&gt;<i> 				return; // a namespace
</I>&gt;<i> 			}
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>_______________________________________________
</I>&gt;<i>Mono-devel-list mailing list
</I>&gt;<i><A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i><A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>  
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015334.html">[Mono-dev] Extern alias patch (latest modifications)
</A></li>
	<LI>Next message: <A HREF="015395.html">[Mono-dev] Extern alias patch (latest modifications)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15348">[ date ]</a>
              <a href="thread.html#15348">[ thread ]</a>
              <a href="subject.html#15348">[ subject ]</a>
              <a href="author.html#15348">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
