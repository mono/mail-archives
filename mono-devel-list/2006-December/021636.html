<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] COM Callable Wrapper Patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20COM%20Callable%20Wrapper%20Patch&In-Reply-To=20061204175312.GB16688%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="021628.html">
   <LINK REL="Next"  HREF="021655.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] COM Callable Wrapper Patch</H1>
    <B>Jon Chambers</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20COM%20Callable%20Wrapper%20Patch&In-Reply-To=20061204175312.GB16688%40debian.org"
       TITLE="[Mono-dev] COM Callable Wrapper Patch">joncham at gmail.com
       </A><BR>
    <I>Mon Dec  4 19:42:37 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="021628.html">[Mono-dev] COM Callable Wrapper Patch
</A></li>
        <LI>Next message: <A HREF="021655.html">[Mono-dev] COM Callable Wrapper Patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21636">[ date ]</a>
              <a href="thread.html#21636">[ thread ]</a>
              <a href="subject.html#21636">[ subject ]</a>
              <a href="author.html#21636">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Paolo,
      Thanks for reviewing the changes. I've addressed most of the issues
you have brought up below. See comments inline and new patch.

On 12/4/06, Paolo Molaro &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i> On 12/01/06 Jon Chambers wrote:
</I>&gt;<i> &gt; Index: mono/mono/metadata/loader.c
</I>&gt;<i> &gt; ===================================================================
</I>&gt;<i> &gt; --- mono/mono/metadata/loader.c       (revision 68741)
</I>&gt;<i> &gt; +++ mono/mono/metadata/loader.c       (working copy)
</I>&gt;<i> &gt; @@ -1377,7 +1377,7 @@
</I>&gt;<i> &gt;           !(cols [1] &amp; METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) &amp;&amp;
</I>&gt;<i> &gt;           !(result-&gt;iflags &amp; METHOD_IMPL_ATTRIBUTE_RUNTIME) &amp;&amp;
</I>&gt;<i> container) {
</I>&gt;<i> &gt;               gpointer loc = mono_image_rva_map (image, cols [0]);
</I>&gt;<i> &gt; -             g_assert (loc);
</I>&gt;<i> &gt; +             g_assert (loc) ;
</I>&gt;<i>
</I>&gt;<i> This change is incorrect and should be dropped.
</I>

Fixed.

&gt;<i> Index: mono/mono/metadata/domain.c
</I>&gt;<i> &gt; ===================================================================
</I>&gt;<i> &gt; --- mono/mono/metadata/domain.c       (revision 68741)
</I>&gt;<i> &gt; +++ mono/mono/metadata/domain.c       (working copy)
</I>&gt;<i> &gt; @@ -812,14 +812,24 @@
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;       mono_defaults.variant_class = mono_class_from_name (
</I>&gt;<i> &gt;               mono_defaults.corlib, &quot;System&quot;, &quot;Variant&quot;);
</I>&gt;<i> &gt; +     g_assert (mono_defaults.variant_class != 0);
</I>&gt;<i>
</I>&gt;<i> I think we should move away from asserting here. I most cases
</I>&gt;<i> the types here should be initialized lazily to avoid increasing startup
</I>&gt;<i> time and memory usage. Likely all the COM-related types can be loaded
</I>&gt;<i> lazily the first time some COM feature is used.
</I>&gt;<i> It's still fine to have the fields in mono_defaults.
</I>

The are lazily initialized now.

&gt;<i> Index: mono/mono/metadata/marshal.c
</I>&gt;<i> &gt; ===================================================================
</I>&gt;<i> &gt; --- mono/mono/metadata/marshal.c      (revision 68741)
</I>&gt;<i> &gt; +++ mono/mono/metadata/marshal.c      (working copy)
</I>&gt;<i> &gt; @@ -386,6 +448,10 @@
</I>&gt;<i> &gt;       return rt;
</I>&gt;<i> &gt;  }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* End COM Interop related stuff until seperate file */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt;  void
</I>&gt;<i> &gt;  mono_marshal_init (void)
</I>&gt;<i> &gt;  {
</I>&gt;<i> &gt; @@ -446,6 +512,8 @@
</I>&gt;<i> &gt;               register_icall (cominterop_get_method_interface,
</I>&gt;<i> &quot;cominterop_get_method_interface&quot;, &quot;object ptr&quot;, FALSE);
</I>&gt;<i> &gt;               register_icall (cominterop_get_function_pointer,
</I>&gt;<i> &quot;cominterop_get_function_pointer&quot;, &quot;ptr ptr int32&quot;, FALSE);
</I>&gt;<i> &gt;               register_icall (cominterop_object_is_rcw,
</I>&gt;<i> &quot;cominterop_object_is_rcw&quot;, &quot;int32 object&quot;, FALSE);
</I>&gt;<i> &gt; +             register_icall (cominterop_get_ccw, &quot;cominterop_get_ccw&quot;,
</I>&gt;<i> &quot;ptr object ptr&quot;, FALSE);
</I>&gt;<i> &gt; +             register_icall (cominterop_get_ccw_object,
</I>&gt;<i> &quot;cominterop_get_ccw_object&quot;, &quot;object ptr int32&quot;, FALSE);
</I>&gt;<i> &gt;       }
</I>&gt;<i> &gt;  }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @@ -1796,7 +1864,7 @@
</I>&gt;<i> &gt;               static MonoMethod* com_interop_proxy_get_proxy = NULL;
</I>&gt;<i> &gt;               static MonoMethod* get_transparent_proxy = NULL;
</I>&gt;<i> &gt;               int real_proxy;
</I>&gt;<i> &gt; -             guint32 pos_failed = 0;
</I>&gt;<i> &gt; +             guint32 pos_null = 0, pos_ccw = 0, pos_end = 0;
</I>&gt;<i> &gt;               MonoClass *klass = mono_class_from_mono_type (type);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;               mono_mb_emit_ldloc (mb, 1);
</I>&gt;<i> &gt; @@ -1805,8 +1873,17 @@
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;               mono_mb_emit_ldloc (mb, 0);
</I>&gt;<i> &gt;               mono_mb_emit_byte (mb, CEE_LDIND_I);
</I>&gt;<i> &gt; -             pos_failed = mono_mb_emit_short_branch (mb,
</I>&gt;<i> CEE_BRFALSE_S);
</I>&gt;<i> &gt; +             pos_null = mono_mb_emit_short_branch (mb, CEE_BRFALSE_S);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +             // load dst to store later
</I>&gt;<i> &gt; +             mono_mb_emit_ldloc (mb, 1);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             mono_mb_emit_ldloc (mb, 0);
</I>&gt;<i> &gt; +             mono_mb_emit_byte (mb, CEE_LDIND_I);
</I>&gt;<i> &gt; +             mono_mb_emit_icon (mb, TRUE);
</I>&gt;<i> &gt; +             mono_mb_emit_icall (mb, cominterop_get_ccw_object);
</I>&gt;<i> &gt; +             pos_ccw = mono_mb_emit_short_branch (mb, CEE_BRTRUE_S);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt;               if (!com_interop_proxy_class)
</I>&gt;<i> &gt;                       com_interop_proxy_class = mono_class_from_name
</I>&gt;<i> (mono_defaults.corlib, &quot;Mono.Interop&quot;, &quot;ComInteropProxy&quot;);
</I>&gt;<i> &gt;               if (!com_interop_proxy_get_proxy)
</I>&gt;<i> &gt; @@ -1821,18 +1898,35 @@
</I>&gt;<i> &gt;               mono_mb_emit_ptr (mb,
</I>&gt;<i> &amp;mono_defaults.com_object_class-&gt;byval_arg);
</I>&gt;<i> &gt;               mono_mb_emit_icall (mb, type_from_handle);
</I>&gt;<i> &gt;               mono_mb_emit_managed_call (mb,
</I>&gt;<i> com_interop_proxy_get_proxy, NULL);
</I>&gt;<i> &gt; -             mono_mb_emit_stloc (mb, real_proxy);
</I>&gt;<i> &gt; +             //mono_mb_emit_stloc (mb, real_proxy);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             mono_mb_emit_ldloc (mb, 1);
</I>&gt;<i> &gt; -             mono_mb_emit_ldloc (mb, real_proxy);
</I>&gt;<i> &gt; +             //mono_mb_emit_ldloc (mb, 1);
</I>&gt;<i> &gt; +             //mono_mb_emit_ldloc (mb, real_proxy);
</I>&gt;<i>
</I>&gt;<i> Why is this code commented out?
</I>

Removed.

&gt;<i> +GHashTable* ccw_hash = NULL;
</I>&gt;<i> &gt; +GHashTable* ccw_entry_hash = NULL;
</I>&gt;<i>
</I>&gt;<i> These must be static. Also, document with a comment what the key and
</I>&gt;<i> value types are for each hashtable.
</I>

Static and now documented.

&gt;<i> +/**
</I>&gt;<i> &gt; + * cominterop_get_ccw:
</I>&gt;<i> &gt; + * @object: a pointer to the object
</I>&gt;<i> &gt; + * @itf: interface type needed
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Returns: a value indicating if the object is a
</I>&gt;<i> &gt; + * Runtime Callable Wrapper (RCW) for a COM object
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static gpointer
</I>&gt;<i> &gt; +cominterop_get_ccw (MonoObject* object, MonoClass* itf)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     int i;
</I>&gt;<i> &gt; +     MonoCCW *ccw = NULL;
</I>&gt;<i> &gt; +     MonoCCWEntry* ccw_entry = NULL;
</I>&gt;<i> &gt; +     gpointer *vtable = NULL;
</I>&gt;<i> &gt; +     static gpointer iunknown[3] = {NULL, NULL, NULL};
</I>&gt;<i> &gt; +     static gpointer idispatch[4] = {NULL, NULL, NULL, NULL};
</I>&gt;<i> &gt; +     MonoClass* iface = NULL;
</I>&gt;<i> &gt; +     MonoClass* klass = NULL;
</I>&gt;<i> &gt; +     EmitMarshalContext m;
</I>&gt;<i> &gt; +     int start_slot = 3;
</I>&gt;<i> &gt; +     int method_count = 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     if (!object)
</I>&gt;<i> &gt; +             return NULL;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     klass = mono_object_get_class (object);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     if (!ccw_hash)
</I>&gt;<i> &gt; +             ccw_hash = g_hash_table_new (mono_aligned_addr_hash,
</I>&gt;<i> NULL);
</I>&gt;<i> &gt; +     if (!ccw_entry_hash)
</I>&gt;<i> &gt; +             ccw_entry_hash = g_hash_table_new (mono_aligned_addr_hash,
</I>&gt;<i> NULL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     ccw = g_hash_table_lookup (ccw_hash, object);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     if (!iunknown[0]) {
</I>&gt;<i> &gt; +             iunknown[0] = cominterop_ccw_queryinterface;
</I>&gt;<i> &gt; +             iunknown[1] = cominterop_ccw_addref;
</I>&gt;<i> &gt; +             iunknown[2] = cominterop_ccw_release;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     if (!idispatch[0]) {
</I>&gt;<i> &gt; +             idispatch[0] = cominterop_ccw_get_type_info_count;
</I>&gt;<i> &gt; +             idispatch[1] = cominterop_ccw_get_type_info;
</I>&gt;<i> &gt; +             idispatch[2] = cominterop_ccw_get_ids_of_names;
</I>&gt;<i> &gt; +             idispatch[3] = cominterop_ccw_invoke;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     if (!ccw) {
</I>&gt;<i> &gt; +             ccw = g_new0 (MonoCCW, 1);
</I>&gt;<i> &gt; +             ccw-&gt;vtable_hash = g_hash_table_new
</I>&gt;<i> (mono_aligned_addr_hash, NULL);
</I>&gt;<i> &gt; +             ccw-&gt;ref_count = 0;
</I>&gt;<i> &gt; +             ccw-&gt;object = object;
</I>&gt;<i> &gt; +             g_hash_table_insert (ccw_hash, object, ccw);
</I>&gt;<i>
</I>&gt;<i> You can't insert a managed object inside a GHashTable, since objects
</I>&gt;<i> can move and the GC can't see inside GHashTable, you'll get a broken
</I>&gt;<i> pointer and a crash. If the hash must not keep alive the object and you
</I>&gt;<i> used a GHashTable as a way to implement weak references, you must use
</I>&gt;<i> the runtime support for weak references instead. Also, remember that for
</I>&gt;<i> object hashes you must use the mono_object_hash() function.
</I>

The object is not put in hashtable, but just used as the key in this case. I
changed the hash table to use mono_object_hash() as the hash function where
the object is the key. I've removed the MonoObject* field from the MonoCCW
struct and just look it up using the gc_handle when needed instead.

&gt;<i> +             // register for finalization to clean up ccw
</I>&gt;<i> &gt; +             mono_object_register_finalizer (object);
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     iface = itf;
</I>&gt;<i> &gt; +     if (iface == mono_defaults.iunknown_class) {
</I>&gt;<i> &gt; +             start_slot = 3;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +     else if (iface == mono_defaults.idispatch_class) {
</I>&gt;<i> &gt; +             start_slot = 7;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +     else {
</I>&gt;<i> &gt; +             while (iface) {
</I>&gt;<i> &gt; +                     method_count += iface-&gt;method.count;
</I>&gt;<i> &gt; +                     if (iface-&gt;interface_count) {
</I>&gt;<i> &gt; +                             iface = iface-&gt;interfaces[0];
</I>&gt;<i> &gt; +                     }
</I>&gt;<i> &gt; +                     else {
</I>&gt;<i> &gt; +                             start_slot = cominterop_get_com_slot_begin
</I>&gt;<i> (iface);
</I>&gt;<i> &gt; +                             iface = NULL;
</I>&gt;<i> &gt; +                     }
</I>&gt;<i> &gt; +             }
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     ccw_entry = g_hash_table_lookup (ccw-&gt;vtable_hash, itf);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     if (!ccw_entry) {
</I>&gt;<i> &gt; +             int vtable_index = method_count-1+start_slot;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             vtable = mono_mempool_alloc0 (klass-&gt;image-&gt;mempool,
</I>&gt;<i> sizeof (gpointer)*(method_count+start_slot));
</I>&gt;<i>
</I>&gt;<i> You need to take the loader lock to allocate from image-&gt;mempool.
</I>

I've added the loader lock.

&gt;<i> +             memcpy(vtable, iunknown, sizeof(iunknown));
</I>&gt;<i> &gt; +             if (start_slot == 7)
</I>&gt;<i> &gt; +                     memcpy(vtable+3, idispatch, sizeof(idispatch));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             iface = itf;
</I>&gt;<i> &gt; +             while (iface) {
</I>&gt;<i> &gt; +                     for (i = iface-&gt;method.count-1; i &gt;= 0;i--) {
</I>&gt;<i> &gt; +                             int param_index = 0;
</I>&gt;<i> &gt; +                             MonoMethodBuilder *mb;
</I>&gt;<i> &gt; +                             MonoMarshalSpec ** mspecs;
</I>&gt;<i> &gt; +                             MonoMethod *wrapper_method,
</I>&gt;<i> *adjust_method;
</I>&gt;<i> &gt; +                             MonoMethod *method = iface-&gt;methods[i];
</I>&gt;<i> &gt; +                             MonoMethodSignature* sig_adjusted;
</I>&gt;<i> &gt; +                             MonoMethodSignature* sig =
</I>&gt;<i> mono_method_signature (method);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                             mb = mono_mb_new (iface, method-&gt;name,
</I>&gt;<i> MONO_WRAPPER_CCW);
</I>&gt;<i> &gt; +                             adjust_method =
</I>&gt;<i> cominterop_get_managed_wrapper_adjusted (method);
</I>&gt;<i> &gt; +                             sig_adjusted = mono_method_signature
</I>&gt;<i> (adjust_method);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                             mspecs = g_new (MonoMarshalSpec*,
</I>&gt;<i> sig_adjusted-&gt;param_count + 1);
</I>&gt;<i> &gt; +                             mono_method_get_marshal_info (method,
</I>&gt;<i> mspecs);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                             // move managed args up one
</I>&gt;<i> &gt; +                             for (param_index = sig-&gt;param_count;
</I>&gt;<i> param_index &gt;= 1; param_index--)
</I>&gt;<i> &gt; +                                     mspecs[param_index+1] =
</I>&gt;<i> mspecs[param_index];
</I>&gt;<i>
</I>&gt;<i> Here and in the other places, put a space before the [ of an array
</I>&gt;<i> access.
</I>

I've put in spaces in my uses of array accessors.

&gt;<i> +
</I>&gt;<i> &gt; +                             // first arg is IntPtr for interface
</I>&gt;<i> &gt; +                             mspecs[1] = NULL;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                             // move return spec to last param
</I>&gt;<i> &gt; +                             if (!MONO_TYPE_IS_VOID (sig-&gt;ret))
</I>&gt;<i> &gt; +                                     mspecs[sig_adjusted-&gt;param_count]
</I>&gt;<i> = mspecs[0];
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                             mspecs[0] = NULL;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                             cominterop_setup_marshal_context (&amp;m,
</I>&gt;<i> adjust_method);
</I>&gt;<i> &gt; +                             m.mb = mb;
</I>&gt;<i> &gt; +                             mono_marshal_emit_managed_wrapper (mb,
</I>&gt;<i> sig_adjusted, mspecs, &amp;m, adjust_method, NULL);
</I>&gt;<i> &gt; +                             mono_loader_lock ();
</I>&gt;<i> &gt; +                             mono_marshal_lock ();
</I>&gt;<i> &gt; +                             wrapper_method = mono_mb_create_method
</I>&gt;<i> (mb, sig_adjusted, sig_adjusted-&gt;param_count + 16);
</I>&gt;<i> &gt; +                             mono_marshal_unlock ();
</I>&gt;<i> &gt; +                             mono_loader_unlock ();
</I>&gt;<i> &gt; +                             vtable[vtable_index--] =
</I>&gt;<i> mono_compile_method (wrapper_method);
</I>&gt;<i>
</I>&gt;<i> Do you really need the methods to be compiled right away?
</I>&gt;<i> It would be good to delay compilation to when the methods are actually
</I>&gt;<i> used.
</I>

These are unmanaged-&gt;managed transition wrappers, so I compile these to get
the function pointers to fill the COM vtables.

&gt;<i> +                             for (param_index =
</I>&gt;<i> sig_adjusted-&gt;param_count; param_index &gt;= 0; param_index--)
</I>&gt;<i> &gt; +                                     if (mspecs [param_index])
</I>&gt;<i> &gt; +
</I>&gt;<i> mono_metadata_free_marshal_spec (mspecs [param_index]);
</I>&gt;<i> &gt; +                             g_free (mspecs);
</I>&gt;<i> &gt; +                     }
</I>&gt;<i> &gt; +                     if (iface-&gt;interface_count)
</I>&gt;<i> &gt; +                             iface = iface-&gt;interfaces[0];
</I>&gt;<i> &gt; +                     else
</I>&gt;<i> &gt; +                             iface = NULL;
</I>&gt;<i> &gt; +             }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             ccw_entry = g_new0 (MonoCCWEntry, 1);
</I>&gt;<i> &gt; +             ccw_entry-&gt;ccw = ccw;
</I>&gt;<i> &gt; +             ccw_entry-&gt;vtable = vtable;
</I>&gt;<i> &gt; +             g_hash_table_insert (ccw-&gt;vtable_hash, itf, ccw_entry);
</I>&gt;<i> &gt; +             g_hash_table_insert (ccw_entry_hash, ccw_entry, ccw);
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     return ccw_entry;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static gboolean
</I>&gt;<i> &gt; +mono_marshal_free_ccw_entry (gpointer key, gpointer value, gpointer
</I>&gt;<i> user_data)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     MonoCCWEntry* entry = (MonoCCWEntry*)value;
</I>&gt;<i>
</I>&gt;<i> No need to use a cast here.
</I>

Removed cast.

&gt;<i> +gboolean
</I>&gt;<i> &gt; +mono_marshal_free_ccw (MonoObject* object)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     MonoCCW* ccw = NULL;
</I>&gt;<i> &gt; +     // no ccw's were created
</I>&gt;<i> &gt; +     if (!ccw_hash)
</I>&gt;<i> &gt; +             return FALSE;
</I>&gt;<i> &gt; +
</I>&gt;<i>
</I>&gt;<i> You might want to add also a check for g_hash_table_size () == 0 here.
</I>

Added check.

&gt;<i> +static int STDCALL
</I>&gt;<i> &gt; +cominterop_ccw_addref (MonoCCWEntry* ccwe)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     MonoCCW* ccw = ccwe-&gt;ccw;
</I>&gt;<i> &gt; +     g_assert (ccw);
</I>&gt;<i> &gt; +     g_assert (ccw-&gt;object);
</I>&gt;<i> &gt; +     g_assert (ccw-&gt;ref_count &gt;= 0);
</I>&gt;<i> &gt; +     ccw-&gt;ref_count++;
</I>&gt;<i> &gt; +     if (ccw-&gt;ref_count == 1) {
</I>&gt;<i> &gt; +             /* since we now have a ref count, alloc a handle*/
</I>&gt;<i> &gt; +             ccw-&gt;gc_handle = mono_gchandle_new (ccw-&gt;object, FALSE);
</I>&gt;<i> &gt; +     }
</I>&gt;<i>
</I>&gt;<i> Can you explain this MonoCCW data structure here? It has a pointer
</I>&gt;<i> to a reference which isn't GC-tracked and so it's bad. It looks to be
</I>&gt;<i> created with a 0 refcount and an handle is created for the object, so
</I>&gt;<i> there doesn't seem to be any need to store also an object in it.
</I>&gt;<i> Also, the reference count increase is done in a thread-unsafe way.
</I>

I've removed the object reference. I only allocate a weak handle and set the
reference count to 0. If the unmanaged client code decides to addref and
hold onto the CCW, I then allocate a strong handle. Once the reference count
goes back to 0 I go back to a weak handle.

&gt;<i> +     return ccw-&gt;ref_count;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int STDCALL
</I>&gt;<i> &gt; +cominterop_ccw_release (MonoCCWEntry* ccwe)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     MonoCCW* ccw = ccwe-&gt;ccw;
</I>&gt;<i> &gt; +     g_assert (ccw);
</I>&gt;<i> &gt; +     g_assert (ccw-&gt;object);
</I>&gt;<i> &gt; +     g_assert (ccw-&gt;ref_count &gt; 0);
</I>&gt;<i> &gt; +     ccw-&gt;ref_count--;
</I>&gt;<i> &gt; +     if (ccw-&gt;ref_count == 0) {
</I>&gt;<i> &gt; +             /* allow gc of object */
</I>&gt;<i> &gt; +             guint32 handle = ccw-&gt;gc_handle;
</I>&gt;<i> &gt; +             g_assert (handle);
</I>&gt;<i> &gt; +             ccw-&gt;gc_handle = 0;
</I>&gt;<i> &gt; +             mono_gchandle_free (handle);
</I>&gt;<i>
</I>&gt;<i> Why doesn't this clear ccw-&gt;object?
</I>

Object reference removed.

&gt;<i> +static int STDCALL
</I>&gt;<i> &gt; +cominterop_ccw_get_type_info_count (MonoCCWEntry* ccwe, guint32
</I>&gt;<i> *pctinfo)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     if (pctinfo)
</I>&gt;<i> &gt; +             *pctinfo = 1;
</I>&gt;<i> &gt; +     return 0x80004001L;
</I>&gt;<i>
</I>&gt;<i> Better use a named define here for clarity of what the number means.
</I>

Added named defines for basic error codes.

&gt;<i> Index: mono/mono/metadata/gc.c
</I>&gt;<i> &gt; ===================================================================
</I>&gt;<i> &gt; --- mono/mono/metadata/gc.c   (revision 68741)
</I>&gt;<i> &gt; +++ mono/mono/metadata/gc.c   (working copy)
</I>&gt;<i> &gt; @@ -61,6 +61,7 @@
</I>&gt;<i> &gt;  {
</I>&gt;<i> &gt;       MonoObject *exc = NULL;
</I>&gt;<i> &gt;       MonoObject *o, *o2;
</I>&gt;<i> &gt; +     MonoMethod* finalizer = NULL;
</I>&gt;<i> &gt;       o = (MonoObject*)((char*)obj + GPOINTER_TO_UINT (data));
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  #ifndef HAVE_SGEN_GC
</I>&gt;<i> &gt; @@ -100,8 +101,15 @@
</I>&gt;<i> &gt;               return;
</I>&gt;<i> &gt;       }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     mono_runtime_invoke (mono_class_get_finalizer (o-&gt;vtable-&gt;klass),
</I>&gt;<i> o, NULL, &amp;exc);
</I>&gt;<i> &gt; +     finalizer = mono_class_get_finalizer (o-&gt;vtable-&gt;klass);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +     /* if we area ccw, and have no finalizer method just return
</I>&gt;<i> &gt; +      * else run regular finalizer after freeing ccw */
</I>&gt;<i> &gt; +     if (mono_marshal_free_ccw (o) &amp;&amp; !finalizer)
</I>&gt;<i> &gt; +             return;
</I>&gt;<i>
</I>&gt;<i> So what happens if the object has a finalizer and wants to use COM
</I>&gt;<i> features in it? Is that not possible? We need a comment here.
</I>&gt;<i> You may also want to check what happens with resurrection (ie the
</I>&gt;<i> objects stores itself in a static field inside the finalizer).
</I>

Added better comment. If an object has a CCW associated with it and has no
finalizer we can safely return after destroying the CCW since we are only
being finalized since COM Interop registered the object for finalization to
clean up the CCW. In all other cases we continue on (including the case you
brought up where an object has a finalizer and has been exposed to unmanaged
code via a CCW) to call the objects finalizer. I've added a FIXME for
resurrection, and also if the user calls SuppressFinalize the CCW will leak
currently. I see what is done for delegates in that case, but this is a bit
different. I currently have no way to determine that an object with a
finalizer needs it's CCW destroyed but don't need it's finalizer run.

Thanks!
&gt;<i>
</I>&gt;<i> lupus
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> -----------------------------------------------------------------
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>

Also, there are some places I know I need to make threadsafe. Should I
create a new critical section, or just use the marshal one?

Thanks,
Jonathan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20061204/5d912659/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20061204/5d912659/attachment.html</A> 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ccw11.diff
Type: text/x-patch
Size: 60864 bytes
Desc: not available
Url : <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20061204/5d912659/attachment.bin">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20061204/5d912659/attachment.bin</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="021628.html">[Mono-dev] COM Callable Wrapper Patch
</A></li>
	<LI>Next message: <A HREF="021655.html">[Mono-dev] COM Callable Wrapper Patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21636">[ date ]</a>
              <a href="thread.html#21636">[ thread ]</a>
              <a href="subject.html#21636">[ subject ]</a>
              <a href="author.html#21636">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
