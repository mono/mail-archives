<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] COM Callable Wrapper Patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20COM%20Callable%20Wrapper%20Patch&In-Reply-To=17c2d80b0612011333o52bc4c2ev929d45769fc16f1b%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="021605.html">
   <LINK REL="Next"  HREF="021636.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] COM Callable Wrapper Patch</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20COM%20Callable%20Wrapper%20Patch&In-Reply-To=17c2d80b0612011333o52bc4c2ev929d45769fc16f1b%40mail.gmail.com"
       TITLE="[Mono-dev] COM Callable Wrapper Patch">lupus at ximian.com
       </A><BR>
    <I>Mon Dec  4 12:53:12 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="021605.html">[Mono-dev] COM Callable Wrapper Patch
</A></li>
        <LI>Next message: <A HREF="021636.html">[Mono-dev] COM Callable Wrapper Patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21628">[ date ]</a>
              <a href="thread.html#21628">[ thread ]</a>
              <a href="subject.html#21628">[ subject ]</a>
              <a href="author.html#21628">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/01/06 Jon Chambers wrote:
&gt;<i> Index: mono/mono/metadata/loader.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/loader.c	(revision 68741)
</I>&gt;<i> +++ mono/mono/metadata/loader.c	(working copy)
</I>&gt;<i> @@ -1377,7 +1377,7 @@
</I>&gt;<i>  	    !(cols [1] &amp; METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) &amp;&amp;
</I>&gt;<i>  	    !(result-&gt;iflags &amp; METHOD_IMPL_ATTRIBUTE_RUNTIME) &amp;&amp; container) {
</I>&gt;<i>  		gpointer loc = mono_image_rva_map (image, cols [0]);
</I>&gt;<i> -		g_assert (loc);
</I>&gt;<i> +		g_assert (loc) ;
</I>
This change is incorrect and should be dropped.

&gt;<i> Index: mono/mono/metadata/domain.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/domain.c	(revision 68741)
</I>&gt;<i> +++ mono/mono/metadata/domain.c	(working copy)
</I>&gt;<i> @@ -812,14 +812,24 @@
</I>&gt;<i>  
</I>&gt;<i>  	mono_defaults.variant_class = mono_class_from_name (
</I>&gt;<i>  	        mono_defaults.corlib, &quot;System&quot;, &quot;Variant&quot;);
</I>&gt;<i> +	g_assert (mono_defaults.variant_class != 0);
</I>
I think we should move away from asserting here. I most cases
the types here should be initialized lazily to avoid increasing startup
time and memory usage. Likely all the COM-related types can be loaded
lazily the first time some COM feature is used.
It's still fine to have the fields in mono_defaults.

&gt;<i> Index: mono/mono/metadata/marshal.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/marshal.c	(revision 68741)
</I>&gt;<i> +++ mono/mono/metadata/marshal.c	(working copy)
</I>&gt;<i> @@ -386,6 +448,10 @@
</I>&gt;<i>  	return rt;
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/* End COM Interop related stuff until seperate file */
</I>&gt;<i> +
</I>&gt;<i>  void
</I>&gt;<i>  mono_marshal_init (void)
</I>&gt;<i>  {
</I>&gt;<i> @@ -446,6 +512,8 @@
</I>&gt;<i>  		register_icall (cominterop_get_method_interface, &quot;cominterop_get_method_interface&quot;, &quot;object ptr&quot;, FALSE);
</I>&gt;<i>  		register_icall (cominterop_get_function_pointer, &quot;cominterop_get_function_pointer&quot;, &quot;ptr ptr int32&quot;, FALSE);
</I>&gt;<i>  		register_icall (cominterop_object_is_rcw, &quot;cominterop_object_is_rcw&quot;, &quot;int32 object&quot;, FALSE);
</I>&gt;<i> +		register_icall (cominterop_get_ccw, &quot;cominterop_get_ccw&quot;, &quot;ptr object ptr&quot;, FALSE);
</I>&gt;<i> +		register_icall (cominterop_get_ccw_object, &quot;cominterop_get_ccw_object&quot;, &quot;object ptr int32&quot;, FALSE);
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i> @@ -1796,7 +1864,7 @@
</I>&gt;<i>  		static MonoMethod* com_interop_proxy_get_proxy = NULL;
</I>&gt;<i>  		static MonoMethod* get_transparent_proxy = NULL;
</I>&gt;<i>  		int real_proxy;
</I>&gt;<i> -		guint32 pos_failed = 0;
</I>&gt;<i> +		guint32 pos_null = 0, pos_ccw = 0, pos_end = 0;
</I>&gt;<i>  		MonoClass *klass = mono_class_from_mono_type (type);
</I>&gt;<i>  
</I>&gt;<i>  		mono_mb_emit_ldloc (mb, 1);
</I>&gt;<i> @@ -1805,8 +1873,17 @@
</I>&gt;<i>  
</I>&gt;<i>  		mono_mb_emit_ldloc (mb, 0);
</I>&gt;<i>  		mono_mb_emit_byte (mb, CEE_LDIND_I);
</I>&gt;<i> -		pos_failed = mono_mb_emit_short_branch (mb, CEE_BRFALSE_S);
</I>&gt;<i> +		pos_null = mono_mb_emit_short_branch (mb, CEE_BRFALSE_S);
</I>&gt;<i>  
</I>&gt;<i> +		// load dst to store later
</I>&gt;<i> +		mono_mb_emit_ldloc (mb, 1);
</I>&gt;<i> +
</I>&gt;<i> +		mono_mb_emit_ldloc (mb, 0);
</I>&gt;<i> +		mono_mb_emit_byte (mb, CEE_LDIND_I);
</I>&gt;<i> +		mono_mb_emit_icon (mb, TRUE);
</I>&gt;<i> +		mono_mb_emit_icall (mb, cominterop_get_ccw_object);
</I>&gt;<i> +		pos_ccw = mono_mb_emit_short_branch (mb, CEE_BRTRUE_S);
</I>&gt;<i> +
</I>&gt;<i>  		if (!com_interop_proxy_class)
</I>&gt;<i>  			com_interop_proxy_class = mono_class_from_name (mono_defaults.corlib, &quot;Mono.Interop&quot;, &quot;ComInteropProxy&quot;);
</I>&gt;<i>  		if (!com_interop_proxy_get_proxy)
</I>&gt;<i> @@ -1821,18 +1898,35 @@
</I>&gt;<i>  		mono_mb_emit_ptr (mb, &amp;mono_defaults.com_object_class-&gt;byval_arg);
</I>&gt;<i>  		mono_mb_emit_icall (mb, type_from_handle);
</I>&gt;<i>  		mono_mb_emit_managed_call (mb, com_interop_proxy_get_proxy, NULL);
</I>&gt;<i> -		mono_mb_emit_stloc (mb, real_proxy);
</I>&gt;<i> +		//mono_mb_emit_stloc (mb, real_proxy);
</I>&gt;<i>  
</I>&gt;<i>  		
</I>&gt;<i> -		mono_mb_emit_ldloc (mb, 1);
</I>&gt;<i> -		mono_mb_emit_ldloc (mb, real_proxy);
</I>&gt;<i> +		//mono_mb_emit_ldloc (mb, 1);
</I>&gt;<i> +		//mono_mb_emit_ldloc (mb, real_proxy);
</I>
Why is this code commented out?

&gt;<i> +GHashTable* ccw_hash = NULL;
</I>&gt;<i> +GHashTable* ccw_entry_hash = NULL;
</I>
These must be static. Also, document with a comment what the key and
value types are for each hashtable.

&gt;<i> +/**
</I>&gt;<i> + * cominterop_get_ccw:
</I>&gt;<i> + * @object: a pointer to the object
</I>&gt;<i> + * @itf: interface type needed
</I>&gt;<i> + *
</I>&gt;<i> + * Returns: a value indicating if the object is a
</I>&gt;<i> + * Runtime Callable Wrapper (RCW) for a COM object
</I>&gt;<i> + */
</I>&gt;<i> +static gpointer
</I>&gt;<i> +cominterop_get_ccw (MonoObject* object, MonoClass* itf)
</I>&gt;<i> +{
</I>&gt;<i> +	int i;
</I>&gt;<i> +	MonoCCW *ccw = NULL;
</I>&gt;<i> +	MonoCCWEntry* ccw_entry = NULL;
</I>&gt;<i> +	gpointer *vtable = NULL;
</I>&gt;<i> +	static gpointer iunknown[3] = {NULL, NULL, NULL};
</I>&gt;<i> +	static gpointer idispatch[4] = {NULL, NULL, NULL, NULL};
</I>&gt;<i> +	MonoClass* iface = NULL;
</I>&gt;<i> +	MonoClass* klass = NULL;
</I>&gt;<i> +	EmitMarshalContext m;
</I>&gt;<i> +	int start_slot = 3;
</I>&gt;<i> +	int method_count = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (!object)
</I>&gt;<i> +		return NULL;
</I>&gt;<i> +
</I>&gt;<i> +	klass = mono_object_get_class (object);
</I>&gt;<i> +
</I>&gt;<i> +	if (!ccw_hash)
</I>&gt;<i> +		ccw_hash = g_hash_table_new (mono_aligned_addr_hash, NULL);
</I>&gt;<i> +	if (!ccw_entry_hash)
</I>&gt;<i> +		ccw_entry_hash = g_hash_table_new (mono_aligned_addr_hash, NULL);
</I>&gt;<i> +
</I>&gt;<i> +	ccw = g_hash_table_lookup (ccw_hash, object);
</I>&gt;<i> +
</I>&gt;<i> +	if (!iunknown[0]) {
</I>&gt;<i> +		iunknown[0] = cominterop_ccw_queryinterface;
</I>&gt;<i> +		iunknown[1] = cominterop_ccw_addref;
</I>&gt;<i> +		iunknown[2] = cominterop_ccw_release;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (!idispatch[0]) {
</I>&gt;<i> +		idispatch[0] = cominterop_ccw_get_type_info_count;
</I>&gt;<i> +		idispatch[1] = cominterop_ccw_get_type_info;
</I>&gt;<i> +		idispatch[2] = cominterop_ccw_get_ids_of_names;
</I>&gt;<i> +		idispatch[3] = cominterop_ccw_invoke;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (!ccw) {
</I>&gt;<i> +		ccw = g_new0 (MonoCCW, 1);
</I>&gt;<i> +		ccw-&gt;vtable_hash = g_hash_table_new (mono_aligned_addr_hash, NULL);
</I>&gt;<i> +		ccw-&gt;ref_count = 0;
</I>&gt;<i> +		ccw-&gt;object = object;
</I>&gt;<i> +		g_hash_table_insert (ccw_hash, object, ccw);
</I>
You can't insert a managed object inside a GHashTable, since objects
can move and the GC can't see inside GHashTable, you'll get a broken
pointer and a crash. If the hash must not keep alive the object and you
used a GHashTable as a way to implement weak references, you must use
the runtime support for weak references instead. Also, remember that for
object hashes you must use the mono_object_hash() function.

&gt;<i> +		// register for finalization to clean up ccw
</I>&gt;<i> +		mono_object_register_finalizer (object);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	iface = itf;
</I>&gt;<i> +	if (iface == mono_defaults.iunknown_class) {
</I>&gt;<i> +		start_slot = 3;
</I>&gt;<i> +	}
</I>&gt;<i> +	else if (iface == mono_defaults.idispatch_class) {
</I>&gt;<i> +		start_slot = 7;
</I>&gt;<i> +	}
</I>&gt;<i> +	else {
</I>&gt;<i> +		while (iface) {
</I>&gt;<i> +			method_count += iface-&gt;method.count;
</I>&gt;<i> +			if (iface-&gt;interface_count) {
</I>&gt;<i> +				iface = iface-&gt;interfaces[0];
</I>&gt;<i> +			}
</I>&gt;<i> +			else {
</I>&gt;<i> +				start_slot = cominterop_get_com_slot_begin (iface);
</I>&gt;<i> +				iface = NULL;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	ccw_entry = g_hash_table_lookup (ccw-&gt;vtable_hash, itf);
</I>&gt;<i> +
</I>&gt;<i> +	if (!ccw_entry) {
</I>&gt;<i> +		int vtable_index = method_count-1+start_slot;
</I>&gt;<i> +
</I>&gt;<i> +		vtable = mono_mempool_alloc0 (klass-&gt;image-&gt;mempool, sizeof (gpointer)*(method_count+start_slot));
</I>
You need to take the loader lock to allocate from image-&gt;mempool.

&gt;<i> +		memcpy(vtable, iunknown, sizeof(iunknown));
</I>&gt;<i> +		if (start_slot == 7)
</I>&gt;<i> +			memcpy(vtable+3, idispatch, sizeof(idispatch));
</I>&gt;<i> +
</I>&gt;<i> +		iface = itf;
</I>&gt;<i> +		while (iface) {
</I>&gt;<i> +			for (i = iface-&gt;method.count-1; i &gt;= 0;i--) {
</I>&gt;<i> +				int param_index = 0;
</I>&gt;<i> +				MonoMethodBuilder *mb;
</I>&gt;<i> +				MonoMarshalSpec ** mspecs;
</I>&gt;<i> +				MonoMethod *wrapper_method, *adjust_method;
</I>&gt;<i> +				MonoMethod *method = iface-&gt;methods[i];
</I>&gt;<i> +				MonoMethodSignature* sig_adjusted;
</I>&gt;<i> +				MonoMethodSignature* sig = mono_method_signature (method);
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +				mb = mono_mb_new (iface, method-&gt;name, MONO_WRAPPER_CCW);
</I>&gt;<i> +				adjust_method = cominterop_get_managed_wrapper_adjusted (method);
</I>&gt;<i> +				sig_adjusted = mono_method_signature (adjust_method);
</I>&gt;<i> +				
</I>&gt;<i> +				mspecs = g_new (MonoMarshalSpec*, sig_adjusted-&gt;param_count + 1);
</I>&gt;<i> +				mono_method_get_marshal_info (method, mspecs);
</I>&gt;<i> +
</I>&gt;<i> +				
</I>&gt;<i> +				// move managed args up one
</I>&gt;<i> +				for (param_index = sig-&gt;param_count; param_index &gt;= 1; param_index--)
</I>&gt;<i> +					mspecs[param_index+1] = mspecs[param_index];
</I>
Here and in the other places, put a space before the [ of an array
access.

&gt;<i> +
</I>&gt;<i> +				// first arg is IntPtr for interface
</I>&gt;<i> +				mspecs[1] = NULL;
</I>&gt;<i> +
</I>&gt;<i> +				// move return spec to last param
</I>&gt;<i> +				if (!MONO_TYPE_IS_VOID (sig-&gt;ret))
</I>&gt;<i> +					mspecs[sig_adjusted-&gt;param_count] = mspecs[0];
</I>&gt;<i> +
</I>&gt;<i> +				mspecs[0] = NULL;
</I>&gt;<i> +
</I>&gt;<i> +				cominterop_setup_marshal_context (&amp;m, adjust_method);
</I>&gt;<i> +				m.mb = mb;
</I>&gt;<i> +				mono_marshal_emit_managed_wrapper (mb, sig_adjusted, mspecs, &amp;m, adjust_method, NULL);
</I>&gt;<i> +				mono_loader_lock ();
</I>&gt;<i> +				mono_marshal_lock ();
</I>&gt;<i> +				wrapper_method = mono_mb_create_method (mb, sig_adjusted, sig_adjusted-&gt;param_count + 16);
</I>&gt;<i> +				mono_marshal_unlock ();
</I>&gt;<i> +				mono_loader_unlock ();
</I>&gt;<i> +				vtable[vtable_index--] = mono_compile_method (wrapper_method);
</I>
Do you really need the methods to be compiled right away?
It would be good to delay compilation to when the methods are actually
used.

&gt;<i> +				for (param_index = sig_adjusted-&gt;param_count; param_index &gt;= 0; param_index--)
</I>&gt;<i> +					if (mspecs [param_index])
</I>&gt;<i> +						mono_metadata_free_marshal_spec (mspecs [param_index]);
</I>&gt;<i> +				g_free (mspecs);
</I>&gt;<i> +			}
</I>&gt;<i> +			if (iface-&gt;interface_count)
</I>&gt;<i> +				iface = iface-&gt;interfaces[0];
</I>&gt;<i> +			else 
</I>&gt;<i> +				iface = NULL;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		ccw_entry = g_new0 (MonoCCWEntry, 1);
</I>&gt;<i> +		ccw_entry-&gt;ccw = ccw;
</I>&gt;<i> +		ccw_entry-&gt;vtable = vtable;
</I>&gt;<i> +		g_hash_table_insert (ccw-&gt;vtable_hash, itf, ccw_entry);
</I>&gt;<i> +		g_hash_table_insert (ccw_entry_hash, ccw_entry, ccw);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return ccw_entry;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static gboolean    
</I>&gt;<i> +mono_marshal_free_ccw_entry (gpointer key, gpointer value, gpointer user_data)
</I>&gt;<i> +{
</I>&gt;<i> +	MonoCCWEntry* entry = (MonoCCWEntry*)value;
</I>
No need to use a cast here.

&gt;<i> +gboolean
</I>&gt;<i> +mono_marshal_free_ccw (MonoObject* object)
</I>&gt;<i> +{
</I>&gt;<i> +	MonoCCW* ccw = NULL;
</I>&gt;<i> +	// no ccw's were created
</I>&gt;<i> +	if (!ccw_hash)
</I>&gt;<i> +		return FALSE;
</I>&gt;<i> +
</I>
You might want to add also a check for g_hash_table_size () == 0 here.

&gt;<i> +static int STDCALL 
</I>&gt;<i> +cominterop_ccw_addref (MonoCCWEntry* ccwe)
</I>&gt;<i> +{
</I>&gt;<i> +	MonoCCW* ccw = ccwe-&gt;ccw;
</I>&gt;<i> +	g_assert (ccw);
</I>&gt;<i> +	g_assert (ccw-&gt;object);
</I>&gt;<i> +	g_assert (ccw-&gt;ref_count &gt;= 0);
</I>&gt;<i> +	ccw-&gt;ref_count++;
</I>&gt;<i> +	if (ccw-&gt;ref_count == 1) {
</I>&gt;<i> +		/* since we now have a ref count, alloc a handle*/
</I>&gt;<i> +		ccw-&gt;gc_handle = mono_gchandle_new (ccw-&gt;object, FALSE);
</I>&gt;<i> +	}
</I>
Can you explain this MonoCCW data structure here? It has a pointer
to a reference which isn't GC-tracked and so it's bad. It looks to be
created with a 0 refcount and an handle is created for the object, so
there doesn't seem to be any need to store also an object in it.
Also, the reference count increase is done in a thread-unsafe way.

&gt;<i> +	return ccw-&gt;ref_count;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int STDCALL 
</I>&gt;<i> +cominterop_ccw_release (MonoCCWEntry* ccwe)
</I>&gt;<i> +{
</I>&gt;<i> +	MonoCCW* ccw = ccwe-&gt;ccw;
</I>&gt;<i> +	g_assert (ccw);
</I>&gt;<i> +	g_assert (ccw-&gt;object);
</I>&gt;<i> +	g_assert (ccw-&gt;ref_count &gt; 0);
</I>&gt;<i> +	ccw-&gt;ref_count--;
</I>&gt;<i> +	if (ccw-&gt;ref_count == 0) {
</I>&gt;<i> +		/* allow gc of object */
</I>&gt;<i> +		guint32 handle = ccw-&gt;gc_handle;
</I>&gt;<i> +		g_assert (handle);
</I>&gt;<i> +		ccw-&gt;gc_handle = 0;
</I>&gt;<i> +		mono_gchandle_free (handle);
</I>
Why doesn't this clear ccw-&gt;object?

&gt;<i> +static int STDCALL 
</I>&gt;<i> +cominterop_ccw_get_type_info_count (MonoCCWEntry* ccwe, guint32 *pctinfo)
</I>&gt;<i> +{
</I>&gt;<i> +	if (pctinfo)
</I>&gt;<i> +		*pctinfo = 1;
</I>&gt;<i> +	return 0x80004001L;
</I>
Better use a named define here for clarity of what the number means.

&gt;<i> Index: mono/mono/metadata/gc.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/gc.c	(revision 68741)
</I>&gt;<i> +++ mono/mono/metadata/gc.c	(working copy)
</I>&gt;<i> @@ -61,6 +61,7 @@
</I>&gt;<i>  {
</I>&gt;<i>  	MonoObject *exc = NULL;
</I>&gt;<i>  	MonoObject *o, *o2;
</I>&gt;<i> +	MonoMethod* finalizer = NULL;
</I>&gt;<i>  	o = (MonoObject*)((char*)obj + GPOINTER_TO_UINT (data));
</I>&gt;<i>  
</I>&gt;<i>  #ifndef HAVE_SGEN_GC
</I>&gt;<i> @@ -100,8 +101,15 @@
</I>&gt;<i>  		return;
</I>&gt;<i>  	}
</I>&gt;<i>  
</I>&gt;<i> -	mono_runtime_invoke (mono_class_get_finalizer (o-&gt;vtable-&gt;klass), o, NULL, &amp;exc);
</I>&gt;<i> +	finalizer = mono_class_get_finalizer (o-&gt;vtable-&gt;klass);
</I>&gt;<i>  
</I>&gt;<i> +	/* if we area ccw, and have no finalizer method just return 
</I>&gt;<i> +	 * else run regular finalizer after freeing ccw */ 
</I>&gt;<i> +	if (mono_marshal_free_ccw (o) &amp;&amp; !finalizer)
</I>&gt;<i> +		return;
</I>
So what happens if the object has a finalizer and wants to use COM
features in it? Is that not possible? We need a comment here.
You may also want to check what happens with resurrection (ie the
objects stores itself in a static field inside the finalizer).

Thanks!

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="021605.html">[Mono-dev] COM Callable Wrapper Patch
</A></li>
	<LI>Next message: <A HREF="021636.html">[Mono-dev] COM Callable Wrapper Patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21628">[ date ]</a>
              <a href="thread.html#21628">[ thread ]</a>
              <a href="subject.html#21628">[ subject ]</a>
              <a href="author.html#21628">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
