<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Single thread scheduler for Threading.Timers  patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Single%20thread%20scheduler%20for%20Threading.Timers%20%20patch&In-Reply-To=3785-35152%40sneakemail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018939.html">
   <LINK REL="Next"  HREF="018974.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Single thread scheduler for Threading.Timers  patch</H1>
    <B>Rafael Ferreira</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Single%20thread%20scheduler%20for%20Threading.Timers%20%20patch&In-Reply-To=3785-35152%40sneakemail.com"
       TITLE="[Mono-dev] Single thread scheduler for Threading.Timers  patch">lists at ophion.org
       </A><BR>
    <I>Fri Jun 16 04:04:01 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018939.html">[Mono-dev] Single thread scheduler for Threading.Timers   patch
</A></li>
        <LI>Next message: <A HREF="018974.html">[Mono-dev] Fedora Core 5 rpms now available for Monodevelop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18972">[ date ]</a>
              <a href="thread.html#18972">[ thread ]</a>
              <a href="subject.html#18972">[ subject ]</a>
              <a href="author.html#18972">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>sorry for the late response to this email but work has kept me quite
busy lately. 

- raf 

On Wed, 2006-06-14 at 15:19 -0500, Jonathan Gilbert wrote:
&gt;<i> At 09:37 AM 14/06/2006 -0700, Rafael Ferreira wrote:
</I>&gt;<i> &gt;Hey there, let me start by saying thanks for the feedback.. my commments
</I>&gt;<i> &gt;below:
</I>&gt;<i> 
</I>&gt;<i> No problem :-) By the way, it may have appeared to be off of the list (I
</I>&gt;<i> mention this because I didn't see your reply on the list), but actually my
</I>&gt;<i> post was to mono-devel-list and CCed to you. I've done the same with this
</I>&gt;<i> reply; I hope that's okay with you :-)
</I>&gt;<i> 
</I>&gt;<i> &gt;&gt; At 11:04 PM 13/06/2006 -0700, Rafael Ferreira wrote:
</I>&gt;<i> &gt;&gt;&gt;Howdy,
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;The attached patch changes the current Threading.Timer class to use a
</I>&gt;<i> &gt;&gt;&gt;single thread scheduler instead of the current 1 thread per timer logic.
</I>&gt;<i> &gt;&gt;&gt;I also spent a lot of time working on the Timer unit tests so they more
</I>&gt;<i> &gt;&gt;&gt;consistently pass as well as fixing the &quot;NotWorking&quot; tests.
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;Some key features include:
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;* A single thread handles firing all timer jobs thus allowing a much
</I>&gt;<i> &gt;&gt;&gt;greater number of Timers to be defined - Fixing bug #65734
</I>&gt;<i> &gt;&gt;&gt;* Timer scheduler is only started after the first System.Threading.Timer
</I>&gt;<i> &gt;&gt;&gt;is created (lazy init)
</I>&gt;<i> &gt;&gt;&gt;* Timer scheduler thread dies if there are no more timer jobs in its Job
</I>&gt;<i> &gt;&gt;&gt;queue (early termination)
</I>&gt;<i> &gt;&gt;&gt;* Scheduler can spit out debug info by exporting the MONO_TIMER_DEBUG
</I>&gt;<i> &gt;&gt;&gt;environment variable
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; One thing that gets me about the design is the way that timer events are
</I>&gt;<i> &gt;&gt; marshalled to a different thread (in the thread pool) in order to be
</I>&gt;<i> &gt;&gt; fired.
</I>&gt;<i> &gt;&gt; Obviously, you don't want synchronous callbacks from a single thread for
</I>&gt;<i> &gt;&gt; all timers, but perhaps a timer thread pool, each of which handling a
</I>&gt;<i> &gt;&gt; subset of the timers, would be a viable alternate design. With a limit of,
</I>&gt;<i> &gt;&gt; say, 100 scheduler threads, up to 100 timers could be created without any
</I>&gt;<i> &gt;&gt; chance of interference, and after that point, the threads would be reused
</I>&gt;<i> &gt;&gt; instead of overloading the system with thousands of threads. The threads
</I>&gt;<i> &gt;&gt; could even switch from synchronous callbacks when they are handling only a
</I>&gt;<i> &gt;&gt; single timer to asynchronous thread pool callbacks when their
</I>&gt;<i> &gt;&gt; responsibilities increase.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;I'm not sure what do you mean by &quot;marshalled to a different thread&quot;,
</I>&gt;<i> &gt;there's no serialization taking place here and this implementation is not
</I>&gt;<i> &gt;any different than what is currently being done by the timer class. The
</I>&gt;<i> &gt;only difference is that I chose to call ThreadPool.QueueUserWorkItem
</I>&gt;<i> &gt;explicitly instead of using .BeingInvoke(). Also, having n scheduler
</I>&gt;<i> &gt;therads would not help you much, actually I the whole point of the
</I>&gt;<i> &gt;single-thread scheduler is to minimize idle threads.
</I>&gt;<i> 
</I>&gt;<i> The call to ThreadPool.QueueUserWorkItem *is* the marshalling I was
</I>&gt;<i> referring to. It isn't data that's being marshalled, but rather the
</I>&gt;<i> function call itself. The only concern I had was with the responsiveness of
</I>&gt;<i> thread pool threads being awakened when they have possibly been asleep for
</I>&gt;<i> a long time; if pages have to be brought into memory when the thread pool
</I>&gt;<i> threads unblock, then the timer will have possibly several additional
</I>&gt;<i> seconds of delay added to the callback. Obviously, making the callback from
</I>&gt;<i> the thread that is driving the timer wouldn't have this problem, but it
</I>&gt;<i> would have the different problem that if the callback takes too long the
</I>&gt;<i> timer's activity (and that of any other timers on the same thread) will be
</I>&gt;<i> negatively affected.
</I>&gt;<i> 
</I>&gt;<i> I'm not actually sure how Microsoft's implementation works. I could write a
</I>&gt;<i> couple of tests and run them. Specifically, what I'm interested to know is,
</I>&gt;<i> if you have only one timer running, and that timer's callback takes longer
</I>&gt;<i> than the interval, will the next timer tick cause another, re-entrant call
</I>&gt;<i> into the callback on another thread, or does that next tick get delayed
</I>&gt;<i> until the callback returns? The MSDN documentation makes it clear that
</I>&gt;<i> thread pool threads are involved, but it doesn't indicate whether the
</I>&gt;<i> thread pool threads themselves drive the timer, or whether the timer(s) are
</I>&gt;<i> driven by a separate thread and only the callbacks are done through the
</I>&gt;<i> thread pool.
</I>
According to my tests and the documentation I found here

<A HREF="http://msdn.microsoft.com/msdnmag/issues/04/02/TimersinNET/default.aspx">http://msdn.microsoft.com/msdnmag/issues/04/02/TimersinNET/default.aspx</A>

which describes the re-entrance problem you described above, I believe
that the behavior of my implementation is consistent... but I'm not
claiming to be an expert on Timers. 
It might help you to look over the current Timer implementation so you
can get a sense for how we're currently utilizing the threadpool to
handle timers.

&gt;<i> 
</I>&gt;<i> &gt;&gt; If we accept the single-thread thread-pool-callback design, though, I have
</I>&gt;<i> &gt;&gt; the following comments on the implementation:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; 1. A heap structure is very easy to maintain, and would be a significantly
</I>&gt;<i> &gt;&gt; more efficient way to find the next event to be fired. You have comments
</I>&gt;<i> &gt;&gt; that acknowledge the deficiency of looping over the entire set every time,
</I>&gt;<i> &gt;&gt; and I think this would be the logical next step in this.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;I agree that a sorted data structure would speed things up the problem
</I>&gt;<i> &gt;there is that SortedList will just not cut it and writing a new data
</I>&gt;<i> &gt;structure (or a wrapper class) just didn't sense just to speed up a very
</I>&gt;<i> &gt;edge case (how many users are going create 10k timers?)
</I>&gt;<i> 
</I>&gt;<i> Sure, but heaps are especially easy to write :-) They fit into an array,
</I>&gt;<i> and they require only three helper methods to update the structure: swap,
</I>&gt;<i> heapify-up and heapify-down.
</I>&gt;<i> 
</I>&gt;<i> When a new timer is added, you simply drop it onto the end of the array,
</I>&gt;<i> and then heapify-up. When a timer tick occurs, you move the item at the end
</I>&gt;<i> of the array overtop of the one at the front of the array, and then
</I>&gt;<i> heapify-down. Following these rules, the first entry in the array will
</I>&gt;<i> always be the next event to fire.
</I>&gt;<i> 
</I>&gt;<i> The heapifying functions are relatively simple to implement and take only a
</I>&gt;<i> dozen lines each.
</I>
&gt;<i> &gt;&gt; 2. Using Thread.Abort to signal the thread is fundamentally flawed. A user
</I>&gt;<i> &gt;&gt; very quickly adding &amp; removing timers would eventually cause a
</I>&gt;<i> &gt;&gt; ThreadAbortException to fire inside the 'catch' handler, killing off the
</I>&gt;<i> &gt;&gt; scheduler thread and disabling all timers. A better approach would be to
</I>&gt;<i> &gt;&gt; use Monitor.Wait on a synchronization object in the scheduler thread with
</I>&gt;<i> &gt;&gt; the correct time-out, and then Monitor.Pulse to awaken the thread for an
</I>&gt;<i> &gt;&gt; update. The scheduler can use DateTime.Now comparisons to determine, when
</I>&gt;<i> &gt;&gt; Monitor.Wait returns, how long it actually waited and whether it should
</I>&gt;<i> &gt;&gt; actually fire the event at top of the heap, and the return value of
</I>&gt;<i> &gt;&gt; Monitor.Wait will indicate whether it was interrupted and thus should
</I>&gt;<i> &gt;&gt; check
</I>&gt;<i> &gt;&gt; the queue of timer additions/deletions before proceeding.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;I agree that doing a Abort() on the thread is not the most elegant way to
</I>&gt;<i> &gt;singal a thread but I do cover the edge cases in send_scheduler_signal so
</I>&gt;<i> &gt;a thread is only signaled if it is in the right &quot;state&quot;. I also &quot;queue&quot; up
</I>&gt;<i> &gt;abort()'s so under heavy &quot;timer&quot; creation only 1 abort call is made. I'm
</I>&gt;<i> &gt;not quite sure how your Monitor logic would work but I would be more than
</I>&gt;<i> &gt;glad to entertain your solution.
</I>&gt;<i> 
</I>&gt;<i> I haven't had the opportunity to apply the patch; I have been reading it
</I>&gt;<i> directly from the timer.patch file, in which form it is rather difficult to
</I>&gt;<i> make heads or tails of :-) So, I'm not able to evaluate the
</I>&gt;<i> send_scheduler_signal code to see if there might be any holes in it.
</I>&gt;<i> 
</I>&gt;<i> The monitor approach looks roughly like this:
</I>&gt;<i> 
</I>&gt;<i> void send_signal(object signal_object)
</I>&gt;<i> {
</I>&gt;<i>   lock (sync)
</I>&gt;<i>   {
</I>&gt;<i>     signal_queue.Enqueue(signal_object);
</I>&gt;<i>     Monitor.Pulse(sync);
</I>&gt;<i>   }
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> Queue signal_queue = new Queue();
</I>&gt;<i> object sync = new object();
</I>&gt;<i> 
</I>&gt;<i> struct TickInfo
</I>&gt;<i> {
</I>&gt;<i>   public DateTime TimeOfNextTick, Interval;
</I>&gt;<i>   public WaitCallback CallbackMethod;
</I>&gt;<i>   public object CallbackData;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> void thread_proc()
</I>&gt;<i> {
</I>&gt;<i>   TickInfo[] heap = new TickInfo[initial size];
</I>&gt;<i>   int num_heap_entries = 0;
</I>&gt;<i> 
</I>&gt;<i>   lock (sync)
</I>&gt;<i>     while (true)
</I>&gt;<i>     {
</I>&gt;<i>       TimeSpan delay = TimeSpan.FromMilliseconds(Timeout.Infinite);
</I>&gt;<i> 
</I>&gt;<i>       if (num_heap_entries &gt; 0)
</I>&gt;<i>       {
</I>&gt;<i>         DateTime now = DateTime.Now;
</I>&gt;<i> 
</I>&gt;<i>         if (heap[0].TimeOfNextTick &lt; now)
</I>&gt;<i>         {  
</I>&gt;<i>           fire_first_event_from_heap(heap, num_heap_entries);
</I>&gt;<i>           continue;
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i>         delay = heap[0].TimeOfNextTick - now;
</I>&gt;<i>       }
</I>&gt;<i> 
</I>&gt;<i>       Monitor.Wait(sync, delay);
</I>&gt;<i> 
</I>&gt;<i>       while (signal_queue.Count &gt; 0)
</I>&gt;<i>         update_heap(ref heap,
</I>&gt;<i> (SchedulerUpdateSignalObject)signal_queue.Dequeue());
</I>&gt;<i>     }
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> void fire_first_event_from_heap(TickInfo[] heap, int num_heap_entries)
</I>&gt;<i> {
</I>&gt;<i>   ThreadPool.QueueUserWorkItem(heap[0].CallbackMethod, heap[0].CallbackData);
</I>&gt;<i> 
</I>&gt;<i>   TickInfo next_tick = heap[0];
</I>&gt;<i> 
</I>&gt;<i>   next_tick.TimeOfNextTick = DateTime.Now + next_tick.Interval;
</I>&gt;<i> 
</I>&gt;<i>   // remove the old tick
</I>&gt;<i>   heap[0] = heap[num_heap_entries - 1];
</I>&gt;<i>   heapify_down(heap, num_heap_entries - 1);
</I>&gt;<i> 
</I>&gt;<i>   // insert the new one
</I>&gt;<i>   heap[num_heap_entries - 1] = next_tick;
</I>&gt;<i>   heapify_up(heap, num_heap_entries);
</I>&gt;<i> }
</I>
I do like the Monitor Wait/Pulse logic so I'll play with it for a bit
and see how I could use it in the scheduler.

&gt;<i> 
</I>&gt;<i> &gt;&gt; If you'd like, I can try writing an alternate implementation along these
</I>&gt;<i> &gt;&gt; lines, but it will have to wait until after work for me today.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Like I said, go right ahead. There's always more than 1 way to implement
</I>&gt;<i> &gt;things
</I>&gt;<i> 
</I>&gt;<i> I guess the above counts as a rough pseudocode implementation of what I had
</I>&gt;<i> in mind :-) What are your thoughts?
</I>&gt;<i> 
</I>&gt;<i> Jonathan Gilbert
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> 
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018939.html">[Mono-dev] Single thread scheduler for Threading.Timers   patch
</A></li>
	<LI>Next message: <A HREF="018974.html">[Mono-dev] Fedora Core 5 rpms now available for Monodevelop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18972">[ date ]</a>
              <a href="thread.html#18972">[ thread ]</a>
              <a href="subject.html#18972">[ subject ]</a>
              <a href="author.html#18972">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
