<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Single thread scheduler for Threading.Timers  patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Single%20thread%20scheduler%20for%20Threading.Timers%0A%20%20patch&In-Reply-To=1150265055.26740.14.camel%40stan.ophion.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018919.html">
   <LINK REL="Next"  HREF="019007.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Single thread scheduler for Threading.Timers  patch</H1>
    <B>Jonathan Gilbert</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Single%20thread%20scheduler%20for%20Threading.Timers%0A%20%20patch&In-Reply-To=1150265055.26740.14.camel%40stan.ophion.org"
       TITLE="[Mono-dev] Single thread scheduler for Threading.Timers  patch">2a5gjx302 at sneakemail.com
       </A><BR>
    <I>Wed Jun 14 12:05:51 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="018919.html">[Mono-dev] Single thread scheduler for Threading.Timers patch
</A></li>
        <LI>Next message: <A HREF="019007.html">[Mono-dev] Single thread scheduler for Threading.Timers patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18933">[ date ]</a>
              <a href="thread.html#18933">[ thread ]</a>
              <a href="subject.html#18933">[ subject ]</a>
              <a href="author.html#18933">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 11:04 PM 13/06/2006 -0700, Rafael Ferreira wrote:
&gt;<i>Howdy, 
</I>&gt;<i>
</I>&gt;<i>The attached patch changes the current Threading.Timer class to use a
</I>&gt;<i>single thread scheduler instead of the current 1 thread per timer logic.
</I>&gt;<i>I also spent a lot of time working on the Timer unit tests so they more
</I>&gt;<i>consistently pass as well as fixing the &quot;NotWorking&quot; tests. 
</I>&gt;<i>
</I>&gt;<i>Some key features include:
</I>&gt;<i>
</I>&gt;<i>* A single thread handles firing all timer jobs thus allowing a much
</I>&gt;<i>greater number of Timers to be defined - Fixing bug #65734
</I>&gt;<i>* Timer scheduler is only started after the first System.Threading.Timer
</I>&gt;<i>is created (lazy init)
</I>&gt;<i>* Timer scheduler thread dies if there are no more timer jobs in its Job
</I>&gt;<i>queue (early termination)
</I>&gt;<i>* Scheduler can spit out debug info by exporting the MONO_TIMER_DEBUG
</I>&gt;<i>environment variable
</I>
One thing that gets me about the design is the way that timer events are
marshalled to a different thread (in the thread pool) in order to be fired.
Obviously, you don't want synchronous callbacks from a single thread for
all timers, but perhaps a timer thread pool, each of which handling a
subset of the timers, would be a viable alternate design. With a limit of,
say, 100 scheduler threads, up to 100 timers could be created without any
chance of interference, and after that point, the threads would be reused
instead of overloading the system with thousands of threads. The threads
could even switch from synchronous callbacks when they are handling only a
single timer to asynchronous thread pool callbacks when their
responsibilities increase.

If we accept the single-thread thread-pool-callback design, though, I have
the following comments on the implementation:

1. A heap structure is very easy to maintain, and would be a significantly
more efficient way to find the next event to be fired. You have comments
that acknowledge the deficiency of looping over the entire set every time,
and I think this would be the logical next step in this.

2. Using Thread.Abort to signal the thread is fundamentally flawed. A user
very quickly adding &amp; removing timers would eventually cause a
ThreadAbortException to fire inside the 'catch' handler, killing off the
scheduler thread and disabling all timers. A better approach would be to
use Monitor.Wait on a synchronization object in the scheduler thread with
the correct time-out, and then Monitor.Pulse to awaken the thread for an
update. The scheduler can use DateTime.Now comparisons to determine, when
Monitor.Wait returns, how long it actually waited and whether it should
actually fire the event at top of the heap, and the return value of
Monitor.Wait will indicate whether it was interrupted and thus should check
the queue of timer additions/deletions before proceeding.

If you'd like, I can try writing an alternate implementation along these
lines, but it will have to wait until after work for me today.

Jonathan Gilbert

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018919.html">[Mono-dev] Single thread scheduler for Threading.Timers patch
</A></li>
	<LI>Next message: <A HREF="019007.html">[Mono-dev] Single thread scheduler for Threading.Timers patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18933">[ date ]</a>
              <a href="thread.html#18933">[ thread ]</a>
              <a href="subject.html#18933">[ subject ]</a>
              <a href="author.html#18933">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
