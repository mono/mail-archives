<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Patch for full-featured mcs /doc support
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20full-featured%20mcs%20/doc%20support&In-Reply-To=41A6FE1D.4040209%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009068.html">
   <LINK REL="Next"  HREF="009070.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Patch for full-featured mcs /doc support</H1>
    <B>Marek Safar</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20full-featured%20mcs%20/doc%20support&In-Reply-To=41A6FE1D.4040209%40ximian.com"
       TITLE="[Mono-devel-list] Patch for full-featured mcs /doc support">marek.safar at seznam.cz
       </A><BR>
    <I>Fri Nov 26 05:25:53 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009068.html">[Mono-devel-list] Patch for full-featured mcs /doc support
</A></li>
        <LI>Next message: <A HREF="009070.html">[Mono-devel-list] Patch for full-featured mcs /doc support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9069">[ date ]</a>
              <a href="thread.html#9069">[ thread ]</a>
              <a href="subject.html#9069">[ subject ]</a>
              <a href="author.html#9069">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Eno,

&gt;<i>Ok, the harness.mk problem was from both xmldocdiff.cs and
</I>&gt;<i>makefiles. Additionally I have to modify decl.cs a bit (to
</I>&gt;<i>mimick csc output for invalid &quot;include&quot; element) and had
</I>&gt;<i>to make a trick for xml-025.cs that handles inclusion that
</I>&gt;<i>csc cannot handle '/' file path separator expectedly.
</I>&gt;<i>
</I>&gt;<i>Sorry for flooding the patches. Please review this latest one.
</I>&gt;<i>  
</I>&gt;<i>
</I>OK,

+		if (RootContext.NeedDocument)
+			if (Lexer.doc_state == XmlCommentState.Error)
+				Lexer.doc_state = XmlCommentState.NotAllowed;

Please change to &amp;&amp; (2 places)

+ private Type [] emptyParamList = new Type [0];


Should be static.

That is all

Marek

&gt;<i>Atsushi Eno
</I>&gt;<i>
</I>&gt;<i>Atsushi Eno wrote:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>Hello,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Thanks for several checks!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>+ public string consume_doc_comment ()
</I>&gt;&gt;&gt;<i>+ {
</I>&gt;&gt;&gt;<i>+ if (xml_comment_buffer.Length &gt; 0) {
</I>&gt;&gt;&gt;<i>+ string ret = null;
</I>&gt;&gt;&gt;<i>+ if (xmlCommentSavePoint &gt; 0) {
</I>&gt;&gt;&gt;<i>+ ret = xml_comment_buffer.ToString (0, xmlCommentSavePoint);
</I>&gt;&gt;&gt;<i>+ xml_comment_buffer.Remove (0, xmlCommentSavePoint);
</I>&gt;&gt;&gt;<i>+ } else {
</I>&gt;&gt;&gt;<i>+ ret = xml_comment_buffer.ToString ();
</I>&gt;&gt;&gt;<i>+ xml_comment_buffer.Length = 0;
</I>&gt;&gt;&gt;<i>+ }
</I>&gt;&gt;&gt;<i>+ xmlCommentSavePoint = 0;
</I>&gt;&gt;&gt;<i>+ return ret;
</I>&gt;&gt;&gt;<i>+ }
</I>&gt;&gt;&gt;<i>+ else
</I>&gt;&gt;&gt;<i>+ return null;
</I>&gt;&gt;&gt;<i>+ }
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>The last else is useless and xmlCommentSavePoint = 0 should be only for
</I>&gt;&gt;&gt;<i>xmlCommentSavePoint &gt; 0.
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Ok. Actually I noticed that push_xml_comment() is not required anymore
</I>&gt;&gt;<i>(since I implemented invalid comment state transition), I just removed
</I>&gt;&gt;<i>it as well as xmlCommentSavePoint which is also not required anymore.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>+ public enum XmlCommentState {
</I>&gt;&gt;&gt;<i>+ OK,
</I>&gt;&gt;&gt;<i>+ NG,
</I>&gt;&gt;&gt;<i>+ Error
</I>&gt;&gt;&gt;<i>+ }
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>What is NG ?
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>OK, I found that NG is kind of Japanglish ;-) so just renamed
</I>&gt;&gt;<i>OK as Allowed and NG as NotAllowed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>+ MemberInfo mi = FindDocumentedMember (type, memberName,
</I>&gt;&gt;&gt;<i>parameterTypes, ds, out warnResult);
</I>&gt;&gt;&gt;<i>+ switch (warnResult) {
</I>&gt;&gt;&gt;<i>+ case 1581:
</I>&gt;&gt;&gt;<i>+ Report.Warning (1581, 1, Location, &quot;Invalid return type in XML comment
</I>&gt;&gt;&gt;<i>cref attribute '{0}'&quot;, cref);
</I>&gt;&gt;&gt;<i>+ return;
</I>&gt;&gt;&gt;<i>+ case 1584:
</I>&gt;&gt;&gt;<i>+ Report.Warning (1020, 1, Location, &quot;Overloadable {0} operator is
</I>&gt;&gt;&gt;<i>expected&quot;, parameterTypes.Length == 2 ? &quot;binary&quot; : &quot;unary&quot;);
</I>&gt;&gt;&gt;<i>+ Report.Warning (1584, 1, Location, &quot;XML comment on '{0}' has
</I>&gt;&gt;&gt;<i>syntactically incorrect attribute '{1}'&quot;, GetSignatureForError (), cref);
</I>&gt;&gt;&gt;<i>+ return;
</I>&gt;&gt;&gt;<i>+ }
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Why don't do it inside FindDocumentMember to avoid copy&amp;paste.
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Fixed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>- : IDENTIFIER
</I>&gt;&gt;&gt;<i>+ : IDENTIFIER
</I>&gt;&gt;&gt;<i>+ {
</I>&gt;&gt;&gt;<i>+ tmpComment = Lexer.consume_doc_comment ();
</I>&gt;&gt;&gt;<i>+ Lexer.doc_state = XmlCommentState.OK;
</I>&gt;&gt;&gt;<i>+ }
</I>&gt;&gt;&gt;<i>OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
</I>&gt;&gt;&gt;<i>{
</I>&gt;&gt;&gt;<i>oob_stack.Push (lexer.Location);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>- current_local_parameters = (Parameters) $3;
</I>&gt;&gt;&gt;<i>+ current_local_parameters = (Parameters) $4;
</I>&gt;&gt;&gt;<i>}
</I>&gt;&gt;&gt;<i>opt_constructor_initializer
</I>&gt;&gt;&gt;<i>{
</I>&gt;&gt;&gt;<i>Location l = (Location) oob_stack.Pop ();
</I>&gt;&gt;&gt;<i>- $$ = new Constructor (current_class, (string) $1, 0, (Parameters) $3,
</I>&gt;&gt;&gt;<i>- (ConstructorInitializer) $6, l);
</I>&gt;&gt;&gt;<i>+ $$ = new Constructor (current_class, (string) $1, 0, (Parameters) $4,
</I>&gt;&gt;&gt;<i>+ (ConstructorInitializer) $7, l);
</I>&gt;&gt;&gt;<i>}
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>I am confuse, what has been changed.
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>I cannot understand what you mean. It should not be regarded as
</I>&gt;&gt;<i>confusion, since it must happen whenever any of you guys have to
</I>&gt;&gt;<i>insert logic between tokens.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>+ } catch (NotImplementedException ex) {
</I>&gt;&gt;&gt;<i>+ Report.Error (1569, &quot;Error generating XML documentation file '{0}'
</I>&gt;&gt;&gt;<i>('{1}')&quot;, xml_documentation_file, ex.Message);
</I>&gt;&gt;&gt;<i>+ return false;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Does make a sense to catch this exception ?
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Oops, it should just be Exception (to catch xml-output errors).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>+ vd.DocComment = ConsumeStoredComment ();
</I>&gt;&gt;&gt;<i>+ Lexer.doc_state = XmlCommentState.OK;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Why don't call this tricky property in ConsumeStroredComment I found
</I>&gt;&gt;&gt;<i>only one place where this combination is missing (bug ??). Should be
</I>&gt;&gt;&gt;<i>possible also to rename this property ?
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Made as such.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>BTW: I think we should call this call only for /doc option.
</I>&gt;&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Ok, now everything in .jay checks RootContext.NeedDocument.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I've attached the latest diff in mcs/mcs and mcs/tests, and added
</I>&gt;&gt;<i>new tests in mcs/errors (cs1587-*.cs). It still needs some love
</I>&gt;&gt;<i>on the files in tests (test-harness is not working properly; am
</I>&gt;&gt;<i>asking Hari about that).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Atsushi Eno
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>Index: cs-tokenizer.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- cs-tokenizer.cs	(revision 36616)
</I>&gt;<i>+++ cs-tokenizer.cs	(working copy)
</I>&gt;<i>@@ -42,6 +42,17 @@
</I>&gt;<i> 		bool handle_assembly = false;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i>+		// XML documentation buffer. The save point is used to divide
</I>&gt;<i>+		// comments on types and comments on members.
</I>&gt;<i>+		//
</I>&gt;<i>+		StringBuilder xml_comment_buffer;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// See comment on XmlCommentState enumeration.
</I>&gt;<i>+		//
</I>&gt;<i>+		XmlCommentState xmlDocState = XmlCommentState.Allowed;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i> 		// Whether tokens have been seen on this line
</I>&gt;<i> 		//
</I>&gt;<i> 		bool tokens_seen = false;
</I>&gt;<i>@@ -132,6 +143,18 @@
</I>&gt;<i> 				handle_remove_add = value;
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		public XmlCommentState doc_state {
</I>&gt;<i>+			get { return xmlDocState; }
</I>&gt;<i>+			set {
</I>&gt;<i>+				if (value == XmlCommentState.Allowed) {
</I>&gt;<i>+					check_incorrect_doc_comment ();
</I>&gt;<i>+					consume_doc_comment ();
</I>&gt;<i>+				}
</I>&gt;<i>+				xmlDocState = value;
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		
</I>&gt;<i> 		//
</I>&gt;<i> 		// Class variables
</I>&gt;<i>@@ -362,6 +385,8 @@
</I>&gt;<i> 					define (def);
</I>&gt;<i> 			}
</I>&gt;<i> 
</I>&gt;<i>+			xml_comment_buffer = new StringBuilder ();
</I>&gt;<i>+
</I>&gt;<i> 			//
</I>&gt;<i> 			// FIXME: This could be `Location.Push' but we have to
</I>&gt;<i> 			// find out why the MS compiler allows this
</I>&gt;<i>@@ -411,6 +436,9 @@
</I>&gt;<i> 			case '}':
</I>&gt;<i> 				return Token.CLOSE_BRACE;
</I>&gt;<i> 			case '[':
</I>&gt;<i>+				// To block doccomment inside attribute declaration.
</I>&gt;<i>+				if (doc_state == XmlCommentState.Allowed)
</I>&gt;<i>+					doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i> 				return Token.OPEN_BRACKET;
</I>&gt;<i> 			case ']':
</I>&gt;<i> 				return Token.CLOSE_BRACKET;
</I>&gt;<i>@@ -1741,6 +1769,15 @@
</I>&gt;<i> 		{
</I>&gt;<i> 			int res = consume_identifier (s, false);
</I>&gt;<i> 
</I>&gt;<i>+			if (doc_state == XmlCommentState.Allowed)
</I>&gt;<i>+				doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i>+			switch (res) {
</I>&gt;<i>+			case Token.USING:
</I>&gt;<i>+			case Token.NAMESPACE:
</I>&gt;<i>+				check_incorrect_doc_comment ();
</I>&gt;<i>+				break;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i> 			if (res == Token.PARTIAL) {
</I>&gt;<i> 				// Save current position and parse next token.
</I>&gt;<i> 				int old = reader.Position;
</I>&gt;<i>@@ -1862,6 +1899,13 @@
</I>&gt;<i> 				
</I>&gt;<i> 					if (d == '/'){
</I>&gt;<i> 						getChar ();
</I>&gt;<i>+						if (RootContext.NeedDocument &amp;&amp; peekChar () == '/') {
</I>&gt;<i>+							getChar ();
</I>&gt;<i>+							if (doc_state == XmlCommentState.Allowed)
</I>&gt;<i>+								handle_one_line_xml_comment ();
</I>&gt;<i>+							else if (doc_state == XmlCommentState.NotAllowed)
</I>&gt;<i>+								warn_incorrect_doc_comment ();
</I>&gt;<i>+						}
</I>&gt;<i> 						while ((d = getChar ()) != -1 &amp;&amp; (d != '\n') &amp;&amp; d != '\r')
</I>&gt;<i> 							col++;
</I>&gt;<i> 						if (d == '\n'){
</I>&gt;<i>@@ -1874,13 +1918,33 @@
</I>&gt;<i> 						continue;
</I>&gt;<i> 					} else if (d == '*'){
</I>&gt;<i> 						getChar ();
</I>&gt;<i>+						bool docAppend = false;
</I>&gt;<i>+						if (RootContext.NeedDocument &amp;&amp; peekChar () == '*') {
</I>&gt;<i>+							getChar ();
</I>&gt;<i>+							// But when it is /**/, just do nothing.
</I>&gt;<i>+							if (peekChar () == '/') {
</I>&gt;<i>+								getChar ();
</I>&gt;<i>+								continue;
</I>&gt;<i>+							}
</I>&gt;<i>+							if (doc_state == XmlCommentState.Allowed)
</I>&gt;<i>+								docAppend = true;
</I>&gt;<i>+							else if (doc_state == XmlCommentState.NotAllowed)
</I>&gt;<i>+								warn_incorrect_doc_comment ();
</I>&gt;<i>+						}
</I>&gt;<i> 
</I>&gt;<i>+						int currentCommentStart = xml_comment_buffer.Length;
</I>&gt;<i>+						if (docAppend)
</I>&gt;<i>+							xml_comment_buffer.Append (Environment.NewLine);
</I>&gt;<i>+
</I>&gt;<i> 						while ((d = getChar ()) != -1){
</I>&gt;<i> 							if (d == '*' &amp;&amp; peekChar () == '/'){
</I>&gt;<i> 								getChar ();
</I>&gt;<i> 								col++;
</I>&gt;<i> 								break;
</I>&gt;<i> 							}
</I>&gt;<i>+							if (docAppend)
</I>&gt;<i>+								xml_comment_buffer.Append ((char) d);
</I>&gt;<i>+							
</I>&gt;<i> 							if (d == '\n'){
</I>&gt;<i> 								line++;
</I>&gt;<i> 								ref_line++;
</I>&gt;<i>@@ -1889,6 +1953,8 @@
</I>&gt;<i> 								tokens_seen = false;
</I>&gt;<i> 							}
</I>&gt;<i> 						}
</I>&gt;<i>+						if (docAppend)
</I>&gt;<i>+							update_formatted_doc_comment (currentCommentStart);
</I>&gt;<i> 						continue;
</I>&gt;<i> 					}
</I>&gt;<i> 					goto is_punct_label;
</I>&gt;<i>@@ -2037,6 +2103,97 @@
</I>&gt;<i> 			return Token.EOF;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Handles one line xml comment
</I>&gt;<i>+		//
</I>&gt;<i>+		private void handle_one_line_xml_comment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			int c;
</I>&gt;<i>+			while ((c = peekChar ()) == ' ')
</I>&gt;<i>+				getChar (); // skip heading whitespaces.
</I>&gt;<i>+			while ((c = peekChar ()) != -1 &amp;&amp; (c != '\n') &amp;&amp; c != '\r') {
</I>&gt;<i>+				col++;
</I>&gt;<i>+				xml_comment_buffer.Append ((char) getChar ());
</I>&gt;<i>+			}
</I>&gt;<i>+			if (c == '\r') {
</I>&gt;<i>+				getChar ();
</I>&gt;<i>+				xml_comment_buffer.Append ('\r');
</I>&gt;<i>+				if (peekChar () == '\n')
</I>&gt;<i>+					xml_comment_buffer.Append ('\n');
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (c == '\n')
</I>&gt;<i>+				xml_comment_buffer.Append ('\n');
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Remove heading &quot;*&quot; in Javadoc-like xml documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		private void update_formatted_doc_comment (int currentCommentStart)
</I>&gt;<i>+		{
</I>&gt;<i>+			int length = xml_comment_buffer.Length - currentCommentStart;
</I>&gt;<i>+			string [] lines = xml_comment_buffer.ToString (
</I>&gt;<i>+				currentCommentStart,
</I>&gt;<i>+				length).Split ('\n');
</I>&gt;<i>+			// The first line starts with /**, thus it is not target
</I>&gt;<i>+			// for the format check.
</I>&gt;<i>+			for (int i = 1; i &lt; lines.Length; i++) {
</I>&gt;<i>+				string s = lines [i];
</I>&gt;<i>+				int idx = s.IndexOf ('*');
</I>&gt;<i>+				string head = null;
</I>&gt;<i>+				if (idx &lt; 0) {
</I>&gt;<i>+					if (i &lt; lines.Length - 1)
</I>&gt;<i>+						return;
</I>&gt;<i>+					head = s;
</I>&gt;<i>+				}
</I>&gt;<i>+				else
</I>&gt;<i>+					head = s.Substring (0, idx);
</I>&gt;<i>+				foreach (char c in head)
</I>&gt;<i>+					if (c != ' ')
</I>&gt;<i>+						return;
</I>&gt;<i>+				lines [i] = s.Substring (idx + 1);
</I>&gt;<i>+			}
</I>&gt;<i>+			xml_comment_buffer.Remove (currentCommentStart, length);
</I>&gt;<i>+			xml_comment_buffer.Insert (
</I>&gt;<i>+				currentCommentStart,
</I>&gt;<i>+				String.Join (&quot;\n&quot;, lines));
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Checks if there was incorrect doc comments and raise
</I>&gt;<i>+		// warnings.
</I>&gt;<i>+		//
</I>&gt;<i>+		public void check_incorrect_doc_comment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			if (xml_comment_buffer.Length &gt; 0)
</I>&gt;<i>+				warn_incorrect_doc_comment ();
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Raises a warning when tokenizer found incorrect doccomment
</I>&gt;<i>+		// markup.
</I>&gt;<i>+		//
</I>&gt;<i>+		private void warn_incorrect_doc_comment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			doc_state = XmlCommentState.Error;
</I>&gt;<i>+			// in csc, it is 'XML comment is not placed on a valid 
</I>&gt;<i>+			// language element'. But that does not make sense.
</I>&gt;<i>+			Report.Warning (1587, 2, Location, &quot;XML comment is placed on an invalid language element which can not accept it.&quot;);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Consumes the saved xml comment lines (if any)
</I>&gt;<i>+		// as for current target member or type.
</I>&gt;<i>+		//
</I>&gt;<i>+		public string consume_doc_comment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			if (xml_comment_buffer.Length &gt; 0) {
</I>&gt;<i>+				string ret = xml_comment_buffer.ToString ();
</I>&gt;<i>+				xml_comment_buffer.Length = 0;
</I>&gt;<i>+				return ret;
</I>&gt;<i>+			}
</I>&gt;<i>+			return null;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		public void cleanup ()
</I>&gt;<i> 		{
</I>&gt;<i> 			if (ifstack != null &amp;&amp; ifstack.Count &gt;= 1) {
</I>&gt;<i>@@ -2049,4 +2206,18 @@
</I>&gt;<i> 				
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i>+
</I>&gt;<i>+	//
</I>&gt;<i>+	// Indicates whether it accepts XML documentation or not.
</I>&gt;<i>+	//
</I>&gt;<i>+	public enum XmlCommentState {
</I>&gt;<i>+		// comment is allowed in this state.
</I>&gt;<i>+		Allowed,
</I>&gt;<i>+		// comment is not allowed in this state.
</I>&gt;<i>+		NotAllowed,
</I>&gt;<i>+		// once comments appeared when it is NotAllowed, then the
</I>&gt;<i>+		// state is changed to it, until the state is changed to
</I>&gt;<i>+		// .Allowed.
</I>&gt;<i>+		Error
</I>&gt;<i>+	}
</I>&gt;<i> }
</I>&gt;<i>Index: rootcontext.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- rootcontext.cs	(revision 36616)
</I>&gt;<i>+++ rootcontext.cs	(working copy)
</I>&gt;<i>@@ -13,6 +13,7 @@
</I>&gt;<i> using System.Reflection;
</I>&gt;<i> using System.Reflection.Emit;
</I>&gt;<i> using System.Diagnostics;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i> 
</I>&gt;<i> namespace Mono.CSharp {
</I>&gt;<i> 
</I>&gt;<i>@@ -80,12 +81,34 @@
</I>&gt;<i> 		public static bool StrongNameDelaySign = false;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i>+		// If set, enable XML documentation generation
</I>&gt;<i>+		//
</I>&gt;<i>+		public static bool NeedDocument = false;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Used to create element which helps well-formedness checking.
</I>&gt;<i>+		//
</I>&gt;<i>+		public static XmlDocument XmlDocumentation;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// The output for XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public static XmlWriter XmlCommentOutput;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Stores XmlDocuments that are included in XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public static Hashtable StoredDocuments = new Hashtable ();
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i> 		// Constructor
</I>&gt;<i> 		//
</I>&gt;<i> 		static RootContext ()
</I>&gt;<i> 		{
</I>&gt;<i> 			tree = new Tree ();
</I>&gt;<i> 			type_container_resolve_order = new ArrayList ();
</I>&gt;<i>+			XmlDocumentation = new XmlDocument ();
</I>&gt;<i>+			XmlDocumentation.PreserveWhitespace = false;
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public static bool NeedsEntryPoint {
</I>&gt;<i>@@ -174,6 +197,29 @@
</I>&gt;<i> 					e.DefineType ();
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Fixes full type name of each documented types/members up.
</I>&gt;<i>+		//
</I>&gt;<i>+		static public void GenerateDocComment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			TypeContainer root = Tree.Types;
</I>&gt;<i>+
</I>&gt;<i>+			if (root.Interfaces != null)
</I>&gt;<i>+				foreach (Interface i in root.Interfaces) 
</I>&gt;<i>+					i.GenerateDocComment (null);
</I>&gt;<i>+
</I>&gt;<i>+			foreach (TypeContainer tc in root.Types)
</I>&gt;<i>+				tc.GenerateDocComment (null);
</I>&gt;<i>+
</I>&gt;<i>+			if (root.Delegates != null)
</I>&gt;<i>+				foreach (Delegate d in root.Delegates) 
</I>&gt;<i>+					d.GenerateDocComment (null);
</I>&gt;<i>+
</I>&gt;<i>+			if (root.Enums != null)
</I>&gt;<i>+				foreach (Enum e in root.Enums)
</I>&gt;<i>+					e.GenerateDocComment (null);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		static void Error_TypeConflict (string name, Location loc)
</I>&gt;<i> 		{
</I>&gt;<i> 			Report.Error (
</I>&gt;<i>Index: class.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- class.cs	(revision 36616)
</I>&gt;<i>+++ class.cs	(working copy)
</I>&gt;<i>@@ -40,6 +40,7 @@
</I>&gt;<i> using System.Security;
</I>&gt;<i> using System.Security.Permissions;
</I>&gt;<i> using System.Text;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i> 
</I>&gt;<i> using Mono.CompilerServices.SymbolWriter;
</I>&gt;<i> 
</I>&gt;<i>@@ -2396,6 +2397,62 @@
</I>&gt;<i> 			return FindMembers (mt, bf | BindingFlags.DeclaredOnly, null, null);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Generates xml doc comments (if any), and if required,
</I>&gt;<i>+		// handle warning report.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal override void GenerateDocComment (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			base.GenerateDocComment (ds);
</I>&gt;<i>+
</I>&gt;<i>+			if (default_static_constructor != null)
</I>&gt;<i>+				default_static_constructor.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (InstanceConstructors != null)
</I>&gt;<i>+				foreach (Constructor c in InstanceConstructors)
</I>&gt;<i>+					c.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Types != null)
</I>&gt;<i>+				foreach (TypeContainer tc in Types)
</I>&gt;<i>+					tc.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Enums != null)
</I>&gt;<i>+				foreach (Enum en in Enums)
</I>&gt;<i>+					en.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Constants != null)
</I>&gt;<i>+				foreach (Const c in Constants)
</I>&gt;<i>+					c.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Fields != null)
</I>&gt;<i>+				foreach (Field f in Fields)
</I>&gt;<i>+					f.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Events != null)
</I>&gt;<i>+				foreach (Event e in Events)
</I>&gt;<i>+					e.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Indexers != null)
</I>&gt;<i>+				foreach (Indexer ix in Indexers)
</I>&gt;<i>+					ix.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Properties != null)
</I>&gt;<i>+				foreach (Property p in Properties)
</I>&gt;<i>+					p.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Methods != null)
</I>&gt;<i>+				foreach (Method m in Methods)
</I>&gt;<i>+					m.GenerateDocComment (this);
</I>&gt;<i>+
</I>&gt;<i>+			if (Operators != null)
</I>&gt;<i>+				foreach (Operator o in Operators)
</I>&gt;<i>+					o.GenerateDocComment (this);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;T:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		public virtual MemberCache ParentCache {
</I>&gt;<i> 			get {
</I>&gt;<i> 				return parent_cache;
</I>&gt;<i>@@ -3296,6 +3353,72 @@
</I>&gt;<i> 			return true;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Returns a string that represents the signature for this 
</I>&gt;<i>+		// member which should be used in XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string GetDocCommentName (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			Parameter [] plist = Parameters.FixedParameters;
</I>&gt;<i>+			Parameter parr = Parameters.ArrayParameter;
</I>&gt;<i>+			string paramSpec = String.Empty;
</I>&gt;<i>+			if (plist != null) {
</I>&gt;<i>+				StringBuilder psb = new StringBuilder ();
</I>&gt;<i>+				foreach (Parameter p in plist) {
</I>&gt;<i>+					psb.Append (psb.Length != 0 ? &quot;,&quot; : &quot;(&quot;);
</I>&gt;<i>+					psb.Append (p.ParameterType.FullName.Replace (&quot;+&quot;, &quot;.&quot;));
</I>&gt;<i>+				}
</I>&gt;<i>+				psb.Append (&quot;)&quot;);
</I>&gt;<i>+				paramSpec = psb.ToString ();
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (parr != null)
</I>&gt;<i>+				paramSpec = String.Concat (
</I>&gt;<i>+					&quot;(&quot;,
</I>&gt;<i>+					parr.ParameterType.FullName.Replace (&quot;+&quot;, &quot;.&quot;),
</I>&gt;<i>+					&quot;)&quot;);
</I>&gt;<i>+
</I>&gt;<i>+			string name = this is Constructor ? &quot;#ctor&quot; : Name;
</I>&gt;<i>+			return String.Concat (DocCommentHeader, ds.Name, &quot;.&quot;, name, paramSpec);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Raised (and passed an XmlElement that contains the comment)
</I>&gt;<i>+		// when GenerateDocComment is writing documentation expectedly.
</I>&gt;<i>+		//
</I>&gt;<i>+		// FIXME: with a few effort, it could be done with XmlReader,
</I>&gt;<i>+		// that means removal of DOM use.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal override void OnGenerateDocComment (DeclSpace ds, XmlElement el)
</I>&gt;<i>+		{
</I>&gt;<i>+			Hashtable paramTags = new Hashtable ();
</I>&gt;<i>+			foreach (XmlElement pelem in el.SelectNodes (&quot;param&quot;)) {
</I>&gt;<i>+				int i;
</I>&gt;<i>+				string xname = pelem.GetAttribute (&quot;name&quot;);
</I>&gt;<i>+				if (xname == &quot;&quot;)
</I>&gt;<i>+					continue; // really? but MS looks doing so
</I>&gt;<i>+				if (xname != &quot;&quot; &amp;&amp; Parameters.GetParameterByName (xname, out i) == null)
</I>&gt;<i>+					Report.Warning (1572, 2, Location, &quot;XML comment on '{0}' has a 'param' tag for '{1}', but there is no such parameter.&quot;, Name, xname);
</I>&gt;<i>+				else if (paramTags [xname] != null)
</I>&gt;<i>+					Report.Warning (1571, 2, Location, &quot;XML comment on '{0}' has a duplicate param tag for '{1}'&quot;, Name, xname);
</I>&gt;<i>+				paramTags [xname] = xname;
</I>&gt;<i>+			}
</I>&gt;<i>+			Parameter [] plist = Parameters.FixedParameters;
</I>&gt;<i>+			Parameter parr = Parameters.ArrayParameter;
</I>&gt;<i>+			if (plist != null) {
</I>&gt;<i>+				foreach (Parameter p in plist) {
</I>&gt;<i>+					if (paramTags.Count &gt; 0 &amp;&amp; paramTags [p.Name] == null)
</I>&gt;<i>+						Report.Warning (1573, 4, Location, &quot;Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)&quot;, Name, p.Name);
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;M:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		protected override void VerifyObsoleteAttribute()
</I>&gt;<i> 		{
</I>&gt;<i> 			base.VerifyObsoleteAttribute ();
</I>&gt;<i>@@ -5223,6 +5346,13 @@
</I>&gt;<i> 
</I>&gt;<i> 			base.Emit ();
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;F:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	//
</I>&gt;<i>@@ -5531,6 +5661,13 @@
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { throw new InvalidOperationException (&quot;Unexpected attempt to get doc comment from &quot; + this.GetType () + &quot;.&quot;); }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		protected override void VerifyObsoleteAttribute()
</I>&gt;<i> 		{
</I>&gt;<i> 		}
</I>&gt;<i>@@ -5981,6 +6118,13 @@
</I>&gt;<i> 				return attribute_targets;
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;P:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 			
</I>&gt;<i> 	public class Property : PropertyBase, IIteratorContainer {
</I>&gt;<i>@@ -6621,6 +6765,13 @@
</I>&gt;<i> 
</I>&gt;<i> 			return TypeManager.GetFullNameSignature (EventBuilder);
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;E:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>Index: decl.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- decl.cs	(revision 36616)
</I>&gt;<i>+++ decl.cs	(working copy)
</I>&gt;<i>@@ -16,6 +16,7 @@
</I>&gt;<i> using System.Globalization;
</I>&gt;<i> using System.Reflection.Emit;
</I>&gt;<i> using System.Reflection;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i> 
</I>&gt;<i> namespace Mono.CSharp {
</I>&gt;<i> 
</I>&gt;<i>@@ -137,6 +138,17 @@
</I>&gt;<i> 		/// &lt;/summary&gt;
</I>&gt;<i> 		public readonly Location Location;
</I>&gt;<i> 
</I>&gt;<i>+		/// &lt;summary&gt;
</I>&gt;<i>+		///   XML documentation comment
</I>&gt;<i>+		/// &lt;/summary&gt;
</I>&gt;<i>+		public string DocComment;
</I>&gt;<i>+
</I>&gt;<i>+		/// &lt;summary&gt;
</I>&gt;<i>+		///   Represents header string for documentation comment 
</I>&gt;<i>+		///   for each member types.
</I>&gt;<i>+		/// &lt;/summary&gt;
</I>&gt;<i>+		public abstract string DocCommentHeader { get; }
</I>&gt;<i>+
</I>&gt;<i> 		[Flags]
</I>&gt;<i> 		public enum Flags {
</I>&gt;<i> 			Obsolete_Undetected = 1,		// Obsolete attribute has not been detected yet
</I>&gt;<i>@@ -363,6 +375,473 @@
</I>&gt;<i> 
</I>&gt;<i> 		protected abstract void VerifyObsoleteAttribute ();
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Raised (and passed an XmlElement that contains the comment)
</I>&gt;<i>+		// when GenerateDocComment is writing documentation expectedly.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal virtual void OnGenerateDocComment (DeclSpace ds, XmlElement intermediateNode)
</I>&gt;<i>+		{
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Returns a string that represents the signature for this 
</I>&gt;<i>+		// member which should be used in XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public virtual string GetDocCommentName (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (ds == null || this is DeclSpace)
</I>&gt;<i>+				return DocCommentHeader + Name;
</I>&gt;<i>+			else
</I>&gt;<i>+				return String.Concat (DocCommentHeader, ds.Name, &quot;.&quot;, Name);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		private XmlNode GetDocCommentNode (string name)
</I>&gt;<i>+		{
</I>&gt;<i>+			// FIXME: It could be even optimizable as not
</I>&gt;<i>+			// to use XmlDocument. But anyways the nodes
</I>&gt;<i>+			// are not kept in memory.
</I>&gt;<i>+			XmlDocument doc = RootContext.XmlDocumentation;
</I>&gt;<i>+			try {
</I>&gt;<i>+				XmlElement el = doc.CreateElement (&quot;member&quot;);
</I>&gt;<i>+				el.SetAttribute (&quot;name&quot;, name);
</I>&gt;<i>+				string normalized = DocComment;
</I>&gt;<i>+				el.InnerXml = normalized;
</I>&gt;<i>+				// csc keeps lines as written in the sources
</I>&gt;<i>+				// and inserts formatting indentation (which 
</I>&gt;<i>+				// is different from XmlTextWriter.Formatting
</I>&gt;<i>+				// one), but when a start tag contains an 
</I>&gt;<i>+				// endline, it joins the next line. We don't
</I>&gt;<i>+				// have to follow such a hacky behavior.
</I>&gt;<i>+				string [] split =
</I>&gt;<i>+					DocComment.Split ('\n');
</I>&gt;<i>+				int j = 0;
</I>&gt;<i>+				for (int i = 0; i &lt; split.Length; i++) {
</I>&gt;<i>+					string s = split [i].TrimEnd ();
</I>&gt;<i>+					if (s.Length &gt; 0)
</I>&gt;<i>+						split [j++] = s;
</I>&gt;<i>+				}
</I>&gt;<i>+				el.InnerXml = String.Join (
</I>&gt;<i>+					&quot;\n            &quot;, split, 0, j);
</I>&gt;<i>+				return el;
</I>&gt;<i>+			} catch (XmlException ex) {
</I>&gt;<i>+				Report.Warning (1570, 1, Location, &quot;XML comment on '{0}' has non-well-formed XML ({1}).&quot;, name, ex.Message);
</I>&gt;<i>+				XmlComment com = doc.CreateComment (String.Format (&quot;FIXME: Invalid documentation markup was found for member {0}&quot;, name));
</I>&gt;<i>+				return com;
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Generates xml doc comments (if any), and if required,
</I>&gt;<i>+		// handle warning report.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal virtual void GenerateDocComment (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (DocComment != null) {
</I>&gt;<i>+				string name = GetDocCommentName (ds);
</I>&gt;<i>+
</I>&gt;<i>+				XmlNode n = GetDocCommentNode (name);
</I>&gt;<i>+
</I>&gt;<i>+				XmlElement el = n as XmlElement;
</I>&gt;<i>+				if (el != null) {
</I>&gt;<i>+					OnGenerateDocComment (ds, el);
</I>&gt;<i>+
</I>&gt;<i>+					// FIXME: it could be done with XmlReader
</I>&gt;<i>+					foreach (XmlElement inc in n.SelectNodes (&quot;.//include&quot;))
</I>&gt;<i>+						HandleInclude (inc);
</I>&gt;<i>+
</I>&gt;<i>+					// FIXME: it could be done with XmlReader
</I>&gt;<i>+					DeclSpace dsTarget = this as DeclSpace;
</I>&gt;<i>+					if (dsTarget == null)
</I>&gt;<i>+						dsTarget = ds;
</I>&gt;<i>+
</I>&gt;<i>+					foreach (XmlElement see in n.SelectNodes (&quot;.//see&quot;))
</I>&gt;<i>+						HandleSee (dsTarget, name, see);
</I>&gt;<i>+					foreach (XmlElement seealso in n.SelectNodes (&quot;.//seealso&quot;))
</I>&gt;<i>+						HandleSeeAlso (dsTarget, name, seealso);
</I>&gt;<i>+				}
</I>&gt;<i>+
</I>&gt;<i>+				n.WriteTo (RootContext.XmlCommentOutput);
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (IsExposedFromAssembly (ds) &amp;&amp;
</I>&gt;<i>+				// There are no warnings when the container also
</I>&gt;<i>+				// misses documentations.
</I>&gt;<i>+				(ds == null || ds.DocComment != null))
</I>&gt;<i>+			{
</I>&gt;<i>+				Report.Warning (1591, 4, Location,
</I>&gt;<i>+					&quot;Missing XML comment for publicly visible type or member '{0}'&quot;, GetSignatureForError ());
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Processes &quot;include&quot; element. Check included file and
</I>&gt;<i>+		// embed the document content inside this documentation node.
</I>&gt;<i>+		//
</I>&gt;<i>+		private void HandleInclude (XmlElement el)
</I>&gt;<i>+		{
</I>&gt;<i>+			string file = el.GetAttribute (&quot;file&quot;);
</I>&gt;<i>+			string path = el.GetAttribute (&quot;path&quot;);
</I>&gt;<i>+			if (file == &quot;&quot;) {
</I>&gt;<i>+				Report.Warning (1590, 1, Location, &quot;Invalid XML 'include' element; Missing 'file' attribute.&quot;);
</I>&gt;<i>+				el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (&quot; Include tag is invalid &quot;), el);
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (path == &quot;&quot;) {
</I>&gt;<i>+				Report.Warning (1590, 1, Location, &quot;Invalid XML 'include' element; Missing 'path' attribute.&quot;);
</I>&gt;<i>+				el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (&quot; Include tag is invalid &quot;), el);
</I>&gt;<i>+			}
</I>&gt;<i>+			else {
</I>&gt;<i>+				XmlDocument doc = RootContext.StoredDocuments [file] as XmlDocument;
</I>&gt;<i>+				if (doc == null) {
</I>&gt;<i>+					try {
</I>&gt;<i>+						doc = new XmlDocument ();
</I>&gt;<i>+						doc.Load (file);
</I>&gt;<i>+						RootContext.StoredDocuments.Add (file, doc);
</I>&gt;<i>+					} catch (Exception) {
</I>&gt;<i>+						el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (String.Format (&quot; Badly formed XML in at comment file '{0}': cannot be included &quot;, file)), el);
</I>&gt;<i>+						Report.Warning (1592, 1, Location, &quot;Badly formed XML in included comments file -- '{0}'&quot;, file);
</I>&gt;<i>+					}
</I>&gt;<i>+				}
</I>&gt;<i>+				bool keepIncludeNode = false;
</I>&gt;<i>+				if (doc != null) {
</I>&gt;<i>+					try {
</I>&gt;<i>+						XmlNodeList nl = doc.SelectNodes (path);
</I>&gt;<i>+						if (nl.Count == 0) {
</I>&gt;<i>+							el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (&quot; No matching elements were found for the include tag embedded here. &quot;), el);
</I>&gt;<i>+					
</I>&gt;<i>+							keepIncludeNode = true;
</I>&gt;<i>+						}
</I>&gt;<i>+						foreach (XmlNode n in nl)
</I>&gt;<i>+							el.ParentNode.InsertBefore (el.OwnerDocument.ImportNode (n, true), el);
</I>&gt;<i>+					} catch (Exception ex) {
</I>&gt;<i>+						el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (&quot; Failed to insert some or all of included XML &quot;), el);
</I>&gt;<i>+						Report.Warning (1589, 1, Location, &quot;Unable to include XML fragment '{0}' of file {1} -- {2}.&quot;, path, file, ex.Message);
</I>&gt;<i>+					}
</I>&gt;<i>+				}
</I>&gt;<i>+				if (!keepIncludeNode)
</I>&gt;<i>+					el.ParentNode.RemoveChild (el);
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Handles &lt;see&gt; elements.
</I>&gt;<i>+		//
</I>&gt;<i>+		private void HandleSee (DeclSpace ds, string name, XmlElement see)
</I>&gt;<i>+		{
</I>&gt;<i>+			HandleXrefCommon (ds, name, see);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Handles &lt;seealso&gt; elements.
</I>&gt;<i>+		//
</I>&gt;<i>+		private void HandleSeeAlso (DeclSpace ds, string name, XmlElement seealso)
</I>&gt;<i>+		{
</I>&gt;<i>+			HandleXrefCommon (ds, name, seealso);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		static readonly char [] wsChars =
</I>&gt;<i>+			new char [] {' ', '\t', '\n', '\r'};
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// returns a full runtime type name from a name which might
</I>&gt;<i>+		// be C# specific type name.
</I>&gt;<i>+		//
</I>&gt;<i>+		private Type FindDocumentedType (string identifier, DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			switch (identifier) {
</I>&gt;<i>+			case &quot;int&quot;:
</I>&gt;<i>+				return typeof (int);
</I>&gt;<i>+			case &quot;uint&quot;:
</I>&gt;<i>+				return typeof (uint);
</I>&gt;<i>+			case &quot;short&quot;:
</I>&gt;<i>+				return typeof (short);
</I>&gt;<i>+			case &quot;ushort&quot;:
</I>&gt;<i>+				return typeof (ushort);
</I>&gt;<i>+			case &quot;long&quot;:
</I>&gt;<i>+				return typeof (long);
</I>&gt;<i>+			case &quot;ulong&quot;:
</I>&gt;<i>+				return typeof (ulong);
</I>&gt;<i>+			case &quot;float&quot;:
</I>&gt;<i>+				return typeof (float);
</I>&gt;<i>+			case &quot;double&quot;:
</I>&gt;<i>+				return typeof (double);
</I>&gt;<i>+			case &quot;char&quot;:
</I>&gt;<i>+				return typeof (char);
</I>&gt;<i>+			case &quot;decimal&quot;:
</I>&gt;<i>+				return typeof (decimal);
</I>&gt;<i>+			case &quot;byte&quot;:
</I>&gt;<i>+				return typeof (byte);
</I>&gt;<i>+			case &quot;sbyte&quot;:
</I>&gt;<i>+				return typeof (sbyte);
</I>&gt;<i>+			case &quot;object&quot;:
</I>&gt;<i>+				return typeof (object);
</I>&gt;<i>+			case &quot;bool&quot;:
</I>&gt;<i>+				return typeof (bool);
</I>&gt;<i>+			case &quot;string&quot;:
</I>&gt;<i>+				return typeof (string);
</I>&gt;<i>+			case &quot;void&quot;:
</I>&gt;<i>+				return typeof (void);
</I>&gt;<i>+			}
</I>&gt;<i>+			return ds.FindType (this.Location, identifier);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Returns a MemberInfo that is referenced in XML documentation
</I>&gt;<i>+		// (by &quot;see&quot; or &quot;seealso&quot; elements).
</I>&gt;<i>+		//
</I>&gt;<i>+		private MemberInfo FindDocumentedMember (Type type, string memberName, Type [] paramList, DeclSpace ds, out int warningType, string cref)
</I>&gt;<i>+		{
</I>&gt;<i>+			warningType = 0;
</I>&gt;<i>+			MethodSignature msig = new MethodSignature (memberName, null, paramList);
</I>&gt;<i>+			MemberInfo [] mis = type.FindMembers (
</I>&gt;<i>+				MemberTypes.All,
</I>&gt;<i>+				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
</I>&gt;<i>+				MethodSignature.method_signature_filter,
</I>&gt;<i>+				msig);
</I>&gt;<i>+			if (mis.Length &gt; 0)
</I>&gt;<i>+				return mis [0];
</I>&gt;<i>+
</I>&gt;<i>+			if (paramList.Length == 0) {
</I>&gt;<i>+				// search for fields/events etc.
</I>&gt;<i>+				mis = type.FindMembers (
</I>&gt;<i>+					MemberTypes.All,
</I>&gt;<i>+					BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
</I>&gt;<i>+					Type.FilterName,
</I>&gt;<i>+					memberName);
</I>&gt;<i>+				return (mis.Length &gt; 0) ? mis [0] : null;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			// search for operators (whose parameters exactly
</I>&gt;<i>+			// matches with the list) and possibly report CS1581.
</I>&gt;<i>+			string oper = null;
</I>&gt;<i>+			string returnTypeName = null;
</I>&gt;<i>+			if (memberName.StartsWith (&quot;implicit operator &quot;)) {
</I>&gt;<i>+				oper = &quot;op_Implicit&quot;;
</I>&gt;<i>+				returnTypeName = memberName.Substring (18).Trim (wsChars);
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (memberName.StartsWith (&quot;explicit operator &quot;)) {
</I>&gt;<i>+				oper = &quot;op_Explicit&quot;;
</I>&gt;<i>+				returnTypeName = memberName.Substring (18).Trim (wsChars);
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (memberName.StartsWith (&quot;operator &quot;)) {
</I>&gt;<i>+				oper = memberName.Substring (9).Trim (wsChars);
</I>&gt;<i>+				switch (oper) {
</I>&gt;<i>+				// either unary or binary
</I>&gt;<i>+				case &quot;+&quot;:
</I>&gt;<i>+					oper = paramList.Length == 2 ?
</I>&gt;<i>+						Binary.oper_names [(int) Binary.Operator.Addition] :
</I>&gt;<i>+						Unary.oper_names [(int) Unary.Operator.UnaryPlus];
</I>&gt;<i>+					break;
</I>&gt;<i>+				case &quot;-&quot;:
</I>&gt;<i>+					oper = paramList.Length == 2 ?
</I>&gt;<i>+						Binary.oper_names [(int) Binary.Operator.Subtraction] :
</I>&gt;<i>+						Unary.oper_names [(int) Unary.Operator.UnaryNegation];
</I>&gt;<i>+					break;
</I>&gt;<i>+				// unary
</I>&gt;<i>+				case &quot;!&quot;:
</I>&gt;<i>+					oper = Unary.oper_names [(int) Unary.Operator.LogicalNot]; break;
</I>&gt;<i>+				case &quot;~&quot;:
</I>&gt;<i>+					oper = Unary.oper_names [(int) Unary.Operator.OnesComplement]; break;
</I>&gt;<i>+					
</I>&gt;<i>+				case &quot;++&quot;:
</I>&gt;<i>+					oper = &quot;op_Increment&quot;; break;
</I>&gt;<i>+				case &quot;--&quot;:
</I>&gt;<i>+					oper = &quot;op_Decrement&quot;; break;
</I>&gt;<i>+				case &quot;true&quot;:
</I>&gt;<i>+					oper = &quot;op_True&quot;; break;
</I>&gt;<i>+				case &quot;false&quot;:
</I>&gt;<i>+					oper = &quot;op_False&quot;; break;
</I>&gt;<i>+				// binary
</I>&gt;<i>+				case &quot;*&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Multiply]; break;
</I>&gt;<i>+				case &quot;/&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Division]; break;
</I>&gt;<i>+				case &quot;%&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Modulus]; break;
</I>&gt;<i>+				case &quot;&amp;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.BitwiseAnd]; break;
</I>&gt;<i>+				case &quot;|&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.BitwiseOr]; break;
</I>&gt;<i>+				case &quot;^&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.ExclusiveOr]; break;
</I>&gt;<i>+				case &quot;&lt;&lt;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.LeftShift]; break;
</I>&gt;<i>+				case &quot;&gt;&gt;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.RightShift]; break;
</I>&gt;<i>+				case &quot;==&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Equality]; break;
</I>&gt;<i>+				case &quot;!=&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Inequality]; break;
</I>&gt;<i>+				case &quot;&lt;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.LessThan]; break;
</I>&gt;<i>+				case &quot;&gt;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.GreaterThan]; break;
</I>&gt;<i>+				case &quot;&lt;=&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.LessThanOrEqual]; break;
</I>&gt;<i>+				case &quot;&gt;=&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.GreaterThanOrEqual]; break;
</I>&gt;<i>+				default:
</I>&gt;<i>+					warningType = 1584;
</I>&gt;<i>+					Report.Warning (1020, 1, Location, &quot;Overloadable {0} operator is expected&quot;, paramList.Length == 2 ? &quot;binary&quot; : &quot;unary&quot;);
</I>&gt;<i>+					Report.Warning (1584, 1, Location, &quot;XML comment on '{0}' has syntactically incorrect attribute '{1}'&quot;, GetSignatureForError (), cref);
</I>&gt;<i>+					return null;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+			// here we still does not consider return type (to
</I>&gt;<i>+			// detect CS1581 or CS1002+CS1584).
</I>&gt;<i>+			msig = new MethodSignature (oper, null, paramList);
</I>&gt;<i>+			mis = type.FindMembers (
</I>&gt;<i>+				MemberTypes.Method,
</I>&gt;<i>+				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static,
</I>&gt;<i>+				MethodSignature.method_signature_filter,
</I>&gt;<i>+				msig);
</I>&gt;<i>+			if (mis.Length == 0)
</I>&gt;<i>+				return null; // CS1574
</I>&gt;<i>+			MemberInfo mi = mis [0];
</I>&gt;<i>+			Type expected = mi is MethodInfo ?
</I>&gt;<i>+				((MethodInfo) mi).ReturnType :
</I>&gt;<i>+				mi is PropertyInfo ?
</I>&gt;<i>+				((PropertyInfo) mi).PropertyType :
</I>&gt;<i>+				null;
</I>&gt;<i>+			if (returnTypeName != null) {
</I>&gt;<i>+				Type returnType = FindDocumentedType (returnTypeName, ds);
</I>&gt;<i>+				if (returnType == null || returnType != expected) {
</I>&gt;<i>+					warningType = 1581;
</I>&gt;<i>+					Report.Warning (1581, 1, Location, &quot;Invalid return type in XML comment cref attribute '{0}'&quot;, cref);
</I>&gt;<i>+					return null;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+			return mis [0];
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		private Type [] emptyParamList = new Type [0];
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Processes &quot;see&quot; or &quot;seealso&quot; elements.
</I>&gt;<i>+		// Checks cref attribute.
</I>&gt;<i>+		//
</I>&gt;<i>+		private void HandleXrefCommon (DeclSpace ds, string name, XmlElement xref)
</I>&gt;<i>+		{
</I>&gt;<i>+			string cref = xref.GetAttribute (&quot;cref&quot;).Trim (wsChars);
</I>&gt;<i>+			// when, XmlReader, &quot;if (cref == null)&quot;
</I>&gt;<i>+			if (!xref.HasAttribute (&quot;cref&quot;))
</I>&gt;<i>+				return;
</I>&gt;<i>+			if (cref.Length == 0)
</I>&gt;<i>+				Report.Warning (1001, 1, Location, &quot;Identifier expected&quot;);
</I>&gt;<i>+				// ... and continue until CS1584.
</I>&gt;<i>+
</I>&gt;<i>+			string signature, identifier, parameters;
</I>&gt;<i>+
</I>&gt;<i>+			// strip 'T:' 'M:' 'F:' 'P:' 'E:' etc.
</I>&gt;<i>+			// Here, MS ignores its member kind. No idea why.
</I>&gt;<i>+			if (cref.Length &gt; 2 &amp;&amp; cref [1] == ':')
</I>&gt;<i>+				signature = cref.Substring (2).Trim (wsChars);
</I>&gt;<i>+			else
</I>&gt;<i>+				signature = cref;
</I>&gt;<i>+
</I>&gt;<i>+			int parensPos = signature.IndexOf ('(');
</I>&gt;<i>+			if (parensPos &gt; 0 &amp;&amp; signature [signature.Length - 1] == ')') {
</I>&gt;<i>+				identifier = signature.Substring (0, parensPos).Trim (wsChars);
</I>&gt;<i>+				parameters = signature.Substring (parensPos + 1, signature.Length - parensPos - 2);
</I>&gt;<i>+			}
</I>&gt;<i>+			else {
</I>&gt;<i>+				identifier = signature;
</I>&gt;<i>+				parameters = String.Empty;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			string alias = ds.LookupAlias (identifier);
</I>&gt;<i>+			if (alias != null)
</I>&gt;<i>+				identifier = alias;
</I>&gt;<i>+
</I>&gt;<i>+			// Check if identifier is valid.
</I>&gt;<i>+			// This check is not necessary to mark as error, but
</I>&gt;<i>+			// csc specially reports CS1584 for wrong identifiers.
</I>&gt;<i>+			foreach (string nameElem in identifier.Split ('.')) {
</I>&gt;<i>+				if (!Tokenizer.IsValidIdentifier (nameElem) &amp;&amp; nameElem.IndexOf (&quot;operator&quot;) &lt; 0) {
</I>&gt;<i>+					Report.Warning (1584, 1, Location, &quot;XML comment on '{0}' has syntactically incorrect attribute '{1}'&quot;, GetSignatureForError (), cref);
</I>&gt;<i>+					xref.SetAttribute (&quot;cref&quot;, &quot;!:&quot; + signature);
</I>&gt;<i>+					return;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			// check if parameters are valid
</I>&gt;<i>+			Type [] parameterTypes = emptyParamList;
</I>&gt;<i>+			if (parameters.Length &gt; 0) {
</I>&gt;<i>+				string [] paramList = parameters.Split (',');
</I>&gt;<i>+				ArrayList plist = new ArrayList ();
</I>&gt;<i>+				for (int i = 0; i &lt; paramList.Length; i++) {
</I>&gt;<i>+					string paramTypeName = paramList [i].Trim (wsChars);
</I>&gt;<i>+					alias = ds.LookupAlias (paramTypeName);
</I>&gt;<i>+					if (alias != null)
</I>&gt;<i>+						paramTypeName = alias;
</I>&gt;<i>+					Type paramType = FindDocumentedType (paramTypeName, ds);
</I>&gt;<i>+					if (paramType == null) {
</I>&gt;<i>+						Report.Warning (1580, 1, Location, &quot;Invalid type for parameter '{0}' in XML comment cref attribute '{1}'&quot;, i + 1, cref);
</I>&gt;<i>+						return;
</I>&gt;<i>+					}
</I>&gt;<i>+					plist.Add (paramType);
</I>&gt;<i>+				}
</I>&gt;<i>+				parameterTypes = plist.ToArray (typeof (Type)) as Type [];
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			Type type = FindDocumentedType (identifier, ds);
</I>&gt;<i>+			if (type != null) {
</I>&gt;<i>+				xref.SetAttribute (&quot;cref&quot;, &quot;T:&quot; + type.FullName.Replace (&quot;+&quot;, &quot;.&quot;));
</I>&gt;<i>+				return; // a type
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			int period = identifier.LastIndexOf ('.');
</I>&gt;<i>+			if (period &gt; 0) {
</I>&gt;<i>+				string typeName = identifier.Substring (0, period);
</I>&gt;<i>+				string memberName = identifier.Substring (period + 1);
</I>&gt;<i>+				type = FindDocumentedType (typeName, ds);
</I>&gt;<i>+				int warnResult;
</I>&gt;<i>+				if (type != null) {
</I>&gt;<i>+					MemberInfo mi = FindDocumentedMember (type, memberName, parameterTypes, ds, out warnResult, cref);
</I>&gt;<i>+					if (warnResult &gt; 0)
</I>&gt;<i>+						return;
</I>&gt;<i>+					if (mi != null) {
</I>&gt;<i>+						xref.SetAttribute (&quot;cref&quot;, GetMemberDocHead (mi.MemberType) + type.FullName.Replace (&quot;+&quot;, &quot;.&quot;) + &quot;.&quot; + memberName);
</I>&gt;<i>+						return; // a member of a type
</I>&gt;<i>+					}
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+			else {
</I>&gt;<i>+				int warnResult;
</I>&gt;<i>+				MemberInfo mi = FindDocumentedMember (ds.TypeBuilder, identifier, parameterTypes, ds, out warnResult, cref);
</I>&gt;<i>+				if (warnResult &gt; 0)
</I>&gt;<i>+					return;
</I>&gt;<i>+				if (mi != null) {
</I>&gt;<i>+					xref.SetAttribute (&quot;cref&quot;, GetMemberDocHead (mi.MemberType) + ds.TypeBuilder.FullName.Replace (&quot;+&quot;, &quot;.&quot;) + &quot;.&quot; + identifier);
</I>&gt;<i>+					return; // local member name
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			Report.Warning (1574, 1, Location, &quot;XML comment on '{0}' has cref attribute '{1}' that could not be resolved in '{2}'.&quot;, GetSignatureForError (), cref, ds.GetSignatureForError ());
</I>&gt;<i>+
</I>&gt;<i>+			xref.SetAttribute (&quot;cref&quot;, &quot;!:&quot; + identifier);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Get a prefix from member type for XML documentation (used
</I>&gt;<i>+		// to formalize cref target name).
</I>&gt;<i>+		//
</I>&gt;<i>+		static string GetMemberDocHead (MemberTypes type)
</I>&gt;<i>+		{
</I>&gt;<i>+			switch (type) {
</I>&gt;<i>+			case MemberTypes.Constructor:
</I>&gt;<i>+			case MemberTypes.Method:
</I>&gt;<i>+				return &quot;M:&quot;;
</I>&gt;<i>+			case MemberTypes.Event:
</I>&gt;<i>+				return &quot;E:&quot;;
</I>&gt;<i>+			case MemberTypes.Field:
</I>&gt;<i>+				return &quot;F:&quot;;
</I>&gt;<i>+			case MemberTypes.NestedType:
</I>&gt;<i>+			case MemberTypes.TypeInfo:
</I>&gt;<i>+				return &quot;T:&quot;;
</I>&gt;<i>+			case MemberTypes.Property:
</I>&gt;<i>+				return &quot;P:&quot;;
</I>&gt;<i>+			}
</I>&gt;<i>+			return &quot;!:&quot;;
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i>@@ -1325,7 +1804,7 @@
</I>&gt;<i> 			IDictionaryEnumerator it = parent.member_hash.GetEnumerator ();
</I>&gt;<i> 			while (it.MoveNext ()) {
</I>&gt;<i> 				hash [it.Key] = ((ArrayList) it.Value).Clone ();
</I>&gt;<i>-                        }
</I>&gt;<i>+			 }
</I>&gt;<i>                                 
</I>&gt;<i> 			return hash;
</I>&gt;<i> 		}
</I>&gt;<i>Index: delegate.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- delegate.cs	(revision 36616)
</I>&gt;<i>+++ delegate.cs	(working copy)
</I>&gt;<i>@@ -643,6 +643,13 @@
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;T:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		protected override void VerifyObsoleteAttribute()
</I>&gt;<i> 		{
</I>&gt;<i> 			CheckUsageOfObsoleteAttribute (ret_type);
</I>&gt;<i>Index: cs-parser.jay
</I>&gt;<i>===================================================================
</I>&gt;<i>--- cs-parser.jay	(revision 36616)
</I>&gt;<i>+++ cs-parser.jay	(working copy)
</I>&gt;<i>@@ -81,6 +81,14 @@
</I>&gt;<i> 		/// The current file.
</I>&gt;<i> 		///
</I>&gt;<i> 		SourceFile file;
</I>&gt;<i>+
</I>&gt;<i>+		///
</I>&gt;<i>+		/// Temporary Xml documentation cache.
</I>&gt;<i>+		/// For enum types, we need one more temporary store.
</I>&gt;<i>+		///
</I>&gt;<i>+		string tmpComment;
</I>&gt;<i>+		string enumTypeComment;
</I>&gt;<i>+
</I>&gt;<i> 		
</I>&gt;<i> 		
</I>&gt;<i> 		/// Current attribute target
</I>&gt;<i>@@ -284,7 +292,13 @@
</I>&gt;<i> 	
</I>&gt;<i> opt_EOF
</I>&gt;<i> 	: /* empty */
</I>&gt;<i>+	{
</I>&gt;<i>+		Lexer.check_incorrect_doc_comment ();
</I>&gt;<i>+	}
</I>&gt;<i> 	| EOF
</I>&gt;<i>+	{
</I>&gt;<i>+		Lexer.check_incorrect_doc_comment ();
</I>&gt;<i>+	}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> outer_declarations
</I>&gt;<i>@@ -304,7 +318,15 @@
</I>&gt;<i> 
</I>&gt;<i> using_directive
</I>&gt;<i> 	: using_alias_directive
</I>&gt;<i>+	{
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	}
</I>&gt;<i> 	| using_namespace_directive
</I>&gt;<i>+	{
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> using_alias_directive
</I>&gt;<i>@@ -375,6 +397,10 @@
</I>&gt;<i> 
</I>&gt;<i> namespace_body
</I>&gt;<i> 	: OPEN_BRACE
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i> 	  opt_using_directives
</I>&gt;<i> 	  opt_namespace_member_declarations
</I>&gt;<i> 	  CLOSE_BRACE
</I>&gt;<i>@@ -491,6 +517,13 @@
</I>&gt;<i> 			} else {
</I>&gt;<i> 				$$ = new Attributes (sect);
</I>&gt;<i> 			}
</I>&gt;<i>+			if ($$ == null) {
</I>&gt;<i>+				if (RootContext.NeedDocument) {
</I>&gt;<i>+					Lexer.check_incorrect_doc_comment ();
</I>&gt;<i>+					Lexer.doc_state =
</I>&gt;<i>+						XmlCommentState.Allowed;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i> 		} else {
</I>&gt;<i> 			$$ = new Attributes (sect);
</I>&gt;<i> 		}		
</I>&gt;<i>@@ -746,9 +779,16 @@
</I>&gt;<i> 		if ($7 != null)
</I>&gt;<i> 			current_class.Bases = (ArrayList) $7;
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			current_class.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+
</I>&gt;<i> 		current_class.Register ();
</I>&gt;<i> 	  }
</I>&gt;<i> 	  struct_body
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i> 	  opt_semicolon
</I>&gt;<i> 	  {
</I>&gt;<i> 		$$ = current_class;
</I>&gt;<i>@@ -762,7 +802,12 @@
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> struct_body
</I>&gt;<i>-	: OPEN_BRACE opt_struct_member_declarations CLOSE_BRACE
</I>&gt;<i>+	: OPEN_BRACE
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i>+	  opt_struct_member_declarations CLOSE_BRACE
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> opt_struct_member_declarations
</I>&gt;<i>@@ -814,6 +859,10 @@
</I>&gt;<i> 				(Expression) constant.expression_or_array_initializer, modflags, 
</I>&gt;<i> 				(Attributes) $1, l);
</I>&gt;<i> 
</I>&gt;<i>+			if (RootContext.NeedDocument) {
</I>&gt;<i>+				c.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+			}
</I>&gt;<i> 			current_container.AddConstant (c);
</I>&gt;<i> 		}
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -866,6 +915,10 @@
</I>&gt;<i> 						 var.expression_or_array_initializer, 
</I>&gt;<i> 						 (Attributes) $1, l);
</I>&gt;<i> 
</I>&gt;<i>+			if (RootContext.NeedDocument) {
</I>&gt;<i>+				field.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+			}
</I>&gt;<i> 			current_container.AddField (field);
</I>&gt;<i> 		}
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -927,6 +980,8 @@
</I>&gt;<i> method_declaration
</I>&gt;<i> 	: method_header {
</I>&gt;<i> 		iterator_container = (IIteratorContainer) $1;
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	  method_body
</I>&gt;<i> 	  {
</I>&gt;<i>@@ -953,6 +1008,9 @@
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = null;
</I>&gt;<i> 		iterator_container = null;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -989,6 +1047,9 @@
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = (Parameters) $6;
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			method.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+
</I>&gt;<i> 		$$ = method;
</I>&gt;<i> 	  }
</I>&gt;<i> 	| opt_attributes
</I>&gt;<i>@@ -1003,6 +1064,10 @@
</I>&gt;<i> 					    (Attributes) $1, lexer.Location);
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = (Parameters) $6;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			method.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+
</I>&gt;<i> 		$$ = method;
</I>&gt;<i> 	  }
</I>&gt;<i> 	| opt_attributes
</I>&gt;<i>@@ -1020,6 +1085,10 @@
</I>&gt;<i> 					    lexer.Location);
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = (Parameters) $7;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			method.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+
</I>&gt;<i> 		$$ = method;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i>@@ -1163,7 +1232,12 @@
</I>&gt;<i> property_declaration
</I>&gt;<i> 	: opt_attributes
</I>&gt;<i> 	  opt_modifiers
</I>&gt;<i>-	  type namespace_or_type_name
</I>&gt;<i>+	  type
</I>&gt;<i>+	  namespace_or_type_name
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+	  }
</I>&gt;<i> 	  OPEN_BRACE 
</I>&gt;<i> 	  {
</I>&gt;<i> 		implicit_value_parameter_type = (Expression) $3;
</I>&gt;<i>@@ -1181,11 +1255,11 @@
</I>&gt;<i> 	  CLOSE_BRACE
</I>&gt;<i> 	  { 
</I>&gt;<i> 		Property prop;
</I>&gt;<i>-		Pair pair = (Pair) $7;
</I>&gt;<i>+		Pair pair = (Pair) $8;
</I>&gt;<i> 		Accessor get_block = (Accessor) pair.First;
</I>&gt;<i> 		Accessor set_block = (Accessor) pair.Second;
</I>&gt;<i> 
</I>&gt;<i>-		Location loc = (Location) $6;
</I>&gt;<i>+		Location loc = (Location) $7;
</I>&gt;<i> 		MemberName name = (MemberName) $4;
</I>&gt;<i> 
</I>&gt;<i> 		prop = new Property (current_class, (Expression) $3, (int) $2, false,
</I>&gt;<i>@@ -1196,6 +1270,10 @@
</I>&gt;<i> 		current_container.AddProperty (prop);
</I>&gt;<i> 		implicit_value_parameter_type = null;
</I>&gt;<i> 		iterator_container = null;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			prop.DocComment = ConsumeStoredComment ();
</I>&gt;<i>+
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1236,6 +1314,10 @@
</I>&gt;<i> 		$$ = new Accessor ((ToplevelBlock) $5, (int) $2, (Attributes) $1, lexer.Location);
</I>&gt;<i> 		current_local_parameters = null;
</I>&gt;<i> 		lexer.PropertyParsing = true;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			if (Lexer.doc_state == XmlCommentState.Error)
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1273,6 +1355,10 @@
</I>&gt;<i> 		$$ = new Accessor ((ToplevelBlock) $5, (int) $2, (Attributes) $1, lexer.Location);
</I>&gt;<i> 		current_local_parameters = null;
</I>&gt;<i> 		lexer.PropertyParsing = true;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			if (Lexer.doc_state == XmlCommentState.Error)
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1310,6 +1396,11 @@
</I>&gt;<i> 	  {
</I>&gt;<i> 		current_class.Bases = (ArrayList) $7;
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			current_class.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		current_class.Register ();
</I>&gt;<i> 	  }
</I>&gt;<i> 	  interface_body 
</I>&gt;<i>@@ -1470,6 +1561,8 @@
</I>&gt;<i> 				  new MemberName (TypeContainer.DefaultIndexerName),
</I>&gt;<i> 				  (int) $2, true, (Parameters) $6, (Attributes) $1,
</I>&gt;<i> 				  info.Get, info.Set, lexer.Location);
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			((Indexer) $$).DocComment = ConsumeStoredComment ();
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1493,6 +1586,9 @@
</I>&gt;<i> 			new Parameters (param_list, null, decl.location),
</I>&gt;<i> 			(ToplevelBlock) $5, (Attributes) $1, decl.location);
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			op.DocComment = ConsumeStoredComment ();
</I>&gt;<i>+
</I>&gt;<i> 		if (SimpleIteratorContainer.Simple.Yields)
</I>&gt;<i> 			op.SetYields ();
</I>&gt;<i> 
</I>&gt;<i>@@ -1522,12 +1618,18 @@
</I>&gt;<i> 			op = Operator.OpType.UnaryNegation;
</I>&gt;<i> 
</I>&gt;<i> 		Parameter [] pars = new Parameter [1];
</I>&gt;<i>+		Expression type = (Expression) $5;
</I>&gt;<i> 
</I>&gt;<i>-		pars [0] = new Parameter ((Expression) $5, (string) $6, Parameter.Modifier.NONE, null);
</I>&gt;<i>+		pars [0] = new Parameter (type, (string) $6, Parameter.Modifier.NONE, null);
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = new Parameters (pars, null, lexer.Location);
</I>&gt;<i> 
</I>&gt;<i>-		$$ = new OperatorDeclaration (op, (Expression) $1, (Expression) $5, (string) $6,
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		$$ = new OperatorDeclaration (op, (Expression) $1, type, (string) $6,
</I>&gt;<i> 					      null, null, lexer.Location);
</I>&gt;<i> 	}
</I>&gt;<i> 	| type OPERATOR overloadable_operator
</I>&gt;<i>@@ -1536,18 +1638,26 @@
</I>&gt;<i> 	  	type IDENTIFIER 
</I>&gt;<i> 	  CLOSE_PARENS
</I>&gt;<i>         {
</I>&gt;<i>-	       CheckBinaryOperator ((Operator.OpType) $3);
</I>&gt;<i>+		CheckBinaryOperator ((Operator.OpType) $3);
</I>&gt;<i> 
</I>&gt;<i>-	       Parameter [] pars = new Parameter [2];
</I>&gt;<i>+		Parameter [] pars = new Parameter [2];
</I>&gt;<i> 
</I>&gt;<i>-	       pars [0] = new Parameter ((Expression) $5, (string) $6, Parameter.Modifier.NONE, null);
</I>&gt;<i>-	       pars [1] = new Parameter ((Expression) $8, (string) $9, Parameter.Modifier.NONE, null);
</I>&gt;<i>+		Expression typeL = (Expression) $5;
</I>&gt;<i>+		Expression typeR = (Expression) $8;
</I>&gt;<i> 
</I>&gt;<i>+	       pars [0] = new Parameter (typeL, (string) $6, Parameter.Modifier.NONE, null);
</I>&gt;<i>+	       pars [1] = new Parameter (typeR, (string) $9, Parameter.Modifier.NONE, null);
</I>&gt;<i>+
</I>&gt;<i> 	       current_local_parameters = new Parameters (pars, null, lexer.Location);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i> 	       
</I>&gt;<i> 	       $$ = new OperatorDeclaration ((Operator.OpType) $3, (Expression) $1, 
</I>&gt;<i>-					     (Expression) $5, (string) $6,
</I>&gt;<i>-					     (Expression) $8, (string) $9, lexer.Location);
</I>&gt;<i>+					     typeL, (string) $6,
</I>&gt;<i>+					     typeR, (string) $9, lexer.Location);
</I>&gt;<i>         }
</I>&gt;<i> 	| conversion_operator_declarator
</I>&gt;<i> 	;
</I>&gt;<i>@@ -1624,6 +1734,9 @@
</I>&gt;<i> 		c.OptAttributes = (Attributes) $1;
</I>&gt;<i> 		c.ModFlags = (int) $2;
</I>&gt;<i> 	
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			c.DocComment = ConsumeStoredComment ();
</I>&gt;<i>+
</I>&gt;<i> 		if (c.Name == current_container.Basename){
</I>&gt;<i> 			if ((c.ModFlags &amp; Modifiers.STATIC) != 0){
</I>&gt;<i> 				if ((c.ModFlags &amp; Modifiers.Accessibility) != 0){
</I>&gt;<i>@@ -1657,22 +1770,30 @@
</I>&gt;<i> 		current_container.AddConstructor (c);
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = null;
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> constructor_declarator
</I>&gt;<i>-	: IDENTIFIER 
</I>&gt;<i>+	: IDENTIFIER
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+	  }
</I>&gt;<i> 	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS 
</I>&gt;<i> 	  {
</I>&gt;<i> 		oob_stack.Push (lexer.Location);
</I>&gt;<i> 
</I>&gt;<i>-		current_local_parameters = (Parameters) $3;
</I>&gt;<i>+		current_local_parameters = (Parameters) $4;
</I>&gt;<i> 	  }
</I>&gt;<i> 	  opt_constructor_initializer
</I>&gt;<i> 	  {
</I>&gt;<i> 		Location l = (Location) oob_stack.Pop ();
</I>&gt;<i>-		$$ = new Constructor (current_class, (string) $1, 0, (Parameters) $3,
</I>&gt;<i>-				      (ConstructorInitializer) $6, l);
</I>&gt;<i>+		$$ = new Constructor (current_class, (string) $1, 0, (Parameters) $4,
</I>&gt;<i>+				      (ConstructorInitializer) $7, l);
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1708,9 +1829,16 @@
</I>&gt;<i>         ;
</I>&gt;<i>         
</I>&gt;<i> destructor_declaration
</I>&gt;<i>-	: opt_attributes opt_finalizer TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS block
</I>&gt;<i>+	: opt_attributes opt_finalizer TILDE 
</I>&gt;<i> 	  {
</I>&gt;<i>-		if ((string) $4 != current_container.Basename){
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i>+		}
</I>&gt;<i>+	  }
</I>&gt;<i>+	  IDENTIFIER OPEN_PARENS CLOSE_PARENS block
</I>&gt;<i>+	  {
</I>&gt;<i>+		if ((string) $5 != current_container.Basename){
</I>&gt;<i> 			Report.Error (574, lexer.Location, &quot;Name of destructor must match name of class&quot;);
</I>&gt;<i> 		} else if (!(current_container is Class)){
</I>&gt;<i> 			Report.Error (575, lexer.Location, &quot;Destructors are only allowed in class types&quot;);
</I>&gt;<i>@@ -1734,8 +1862,10 @@
</I>&gt;<i> 			Method d = new Destructor (
</I>&gt;<i> 				current_class, TypeManager.system_void_expr, m, &quot;Finalize&quot;, 
</I>&gt;<i> 				new Parameters (null, null, l), (Attributes) $1, l);
</I>&gt;<i>+			if (RootContext.NeedDocument)
</I>&gt;<i>+				d.DocComment = ConsumeStoredComment ();
</I>&gt;<i> 		  
</I>&gt;<i>-			d.Block = (ToplevelBlock) $7;
</I>&gt;<i>+			d.Block = (ToplevelBlock) $8;
</I>&gt;<i> 			current_container.AddMethod (d);
</I>&gt;<i> 		}
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -1756,7 +1886,11 @@
</I>&gt;<i> 				lexer.Location);
</I>&gt;<i> 
</I>&gt;<i> 			current_container.AddEvent (e);
</I>&gt;<i>-				       
</I>&gt;<i>+
</I>&gt;<i>+			if (RootContext.NeedDocument) {
</I>&gt;<i>+				e.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+			}
</I>&gt;<i> 		}
</I>&gt;<i> 	  }
</I>&gt;<i> 	| opt_attributes
</I>&gt;<i>@@ -1788,7 +1922,11 @@
</I>&gt;<i> 				current_class, (Expression) $4, (int) $2, false, name, null,
</I>&gt;<i> 				(Attributes) $1, (Accessor) pair.First, (Accessor) pair.Second,
</I>&gt;<i> 				loc);
</I>&gt;<i>-			
</I>&gt;<i>+			if (RootContext.NeedDocument) {
</I>&gt;<i>+				e.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i> 			current_container.AddEvent (e);
</I>&gt;<i> 			implicit_value_parameter_type = null;
</I>&gt;<i> 		}
</I>&gt;<i>@@ -1800,6 +1938,9 @@
</I>&gt;<i> 			Report.Error (71, lexer.Location, &quot;Explicit implementation of events requires property syntax&quot;);
</I>&gt;<i> 		else 
</I>&gt;<i> 			Report.Error (71, lexer.Location, &quot;Event declaration should use property syntax&quot;);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1910,6 +2051,8 @@
</I>&gt;<i> 		indexer = new Indexer (current_class, decl.type, name,
</I>&gt;<i> 				       (int) $2, false, decl.param_list, (Attributes) $1,
</I>&gt;<i> 				       get_block, set_block, loc);
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			indexer.DocComment = ConsumeStoredComment ();
</I>&gt;<i> 
</I>&gt;<i> 		current_container.AddIndexer (indexer);
</I>&gt;<i> 		
</I>&gt;<i>@@ -1929,6 +2072,10 @@
</I>&gt;<i> 		} else if (pars.FixedParameters == null &amp;&amp; pars.ArrayParameter == null){
</I>&gt;<i> 			Report.Error (1551, lexer.Location, &quot;Indexers must have at least one parameter&quot;);
</I>&gt;<i> 		}
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i> 
</I>&gt;<i> 		$$ = new IndexerDeclaration ((Expression) $1, null, pars);
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -1942,8 +2089,14 @@
</I>&gt;<i> 		} else if (pars.FixedParameters == null &amp;&amp; pars.ArrayParameter == null){
</I>&gt;<i> 			Report.Error (1551, lexer.Location, &quot;Indexers must have at least one parameter&quot;);
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i> 		MemberName name = (MemberName) $2;
</I>&gt;<i> 		$$ = new IndexerDeclaration ((Expression) $1, name, pars);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1951,7 +2104,10 @@
</I>&gt;<i> 	: opt_attributes
</I>&gt;<i> 	  opt_modifiers
</I>&gt;<i> 	  ENUM IDENTIFIER 
</I>&gt;<i>-	  opt_enum_base
</I>&gt;<i>+	  opt_enum_base {
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			enumTypeComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+	  }
</I>&gt;<i> 	  enum_body
</I>&gt;<i> 	  opt_semicolon
</I>&gt;<i> 	  { 
</I>&gt;<i>@@ -1961,10 +2117,14 @@
</I>&gt;<i> 		Enum e = new Enum (current_namespace, current_container, (Expression) $5, (int) $2,
</I>&gt;<i> 				   full_name, (Attributes) $1, enum_location);
</I>&gt;<i> 		
</I>&gt;<i>-		foreach (VariableDeclaration ev in (ArrayList) $6) {
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			e.DocComment = enumTypeComment;
</I>&gt;<i>+
</I>&gt;<i>+		foreach (VariableDeclaration ev in (ArrayList) $7) {
</I>&gt;<i> 			e.AddEnumMember (ev.identifier, 
</I>&gt;<i> 					 (Expression) ev.expression_or_array_initializer,
</I>&gt;<i>-					 ev.Location, ev.OptAttributes);
</I>&gt;<i>+					 ev.Location, ev.OptAttributes,
</I>&gt;<i>+					 ev.DocComment);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		string name = full_name.GetName ();
</I>&gt;<i>@@ -1980,10 +2140,21 @@
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> enum_body
</I>&gt;<i>-	: OPEN_BRACE opt_enum_member_declarations CLOSE_BRACE
</I>&gt;<i>+	: OPEN_BRACE
</I>&gt;<i> 	  {
</I>&gt;<i>-		$$ = $2;
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i>+	  opt_enum_member_declarations
</I>&gt;<i>+	  {
</I>&gt;<i>+	  	// here will be evaluated after CLOSE_BLACE is consumed.
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i>+	  CLOSE_BRACE
</I>&gt;<i>+	  {
</I>&gt;<i>+		$$ = $3;
</I>&gt;<i>+	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> opt_enum_member_declarations
</I>&gt;<i>@@ -2012,15 +2183,31 @@
</I>&gt;<i> enum_member_declaration
</I>&gt;<i> 	: opt_attributes IDENTIFIER 
</I>&gt;<i> 	  {
</I>&gt;<i>-		$$ = new VariableDeclaration ((string) $2, null, lexer.Location, (Attributes) $1);
</I>&gt;<i>+		VariableDeclaration vd = new VariableDeclaration ((string) $2, null, lexer.Location, (Attributes) $1);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			vd.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		$$ = vd;
</I>&gt;<i> 	  }
</I>&gt;<i> 	| opt_attributes IDENTIFIER
</I>&gt;<i> 	  {
</I>&gt;<i>-		  $$ = lexer.Location;
</I>&gt;<i>+		$$ = lexer.Location;
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i>+		}
</I>&gt;<i> 	  }
</I>&gt;<i>           ASSIGN expression
</I>&gt;<i> 	  { 
</I>&gt;<i>-		$$ = new VariableDeclaration ((string) $2, $5, lexer.Location, (Attributes) $1);
</I>&gt;<i>+		VariableDeclaration vd = new VariableDeclaration ((string) $2, $5, lexer.Location, (Attributes) $1);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			vd.DocComment = ConsumeStoredComment ();
</I>&gt;<i>+
</I>&gt;<i>+		$$ = vd;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -2036,6 +2223,11 @@
</I>&gt;<i> 		Delegate del = new Delegate (current_namespace, current_container, (Expression) $4,
</I>&gt;<i> 					     (int) $2, name, (Parameters) $7, (Attributes) $1, l);
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			del.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		current_container.AddDelegate (del);
</I>&gt;<i> 		RootContext.Tree.RecordDecl (name.GetName (true), del);
</I>&gt;<i> 	  }	
</I>&gt;<i>@@ -2052,6 +2244,11 @@
</I>&gt;<i> 			TypeManager.system_void_expr, (int) $2, name,
</I>&gt;<i> 			(Parameters) $7, (Attributes) $1, l);
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			del.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		current_container.AddDelegate (del);
</I>&gt;<i> 		RootContext.Tree.RecordDecl (name.GetName (true), del);
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -3055,9 +3252,18 @@
</I>&gt;<i> 			current_class.Bases = (ArrayList) $7;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.NeedDocument) {
</I>&gt;<i>+			current_class.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		current_class.Register ();
</I>&gt;<i> 	  }
</I>&gt;<i>-	  class_body 
</I>&gt;<i>+	  class_body
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.NeedDocument)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i> 	  opt_semicolon 
</I>&gt;<i> 	  {
</I>&gt;<i> 		$$ = current_class;
</I>&gt;<i>@@ -4138,6 +4344,7 @@
</I>&gt;<i> 	public object expression_or_array_initializer;
</I>&gt;<i> 	public Location Location;
</I>&gt;<i> 	public Attributes OptAttributes;
</I>&gt;<i>+	public string DocComment;
</I>&gt;<i> 
</I>&gt;<i> 	public VariableDeclaration (string id, object eoai, Location l, Attributes opt_attrs)
</I>&gt;<i> 	{
</I>&gt;<i>@@ -4482,5 +4689,13 @@
</I>&gt;<i> 	CheckToken (1041, yyToken, &quot;Identifier expected&quot;);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i>+string ConsumeStoredComment ()
</I>&gt;<i>+{
</I>&gt;<i>+	string s = tmpComment;
</I>&gt;<i>+	tmpComment = null;
</I>&gt;<i>+	Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	return s;
</I>&gt;<i>+}
</I>&gt;<i>+
</I>&gt;<i> /* end end end */
</I>&gt;<i> }
</I>&gt;<i>Index: ChangeLog
</I>&gt;<i>===================================================================
</I>&gt;<i>--- ChangeLog	(revision 36616)
</I>&gt;<i>+++ ChangeLog	(working copy)
</I>&gt;<i>@@ -1,3 +1,35 @@
</I>&gt;<i>+2004-11-26  Atsushi Enomoto  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>+
</I>&gt;<i>+	all things are for /doc support:
</I>&gt;<i>+
</I>&gt;<i>+	* driver.cs:
</I>&gt;<i>+	  Handle /doc command line option.
</I>&gt;<i>+	  Report error 2006 instead of 5 for missing file name for /doc.
</I>&gt;<i>+	  Added call to RootContext.GenerateDocComment() after type resolution.
</I>&gt;<i>+	* cs-tokenizer.cs:
</I>&gt;<i>+	  Added support for picking up documentation (/// and /** ... */),
</I>&gt;<i>+	  including a new XmlCommentState enumeration.
</I>&gt;<i>+	* cs-parser.jay:
</I>&gt;<i>+	  Added lines to fill Documentation element for field, constant,
</I>&gt;<i>+	  property, indexer, method, constructor, destructor, operator, event
</I>&gt;<i>+	  and class, struct, interface, delegate, enum.
</I>&gt;<i>+	  Added lines to warn incorrect comment.
</I>&gt;<i>+	* rootcontext.cs :
</I>&gt;<i>+	  Added NeedDocument, XmlCommentOutput and XmlDocumentation (values
</I>&gt;<i>+	  are passed only when /doc was specified).
</I>&gt;<i>+	  Added StoredDocuments() to cache &lt;include&gt;d xml comment documents.
</I>&gt;<i>+	  Added static GenerateDocComment().
</I>&gt;<i>+	* decl.cs:
</I>&gt;<i>+	  Added DocComment, DocCommentHeader, GenerateDocComment() and
</I>&gt;<i>+	  OnGenerateDocComment() and some supporting private members for
</I>&gt;<i>+	  /doc feature to MemberCore.
</I>&gt;<i>+	* class.cs:
</I>&gt;<i>+	  Added GenerateDocComment() on TypeContainer, MethodCore and Operator.
</I>&gt;<i>+	* delegate.cs:
</I>&gt;<i>+	  Added overriden DocCommentHeader.
</I>&gt;<i>+	* enum.cs:
</I>&gt;<i>+	  Added overriden DocCommentHeader and GenerateDocComment().
</I>&gt;<i>+
</I>&gt;<i> 2004-11-25  Ben Maurer  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">bmaurer at ximian.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> 	* rootcontext.cs (LookupType): Make sure to cache lookups that
</I>&gt;<i>Index: driver.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- driver.cs	(revision 36616)
</I>&gt;<i>+++ driver.cs	(working copy)
</I>&gt;<i>@@ -17,6 +17,7 @@
</I>&gt;<i> 	using System.IO;
</I>&gt;<i> 	using System.Text;
</I>&gt;<i> 	using System.Globalization;
</I>&gt;<i>+	using System.Xml;
</I>&gt;<i> 	using System.Diagnostics;
</I>&gt;<i> 
</I>&gt;<i> 	public enum Target {
</I>&gt;<i>@@ -98,6 +99,11 @@
</I>&gt;<i> 		static Encoding encoding;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i>+		// XML Comment documentation
</I>&gt;<i>+		//
</I>&gt;<i>+		static string xml_documentation_file;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i> 		// Whether the user has specified a different encoder manually
</I>&gt;<i> 		//
</I>&gt;<i> 		static bool using_default_encoder = true;
</I>&gt;<i>@@ -220,6 +226,7 @@
</I>&gt;<i> 				&quot;   -nostdlib[+|-]     Does not load core libraries\n&quot; +
</I>&gt;<i> 				&quot;   -nowarn:W1[,W2]    Disables one or more warnings\n&quot; + 
</I>&gt;<i> 				&quot;   -out:FNAME         Specifies output file\n&quot; +
</I>&gt;<i>+				&quot;   -doc:XMLFILE         Generates xml documentation into specified file\n&quot; +
</I>&gt;<i> 				&quot;   -pkg:P1[,Pn]       References packages P1..Pn\n&quot; + 
</I>&gt;<i> 				&quot;   --expect-error X   Expect that error X will be encountered\n&quot; +
</I>&gt;<i> 				&quot;   -recurse:SPEC      Recursively compiles the files in SPEC ([dir]/file)\n&quot; + 
</I>&gt;<i>@@ -1101,10 +1108,11 @@
</I>&gt;<i> 			}
</I>&gt;<i> 			case &quot;/doc&quot;: {
</I>&gt;<i> 				if (value == &quot;&quot;){
</I>&gt;<i>-					Report.Error (5, arg + &quot; requires an argument&quot;);
</I>&gt;<i>+					Report.Error (2006, arg + &quot; requires an argument&quot;);
</I>&gt;<i> 					Environment.Exit (1);
</I>&gt;<i> 				}
</I>&gt;<i>-				// TODO handle the /doc argument to generate xml doc
</I>&gt;<i>+				xml_documentation_file = value;
</I>&gt;<i>+				RootContext.NeedDocument = true;
</I>&gt;<i> 				return true;
</I>&gt;<i> 			}
</I>&gt;<i> 			case &quot;/lib&quot;: {
</I>&gt;<i>@@ -1536,6 +1544,7 @@
</I>&gt;<i> 			if (timestamps)
</I>&gt;<i> 				ShowTime (&quot;Resolving tree&quot;);
</I>&gt;<i> 			RootContext.ResolveTree ();
</I>&gt;<i>+
</I>&gt;<i> 			if (Report.Errors &gt; 0)
</I>&gt;<i> 				return false;
</I>&gt;<i> 			if (timestamps)
</I>&gt;<i>@@ -1546,6 +1555,35 @@
</I>&gt;<i> 			RootContext.PopulateTypes ();
</I>&gt;<i> 			RootContext.DefineTypes ();
</I>&gt;<i> 			
</I>&gt;<i>+			if (RootContext.NeedDocument) {
</I>&gt;<i>+				XmlTextWriter w = null;
</I>&gt;<i>+				try {
</I>&gt;<i>+					w = new XmlTextWriter (xml_documentation_file, null);
</I>&gt;<i>+					w.Indentation = 4;
</I>&gt;<i>+					w.Formatting = Formatting.Indented;
</I>&gt;<i>+					w.WriteStartDocument ();
</I>&gt;<i>+					w.WriteStartElement (&quot;doc&quot;);
</I>&gt;<i>+					w.WriteStartElement (&quot;assembly&quot;);
</I>&gt;<i>+					w.WriteStartElement (&quot;name&quot;);
</I>&gt;<i>+					w.WriteString (Path.ChangeExtension (output_file, null));
</I>&gt;<i>+					w.WriteEndElement (); // name
</I>&gt;<i>+					w.WriteEndElement (); // assembly
</I>&gt;<i>+					w.WriteStartElement (&quot;members&quot;);
</I>&gt;<i>+					RootContext.XmlCommentOutput = w;
</I>&gt;<i>+					RootContext.GenerateDocComment ();
</I>&gt;<i>+					w.WriteFullEndElement (); // members
</I>&gt;<i>+					w.WriteEndElement ();
</I>&gt;<i>+					w.WriteWhitespace (Environment.NewLine);
</I>&gt;<i>+					w.WriteEndDocument ();
</I>&gt;<i>+				} catch (Exception ex) {
</I>&gt;<i>+					Report.Error (1569, &quot;Error generating XML documentation file '{0}' ('{1}')&quot;, xml_documentation_file, ex.Message);
</I>&gt;<i>+					return false;
</I>&gt;<i>+				} finally {
</I>&gt;<i>+					if (w != null)
</I>&gt;<i>+						w.Close ();
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i> 			TypeManager.InitCodeHelpers ();
</I>&gt;<i> 
</I>&gt;<i> 			//
</I>&gt;<i>@@ -1735,7 +1773,6 @@
</I>&gt;<i> #endif
</I>&gt;<i> 			return (Report.Errors == 0);
</I>&gt;<i> 		}
</I>&gt;<i>-
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	//
</I>&gt;<i>Index: enum.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- enum.cs	(revision 36616)
</I>&gt;<i>+++ enum.cs	(working copy)
</I>&gt;<i>@@ -14,6 +14,7 @@
</I>&gt;<i> using System.Reflection;
</I>&gt;<i> using System.Reflection.Emit;
</I>&gt;<i> using System.Globalization;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i> 
</I>&gt;<i> namespace Mono.CSharp {
</I>&gt;<i> 
</I>&gt;<i>@@ -100,6 +101,10 @@
</I>&gt;<i> 		protected override void VerifyObsoleteAttribute()
</I>&gt;<i> 		{
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;F:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i>@@ -152,7 +157,7 @@
</I>&gt;<i> 		///   Adds @name to the enumeration space, with @expr
</I>&gt;<i> 		///   being its definition.  
</I>&gt;<i> 		/// &lt;/summary&gt;
</I>&gt;<i>-		public void AddEnumMember (string name, Expression expr, Location loc, Attributes opt_attrs)
</I>&gt;<i>+		public void AddEnumMember (string name, Expression expr, Location loc, Attributes opt_attrs, string documentation)
</I>&gt;<i> 		{
</I>&gt;<i> 			if (name == &quot;value__&quot;) {
</I>&gt;<i> 				Report.Error (76, loc, &quot;An item in an enumeration can't have an identifier `value__'&quot;);
</I>&gt;<i>@@ -160,6 +165,7 @@
</I>&gt;<i> 			}
</I>&gt;<i> 
</I>&gt;<i> 			EnumMember em = new EnumMember (this, expr, name, loc, opt_attrs);
</I>&gt;<i>+			em.DocComment = documentation;
</I>&gt;<i> 			if (!AddToContainer (em, false, name, &quot;&quot;))
</I>&gt;<i> 				return;
</I>&gt;<i> 
</I>&gt;<i>@@ -784,5 +790,25 @@
</I>&gt;<i> 		{
</I>&gt;<i> 			// UnderlyingType is never obsolete
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Generates xml doc comments (if any), and if required,
</I>&gt;<i>+		// handle warning report.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal override void GenerateDocComment (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			base.GenerateDocComment (ds);
</I>&gt;<i>+			foreach (string name in ordered_enums) {
</I>&gt;<i>+				MemberCore mc = GetDefinition (name);
</I>&gt;<i>+				mc.GenerateDocComment (this);
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;T:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>Index: harness.mk
</I>&gt;<i>===================================================================
</I>&gt;<i>--- harness.mk	(revision 36619)
</I>&gt;<i>+++ harness.mk	(working copy)
</I>&gt;<i>@@ -9,6 +9,8 @@
</I>&gt;<i> MCS = MONO_PATH=&quot;$(topdir)/class/lib/$(PROFILE)$(PLATFORM_PATH_SEPARATOR)$$MONO_PATH&quot; $(INTERNAL_MCS)
</I>&gt;<i> endif
</I>&gt;<i> 
</I>&gt;<i>+XMLDOCDIFF = $(TEST_RUNTIME) ../xmldocdiff.exe
</I>&gt;<i>+
</I>&gt;<i> all-local $(STD_TARGETS:=-local):
</I>&gt;<i> 
</I>&gt;<i> %.res:
</I>&gt;<i>@@ -20,8 +22,17 @@
</I>&gt;<i> 	  if test -f $*.exe; then \
</I>&gt;<i> 	    echo '*** $(TEST_RUNTIME) ./$*.exe' &gt;&gt; $$testlogfile ; \
</I>&gt;<i> 	      if $(TEST_RUNTIME) -O=-all ./$*.exe &gt;&gt; $$testlogfile 2&gt;&amp;1 ; then \
</I>&gt;<i>-		echo &quot;PASS: $*&quot; &gt; $@ ; \
</I>&gt;<i>-	        rm -f $$testlogfile ; \
</I>&gt;<i>+	        if test -f $*.xml; then \
</I>&gt;<i>+	          if $(XMLDOCDIFF) ../$*-ref.xml $*.xml &gt;&gt; $$testlogfile ; then \
</I>&gt;<i>+	            echo &quot;PASS: $*: xml comparison&quot; &gt; $@ ; \
</I>&gt;<i>+	            rm -f $$testlogfile ; \
</I>&gt;<i>+	          else \
</I>&gt;<i>+	            echo &quot;FAIL: $*: xml comparison&quot; &gt; $@ ; \
</I>&gt;<i>+	          fi \
</I>&gt;<i>+	        else \
</I>&gt;<i>+	          echo &quot;PASS: $*&quot; &gt; $@ ; \
</I>&gt;<i>+	          rm -f $$testlogfile ; \
</I>&gt;<i>+	        fi \
</I>&gt;<i> 	      else \
</I>&gt;<i> 		echo &quot;Exit code: $$?&quot; &gt;&gt; $$testlogfile ; \
</I>&gt;<i> 		echo &quot;FAIL: $*&quot; &gt; $@ ; \
</I>&gt;<i>Index: Makefile
</I>&gt;<i>===================================================================
</I>&gt;<i>--- Makefile	(revision 36620)
</I>&gt;<i>+++ Makefile	(working copy)
</I>&gt;<i>@@ -26,7 +26,8 @@
</I>&gt;<i> # He may also move some to TEST_EXCLUDE_net_2_0 if some of the merges are inappropriate for GMCS.
</I>&gt;<i> #
</I>&gt;<i> NEW_TEST_SOURCES_common = test-294 test-304 test-305 test-306 test-307 test-318 mtest-5-dll mtest-5-exe \
</I>&gt;<i>-			test-319-dll test-319-exe test-320
</I>&gt;<i>+			test-319-dll test-319-exe test-320 \
</I>&gt;<i>+			$(TEST_SOURCES_XML)
</I>&gt;<i> 
</I>&gt;<i> #
</I>&gt;<i> # Please do _not_ add any tests here - all new tests should go into NEW_TEST_SOURCES_common
</I>&gt;<i>@@ -181,7 +182,7 @@
</I>&gt;<i> endif
</I>&gt;<i> 
</I>&gt;<i> .PHONY: test-harness test-harness-run
</I>&gt;<i>-test-harness:
</I>&gt;<i>+test-harness: xmldocdiff.exe
</I>&gt;<i> 	@$(MAKE) -s test-harness-run
</I>&gt;<i> 
</I>&gt;<i> exe_tests := $(filter %-exe, $(TEST_SOURCES))
</I>&gt;<i>@@ -222,3 +223,22 @@
</I>&gt;<i> 	$(INTERNAL_ILASM) /dll property-il.il
</I>&gt;<i> 	$(CSCOMPILE) /r:property-il.dll property-main.cs /out:property-main.exe
</I>&gt;<i> 	$(TEST_RUNTIME) property-main.exe
</I>&gt;<i>+
</I>&gt;<i>+
</I>&gt;<i>+#
</I>&gt;<i>+# Test for /doc option; need to compare result documentation files.
</I>&gt;<i>+#
</I>&gt;<i>+
</I>&gt;<i>+TEST_SOURCES_XML = \
</I>&gt;<i>+	xml-001 xml-002 xml-003 xml-004 xml-005 xml-006 xml-007 xml-008 xml-009 xml-010 \
</I>&gt;<i>+	xml-011 xml-012 xml-013 xml-014 xml-015 xml-016 xml-017 xml-018 xml-019 xml-020 \
</I>&gt;<i>+	xml-021 xml-022 xml-023 xml-024 xml-025 xml-026
</I>&gt;<i>+
</I>&gt;<i>+# currently no formalization on 'cref' attribute was found, so there are some
</I>&gt;<i>+# differences between MS.NET and mono.
</I>&gt;<i>+TEST_SOURCES_XML_PENDING = xml-027
</I>&gt;<i>+
</I>&gt;<i>+xml-doc-tests := $(filter xml-%, $(TEST_SOURCES))
</I>&gt;<i>+
</I>&gt;<i>+xmldocdiff.exe:
</I>&gt;<i>+	$(CSCOMPILE) xmldocdiff.cs
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>&lt;?xml version=&quot;1.0&quot;?&gt;
</I>&gt;<i>&lt;doc&gt;
</I>&gt;<i>    &lt;assembly&gt;
</I>&gt;<i>        &lt;name&gt;xml-025&lt;/name&gt;
</I>&gt;<i>    &lt;/assembly&gt;
</I>&gt;<i>    &lt;members&gt;
</I>&gt;<i>        &lt;member name=&quot;T:Testing.Test&quot;&gt;
</I>&gt;<i>            &lt;!-- No matching elements were found for the following include tag --&gt;&lt;include file=&quot;../xml-025.inc&quot; path=&quot;/foo&quot;/&gt;
</I>&gt;<i>        &lt;/member&gt;
</I>&gt;<i>        &lt;member name=&quot;F:Testing.Test.S1&quot;&gt;
</I>&gt;<i>            &lt;root attr=&quot;is attribute allowed?&quot;&gt;
</I>&gt;<i>  includes XML markup.
</I>&gt;<i>  &lt;child&gt;test&lt;/child&gt;
</I>&gt;<i>  &lt;child&gt;test2&lt;/child&gt;
</I>&gt;<i>&lt;/root&gt;
</I>&gt;<i>        &lt;/member&gt;
</I>&gt;<i>        &lt;member name=&quot;F:Testing.Test.S2&quot;&gt;
</I>&gt;<i>            &lt;child&gt;test&lt;/child&gt;&lt;child&gt;test2&lt;/child&gt;
</I>&gt;<i>        &lt;/member&gt;
</I>&gt;<i>        &lt;member name=&quot;F:Testing.Test.S3&quot;&gt;
</I>&gt;<i>            &lt;!-- Failed to insert some or all of included XML --&gt;
</I>&gt;<i>        &lt;/member&gt;
</I>&gt;<i>    &lt;/members&gt;
</I>&gt;<i>&lt;/doc&gt;
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>// Compiler options: -doc:xml-025.xml
</I>&gt;<i>// Note that it could not be compiled to generate reference output as it is.
</I>&gt;<i>// csc needs '\\' instead of '/' for file specification.
</I>&gt;<i>
</I>&gt;<i>namespace Testing
</I>&gt;<i>{
</I>&gt;<i>   /// &lt;include file='../xml-025.inc' path='/foo' /&gt;
</I>&gt;<i>   public class Test
</I>&gt;<i>   {
</I>&gt;<i>	public static void Main ()
</I>&gt;<i>	{
</I>&gt;<i>	}
</I>&gt;<i>
</I>&gt;<i>	/// &lt;include file='../xml-025.inc' path='/root'/&gt;
</I>&gt;<i>	public string S1;
</I>&gt;<i>
</I>&gt;<i>	/// &lt;include file='../xml-025.inc' path='/root/child'/&gt;
</I>&gt;<i>	public string S2;
</I>&gt;<i>
</I>&gt;<i>	/// &lt;include file='../xml-025.inc' path='/root/@attr'/&gt;
</I>&gt;<i>	public string S3;
</I>&gt;<i>   }
</I>&gt;<i>}
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>using System;
</I>&gt;<i>using System.Collections;
</I>&gt;<i>using System.Xml;
</I>&gt;<i>
</I>&gt;<i>public class Test
</I>&gt;<i>{
</I>&gt;<i>	public class ComparisonException : Exception
</I>&gt;<i>	{
</I>&gt;<i>		public ComparisonException (string message)
</I>&gt;<i>			: base (message)
</I>&gt;<i>		{
</I>&gt;<i>		}
</I>&gt;<i>	}
</I>&gt;<i>
</I>&gt;<i>	static bool debug = false;
</I>&gt;<i>	static bool error = false;
</I>&gt;<i>
</I>&gt;<i>	public static void Main (string [] args)
</I>&gt;<i>	{
</I>&gt;<i>		if (args.Length &lt; 2) {
</I>&gt;<i>			Console.Error.WriteLine (&quot;Usage: xmldocdiff [reference_output.xml] [actual_output.xml]&quot;);
</I>&gt;<i>			return;
</I>&gt;<i>		}
</I>&gt;<i>		if (args.Length &gt; 2 &amp;&amp; args [2].EndsWith (&quot;-debug&quot;))
</I>&gt;<i>			debug = true;
</I>&gt;<i>
</I>&gt;<i>		try {
</I>&gt;<i>			Run (args);
</I>&gt;<i>		} catch (Exception ex) {
</I>&gt;<i>			Console.WriteLine (&quot;FAIL: &quot; + args [1]);
</I>&gt;<i>			throw ex;
</I>&gt;<i>		}
</I>&gt;<i>		Console.WriteLine (&quot;PASS: &quot; + args [1]);
</I>&gt;<i>	}
</I>&gt;<i>
</I>&gt;<i>	private static void Run (string [] args)
</I>&gt;<i>	{
</I>&gt;<i>		XmlDocument doc1 = new XmlDocument ();
</I>&gt;<i>		doc1.Load (args [0]);
</I>&gt;<i>		XmlDocument doc2 = new XmlDocument ();
</I>&gt;<i>		doc2.Load (args [1]);
</I>&gt;<i>
</I>&gt;<i>		XmlNodeList memberList1 = doc1.SelectNodes (&quot;/doc/members/member&quot;);
</I>&gt;<i>		XmlNodeList memberList2 = doc2.SelectNodes (&quot;/doc/members/member&quot;);
</I>&gt;<i>
</I>&gt;<i>		Hashtable namedItems = new Hashtable ();
</I>&gt;<i>
</I>&gt;<i>		foreach (XmlElement el in memberList1)
</I>&gt;<i>			namedItems.Add (el.GetAttribute (&quot;name&quot;), el);
</I>&gt;<i>		foreach (XmlElement el2 in memberList2) {
</I>&gt;<i>			string name = el2.GetAttribute (&quot;name&quot;);
</I>&gt;<i>			XmlElement el1 = namedItems [name] as XmlElement;
</I>&gt;<i>			if (el1 == null) {
</I>&gt;<i>				Report (&quot;Extraneous element found. Name is '{0}'&quot;, name);
</I>&gt;<i>				continue;
</I>&gt;<i>			}
</I>&gt;<i>			namedItems.Remove (name);
</I>&gt;<i>
</I>&gt;<i>/*
</I>&gt;<i>			string el1xml = el1.InnerXml.Replace (&quot;\r&quot;, &quot;&quot;).Trim ();
</I>&gt;<i>			string el2xml = el2.InnerXml.Replace (&quot;\r&quot;, &quot;&quot;).Trim ();
</I>&gt;<i>			if (el1xml != el2xml)
</I>&gt;<i>				Report (@&quot;Member {0} contains different XML.
</I>&gt;<i>---- Expected: {1}
</I>&gt;<i>---- Actual  : {2}&quot;, name, el1xml, el2xml);
</I>&gt;<i>*/
</I>&gt;<i>			CompareNodes (el1, el2);
</I>&gt;<i>
</I>&gt;<i>		}
</I>&gt;<i>		foreach (string name in namedItems.Keys)
</I>&gt;<i>			Report (&quot;Expected comment was not found. Name is {0}, XML is {1}&quot;, name, ((XmlElement) namedItems [name]).OuterXml);
</I>&gt;<i>
</I>&gt;<i>		// finally, check other nodes than members
</I>&gt;<i>		doc1.SelectSingleNode (&quot;/doc/members&quot;).RemoveAll ();
</I>&gt;<i>		doc2.SelectSingleNode (&quot;/doc/members&quot;).RemoveAll ();
</I>&gt;<i>		string xml1 = doc1.OuterXml.Replace (&quot;\r&quot;, &quot;&quot;).Trim ();
</I>&gt;<i>		string xml2 = doc2.OuterXml.Replace (&quot;\r&quot;, &quot;&quot;).Trim ();
</I>&gt;<i>		if (xml1 != xml2)
</I>&gt;<i>			Report (@&quot;Either of doc, assembly, name, members elements  are different.
</I>&gt;<i>doc1: {0}
</I>&gt;<i>doc2: {1}&quot;, xml1, xml2);
</I>&gt;<i>	}
</I>&gt;<i>
</I>&gt;<i>	private static void CompareNodes (XmlNode n1, XmlNode n2)
</I>&gt;<i>	{
</I>&gt;<i>		if (n2 == null) {
</I>&gt;<i>			Report (@&quot;Nodes does not exist:
</I>&gt;<i>Node1: {0}&quot;, n1.OuterXml);
</I>&gt;<i>			return;
</I>&gt;<i>		}
</I>&gt;<i>		if (n1.NodeType != n2.NodeType) {
</I>&gt;<i>			Report (@&quot;Nodes differ:
</I>&gt;<i>Node1: {0}
</I>&gt;<i>Node2: {1}&quot;, n1.OuterXml, n2.OuterXml);
</I>&gt;<i>			return;
</I>&gt;<i>		}
</I>&gt;<i>		if (n1.Name != n2.Name) {
</I>&gt;<i>			Report (@&quot;Node names differ:
</I>&gt;<i>Node1: {0}
</I>&gt;<i>Node2: {1}&quot;, n1.OuterXml, n2.OuterXml);
</I>&gt;<i>			return;
</I>&gt;<i>		}
</I>&gt;<i>		if (n1 is XmlElement) {
</I>&gt;<i>			for (int i = 0; i &lt; n1.Attributes.Count; i++)
</I>&gt;<i>				CompareNodes (n1.Attributes [i],
</I>&gt;<i>					n2.Attributes [i]);
</I>&gt;<i>			for (int i = 0; i &lt; n1.ChildNodes.Count; i++)
</I>&gt;<i>				CompareNodes (n1.ChildNodes [i],
</I>&gt;<i>					n2.ChildNodes [i]);
</I>&gt;<i>		}
</I>&gt;<i>		if (n1.NodeType != XmlNodeType.Comment &amp;&amp; n1.Value != null) {
</I>&gt;<i>			string v1 = n1.Value.Trim ();
</I>&gt;<i>			string v2 = n2.Value.Trim ();
</I>&gt;<i>			if (v1 != v2)
</I>&gt;<i>				Report (@&quot;Node values differ:
</I>&gt;<i>Node1: {0}
</I>&gt;<i>Node2: {1}&quot;, v1, v2);
</I>&gt;<i>		}
</I>&gt;<i>	}
</I>&gt;<i>
</I>&gt;<i>	static void Report (string format, params string [] args)
</I>&gt;<i>	{
</I>&gt;<i>		error = true;
</I>&gt;<i>		if (debug)
</I>&gt;<i>			Console.WriteLine (format, args);
</I>&gt;<i>		else
</I>&gt;<i>			throw new ComparisonException (String.Format (format, args));
</I>&gt;<i>	}
</I>&gt;<i>}
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009068.html">[Mono-devel-list] Patch for full-featured mcs /doc support
</A></li>
	<LI>Next message: <A HREF="009070.html">[Mono-devel-list] Patch for full-featured mcs /doc support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9069">[ date ]</a>
              <a href="thread.html#9069">[ thread ]</a>
              <a href="subject.html#9069">[ subject ]</a>
              <a href="author.html#9069">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
