<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] RAPGO Proposal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20RAPGO%20Proposal&In-Reply-To=41A7739D.8000308%40gmx.at">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009082.html">
   <LINK REL="Next"  HREF="009112.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] RAPGO Proposal</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20RAPGO%20Proposal&In-Reply-To=41A7739D.8000308%40gmx.at"
       TITLE="[Mono-devel-list] RAPGO Proposal">lupus at ximian.com
       </A><BR>
    <I>Mon Nov 29 05:48:07 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009082.html">[Mono-devel-list] RAPGO Proposal
</A></li>
        <LI>Next message: <A HREF="009112.html">[Mono-devel-list] RAPGO Proposal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9108">[ date ]</a>
              <a href="thread.html#9108">[ thread ]</a>
              <a href="subject.html#9108">[ subject ]</a>
              <a href="author.html#9108">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/26/04 Willibald Krenn wrote:
&gt;<i> 	IMO it would be beneficial to somehow cache compiled code on
</I>&gt;<i> 	disk along with the executable, so that the first time
</I>&gt;<i> 	compilation may be replaced by loading the cached version...
</I>&gt;<i> 	(Some sort of implicit AOT compilation?) Of course this can't
</I>&gt;<i> 	be done with fully optimized versions..
</I>
Zoltan has already some code that does this, though I don't remember
if it's finished cleaned up. Look in aot.c.

&gt;<i> 	I've come up with following 'idea': Each method is called
</I>&gt;<i> 	indirectly via	call *rax (where rax points to some GOT). So by
</I>&gt;<i> 	changing the offset every call will go to the new location.
</I>&gt;<i> 	Another technique would be to replace the existing method by
</I>&gt;<i> 	some code that patches the caller's address to jump to the new
</I>&gt;<i> 	code the next time directly. This however means that we would
</I>&gt;<i> 	have to take care how long a given 'Patcher' needs to be
</I>&gt;<i> 	preserved... (some problem GC could take care of..)
</I>
We have already the code to deal with this.

&gt;<i> 	Before freeing/overwriting a method we also have to ensure no
</I>&gt;<i> 	thread is executing this piece of code anymore. Simple
</I>&gt;<i> 	Entry/Exit counters should be able to handle that..
</I>
Counters are not needed and would be too slow. We can simply walk
the stack of the various threads and see if any is inside the method.
At first, there is no need to free the code, since we'll only recompile a 
method once or twice, so the 'leak' is bounded.

&gt;<i> 	(In case of an endless loop, code could be patched so that this
</I>&gt;<i> 	thread generates a signal..)
</I>
One of the issues is how to handle methods that are never exited. If a method
is called many times it's easy to recompile it and make the code call the new
faster version. However, if most of the time is spent inside a single method
which is executed once, for example, just recompiling and changing the call 
sites is not going to work. We'd need to transfer the state from the old 
stack/registers to the state as needed by the new code: this is far from 
trivial and one of the reasons I prefer statistical profiling vs 
counter-based profiling with code embedded in the slow method compilation
(though I guess in such cases that code could be overwritten with nops).
With statistical profiling the code is at least not slowed down by
the profiling overhead.

&gt;<i> VI Placement
</I>&gt;<i> ~~~~~~~~~~~~
</I>&gt;<i> 	Currently every code that is being emitted gets copied to it's
</I>&gt;<i> 	final location - smells like overhead to me..
</I>&gt;<i> 	What about mmap and direct emit into this area?
</I>&gt;<i> 	This would also save time for freeing/allocating memory for
</I>&gt;<i> 	replacement code.
</I>
I don't think any of this is an issue: a memcpy of the code is going
to be a very tiny fraction of the time spent compiling. And I don't see
any relation with the freeing/allocating.

Thanks.
lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009082.html">[Mono-devel-list] RAPGO Proposal
</A></li>
	<LI>Next message: <A HREF="009112.html">[Mono-devel-list] RAPGO Proposal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9108">[ date ]</a>
              <a href="thread.html#9108">[ thread ]</a>
              <a href="subject.html#9108">[ subject ]</a>
              <a href="author.html#9108">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
