<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] RAPGO Proposal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20RAPGO%20Proposal&In-Reply-To=20041129104807.GJ2153%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009108.html">
   <LINK REL="Next"  HREF="009113.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] RAPGO Proposal</H1>
    <B>Willibald Krenn</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20RAPGO%20Proposal&In-Reply-To=20041129104807.GJ2153%40debian.org"
       TITLE="[Mono-devel-list] RAPGO Proposal">Willibald.Krenn at gmx.at
       </A><BR>
    <I>Mon Nov 29 08:07:10 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009108.html">[Mono-devel-list] RAPGO Proposal
</A></li>
        <LI>Next message: <A HREF="009113.html">[Mono-devel-list] RAPGO Proposal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9112">[ date ]</a>
              <a href="thread.html#9112">[ thread ]</a>
              <a href="subject.html#9112">[ subject ]</a>
              <a href="author.html#9112">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Paolo Molaro schrieb:
&gt;<i> 
</I>&gt;<i> Zoltan has already some code that does this, though I don't remember
</I>&gt;<i> if it's finished cleaned up. Look in aot.c.
</I>
Ok, I'll do. But this isn't my number 1 priority..


&gt;<i> 
</I>&gt;&gt;<i>	I've come up with following 'idea': Each method is called
</I>&gt;&gt;<i>	indirectly via	call *rax (where rax points to some GOT). So by
</I>&gt;&gt;<i>	changing the offset every call will go to the new location.
</I>&gt;&gt;<i>	Another technique would be to replace the existing method by
</I>&gt;&gt;<i>	some code that patches the caller's address to jump to the new
</I>&gt;&gt;<i>	code the next time directly. This however means that we would
</I>&gt;&gt;<i>	have to take care how long a given 'Patcher' needs to be
</I>&gt;&gt;<i>	preserved... (some problem GC could take care of..)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> We have already the code to deal with this.
</I>
Could you give me a pointer? I wasn't aware of that - must be some 
relatively new thing..


&gt;&gt;<i>	Before freeing/overwriting a method we also have to ensure no
</I>&gt;&gt;<i>	thread is executing this piece of code anymore. Simple
</I>&gt;&gt;<i>	Entry/Exit counters should be able to handle that..
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Counters are not needed and would be too slow. We can simply walk
</I>&gt;<i> the stack of the various threads and see if any is inside the method.
</I>&gt;<i> At first, there is no need to free the code, since we'll only recompile a 
</I>&gt;<i> method once or twice, so the 'leak' is bounded.
</I>
I see. So you are first patching all invocations to go to the new method 
and will then check all threads whether they are within the 'old' method..
When do you think stack walking will be slower than having counters?


&gt;&gt;<i>	(In case of an endless loop, code could be patched so that this
</I>&gt;&gt;<i>	thread generates a signal..)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> One of the issues is how to handle methods that are never exited. If a method
</I>&gt;<i> is called many times it's easy to recompile it and make the code call the new
</I>&gt;<i> faster version. However, if most of the time is spent inside a single method
</I>&gt;<i> which is executed once, for example, just recompiling and changing the call 
</I>&gt;<i> sites is not going to work. We'd need to transfer the state from the old 
</I>&gt;<i> stack/registers to the state as needed by the new code: this is far from 
</I>&gt;<i> trivial and one of the reasons I prefer statistical profiling vs 
</I>&gt;<i> counter-based profiling with code embedded in the slow method compilation
</I>&gt;<i> (though I guess in such cases that code could be overwritten with nops).
</I>&gt;<i> With statistical profiling the code is at least not slowed down by
</I>&gt;<i> the profiling overhead.
</I>
Well, a sampling profiler will slow down execution too, but not that 
much. However, you won't get all information you need for certain 
optimizations by using a sampling profiler AFAIK, so IMO it's still 
beneficial to instrument methods that have been shown by sampling to be 
'hot'. The resulting slowdown will IMO be minimal (especially if MMX 
registers are used, the float pipeline isn't populated by the method to 
be profiled and results get written to memory once) and therefore 
negligible.

Code that runs endlessly in a loop probably isn't a good candidate for 
runtime replacement at all. Probably 'transfer-points' - icalls p/i 
calls are good candidates - could be introduced that have a known 
stack/register state, but well..
However, mono could memorize methods that run some endless loop for the 
next time the application is run.

&gt;&gt;<i>	Currently every code that is being emitted gets copied to it's
</I>&gt;&gt;<i>	final location - smells like overhead to me..
</I>&gt;&gt;<i>	What about mmap and direct emit into this area?
</I>&gt;&gt;<i>	This would also save time for freeing/allocating memory for
</I>&gt;&gt;<i>	replacement code.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I don't think any of this is an issue: a memcpy of the code is going
</I>&gt;<i> to be a very tiny fraction of the time spent compiling. And I don't see
</I>&gt;<i> any relation with the freeing/allocating.
</I>
Ok, point taken. (Although if you'd move inssel into the backend and let 
the inssel generate the final code into the target buffer, things should 
be faster. However, it's questionable how much.)

I'm quite surprised no-one commented on my C++ proposal! So does that 
mean if I send patches that use C++, you'll accept them?

Willi


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009108.html">[Mono-devel-list] RAPGO Proposal
</A></li>
	<LI>Next message: <A HREF="009113.html">[Mono-devel-list] RAPGO Proposal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9112">[ date ]</a>
              <a href="thread.html#9112">[ thread ]</a>
              <a href="subject.html#9112">[ subject ]</a>
              <a href="author.html#9112">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
