<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] The future of Mono's profiler API
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.dot.net?Subject=Re%3A%20%5BMono-dev%5D%20The%20future%20of%20Mono%27s%20profiler%20API&In-Reply-To=%3CCAH9TF6PWz0xqsvcQonZxh%3D44M7hMpf7qy_sZz9_R3dc7N5L5yA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="044419.html">
   <LINK REL="Next"  HREF="044421.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] The future of Mono's profiler API</H1>
    <B>Alex Rønne Petersen</B> 
    <A HREF="mailto:mono-devel-list%40lists.dot.net?Subject=Re%3A%20%5BMono-dev%5D%20The%20future%20of%20Mono%27s%20profiler%20API&In-Reply-To=%3CCAH9TF6PWz0xqsvcQonZxh%3D44M7hMpf7qy_sZz9_R3dc7N5L5yA%40mail.gmail.com%3E"
       TITLE="[Mono-dev] The future of Mono's profiler API">alex at alexrp.com
       </A><BR>
    <I>Tue Jun 20 16:44:43 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="044419.html">[Mono-dev] The future of Mono's profiler API
</A></li>
        <LI>Next message (by thread): <A HREF="044421.html">[Mono-dev] The future of Mono's profiler API
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#44420">[ date ]</a>
              <a href="thread.html#44420">[ thread ]</a>
              <a href="subject.html#44420">[ subject ]</a>
              <a href="author.html#44420">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>(Re-sending since my last email didn't go to the list for some reason.)

Hey Greg,

One possibility is that we could use a new entry point name for the
new version of the profiler API. That way, if we detect that a
profiler module has the old entry point name, we could print an error
and refuse to load it, rather than relying on the dynamic linker to
throw errors when mono_profiler_install_* functions are invoked by the
profiler modules, Does this sound reasonable?

Regarding dynamic enter/leave hooking, I agree that it would be a
super cool feature to have. Unfortunately, it would require a
significant amount of work on the JIT side as re-JITing code is a hard
problem to solve reliably on most architectures. There are other
reasons I could see re-JITing being a useful feature to have (e.g.
incremental optimization based on profiling), but I can't really say
definitively whether we'll ever do it.

Regards,
Alex

On Tue, Jun 20, 2017 at 11:04 AM, Greg Young &lt;<A HREF="http://lists.dot.net/mailman/listinfo/mono-devel-list">gregoryyoung1 at gmail.com</A>&gt; wrote:
&gt;<i> So the possible issue with option #2 that I see is in distribution for
</I>&gt;<i> 3rd party profilers like privateeye. I don't see this as a huge issue
</I>&gt;<i> but it might be useful to at least be able to load the old API still
</I>&gt;<i> (not work) so the old version of the profiler could realize it is on a
</I>&gt;<i> newer version and exit (or the runtime could recognize this and give a
</I>&gt;<i> reasonable error message.
</I>&gt;<i>
</I>&gt;<i> Also a wonderful feature would be the ability to dynamically hook
</I>&gt;<i>
</I>&gt;<i> mono_profiler_install_enter_leave (pe_method_enter, pe_method_leave);
</I>&gt;<i>
</I>&gt;<i> As it is quite expensive. I imagine though this would be non-trivial.
</I>&gt;<i>
</I>&gt;<i> Greg
</I>&gt;<i>
</I>&gt;<i> On Tue, Jun 20, 2017 at 9:50 AM, Alex Rønne Petersen &lt;<A HREF="http://lists.dot.net/mailman/listinfo/mono-devel-list">alex at alexrp.com</A>&gt; wrote:
</I>&gt;&gt;<i> Hello everyone,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As part of our ongoing effort to make Mono's log profiler useful for
</I>&gt;&gt;<i> more scenarios, I'm planning to make it possible to interact with the
</I>&gt;&gt;<i> profiler at runtime - you can enable, disable, and tweak specific
</I>&gt;&gt;<i> profiler features in certain sections of your application, so you get
</I>&gt;&gt;<i> exactly the data that you're interested in. In order to do this, the
</I>&gt;&gt;<i> log profiler needs to be able to change its event flags and installed
</I>&gt;&gt;<i> callbacks dynamically at runtime.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # The Problem
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is currently impossible for any profiler to reliably change its
</I>&gt;&gt;<i> setup at runtime because Mono's profiler API (metadata/profiler.h)
</I>&gt;&gt;<i> only allows modifying the most recently installed profiler. Mono
</I>&gt;&gt;<i> supports having multiple profilers active at the same time, and we do
</I>&gt;&gt;<i> in fact use this feature in the Xamarin platform products. There's no
</I>&gt;&gt;<i> way around it: We need to rethink the profiler API. All functions must
</I>&gt;&gt;<i> take an explicit MonoProfiler* parameter.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This isn't the only problem with the current API.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Another issue is that multiple callbacks are installed through the
</I>&gt;&gt;<i> same function. For example, mono_profiler_install_exception installs
</I>&gt;&gt;<i> callbacks for thrown exceptions, exceptional method exits, and
</I>&gt;&gt;<i> exception clauses. When I had to add an extra parameter to the
</I>&gt;&gt;<i> exception clause callback recently, I introduced
</I>&gt;&gt;<i> mono_profiler_install_exception_clause for version 2 of that callback.
</I>&gt;&gt;<i> This means that new code will pass NULL to the third parameter of
</I>&gt;&gt;<i> mono_profiler_install_exception from now on. This just adds confusion.
</I>&gt;&gt;<i> It would be much clearer if the old function had been called
</I>&gt;&gt;<i> mono_profiler_install_exception_clause and I'd just been able to
</I>&gt;&gt;<i> introduce a mono_profiler_install_exception_v2 function. New users of
</I>&gt;&gt;<i> the API will likely wonder why mono_profiler_install_exception_clause
</I>&gt;&gt;<i> isn't part of mono_profiler_install_exception since the API has a
</I>&gt;&gt;<i> precedent of bundling related callbacks into the same installation
</I>&gt;&gt;<i> function.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There are also multiple callbacks in the API that aren't guarded by
</I>&gt;&gt;<i> event flags. For example, the code buffer callbacks should logically
</I>&gt;&gt;<i> be guarded by MONO_PROFILE_JIT_COMPILATION, but that's a change we
</I>&gt;&gt;<i> can't make now as it would be breaking. Another curiosity is that the
</I>&gt;&gt;<i> GC handle callbacks are guarded by MONO_PROFILE_GC_ROOTS even though
</I>&gt;&gt;<i> it's entirely likely that someone would be interested in GC handles
</I>&gt;&gt;<i> but not GC roots (see: Alan McGovern's GC handle profiler). It's also
</I>&gt;&gt;<i> odd that the exceptional method exit callback is guarded by
</I>&gt;&gt;<i> MONO_PROFILE_EXCEPTIONS when in fact most uses of this callback have
</I>&gt;&gt;<i> little to do with profiling exceptions and everything to do with
</I>&gt;&gt;<i> keeping track of method entries/exits as with the normal method
</I>&gt;&gt;<i> enter/exit callbacks (which are guarded by MONO_PROFILE_ENTER_LEAVE).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We also have callbacks that serve no actual purpose, and never will.
</I>&gt;&gt;<i> For example, the notion of a 'class unload' does not exist in the Mono
</I>&gt;&gt;<i> runtime. Never has, probably never will. Entire images are unloaded at
</I>&gt;&gt;<i> once, so this callback is literally never invoked. I'd actually say
</I>&gt;&gt;<i> having that callback there adds negative value to the API. The
</I>&gt;&gt;<i> managed/native transition callback was never implemented, either.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Finally, some features in the API have not been maintained or tested
</I>&gt;&gt;<i> for years. The call chain sampling API is a great example of this.
</I>&gt;&gt;<i> Another example: Did you know that the profiler API supports two
</I>&gt;&gt;<i> coverage modes which are mutually exclusive? You might think that
</I>&gt;&gt;<i> MONO_PROFILE_COVERAGE is the flag that you're supposed to be using.
</I>&gt;&gt;<i> Nope; it's MONO_PROFILE_INS_COVERAGE. The former is implemented in a
</I>&gt;&gt;<i> very platform-specific manner that has resulted in it not being
</I>&gt;&gt;<i> maintained, tested, or ported fully to new platforms.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In short, the current profiler API is pretty bad. We need a new API.
</I>&gt;&gt;<i> Of course, the elephant in the room is backwards compatibility. The
</I>&gt;&gt;<i> question is: Do we introduce a new profiler API and make the old one
</I>&gt;&gt;<i> 'simply' call the new one? Or do we just replace the old API entirely,
</I>&gt;&gt;<i> backwards compatibility be damned?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # The New Profiler API
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The new API would not be all that different from the old one. The main
</I>&gt;&gt;<i> changes would be:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. All functions in the API take an explicit MonoProfiler* parameter.
</I>&gt;&gt;<i> 2. Callbacks can be changed safely at runtime.
</I>&gt;&gt;<i> 3. One installation function installs exactly one callback.
</I>&gt;&gt;<i> 4. You will no longer need to specify event flags.
</I>&gt;&gt;<i> 5. Unmaintained and unfinished features (see above) will be removed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As an example, old code might look like this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> void
</I>&gt;&gt;<i> mono_profiler_startup (const char *args)
</I>&gt;&gt;<i> {
</I>&gt;&gt;<i>     MonoProfiler *prof = malloc (...);
</I>&gt;&gt;<i>     profiler_specific_setup (prof);
</I>&gt;&gt;<i>     mono_profiler_install (prof, my_shutdown_callback);
</I>&gt;&gt;<i>     mono_profiler_install_enter_leave (my_enter_callback, my_leave_callback);
</I>&gt;&gt;<i>     mono_profiler_set_events (MONO_PROFILE_ENTER_LEAVE);
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> New code would look like this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> void
</I>&gt;&gt;<i> mono_profiler_startup (const char *args)
</I>&gt;&gt;<i> {
</I>&gt;&gt;<i>     MonoProfiler *prof = malloc (...);
</I>&gt;&gt;<i>     profiler_specific_setup (prof);
</I>&gt;&gt;<i>     mono_profiler_install (prof);
</I>&gt;&gt;<i>     mono_profiler_set_shutdown_callback (prof, my_shutdown_callback);
</I>&gt;&gt;<i>     mono_profiler_set_enter_callback (prof, my_enter_callback);
</I>&gt;&gt;<i>     mono_profiler_set_leave_callback (prof, my_leave_callback);
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We would still use flags internally so we don't slow the runtime down
</I>&gt;&gt;<i> with unnecessary profiler API calls, but that will be completely
</I>&gt;&gt;<i> hidden from users. All a user would have to worry about is (un)setting
</I>&gt;&gt;<i> callbacks, which can be done at any point during an app's lifetime.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Transitioning to the new API should be fairly painless. I'd estimate
</I>&gt;&gt;<i> it to take an hour or two at worst for e.g. the log profiler.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # Approach One: Backwards Compatibility
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In this approach, we would introduce a new metadata/profiler-v2.h
</I>&gt;&gt;<i> header. This header would provide the new API and have no dependencies
</I>&gt;&gt;<i> on the old one. The old API would remain in metadata/profiler.h and
</I>&gt;&gt;<i> people's code would continue to compile and work. We would need to
</I>&gt;&gt;<i> bridge the old API to the new one and make sure that it's done in a
</I>&gt;&gt;<i> backwards-compatible way.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The advantage here is fairly obvious: Nobody likes having to rewrite
</I>&gt;&gt;<i> their code because the authors of a library decided to change the API,
</I>&gt;&gt;<i> especially if that change doesn't carry an obvious benefit to users,
</I>&gt;&gt;<i> which it could be argued this change wouldn't for most (all?) current
</I>&gt;&gt;<i> users of Mono's profiler API.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On the other hand, this is a significant maintenance burden, both in
</I>&gt;&gt;<i> the short and long term. Writing the code to bridge the nonsensical
</I>&gt;&gt;<i> aspects of the old API with the new one would be tricky to say the
</I>&gt;&gt;<i> least. In addition, there's the risk that any change to the new API in
</I>&gt;&gt;<i> the future could break the old API.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # Approach Two: Replacing the API
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In this approach, we replace the old API in metadata/profiler.h with
</I>&gt;&gt;<i> the new one, with zero regard for backwards compatibility. People's
</I>&gt;&gt;<i> code would fail to compile, and old compiled profiler modules would
</I>&gt;&gt;<i> fail to run. In both cases, the failures should be fairly loud - a
</I>&gt;&gt;<i> compiler error, or a dynamic linker error.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The advantage of this approach is that it's significantly less effort
</I>&gt;&gt;<i> to implement and maintain. It also avoids any potential confusion for
</I>&gt;&gt;<i> new users of the API, in that there's only one set of functions to
</I>&gt;&gt;<i> use.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If we go down this route, all projects that use Mono's profiler API
</I>&gt;&gt;<i> would need to change their code slightly, and people would need to
</I>&gt;&gt;<i> compile separate versions of their profiler modules if they want to
</I>&gt;&gt;<i> support older Mono versions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # My Opinion
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm strongly in favor of the second approach. Frankly, as the person
</I>&gt;&gt;<i> who'll be implementing and maintaining the new API, I don't
</I>&gt;&gt;<i> particularly enjoy the idea of having to also maintain the old one in
</I>&gt;&gt;<i> a backwards compatible fashion. I think there are much better things I
</I>&gt;&gt;<i> could be working on in Mono's profiling infrastructure.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I also firmly believe that this is the only time we'll have to do such
</I>&gt;&gt;<i> a drastic breaking change to the profiler API. This isn't a proposal
</I>&gt;&gt;<i> to jump on some fancy new API design fad. Using a mutable global
</I>&gt;&gt;<i> variable as an implicit parameter to an entire API was pretty bad
</I>&gt;&gt;<i> design, even by 2002 standards. Just by passing an explicit
</I>&gt;&gt;<i> MonoProfiler* argument to all API functions, we open ourselves up to
</I>&gt;&gt;<i> much easier, backwards-compatible expansion of the API in the future.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Finally, as I mentioned earlier, transitioning to the new API would be
</I>&gt;&gt;<i> very easy, and users would have to do it sooner or later anyway, as we
</I>&gt;&gt;<i> wouldn't want to keep the old API around forever, even in the first
</I>&gt;&gt;<i> approach. Also, in the grand scheme of things, this probably won't
</I>&gt;&gt;<i> affect that many people, unlike breaking changes to the core embedding
</I>&gt;&gt;<i> API.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What's everyone's thoughts on this?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Regards,
</I>&gt;&gt;<i> Alex
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.dot.net/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.dot.net</A>
</I>&gt;&gt;<i> <A HREF="http://lists.dot.net/mailman/listinfo/mono-devel-list">http://lists.dot.net/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> Studying for the Turing test
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="044419.html">[Mono-dev] The future of Mono's profiler API
</A></li>
	<LI>Next message (by thread): <A HREF="044421.html">[Mono-dev] The future of Mono's profiler API
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#44420">[ date ]</a>
              <a href="thread.html#44420">[ thread ]</a>
              <a href="subject.html#44420">[ subject ]</a>
              <a href="author.html#44420">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.dot.net/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
