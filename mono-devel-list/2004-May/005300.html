<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [IDEA] Caching String Hashcodes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BIDEA%5D%20Caching%20String%20Hashcodes&In-Reply-To=1083510054.3386.20.camel%40Ben">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005269.html">
   <LINK REL="Next"  HREF="005327.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [IDEA] Caching String Hashcodes</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BIDEA%5D%20Caching%20String%20Hashcodes&In-Reply-To=1083510054.3386.20.camel%40Ben"
       TITLE="[Mono-devel-list] [IDEA] Caching String Hashcodes">lupus at ximian.com
       </A><BR>
    <I>Mon May  3 07:58:24 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="005269.html">[Mono-devel-list] [IDEA] Caching String Hashcodes
</A></li>
        <LI>Next message: <A HREF="005327.html">[Mono-devel-list] [IDEA] Caching String Hashcodes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5300">[ date ]</a>
              <a href="thread.html#5300">[ thread ]</a>
              <a href="subject.html#5300">[ subject ]</a>
              <a href="author.html#5300">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 05/02/04 Ben Maurer wrote:
&gt;<i> &gt; I thought about a pretty simple thing. As strings are immutable we are
</I>&gt;<i> &gt; able to cache their hashcodes. For (long) strings that make several
</I>&gt;<i> &gt; calls to GetHashCode this would give us an incredible perf boost.
</I>&gt;<i> &gt; However it will cost us 4 bytes of additional data per string even if
</I>&gt;<i> &gt; the hashcode isn't used at all.
</I>
Eventually we'll probably put the hashcode in the synchronization
area, but that requires quite a bit more changes in the Monitor
implementation.
Adding 4 bytes to all the strings means a 10-20% space increase for the
most commons strings: the total overhead of this is hard to measure, but
we should try to avoid it.
One idea is to allocate extra room for the hash code only for large
strings (at the end of the string data), say, for 50+ char strings
the overhead is capped at 4 % and is usually much less. This would be
easy to implement: we already need to allocate one more char than
required anyway. And for short strings it should not be a big issue to
always calculate the hash code.
We could also try with just a ushort for the hash, just don't quote me
in the future as the one who said: who needs hashtables with many
more string entries than 64K:-)
Anyway: we need people to try out these ideas and experiment and post
numbers that we can look at.

&gt;<i> You might see a huge boost for a large string, but i would only be
</I>&gt;<i> impressed if you were able to show a metric such as MCS bootstrap time
</I>&gt;<i> reduced by 3%.
</I>
Considering that a profile run puts the cost of String.GetHashCode()
below 1 % with mcs compiling itself, this looks like an extremely silly
expectation.

&gt;<i> memory for everyone. However, this might prevent us from doing it in
</I>&gt;<i> managed, which would be a very bad thing.
</I>
This is completely untrue, it's just that you don't know how things work.

&gt;<i> Also, It would still take some
</I>&gt;<i> sort of benchmark to convince me this is worthwhile.
</I>
Ben, he doesn't need to convince _you_: you're free to voice your
opinion, but that doesn't mean it has any value wrt a change to
how the runtime works.

&gt;<i> I gave you a list before of optimizations that would be truly helpful.
</I>
Ben: it's none of your business to tell people what to do and whine on
the list if they don't do it. The mono contributors may do whatever
pleases them the most: deal with it.

&gt;<i> Also, last night I checked in some benchmarks that the JIT could do
</I>&gt;<i> better on. They are things that show up in real code. You might want to
</I>&gt;<i> try them.
</I>
I only checked readonly-vt.cs and, frankly, the only interesting thing
about that test is that the comment shows you don't understand the
difference between readonly and immutable.

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005269.html">[Mono-devel-list] [IDEA] Caching String Hashcodes
</A></li>
	<LI>Next message: <A HREF="005327.html">[Mono-devel-list] [IDEA] Caching String Hashcodes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5300">[ date ]</a>
              <a href="thread.html#5300">[ thread ]</a>
              <a href="subject.html#5300">[ subject ]</a>
              <a href="author.html#5300">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
