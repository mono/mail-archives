<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] GAC (design) issues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20GAC%20%28design%29%20issues&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005254.html">
   <LINK REL="Next"  HREF="005259.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] GAC (design) issues</H1>
    <B>Jaroslaw Kowalski</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20GAC%20%28design%29%20issues&In-Reply-To="
       TITLE="[Mono-devel-list] GAC (design) issues">jaak at zd.com.pl
       </A><BR>
    <I>Sat May  1 05:22:12 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="005254.html">[Mono-devel-list] GAC (design) issues
</A></li>
        <LI>Next message: <A HREF="005259.html">[Mono-devel-list] GAC (design) issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5255">[ date ]</a>
              <a href="thread.html#5255">[ thread ]</a>
              <a href="subject.html#5255">[ subject ]</a>
              <a href="author.html#5255">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> &gt; +1 to Ian and Gert. We all suffer from NAnt not working on Linux. Fixing
</I>&gt;<i> &gt; nant to deal with the current mono behaviour would be a major hack,
</I>because
&gt;<i> &gt; you can no longer specify system assemblies references in a portable
</I>manner.
&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> How exactly do you do this on ms.net? by setting up your path properly?
</I>&gt;<i> that sounds like the original hack.
</I>
No. NAnt eploys the concept of &quot;frameworks&quot;. At startup it detects the
available CLI runtimes found on the system (net-1.0, net-1.1, net-2.0,
mono-1.0, sscli, netcf-1.0) and determines (among other things) the path
where all system libraries are located. Now you can have a single build
script and re-target the compilation for a specific platform. Note that you
can compile for some other platform than the one nant is running on. For
example you can run on .NET 1.0 and compile for .NET 1.1 or mono-1.0. NAnt
always feeds the compiler with a list of fully qualified source and
reference names, so that you can have 100% repeatable builds independently
of the PATH settings.

csc.exe doesn't have to be added to the PATH. NAnt is detects it and always
invokes it with a fully qualified path name.

&gt;<i> &gt; Some more issues to consider before shipping v1:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1. AssemblyFolders
</I>&gt;<i> &gt;
</I>&gt;<i> Well, it seems like if a dll is public it should be in the gac.
</I>&gt;<i> and if mcs can resolve libraries out of the gac, then there really isnt a
</I>need
&gt;<i> for this registry + filepath hack.
</I>
Yes, it works. If you really want to type:

mcs -r &quot;System.Data, Version=1.0.3300.0, Culture=neutral,
PublicKeyToken=b77a5c561934e089&quot;

each time you compile. OK. I know that mcs can be taught to know to use
&quot;System.Data&quot; with the appropriate version (it's kind-of &quot;core&quot;) but it's a
hack.

But what about non-system assemblies like nunit.framework.dll,
NDoc.Core.dll, ICSharpCode.SharpCvsLib.dll, ICSharpCode.SharpZipLib.dll
which come strong-named and in different versions? Are you prepared to type
(actually copy/paste, because you have no chance to remember it) the full
name including the public key token and exact version number?

&gt;<i> So you would prefer we change the default (seemingly sensical) behaviour
</I>&gt;<i> and then add this hack to fix an issue fixed by the current solution?
</I>&gt;<i>
</I>
OK. MS.NET developers do it the other way and it does work. IMHO the current
Mono GAC structure will cause more trouble than good.

&gt;<i> &gt; This setup is currently used for Visual Studio to populate &quot;Add
</I>&gt;<i> &gt; Reference...&quot; dialog box. VS.NET stores file references in a portable
</I>manner
&gt;<i> &gt; by storing the name of the assemblyfolder used to find the reference in
</I>&gt;<i> &gt; addition to storing the actual path name. Same thing could be done in
</I>&gt;<i> &gt; MonoDevelop to achieve compatibility.
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> the name of the assemblyfolder? you mean the registry key it found it in
</I>&gt;<i> i assume.
</I>
Yes.

&gt;<i> I dont see how MonoDevelop would maintain that kind of
</I>&gt;<i> portability.
</I>
Simple. Same as VS.NET. Assuming the package names will match AssemblyFolder
names there shouldn't be any problem.

&gt;<i> The current thinking for MonoDevelop is pretty simple:
</I>&gt;<i>
</I>&gt;<i> Add a GAC based reference, compile using mcs and it finds it because its
</I>&gt;<i> in the gac. When you go to deploy the package, the configure script
</I>&gt;<i> probes the gac and complains if it cant find the library.
</I>&gt;<i>
</I>&gt;<i> Seems to be pretty easy.
</I>
So you're hereby eliminating the possibility of running on MS.NET and using
csc.exe to compile, right? I think that in the future versions of .NET, GAC
might not even be a filesystem-backed store.

&gt;<i> &gt; This way a small &quot;starter&quot; application could be created (simiar to what
</I>&gt;<i> &gt; mscoree.dll does) that would just read the expected mscorlib.dll version
</I>and
&gt;<i> &gt; route to the appropriate mono runtime.
</I>
&gt;<i> There is only one runtime as far as I can tell. And the version of the
</I>&gt;<i> libraries that mono attempts to use should be based off the corlib
</I>&gt;<i> version included in your executable, not a config mapping.
</I>
I'm not sure if this means &quot;perfect backward compatibility&quot;, but I may be
wrong. If I'm right though, it means the dependency hell is likely to arise.
Remember that the runtime itself can have issues which some applications
will rely upon which will ultimately break them when the runtime is &quot;fixed&quot;.

&gt;<i> Again, I dont understand why Gert needs to reference these assemblies
</I>&gt;<i> explicitly, and if he does, why $PREFIX/mono/$VERSION/$ASSEMBLYNAME is
</I>&gt;<i> any easier than
</I>&gt;<i> $PREFIX/lib/mono/gac/$ASSEMBLYNAME/$VERSION__$PUBTOKEN/$ASSEMBLYNAME .
</I>&gt;<i> (Other than it obviously being easier to type).
</I>
GAC is not a filesystem and shouldn't be treaded as such. Ideally the MS
should have encrypted the contents of &quot;\Windows\assembly\GAC&quot; folder or put
it into a ZIP file in the past.

BTW. Under .NET GAC has a special semantics: assemblies from the GAC are
&quot;shared&quot; among appdomains in a single process. It introduces a performance
hit when accessing static data but helps in preserving memory since only one
copy of each routine is JITted. Is mono going to implement this feature? Do
you think the GAC as it's implemented will fit this idea?

Jarek


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005254.html">[Mono-devel-list] GAC (design) issues
</A></li>
	<LI>Next message: <A HREF="005259.html">[Mono-devel-list] GAC (design) issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5255">[ date ]</a>
              <a href="thread.html#5255">[ thread ]</a>
              <a href="subject.html#5255">[ subject ]</a>
              <a href="author.html#5255">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
