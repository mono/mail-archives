<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [PATCH] Faster String.Equals
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20Faster%20String.Equals&In-Reply-To=005901c43fe9%2401d40ae0%246464a8c0%40ansuria">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005916.html">
   <LINK REL="Next"  HREF="005946.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [PATCH] Faster String.Equals</H1>
    <B>Ben Maurer</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20Faster%20String.Equals&In-Reply-To=005901c43fe9%2401d40ae0%246464a8c0%40ansuria"
       TITLE="[Mono-devel-list] [PATCH] Faster String.Equals">bmaurer at users.sourceforge.net
       </A><BR>
    <I>Sat May 22 11:49:51 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="005916.html">[Mono-devel-list] [PATCH] Faster String.Equals
</A></li>
        <LI>Next message: <A HREF="005946.html">[Mono-devel-list] [PATCH] Faster String.Equals
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5920">[ date ]</a>
              <a href="thread.html#5920">[ thread ]</a>
              <a href="subject.html#5920">[ subject ]</a>
              <a href="author.html#5920">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sat, 2004-05-22 at 06:38, Andreas Nahr wrote:
&gt;<i> However I see some problems with that approach:
</I>&gt;<i> 1. Substantial code multiplication. We need Supported_Architectures + 1 code
</I>&gt;<i> implementations for every method instread of just 1. This will be horrible
</I>&gt;<i> to maintain and a lot of additional work.
</I>Agreed.

However, you miss one important point. We are only going to do this for
*VERY* common methods. If you take a step back, there are really three
approaches we can take to optimizing low level methods like this:
     1. Handwritten assembly
     2. Messy c# optimizations like unrolling loops
     3. Writing &quot;standard&quot; code.

For the most frequent methods, we would do 1. For methods that are
frequent but not critical, 2. Others, 3. So, we only have code
multiplication.

And remember, this is opt-in. You dont have to provide an impl if you
dont want to.

&gt;<i> 2. Too platform specific optimizations. Look at your String.Equals that is
</I>&gt;<i> only implemented for x86. If somebody uses a lot of String.Equals in his own
</I>&gt;<i> classes then his implementation will perform seriously slower/ different on
</I>&gt;<i> other platforms. This may lead to problematic optimizations for classes
</I>&gt;<i> which internally use these methods.
</I>In no case does this code result in string.equals being slower than it
is today -- on any platform. So, this is really a moot point

&gt;<i> 3. Defeats the purpose of having a platform - neutralizing platform.
</I>Take a look at glibc.

&gt;<i> 4. Although it does not have the overhead of an icall AFAIU it still poses a
</I>&gt;<i> problem for optimizations. A compiler (like ngen) may be able to completely
</I>&gt;<i> eliminate a case like:
</I>&gt;<i> &quot;Test&quot; != &quot;Test&quot;
</I>&gt;<i> to a false constant (very simple example). Is that still possible with your
</I>&gt;<i> implementation?
</I>&gt;<i> 
</I>&gt;<i> Or
</I>&gt;<i> String a = &quot;dh&quot;
</I>&gt;<i> String b = &quot;dfh&quot;
</I>&gt;<i> a.Equals (b)
</I>&gt;<i> might get inlined and *optimized* by the compiler or JIT or especially AOT
</I>&gt;<i> because it can guarantee that a and b can never be null (which is checked in
</I>&gt;<i> Equals).
</I>
Absolutely we can still do this. Actually, there is a much more
important optimization. We can inline something like:

if (a == &quot;abcdef&quot;) into code with no calls.

&gt;<i> 
</I>&gt;<i> 5. A compiler tries (should try) to optimize to the maximum global speed,
</I>&gt;<i> you optimize for a maximum local speed which MIGHT lead to slower overall
</I>&gt;<i> performance (surely not nowadays because our compilers are not anywhere near
</I>&gt;<i> that level of optimization)
</I>How exactly would this lead to a slowdown?

&gt;<i> 6. We still need a fast managed implementation for cases when a ASM -
</I>&gt;<i> version is not available
</I>Yes, but it is not as critical.

&gt;<i> 7. Finding bugs will be much harder if we have architecture specific
</I>&gt;<i> implementations for specific methods.
</I>We should run tests with and without the optimization enabled.

&gt;<i> Therefore IMHO we should:
</I>&gt;<i> 1. Add that ASM - injection architecture, but not enable it by default. We
</I>&gt;<i> could have a --AsmInject switch which enables it.
</I>
IMHO it should be enabled. It comes at practically 0 cost, and gives
alot of gain.
&gt;<i> 2. I would love to see a asm - coded version of string CreateString (int
</I>&gt;<i> length)  :-)
</I>Probably not possible with the current gc.
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I've attached my version of String.Equals which is also a lot faster than
</I>&gt;<i> the current version (especially for larger compares)
</I>&gt;<i> Microbench:
</I>&gt;<i> chars 7: 4196 -&gt; 3054
</I>&gt;<i> chars 88: 2743 -&gt; 1772
</I>&gt;<i> chars a lot: 1011 -&gt; 591
</I>
This is nice. However, note that I did not have to resort to unrolling
to get this result. If I hand code unrolling, it may be even faster.

-- Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005916.html">[Mono-devel-list] [PATCH] Faster String.Equals
</A></li>
	<LI>Next message: <A HREF="005946.html">[Mono-devel-list] [PATCH] Faster String.Equals
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5920">[ date ]</a>
              <a href="thread.html#5920">[ thread ]</a>
              <a href="subject.html#5920">[ subject ]</a>
              <a href="author.html#5920">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
