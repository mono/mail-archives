<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Mono .net 2.0 preview and generics
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Mono%20.net%202.0%20preview%20and%20generics&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005691.html">
   <LINK REL="Next"  HREF="005694.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Mono .net 2.0 preview and generics</H1>
    <B>prw at ceiriog1.demon.co.uk</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Mono%20.net%202.0%20preview%20and%20generics&In-Reply-To="
       TITLE="[Mono-devel-list] Mono .net 2.0 preview and generics">prw at ceiriog1.demon.co.uk
       </A><BR>
    <I>Thu May 13 11:12:45 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="005691.html">[Mono-devel-list] System.Runtime.Remoting doesn't compile
</A></li>
        <LI>Next message: <A HREF="005694.html">[Mono-devel-list] Mono .net 2.0 preview and generics
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5692">[ date ]</a>
              <a href="thread.html#5692">[ thread ]</a>
              <a href="subject.html#5692">[ subject ]</a>
              <a href="author.html#5692">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

I've just got started with Mono and .NET. I need to know whether it is a
viable platform for a project for which I have previously used C++ with
its templates, so I'm testing on some substantial examples found on
the WWW.

On the example attached, I get the following errors from gmcs (The 0.91
RPM for mono-preview).

[<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">prw at desdemona</A> generics]$ gmcs Gsort.cs
Mono C# Compiler 0.91.0.0 for Generics
Gsort.cs(70) error CS1502: The best overloaded match for method 'void Polysort.swap (T, T)' has some invalid arguments
Gsort.cs(70) error CS1503: Argument 0: Cannot convert from 'ref T' to 'T'
Gsort.cs(103) error CS1502: The best overloaded match for method 'void Polysort.swap (T, T)' has some invalid arguments
Gsort.cs(103) error CS1503: Argument 0: Cannot convert from 'ref T' to 'T'
Compilation failed: 4 error(s), 0 warnings

Should not the template (sorry, generic) Polysort.swap&lt;U&gt; be instantiated
automatically to resolve the calls on line 70 and 103? Is this yet
to be fixed in gmcs, or am I doing something wrong (quite possible
as I am such a noobie here :)


Peter Wainwright

********
// Sorting with Generic C#, and comparisons with dynamically typed sorting
// Revised to use three-way comparisons (IComparable and IGComparable)
// Sorting integers or strings
// This program requires .NET version 2.0.
// Peter Sestoft (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sestoft at dina.kvl.dk</A>) * 2001-11-01, 2001-11-22, 2003-08-11

using System;

// Generic sorting routines

public class Polysort {
  // Cannot use this in 
  //   void qsort&lt;T&gt;(IGComparable&lt;T&gt;[] arr, int a, int b)
  // because ref arguments that are array elements of reference
  // type must have the exact element type of the formal parameter

  private static void swap&lt;U&gt;(ref U s, ref U t) {
    U tmp = s;  s = t;  t = tmp;    
  }

  private static void swap&lt;U&gt;(U[] arr, int s, int t) {
    U tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  private static void swap(object[] arr, int s, int t) {
    object tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Polymorphic OO-style quicksort: general, not typesafe
  
  private static void qsort&lt;T&gt;(IGComparable&lt;T&gt;[] arr, int a, int b) {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      IGComparable&lt;T&gt; x = arr[(i+j) / 2];             
      do {                              
        while (arr[i].CompareTo(x) &lt; 0) i++;     
        while (x.CompareTo(arr[j]) &lt; 0) j--;     
        if (i &lt;= j) {                           
	  swap&lt; IGComparable&lt;T&gt; &gt;(arr, i, j);
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort&lt;T&gt;(arr, a, j);                 
      qsort&lt;T&gt;(arr, i, b);                 
    }                                   
  }
  
  public static void Quicksort&lt;T&gt;(IGComparable&lt;T&gt;[] arr) {
    qsort&lt;T&gt;(arr, 0, arr.Length-1);
  }

  public static void CheckSorted&lt;T&gt;(IGComparable&lt;T&gt;[] arr) {
    for (int i=1; i&lt;arr.Length; i++)
      if (arr[i].CompareTo(arr[i-1]) &lt; 0)
        throw new Exception(&quot;Polysort.CheckSorted&quot;);
  }
  
  // Polymorphic functional-style quicksort: general, typesafe
  
  private static void qsort&lt;T&gt;(T[] arr, IGComparer&lt;T&gt; cmp, int a, int b) {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      T x = arr[(i+j) / 2];             
      do {                              
        while (cmp.Compare(arr[i], x) &lt; 0) i++;     
        while (cmp.Compare(x, arr[j]) &lt; 0) j--;     
        if (i &lt;= j) {                           
          swap&lt;T&gt;(ref arr[i], ref arr[j]);        // ***** LINE 70 *****
          // swap&lt;T&gt;(arr, i, j);           
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort&lt;T&gt;(arr, cmp, a, j);                 
      qsort&lt;T&gt;(arr, cmp, i, b);                 
    }                                   
  }

  public static void Quicksort&lt;T&gt;(T[] arr, IGComparer&lt;T&gt; cmp) {
    qsort&lt;T&gt;(arr, cmp, 0, arr.Length-1);
  }

  public static void CheckSorted&lt;T&gt;(T[] arr, IGComparer&lt;T&gt; cmp) {
    for (int i=1; i&lt;arr.Length; i++)
      if (cmp.Compare(arr[i], arr[i-1]) &lt; 0)
        throw new Exception(&quot;Polysort.CheckSorted&quot;);
  }

  // Polymorphic functional-style quicksort using delegates: general, typesafe
  
  public delegate int DGComparer&lt;T&gt;(T v1, T v2);

  private static void qsort&lt;T&gt;(T[] arr, DGComparer&lt;T&gt; cmp, int a, int b) {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      T x = arr[(i+j) / 2];             
      do {                              
        while (cmp(arr[i], x) &lt; 0) i++;     
        while (cmp(x, arr[j]) &lt; 0) j--;     
        if (i &lt;= j) {                           
          swap&lt;T&gt;(ref arr[i], ref arr[j]);        // ***** LINE 103 *****
          // swap&lt;T&gt;(arr, i, j);           
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort&lt;T&gt;(arr, cmp, a, j);                 
      qsort&lt;T&gt;(arr, cmp, i, b);                 
    }                                   
  }

  public static void Quicksort&lt;T&gt;(T[] arr, DGComparer&lt;T&gt; cmp) {
    qsort&lt;T&gt;(arr, cmp, 0, arr.Length-1);
  }
}

public class Polyselfsort {
  private static void swap&lt;T&gt;(T[] arr, int s, int t) {
    T tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }
  
  // Polymorphic OO-style quicksort: general, typesafe
  // Note the type parameter bound in the generic method
  
  public static void qsort&lt;T&gt;(T[] arr, int a, int b) 
    where T : IGSelfComparable&lt;T&gt; {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      T x = arr[(i+j) / 2];             
      do {                              
        while (arr[i].CompareTo(x) &lt; 0) i++;     
        while (x.CompareTo(arr[j]) &lt; 0) j--;     
        if (i &lt;= j) {                           
          swap&lt;T&gt;(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort&lt;T&gt;(arr, a, j);                 
      qsort&lt;T&gt;(arr, i, b);                 
    }                                   
   }
  
  public static void Quicksort&lt;T&gt;(T[] arr) where T : IGSelfComparable&lt;T&gt; {
    qsort&lt;T&gt;(arr, 0, arr.Length-1);
  }
}

public class Objsort {
  private static void swap(object[] arr, int s, int t) {
    object tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // OO-style IComparable quicksort: general, not typesafe

  private static void qsort(IComparable[] arr, int a, int b) {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      IComparable x = arr[(i+j) / 2];             
      do {                              
        while (arr[i].CompareTo(x) &lt; 0) i++;     
        while (x.CompareTo(arr[j]) &lt; 0) j--;     
        if (i &lt;= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort(arr, a, j);                 
      qsort(arr, i, b);                 
    }
  }

  public static void Quicksort(IComparable[] arr) {
    qsort(arr, 0, arr.Length-1);
  }

  public static void CheckSorted(IComparable[] arr) {
    for (int i=1; i&lt;arr.Length; i++)
      if (arr[i].CompareTo(arr[i-1]) &lt; 0)
        throw new Exception(&quot;Objsort.CheckSorted&quot;);
  }
}

public class Intsort {
  private static void swap(int[] arr, int s, int t) {
    int tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Plain monomorphic quicksort: not general, but typesafe

  private static void qsort(int[] arr, int a, int b) {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      int x = arr[(i+j) / 2];             
      do {                              
        while (arr[i] &lt; x) i++;     
        while (x &lt; arr[j]) j--;     
        if (i &lt;= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort(arr, a, j);                 
      qsort(arr, i, b);                 
    }
  }

  public static void Quicksort(int[] arr) {
    qsort(arr, 0, arr.Length-1);
  }

  public static void CheckSorted(int[] arr) {
    for (int i=1; i&lt;arr.Length; i++)
      if (arr[i] &lt; arr[i-1])
        throw new Exception(&quot;Intsort.CheckSorted&quot;);
  }
}

public class Stringsort {
  private static void swap(string[] arr, int s, int t) {
    string tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Plain monomorphic quicksort: not general, but typesafe

  private static void qsort(string[] arr, int a, int b) {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      string x = arr[(i+j) / 2];             
      do {                              
        while (string.Compare(arr[i],x) &lt; 0) i++;     
        while (string.Compare(x,arr[j]) &lt; 0) j--;     
        if (i &lt;= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort(arr, a, j);                 
      qsort(arr, i, b);                 
    }
  }

  public static void Quicksort(string[] arr) {
    qsort(arr, 0, arr.Length-1);
  }

  public static void CheckSorted(string[] arr) {
    for (int i=1; i&lt;arr.Length; i++)
      if (string.Compare(arr[i], arr[i-1]) &lt; 0)
        throw new Exception(&quot;Stringsort.CheckSorted&quot;);
  }
}

public class FunIntsort {
  private static void swap(int[] arr, int s, int t) {
    int tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Monomorphic quicksort with comparer: not general, but typesafe

  private static void qsort(int[] arr, IIntComparer cmp, int a, int b) {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      int x = arr[(i+j) / 2];             
      do {                              
        while (cmp.Compare(arr[i], x) &lt; 0) i++;     
        while (cmp.Compare(x, arr[j]) &lt; 0) j--;     
        if (i &lt;= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort(arr, cmp, a, j);                 
      qsort(arr, cmp, i, b);                 
    }
  }

  public static void Quicksort(int[] arr, IIntComparer cmp) {
    qsort(arr, cmp, 0, arr.Length-1);
  }
}

public class FunStringsort {
  private static void swap(string[] arr, int s, int t) {
    string tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Monomorphic quicksort with comparer: not general, but typesafe

  private static void qsort(string[] arr, IStringComparer cmp, int a, int b) {
    // sort arr[a..b]
    if (a &lt; b) { 
      int i = a, j = b;
      string x = arr[(i+j) / 2];             
      do {                              
        while (cmp.Compare(arr[i], x) &lt; 0) i++;     
        while (cmp.Compare(x, arr[j]) &lt; 0) j--;     
        if (i &lt;= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i &lt;= j);                 
      qsort(arr, cmp, a, j);                 
      qsort(arr, cmp, i, b);                 
    }
  }

  public static void Quicksort(string[] arr, IStringComparer cmp) {
    qsort(arr, cmp, 0, arr.Length-1);
  }
}

// Two generic versions of IComparable

public interface IGComparable&lt;T&gt; {
  int CompareTo(IGComparable&lt;T&gt; that);
}

public interface IGSelfComparable&lt;T&gt; {
  // Actually we could assert a bound on the parameter: 
  //   public interface IGSelfComparable&lt; T : IGSelfComparable&lt;T&gt; &gt;
  // but there seems to be no need for that.

  // Note that the argument type is T itself, not a superclass:
  int CompareTo(T that);
}

// An int wrapper that implements all Comparable interfaces

public class OrderedInt : IComparable,
                          IGComparable&lt;OrderedInt&gt;,
                          IGSelfComparable&lt;OrderedInt&gt; {
  int i;

  public OrderedInt(int i) {
    this.i = i;
  }

  public int Value { 
    get { return i; } 
  }

  // Implements IComparable.CompareTo(object)
  public int CompareTo(object that) {
    int thati = ((OrderedInt)that).i;
    return i &lt; thati ? -1 : i &gt; thati ? +1 : 0;
  }

  // Implements IGComparable&lt;OrderedInt&gt;.CompareTo(IGComparable&lt;OrderedInt&gt;)
  public int CompareTo(IGComparable&lt;OrderedInt&gt; that) {
    int thati = ((OrderedInt)that).i;
    return i &lt; thati ? -1 : i &gt; thati ? +1 : 0;
  }

  // Implements IGSelfComparable&lt;OrderedInt&gt;.CompareTo(T)
  // because with T = OrderedInt we have T : IGSelfComparable&lt;T&gt;
  public int CompareTo(OrderedInt that) {
    // Simple subtraction i-that.i won't do because of possible overflow.
    return i &lt; that.i ? -1 : i &gt; that.i ? +1 : 0;
    // This following is eight times slower, although the compiler 
    // and runtime knows that i and that.i are ints:
    // return i.CompareTo(that.i);
  }
}

// A string wrapper that implements all Comparable interfaces

public class OrderedString : IComparable,
                             IGComparable&lt;OrderedString&gt;,
                             IGSelfComparable&lt;OrderedString&gt; {
  string s;

  public OrderedString(string s) {
    this.s = s;
  }

  public string Value { 
    get { return s; } 
  }

  // Implements IComparable.CompareTo(object)
  public int CompareTo(object that) {
    return string.Compare(this.s, ((OrderedString)that).s);
  }

  // Implements IGComparable&lt;OrderedString&gt;.CompareTo(IGComparable&lt;OrderedString&gt;)
  public int CompareTo(IGComparable&lt;OrderedString&gt; that) {
    return string.Compare(this.s, ((OrderedString)that).s);
  }

  // Implements IGSelfComparable&lt;OrderedString&gt;.CompareTo(T)
  // because with T = OrderedString we have T : IGSelfComparable&lt;T&gt;
  public int CompareTo(OrderedString that) {
    return string.Compare(this.s, that.s);
  }
}

// A generic version of IComparer

public interface IGComparer&lt;T&gt; {
  int Compare(T v1, T v2);
}

public interface IIntComparer {
  int Compare(int v1, int v2);
}

public class IntComparer : IGComparer&lt;int&gt;, IIntComparer {
  public int Compare(int v1, int v2) {
    return v1 &lt; v2 ? -1 : v1 &gt; v2 ? +1 : 0;
  }
}

public interface IStringComparer {
  int Compare(string v1, string v2);
}

public class StringComparer : IGComparer&lt;string&gt;, IStringComparer {
  public int Compare(string v1, string v2) {
    return string.Compare(v1, v2);
  }
}

// Try it on integers

public class Gsort {
  static readonly Random rnd = new Random();

  static void Main(string[] args) {
    if (args.Length &lt; 1) 
      Console.Out.WriteLine(&quot;Usage: Gsort &lt;arraysize&gt; [string]\n&quot;);
    else {
      int N = int.Parse(args[0]);
      const string fmt = &quot;{0,9:0.00}&quot;;
      if (args.Length &lt; 2 || args[1] != &quot;string&quot;) {
	Console.Out.WriteLine(&quot; Sorting {0} ints&quot;, N);
	headers(fmt);
	for (int i=0; i&lt;20; i++) {
	  int[] arr = mkRandomInts(N);
          Console.Out.Write(fmt, ObjComparable(arr));
          Console.Out.Write(fmt, ObjOrderedInt(arr));
          Console.Out.Write(fmt, MonoIntPrimitive(arr));
          Console.Out.Write(fmt, MonoIntComparer(arr));
          Console.Out.Write(fmt, PolyIGComparable(arr));
          Console.Out.Write(fmt, PolyIGSelfComparable(arr));
          Console.Out.Write(fmt, PolyIGComparer(arr));
          Console.Out.Write(fmt, PolyDGComparer(arr));
	  Console.Out.WriteLine();
	} 
      } else {
	Console.Out.WriteLine(&quot; Sorting {0} strings&quot;, N);
	headers(fmt);
	for (int i=0; i&lt;20; i++) {
	  string[] arr = mkRandomStrings(N);
	  Console.Out.Write(fmt, ObjComparable(arr));
	  Console.Out.Write(fmt, ObjOrderedString(arr));
	  Console.Out.Write(fmt, MonoStringPrimitive(arr));
	  Console.Out.Write(fmt, MonoStringComparer(arr));
	  Console.Out.Write(fmt, PolyIGComparable(arr));
	  Console.Out.Write(fmt, PolyIGSelfComparable(arr));
	  Console.Out.Write(fmt, PolyIGComparer(arr));
	  Console.Out.Write(fmt, PolyDGComparer(arr));
	  Console.Out.WriteLine();
	}
      }
    }
  }

  static void headers(string fmt) {
      Console.Out.Write(fmt, &quot;general&quot;);
      Console.Out.Write(fmt, &quot;general&quot;);
      Console.Out.Write(fmt, &quot;not genl&quot;);
      Console.Out.Write(fmt, &quot;not genl&quot;);
      Console.Out.Write(fmt, &quot;general&quot;);
      Console.Out.Write(fmt, &quot;general&quot;);
      Console.Out.Write(fmt, &quot;general&quot;);
      Console.Out.Write(fmt, &quot;general&quot;);
      Console.Out.WriteLine();
      Console.Out.Write(fmt, &quot;not safe&quot;);
      Console.Out.Write(fmt, &quot;not safe&quot;);
      Console.Out.Write(fmt, &quot;typesafe&quot;);
      Console.Out.Write(fmt, &quot;typesafe&quot;);
      Console.Out.Write(fmt, &quot;not safe&quot;);
      Console.Out.Write(fmt, &quot;typesafe&quot;);
      Console.Out.Write(fmt, &quot;typesafe&quot;);
      Console.Out.Write(fmt, &quot;typesafe&quot;);
      Console.Out.WriteLine();
      Console.Out.Write(fmt, &quot;Comparab&quot;);
      Console.Out.Write(fmt, &quot;OrderedI&quot;);
      Console.Out.Write(fmt, &quot;Primitiv&quot;);
      Console.Out.Write(fmt, &quot;Comparer&quot;);
      Console.Out.Write(fmt, &quot;GCompara&quot;);
      Console.Out.Write(fmt, &quot;GSelfCom&quot;);
      Console.Out.Write(fmt, &quot;IGCompar&quot;);
      Console.Out.Write(fmt, &quot;DGCompar&quot;);
      Console.Out.WriteLine();
  }

  // The standard OO thing to do, given that int : IComparable
  static double ObjComparable(int[] arr) {
    int n = arr.Length;
    // Objsort.Quicksort(arr) would be illegal since int[] cannot be
    // converted to IComparable[], even though int : IComparable.
    IComparable[] oarr = new IComparable[n];
    for (int i=0; i&lt;n; i++)
      oarr[i] = arr[i];  // using that int : IComparable
    Timer t = new Timer();
    Objsort.Quicksort(oarr);
    //    print(oarr);
    return t.Check();
  }

  // Here we're using our own int wrapper, instead of IComparable (faster)
  static double ObjOrderedInt(int[] arr) {
    int n = arr.Length;
    OrderedInt[] oarr = new OrderedInt[n];
    for (int i=0; i&lt;n; i++)
      oarr[i] = new OrderedInt(arr[i]); 
    Timer t = new Timer();
    Objsort.Quicksort(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double MonoIntPrimitive(int[] arr) {
    int n = arr.Length;
    int[] narr = new int[n];
    for (int i=0; i&lt;n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Intsort.Quicksort(narr);
    //    print(narr);
    return t.Check();
  }

  static double MonoIntComparer(int[] arr) {
    int n = arr.Length;
    int[] narr = new int[n];
    for (int i=0; i&lt;n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    FunIntsort.Quicksort(narr, new IntComparer());
    //    print(narr);
    return t.Check();
  }

  static double PolyIGComparable(int[] arr) {
    int n = arr.Length;
    OrderedInt[] oarr = new OrderedInt[n];
    for (int i=0; i&lt;n; i++)
      oarr[i] = new OrderedInt(arr[i]); 
    Timer t = new Timer();
    Polysort.Quicksort&lt;OrderedInt&gt;(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double PolyIGSelfComparable(int[] arr) {
    int n = arr.Length;
    OrderedInt[] oarr = new OrderedInt[n];
    for (int i=0; i&lt;n; i++)
      oarr[i] = new OrderedInt(arr[i]); 
    Timer t = new Timer();
    Polyselfsort.Quicksort&lt;OrderedInt&gt;(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double PolyIGComparer(int[] arr) {
    int n = arr.Length;
    int[] narr = new int[n];
    for (int i=0; i&lt;n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Polysort.Quicksort&lt;int&gt;(narr, new IntComparer());
    //    print(narr);
    return t.Check();
  }

  static int intCompare(int v1, int v2) {
    return v1 &lt; v2 ? -1 : v1 &gt; v2 ? +1 : 0;
  }

  static double PolyDGComparer(int[] arr) {
    int n = arr.Length;
    int[] narr = new int[n];
    for (int i=0; i&lt;n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Polysort.Quicksort&lt;int&gt;(narr, new Polysort.DGComparer&lt;int&gt;(intCompare));
    //    print(narr);
    return t.Check();
  }

  // Eight ways to sort strings

  // The standard OO thing to do, given that string : IComparable
  static double ObjComparable(string[] arr) {
    int n = arr.Length;
    // Objsort.Quicksort(arr) would be illegal since string[] cannot be
    // converted to IComparable[], even though string : IComparable.
    IComparable[] oarr = new IComparable[n];
    for (int i=0; i&lt;n; i++)
      oarr[i] = arr[i];  // using that string : IComparable
    Timer t = new Timer();
    Objsort.Quicksort(oarr);
    //    print(oarr);
    return t.Check();
  }

  // Here we're using our own string wrapper, instead of IComparable (faster)
  static double ObjOrderedString(string[] arr) {
    int n = arr.Length;
    OrderedString[] oarr = new OrderedString[n];
    for (int i=0; i&lt;n; i++)
      oarr[i] = new OrderedString(arr[i]); 
    Timer t = new Timer();
    Objsort.Quicksort(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double MonoStringPrimitive(string[] arr) {
    int n = arr.Length;
    string[] narr = new string[n];
    for (int i=0; i&lt;n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Stringsort.Quicksort(narr);
    //    print(narr);
    return t.Check();
  }

  static double MonoStringComparer(string[] arr) {
    int n = arr.Length;
    string[] narr = new string[n];
    for (int i=0; i&lt;n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    FunStringsort.Quicksort(narr, new StringComparer());
    //    print(narr);
    return t.Check();
  }

  static double PolyIGComparable(string[] arr) {
    int n = arr.Length;
    OrderedString[] oarr = new OrderedString[n];
    for (int i=0; i&lt;n; i++)
      oarr[i] = new OrderedString(arr[i]); 
    Timer t = new Timer();
    Polysort.Quicksort&lt;OrderedString&gt;(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double PolyIGSelfComparable(string[] arr) {
    int n = arr.Length;
    OrderedString[] oarr = new OrderedString[n];
    for (int i=0; i&lt;n; i++)
      oarr[i] = new OrderedString(arr[i]); 
    Timer t = new Timer();
    Polyselfsort.Quicksort&lt;OrderedString&gt;(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double PolyIGComparer(string[] arr) {
    int n = arr.Length;
    string[] narr = new string[n];
    for (int i=0; i&lt;n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Polysort.Quicksort&lt;string&gt;(narr, new StringComparer());
    //    print(narr);
    return t.Check();
  }

  static double PolyDGComparer(string[] arr) {
    int n = arr.Length;
    string[] narr = new string[n];
    for (int i=0; i&lt;n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    // Note that string.Compare plugs right into the delegate:
    Polysort.Quicksort&lt;string&gt;(narr, new Polysort.DGComparer&lt;string&gt;(string.Compare));
    //    print(narr);
    return t.Check();
  }

  // Create arrays of random ints

  static int[] mkRandomInts(int n) {
    int[] arr = new int[n];
    for (int i=0; i&lt;n; i++) 
      arr[i] = rnd.Next(100000000);
    return arr;
  }

  // Create arrays of random strings

  static string[] mkRandomStrings(int n) {
    string[] arr = new string[n];
    for (int i=0; i&lt;n; i++) 
      arr[i] = mkRandomString(5 + rnd.Next(15));
    return arr;
  }

  static string mkRandomString(int n) {
    System.Text.StringBuilder sb = new System.Text.StringBuilder();
    for (int i=0; i&lt;n; i++) 
      sb.Append((char)(65 + rnd.Next(26) + 32 * rnd.Next(2)));
    return sb.ToString();
  }

  static void print(int[] arr) {
    for (int i=0; i&lt;arr.Length; i++)
      Console.Write(&quot;{0} &quot;, arr[i]);
    Console.WriteLine();
  }

  static void print(IComparable[] arr) {
    for (int i=0; i&lt;arr.Length; i++)
      Console.Write(&quot;{0} &quot;, (int)arr[i]);
    Console.WriteLine();
  }

  static void print(OrderedInt[] arr) {
    for (int i=0; i&lt;arr.Length; i++)
      Console.Write(&quot;{0} &quot;, arr[i].Value);
    Console.WriteLine();
  }
}

public class Timer {
  private DateTime start;

  public Timer() {
    start = DateTime.Now;
  }

  public double Check() {
    TimeSpan dur = DateTime.Now - start;
    return dur.TotalSeconds;
  }
}



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005691.html">[Mono-devel-list] System.Runtime.Remoting doesn't compile
</A></li>
	<LI>Next message: <A HREF="005694.html">[Mono-devel-list] Mono .net 2.0 preview and generics
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5692">[ date ]</a>
              <a href="thread.html#5692">[ thread ]</a>
              <a href="subject.html#5692">[ subject ]</a>
              <a href="author.html#5692">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
