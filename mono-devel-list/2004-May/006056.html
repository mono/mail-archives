<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Ideas on the ABC removal code
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Ideas%20on%20the%20ABC%20removal%20code&In-Reply-To=s0b702f0.041%40gm004.hawken.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006037.html">
   <LINK REL="Next"  HREF="006057.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Ideas on the ABC removal code</H1>
    <B>Iain McCoy</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Ideas%20on%20the%20ABC%20removal%20code&In-Reply-To=s0b702f0.041%40gm004.hawken.edu"
       TITLE="[Mono-devel-list] Ideas on the ABC removal code">iain at mccoy.id.au
       </A><BR>
    <I>Sun May 30 00:07:04 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="006037.html">[Mono-devel-list] Ideas on the ABC removal code
</A></li>
        <LI>Next message: <A HREF="006057.html">[Mono-devel-list] Ideas on the ABC removal code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6056">[ date ]</a>
              <a href="thread.html#6056">[ thread ]</a>
              <a href="subject.html#6056">[ subject ]</a>
              <a href="author.html#6056">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2004-05-28 at 23:13, Ben Maurer wrote:
&gt;<i> We could make under/overflow easy for you if someone does:
</I>&gt;<i> 
</I>&gt;<i> object [] a;
</I>&gt;<i> foreach (object o in a) {
</I>&gt;<i> ....
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> I think it would be valid for mcs to emit an unsigned comparison in the loop. This would mean for that case you need not worry about overflow.
</I>&gt;<i> 
</I>&gt;<i> Of course, some people will still write out manual for loops. I could do some checking to see the frequency of `foreach' vs `for' when looping through an array.
</I>&gt;<i> 
</I>&gt;<i> I am not sure why the Jikes code does not handle the overflow case though...
</I>&gt;<i> 
</I>&gt;<i> -- Ben
</I>
I might be misunderstanding here, but I thought Massimiliano was talking
about a runtime optimization. Surely there's no reason to believe that
the code encountered by the runtime would have been emitted by mcs?

&gt;<i> &gt;&gt;&gt; Massimiliano Mantione &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">massi at ximian.com</A>&gt; 05/28/04 08:50 AM &gt;&gt;&gt;
</I>&gt;<i> 
</I>&gt;<i> I finally &quot;digested&quot; the ABCD paper:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://citeseer.ist.psu.edu/bodik00abcd.html">http://citeseer.ist.psu.edu/bodik00abcd.html</A>
</I>&gt;<i> 
</I>&gt;<i> All in all, their approach is surprisingly similar to ours
</I>&gt;<i> (explained in the file &quot;docs/abc-removal.txt&quot; in the mono
</I>&gt;<i> source tree).
</I>&gt;<i> If it wasn't because they actually were there first, I would
</I>&gt;<i> say that they have stolen my code and improved on it :-)
</I>&gt;<i> 
</I>&gt;<i> The main difference between the two approaches is the way in
</I>&gt;<i> which the &quot;relation graph&quot; is explored. What my code does is
</I>&gt;<i> the most stupid (but also easiest) thing: the graph is stored
</I>&gt;<i> as a matrix (each cell is a potential graph arc), and the
</I>&gt;<i> whole matrix is fully processed multiple times, until all the
</I>&gt;<i> possible consequences are exhausted (it is the computation of
</I>&gt;<i> the &quot;closure&quot; of the relation graph, where &quot;implied&quot; relations
</I>&gt;<i> are made explicit).
</I>&gt;<i> At that point, the eventual presence of specific arcs states
</I>&gt;<i> if specific ABCs can be removed.
</I>&gt;<i> 
</I>&gt;<i> In the ABCD paper, on the other hand, the idea is simply to
</I>&gt;<i> &quot;explore&quot; the graph locally, starting from nodes defining
</I>&gt;<i> arrays, and seeing if the paths that lead to the index used
</I>&gt;<i> accessing the array has certain properties (if this is true,
</I>&gt;<i> the ABC can be removed).
</I>&gt;<i> It turns out that the &quot;exploration&quot; algorithm is simply a
</I>&gt;<i> depth first traversal, with special care taken to break cycles.
</I>&gt;<i> It also turns out that the logic used to break cycles is just
</I>&gt;<i> the one we use now (luckily).
</I>&gt;<i> 
</I>&gt;<i> One minor difference (but very important) is that the ABCD
</I>&gt;<i> approach requires the extension of the SSA form with PI nodes.
</I>&gt;<i> Basically, these nodes are there to mark the fact that a given
</I>&gt;<i> SSA variable actually has &quot;different&quot; values inside different
</I>&gt;<i> BBs, because these BBs are &quot;guarded&quot; by conditions on that
</I>&gt;<i> variable. We keep up without this extended SSA form simply
</I>&gt;<i> because we reconstruct the evaluation graph at each BB, taking
</I>&gt;<i> into account the proper entry condition of the BB.
</I>&gt;<i> However, this reconstruction (which in itself is not so bad)
</I>&gt;<i> causes the need for the re-evaluation (exploration) of the
</I>&gt;<i> *whole* graph at each BB (which is very bad).
</I>&gt;<i> 
</I>&gt;<i> I have been thinking about this for a while, and there is a
</I>&gt;<i> solution that is sound (not a hack) and that can have a good
</I>&gt;<i> performance.
</I>&gt;<i> 
</I>&gt;<i> The goals are:
</I>&gt;<i> [1] Avoid scanning the whole graph, just examine it locally.
</I>&gt;<i> [2] Avoid re-examining the same variable in different BBs
</I>&gt;<i>     if this is not strictly needed (the variable would have
</I>&gt;<i>     had a PI definition in this case, or would &quot;depend&quot; from
</I>&gt;<i>     a PI definition in the ABCD approach).
</I>&gt;<i> 
</I>&gt;<i> Now, to achieve [1] we should avoid the current &quot;brute force&quot;
</I>&gt;<i> approach, store the graph properly, and navigate it locally
</I>&gt;<i> with a depth first algorithm. This does not sound that hard,
</I>&gt;<i> as the logic for breaking cycles in the the traversal is the
</I>&gt;<i> one we already have.
</I>&gt;<i> 
</I>&gt;<i> The hard part (IMHO) is achieving [2] without the extended SSA
</I>&gt;<i> form (the additional PI definitions).
</I>&gt;<i> The problem is that in the ABCD paper they can safely assume
</I>&gt;<i> that *one* single graph describes the whole method, because
</I>&gt;<i> when a variable is subject to different conditions in different
</I>&gt;<i> BBs they actually create different variables. In our approach,
</I>&gt;<i> we have (at least logically) on different graph for each BB, and
</I>&gt;<i> in fact we re-evaluate everything in each BB.
</I>&gt;<i> 
</I>&gt;<i> To get out of this mess, consider a depth-first traversal of
</I>&gt;<i> the idominator tree, and consider how the evaluation graphs
</I>&gt;<i> change in this traversal.
</I>&gt;<i> Basically, we have the following facts:
</I>&gt;<i> 
</I>&gt;<i> - In the start BB, the graph is composed by all the SSA
</I>&gt;<i>   variable definitions, no more, and no less. This is true
</I>&gt;<i>   for two reasons:
</I>&gt;<i>   - All the SSA definitions are &quot;statically valid&quot; in the
</I>&gt;<i>     whole method. Maybe each given variable is not used in
</I>&gt;<i>     every BB, but its single static assignment is OK.
</I>&gt;<i>   - The entry BB has no entry condition, so no other arcs
</I>&gt;<i>     can be added to the graph.
</I>&gt;<i> - Entering each BB in the depth first traversal of the
</I>&gt;<i>   idominator tree, the graph is the previous graph *plus*
</I>&gt;<i>   the arcs representing the relations implied by the entry
</I>&gt;<i>   condition of this BB. Every evaluation that has so far been
</I>&gt;<i>   performed on a variable is still valid, and can only be made
</I>&gt;<i>   &quot;more specific&quot; (or more &quot;powerful&quot;, or &quot;detailed&quot;, think of
</I>&gt;<i>   it as you like) by the conditions added in this BB.
</I>&gt;<i> 
</I>&gt;<i> This second observation is really important: every evaluation
</I>&gt;<i> performed early in the depth first traversal on the idominator
</I>&gt;<i> tree is still valid, so we can avoid repeating it (this is
</I>&gt;<i> what we aimed for in point [2]). We can, of course, &quot;refine&quot;
</I>&gt;<i> it using the new conditions, but these new results must be
</I>&gt;<i> discarded when we exit from the evaluation phase of this BB
</I>&gt;<i> (by definition, they are valid only in the region of the tree
</I>&gt;<i> that is dominated by this BB).
</I>&gt;<i> 
</I>&gt;<i> This suggests to restructure the evaluation phase as a depth
</I>&gt;<i> first traversal of the idominator tree. The function that
</I>&gt;<i> performs the evaluation should be properly recursive, and the
</I>&gt;<i> results for each BB should be kept (on the stack, or pointed to
</I>&gt;<i> by some context on the stack) to be used by the other BBs down
</I>&gt;<i> the tree.
</I>&gt;<i> 
</I>&gt;<i> I really hope this makes sense to somebody ;-) otherwise just
</I>&gt;<i> ask...
</I>&gt;<i> 
</I>&gt;<i> I'm going to decide the exact data structures to be used in
</I>&gt;<i> the next days, and then rewrite the thing, but comments on the
</I>&gt;<i> approach are really appreciated.
</I>&gt;<i> 
</I>&gt;<i> Ciao,
</I>&gt;<i>   Massimiliano
</I>&gt;<i> 
</I>&gt;<i> P.S. One thing the ABCD paper totally overlooks is the issue
</I>&gt;<i> of array indexes (over)|(under)flowing after an arithmetical
</I>&gt;<i> operation. Has anybody a clue of why this is not an issue for
</I>&gt;<i> them?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>-- 
Iain McCoy &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">iain at mccoy.id.au</A>&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006037.html">[Mono-devel-list] Ideas on the ABC removal code
</A></li>
	<LI>Next message: <A HREF="006057.html">[Mono-devel-list] Ideas on the ABC removal code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6056">[ date ]</a>
              <a href="thread.html#6056">[ thread ]</a>
              <a href="subject.html#6056">[ subject ]</a>
              <a href="author.html#6056">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
