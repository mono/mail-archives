<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [PATCH] Faster String.Equals
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20Faster%20String.Equals&In-Reply-To=005901c43fe9%2401d40ae0%246464a8c0%40ansuria">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005920.html">
   <LINK REL="Next"  HREF="005949.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [PATCH] Faster String.Equals</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20Faster%20String.Equals&In-Reply-To=005901c43fe9%2401d40ae0%246464a8c0%40ansuria"
       TITLE="[Mono-devel-list] [PATCH] Faster String.Equals">lupus at ximian.com
       </A><BR>
    <I>Mon May 24 06:40:20 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="005920.html">[Mono-devel-list] [PATCH] Faster String.Equals
</A></li>
        <LI>Next message: <A HREF="005949.html">[Mono-devel-list] [PATCH] Faster String.Equals
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5946">[ date ]</a>
              <a href="thread.html#5946">[ thread ]</a>
              <a href="subject.html#5946">[ subject ]</a>
              <a href="author.html#5946">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 05/22/04 Andreas Nahr wrote:
&gt;<i> However I see some problems with that approach:
</I>
Note, most (all?) of these issues were considered when I proposed this
optimization (bug#58026).

&gt;<i> 1. Substantial code multiplication. We need Supported_Architectures + 1 code
</I>&gt;<i> implementations for every method instread of just 1. This will be horrible
</I>&gt;<i> to maintain and a lot of additional work.
</I>
Nope: they are optional, so architectures don't need to write code for
them.

&gt;<i> 2. Too platform specific optimizations. Look at your String.Equals that is
</I>&gt;<i> only implemented for x86. If somebody uses a lot of String.Equals in his own
</I>&gt;<i> classes then his implementation will perform seriously slower/ different on
</I>&gt;<i> other platforms. This may lead to problematic optimizations for classes
</I>&gt;<i> which internally use these methods.
</I>
These kind of assembly-coded icalls will be used for three kinds of
methods:
*) code which cannot be expressed as IL/C# code
*) code which would require a managed-&gt;unmanaged transition
*) code that the compiler won't be able to optimally compile, just like
some functions in libc are coded in asm and not in C (also code which
make take advantage of features in the current processor)

&gt;<i> 4. Although it does not have the overhead of an icall AFAIU it still poses a
</I>&gt;<i> problem for optimizations. A compiler (like ngen) may be able to completely
</I>&gt;<i> eliminate a case like:
</I>&gt;<i> &quot;Test&quot; != &quot;Test&quot;
</I>&gt;<i> to a false constant (very simple example). Is that still possible with your
</I>&gt;<i> implementation?
</I>&gt;<i> 
</I>&gt;<i> Or
</I>&gt;<i> String a = &quot;dh&quot;
</I>&gt;<i> String b = &quot;dfh&quot;
</I>&gt;<i> a.Equals (b)
</I>&gt;<i> might get inlined and *optimized* by the compiler or JIT or especially AOT
</I>&gt;<i> because it can guarantee that a and b can never be null (which is checked in
</I>&gt;<i> Equals).
</I>
Inlining can still happen just fine.

&gt;<i> 6. We still need a fast managed implementation for cases when a ASM -
</I>&gt;<i> version is not available
</I>
We need it also when it's present, so the inliner can see the code and
take advantage of it. This is one of the reasons Ben's patch is not
going in: we first need to optimize the current C# code and the code
produced by the JIT for those methods (the current String.Equals
generated code could be trivially made better), since those changes
benefit everyone and having it in critical methods should just be
considered an incentive to make it better:-).
The other reason is that his code is still slow and it's not worth the 
complexity and the uglyness of adding asm-based icalls if the code 
is still not optimized.

&gt;<i> 1. Add that ASM - injection architecture, but not enable it by default. We
</I>&gt;<i> could have a --AsmInject switch which enables it.
</I>
Yes, we could commit the stubs and add a separate optimization flag
which is not selected by -O=all.

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005920.html">[Mono-devel-list] [PATCH] Faster String.Equals
</A></li>
	<LI>Next message: <A HREF="005949.html">[Mono-devel-list] [PATCH] Faster String.Equals
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5946">[ date ]</a>
              <a href="thread.html#5946">[ thread ]</a>
              <a href="subject.html#5946">[ subject ]</a>
              <a href="author.html#5946">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
