<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] SecureString implementation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20SecureString%20implementation&In-Reply-To=1134170010.13297.35.camel%40omega.res.cmu.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016136.html">
   <LINK REL="Next"  HREF="016130.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] SecureString implementation</H1>
    <B>Sebastien Pouliot</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20SecureString%20implementation&In-Reply-To=1134170010.13297.35.camel%40omega.res.cmu.edu"
       TITLE="[Mono-dev] [PATCH] SecureString implementation">sebastien.pouliot at gmail.com
       </A><BR>
    <I>Fri Dec  9 19:40:27 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="016136.html">[Mono-dev] [PATCH] SecureString implementation
</A></li>
        <LI>Next message: <A HREF="016130.html">[Mono-dev] Status Report
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16139">[ date ]</a>
              <a href="thread.html#16139">[ thread ]</a>
              <a href="subject.html#16139">[ subject ]</a>
              <a href="author.html#16139">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

On Fri, 2005-12-09 at 18:13 -0500, Ben Maurer wrote:
&gt;<i> I think I am confused about the design of ProtectedMemory, can you
</I>&gt;<i> correct the errors I make in the following reply? Mostly this because I
</I>&gt;<i> am curious about the API now ;-).
</I>
Sure. Always happy to talk about security :)

&gt;<i> On Fri, 2005-12-09 at 17:39 -0500, Sebastien Pouliot wrote:
</I>&gt;<i> &gt; Hello Ben,
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; On Fri, 2005-12-09 at 16:28 -0500, Ben Maurer wrote:
</I>&gt;<i> &gt; &gt; Why does this need to be implemented in unmanaged code? The win32 apis
</I>&gt;<i> &gt; &gt; could be pinvoked, and we already have an AES implementation in managed
</I>&gt;<i> &gt; &gt; code. 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Oh, believe me I have a *much* higher preference to managed code (and I
</I>&gt;<i> &gt; did try it) but in the end the choice wasn't about &quot;how&quot;, it was about
</I>&gt;<i> &gt; &quot;why&quot;.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The use cases for ProtectedMemory (and SecureString is very similar) are
</I>&gt;<i> &gt; very different from the &quot;general&quot; use cases of cryptography. I won't get
</I>&gt;<i> &gt; in long (and potentially boring for some) details (there's lot of docs
</I>&gt;<i> &gt; on MSDN for interested people) but PM and SS are mainly used to limit
</I>&gt;<i> &gt; the window of opportunity to access some data during software execution.
</I>&gt;<i> 
</I>&gt;<i> The primary goal of ProtectedMemory (or SecureString) seems to be:
</I>&gt;<i>      1. To prevent the protected value from being exposed should it ever
</I>&gt;<i>         be swapped to disk (and the computer rebooted into an OS that
</I>&gt;<i>         could read the swap file)
</I>
Prevent? No.

It's less likely to happen (how much less depends on how it is used) but
it can't prevent it - there's too much other things to consider outside
DPAPI. We could say it's like an &quot;widely varying indirect advantage&quot;.

&gt;<i>      2. To reduce the window for for a process with access to the
</I>&gt;<i>         program's address space to view the data (what is an example of
</I>&gt;<i>         where somebody would have access to the programs address space
</I>&gt;<i>         but can't just call the DAPI code to decrypt the string? I don't
</I>&gt;<i>         think I understand this case)
</I>
DPAPI use different keys for each process, user (logon) and a global one
(cross-process). See MemoryProtectionScope in fx 2.0 for more details.

SecureString use (in Mono and most likely in MS implementation) the
process key. So only code executing in the same process can use DPAPI to
decrypt the value.

If someone runs into your address space then all bets are off (and that
include encryption, digital signatures ...).

&gt;<i>      3. (SecureString) Allow untrusted APIs to be given a string without
</I>&gt;<i>         being able to read it. For example, I could give somebody a
</I>&gt;<i>         password for a web service and know that they'd never be able to
</I>&gt;<i>         get the password and send it to a place I didn't want it to go.
</I>
Not really (or not only) untrusted API. It's common to ask, and keep,
credentials (or other sensitive information) for a very long time in an
application. It's also hard to predict how those information could be
disclosed if case the application fails[*]. Keeping them encrypted, but
accessible, is an easy way to &quot;decrease&quot; this problem (without
re-designing your application).

Also .NET has very special rules regarding strings which make them even
harder (well almost impossible) to clear properly once they contained
important data. So providing a &quot;string&quot; class not bound by those rules
is also very helpful.

Sadly the SecureString isn't being always available to be used in many
API - including new ones in 2.0 where byte[] overloads were added for
passwords :(

[*] it's a major, yet little known, fact that &quot;application failing&quot; (not
to confuse with &quot;security failing&quot; ;-) is a very important aspect of
security. That's in large part due to how easy it can be to make
software fail...

&gt;<i> Right?
</I>
Mostly ;-)

&gt;<i> &gt; There are some reasons this cannot be build on top of the managed
</I>&gt;<i> &gt; implementation. The biggest one, IMHO, is that the symmetric algorithms
</I>&gt;<i> &gt; in .NET have a design flaw[1]: the secret key is publicly exposed (and
</I>&gt;<i> &gt; some would say it's &quot;by design&quot; ;-). This it's not a big deal for the
</I>&gt;<i> &gt; most common usage where you already supply, hence know, the secret key.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; However the lack of encapsulation of the key (like provided in
</I>&gt;<i> &gt; CryptoAPI, and many other toolkits, using opaque handles) makes it
</I>&gt;<i> &gt; &quot;hard&quot; to share the use of a common key without sharing the key itself.
</I>&gt;<i> &gt; By &quot;hard&quot; I mean it's &quot;too easy to share&quot; so it destroy the real
</I>&gt;<i> &gt; advantage of using PM/SS (as the window of opportunity on the secret key
</I>&gt;<i> &gt; would be larger than on the protected data).
</I>&gt;<i> 
</I>&gt;<i> How does having encapsulated in the runtime add additional security?
</I>&gt;<i> Somebody who has access to reflect on private APIs (such as the secret
</I>&gt;<i> key for ProtectedMemory/SecureString) should be able to get this data
</I>&gt;<i> from the runtime just as easily (well, they might need some more hackery
</I>&gt;<i> as the C library obviously isn't reflectable.
</I>
Right, in this case reflection wouldn't be enough to get the key. It may
seems a simple step (for you) to go the more &quot;hackery&quot; step but it may
be enough to stop a lot of people.

The next logical step would be to &quot;outsource&quot; this service to the OS
(like we do in Windows) as the OS, having more control, can do a lot of
things more safely than applications. But even then it won't be
perfect...

&gt;<i> But it seems to be protection by obscurity rather than real protection).
</I>
No. Obscurity would be hide the solution (e.g. an hardcoded key in the
runtime) or the problem existence (shhh, maybe no one will notice ;-).

Admitting limits (in this case it means &quot;reducing the window of
opportunity&quot; and &quot;limiting the access to the shared key&quot;) isn't
obscurity. We clearly know that encryption or &quot;insert your buzzword
here&quot; doesn't solve every problem, yet we do offer encryption (and other
buzzwords ;-)

Security is a pile of trade off. Nothing is 100% safe but by using many
&quot;tricks&quot; we can cover a lot of it. That's still nowhere near 100% but
it's enough to make (some) software usable ;-)

&gt;<i> &gt; Could it be implemented differently ? Maybe.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ProtectedData is very similar but has some different rules (e.g.
</I>&gt;<i> &gt; longer-term) and it's API makes it easy to use asymmetric cryptography
</I>&gt;<i> &gt; (which doesn't have the design flaw [1]) so it was fully implemented in
</I>&gt;<i> &gt; managed code. However a quick look at the PM API shows, without a doubt,
</I>&gt;<i> &gt; that the implementation is based on a symmetric block cipher.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Could I modify the managed AES implementation to achieve this ? Probably
</I>&gt;<i> &gt; for a good chunk of the current code/features. Hardly for the other
</I>&gt;<i> &gt; MemoryProtectionScope options.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [1] The asymmetric algorithms have the &quot;opaque&quot; concept (using the
</I>&gt;<i> &gt; CspParameters class) which can (this is really implementation dependent)
</I>&gt;<i> &gt; allow keypairs to be used without disclosing the private key (e.g. by
</I>&gt;<i> &gt; refusing to export it).
</I>&gt;<i> 
</I>&gt;<i> How is this opacity implemented?
</I>
This is implementation dependant. The important thing is that the design
allows it (while the symmetric API design prevents it).

Software implementations aren't very good at opacity. This is why you'll
(most probably) never find a software only implementation rated more
higher than level 2.

However hardware implementation (e.g. smartcard, SSL accelerator, HSM
used in PKI CA...) are much better at opacity. The design of asymmetric
algorithms in the .NET framework can easily be used in this case, while
the design of the symmetric algorithms cannot (well you're still free to
implement your own design if you like).

&gt;<i>  If I have the ability to read a random
</I>&gt;<i> address in memory, can't I (with some level of reverse engineering) find
</I>&gt;<i> the shared key 
</I>well private key in the asymmetric case.

&gt;<i> with no more effort than I needed to gain access to the
</I>&gt;<i> secure string in the first place? 
</I>
Yes, it's just harder. Sometimes it becomes just hard enough, or the
condition aren't right, that it can't be done (and we gain a little ;-).

&gt;<i> How is the shared key protected from being swapped to disk?
</I>
In Mono, it's not. In fact this isn't something that should be part of
Mono itself, but part of the operating system and exposed thru Mono.

In general it depends. I designed, for my previous employer, a kernel
mode driver (windows) which sole purpose was keeping secrets safe,
including not swapping them to disk. It's not that hard but it impose
very strict application requirements to be effective (which would be
very hard to &quot;impose&quot; on third parties).
-- 
Sebastien Pouliot
email: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>
blog: <A HREF="http://pages.infinit.net/ctech/">http://pages.infinit.net/ctech/</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016136.html">[Mono-dev] [PATCH] SecureString implementation
</A></li>
	<LI>Next message: <A HREF="016130.html">[Mono-dev] Status Report
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16139">[ date ]</a>
              <a href="thread.html#16139">[ thread ]</a>
              <a href="subject.html#16139">[ subject ]</a>
              <a href="author.html#16139">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
