<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Anonymous Pipe Stream Implementation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-dev%5D%20Anonymous%20Pipe%20Stream%20Implementation&In-Reply-To=%3C51DA2716.3080809%40veritas-vos-liberabit.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="040580.html">
   <LINK REL="Next"  HREF="040598.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Anonymous Pipe Stream Implementation</H1>
    <B>Atsushi Eno</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-dev%5D%20Anonymous%20Pipe%20Stream%20Implementation&In-Reply-To=%3C51DA2716.3080809%40veritas-vos-liberabit.com%3E"
       TITLE="[Mono-dev] Anonymous Pipe Stream Implementation">atsushieno at veritas-vos-liberabit.com
       </A><BR>
    <I>Mon Jul  8 02:42:30 UTC 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="040580.html">[Mono-dev] Anonymous Pipe Stream Implementation
</A></li>
        <LI>Next message: <A HREF="040598.html">[Mono-dev] Anonymous Pipe Stream Implementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40581">[ date ]</a>
              <a href="thread.html#40581">[ thread ]</a>
              <a href="subject.html#40581">[ subject ]</a>
              <a href="author.html#40581">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

SmokingRope wrote:
&gt;<i> Hi, I'm poking through the pieces of the System.Core/System.IO.Pipes 
</I>&gt;<i> code looking to build out anonymous pipes. I have at least a basic 
</I>&gt;<i> working Unix implementation now. Though i imagine Win32 and Named 
</I>&gt;<i> pipes have been broken (if they ever worked) in the process, and there 
</I>&gt;<i> is undoubtedly some cleanup work required. I'd like to get some 
</I>&gt;<i> feedback from people more knowledgeable than myself about mono at this 
</I>&gt;<i> point so i can try and wrap this project up into a pull request.
</I>
That's great! Thanks for taking care of this.

I'm skipping some parts of your questions and writing for some parts 
that I can answer...


&gt;<i>
</I>&gt;<i> My initial test case is this example from MSDN: 
</I>&gt;<i> <A HREF="http://msdn.microsoft.com/en-us/library/bb546102.aspx">http://msdn.microsoft.com/en-us/library/bb546102.aspx</A>
</I>&gt;<i>
</I>&gt;<i> Handle Inheritance
</I>&gt;<i> -------------------------
</I>&gt;<i> Presently, Process.Start() arbitrarily closes all handles in the 
</I>&gt;<i> fork()'d process, except stdin / stdout / stderr. There exists a todo 
</I>&gt;<i> comment in this same code (io-layer/processes.c) pointing out that 
</I>&gt;<i> (when inherit_handles is TRUE, which it is) that something should be 
</I>&gt;<i> done differently than when not...
</I>&gt;<i>
</I>&gt;<i> if (/inherit_handles/ != TRUE) {
</I>&gt;<i>
</I>&gt;<i> /* FIXME: do something here */
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Without a far more expansive knowledge of mono i can't make a very 
</I>&gt;<i> well informed decision about the liberties i can take in addressing this.
</I>&gt;<i> The cleanest solution might be to use FD_CLOEXEC on all the existing 
</I>&gt;<i> fd's and (at least in process.Start case) the handles that should be 
</I>&gt;<i> cleaned up would be closed automatically / inherited automatically. 
</I>&gt;<i> Are there compatibility reasons this cannot be done? Has there been 
</I>&gt;<i> any consideration for this that could be drawn upon?
</I>&gt;<i> &gt;From information i do have, it seems like these pipe handles could 
</I>&gt;<i> also be flagged as 'inheritable' in the internal handle registry and 
</I>&gt;<i> then after fork() mono could leave those open, while closing 
</I>&gt;<i> everything else.
</I>&gt;<i>
</I>&gt;<i> In addition to this basic test case, i'm not currently aware of how 
</I>&gt;<i> anonymous pipes should behave when you invoke Process.Start() several 
</I>&gt;<i> times with an anonymous pipe. Without using FD_CLOEXEC it would be 
</I>&gt;<i> difficult and messy to (in a 'execd' child process) to identify all 
</I>&gt;<i> the pipe handles at startup and register them in the mono handle 
</I>&gt;<i> registry as inheritable again (so that Process.Start in that child 
</I>&gt;<i> process would pass these handles on again to its children). If 
</I>&gt;<i> anonymous pipes are supposed to support this, it lends further support 
</I>&gt;<i> for the FD_CLOEXEC solution.
</I>&gt;<i>
</I>&gt;<i> API Methods Difficult To Implement In Unix
</I>&gt;<i> -------------------------
</I>&gt;<i> There doesn't seem to be a clear specification for the anonymous pipe 
</I>&gt;<i> feature and i've so far had to make some little assumptions / 
</I>&gt;<i> inferences based on the documentation on MSDN. That said, the posix 
</I>&gt;<i> anonymous pipe standard lacks a few features which are pertinent to 
</I>&gt;<i> the API for anonymous pipe streams. In particular there are two 
</I>&gt;<i> conflicting features:
</I>&gt;<i>
</I>&gt;<i>      * WaitForPipeDrain 
</I>&gt;<i> &lt;<A HREF="http://msdn.microsoft.com/en-us/library/system.io.pipes.pipestream.waitforpipedrain.aspx">http://msdn.microsoft.com/en-us/library/system.io.pipes.pipestream.waitforpipedrain.aspx</A>&gt;() 
</I>&gt;<i> defined on the AnonymousPipeStream requires some ability to peak into 
</I>&gt;<i> an anonymous pipe and wait for the pipe's buffer to become empty
</I>&gt;<i>      * Write / Read / etc... is supposed to throw an IOException if 
</I>&gt;<i> the other end of the pipe stream has been closed (i have interpreted 
</I>&gt;<i> the wording 'pipe is broken' from the msdn docs to mean this, although 
</I>&gt;<i> there is a chance i am mis-interpreting this too)
</I>&gt;<i>
</I>&gt;<i> These two features conflict when trying to implement them in unix 
</I>&gt;<i> through minor hacks / workarounds.
</I>&gt;<i>
</I>&gt;<i> I can implement WaitForPipeDrain() by leaving the read end of the pipe 
</I>&gt;<i> handle open in the writer process, and calling poll(3) on the read end 
</I>&gt;<i> repeatedly until the POLL_IN flag is gone.
</I>&gt;<i>
</I>&gt;<i> I can detect that the pipe is broken by closing the read end on the 
</I>&gt;<i> writer, (and the write end on the reader) and calling poll(3), 
</I>&gt;<i> throwing this &quot;pipe broken&quot; error when a POLLERR /. POLLHUP is issued. 
</I>&gt;<i> One of these two flags will be set if all handles to the other end of 
</I>&gt;<i> the pipe have been closed.
</I>&gt;<i>
</I>&gt;<i> In order to implement both of these conflicting features i actually 
</I>&gt;<i> need to create two pipes (one where i can leave the read end open on 
</I>&gt;<i> the writer process, and one where i can close it). This is not very 
</I>&gt;<i> nice in the case that system resources might be at a premium, however 
</I>&gt;<i> i haven't been able to devise any other way to get both features 
</I>&gt;<i> either. Would there be any major objection to implementing it like 
</I>&gt;<i> this (which as i have noted seems to be the only way)?
</I>
I would say that opening two pipes is of less concern. If people need 
very efficient named pipes then they should rather use platform-specific 
stuff.
&gt;<i>
</I>&gt;<i> Using two separate pipes like this, the GetClientHandleAsString() 
</I>&gt;<i> method is going to be significantly different from the win32 version. 
</I>&gt;<i> When the client is supposed to be the writer, the client handle as 
</I>&gt;<i> string must contain three separate fds. When the client is the reader 
</I>&gt;<i> two fd's must be passed. I don't see any reason that this would bother 
</I>&gt;<i> anybody, but if it's relevant let me know!
</I>
That method can return totally different string than what .NET returns. 
It's weird that if an application totally depends on certain format of 
the return values of it and I believe we can ignore them.

&gt;<i>
</I>&gt;<i> Compatibility
</I>&gt;<i> -------------------------
</I>&gt;<i> I can create pipes and manipulate them without adding any new library 
</I>&gt;<i> references but i do depend on using the poll(3) function more heavily 
</I>&gt;<i> than it seems to be presently (it's only exposed for Network Sockets 
</I>&gt;<i> presently). Are there any portability / compatibility considerations 
</I>&gt;<i> with poll(3) that might need to be addressed?
</I>&gt;<i>
</I>
I guess Mono.Posix.dll has a lot more bound API that you want to use (it 
is already referenced by System.Core.dll for desktop CLR_PROFILE in 
System.Core/Makefile).

If that still needs to touch our runtime (io-layer) then it is of our 
concern yes, as we are building runtime not only for desktop. Yet we 
have couple of defs (PLATFORM_ANDROID etc.), so as long as things can be 
easily conditioned out it would work.

&gt;<i> Versioning
</I>&gt;<i> -------------------------
</I>&gt;<i> I'm not familiar with how versioning between .NET 1/2/3/etc... is 
</I>&gt;<i> being handled. Anonymous pipes are introduced in .NET 3.5. Do these 
</I>&gt;<i> classes need to be hidden to older versions, etc... Maybe there is a 
</I>&gt;<i> wiki page i haven't found discussing some of this?
</I>&gt;<i>
</I>
Our least supported Framework API is 2.0 runtime, which covers 2.0, 3.0, 
3.5 and 3.5 SP1 API.  So, you don't need to add any condition. For 4.0 
specific types and members, use &quot;#if NET_4_0&quot; for all of them (you can 
hide them by changing them as internal for !NET_4_0).

&gt;<i> I have added several new internal calls to the MonoIO utility, 
</I>&gt;<i> specifically for poll(3) and pipe handle manipulation. Does adding 
</I>&gt;<i> internal calls require any versioning considerations?
</I>&gt;<i>
</I>&gt;<i> Testing
</I>&gt;<i> -------------------------
</I>&gt;<i> In order to write a test suite for anonymous pipes i need to start new 
</I>&gt;<i> processes and i will need to use some sort of IPC mechanism to 
</I>&gt;<i> communicate certain errors back to the test process. This seems like a 
</I>&gt;<i> rather unique challenge compared to most of the testing needed for mono.
</I>&gt;<i>
</I>&gt;<i> Has any of this multi-process unit testing been done before in mono, 
</I>&gt;<i> or are there any considerations that might be relevant?
</I>&gt;<i>
</I>
Not everything has to be in our existing NUnit test style. We have a 
couple of standalone tests (e.g. in System.Web.Services or System.Xml). 
Probably you can create your own test runner to deal with multiple 
processes.

Please do not hesitate to show us your ongoing changes. I'm sure that 
almost no one cared this API (at least no one contributed to the 
implementation), so you're most likely the one at best knowledge here :) 
And with code people can talk better.

Atsushi Eno

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="040580.html">[Mono-dev] Anonymous Pipe Stream Implementation
</A></li>
	<LI>Next message: <A HREF="040598.html">[Mono-dev] Anonymous Pipe Stream Implementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40581">[ date ]</a>
              <a href="thread.html#40581">[ thread ]</a>
              <a href="subject.html#40581">[ subject ]</a>
              <a href="author.html#40581">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
