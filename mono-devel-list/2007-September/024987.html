<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] DataContext Implementation Advice
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20DataContext%20Implementation%20Advice&In-Reply-To=9a962700709210410g52cdd1ddo86c085e59ac84571%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024986.html">
   <LINK REL="Next"  HREF="024993.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] DataContext Implementation Advice</H1>
    <B>Kevin Kubasik</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20DataContext%20Implementation%20Advice&In-Reply-To=9a962700709210410g52cdd1ddo86c085e59ac84571%40mail.gmail.com"
       TITLE="[Mono-dev] DataContext Implementation Advice">kevin at kubasik.net
       </A><BR>
    <I>Fri Sep 21 07:16:03 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="024986.html">[Mono-dev] DataContext Implementation Advice
</A></li>
        <LI>Next message: <A HREF="024993.html">[Mono-dev] C bindings VS C++ bindings (Gtk# vs. Kimono?)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24987">[ date ]</a>
              <a href="thread.html#24987">[ thread ]</a>
              <a href="subject.html#24987">[ subject ]</a>
              <a href="author.html#24987">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Yeah, thats right along the line I was hoping to go before, my only
concern really stems from my lack of experience with the whole
&quot;functional programming&quot; workflow. I would think that adding a
listener to every entity in a DataContex's Tables. But my concern was
more over managing state accurately, and are the 'same' entities
always going to appear that way to a hash, or would it need to be a
searched list?

Just because of the mammoth amount of work that has to go into getting
the very start of a system like that working, I want to be somewhat
confident. Anyways, the upside is that I can probably use linq over
the object store ;)

On 9/21/07, Paul Stovell &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lists at paulstovell.com</A>&gt; wrote:
&gt;<i> Hi Kevin,
</I>&gt;<i>
</I>&gt;<i> I'm enjoying reading these posts of yours - very fascinating.
</I>&gt;<i>
</I>&gt;<i> With regards to change tracking, the last time I looked, DLINQ objects raise
</I>&gt;<i> a PropertyChanging (INotifyPropertyChanging, part of System.ComponentModel )
</I>&gt;<i> event when properties are changed. Since it is your QueryProvider (the
</I>&gt;<i> DataContext) which is returning the objects, it can subscribe to these
</I>&gt;<i> events and use them to builds its hashtable when updateable items are
</I>&gt;<i> modified.
</I>&gt;<i>
</I>&gt;<i> So a Dictionary&lt;Row, Change&gt; (where a &quot;Change&quot; represents the original and
</I>&gt;<i> new value), as you suggested, would seem like the way to go to me.
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>
</I>&gt;<i> Paul
</I>&gt;<i>  www.paulstovell.net
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On 9/21/07, Kevin Kubasik &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">kevin at kubasik.net</A>&gt; wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Ok, so I've been able to create a pretty generic (if highly adaptable)
</I>&gt;<i> &gt; IQueryProvider which implements very basic Linq -&gt; Sql support(More on
</I>&gt;<i> &gt; that later). This project was to better understand the roll played by
</I>&gt;<i> &gt; different components in the linq-&gt;sql pipeline. While the more
</I>&gt;<i> &gt; complicated and optimized we try to make the Linq-SQL conversion, the
</I>&gt;<i> &gt; harder it becomes, the core of implementing a Provider is pretty easy.
</I>&gt;<i> &gt; We could write custom _query_ providers all day long and have linq to
</I>&gt;<i> &gt; the world. The problem is that we want updates, deletes, sprocs etc.
</I>&gt;<i> &gt; That is where the DataContext comes in, and my headaches start.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The principal of the DataContext is easy enough, its like the ADO.NET
</I>&gt;<i> &gt; 2.0 DataSets in that it can be generated as a strongly-typed extension
</I>&gt;<i> &gt; of the core DataContex, or as a generic and adaptable class. The
</I>&gt;<i> &gt; DataContext sits in System.Data.Linq, and is the gatekeeper between
</I>&gt;<i> &gt; the query language and a provider. In addition to just being in the
</I>&gt;<i> &gt; way, the DataContext provides metadata about a database, has an
</I>&gt;<i> &gt; understanding of tables and relationships, as well as stored
</I>&gt;<i> &gt; procedures. It is also responsible for object caches.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This is all fun and good, with some decent mapping code we can do all
</I>&gt;<i> &gt; that without breaking a sweat. The problem is
</I>&gt;<i> &gt; DataContext.SubmitChanges(). As tables are manipulated etc. these
</I>&gt;<i> &gt; changes are tracked in-memory (or some other awesometastic way) and
</I>&gt;<i> &gt; eventually either reverted or submitted. More importantly, to anyone
</I>&gt;<i> &gt; using the DataContext's tables gets the modified information. Again,
</I>&gt;<i> &gt; things don't sound too bad, and there are already implementations
</I>&gt;<i> &gt; (DataTable, DataSet etc.). The difference is they have all the data,
</I>&gt;<i> &gt; and execute a modification upon call, then store the old value and the
</I>&gt;<i> &gt; current state of the data. Linq is all deferred execution, we don't
</I>&gt;<i> &gt; have an in memory representation of the data on the database, we just
</I>&gt;<i> &gt; have a list of instructions, each of which will return a result.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So, basically I've determined that out DataContext will have to track
</I>&gt;<i> &gt; everything happening in each of its tables. This got me thinking, an
</I>&gt;<i> &gt; event driven model would be perfect, we would only act when actual
</I>&gt;<i> &gt; action was being taken.  Now, I basically have both ends of the
</I>&gt;<i> &gt; spectrum, we get every object associated with an expression utilizing
</I>&gt;<i> &gt; a DataContext, and flag it in our cool DiffTracker, using a Dictionary
</I>&gt;<i> &gt; or Hashtable for fast lookups based upon the entity itself, then we
</I>&gt;<i> &gt; process each event as it happens (which is pretty much the last thing
</I>&gt;<i> &gt; an expression will do). I think we can get away with only the current
</I>&gt;<i> &gt; state of each noteworthy object and the most recent past.I figure if
</I>&gt;<i> &gt; the state is Insert, who cares what the object was before, if the
</I>&gt;<i> &gt; state is Update, we just update all values to their current value,
</I>&gt;<i> &gt; selecting on the old object, and if its delete.... yeah. There is a
</I>&gt;<i> &gt; States.cs Enum in the System.Data.Linq directory with all the states a
</I>&gt;<i> &gt; DataContext  is aware of.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The problem is the massive middleman, I've gotten absolutely worlds
</I>&gt;<i> &gt; better with some of C#'s more advanced language structures in the few
</I>&gt;<i> &gt; days I've been working on this, but I am not 100% sure of hows the
</I>&gt;<i> &gt; best way to go about this. As a result, I would really love some help.
</I>&gt;<i> &gt; I can get the DataContext to respond intelligently to Linq queries,
</I>&gt;<i> &gt; and continue to process the subtree into a table. Once we are at that
</I>&gt;<i> &gt; point, its all on the individual Sql implementation (which isn't
</I>&gt;<i> &gt; important yet, and isn't really on the immeidate radar.).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If someone could help me out a bit with the actual construction of the
</I>&gt;<i> &gt; DiffTracker and DiffWrapper classes, it would be greatly appreciated.
</I>&gt;<i> &gt; You aren't obligated to use my design, or even help at all. But I
</I>&gt;<i> &gt; would _greatly_ appreciate some feedback or any ideas anyone has about
</I>&gt;<i> &gt; this. Specifically with regard too keeping this light and simple, as I
</I>&gt;<i> &gt; feel like it could quickly become a massive buggy mess.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; --
</I>&gt;<i> &gt; Cheers,
</I>&gt;<i> &gt; Kevin Kubasik
</I>&gt;<i> &gt; <A HREF="http://kubasik.net/blog">http://kubasik.net/blog</A>
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-devel-list mailing list
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt;
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>

-- 
Cheers,
Kevin Kubasik
<A HREF="http://kubasik.net/blog">http://kubasik.net/blog</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024986.html">[Mono-dev] DataContext Implementation Advice
</A></li>
	<LI>Next message: <A HREF="024993.html">[Mono-dev] C bindings VS C++ bindings (Gtk# vs. Kimono?)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24987">[ date ]</a>
              <a href="thread.html#24987">[ thread ]</a>
              <a href="subject.html#24987">[ subject ]</a>
              <a href="author.html#24987">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
