<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] HTTPS - MS .NET Client - Linux Mono Server -	Interoperability
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20HTTPS%20-%20MS%20.NET%20Client%20-%20Linux%20Mono%20Server%20-%0A%09Interoperability&In-Reply-To=1127900562.3865.133.camel%40localhost.localdomain">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014994.html">
   <LINK REL="Next"  HREF="014995.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] HTTPS - MS .NET Client - Linux Mono Server -	Interoperability</H1>
    <B>Sebastien Pouliot</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20HTTPS%20-%20MS%20.NET%20Client%20-%20Linux%20Mono%20Server%20-%0A%09Interoperability&In-Reply-To=1127900562.3865.133.camel%40localhost.localdomain"
       TITLE="[Mono-dev] HTTPS - MS .NET Client - Linux Mono Server -	Interoperability">sebastien.pouliot at gmail.com
       </A><BR>
    <I>Wed Sep 28 08:12:15 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="014994.html">[Mono-dev] HTTPS - MS .NET Client - Linux Mono Server -	Interoperability
</A></li>
        <LI>Next message: <A HREF="014995.html">[Mono-dev] Default code page used by mcs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15004">[ date ]</a>
              <a href="thread.html#15004">[ thread ]</a>
              <a href="subject.html#15004">[ subject ]</a>
              <a href="author.html#15004">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Yngve,

On Wed, 2005-28-09 at 11:42 +0200, Yngve Zackrisson wrote:
&gt;<i> Hello Sebastien,
</I>&gt;<i> 
</I>&gt;<i> Things seems to go better for me, 
</I>
great :)

&gt;<i> but I still have problems 
</I>&gt;<i> with my server side (Mono) authentication and decryption.
</I>&gt;<i> I now use a PKCS#12 file on my server side.
</I>&gt;<i> Se below for more info.
</I>
...

&gt;<i> &gt; &gt; For the authentication probably an custom channel have to be used.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I don't see why this would be required (for client-side certificates) as
</I>&gt;<i> &gt; the authentication is part of the protocol itself.
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> OK. Maybe I do not need this.
</I>&gt;<i> I just read some articles/samples at msdn about 
</I>&gt;<i> .NET Remoting Authentication 
</I>&gt;<i> and those articles suggested a custom channel.
</I>&gt;<i> (<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dndotnet/html/remsspi.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dndotnet/html/remsspi.asp</A> and <A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dndotnet/html/remsec.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dndotnet/html/remsec.asp</A>
</I>&gt;<i> and
</I>&gt;<i> <A HREF="http://msdn.microsoft.com/msdnmag/issues/03/06/NETRemoting/default.aspx">http://msdn.microsoft.com/msdnmag/issues/03/06/NETRemoting/default.aspx</A>
</I>&gt;<i> ). 
</I>&gt;<i> The examples was about other forms of authentication (Kerberos etc) 
</I>&gt;<i> and encryption so these references may not apply?.
</I>
I don't think you'll need that unless you have some additional (more
than the client certificate) authentication data.

...

&gt;<i> We intend to sign both our server and client certificates 
</I>&gt;<i> with our own root CA.
</I>&gt;<i> There is already unix scripts for this using openssl, 
</I>&gt;<i> hence the preference for openssl.
</I>
Ok, so you'll have a single root CA signing both your server and client
certificate. This root certificate will have to be in the Mono's Trusted
store on the server.

...

&gt;<i> &gt; &gt; Binary formating shall be used.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Was there a specific reason for using https and a binary formatting ? If
</I>&gt;<i> &gt; I understand correctly you'll be supplying your own server software ? so
</I>&gt;<i> &gt; you _could_ use SSL without using HTTP(S).
</I>&gt;<i> 
</I>&gt;<i> Firewalls.
</I>
Ok, so it's a port issue (not a protocol issue).

&gt;<i> &gt; &gt; The server is in house and should be a Linux one.
</I>&gt;<i> &gt; &gt; We use latest version on Mono (1.1.9).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Is the server software using Mono.Security.dll ? 
</I>&gt;<i> &gt; or is it using (vanilla or custom) XSP ?
</I>&gt;<i> 
</I>&gt;<i> Currently Mono.Security.dll.
</I>&gt;<i> 
</I>&gt;<i> The intention is to run the services as &quot;Windows services&quot; in Mono,
</I>&gt;<i> if that works.
</I>
Remember that if the Mono service runs under another identity then the
trusted root certificate must either be (a) in that user Trust store or
(b) in the machine Trust store.

&gt;<i> I have not got into this yet, so we might have to shift.
</I>&gt;<i> Currently I host the remote objects in a console application.
</I>&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; The clients are Win32 clients using MS .NET 
</I>&gt;<i> &gt; &gt; (v1.0 or v1.1 with SP enough to handle the certificates).
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; The clients are not connected all the time, but only during 
</I>&gt;<i> &gt; &gt; initialization and zip file transfer.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; The installation on the client side should be as simple as possible 
</I>&gt;<i> &gt; &gt; for the clients. 
</I>&gt;<i> &gt; &gt; Hence, preferable PKCS#12 client certificates should be used 
</I>&gt;<i> &gt; &gt; and it should preferable be stored only in one file or in one store 
</I>&gt;<i> &gt; &gt; (Windows store).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; You'll either have to :
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; (a) write your own glue (p/invokes) if you want Mono.Security.dll to
</I>&gt;<i> &gt; co-exists with Windows certificate stores;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; (b) completely skip Mono.Security.dll on the client side. I.e. once
</I>&gt;<i> &gt; installed &quot;correctly&quot; the MS runtime should be able to &quot;find&quot; the
</I>&gt;<i> &gt; private key matching the certificate you use in HttpWebRequest.
</I>&gt;<i> 
</I>&gt;<i> OK. I have gone for (b).
</I>&gt;<i> 
</I>&gt;<i> First I set the ServicePointManager.CertificatePolicy 
</I>&gt;<i> to an custom class to detect any certificate errors.
</I>&gt;<i> 
</I>&gt;<i> Then I use a DLL from Mentalis (Org.Mentalis.Security.dll) 
</I>&gt;<i> to extract the client certificates from the Windows store, 
</I>&gt;<i> and then select on the IssuerName.
</I>&gt;<i> Once that done, I use the Mentalis Certificate.ToX509() method 
</I>&gt;<i> to convert to X509Certificate(s).
</I>&gt;<i> (See: <A HREF="http://www.mentalis.org/">http://www.mentalis.org/</A> and 
</I>&gt;<i> <A HREF="http://www.mentalis.org/soft/projects/certificates/">http://www.mentalis.org/soft/projects/certificates/</A> ).
</I>&gt;<i> 
</I>&gt;<i> Last I create the HttpWebRequest, 
</I>&gt;<i> Add the X509Certificate(s) the requests ClientCertificates 
</I>&gt;<i> and set the WebResponse to the HttpWebRequest.GetResponse().
</I>&gt;<i> It seems to work (on the client side). 
</I>&gt;<i> No more &quot;Untrusted root&quot;, since the certificates 
</I>&gt;<i> is in the Windows store now.
</I>
That's ok.

&gt;<i> Other options for extracting the certificate(s) 
</I>&gt;<i> from the Windows store seems to be: 
</I>&gt;<i> 
</I>&gt;<i> Using CryptoAPI calls:
</I>&gt;<i> <A HREF="http://support.microsoft.com/default.aspx?scid=kb;en-us;895971">http://support.microsoft.com/default.aspx?scid=kb;en-us;895971</A>
</I>&gt;<i> 
</I>&gt;<i> Using a CAPICOM wrapper: 
</I>&gt;<i> <A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncapi/html/netcryptoapi.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncapi/html/netcryptoapi.asp</A>
</I>&gt;<i> 
</I>&gt;<i> Using WS-Security with the Web Service Developement Kit:
</I>&gt;<i> <A HREF="http://www.codeproject.com/csharp/cryptography.asp">http://www.codeproject.com/csharp/cryptography.asp</A>
</I>
Yes, they are the other options.

&gt;<i> &gt; &gt; As a first step, I would like to have the HttpWebRequest 
</I>&gt;<i> &gt; &gt; and HttpWebResponse to work toghther with HTTPS.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; MS version of HttpWebRequest.ClientCertificates will &quot;try to find&quot;
</I>&gt;<i> &gt; private keys (in it's store) associated with the certificate(s) you're
</I>&gt;<i> &gt; supplying.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Note that you may have problems if the client application runs on
</I>&gt;<i> &gt; another identity (e.g. services runs as SYSTEM).
</I>&gt;<i> 
</I>&gt;<i> OK. (Seems no problem for me).
</I>&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Then, on the server side, you'll get this certificate (from
</I>&gt;<i> &gt; SslServerStream) and you can validate it (with your own code) and decide
</I>&gt;<i> &gt; what to do next...
</I>&gt;<i> 
</I>&gt;<i> Here I still have problems.
</I>&gt;<i> 
</I>&gt;<i> I have created a mssslserver2.exe based on your mssslserver.exe.
</I>&gt;<i> The difference is that mssslserver2.exe uses 
</I>&gt;<i> a PKCS#12-filename and a password as arguments, 
</I>&gt;<i> instead of a .cer-filename and .pvk-filename.
</I>&gt;<i> I have change the internals accordingly.
</I>&gt;<i> 
</I>&gt;<i> When I run this program with: 
</I>&gt;<i> 
</I>&gt;<i> $ mono --debug --verbose mssslserver2.exe server16-cert.p12 'password'
</I>&gt;<i> 
</I>&gt;<i> and call this with my client HttpWebRequest, 
</I>&gt;<i> I got this error message on my server: 
</I>&gt;<i> 
</I>&gt;<i>     error #-2146762486
</I>&gt;<i> 
</I>&gt;<i> meaning a CERT_E_CHAINING problem 
</I>&gt;<i> (also: X509ChainStatusFlags.UntrustedRoot 
</I>&gt;<i> and AlertDescription.UnknownCA).
</I>&gt;<i> 
</I>&gt;<i> I am pretty sure I have the right cert, key and CA in the .p12 file.
</I>&gt;<i> It seems that the root CA could not be found if it is in a PKCS#12 file.
</I>
The root can (very probably) be found in the PKCS#12 file. However it
_cannot_ be trusted *unless* it's installed in the Trust store.

&gt;<i> Should I add a PKCS#12 cert file to the Mono Store (Machine store) 
</I>&gt;<i> (mono /.../certmgr.exe -add -c -m Trust server16-cert.p12) 
</I>&gt;<i> or add only the CA to the trust store
</I>&gt;<i> (mono /.../certmgr.exe -add -c -m Trust cacert16t.cer)
</I>&gt;<i> or anything else to get rid of this error message?.
</I>
It must be either the user or machine Trusted store (otherwise you'll
get a trust error).

&gt;<i> On the server I get an exception during the client call 
</I>&gt;<i> (in: reader.ReadLine ()) below: 
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> ...
</I>&gt;<i> using (SslServerStream s = new SslServerStream (ns, Certificate, true, 
</I>&gt;<i> false)) {
</I>&gt;<i> ... 
</I>&gt;<i> StreamReader reader = new StreamReader (s);
</I>&gt;<i> ...
</I>&gt;<i> string line;
</I>&gt;<i> // Read request header 
</I>&gt;<i> do {
</I>&gt;<i>         line = reader.ReadLine ();
</I>&gt;<i> ...
</I>&gt;<i> &lt;&lt;&lt;
</I>&gt;<i> 
</I>&gt;<i> The exception goes like this:
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> EXCEPTION handling: TlsException
</I>&gt;<i> EXCEPTION handling: TlsException
</I>&gt;<i> EXCEPTION handling: IOException
</I>&gt;<i> EXCEPTION handling: IOException
</I>&gt;<i> ---------------------------------------------------------
</I>&gt;<i> System.IO.IOException: The authentication or decryption has failed. ---&gt;
</I>&gt;<i> Mono.Security.Protocol.Tls.TlsException: Handshake Failure.
</I>&gt;<i> in &lt;0x00134&gt; 
</I>&gt;<i> Mono.Security.Protocol.Tls.Handshake.Server.TlsClientCertificateVerify:ProcessAsSs3  ()
</I>&gt;<i> in &lt;0x00057&gt; 
</I>&gt;<i> Mono.Security.Protocol.Tls.Handshake.HandshakeMessage:Process ()
</I>&gt;<i> in (wrapper remoting-invoke-with-check) 
</I>&gt;<i> Mono.Security.Protocol.Tls.Handshake.HandshakeMessage:Process ()
</I>&gt;<i> in &lt;0x00084&gt; 
</I>&gt;<i> Mono.Security.Protocol.Tls.ServerRecordProtocol:ProcessHandshakeMessage 
</I>&gt;<i> (Mono.Security.Protocol.Tls.TlsStream handMsg)
</I>&gt;<i> in &lt;0x00239&gt; 
</I>&gt;<i> Mono.Security.Protocol.Tls.RecordProtocol:InternalReceiveRecordCallBack 
</I>&gt;<i> (IAsyncResult asyncResult)--- End of inner exception stack trace ---
</I>&gt;<i> 
</I>&gt;<i> in &lt;0x000d4&gt; 
</I>&gt;<i> Mono.Security.Protocol.Tls.SslStreamBase:AsyncHandshakeCallback
</I>&gt;<i> (IAsyncResult asyncResult)
</I>&gt;<i> &lt;&lt;&lt;
</I>&gt;<i> 
</I>&gt;<i> I guess that this has to do with the CERT_E_CHAINING problem 
</I>&gt;<i> mentioned above. Possible?. Right?
</I>
Maybe but I don't think so.

Yesterday (after your previous email) I tried to use the MS runtime for
client certificate without success (same failure). Somehow MS does
something different* because the server can't verify the signature (and
it's not a key and/or decryption problem - the hash value is different
but the padding is ok).

Using IE (with the SSL2 client hello) to do the same turned out another
problem, very similar to the bug #76254 reported today.

[*] The client certificate testing is done with wget/openssl
(linux/cygwin) - which sadly doesn't seems enough :(
-- 
Sebastien Pouliot
email: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>
blog: <A HREF="http://pages.infinit.net/ctech/">http://pages.infinit.net/ctech/</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014994.html">[Mono-dev] HTTPS - MS .NET Client - Linux Mono Server -	Interoperability
</A></li>
	<LI>Next message: <A HREF="014995.html">[Mono-dev] Default code page used by mcs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15004">[ date ]</a>
              <a href="thread.html#15004">[ thread ]</a>
              <a href="subject.html#15004">[ subject ]</a>
              <a href="author.html#15004">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
