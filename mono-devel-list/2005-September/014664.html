<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] embedded runtime questions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20embedded%20runtime%20questions&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014663.html">
   <LINK REL="Next"  HREF="014677.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] embedded runtime questions</H1>
    <B>Allan Hsu</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20embedded%20runtime%20questions&In-Reply-To="
       TITLE="[Mono-dev] embedded runtime questions">allan at counterpop.net
       </A><BR>
    <I>Fri Sep  9 17:06:00 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="014663.html">[Mono-dev] Compile npgsql?
</A></li>
        <LI>Next message: <A HREF="014677.html">[Mono-dev] embedded runtime questions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14664">[ date ]</a>
              <a href="thread.html#14664">[ thread ]</a>
              <a href="subject.html#14664">[ subject ]</a>
              <a href="author.html#14664">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Some of us from imeem will be at PDC next week and we'll definitely  
be at the Mono meeting on Tuesday. I'd love to meet some of you guys  
and provide a look at what we're doing with Mono.

Now, on to some questions I have regarding the Mono embedded C API:

1. Under the Mono 1.1.8.1, (most recent release made for OS X), the  
instructions from the Wiki entry  (<A HREF="http://mono-project.com/">http://mono-project.com/</A> 
Embedding_Mono#Threading_issues) to call mono_thread_attach don't  
work in all situations. I get an error telling me to include &lt;gc.h&gt;  
before &lt;pthread.h&gt;, which is impossible for me to do in the cases  
where the current thread was not created by my own code.

Instead, I've been using mono_thread_create in an Objective-C  
NSThread poser class. Is it safe to do this? This function is not  
mentioned in the Wiki entry. If so, is there any additional setup/ 
teardown I need to perform? It seems to work, but I'm unsure as to  
whether or not I'm being totally clean about it.

2. Is there a facility to get a MonoMethod* that is more specific  
than mono_class_get_method_from_name? This works fine until you have  
multiple methods with the same name and the same number of arguments.  
I've been able to work around the problems I've had by tweaking my C#  
code (renaming methods, etc), but I could see this being a problem  
for people that are calling into corlib or other C# assemblies that  
are not their own.

3. Is there any way to reduce method invocation overhead past caching  
MonoMethod*s? I notice that mono_jit_runtime_invoke in mini.c emits  
and compiles an invocation wrapper with this function prototype:

MonoObject *(*runtime_invoke) (MonoObject *this, void **params,  
MonoObject **exc, void* compiled_method);

As far as I can tell, every time mono_jit_runtime_invoke is called,  
it has to make sure that the MonoMethod in question is inflated and  
JITed and that it there is also an invocation wrapper emitted and  
JITed before actually calling the runtime_invoke function. I would  
love to be able to cache pointers to both the compiled method as well  
as the invocation wrapper, so that I could do something like this,  
avoiding the lookup overhead in mono_jit_runtime_invoke:

MonoObject *result = someCachedRuntimeInvoke(someObject, monoArgs,  
&amp;monoException, someCachedCompiledMethod);

Even better would be if it were possible to JIT the invocation  
wrapper in such a way that saving a pointer to the compiled method  
were not necessary.

Here are some of my informal benchmarking numbers on function calling/ 
message passing/method invocation overhead on a 2Ghz G5 iMac. The  
numbers are average call times for nop methods called several hundred  
thousand times:

Objective-C message passing: ~.055 usec
C# method calls: ~0.04 usec
Full, non-cached embedded Mono C API lookup/invocation (parent  
lookup, etc): ~6 usec
locally saved Mono C API (using the same MonoMethod* over and over):  
~2.9 usec
self-written caching, using Judy Arrays: ~3.2 usec

I'm currently using a caching scheme that uses (MonoClass*, method  
name, number of arguments) as a key that maps to MonoMethod*  
pointers. I'm hoping I can reduce call overhead further by mapping  
the same key straight to function pointers. What do you think? The  
unmanaged thunk proposal in the embedding page sounds interesting,  
but I'd be happy with something more complicated.

See you guys next week at PDC.

-Allan
--
Allan Hsu &lt;allan at counterpop dot net&gt;
1E64 E20F 34D9 CBA7 1300  1457 AC37 CBBB 0E92 C779



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014663.html">[Mono-dev] Compile npgsql?
</A></li>
	<LI>Next message: <A HREF="014677.html">[Mono-dev] embedded runtime questions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14664">[ date ]</a>
              <a href="thread.html#14664">[ thread ]</a>
              <a href="subject.html#14664">[ subject ]</a>
              <a href="author.html#14664">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
