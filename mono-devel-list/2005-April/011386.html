<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] UDP 40%+ loss
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20UDP%2040%25%2B%20loss&In-Reply-To=20050404151504.2533F124684%40lists.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011383.html">
   <LINK REL="Next"  HREF="011400.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] UDP 40%+ loss</H1>
    <B>marcusmonaghan at f2s.com</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20UDP%2040%25%2B%20loss&In-Reply-To=20050404151504.2533F124684%40lists.ximian.com"
       TITLE="[Mono-devel-list] UDP 40%+ loss">marcusmonaghan at f2s.com
       </A><BR>
    <I>Mon Apr  4 12:03:52 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011383.html">[Mono-devel-list] UDP 40%+ loss
</A></li>
        <LI>Next message: <A HREF="011400.html">[Mono-devel-list] UDP 40%+ loss
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11386">[ date ]</a>
              <a href="thread.html#11386">[ thread ]</a>
              <a href="subject.html#11386">[ subject ]</a>
              <a href="author.html#11386">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for the reply Jason.

I didn't post code initially as I was just seeing if there was a &quot;ah yes, we
know about that one&quot; answer.

So as there doesn't seem to be that, here is the code snippets. I have exluded
obtaining settings:

C code:
        while (TRUE) /* receive (and pass on) loop */
        {
            /* Now clear buffers ready for next iteration */
            memset(buffer, '\0', BUFLEN);
            memset(outbuf, '\0', BUFLEN);

            /* Let select know which file descriptor we want to wait on */
            FD_SET(multicast_socket, &amp;read_set);
            /* If we are not using a file then add the tcp socket to the set */
            if (message_file &lt;= FAILURE) FD_SET(tcp_socket, &amp;read_set);

            /* Select needs to know the maximum file descriptor to look for. We
could specify FS_SETSIZE which is defined as 256 but
               this would meen the kernal would be checking for extra file
descriptors that did not exist. */
            if (multicast_socket &gt; tcp_socket || message_file &gt;= VALID)
                max_fd = multicast_socket + 1;
            else
                max_fd = tcp_socket + 1;

            /* Now select and wait for a signal */
            now_msg(0, &quot;Waiting on select ...\n&quot;, errno);
            selected_fd = select(max_fd, &amp;read_set, NULL, NULL, NULL);
            now_msg(1, &quot;After select ...\n&quot;, errno);

            /* We have a connection so reset the connection_try indicator */
            connection_try=0;

            if (selected_fd == FAILURE)
            {
                now_msg_err(0, errno, &quot;Error on select&quot;);
                break;
            }
            if (selected_fd == TIMEOUT)
            {
                /* Currently this isn't supported so shouldn't be called yet */
                now_msg(0, &quot;Select timed out ... POLL&quot;);

                /* Need to clear here as we are resetting at the top of the loop
*/
                FD_CLR(multicast_socket, &amp;read_set);
                FD_CLR(tcp_socket, &amp;read_set);
                continue;
            }

            if ((message_file &lt;= FAILURE) &amp;&amp; FD_ISSET(tcp_socket, &amp;read_set))   
    /* Data available on tcp socket, only if not using a file */
            {

.. Doesn't fire!!!

            }   /* End of data available on TCP socket */

            if (FD_ISSET(multicast_socket, &amp;read_set))  /* Data available on udp
socket */
            {
                bytes_received=recvfrom(multicast_socket, buffer, BUFLEN, 0,
NULL, NULL); /* get one message at a time (as it is UDP) */
                if(bytes_received==FAILURE)
                {
                    now_msg_err(0, errno, &quot;Error receiving multicast messages&quot;);
                    break;
                }
                /* Let the user know what we have received (remove a linefeed if
one is already there due to testing) */
                if (buffer[bytes_received - 1] == '\n')
                {
                    now_msg(5, &quot;removing LF from input\n&quot;);
                    buffer[--bytes_received] = 0;
                }
                now_msg(0, &quot;&lt;&lt;&lt;[%d][%s]\n&quot;, bytes_received, buffer);
                if (add_ascii_header == TRUE)
                {
.. No longer used
                }
                else
                {
                    sprintf(outbuf, &quot;\&quot;%s\&quot;\n&quot;, buffer);
                }
                bytes_to_send = strlen(outbuf);

                /* Depending on whether or not a file has been specified send to
to a tcp server or write it to a file */
                if (message_file &gt;= VALID) /* File provided */
                {
                    now_msg(5, &quot;Writing to file [%d]\n&quot;, bytes_to_send);
                    bytes_sent=write(message_file, outbuf, bytes_to_send);
                }
                else
                {
                    now_msg(5, &quot;Writing to socket [%d]\n&quot;, bytes_to_send);
                    bytes_sent=send(tcp_socket, outbuf, bytes_to_send, 0 );	/*
write the message - 0 = no options */
                }

                outbuf[bytes_to_send] = 0; /* for the record, remove the \n, but
retain real length for checking purposes */
                now_msg(0, &quot;&gt;&gt;&gt;[%d][%s]\n&quot;, bytes_sent, outbuf);
            }   /* End of data available on udp socket */
        } /* listener failed */

c# Code

	public class MulticastClient
	{
		#region Member Variables
		private string _multicastAddress = string.Empty;
		private int _multicastPort = 0;
		#endregion Member Variables

		#region Variables
		private int messageCount = 0;
		private IPAddress multicastAddress;
		private Socket multicastSocket;
		#endregion Variables

		#region Constructors
		public MulticastClient(string MulticastGroup, int MulticastPort)
		{
			new MulticastClient(MulticastGroup, MulticastPort, true);
		}

		public MulticastClient(string MulticastGroup, int MulticastPort, bool
StartImmediately)
		{
			_multicastAddress = MulticastGroup;
			_multicastPort = MulticastPort;

			// Do we want to start?
			if (StartImmediately) { StartListening(); }
		}

		#endregion Constructors

		#region Properties
		public string HostAddress
		{
			get
			{
				return _multicastAddress;
			}
			set
			{
				// TODO: Only allow the setting of the property if the client is not active

				if (value != _multicastAddress)
				{
					_multicastAddress = value;
				}
			}
		}

		public int Port
		{
			get
			{
				return _multicastPort;
			}
			set
			{
				// TODO: Only allow the setting of the property if the client is not active
				_multicastPort = value;
			}
		}
		#endregion

		#region Methods

		private void ConfigureMulticastSocket()
		{
			// Assign the local address automatically
			EndPoint localEndPoint;
			MulticastOption multicastOption;
			IPAddress localIPAddress = IPAddress.Any;	// TODO: Possibly need to change
this to be specific

			// Configure the multicast address object
			multicastAddress = IPAddress.Parse(_multicastAddress);

			// Create the socket object
			// TODO: Make sure the socket is not already active
			multicastSocket = new Socket(AddressFamily.InterNetwork,
				SocketType.Dgram, ProtocolType.Udp);

			// Now create an end point for this end. Local IP address with the multicast
port
			localEndPoint = (EndPoint)new IPEndPoint(localIPAddress, _multicastPort);

			// Bind the socket object to the end point
			multicastSocket.Bind(localEndPoint);

			// Now set the multicast options
			multicastOption = new MulticastOption(multicastAddress, localIPAddress);
			multicastSocket.SetSocketOption(SocketOptionLevel.IP,
				SocketOptionName.AddMembership,
				multicastOption);

		}

		private void StartListening()
		{
			bool complete = false;		// Flag to indicate completion of processing loop
			IPEndPoint groupEndPoint;	// The end point to the group
			EndPoint remoteEndPoint;	// The other end of the socket
			byte[] recievedBytes = new byte[10000];	// Bytes to receive
			int recievedByteCount = 0;	// Number of bytes recieved

			// Configure the socket and start listening
			ConfigureMulticastSocket();

			// Configure the end point for the group
			groupEndPoint = new IPEndPoint(multicastAddress, _multicastPort);

			// Configure the other end point or where we want to retrieve data from.
			// For this example we are going to accept data from anywhere, but
			// we should be able to specify where we want to receive data from.
			// Port 0 is given to allow the framework/OS to decide what is used.
			remoteEndPoint = (EndPoint) new IPEndPoint(IPAddress.Any, 0);

			// Wait for data
			// TODO: This should be asynchronous
			try
			{
				while(!complete)
				{
					Console.WriteLine(&quot;Waiting for multicast messages ...&quot;);

					// Wait for some data
					recievedByteCount = multicastSocket.ReceiveFrom(recievedBytes, ref
remoteEndPoint);

					// Show we have got something
					Console.WriteLine(&quot;Received {2}: {0} from {1}&quot;,
						Encoding.ASCII.GetString(recievedBytes, 0, recievedByteCount),
						remoteEndPoint.ToString(),
						++messageCount);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}


		}

		#endregion Methods

	}


As you can see the c# code is no where near complete compared to the C code. It
has less processing, but still manages to miss the messages. The only thing I
can think of is to remove the Console.Writelines and log the messages to a log
file. Just incase this is actually causing the issue (overhead of writing out
to the console is more than writing to a file perhaps).

Marcus.



Quoting Jason Starin | Giant Head &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jasonstarin at giant-head.com</A>&gt;:

&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  Hi Marcus,
</I>&gt;<i>
</I>&gt;<i>   First off, without code, I feel like I'm going into this question blind,
</I>&gt;<i> but I do have a similar example that I did find a solution for.
</I>&gt;<i>
</I>&gt;<i> I had a web service that was capturing web requests from several different
</I>&gt;<i> forms, it then incremented a database, and then sent confirmation mails as
</I>&gt;<i> well as lead emails to different targets, based upon the web data.  I had
</I>&gt;<i> all exceptions mailed to me, and it allowed me a little time to figure out
</I>&gt;<i> about how to configure my application to work well with xsp.
</I>&gt;<i>
</I>&gt;<i> Here's the general idea:
</I>&gt;<i>
</I>&gt;<i> 1.  I made receipt of requests a top priority process, running on a separate
</I>&gt;<i> service, so that I always received requests.  I had those requests write to
</I>&gt;<i> a common xml file that was hosted in memory.  Whenever my requests exceeded
</I>&gt;<i> 1000 or so a minute, the service would crash if I was trying to write a file
</I>&gt;<i> to disk, so instead, I had a single write at the end of each minute as part
</I>&gt;<i> of a separate thread.
</I>&gt;<i>
</I>&gt;<i> 2.  Database updates seem to be slow using the ByteFX and the MySql.Data
</I>&gt;<i> ADO.net connections.  I built a timer that updated with the common XML file
</I>&gt;<i> every 4 minutes.  That reduced the total number of database requests to a
</I>&gt;<i> manageable number that gave them plenty of time to finish (all of my
</I>&gt;<i> requests seem to take between 9 and 15 seconds to run almost regardless of
</I>&gt;<i> their size).
</I>&gt;<i>
</I>&gt;<i> 3.  Because mail services (I'm using sendmail on RedHat Fedora Core 2, but I
</I>&gt;<i> also tested SMTP on a Win2k3 with Mono box) seemed to flake out on repeated
</I>&gt;<i> connections, I batched emails, and sent them in groups, every ten minutes.
</I>&gt;<i> If I allowed each process to send an email message, immediately, my dual
</I>&gt;<i> processor server seemed to choke on all of the connections, and eventually
</I>&gt;<i> XSP would crash and take apache with it.  On Windows, I'd have a great big
</I>&gt;<i> collection of emails bogged down in my logs, needing to be resent.
</I>&gt;<i>
</I>&gt;<i> Frankly, I don't think these are bugs, but more along the lines of
</I>&gt;<i> enviornmental constraints, that you can adapt to if you map out the process
</I>&gt;<i> and look for where things are flaking out.  Perhaps establish a separate log
</I>&gt;<i> file to watch each step through your process, and save at the end of your
</I>&gt;<i> test?
</I>&gt;<i>
</I>&gt;<i> Send code if you get a chance, I'm interested to see where I can help, and
</I>&gt;<i> have you thought about testing your C# app on a windows machine?
</I>&gt;<i>
</I>&gt;<i> Interesting problem,
</I>&gt;<i> Jason
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  From: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list-admin at lists.ximian.com</A>
</I>&gt;<i> [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list-admin at lists.ximian.com</A>] On Behalf Of
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">marcusmonaghan at f2s.com</A>
</I>&gt;<i> Sent: Monday, April 04, 2005 10:37 AM
</I>&gt;<i> To: Mono Help
</I>&gt;<i> Subject: [Mono-devel-list] UDP 40%+ loss
</I>&gt;<i>
</I>&gt;<i> All,
</I>&gt;<i>
</I>&gt;<i> I am trying to re-creating a C program in C# mono (as there are more C#
</I>&gt;<i> developers in our company now) and it seems it's not behaving in the
</I>&gt;<i> expected
</I>&gt;<i> way.
</I>&gt;<i>
</I>&gt;<i> The program is very simple. It listens on a multicast group, receives data
</I>&gt;<i> and
</I>&gt;<i> writes it to a file. The problem is that I'm seeing roughly 40%+ missed
</I>&gt;<i> messages when compared to the C program. I ran the C# and C program on the
</I>&gt;<i> same
</I>&gt;<i> box. On another box I send out 100 messages in 10 second bursts. The C
</I>&gt;<i> program
</I>&gt;<i> receives all of them whereas the C# program only receive 60 on the first
</I>&gt;<i> burst
</I>&gt;<i> 50 on the second 55 on the third and so on.
</I>&gt;<i>
</I>&gt;<i> I then (just for a laugh) unthrottled the sending program. It sent 51,000
</I>&gt;<i> messages, all of which where received by the C program. The c# program
</I>&gt;<i> recorded
</I>&gt;<i> 7152.
</I>&gt;<i>
</I>&gt;<i> Anyone got any ideas? Possibly a bug?
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Marcus
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>

Regards,
Marcus

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011383.html">[Mono-devel-list] UDP 40%+ loss
</A></li>
	<LI>Next message: <A HREF="011400.html">[Mono-devel-list] UDP 40%+ loss
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11386">[ date ]</a>
              <a href="thread.html#11386">[ thread ]</a>
              <a href="subject.html#11386">[ subject ]</a>
              <a href="author.html#11386">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
