<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] SSA and try/catch/finally regions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20SSA%20and%20try/catch/finally%20regions&In-Reply-To=295e750a05040413231b11f867%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011396.html">
   <LINK REL="Next"  HREF="011397.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] SSA and try/catch/finally regions</H1>
    <B>Massimiliano Mantione</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20SSA%20and%20try/catch/finally%20regions&In-Reply-To=295e750a05040413231b11f867%40mail.gmail.com"
       TITLE="[Mono-devel-list] SSA and try/catch/finally regions">massi at ximian.com
       </A><BR>
    <I>Tue Apr  5 03:05:20 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011396.html">[Mono-devel-list] SSA and try/catch/finally regions
</A></li>
        <LI>Next message: <A HREF="011397.html">AW: [Mono-devel-list] System.ServiceProcess development
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11407">[ date ]</a>
              <a href="thread.html#11407">[ thread ]</a>
              <a href="subject.html#11407">[ subject ]</a>
              <a href="author.html#11407">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, 2005-04-04 at 22:23 +0200, Zoltan Varga wrote:
&gt;<i> with the current JIT, the liveness range of 'i' does not include the
</I>&gt;<i> catch block, so if i is not made volatile, the JIT might allocate 'i'
</I>&gt;<i> and a variable used in the catch block to the same global register,
</I>&gt;<i> screwing things up.
</I>
Yes, the code has a comment pointing to bug #42136 about this.

But just to be sure I understand: if we had proper CFG edges,
the liveness range would be correct, would it?

My plan was to make sure the CFG had the following edges in
place:
[1] Connection from the &quot;end&quot; of the try region to the catch
    region, *and* to the finally region if present, otherwise
    to the place where the control flow goes on.
[2] Connection from the end of the catch region to the
    start of the finally region, or to the place where the
    control flow goes on if there is no finally region.
[2] Connection from the end of the finally region to the
    place where the control flow goes on (like above, the one
    just &quot;after&quot; the whole try/catch/finally block).

A CFG of this shape looks like if the catch region were under
a conditional branch after the &quot;end&quot; of the try region, and
is then followed by the finally region.

Both the catch and the finally regions are dominated by the
try one (which is correct).
Also, the catch part is sort of &quot;optional&quot; (because in point
[1] we make it look that it can be &quot;skipped&quot;), while it is
evident that the finally region is &quot;mandatory&quot;.
The only inaccuracy is the fact that in principle one could
reach the catch/finally regions from many places inside the
try region, which is not modeled in this CFG, because it is
done like if the try region were always executed entirely.

IMHO, trying to model correctly each edge from each point in
the try region that could throw an exception is overkill.
It is true that the resulting SSA representation would be
&quot;perfect&quot;, but in practice all those &quot;large&quot; phi nodes would
not give us any useful information, because we cannot really
know which of those edges will be taken.

Instead, I was proposing to keep the CFG relatively simple.
The fact that some variables have &quot;unpredictable&quot; values
after the try block (because the try block *could* have not
been executed entirely) would be modeled using dummy store
instructions, which would force the SSA generation code to
give those variables a new SSA version.

I still have to check the exact places where those dummy
store instructions should be put.
Ideally, with a CFG of this shape, they should be put
exactly at the &quot;end&quot; of the try region.
In fact, it is the &quot;exit&quot; from the try region that we are
not modeling correctly, so it is that point that should be
&quot;patched&quot;.
If there is no single BB representing this &quot;exit&quot;, I still
have to verify what would be the best thing to do... but
this is just an &quot;implementation detail&quot; ;-)
In any case, control flow transfers from the try region are
rigidly regulated and represented with special opcodes, so
it should not be hard tracking them.

This, for me, is a nice balance between the &quot;perfectly
accurate&quot; approach (one CFG edge for each place that could
throw an exception in the try region), and the &quot;easy&quot; one
(forget all optimizations on those variables in the whole
method because they are made volatile).
It gives you (almost?) all the optimization opportunities
of the accurate method, but keeps the CFG reasonable.

I hope I explained this clearly this time :-)

Ciao,
  Massi



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011396.html">[Mono-devel-list] SSA and try/catch/finally regions
</A></li>
	<LI>Next message: <A HREF="011397.html">AW: [Mono-devel-list] System.ServiceProcess development
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11407">[ date ]</a>
              <a href="thread.html#11407">[ thread ]</a>
              <a href="subject.html#11407">[ subject ]</a>
              <a href="author.html#11407">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
