<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] UDP 40%+ loss
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20UDP%2040%25%2B%20loss&In-Reply-To=1112630632.4251656821fd1%40webmail.freedom2surf.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011386.html">
   <LINK REL="Next"  HREF="011402.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] UDP 40%+ loss</H1>
    <B>marcusmonaghan at f2s.com</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20UDP%2040%25%2B%20loss&In-Reply-To=1112630632.4251656821fd1%40webmail.freedom2surf.net"
       TITLE="[Mono-devel-list] UDP 40%+ loss">marcusmonaghan at f2s.com
       </A><BR>
    <I>Mon Apr  4 17:39:34 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011386.html">[Mono-devel-list] UDP 40%+ loss
</A></li>
        <LI>Next message: <A HREF="011402.html">[Mono-devel-list] UDP 40%+ loss
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11400">[ date ]</a>
              <a href="thread.html#11400">[ thread ]</a>
              <a href="subject.html#11400">[ subject ]</a>
              <a href="author.html#11400">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Some more information:

It seems my testing was slightly incorrect. I still think there is a problem but
not with mono. When I did my initial testing I used a program on one machine to
send 51000 messages on a broadcast group. I then had two programs running, the
first was the C program and the second was the c# program. When I checked the
results I checked the output of the C program (the file that was generated) and
the count of messages generated by the c# program. I accidentally checked the
input file instead of the output file and thus thought the C program wasn't
missing any messages. However, after running the test several more times I have
discovered that the C program is actually missing data, probably more data than
the c# program. This is to be expected as the C program is doing a lot more
work. So I think I can safely say that c# and mono on linux is just as bad as C
:<i>)
</I>
However, the interesting thing is that running the same C program on Unixware
(and i'm doubly sure) doesn't miss a message. Infact on Unixware it seems to
buffer the messages automatically. I can see that when the sending process
finishes the C program is still receiving and keeps receiving for about 1min
45secs.

So I'm off to investigate the differences between Linux (Suse 9.2 Pro) and
Unixware.

Thanks Jason for replying!!

Kind regards,
Marcus


Quoting <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">marcusmonaghan at f2s.com</A>:

&gt;<i> Thanks for the reply Jason.
</I>&gt;<i>
</I>&gt;<i> I didn't post code initially as I was just seeing if there was a &quot;ah yes, we
</I>&gt;<i> know about that one&quot; answer.
</I>&gt;<i>
</I>&gt;<i> So as there doesn't seem to be that, here is the code snippets. I have
</I>&gt;<i> exluded
</I>&gt;<i> obtaining settings:
</I>&gt;<i>
</I>&gt;<i> C code:
</I>&gt;<i>         while (TRUE) /* receive (and pass on) loop */
</I>&gt;<i>         {
</I>&gt;<i>             /* Now clear buffers ready for next iteration */
</I>&gt;<i>             memset(buffer, '\0', BUFLEN);
</I>&gt;<i>             memset(outbuf, '\0', BUFLEN);
</I>&gt;<i>
</I>&gt;<i>             /* Let select know which file descriptor we want to wait on */
</I>&gt;<i>             FD_SET(multicast_socket, &amp;read_set);
</I>&gt;<i>             /* If we are not using a file then add the tcp socket to the set
</I>&gt;<i> */
</I>&gt;<i>             if (message_file &lt;= FAILURE) FD_SET(tcp_socket, &amp;read_set);
</I>&gt;<i>
</I>&gt;<i>             /* Select needs to know the maximum file descriptor to look for.
</I>&gt;<i> We
</I>&gt;<i> could specify FS_SETSIZE which is defined as 256 but
</I>&gt;<i>                this would meen the kernal would be checking for extra file
</I>&gt;<i> descriptors that did not exist. */
</I>&gt;<i>             if (multicast_socket &gt; tcp_socket || message_file &gt;= VALID)
</I>&gt;<i>                 max_fd = multicast_socket + 1;
</I>&gt;<i>             else
</I>&gt;<i>                 max_fd = tcp_socket + 1;
</I>&gt;<i>
</I>&gt;<i>             /* Now select and wait for a signal */
</I>&gt;<i>             now_msg(0, &quot;Waiting on select ...\n&quot;, errno);
</I>&gt;<i>             selected_fd = select(max_fd, &amp;read_set, NULL, NULL, NULL);
</I>&gt;<i>             now_msg(1, &quot;After select ...\n&quot;, errno);
</I>&gt;<i>
</I>&gt;<i>             /* We have a connection so reset the connection_try indicator */
</I>&gt;<i>             connection_try=0;
</I>&gt;<i>
</I>&gt;<i>             if (selected_fd == FAILURE)
</I>&gt;<i>             {
</I>&gt;<i>                 now_msg_err(0, errno, &quot;Error on select&quot;);
</I>&gt;<i>                 break;
</I>&gt;<i>             }
</I>&gt;<i>             if (selected_fd == TIMEOUT)
</I>&gt;<i>             {
</I>&gt;<i>                 /* Currently this isn't supported so shouldn't be called yet
</I>&gt;<i> */
</I>&gt;<i>                 now_msg(0, &quot;Select timed out ... POLL&quot;);
</I>&gt;<i>
</I>&gt;<i>                 /* Need to clear here as we are resetting at the top of the
</I>&gt;<i> loop
</I>&gt;<i> */
</I>&gt;<i>                 FD_CLR(multicast_socket, &amp;read_set);
</I>&gt;<i>                 FD_CLR(tcp_socket, &amp;read_set);
</I>&gt;<i>                 continue;
</I>&gt;<i>             }
</I>&gt;<i>
</I>&gt;<i>             if ((message_file &lt;= FAILURE) &amp;&amp; FD_ISSET(tcp_socket, &amp;read_set))
</I>&gt;<i>     /* Data available on tcp socket, only if not using a file */
</I>&gt;<i>             {
</I>&gt;<i>
</I>&gt;<i> .. Doesn't fire!!!
</I>&gt;<i>
</I>&gt;<i>             }   /* End of data available on TCP socket */
</I>&gt;<i>
</I>&gt;<i>             if (FD_ISSET(multicast_socket, &amp;read_set))  /* Data available on
</I>&gt;<i> udp
</I>&gt;<i> socket */
</I>&gt;<i>             {
</I>&gt;<i>                 bytes_received=recvfrom(multicast_socket, buffer, BUFLEN, 0,
</I>&gt;<i> NULL, NULL); /* get one message at a time (as it is UDP) */
</I>&gt;<i>                 if(bytes_received==FAILURE)
</I>&gt;<i>                 {
</I>&gt;<i>                     now_msg_err(0, errno, &quot;Error receiving multicast
</I>&gt;<i> messages&quot;);
</I>&gt;<i>                     break;
</I>&gt;<i>                 }
</I>&gt;<i>                 /* Let the user know what we have received (remove a linefeed
</I>&gt;<i> if
</I>&gt;<i> one is already there due to testing) */
</I>&gt;<i>                 if (buffer[bytes_received - 1] == '\n')
</I>&gt;<i>                 {
</I>&gt;<i>                     now_msg(5, &quot;removing LF from input\n&quot;);
</I>&gt;<i>                     buffer[--bytes_received] = 0;
</I>&gt;<i>                 }
</I>&gt;<i>                 now_msg(0, &quot;&lt;&lt;&lt;[%d][%s]\n&quot;, bytes_received, buffer);
</I>&gt;<i>                 if (add_ascii_header == TRUE)
</I>&gt;<i>                 {
</I>&gt;<i> .. No longer used
</I>&gt;<i>                 }
</I>&gt;<i>                 else
</I>&gt;<i>                 {
</I>&gt;<i>                     sprintf(outbuf, &quot;\&quot;%s\&quot;\n&quot;, buffer);
</I>&gt;<i>                 }
</I>&gt;<i>                 bytes_to_send = strlen(outbuf);
</I>&gt;<i>
</I>&gt;<i>                 /* Depending on whether or not a file has been specified send
</I>&gt;<i> to
</I>&gt;<i> to a tcp server or write it to a file */
</I>&gt;<i>                 if (message_file &gt;= VALID) /* File provided */
</I>&gt;<i>                 {
</I>&gt;<i>                     now_msg(5, &quot;Writing to file [%d]\n&quot;, bytes_to_send);
</I>&gt;<i>                     bytes_sent=write(message_file, outbuf, bytes_to_send);
</I>&gt;<i>                 }
</I>&gt;<i>                 else
</I>&gt;<i>                 {
</I>&gt;<i>                     now_msg(5, &quot;Writing to socket [%d]\n&quot;, bytes_to_send);
</I>&gt;<i>                     bytes_sent=send(tcp_socket, outbuf, bytes_to_send, 0
</I>&gt;<i> );	/*
</I>&gt;<i> write the message - 0 = no options */
</I>&gt;<i>                 }
</I>&gt;<i>
</I>&gt;<i>                 outbuf[bytes_to_send] = 0; /* for the record, remove the \n,
</I>&gt;<i> but
</I>&gt;<i> retain real length for checking purposes */
</I>&gt;<i>                 now_msg(0, &quot;&gt;&gt;&gt;[%d][%s]\n&quot;, bytes_sent, outbuf);
</I>&gt;<i>             }   /* End of data available on udp socket */
</I>&gt;<i>         } /* listener failed */
</I>&gt;<i>
</I>&gt;<i> c# Code
</I>&gt;<i>
</I>&gt;<i> 	public class MulticastClient
</I>&gt;<i> 	{
</I>&gt;<i> 		#region Member Variables
</I>&gt;<i> 		private string _multicastAddress = string.Empty;
</I>&gt;<i> 		private int _multicastPort = 0;
</I>&gt;<i> 		#endregion Member Variables
</I>&gt;<i>
</I>&gt;<i> 		#region Variables
</I>&gt;<i> 		private int messageCount = 0;
</I>&gt;<i> 		private IPAddress multicastAddress;
</I>&gt;<i> 		private Socket multicastSocket;
</I>&gt;<i> 		#endregion Variables
</I>&gt;<i>
</I>&gt;<i> 		#region Constructors
</I>&gt;<i> 		public MulticastClient(string MulticastGroup, int MulticastPort)
</I>&gt;<i> 		{
</I>&gt;<i> 			new MulticastClient(MulticastGroup, MulticastPort, true);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		public MulticastClient(string MulticastGroup, int MulticastPort, bool
</I>&gt;<i> StartImmediately)
</I>&gt;<i> 		{
</I>&gt;<i> 			_multicastAddress = MulticastGroup;
</I>&gt;<i> 			_multicastPort = MulticastPort;
</I>&gt;<i>
</I>&gt;<i> 			// Do we want to start?
</I>&gt;<i> 			if (StartImmediately) { StartListening(); }
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		#endregion Constructors
</I>&gt;<i>
</I>&gt;<i> 		#region Properties
</I>&gt;<i> 		public string HostAddress
</I>&gt;<i> 		{
</I>&gt;<i> 			get
</I>&gt;<i> 			{
</I>&gt;<i> 				return _multicastAddress;
</I>&gt;<i> 			}
</I>&gt;<i> 			set
</I>&gt;<i> 			{
</I>&gt;<i> 				// TODO: Only allow the setting of the property if the client is not
</I>&gt;<i> active
</I>&gt;<i>
</I>&gt;<i> 				if (value != _multicastAddress)
</I>&gt;<i> 				{
</I>&gt;<i> 					_multicastAddress = value;
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		public int Port
</I>&gt;<i> 		{
</I>&gt;<i> 			get
</I>&gt;<i> 			{
</I>&gt;<i> 				return _multicastPort;
</I>&gt;<i> 			}
</I>&gt;<i> 			set
</I>&gt;<i> 			{
</I>&gt;<i> 				// TODO: Only allow the setting of the property if the client is not
</I>&gt;<i> active
</I>&gt;<i> 				_multicastPort = value;
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 		#endregion
</I>&gt;<i>
</I>&gt;<i> 		#region Methods
</I>&gt;<i>
</I>&gt;<i> 		private void ConfigureMulticastSocket()
</I>&gt;<i> 		{
</I>&gt;<i> 			// Assign the local address automatically
</I>&gt;<i> 			EndPoint localEndPoint;
</I>&gt;<i> 			MulticastOption multicastOption;
</I>&gt;<i> 			IPAddress localIPAddress = IPAddress.Any;	// TODO: Possibly need to change
</I>&gt;<i> this to be specific
</I>&gt;<i>
</I>&gt;<i> 			// Configure the multicast address object
</I>&gt;<i> 			multicastAddress = IPAddress.Parse(_multicastAddress);
</I>&gt;<i>
</I>&gt;<i> 			// Create the socket object
</I>&gt;<i> 			// TODO: Make sure the socket is not already active
</I>&gt;<i> 			multicastSocket = new Socket(AddressFamily.InterNetwork,
</I>&gt;<i> 				SocketType.Dgram, ProtocolType.Udp);
</I>&gt;<i>
</I>&gt;<i> 			// Now create an end point for this end. Local IP address with the
</I>&gt;<i> multicast
</I>&gt;<i> port
</I>&gt;<i> 			localEndPoint = (EndPoint)new IPEndPoint(localIPAddress, _multicastPort);
</I>&gt;<i>
</I>&gt;<i> 			// Bind the socket object to the end point
</I>&gt;<i> 			multicastSocket.Bind(localEndPoint);
</I>&gt;<i>
</I>&gt;<i> 			// Now set the multicast options
</I>&gt;<i> 			multicastOption = new MulticastOption(multicastAddress, localIPAddress);
</I>&gt;<i> 			multicastSocket.SetSocketOption(SocketOptionLevel.IP,
</I>&gt;<i> 				SocketOptionName.AddMembership,
</I>&gt;<i> 				multicastOption);
</I>&gt;<i>
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		private void StartListening()
</I>&gt;<i> 		{
</I>&gt;<i> 			bool complete = false;		// Flag to indicate completion of processing loop
</I>&gt;<i> 			IPEndPoint groupEndPoint;	// The end point to the group
</I>&gt;<i> 			EndPoint remoteEndPoint;	// The other end of the socket
</I>&gt;<i> 			byte[] recievedBytes = new byte[10000];	// Bytes to receive
</I>&gt;<i> 			int recievedByteCount = 0;	// Number of bytes recieved
</I>&gt;<i>
</I>&gt;<i> 			// Configure the socket and start listening
</I>&gt;<i> 			ConfigureMulticastSocket();
</I>&gt;<i>
</I>&gt;<i> 			// Configure the end point for the group
</I>&gt;<i> 			groupEndPoint = new IPEndPoint(multicastAddress, _multicastPort);
</I>&gt;<i>
</I>&gt;<i> 			// Configure the other end point or where we want to retrieve data from.
</I>&gt;<i> 			// For this example we are going to accept data from anywhere, but
</I>&gt;<i> 			// we should be able to specify where we want to receive data from.
</I>&gt;<i> 			// Port 0 is given to allow the framework/OS to decide what is used.
</I>&gt;<i> 			remoteEndPoint = (EndPoint) new IPEndPoint(IPAddress.Any, 0);
</I>&gt;<i>
</I>&gt;<i> 			// Wait for data
</I>&gt;<i> 			// TODO: This should be asynchronous
</I>&gt;<i> 			try
</I>&gt;<i> 			{
</I>&gt;<i> 				while(!complete)
</I>&gt;<i> 				{
</I>&gt;<i> 					Console.WriteLine(&quot;Waiting for multicast messages ...&quot;);
</I>&gt;<i>
</I>&gt;<i> 					// Wait for some data
</I>&gt;<i> 					recievedByteCount = multicastSocket.ReceiveFrom(recievedBytes, ref
</I>&gt;<i> remoteEndPoint);
</I>&gt;<i>
</I>&gt;<i> 					// Show we have got something
</I>&gt;<i> 					Console.WriteLine(&quot;Received {2}: {0} from {1}&quot;,
</I>&gt;<i> 						Encoding.ASCII.GetString(recievedBytes, 0, recievedByteCount),
</I>&gt;<i> 						remoteEndPoint.ToString(),
</I>&gt;<i> 						++messageCount);
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 			catch(Exception e)
</I>&gt;<i> 			{
</I>&gt;<i> 				Console.WriteLine(e.ToString());
</I>&gt;<i> 			}
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		#endregion Methods
</I>&gt;<i>
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> As you can see the c# code is no where near complete compared to the C code.
</I>&gt;<i> It
</I>&gt;<i> has less processing, but still manages to miss the messages. The only thing I
</I>&gt;<i> can think of is to remove the Console.Writelines and log the messages to a
</I>&gt;<i> log
</I>&gt;<i> file. Just incase this is actually causing the issue (overhead of writing out
</I>&gt;<i> to the console is more than writing to a file perhaps).
</I>&gt;<i>
</I>&gt;<i> Marcus.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Quoting Jason Starin | Giant Head &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jasonstarin at giant-head.com</A>&gt;:
</I>&gt;<i>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  Hi Marcus,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   First off, without code, I feel like I'm going into this question blind,
</I>&gt;<i> &gt; but I do have a similar example that I did find a solution for.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I had a web service that was capturing web requests from several different
</I>&gt;<i> &gt; forms, it then incremented a database, and then sent confirmation mails as
</I>&gt;<i> &gt; well as lead emails to different targets, based upon the web data.  I had
</I>&gt;<i> &gt; all exceptions mailed to me, and it allowed me a little time to figure out
</I>&gt;<i> &gt; about how to configure my application to work well with xsp.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Here's the general idea:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1.  I made receipt of requests a top priority process, running on a
</I>&gt;<i> separate
</I>&gt;<i> &gt; service, so that I always received requests.  I had those requests write to
</I>&gt;<i> &gt; a common xml file that was hosted in memory.  Whenever my requests exceeded
</I>&gt;<i> &gt; 1000 or so a minute, the service would crash if I was trying to write a
</I>&gt;<i> file
</I>&gt;<i> &gt; to disk, so instead, I had a single write at the end of each minute as part
</I>&gt;<i> &gt; of a separate thread.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 2.  Database updates seem to be slow using the ByteFX and the MySql.Data
</I>&gt;<i> &gt; ADO.net connections.  I built a timer that updated with the common XML file
</I>&gt;<i> &gt; every 4 minutes.  That reduced the total number of database requests to a
</I>&gt;<i> &gt; manageable number that gave them plenty of time to finish (all of my
</I>&gt;<i> &gt; requests seem to take between 9 and 15 seconds to run almost regardless of
</I>&gt;<i> &gt; their size).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 3.  Because mail services (I'm using sendmail on RedHat Fedora Core 2, but
</I>&gt;<i> I
</I>&gt;<i> &gt; also tested SMTP on a Win2k3 with Mono box) seemed to flake out on repeated
</I>&gt;<i> &gt; connections, I batched emails, and sent them in groups, every ten minutes.
</I>&gt;<i> &gt; If I allowed each process to send an email message, immediately, my dual
</I>&gt;<i> &gt; processor server seemed to choke on all of the connections, and eventually
</I>&gt;<i> &gt; XSP would crash and take apache with it.  On Windows, I'd have a great big
</I>&gt;<i> &gt; collection of emails bogged down in my logs, needing to be resent.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Frankly, I don't think these are bugs, but more along the lines of
</I>&gt;<i> &gt; enviornmental constraints, that you can adapt to if you map out the process
</I>&gt;<i> &gt; and look for where things are flaking out.  Perhaps establish a separate
</I>&gt;<i> log
</I>&gt;<i> &gt; file to watch each step through your process, and save at the end of your
</I>&gt;<i> &gt; test?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Send code if you get a chance, I'm interested to see where I can help, and
</I>&gt;<i> &gt; have you thought about testing your C# app on a windows machine?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Interesting problem,
</I>&gt;<i> &gt; Jason
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  From: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list-admin at lists.ximian.com</A>
</I>&gt;<i> &gt; [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list-admin at lists.ximian.com</A>] On Behalf Of
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">marcusmonaghan at f2s.com</A>
</I>&gt;<i> &gt; Sent: Monday, April 04, 2005 10:37 AM
</I>&gt;<i> &gt; To: Mono Help
</I>&gt;<i> &gt; Subject: [Mono-devel-list] UDP 40%+ loss
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; All,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I am trying to re-creating a C program in C# mono (as there are more C#
</I>&gt;<i> &gt; developers in our company now) and it seems it's not behaving in the
</I>&gt;<i> &gt; expected
</I>&gt;<i> &gt; way.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The program is very simple. It listens on a multicast group, receives data
</I>&gt;<i> &gt; and
</I>&gt;<i> &gt; writes it to a file. The problem is that I'm seeing roughly 40%+ missed
</I>&gt;<i> &gt; messages when compared to the C program. I ran the C# and C program on the
</I>&gt;<i> &gt; same
</I>&gt;<i> &gt; box. On another box I send out 100 messages in 10 second bursts. The C
</I>&gt;<i> &gt; program
</I>&gt;<i> &gt; receives all of them whereas the C# program only receive 60 on the first
</I>&gt;<i> &gt; burst
</I>&gt;<i> &gt; 50 on the second 55 on the third and so on.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I then (just for a laugh) unthrottled the sending program. It sent 51,000
</I>&gt;<i> &gt; messages, all of which where received by the C program. The c# program
</I>&gt;<i> &gt; recorded
</I>&gt;<i> &gt; 7152.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Anyone got any ideas? Possibly a bug?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Regards,
</I>&gt;<i> &gt; Marcus
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-devel-list mailing list
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-devel-list mailing list
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Marcus
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>

Regards,
Marcus

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011386.html">[Mono-devel-list] UDP 40%+ loss
</A></li>
	<LI>Next message: <A HREF="011402.html">[Mono-devel-list] UDP 40%+ loss
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11400">[ date ]</a>
              <a href="thread.html#11400">[ thread ]</a>
              <a href="subject.html#11400">[ subject ]</a>
              <a href="author.html#11400">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
