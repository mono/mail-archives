<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Fundamental performance problems with Mono
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Fundamental%20performance%20problems%20with%20Mono&In-Reply-To=27074993.post%40talk.nabble.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033823.html">
   <LINK REL="Next"  HREF="033826.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Fundamental performance problems with Mono</H1>
    <B>Stifu</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Fundamental%20performance%20problems%20with%20Mono&In-Reply-To=27074993.post%40talk.nabble.com"
       TITLE="[Mono-dev] Fundamental performance problems with Mono">stifu at free.fr
       </A><BR>
    <I>Fri Jan  8 07:14:36 EST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="033823.html">[Mono-dev] Fundamental performance problems with Mono
</A></li>
        <LI>Next message: <A HREF="033826.html">[Mono-dev] Fundamental performance problems with Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33824">[ date ]</a>
              <a href="thread.html#33824">[ thread ]</a>
              <a href="subject.html#33824">[ subject ]</a>
              <a href="author.html#33824">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Hi,

You may already know, but Mono 2.8 will have a brand new GC... This may
improve your app performances.


zvikag wrote:
&gt;<i> 
</I>&gt;<i> Hi,
</I>&gt;<i> 
</I>&gt;<i> Writing my server in a managed language, be it Mono or Java, is a basic
</I>&gt;<i> choice of effectiveness over cost. I prefer good performance in no time
</I>&gt;<i> than super-great-performance that takes ages to develop and will almost
</I>&gt;<i> surely rain upon me bugs from hell. And if you write your managed code
</I>&gt;<i> correctly (mainly aim towards zero GC, and this includes the framework...)
</I>&gt;<i> then your performance should be equivalent to a native implementation. If
</I>&gt;<i> you can point out a managed async socket framework that works I'd be happy
</I>&gt;<i> to try it. I don't have time to get down and dirty. I got business logic
</I>&gt;<i> on my hands... 
</I>&gt;<i> 
</I>&gt;<i> Now, from what I understand, the implementation in mono follows the
</I>&gt;<i> well-known recipe for high-performance socket servers in Linux: event
</I>&gt;<i> polling (epoll) with I/O Thread pool - you call send()/receive() when the
</I>&gt;<i> socket is ready. so, yes, eventually you call the simple socket API, but
</I>&gt;<i> this is how you write high-performance servers in Linux. but more
</I>&gt;<i> importantly, any socket framework that wants to wrap this model will need
</I>&gt;<i> primitives like BeginReceive\ReceiveAsync + OnDataReceived callback and
</I>&gt;<i> BeginSend\SendAsync + OnDataSent calback. can't escape it. so it doesn't
</I>&gt;<i> matter if the operating system doesn't have native support for async
</I>&gt;<i> sockets - you end up with more or less the same managed async socket API
</I>&gt;<i> on Windows and Linux.
</I>&gt;<i> 
</I>&gt;<i> Therefore, I do blame Mono for the poor performance. If the epoll+I/O
</I>&gt;<i> Thread pool model is implemented correctly and if the managed async socket
</I>&gt;<i> API is implemented properly (and there is a lot to benefit from the
</I>&gt;<i> XXXAsync methods) then there is no reason why a Mono server should not be
</I>&gt;<i> equal in performance to a .NET on Windows server. And again, this is good
</I>&gt;<i> enough performance for me.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> damageboy wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Hi Zvika,
</I>&gt;&gt;<i> I'll start by saying that I've been there, I've also seen abysmal
</I>&gt;&gt;<i> performance with the mono async socket implementation.
</I>&gt;&gt;<i> If you'll dig down in the code (I did so last time around Mono 2.2) you
</I>&gt;&gt;<i> should also see that there is no such thing in Mono/Linux at any rate...
</I>&gt;&gt;<i> By this, I mean that a fundamental difference you'll find in the Linux
</I>&gt;&gt;<i> world from the Windows world is that there is no async socket API for
</I>&gt;&gt;<i> Linux. This is a &quot;limitation&quot; (if you want to call it like that) of the
</I>&gt;&gt;<i> Linux kernel, and in no way related to mono.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> While calling BeginSend/Receive in Windows + MS.NET is implemented by
</I>&gt;&gt;<i> means of true async sockets on Windows, which ultimately are a Winsock /
</I>&gt;&gt;<i> Windows NT Kernel feature, calling BeginSend on Mono simply queues a work
</I>&gt;&gt;<i> item into the thread pool that will call the normal socket apis.
</I>&gt;&gt;<i> This is a fundamental difference in how Mono/MS.NET work.
</I>&gt;&gt;<i> Feel free to gaze at the code on
</I>&gt;&gt;<i> &quot;mcs/class/System/System.Net.Sockets/Socket.cs&quot; and see this for
</I>&gt;&gt;<i> yourself...
</I>&gt;&gt;<i> While the Mono people could write two implementations for BeginXXX (one
</I>&gt;&gt;<i> for Windows + async sockets, one for Linux) I don't really blame them for
</I>&gt;&gt;<i> implementing the BeingXXX APIs the way they did.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> In a way, using a BeginXXX APIs for sockets on Mono generally degrades
</I>&gt;&gt;<i> performance (in terms of overhead and latency for packet send/receive)
</I>&gt;&gt;<i> under heavy load than using the regular non-async apis.
</I>&gt;&gt;<i> This should pretty much leave you asking yourself why would you ever want
</I>&gt;&gt;<i> to use the so-called more advanced &quot;XXXAsync Socket API&quot; (which was your
</I>&gt;&gt;<i> original intent, as far as I can tell).
</I>&gt;&gt;<i> I personally see very little benefit even if were implemented in Mono.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> This definitely does not mean that all is lost. On the contrary, you can
</I>&gt;&gt;<i> achieve much higher throughput / lower latency with Mono + Linux, but
</I>&gt;&gt;<i> achieving this with the Microsoft centric APIs / paradigms (as
</I>&gt;&gt;<i> System.Net.Sockets is) is highly unlikely IMO (again, I would like to
</I>&gt;&gt;<i> stress that this is really not Mono's fault).
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I suggest you read up on the C10K problem either on Wikipedia or Dan
</I>&gt;&gt;<i> Kegel's site:
</I>&gt;&gt;<i> <A HREF="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</A>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> There are many possible solutions, including some that are not mentioned
</I>&gt;&gt;<i> in the C10K page, such as using
</I>&gt;&gt;<i> P/Invoke to call vmsplice/splice for sending/receiving data with Zero
</I>&gt;&gt;<i> Copy networking or, as I've done in the past,
</I>&gt;&gt;<i> wrapping up Evgeniy Polyakov's netchannels and userspace network stack:
</I>&gt;&gt;<i> <A HREF="http://www.ioremap.net/projects/unetstack">http://www.ioremap.net/projects/unetstack</A>
</I>&gt;&gt;<i> <A HREF="http://www.ioremap.net/projects/netchannels">http://www.ioremap.net/projects/netchannels</A>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Although this means getting down and dirty, often using unsafe code and
</I>&gt;&gt;<i> pointers and 
</I>&gt;&gt;<i> what not, let me assure you, that you will be able to make a very modest
</I>&gt;&gt;<i> server/desktop 
</I>&gt;&gt;<i> machine blow away anything you've ever sen with Windows before.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> In short, I think you're looking at the wrong problem.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Hope this helps.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> zvikag wrote:
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> Hello all,
</I>&gt;&gt;&gt;<i> The bottom line of this message is that I don't see how can one write a
</I>&gt;&gt;&gt;<i> high-performance socket server in Mono...
</I>&gt;&gt;&gt;<i> Here is the story:
</I>&gt;&gt;&gt;<i> I am writing a proxy server using .NET Socket API. This proxy does
</I>&gt;&gt;&gt;<i> almost entirely I/O work - copying buffers from one socket to another.
</I>&gt;&gt;&gt;<i> Now, Mono doesn't implement the newer 
</I>&gt;&gt;&gt;<i> <A HREF="http://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.aspx">http://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.aspx</A>
</I>&gt;&gt;&gt;<i> XXXAsync Socket API  that was introduced in .NET 2.0 SP1 (or more
</I>&gt;&gt;&gt;<i> accurately, implements it 
</I>&gt;&gt;&gt;<i> <A HREF="http://www.mail-archive.com/mono-list@lists.ximian.com/msg28621.html">http://www.mail-archive.com/mono-list@lists.ximian.com/msg28621.html</A>
</I>&gt;&gt;&gt;<i> perfunctorily ). So I was left to use the APM Socket API which produces
</I>&gt;&gt;&gt;<i> tons of garbage objects under heavy load.
</I>&gt;&gt;&gt;<i> When testing the server on Linux under load we saw very frequent CPU
</I>&gt;&gt;&gt;<i> bursts that crippled the throughput of the server. After profiling with
</I>&gt;&gt;&gt;<i> the mono built-in profiler I confirmed that the reason for the high CPU
</I>&gt;&gt;&gt;<i> usage was the GC collections that got more and more frequent and took
</I>&gt;&gt;&gt;<i> more and more time. I then read a little bit and realized that the Mono
</I>&gt;&gt;&gt;<i> GC is non-generational which might explain the long GC cycles (if it was
</I>&gt;&gt;&gt;<i> generational it could have collected the garbage objects that were
</I>&gt;&gt;&gt;<i> created during async socket operations in generation 0 and probably stop
</I>&gt;&gt;&gt;<i> there, but it has to traverse the entire managed heap).
</I>&gt;&gt;&gt;<i> So the combination of the non-generational GC and the unimplemented
</I>&gt;&gt;&gt;<i> XXXAsync Socket API result in very poor performance of the Mono server.
</I>&gt;&gt;&gt;<i> The maximum throughput of the server with Mono on Linux is about half of
</I>&gt;&gt;&gt;<i> that on Windows using .NET.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> I attached the GC stats and profiling results of a 15 minute run.
</I>&gt;&gt;&gt;<i>  <A HREF="http://old.nabble.com/file/p27026906/profile_alloc.log">http://old.nabble.com/file/p27026906/profile_alloc.log</A>
</I>&gt;&gt;&gt;<i> profile_alloc.log 
</I>&gt;&gt;&gt;<i>  <A HREF="http://old.nabble.com/file/p27026906/gc_stats.log">http://old.nabble.com/file/p27026906/gc_stats.log</A> gc_stats.log 
</I>&gt;&gt;&gt;<i> Can you help me out here?
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>
-- 
View this message in context: <A HREF="http://old.nabble.com/Fundamental-performance-problems-with-Mono-tp27026906p27075072.html">http://old.nabble.com/Fundamental-performance-problems-with-Mono-tp27026906p27075072.html</A>
Sent from the Mono - Dev mailing list archive at Nabble.com.

</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033823.html">[Mono-dev] Fundamental performance problems with Mono
</A></li>
	<LI>Next message: <A HREF="033826.html">[Mono-dev] Fundamental performance problems with Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33824">[ date ]</a>
              <a href="thread.html#33824">[ thread ]</a>
              <a href="subject.html#33824">[ subject ]</a>
              <a href="author.html#33824">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
