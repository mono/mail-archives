<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Fundamental performance problems with Mono
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Fundamental%20performance%20problems%20with%20Mono&In-Reply-To=27026906.post%40talk.nabble.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033820.html">
   <LINK REL="Next"  HREF="033823.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Fundamental performance problems with Mono</H1>
    <B>damageboy</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Fundamental%20performance%20problems%20with%20Mono&In-Reply-To=27026906.post%40talk.nabble.com"
       TITLE="[Mono-dev] Fundamental performance problems with Mono">dans at houmus.org
       </A><BR>
    <I>Thu Jan  7 17:14:28 EST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="033820.html">[Mono-dev] Fundamental performance problems with Mono
</A></li>
        <LI>Next message: <A HREF="033823.html">[Mono-dev] Fundamental performance problems with Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33821">[ date ]</a>
              <a href="thread.html#33821">[ thread ]</a>
              <a href="subject.html#33821">[ subject ]</a>
              <a href="author.html#33821">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Hi Zvika,
I'll start by saying that I've been there, I've also seen abysmal
performance with the mono async socket implementation.
If you'll dig down in the code (I did so last time around Mono 2.2) you
should also see that there is no such thing in Mono/Linux at any rate...
By this, I mean that a fundamental difference you'll find in the Linux world
from the Windows world is that there is no async socket API for Linux. This
is a &quot;limitation&quot; (if you want to call it like that) of the Linux kernel,
and in no way related to mono.

While calling BeginSend/Receive in Windows + MS.NET is implemented by means
of true async sockets on Windows, which ultimately are a Winsock / Windows
NT Kernel feature, calling BeginSend on Mono simply queues a work item into
the thread pool that will call the normal socket apis.
This is a fundamental difference in how Mono/MS.NET work.
Feel free to gaze at the code on
&quot;mcs/class/System/System.Net.Sockets/Socket.cs&quot; and see this for yourself...
While the Mono people could write two implementations for BeginXXX (one for
Windows + async sockets, one for Linux) I don't really blame them for
implementing the BeingXXX APIs the way they did.

In a way, using a BeginXXX APIs for sockets on Mono generally degrades
performance (in terms of overhead and latency for packet send/receive) under
heavy load than using the regular non-async apis.
This should pretty much leave you asking yourself why would you ever want to
use the so-called more advanced &quot;XXXAsync Socket API&quot; (which was your
original intent, as far as I can tell).
I personally see very little benefit even if were implemented in Mono.

This definitely does not mean that all is lost. On the contrary, you can
achieve much higher throughput / lower latency with Mono + Linux, but
achieving this with the Microsoft centric APIs / paradigms (as
System.Net.Sockets is) is highly unlikely IMO (again, I would like to stress
that this is really not Mono's fault).

I suggest you read up on the C10K problem either on Wikipedia or Dan Kegel's
site:
<A HREF="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</A>

There are many possible solutions, including some that are not mentioned in
the C10K page, such as using
P/Invoke to call vmsplice/splice for sending/receiving data with Zero Copy
networking or, as I've done in the past,
wrapping up Evgeniy Polyakov's netchannels and userspace network stack:
<A HREF="http://www.ioremap.net/projects/unetstack">http://www.ioremap.net/projects/unetstack</A>
<A HREF="http://www.ioremap.net/projects/netchannels">http://www.ioremap.net/projects/netchannels</A>

Although this means getting down and dirty, often using unsafe code and
pointers and 
what not, let me assure you, that you will be able to make a very modest
server/desktop 
machine blow away anything you've ever sen with Windows before.

In short, I think you're looking at the wrong problem.

Hope this helps.



zvikag wrote:
&gt;<i> 
</I>&gt;<i> Hello all,
</I>&gt;<i> The bottom line of this message is that I don't see how can one write a
</I>&gt;<i> high-performance socket server in Mono...
</I>&gt;<i> Here is the story:
</I>&gt;<i> I am writing a proxy server using .NET Socket API. This proxy does almost
</I>&gt;<i> entirely I/O work - copying buffers from one socket to another. Now, Mono
</I>&gt;<i> doesn't implement the newer 
</I>&gt;<i> <A HREF="http://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.aspx">http://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.aspx</A>
</I>&gt;<i> XXXAsync Socket API  that was introduced in .NET 2.0 SP1 (or more
</I>&gt;<i> accurately, implements it 
</I>&gt;<i> <A HREF="http://www.mail-archive.com/mono-list@lists.ximian.com/msg28621.html">http://www.mail-archive.com/mono-list@lists.ximian.com/msg28621.html</A>
</I>&gt;<i> perfunctorily ). So I was left to use the APM Socket API which produces
</I>&gt;<i> tons of garbage objects under heavy load.
</I>&gt;<i> When testing the server on Linux under load we saw very frequent CPU
</I>&gt;<i> bursts that crippled the throughput of the server. After profiling with
</I>&gt;<i> the mono built-in profiler I confirmed that the reason for the high CPU
</I>&gt;<i> usage was the GC collections that got more and more frequent and took more
</I>&gt;<i> and more time. I then read a little bit and realized that the Mono GC is
</I>&gt;<i> non-generational which might explain the long GC cycles (if it was
</I>&gt;<i> generational it could have collected the garbage objects that were created
</I>&gt;<i> during async socket operations in generation 0 and probably stop there,
</I>&gt;<i> but it has to traverse the entire managed heap).
</I>&gt;<i> So the combination of the non-generational GC and the unimplemented
</I>&gt;<i> XXXAsync Socket API result in very poor performance of the Mono server.
</I>&gt;<i> The maximum throughput of the server with Mono on Linux is about half of
</I>&gt;<i> that on Windows using .NET.
</I>&gt;<i> 
</I>&gt;<i> I attached the GC stats and profiling results of a 15 minute run.
</I>&gt;<i>  <A HREF="http://old.nabble.com/file/p27026906/profile_alloc.log">http://old.nabble.com/file/p27026906/profile_alloc.log</A> profile_alloc.log 
</I>&gt;<i>  <A HREF="http://old.nabble.com/file/p27026906/gc_stats.log">http://old.nabble.com/file/p27026906/gc_stats.log</A> gc_stats.log 
</I>&gt;<i> Can you help me out here?
</I>&gt;<i> 
</I>
-- 
View this message in context: <A HREF="http://old.nabble.com/Fundamental-performance-problems-with-Mono-tp27026906p27067974.html">http://old.nabble.com/Fundamental-performance-problems-with-Mono-tp27026906p27067974.html</A>
Sent from the Mono - Dev mailing list archive at Nabble.com.

</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033820.html">[Mono-dev] Fundamental performance problems with Mono
</A></li>
	<LI>Next message: <A HREF="033823.html">[Mono-dev] Fundamental performance problems with Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33821">[ date ]</a>
              <a href="thread.html#33821">[ thread ]</a>
              <a href="subject.html#33821">[ subject ]</a>
              <a href="author.html#33821">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
