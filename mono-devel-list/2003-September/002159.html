<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Re: Dynamically changing classes?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Re%3A%20Dynamically%20changing%20classes%3F&In-Reply-To=bkt939%24nrt%241%40sea.gmane.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002155.html">
   <LINK REL="Next"  HREF="002160.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Re: Dynamically changing classes?</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Re%3A%20Dynamically%20changing%20classes%3F&In-Reply-To=bkt939%24nrt%241%40sea.gmane.org"
       TITLE="[Mono-devel-list] Re: Dynamically changing classes?">lupus at ximian.com
       </A><BR>
    <I>Thu Sep 25 09:36:10 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="002155.html">[Mono-devel-list] Re: Dynamically changing classes?
</A></li>
        <LI>Next message: <A HREF="002160.html">[Mono-devel-list] Re: Dynamically changing classes?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2159">[ date ]</a>
              <a href="thread.html#2159">[ thread ]</a>
              <a href="subject.html#2159">[ subject ]</a>
              <a href="author.html#2159">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/25/03 Thomas Sondergaard wrote:
&gt;<i> &gt; Problem: it doesn't handle updating existing class instances.  Thus,
</I>&gt;<i> &gt; this may be unsuitable for some situations.
</I>&gt;<i> 
</I>&gt;<i> Yes it is a trick and it is nasty. I think it is fair to conclude that the
</I>&gt;<i> current class model in .net is not friendly to the idea of classes that
</I>&gt;<i> change their interface and/or implementation at runtime.
</I>
I think you're mixing two things: language implementation and
interoperability with other languages in the CLR. This is the cause of
much confusion: the two things should be addressed separately or you'd
end up saying that C is not an adequate language to implement a dynamic
language, because C doesn't have classes/interfaces/whatever. The truth
is most dynamic languages are implemented in C just fine:-)
In the CLR a class can't be changed at runtime the same way a package
can be done in perl or other dynamic languages: adding/removing methods,
changing the parent class etc. This is not an issue for the
implementation of the dynamic language in the CLR, though, it's only an
issue of interoperability. So let's start with the implementation first
and discuss the interoperability issue later.

Since the CLR offers basically the same features that are available to a
C programmer, if a dynamic language can be implemented in C, it can be
implemented in the CLR, too. There may be a few drawbacks (higher memory
usage or it can be a little slower), but there are also benefits
(interoperability with other languages, first of all, but also access to
a GC, a JIT etc.).

Just porting from the C code, though possible, is not going to give access
to most of the useful features of the CLR, but which features are useful
for a particular dynamic language depend on the langauge needs.
For example, the CLR provides a nice (and fast) way to do
single-inheritance, but if it's not enough for a language, the language
implementor can always implement its own mechanism. So, again, this is
not an implementation issue, it's just an interoperability issue.

In Perl you have multiple-inheritance and the parents of a type can be
changed at runtime. Now, *implementing* the feature on the CLR is very
easy: each perl package can be its own CLR type. The base type of the
CLR type doesn't matter, it could be System.Object or a perl-specific
class such as Perl.UNIVERSAL or Perl.RV. This type would have an array
of types that correspond to the @ISA array in perl-land. The isa method
is easily implemented with a linear search in this array (though of
course, more clever methods can be used as well). As we see, there is no
issue in implementing the feature, even if it doesn't map to the CLR
feature.
The same can happen with methods: the CLR type can have a hashtable
that maps from method names to perl subroutines (exactly like the C
implementation of Perl) and the nethod invocation will just do a lookup
in the hash. This reproduces the needs for a dynamic language like perl.
So, most of the features that are common to many dynamic languages can
be easily implemented in the CLR.

Now, let's see about the other issue: interoperability. You can be a
consumer or a producer, so let's see first how to consume CLR
methods from a dynamic language. In perl a call to Console.WriteLine
could look like this:

	System::Console-&gt;WriteLine (&quot;hello world!&quot;);

The perl compiler could generate the following code (in C# syntax):

	IObject console = get_object_from_type_name (&quot;System::Console&quot;);
	console.send (&quot;WriteLine&quot;, new object[] {&quot;hello world!&quot;});

The console.send implementation would do:

	object send (string name, object[] args) {
		clr_type.InvokeMember (name, null, args);
	}

This is what a simple compiler would do and I agree this wouldn't be
very fast, but a slightly smarter compiler can do better: the
get_object_from_type_name() call can be done at compile time, for
example (this optimization is done also by the current C Perl
implementation). Once System::Console is mapped to a CLR type,
the compiler could also get the MethodInfo and invoke on it directly
(much faster than InvokeMember). An even better compiler can
add a couple of runtime checks and the IL code to call Console.WriteLine
directly, depending on the argument types.

How would you expose Perl methods to other languages? One way is to
just expose an IObject-like interface (with params object[] args) so
that calling a method in a perl object would be almost natural:

	// C# code to call a method on a perl-object
	perl_object.send (&quot;do_something&quot;, &quot;with&quot; &quot;these&quot;, &quot;arguments&quot;);

Another one can be to generate methods in IL that can be called directly
in C#. The implementation can be very simple:

	// could have also overloaded versions with different types
	void do_something (params object[] args) {
		send (&quot;do_something&quot;, args);
	}

&gt;<i> &gt; Just have all your internal classes implement IDynamicLanguage, and you
</I>&gt;<i> &gt; get the same functionality as &quot;send_msg&quot;.  There's no particular reason
</I>&gt;<i> &gt; why this has to be in CIL, as opposed to doing it yourself (above).
</I>&gt;<i> 
</I>&gt;<i> Not really, by implementing this 'in .net' not as .net you are bound to
</I>&gt;<i> execute a lot slower. Imagine compiling this ruby function to .net
</I>&gt;<i> 
</I>&gt;<i> class ACLass
</I>&gt;<i>     def invokeSomeMethodsOnArg(arg)
</I>&gt;<i>         arg.doThis
</I>&gt;<i>         arg.doThat
</I>&gt;<i>         arg.AlsoThis
</I>&gt;<i>     end
</I>&gt;<i> end
</I>&gt;<i> 
</I>&gt;<i> Ruby is dynamically type so arg can be any type. This means that the only
</I>&gt;<i> way to invoke doThis, doThat and AlsoThis is using the reflection API, e.g.
</I>&gt;<i> using arg.GetType().InvokeMember(&quot;doThis&quot;, ....). This will be very slow.
</I>
Nope, you can easily implement it another way. In C# syntax it could be:

	IObject obj = arg as IObject;
	if (arg != null) {
		arg.send (&quot;doThis&quot;, null);
		arg.send (&quot;doThat&quot;, null);
		arg.send (&quot;AlsoThis&quot;, null);
	} else {
		// slow path
		arg.GetType().InvokeMember(&quot;doThis&quot;, ...);
	}

A smart compiler can optimize the slow path as detailed above (maybe
also making use of profiling information or some sort of cache).

&gt;<i> Not only because of the services rendered I think, but because of the layers
</I>&gt;<i> of abstraction, which could be done away with if the CLR supported the
</I>&gt;<i> concept. The abomination known as method overloading adds complexity to this
</I>
I don't see what concept you think the CLR should support, but if you think you
need some kind of support from the CLR, mono is sure a good platform to
prototype it in:-)
Sure, InvokeMember() is bound to be slow (maybe we could see if we can
speedup the mono implementation), but, for example, MethodInfo.Invoke()
is a lot faster (it's currently 2-3 times slower than a ruby/perl method
call and it could be optimized, probably). But those are not concept
issues, just performance tuning issues.

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002155.html">[Mono-devel-list] Re: Dynamically changing classes?
</A></li>
	<LI>Next message: <A HREF="002160.html">[Mono-devel-list] Re: Dynamically changing classes?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2159">[ date ]</a>
              <a href="thread.html#2159">[ thread ]</a>
              <a href="subject.html#2159">[ subject ]</a>
              <a href="author.html#2159">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
