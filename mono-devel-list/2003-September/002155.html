<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Re: Dynamically changing classes?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Re%3A%20Dynamically%20changing%20classes%3F&In-Reply-To=bkt939%24nrt%241%40sea.gmane.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002154.html">
   <LINK REL="Next"  HREF="002159.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Re: Dynamically changing classes?</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Re%3A%20Dynamically%20changing%20classes%3F&In-Reply-To=bkt939%24nrt%241%40sea.gmane.org"
       TITLE="[Mono-devel-list] Re: Dynamically changing classes?">jonpryor at vt.edu
       </A><BR>
    <I>Wed Sep 24 21:45:23 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="002154.html">[Mono-devel-list] Re: Dynamically changing classes?
</A></li>
        <LI>Next message: <A HREF="002159.html">[Mono-devel-list] Re: Dynamically changing classes?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2155">[ date ]</a>
              <a href="thread.html#2155">[ thread ]</a>
              <a href="subject.html#2155">[ subject ]</a>
              <a href="author.html#2155">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, 2003-09-24 at 19:24, Thomas Sondergaard wrote:
&lt;snip what=&quot;IDynamicLanguage declaration, etc.&quot; /&gt;
&gt;<i> &gt; Just have all your internal classes implement IDynamicLanguage, and you
</I>&gt;<i> &gt; get the same functionality as &quot;send_msg&quot;.  There's no particular reason
</I>&gt;<i> &gt; why this has to be in CIL, as opposed to doing it yourself (above).
</I>&gt;<i> 
</I>&gt;<i> Not really, by implementing this 'in .net' not as .net you are bound to
</I>&gt;<i> execute a lot slower. Imagine compiling this ruby function to .net
</I>&gt;<i> 
</I>&gt;<i> class ACLass
</I>&gt;<i>     def invokeSomeMethodsOnArg(arg)
</I>&gt;<i>         arg.doThis
</I>&gt;<i>         arg.doThat
</I>&gt;<i>         arg.AlsoThis
</I>&gt;<i>     end
</I>&gt;<i> end
</I>&gt;<i> 
</I>&gt;<i> Ruby is dynamically type so arg can be any type. This means that the only
</I>&gt;<i> way to invoke doThis, doThat and AlsoThis is using the reflection API, e.g.
</I>&gt;<i> using arg.GetType().InvokeMember(&quot;doThis&quot;, ....). This will be very slow.
</I>&gt;<i> Not only because of the services rendered I think, but because of the layers
</I>&gt;<i> of abstraction, which could be done away with if the CLR supported the
</I>&gt;<i> concept. The abomination known as method overloading adds complexity to this
</I>&gt;<i> issue, unfortunately.
</I>
I'm inclined to disagree.  Certainly, using Reflection (right now) is
bound to be slow.  So would using a custom interface; again, Right Now.

Forget about dynamic languages for the moment.  How does .NET handle
String.Length?

	string s = &quot;hello, world!&quot;;
	for (int i = 0; i != s.Length; ++i) {
		// do something with s[i]
	}

This *looks* like it will call String.Length &quot;i&quot; times -- once for each
loop iteration.  However, the .NET JIT engine (and mini, AFAIK) looks
for this style code, and caches the result of &quot;s.Length&quot;.  The end
result is that the above code is *faster* than the equivalent:

	string s = &quot;hello, world!&quot;;
	int len = s.Length;
	for (int i = 0; i != len; ++i) {
		// do something with s[i]
	}

No special CIL opcodes are used; the JIT just looks for this style CIL
and a call to System.String::get_Length().

Getting back to dynamic languages, it seems reasonable to assume that if
we had a standard interface -- that is, one that the JIT knew about --
the runtime could optimize for dynamic languages via message sending,
buy Doing The Right Thing, whatever that happens to entail.

This wouldn't require any additional CIL opcodes, it would just require
adding additional optimizations to the runtime.

It would also require determining under what circumstances the
optimizations apply, how to best optimize them, and implementing those
optimizations.  Again, a research effort. :-)

It may be that adding CIL opcodes simplifies the effort for dynamic
languages, or makes the JIT operation faster, so I'm not going to say
that CIL opcodes are a Bad Idea.  I'm just trying to point out that
adding CIL opcodes doesn't have to be the first attempted solution, that
there may be ways to be friendlier to dynamic languages without
extending the ECMA spec (well, without extending it *too* much; I figure
a new, recognizable interface may be required, but adding CIL opcodes
should be the last resort).

 - Jon



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002154.html">[Mono-devel-list] Re: Dynamically changing classes?
</A></li>
	<LI>Next message: <A HREF="002159.html">[Mono-devel-list] Re: Dynamically changing classes?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2155">[ date ]</a>
              <a href="thread.html#2155">[ thread ]</a>
              <a href="subject.html#2155">[ subject ]</a>
              <a href="author.html#2155">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
