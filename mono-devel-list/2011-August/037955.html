<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Environment.GetFolderPath() behaviour inconsistent with .NET
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Environment.GetFolderPath%28%29%20behaviour%20inconsistent%0A%20with%20.NET&In-Reply-To=CANqeOFoT%2BptZawqYzDhstZ4%2BZGGpL_tihpAeLFTWXv-xB4%3D07g%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="037954.html">
   <LINK REL="Next"  HREF="037952.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Environment.GetFolderPath() behaviour inconsistent with .NET</H1>
    <B>Gabe Mc</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Environment.GetFolderPath%28%29%20behaviour%20inconsistent%0A%20with%20.NET&In-Reply-To=CANqeOFoT%2BptZawqYzDhstZ4%2BZGGpL_tihpAeLFTWXv-xB4%3D07g%40mail.gmail.com"
       TITLE="[Mono-dev] Environment.GetFolderPath() behaviour inconsistent with .NET">madeonamac at gmail.com
       </A><BR>
    <I>Sat Aug 20 01:06:04 EDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="037954.html">[Mono-dev] Environment.GetFolderPath() behaviour inconsistent with .NET
</A></li>
        <LI>Next message: <A HREF="037952.html">[Mono-dev] Generating Cocoa bindings through Objective-C	introspection?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37955">[ date ]</a>
              <a href="thread.html#37955">[ thread ]</a>
              <a href="subject.html#37955">[ subject ]</a>
              <a href="author.html#37955">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ok, I could just be talking complete crap here, so just keep that in
mind. I didn't see the start of this thread, but this commentary really
got me to thinking that you could solve this problem in a different way.

&gt;<i> 
</I>&gt;<i> If you knew me better, you would know that I detest the gratuitous
</I>&gt;<i> breakage of APIs for the sake of cleaning up, at the expense of
</I>&gt;<i> breaking people's software.   Evidence can be found on assorted
</I>&gt;<i> mailing lists and interviews.   
</I>&gt;<i> 
</I>
I recognize the distaste for breaking APIs. I have a similar aversion to
causing down-stream disruptions. I also recognize, however, that some
disruptions are not only unfortunate, but also sometimes necessary. At
some point, a critical bug or planned obsolescence is going to appear
that affects people already on your platform, that has to be fixed
because it doesn't conform to what the developer works with on &quot;the
other&quot; platform. It seems like, in a position like this, it would be
better to see if one could leverage a tool to automate some of the hard
work of downstream maintenance.

&gt;<i> 
</I>&gt;<i> This is not one of those things that can easily be detected, so it
</I>&gt;<i> introduces subtle errors, which might be impossible to diagnose.
</I>&gt;<i> 
</I>
Indeed, the only real way to check to see that downstream users will be
affected is to make sure one has a passing test that defines what the
current implementation _does_ and a failing test for what the
implementation _should_ do. However, once you have that knowledge, you
could easily begin to annotate methods and classes with information
about what will be breaking in this release. Indeed, I could see you
even attaching metadata to the test cases for pre- and post-iteration
notices, tying together these two tests to the method that is changing
or disappearing, all in annotations. 

You could then have a post-build step use the Cecil library to strip out
those annotations from the library (to remove bloat), and use the
information in them to generate a small library of information about
what changed (like NAME.VERSION.diff.dll). That new library could passed
on the command line to another tool that loads it, looks at the metadata
and looks at any and all of the other libraries it finds on the command
line, loads them, and checks to see if any of those libraries have
potential breakages associated.  

Now you have two happy downstream customers: the existing group that now
uses the output of this process, since this tool will tell them all of
the places that they should fix before they even hit F8 to rebuild to
see the errors; and, your new customers see that you have a consistent
record of tracking changes and notifying them of downstream breaks more
easily. Older users get to update their code, and new users get to to
bring their code to new platforms more easily. Everybody can then trust
but verify.

Since downstream users probably move platforms relatively slowly, they
could easily use this tool on the output of their builds (and even use
it on their own stuff!), to verify that they will not be breaking
anything in their next release for their internal clients!  Now, you
could give them a complete guide, all from the metadata, about how they
should upgrade their code. The best form of code communication!

&gt;<i> 
</I>&gt;<i> The only way this would be remotely responsible is to entirely rip out
</I>&gt;<i> the API from the library, so every app that depended on it got a
</I>&gt;<i> message &quot;The method does not exist, replace with XXX&quot;.    
</I>&gt;<i> 
</I>
Now, all of the API changes could be noted easily at build time as
failing, so they can refactor until they are green. A tool like that
could be used by other people too. Lots of library writers with large
code bases could use it, I'm sure.

&gt;<i> 
</I>&gt;<i> Faced with ripping out the API, or keeping the behavior, I will side
</I>&gt;<i> with &quot;keep the behavior&quot; and anyone that wants to get access to
</I>&gt;<i> ~/Documents, will have to deal with this difference.   
</I>&gt;<i> 
</I>
Again, you'd be ripping out APIs, but maybe you spit out two dlls, one
to be used at compile time and another for runtime. That way they could
see in the report printout that they still have API calls that are
invalid, though it wouldn't technically fail the build, because that
code that is removed could still be present in the compile-time dll. Now
that I think about it, you could make it even cooler: say you have a
serries of these DLLs, you could create a tool to combine several
versions together into one patched compile-time DLL. If you're going
from something like 1.3 -&gt; 1.7, as a downstream user, I wouldn't have to
apply 1.4.diff.dll, 1.5.diff.dll, 1.6.diff.dll, and 1.7.diff.dll.
Instead, the tool could combine multiple migrations into one file,
annotating which breakage comes from which release.

&gt;<i> 
</I>&gt;<i> People *porting* software already have to do a lot of work to port,
</I>&gt;<i> this is something else that they will deal with.    People that
</I>&gt;<i> trusted us with their code in the first place should not pay the
</I>&gt;<i> price.
</I>&gt;<i>  
</I>
As I said, this would actually pretty well split the labor for porting
and maintaining software. All of the existing downstream users would be
made aware of potential breaks and how to fix them, and upstream users
can submit patches and reports about how the API should be fixed, so
that it can be compared to &quot;the other&quot; platform's behavior. Maybe even
run them both on a Windows build box, so that you can constantly see
whether the submitted patches actually conform to the submission. (Maybe
even use PEX for this, to inject behavior to see if the method calls
fail in the same way?)

&gt;<i> 
</I>&gt;<i> Feel free to fork Mono and maintain Mono on your own with your patch.
</I>&gt;<i> 
</I>
No thanks.

&gt;<i> 
</I>&gt;<i> Maybe history will prove you were right :-)
</I>&gt;<i> Miguel
</I>
Unlikely. I like my solution better ;) 

Sorry if this was long and kind of rambling. I think about this kind of
stuff a lot, as a (somewhat) former build engineer. I think this kind of
stuff is pretty cool, and it was an interesting thought experiment I
thought I could write down. With a basic appraisal, it doesn't seem
_too_ outlandish that at least some minor functional bits could be done,
though some of the advanced functionality would, of course, require
significantly more work -- possibly much more than a neophyte to the
toolchain like myself could envision. Does anyone else think something
like this _could_ be done? Would there be any value in it?

-Gabe

;tldr: Scumbag developer has weird idea, foists it on people he's never
met, on a platform he's not an expert on, and asks for serious feedback.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="037954.html">[Mono-dev] Environment.GetFolderPath() behaviour inconsistent with .NET
</A></li>
	<LI>Next message: <A HREF="037952.html">[Mono-dev] Generating Cocoa bindings through Objective-C	introspection?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37955">[ date ]</a>
              <a href="thread.html#37955">[ thread ]</a>
              <a href="subject.html#37955">[ subject ]</a>
              <a href="author.html#37955">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
