<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] Optimization to System.Collections.Generic.List
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Optimization%20to%20System.Collections.Generic.List&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015744.html">
   <LINK REL="Next"  HREF="015737.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] Optimization to System.Collections.Generic.List</H1>
    <B>Laurent Debacker</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Optimization%20to%20System.Collections.Generic.List&In-Reply-To="
       TITLE="[Mono-dev] [PATCH] Optimization to System.Collections.Generic.List">debackerl at gmail.com
       </A><BR>
    <I>Sat Nov 12 13:13:37 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="015744.html">[Mono-dev] [PATCH] Update InternalsVisibleTo check
</A></li>
        <LI>Next message: <A HREF="015737.html">[Mono-dev] [PATCH] Optimization to System.Collections.Generic.List
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15732">[ date ]</a>
              <a href="thread.html#15732">[ thread ]</a>
              <a href="subject.html#15732">[ subject ]</a>
              <a href="author.html#15732">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi!

The file is a modified version of
mcs/class/corlib/System.Collections.Generic/List.cs revision 52947.

I've modified the ForEach method so that it no longer uses the
enumerator. This avoids a lot of method calls to Enumerator (and the
creation of yet another Enumerator object).

A simple test of the method was 3 times faster with my optimization.

I've also updated
public List &lt;TOutput&gt; ConvertAll &lt;TOutput&gt; (Converter &lt;T, TOutput&gt; converter)
and
public List &lt;T&gt; FindAll (Predicate &lt;T&gt; match)
to use the ForEach method instead of the foreach token.

If you want a patch, please give me the command line I have to type to
make sure the format is ok.

Here is my sample test compiled with MSFT's .NET 2 RTM.

List1&lt;Foo&gt; aa = new List1&lt;Foo&gt;(); // Mono's List
List2&lt;Foo&gt; ab = new List2&lt;Foo&gt;(); // My patch
for(int i = 0 ; i &lt; 10000 ; i++)
{
    Foo f = new Foo();
    aa.Add(f);
    ab.Add(f);
}

DateTime timee = DateTime.Now;
for(int i = 0 ; i &lt; 2000 ; i++)
{
    aa.ForEach( delegate(Foo f) { f.Test(1); } );
}
Console.WriteLine((DateTime.Now - timee).TotalSeconds + &quot;secs&quot;);

timee = DateTime.Now;
for(int i = 0 ; i &lt; 2000 ; i++)
{
    ab.ForEach( delegate(Foo f) { f.Test(1); } );
}
Console.WriteLine((DateTime.Now - timee).TotalSeconds + &quot;secs&quot;);

Have a nice day,
Laurent Debacker.
-------------- next part --------------
//
// System.Collections.Generic.List
//
// Authors:
//    Ben Maurer (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">bmaurer at ximian.com</A>)
//    Martin Baulig (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">martin at ximian.com</A>)
//    Carlos Alberto Cortez (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">calberto.cortez at gmail.com</A>)
//    David Waite (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mass at akuma.org</A>)
//    Laurent Debacker (debackerl AT gmail com)
//
// (C) 2004 Novell, Inc.
// (C) 2005 David Waite
//

//
// Copyright (C) 2004 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
// Copyright (C) 2005 David Waite
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#if NET_2_0
using System;
using System.Collections;
using System.Collections.ObjectModel;
using System.Runtime.InteropServices;

namespace System.Collections.Generic {
	[Serializable]
	public class List &lt;T&gt; : IList &lt;T&gt;, IList, ICollection {
		T [] data;
		int size;
		int version;
		
		static readonly T [] EmptyArray = new T [0]; 
		const int DefaultCapacity = 4;
		
		public List ()
		{
			data = EmptyArray;
		}
		
		public List (IEnumerable &lt;T&gt; collection)
		{
			CheckCollection (collection);

			// initialize to needed size (if determinable)
			ICollection &lt;T&gt; c = collection as ICollection &lt;T&gt;;
			if (c == null)
			{
				data = EmptyArray;
				AddEnumerable (collection);
			}
			else
			{
				data = new T [c.Count];
				AddCollection (c);
			}
		}
		
		public List (int capacity)
		{
			if (capacity &lt; 0)
				throw new ArgumentOutOfRangeException (&quot;capacity&quot;);
			data = new T [capacity];
		}
		
		internal List (T [] data, int size)
		{
			this.data = data;
			this.size = size;
		}
		public void Add (T item)
		{
			GrowIfNeeded (1);
			data [size ++] = item;
		}
		
		void GrowIfNeeded (int newCount)
		{
			int minimumSize = size + newCount;
			if (minimumSize &gt; data.Length)
				Capacity = Math.Max (Math.Max (Capacity * 2, DefaultCapacity), minimumSize);
		}
		
		void CheckRange (int idx, int count)
		{
			if (idx &lt; 0)
				throw new ArgumentOutOfRangeException (&quot;index&quot;);
			
			if (count &lt; 0)
				throw new ArgumentOutOfRangeException (&quot;count&quot;);

			if ((uint) idx + (uint) count &gt; (uint) size)
				throw new ArgumentException (&quot;index and count exceed length of list&quot;);
		}
		
		void AddCollection (ICollection &lt;T&gt; collection)
		{
			int collectionCount = collection.Count;
			GrowIfNeeded (collectionCount);			 
			collection.CopyTo (data, size);
			size += collectionCount;
		}
		void AddEnumerable (IEnumerable &lt;T&gt; enumerable)
		{
			foreach (T t in enumerable)
			{
				Add (t);
			}
		}

		public void AddRange (IEnumerable &lt;T&gt; collection)
		{
			CheckCollection (collection);
			
			ICollection &lt;T&gt; c = collection as ICollection &lt;T&gt;;
			if (c != null)
				AddCollection (c);
			else
				AddEnumerable (collection);
		}
		
		public ReadOnlyCollection &lt;T&gt; AsReadOnly ()
		{
			return new ReadOnlyCollection &lt;T&gt; (this);
		}
		
		public int BinarySearch (T item)
		{
			return Array.BinarySearch (data, item);
		}
		
		public int BinarySearch (T item, IComparer &lt;T&gt; comparer)
		{
			return Array.BinarySearch (data, item, comparer);
		}
		
		public int BinarySearch (int index, int count, T item, IComparer &lt;T&gt; comparer)
		{
			CheckRange (index, count);
			return Array.BinarySearch (data, index, size, item, comparer);
		}
		
		public void Clear ()
		{
			Array.Clear (data, 0, data.Length);
			size = 0;
		}
		
		public bool Contains (T item)
		{
			return IndexOf (item) != -1;
		}
		
		public List &lt;TOutput&gt; ConvertAll &lt;TOutput&gt; (Converter &lt;T, TOutput&gt; converter)
		{
			if (converter == null)
				throw new ArgumentNullException (&quot;converter&quot;);
			List &lt;TOutput&gt; u = new List &lt;TOutput&gt; (size);
			this.ForEach( delegate(T t) { u.Add (converter (t)); } );
			return u;
		}
		
		public void CopyTo (T [] array)
		{
			Array.Copy (data, 0, array, 0, size);
		}
		
		public void CopyTo (T [] array, int arrayIndex)
		{
			Array.Copy (data, 0, array, arrayIndex, size);
		}
		
		public void CopyTo (int index, T [] array, int arrayIndex, int count)
		{
			CheckRange (index, count);
			Array.Copy (data, index, array, arrayIndex, count);
		}

		public bool Exists (Predicate &lt;T&gt; match)
		{
			return FindIndex (match) != -1;
		}
		
		public T Find (Predicate &lt;T&gt; match)
		{
			int i = FindIndex (match);
			return (i != -1) ? data [i] : default (T);
		}
		void CheckMatch (Predicate &lt;T&gt; match)
		{
			if (match == null)
				throw new ArgumentNullException (&quot;match&quot;);
		}
		
		// Maybe we could make this faster. For example, you could
		// make a bit set with stackalloc for which elements to copy
		// then you could size the array correctly.
		public List &lt;T&gt; FindAll (Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			List &lt;T&gt; f = new List &lt;T&gt; ();
			
			this.ForEach( delegate(T t) { if (match (t)) f.Add (t); } );
			
			return f;
		}
		
		public int FindIndex (Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			return GetIndex (0, size, match);
		}
		
		public int FindIndex (int startIndex, Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			CheckIndex (startIndex);
			return GetIndex (startIndex, size - startIndex, match);
		}
		public int FindIndex (int startIndex, int count, Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			CheckRange (startIndex, count);
			return GetIndex (startIndex, count, match);
		}
		int GetIndex (int startIndex, int count, Predicate &lt;T&gt; match)
		{
			for (int i = startIndex; i &lt; startIndex + count; i ++)
				if (match (data [i]))
					return i;
				
			return -1;
		}
		
		public T FindLast (Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			int i = GetLastIndex (0, size, match);
			return i == -1 ? default (T) : this [i];
		}
		
		public int FindLastIndex (Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			return GetLastIndex (0, size, match);
		}
		
		public int FindLastIndex (int startIndex, Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			CheckIndex (startIndex);
			return GetLastIndex (0, startIndex + 1, match);
		}
		
		public int FindLastIndex (int startIndex, int count, Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			int start = startIndex - count + 1;
			CheckRange (start, count);
			return GetLastIndex (start, count, match);
		}

		int GetLastIndex (int startIndex, int count, Predicate &lt;T&gt; match)
		{
			// unlike FindLastIndex, takes regular params for search range
			for (int i = startIndex + count; i != startIndex;)
				if (match (data [--i]))
					return i;
			return -1;	
		}
		
		public void ForEach (Action &lt;T&gt; action)
		{
			if (action == null)
				throw new ArgumentNullException (&quot;action&quot;);
			
			int idx = size;
			while(--idx &gt;= 0)
			{
				// MSFT does not seem to check version of the List
				action(data[idx]);
			}
		}
		
		public Enumerator GetEnumerator ()
		{
			return new Enumerator (this);
		}
		
		public List &lt;T&gt; GetRange (int index, int count)
		{
			CheckRange (index, count);
			T [] tmpArray = new T [count];
			Array.Copy (data, index, tmpArray, 0, count);
			return new List &lt;T&gt; (tmpArray, count);
		}
		
		public int IndexOf (T item)
		{
			return Array.IndexOf (data, item, 0, size);
		}
		
		public int IndexOf (T item, int index)
		{
			CheckIndex (index);
			return Array.IndexOf (data, item, index, size - index);
		}
		
		public int IndexOf (T item, int index, int count)
		{
			CheckRange (index, count);
			return Array.IndexOf (data, item, index, count);
		}
		
		void Shift (int start, int delta)
		{
			if (delta &lt; 0)
				start -= delta;
			
			Array.Copy (data, start, data, start + delta, size - start);
			
			size += delta;
		}

		void CheckIndex (int index)
		{
			if ((uint) index &gt;= (uint) size)
				throw new ArgumentOutOfRangeException (&quot;index&quot;);
		}
		
		public void Insert (int index, T item)
		{
			if ((uint) index &gt; (uint) size)
				throw new ArgumentOutOfRangeException (&quot;index&quot;);
			
			GrowIfNeeded (1);
			Shift (index, 1);
			this [index] = item;
				
		}

		void CheckCollection (IEnumerable &lt;T&gt; collection)
		{
			if (collection == null)
				throw new ArgumentNullException (&quot;collection&quot;);
		}
		
		public void InsertRange (int index, IEnumerable &lt;T&gt; collection)
		{
			CheckCollection (collection);
			CheckIndex (index);
			ICollection &lt;T&gt; c = collection as ICollection &lt;T&gt;;
			if (c != null)
				InsertCollection (index, c);
			else
				InsertEnumeration (index, collection);
		}

		void InsertCollection (int index, ICollection &lt;T&gt; collection)
		{
			int collectionCount = collection.Count;
			GrowIfNeeded (collectionCount);
			
			Shift (index, collectionCount);
			collection.CopyTo (data, index);
		}
		void InsertEnumeration (int index, IEnumerable &lt;T&gt; enumerable)
		{
			foreach (T t in enumerable)
				Insert (index++, t);		
		}

		public int LastIndexOf (T item)
		{
			return Array.LastIndexOf (data, item, 0, size);
		}
		
		public int LastIndexOf (T item, int index)
		{
			CheckIndex (index);
			return Array.LastIndexOf (data, item, index, size - index);
		}
		
		public int LastIndexOf (T item, int index, int count)
		{
			CheckRange (index, count);			 
			return Array.LastIndexOf (data, item, index, count);
		}
		
		public bool Remove (T item)
		{
			int loc = IndexOf (item);
			if (loc != -1)
				RemoveAt (loc);
			
			return loc != -1;
		}
		
		[MonoTODO (&quot;I can make it faster than this...&quot;)]
		public int RemoveAll (Predicate &lt;T&gt; match)
		{
			CheckMatch (match);

			int index = 0;
			int c = 0;
			while ((index = GetIndex (index, size - index, match)) != -1) {
				RemoveAt (index);
				c ++;
			}
			
			Array.Clear (data, size, c);
			return c;
		}
		
		public void RemoveAt (int index)
		{
			CheckIndex (index);
			Shift (index, -1);
			Array.Clear (data, size, 0);
		}
		
		public void RemoveRange (int index, int count)
		{
			CheckRange (index, count);
			Shift (index, -count);
			Array.Clear (data, size, count);
		}
		
		public void Reverse ()
		{
			Array.Reverse (data, 0, size);
		}
		public void Reverse (int index, int count)
		{
			CheckRange (index, count);
			Array.Reverse (data, index, count);
		}
		
		public void Sort ()
		{
			Array.Sort (data, 0, size, (IComparer) Comparer &lt;T&gt;.Default);
		}
		public void Sort (IComparer &lt;T&gt; comparer)
		{
			Array.Sort (data, 0, size, (IComparer) comparer);
		}
		
		// Waiting on Array
		[MonoTODO]
		public void Sort (Comparison &lt;T&gt; comparison)
		{
			throw new NotImplementedException ();
		}
		
		public void Sort (int index, int count, IComparer &lt;T&gt; comparer)
		{
			CheckRange (index, count);
			Array.Sort (data, index, count, (IComparer) comparer);
		}

		public T [] ToArray ()
		{
			T [] t = new T [size];
			Array.Copy (data, t, size);
			
			return t;
		}
		
		public void TrimExcess ()
		{
			Capacity = size;
		}
		
		public bool TrueForAll (Predicate &lt;T&gt; match)
		{
			CheckMatch (match);
			
			foreach (T t in this)
				if (!match (t))
					return false;
				
			return true;
		}
		
		public int Capacity {
			get { 
				return data.Length;
			}
			set {
				if ((uint) value &lt; (uint) size)
					throw new ArgumentOutOfRangeException ();
				
				Array.Resize (ref data, value);
			}
		}
		
		public int Count {
			get { return size; }
		}
		
		public T this [int index] {
			get {
				if ((uint) index &gt;= (uint) size)
					throw new ArgumentOutOfRangeException (&quot;index&quot;);
				return data [index];
			}
			set {
				CheckIndex (index);
				data [index] = value;
			}
		}
		
#region Interface implementations.
		IEnumerator &lt;T&gt; IEnumerable &lt;T&gt;.GetEnumerator ()
		{
			return GetEnumerator ();
		}
		
		void ICollection.CopyTo (Array array, int arrayIndex)
		{
			Array.Copy (data, 0, array, arrayIndex, size);
		}
		
		IEnumerator IEnumerable.GetEnumerator ()
		{
			return GetEnumerator ();
		}
		
		int IList.Add (object item)
		{
			Add ((T) item);
			return size - 1;
		}
		
		bool IList.Contains (object item)
		{
			return Contains ((T) item);
		}
		
		int IList.IndexOf (object item)
		{
			return IndexOf ((T) item);
		}
		
		void IList.Insert (int index, object item)
		{
			Insert (index, (T) item);
		}
		
		void IList.Remove (object item)
		{
			Remove ((T) item);
		}
		
		bool ICollection &lt;T&gt;.IsReadOnly {
			get { return false; }
		}
		bool ICollection.IsSynchronized {
			get { return false; }
		}
		
		object ICollection.SyncRoot {
			get { return this; }
		}
		bool IList.IsFixedSize {
			get { return false; }
		}
		
		bool IList.IsReadOnly {
			get { return false; }
		}
		
		object IList.this [int index] {
			get { return this [index]; }
			set { this [index] = (T) value; }
		}
#endregion
				
		public struct Enumerator : IEnumerator &lt;T&gt;, IDisposable {
			const int NOT_STARTED = -2;
			
			// this MUST be -1, because we depend on it in move next.
			// we just decr the size, so, 0 - 1 == FINISHED
			const int FINISHED = -1;
			
			List &lt;T&gt; l;
			int idx;
			int ver;
			
			internal Enumerator (List &lt;T&gt; l)
			{
				this.l = l;
				idx = NOT_STARTED;
				ver = l.version;
			}
			
			// for some fucked up reason, MSFT added a useless dispose to this class
			// It means that in foreach, we must still do a try/finally. Broken, very
			// broken.
			public void Dispose ()
			{
				idx = NOT_STARTED;
			}
			
			public bool MoveNext ()
			{
				if (ver != l.version)
					throw new InvalidOperationException ();
				
				if (idx == NOT_STARTED)
					idx = l.size;
				
				return idx != FINISHED &amp;&amp; -- idx != FINISHED;
			}
			
			public T Current {
				get {
					if (idx &lt; 0)
						throw new InvalidOperationException ();
					
					return l.data [l.size - 1 - idx];
				}
			}
			
			void IEnumerator.Reset ()
			{
				if (ver != l.version)
					throw new InvalidOperationException ();
				
				idx = NOT_STARTED;
			}
			
			object IEnumerator.Current {
				get { return Current; }
			}
		}
	}
}
#endif






</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015744.html">[Mono-dev] [PATCH] Update InternalsVisibleTo check
</A></li>
	<LI>Next message: <A HREF="015737.html">[Mono-dev] [PATCH] Optimization to System.Collections.Generic.List
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15732">[ date ]</a>
              <a href="thread.html#15732">[ thread ]</a>
              <a href="subject.html#15732">[ subject ]</a>
              <a href="author.html#15732">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
