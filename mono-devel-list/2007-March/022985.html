<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] patch for (and question	about)	Mono.Security.Protocol.Ntlm
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20patch%20for%20%28and%20question%0A%09about%29%09Mono.Security.Protocol.Ntlm&In-Reply-To=46082414.7050309%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022978.html">
   <LINK REL="Next"  HREF="022973.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] patch for (and question	about)	Mono.Security.Protocol.Ntlm</H1>
    <B>Sebastien Pouliot</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20patch%20for%20%28and%20question%0A%09about%29%09Mono.Security.Protocol.Ntlm&In-Reply-To=46082414.7050309%40ximian.com"
       TITLE="[Mono-dev] patch for (and question	about)	Mono.Security.Protocol.Ntlm">sebastien at ximian.com
       </A><BR>
    <I>Tue Mar 27 10:25:47 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="022978.html">[Mono-dev] patch for (and question about)	Mono.Security.Protocol.Ntlm
</A></li>
        <LI>Next message: <A HREF="022973.html">[Mono-dev] BitArray patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22985">[ date ]</a>
              <a href="thread.html#22985">[ thread ]</a>
              <a href="subject.html#22985">[ subject ]</a>
              <a href="author.html#22985">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Tue, 2007-03-27 at 04:50 +0900, Atsushi Eno wrote:
&gt;<i> Hi,
</I>&gt;<i> 
</I>&gt;<i> During WCF hacking I found that Mono.Security.Protocol.Ntlm looks
</I>&gt;<i> based on somewhat old analysis.
</I>
IIRC (I'm not feeling well enough to fully trust my memory today) I did
this code when Daniel Morgan asked (2003) my help on the SQL Server
authentication issues he had (integrated security). Later on (2004), it
was &quot;adapted&quot; to be used for HttpWebRequest.

But being old isn't a problem in itself as NTLM, a successor to OS/2 1.x
LM, is quite old.

&gt;<i> Currently the code does not look &quot;version&quot; aware. According to
</I>&gt;<i> <A HREF="http://davenport.sourceforge.net/ntlm.html">http://davenport.sourceforge.net/ntlm.html</A> , 
</I>
The two unofficial specs I had at the time, including an earlier version
of your link, did not agree 100% with each other. So I merged a few
things (from both).

&gt;<i> there seems three
</I>&gt;<i> ntlm versions and the message layout is diffrent for each version.
</I>&gt;<i> And WCF SSPI negotiation seems based on version3, which is not
</I>&gt;<i> what current code supports.
</I>
That would make sense. NTLM always tried to be backward compatible with
earlier version and that caused a lot of problems over the years.

&gt;<i> So I have created a patch to add support for every version of NTLM.
</I>&gt;<i> It is not a small, but the purpose is to handle &quot;optional&quot; fields
</I>&gt;<i> denoted in the document above.
</I>
Great work! I'll need to check a few things, like API forward
compatibility before it's committed.

&gt;<i> This patch however breaks some NUnit tests. 
</I>
Which ones ?

&gt;<i> But as long as I see
</I>&gt;<i> the test buffers, they do not seem conformant to the document
</I>&gt;<i> above... how were those test buffers created?
</I>
Most of them have an URL from where the data was taken to build the test
case. They were part of the (earlier) specs so if the unofficial specs
were updated maybe the samples were too. 

However it also means that the code was working &quot;as is&quot;, so it may hide
other issues too.

A good way to be sure there's no regression is to test the code against
SQL Server 2000+ and against IIS with integrated security.

&gt;<i> (Also, existing message type1 looks based on version 2, while
</I>&gt;<i> message type2 and message type3 do not look so, but I'm not sure.
</I>&gt;<i> They hence resulted in weird default version mismatch in my patch...)
</I>&gt;<i> 
</I>&gt;<i> Atsushi Eno
</I>&gt;<i> plain text document attachment (version-aware-ntlm.patch)
</I>&gt;<i> Index: Mono.Security.Protocol.Ntlm/MessageBase.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.Protocol.Ntlm/MessageBase.cs	(revision 74928)
</I>&gt;<i> +++ Mono.Security.Protocol.Ntlm/MessageBase.cs	(working copy)
</I>&gt;<i> @@ -4,9 +4,10 @@
</I>&gt;<i>  //
</I>&gt;<i>  // Author:
</I>&gt;<i>  //	Sebastien Pouliot  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>&gt;
</I>&gt;<i> +//	Atsushi Enomoto &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>  //
</I>&gt;<i>  // Copyright (C) 2003 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
</I>&gt;<i> -// Copyright (C) 2004 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +// Copyright (C) 2004, 2007 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  // References
</I>&gt;<i>  // a.	NTLM Authentication Scheme for HTTP, Ronald Tschal&#228;r
</I>&gt;<i> @@ -40,15 +41,34 @@
</I>&gt;<i>  namespace Mono.Security.Protocol.Ntlm {
</I>&gt;<i>  
</I>&gt;<i>  	public abstract class MessageBase {
</I>&gt;<i> +		static byte [] _current_os_version = GetOSVersion ();
</I>&gt;<i>  
</I>&gt;<i> +		static byte [] GetOSVersion ()
</I>&gt;<i> +		{
</I>&gt;<i> +			Version v = Environment.OSVersion.Version;
</I>&gt;<i> +			byte [] bytes = new byte [8];
</I>&gt;<i> +			bytes [0] = (byte) v.Major;
</I>&gt;<i> +			bytes [1] = (byte) v.Minor;
</I>&gt;<i> +			bytes [2] = (byte) v.Build;
</I>&gt;<i> +			bytes [3] = (byte) (v.Build &gt;&gt; 8);
</I>&gt;<i> +			bytes [7] = 0xF;
</I>&gt;<i> +			return bytes;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		static private byte[] header = { 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00 };
</I>&gt;<i>  		
</I>&gt;<i>  		private int _type;
</I>&gt;<i>  		private NtlmFlags _flags;
</I>&gt;<i> +		private NtlmVersion _version;
</I>&gt;<i> +		private byte [] _osversion = _current_os_version;
</I>&gt;<i>  
</I>&gt;<i> -		protected MessageBase (int messageType) 
</I>&gt;<i> +		protected MessageBase (int messageType) : this (messageType, NtlmVersion.Version1)
</I>&gt;<i>  		{
</I>&gt;<i> +		}
</I>&gt;<i> +		protected MessageBase (int messageType, NtlmVersion version) 
</I>&gt;<i> +		{
</I>&gt;<i>  			_type = messageType;
</I>&gt;<i> +			_version = version;
</I>&gt;<i>  		}
</I>&gt;<i>  		
</I>&gt;<i>  		public NtlmFlags Flags {
</I>&gt;<i> @@ -56,10 +76,19 @@
</I>&gt;<i>  			set { _flags = value; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public byte [] OSVersion {
</I>&gt;<i> +			get { return (byte []) _osversion.Clone (); }
</I>&gt;<i> +			set { _osversion = (byte []) value.Clone (); }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public int Type { 
</I>&gt;<i>  			get { return _type; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public NtlmVersion Version {
</I>&gt;<i> +			get { return _version; }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		protected byte[] PrepareMessage (int messageSize) 
</I>&gt;<i>  		{
</I>&gt;<i>  			byte[] message = new byte [messageSize];
</I>&gt;<i> @@ -100,5 +129,12 @@
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public abstract byte[] GetBytes ();
</I>&gt;<i> +
</I>&gt;<i> +		internal byte [] CreateSubArray (byte [] source, int offset, int length)
</I>&gt;<i> +		{
</I>&gt;<i> +			byte [] ret = new byte [length];
</I>&gt;<i> +			Array.Copy (source, offset, ret, 0, length);
</I>&gt;<i> +			return ret;
</I>&gt;<i> +		}
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i> Index: Mono.Security.Protocol.Ntlm/NtlmVersion.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.Protocol.Ntlm/NtlmVersion.cs	(revision 0)
</I>&gt;<i> +++ Mono.Security.Protocol.Ntlm/NtlmVersion.cs	(revision 0)
</I>&gt;<i> @@ -0,0 +1,41 @@
</I>&gt;<i> +//
</I>&gt;<i> +// Mono.Security.Protocol.Ntlm.NtlmVersion
</I>&gt;<i> +//
</I>&gt;<i> +// Author:
</I>&gt;<i> +//	Atsushi Enomoto &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i> +//
</I>&gt;<i> +// (C) 2007 Novell, Inc. (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +//
</I>&gt;<i> +
</I>&gt;<i> +//
</I>&gt;<i> +// Permission is hereby granted, free of charge, to any person obtaining
</I>&gt;<i> +// a copy of this software and associated documentation files (the
</I>&gt;<i> +// &quot;Software&quot;), to deal in the Software without restriction, including
</I>&gt;<i> +// without limitation the rights to use, copy, modify, merge, publish,
</I>&gt;<i> +// distribute, sublicense, and/or sell copies of the Software, and to
</I>&gt;<i> +// permit persons to whom the Software is furnished to do so, subject to
</I>&gt;<i> +// the following conditions:
</I>&gt;<i> +// 
</I>&gt;<i> +// The above copyright notice and this permission notice shall be
</I>&gt;<i> +// included in all copies or substantial portions of the Software.
</I>&gt;<i> +// 
</I>&gt;<i> +// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
</I>&gt;<i> +// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
</I>&gt;<i> +// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
</I>&gt;<i> +// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
</I>&gt;<i> +// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
</I>&gt;<i> +// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
</I>&gt;<i> +// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i> +//
</I>&gt;<i> +
</I>&gt;<i> +using System;
</I>&gt;<i> +
</I>&gt;<i> +namespace Mono.Security.Protocol.Ntlm 
</I>&gt;<i> +{
</I>&gt;<i> +	public enum NtlmVersion
</I>&gt;<i> +	{
</I>&gt;<i> +		Version1,
</I>&gt;<i> +		Version2,
</I>&gt;<i> +		Version3
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> Index: Mono.Security.Protocol.Ntlm/ChallengeResponse.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.Protocol.Ntlm/ChallengeResponse.cs	(revision 74928)
</I>&gt;<i> +++ Mono.Security.Protocol.Ntlm/ChallengeResponse.cs	(working copy)
</I>&gt;<i> @@ -4,9 +4,10 @@
</I>&gt;<i>  //
</I>&gt;<i>  // Author:
</I>&gt;<i>  //	Sebastien Pouliot &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>&gt;
</I>&gt;<i> +//	Atsushi Enomoto &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>  //
</I>&gt;<i>  // (C) 2003 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
</I>&gt;<i> -// (C) 2004 Novell (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +// (C) 2004, 2007 Novell (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  // References
</I>&gt;<i>  // a.	NTLM Authentication Scheme for HTTP, Ronald Tschal&#228;r
</I>&gt;<i> @@ -156,6 +157,29 @@
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public byte [] LMSessionKey {
</I>&gt;<i> +			get {
</I>&gt;<i> +				if (_disposed)
</I>&gt;<i> +					throw new ObjectDisposedException (&quot;too late&quot;);
</I>&gt;<i> +
</I>&gt;<i> +				byte[] lm = LM;
</I>&gt;<i> +				byte[] pwd = new byte [14];
</I>&gt;<i> +				Buffer.BlockCopy (lm, 0, pwd, 0, 8);
</I>&gt;<i> +				for (int i = 8; i &lt; 14; i++)
</I>&gt;<i> +					pwd [i] = 0xBD;
</I>&gt;<i> +				byte[] response = new byte [16];
</I>&gt;<i> +				DES des = DES.Create ();
</I>&gt;<i> +				des.Mode = CipherMode.ECB;
</I>&gt;<i> +				des.Key = PrepareDESKey (pwd, 0);
</I>&gt;<i> +				ICryptoTransform ct = des.CreateEncryptor ();
</I>&gt;<i> +				ct.TransformBlock (lm, 0, 8, response, 0);
</I>&gt;<i> +				des.Key = PrepareDESKey (pwd, 7);
</I>&gt;<i> +				ct = des.CreateEncryptor ();
</I>&gt;<i> +				ct.TransformBlock (lm, 0, 8, response, 8);
</I>&gt;<i> +				return response;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		// IDisposable method
</I>&gt;<i>  
</I>&gt;<i>  		public void Dispose () 
</I>&gt;<i> Index: Mono.Security.Protocol.Ntlm/NtlmFlags.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.Protocol.Ntlm/NtlmFlags.cs	(revision 74928)
</I>&gt;<i> +++ Mono.Security.Protocol.Ntlm/NtlmFlags.cs	(working copy)
</I>&gt;<i> @@ -3,9 +3,10 @@
</I>&gt;<i>  //
</I>&gt;<i>  // Author:
</I>&gt;<i>  //	Sebastien Pouliot &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>&gt;
</I>&gt;<i> +//	Atsushi Enomoto &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>  //
</I>&gt;<i>  // (C) 2003 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
</I>&gt;<i> -// (C) 2004 Novell (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +// (C) 2004, 2007 Novell (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  // References
</I>&gt;<i>  // a.	NTLM Authentication Scheme for HTTP, Ronald Tschal&#228;r
</I>&gt;<i> @@ -47,8 +48,18 @@
</I>&gt;<i>  		NegotiateOem = 0x00000002,
</I>&gt;<i>  		// This requests that the server send the authentication target with the Type 2 reply.
</I>&gt;<i>  		RequestTarget = 0x00000004,
</I>&gt;<i> +		// Negotiate Sign
</I>&gt;<i> +		NegotiateSign = 0x00000010,
</I>&gt;<i> +		// Negotiate Seal
</I>&gt;<i> +		NegotiateSeal = 0x00000020,
</I>&gt;<i> +		// Negotiate DatagramStyle
</I>&gt;<i> +		NegotiateDatagramStyle = 0x00000040,
</I>&gt;<i> +		// Negotiate Lan Manager Key
</I>&gt;<i> +		NegotiateLm = 0x00000080,
</I>&gt;<i>  		// Indicates that NTLM authentication is supported.
</I>&gt;<i>  		NegotiateNtlm = 0x00000200,
</I>&gt;<i> +		// Indicates that NTLM authentication is supported.
</I>&gt;<i> +		NegotiateAnonymous = 0x00000800,
</I>&gt;<i>  		// When set, the client will send with the message the name of the domain in which the workstation has membership.
</I>&gt;<i>  		NegotiateDomainSupplied = 0x00001000,
</I>&gt;<i>  		// Indicates that the client is sending its workstation name with the message.  
</I>&gt;<i> @@ -59,6 +70,8 @@
</I>&gt;<i>  		NegotiateNtlm2Key = 0x00080000,
</I>&gt;<i>  		// Indicates that this client supports strong (128-bit) encryption.
</I>&gt;<i>  		Negotiate128 = 0x20000000,
</I>&gt;<i> +		// Negotiate Key Exchange
</I>&gt;<i> +		NegotiateKeyExchange = 0x40000000,
</I>&gt;<i>  		// Indicates that this client supports medium (56-bit) encryption.
</I>&gt;<i>  		Negotiate56 = (unchecked ((int) 0x80000000))
</I>&gt;<i>  	}
</I>&gt;<i> Index: Mono.Security.Protocol.Ntlm/Type1Message.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.Protocol.Ntlm/Type1Message.cs	(revision 74928)
</I>&gt;<i> +++ Mono.Security.Protocol.Ntlm/Type1Message.cs	(working copy)
</I>&gt;<i> @@ -3,9 +3,10 @@
</I>&gt;<i>  //
</I>&gt;<i>  // Author:
</I>&gt;<i>  //	Sebastien Pouliot &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>&gt;
</I>&gt;<i> +//	Atsushi Enomoto &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>  //
</I>&gt;<i>  // (C) 2003 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
</I>&gt;<i> -// Copyright (C) 2004 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +// Copyright (C) 2004, 2007 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  // References
</I>&gt;<i>  // a.	NTLM Authentication Scheme for HTTP, Ronald Tschal&#228;r
</I>&gt;<i> @@ -44,16 +45,24 @@
</I>&gt;<i>  		private string _host;
</I>&gt;<i>  		private string _domain;
</I>&gt;<i>  
</I>&gt;<i> -		public Type1Message () : base (1)
</I>&gt;<i> +		public Type1Message () : this (NtlmVersion.Version2)
</I>&gt;<i>  		{
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public Type1Message (NtlmVersion version) : base (1, version)
</I>&gt;<i> +		{
</I>&gt;<i>  			// default values
</I>&gt;<i>  			_domain = Environment.UserDomainName;
</I>&gt;<i>  			_host = Environment.MachineName;
</I>&gt;<i>  			Flags = (NtlmFlags) 0xb203;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public Type1Message (byte[] message) : base (1)
</I>&gt;<i> +		public Type1Message (byte[] message) : this (message, NtlmVersion.Version2)
</I>&gt;<i>  		{
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public Type1Message (byte[] message, NtlmVersion version) : base (1, version)
</I>&gt;<i> +		{
</I>&gt;<i>  			Decode (message);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> @@ -76,28 +85,44 @@
</I>&gt;<i>  			base.Decode (message);
</I>&gt;<i>  
</I>&gt;<i>  			Flags = (NtlmFlags) BitConverterLE.ToUInt32 (message, 12);
</I>&gt;<i> +			if (Version == NtlmVersion.Version1)
</I>&gt;<i> +				return;
</I>&gt;<i>  
</I>&gt;<i>  			int dom_len = BitConverterLE.ToUInt16 (message, 16);
</I>&gt;<i>  			int dom_off = BitConverterLE.ToUInt16 (message, 20);
</I>&gt;<i>  			_domain = Encoding.ASCII.GetString (message, dom_off, dom_len);
</I>&gt;<i>  
</I>&gt;<i>  			int host_len = BitConverterLE.ToUInt16 (message, 24);
</I>&gt;<i> -			_host = Encoding.ASCII.GetString (message, 32, host_len);
</I>&gt;<i> +			int host_off = BitConverterLE.ToUInt16 (message, 28);
</I>&gt;<i> +			_host = Encoding.ASCII.GetString (message, host_off, host_len);
</I>&gt;<i> +
</I>&gt;<i> +			if (Version != NtlmVersion.Version3)
</I>&gt;<i> +				return;
</I>&gt;<i> +			OSVersion = CreateSubArray (message, 32, 8);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public override byte[] GetBytes () 
</I>&gt;<i>  		{
</I>&gt;<i> -			short dom_len = (short) _domain.Length;
</I>&gt;<i> -			short host_len = (short) _host.Length;
</I>&gt;<i> +			short dom_len = 0, host_len = 0;
</I>&gt;<i> +			if (Version != NtlmVersion.Version1) {
</I>&gt;<i> +				dom_len = (short) _domain.Length;
</I>&gt;<i> +				host_len = (short) _host.Length;
</I>&gt;<i> +			}
</I>&gt;<i>  
</I>&gt;<i> -			byte[] data = PrepareMessage (32 + dom_len + host_len);
</I>&gt;<i> +			int headSize = (Version == NtlmVersion.Version3 ? 40 : 32);
</I>&gt;<i>  
</I>&gt;<i> +			byte[] data = PrepareMessage (headSize + dom_len + host_len);
</I>&gt;<i> +
</I>&gt;<i> +			// v1 contains only the flags.
</I>&gt;<i> +			if (Version == NtlmVersion.Version1)
</I>&gt;<i> +				return data;
</I>&gt;<i> +
</I>&gt;<i>  			data [12] = (byte) Flags;
</I>&gt;<i>  			data [13] = (byte)((uint)Flags &gt;&gt; 8);
</I>&gt;<i>  			data [14] = (byte)((uint)Flags &gt;&gt; 16);
</I>&gt;<i>  			data [15] = (byte)((uint)Flags &gt;&gt; 24);
</I>&gt;<i>  
</I>&gt;<i> -			short dom_off = (short)(32 + host_len);
</I>&gt;<i> +			short dom_off = (short) (headSize + host_len);
</I>&gt;<i>  
</I>&gt;<i>  			data [16] = (byte) dom_len;
</I>&gt;<i>  			data [17] = (byte)(dom_len &gt;&gt; 8);
</I>&gt;<i> @@ -113,8 +138,11 @@
</I>&gt;<i>  			data [28] = 0x20;
</I>&gt;<i>  			data [29] = 0x00;
</I>&gt;<i>  
</I>&gt;<i> +			if (Version == NtlmVersion.Version3)
</I>&gt;<i> +				Buffer.BlockCopy (OSVersion, 0, data, 32, OSVersion.Length);
</I>&gt;<i> +
</I>&gt;<i>  			byte[] host = Encoding.ASCII.GetBytes (_host.ToUpper (CultureInfo.InvariantCulture));
</I>&gt;<i> -			Buffer.BlockCopy (host, 0, data, 32, host.Length);
</I>&gt;<i> +			Buffer.BlockCopy (host, 0, data, headSize, host.Length);
</I>&gt;<i>  
</I>&gt;<i>  			byte[] domain = Encoding.ASCII.GetBytes (_domain.ToUpper (CultureInfo.InvariantCulture));
</I>&gt;<i>  			Buffer.BlockCopy (domain, 0, data, dom_off, domain.Length);
</I>&gt;<i> Index: Mono.Security.Protocol.Ntlm/NtlmTargetInformation.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.Protocol.Ntlm/NtlmTargetInformation.cs	(revision 0)
</I>&gt;<i> +++ Mono.Security.Protocol.Ntlm/NtlmTargetInformation.cs	(revision 0)
</I>&gt;<i> @@ -0,0 +1,103 @@
</I>&gt;<i> +//
</I>&gt;<i> +// Mono.Security.Protocol.Ntlm.NtlmTargetInformation
</I>&gt;<i> +//
</I>&gt;<i> +// Author:
</I>&gt;<i> +//	Atsushi Enomoto  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i> +//
</I>&gt;<i> +// (C) 2007 Novell, Inc. (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +//
</I>&gt;<i> +
</I>&gt;<i> +//
</I>&gt;<i> +// Permission is hereby granted, free of charge, to any person obtaining
</I>&gt;<i> +// a copy of this software and associated documentation files (the
</I>&gt;<i> +// &quot;Software&quot;), to deal in the Software without restriction, including
</I>&gt;<i> +// without limitation the rights to use, copy, modify, merge, publish,
</I>&gt;<i> +// distribute, sublicense, and/or sell copies of the Software, and to
</I>&gt;<i> +// permit persons to whom the Software is furnished to do so, subject to
</I>&gt;<i> +// the following conditions:
</I>&gt;<i> +// 
</I>&gt;<i> +// The above copyright notice and this permission notice shall be
</I>&gt;<i> +// included in all copies or substantial portions of the Software.
</I>&gt;<i> +// 
</I>&gt;<i> +// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
</I>&gt;<i> +// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
</I>&gt;<i> +// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
</I>&gt;<i> +// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
</I>&gt;<i> +// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
</I>&gt;<i> +// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
</I>&gt;<i> +// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i> +//
</I>&gt;<i> +using System;
</I>&gt;<i> +using System.IO;
</I>&gt;<i> +using System.Text;
</I>&gt;<i> +
</I>&gt;<i> +namespace Mono.Security.Protocol.Ntlm {
</I>&gt;<i> +	public class NtlmTargetInformation {
</I>&gt;<i> +		string _server, _domain, _dns_host, _dns_domain;
</I>&gt;<i> +
</I>&gt;<i> +		public string ServerName {
</I>&gt;<i> +			get { return _server; }
</I>&gt;<i> +			set { _server = value; }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public string DomainName {
</I>&gt;<i> +			get { return _domain; }
</I>&gt;<i> +			set { _domain = value; }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public string DnsHostName {
</I>&gt;<i> +			get { return _dns_host; }
</I>&gt;<i> +			set { _dns_host = value; }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public string DnsDomainName {
</I>&gt;<i> +			get { return _dns_domain; }
</I>&gt;<i> +			set { _dns_domain = value; }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public void Decode (byte [] bytes, int length, int offset)
</I>&gt;<i> +		{
</I>&gt;<i> +			int end = offset + length;
</I>&gt;<i> +			for (int pos = offset; pos &lt; end;) {
</I>&gt;<i> +				short type = BitConverterLE.ToInt16 (bytes, pos); // reader.ReadInt16 ();
</I>&gt;<i> +				short blen = BitConverterLE.ToInt16 (bytes, pos + 2); // reader.ReadInt16 ();
</I>&gt;<i> +				string s = Encoding.Unicode.GetString (bytes, pos + 4, blen);
</I>&gt;<i> +				pos += blen + 4;
</I>&gt;<i> +				switch (type) {
</I>&gt;<i> +				case 0: break; // terminator
</I>&gt;<i> +				case 1: ServerName = s; break;
</I>&gt;<i> +				case 2: DomainName = s; break;
</I>&gt;<i> +				case 3: DnsHostName = s; break;
</I>&gt;<i> +				case 4: DnsDomainName = s; break;
</I>&gt;<i> +				default:
</I>&gt;<i> +					throw new ArgumentException (String.Format (&quot;Invalid SSPI message type 2 subblock type: {0}&quot;, type));
</I>&gt;<i> +				}
</I>&gt;<i> +				if (type == 0)
</I>&gt;<i> +					break; // terminator subblock
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public byte [] ToBytes ()
</I>&gt;<i> +		{
</I>&gt;<i> +			MemoryStream ms = new MemoryStream ();
</I>&gt;<i> +			BinaryWriter bw = new BinaryWriter (ms);
</I>&gt;<i> +
</I>&gt;<i> +			WriteName (bw, 1, ServerName);
</I>&gt;<i> +			WriteName (bw, 2, DomainName);
</I>&gt;<i> +			WriteName (bw, 3, DnsHostName);
</I>&gt;<i> +			WriteName (bw, 4, DnsDomainName);
</I>&gt;<i> +			bw.Close ();
</I>&gt;<i> +			return ms.ToArray ();
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		private void WriteName (BinaryWriter bw, short type, string value)
</I>&gt;<i> +		{
</I>&gt;<i> +			if (value == null)
</I>&gt;<i> +				return;
</I>&gt;<i> +			byte [] bytes = Encoding.Unicode.GetBytes (value);
</I>&gt;<i> +			bw.Write (type);
</I>&gt;<i> +			bw.Write ((short) bytes.Length);
</I>&gt;<i> +			bw.Write (bytes);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> Index: Mono.Security.Protocol.Ntlm/Type2Message.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.Protocol.Ntlm/Type2Message.cs	(revision 74928)
</I>&gt;<i> +++ Mono.Security.Protocol.Ntlm/Type2Message.cs	(working copy)
</I>&gt;<i> @@ -3,9 +3,10 @@
</I>&gt;<i>  //
</I>&gt;<i>  // Author:
</I>&gt;<i>  //	Sebastien Pouliot &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>&gt;
</I>&gt;<i> +//	Atsushi Enomoto &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>  //
</I>&gt;<i>  // Copyright (C) 2003 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
</I>&gt;<i> -// Copyright (C) 2004 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +// Copyright (C) 2004, 2007 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  // References
</I>&gt;<i>  // a.	NTLM Authentication Scheme for HTTP, Ronald Tschal&#228;r
</I>&gt;<i> @@ -35,24 +36,40 @@
</I>&gt;<i>  
</I>&gt;<i>  using System;
</I>&gt;<i>  using System.Security.Cryptography;
</I>&gt;<i> +using System.Text;
</I>&gt;<i>  
</I>&gt;<i>  namespace Mono.Security.Protocol.Ntlm {
</I>&gt;<i>  
</I>&gt;<i>  	public class Type2Message : MessageBase {
</I>&gt;<i>  
</I>&gt;<i>  		private byte[] _nonce;
</I>&gt;<i> +		private byte[] _context;
</I>&gt;<i> +		private NtlmTargetInformation _target;
</I>&gt;<i> +		private string _target_name;
</I>&gt;<i>  
</I>&gt;<i> -		public Type2Message () : base (2)
</I>&gt;<i> +		public Type2Message () : this (NtlmVersion.Version1)
</I>&gt;<i>  		{
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public Type2Message (NtlmVersion version) : base (2, version)
</I>&gt;<i> +		{
</I>&gt;<i>  			_nonce = new byte [8];
</I>&gt;<i>  			RandomNumberGenerator rng = RandomNumberGenerator.Create ();
</I>&gt;<i>  			rng.GetBytes (_nonce);
</I>&gt;<i>  			// default values
</I>&gt;<i>  			Flags = (NtlmFlags) 0x8201;
</I>&gt;<i> +			if (Version != NtlmVersion.Version1) {
</I>&gt;<i> +				_context = new byte [8];
</I>&gt;<i> +				_target = new NtlmTargetInformation ();
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public Type2Message (byte[] message) : base (2)
</I>&gt;<i> +		public Type2Message (byte[] message) : this (message, NtlmVersion.Version1)
</I>&gt;<i>  		{
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public Type2Message (byte[] message, NtlmVersion version) : base (2, version)
</I>&gt;<i> +		{
</I>&gt;<i>  			_nonce = new byte [8];
</I>&gt;<i>  			Decode (message);
</I>&gt;<i>  		}
</I>&gt;<i> @@ -65,6 +82,19 @@
</I>&gt;<i>  
</I>&gt;<i>  		// properties
</I>&gt;<i>  
</I>&gt;<i> +		public byte[] Context {
</I>&gt;<i> +			get { return (byte[]) _context.Clone (); }
</I>&gt;<i> +			set { 
</I>&gt;<i> +				if (value == null)
</I>&gt;<i> +					throw new ArgumentNullException (&quot;Nonce&quot;);
</I>&gt;<i> +				if (value.Length != 8) {
</I>&gt;<i> +					string msg = Locale.GetText (&quot;Invalid Nonce Length (should be 8 bytes).&quot;);
</I>&gt;<i> +					throw new ArgumentException (msg, &quot;Nonce&quot;);
</I>&gt;<i> +				}
</I>&gt;<i> +				_context = (byte[]) value.Clone (); 
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public byte[] Nonce {
</I>&gt;<i>  			get { return (byte[]) _nonce.Clone (); }
</I>&gt;<i>  			set { 
</I>&gt;<i> @@ -78,26 +108,76 @@
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public NtlmTargetInformation Target {
</I>&gt;<i> +			get { return _target; }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public string TargetName {
</I>&gt;<i> +			get { return _target_name; }
</I>&gt;<i> +			set { _target_name = value; }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		// methods
</I>&gt;<i>  
</I>&gt;<i>  		protected override void Decode (byte[] message) 
</I>&gt;<i>  		{
</I>&gt;<i>  			base.Decode (message);
</I>&gt;<i>  
</I>&gt;<i> +			short targetNameSize = BitConverterLE.ToInt16 (message, 12);
</I>&gt;<i> +			int targetNameOffset = BitConverterLE.ToInt32 (message, 16);
</I>&gt;<i> +
</I>&gt;<i>  			Flags = (NtlmFlags) BitConverterLE.ToUInt32 (message, 20);
</I>&gt;<i>  
</I>&gt;<i>  			Buffer.BlockCopy (message, 24, _nonce, 0, 8);
</I>&gt;<i> +
</I>&gt;<i> +			if (Version == NtlmVersion.Version1)
</I>&gt;<i> +				return;
</I>&gt;<i> +
</I>&gt;<i> +			Buffer.BlockCopy (message, 32, _context, 0, 8);
</I>&gt;<i> +			short targetInfoSize = BitConverterLE.ToInt16 (message, 40);
</I>&gt;<i> +			int targetInfoOffset = BitConverterLE.ToInt32 (message, 44);
</I>&gt;<i> +
</I>&gt;<i> +			if (Version == NtlmVersion.Version3)
</I>&gt;<i> +				Buffer.BlockCopy (OSVersion, 0, message, 48, OSVersion.Length);
</I>&gt;<i> +
</I>&gt;<i> +			Encoding enc = (Flags &amp; NtlmFlags.NegotiateUnicode) != 0 ? Encoding.Unicode : Encoding.UTF8;
</I>&gt;<i> +			if (targetNameSize &gt; 0)
</I>&gt;<i> +				TargetName = enc.GetString (message, targetNameOffset, targetNameSize);
</I>&gt;<i> +
</I>&gt;<i> +			_target.Decode (message, targetInfoOffset, targetInfoSize);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public override byte[] GetBytes ()
</I>&gt;<i>  		{
</I>&gt;<i> -			byte[] data = PrepareMessage (40);
</I>&gt;<i> +			byte [] name_bytes = null, target = null;
</I>&gt;<i> +			short name_len = 0, target_len = 0;
</I>&gt;<i> +			if (TargetName != null) {
</I>&gt;<i> +				Encoding enc = (Flags &amp; NtlmFlags.NegotiateUnicode) != 0 ? Encoding.Unicode : Encoding.UTF8;
</I>&gt;<i> +				name_bytes = enc.GetBytes (TargetName);
</I>&gt;<i> +				name_len = (short) name_bytes.Length;
</I>&gt;<i> +			}
</I>&gt;<i> +			if (Version != NtlmVersion.Version1) {
</I>&gt;<i> +				target = _target.ToBytes ();
</I>&gt;<i> +				target_len = (short) target.Length;
</I>&gt;<i> +			}
</I>&gt;<i>  
</I>&gt;<i> -			// message length
</I>&gt;<i> -			short msg_len = (short)data.Length;
</I>&gt;<i> -			data [16] = (byte) msg_len;
</I>&gt;<i> -			data [17] = (byte)(msg_len &gt;&gt; 8);
</I>&gt;<i> +			uint name_offset = (uint) (Version == NtlmVersion.Version3 ? 56 : 48);
</I>&gt;<i>  
</I>&gt;<i> +			int size = (int) name_offset +
</I>&gt;<i> +				   (name_len &gt; 0 ? name_len + 8 : 0) +
</I>&gt;<i> +				   (target_len &gt; 0 ? target_len + 8 : 0);
</I>&gt;<i> +			byte[] data = PrepareMessage (size);
</I>&gt;<i> +
</I>&gt;<i> +			// target name
</I>&gt;<i> +			data [12] = (byte) name_len;
</I>&gt;<i> +			data [13] = (byte) (name_len &gt;&gt; 8);
</I>&gt;<i> +			data [14] = data [12];
</I>&gt;<i> +			data [15] = data [13];
</I>&gt;<i> +			data [16] = (byte) name_offset;
</I>&gt;<i> +			data [17] = (byte) (name_offset &gt;&gt; 8);
</I>&gt;<i> +			data [18] = (byte) (name_offset &gt;&gt; 16);
</I>&gt;<i> +			data [19] = (byte) (name_offset &gt;&gt; 24);
</I>&gt;<i> +
</I>&gt;<i>  			// flags
</I>&gt;<i>  			data [20] = (byte) Flags;
</I>&gt;<i>  			data [21] = (byte)((uint)Flags &gt;&gt; 8);
</I>&gt;<i> @@ -105,6 +185,30 @@
</I>&gt;<i>  			data [23] = (byte)((uint)Flags &gt;&gt; 24);
</I>&gt;<i>  
</I>&gt;<i>  			Buffer.BlockCopy (_nonce, 0, data, 24, _nonce.Length);
</I>&gt;<i> +
</I>&gt;<i> +			if (Version == NtlmVersion.Version1)
</I>&gt;<i> +				return data;
</I>&gt;<i> +
</I>&gt;<i> +			// context
</I>&gt;<i> +			Buffer.BlockCopy (_context, 0, data, 32, 8);
</I>&gt;<i> +
</I>&gt;<i> +			// target information
</I>&gt;<i> +			data [40] = (byte) target_len;
</I>&gt;<i> +			data [41] = (byte) (target_len &gt;&gt; 8);
</I>&gt;<i> +			data [42] = data [40];
</I>&gt;<i> +			data [43] = data [41];
</I>&gt;<i> +			uint info_offset = (uint) (name_offset + name_bytes.Length);
</I>&gt;<i> +			data [44] = (byte) info_offset;
</I>&gt;<i> +			data [45] = (byte) (info_offset &gt;&gt; 8);
</I>&gt;<i> +			data [46] = (byte) (info_offset &gt;&gt; 16);
</I>&gt;<i> +			data [47] = (byte) (info_offset &gt;&gt; 24);
</I>&gt;<i> +
</I>&gt;<i> +			if (Version == NtlmVersion.Version3)
</I>&gt;<i> +				Buffer.BlockCopy (OSVersion, 0, data, 48, OSVersion.Length);
</I>&gt;<i> +
</I>&gt;<i> +			Buffer.BlockCopy (name_bytes, 0, data, (int) name_offset, name_len);
</I>&gt;<i> +			Buffer.BlockCopy (target, 0, data, (int) info_offset, target.Length);
</I>&gt;<i> +
</I>&gt;<i>  			return data;
</I>&gt;<i>  		}
</I>&gt;<i>  	}
</I>&gt;<i> Index: Mono.Security.Protocol.Ntlm/Type3Message.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.Protocol.Ntlm/Type3Message.cs	(revision 74928)
</I>&gt;<i> +++ Mono.Security.Protocol.Ntlm/Type3Message.cs	(working copy)
</I>&gt;<i> @@ -3,9 +3,10 @@
</I>&gt;<i>  //
</I>&gt;<i>  // Author:
</I>&gt;<i>  //	Sebastien Pouliot &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">sebastien at ximian.com</A>&gt;
</I>&gt;<i> +//	Atsushi Enomoto &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>  //
</I>&gt;<i>  // (C) 2003 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
</I>&gt;<i> -// Copyright (C) 2004 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +// Copyright (C) 2004, 2007 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  // References
</I>&gt;<i>  // a.	NTLM Authentication Scheme for HTTP, Ronald Tschal&#228;r
</I>&gt;<i> @@ -35,6 +36,7 @@
</I>&gt;<i>  
</I>&gt;<i>  using System;
</I>&gt;<i>  using System.Globalization;
</I>&gt;<i> +using System.Security.Cryptography;
</I>&gt;<i>  using System.Text;
</I>&gt;<i>  
</I>&gt;<i>  namespace Mono.Security.Protocol.Ntlm {
</I>&gt;<i> @@ -48,18 +50,30 @@
</I>&gt;<i>  		private string _password;
</I>&gt;<i>  		private byte[] _lm;
</I>&gt;<i>  		private byte[] _nt;
</I>&gt;<i> +		private byte[] _nonce;
</I>&gt;<i>  
</I>&gt;<i> -		public Type3Message () : base (3)
</I>&gt;<i> +		public Type3Message () : this (NtlmVersion.Version1)
</I>&gt;<i>  		{
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public Type3Message (NtlmVersion version) : base (3, version)
</I>&gt;<i> +		{
</I>&gt;<i>  			// default values
</I>&gt;<i>  			_domain = Environment.UserDomainName;
</I>&gt;<i>  			_host = Environment.MachineName;
</I>&gt;<i>  			_username = Environment.UserName;
</I>&gt;<i>  			Flags = (NtlmFlags) 0x8201;
</I>&gt;<i> +			_nonce = new byte [8];
</I>&gt;<i> +			RandomNumberGenerator rng = RandomNumberGenerator.Create ();
</I>&gt;<i> +			rng.GetBytes (_nonce);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public Type3Message (byte[] message) : base (3)
</I>&gt;<i> +		public Type3Message (byte[] message) : this (message, NtlmVersion.Version1)
</I>&gt;<i>  		{
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public Type3Message (byte[] message, NtlmVersion version) : base (3, version)
</I>&gt;<i> +		{
</I>&gt;<i>  			Decode (message);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> @@ -125,15 +139,17 @@
</I>&gt;<i>  		{
</I>&gt;<i>  			base.Decode (message);
</I>&gt;<i>  
</I>&gt;<i> +/*
</I>&gt;<i>  			if (BitConverterLE.ToUInt16 (message, 56) != message.Length) {
</I>&gt;<i>  				string msg = Locale.GetText (&quot;Invalid Type3 message length.&quot;);
</I>&gt;<i>  				throw new ArgumentException (msg, &quot;message&quot;);
</I>&gt;<i>  			}
</I>&gt;<i> +*/
</I>&gt;<i>  
</I>&gt;<i>  			_password = null;
</I>&gt;<i>  
</I>&gt;<i>  			int dom_len = BitConverterLE.ToUInt16 (message, 28);
</I>&gt;<i> -			int dom_off = 64;
</I>&gt;<i> +			int dom_off = BitConverterLE.ToUInt16 (message, 32);
</I>&gt;<i>  			_domain = Encoding.Unicode.GetString (message, dom_off, dom_len);
</I>&gt;<i>  
</I>&gt;<i>  			int host_len = BitConverterLE.ToUInt16 (message, 44);
</I>&gt;<i> @@ -162,60 +178,89 @@
</I>&gt;<i>  			byte[] user = Encoding.Unicode.GetBytes (_username);
</I>&gt;<i>  			byte[] host = Encoding.Unicode.GetBytes (_host.ToUpper (CultureInfo.InvariantCulture));
</I>&gt;<i>  
</I>&gt;<i> -			byte[] data = PrepareMessage (64 + domain.Length + user.Length + host.Length + 24 + 24);
</I>&gt;<i> +			int fixed_size = Version == NtlmVersion.Version3 ? 72 : 64;
</I>&gt;<i> +			short skey_len = (short) (Version != NtlmVersion.Version1 ? 16 : 0);
</I>&gt;<i> +			int skey_off = 0;
</I>&gt;<i>  
</I>&gt;<i> +			byte[] data = PrepareMessage (fixed_size + domain.Length + user.Length + host.Length + 24 + 24 + skey_len);
</I>&gt;<i> +
</I>&gt;<i>  			// LM response
</I>&gt;<i> -			short lmresp_off = (short)(64 + domain.Length + user.Length + host.Length);
</I>&gt;<i> +			int lmresp_off = fixed_size + domain.Length + user.Length + host.Length;
</I>&gt;<i>  			data [12] = (byte) 0x18;
</I>&gt;<i>  			data [13] = (byte) 0x00;
</I>&gt;<i>  			data [14] = (byte) 0x18;
</I>&gt;<i>  			data [15] = (byte) 0x00;
</I>&gt;<i>  			data [16] = (byte) lmresp_off;
</I>&gt;<i>  			data [17] = (byte)(lmresp_off &gt;&gt; 8);
</I>&gt;<i> +			data [18] = (byte)(lmresp_off &gt;&gt; 16);
</I>&gt;<i> +			data [19] = (byte)(lmresp_off &gt;&gt; 24);
</I>&gt;<i>  
</I>&gt;<i>  			// NT response
</I>&gt;<i> -			short ntresp_off = (short)(lmresp_off + 24);
</I>&gt;<i> +			int ntresp_off = lmresp_off + 24;
</I>&gt;<i>  			data [20] = (byte) 0x18;
</I>&gt;<i>  			data [21] = (byte) 0x00;
</I>&gt;<i>  			data [22] = (byte) 0x18;
</I>&gt;<i>  			data [23] = (byte) 0x00;
</I>&gt;<i>  			data [24] = (byte) ntresp_off;
</I>&gt;<i>  			data [25] = (byte)(ntresp_off &gt;&gt; 8);
</I>&gt;<i> +			data [26] = (byte)(ntresp_off &gt;&gt; 16);
</I>&gt;<i> +			data [27] = (byte)(ntresp_off &gt;&gt; 24);
</I>&gt;<i>  
</I>&gt;<i>  			// domain
</I>&gt;<i>  			short dom_len = (short)domain.Length;
</I>&gt;<i> -			short dom_off = 64;
</I>&gt;<i> +			int dom_off = (short)fixed_size;
</I>&gt;<i>  			data [28] = (byte) dom_len;
</I>&gt;<i>  			data [29] = (byte)(dom_len &gt;&gt; 8);
</I>&gt;<i>  			data [30] = data [28];
</I>&gt;<i>  			data [31] = data [29];
</I>&gt;<i>  			data [32] = (byte) dom_off;
</I>&gt;<i>  			data [33] = (byte)(dom_off &gt;&gt; 8);
</I>&gt;<i> +			data [34] = (byte)(dom_off &gt;&gt; 16);
</I>&gt;<i> +			data [35] = (byte)(dom_off &gt;&gt; 24);
</I>&gt;<i>  
</I>&gt;<i>  			// username
</I>&gt;<i>  			short uname_len = (short)user.Length;
</I>&gt;<i> -			short uname_off = (short)(dom_off + dom_len);
</I>&gt;<i> +			int uname_off = dom_off + dom_len;
</I>&gt;<i>  			data [36] = (byte) uname_len;
</I>&gt;<i>  			data [37] = (byte)(uname_len &gt;&gt; 8);
</I>&gt;<i>  			data [38] = data [36];
</I>&gt;<i>  			data [39] = data [37];
</I>&gt;<i>  			data [40] = (byte) uname_off;
</I>&gt;<i>  			data [41] = (byte)(uname_off &gt;&gt; 8);
</I>&gt;<i> +			data [42] = (byte)(uname_off &gt;&gt; 16);
</I>&gt;<i> +			data [43] = (byte)(uname_off &gt;&gt; 24);
</I>&gt;<i>  
</I>&gt;<i>  			// host
</I>&gt;<i>  			short host_len = (short)host.Length;
</I>&gt;<i> -			short host_off = (short)(uname_off + uname_len);
</I>&gt;<i> +			int host_off = uname_off + uname_len;
</I>&gt;<i>  			data [44] = (byte) host_len;
</I>&gt;<i>  			data [45] = (byte)(host_len &gt;&gt; 8);
</I>&gt;<i>  			data [46] = data [44];
</I>&gt;<i>  			data [47] = data [45];
</I>&gt;<i>  			data [48] = (byte) host_off;
</I>&gt;<i>  			data [49] = (byte)(host_off &gt;&gt; 8);
</I>&gt;<i> +			data [50] = (byte)(host_off &gt;&gt; 16);
</I>&gt;<i> +			data [51] = (byte)(host_off &gt;&gt; 24);
</I>&gt;<i>  
</I>&gt;<i> +			// session key
</I>&gt;<i> +			if (Version != NtlmVersion.Version1) {
</I>&gt;<i> +				skey_off = (short)(data.Length - skey_len);
</I>&gt;<i> +				data [52] = (byte) skey_len;
</I>&gt;<i> +				data [53] = (byte)(skey_len &gt;&gt; 8);
</I>&gt;<i> +				data [54] = data [52];
</I>&gt;<i> +				data [55] = data [53];
</I>&gt;<i> +				data [56] = (byte) skey_off;
</I>&gt;<i> +				data [57] = (byte)(skey_off &gt;&gt; 8);
</I>&gt;<i> +				data [58] = (byte)(skey_off &gt;&gt; 16);
</I>&gt;<i> +				data [59] = (byte)(skey_off &gt;&gt; 24);
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i>  			// message length
</I>&gt;<i>  			short msg_len = (short)data.Length;
</I>&gt;<i>  			data [56] = (byte) msg_len;
</I>&gt;<i>  			data [57] = (byte)(msg_len &gt;&gt; 8);
</I>&gt;<i> +*/
</I>&gt;<i>  
</I>&gt;<i>  			// options flags
</I>&gt;<i>  			data [60] = (byte) Flags;
</I>&gt;<i> @@ -223,6 +268,10 @@
</I>&gt;<i>  			data [62] = (byte)((uint)Flags &gt;&gt; 16);
</I>&gt;<i>  			data [63] = (byte)((uint)Flags &gt;&gt; 24);
</I>&gt;<i>  
</I>&gt;<i> +			// osversion
</I>&gt;<i> +			if (Version == NtlmVersion.Version3)
</I>&gt;<i> +				Buffer.BlockCopy (OSVersion, 0, data, 64, OSVersion.Length);
</I>&gt;<i> +
</I>&gt;<i>  			Buffer.BlockCopy (domain, 0, data, dom_off, domain.Length);
</I>&gt;<i>  			Buffer.BlockCopy (user, 0, data, uname_off, user.Length);
</I>&gt;<i>  			Buffer.BlockCopy (host, 0, data, host_off, host.Length);
</I>&gt;<i> @@ -230,7 +279,12 @@
</I>&gt;<i>  			using (ChallengeResponse ntlm = new ChallengeResponse (_password, _challenge)) {
</I>&gt;<i>  				Buffer.BlockCopy (ntlm.LM, 0, data, lmresp_off, 24);
</I>&gt;<i>  				Buffer.BlockCopy (ntlm.NT, 0, data, ntresp_off, 24);
</I>&gt;<i> +
</I>&gt;<i> +				if (Version != NtlmVersion.Version1)
</I>&gt;<i> +					// session key
</I>&gt;<i> +					Buffer.BlockCopy (ntlm.LMSessionKey, 0, data, skey_off, 16);
</I>&gt;<i>  			}
</I>&gt;<i> +
</I>&gt;<i>  			return data;
</I>&gt;<i>  		}
</I>&gt;<i>  	}
</I>&gt;<i> Index: Mono.Security.dll.sources
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Mono.Security.dll.sources	(revision 74928)
</I>&gt;<i> +++ Mono.Security.dll.sources	(working copy)
</I>&gt;<i> @@ -68,6 +68,8 @@
</I>&gt;<i>  ./Mono.Security.Protocol.Ntlm/ChallengeResponse.cs
</I>&gt;<i>  ./Mono.Security.Protocol.Ntlm/MessageBase.cs
</I>&gt;<i>  ./Mono.Security.Protocol.Ntlm/NtlmFlags.cs
</I>&gt;<i> +./Mono.Security.Protocol.Ntlm/NtlmTargetInformation.cs
</I>&gt;<i> +./Mono.Security.Protocol.Ntlm/NtlmVersion.cs
</I>&gt;<i>  ./Mono.Security.Protocol.Ntlm/Type1Message.cs
</I>&gt;<i>  ./Mono.Security.Protocol.Ntlm/Type2Message.cs
</I>&gt;<i>  ./Mono.Security.Protocol.Ntlm/Type3Message.cs
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022978.html">[Mono-dev] patch for (and question about)	Mono.Security.Protocol.Ntlm
</A></li>
	<LI>Next message: <A HREF="022973.html">[Mono-dev] BitArray patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22985">[ date ]</a>
              <a href="thread.html#22985">[ thread ]</a>
              <a href="subject.html#22985">[ subject ]</a>
              <a href="author.html#22985">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
