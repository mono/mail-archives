<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Mono's BitConverter.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Mono%27s%20BitConverter.&In-Reply-To=1174746182.21840.91.camel%40melchior.magi">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022905.html">
   <LINK REL="Next"  HREF="022864.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Mono's BitConverter.</H1>
    <B>Miguel de Icaza</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Mono%27s%20BitConverter.&In-Reply-To=1174746182.21840.91.camel%40melchior.magi"
       TITLE="[Mono-dev] Mono's BitConverter.">miguel at ximian.com
       </A><BR>
    <I>Sat Mar 24 11:28:58 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="022905.html">[Mono-dev] Mono's BitConverter.
</A></li>
        <LI>Next message: <A HREF="022864.html">[Mono-dev] Wrong logs from make run-test-ondotnet
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22906">[ date ]</a>
              <a href="thread.html#22906">[ thread ]</a>
              <a href="subject.html#22906">[ subject ]</a>
              <a href="author.html#22906">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Jonathan,

    Thanks for the feedback, currently I have implemented:

	* [Type]From[Endian] (byte [] data, int index) static
	  methods of DataConverter class.

	* A DataConverter class that also provides abstract
	  methods for Get[Type] and GetBytes ([Type]) and
	  a couple of properties:

		DataConverter LittleEndian  { get; }
		DataConverter BigEndian     { get; }
		DataConverter Host	    { get; }

	  The idea here is that there are certain streams
	  that will all be encoded in a particular endian mode
	  and depending on the host we can provide a fast Copy or
	  Swap operations.

	* A Pack method, looks like this:

		byte [] Pack (string description, params object [] args)

	  See the attached source code for the actual format of the 
	  description string, but it allows code like this:

		Pack (&quot;^idf$8x&quot;, intval, doubleval, floatval, string);

	  The above would produce a big-endian encoded, int, double,
	  float, followed by a UTF8 encoded string and a null char.

I have not implemented the stream methods yet nor the GetAsBytes
methods.

&gt;<i> I would suggest that IList be the return type instead of ArrayList, as
</I>&gt;<i> this would allow changing the actual collection if necessary (to e.g.
</I>&gt;<i> List&lt;object&gt; or an object[], etc. -- in fact, it should be possible to
</I>&gt;<i> return a object[] if each template parameter is a single character, as
</I>&gt;<i> the number of objects to return will always be template.Length, so the
</I>&gt;<i> overhead of a re-sizable array wouldn't be needed).
</I>
I agree with this suggestion, but I have not implemented it yet (Unpack)

Am wondering if we should just return an array of objects, as that would
have all the interesting interfaces implemented already (IList,
IEnumerable) and they are part of the public contract.

&gt;<i> It might be useful to have an `IEnumerable' overload to Pack() as well,
</I>&gt;<i> so that if the arguments are already in a collection class they can be
</I>&gt;<i> reused as-is:
</I>&gt;<i> 
</I>&gt;<i> 	byte[] Pack (string template, IEnumerable arguments);
</I>
This is a very good idea.   But I do not want to loose the params
version of it.

&gt;<i> Finally, we need to specify the [Endian] for Pack, so it should be
</I>&gt;<i> PackLittleEndian() and PackBigEndian().
</I>
I dealt with this differently, the specification string will start in
host packing mode, and will continue packing data in that mode until
told otherwise.   

To control the packing mode, you use one of these values:

	^ switch to big endian packing
	_ switch to little endian packing
	% switch to native packing.

&gt;<i> ByteConverter could be trimmed down by removing some of its methods --
</I>&gt;<i> it might be practical to remove the non-Stream overloads, as you can
</I>&gt;<i> always construct a System.IO.MemoryStream and get a byte[] from that
</I>&gt;<i> after converting *all* of your data -- but this might not be ideal
</I>&gt;<i> either.  I don't think the Stream overloads should be removed, as
</I>&gt;<i> they're an ideal way to keep GC pressure lower (fewer byte[] should need
</I>&gt;<i> to be created).  Alternatively, perhaps we don't need the unsigned
</I>&gt;<i> flavors, which would require only 56 methods.
</I>
I agree, we need to have the Stream methods.  

We already have been bitten by the completely unsuitable BitConverter,
so I rather do the right thing here and provide correct implementations
of things that developers typically need.

One last thing: this code currently has no tests, and I have not tested
it beyond compiling the code.

Miguel.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bitconverter.cs
Type: text/x-csharp
Size: 23967 bytes
Desc: not available
Url : <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20070324/0dc80dba/attachment.bin">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20070324/0dc80dba/attachment.bin</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022905.html">[Mono-dev] Mono's BitConverter.
</A></li>
	<LI>Next message: <A HREF="022864.html">[Mono-dev] Wrong logs from make run-test-ondotnet
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22906">[ date ]</a>
              <a href="thread.html#22906">[ thread ]</a>
              <a href="subject.html#22906">[ subject ]</a>
              <a href="author.html#22906">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
