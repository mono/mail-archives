<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Patch review request -- generic changes to support MIPS conditional exceptions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Patch%20review%20request%20--%20generic%20changes%20to%20support%20MIPS%0A%20conditional%20exceptions&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022119.html">
   <LINK REL="Next"  HREF="022120.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Patch review request -- generic changes to support MIPS conditional exceptions</H1>
    <B>mason</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Patch%20review%20request%20--%20generic%20changes%20to%20support%20MIPS%0A%20conditional%20exceptions&In-Reply-To="
       TITLE="[Mono-dev] Patch review request -- generic changes to support MIPS conditional exceptions">mason at broadcom.com
       </A><BR>
    <I>Thu Jan 11 14:30:15 EST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="022119.html">[Mono-dev] Patch review request -- breakup large tests in	basic.cs &amp; exception.cs
</A></li>
        <LI>Next message: <A HREF="022120.html">[Mono-dev] Patch review request -- generic changes to support	MIPS conditional exceptions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22110">[ date ]</a>
              <a href="thread.html#22110">[ thread ]</a>
              <a href="subject.html#22110">[ subject ]</a>
              <a href="author.html#22110">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

Please review the following patch.  This patch includes changes to the
generic .brg files to support MIPS conditional exceptions.  The changes
are very similar to those made earlier to support conditional branches -
new macros are introduced to combine generation of the compare
instructions and the issuing of the conditional branch. All all
archtectures other than MIPS, these new macros immediately expand back
out to the old behaviour.  On MIPS, they'll do something a bit
different.

If there's no objections, I'll check these in in a few days.

Thanks,
Mark

Index: mono/mini/inssel.brg
===================================================================
--- mono/mini/inssel.brg	(revision 70746)
+++ mono/mini/inssel.brg	(working copy)
@@ -278,8 +278,7 @@
 		if (! (state-&gt;tree-&gt;flags &amp; MONO_INST_NORANGECHECK)) { \
 			int _length_reg = mono_regstate_next_int (cfg-&gt;rs); \
 			MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, _length_reg, array_reg, G_STRUCT_OFFSET (array_type, array_length_field)); \
-			MONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, _length_reg, index_reg); \
-			MONO_EMIT_NEW_COND_EXC (cfg, LE_UN, &quot;IndexOutOfRangeException&quot;); \
+			MONO_EMIT_NEW_COMPARE_EXC (cfe, LE_UN, _length_reg, index_reg, &quot;IndexOutOfRangeException&quot;); \
 		} \
 	} while (0)
 
@@ -287,11 +286,31 @@
 		if (! (state-&gt;tree-&gt;flags &amp; MONO_INST_NORANGECHECK)) { \
 			int _length_reg = mono_regstate_next_int (cfg-&gt;rs); \
 			MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, _length_reg, array_reg, G_STRUCT_OFFSET (array_type, array_length_field)); \
-			MONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, _length_reg, index_imm); \
-			MONO_EMIT_NEW_COND_EXC (cfg, LE_UN, &quot;IndexOutOfRangeException&quot;); \
+			MONO_EMIT_NEW_COMPARE_IMM_EXC (cfe, LE_UN, _length_reg, index_imm, &quot;IndexOutOfRangeException&quot;); \
 		} \
 	} while (0)
 
+#ifndef MONO_EMIT_NEW_COMPARE_EXC
+#define MONO_EMIT_NEW_COMPARE_EXC(cfg, cmp_op, sreg1, sreg2, exc) do { \
+		MONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, sreg1, sreg2); \
+		MONO_EMIT_NEW_COND_EXC (cfg, cmp_op, exc); \
+	} while (0)
+#endif
+
+#ifndef MONO_EMIT_NEW_COMPARE_IMM_EXC
+#define MONO_EMIT_NEW_COMPARE_IMM_EXC(cfg, cmp_op, sreg1, imm, exc) do { \
+		MONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE, -1, sreg1, imm); \
+		MONO_EMIT_NEW_COND_EXC (cfg, cmp_op, exc); \
+	} while (0)
+#endif
+
+#ifndef MONO_EMIT_NEW_ICOMPARE_IMM_EXC
+#define MONO_EMIT_NEW_ICOMPARE_IMM_EXC(cfg, cmp_op, sreg1, imm, exc) do { \
+		MONO_EMIT_NEW_ICOMPARE_IMM(cfg, sreg1, imm); \
+		MONO_EMIT_NEW_COND_EXC (cfg, cmp_op, exc); \
+	} while (0)
+#endif
+
 #ifndef MONO_EMIT_NEW_COMPARE_BRANCH_LABEL
 #define MONO_EMIT_NEW_COMPARE_BRANCH_LABEL(cfg, cmp_op, sreg1, sreg2, label) \
 	do { \
@@ -629,16 +648,14 @@
 	MONO_EMIT_NEW_BIALU (s, CEE_SUB, realidx1_reg, index1, low1_reg);
 	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, high1_reg, 
 				       bounds_reg, G_STRUCT_OFFSET (MonoArrayBounds, length));
-	MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, high1_reg, realidx1_reg);
-	MONO_EMIT_NEW_COND_EXC (s, LE_UN, &quot;IndexOutOfRangeException&quot;);
+	MONO_EMIT_NEW_COMPARE_EXC (s, LE_UN, high1_reg, realidx1_reg, &quot;IndexOutOfRangeException&quot;);
 
 	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, low2_reg, 
 				       bounds_reg, sizeof (MonoArrayBounds) + G_STRUCT_OFFSET (MonoArrayBounds, lower_bound));
 	MONO_EMIT_NEW_BIALU (s, CEE_SUB, realidx2_reg, index2, low2_reg);
 	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, high2_reg, 
 				       bounds_reg, sizeof (MonoArrayBounds) + G_STRUCT_OFFSET (MonoArrayBounds, length));
-	MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, high2_reg, realidx2_reg);
-	MONO_EMIT_NEW_COND_EXC (s, LE_UN, &quot;IndexOutOfRangeException&quot;);
+	MONO_EMIT_NEW_COMPARE_EXC (s, LE_UN, high2_reg, realidx2_reg, &quot;IndexOutOfRangeException&quot;);
 
 	MONO_EMIT_NEW_BIALU (s, CEE_MUL, mult_reg, high2_reg, realidx1_reg);
 	MONO_EMIT_NEW_BIALU (s, CEE_ADD, sum_reg, mult_reg, realidx2_reg);
@@ -683,56 +700,47 @@
 	if (sizeof (void *) == 8) {
 		MONO_EMIT_UNALU (s, tree, tree-&gt;opcode, state-&gt;reg1, state-&gt;left-&gt;reg1);
 	} else {	
-		MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 0);
-		MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
+		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, 0, &quot;OverflowException&quot;);
 		MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 	}
 }
 
 reg: CEE_CONV_OVF_I1 (reg) {     
-	MONO_EMIT_NEW_ICOMPARE_IMM (s, state-&gt;left-&gt;reg1, 127);
-	MONO_EMIT_NEW_COND_EXC (s, GT, &quot;OverflowException&quot;);
-	MONO_EMIT_NEW_ICOMPARE_IMM (s, state-&gt;left-&gt;reg1, -128);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT, state-&gt;left-&gt;reg1, 127, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, -128, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: CEE_CONV_OVF_I1_UN (reg) {
 	/* probe values between 0 to 127 */
-	MONO_EMIT_NEW_ICOMPARE_IMM (s, state-&gt;left-&gt;reg1, 127);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 127, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: CEE_CONV_OVF_U1 (reg),
 reg: CEE_CONV_OVF_U1_UN (reg) {
 	/* probe value to be within 0 to 255 */
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 255);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 255, &quot;OverflowException&quot;);
 	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state-&gt;reg1, state-&gt;left-&gt;reg1, 0xff);
 }
 
 reg: CEE_CONV_OVF_I2 (reg) {	
 	/* Probe value to be within -32768 and 32767 */
-	MONO_EMIT_NEW_ICOMPARE_IMM (s, state-&gt;left-&gt;reg1, 32767);
-	MONO_EMIT_NEW_COND_EXC (s, GT, &quot;OverflowException&quot;);
-	MONO_EMIT_NEW_ICOMPARE_IMM (s, state-&gt;left-&gt;reg1, -32768);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT, state-&gt;left-&gt;reg1, 32767, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, -32768, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: CEE_CONV_OVF_I2_UN (reg) {
 	/* Convert uint value into short, value within 0 and 32767 */
-	MONO_EMIT_NEW_ICOMPARE_IMM (s, state-&gt;left-&gt;reg1, 32767);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 32767, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: CEE_CONV_OVF_U2 (reg),
 reg: CEE_CONV_OVF_U2_UN (reg) {
 	/* Probe value to be within 0 and 65535 */
-	MONO_EMIT_NEW_ICOMPARE_IMM (s, state-&gt;left-&gt;reg1, 0xffff);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_ICOMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 0xffff, &quot;OverflowException&quot;);
 	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state-&gt;reg1, state-&gt;left-&gt;reg1, 0xffff);
 }
 
@@ -1208,8 +1216,7 @@
 	g_assert (klass-&gt;rank == 0);
 
 	// Check rank == 0
-	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, rank_reg, 0);
-	MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, rank_reg, 0, &quot;InvalidCastException&quot;);
 
 	MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
 	MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, element_class));
@@ -1217,12 +1224,11 @@
 	if (s-&gt;compile_aot) {
 		int const_reg = mono_regstate_next_int (s-&gt;rs);
 		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass-&gt;element_class);
-		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
+		MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, const_reg, &quot;InvalidCastException&quot;);
 	} else {
-		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, klass-&gt;element_class);
+		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, eclass_reg, klass-&gt;element_class, &quot;InvalidCastException&quot;);
 	}
 	
-	MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, obj_reg);
 }
 
@@ -1249,8 +1255,7 @@
 			int eclass_reg = mono_regstate_next_int (s-&gt;rs);
 
 			MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU1_MEMBASE, rank_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, rank));
-			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, rank_reg, klass-&gt;rank);
-			MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
+			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, rank_reg, klass-&gt;rank, &quot;InvalidCastException&quot;);
 			MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
 			MONO_EMIT_NEW_LOAD_MEMBASE (s, eclass_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, cast_class));
 			if (klass-&gt;cast_class == mono_defaults.object_class) {
@@ -1267,11 +1272,10 @@
 				}
 				if (s-&gt;compile_aot) {
 					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
-					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
+					MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, const_reg, &quot;InvalidCastException&quot;);
 				} else {
-					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
+					MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, eclass_reg, mono_defaults.enum_class, &quot;InvalidCastException&quot;);
 				}
-				MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
 			} else if (klass-&gt;cast_class == mono_defaults.enum_class-&gt;parent) {
 				int const_reg = mono_regstate_next_int (s-&gt;rs);
 				if (s-&gt;compile_aot) {
@@ -1283,20 +1287,18 @@
 				}
 				if (s-&gt;compile_aot) {
 					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
-					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
+					MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, const_reg, &quot;InvalidCastException&quot;);
 				} else {
-					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
+					MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, eclass_reg, mono_defaults.enum_class, &quot;InvalidCastException&quot;);
 				}
-				MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
 			} else if (klass-&gt;cast_class == mono_defaults.enum_class) {
 				if (s-&gt;compile_aot) {
 					int const_reg = mono_regstate_next_int (s-&gt;rs);
 					MONO_EMIT_NEW_CLASSCONST (s, const_reg, mono_defaults.enum_class);
-					MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, eclass_reg, const_reg);
+					MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, eclass_reg, const_reg, &quot;InvalidCastException&quot;);
 				} else {
-					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, eclass_reg, mono_defaults.enum_class);
+					MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, eclass_reg, mono_defaults.enum_class, &quot;InvalidCastException&quot;);
 				}
-				MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
 			} else if (klass-&gt;cast_class-&gt;flags &amp; TYPE_ATTRIBUTE_INTERFACE) {
 				mini_emit_castclass_iface_class (s, eclass_reg, klass-&gt;cast_class);
 			} else {
@@ -1307,20 +1309,18 @@
 				/* Check that the object is a vector too */
 				int bounds_reg = mono_regstate_next_int (s-&gt;rs);
 				MONO_EMIT_NEW_LOAD_MEMBASE (s, bounds_reg, obj_reg, G_STRUCT_OFFSET (MonoArray, bounds));
-				MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, bounds_reg, 0);
-				MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
+				MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, bounds_reg, 0, &quot;InvalidCastException&quot;);
 			}
 		} else {
 			if (!s-&gt;compile_aot &amp;&amp; !(s-&gt;opt &amp; MONO_OPT_SHARED) &amp;&amp; (klass-&gt;flags &amp; TYPE_ATTRIBUTE_SEALED)) {
 				/* the remoting code is broken, access the class for now */
 				if (0) {
 					MonoVTable *vt = mono_class_vtable (s-&gt;domain, klass);
-					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, vtable_reg, vt);
+					MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, vtable_reg, vt, &quot;InvalidCastException&quot;);
 				} else {
 					MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
-					MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, klass_reg, klass);
+					MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, klass_reg, klass, &quot;InvalidCastException&quot;);
 				}
-				MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
 			} else {
 				MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
 				mini_emit_castclass (s, klass_reg, klass);
@@ -1362,19 +1362,17 @@
 		if (s-&gt;compile_aot) {
 			int tproxy_reg = mono_regstate_next_int (s-&gt;rs);
 			MONO_EMIT_NEW_CLASSCONST (s, tproxy_reg, mono_defaults.transparent_proxy_class);
-			MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, klass_reg, tproxy_reg);
+			MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, klass_reg, tproxy_reg, &quot;InvalidCastException&quot;);
 		} else {
-			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, klass_reg, mono_defaults.transparent_proxy_class);
+			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, klass_reg, mono_defaults.transparent_proxy_class, &quot;InvalidCastException&quot;);
 		}
 		
-		MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
 		
 		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, remote_class));
 		MONO_EMIT_NEW_LOAD_MEMBASE (s, klass_reg, tmp_reg, G_STRUCT_OFFSET (MonoRemoteClass, proxy_class));
 		
 		MONO_EMIT_NEW_LOAD_MEMBASE (s, tmp_reg, obj_reg, G_STRUCT_OFFSET (MonoTransparentProxy, custom_type_info));
-		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, tmp_reg, 0);
-		MONO_EMIT_NEW_COND_EXC (s, EQ, &quot;InvalidCastException&quot;);
+		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, EQ, tmp_reg, 0, &quot;InvalidCastException&quot;);
 		
 		MONO_EMIT_NEW_ICONST (s, state-&gt;reg1, 1);
 		MONO_EMIT_NEW_BRANCH_LABEL (s, CEE_BR, end_label);
@@ -1520,21 +1518,20 @@
 		if (s-&gt;compile_aot) {
 			int klass_reg = mono_regstate_next_int (s-&gt;rs);
 			MONO_EMIT_NEW_CLASSCONST (s, klass_reg, array_class);
-			MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, class_reg, klass_reg);
+			MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, class_reg, klass_reg, &quot;ArrayTypeMismatchException&quot;);
 		} else {
-			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, class_reg, array_class);
+			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, class_reg, array_class, &quot;ArrayTypeMismatchException&quot;);
 		}
 	} else {
 		if (s-&gt;compile_aot) {
 			int vt_reg = mono_regstate_next_int (s-&gt;rs);
 			MONO_EMIT_NEW_VTABLECONST (s, vt_reg, mono_class_vtable (s-&gt;domain, array_class));
-			MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, vtable_reg, vt_reg);
+			MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, vtable_reg, vt_reg, &quot;ArrayTypeMismatchException&quot;);
 		} else {
-			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, vtable_reg, mono_class_vtable (s-&gt;domain, array_class));
+			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, vtable_reg, mono_class_vtable (s-&gt;domain, array_class), &quot;ArrayTypeMismatchException&quot;);
 		}
 	}
 	
-	MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;ArrayTypeMismatchException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
@@ -1564,11 +1561,10 @@
 	if (s-&gt;compile_aot) {
 		int const_reg = mono_regstate_next_int (s-&gt;rs);
 		MONO_EMIT_NEW_CLASSCONST (s, const_reg, tree-&gt;inst_newa_class);
-		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, klass_reg, const_reg);
+		MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, klass_reg, const_reg, &quot;InvalidCastException&quot;);
 	} else {
-		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, klass_reg, tree-&gt;inst_newa_class);
+		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, klass_reg, tree-&gt;inst_newa_class, &quot;InvalidCastException&quot;);
 	}
-	MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
 	MONO_EMIT_NEW_LOAD_MEMBASE (s, state-&gt;reg1, state-&gt;left-&gt;reg1, G_STRUCT_OFFSET (MonoTypedRef, value));
 }	
 
@@ -1612,15 +1608,13 @@
 		if (false_target)
 			MONO_EMIT_NEW_COMPARE_BRANCH_LABEL (s, CEE_BLT_UN, max_iid_reg, iid_reg, false_target);
 		else
-			MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, max_iid_reg, iid_reg);
+			MONO_EMIT_NEW_COMPARE_EXC (s, LT_UN, max_iid_reg, iid_reg, &quot;InvalidCastException&quot;);
 	} else {
 		if (false_target)
 			MONO_EMIT_NEW_COMPARE_IMM_BRANCH_LABEL (s, CEE_BLT_UN, max_iid_reg, klass-&gt;interface_id, false_target);
 		else
-			MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, max_iid_reg, klass-&gt;interface_id);
+			MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT_UN, max_iid_reg, klass-&gt;interface_id, &quot;InvalidCastException&quot;);
 	}
-	if (!false_target)
-		MONO_EMIT_NEW_COND_EXC (s, LT_UN, &quot;InvalidCastException&quot;);
 }
 
 /* Same as above, but obtains max_iid from a vtable */
@@ -1790,19 +1784,17 @@
 
 	if (klass-&gt;idepth &gt; MONO_DEFAULT_SUPERTABLE_SIZE) {
 		MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADU2_MEMBASE, idepth_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, idepth));
-		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, idepth_reg, klass-&gt;idepth);
-		MONO_EMIT_NEW_COND_EXC (s, LT_UN, &quot;InvalidCastException&quot;);
+		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT_UN, idepth_reg, klass-&gt;idepth, &quot;InvalidCastException&quot;);
 	}
 	MONO_EMIT_NEW_LOAD_MEMBASE (s, stypes_reg, klass_reg, G_STRUCT_OFFSET (MonoClass, supertypes));
 	MONO_EMIT_NEW_LOAD_MEMBASE (s, stype, stypes_reg, ((klass-&gt;idepth - 1) * SIZEOF_VOID_P));
 	if (s-&gt;compile_aot) {
 		int const_reg = mono_regstate_next_int (s-&gt;rs);
 		MONO_EMIT_NEW_CLASSCONST (s, const_reg, klass);
-		MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, stype, const_reg);
+		MONO_EMIT_NEW_COMPARE_EXC (s, NE_UN, stype, const_reg, &quot;InvalidCastException&quot;);
 	} else {
-		MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, stype, klass);
+		MONO_EMIT_NEW_COMPARE_IMM_EXC (s, NE_UN, stype, klass, &quot;InvalidCastException&quot;);
 	}
-	MONO_EMIT_NEW_COND_EXC (s, NE_UN, &quot;InvalidCastException&quot;);
 }
 
 static void
@@ -1812,8 +1804,7 @@
 
 	mini_emit_max_iid_check_vtable (s, vtable_reg, klass, NULL);
 	mini_emit_load_intf_reg_vtable (s, intf_reg, vtable_reg, klass);
-	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, intf_reg, 0);
-	MONO_EMIT_NEW_COND_EXC (s, EQ, &quot;InvalidCastException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, EQ, intf_reg, 0, &quot;InvalidCastException&quot;);
 }
 
 /*
@@ -1827,8 +1818,7 @@
 
 	mini_emit_max_iid_check_class (s, klass_reg, klass, NULL);
 	mini_emit_load_intf_reg_class (s, intf_reg, klass_reg, klass);
-	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, intf_reg, -1);
-	MONO_EMIT_NEW_COND_EXC (s, EQ, &quot;InvalidCastException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, EQ, intf_reg, -1, &quot;InvalidCastException&quot;);
 }
 
 static void
Index: mono/mini/inssel-long.brg
===================================================================
--- mono/mini/inssel-long.brg	(revision 70746)
+++ mono/mini/inssel-long.brg	(working copy)
@@ -228,103 +228,83 @@
 }
 
 reg: OP_LCONV_TO_OVF_I1 (reg) {
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 127);
-	MONO_EMIT_NEW_COND_EXC (s, GT, &quot;OverflowException&quot;);
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, -128);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT, state-&gt;left-&gt;reg1, 127, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, -128, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_I1_UN (reg) {
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 127);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 127, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_U1 (reg) {
 	/* probe value to be within 0 to 255 */
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 255);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 255, &quot;OverflowException&quot;);
 	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state-&gt;reg1, state-&gt;left-&gt;reg1, 0xff);
 }
 
 reg: OP_LCONV_TO_OVF_U1_UN (reg) {
 	/* probe value to be within 0 to 255 */
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 255);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 255, &quot;OverflowException&quot;);
 	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state-&gt;reg1, state-&gt;left-&gt;reg1, 0xff);
 }
 
 reg: OP_LCONV_TO_OVF_I2 (reg) {
 	/* Probe value to be within -32768 and 32767 */
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 32767);
-	MONO_EMIT_NEW_COND_EXC (s, GT, &quot;OverflowException&quot;);
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, -32768);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT, state-&gt;left-&gt;reg1, 32767, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, -32768, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_I2_UN (reg) {
 	/* Probe value to be within 0 and 32767 */
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 32767);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 32767, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_U2 (reg) {
 	/* Probe value to be within 0 and 65535 */
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 0xffff);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 0xffff, &quot;OverflowException&quot;);
 	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state-&gt;reg1, state-&gt;left-&gt;reg1, 0xffff);
 }
 
 reg: OP_LCONV_TO_OVF_U2_UN (reg) {
 	/* Probe value to be within 0 and 65535 */
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 0xffff);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 0xffff, &quot;OverflowException&quot;);
 	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state-&gt;reg1, state-&gt;left-&gt;reg1, 0xffff);
 }
 
 reg: OP_LCONV_TO_OVF_I4 (reg) {
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 0x7fffffff);
-	MONO_EMIT_NEW_COND_EXC (s, GT, &quot;OverflowException&quot;);
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, -2147483648);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT, state-&gt;left-&gt;reg1, 0x7fffffff, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, -2147483648, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_I4_UN (reg) {
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 0x7fffffff);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 0x7fffffff, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_U4 (reg) {
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 0xffffffffUL);
-	MONO_EMIT_NEW_COND_EXC (s, GT, &quot;OverflowException&quot;);
-	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, state-&gt;left-&gt;reg1, 0);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT, state-&gt;left-&gt;reg1, 0xffffffffUL, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, 0, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_U4_UN (reg) {
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 0xffffffff);
-	MONO_EMIT_NEW_COND_EXC (s, GT_UN, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, GT_UN, state-&gt;left-&gt;reg1, 0xffffffff, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_I_UN (reg),
 reg: OP_LCONV_TO_OVF_I8_UN (reg) {
-	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, state-&gt;left-&gt;reg1, 0);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
-
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, 0, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
 reg: OP_LCONV_TO_OVF_U8 (reg) {
-	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, state-&gt;left-&gt;reg1, 0);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
-
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, 0, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 
@@ -357,8 +337,7 @@
 }
 
 reg: CEE_CONV_OVF_U8 (reg) {
-	MONO_EMIT_NEW_COMPARE_IMM (s, state-&gt;left-&gt;reg1, 0);
-	MONO_EMIT_NEW_COND_EXC (s, LT, &quot;OverflowException&quot;);
+	MONO_EMIT_NEW_COMPARE_IMM_EXC (s, LT, state-&gt;left-&gt;reg1, 0, &quot;OverflowException&quot;);
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state-&gt;reg1, state-&gt;left-&gt;reg1);
 }
 



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022119.html">[Mono-dev] Patch review request -- breakup large tests in	basic.cs &amp; exception.cs
</A></li>
	<LI>Next message: <A HREF="022120.html">[Mono-dev] Patch review request -- generic changes to support	MIPS conditional exceptions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22110">[ date ]</a>
              <a href="thread.html#22110">[ thread ]</a>
              <a href="subject.html#22110">[ subject ]</a>
              <a href="author.html#22110">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
