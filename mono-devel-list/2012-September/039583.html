<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] runtime assisted object pools
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-dev%5D%20runtime%20assisted%20object%20pools&In-Reply-To=%3CCABaweDOJXmojZ2jiuF%2BtweASyC%2BEGaDB_1eqSy2dW0_3see2Zg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="039582.html">
   <LINK REL="Next"  HREF="039584.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] runtime assisted object pools</H1>
    <B>Jonathan Shore</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-dev%5D%20runtime%20assisted%20object%20pools&In-Reply-To=%3CCABaweDOJXmojZ2jiuF%2BtweASyC%2BEGaDB_1eqSy2dW0_3see2Zg%40mail.gmail.com%3E"
       TITLE="[Mono-dev] runtime assisted object pools">jonathan.shore at gmail.com
       </A><BR>
    <I>Mon Sep  3 16:14:43 UTC 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="039582.html">[Mono-dev] runtime assisted object pools
</A></li>
        <LI>Next message: <A HREF="039584.html">[Mono-dev] mono-patches list not working
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39583">[ date ]</a>
              <a href="thread.html#39583">[ thread ]</a>
              <a href="subject.html#39583">[ subject ]</a>
              <a href="author.html#39583">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>When I am able to use an object pool I don't really rely on the GC and
don't really need weak references either.   In one real-time application, I
cycle through ~ 9 billion objects over the course of a few hours.   The
working set in this scenario is small.

In the application I was testing with sgen, it is a batch oriented process,
not real-time.  Hence I rely on the GC in that case.    For latency
sensitive work am largely using object pools for the objects used at high
frequency and some structs where appropriate.

On Mon, Sep 3, 2012 at 8:18 AM, Nicholas Frechette &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">zeno490 at gmail.com</A>&gt;wrote:

&gt;<i> Have you thought about using weak pointers? Those are already handled
</I>&gt;<i> as a special case by the GC.
</I>&gt;<i> In your pool, you keep weak references such that if a GC happens and
</I>&gt;<i> no real references exist on an object outside of weak references, the
</I>&gt;<i> object will be GCed and all weak references will be invalidated. In
</I>&gt;<i> the event that a real reference exists, nothing changes.
</I>&gt;<i>
</I>&gt;<i> Then in your pool you can check for any invalidated entries and reuse
</I>&gt;<i> those, you could trigger a GC manually in hope of freeing some or you
</I>&gt;<i> could allocate new ones. As you see fit.
</I>&gt;<i>
</I>&gt;<i> Implementing a cache isn't very hard and I believe some might already
</I>&gt;<i> exist in .net (using more or less what I just described).
</I>&gt;<i>
</I>&gt;<i> In .net, weak references are called: System.WeakReference.
</I>&gt;<i>
</I>&gt;<i> As discussed above, a cache like this mostly only makes sense if the
</I>&gt;<i> allocation cost is very large or if you want a maximum fixed amount of
</I>&gt;<i> objects allocated.
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> Nicholas
</I>&gt;<i>
</I>&gt;<i> On Fri, Aug 31, 2012 at 7:45 PM, Jonathan Shore
</I>&gt;<i> &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jonathan.shore at gmail.com</A>&gt; wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On Aug 31, 2012, at 7:39 PM, Rodrigo Kumpera wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Unless you use explicit memory management or some other trick, such
</I>&gt;<i> scheme
</I>&gt;<i> &gt; is not any better than what both collectors already do.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Both use a size-segregated allocator for the major heap which works very
</I>&gt;<i> &gt; much like an object pool based on size.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Object pools work when allocating memory is very expensive. With an
</I>&gt;<i> modern
</I>&gt;<i> &gt; GC, the major cost is not allocation, but tracing.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I guess I'm searching for some solution that is at least as good as boehm
</I>&gt;<i> &gt; for my working set, but without the current memory size limitations.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I achieve much better performance when using object pools, of course
</I>&gt;<i> because
</I>&gt;<i> &gt; of the explicit object release, avoiding the cost of tracing.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On Fri, Aug 31, 2012 at 8:18 PM, Jonathan Shore &lt;
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jonathan.shore at gmail.com</A>&gt;
</I>&gt;<i> &gt; wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I use object pools where I have control over the lifecycle of objects
</I>&gt;<i> used
</I>&gt;<i> &gt;&gt; with high frequency.    In the application I was discussing with
</I>&gt;<i> respect to
</I>&gt;<i> &gt;&gt; sgen, it is very hard to explicitly use object pools (nor can I use
</I>&gt;<i> structs
</I>&gt;<i> &gt;&gt; in this case).
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I think Miguel mentioned briefly in a blog, but would be interesting to
</I>&gt;<i> &gt;&gt; have a non-MS compatible extension or special Mono namespace library /
</I>&gt;<i> &gt;&gt; runtime support for automatic object pooling.    I have a number of
</I>&gt;<i> &gt;&gt; applications that need to deal with billions of objects cycled through.
</I>&gt;<i> &gt;&gt; Instead of bending over backwards to try to fit in an explicit
</I>&gt;<i> ObjectPool
</I>&gt;<i> &gt;&gt; model, would love to be able to designate a maximum fixed size pool that
</I>&gt;<i> &gt;&gt; would be handled as a special case by the GC:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; whenever new &lt;someobject&gt; () is invoked, the runtime will attempt to
</I>&gt;<i> pull
</I>&gt;<i> &gt;&gt; from an existing object in pool
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; if the pool is full, a GC sweep is done to determine whether any of the
</I>&gt;<i> &gt;&gt; objects / slots in the pool are now garbage, perhaps compacting or just
</I>&gt;<i> &gt;&gt; marking.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; when an object becomes garbage, nothing explicit happens, is only
</I>&gt;<i> marked &amp;
</I>&gt;<i> &gt;&gt; reused on the next new.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I realize this is not part of the MS CLR spec, but is *very* useful for
</I>&gt;<i> &gt;&gt; all sorts of high throughput services and processing.   It seems like a
</I>&gt;<i> much
</I>&gt;<i> &gt;&gt; simplified form of what sgen or beohm would be doing.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Thoughts?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Jonathan
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; _______________________________________________
</I>&gt;<i> &gt;&gt; Mono-devel-list mailing list
</I>&gt;<i> &gt;&gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt;&gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-devel-list mailing list
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>


-- 
Jonathan Shore
<A HREF="http://tr8dr.wordpress.com/">http://tr8dr.wordpress.com/</A>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20120903/546e767f/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20120903/546e767f/attachment.html</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="039582.html">[Mono-dev] runtime assisted object pools
</A></li>
	<LI>Next message: <A HREF="039584.html">[Mono-dev] mono-patches list not working
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39583">[ date ]</a>
              <a href="thread.html#39583">[ thread ]</a>
              <a href="subject.html#39583">[ subject ]</a>
              <a href="author.html#39583">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
