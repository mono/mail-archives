<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] tuning sgen performance &amp; bug
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-dev%5D%20tuning%20sgen%20performance%20%26%20bug&In-Reply-To=%3CCAEGCbuLA8FcSLV2BwJaxLbMMeo0rM7MZmbRXpZdKnUcTk4CDiA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="039582.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] tuning sgen performance &amp; bug</H1>
    <B>Nicholas Frechette</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-dev%5D%20tuning%20sgen%20performance%20%26%20bug&In-Reply-To=%3CCAEGCbuLA8FcSLV2BwJaxLbMMeo0rM7MZmbRXpZdKnUcTk4CDiA%40mail.gmail.com%3E"
       TITLE="[Mono-dev] tuning sgen performance &amp; bug">zeno490 at gmail.com
       </A><BR>
    <I>Mon Sep  3 15:10:13 UTC 2012</I>
    <P><UL>
        
        <LI>Next message: <A HREF="039582.html">[Mono-dev] runtime assisted object pools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39581">[ date ]</a>
              <a href="thread.html#39581">[ thread ]</a>
              <a href="subject.html#39581">[ subject ]</a>
              <a href="author.html#39581">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>You might want to consider optimizing your memory usage. In time
series data, usually it is best not to keep objects in those arrays
but rather structs. The time serie itself can be an object but keeping
large arrays of small objects is very bad performance wise: you waste
memory due to the internal overhead of an allocation/object and the
CPU cache will have a very hard time keeping up (because every small
object access will cause a cache miss). Also obviously the high
allocation rates will cause many GC collections to happen as you touch
those. This also will speed up the GC collection time since far fewer
references need to be traversed/touched.

With arrays of structs, the allocations are likely to be large and go
into a separate heap. If they aren't that large (because maybe your
time series only keep a small set of data), they the amount of
allocations is still dramatically reduced and fixed.

In mine, my time serie keeps arrays of structs (typed on the time
serie) where those arrays are managed as circular buffers. Cache usage
is optimal and the number of allocations is reduced. Furthermore,
since the size is fixed, once it is allocated, no allocation happens
even if I go through GBs of data.

Keep in mind nothing I said applies to you if your objects in those
time series are very large and the copy overhead would be too great
for you. However, I would consider 88 bytes to be small considering
the potential memory/cpu savings here.

2 cents.
Cheers,
Nicholas

On Fri, Aug 31, 2012 at 6:26 PM, Jonathan Shore
&lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jonathan.shore at gmail.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i> With this specific application, (which is single threaded), I have a
</I>&gt;<i> &quot;volatile&quot; working set of ~2GB .   By volatile I mean that these are not
</I>&gt;<i> application lifetime objects, rather will be disposed at some point during
</I>&gt;<i> evaluation.
</I>&gt;<i>
</I>&gt;<i> More specifically, I read 1.6TB of data incrementally into 1600 timeseries
</I>&gt;<i> (basically an array of event objects).   Each timeseries only holds a window
</I>&gt;<i> of data (in my case half with 25K items  and half with 5K items).   Once
</I>&gt;<i> each timeseries has overrun by say 1024 elements, the 1024 oldest elements
</I>&gt;<i> are shifted off, for GC.
</I>&gt;<i>
</I>&gt;<i> So the pattern is that there are always 2GB of referenced objects, and
</I>&gt;<i> periodically 1600 x 1024 old objects to be disposed of.    Due to the large
</I>&gt;<i> sizes, it would seem that these older objects get relegated to the main
</I>&gt;<i> heap.   This then requires a much more expensive GC (presumably).
</I>&gt;<i>
</I>&gt;<i> If I understood the sgen algorithm correctly, no matter what the size of the
</I>&gt;<i> nursery (unless was 1.6TB), my working set is going to land in the main heap
</I>&gt;<i> with my object garbage pattern.    I believe this is because if the nursery
</I>&gt;<i> fills, any objects that are still referenced, regardless of age, will be
</I>&gt;<i> moved to the main heap.    Once GC completes, the nursery is empty (maybe
</I>&gt;<i> except pinned objs)?
</I>&gt;<i>
</I>&gt;<i> My objects become garbage in a FIFO pattern and not something LIFO like.
</I>&gt;<i> The garbage &quot;pipeline&quot; is 2GB large, so the nursery fails for this app.
</I>&gt;<i>
</I>&gt;<i> Assuming Boehm is my only choice, If I expand the series window or # of
</I>&gt;<i> series I quickly run into the maximum heap problem with Boehm.
</I>&gt;<i>
</I>&gt;<i> Ideas?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Aug 31, 2012, at 5:29 PM, Rodrigo Kumpera wrote:
</I>&gt;<i>
</I>&gt;<i> There are two situations that make sgen slower than boehm.
</I>&gt;<i>
</I>&gt;<i> The first is a non-generational workload. If your survivor rate is too high,
</I>&gt;<i> a generational collector
</I>&gt;<i> can't compete with single space one like boehm.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> To some extent this is defined by the size of the nursery, no?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The second one is if you have too much of the old generation pointing to
</I>&gt;<i> young objects causing minor collections
</I>&gt;<i> to scan way too much memory to be profitable.
</I>&gt;<i>
</I>&gt;<i> The nursery size should usually be a not so small fraction of the total heap
</I>&gt;<i> you expect. As a good guess you can use
</I>&gt;<i> 1/10 - 1/20.
</I>&gt;<i>
</I>&gt;<i> Are you expecting to have a heap of multiple Gigs? Because a 2Gb nursery
</I>&gt;<i> will need at least 8Gb of major memory.
</I>&gt;<i>
</I>&gt;<i> About your crash. I just noticed a very silly thing, we have never ever
</I>&gt;<i> tried sgen with huge nurseries because there's a
</I>&gt;<i> 128Mb implicit limit due to some internal sizes.
</I>&gt;<i>
</I>&gt;<i> Jonathan, for such huge heaps, sgen will need the parallel collector to
</I>&gt;<i> compete with boehm on linux, which is a not
</I>&gt;<i> very mature piece of code both in stability and performance.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Fri, Aug 31, 2012 at 2:03 PM, Jonathan Shore &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jonathan.shore at gmail.com</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> HI,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> sgen is now working for me (thanks to a subtle bug fix for
</I>&gt;&gt;<i> thread-local-storage by Zoltan).   However, for one application, sgen is 25%
</I>&gt;&gt;<i> slower than the same with the boehm collector.   I am processing some GBs of
</I>&gt;&gt;<i> timeseries data, though only evaluating a window at a time.   As the window
</I>&gt;&gt;<i> reaches some size, older objects in the timeseries are dereferenced.   The
</I>&gt;&gt;<i> object size is 88bytes, but generate many millions across the course of a
</I>&gt;&gt;<i> run.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I suspect that the nursery is too small, so that the objects I want to
</I>&gt;&gt;<i> collect are now in the main heap.    Towards that end I wanted to extend the
</I>&gt;&gt;<i> nursery, and attempted this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> export MONO_GC_PARAMS=&quot;nursery-size=2g&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This causes mono to crash immediately, with:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Assertion at sgen-gc.c:1206, condition `idx &lt; section-&gt;num_scan_start'
</I>&gt;&gt;<i> not met
</I>&gt;&gt;<i> ...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (this is on linux with the latest code on master, roughly 2.11.3+)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I took a look at the code, but requires too much context for me to
</I>&gt;&gt;<i> understand the real cause of the issue.   I am guessing that there is some
</I>&gt;&gt;<i> assumption re: the size of the nursery, block size, etc.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Finally, I am interested in trying the &quot;copying collector&quot; as discussed in
</I>&gt;&gt;<i> this blog entry:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> <A HREF="http://schani.wordpress.com/2011/01/10/sgen-the-major-collectors/">http://schani.wordpress.com/2011/01/10/sgen-the-major-collectors/</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm wondering if will get some performance advantages with this approach,
</I>&gt;&gt;<i> whereas the nursery may be too small for my garbage working set.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ideas?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks
</I>&gt;&gt;<i> Jonathan
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="039582.html">[Mono-dev] runtime assisted object pools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39581">[ date ]</a>
              <a href="thread.html#39581">[ thread ]</a>
              <a href="subject.html#39581">[ subject ]</a>
              <a href="author.html#39581">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
