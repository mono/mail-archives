<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [Mono-patches] [mono/moon] caef081d: Implemented an iconv-like API for unicode conversion
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BMono-patches%5D%20%5Bmono/moon%5D%20caef081d%3A%20Implemented%20an%0A%20iconv-like%20API%20for%20unicode%20conversion&In-Reply-To=20110420010641.5843522128%40mono.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="037445.html">
   <LINK REL="Next"  HREF="037448.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [Mono-patches] [mono/moon] caef081d: Implemented an iconv-like API for unicode conversion</H1>
    <B>Rodrigo Kumpera</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BMono-patches%5D%20%5Bmono/moon%5D%20caef081d%3A%20Implemented%20an%0A%20iconv-like%20API%20for%20unicode%20conversion&In-Reply-To=20110420010641.5843522128%40mono.ximian.com"
       TITLE="[Mono-dev] [Mono-patches] [mono/moon] caef081d: Implemented an iconv-like API for unicode conversion">kumpera at gmail.com
       </A><BR>
    <I>Wed Apr 20 00:00:35 EDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="037445.html">[Mono-dev] eglib changes for Moonlight
</A></li>
        <LI>Next message: <A HREF="037448.html">[Mono-dev] [Mono-patches] [mono/moon] caef081d: Implemented an iconv-like API for unicode conversion
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37447">[ date ]</a>
              <a href="thread.html#37447">[ thread ]</a>
              <a href="subject.html#37447">[ subject ]</a>
              <a href="author.html#37447">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jeff, shouldn't this be part of eglib as a build time option?
On Apr 19, 2011 10:06 PM, &quot;Jeffrey Stedfast (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">fejj at gnome.org</A>)&quot; &lt;
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-patches at lists.ximian.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i> Branch: refs/heads/master
</I>&gt;<i> Home: <A HREF="https://github.com/mono/moon">https://github.com/mono/moon</A>
</I>&gt;<i>
</I>&gt;<i> Commit: caef081dc43c17327c37932f65264deec19d8022
</I>&gt;<i> Author: Jeffrey Stedfast &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">fejj at gnome.org</A>&gt;
</I>&gt;<i> Date: 04/19/2011 21:05:59
</I>&gt;<i> URL:
</I><A HREF="https://github.com/mono/moon/commit/caef081dc43c17327c37932f65264deec19d8022">https://github.com/mono/moon/commit/caef081dc43c17327c37932f65264deec19d8022</A>
&gt;<i>
</I>&gt;<i> Implemented an iconv-like API for unicode conversion
</I>&gt;<i>
</I>&gt;<i> Changed paths:
</I>&gt;<i> M src/Makefile.am
</I>&gt;<i> Added paths:
</I>&gt;<i> A src/miconv.cpp
</I>&gt;<i> A src/miconv.h
</I>&gt;<i>
</I>&gt;<i> Modified: src/Makefile.am
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- a/src/Makefile.am
</I>&gt;<i> +++ b/src/Makefile.am
</I>&gt;<i> @@ -78,6 +78,7 @@ libmoon_include_headers = \
</I>&gt;<i> medialog.h \
</I>&gt;<i> mediaplayer.h \
</I>&gt;<i> messaging.h \
</I>&gt;<i> + miconv.h \
</I>&gt;<i> moon-curves.h \
</I>&gt;<i> moonlightconfiguration.h\
</I>&gt;<i> moon-path.h \
</I>&gt;<i> @@ -234,6 +235,7 @@ dist_libmoon_la_SOURCES = \
</I>&gt;<i> medialog.cpp \
</I>&gt;<i> mediaplayer.cpp \
</I>&gt;<i> messaging.cpp \
</I>&gt;<i> + miconv.cpp \
</I>&gt;<i> moon-curves.c \
</I>&gt;<i> moonlightconfiguration.cpp \
</I>&gt;<i> moon-path.c \
</I>&gt;<i>
</I>&gt;<i> Added: src/miconv.cpp
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/src/miconv.cpp
</I>&gt;<i> @@ -0,0 +1,344 @@
</I>&gt;<i> +/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8
</I>-*- */
&gt;<i> +/*
</I>&gt;<i> + * miconv.cpp:
</I>&gt;<i> + *
</I>&gt;<i> + * Contact:
</I>&gt;<i> + * Moonlight List (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">moonlight-list at lists.ximian.com</A>)
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright 2011 Novell, Inc. (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> + *
</I>&gt;<i> + * See the LICENSE file included with the distribution for details.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;config.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;glib.h&gt;
</I>&gt;<i> +#include &lt;string.h&gt;
</I>&gt;<i> +#include &lt;errno.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &quot;miconv.h&quot;
</I>&gt;<i> +
</I>&gt;<i> +namespace Moonlight {
</I>&gt;<i> +
</I>&gt;<i> +enum Endian {
</I>&gt;<i> + LittleEndian,
</I>&gt;<i> + BigEndian
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +typedef int (* Decoder) (Endian endian, char **inbytes, size_t
</I>*inbytesleft, gunichar *outchar);
&gt;<i> +typedef int (* Encoder) (gunichar c, char **outbytes, size_t
</I>*outbytesleft);
&gt;<i> +
</I>&gt;<i> +static int decode_utf32 (Endian endian, char **inbytes, size_t
</I>*inbytesleft, gunichar *outchar);
&gt;<i> +//static int encode_utf32 (gunichar c, char **outbytes, size_t
</I>*outbytesleft);
&gt;<i> +
</I>&gt;<i> +static int decode_utf16 (Endian endian, char **inbytes, size_t
</I>*inbytesleft, gunichar *outchar);
&gt;<i> +//static int encode_utf16 (gunichar c, char **outbytes, size_t
</I>*outbytesleft);
&gt;<i> +
</I>&gt;<i> +static int decode_utf8 (Endian endian, char **inbytes, size_t
</I>*inbytesleft, gunichar *outchar);
&gt;<i> +static int encode_utf8 (gunichar c, char **outbytes, size_t
</I>*outbytesleft);
&gt;<i> +
</I>&gt;<i> +static struct {
</I>&gt;<i> + const char *name;
</I>&gt;<i> + Decoder decoder;
</I>&gt;<i> + Encoder encoder;
</I>&gt;<i> + Endian endian;
</I>&gt;<i> +} charsets[] = {
</I>&gt;<i> + { &quot;UTF-32BE&quot;, decode_utf32, NULL, BigEndian },
</I>&gt;<i> + { &quot;UTF-32LE&quot;, decode_utf32, NULL, LittleEndian },
</I>&gt;<i> + { &quot;UTF-16BE&quot;, decode_utf16, NULL, BigEndian },
</I>&gt;<i> + { &quot;UTF-16LE&quot;, decode_utf16, NULL, LittleEndian },
</I>&gt;<i> + { &quot;UTF-8&quot;, decode_utf8, encode_utf8, LittleEndian },
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct _miconv_t {
</I>&gt;<i> + Decoder decode;
</I>&gt;<i> + Encoder encode;
</I>&gt;<i> + Endian endian;
</I>&gt;<i> + gunichar c;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +miconv_t
</I>&gt;<i> +miconv_open (const char *to, const char *from)
</I>&gt;<i> +{
</I>&gt;<i> + Decoder decoder = NULL;
</I>&gt;<i> + Encoder encoder = NULL;
</I>&gt;<i> + Endian endian;
</I>&gt;<i> + miconv_t cd;
</I>&gt;<i> + guint i;
</I>&gt;<i> +
</I>&gt;<i> + if (!to || !from)
</I>&gt;<i> + return (miconv_t) -1;
</I>&gt;<i> +
</I>&gt;<i> + for (i = 0; i &lt; G_N_ELEMENTS (charsets); i++) {
</I>&gt;<i> + if (!strcmp (charsets[i].name, from)) {
</I>&gt;<i> + decoder = charsets[i].decoder;
</I>&gt;<i> + endian = charsets[i].endian;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (!strcmp (charsets[i].name, to))
</I>&gt;<i> + encoder = charsets[i].encoder;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (encoder == NULL || decoder == NULL)
</I>&gt;<i> + return (miconv_t) -1;
</I>&gt;<i> +
</I>&gt;<i> + cd = (miconv_t) g_malloc (sizeof (*cd));
</I>&gt;<i> + cd-&gt;decode = decoder;
</I>&gt;<i> + cd-&gt;encode = encoder;
</I>&gt;<i> + cd-&gt;endian = endian;
</I>&gt;<i> + cd-&gt;c = -1;
</I>&gt;<i> +
</I>&gt;<i> + return cd;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int
</I>&gt;<i> +miconv_close (miconv_t cd)
</I>&gt;<i> +{
</I>&gt;<i> + g_free (cd);
</I>&gt;<i> + return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int
</I>&gt;<i> +miconv (miconv_t cd, char **inbytes, size_t *inbytesleft,
</I>&gt;<i> + char **outbytes, size_t *outbytesleft)
</I>&gt;<i> +{
</I>&gt;<i> + size_t inleft, outleft;
</I>&gt;<i> + char *inptr, *outptr;
</I>&gt;<i> + gunichar c;
</I>&gt;<i> + int rc = 0;
</I>&gt;<i> +
</I>&gt;<i> + if (outbytes == NULL || outbytesleft == NULL) {
</I>&gt;<i> + /* reset converter */
</I>&gt;<i> + cd-&gt;c = -1;
</I>&gt;<i> + return 0;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + inleft = inbytesleft ? *inbytesleft : 0;
</I>&gt;<i> + inptr = inbytes ? *inbytes : NULL;
</I>&gt;<i> + outleft = *outbytesleft;
</I>&gt;<i> + outptr = *outbytes;
</I>&gt;<i> + c = cd-&gt;c;
</I>&gt;<i> +
</I>&gt;<i> + while (inleft &gt;= 0 &amp;&amp; outleft &gt; 0) {
</I>&gt;<i> + if (c == (gunichar) -1 &amp;&amp; cd-&gt;decode (cd-&gt;endian, &amp;inptr, &amp;inleft, &amp;c)
</I>== -1) {
&gt;<i> + rc = -1;
</I>&gt;<i> + break;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (cd-&gt;encode (c, &amp;outptr, &amp;outleft) == -1) {
</I>&gt;<i> + rc = -1;
</I>&gt;<i> + break;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + c = -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (inbytesleft)
</I>&gt;<i> + *inbytesleft = inleft;
</I>&gt;<i> +
</I>&gt;<i> + if (inbytes)
</I>&gt;<i> + *inbytes = inptr;
</I>&gt;<i> +
</I>&gt;<i> + *outbytesleft = outleft;
</I>&gt;<i> + *outbytes = outptr;
</I>&gt;<i> + cd-&gt;c = c;
</I>&gt;<i> +
</I>&gt;<i> + return rc;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static int
</I>&gt;<i> +decode_utf32 (Endian endian, char **inbytes, size_t *inbytesleft,
</I>gunichar *outchar)
&gt;<i> +{
</I>&gt;<i> + gunichar *inptr = (gunichar *) *inbytes;
</I>&gt;<i> + size_t inleft = *inbytesleft;
</I>&gt;<i> + gunichar c;
</I>&gt;<i> +
</I>&gt;<i> + if (inleft &lt; 4) {
</I>&gt;<i> + errno = EINVAL;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (endian == BigEndian)
</I>&gt;<i> + c = GUINT32_FROM_BE (*inptr);
</I>&gt;<i> + else
</I>&gt;<i> + c = GUINT32_FROM_LE (*inptr);
</I>&gt;<i> +
</I>&gt;<i> + inleft -= 4;
</I>&gt;<i> + inptr++;
</I>&gt;<i> +
</I>&gt;<i> + if (c &gt;= 2147483648UL) {
</I>&gt;<i> + errno = EILSEQ;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + *inbytes = (char *) inptr;
</I>&gt;<i> + *inbytesleft = inleft;
</I>&gt;<i> + *outchar = c;
</I>&gt;<i> +
</I>&gt;<i> + return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +//static int encode_utf32 (gunichar c, char **outbytes, size_t
</I>*outbytesleft);
&gt;<i> +
</I>&gt;<i> +static int
</I>&gt;<i> +decode_utf16 (Endian endian, char **inbytes, size_t *inbytesleft,
</I>gunichar *outchar)
&gt;<i> +{
</I>&gt;<i> + gunichar2 *inptr = (gunichar2 *) *inbytes;
</I>&gt;<i> + size_t inleft = *inbytesleft;
</I>&gt;<i> + gunichar2 c;
</I>&gt;<i> + gunichar u;
</I>&gt;<i> +
</I>&gt;<i> + if (inleft &lt; 2) {
</I>&gt;<i> + errno = EINVAL;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (endian == BigEndian)
</I>&gt;<i> + u = GUINT16_FROM_BE (*inptr);
</I>&gt;<i> + else
</I>&gt;<i> + u = GUINT16_FROM_LE (*inptr);
</I>&gt;<i> +
</I>&gt;<i> + inleft -= 2;
</I>&gt;<i> + inptr++;
</I>&gt;<i> +
</I>&gt;<i> + if (u &gt;= 0xdc00 &amp;&amp; u &lt;= 0xdfff) {
</I>&gt;<i> + errno = EILSEQ;
</I>&gt;<i> + return -1;
</I>&gt;<i> + } else if (u &gt;= 0xd800 &amp;&amp; u &lt;= 0xdbff) {
</I>&gt;<i> + if (inleft &lt; 2) {
</I>&gt;<i> + errno = EINVAL;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (endian == BigEndian)
</I>&gt;<i> + c = GUINT16_FROM_BE (*inptr);
</I>&gt;<i> + else
</I>&gt;<i> + c = GUINT16_FROM_LE (*inptr);
</I>&gt;<i> +
</I>&gt;<i> + inleft -= 2;
</I>&gt;<i> + inptr++;
</I>&gt;<i> +
</I>&gt;<i> + if (c &lt; 0xdc00 || c &gt; 0xdfff) {
</I>&gt;<i> + errno = EILSEQ;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + u = ((u - 0xd800) &lt;&lt; 10) + (c - 0xdc00) + 0x0010000UL;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + *inbytes = (char *) inptr;
</I>&gt;<i> + *inbytesleft = inleft;
</I>&gt;<i> + *outchar = u;
</I>&gt;<i> +
</I>&gt;<i> + return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +//static int encode_utf16 (gunichar c, char **outbytes, size_t
</I>*outbytesleft);
&gt;<i> +
</I>&gt;<i> +static int
</I>&gt;<i> +decode_utf8 (Endian endian, char **inbytes, size_t *inbytesleft, gunichar
</I>*outchar)
&gt;<i> +{
</I>&gt;<i> + size_t inleft = *inbytesleft;
</I>&gt;<i> + char *inptr = *inbytes;
</I>&gt;<i> + size_t i, len = 0;
</I>&gt;<i> + unsigned char c;
</I>&gt;<i> + gunichar u;
</I>&gt;<i> +
</I>&gt;<i> + c = *inptr++;
</I>&gt;<i> +
</I>&gt;<i> + if (c &lt; 0x80) {
</I>&gt;<i> + /* simple ascii case */
</I>&gt;<i> + len = 1;
</I>&gt;<i> + } else if ((c &amp; 0xe0) == 0xc0) {
</I>&gt;<i> + c &amp;= 0x1f;
</I>&gt;<i> + len = 2;
</I>&gt;<i> + } else if ((c &amp; 0xf0) == 0xe0) {
</I>&gt;<i> + c &amp;= 0x0f;
</I>&gt;<i> + len = 3;
</I>&gt;<i> + } else if ((c &amp; 0xf8) == 0xf0) {
</I>&gt;<i> + c &amp;= 0x07;
</I>&gt;<i> + len = 4;
</I>&gt;<i> + } else if ((c &amp; 0xfc) == 0xf8) {
</I>&gt;<i> + c &amp;= 0x03;
</I>&gt;<i> + len = 5;
</I>&gt;<i> + } else if ((c &amp; 0xfe) == 0xfc) {
</I>&gt;<i> + c &amp;= 0x01;
</I>&gt;<i> + len = 6;
</I>&gt;<i> + } else {
</I>&gt;<i> + errno = EILSEQ;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (len &gt; inleft) {
</I>&gt;<i> + errno = EINVAL;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + u = c;
</I>&gt;<i> + for (i = 1; i &lt; len; i++) {
</I>&gt;<i> + u &lt;&lt;= 6 | ((*inptr) &amp; 0x3f);
</I>&gt;<i> + inptr++;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + *inbytesleft = inleft - len;
</I>&gt;<i> + *inbytes = inptr;
</I>&gt;<i> + *outchar = u;
</I>&gt;<i> +
</I>&gt;<i> + return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int
</I>&gt;<i> +encode_utf8 (gunichar c, char **outbytes, size_t *outbytesleft)
</I>&gt;<i> +{
</I>&gt;<i> + size_t outleft = *outbytesleft;
</I>&gt;<i> + char *outptr = *outbytes;
</I>&gt;<i> + size_t len, i;
</I>&gt;<i> + char base;
</I>&gt;<i> +
</I>&gt;<i> + if (c &lt; 128UL) {
</I>&gt;<i> + base = 0;
</I>&gt;<i> + len = 1;
</I>&gt;<i> + } else if (c &lt; 2048UL) {
</I>&gt;<i> + base = 192;
</I>&gt;<i> + len = 2;
</I>&gt;<i> + } else if (c &lt; 65536UL) {
</I>&gt;<i> + base = 224;
</I>&gt;<i> + len = 3;
</I>&gt;<i> + } else if (c &lt; 2097152UL) {
</I>&gt;<i> + base = 240;
</I>&gt;<i> + len = 4;
</I>&gt;<i> + } else if (c &lt; 67108864UL) {
</I>&gt;<i> + base = 248;
</I>&gt;<i> + len = 5;
</I>&gt;<i> + } else if (c &lt; 2147483648UL) {
</I>&gt;<i> + base = 252;
</I>&gt;<i> + len = 6;
</I>&gt;<i> + } else {
</I>&gt;<i> + errno = EINVAL;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + if (outleft &lt; len) {
</I>&gt;<i> + errno = E2BIG;
</I>&gt;<i> + return -1;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + for (i = len - 1; i &gt; 0; i--) {
</I>&gt;<i> + /* mask off 6 bits worth and add 128 */
</I>&gt;<i> + outptr[i] = 128 + (c &amp; 0x3f);
</I>&gt;<i> + c &gt;&gt;= 6;
</I>&gt;<i> + }
</I>&gt;<i> +
</I>&gt;<i> + /* first character has a different base */
</I>&gt;<i> + outptr[0] = base + (c &amp; 0x3f);
</I>&gt;<i> +
</I>&gt;<i> + *outbytesleft = outleft - len;
</I>&gt;<i> + *outbytes = outptr + len;
</I>&gt;<i> +
</I>&gt;<i> + return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i>
</I>&gt;<i> Added: src/miconv.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/src/miconv.h
</I>&gt;<i> @@ -0,0 +1,35 @@
</I>&gt;<i> +/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8
</I>-*- */
&gt;<i> +/*
</I>&gt;<i> + * miconv.h:
</I>&gt;<i> + *
</I>&gt;<i> + * Contact:
</I>&gt;<i> + * Moonlight List (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">moonlight-list at lists.ximian.com</A>)
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright 2011 Novell, Inc. (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> + *
</I>&gt;<i> + * See the LICENSE file included with the distribution for details.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#ifndef __MICONV_H__
</I>&gt;<i> +#define __MICONV_H__
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;glib.h&gt;
</I>&gt;<i> +#include &lt;sys/types.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +namespace Moonlight {
</I>&gt;<i> +
</I>&gt;<i> +G_BEGIN_DECLS
</I>&gt;<i> +
</I>&gt;<i> +typedef struct _miconv_t *miconv_t;
</I>&gt;<i> +
</I>&gt;<i> +int miconv (miconv_t cd, char **inbytes, size_t *inbytesleft,
</I>&gt;<i> + char **outbytes, size_t *outbytesleft);
</I>&gt;<i> +miconv_t miconv_open (const char *to, const char *from);
</I>&gt;<i> +int miconv_close (miconv_t cd);
</I>&gt;<i> +
</I>&gt;<i> +G_END_DECLS
</I>&gt;<i> +
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +#endif /* __MICONV_H__ */
</I>&gt;<i> +
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-patches maillist - <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-patches at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-patches">http://lists.ximian.com/mailman/listinfo/mono-patches</A>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20110420/6868159f/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20110420/6868159f/attachment.html</A> 
</PRE>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="037445.html">[Mono-dev] eglib changes for Moonlight
</A></li>
	<LI>Next message: <A HREF="037448.html">[Mono-dev] [Mono-patches] [mono/moon] caef081d: Implemented an iconv-like API for unicode conversion
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37447">[ date ]</a>
              <a href="thread.html#37447">[ thread ]</a>
              <a href="subject.html#37447">[ subject ]</a>
              <a href="author.html#37447">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
