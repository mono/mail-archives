<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Control-C handler
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Control-C%20handler&In-Reply-To=20080111185614.GJ5889%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026609.html">
   <LINK REL="Next"  HREF="026719.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Control-C handler</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Control-C%20handler&In-Reply-To=20080111185614.GJ5889%40debian.org"
       TITLE="[Mono-dev] Control-C handler">jonpryor at vt.edu
       </A><BR>
    <I>Fri Jan 11 14:57:49 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="026609.html">[Mono-dev] Control-C handler
</A></li>
        <LI>Next message: <A HREF="026719.html">[Mono-dev] Control-C handler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26613">[ date ]</a>
              <a href="thread.html#26613">[ thread ]</a>
              <a href="subject.html#26613">[ subject ]</a>
              <a href="author.html#26613">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2008-01-11 at 19:56 +0100, Paolo Molaro wrote:
&gt;<i> On 01/10/08 Jonathan Pryor wrote:
</I>&gt;<i> &gt; Attached is an updated patch set which supports both the existing/new
</I>&gt;<i> &gt; Stdlib.signal() semantics...
</I>&gt;<i> 
</I>&gt;<i> I think signal() should just be obsoleted, starting a thread yourself
</I>&gt;<i> doesn't provide the same semantics and it is doesn't allow the user much
</I>&gt;<i> control.
</I>
OK.  But...

&gt;<i> &gt; Of course, this could be used as an argument to dump Stdlib.signal()
</I>&gt;<i> &gt; support entirely, but it needs to stick around to permit setting SIG_IGN
</I>&gt;<i> &gt; on a given signal.  I suppose Stdlib.signal() could be restricted to
</I>&gt;<i> &gt; just accepting SIG_IGN, SIG_ERR, and SIG_DFL and error out if any other
</I>&gt;<i> 
</I>&gt;<i> Just provide a sane interface to ignore a signal instead of this kludge.
</I>
What exactly would be a &quot;sane interface to ignore a signal&quot; aside from
e.g. Stdlib.signal(Signum.SIGINT, Stdlib.SIG_IGN) (and/or setting the
default or error handler for the specified signal)?  The current
Stdlib.signal() interface seems quite sane for that (to me), and results
in a fairly sensible implementation:

	public static SignalHandler signal (Signum sig, SignalHandler h)
	{
	  if (h != SIG_IGN &amp;&amp; h != SIG_DFL &amp;&amp; h != SIG_ERR)
	    throw new UnixIOException (...);
	  return TranslateHandler (sys_signal (sig, h));
	}

&gt;<i> &gt; delegate instance is passed, so that people use UnixSignal for all
</I>&gt;<i> &gt; significant signal usage, but I don't like this either as currently each
</I>&gt;<i> &gt; UnixSignal.WaitOne() call requires a separate pipe, while
</I>&gt;<i> 
</I>&gt;<i> This is an implementation detail of your version, it could be done
</I>&gt;<i> differently.
</I>
Yes, but the question is at what cost?  With one pipe/UnixSignal
instance, WaitOne() will ONLY be woken up once the pipe is ready.  With
a all UnixSignal instances sharing a single pipe, ALL instances will
wake up once the pipe is ready, and the only way of knowing which
signal(s) was written was to read(2) the pipe, which only one UnixSignal
instance can do...

I'm sure there's a better way to do it, but I can't think of it yet.
Suggestions welcome. :-)

&gt;<i> &gt; Index: Mono.Unix.Native/Stdlib.cs
</I>&gt;<i> &gt; ===================================================================
</I>&gt;<i> &gt; --- Mono.Unix.Native/Stdlib.cs	(revision 92060)
</I>&gt;<i> &gt; +++ Mono.Unix.Native/Stdlib.cs	(working copy)
</I>&gt;<i> &gt; @@ -31,6 +31,9 @@
</I>&gt;<i> &gt;  using System.IO;
</I>&gt;<i> &gt;  using System.Runtime.InteropServices;
</I>&gt;<i> &gt;  using System.Text;
</I>&gt;<i> &gt; +using System.Threading;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +using Mono.Unix;
</I>&gt;<i> &gt;  using Mono.Unix.Native;
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;  namespace Mono.Unix.Native {
</I>&gt;<i> &gt; @@ -359,7 +362,7 @@
</I>&gt;<i> &gt;  	//        This is the case for using NativeConvert, which will throw an
</I>&gt;<i> &gt;  	//        exception if an invalid/unsupported value is used.
</I>&gt;<i> &gt;  	//
</I>&gt;<i> &gt; -	public class Stdlib
</I>&gt;<i> &gt; +	public unsafe class Stdlib
</I>&gt;<i> 
</I>&gt;<i> It's a bad idea to make the whole class unsafe.
</I>
Indeed, especially when only one method needs it.  For some reason I
thought if any method needed unsafe, the class did as well -- insane.

&gt;<i> &gt; @@ -494,6 +495,45 @@
</I>&gt;<i> &gt;  #endif
</I>&gt;<i> &gt;  		}
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt; +		[DllImport (MPH, CallingConvention=CallingConvention.Cdecl,
</I>&gt;<i> &gt; +				SetLastError=true, EntryPoint=&quot;_mph_set_signal_write_fd&quot;)]
</I>&gt;<i> &gt; +		private static extern void set_signal_write_fd (int signum);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +		static object signal_dispatcher;
</I>&gt;<i> &gt; +		static int    signal_read_fd;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +		private static void InitSignalSupport ()
</I>&gt;<i> &gt; +		{
</I>&gt;<i> &gt; +			if (Path.DirectorySeparatorChar == '\\')
</I>&gt;<i> &gt; +				return;
</I>&gt;<i> 
</I>&gt;<i> This looks ugly.
</I>
This is no longer necessary if we only support UnixSignal and not the
separate-thread Stdlib.signal() behavior.

&gt;<i> &gt; --- Mono.Unix/UnixSignal.cs	(revision 0)
</I>&gt;<i> &gt; +++ Mono.Unix/UnixSignal.cs	(revision 0)
</I>&gt;<i> [...]
</I>&gt;<i> &gt; +namespace Mono.Unix {
</I>&gt;<i> &gt; +	public class UnixSignal : WaitHandle {
</I>&gt;<i> &gt; +		private Signum signum;
</I>&gt;<i> &gt; +		private int _signum;
</I>&gt;<i> &gt; +		private IntPtr signal_info;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +		public UnixSignal (Signum signum)
</I>&gt;<i> &gt; +		{
</I>&gt;<i> &gt; +			this.signum = signum;
</I>&gt;<i> &gt; +			this._signum = NativeConvert.FromSignum (signum);
</I>&gt;<i> &gt; +			lock (Stdlib.registered_signals) {
</I>&gt;<i> &gt; +				this.signal_info = install (_signum);
</I>&gt;<i> &gt; +			}
</I>&gt;<i> &gt; +			if (this.signal_info == IntPtr.Zero) {
</I>&gt;<i> &gt; +				throw new ArgumentException (&quot;Unable to handle signal&quot;, &quot;signum&quot;);
</I>&gt;<i> &gt; +			}
</I>&gt;<i> &gt; +		}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +		public Signum Signum {
</I>&gt;<i> &gt; +			get { return signum; }
</I>&gt;<i> &gt; +		}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +		[DllImport (Stdlib.MPH, CallingConvention=CallingConvention.Cdecl,
</I>&gt;<i> &gt; +				EntryPoint=&quot;Mono_Unix_UnixSignal_install&quot;)]
</I>&gt;<i> &gt; +		private static extern IntPtr install (int signum);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +		[DllImport (Stdlib.MPH, CallingConvention=CallingConvention.Cdecl,
</I>&gt;<i> &gt; +				EntryPoint=&quot;Mono_Unix_UnixSignal_uninstall&quot;)]
</I>&gt;<i> &gt; +		private static extern void uninstall (int signum);
</I>&gt;<i> 
</I>&gt;<i> My proposed interface allows registering multiple handlers per signals
</I>&gt;<i> and this code can deal with just one.
</I>
That's another one of those &quot;I'm not sure how else to implement that&quot;
issues, largely tied to the previous one regarding pipes.

&gt;<i> &gt; +		public unsafe override bool WaitOne (int millisecondsTimeout, bool exitContext)
</I>&gt;<i> &gt; +		{
</I>&gt;<i> &gt; +			AssertValid ();
</I>&gt;<i> &gt; +			if (exitContext)
</I>&gt;<i> &gt; +				throw new InvalidOperationException (&quot;exitContext is not supported&quot;);
</I>&gt;<i> &gt; +			if (millisecondsTimeout &lt; -1)
</I>&gt;<i> &gt; +				throw new ArgumentOutOfRangeException (&quot;millisecondsTimeout&quot;);
</I>&gt;<i> &gt; +			int read, write;
</I>&gt;<i> &gt; +			bool close = true;
</I>&gt;<i> &gt; +			read = write = -1;
</I>&gt;<i> &gt; +			try {
</I>&gt;<i> &gt; +				if (Syscall.pipe (out read, out write) &lt; 0) {
</I>&gt;<i> &gt; +					close = false;
</I>&gt;<i> &gt; +					throw UnixMarshal.CreateExceptionForLastError ();
</I>&gt;<i> &gt; +				}
</I>&gt;<i> &gt; +				Pollfd[] fds  = new Pollfd[1];
</I>&gt;<i> &gt; +				fds[0].fd     = read;
</I>&gt;<i> &gt; +				fds[0].events = PollEvents.POLLIN;
</I>&gt;<i> &gt; +				if (IsSet)
</I>&gt;<i> &gt; +					return true;
</I>&gt;<i> &gt; +				Info-&gt;write_fd = write;
</I>&gt;<i> &gt; +				int r = Syscall.poll (fds, 1, millisecondsTimeout);
</I>&gt;<i> 
</I>&gt;<i> Unless Syscall.poll() actually falls back to select() it shouldn't be
</I>&gt;<i> used as for example the POS OS X doesn't implement it.
</I>
Which is odd, as OS X is documented as supporting it:
<A HREF="http://developer.apple.com/documentation/Darwin/Reference/ManPages/man2/poll.2.html">http://developer.apple.com/documentation/Darwin/Reference/ManPages/man2/poll.2.html</A>

&gt;<i> &gt; +				if (r == -1 &amp;&amp; Stdlib.GetLastError () != Errno.EINTR) {
</I>&gt;<i> &gt; +					return false;
</I>&gt;<i> &gt; +				}
</I>&gt;<i> &gt; +				else
</I>&gt;<i> &gt; +					r = Syscall.poll (fds, 1, 0);
</I>&gt;<i> &gt; +				if (r &gt; 0) {
</I>&gt;<i> &gt; +					byte c = 0;
</I>&gt;<i> &gt; +					Syscall.read (read, &amp;c, 1);
</I>&gt;<i> 
</I>&gt;<i> No error checking. This stuff should be implemented in C anyway.
</I>
I'm not sure what error checking this needs, as poll(2) says it's
readable in order to reach it; for that matter, I'm not sure what to do
on error here either -- retry the poll/read combo?

&gt;<i> &gt; --- signal.c	(revision 92060)
</I>&gt;<i> &gt; +++ signal.c	(working copy)
</I>&gt;<i> &gt; +void*
</I>&gt;<i> &gt; +Mono_Unix_UnixSignal_install (int sig)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +	signal_info* n = realloc (registered_signals, 
</I>&gt;<i> &gt; +			sizeof(signal_info)*(registered_signals_count+1));
</I>&gt;<i> &gt; +	if (n) {
</I>&gt;<i> &gt; +		signal_info* r;
</I>&gt;<i> &gt; +		registered_signals = n;
</I>&gt;<i> &gt; +		r = &amp;registered_signals [registered_signals_count++];
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +		r-&gt;signum   = sig;
</I>&gt;<i> &gt; +		r-&gt;count    = 0;
</I>&gt;<i> &gt; +		r-&gt;write_fd = 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +		if ((r-&gt;handler = signal (sig, default_handler)) == SIG_ERR) {
</I>&gt;<i> &gt; +			Mono_Posix_Signal_uninstall (sig);
</I>&gt;<i> &gt; +			return NULL;
</I>&gt;<i> &gt; +		}
</I>&gt;<i> &gt; +		return r;
</I>&gt;<i> &gt; +	}
</I>&gt;<i> &gt; +	return NULL;
</I>&gt;<i> &gt; +}
</I>&gt;<i> 
</I>&gt;<i> The handling of the registered_signals array is not thread safe and not
</I>&gt;<i> signal safe.
</I>
I don't see why this would need to be signal safe -- it should never be
called from a signal handler -- and it is already thread safe, as
managed code performs the locking: the UnixSignal constructor and
UnixSignal.Dispose() both acquire the Stdlib.registered_signals lock
before calling into this code, so only one thread can execute it at a
time anyway.

 - Jon



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026609.html">[Mono-dev] Control-C handler
</A></li>
	<LI>Next message: <A HREF="026719.html">[Mono-dev] Control-C handler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26613">[ date ]</a>
              <a href="thread.html#26613">[ thread ]</a>
              <a href="subject.html#26613">[ subject ]</a>
              <a href="author.html#26613">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
