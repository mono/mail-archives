<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Program Option Parsing Library
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Program%20Option%20Parsing%20Library&In-Reply-To=4787E855.5050505%40toaster.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026614.html">
   <LINK REL="Next"  HREF="026632.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Program Option Parsing Library</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Program%20Option%20Parsing%20Library&In-Reply-To=4787E855.5050505%40toaster.com"
       TITLE="[Mono-dev] Program Option Parsing Library">jonpryor at vt.edu
       </A><BR>
    <I>Fri Jan 11 22:12:48 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="026614.html">[Mono-dev] Program Option Parsing Library
</A></li>
        <LI>Next message: <A HREF="026632.html">[Mono-dev] Program Option Parsing Library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26622">[ date ]</a>
              <a href="thread.html#26622">[ thread ]</a>
              <a href="subject.html#26622">[ subject ]</a>
              <a href="author.html#26622">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2008-01-11 at 14:06 -0800, Jay Logue wrote:
&gt;<i> Jonathan Pryor wrote: 
</I>&gt;<i> &gt; I guess I should create a new delegate type:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 	delegate string OptionLocalizer (string format, string[] args);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Other possible type names appreciated (and I don't like Rafael's
</I>&gt;<i> &gt; TranslateIt name. ;-)
</I>&gt;<i> &gt;   
</I>&gt;<i> I like this approach.  Would it be used for option descriptions as
</I>&gt;<i> well?  
</I>
Yes.  This is done in the next drop (attached).  The conversion delegate
is provided as an optional constructor parameter; if not specified, it
defaults to string.Format().

&gt;<i> &gt; This is also a good idea, and suffers the same problem as providing the
</I>&gt;<i> &gt; actual option used: the callback doesn't have that information, and thus
</I>&gt;<i> &gt; can't provide it in the OptionException.
</I>&gt;<i> &gt;   
</I>&gt;<i> I faced this exact issue in a configuration system I wrote, except
</I>&gt;<i> there the problem was exacerbated by the need to have file and line
</I>&gt;<i> information in the exception (plus it was based on .NET 1.1, so no
</I>&gt;<i> anon delegates to make things prettier). I  solved it by requiring the
</I>&gt;<i> use of a context object.
</I>&gt;<i> 
</I>&gt;<i> How about this.  Create a delegate that takes the necessary context
</I>&gt;<i> information, e.g.:
</I>&gt;<i> 
</I>&gt;<i>     delegate void OptionAction&lt;T&gt;(T v, string optionName);
</I>&gt;<i> 
</I>&gt;<i> and use this as the argument to the workhorse Add&lt;T&gt; method:
</I>&gt;<i> 
</I>&gt;<i>     public Options Add&lt;T&gt; (string options, string description,
</I>&gt;<i> OptionAction&lt;T&gt; action)
</I>&gt;<i> 
</I>&gt;<i> then create an overloaded Add&lt;T&gt; that accepts an Action&lt;T&gt; and calls
</I>&gt;<i> the workhorse method:
</I>&gt;<i> 
</I>&gt;<i>     public Options Add&lt;T&gt;(string options, string description,
</I>&gt;<i> Action&lt;T&gt; action)
</I>&gt;<i>     {
</I>&gt;<i>         return Add(options, description, delegate(T v, string
</I>&gt;<i> optionName) { action(v); });
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> That way the user can make use of the context when they want too, but
</I>&gt;<i> the type conversion code has access to it all the time.
</I>
I opted for a different approach, as the one you described would require
an additional parameter for each additional piece of context
information.  (I can't think of too many now, but no sense not being
more future-resilient if we can be.)

So the universal Action&lt;string&gt; delegate is now an
Action&lt;string,OptionContext&gt; delegate, and the generic delegate is
Action&lt;T,OptionContext&gt;.  OptionContext has properties for OptionName,
OptionIndex, and OptionValue (which is technically redundant as the
value is *also* provided as the first argument, and I don't care).

I opted for a two-argument form of Action`2 as this keeps the simple
case simple; usually you won't need OptionContext, so if everything were
an Action&lt;OptionContext&gt; we'd need:

	string s;
	var p = new Options () {
	  { &quot;s=&quot;, v =&gt; s = v.OptionValue },
	};

and I thought all the (required) `.OptionValue's everywhere would just
be unnecessary visual noise that should be avoided.

&gt;<i> &gt; Foo isn't a stand-in for the real type, it *is* the real type.  Just as
</I>&gt;<i> &gt; `int' is the real type, not System.ComponentModel.Int32Converter (the
</I>&gt;<i> &gt; actual type that does the string-&gt;int conversion).
</I>&gt;<i>
</I>&gt;<i> What about the case where you want an option that accepts standard
</I>&gt;<i> binary abbreviations, e.g. 1K for 1024?  The type of the value is
</I>&gt;<i> clearly an integer, but I need a custom parser to handle the syntax.
</I>
Options isn't the be-all end-all parser; it's intended to be flexible,
so use the flexibility it has: stick to strings. :-)

	int n = 0;
	var p = new Options () {
	  { &quot;n=&quot;, v =&gt; n = SpecialConversionRoutine (v) },
	};

SpecialConversionRoutine(string) can handle the 1K parsing.
TypeConverter support is ~trivial and makes for a nice syntax (you ask
for an int, you get an int); what you're suggesting is extra complexity
for what I consider minimal gain, especially since there's a simple
alternate solution.

&gt;<i> That said, if you solve the problem of user thrown exceptions having
</I>&gt;<i> access to the parsing context, then I can just handle this myself in
</I>&gt;<i> the Action code.
</I>
Indeed:
	var p = new Options () {
	  { &quot;n=&quot;, (v, c) =&gt; { Console.WriteLine (c.OptionName); } },
	};

One final note: due to the above Action change, I'm using Action`2,
which is specific to .NET 3.5.  Localization is via Func`3, which is
specific to .NET 3.5.  So how to maintain .NET 2.0 support?

	#if !LINQ
		public delegate TResult Func&lt;T1,T2,TResult&gt;(T1 a, T2 b);
		public delegate void Action&lt;T1,T2&gt;(T1 a, T2 b);
	#endif

If LINQ is defined, we use the .NET 3.5 types; if it isn't defined, we
assume .NET 2.0 and declare a local version of those types.

What this currently means is that you can't stick this into a
stand-alone assembly and link against it; you should instead compile it
into your assembly and set the #defines appropriately.

Maybe this isn't the best approach, maybe it is; I'm not sure.

If LINQ is defined you also get a (for fun) Options.Parse()
implementation that uses LINQ syntax.  It's 11 lines shorter, and has so
many nested ternary operators I'm not sure it's more readable.  But it's
fun. :-)

 - Jon

-------------- next part --------------
A non-text attachment was scrubbed...
Name: Options.cs
Type: text/x-csharp
Size: 24121 bytes
Desc: not available
Url : <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20080111/82d0d2d7/attachment.bin">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20080111/82d0d2d7/attachment.bin</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026614.html">[Mono-dev] Program Option Parsing Library
</A></li>
	<LI>Next message: <A HREF="026632.html">[Mono-dev] Program Option Parsing Library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26622">[ date ]</a>
              <a href="thread.html#26622">[ thread ]</a>
              <a href="subject.html#26622">[ subject ]</a>
              <a href="author.html#26622">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
