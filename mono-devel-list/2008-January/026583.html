<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Program Option Parsing Library
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Program%20Option%20Parsing%20Library&In-Reply-To=1199906603.8432.216.camel%40lina.magi.jprl.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026570.html">
   <LINK REL="Next"  HREF="026584.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Program Option Parsing Library</H1>
    <B>Jay Logue</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Program%20Option%20Parsing%20Library&In-Reply-To=1199906603.8432.216.camel%40lina.magi.jprl.com"
       TITLE="[Mono-dev] Program Option Parsing Library">jay-MonoDev at toaster.com
       </A><BR>
    <I>Thu Jan 10 13:43:06 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="026570.html">[Mono-dev] Program Option Parsing Library
</A></li>
        <LI>Next message: <A HREF="026584.html">[Mono-dev] Program Option Parsing Library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26583">[ date ]</a>
              <a href="thread.html#26583">[ thread ]</a>
              <a href="subject.html#26583">[ subject ]</a>
              <a href="author.html#26583">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>You asked for thoughts, so here I go...   Overall I like it.  The use of 
lambda delegates is great.  As in perl, it helps keep the code succinct, 
and allows the snippets of option handling code to sit right next to the 
option definition.  A big plus in my book.

Where I think you may have OD'ed on the crack (:-) is in the use of an 
enumerator and ToArray() to parse the arguments.  Its a cleaver 
implementation, and I think you should keep it as an internal 
mechanism.  But from a user perspective it makes the code non-obvious.  
Most people would expect a method called Parse() on an object called 
Options to actually parse the options.  And seeing a call to ToArray() 
where you don't actually use the result (which will be typical for 
commands that don't use extra arguments) is very mysterious.

A better approach, I think, would be have a Parse() method that parses 
the argument list and returns the extra arguments via an out parameter.  
I like using an out parameter because it signals that Parse() is doing 
more than just producing an array.  Taking this approach, I would rename 
your existing Parse() method to something like GetArgumentParser() and 
make it private.  Then I would have the new Parse() method call 
GetArgumentParser() as part of its implementation.

Another thing I think is really important is better error handling for 
typed options.  If the call to TypeConverter.ConvertFromString() fails, 
the exception thrown needs to identify the name of the option that 
failed as well as its value.  I would create a specific exception class 
to convey this (with the original exception inside) so that the case can 
be caught and handled separately in the user's code.

Finally, it looks like this code doesn't handle the case of option 
values separated by whitespace--e.g. &quot;--foo 42&quot;.  I think a lot of 
people will miss this feature.

I hope this was helpful.

-- Jay


Jonathan Pryor wrote:
&gt;<i> I've been doing a lot of work on monodocer, and (for some unknown
</I>&gt;<i> reason) decided that the warning about the deprecation of
</I>&gt;<i> Mono.GetOptions was annoying so I thought I'd come up with a
</I>&gt;<i> replacement.
</I>&gt;<i>
</I>&gt;<i> This replacement is NOT currently intended to be stable, nor to be
</I>&gt;<i> bundled with Mono itself for public use.
</I>&gt;<i>
</I>&gt;<i> It is also extremely crack-addled, which is why I'm liking it so much,
</I>&gt;<i> and why I thought I'd share it with you.
</I>&gt;<i>
</I>&gt;<i> Crack-addled?  How else would you describe this cunning combination of
</I>&gt;<i> collection initializers and lambda delegates?
</I>&gt;<i>
</I>&gt;<i>         bool help = false;
</I>&gt;<i>         int verbose = 0;
</I>&gt;<i>         string source = null;
</I>&gt;<i>         
</I>&gt;<i>         var p = new Options () {
</I>&gt;<i>                 { &quot;h|?|help&quot;,  v =&gt; help = v != null },
</I>&gt;<i>                 { &quot;v|verbose&quot;, v =&gt; { ++verbose; } },
</I>&gt;<i>                 { &quot;source=&quot;,   v =&gt; source = v },
</I>&gt;<i>         };
</I>&gt;<i>         p.Parse (new string[]{&quot;--help&quot;, &quot;-v&quot;, &quot;-v&quot;, &quot;-source=foo&quot;})
</I>&gt;<i>                 .ToArray ();
</I>&gt;<i>         
</I>&gt;<i> After p.Parse().ToArray(), help=true, verbose=2, and source=&quot;foo&quot;.
</I>&gt;<i>
</I>&gt;<i> It is inspired by Perl's Getopt::Long library, except that all option
</I>&gt;<i> processing is done via delegates (i.e. Perl `sub's) and not via by-ref
</I>&gt;<i> variables (as Perl also supports).
</I>&gt;<i>
</I>&gt;<i> No reflection is used unless you use TypeConverter to implicitly convert
</I>&gt;<i> strings to random managed types:
</I>&gt;<i>
</I>&gt;<i>         int n = 0;
</I>&gt;<i>         var p = new Options () {
</I>&gt;<i>                 { &quot;n=&quot;, (int v) =&gt; n = v }
</I>&gt;<i>         };
</I>&gt;<i>
</I>&gt;<i> Options currently supports:
</I>&gt;<i>
</I>&gt;<i>       * Parameters of the form: -flag, --flag, /flag, -flag=value,
</I>&gt;<i>         --flag=value, /flag=value, -flag:value,
</I>&gt;<i>         --flag:value, /flag:value, -flag value, --flag value, /flag
</I>&gt;<i>         value.
</I>&gt;<i>       * &quot;boolean&quot; parameters of the form: -flag, --flag, and /flag.
</I>&gt;<i>         Boolean parameters can have a `+' or `-' appended to explicitly
</I>&gt;<i>         enable or disable the flag (in the same fashion as mcs -debug+).
</I>&gt;<i>         For boolean callbacks, the provided value is non-null for
</I>&gt;<i>         enabled, and null for disabled.
</I>&gt;<i>       * &quot;value&quot; parameters with a required value (append `=' to the
</I>&gt;<i>         option name) or an optional value (append `:' to the option
</I>&gt;<i>         name). The option value can either be in the current option
</I>&gt;<i>         (--opt=value) or in the following parameter (--opt value). The
</I>&gt;<i>         actual value is provided as the parameter to the callback
</I>&gt;<i>         delegate, unless it's (1) optional and (2) missing, in which
</I>&gt;<i>         case null is passed.
</I>&gt;<i>       * &quot;bundled&quot; parameters which must start with a single `-' and
</I>&gt;<i>         consists of only single characters. In this manner, -abc would
</I>&gt;<i>         be a shorthand for -a -b -c.
</I>&gt;<i>       * Option processing is disabled when -- is encountered.
</I>&gt;<i>
</I>&gt;<i> Furthermore, it does not treat '-' options differently from '--' or '/'
</I>&gt;<i> options, aside from the aforementioned bundling support.
</I>&gt;<i>
</I>&gt;<i> Regardless, at ~270 LOC for the associated classes (not including
</I>&gt;<i> comments or tests), I think it's a reasonably concise and useful library
</I>&gt;<i> for command-line option processing.
</I>&gt;<i>
</I>&gt;<i> See also: 
</I>&gt;<i>     <A HREF="http://www.jprl.com/Blog/archive/development/mono/2008/Jan-07.html">http://www.jprl.com/Blog/archive/development/mono/2008/Jan-07.html</A>
</I>&gt;<i>
</I>&gt;<i> Thoughts?
</I>&gt;<i>
</I>&gt;<i> - Jon
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20080110/b527369a/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20080110/b527369a/attachment.html</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026570.html">[Mono-dev] Program Option Parsing Library
</A></li>
	<LI>Next message: <A HREF="026584.html">[Mono-dev] Program Option Parsing Library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26583">[ date ]</a>
              <a href="thread.html#26583">[ thread ]</a>
              <a href="subject.html#26583">[ subject ]</a>
              <a href="author.html#26583">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
