<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Program Option Parsing Library
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Program%20Option%20Parsing%20Library&In-Reply-To=4787B4AF.2010102%40toaster.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026607.html">
   <LINK REL="Next"  HREF="026614.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Program Option Parsing Library</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Program%20Option%20Parsing%20Library&In-Reply-To=4787B4AF.2010102%40toaster.com"
       TITLE="[Mono-dev] Program Option Parsing Library">jonpryor at vt.edu
       </A><BR>
    <I>Fri Jan 11 14:39:03 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="026607.html">[Mono-dev] Program Option Parsing Library
</A></li>
        <LI>Next message: <A HREF="026614.html">[Mono-dev] Program Option Parsing Library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26610">[ date ]</a>
              <a href="thread.html#26610">[ thread ]</a>
              <a href="subject.html#26610">[ subject ]</a>
              <a href="author.html#26610">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2008-01-11 at 10:25 -0800, Jay Logue wrote:
&gt;<i> Jonathan Pryor wrote: 
</I>&gt;<i> &gt; Now how should localization be handled?  Should it?
</I>&gt;<i>
</I>&gt;<i> It only seems fair.  I would do the localization in the
</I>&gt;<i> OptionException class itself.  I see other mono Exception types
</I>&gt;<i> calling Locale.GetText() to translate their text (e.g.
</I>&gt;<i> FileNotFoundException), but I don't see where its declared.  (I see
</I>&gt;<i> one in mcs/class/Managed.Windows.Forms/Assembly/Locale.cs but I don't
</I>&gt;<i> think that's it).
</I>
Yes, but...  Currently the except message text itself is (potentially)
generated across two different places; consider Options.Add&lt;T&gt;:

        catch (Exception e) {
          throw new OptionException (
            string.Format (
              &quot;Could not convert string `{0}' to type {1} for options `{{0}}'.&quot;,
              s, typeof(T).Name), 
            options, e);
        }

Options.Add&lt;T&gt;() has one string.Format() call, while OptionException has
another (to insert the actual option string into the final string).

One thing to do would be to alter OptionException to take a
`OptionException(string format, string[] arguments)' constructor, so
that instead of building up the final string piece-meal, it does
everything.

Alternatively, OptionException could become *dumber* than it is (i.e.
remove all string formatting), and have Options do ALL formatting.  This
has the advantage that an Options constructor overload could take a
Func&lt;string,string[],string&gt; delegate instance which would be
responsible for ALL translation ((f,a) =&gt; string.Format(f,a)).

Thinking about it, this seems the saner solution.

The one downside is that Func`3 is specific to .NET 3.5, while (aside
from syntax and tests) Options _should_ currently be .NET 2.0 compatible
(though I haven't tested this).  Consequently Func`3 should be avoided;
I guess I should create a new delegate type:

	delegate string OptionLocalizer (string format, string[] args);

Other possible type names appreciated (and I don't like Rafael's
TranslateIt name. ;-)

&gt;<i> A couple of other thoughts: 
</I>&gt;<i> 
</I>&gt;<i> -- I think it would be convenient to the user if the error message
</I>&gt;<i> included the option value whenever ConvertFromString() failed.
</I>
Already done, as seen via the catch block above, and in
Test.CheckExceptions:

        AssertException (typeof(OptionException),
          &quot;Could not convert string `value' to type Int32 for options `n='.&quot;,
          p, v =&gt; { v.Parse (_(&quot;-n&quot;, &quot;value&quot;)); });

The one downside is that the actual option used which triggered the
exception is lost.  For example, if you did:

        var p = new Options () {
          { &quot;a|b|c|d=&quot;, (int n) =&gt; { /* ... */ } },
        };
        p.Parse (new string[]{&quot;-b&quot;, &quot;42&quot;, &quot;-a&quot;, &quot;value&quot;});

In this case -b is valid, but -a is not.  However, the error message
wouldn't show that -a was the problem, but would instead say:

  Could not convert string `value' to type Int32 for options `a|b|c|d='.

Which is less than friendly.  Sadly, the only solution I can think of is
to use an Action&lt;string,string&gt; where the 1st argument would be the
actual option string used, which seems like overkill (and would also
prevent .NET 2.0 compatibility).  I'm currently willing to live with the
current output.

&gt;<i>   That way if there are many instances of the same option the user can
</I>&gt;<i> easily figure out which one is causing the problem.  An alternative is
</I>&gt;<i> to include the index of the offending argument as a property of the
</I>&gt;<i> OptionException, leaving it to the caller's exception handler to point
</I>&gt;<i> out the value.
</I>
This is also a good idea, and suffers the same problem as providing the
actual option used: the callback doesn't have that information, and thus
can't provide it in the OptionException.

I can think of only one workaround for both these issues that doesn't
involve changing the Action&lt;string&gt; delegate with something else:
provide additional context information in the Options class itself,
which Options.Add&lt;T&gt;() can make use of.

I don't like this idea as currently, post initialization, Options is
thread-safe (as there is no mutable data -- the Items IList&lt;Option&gt; from
Collection&lt;Option&gt; and the Dictionary&lt;string,Option&gt; mapping are never
modified except on addition/removal, which are both explicitly
programmer controlled).  Consequently you could create one Options
instance and, as long as all threads only call Options.Parse(), it's
completely thread safe.

I'd rather not lose this capability.

&gt;<i> -- I was looking at your FooConverter example and it occurred to me
</I>&gt;<i> that the code might be more concise if Options.Add&lt;T&gt;() had an
</I>&gt;<i> overload that took a TypeConverter.  That way I could simply say:
</I>&gt;<i> 
</I>&gt;<i>          Options p = new Options () {
</I>&gt;<i>             { &quot;v&quot;, v =&gt; ++verbose },
</I>&gt;<i>             { &quot;foo&quot;, new FooConverter(), (int v) =&gt; foo = v },
</I>&gt;<i>             { &quot;h|?|help&quot;, v =&gt; ShowHelp () }
</I>&gt;<i>          };
</I>&gt;<i> 
</I>&gt;<i> ... rather than having to use a wrapper type (Foo) as a stand-in for
</I>&gt;<i> the real type.
</I>
Foo isn't a stand-in for the real type, it *is* the real type.  Just as
`int' is the real type, not System.ComponentModel.Int32Converter (the
actual type that does the string-&gt;int conversion).

So no, I see this as a disadvantage.

 - Jon



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026607.html">[Mono-dev] Program Option Parsing Library
</A></li>
	<LI>Next message: <A HREF="026614.html">[Mono-dev] Program Option Parsing Library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26610">[ date ]</a>
              <a href="thread.html#26610">[ thread ]</a>
              <a href="subject.html#26610">[ subject ]</a>
              <a href="author.html#26610">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
