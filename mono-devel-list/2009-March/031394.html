<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Patch for ZipPackagePart.GetStreamCore in	System.IO.Packaging (olive)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Patch%20for%20ZipPackagePart.GetStreamCore%20in%0A%09System.IO.Packaging%20%28olive%29&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031391.html">
   <LINK REL="Next"  HREF="031417.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Patch for ZipPackagePart.GetStreamCore in	System.IO.Packaging (olive)</H1>
    <B>Yves Dhondt</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Patch%20for%20ZipPackagePart.GetStreamCore%20in%0A%09System.IO.Packaging%20%28olive%29&In-Reply-To="
       TITLE="[Mono-dev] Patch for ZipPackagePart.GetStreamCore in	System.IO.Packaging (olive)">yves.dhondt at gmail.com
       </A><BR>
    <I>Mon Mar 16 15:21:27 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="031391.html">[Mono-dev] Announcing Mono 2.4 Preview RC 1...
</A></li>
        <LI>Next message: <A HREF="031417.html">[Mono-dev] Patch for ZipPackagePart.GetStreamCore in	System.IO.Packaging (olive)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31394">[ date ]</a>
              <a href="thread.html#31394">[ thread ]</a>
              <a href="subject.html#31394">[ subject ]</a>
              <a href="author.html#31394">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Issue:
-------
ZipPackagePart.GetStreamCore in System.IO.Packaging does not handle
Filemode mode input parameter (correctly).

Test program (requires an existing openxml document, for example
test.docx as input):
-------------------
I'm not that good with unit testing, but the following code should be
easily translated into 4 tests.


using System;
using System.IO;
using System.IO.Packaging;

namespace MonoOpenXmlExperiment
{
&#160; class Program
&#160; {
&#160;&#160;&#160; static void Main(string[] args)
&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160; // Warning do this with a document which can be damaged!!!
&#160;&#160;&#160;&#160;&#160; Package pack = Package.Open(args[0]);
&#160;&#160;&#160;&#160;&#160; PackagePart part = pack.CreatePart(new Uri(&quot;/somepart.xml&quot;,
UriKind.Relative), &quot;application/xml&quot;);

&#160;&#160;&#160;&#160;&#160; try
&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160; Stream s2 = part.GetStream(FileMode.CreateNew, FileAccess.Write);
&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160; catch (Exception ex)
&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160; // An ArgumentException should be throw as CreateNew is an
unsupported mode.
&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Expected ArgumentException, got {0}.&quot;,
ex.GetType().ToString());
&#160;&#160;&#160;&#160;&#160; }

&#160;&#160;&#160;&#160;&#160; try
&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160; Stream s3 = part.GetStream(FileMode.Truncate, FileAccess.Write);
&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160; catch (Exception ex)
&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160; // An ArgumentException should be throw as Truncate is an
unsupported mode.
&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Expected ArgumentException, got {0}.&quot;,
ex.GetType().ToString());
&#160;&#160;&#160;&#160;&#160; }

&#160;&#160;&#160;&#160;&#160; try
&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160; Stream s4 = part.GetStream(FileMode.Append, FileAccess.Write);
&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160; catch (Exception ex)
&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160; // An ArgumentException should be throw as Append is an
unsupported mode.
&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Expected ArgumentException, got {0}.&quot;,
ex.GetType().ToString());
&#160;&#160;&#160;&#160;&#160; }

&#160;&#160;&#160;&#160;&#160; Stream s = part.GetStream(FileMode.OpenOrCreate, FileAccess.Write);
&#160;&#160;&#160;&#160;&#160; StreamWriter sw = new StreamWriter(s);
&#160;&#160;&#160;&#160;&#160; sw.Write(&quot;&lt;test&gt;aaaaaaa&lt;/test&gt;&quot;);
&#160;&#160;&#160;&#160;&#160; sw.Flush();

&#160;&#160;&#160;&#160;&#160; Stream s5 = part.GetStream(FileMode.Create, FileAccess.ReadWrite);
&#160;&#160;&#160;&#160;&#160; StreamWriter sw2 = new StreamWriter(s5);
&#160;&#160;&#160;&#160;&#160; sw2.Write(&quot;&lt;test&gt;bbb&lt;/test&gt;&quot;);
&#160;&#160;&#160;&#160;&#160; sw2.Flush();

&#160;&#160;&#160;&#160;&#160; // Verify that the part got overwritten correctly.
&#160;&#160;&#160;&#160;&#160; Stream s6 = part.GetStream();
&#160;&#160;&#160;&#160;&#160; StreamReader sr = new StreamReader(s6);
&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Expected &lt;test&gt;bbb&lt;/test&gt;, got {0}.&quot;, sr.ReadToEnd());

&#160;&#160;&#160;&#160;&#160; pack.Close();
&#160;&#160;&#160; }
&#160; }
}



Expected output:
------------------------
Expected ArgumentException, got System.ArgumentException.
Expected ArgumentException, got System.ArgumentException.
Expected ArgumentException, got System.ArgumentException.
Expected &lt;test&gt;bbb&lt;/test&gt;, got &lt;test&gt;bbb&lt;/test&gt;.

Output currently given by mono:
---------------------------------------------
Expected &lt;test&gt;bbb&lt;/test&gt;, got &lt;test&gt;bbb&lt;/test&gt;.

Remarks:
-------------
The last test is especially important as it indicates that a create
would only overwrite part of stream.

Solution:
------------
Replace function by:

protected override Stream GetStreamCore (FileMode mode, FileAccess access)
&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160; MemoryStream stream;

&#160;&#160;&#160;&#160;&#160; switch (mode)
&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160; case FileMode.CreateNew:
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ArgumentException(&quot;FileMode not supported&quot;, &quot;CreateNew&quot;);
&#160;&#160;&#160;&#160;&#160;&#160;&#160; case FileMode.Truncate:
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ArgumentException(&quot;FileMode not supported&quot;, &quot;Truncate&quot;);
&#160;&#160;&#160;&#160;&#160;&#160;&#160; case FileMode.Append:
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ArgumentException(&quot;FileMode not supported&quot;, &quot;Append&quot;);
&#160;&#160;&#160;&#160;&#160;&#160;&#160; case FileMode.Open:
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (Package.PartStreams.TryGetValue(Uri, out stream)) {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return new ZipPartStream(Package, stream, access);
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; else {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new IOException(); // Verify that this is the
correct exception.
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160;&#160;&#160; case FileMode.OpenOrCreate:
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case FileMode.Create:
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Check if a stream is already loaded. If not, load it or
create an empty one.
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!Package.PartStreams.TryGetValue(Uri, out stream)) {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stream = new MemoryStream();

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; using (UnzipArchive archive = new
UnzipArchive(Package.PackageStream))
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; foreach (string file in archive.GetFiles())
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (file != Uri.ToString().Substring(1))
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; continue;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; using (Stream archiveStream = archive.GetStream(file))
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int read = 0;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; byte[] buffer = new
byte[Math.Min(archiveStream.Length, 2 * 1024)];
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while ((read = archiveStream.Read(buffer, 0,
buffer.Length)) != 0)
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stream.Write(buffer, 0, read);
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; catch
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // The zipfile is invalid, so just create the file
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // as if it didn't exist
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stream.SetLength(0);
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Package.PartStreams.Add(Uri, stream);
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }

&#160;&#160; // This ensures that an existing stream to which a create
&#160;&#160; // is applied will be overwritten.
&#160;&#160; if (mode == FileMode.Create)
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stream.SetLength(0);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return new ZipPartStream(Package, stream, access);
&#160;default:
&#160;&#160; throw new ArgumentOutOfRangeException(&quot;mode&quot;);
&#160;&#160;&#160;&#160;&#160; }
}
</PRE>





























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031391.html">[Mono-dev] Announcing Mono 2.4 Preview RC 1...
</A></li>
	<LI>Next message: <A HREF="031417.html">[Mono-dev] Patch for ZipPackagePart.GetStreamCore in	System.IO.Packaging (olive)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31394">[ date ]</a>
              <a href="thread.html#31394">[ thread ]</a>
              <a href="subject.html#31394">[ subject ]</a>
              <a href="author.html#31394">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
