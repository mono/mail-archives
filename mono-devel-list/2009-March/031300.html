<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] Update AuxV memcpy and icbi optimizations
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Update%20AuxV%20memcpy%20and%20icbi%20optimizations&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031305.html">
   <LINK REL="Next"  HREF="031301.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] Update AuxV memcpy and icbi optimizations</H1>
    <B>Steven Munroe</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Update%20AuxV%20memcpy%20and%20icbi%20optimizations&In-Reply-To="
       TITLE="[Mono-dev] [PATCH] Update AuxV memcpy and icbi optimizations">munroesj at us.ibm.com
       </A><BR>
    <I>Thu Mar  5 22:03:16 EST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="031305.html">[Mono-dev] [PATCH] System.Convert.ChangeType
</A></li>
        <LI>Next message: <A HREF="031301.html">[Mono-dev] DistCC and cross-compiling Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31300">[ date ]</a>
              <a href="thread.html#31300">[ thread ]</a>
              <a href="subject.html#31300">[ subject ]</a>
              <a href="author.html#31300">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch address Paolo's concerns

We need this committed in some form so I can move on to other
optimizations.

Paolo Molaro wrote:

&gt;<i> &gt; &lt;snip&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Headers included without proper checks, besides, pthread is not needed
</I>&gt;<i> &gt; here, elf.h can be simply avoided (there was already a structure to
</I>&gt;<i> &gt; represent the auxv data that you deleted).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>cleaned up the use of header to be the minimum.

&gt;&gt;<i> &gt;&gt; +volatile static ElfW(auxv_t) *linux_auxv_buf = NULL;
</I>&gt;&gt;<i> &gt;&gt;     
</I>&gt;&gt;<i>     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; We don't want to keep this data duplicated in memory: there is no use
</I>&gt;<i> &gt; except using more memory.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>I Now free the buffer at the end of mono_arch_cpu_init.


&gt;&gt;<i> &gt;&gt; +		/* Older kernels did not support /proc/&lt;PID&gt;/auxv. But
</I>&gt;&gt;<i> &gt;&gt; +		   the auvx table does exist in the process address
</I>&gt;&gt;<i> &gt;&gt; +		   space following the env table. So try scanning over
</I>&gt;&gt;<i> &gt;&gt; +		   the environment table to find the auxv. */
</I>&gt;&gt;<i> &gt;&gt; +			if (errno == ENOENT) {
</I>&gt;&gt;<i> &gt;&gt; +				auxv_temp = (ElfW(auxv_t)*) linux_find_auxv();
</I>&gt;&gt;<i> &gt;&gt; +		/* If someone has done a setenv() the __environ pointer
</I>&gt;&gt;<i> &gt;&gt; +		   may have been moved and the assumption that the auxv
</I>&gt;&gt;<i> &gt;&gt; +		   follows is not true. So look at the first entry and
</I>&gt;&gt;<i> &gt;&gt; +		   verify that it is an auxv entry. */
</I>&gt;&gt;<i> &gt;&gt;     
</I>&gt;&gt;<i>     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If this detection is not reliable we should simply not do it. We can
</I>&gt;<i> &gt; document that users should have a 2.6 kernel.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>This the method we support in libauxv.so so I don't why mono should be
different.

&gt;&gt;<i> &gt;&gt; +			} else {
</I>&gt;&gt;<i> &gt;&gt; +				perror(&quot;Error opening file for reading&quot;);
</I>&gt;&gt;<i> &gt;&gt;     
</I>&gt;&gt;<i>     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; We don't want to bother users with an error message that is both
</I>&gt;<i> &gt; non-informative and that they can't do anything about.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>Ok, removed these and the associated headers.


&gt;&gt;<i> &gt;&gt; +static pthread_once_t auxv_once_control = PTHREAD_ONCE_INIT;
</I>&gt;&gt;<i> &gt;&gt;     
</I>&gt;&gt;<i>     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; There is no need to use pthread_once_t: just doing the setup in the init
</I>&gt;<i> &gt; call is ok.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>Ok, removed

&gt;<i> &gt; &lt;snip&gt;
</I>&gt;<i>   
</I>&gt;&gt;<i> &gt;&gt; +/* Number of independent load store pipes in each core. */
</I>&gt;&gt;<i> &gt;&gt; +static int		linux_ppc_LSUs = 0;
</I>&gt;&gt;<i> &gt;&gt; +/* Number of independent fixed point pipes in each core. */
</I>&gt;&gt;<i> &gt;&gt; +static int		linux_ppc_FXUs = 0;
</I>&gt;&gt;<i> &gt;&gt; +/* Number of independent floating point pipes in each core. */
</I>&gt;&gt;<i> &gt;&gt; +static int		linux_ppc_FPUs = 0;
</I>&gt;&gt;<i> &gt;&gt;     
</I>&gt;&gt;<i>     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; A single uint bitmask can replace all of the above for the jit usage.
</I>&gt;<i> &gt; Besides, having one or more load/store units is not a linux property,
</I>&gt;<i> &gt; so the names of the variables is incorrect.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>Actually with current and future processors in the pipeline a bitmask is
not enough.


&gt;&gt;<i> &gt;&gt; +#ifdef PPC_FEATURE_ICACHE_SNOOP
</I>&gt;&gt;<i> &gt;&gt; +#define HAS_ICACHE_SNOOP (linux_ppc_hwcap &amp; PPC_FEATURE_ICACHE_SNOOP)
</I>&gt;&gt;<i> &gt;&gt; +#else
</I>&gt;&gt;<i> &gt;&gt; +#define HAS_ICACHE_SNOOP 0
</I>&gt;&gt;<i> &gt;&gt; +#endif
</I>&gt;&gt;<i> &gt;&gt; +
</I>&gt;&gt;<i> &gt;&gt; +static int
</I>&gt;&gt;<i> &gt;&gt; +linux_init_ppc_SMP(void)
</I>&gt;&gt;<i> &gt;&gt; +{
</I>&gt;&gt;<i> &gt;&gt; +	struct utsname u;
</I>&gt;&gt;<i> &gt;&gt; +	/* FIXME For 2.6.26 kernels we can try to use sysfs
</I>&gt;&gt;<i> &gt;&gt; +	   /sys/devices/system/cpu/possible,  but we would have to fall
</I>&gt;&gt;<i> &gt;&gt; +	   back to uname for early kernels anyway. */
</I>&gt;&gt;<i> &gt;&gt; +
</I>&gt;&gt;<i> &gt;&gt; +	if (uname(&amp;u) != 0) {
</I>&gt;&gt;<i> &gt;&gt; +		perror(&quot;Error uname syscall failer\n&quot;);
</I>&gt;&gt;<i> &gt;&gt; +		return 1;
</I>&gt;&gt;<i> &gt;&gt; +	}
</I>&gt;&gt;<i> &gt;&gt; +
</I>&gt;&gt;<i> &gt;&gt; +	if (strstr(u.version, &quot;SMP&quot;))
</I>&gt;&gt;<i> &gt;&gt; +		return 1;
</I>&gt;&gt;<i> &gt;&gt; +	else {
</I>&gt;&gt;<i> &gt;&gt; +		if (strstr(u.version, &quot;smp&quot;))
</I>&gt;&gt;<i> &gt;&gt; +			return 1;
</I>&gt;&gt;<i> &gt;&gt; +		else
</I>&gt;&gt;<i> &gt;&gt; +			return 0;
</I>&gt;&gt;<i> &gt;&gt;     
</I>&gt;&gt;<i>     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This doesn't look like a reliable way. We have already utility calls to
</I>&gt;<i> &gt; get the number of processors and that should be enough.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>I have not found any evidence of a framework for detecting SMP in the
mono source. Also in the server world, where dynamic CPU add is common,
a SMP capable kernel is the best evidence.


&gt;<i> &gt; &lt;snip&gt;
</I>&gt;<i>   
</I>&gt;&gt;<i> &gt;&gt; +#else
</I>&gt;&gt;<i> &gt;&gt; +	if ((linux_ppc_LSUs &gt; 1) &amp;&amp; (dreg != ppc_r12) &amp;&amp; (sreg != ppc_r12)) { 
</I>&gt;&gt;<i> &gt;&gt; +		while (size &gt;= 8) {
</I>&gt;&gt;<i> &gt;&gt; +			ppc_load_reg (code, ppc_r0, soffset, sreg);
</I>&gt;&gt;<i> &gt;&gt; +			ppc_load_reg (code, ppc_r12, soffset+4, sreg);
</I>&gt;&gt;<i> &gt;&gt; +			ppc_store_reg (code, ppc_r0, doffset, dreg);
</I>&gt;&gt;<i> &gt;&gt; +			ppc_store_reg (code, ppc_r12, doffset+4, dreg);
</I>&gt;&gt;<i> &gt;&gt; +			size -= 8;
</I>&gt;&gt;<i> &gt;&gt; +			soffset += 8;
</I>&gt;&gt;<i> &gt;&gt; +			doffset += 8; 
</I>&gt;&gt;<i> &gt;&gt; +		}
</I>&gt;&gt;<i> &gt;&gt; +	}
</I>&gt;&gt;<i> &gt;&gt;     
</I>&gt;&gt;<i>     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This optimization should be in its own separate patch (together with
</I>&gt;<i> &gt; numbers that show it's worthwhile).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>This was the way processor designers told us to implement memcpy. That
is why we used this used this in both GCC and GLIBC memcpy. The GLIBC
memcpy improvement where on the order of 20% for micro benchmarks.

&gt;&gt;<i> &gt;&gt; @@ -664,21 +890,29 @@
</I>&gt;&gt;<i> &gt;&gt;  		isync
</I>&gt;&gt;<i> &gt;&gt;  	}
</I>&gt;&gt;<i> &gt;&gt;  #else
</I>&gt;&gt;<i> &gt;&gt; -	if (1) {
</I>&gt;&gt;<i> &gt;&gt; -		for (p = start; p &lt; endp; p += cachelineinc) {
</I>&gt;&gt;<i> &gt;&gt; -			asm (&quot;dcbf 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
</I>&gt;&gt;<i> &gt;&gt; +	/* For POWER5/6 with ICACHE_SNOOP the dcbst/icbi is not required.  */
</I>&gt;&gt;<i> &gt;&gt; +	if (!HAS_ICACHE_SNOOP) {
</I>&gt;&gt;<i> &gt;&gt; +		if (linux_ppc_SMP) {
</I>&gt;&gt;<i> &gt;&gt; +			for (p = start; p &lt; endp; p += cachelineinc) {
</I>&gt;&gt;<i> &gt;&gt; +				asm (&quot;dcbf 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
</I>&gt;&gt;<i> &gt;&gt; +			}
</I>&gt;&gt;<i> &gt;&gt; +		} else {
</I>&gt;&gt;<i> &gt;&gt; +			for (p = start; p &lt; endp; p += cachelineinc) {
</I>&gt;&gt;<i> &gt;&gt; +				asm (&quot;dcbst 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
</I>&gt;&gt;<i> &gt;&gt; +			}
</I>&gt;&gt;<i> &gt;&gt;     
</I>&gt;&gt;<i>     
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The changes to icache flush should be a separate patch. As I said already
</I>&gt;<i> &gt; on irc, though, unless there is a bug in the code, changes to it should
</I>&gt;<i> &gt; be done only if there are hard numbers showing that the change is a
</I>&gt;<i> &gt; performance benefit in some real-world case. The code as it is written
</I>&gt;<i> &gt; fixed some random crashes happening a few years ago, so there must be
</I>&gt;<i> &gt; very strong reasons to change it even a single instruction.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i>   
</I>I provided results in a separate email.





-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: ppc-part4-opt-20090303.txt
Url: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20090305/830280ac/attachment-0001.txt">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20090305/830280ac/attachment-0001.txt</A> 
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031305.html">[Mono-dev] [PATCH] System.Convert.ChangeType
</A></li>
	<LI>Next message: <A HREF="031301.html">[Mono-dev] DistCC and cross-compiling Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31300">[ date ]</a>
              <a href="thread.html#31300">[ thread ]</a>
              <a href="subject.html#31300">[ subject ]</a>
              <a href="author.html#31300">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
