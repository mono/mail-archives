<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [PATCH] System.Web.Caching small cleaning
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20System.Web.Caching%20small%20cleaning&In-Reply-To=407C0F0D.8000200%40slamail.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004961.html">
   <LINK REL="Next"  HREF="004963.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [PATCH] System.Web.Caching small cleaning</H1>
    <B>Jackson Harper</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20System.Web.Caching%20small%20cleaning&In-Reply-To=407C0F0D.8000200%40slamail.org"
       TITLE="[Mono-devel-list] [PATCH] System.Web.Caching small cleaning">jackson at ximian.com
       </A><BR>
    <I>Tue Apr 13 12:04:49 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="004961.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
        <LI>Next message: <A HREF="004963.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4962">[ date ]</a>
              <a href="thread.html#4962">[ thread ]</a>
              <a href="subject.html#4962">[ subject ]</a>
              <a href="author.html#4962">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

	Could you expand on your description of the Cache.cs changes?

Thanks,
Jackson


On Tue, 2004-04-13 at 09:02, Yaacov Akiba Slama wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i> Enclosed is a patch which :
</I>&gt;<i> 
</I>&gt;<i> 1) Delete the CacheabilityUpdatedCallback delegate of CachePolicy after 
</I>&gt;<i> the response is sent back to the client in order to let HttpResponse 
</I>&gt;<i> instances be garbage collected even if corresponding CacheEntry 
</I>&gt;<i> instances are still in memory.
</I>&gt;<i> 
</I>&gt;<i> 2) Clean up System.Web.Caching.Cache.cs
</I>&gt;<i> 
</I>&gt;<i> Thanks,
</I>&gt;<i> 
</I>&gt;<i> Yaacov Akiba Slama
</I>&gt;<i> 
</I>&gt;<i> ______________________________________________________________________
</I>&gt;<i> diff -u System.Web/System.Web/HttpResponse.cs System.Web/System.Web/HttpResponse.cs
</I>&gt;<i> --- System.Web/System.Web/HttpResponse.cs
</I>&gt;<i> +++ System.Web/System.Web/HttpResponse.cs
</I>&gt;<i> @@ -55,6 +55,7 @@
</I>&gt;<i>  
</I>&gt;<i>  		HttpCookieCollection _Cookies;
</I>&gt;<i>  		HttpCachePolicy _CachePolicy;
</I>&gt;<i> +		CacheabilityUpdatedCallback _CacheabilityUpdatedCallback;
</I>&gt;<i>  
</I>&gt;<i>  		Encoding _ContentEncoding;
</I>&gt;<i>  			
</I>&gt;<i> @@ -377,8 +378,9 @@
</I>&gt;<i>  			get {
</I>&gt;<i>  				if (null == _CachePolicy) {
</I>&gt;<i>  					_CachePolicy = new HttpCachePolicy ();
</I>&gt;<i> -					_CachePolicy.CacheabilityUpdated += new CacheabilityUpdatedCallback (
</I>&gt;<i> +					_CacheabilityUpdatedCallback = new CacheabilityUpdatedCallback (
</I>&gt;<i>  						OnCacheabilityUpdated);
</I>&gt;<i> +					_CachePolicy.CacheabilityUpdated += _CacheabilityUpdatedCallback;
</I>&gt;<i>  				}
</I>&gt;<i>  
</I>&gt;<i>  				return _CachePolicy;
</I>&gt;<i> @@ -862,8 +875,14 @@
</I>&gt;<i>  				}
</I>&gt;<i>  				_Writer.Clear ();
</I>&gt;<i>  			} finally {
</I>&gt;<i> -				if (bFinish)
</I>&gt;<i> +				if (bFinish) {
</I>&gt;<i>  					closed = true;
</I>&gt;<i> +
</I>&gt;<i> +					// delete the delegate in order to let &quot;this&quot; garbage collected even
</I>&gt;<i> +					// if _CachePolicy is not GC'ed.
</I>&gt;<i> +					if (_CachePolicy != null)
</I>&gt;<i> +						_CachePolicy.CacheabilityUpdated -= _CacheabilityUpdatedCallback;
</I>&gt;<i> +				}
</I>&gt;<i>  				_bFlushing = false;
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i> diff -u System.Web/System.Web.Caching/Cache.cs System.Web/System.Web.Caching/Cache.cs
</I>&gt;<i> --- System.Web/System.Web.Caching/Cache.cs
</I>&gt;<i> +++ System.Web/System.Web.Caching/Cache.cs
</I>&gt;<i> @@ -222,13 +222,20 @@
</I>&gt;<i>  			if (objEntry.HasSlidingExpiration || objEntry.HasAbsoluteExpiration)
</I>&gt;<i>  				_objExpires.Add (objEntry);
</I>&gt;<i>  
</I>&gt;<i> -			// Check and get the new item..
</I>&gt;<i> -			objNewEntry = UpdateCache (strKey, objEntry, true, CacheItemRemovedReason.Removed);
</I>&gt;<i> -
</I>&gt;<i> -			if (objNewEntry == null)
</I>&gt;<i> -				return null;
</I>&gt;<i> +			bool boolAdded = false;
</I>&gt;<i> +			_lockEntries.AcquireWriterLock (-1);
</I>&gt;<i> +			try {
</I>&gt;<i> +				_arrEntries [strKey] = objEntry;
</I>&gt;<i> +				boolAdded = true;
</I>&gt;<i> +			} finally {
</I>&gt;<i> +				_lockEntries.ReleaseLock ();
</I>&gt;<i> +			}
</I>&gt;<i>  
</I>&gt;<i> +			if (boolAdded) {
</I>&gt;<i>  			return objEntry.Item;
</I>&gt;<i> +			} else {
</I>&gt;<i> +				return null;
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  		
</I>&gt;<i>  		/// &lt;summary&gt;
</I>&gt;<i> @@ -401,13 +408,35 @@
</I>&gt;<i>  		/// &lt;/returns&gt;
</I>&gt;<i>  		internal object Remove (string strKey, CacheItemRemovedReason enumReason)
</I>&gt;<i>  		{
</I>&gt;<i> -			CacheEntry objEntry = UpdateCache (strKey, null, true, enumReason);
</I>&gt;<i> +
</I>&gt;<i> +			CacheEntry objEntry;
</I>&gt;<i> +			bool boolRemoved = false;
</I>&gt;<i> +
</I>&gt;<i> +			_lockEntries.AcquireReaderLock (-1);
</I>&gt;<i> +			try {
</I>&gt;<i> +				objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;<i>  			if (objEntry == null)
</I>&gt;<i>  				return null;
</I>&gt;<i>  
</I>&gt;<i> +				Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;<i> +				try {
</I>&gt;<i> +					_arrEntries.Remove (strKey);
</I>&gt;<i> +					boolRemoved = true;
</I>&gt;<i> +				} finally {
</I>&gt;<i> +					_lockEntries.DowngradeFromWriterLock (ref objCookie);
</I>&gt;<i> +				}
</I>&gt;<i> +			} finally {
</I>&gt;<i> +				_lockEntries.ReleaseLock ();
</I>&gt;<i> +			}
</I>&gt;<i> +		
</I>&gt;<i> +			if (!boolRemoved)
</I>&gt;<i> +				return null;
</I>&gt;<i> +				
</I>&gt;<i> +			if (objEntry.HasAbsoluteExpiration || objEntry.HasSlidingExpiration)
</I>&gt;<i> +				_objExpires.Remove (objEntry);
</I>&gt;<i> +
</I>&gt;<i>  			Interlocked.Decrement (ref _nItems);
</I>&gt;<i>  
</I>&gt;<i> -			// Close the cache entry (calls the remove delegate)
</I>&gt;<i>  			objEntry.Close (enumReason);
</I>&gt;<i>  
</I>&gt;<i>  			return objEntry.Item;
</I>&gt;<i> @@ -420,7 +450,8 @@
</I>&gt;<i>  		/// &lt;returns&gt;The retrieved cache item, or a null reference.&lt;/returns&gt;
</I>&gt;<i>  		public object Get (string strKey)
</I>&gt;<i>  		{
</I>&gt;<i> -			CacheEntry objEntry = UpdateCache (strKey, null, false, CacheItemRemovedReason.Expired);
</I>&gt;<i> +
</I>&gt;<i> +			CacheEntry objEntry = GetEntry (strKey);
</I>&gt;<i>  
</I>&gt;<i>  			if (objEntry == null)
</I>&gt;<i>  				return null;
</I>&gt;<i> @@ -430,97 +462,36 @@
</I>&gt;<i>  
</I>&gt;<i>  		internal CacheEntry GetEntry (string strKey)
</I>&gt;<i>  		{
</I>&gt;<i> -			CacheEntry objEntry = UpdateCache (strKey, null, false, CacheItemRemovedReason.Expired);
</I>&gt;<i> -
</I>&gt;<i> -			if (objEntry == null)
</I>&gt;<i> -				return null;
</I>&gt;<i>  
</I>&gt;<i> -			return objEntry;
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		/// &lt;summary&gt;
</I>&gt;<i> -		/// Internal method used for removing, updating and adding CacheEntries into the cache.
</I>&gt;<i> -		/// &lt;/summary&gt;
</I>&gt;<i> -		/// &lt;param name=&quot;strKey&quot;&gt;The identifier for the cache item to modify&lt;/param&gt;
</I>&gt;<i> -		/// &lt;param name=&quot;objEntry&quot;&gt;
</I>&gt;<i> -		/// CacheEntry to use for overwrite operation, if this
</I>&gt;<i> -		/// parameter is null and overwrite true the item is going to be
</I>&gt;<i> -		/// removed
</I>&gt;<i> -		/// &lt;/param&gt;
</I>&gt;<i> -		/// &lt;param name=&quot;boolOverwrite&quot;&gt;
</I>&gt;<i> -		/// If true the objEntry parameter is used to overwrite the
</I>&gt;<i> -		/// strKey entry
</I>&gt;<i> -		/// &lt;/param&gt;
</I>&gt;<i> -		/// &lt;param name=&quot;enumReason&quot;&gt;Reason why an item was removed&lt;/param&gt;
</I>&gt;<i> -		/// &lt;returns&gt;&lt;/returns&gt;
</I>&gt;<i> -		private CacheEntry UpdateCache (string strKey,
</I>&gt;<i> -						CacheEntry objEntry,
</I>&gt;<i> -						bool boolOverwrite,
</I>&gt;<i> -						CacheItemRemovedReason enumReason)
</I>&gt;<i> -		{
</I>&gt;<i>  			if (strKey == null)
</I>&gt;<i>  				throw new ArgumentNullException (&quot;strKey&quot;);
</I>&gt;<i>  
</I>&gt;<i> +			CacheEntry objEntry;
</I>&gt;<i> +			bool boolExpired = false;
</I>&gt;<i> +			bool boolRemoved = false;
</I>&gt;<i>  			long ticksNow = DateTime.Now.Ticks;
</I>&gt;<i>  			long ticksExpires = long.MaxValue;
</I>&gt;<i>  
</I>&gt;<i> -			bool boolGetItem = false;
</I>&gt;<i> -			bool boolExpiried = false;
</I>&gt;<i> -			bool boolWrite = false;
</I>&gt;<i> -			bool boolRemoved = false;
</I>&gt;<i> -
</I>&gt;<i> -			// Are we getting the item from the hashtable
</I>&gt;<i> -			if (boolOverwrite == false &amp;&amp; strKey.Length &gt; 0 &amp;&amp; objEntry == null)
</I>&gt;<i> -				boolGetItem = true;
</I>&gt;<i> -
</I>&gt;<i> -			// TODO: Optimize this method, move out functionality outside the lock
</I>&gt;<i> -			_lockEntries.AcquireReaderLock (-1);
</I>&gt;<i> +			_lockEntries.AcquireReaderLock (-1);
</I>&gt;<i>  			try {
</I>&gt;<i> -				if (boolGetItem) {
</I>&gt;<i>  					objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;<i>  					if (objEntry == null)
</I>&gt;<i>  						return null;
</I>&gt;<i> -				}
</I>&gt;<i>  
</I>&gt;<i> -				if (objEntry != null) {
</I>&gt;<i> -					// Check if we have expired
</I>&gt;<i>  					if (objEntry.HasSlidingExpiration || objEntry.HasAbsoluteExpiration) {
</I>&gt;<i>  						if (objEntry.Expires &lt; ticksNow) {
</I>&gt;<i>  							// We have expired, remove the item from the cache
</I>&gt;<i> -							boolWrite = true;
</I>&gt;<i> -							boolExpiried = true;
</I>&gt;<i> -						} 
</I>&gt;<i> -					} 
</I>&gt;<i> -				}
</I>&gt;<i> -
</I>&gt;<i> -				// Check if we going to modify the hashtable
</I>&gt;<i> -				if (boolWrite || (boolOverwrite &amp;&amp; !boolExpiried)) {
</I>&gt;<i> -					// Upgrade our lock to write
</I>&gt;<i> -					Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;<i> +						boolExpired = true;
</I>&gt;<i> +						Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;<i>  					try {
</I>&gt;<i> -						// Check if we going to just modify an existing entry (or add)
</I>&gt;<i> -						if (boolOverwrite &amp;&amp; objEntry != null) {
</I>&gt;<i> -							_arrEntries [strKey] = objEntry;
</I>&gt;<i> -						} else {
</I>&gt;<i> -							// We need to remove the item, fetch the item first
</I>&gt;<i> -							objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;<i> -							if (objEntry != null)
</I>&gt;<i>  								_arrEntries.Remove (strKey);
</I>&gt;<i> -
</I>&gt;<i>  							boolRemoved = true;
</I>&gt;<i> -						}
</I>&gt;<i>  					} finally {
</I>&gt;<i>  						_lockEntries.DowngradeFromWriterLock (ref objCookie);
</I>&gt;<i>  					}
</I>&gt;<i>  				}
</I>&gt;<i> -
</I>&gt;<i> -				// If the entry haven't expired or been removed update the info
</I>&gt;<i> -				if (!boolExpiried &amp;&amp; !boolRemoved) {
</I>&gt;<i> -					// Update that we got a hit
</I>&gt;<i> -					objEntry.Hits++;
</I>&gt;<i> -					if (objEntry.HasSlidingExpiration)
</I>&gt;<i> -						ticksExpires = ticksNow + objEntry.SlidingExpiration;
</I>&gt;<i>  				}
</I>&gt;<i> +
</I>&gt;<i>  			} finally {
</I>&gt;<i>  				_lockEntries.ReleaseLock ();
</I>&gt;<i>  			}
</I>&gt;<i> @@ -525,26 +496,27 @@
</I>&gt;<i>  				_lockEntries.ReleaseLock ();
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i> -			// If the item was removed we need to remove it from the CacheExpired class also
</I>&gt;<i>  			if (boolRemoved) {
</I>&gt;<i> -				if (objEntry != null) {
</I>&gt;<i>  					if (objEntry.HasAbsoluteExpiration || objEntry.HasSlidingExpiration)
</I>&gt;<i>  						_objExpires.Remove (objEntry);
</I>&gt;<i> -				}
</I>&gt;<i> -				objEntry.Close (enumReason);
</I>&gt;<i> +				Interlocked.Decrement (ref _nItems);
</I>&gt;<i> +				objEntry.Close (CacheItemRemovedReason.Expired);
</I>&gt;<i>  				return null;
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i> -			// If we have sliding expiration and we have a correct hit, update the expiration manager
</I>&gt;<i> +			if (!boolExpired) {
</I>&gt;<i> +				objEntry.Hits++;
</I>&gt;<i>  			if (objEntry.HasSlidingExpiration) {
</I>&gt;<i> +					ticksExpires = ticksNow + objEntry.SlidingExpiration;
</I>&gt;<i>  				_objExpires.Update (objEntry, ticksExpires);
</I>&gt;<i>  				objEntry.Expires = ticksExpires;
</I>&gt;<i>  			}
</I>&gt;<i> -
</I>&gt;<i> -			// Return the cache entry
</I>&gt;<i>  			return objEntry;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +			return null;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		/// &lt;summary&gt;
</I>&gt;<i>  		/// Gets the number of items stored in the cache.
</I>&gt;<i>  		/// &lt;/summary&gt;
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004961.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
	<LI>Next message: <A HREF="004963.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4962">[ date ]</a>
              <a href="thread.html#4962">[ thread ]</a>
              <a href="subject.html#4962">[ subject ]</a>
              <a href="author.html#4962">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
