<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [PATCH] System.Web.Caching small cleaning
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20System.Web.Caching%20small%20cleaning&In-Reply-To=407C13E5.7020806%40slamail.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004963.html">
   <LINK REL="Next"  HREF="004965.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [PATCH] System.Web.Caching small cleaning</H1>
    <B>Jackson Harper</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20System.Web.Caching%20small%20cleaning&In-Reply-To=407C13E5.7020806%40slamail.org"
       TITLE="[Mono-devel-list] [PATCH] System.Web.Caching small cleaning">jackson at ximian.com
       </A><BR>
    <I>Tue Apr 13 12:25:33 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="004963.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
        <LI>Next message: <A HREF="004965.html">[Mono-devel-list] Call to Thread.Abort causes to Application failure!
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4964">[ date ]</a>
              <a href="thread.html#4964">[ thread ]</a>
              <a href="subject.html#4964">[ subject ]</a>
              <a href="author.html#4964">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thank you. I will look these patches over tonight/tomorrow and commit.

Cheers,
Jackson

On Tue, 2004-04-13 at 09:23, Yaacov Akiba Slama wrote:
&gt;<i> Jackson Harper wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt;Hello,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;	Could you expand on your description of the Cache.cs changes?
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> Currently, there is one fucntion called UpdateCache() which is called by 
</I>&gt;<i> Add(), Remove() and Get() and from these functions only.
</I>&gt;<i> 1) The flow inside UpdateCache is different depending on the caller and 
</I>&gt;<i> this function is a lot more complicated than if the same operations are 
</I>&gt;<i> written in each of the Add(), Remove() and Get().
</I>&gt;<i> 2) The locks inside this function is far from optimal.
</I>&gt;<i> 
</I>&gt;<i> My patch delete this function and move the needed functionality in 
</I>&gt;<i> Add(), Remove() and Get(). The code is cleaner and seems to be faster 
</I>&gt;<i> (at least in some basic stress tests).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Thanks,
</I>&gt;<i> Yaacov Akiba
</I>&gt;<i> 
</I>&gt;<i> &gt;Thanks,
</I>&gt;<i> &gt;Jackson
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;On Tue, 2004-04-13 at 09:02, Yaacov Akiba Slama wrote:
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt;Hello,
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;Enclosed is a patch which :
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;1) Delete the CacheabilityUpdatedCallback delegate of CachePolicy after 
</I>&gt;<i> &gt;&gt;the response is sent back to the client in order to let HttpResponse 
</I>&gt;<i> &gt;&gt;instances be garbage collected even if corresponding CacheEntry 
</I>&gt;<i> &gt;&gt;instances are still in memory.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;2) Clean up System.Web.Caching.Cache.cs
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;Thanks,
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;Yaacov Akiba Slama
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;______________________________________________________________________
</I>&gt;<i> &gt;&gt;diff -u System.Web/System.Web/HttpResponse.cs System.Web/System.Web/HttpResponse.cs
</I>&gt;<i> &gt;&gt;--- System.Web/System.Web/HttpResponse.cs
</I>&gt;<i> &gt;&gt;+++ System.Web/System.Web/HttpResponse.cs
</I>&gt;<i> &gt;&gt;@@ -55,6 +55,7 @@
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; 		HttpCookieCollection _Cookies;
</I>&gt;<i> &gt;&gt; 		HttpCachePolicy _CachePolicy;
</I>&gt;<i> &gt;&gt;+		CacheabilityUpdatedCallback _CacheabilityUpdatedCallback;
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; 		Encoding _ContentEncoding;
</I>&gt;<i> &gt;&gt; 			
</I>&gt;<i> &gt;&gt;@@ -377,8 +378,9 @@
</I>&gt;<i> &gt;&gt; 			get {
</I>&gt;<i> &gt;&gt; 				if (null == _CachePolicy) {
</I>&gt;<i> &gt;&gt; 					_CachePolicy = new HttpCachePolicy ();
</I>&gt;<i> &gt;&gt;-					_CachePolicy.CacheabilityUpdated += new CacheabilityUpdatedCallback (
</I>&gt;<i> &gt;&gt;+					_CacheabilityUpdatedCallback = new CacheabilityUpdatedCallback (
</I>&gt;<i> &gt;&gt; 						OnCacheabilityUpdated);
</I>&gt;<i> &gt;&gt;+					_CachePolicy.CacheabilityUpdated += _CacheabilityUpdatedCallback;
</I>&gt;<i> &gt;&gt; 				}
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; 				return _CachePolicy;
</I>&gt;<i> &gt;&gt;@@ -862,8 +875,14 @@
</I>&gt;<i> &gt;&gt; 				}
</I>&gt;<i> &gt;&gt; 				_Writer.Clear ();
</I>&gt;<i> &gt;&gt; 			} finally {
</I>&gt;<i> &gt;&gt;-				if (bFinish)
</I>&gt;<i> &gt;&gt;+				if (bFinish) {
</I>&gt;<i> &gt;&gt; 					closed = true;
</I>&gt;<i> &gt;&gt;+
</I>&gt;<i> &gt;&gt;+					// delete the delegate in order to let &quot;this&quot; garbage collected even
</I>&gt;<i> &gt;&gt;+					// if _CachePolicy is not GC'ed.
</I>&gt;<i> &gt;&gt;+					if (_CachePolicy != null)
</I>&gt;<i> &gt;&gt;+						_CachePolicy.CacheabilityUpdated -= _CacheabilityUpdatedCallback;
</I>&gt;<i> &gt;&gt;+				}
</I>&gt;<i> &gt;&gt; 				_bFlushing = false;
</I>&gt;<i> &gt;&gt; 			}
</I>&gt;<i> &gt;&gt; 		}
</I>&gt;<i> &gt;&gt;diff -u System.Web/System.Web.Caching/Cache.cs System.Web/System.Web.Caching/Cache.cs
</I>&gt;<i> &gt;&gt;--- System.Web/System.Web.Caching/Cache.cs
</I>&gt;<i> &gt;&gt;+++ System.Web/System.Web.Caching/Cache.cs
</I>&gt;<i> &gt;&gt;@@ -222,13 +222,20 @@
</I>&gt;<i> &gt;&gt; 			if (objEntry.HasSlidingExpiration || objEntry.HasAbsoluteExpiration)
</I>&gt;<i> &gt;&gt; 				_objExpires.Add (objEntry);
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;-			// Check and get the new item..
</I>&gt;<i> &gt;&gt;-			objNewEntry = UpdateCache (strKey, objEntry, true, CacheItemRemovedReason.Removed);
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt;-			if (objNewEntry == null)
</I>&gt;<i> &gt;&gt;-				return null;
</I>&gt;<i> &gt;&gt;+			bool boolAdded = false;
</I>&gt;<i> &gt;&gt;+			_lockEntries.AcquireWriterLock (-1);
</I>&gt;<i> &gt;&gt;+			try {
</I>&gt;<i> &gt;&gt;+				_arrEntries [strKey] = objEntry;
</I>&gt;<i> &gt;&gt;+				boolAdded = true;
</I>&gt;<i> &gt;&gt;+			} finally {
</I>&gt;<i> &gt;&gt;+				_lockEntries.ReleaseLock ();
</I>&gt;<i> &gt;&gt;+			}
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;+			if (boolAdded) {
</I>&gt;<i> &gt;&gt; 			return objEntry.Item;
</I>&gt;<i> &gt;&gt;+			} else {
</I>&gt;<i> &gt;&gt;+				return null;
</I>&gt;<i> &gt;&gt;+			}
</I>&gt;<i> &gt;&gt; 		}
</I>&gt;<i> &gt;&gt; 		
</I>&gt;<i> &gt;&gt; 		/// &lt;summary&gt;
</I>&gt;<i> &gt;&gt;@@ -401,13 +408,35 @@
</I>&gt;<i> &gt;&gt; 		/// &lt;/returns&gt;
</I>&gt;<i> &gt;&gt; 		internal object Remove (string strKey, CacheItemRemovedReason enumReason)
</I>&gt;<i> &gt;&gt; 		{
</I>&gt;<i> &gt;&gt;-			CacheEntry objEntry = UpdateCache (strKey, null, true, enumReason);
</I>&gt;<i> &gt;&gt;+
</I>&gt;<i> &gt;&gt;+			CacheEntry objEntry;
</I>&gt;<i> &gt;&gt;+			bool boolRemoved = false;
</I>&gt;<i> &gt;&gt;+
</I>&gt;<i> &gt;&gt;+			_lockEntries.AcquireReaderLock (-1);
</I>&gt;<i> &gt;&gt;+			try {
</I>&gt;<i> &gt;&gt;+				objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;<i> &gt;&gt; 			if (objEntry == null)
</I>&gt;<i> &gt;&gt; 				return null;
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;+				Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;<i> &gt;&gt;+				try {
</I>&gt;<i> &gt;&gt;+					_arrEntries.Remove (strKey);
</I>&gt;<i> &gt;&gt;+					boolRemoved = true;
</I>&gt;<i> &gt;&gt;+				} finally {
</I>&gt;<i> &gt;&gt;+					_lockEntries.DowngradeFromWriterLock (ref objCookie);
</I>&gt;<i> &gt;&gt;+				}
</I>&gt;<i> &gt;&gt;+			} finally {
</I>&gt;<i> &gt;&gt;+				_lockEntries.ReleaseLock ();
</I>&gt;<i> &gt;&gt;+			}
</I>&gt;<i> &gt;&gt;+		
</I>&gt;<i> &gt;&gt;+			if (!boolRemoved)
</I>&gt;<i> &gt;&gt;+				return null;
</I>&gt;<i> &gt;&gt;+				
</I>&gt;<i> &gt;&gt;+			if (objEntry.HasAbsoluteExpiration || objEntry.HasSlidingExpiration)
</I>&gt;<i> &gt;&gt;+				_objExpires.Remove (objEntry);
</I>&gt;<i> &gt;&gt;+
</I>&gt;<i> &gt;&gt; 			Interlocked.Decrement (ref _nItems);
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;-			// Close the cache entry (calls the remove delegate)
</I>&gt;<i> &gt;&gt; 			objEntry.Close (enumReason);
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; 			return objEntry.Item;
</I>&gt;<i> &gt;&gt;@@ -420,7 +450,8 @@
</I>&gt;<i> &gt;&gt; 		/// &lt;returns&gt;The retrieved cache item, or a null reference.&lt;/returns&gt;
</I>&gt;<i> &gt;&gt; 		public object Get (string strKey)
</I>&gt;<i> &gt;&gt; 		{
</I>&gt;<i> &gt;&gt;-			CacheEntry objEntry = UpdateCache (strKey, null, false, CacheItemRemovedReason.Expired);
</I>&gt;<i> &gt;&gt;+
</I>&gt;<i> &gt;&gt;+			CacheEntry objEntry = GetEntry (strKey);
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; 			if (objEntry == null)
</I>&gt;<i> &gt;&gt; 				return null;
</I>&gt;<i> &gt;&gt;@@ -430,97 +462,36 @@
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; 		internal CacheEntry GetEntry (string strKey)
</I>&gt;<i> &gt;&gt; 		{
</I>&gt;<i> &gt;&gt;-			CacheEntry objEntry = UpdateCache (strKey, null, false, CacheItemRemovedReason.Expired);
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt;-			if (objEntry == null)
</I>&gt;<i> &gt;&gt;-				return null;
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;-			return objEntry;
</I>&gt;<i> &gt;&gt;-		}
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt;-		/// &lt;summary&gt;
</I>&gt;<i> &gt;&gt;-		/// Internal method used for removing, updating and adding CacheEntries into the cache.
</I>&gt;<i> &gt;&gt;-		/// &lt;/summary&gt;
</I>&gt;<i> &gt;&gt;-		/// &lt;param name=&quot;strKey&quot;&gt;The identifier for the cache item to modify&lt;/param&gt;
</I>&gt;<i> &gt;&gt;-		/// &lt;param name=&quot;objEntry&quot;&gt;
</I>&gt;<i> &gt;&gt;-		/// CacheEntry to use for overwrite operation, if this
</I>&gt;<i> &gt;&gt;-		/// parameter is null and overwrite true the item is going to be
</I>&gt;<i> &gt;&gt;-		/// removed
</I>&gt;<i> &gt;&gt;-		/// &lt;/param&gt;
</I>&gt;<i> &gt;&gt;-		/// &lt;param name=&quot;boolOverwrite&quot;&gt;
</I>&gt;<i> &gt;&gt;-		/// If true the objEntry parameter is used to overwrite the
</I>&gt;<i> &gt;&gt;-		/// strKey entry
</I>&gt;<i> &gt;&gt;-		/// &lt;/param&gt;
</I>&gt;<i> &gt;&gt;-		/// &lt;param name=&quot;enumReason&quot;&gt;Reason why an item was removed&lt;/param&gt;
</I>&gt;<i> &gt;&gt;-		/// &lt;returns&gt;&lt;/returns&gt;
</I>&gt;<i> &gt;&gt;-		private CacheEntry UpdateCache (string strKey,
</I>&gt;<i> &gt;&gt;-						CacheEntry objEntry,
</I>&gt;<i> &gt;&gt;-						bool boolOverwrite,
</I>&gt;<i> &gt;&gt;-						CacheItemRemovedReason enumReason)
</I>&gt;<i> &gt;&gt;-		{
</I>&gt;<i> &gt;&gt; 			if (strKey == null)
</I>&gt;<i> &gt;&gt; 				throw new ArgumentNullException (&quot;strKey&quot;);
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;+			CacheEntry objEntry;
</I>&gt;<i> &gt;&gt;+			bool boolExpired = false;
</I>&gt;<i> &gt;&gt;+			bool boolRemoved = false;
</I>&gt;<i> &gt;&gt; 			long ticksNow = DateTime.Now.Ticks;
</I>&gt;<i> &gt;&gt; 			long ticksExpires = long.MaxValue;
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;-			bool boolGetItem = false;
</I>&gt;<i> &gt;&gt;-			bool boolExpiried = false;
</I>&gt;<i> &gt;&gt;-			bool boolWrite = false;
</I>&gt;<i> &gt;&gt;-			bool boolRemoved = false;
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt;-			// Are we getting the item from the hashtable
</I>&gt;<i> &gt;&gt;-			if (boolOverwrite == false &amp;&amp; strKey.Length &gt; 0 &amp;&amp; objEntry == null)
</I>&gt;<i> &gt;&gt;-				boolGetItem = true;
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt;-			// TODO: Optimize this method, move out functionality outside the lock
</I>&gt;<i> &gt;&gt;-			_lockEntries.AcquireReaderLock (-1);
</I>&gt;<i> &gt;&gt;+			_lockEntries.AcquireReaderLock (-1);
</I>&gt;<i> &gt;&gt; 			try {
</I>&gt;<i> &gt;&gt;-				if (boolGetItem) {
</I>&gt;<i> &gt;&gt; 					objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;<i> &gt;&gt; 					if (objEntry == null)
</I>&gt;<i> &gt;&gt; 						return null;
</I>&gt;<i> &gt;&gt;-				}
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;-				if (objEntry != null) {
</I>&gt;<i> &gt;&gt;-					// Check if we have expired
</I>&gt;<i> &gt;&gt; 					if (objEntry.HasSlidingExpiration || objEntry.HasAbsoluteExpiration) {
</I>&gt;<i> &gt;&gt; 						if (objEntry.Expires &lt; ticksNow) {
</I>&gt;<i> &gt;&gt; 							// We have expired, remove the item from the cache
</I>&gt;<i> &gt;&gt;-							boolWrite = true;
</I>&gt;<i> &gt;&gt;-							boolExpiried = true;
</I>&gt;<i> &gt;&gt;-						} 
</I>&gt;<i> &gt;&gt;-					} 
</I>&gt;<i> &gt;&gt;-				}
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt;-				// Check if we going to modify the hashtable
</I>&gt;<i> &gt;&gt;-				if (boolWrite || (boolOverwrite &amp;&amp; !boolExpiried)) {
</I>&gt;<i> &gt;&gt;-					// Upgrade our lock to write
</I>&gt;<i> &gt;&gt;-					Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;<i> &gt;&gt;+						boolExpired = true;
</I>&gt;<i> &gt;&gt;+						Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;<i> &gt;&gt; 					try {
</I>&gt;<i> &gt;&gt;-						// Check if we going to just modify an existing entry (or add)
</I>&gt;<i> &gt;&gt;-						if (boolOverwrite &amp;&amp; objEntry != null) {
</I>&gt;<i> &gt;&gt;-							_arrEntries [strKey] = objEntry;
</I>&gt;<i> &gt;&gt;-						} else {
</I>&gt;<i> &gt;&gt;-							// We need to remove the item, fetch the item first
</I>&gt;<i> &gt;&gt;-							objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;<i> &gt;&gt;-							if (objEntry != null)
</I>&gt;<i> &gt;&gt; 								_arrEntries.Remove (strKey);
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt; 							boolRemoved = true;
</I>&gt;<i> &gt;&gt;-						}
</I>&gt;<i> &gt;&gt; 					} finally {
</I>&gt;<i> &gt;&gt; 						_lockEntries.DowngradeFromWriterLock (ref objCookie);
</I>&gt;<i> &gt;&gt; 					}
</I>&gt;<i> &gt;&gt; 				}
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt;-				// If the entry haven't expired or been removed update the info
</I>&gt;<i> &gt;&gt;-				if (!boolExpiried &amp;&amp; !boolRemoved) {
</I>&gt;<i> &gt;&gt;-					// Update that we got a hit
</I>&gt;<i> &gt;&gt;-					objEntry.Hits++;
</I>&gt;<i> &gt;&gt;-					if (objEntry.HasSlidingExpiration)
</I>&gt;<i> &gt;&gt;-						ticksExpires = ticksNow + objEntry.SlidingExpiration;
</I>&gt;<i> &gt;&gt; 				}
</I>&gt;<i> &gt;&gt;+
</I>&gt;<i> &gt;&gt; 			} finally {
</I>&gt;<i> &gt;&gt; 				_lockEntries.ReleaseLock ();
</I>&gt;<i> &gt;&gt; 			}
</I>&gt;<i> &gt;&gt;@@ -525,26 +496,27 @@
</I>&gt;<i> &gt;&gt; 				_lockEntries.ReleaseLock ();
</I>&gt;<i> &gt;&gt; 			}
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;-			// If the item was removed we need to remove it from the CacheExpired class also
</I>&gt;<i> &gt;&gt; 			if (boolRemoved) {
</I>&gt;<i> &gt;&gt;-				if (objEntry != null) {
</I>&gt;<i> &gt;&gt; 					if (objEntry.HasAbsoluteExpiration || objEntry.HasSlidingExpiration)
</I>&gt;<i> &gt;&gt; 						_objExpires.Remove (objEntry);
</I>&gt;<i> &gt;&gt;-				}
</I>&gt;<i> &gt;&gt;-				objEntry.Close (enumReason);
</I>&gt;<i> &gt;&gt;+				Interlocked.Decrement (ref _nItems);
</I>&gt;<i> &gt;&gt;+				objEntry.Close (CacheItemRemovedReason.Expired);
</I>&gt;<i> &gt;&gt; 				return null;
</I>&gt;<i> &gt;&gt; 			}
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;-			// If we have sliding expiration and we have a correct hit, update the expiration manager
</I>&gt;<i> &gt;&gt;+			if (!boolExpired) {
</I>&gt;<i> &gt;&gt;+				objEntry.Hits++;
</I>&gt;<i> &gt;&gt; 			if (objEntry.HasSlidingExpiration) {
</I>&gt;<i> &gt;&gt;+					ticksExpires = ticksNow + objEntry.SlidingExpiration;
</I>&gt;<i> &gt;&gt; 				_objExpires.Update (objEntry, ticksExpires);
</I>&gt;<i> &gt;&gt; 				objEntry.Expires = ticksExpires;
</I>&gt;<i> &gt;&gt; 			}
</I>&gt;<i> &gt;&gt;-
</I>&gt;<i> &gt;&gt;-			// Return the cache entry
</I>&gt;<i> &gt;&gt; 			return objEntry;
</I>&gt;<i> &gt;&gt; 		}
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;+			return null;
</I>&gt;<i> &gt;&gt;+		}
</I>&gt;<i> &gt;&gt;+
</I>&gt;<i> &gt;&gt; 		/// &lt;summary&gt;
</I>&gt;<i> &gt;&gt; 		/// Gets the number of items stored in the cache.
</I>&gt;<i> &gt;&gt; 		/// &lt;/summary&gt;
</I>&gt;<i> &gt;&gt;    
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;
</I>&gt;<i> 
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004963.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
	<LI>Next message: <A HREF="004965.html">[Mono-devel-list] Call to Thread.Abort causes to Application failure!
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4964">[ date ]</a>
              <a href="thread.html#4964">[ thread ]</a>
              <a href="subject.html#4964">[ subject ]</a>
              <a href="author.html#4964">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
