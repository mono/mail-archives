<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Proposal: Library Loading
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Proposal%3A%20Library%20Loading&In-Reply-To=1081903925.27887.25.camel%40localhost.localdomain">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004997.html">
   <LINK REL="Next"  HREF="004986.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Proposal: Library Loading</H1>
    <B>Eran Sandler</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Proposal%3A%20Library%20Loading&In-Reply-To=1081903925.27887.25.camel%40localhost.localdomain"
       TITLE="[Mono-devel-list] Proposal: Library Loading">esandler at netvision.net.il
       </A><BR>
    <I>Wed Apr 14 04:04:21 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="004997.html">[Mono-devel-list] Proposal: Library Loading
</A></li>
        <LI>Next message: <A HREF="004986.html">[Mono-devel-list] [Patch] Fix for Bugzilla #56456
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4984">[ date ]</a>
              <a href="thread.html#4984">[ thread ]</a>
              <a href="subject.html#4984">[ subject ]</a>
              <a href="author.html#4984">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'll outline what is and what was the assembly loading logic in .NET and
its early betas and lets see if we can borrow some of the ideas from
there.

In the early betas of .NET v1.0 when one wanted to dynamically load an
assembly and one did not specify its version it first searched in the
GAC (Global Assembly Cache) for the latest version of that assembly. 
If it did not find it, it will search in the app's directory and from
there go on to a predefined search path that you can define per an
application.

If you had a specific reference with a specific version, culture and
public key token, it will search for it in the GAC. If it will not find
it, it will search in the app's directory and so on.


In the release of .NET v1.0, Microsoft decided to make the assembly load
logic strickter. One cannot dynamically load things from the GAC unless
one specifies a specific version, culture and public key token.

If a new version of a certain assembly came out, a policy file (which is
actually a DLL which has a XML file embedded as a resource that
specifies the redirection from one version or a range of version to
another version) would control the redirection and even though an
application requested version 1.0, since there is a policy file, it will
actually get version 1.1, for example.


Since the GAC is the only place that Windows can handle versioning of
dynamically loaded files, perhaps we need a mechanism similar to the GAC
for DllImport.

This means that DllImport will have to include not just &quot;foo&quot;, but
&quot;foo-2&quot; for example (or some other syntax, as long as it won't break the
DllImport signature). 

In this case we will specifically take libfoo.so.2 and only libfoo.so.2.

If a redirection is needed we can have some kind of an XML file that
will be located in a predefined place for a certain lib.

This is for the stricter people...




The other option is to assume the idea that was in the early .NET 1.0
betas. In this case, if someone specified only &quot;foo&quot;, we can search for
the latest version available and use it. If someone specified a specific
version, like in the example I gave earlier, it will search for it, and
only it. If a redirection is needed we will have to find, as I said
above, a similar mechanism to GAC that will perform redirections.


There is also an option that instead of using policy files you can
declare a redirect in the application's config file (app.config) or in
the machine.config file. 

Therefore, for package installations, either the installer will update
the machine.config (if this is a shared library that simply have a fix
and a lot of apps use it) or a specific application app.config.
If we go for policy file like solution, the package installation can
simply put certain files in a certain place that will perform the
redirection.


What do you think?


Eran


On Wed, 2004-04-14 at 03:52, Jonathan Pryor wrote:
&gt;<i> This came up on #mono today in the context of Fedora and package
</I>&gt;<i> management, so I figured I'd document the current idea for discussion
</I>&gt;<i> and possible future implementation [1].
</I>&gt;<i> 
</I>&gt;<i> The Problem:
</I>&gt;<i> 
</I>&gt;<i> DllImport doesn't allow developers to specify which library version to
</I>&gt;<i> load at runtime.  Thus, with code such as:
</I>&gt;<i> 
</I>&gt;<i> 	[DllImport (&quot;foo&quot;)]
</I>&gt;<i> 	private static extern void foo ();
</I>&gt;<i> 
</I>&gt;<i> Mono will attempt to load &quot;libfoo.so&quot; at runtime.
</I>&gt;<i> 
</I>&gt;<i> There are three problems with this:
</I>&gt;<i> 
</I>&gt;<i> 1.  What happens if there are multiple major versions of libfoo.so
</I>&gt;<i>     installed: libfoo.so.1 and libfoo.so.2?  Which gets loaded?  At
</I>&gt;<i>     present, whichever libfoo-devel package was installed, which may be
</I>&gt;<i>     ABI-incompatible with what the assembly was written against.  Oops.
</I>&gt;<i> 
</I>&gt;<i> 2.  Ignoring (1), the user needs to have N MB of -devel packages
</I>&gt;<i>     installed in order for Mono to find the .so file (as the .so file is
</I>&gt;<i>     usually only present in the -devel packages).  N can be very large;
</I>&gt;<i>     previously, I've heard of N &gt; 50 MB.  Users will find this to be
</I>&gt;<i>     unacceptable.
</I>&gt;<i> 
</I>&gt;<i> 3.  To avoid (2), the user can edit $prefix/mono/config, an XML file
</I>&gt;<i>     which &quot;maps&quot; the DllImport library to the actual library to load. 
</I>&gt;<i>     While this works, it is inelegant (the user has to edit XML, which
</I>&gt;<i>     may scare some users), and is not extensible (what should happen
</I>&gt;<i>     when a new library/assembly/RPM is installed?).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The Proposed Solution:
</I>&gt;<i> 
</I>&gt;<i> Scrap $prefix/mono/config, and replace it with a $prefix/mono/config.d
</I>&gt;<i> directory.  This directory would contain one file per DllImport &quot;base&quot;
</I>&gt;<i> name, where a base name is the library name without the &quot;lib&quot; prefix and
</I>&gt;<i> any suffix (&quot;.so&quot;, &quot;.dll&quot;, .etc).
</I>&gt;<i> 
</I>&gt;<i> The syntax of the XML file could be:
</I>&gt;<i> 
</I>&gt;<i> 	&lt;library&gt;
</I>&gt;<i> 		&lt;dll import=&quot;DllImport Attribute Value&quot; 
</I>&gt;<i> 			target=&quot;actual library to load&quot;
</I>&gt;<i> 			version=&quot;version .NET assembly targets&quot;/&gt;
</I>&gt;<i> 	&lt;/library&gt;
</I>&gt;<i> 
</I>&gt;<i> For example, the C library would have an entry in
</I>&gt;<i> $prefix/mono/config.d/c.xml, which the contents:
</I>&gt;<i> 
</I>&gt;<i> 	&lt;library&gt;
</I>&gt;<i> 		&lt;dll import=&quot;libc&quot; 
</I>&gt;<i> 			target=&quot;libc.so&quot;
</I>&gt;<i> 			version=&quot;6&quot; /&gt;
</I>&gt;<i> 	&lt;/library&gt;
</I>&gt;<i> 
</I>&gt;<i> The version attribute is present to solve problem (1), and would contain
</I>&gt;<i> the major and optional minor version number of the library to load. 
</I>&gt;<i> Mono's library loading logic would thus need to search for the
</I>&gt;<i> ${target}.${version} library in the standard locations (LD_LIBRARY_PATH,
</I>&gt;<i> /etc/ld.so.conf, /usr/lib, /lib), with intelligent fallback handling
</I>&gt;<i> (e.g. if @version is 1.2, and ${target}.1.2 isn't present, but
</I>&gt;<i> ${target}.1 is, then ${target}.1 should be loaded).
</I>&gt;<i> 
</I>&gt;<i> Benefits:
</I>&gt;<i> 
</I>&gt;<i> The &quot;one file per base library name&quot; ensures that only one package (RPM,
</I>&gt;<i> etc.) will attempt to &quot;own&quot; a particular library, so we don't have
</I>&gt;<i> multiple packages attempting to &quot;own&quot; the GTK+ libraries.
</I>&gt;<i> 
</I>&gt;<i> The version number attribute benefits were mentioned above.
</I>&gt;<i> 
</I>&gt;<i> Future packages can install files into $prefix/mono/config.d as part of
</I>&gt;<i> their install, ensuring that any native libraries they require will be
</I>&gt;<i> found by Mono, simplifying package maintenance.
</I>&gt;<i> 
</I>&gt;<i> The one potentially troubling part is the duplication between the file
</I>&gt;<i> name and the /library/dll/@import attribute value.
</I>&gt;<i> 
</I>&gt;<i> Thoughts?
</I>&gt;<i> 
</I>&gt;<i>  - Jon
</I>&gt;<i> 
</I>&gt;<i> [1] Alas, I'm not implementing this.  I plead lack of time. :-(
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004997.html">[Mono-devel-list] Proposal: Library Loading
</A></li>
	<LI>Next message: <A HREF="004986.html">[Mono-devel-list] [Patch] Fix for Bugzilla #56456
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4984">[ date ]</a>
              <a href="thread.html#4984">[ thread ]</a>
              <a href="subject.html#4984">[ subject ]</a>
              <a href="author.html#4984">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
