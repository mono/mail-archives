<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [PATCH] DecimalFormatters
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20DecimalFormatters&In-Reply-To=20040416092413.GE8764%40ox.compsoc.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005023.html">
   <LINK REL="Next"  HREF="005026.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [PATCH] DecimalFormatters</H1>
    <B>David Sheldon</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20DecimalFormatters&In-Reply-To=20040416092413.GE8764%40ox.compsoc.net"
       TITLE="[Mono-devel-list] [PATCH] DecimalFormatters">dave-monolist at earth.li
       </A><BR>
    <I>Fri Apr 16 05:47:24 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="005023.html">[Mono-devel-list] [PATCH] DecimalFormatters
</A></li>
        <LI>Next message: <A HREF="005026.html">[Mono-devel-list] [PATCH] DecimalFormatters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5025">[ date ]</a>
              <a href="thread.html#5025">[ thread ]</a>
              <a href="subject.html#5025">[ subject ]</a>
              <a href="author.html#5025">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Apr 16, 2004 at 10:24:13AM +0100, David Sheldon wrote:
&gt;<i> Attached are two patches to corlib/System/DecimalFormatter.
</I>
Well, they were not, but now they are.

David

-- 
  Cordelia: So does looking at guns make you wanna have sex?
    Xander: I'm 17. Looking at *linoleum* makes me wanna have sex.
                    -- &quot;Buffy The Vampire Slayer&quot;
-------------- next part --------------
Index: ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System/ChangeLog,v
retrieving revision 1.753
diff -u -r1.753 ChangeLog
--- ChangeLog	13 Apr 2004 20:19:08 -0000	1.753
+++ ChangeLog	16 Apr 2004 08:21:55 -0000
@@ -1,3 +1,9 @@
+2004-04-16  David Sheldon &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">dave-mono at earth.li</A>&gt;
+
+  * DecimalFormatter.cs: Don't append a decimal point after the
+    end of a number. ((decimal)1).ToString(&quot;P0&quot;) should be &quot;100 %&quot;, not
+    &quot;100. %&quot;
+
 2004-04-09  Miguel de Icaza  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">miguel at ximian.com</A>&gt;
 
 	* OutOfMemoryException.cs: Removed the call to Locale.GetText from
Index: DecimalFormatter.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System/DecimalFormatter.cs,v
retrieving revision 1.9
diff -u -r1.9 DecimalFormatter.cs
--- DecimalFormatter.cs	13 Dec 2002 10:05:51 -0000	1.9
+++ DecimalFormatter.cs	16 Apr 2004 08:21:56 -0000
@@ -232,7 +232,7 @@
                 }
             }
 
-            if (decimals &gt; 0)
+            if ((decimals &gt; 0) &amp;&amp; (decPos+offset &lt; sb.Length))
             {
                 sb.Insert(offset + ((decPos &lt;= 0) ? 1 : decPos), decSeparator);
             }
-------------- next part --------------
Index: ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System/ChangeLog,v
retrieving revision 1.753
diff -u -r1.753 ChangeLog
--- ChangeLog	13 Apr 2004 20:19:08 -0000	1.753
+++ ChangeLog	16 Apr 2004 08:35:56 -0000
@@ -1,3 +1,15 @@
+2004-04-16  David Sheldon &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">dave-mono at earth.li</A>&gt;
+
+  * DecimalFormatter.cs: .NET appears to not represent small numbers
+    in scientific form any more. #if used to match the test case, 
+    and represent 0.00000012 rather than 1.2E-7
+
+2004-04-16  David Sheldon &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">dave-mono at earth.li</A>&gt;
+
+  * DecimalFormatter.cs: Don't append a decimal point after the
+    end of a number. ((decimal)1).ToString(&quot;P0&quot;) should be &quot;100 %&quot;, not
+    &quot;100. %&quot;
+
 2004-04-09  Miguel de Icaza  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">miguel at ximian.com</A>&gt;
 
 	* OutOfMemoryException.cs: Removed the call to Locale.GetText from
Index: DecimalFormatter.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System/DecimalFormatter.cs,v
retrieving revision 1.9
diff -u -r1.9 DecimalFormatter.cs
--- DecimalFormatter.cs	13 Dec 2002 10:05:51 -0000	1.9
+++ DecimalFormatter.cs	16 Apr 2004 08:35:57 -0000
@@ -2,7 +2,7 @@
 // System.DecimalFormatter.cs
 //
 // Author:
-//   Martin Weindel (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">martin.weindel at t-online.de</A>)
+//	 Martin Weindel (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">martin.weindel at t-online.de</A>)
 //
 // (C) Martin Weindel, Derek Holden  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">dholden at draper.com</A>
 //
@@ -17,366 +17,370 @@
 namespace System 
 {
 
-    internal sealed class DecimalFormatter 
-    {
+	internal sealed class DecimalFormatter 
+	{
 
-        private static bool ParseFormat (string format, out char specifier,  out int precision)
-        {		 		 
-            precision = -1;
-            specifier = '\0';
-		    
-            int length = format.Length;
-            if (length &lt; 1 || length &gt; 3)
-                return false;
-		    
-            char[] chars = format.ToCharArray ();
-            specifier = Char.ToUpper(chars[0]);
-
-            if (length == 1) 
-                return true;
-		    
-            if (length == 2) 
-            {
-                if (chars[1] &lt; '0' || chars[1] &gt; '9')
-                    return false;
-			    
-                precision = chars[1] - '0';
-            } 
-            else 
-            {
-                if (chars[1] &lt; '0' || chars[2] &lt; '0' || chars[1] &gt; '9' || chars[2] &gt; '9')
-                    return false;
-			    
-                precision = (chars[1] - '0') * 10 + (chars[2] - '0');
-            }
-		    
-            return true;
-        }	 
-
-        public static string NumberToString(string format, NumberFormatInfo nfi, Decimal value)
-        {
-            char specifier;
-            int precision;
-	    format = format.Trim ();
-            if (!DecimalFormatter.ParseFormat(format, out specifier, out precision)) 
-            {
-                throw new FormatException (Locale.GetText (&quot;The specified format is invalid&quot;));
-            }
+		private static bool ParseFormat (string format, out char specifier,  out int precision)
+		{				 
+			precision = -1;
+			specifier = '\0';
+			
+			int length = format.Length;
+			if (length &lt; 1 || length &gt; 3)
+				return false;
+			
+			char[] chars = format.ToCharArray ();
+			specifier = Char.ToUpper(chars[0]);
+
+			if (length == 1) 
+				return true;
+			
+			if (length == 2) 
+			{
+				if (chars[1] &lt; '0' || chars[1] &gt; '9')
+					return false;
+				
+				precision = chars[1] - '0';
+			} 
+			else 
+			{
+				if (chars[1] &lt; '0' || chars[2] &lt; '0' || chars[1] &gt; '9' || chars[2] &gt; '9')
+					return false;
+				
+				precision = (chars[1] - '0') * 10 + (chars[2] - '0');
+			}
+			
+			return true;
+		}	 
+
+		public static string NumberToString(string format, NumberFormatInfo nfi, Decimal value)
+		{
+			char specifier;
+			int precision;
+		format = format.Trim ();
+			if (!DecimalFormatter.ParseFormat(format, out specifier, out precision)) 
+			{
+				throw new FormatException (Locale.GetText (&quot;The specified format is invalid&quot;));
+			}
 
-            int digits = -1;
-            int decimals = 0;
-            // first calculate number of digits or decimals needed for format
-            switch (specifier)
-            {
-                case 'C':
-                    decimals = (precision &gt;= 0) ? precision : nfi.CurrencyDecimalDigits;
-                    break;
-                case 'F': goto case 'N'; 
-                case 'N':
-                    decimals = (precision &gt;= 0) ? precision : nfi.NumberDecimalDigits;
-                    break;
-                case 'G':
-                    digits = (precision &gt;= 0) ? precision : 0;
-                    break;
-                case 'E': 
-                    digits = (precision &gt;= 0) ? precision+1 : 7;
-                    break;
-                case 'P': 
-                    decimals = (precision &gt;= 0) ? precision+2 : nfi.PercentDecimalDigits+2;
-                    break;
-                case 'Z':
-                    digits = 0;
-                    break;
-            }
+			int digits = -1;
+			int decimals = 0;
+			// first calculate number of digits or decimals needed for format
+			switch (specifier)
+			{
+				case 'C':
+					decimals = (precision &gt;= 0) ? precision : nfi.CurrencyDecimalDigits;
+					break;
+				case 'F': goto case 'N'; 
+				case 'N':
+					decimals = (precision &gt;= 0) ? precision : nfi.NumberDecimalDigits;
+					break;
+				case 'G':
+					digits = (precision &gt;= 0) ? precision : 0;
+					break;
+				case 'E': 
+					digits = (precision &gt;= 0) ? precision+1 : 7;
+					break;
+				case 'P': 
+					decimals = (precision &gt;= 0) ? precision+2 : nfi.PercentDecimalDigits+2;
+					break;
+				case 'Z':
+					digits = 0;
+					break;
+			}
 
-            // get digit string
-            const int bufSize = 40;
-            int decPos = 0, sign = 0;
-            char[] buf = new char[bufSize];
-            if (Decimal.decimal2string(ref value, digits, decimals, buf, bufSize, out decPos, out sign) != 0) 
-            {
-                throw new FormatException(); // should never happen 
-            }
+			// get digit string
+			const int bufSize = 40;
+			int decPos = 0, sign = 0;
+			char[] buf = new char[bufSize];
+			if (Decimal.decimal2string(ref value, digits, decimals, buf, bufSize, out decPos, out sign) != 0) 
+			{
+				throw new FormatException(); // should never happen 
+			}
 
 		string TempString = new String(buf);
 		TempString = TempString.Trim(new char[] {(char)0x0});
 		StringBuilder sb = new StringBuilder(TempString, TempString.Length);
 
-	    if (sb.ToString () == String.Empty &amp;&amp; decPos &gt; 0 &amp;&amp; sign == 0)
-		    sb.Append ('0');
+		if (sb.ToString () == String.Empty &amp;&amp; decPos &gt; 0 &amp;&amp; sign == 0)
+			sb.Append ('0');
 
-            // now build the format
-            switch (specifier)
-            {
-                case 'C': return FormatCurrency(nfi, sb, decimals, decPos, sign);
-                case 'N': return FormatNumber(nfi, sb, decimals, decPos, sign);
-                case 'F': return FormatFixedPoint(nfi, sb, decimals, decPos, sign);
-                case 'G': return FormatGeneral(nfi, sb, digits, decPos, sign, format[0]);
-                case 'E': return FormatExponential(nfi, sb, digits, decPos, sign, format[0], true);
-                case 'P': return FormatPercent(nfi, sb, decimals, decPos, sign);
-                case 'Z': return FormatNormalized(nfi, sb, digits, decPos, sign);
-                default: 
-                    throw new FormatException (Locale.GetText (&quot;The specified format is invalid&quot;));
-            }
-        }
-
-        private static string FormatFixedPoint(NumberFormatInfo nfi, StringBuilder sb, 
-            int decimals, int decPos, int sign)
-        {
-            if (decimals &gt; 0)
-            {
-                sb.Insert((decPos &lt;= 0) ? 1 : decPos, nfi.NumberDecimalSeparator);
-            }
-
-            if (sign != 0) 
-            {
-                sb.Insert(0, nfi.NegativeSign);
-            }
-
-            return sb.ToString();
-        }
-
-        private static string FormatExponential(NumberFormatInfo nfi, StringBuilder sb, 
-            int digits, int decPos, int sign, char echar, bool exp3flag)
-        {
-            // insert decimal separator
-            if (digits &gt; 1 || (digits == 0 &amp;&amp; sb.Length &gt; 1)) 
-            {
-                sb.Insert(1, nfi.NumberDecimalSeparator);
-            }
-
-            // insert sign
-            if (sign != 0)
-            {
-                sb.Insert(0, nfi.NegativeSign);
-            }
-
-            // append exponent
-            sb.Append(echar);
-            decPos--;
-            sb.Append((decPos &gt;= 0) ? nfi.PositiveSign : nfi.NegativeSign);
-            if (decPos &lt; 0) decPos *= -1;
-            if (exp3flag) sb.Append('0');
-            sb.Append((char)('0' + decPos/10));
-            sb.Append((char)('0' + decPos%10));
-
-            return sb.ToString();
-        }
-
-        private static string FormatGeneral(NumberFormatInfo nfi, StringBuilder sb, 
-            int digits, int decPos, int sign, char gchar)
-        {
-            int dig = digits;
-            bool bFix = (digits == 0 &amp;&amp; decPos &gt;= -3) || (digits &gt;= decPos &amp;&amp; decPos &gt;= -3 &amp;&amp; digits != 0);
-
-            // remove trailing digits
-            while (sb.Length &gt; 1 &amp;&amp; (sb.Length &gt; decPos || !bFix) &amp;&amp; sb[sb.Length-1] == '0')
-            {
-                sb.Remove(sb.Length-1, 1);
-                if (dig != 0) dig--;
-            }
-
-            if (bFix)
-            {
-                while (decPos &lt;= 0) 
-                {
-                    sb.Insert(0, '0');
-                    if (dig != 0 &amp;&amp; decPos != 0) dig++;
-                    decPos++;
-                }
-                return FormatFixedPoint(nfi, sb, sb.Length - decPos, decPos, sign);
-            }
-            else
-            {
-                return FormatExponential(nfi, sb, dig, decPos, sign, (char)(gchar-2), false);
-            }
-        }
-
-        private static string FormatGroupAndDec(StringBuilder sb, int decimals, int decPos, 
-            int[] groupSizes, string groupSeparator, string decSeparator)
-        {
-            int offset = 0;
-
-            // Groups
-            if (decPos &gt; 0) 
-            {
-                if (groupSizes != null) 
-                {
-                    int lastSize = 0;
-                    int digitCount = 0;
-                    for (int i = 0; i &lt; groupSizes.GetLength(0); i++) 
-                    {
-                        int size = groupSizes[i];
-                        if (size &gt; 0) 
-                        {
-                            digitCount += size;
-                            if (digitCount &lt; decPos) 
-                            {
-                                sb.Insert(decPos - digitCount, groupSeparator);
-                                offset += groupSeparator.Length;
-                            }
-                        }
-                        lastSize = size;
-                    }
-
-                    if (lastSize &gt; 0) 
-                    {
-                        while (true) 
-                        {
-                            digitCount +=lastSize;
-                            if (digitCount &gt;= decPos) break;
-                            sb.Insert(decPos - digitCount, groupSeparator);
-                            offset += groupSeparator.Length;
-                        }
-                    }
-                }
-            }
-
-            if (decimals &gt; 0)
-            {
-                sb.Insert(offset + ((decPos &lt;= 0) ? 1 : decPos), decSeparator);
-            }
-
-            return sb.ToString();
-        }
-
-        private static string FormatNumber(NumberFormatInfo nfi, StringBuilder sb, 
-            int decimals, int decPos, int sign)
-        {
-            string s = FormatGroupAndDec(sb, decimals, decPos,
-                nfi.NumberGroupSizes, nfi.NumberGroupSeparator, nfi.NumberDecimalSeparator);
-
-            // sign
-            if (sign != 0) 
-            {
-                switch (nfi.NumberNegativePattern)
-                {
-                    case 0:
-                        return &quot;(&quot; + s + &quot;)&quot;;
-                    case 1:
-                        return nfi.NegativeSign + s;
-                    case 2:
-                        return nfi.NegativeSign + &quot; &quot; + s;
-                    case 3:
-                        return s + nfi.NegativeSign;
-                    case 4:
-                        return s + &quot; &quot; + nfi.NegativeSign;
-                    default:
-                        throw new ArgumentException(Locale.GetText (&quot;Invalid NumberNegativePattern&quot;));
-                }
-            } 
-            else 
-            {
-                return s;
-            }
-        }
-
-        private static string FormatCurrency(NumberFormatInfo nfi, StringBuilder sb, 
-            int decimals, int decPos, int sign)
-        {
-            string s = FormatGroupAndDec(sb, decimals, decPos,
-                nfi.CurrencyGroupSizes, nfi.CurrencyGroupSeparator, nfi.CurrencyDecimalSeparator);
-
-            if (sign != 0) 
-            { // negative
-                switch (nfi.CurrencyNegativePattern) 
-                {
-                    case 0:
-                        return &quot;(&quot; + nfi.CurrencySymbol + s + &quot;)&quot;;
-                    case 1:
-                        return nfi.NegativeSign + nfi.CurrencySymbol + s;
-                    case 2:
-                        return nfi.CurrencySymbol + nfi.NegativeSign + s;
-                    case 3:
-                        return nfi.CurrencySymbol + s + nfi.NegativeSign;
-                    case 4:
-                        return &quot;(&quot; + s + nfi.CurrencySymbol + &quot;)&quot;;
-                    case 5:
-                        return nfi.NegativeSign + s + nfi.CurrencySymbol;
-                    case 6:
-                        return s + nfi.NegativeSign + nfi.CurrencySymbol;
-                    case 7:
-                        return s + nfi.CurrencySymbol + nfi.NegativeSign;
-                    case 8:
-                        return nfi.NegativeSign + s + &quot; &quot; + nfi.CurrencySymbol;
-                    case 9:
-                        return nfi.NegativeSign + nfi.CurrencySymbol + &quot; &quot; + s;
-                    case 10:
-                        return s + &quot; &quot; + nfi.CurrencySymbol + nfi.NegativeSign;
-                    case 11:
-                        return nfi.CurrencySymbol + &quot; &quot; + s + nfi.NegativeSign;
-                    case 12:
-                        return nfi.CurrencySymbol + &quot; &quot; + nfi.NegativeSign + s;
-                    case 13:
-                        return s + nfi.NegativeSign + &quot; &quot; + nfi.CurrencySymbol;
-                    case 14:
-                        return &quot;(&quot; + nfi.CurrencySymbol + &quot; &quot; + s + &quot;)&quot;;
-                    case 15:
-                        return &quot;(&quot; + s + &quot; &quot; + nfi.CurrencySymbol + &quot;)&quot;;
-                    default:
-                        throw new ArgumentException(Locale.GetText (&quot;Invalid CurrencyNegativePattern&quot;));
-                }
-            }
-            else 
-            {
-                switch (nfi.CurrencyPositivePattern) 
-                {
-                    case 0:
-                        return nfi.CurrencySymbol + s;
-                    case 1:
-                        return s + nfi.CurrencySymbol;
-                    case 2:
-                        return nfi.CurrencySymbol + &quot; &quot; + s;
-                    case 3:
-                        return s + &quot; &quot; + nfi.CurrencySymbol;
-                    default:
-                        throw new ArgumentException(Locale.GetText (&quot;Invalid CurrencyPositivePattern&quot;));
-                }
-            }
-        }
-
-        private static string FormatPercent(NumberFormatInfo nfi, StringBuilder sb, 
-            int decimals, int decPos, int sign)
-        {
-            string s = FormatGroupAndDec(sb, decimals, decPos+2, 
-                nfi.PercentGroupSizes, nfi.PercentGroupSeparator, nfi.PercentDecimalSeparator);
-
-            if (sign != 0) 
-            { // negative
-                switch (nfi.PercentNegativePattern) 
-                {
-                    case 0:
-                        return nfi.NegativeSign + s + &quot; &quot; + nfi.PercentSymbol;
-                    case 1:
-                        return nfi.NegativeSign + s + nfi.PercentSymbol;
-                    case 2:
-                        return nfi.NegativeSign + nfi.PercentSymbol + s;
-                    default:
-                        throw new ArgumentException(Locale.GetText (&quot;Invalid PercentNegativePattern&quot;));
-                }
-            }
-            else 
-            {
-                switch (nfi.PercentPositivePattern) 
-                {
-                    case 0:
-                        return s + &quot; &quot; + nfi.PercentSymbol;
-                    case 1:
-                        return s + nfi.PercentSymbol;
-                    case 2:
-                        return nfi.PercentSymbol + s;
-                    default:
-                        throw new ArgumentException(&quot;Invalid PercentPositivePattern&quot;);
-                }
-            }
-        }
+			// now build the format
+			switch (specifier)
+			{
+				case 'C': return FormatCurrency(nfi, sb, decimals, decPos, sign);
+				case 'N': return FormatNumber(nfi, sb, decimals, decPos, sign);
+				case 'F': return FormatFixedPoint(nfi, sb, decimals, decPos, sign);
+				case 'G': return FormatGeneral(nfi, sb, digits, decPos, sign, format[0]);
+				case 'E': return FormatExponential(nfi, sb, digits, decPos, sign, format[0], true);
+				case 'P': return FormatPercent(nfi, sb, decimals, decPos, sign);
+				case 'Z': return FormatNormalized(nfi, sb, digits, decPos, sign);
+				default: 
+					throw new FormatException (Locale.GetText (&quot;The specified format is invalid&quot;));
+			}
+		}
+
+		private static string FormatFixedPoint(NumberFormatInfo nfi, StringBuilder sb, 
+			int decimals, int decPos, int sign)
+		{
+			if (decimals &gt; 0)
+			{
+				sb.Insert((decPos &lt;= 0) ? 1 : decPos, nfi.NumberDecimalSeparator);
+			}
+
+			if (sign != 0) 
+			{
+				sb.Insert(0, nfi.NegativeSign);
+			}
+
+			return sb.ToString();
+		}
+
+		private static string FormatExponential(NumberFormatInfo nfi, StringBuilder sb, 
+			int digits, int decPos, int sign, char echar, bool exp3flag)
+		{
+			// insert decimal separator
+			if (digits &gt; 1 || (digits == 0 &amp;&amp; sb.Length &gt; 1)) 
+			{
+				sb.Insert(1, nfi.NumberDecimalSeparator);
+			}
+
+			// insert sign
+			if (sign != 0)
+			{
+				sb.Insert(0, nfi.NegativeSign);
+			}
+
+			// append exponent
+			sb.Append(echar);
+			decPos--;
+			sb.Append((decPos &gt;= 0) ? nfi.PositiveSign : nfi.NegativeSign);
+			if (decPos &lt; 0) decPos *= -1;
+			if (exp3flag) sb.Append('0');
+			sb.Append((char)('0' + decPos/10));
+			sb.Append((char)('0' + decPos%10));
+
+			return sb.ToString();
+		}
+
+		private static string FormatGeneral(NumberFormatInfo nfi, StringBuilder sb, 
+			int digits, int decPos, int sign, char gchar)
+		{
+			int dig = digits;
+#if NET_1_0
+			bool bFix = (digits == 0 &amp;&amp; decPos &gt;= -3) || (digits &gt;= decPos &amp;&amp; decPos &gt;= -3 &amp;&amp; digits != 0);
+#else
+ 			bool bFix = (digits == 0 ) || (digits &gt;= decPos &amp;&amp; digits != 0);
+#endif			
+			
+			// remove trailing digits
+			while (sb.Length &gt; 1 &amp;&amp; (sb.Length &gt; decPos || !bFix) &amp;&amp; sb[sb.Length-1] == '0')
+			{
+				sb.Remove(sb.Length-1, 1);
+				if (dig != 0) dig--;
+			}
+
+			if (bFix)
+			{
+				while (decPos &lt;= 0) 
+				{
+					sb.Insert(0, '0');
+					if (dig != 0 &amp;&amp; decPos != 0) dig++;
+					decPos++;
+				}
+				return FormatFixedPoint(nfi, sb, sb.Length - decPos, decPos, sign);
+			}
+			else
+			{
+				return FormatExponential(nfi, sb, dig, decPos, sign, (char)(gchar-2), false);
+			}
+		}
+
+		private static string FormatGroupAndDec(StringBuilder sb, int decimals, int decPos, 
+			int[] groupSizes, string groupSeparator, string decSeparator)
+		{
+			int offset = 0;
+
+			// Groups
+			if (decPos &gt; 0) 
+			{
+				if (groupSizes != null) 
+				{
+					int lastSize = 0;
+					int digitCount = 0;
+					for (int i = 0; i &lt; groupSizes.GetLength(0); i++) 
+					{
+						int size = groupSizes[i];
+						if (size &gt; 0) 
+						{
+							digitCount += size;
+							if (digitCount &lt; decPos) 
+							{
+								sb.Insert(decPos - digitCount, groupSeparator);
+								offset += groupSeparator.Length;
+							}
+						}
+						lastSize = size;
+					}
+
+					if (lastSize &gt; 0) 
+					{
+						while (true) 
+						{
+							digitCount +=lastSize;
+							if (digitCount &gt;= decPos) break;
+							sb.Insert(decPos - digitCount, groupSeparator);
+							offset += groupSeparator.Length;
+						}
+					}
+				}
+			}
+
+			if ((decimals &gt; 0) &amp;&amp; (decPos+offset &lt; sb.Length))
+			{
+				sb.Insert(offset + ((decPos &lt;= 0) ? 1 : decPos), decSeparator);
+			}
+
+			return sb.ToString();
+		}
+
+		private static string FormatNumber(NumberFormatInfo nfi, StringBuilder sb, 
+			int decimals, int decPos, int sign)
+		{
+			string s = FormatGroupAndDec(sb, decimals, decPos,
+				nfi.NumberGroupSizes, nfi.NumberGroupSeparator, nfi.NumberDecimalSeparator);
+
+			// sign
+			if (sign != 0) 
+			{
+				switch (nfi.NumberNegativePattern)
+				{
+					case 0:
+						return &quot;(&quot; + s + &quot;)&quot;;
+					case 1:
+						return nfi.NegativeSign + s;
+					case 2:
+						return nfi.NegativeSign + &quot; &quot; + s;
+					case 3:
+						return s + nfi.NegativeSign;
+					case 4:
+						return s + &quot; &quot; + nfi.NegativeSign;
+					default:
+						throw new ArgumentException(Locale.GetText (&quot;Invalid NumberNegativePattern&quot;));
+				}
+			} 
+			else 
+			{
+				return s;
+			}
+		}
+
+		private static string FormatCurrency(NumberFormatInfo nfi, StringBuilder sb, 
+			int decimals, int decPos, int sign)
+		{
+			string s = FormatGroupAndDec(sb, decimals, decPos,
+				nfi.CurrencyGroupSizes, nfi.CurrencyGroupSeparator, nfi.CurrencyDecimalSeparator);
+
+			if (sign != 0) 
+			{ // negative
+				switch (nfi.CurrencyNegativePattern) 
+				{
+					case 0:
+						return &quot;(&quot; + nfi.CurrencySymbol + s + &quot;)&quot;;
+					case 1:
+						return nfi.NegativeSign + nfi.CurrencySymbol + s;
+					case 2:
+						return nfi.CurrencySymbol + nfi.NegativeSign + s;
+					case 3:
+						return nfi.CurrencySymbol + s + nfi.NegativeSign;
+					case 4:
+						return &quot;(&quot; + s + nfi.CurrencySymbol + &quot;)&quot;;
+					case 5:
+						return nfi.NegativeSign + s + nfi.CurrencySymbol;
+					case 6:
+						return s + nfi.NegativeSign + nfi.CurrencySymbol;
+					case 7:
+						return s + nfi.CurrencySymbol + nfi.NegativeSign;
+					case 8:
+						return nfi.NegativeSign + s + &quot; &quot; + nfi.CurrencySymbol;
+					case 9:
+						return nfi.NegativeSign + nfi.CurrencySymbol + &quot; &quot; + s;
+					case 10:
+						return s + &quot; &quot; + nfi.CurrencySymbol + nfi.NegativeSign;
+					case 11:
+						return nfi.CurrencySymbol + &quot; &quot; + s + nfi.NegativeSign;
+					case 12:
+						return nfi.CurrencySymbol + &quot; &quot; + nfi.NegativeSign + s;
+					case 13:
+						return s + nfi.NegativeSign + &quot; &quot; + nfi.CurrencySymbol;
+					case 14:
+						return &quot;(&quot; + nfi.CurrencySymbol + &quot; &quot; + s + &quot;)&quot;;
+					case 15:
+						return &quot;(&quot; + s + &quot; &quot; + nfi.CurrencySymbol + &quot;)&quot;;
+					default:
+						throw new ArgumentException(Locale.GetText (&quot;Invalid CurrencyNegativePattern&quot;));
+				}
+			}
+			else 
+			{
+				switch (nfi.CurrencyPositivePattern) 
+				{
+					case 0:
+						return nfi.CurrencySymbol + s;
+					case 1:
+						return s + nfi.CurrencySymbol;
+					case 2:
+						return nfi.CurrencySymbol + &quot; &quot; + s;
+					case 3:
+						return s + &quot; &quot; + nfi.CurrencySymbol;
+					default:
+						throw new ArgumentException(Locale.GetText (&quot;Invalid CurrencyPositivePattern&quot;));
+				}
+			}
+		}
+
+		private static string FormatPercent(NumberFormatInfo nfi, StringBuilder sb, 
+			int decimals, int decPos, int sign)
+		{
+			string s = FormatGroupAndDec(sb, decimals, decPos+2, 
+				nfi.PercentGroupSizes, nfi.PercentGroupSeparator, nfi.PercentDecimalSeparator);
+
+			if (sign != 0) 
+			{ // negative
+				switch (nfi.PercentNegativePattern) 
+				{
+					case 0:
+						return nfi.NegativeSign + s + &quot; &quot; + nfi.PercentSymbol;
+					case 1:
+						return nfi.NegativeSign + s + nfi.PercentSymbol;
+					case 2:
+						return nfi.NegativeSign + nfi.PercentSymbol + s;
+					default:
+						throw new ArgumentException(Locale.GetText (&quot;Invalid PercentNegativePattern&quot;));
+				}
+			}
+			else 
+			{
+				switch (nfi.PercentPositivePattern) 
+				{
+					case 0:
+						return s + &quot; &quot; + nfi.PercentSymbol;
+					case 1:
+						return s + nfi.PercentSymbol;
+					case 2:
+						return nfi.PercentSymbol + s;
+					default:
+						throw new ArgumentException(&quot;Invalid PercentPositivePattern&quot;);
+				}
+			}
+		}
 
 	[MonoTODO]
-        private static string FormatNormalized(NumberFormatInfo nfi, StringBuilder sb, 
-            int digits, int decPos, int sign)
-        {
-            //LAMESPEC: how should this format look like ? Is this a fixed point format ?
-	    throw new NotImplementedException ();
-        }
-    }
+		private static string FormatNormalized(NumberFormatInfo nfi, StringBuilder sb, 
+			int digits, int decPos, int sign)
+		{
+			//LAMESPEC: how should this format look like ? Is this a fixed point format ?
+		throw new NotImplementedException ();
+		}
+	}
 }
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005023.html">[Mono-devel-list] [PATCH] DecimalFormatters
</A></li>
	<LI>Next message: <A HREF="005026.html">[Mono-devel-list] [PATCH] DecimalFormatters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5025">[ date ]</a>
              <a href="thread.html#5025">[ thread ]</a>
              <a href="subject.html#5025">[ subject ]</a>
              <a href="author.html#5025">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
