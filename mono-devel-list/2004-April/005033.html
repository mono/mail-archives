<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Patch for System.Timespan
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20System.Timespan&In-Reply-To=001101c424a6%24fa768960%246464a8c0%40ansuria">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005032.html">
   <LINK REL="Next"  HREF="005037.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Patch for System.Timespan</H1>
    <B>Ben Maurer</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20System.Timespan&In-Reply-To=001101c424a6%24fa768960%246464a8c0%40ansuria"
       TITLE="[Mono-devel-list] Patch for System.Timespan">bmaurer at users.sourceforge.net
       </A><BR>
    <I>Sat Apr 17 14:51:53 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="005032.html">[Mono-devel-list] Patch for System.Timespan
</A></li>
        <LI>Next message: <A HREF="005037.html">[Mono-devel-list] Gecko Sharp error
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5033">[ date ]</a>
              <a href="thread.html#5033">[ thread ]</a>
              <a href="subject.html#5033">[ subject ]</a>
              <a href="author.html#5033">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sat, 2004-04-17 at 14:08, Andreas Nahr wrote: 
&gt;<i> &gt; &gt; &gt;       * You are intermingling formatting changes, bug fixes, and
</I>&gt;<i> &gt; &gt; &gt;         performance improvements. What I would suggest you do is the
</I>&gt;<i> &gt; &gt; &gt;         following:
</I>&gt;<i> &gt; &gt; &gt;               * Check in all formatting related changes that you want.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; That didn't seem to make sense to me with the reimpl. approach.
</I>&gt;<i> &gt; It actually makes alot of sense. If you check in formatting changes
</I>&gt;<i> &gt; *FIRST* and then do other fixes, the diff is alot cleaner. Right now,
</I>&gt;<i> &gt; the diff basically looks like you removed all methods from the class and
</I>&gt;<i> &gt; rewrote it. The diff should show:
</I>&gt;<i> 
</I>&gt;<i> Maybe it look like this because I did it exactly that way ;) Reimplemented
</I>&gt;<i> it from scratch copying over the few parts that worked.
</I>&gt;<i> I simply did not see any sense to make individual patches because that would
</I>&gt;<i> simply be too many of them.
</I>
Ok, let me give you an example of what I am talking about:


&gt;<i> -	public int Seconds
</I>&gt;<i> -	{
</I>&gt;<i> -		get
</I>&gt;<i> +		public TimeSpan (int days, int hours, int minutes, int seconds)
</I>&gt;<i> +			: this (days, hours, minutes, seconds, 0)
</I>&gt;<i>  		{
</I>&gt;<i> -			return (int) (_ticks % TicksPerMinute / TicksPerSecond);
</I>&gt;<i>  		}
</I>&gt;<i> -	}
</I>..
&gt;<i> -	public TimeSpan Add (TimeSpan ts)
</I>&gt;<i> -	{
</I>&gt;<i> -		checked {
</I>&gt;<i> -			return new TimeSpan (_ticks + ts.Ticks);
</I>&gt;<i> +		public int Seconds {
</I>&gt;<i> +			get {
</I>&gt;<i> +				return (int) (_ticks % TicksPerMinute / TicksPerSecond);
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i> -	}
</I>So, in the Seconds property, the only thing you changed was some whitespace. However:
      * The property got moved around the file. I had to search for it
        in the diff 
      * In order to see what changes you made, I had to compare the two
        versions of the property.
It is just not possible to review patches like that. The way to fix this
is to first, format the timespan file to your content. When you do diff
-b, you should get no changes.

After this, you can reintroduce the changes you made to exception
messages, etc. Those are not really `meaningful' so you can check them
in (but separately from the whitespace changes).

Once these two things are done, you can merge your patch back in (you
will likely have to do it by hand).

&gt;<i> &gt; &gt; There are A LOT of them. Would anybody have much for insight if I posted
</I>&gt;<i> &gt; &gt; 40-50 individual patches for that?
</I>&gt;<i> &gt; I would rather review 10-20 atomic patches than 1 patch that I could not
</I>&gt;<i> &gt; understand. As it stands, your patch is unlikely to be reviewed, meaning
</I>&gt;<i> &gt; it is very unlikely to see the light of day.
</I>&gt;<i> 
</I>&gt;<i> I surely can understand that a atomic patch makes sense if you would have to
</I>&gt;<i> compare the new TimeSpan to the old one. If one or some lines in a function
</I>&gt;<i> are CHANGES.
</I>The old method and the new method should be next to each other in the
patch, which is why I want you to do formatting changes first. This
eases reviewing.

&gt;<i> However for all non-tivial changes that require review there is
</I>&gt;<i> not a single original line left in those functions (e.g. ToString, FromXXX,
</I>&gt;<i> Operators). So I do not see any advantage in sending 40 individual patches.
</I>&gt;<i> Do you REALLY feel that reviewing 40 individual patches (which is about how
</I>&gt;<i> much patches get sent to this list in a month or few weeks) is less work
</I>&gt;<i> than a 11kb source file. I would not.
</I>Here is the problem -- if you submit one patch, you are putting all your
eggs in one basket. In order for the patch to be reviewed, every part
must be reviewed.

The number 40 is very much overblown. Lets take a look at the quick
changelog you made, and see how you can partition the patches:


&gt;<i> This is a (probably not complete) list of content changes (no
</I>&gt;<i> stylings):
</I>&gt;<i> public TimeSpan (int hours, int minutes, int seconds): Perf+, better
</I>&gt;<i> called
</I>&gt;<i> method
</I>&gt;<i> public TimeSpan (int days, int hours, int minutes, int seconds):
</I>&gt;<i> Perf+, same
</I>&gt;<i> public TimeSpan (int days, int hours, int minutes, int seconds, int
</I>&gt;<i> milliseconds): Perf+, Own impl., BugFix: thows correct and elaborate
</I>&gt;<i> exception
</I>&gt;<i> private TimeSpan (bool sign, int days, int hours, int minutes, int
</I>&gt;<i> seconds,
</I>&gt;<i> long ticks): BugFix: thows correct and elaborate exception
</I>These changes can probably be in one patch.

&gt;<i> public TimeSpan Add (TimeSpan ts): Minor Bugfix: Throw elaborate
</I>&gt;<i> exception
</I>&gt;<i> public TimeSpan Duration (): Minor Bugfix: Throw elaborate exception
</I>&gt;<i> public TimeSpan Subtract (TimeSpan ts): Minor Bugfix: Throw elaborate
</I>&gt;<i> exception
</I>These are minor, you can probably check them in while you do the
exception message fixups

&gt;<i> 
</I>&gt;<i> public int CompareTo (object value): Bugfix, spelling in exception
</I>&gt;<i> public TimeSpan Negate (): Minor Bugfix: Localize exception
</I>&gt;<i> public static TimeSpan Parse (string s): Bugfix: incorrect exception
</I>&gt;<i> + Several typofixes in error texts
</I>Minor spelling errors dont need to go to the list.

&gt;<i> 
</I>&gt;<i> public static TimeSpan FromDays (double value): Perf+++++, huge speed
</I>&gt;<i> improvement, completely rewritten, Also fixes several bugs: Throws
</I>&gt;<i> ArgumentExceptions for NaN, Fixes bug with wrong overflows with very
</I>&gt;<i> big or
</I>&gt;<i> very small values (did throw exceptions before), Correctly throws
</I>&gt;<i> Overflowexceptions
</I>&gt;<i> public static TimeSpan FromHours (double value): Perf+++++, huge speed
</I>&gt;<i> improvement, completely rewritten, Also fixes several bugs: Throws
</I>&gt;<i> ArgumentExceptions for NaN, Fixes bug with wrong overflows with very
</I>&gt;<i> big or
</I>&gt;<i> very small values (did throw exceptions before), Correctly throws
</I>&gt;<i> Overflowexceptions
</I>&gt;<i> public static TimeSpan FromMinutes (double value): Perf+++++, huge
</I>&gt;<i> speed
</I>&gt;<i> improvement, completely rewritten, Also fixes several bugs: Throws
</I>&gt;<i> ArgumentExceptions for NaN, Fixes bug with wrong overflows with very
</I>&gt;<i> big or
</I>&gt;<i> very small values (did throw exceptions before), Correctly throws
</I>&gt;<i> Overflowexceptions
</I>&gt;<i> public static TimeSpan FromSeconds (double value): Perf+++++, huge
</I>&gt;<i> speed
</I>&gt;<i> improvement, completely rewritten, Also fixes several bugs: Throws
</I>&gt;<i> ArgumentExceptions for NaN, Fixes bug with wrong overflows with very
</I>&gt;<i> big or
</I>&gt;<i> very small values (did throw exceptions before), Correctly throws
</I>&gt;<i> Overflowexceptions
</I>&gt;<i> public static TimeSpan FromMilliseconds (double value): Perf++++, huge
</I>&gt;<i> speed
</I>&gt;<i> improvement, completely rewritten, Also fixes several bugs: Throws
</I>&gt;<i> ArgumentExceptions for NaN, Fixes bug with wrong overflows with very
</I>&gt;<i> big or
</I>&gt;<i> very small values (did throw exceptions before), Correctly throws
</I>&gt;<i> Overflowexceptions
</I>If I understand it, all of these patches do the same thing in different
places, so one patch here.

&gt;<i> public override string ToString (): Perf+++
</I>One patch

&gt;<i> public static bool operator == (TimeSpan t1, TimeSpan t2): Perf+++
</I>&gt;<i> public static bool operator &gt; (TimeSpan t1, TimeSpan t2): Perf+++
</I>&gt;<i> public static bool operator &gt;= (TimeSpan t1, TimeSpan t2): Perf+++
</I>&gt;<i> public static bool operator != (TimeSpan t1, TimeSpan t2): Perf+++
</I>&gt;<i> public static bool operator &lt; (TimeSpan t1, TimeSpan t2): Perf+++
</I>&gt;<i> public static bool operator &lt;= (TimeSpan t1, TimeSpan t2): Perf+++
</I>One patch

&gt;<i> public Parser (string src): Removed stupid (unneeded) method
</I>One patch.

So, this is *5* patches, not 40.


&gt;<i> The problem is simply that i just have a class which I just edit to the need
</I>&gt;<i> that I have for testing. After it is done I usually do not keep any of these
</I>&gt;<i> because they are an entire mess afterwards.
</I>Well, for very obvious ones (like the operator fixes), you dont really
need one (i can tell from looking at it why it is faster).

But for something like ToString, you should really give some benchmarks.

&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; Some more specific ones:
</I>&gt;<i> &gt; &gt; &gt;       * Be careful about large arithmetic. For example, you have
</I>&gt;<i> &gt; &gt; &gt;         TicksPerXXX as a long each time. However, if some of these
</I>&gt;<i> were
</I>&gt;<i> &gt; &gt; &gt;         ints, the JIT could make more optimizations. Also, some
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> 
</I>&gt;<i> TicksPerXXX is a PUBLIC constant. I doubt that we should change the type of
</I>&gt;<i> them just to make it potentially optimizable.
</I>Actually, it turns out that MCS emits a ldc.i4/conv.i8 pair, so it is
fine.


&gt;<i> &gt; &gt; &gt; Am betting that a 100% improvement in any one of these issues will net
</I>&gt;<i> &gt; &gt; &gt; far more benefit than a 3000% improvement in TimeSpan.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; This is probably right. I've also done a LOT of test/ checks on String
</I>&gt;<i> &gt; &gt; members. However testing string takes MUCH more time as it
</I>&gt;<i> &gt; &gt; a) is alredy somewhat optimized (also there is a lot of improvement
</I>&gt;<i> &gt; &gt; possible). However in String lots depend upon usage profile (length and
</I>&gt;<i> &gt; &gt; structure of used strings), which makes it so hard to find completely
</I>&gt;<i> &gt; &gt; superior solutions.
</I>&gt;<i> &gt; Agreed. However, taking the easier optimizations reduces the fun (which
</I>&gt;<i> &gt; you are after anyways). However, some of those opts are things that can
</I>&gt;<i> &gt; be done in a way that they will always increase perf. Take a look at the
</I>&gt;<i> &gt; Array.Sort thing I suggested. You just have to make an icall that will
</I>&gt;<i> &gt; handle sorting int[], char[], etc. using glibc's qsort (which is VERY
</I>&gt;<i> &gt; fast).
</I>&gt;<i> 
</I>&gt;<i> Personally I think we should use as little c code as possible. So I will not
</I>&gt;<i> touch and especially not create any c parts. Each icall makes our libraries
</I>&gt;<i> less portable and reusable. Moreover icalls themselves are relatively slow
</I>&gt;<i> and are probably going to become even slower (afaik mono does not do any
</I>&gt;<i> security checks right now with icalls)
</I>&gt;<i> Also I think whatever makes fun to me is probably my thing to find out ;)
</I>&gt;<i> (And I'm hacking for about 15 Years, so I think I already know)
</I>
Well, the issue with Array.Sort is that it is making O(n^2) ICalls,
because each time it needs to get/set an element, it must make an icall
(because it only has a System.Array, not a foo []). So, for
int/char/long/etc, we really just need an icall. The overhead of an
ICall in a case like this is negated by the performance benefit.
Anyways, in the array methods, we will be netting fewer, not more,
icalls, because of the Get/Set calls.

&gt;<i> As I said I already worked on String. But as I sent a patch to the list (and
</I>&gt;<i> it was just one perfectly atomic one;) - I did not get any useful response -
</I>&gt;<i> so I simply stopped working on that out of frustration.
</I>There were a few questions about why the long operations were faster, no
response was given to those.

Also, I asked if we would be better off using rep prefixed instructions,
there was no response.

&gt;<i> The thing that I would like to see most is a nice, fast, generational GC.
</I>&gt;<i> Because this limits EVERYTHING right now.
</I>Agreed. But that's a ways off.

Again, I really want this patch to get in. However, if we are not able
to review it, it will never see the light of day. I know you dont like
making changelogs, writing atomic patches etc; I don't either. However,
in the end, it gets patches into cvs faster, meaning mono is better
faster -- which is what we really want.

-- Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005032.html">[Mono-devel-list] Patch for System.Timespan
</A></li>
	<LI>Next message: <A HREF="005037.html">[Mono-devel-list] Gecko Sharp error
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5033">[ date ]</a>
              <a href="thread.html#5033">[ thread ]</a>
              <a href="subject.html#5033">[ subject ]</a>
              <a href="author.html#5033">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
