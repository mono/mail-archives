<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Patch for System.Timespan
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20System.Timespan&In-Reply-To=002101c42458%2414192250%246464a8c0%40ansuria">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005030.html">
   <LINK REL="Next"  HREF="005032.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Patch for System.Timespan</H1>
    <B>Ben Maurer</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20System.Timespan&In-Reply-To=002101c42458%2414192250%246464a8c0%40ansuria"
       TITLE="[Mono-devel-list] Patch for System.Timespan">bmaurer at users.sourceforge.net
       </A><BR>
    <I>Sat Apr 17 11:19:46 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="005030.html">[Mono-devel-list] Patch for System.Timespan
</A></li>
        <LI>Next message: <A HREF="005032.html">[Mono-devel-list] Patch for System.Timespan
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5031">[ date ]</a>
              <a href="thread.html#5031">[ thread ]</a>
              <a href="subject.html#5031">[ subject ]</a>
              <a href="author.html#5031">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sat, 2004-04-17 at 04:43, Andreas Nahr wrote:

&gt;<i> 
</I>&gt;<i> This is a (probably not complete) list of content changes (no stylings):
</I>&gt;<i> public TimeSpan (int hours, int minutes, int seconds): Perf+, better called
</I>&gt;<i> method
</I>Ok, I did not ask for a one to five scale of `how much did I improve
performance'. Tell me HOW you did it. Specific numbers (ie, a benchmark)
should also be attached.

&gt;<i> &gt;       * You are intermingling formatting changes, bug fixes, and
</I>&gt;<i> &gt;         performance improvements. What I would suggest you do is the
</I>&gt;<i> &gt;         following:
</I>&gt;<i> &gt;               * Check in all formatting related changes that you want.
</I>&gt;<i> 
</I>&gt;<i> That didn't seem to make sense to me with the reimpl. approach.
</I>It actually makes alot of sense. If you check in formatting changes
*FIRST* and then do other fixes, the diff is alot cleaner. Right now,
the diff basically looks like you removed all methods from the class and
rewrote it. The diff should show:
public void Foo () {
- ...
+ ...
}

So that we can see the old and the new code for each method. This allows
us to better understand what you are doing.   

&gt;<i> &gt;               * Attach *ONE* patch per bug. If a bug appears in multiple
</I>&gt;<i> &gt;                 areas, it is OK to attach one patch that fixes the issue
</I>&gt;<i> &gt;                 in each method. In general, there should be one patch
</I>&gt;<i> &gt;                 per bug that would be filed in bugzilla
</I>&gt;<i> 
</I>&gt;<i> The bugs are currently not in bugzilla (at least I didn't check if any of
</I>&gt;<i> them are there). I just encountered them (mostly) while doing the perfomance
</I>&gt;<i> test. And obviously while testing my implementation. And I really just do
</I>&gt;<i> this all for fun in my spare time and starting to file bugs for things I
</I>&gt;<i> immediately fix is not really fun for me.
</I>
Note &quot;Would be filed in bugzilla&quot; -- There is no need to file tons of
bugs in bugzilla (though, it would not be a bad idea, and would allow us
to track each patch). What I am trying to say is:
        You are fixing different bugs. Attach different a patch for each
        issue. An issue is the smallest diff that you can create that
        fixes a specific behavior. An exception is if the exact same
        behavior occurs in `n' places, in which case, you should attach
        a patch that fixes the issue in each method.

Also, note that doing atomic patches is to your own benefit. It results
in quicker reviews, fewer rants on overpatchitis, and gets your code
into CVS faster.

&gt;<i> 
</I>&gt;<i> &gt;               * Attach one patch for each optimization.
</I>&gt;<i> &gt;       * ALL performance improvements should come with benchmarks.
</I>&gt;<i> 
</I>&gt;<i> There are A LOT of them. Would anybody have much for insight if I posted
</I>&gt;<i> 40-50 individual patches for that?
</I>I would rather review 10-20 atomic patches than 1 patch that I could not
understand. As it stands, your patch is unlikely to be reviewed, meaning
it is very unlikely to see the light of day.

&gt;<i> I've done a lot of microbenchmarking (which fortunatelly is relatively
</I>&gt;<i> simple when dealing mostly with longs). However I do not have any of those
</I>&gt;<i> available for inclusion as I just use one app and modify as needed.
</I>I have no issue if you attach a suite of benchmarks. If the suite is
above the mono-devel-list limit, feel free to zip them.

&gt;<i> 
</I>&gt;<i> &gt; Some more specific ones:
</I>&gt;<i> &gt;       * Be careful about large arithmetic. For example, you have
</I>&gt;<i> &gt;         TicksPerXXX as a long each time. However, if some of these were
</I>&gt;<i> &gt;         ints, the JIT could make more optimizations. Also, some
</I>&gt;<i> 
</I>&gt;<i> These need to be longs because the values can reach long values
</I>Yes, but the jit can optimize:
int a, b;
long c = (long) a * (long) b;

into one mul instruction. It cant do that with:
long a, b;
long c = a * b;

&gt;<i> 
</I>&gt;<i> &gt;         operations could be moved out of checked contexts to make them
</I>&gt;<i> &gt;         faster.
</I>&gt;<i> 
</I>&gt;<i> I choose all of the checked contexts very carefully. If you can tell me any
</I>&gt;<i> context where the check is not needed please tell me. But if I made no
</I>&gt;<i> mistakes the checks are crucial at  the positions where they are now. (These
</I>&gt;<i> places could overflow, but must never do)
</I>
&gt;<i> +		public TimeSpan (int days, int hours, int minutes, int seconds, int milliseconds)
</I>&gt;<i>  		{
</I>&gt;<i> +			try {
</I>&gt;<i> +				checked {
</I>&gt;<i> +					_ticks = TicksPerDay * days + 
</I>&gt;<i> +						TicksPerHour * hours +
</I>&gt;<i> +						TicksPerMinute * minutes +
</I>&gt;<i> +						TicksPerSecond * seconds +
</I>&gt;<i> +						TicksPerMillisecond * milliseconds;
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +			catch {
</I>&gt;<i> +				throw new ArgumentOutOfRangeException (Locale.GetText (&quot;The timespan is too big or too small.&quot;));
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>
In all the cases where TicksPerXXX is smaller than 2^32, the multiplies will not overflow, so you dont need checked.


&gt;<i> 
</I>&gt;<i> &gt;       * When you use stringbuilder, try to guess at how long the string
</I>&gt;<i> &gt;         will be -- this avoids reallocs.
</I>&gt;<i> 
</I>&gt;<i> Yes - played around with that one for a bit of time, but in the end the
</I>&gt;<i> default value of 16 elements seemed just right (This is one of the cases (in
</I>&gt;<i> this struct) were usage profile would matter)
</I>A comment to that effect would help future optimizers.


&gt;<i> &gt; Am betting that a 100% improvement in any one of these issues will net
</I>&gt;<i> &gt; far more benefit than a 3000% improvement in TimeSpan.
</I>&gt;<i> 
</I>&gt;<i> This is probably right. I've also done a LOT of test/ checks on String
</I>&gt;<i> members. However testing string takes MUCH more time as it
</I>&gt;<i> a) is alredy somewhat optimized (also there is a lot of improvement
</I>&gt;<i> possible). However in String lots depend upon usage profile (length and
</I>&gt;<i> structure of used strings), which makes it so hard to find completely
</I>&gt;<i> superior solutions.
</I>Agreed. However, taking the easier optimizations reduces the fun (which
you are after anyways). However, some of those opts are things that can
be done in a way that they will always increase perf. Take a look at the
Array.Sort thing I suggested. You just have to make an icall that will
handle sorting int[], char[], etc. using glibc's qsort (which is VERY
fast).


&gt;<i> Also IMHO we should not make too much assumptions about when and how a
</I>&gt;<i> application uses the core classes. There MAY be applications out there that
</I>&gt;<i> depend on TimeSpan in a very perfomance sensitive way and it is one of the
</I>&gt;<i> CORE classes. So an area where we are 100ds of times slower than MS impl.
</I>&gt;<i> would even seem like a showstopper to me. And it's also just nice that some
</I>&gt;<i> are now faster than MS ;)
</I>
Absolutely we should not. However, opts on Array and String should come
before more uncommon classes.


In short, I really want your patch to get in. However, there is no way
it can possibly be reviewed as is. It is in your best interest to submit
small, atomic patches that can quickly land on CVS.

-- Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005030.html">[Mono-devel-list] Patch for System.Timespan
</A></li>
	<LI>Next message: <A HREF="005032.html">[Mono-devel-list] Patch for System.Timespan
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5031">[ date ]</a>
              <a href="thread.html#5031">[ thread ]</a>
              <a href="subject.html#5031">[ subject ]</a>
              <a href="author.html#5031">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
