<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [PATCH] System.Web.Caching small cleaning
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20System.Web.Caching%20small%20cleaning&In-Reply-To=1081872288.7266.93.camel%40atreyu.localdomain">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004962.html">
   <LINK REL="Next"  HREF="004964.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [PATCH] System.Web.Caching small cleaning</H1>
    <B>Yaacov Akiba Slama</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20System.Web.Caching%20small%20cleaning&In-Reply-To=1081872288.7266.93.camel%40atreyu.localdomain"
       TITLE="[Mono-devel-list] [PATCH] System.Web.Caching small cleaning">ya at slamail.org
       </A><BR>
    <I>Tue Apr 13 12:23:01 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="004962.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
        <LI>Next message: <A HREF="004964.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4963">[ date ]</a>
              <a href="thread.html#4963">[ thread ]</a>
              <a href="subject.html#4963">[ subject ]</a>
              <a href="author.html#4963">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jackson Harper wrote:

&gt;<i>Hello,
</I>&gt;<i>
</I>&gt;<i>	Could you expand on your description of the Cache.cs changes?
</I>&gt;<i>  
</I>&gt;<i>
</I>Currently, there is one fucntion called UpdateCache() which is called by 
Add(), Remove() and Get() and from these functions only.
1) The flow inside UpdateCache is different depending on the caller and 
this function is a lot more complicated than if the same operations are 
written in each of the Add(), Remove() and Get().
2) The locks inside this function is far from optimal.

My patch delete this function and move the needed functionality in 
Add(), Remove() and Get(). The code is cleaner and seems to be faster 
(at least in some basic stress tests).


Thanks,
Yaacov Akiba

&gt;<i>Thanks,
</I>&gt;<i>Jackson
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Tue, 2004-04-13 at 09:02, Yaacov Akiba Slama wrote:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>Hello,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Enclosed is a patch which :
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>1) Delete the CacheabilityUpdatedCallback delegate of CachePolicy after 
</I>&gt;&gt;<i>the response is sent back to the client in order to let HttpResponse 
</I>&gt;&gt;<i>instances be garbage collected even if corresponding CacheEntry 
</I>&gt;&gt;<i>instances are still in memory.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>2) Clean up System.Web.Caching.Cache.cs
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Thanks,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Yaacov Akiba Slama
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>______________________________________________________________________
</I>&gt;&gt;<i>diff -u System.Web/System.Web/HttpResponse.cs System.Web/System.Web/HttpResponse.cs
</I>&gt;&gt;<i>--- System.Web/System.Web/HttpResponse.cs
</I>&gt;&gt;<i>+++ System.Web/System.Web/HttpResponse.cs
</I>&gt;&gt;<i>@@ -55,6 +55,7 @@
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 		HttpCookieCollection _Cookies;
</I>&gt;&gt;<i> 		HttpCachePolicy _CachePolicy;
</I>&gt;&gt;<i>+		CacheabilityUpdatedCallback _CacheabilityUpdatedCallback;
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 		Encoding _ContentEncoding;
</I>&gt;&gt;<i> 			
</I>&gt;&gt;<i>@@ -377,8 +378,9 @@
</I>&gt;&gt;<i> 			get {
</I>&gt;&gt;<i> 				if (null == _CachePolicy) {
</I>&gt;&gt;<i> 					_CachePolicy = new HttpCachePolicy ();
</I>&gt;&gt;<i>-					_CachePolicy.CacheabilityUpdated += new CacheabilityUpdatedCallback (
</I>&gt;&gt;<i>+					_CacheabilityUpdatedCallback = new CacheabilityUpdatedCallback (
</I>&gt;&gt;<i> 						OnCacheabilityUpdated);
</I>&gt;&gt;<i>+					_CachePolicy.CacheabilityUpdated += _CacheabilityUpdatedCallback;
</I>&gt;&gt;<i> 				}
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 				return _CachePolicy;
</I>&gt;&gt;<i>@@ -862,8 +875,14 @@
</I>&gt;&gt;<i> 				}
</I>&gt;&gt;<i> 				_Writer.Clear ();
</I>&gt;&gt;<i> 			} finally {
</I>&gt;&gt;<i>-				if (bFinish)
</I>&gt;&gt;<i>+				if (bFinish) {
</I>&gt;&gt;<i> 					closed = true;
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i>+					// delete the delegate in order to let &quot;this&quot; garbage collected even
</I>&gt;&gt;<i>+					// if _CachePolicy is not GC'ed.
</I>&gt;&gt;<i>+					if (_CachePolicy != null)
</I>&gt;&gt;<i>+						_CachePolicy.CacheabilityUpdated -= _CacheabilityUpdatedCallback;
</I>&gt;&gt;<i>+				}
</I>&gt;&gt;<i> 				_bFlushing = false;
</I>&gt;&gt;<i> 			}
</I>&gt;&gt;<i> 		}
</I>&gt;&gt;<i>diff -u System.Web/System.Web.Caching/Cache.cs System.Web/System.Web.Caching/Cache.cs
</I>&gt;&gt;<i>--- System.Web/System.Web.Caching/Cache.cs
</I>&gt;&gt;<i>+++ System.Web/System.Web.Caching/Cache.cs
</I>&gt;&gt;<i>@@ -222,13 +222,20 @@
</I>&gt;&gt;<i> 			if (objEntry.HasSlidingExpiration || objEntry.HasAbsoluteExpiration)
</I>&gt;&gt;<i> 				_objExpires.Add (objEntry);
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>-			// Check and get the new item..
</I>&gt;&gt;<i>-			objNewEntry = UpdateCache (strKey, objEntry, true, CacheItemRemovedReason.Removed);
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i>-			if (objNewEntry == null)
</I>&gt;&gt;<i>-				return null;
</I>&gt;&gt;<i>+			bool boolAdded = false;
</I>&gt;&gt;<i>+			_lockEntries.AcquireWriterLock (-1);
</I>&gt;&gt;<i>+			try {
</I>&gt;&gt;<i>+				_arrEntries [strKey] = objEntry;
</I>&gt;&gt;<i>+				boolAdded = true;
</I>&gt;&gt;<i>+			} finally {
</I>&gt;&gt;<i>+				_lockEntries.ReleaseLock ();
</I>&gt;&gt;<i>+			}
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>+			if (boolAdded) {
</I>&gt;&gt;<i> 			return objEntry.Item;
</I>&gt;&gt;<i>+			} else {
</I>&gt;&gt;<i>+				return null;
</I>&gt;&gt;<i>+			}
</I>&gt;&gt;<i> 		}
</I>&gt;&gt;<i> 		
</I>&gt;&gt;<i> 		/// &lt;summary&gt;
</I>&gt;&gt;<i>@@ -401,13 +408,35 @@
</I>&gt;&gt;<i> 		/// &lt;/returns&gt;
</I>&gt;&gt;<i> 		internal object Remove (string strKey, CacheItemRemovedReason enumReason)
</I>&gt;&gt;<i> 		{
</I>&gt;&gt;<i>-			CacheEntry objEntry = UpdateCache (strKey, null, true, enumReason);
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i>+			CacheEntry objEntry;
</I>&gt;&gt;<i>+			bool boolRemoved = false;
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i>+			_lockEntries.AcquireReaderLock (-1);
</I>&gt;&gt;<i>+			try {
</I>&gt;&gt;<i>+				objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;&gt;<i> 			if (objEntry == null)
</I>&gt;&gt;<i> 				return null;
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>+				Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;&gt;<i>+				try {
</I>&gt;&gt;<i>+					_arrEntries.Remove (strKey);
</I>&gt;&gt;<i>+					boolRemoved = true;
</I>&gt;&gt;<i>+				} finally {
</I>&gt;&gt;<i>+					_lockEntries.DowngradeFromWriterLock (ref objCookie);
</I>&gt;&gt;<i>+				}
</I>&gt;&gt;<i>+			} finally {
</I>&gt;&gt;<i>+				_lockEntries.ReleaseLock ();
</I>&gt;&gt;<i>+			}
</I>&gt;&gt;<i>+		
</I>&gt;&gt;<i>+			if (!boolRemoved)
</I>&gt;&gt;<i>+				return null;
</I>&gt;&gt;<i>+				
</I>&gt;&gt;<i>+			if (objEntry.HasAbsoluteExpiration || objEntry.HasSlidingExpiration)
</I>&gt;&gt;<i>+				_objExpires.Remove (objEntry);
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i> 			Interlocked.Decrement (ref _nItems);
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>-			// Close the cache entry (calls the remove delegate)
</I>&gt;&gt;<i> 			objEntry.Close (enumReason);
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 			return objEntry.Item;
</I>&gt;&gt;<i>@@ -420,7 +450,8 @@
</I>&gt;&gt;<i> 		/// &lt;returns&gt;The retrieved cache item, or a null reference.&lt;/returns&gt;
</I>&gt;&gt;<i> 		public object Get (string strKey)
</I>&gt;&gt;<i> 		{
</I>&gt;&gt;<i>-			CacheEntry objEntry = UpdateCache (strKey, null, false, CacheItemRemovedReason.Expired);
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i>+			CacheEntry objEntry = GetEntry (strKey);
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 			if (objEntry == null)
</I>&gt;&gt;<i> 				return null;
</I>&gt;&gt;<i>@@ -430,97 +462,36 @@
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 		internal CacheEntry GetEntry (string strKey)
</I>&gt;&gt;<i> 		{
</I>&gt;&gt;<i>-			CacheEntry objEntry = UpdateCache (strKey, null, false, CacheItemRemovedReason.Expired);
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i>-			if (objEntry == null)
</I>&gt;&gt;<i>-				return null;
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>-			return objEntry;
</I>&gt;&gt;<i>-		}
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i>-		/// &lt;summary&gt;
</I>&gt;&gt;<i>-		/// Internal method used for removing, updating and adding CacheEntries into the cache.
</I>&gt;&gt;<i>-		/// &lt;/summary&gt;
</I>&gt;&gt;<i>-		/// &lt;param name=&quot;strKey&quot;&gt;The identifier for the cache item to modify&lt;/param&gt;
</I>&gt;&gt;<i>-		/// &lt;param name=&quot;objEntry&quot;&gt;
</I>&gt;&gt;<i>-		/// CacheEntry to use for overwrite operation, if this
</I>&gt;&gt;<i>-		/// parameter is null and overwrite true the item is going to be
</I>&gt;&gt;<i>-		/// removed
</I>&gt;&gt;<i>-		/// &lt;/param&gt;
</I>&gt;&gt;<i>-		/// &lt;param name=&quot;boolOverwrite&quot;&gt;
</I>&gt;&gt;<i>-		/// If true the objEntry parameter is used to overwrite the
</I>&gt;&gt;<i>-		/// strKey entry
</I>&gt;&gt;<i>-		/// &lt;/param&gt;
</I>&gt;&gt;<i>-		/// &lt;param name=&quot;enumReason&quot;&gt;Reason why an item was removed&lt;/param&gt;
</I>&gt;&gt;<i>-		/// &lt;returns&gt;&lt;/returns&gt;
</I>&gt;&gt;<i>-		private CacheEntry UpdateCache (string strKey,
</I>&gt;&gt;<i>-						CacheEntry objEntry,
</I>&gt;&gt;<i>-						bool boolOverwrite,
</I>&gt;&gt;<i>-						CacheItemRemovedReason enumReason)
</I>&gt;&gt;<i>-		{
</I>&gt;&gt;<i> 			if (strKey == null)
</I>&gt;&gt;<i> 				throw new ArgumentNullException (&quot;strKey&quot;);
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>+			CacheEntry objEntry;
</I>&gt;&gt;<i>+			bool boolExpired = false;
</I>&gt;&gt;<i>+			bool boolRemoved = false;
</I>&gt;&gt;<i> 			long ticksNow = DateTime.Now.Ticks;
</I>&gt;&gt;<i> 			long ticksExpires = long.MaxValue;
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>-			bool boolGetItem = false;
</I>&gt;&gt;<i>-			bool boolExpiried = false;
</I>&gt;&gt;<i>-			bool boolWrite = false;
</I>&gt;&gt;<i>-			bool boolRemoved = false;
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i>-			// Are we getting the item from the hashtable
</I>&gt;&gt;<i>-			if (boolOverwrite == false &amp;&amp; strKey.Length &gt; 0 &amp;&amp; objEntry == null)
</I>&gt;&gt;<i>-				boolGetItem = true;
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i>-			// TODO: Optimize this method, move out functionality outside the lock
</I>&gt;&gt;<i>-			_lockEntries.AcquireReaderLock (-1);
</I>&gt;&gt;<i>+			_lockEntries.AcquireReaderLock (-1);
</I>&gt;&gt;<i> 			try {
</I>&gt;&gt;<i>-				if (boolGetItem) {
</I>&gt;&gt;<i> 					objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;&gt;<i> 					if (objEntry == null)
</I>&gt;&gt;<i> 						return null;
</I>&gt;&gt;<i>-				}
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>-				if (objEntry != null) {
</I>&gt;&gt;<i>-					// Check if we have expired
</I>&gt;&gt;<i> 					if (objEntry.HasSlidingExpiration || objEntry.HasAbsoluteExpiration) {
</I>&gt;&gt;<i> 						if (objEntry.Expires &lt; ticksNow) {
</I>&gt;&gt;<i> 							// We have expired, remove the item from the cache
</I>&gt;&gt;<i>-							boolWrite = true;
</I>&gt;&gt;<i>-							boolExpiried = true;
</I>&gt;&gt;<i>-						} 
</I>&gt;&gt;<i>-					} 
</I>&gt;&gt;<i>-				}
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i>-				// Check if we going to modify the hashtable
</I>&gt;&gt;<i>-				if (boolWrite || (boolOverwrite &amp;&amp; !boolExpiried)) {
</I>&gt;&gt;<i>-					// Upgrade our lock to write
</I>&gt;&gt;<i>-					Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;&gt;<i>+						boolExpired = true;
</I>&gt;&gt;<i>+						Threading.LockCookie objCookie = _lockEntries.UpgradeToWriterLock (-1);
</I>&gt;&gt;<i> 					try {
</I>&gt;&gt;<i>-						// Check if we going to just modify an existing entry (or add)
</I>&gt;&gt;<i>-						if (boolOverwrite &amp;&amp; objEntry != null) {
</I>&gt;&gt;<i>-							_arrEntries [strKey] = objEntry;
</I>&gt;&gt;<i>-						} else {
</I>&gt;&gt;<i>-							// We need to remove the item, fetch the item first
</I>&gt;&gt;<i>-							objEntry = (CacheEntry) _arrEntries [strKey];
</I>&gt;&gt;<i>-							if (objEntry != null)
</I>&gt;&gt;<i> 								_arrEntries.Remove (strKey);
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i> 							boolRemoved = true;
</I>&gt;&gt;<i>-						}
</I>&gt;&gt;<i> 					} finally {
</I>&gt;&gt;<i> 						_lockEntries.DowngradeFromWriterLock (ref objCookie);
</I>&gt;&gt;<i> 					}
</I>&gt;&gt;<i> 				}
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i>-				// If the entry haven't expired or been removed update the info
</I>&gt;&gt;<i>-				if (!boolExpiried &amp;&amp; !boolRemoved) {
</I>&gt;&gt;<i>-					// Update that we got a hit
</I>&gt;&gt;<i>-					objEntry.Hits++;
</I>&gt;&gt;<i>-					if (objEntry.HasSlidingExpiration)
</I>&gt;&gt;<i>-						ticksExpires = ticksNow + objEntry.SlidingExpiration;
</I>&gt;&gt;<i> 				}
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i> 			} finally {
</I>&gt;&gt;<i> 				_lockEntries.ReleaseLock ();
</I>&gt;&gt;<i> 			}
</I>&gt;&gt;<i>@@ -525,26 +496,27 @@
</I>&gt;&gt;<i> 				_lockEntries.ReleaseLock ();
</I>&gt;&gt;<i> 			}
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>-			// If the item was removed we need to remove it from the CacheExpired class also
</I>&gt;&gt;<i> 			if (boolRemoved) {
</I>&gt;&gt;<i>-				if (objEntry != null) {
</I>&gt;&gt;<i> 					if (objEntry.HasAbsoluteExpiration || objEntry.HasSlidingExpiration)
</I>&gt;&gt;<i> 						_objExpires.Remove (objEntry);
</I>&gt;&gt;<i>-				}
</I>&gt;&gt;<i>-				objEntry.Close (enumReason);
</I>&gt;&gt;<i>+				Interlocked.Decrement (ref _nItems);
</I>&gt;&gt;<i>+				objEntry.Close (CacheItemRemovedReason.Expired);
</I>&gt;&gt;<i> 				return null;
</I>&gt;&gt;<i> 			}
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>-			// If we have sliding expiration and we have a correct hit, update the expiration manager
</I>&gt;&gt;<i>+			if (!boolExpired) {
</I>&gt;&gt;<i>+				objEntry.Hits++;
</I>&gt;&gt;<i> 			if (objEntry.HasSlidingExpiration) {
</I>&gt;&gt;<i>+					ticksExpires = ticksNow + objEntry.SlidingExpiration;
</I>&gt;&gt;<i> 				_objExpires.Update (objEntry, ticksExpires);
</I>&gt;&gt;<i> 				objEntry.Expires = ticksExpires;
</I>&gt;&gt;<i> 			}
</I>&gt;&gt;<i>-
</I>&gt;&gt;<i>-			// Return the cache entry
</I>&gt;&gt;<i> 			return objEntry;
</I>&gt;&gt;<i> 		}
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>+			return null;
</I>&gt;&gt;<i>+		}
</I>&gt;&gt;<i>+
</I>&gt;&gt;<i> 		/// &lt;summary&gt;
</I>&gt;&gt;<i> 		/// Gets the number of items stored in the cache.
</I>&gt;&gt;<i> 		/// &lt;/summary&gt;
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004962.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
	<LI>Next message: <A HREF="004964.html">[Mono-devel-list] [PATCH] System.Web.Caching small cleaning
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4963">[ date ]</a>
              <a href="thread.html#4963">[ thread ]</a>
              <a href="subject.html#4963">[ subject ]</a>
              <a href="author.html#4963">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
