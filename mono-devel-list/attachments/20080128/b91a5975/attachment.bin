Index: ChangeLog
===================================================================
--- ChangeLog	(revision 92275)
+++ ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2008-01-28  Jonathan Pryor  <jpryor@novell.com>
+
+	* signal.c: Provide support functions for Mono.Unix.UnixSignal, which 
+	  supports both polling and waiting on signal emission.
+	* map.h: Flush (adds UnixSignal-related prototypes).
+
 2008-01-05  Jonathan Pryor  <jpryor@novell.com>
 
 	* map.h, map.c: Flush; add new ST_NOEXEC, ST_REMOUNT, and ST_BIND MountFlags 
Index: signal.c
===================================================================
--- signal.c	(revision 92060)
+++ signal.c	(working copy)
@@ -3,18 +3,30 @@
  *
  * Authors:
  *   Jonathan Pryor (jonpryor@vt.edu)
+ *   Jonathan Pryor (jpryor@novell.com)
  *
  * Copyright (C) 2004-2005 Jonathan Pryor
+ * Copyright (C) 2008 Novell, Inc.
  */
 
 #include <signal.h>
 
+#ifndef PLATFORM_WIN32
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#endif
+
 #include "map.h"
 #include "mph.h"
 
 G_BEGIN_DECLS
 
 typedef void (*mph_sighandler_t)(int);
+typedef struct Mono_Unix_UnixSignal_SignalInfo signal_info;
 
 void*
 Mono_Posix_Stdlib_SIG_DFL (void)
@@ -42,6 +54,7 @@
 }
 
 #ifndef PLATFORM_WIN32
+
 int
 Mono_Posix_Syscall_psignal (int sig, const char* s)
 {
@@ -49,6 +62,220 @@
 	psignal (sig, s);
 	return errno == 0 ? 0 : -1;
 }
+
+#define NUM_SIGNALS 64
+static signal_info signals[NUM_SIGNALS];
+
+static void
+default_handler (int signum)
+{
+	int i;
+	for (i = 0; i < NUM_SIGNALS; ++i) {
+		signal_info* h = &signals [i];
+		if (h->signum != signum)
+			continue;
+		++h->count;
+		if (h->write_fd > 0) {
+			char c = signum;
+			write (h->write_fd, &c, 1);
+		}
+	}
+}
+
+static pthread_mutex_t signals_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+void*
+Mono_Unix_UnixSignal_install (int sig)
+{
+	int i, mr;
+	signal_info* h = NULL; 
+	int have_handler = 0;
+	void* handler;
+
+	mr = pthread_mutex_lock (&signals_mutex);
+	if (mr != 0) {
+		errno = mr;
+		return NULL;
+	}
+
+	for (i = 0; i < NUM_SIGNALS; ++i) {
+		if (h == NULL && signals [i].signum == 0) {
+			h = &signals [i];
+			h->handler = signal (sig, default_handler);
+			if (h->handler == SIG_ERR) {
+				h->handler = NULL;
+				h = NULL;
+				break;
+			}
+			else {
+				h->signum       = sig;
+				h->count        = 0;
+				h->have_handler = 1;
+			}
+		}
+		if (!have_handler && signals [i].signum == sig &&
+				signals [i].handler != default_handler) {
+			have_handler = 1;
+			handler = signals [i].handler;
+		}
+		if (h && have_handler)
+			break;
+	}
+
+	if (h && have_handler) {
+		h->have_handler = 1;
+		h->handler      = handler;
+	}
+
+	pthread_mutex_unlock (&signals_mutex);
+
+	return h;
+}
+
+static int
+count_handlers (int signum)
+{
+	int i;
+	int count = 0;
+	for (i = 0; i < NUM_SIGNALS; ++i) {
+		if (signals [i].signum == signum)
+			++count;
+	}
+	return count;
+}
+
+int
+Mono_Unix_UnixSignal_uninstall (void* info)
+{
+	signal_info* h;
+	int mr, r = -1;
+
+	mr = pthread_mutex_lock (&signals_mutex);
+	if (mr != 0) {
+		errno = mr;
+		return -1;
+	}
+
+	h = info;
+
+	if (h == NULL || h < signals || h > &signals [NUM_SIGNALS])
+		errno = EINVAL;
+	else {
+		/* last UnixSignal -- we can unregister */
+		if (h->have_handler && count_handlers (h->signum) == 1) {
+			mph_sighandler_t p = signal (h->signum, h->handler);
+			if (p != SIG_ERR)
+				r = 0;
+			h->handler      = NULL;
+			h->have_handler = 0;
+		}
+		h->signum = 0;
+	}
+
+	pthread_mutex_unlock (&signals_mutex);
+
+	return r;
+}
+
+static int
+setup_pipes (signal_info** signals, int count, fd_set *read_fds, int *max_fd)
+{
+	int i, r;
+	for (i = 0; i < count; ++i) {
+		signal_info* h;
+		int filedes[2];
+
+		if ((r = pipe (filedes)) != 0) {
+			break;
+		}
+		h = signals [i];
+		h->read_fd  = filedes [0];
+		h->write_fd = filedes [1];
+		if (h->read_fd > *max_fd)
+			*max_fd = h->read_fd;
+		FD_SET (h->read_fd, read_fds);
+	}
+	return r;
+}
+
+static void
+teardown_pipes (signal_info** signals, int count)
+{
+	int i;
+	for (i = 0; i < count; ++i) {
+		signal_info* h = signals [i];
+		if (h->read_fd != 0)
+			close (h->read_fd);
+		if (h->write_fd != 0)
+			close (h->write_fd);
+		h->read_fd  = 0;
+		h->write_fd = 0;
+	}
+}
+
+static int
+wait_for_any (signal_info** signals, int count, int max_fd, fd_set* read_fds, int timeout)
+{
+	int r;
+	do {
+		struct timeval tv;
+		struct timeval *ptv = NULL;
+		if (timeout != -1) {
+			tv.tv_sec  = timeout / 1000;
+			tv.tv_usec = (timeout % 1000)*1000;
+			ptv = &tv;
+		}
+
+		r = select (max_fd + 1, read_fds, NULL, NULL, ptv);
+	} while (r == -1 && errno == EINTR);
+
+	if (r > 0) {
+		int i;
+		for (i = 0; i < count; ++i) {
+			signal_info* h = signals [i];
+			if (FD_ISSET (h->read_fd, read_fds)) {
+				char c;
+				read (h->read_fd, &c, 1); /* ignore error */
+			}
+		}
+	}
+
+	return r;
+}
+
+/*
+ * returns: -1 on error:
+ *           0 on timeout
+ *         > 0 on success
+ */
+int
+Mono_Unix_UnixSignal_WaitAny (void** _signals, int count, int timeout /* milliseconds */)
+{
+	fd_set read_fds;
+	int mr, r;
+	int max_fd = 0;
+
+	signal_info** signals = (signal_info**) _signals;
+
+	mr = pthread_mutex_lock (&signals_mutex);
+	if (mr != 0) {
+		errno = mr;
+		return -1;
+	}
+
+	FD_ZERO (&read_fds);
+
+	r = setup_pipes (signals, count, &read_fds, &max_fd);
+	if (r == 0) {
+		r = wait_for_any (signals, count, max_fd, &read_fds, timeout);
+	}
+	teardown_pipes (signals, count);
+
+	pthread_mutex_unlock (&signals_mutex);
+
+	return r;
+}
+
 #endif /* ndef PLATFORM_WIN32 */
 
 
Index: map.h
===================================================================
--- map.h	(revision 92275)
+++ map.h	(working copy)
@@ -1382,6 +1382,7 @@
 struct Mono_Posix_Timeval;
 struct Mono_Posix_Timezone;
 struct Mono_Posix_Utimbuf;
+struct Mono_Unix_UnixSignal_SignalInfo;
 
 /*
  * Inferred Structure Declarations
@@ -1541,7 +1542,16 @@
 Mono_Posix_ToUtimbuf (struct utimbuf *from, struct Mono_Posix_Utimbuf* to);
 
 
+struct Mono_Unix_UnixSignal_SignalInfo {
+	int   signum;
+	int   count;
+	int   read_fd;
+	int   write_fd;
+	int   have_handler;
+	void* handler;
+};
 
+
 /*
  * Functions
  */
@@ -1706,6 +1716,9 @@
 int Mono_Posix_Syscall_WSTOPSIG (int status);
 int Mono_Posix_Syscall_WTERMSIG (int status);
 int Mono_Posix_ToStatvfs (void* source, struct Mono_Posix_Statvfs* destination);
+void* Mono_Unix_UnixSignal_install (int signum);
+int Mono_Unix_UnixSignal_uninstall (void* info);
+int Mono_Unix_UnixSignal_WaitAny (void** infos, int count, int timeout);
 int wexitstatus (int status);
 int wifexited (int status);
 int wifsignaled (int status);
