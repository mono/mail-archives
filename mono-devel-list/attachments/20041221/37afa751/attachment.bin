Index: mono/mono/mini/driver.c
===================================================================
--- mono/mono/mini/driver.c	(revision 38026)
+++ mono/mono/mini/driver.c	(working copy)
@@ -90,6 +90,7 @@
 	MONO_OPT_LINEARS |	\
 	MONO_OPT_INTRINS |  \
 	MONO_OPT_LOOP |  \
+	MONO_OPT_SSAPRE |  \
 	MONO_OPT_AOT)
 
 #define EXCLUDED_FROM_ALL (MONO_OPT_SHARED | MONO_OPT_PRECOMP)
Index: mono/mono/mini/ssapre.c
===================================================================
--- mono/mono/mini/ssapre.c	(revision 38026)
+++ mono/mono/mini/ssapre.c	(working copy)
@@ -79,6 +79,57 @@
 	}
 }
 
+#if (MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION)
+static int
+snprint_argument (char *string, size_t max_length, MonoSsapreExpressionArgument *argument) {
+	int length;
+	switch (argument->type) {
+		case MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY:
+			length = snprintf (string, max_length, "ANY");
+			break;
+		case MONO_SSAPRE_EXPRESSION_ARGUMENT_NOT_PRESENT:
+			length = snprintf (string, max_length, "NONE");
+			break;
+		case MONO_SSAPRE_EXPRESSION_ARGUMENT_ORIGINAL_VARIABLE:
+			length = snprintf (string, max_length, "ORIGINAL_VARIABLE %d", argument->argument.original_variable);
+			break;
+		case MONO_SSAPRE_EXPRESSION_ARGUMENT_SSA_VARIABLE:
+			length = snprintf (string, max_length, "SSA_VARIABLE %d", argument->argument.ssa_variable);
+			break;
+		case MONO_SSAPRE_EXPRESSION_ARGUMENT_INTEGER_CONSTANT:
+			length = snprintf (string, max_length, "INTEGER_CONSTANT %d", argument->argument.integer_constant);
+			break;
+		case MONO_SSAPRE_EXPRESSION_ARGUMENT_LONG_COSTANT:
+			length = snprintf (string, max_length, "LONG_COSTANT %lld", *(argument->argument.long_constant));
+			break;
+		case MONO_SSAPRE_EXPRESSION_ARGUMENT_FLOAT_COSTANT:
+			length = snprintf (string, max_length, "FLOAT_COSTANT %f", *(argument->argument.float_constant));
+			break;
+		case MONO_SSAPRE_EXPRESSION_ARGUMENT_DOUBLE_COSTANT:
+			length = snprintf (string, max_length, "DOUBLE_COSTANT %f", *(argument->argument.double_constant));
+			break;
+		default:
+			length = snprintf (string, max_length, "UNKNOWN: %d", argument->type);
+	}
+	return length;
+}
+
+static int
+snprint_expression_description (char *string, size_t max_length, MonoSsapreExpressionDescription *expression_description) {
+	int length = 0;
+	if (expression_description->opcode != 0) {
+		length += snprintf (string + length, max_length - length, "%s ([", mono_inst_name (expression_description->opcode) );
+		length += snprint_argument (string + length, max_length - length, &(expression_description->left_argument));
+		length += snprintf (string + length, max_length - length, "],[");
+		length += snprint_argument (string + length, max_length - length, &(expression_description->right_argument));
+		length += snprintf (string + length, max_length - length, "])");
+	} else {
+		length += snprintf (string + length, max_length - length, "ANY");
+	}
+	return length;
+}
+#endif
+
 #define GBOOLEAN_TO_STRING(b) ((b)?"TRUE":"FALSE")
 
 static void
@@ -244,7 +295,12 @@
 	case CEE_LDIND_R4:
 	case CEE_LDIND_R8:
 	case CEE_LDIND_REF:
-		analyze_argument (argument->inst_left, result);
+		if ((argument->inst_left->opcode == OP_LOCAL) || (argument->inst_left->opcode == OP_ARG)) {
+			result->type = MONO_SSAPRE_EXPRESSION_ARGUMENT_SSA_VARIABLE;
+			result->argument.ssa_variable = argument->inst_left->inst_c0;
+		} else {
+			result->type = MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY;
+		}
 		break;
 	case OP_ICONST:
 		result->type = MONO_SSAPRE_EXPRESSION_ARGUMENT_INTEGER_CONSTANT;
@@ -262,11 +318,6 @@
 		result->type = MONO_SSAPRE_EXPRESSION_ARGUMENT_DOUBLE_COSTANT;
 		result->argument.double_constant = (double*)argument->inst_p0;
 		break;
-	case OP_ARG:
-	case OP_LOCAL:
-		result->type = MONO_SSAPRE_EXPRESSION_ARGUMENT_SSA_VARIABLE;
-		result->argument.ssa_variable = argument->inst_c0;
-		break;
 	default:
 		result->type = MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY;
 	}
@@ -279,6 +330,7 @@
 static void
 analyze_expression (MonoInst *expression, MonoSsapreExpressionDescription *result) {
 	switch (expression->opcode) {
+	//FIXME: We should enable LDIND* opcodes...
 	case CEE_LDIND_I1:
 	case CEE_LDIND_U1:
 	case CEE_LDIND_I2:
@@ -290,12 +342,10 @@
 	case CEE_LDIND_R4:
 	case CEE_LDIND_R8:
 	case CEE_LDIND_REF:
-		analyze_expression (expression->inst_left, result);
-		break;
+	
 	case CEE_SWITCH:
 	case CEE_ISINST:
 	case CEE_CASTCLASS:
-	case OP_OUTARG:
 	case OP_CALL_REG:
 	case OP_FCALL_REG:
 	case OP_LCALL_REG:
@@ -313,12 +363,6 @@
 	case OP_VOIDCALLVIRT:
 	case OP_RENAME:
 	case OP_RETARG:
-//	case OP_OUTARG:
-	case OP_OUTARG_REG:
-	case OP_OUTARG_IMM:
-	case OP_OUTARG_R4:
-	case OP_OUTARG_R8:
-	case OP_OUTARG_VT:
 	case CEE_NOP:
 	case CEE_JMP:
 	case CEE_BREAK:
@@ -329,27 +373,20 @@
 	case OP_ICOMPARE:
 	case OP_ICOMPARE_IMM:
 		result->opcode = 0;
+		result->left_argument.type = MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY;
+		result->right_argument.type = MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY;
 		break;
 	default:
 		if ( (expression->type == STACK_I4) ||
 				(expression->type == STACK_I8) ||
 				(expression->type == STACK_R8) ) {
 			if (mono_burg_arity [expression->opcode] > 0) {
+				result->opcode = expression->opcode;
 				analyze_argument (expression->inst_left, &(result->left_argument));
-				if (result->left_argument.type != MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY) {
-					if (mono_burg_arity [expression->opcode] > 1) {
-						analyze_argument (expression->inst_right, &(result->right_argument));
-						if (result->right_argument.type != MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY) {
-							result->opcode = expression->opcode;
-						} else {
-							result->opcode = 0;
-						}
-					} else {
-						result->right_argument.type = MONO_SSAPRE_EXPRESSION_ARGUMENT_NOT_PRESENT;
-						result->opcode = expression->opcode;
-					}
+				if (mono_burg_arity [expression->opcode] > 1) {
+					analyze_argument (expression->inst_right, &(result->right_argument));
 				} else {
-					result->opcode = 0;
+					result->right_argument.type = MONO_SSAPRE_EXPRESSION_ARGUMENT_NOT_PRESENT;
 				}
 			} else {
 				result->opcode = 0;
@@ -611,20 +648,58 @@
 	}
 }
 
+#if (MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION)
+static char *mono_ssapre_expression_name = NULL;
+static gboolean
+check_ssapre_expression_name (MonoSsapreWorkArea *area, MonoSsapreExpressionDescription *expression_description) {
+	if (area->expression_is_handled_father) {
+		return TRUE;
+	}
+	if (mono_ssapre_expression_name == NULL) {
+		mono_ssapre_expression_name = getenv ("MONO_SSAPRE_EXPRESSION_NAME");
+	}
+	if (mono_ssapre_expression_name != NULL) {
+		char expression_name[1024];
+		snprint_expression_description (expression_name, 1024, expression_description);
+		if (LOG_SSAPRE) {
+			printf ("Comparing expression names '%s' and '%s'\n", mono_ssapre_expression_name, expression_name);
+		}
+		if (strstr (mono_ssapre_expression_name, expression_name) != NULL) {
+			return TRUE;
+		} else {
+			return FALSE;
+		}
+	} else {
+		return TRUE;
+	}
+}
+#endif
+
 /*
- * Adds an expression to the worklist (putting the given occurrence as first
+ * Adds an expression to the worklist (putting the current occurrence as first
  * occurrence of this expression).
  */
 static void
-add_expression_to_worklist (MonoSsapreWorkArea *area, MonoSsapreExpressionOccurrence *occurrence) {
-	MonoSsapreExpression *expression;
+add_expression_to_worklist (MonoSsapreWorkArea *area) {
+	MonoSsapreExpressionOccurrence *occurrence = area->current_occurrence;
+	MonoSsapreExpression *expression = (MonoSsapreExpression*) mono_mempool_alloc (area->mempool, sizeof (MonoSsapreExpression));
 	
-	expression = (MonoSsapreExpression*) mono_mempool_alloc (area->mempool, sizeof (MonoSsapreExpression));
+	convert_ssa_variables_to_original_names (&(expression->description), &(occurrence->description), area->cfg);
 	
-	convert_ssa_variables_to_original_names (&(expression->description), &(occurrence->description), area->cfg);
+#if (MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION)
+	if (! check_ssapre_expression_name (area, &(expression->description))) return;
+#endif	
+	
 	expression->type = mono_type_from_stack_type (occurrence->occurrence);
 	expression->occurrences = NULL;
 	expression->last_occurrence = NULL;
+	expression->next_in_queue = NULL;
+	if (area->last_in_queue != NULL) {
+		area->last_in_queue->next_in_queue = expression;
+	} else {
+		area->first_in_queue = expression;
+	}
+	area->last_in_queue = expression;
 	MONO_SSAPRE_ADD_EXPRESSION_OCCURRANCE (expression, occurrence);
 	
 	area->worklist = add_expression_to_tree (area->worklist, expression);
@@ -632,16 +707,16 @@
 }
 
 /*
- * Adds an expression occurrence to the worklist.
+ * Adds the current expression occurrence to the worklist.
  * If its expression is not yet in the worklist, it is created.
  */
 static void
-add_occurrence_to_worklist (MonoSsapreWorkArea *area, MonoSsapreExpressionOccurrence *occurrence) {
+add_occurrence_to_worklist (MonoSsapreWorkArea *area) {
 	MonoSsapreExpressionDescription description;
 	MonoSsapreExpression *current_expression;
 	int comparison;
 	
-	convert_ssa_variables_to_original_names (&description, &(occurrence->description), area->cfg);
+	convert_ssa_variables_to_original_names (&description, &(area->current_occurrence->description), area->cfg);
 	current_expression = area->worklist;
 	
 	do {
@@ -653,66 +728,75 @@
 			} else if (comparison < 0) {
 				current_expression = current_expression->previous;
 			} else {
-				MONO_SSAPRE_ADD_EXPRESSION_OCCURRANCE (current_expression, occurrence);
+				MONO_SSAPRE_ADD_EXPRESSION_OCCURRANCE (current_expression, area->current_occurrence);
 			}
 		} else {
-			add_expression_to_worklist (area, occurrence);
+			add_expression_to_worklist (area);
 			comparison = 0;
 		}
 	} while (comparison != 0);
+	
+	area->current_occurrence = (MonoSsapreExpressionOccurrence*) mono_mempool_alloc (area->mempool, sizeof (MonoSsapreExpressionOccurrence));
 }
 
 /*
  * Process a MonoInst, and of it is a valid expression add it to the worklist.
  */
-static MonoSsapreExpressionOccurrence*
-process_inst (MonoSsapreWorkArea *area, MonoInst* inst, MonoInst* previous_inst, MonoSsapreBBInfo *bb_info, MonoSsapreExpressionOccurrence *current_occurrence) {
+static void
+process_inst (MonoSsapreWorkArea *area, MonoInst* inst, MonoInst* previous_inst, MonoSsapreFatherExpression*** father_in_tree, MonoSsapreBBInfo *bb_info) {
+	MonoSsapreFatherExpression** left_father_in_tree = NULL;
+	MonoSsapreFatherExpression** right_father_in_tree = NULL;
 	
-	/* Ugly hack to fix missing variable definitions */
-	/* (the SSA construction code should have done it already!) */
-	switch (inst->opcode) {
-	case CEE_STIND_REF:
-	case CEE_STIND_I:
-	case CEE_STIND_I4:
-	case CEE_STIND_I1:
-	case CEE_STIND_I2:
-	case CEE_STIND_I8:
-	case CEE_STIND_R4:
-	case CEE_STIND_R8:
-		if ((inst->inst_left->opcode == OP_LOCAL) || (inst->inst_left->opcode == OP_ARG)) {
-			int variable_index = inst->inst_left->inst_c0;
-			
-			if (area->cfg->vars [variable_index]->def_bb == NULL) {
-				if (area->cfg->verbose_level >= 4) {
-					printf ("SSAPRE WARNING: variable %d has no definition, fixing.\n", variable_index);
-				}
-				area->cfg->vars [variable_index]->def_bb = bb_info->bb;
-			}
-		}
-		break;
-	default:
-		break;
-	}
-	
 	if (mono_burg_arity [inst->opcode] > 0) {
-		current_occurrence = process_inst (area, inst->inst_left, previous_inst, bb_info, current_occurrence);
+		process_inst (area, inst->inst_left, previous_inst, &left_father_in_tree, bb_info);
 		if (mono_burg_arity [inst->opcode] > 1) {
-			current_occurrence = process_inst (area, inst->inst_right, previous_inst, bb_info, current_occurrence);
+			process_inst (area, inst->inst_right, previous_inst, &right_father_in_tree, bb_info);
 		}
 	}
 	
-	analyze_expression (inst, &(current_occurrence->description));
-	if (current_occurrence->description.opcode != 0) {
-		current_occurrence->occurrence = inst;
-		current_occurrence->previous_tree = previous_inst;
-		current_occurrence->bb_info = bb_info;
-		current_occurrence->is_first_in_bb = FALSE;
-		current_occurrence->is_last_in_bb = FALSE;
-		add_occurrence_to_worklist (area, current_occurrence);
-		current_occurrence = (MonoSsapreExpressionOccurrence*) mono_mempool_alloc (area->mempool, sizeof (MonoSsapreExpressionOccurrence));
+	analyze_expression (inst, &(area->current_occurrence->description));
+	if (area->current_occurrence->description.opcode != 0) {
+		if ((left_father_in_tree != NULL) || (right_father_in_tree != NULL)) {
+			MonoSsapreFatherExpression *current_inst_as_father = (MonoSsapreFatherExpression*) mono_mempool_alloc (area->mempool, sizeof (MonoSsapreFatherExpression));
+			current_inst_as_father->father_occurrence = inst;
+			current_inst_as_father->grand_father = NULL;
+			*father_in_tree = &(current_inst_as_father->grand_father);
+			if (left_father_in_tree != NULL) {
+				*left_father_in_tree = current_inst_as_father;
+			}
+			if (right_father_in_tree != NULL) {
+				*right_father_in_tree = current_inst_as_father;
+			}
+			if (DUMP_SSAPRE) {
+				printf ("Expression '");
+				mono_print_tree (inst);
+				printf ("' is a potential father ( ");
+				if (left_father_in_tree != NULL) {
+					printf ("LEFT ");
+				}
+				if (right_father_in_tree != NULL) {
+					printf ("RIGHT ");
+				}
+				printf (")\n");
+			}
+		} else if ((area->current_occurrence->description.left_argument.type != MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY) &&
+				(area->current_occurrence->description.right_argument.type != MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY)) {
+			area->current_occurrence->occurrence = inst;
+			area->current_occurrence->previous_tree = previous_inst;
+			area->current_occurrence->bb_info = bb_info;
+			area->current_occurrence->is_first_in_bb = FALSE;
+			area->current_occurrence->is_last_in_bb = FALSE;
+			
+			area->current_occurrence->father_in_tree = NULL;
+			*father_in_tree = &(area->current_occurrence->father_in_tree);
+			
+			add_occurrence_to_worklist (area);
+		} else {
+			*father_in_tree = NULL;
+		}
+	} else {
+		*father_in_tree = NULL;
 	}
-	
-	return current_occurrence;
 }
 
 /*
@@ -721,13 +805,14 @@
  * auxiliary MonoSsapreBBInfo fields (dt_dfn, dt_descendants) are initialized
  * (with all the info that comes from the MonoBasicBlock).
  */
-static MonoSsapreExpressionOccurrence*
-process_bb (MonoSsapreWorkArea *area, MonoBasicBlock *bb, int *dt_dfn, int *upper_descendants, MonoSsapreExpressionOccurrence *current_occurrence) {
+static void
+process_bb (MonoSsapreWorkArea *area, MonoBasicBlock *bb, int *dt_dfn, int *upper_descendants) {
 	MonoSsapreBBInfo *bb_info;
 	int descendants;
 	GList *dominated_bb;
 	MonoInst* current_inst;
 	MonoInst* previous_inst;
+	MonoSsapreFatherExpression** dummy_father_in_tree;
 	
 	bb_info = &(area->bb_infos [*dt_dfn]);
 	bb_info->dt_dfn = *dt_dfn;
@@ -747,22 +832,53 @@
 	current_inst = bb->code;
 	previous_inst = NULL;
 	while (current_inst != NULL) {
+		/* Ugly hack to fix missing variable definitions */
+		/* (the SSA construction code should have done it already!) */
+		switch (current_inst->opcode) {
+		case CEE_STIND_REF:
+		case CEE_STIND_I:
+		case CEE_STIND_I4:
+		case CEE_STIND_I1:
+		case CEE_STIND_I2:
+		case CEE_STIND_I8:
+		case CEE_STIND_R4:
+		case CEE_STIND_R8:
+			if ((current_inst->inst_left->opcode == OP_LOCAL) || (current_inst->inst_left->opcode == OP_ARG)) {
+				int variable_index = current_inst->inst_left->inst_c0;
+				
+				if (area->cfg->vars [variable_index]->def_bb == NULL) {
+					if (area->cfg->verbose_level >= 4) {
+						printf ("SSAPRE WARNING: variable %d has no definition, fixing.\n", variable_index);
+					}
+					area->cfg->vars [variable_index]->def_bb = bb_info->bb;
+				}
+			}
+			break;
+		default:
+			break;
+		}
+		
 		if (is_phi_definition (current_inst)) {
 			bb_info->phi_insertion_point = current_inst;
 		}
-		current_occurrence = process_inst (area, current_inst, previous_inst, bb_info, current_occurrence);
+		
+		if (mono_burg_arity [current_inst->opcode] > 0) {
+			process_inst (area, current_inst->inst_left, previous_inst, &dummy_father_in_tree, bb_info);
+			if (mono_burg_arity [current_inst->opcode] > 1) {
+				process_inst (area, current_inst->inst_right, previous_inst, &dummy_father_in_tree, bb_info);
+			}
+		}
+		
 		previous_inst = current_inst;
 		current_inst = current_inst->next;
 	}
 	
 	descendants = 0;
 	for (dominated_bb = g_list_first (bb->dominated); dominated_bb != NULL; dominated_bb = g_list_next (dominated_bb)) {
-		current_occurrence = process_bb (area, (MonoBasicBlock*) (dominated_bb->data), dt_dfn, &descendants, current_occurrence);
+		process_bb (area, (MonoBasicBlock*) (dominated_bb->data), dt_dfn, &descendants);
 	}
 	bb_info->dt_descendants = descendants;
 	*upper_descendants += (descendants + 1);
-	
-	return current_occurrence;
 }
 
 /*
@@ -983,35 +1099,64 @@
 	
 	/* This loop is "rename1" */
 	for (current_bb = area->first_interesting_bb, previous_bb = NULL; current_bb != NULL; previous_bb = current_bb, current_bb = current_bb->next_interesting_bb) {
-		if ((previous_bb != NULL) && ! dominates (previous_bb, current_bb)) {
-			if ((area->bb_on_top_of_renaming_stack != NULL) && (area->top_of_renaming_stack == NULL) && (previous_bb->phi_argument_has_real_use == FALSE)) {
-				if (TRACE_SSAPRE) {
-					printf ("Clearing down safe in PHI %d because of backtracking (previous block is [bb %d [ID %d]])\n",
-							area->bb_on_top_of_renaming_stack->phi_redundancy_class, previous_bb->cfg_dfn, previous_bb->bb->block_num);
+		if (previous_bb != NULL) {
+			if (! dominates (previous_bb, current_bb)) {
+				/* This means we are backtracking in the dominator tree */
+				MonoSsapreBBInfo *first_interesting_dominator = current_bb->idominator;
+				while ((first_interesting_dominator->next_interesting_bb == NULL) && (first_interesting_dominator->idominator != NULL)) {
+					first_interesting_dominator = first_interesting_dominator->idominator;
 				}
-				area->bb_on_top_of_renaming_stack->phi_is_down_safe = FALSE;
-			}
-			while ((area->bb_on_top_of_renaming_stack != NULL) && ! dominates (area->bb_on_top_of_renaming_stack, current_bb)) {
-				MonoSsapreBBInfo *top_bb = area->bb_on_top_of_renaming_stack;
-				if (top_bb->next_in_renaming_stack != NULL) {
-					area->top_of_renaming_stack = top_bb->next_in_renaming_stack->top_of_local_renaming_stack;
-				} else {
-					area->top_of_renaming_stack = NULL;
+				current_bb->phi_argument_has_real_use = first_interesting_dominator->phi_argument_has_real_use;
+				
+				if ((area->bb_on_top_of_renaming_stack != NULL) && (area->top_of_renaming_stack == NULL) && (previous_bb->phi_argument_has_real_use == FALSE)) {
+					if (TRACE_SSAPRE) {
+						printf ("Clearing down safe in PHI %d because of backtracking (current block is [bb %d [ID %d]], previous block is [bb %d [ID %d]])\n",
+								area->bb_on_top_of_renaming_stack->phi_redundancy_class, current_bb->cfg_dfn, current_bb->bb->block_num, previous_bb->cfg_dfn, previous_bb->bb->block_num);
+					}
+					area->bb_on_top_of_renaming_stack->phi_is_down_safe = FALSE;
 				}
-				area->bb_on_top_of_renaming_stack = top_bb->next_in_renaming_stack;
+				while ((area->bb_on_top_of_renaming_stack != NULL) && ! dominates (area->bb_on_top_of_renaming_stack, current_bb)) {
+					MonoSsapreBBInfo *top_bb = area->bb_on_top_of_renaming_stack;
+					if (top_bb->next_in_renaming_stack != NULL) {
+						area->top_of_renaming_stack = top_bb->next_in_renaming_stack->top_of_local_renaming_stack;
+					} else {
+						area->top_of_renaming_stack = NULL;
+					}
+					area->bb_on_top_of_renaming_stack = top_bb->next_in_renaming_stack;
+				}
+				if (DUMP_SSAPRE) {
+					printf ("Backtracked, getting real use flag from bb %d [ID %d], current top of the stack is class ",
+							first_interesting_dominator->cfg_dfn, first_interesting_dominator->bb->block_num);
+					if (area->top_of_renaming_stack != NULL) {
+						printf ("%d\n", area->top_of_renaming_stack->redundancy_class);
+					} else if (area->bb_on_top_of_renaming_stack != NULL) {
+						printf ("%d\n", area->bb_on_top_of_renaming_stack->phi_redundancy_class);
+					} else {
+						printf ("BOTTOM\n");
+					}
+				}
+			} else {
+				/* With no backtracking we just propagate the flag */
+				current_bb->phi_argument_has_real_use = previous_bb->phi_argument_has_real_use;
 			}
-		}
-		if (current_bb->idominator != NULL) {
-			current_bb->phi_argument_has_real_use = current_bb->idominator->phi_argument_has_real_use;
 		} else {
+			/* Start condition */
 			current_bb->phi_argument_has_real_use = FALSE;
 		}
+		if (DUMP_SSAPRE) {
+			printf ("Real use flag is %s at the beginning of block [bb %d [ID %d]]\n",
+					GBOOLEAN_TO_STRING (current_bb->phi_argument_has_real_use), current_bb->cfg_dfn, current_bb->bb->block_num);
+		}
 		
 		if (current_bb->has_phi) {
 			current_bb->phi_is_down_safe = TRUE;
 			current_bb->phi_redundancy_class = current_class;
 			current_class++;
 			PUSH_PHI_OCCURRENCE (current_bb);
+			if (TRACE_SSAPRE) {
+				printf ("Assigning class %d to PHI in bb %d [ID %d]\n",
+						current_bb->phi_redundancy_class, current_bb->dt_dfn, current_bb->bb->block_num);
+			}
 		}
 		
 	 	for (current_expression = current_bb->first_expression_in_bb; (current_expression != NULL) && (current_expression->bb_info == current_bb); current_expression = current_expression->next) {
@@ -1024,11 +1169,21 @@
 						(current_expression->description.right_argument.argument.ssa_variable == top->description.right_argument.argument.ssa_variable))) {
 					current_expression->redundancy_class = top->redundancy_class;
 					current_expression->defined_by_real_occurrence = top;
+					if (DUMP_SSAPRE) {
+						printf ("Using class %d for occurrence '", current_expression->redundancy_class);
+						print_expression_description (&(current_expression->description));
+						printf ("' in bb %d [ID %d]\n", current_bb->dt_dfn, current_bb->bb->block_num);
+					}
 				} else {
 					current_expression->redundancy_class = current_class;
 					current_class++;
 					current_expression->defined_by_real_occurrence = NULL;
 					PUSH_REAL_OCCURRENCE (current_expression);
+					if (TRACE_SSAPRE) {
+						printf ("Assigning class %d to occurrence '", current_expression->redundancy_class);
+						print_expression_description (&(current_expression->description));
+						printf ("' in bb %d [ID %d]\n", current_bb->dt_dfn, current_bb->bb->block_num);
+					}
 				}
 				current_expression->defined_by_phi = NULL;
 			} else if (area->bb_on_top_of_renaming_stack != NULL) {
@@ -1076,6 +1231,11 @@
 									right_argument_version, phi_bb, phi_argument);
 						}
 					}
+					if (DUMP_SSAPRE) {
+						printf ("Using class %d for occurrence '", current_expression->redundancy_class);
+						print_expression_description (&(current_expression->description));
+						printf ("' in bb %d [ID %d] (Real use flag is now TRUE)\n", current_bb->cfg_dfn, current_bb->bb->block_num);
+					}
 				} else {
 					current_expression->redundancy_class = current_class;
 					current_class++;
@@ -1083,6 +1243,9 @@
 					PUSH_REAL_OCCURRENCE (current_expression);
 					phi_bb->phi_is_down_safe = FALSE;
 					if (TRACE_SSAPRE) {
+						printf ("Assigning class %d to occurrence '", current_expression->redundancy_class);
+						print_expression_description (&(current_expression->description));
+						printf ("' in bb %d [ID %d]\n", current_bb->dt_dfn, current_bb->bb->block_num);
 						printf ("Clearing down safe in PHI %d because of real occurrence %d\n",
 								phi_bb->phi_redundancy_class, current_expression->redundancy_class);
 					}
@@ -1094,6 +1257,11 @@
 				current_expression->defined_by_real_occurrence = NULL;
 				current_expression->defined_by_phi = NULL;
 				PUSH_REAL_OCCURRENCE (current_expression);
+				if (TRACE_SSAPRE) {
+					printf ("Assigning class %d to occurrence '", current_expression->redundancy_class);
+					print_expression_description (&(current_expression->description));
+					printf ("' in bb %d [ID %d]\n", current_bb->dt_dfn, current_bb->bb->block_num);
+				}
 			}
 		}
 		
@@ -1107,6 +1275,10 @@
 			} else {
 				current_bb->phi_argument_class = BOTTOM_REDUNDANCY_CLASS;
 			}
+			if ((DUMP_SSAPRE) && (current_bb->phi_argument_class != BOTTOM_REDUNDANCY_CLASS)) {
+				printf ("Temporarily using class %d for PHI argument in bb %d [ID %d]\n",
+						current_bb->phi_argument_class, current_bb->cfg_dfn, current_bb->bb->block_num);
+			}
 		}
 	}
 	if ((area->bb_on_top_of_renaming_stack != NULL) && (area->top_of_renaming_stack == NULL) && (previous_bb->phi_argument_has_real_use == FALSE)) {
@@ -1161,6 +1333,11 @@
 					current_bb->phi_argument_defined_by_phi->phi_is_down_safe = FALSE;
 				}
 				current_bb->phi_argument_has_real_use = FALSE;
+				
+				if (DUMP_SSAPRE) {
+					printf ("Cleared real use flag in block [bb %d [ID %d]] because phi argument class is now BOTTOM\n",
+							current_bb->cfg_dfn, current_bb->bb->block_num);
+				}
 			}
 		}
 	}
@@ -1187,9 +1364,6 @@
 	if ((phi_argument->phi_argument_class != BOTTOM_REDUNDANCY_CLASS) && (! phi_argument->phi_argument_has_real_use) && (phi_argument->phi_argument_defined_by_phi != NULL) && (phi_argument->phi_argument_defined_by_phi->phi_is_down_safe)) {
 		int i;
 		MonoSsapreBBInfo *phi = phi_argument->phi_argument_defined_by_phi;
-//		if (TRACE_SSAPRE) {
-//			printf ("Clearing down safe in PHI %d inside reset_down_safe\n", phi->phi_redundancy_class);
-//		}
 		phi->phi_is_down_safe = FALSE;
 		for (i = 0; i < phi->in_count; i++) {
 			reset_down_safe (phi->in_bb [i]);
@@ -1531,16 +1705,48 @@
 }
 
 /*
+ * Handles the father expression of a MonoInst that has been turned
+ * into a load (eventually inserting it into the worklist).
+ * Assumes "current_expression->father_in_tree != NULL".
+ */
+static void
+handle_father_expression (MonoSsapreWorkArea *area, MonoSsapreExpressionOccurrence *current_expression, MonoInst *previous_tree) {
+	if (DUMP_SSAPRE) {
+		printf ("After reload, father expression becomes ");
+		mono_print_tree_nl (current_expression->father_in_tree->father_occurrence);
+	}
+	
+	analyze_expression (current_expression->father_in_tree->father_occurrence, &(area->current_occurrence->description));
+	if ((area->current_occurrence->description.opcode != 0) &&
+			(area->current_occurrence->description.left_argument.type != MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY) &&
+			(area->current_occurrence->description.right_argument.type != MONO_SSAPRE_EXPRESSION_ARGUMENT_ANY)) {
+		area->current_occurrence->occurrence = current_expression->father_in_tree->father_occurrence;
+		area->current_occurrence->previous_tree = previous_tree;
+		area->current_occurrence->father_in_tree = current_expression->father_in_tree->grand_father;
+		area->current_occurrence->bb_info = current_expression->bb_info;
+		area->current_occurrence->is_first_in_bb = FALSE;
+		area->current_occurrence->is_last_in_bb = FALSE;
+		add_occurrence_to_worklist (area);
+	}
+}
+
+/*
  * See paper, section 3.6
  */
 static void code_motion (MonoSsapreWorkArea *area) {
 	MonoSsapreBBInfo *current_bb = NULL;
 	MonoSsapreExpressionOccurrence *current_expression = NULL;
+	gssize original_variable_index = BOTTOM_REDUNDANCY_CLASS;
 	
 	for (current_bb = area->first_interesting_bb; current_bb != NULL; current_bb = current_bb->next_interesting_bb) {	
 		if ((current_bb->has_phi) && (current_bb->phi_can_be_available && ! current_bb->phi_is_later)) {
 			MonoInst *new_var = mono_compile_create_var (area->cfg, area->current_expression->type, OP_LOCAL);
 			current_bb->phi_variable_index = new_var->inst_c0;
+			if (original_variable_index == BOTTOM_REDUNDANCY_CLASS) {
+				original_variable_index = new_var->inst_c0;
+			}
+			area->cfg->vars [new_var->inst_c0]->reg = original_variable_index;
+			area->cfg->vars [new_var->inst_c0]->def_bb = current_bb->bb;
 		} else {
 			current_bb->phi_variable_index = BOTTOM_REDUNDANCY_CLASS;
 		}
@@ -1549,6 +1755,11 @@
 	 		if (current_expression->save) {
 				MonoInst *new_var = mono_compile_create_var (area->cfg, area->current_expression->type, OP_LOCAL);
 				current_expression->variable_index = new_var->inst_c0;
+				if (original_variable_index == BOTTOM_REDUNDANCY_CLASS) {
+					original_variable_index = new_var->inst_c0;
+				}
+				area->cfg->vars [new_var->inst_c0]->reg = original_variable_index;
+				area->cfg->vars [new_var->inst_c0]->def_bb = current_bb->bb;
 	 		} else {
 				current_expression->variable_index = BOTTOM_REDUNDANCY_CLASS;
 	 		}
@@ -1557,6 +1768,11 @@
 		if ((current_bb->has_phi_argument) && (current_bb->phi_argument_needs_insert)) {
 			MonoInst *new_var = mono_compile_create_var (area->cfg, area->current_expression->type, OP_LOCAL);
 			current_bb->phi_argument_variable_index = new_var->inst_c0;
+			if (original_variable_index == BOTTOM_REDUNDANCY_CLASS) {
+				original_variable_index = new_var->inst_c0;
+			}
+			area->cfg->vars [new_var->inst_c0]->reg = original_variable_index;
+			area->cfg->vars [new_var->inst_c0]->def_bb = current_bb->bb;
 		} else {
 			current_bb->phi_argument_variable_index = BOTTOM_REDUNDANCY_CLASS;
 		}
@@ -1569,6 +1785,7 @@
 			int in_bb;
 			
 			NEW_INST (phi, OP_PHI);
+			phi->inst_c0 = area->cfg->vars [current_bb->phi_variable_index]->reg;
 			phi->inst_phi_args = mono_mempool_alloc (area->cfg->mempool, (sizeof (int) * ((current_bb->in_count) + 1)));
 			phi->inst_phi_args [0] = current_bb->in_count;
 			for (in_bb = 0; in_bb < current_bb->in_count; in_bb++) {
@@ -1600,21 +1817,6 @@
 		
 	 	for (current_expression = current_bb->first_expression_in_bb; (current_expression != NULL) && (current_expression->bb_info == current_bb); current_expression = current_expression->next) {
 	 		gboolean altered = FALSE;
-	 		if (current_expression->reload) {
-	 			gssize variable_index;
-	 			if (current_expression->defined_by_phi != NULL) {
-	 				variable_index = current_expression->defined_by_phi->phi_variable_index;
-	 			} else if (current_expression->defined_by_real_occurrence != NULL) {
-	 				variable_index = current_expression->defined_by_real_occurrence->variable_index;
-	 			} else {
-	 				variable_index = BOTTOM_REDUNDANCY_CLASS;
-	 				g_assert_not_reached ();
-	 			}
-	 			mono_compile_make_var_load (area->cfg, current_expression->occurrence, variable_index);
-	 			
-	 			area->reloaded_occurrences ++;
-	 			altered = TRUE;
-	 		}
 	 		if (current_expression->save) {
 	 			MonoInst *store;
 	 			MonoInst *moved_expression = mono_mempool_alloc (area->cfg->mempool, sizeof (MonoInst));
@@ -1628,10 +1830,31 @@
 		 			current_bb->bb->code = store;
 	 			}
 	 			mono_compile_make_var_load (area->cfg, current_expression->occurrence, current_expression->variable_index);
-	 			
+				if (current_expression->father_in_tree != NULL) {
+					handle_father_expression (area, current_expression, store);
+				}
+				
 	 			area->saved_occurrences ++;
 	 			altered = TRUE;
 	 		}
+	 		if (current_expression->reload) {
+	 			gssize variable_index;
+	 			if (current_expression->defined_by_phi != NULL) {
+	 				variable_index = current_expression->defined_by_phi->phi_variable_index;
+	 			} else if (current_expression->defined_by_real_occurrence != NULL) {
+	 				variable_index = current_expression->defined_by_real_occurrence->variable_index;
+	 			} else {
+	 				variable_index = BOTTOM_REDUNDANCY_CLASS;
+	 				g_assert_not_reached ();
+	 			}
+	 			mono_compile_make_var_load (area->cfg, current_expression->occurrence, variable_index);
+				if (current_expression->father_in_tree != NULL) {
+					handle_father_expression (area, current_expression, current_expression->previous_tree);
+				}
+				
+	 			area->reloaded_occurrences ++;
+	 			altered = TRUE;
+	 		}
 	 		if (! altered) {
 	 			area->unaltered_occurrences ++;
 	 		}
@@ -1663,11 +1886,13 @@
 }
 
 /*
- * Perform all SSAPRE steps for an expression
+ * Perform all SSAPRE steps for the current expression
  */
 static void
-process_expression (MonoSsapreWorkArea *area, MonoSsapreExpression *expression) {
-	if (area->cfg->verbose_level >= TRACE_LEVEL) {
+process_expression (MonoSsapreWorkArea *area) {
+	MonoSsapreExpression *expression = area->current_expression;
+	
+	if (area->cfg->verbose_level >= STATISTICS_LEVEL) {
 		printf ("SSAPRE STARTS PROCESSING EXPRESSION ");
 		print_expression_description (&(expression->description));
 		printf ("\n");
@@ -1713,24 +1938,9 @@
 	}
 }
 
-/*
- * Perform all SSAPRE steps for all the expressions in the worklist
- */
-static void
-process_worklist (MonoSsapreWorkArea *area, MonoSsapreExpression *expression) {
-	if (expression != NULL) {
-		process_worklist (area, expression->previous);
-		process_expression (area, expression);
-		process_worklist (area, expression->next);
-	}
-}
-
-/*
- * Hack to apply SSAPRE only to a given method (invaluable in debugging)
- */
-#define APPLY_SSAPRE_TO_SINGLE_METHOD 0
-#if (APPLY_SSAPRE_TO_SINGLE_METHOD)
-static char *mono_ssapre_method_name = NULL;
+#if (MONO_APPLY_SSAPRE_TO_SINGLE_METHOD)
+static char*
+mono_ssapre_method_name = NULL;
 static gboolean check_ssapre_method_name (MonoCompile *cfg) {
 	if (mono_ssapre_method_name == NULL) {
 		mono_ssapre_method_name = getenv ("MONO_SSAPRE_METHOD_NAME");
@@ -1754,12 +1964,14 @@
 void
 mono_perform_ssapre (MonoCompile *cfg) {
 	MonoSsapreWorkArea area;
-	MonoSsapreExpressionOccurrence *current_occurrence;
 	int dt_dfn, descendants, block, i;
 	
-#if (APPLY_SSAPRE_TO_SINGLE_METHOD)
+#if (MONO_APPLY_SSAPRE_TO_SINGLE_METHOD)
 	if (! check_ssapre_method_name (cfg)) return;
 #endif
+#if (MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION)
+	area.expression_is_handled_father = FALSE;
+#endif
 	
 	area.cfg = cfg;
 	area.mempool = mono_mempool_new ();
@@ -1781,10 +1993,12 @@
 		printf ("SSAPRE STARTS PROCESSING METHOD %s\n", mono_method_full_name (cfg->method, TRUE));
 	}
 	
-	current_occurrence = (MonoSsapreExpressionOccurrence*) mono_mempool_alloc (area.mempool, sizeof (MonoSsapreExpressionOccurrence));
+	area.first_in_queue = NULL;
+	area.last_in_queue = NULL;
+	area.current_occurrence = (MonoSsapreExpressionOccurrence*) mono_mempool_alloc (area.mempool, sizeof (MonoSsapreExpressionOccurrence));
 	dt_dfn = 0;
 	descendants = 0;
-	process_bb (&area, cfg->bblocks [0], &dt_dfn, &descendants, current_occurrence);
+	process_bb (&area, cfg->bblocks [0], &dt_dfn, &descendants);
 	for (block = 0; block < area.num_bblocks; block++) {
 		MonoSsapreBBInfo *bb_info = &(area.bb_infos [block]);
 		MonoBasicBlock *bb = bb_info->bb;
@@ -1807,7 +2021,12 @@
 		printf ("SSAPRE END WORKLIST\n");
 	}
 	
-	process_worklist (&area, area.worklist);
+#if (MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION)
+	area.expression_is_handled_father = TRUE;
+#endif
+	for (area.current_expression = area.first_in_queue; area.current_expression != NULL; area.current_expression = area.current_expression->next_in_queue) {
+		process_expression (&area);		
+	}
 	
 	if (area.cfg->verbose_level >= TRACE_LEVEL) {
 		printf ("SSAPRE ENDS PROCESSING METHOD %s\n", mono_method_full_name (cfg->method, TRUE));
Index: mono/mono/mini/ssapre.h
===================================================================
--- mono/mono/mini/ssapre.h	(revision 38026)
+++ mono/mono/mini/ssapre.h	(working copy)
@@ -15,6 +15,16 @@
 #include <mono/metadata/mempool.h>
 
 /*
+ * Hack to apply SSAPRE only to a given method (invaluable in debugging)
+ */
+#define MONO_APPLY_SSAPRE_TO_SINGLE_METHOD 0
+
+/*
+ * Hack to apply SSAPRE only to a given expression (invaluable in debugging)
+ */
+#define MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION 0
+
+/*
  * All the different kind of arguments we can handle.
  * "ANY" means the argument is unknown or cannot be handled, and "NOT_PRESENT"
  * that the expression does not have this argument (has not "enough" arity).
@@ -184,11 +194,25 @@
 
 
 /*
+ * The father of an occurrence in the tree of MonoInst.
+ * (needed just because a MonoInst cannot point to its father)
+ */
+typedef struct MonoSsapreFatherExpression {
+	/* The father occurrence */
+	MonoInst *father_occurrence;
+	/* The MonoSsapreFatherExpression node of the "grand father" */
+	struct MonoSsapreFatherExpression *grand_father;
+} MonoSsapreFatherExpression;
+
+/*
  * A "real" occurrence.
  */
 typedef struct MonoSsapreExpressionOccurrence {
 	/* The occurrence in the CFG */
 	MonoInst *occurrence;
+	/* The "father" of this occurrence in the inst tree (if the occurrence is */
+	/* part of a compound expression, otherwise it is NULL) */
+	MonoSsapreFatherExpression *father_in_tree;
 	/* The tree just before the occurrence in the CFG (if the occurrence must */
 	/* saved into a temporary, the definition will be placed just after that tree) */
 	MonoInst *previous_tree;
@@ -198,7 +222,7 @@
 	MonoSsapreExpressionDescription description;
 	/* Next occurrence of this expression */
 	struct MonoSsapreExpressionOccurrence *next;
-	/* Previois occurrence of this expression */
+	/* Previous occurrence of this expression */
 	struct MonoSsapreExpressionOccurrence *previous;
 	/* True if this occurrence is the first in its BB */
 	gboolean is_first_in_bb;
@@ -241,6 +265,9 @@
 	struct MonoSsapreExpression *previous;
 	struct MonoSsapreExpression *next;
 	gssize tree_size;
+	
+	/* Next expression to be processed in the worklist */
+	struct MonoSsapreExpression *next_in_queue;	
 } MonoSsapreExpression;
 
 /*
@@ -340,8 +367,15 @@
 	/* The expression worklist */
 	MonoSsapreExpression *worklist;
 	
+	/* The expression queue head */
+	MonoSsapreExpression *first_in_queue;
+	/* The expression queue tail */
+	MonoSsapreExpression *last_in_queue;
+	
 	/* The expression being processed */
 	MonoSsapreExpression *current_expression;
+	/* The expression being allocated */
+	MonoSsapreExpressionOccurrence *current_occurrence;
 	
 	/* The BB on top of the renaming stack (if "top_of_renaming_stack" is NULL */
 	/* but this is not, then the top of the stack is the PHI in this BB) */
@@ -361,6 +395,10 @@
 	int inserted_occurrences;
 	int unaltered_occurrences;
 	int added_phis;
+	
+#if (MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION)
+	gboolean expression_is_handled_father;
+#endif
 } MonoSsapreWorkArea;
 
 
