Index: samples/embed/teste.c
===================================================================
--- samples/embed/teste.c	(revision 42142)
+++ samples/embed/teste.c	(working copy)
@@ -1,5 +1,6 @@
 #include <mono/jit/jit.h>
 #include <mono/metadata/environment.h>
+#include <stdlib.h>
 
 /*
  * Very simple mono embedding example.
Index: samples/embed/test-invoke.c
===================================================================
--- samples/embed/test-invoke.c	(revision 42142)
+++ samples/embed/test-invoke.c	(working copy)
@@ -1,4 +1,5 @@
 #include <mono/jit/jit.h>
+#include <mono/metadata/object.h>
 #include <mono/metadata/environment.h>
 #include <mono/metadata/assembly.h>
 #include <mono/metadata/debug-helpers.h>
Index: mono/dis/dump.c
===================================================================
--- mono/dis/dump.c	(revision 42142)
+++ mono/dis/dump.c	(working copy)
@@ -17,6 +17,7 @@
 #include "get.h"
 #include "mono/metadata/loader.h"
 #include "mono/metadata/class.h"
+#include "mono/utils/mono-compiler.h"
 
 #ifdef HAVE_IEEEFP_H
 extern int isinf (double);
Index: mono/dis/dis-cil.c
===================================================================
--- mono/dis/dis-cil.c	(revision 42142)
+++ mono/dis/dis-cil.c	(working copy)
@@ -18,6 +18,7 @@
 #include "dump.h"
 #include "dis-cil.h"
 #include "mono/metadata/opcodes.h"
+#include "mono/utils/mono-compiler.h"
 
 #ifdef HAVE_IEEEFP_H
 #include <ieeefp.h>
Index: mono/metadata/domain.c
===================================================================
--- mono/metadata/domain.c	(revision 42142)
+++ mono/metadata/domain.c	(working copy)
@@ -682,7 +682,7 @@
  *
  * Returns: the current domain.
  */
-inline MonoDomain *
+MonoDomain *
 mono_domain_get ()
 {
 	return GET_APPDOMAIN ();
@@ -694,7 +694,7 @@
  *
  * Sets the current domain to @domain.
  */
-inline void
+void
 mono_domain_set_internal (MonoDomain *domain)
 {
 	SET_APPDOMAIN (domain);
Index: mono/metadata/appdomain.c
===================================================================
--- mono/metadata/appdomain.c	(revision 42142)
+++ mono/metadata/appdomain.c	(working copy)
@@ -1373,7 +1373,7 @@
 #if 0
 	thread_handle = CreateThread (NULL, 0, unload_thread_main, &thread_data, 0, &tid);
 #else
-	thread_handle = CreateThread (NULL, 0, unload_thread_main, &thread_data, CREATE_SUSPENDED, &tid);
+	thread_handle = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)unload_thread_main, &thread_data, CREATE_SUSPENDED, &tid);
 	ResumeThread (thread_handle);
 #endif
 
Index: mono/metadata/appdomain.h
===================================================================
--- mono/metadata/appdomain.h	(revision 42142)
+++ mono/metadata/appdomain.h	(working copy)
@@ -16,6 +16,12 @@
 #include <mono/metadata/reflection.h>
 #include <mono/metadata/mempool.h>
 
+#ifdef _MSC_VER
+#define MONO_INLINE
+#else
+#define MONO_INLINE	inline
+#endif
+
 typedef void (*MonoThreadStartCB) (guint32 tid, gpointer stack_start,
 				   gpointer func);
 typedef void (*MonoThreadAttachCB) (guint32 tid, gpointer stack_start);
@@ -59,19 +65,19 @@
 MonoDomain *
 mono_domain_create         (void);
 
-inline MonoDomain *
+MONO_INLINE MonoDomain *
 mono_domain_get            (void);
 
-inline MonoDomain *
+MONO_INLINE MonoDomain *
 mono_domain_get_by_id      (gint32 domainid);
 
 gint32
 mono_domain_get_id         (MonoDomain *domain);
 
-inline gboolean
+MONO_INLINE gboolean
 mono_domain_set            (MonoDomain *domain, gboolean force);
 
-inline void
+MONO_INLINE void
 mono_domain_set_internal   (MonoDomain *domain);
 
 gboolean
@@ -101,10 +107,10 @@
 void
 mono_context_init 				   (MonoDomain *domain);
 
-inline void 
+MONO_INLINE void 
 mono_context_set				   (MonoAppContext *new_context);
 
-inline MonoAppContext * 
+MONO_INLINE MonoAppContext * 
 mono_context_get				   (void);
 
 MonoJitInfo *
Index: mono/metadata/assembly.c
===================================================================
--- mono/metadata/assembly.c	(revision 42142)
+++ mono/metadata/assembly.c	(working copy)
@@ -28,7 +28,11 @@
 #include <mono/utils/mono-logger.h>
 #ifdef PLATFORM_WIN32
 #include <mono/os/util.h>
+#ifdef _MSC_VER
+	/* not used on Windows - see mono_set_rootdir () */
+	#define MONO_ASSEMBLIES		NULL
 #endif
+#endif
 
 /* AssemblyVersionMap: an assembly name and the assembly version set on which it is based */
 typedef struct  {
Index: mono/metadata/sysmath.c
===================================================================
--- mono/metadata/sysmath.c	(revision 42142)
+++ mono/metadata/sysmath.c	(working copy)
@@ -4,6 +4,7 @@
 #include <math.h>
 #include <mono/metadata/sysmath.h>
 #include <mono/metadata/exception.h>
+#include <mono/utils/mono-compiler.h>
 
 #ifndef NAN
 # if G_BYTE_ORDER == G_BIG_ENDIAN
Index: mono/metadata/threads.c
===================================================================
--- mono/metadata/threads.c	(revision 42142)
+++ mono/metadata/threads.c	(working copy)
@@ -222,7 +222,7 @@
 		mono_thread_cleanup (thread);
 }
 
-static guint32 start_wrapper(void *data)
+static guint32 WINAPI start_wrapper(void *data)
 {
 	struct StartInfo *start_info=(struct StartInfo *)data;
 	guint32 (*start_func)(void *);
@@ -359,7 +359,7 @@
 	/* Create suspended, so we can do some housekeeping before the thread
 	 * starts
 	 */
-	thread_handle = CreateThread(NULL, default_stacksize_for_thread (thread), start_wrapper, start_info,
+	thread_handle = CreateThread(NULL, default_stacksize_for_thread (thread), (LPTHREAD_START_ROUTINE)start_wrapper, start_info,
 				     CREATE_SUSPENDED, &tid);
 	THREAD_DEBUG (g_message (G_GNUC_PRETTY_FUNCTION ": Started thread ID %d (handle %p)",
 		  tid, thread_handle));
@@ -510,7 +510,7 @@
 			return(NULL);
 		}
 
-		thread=CreateThread(NULL, default_stacksize_for_thread (this), start_wrapper, start_info,
+		thread=CreateThread(NULL, default_stacksize_for_thread (this), (LPTHREAD_START_ROUTINE)start_wrapper, start_info,
 				    CREATE_SUSPENDED, &tid);
 		if(thread==NULL) {
 			g_warning(G_GNUC_PRETTY_FUNCTION
@@ -1293,7 +1293,7 @@
 int  
 mono_thread_get_abort_signal (void)
 {
-#ifdef __MINGW32__
+#if defined (__MINGW32__) || defined (_MSC_VER)
 	return -1;
 #else
 #ifndef	SIGRTMIN
@@ -1301,17 +1301,16 @@
 #else
 	return SIGRTMIN;
 #endif
-#endif /* __MINGW32__ */
+#endif /*defined (__MINGW32__) || defined (_MSC_VER) */
 }
 
-#ifdef __MINGW32__
-static CALLBACK void interruption_request_apc (ULONG_PTR param)
+#if defined (__MINGW32__) || defined (_MSC_VER)
+static void CALLBACK interruption_request_apc (ULONG_PTR param)
 {
 	MonoException* exc = mono_thread_request_interruption (FALSE);
 	if (exc) mono_raise_exception (exc);
-	return 0;
 }
-#endif /* __MINGW32__ */
+#endif /* defined (__MINGW32__) || defined (_MSC_VER) */
 
 /*
  * signal_thread_state_change
@@ -1328,8 +1327,8 @@
 			mono_raise_exception (exc);
 	}
 
-#ifdef __MINGW32__
-	QueueUserAPC (interruption_request_apc, thread->handle, NULL);
+#if defined (__MINGW32__) || defined (_MSC_VER)
+	QueueUserAPC ((PAPCFUNC)interruption_request_apc, thread->handle, NULL);
 #else
 	/* fixme: store the state somewhere */
 #ifdef PTHREAD_POINTER_ID
@@ -1337,7 +1336,7 @@
 #else
 	pthread_kill (thread->tid, mono_thread_get_abort_signal ());
 #endif
-#endif /* __MINGW32__ */
+#endif /* defined (__MINGW32__) || defined (__MSC_VER) */
 }
 
 void
@@ -2331,7 +2330,7 @@
 		
 		/* this will awake the thread if it is in WaitForSingleObject 
 	       or similar */
-		QueueUserAPC (dummy_apc, thread->handle, NULL);
+		QueueUserAPC ((PAPCFUNC)dummy_apc, thread->handle, NULL);
 		
 		return NULL;
 	}
Index: mono/metadata/sysmath.h
===================================================================
--- mono/metadata/sysmath.h	(revision 42142)
+++ mono/metadata/sysmath.h	(working copy)
@@ -12,6 +12,7 @@
 
 #include <config.h>
 #include <glib.h>
+#include "mono/utils/mono-compiler.h"
 
 extern gdouble ves_icall_System_Math_Floor (gdouble x);
 extern gdouble ves_icall_System_Math_Round (gdouble x);
Index: mono/metadata/rawbuffer.c
===================================================================
--- mono/metadata/rawbuffer.c	(revision 42142)
+++ mono/metadata/rawbuffer.c	(working copy)
@@ -14,6 +14,7 @@
 #include <unistd.h>
 #include <errno.h>
 #ifdef USE_WIN32_API
+#include <winsock2.h>
 #include <windows.h>
 #include <io.h>
 #else
Index: mono/metadata/mono-config.c
===================================================================
--- mono/metadata/mono-config.c	(revision 42142)
+++ mono/metadata/mono-config.c	(working copy)
@@ -10,6 +10,8 @@
 #include "config.h"
 #include <glib.h>
 #include <string.h>
+
+#include "mono/metadata/assembly.h"
 #include "mono/metadata/loader.h"
 #include "mono/metadata/mono-config.h"
 #include "mono/metadata/metadata-internals.h"
@@ -344,9 +346,11 @@
 void
 mono_config_parse (const char *filename) {
 	const char *home;
+	char *mono_cfg;
+#ifndef PLATFORM_WIN32
 	char *user_cfg;
-	char *mono_cfg;
-	
+#endif
+
 	if (filename) {
 		mono_config_parse_file (filename);
 		return;
Index: mono/metadata/icall.c
===================================================================
--- mono/metadata/icall.c	(revision 42142)
+++ mono/metadata/icall.c	(working copy)
@@ -5488,7 +5488,7 @@
 ves_icall_System_Diagnostics_DefaultTraceListener_WriteWindowsDebugString (MonoString *message)
 {
 #if defined (PLATFORM_WIN32)
-	static void (*output_debug) (gchar *);
+	static void (*output_debug) (gunichar2 *);
 	static gboolean tried_loading = FALSE;
 
 	MONO_ARCH_SAVE_REGS;
Index: mono/metadata/rand.c
===================================================================
--- mono/metadata/rand.c	(revision 42142)
+++ mono/metadata/rand.c	(working copy)
@@ -94,6 +94,7 @@
 
 #if defined (PLATFORM_WIN32)
 
+#include <windows.h>
 #include <WinCrypt.h>
 
 #ifndef PROV_INTEL_SEC
@@ -158,13 +159,14 @@
 	if (!CryptGenRandom (provider, len, buf)) {
 		CryptReleaseContext (provider, 0);
 		/* we may have lost our context with CryptoAPI, but all hope isn't lost yet! */
-		provider = ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngInitialize (NULL);
+		provider = (HCRYPTPROV) ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngInitialize (NULL);
 		if (!CryptGenRandom (provider, len, buf)) {
 			CryptReleaseContext (provider, 0);
 			provider = 0;
 			/* exception will be thrown in managed code */
 		}
-	} 
+	}
+	return (gpointer) provider;
 }
 
 void
Index: mono/io-layer/io-layer.h
===================================================================
--- mono/io-layer/io-layer.h	(revision 42142)
+++ mono/io-layer/io-layer.h	(working copy)
@@ -16,10 +16,12 @@
 #define UNICODE
 #define _UNICODE
 #define __USE_W32_SOCKETS
-#include <w32api.h>
+#include <winsock2.h>
 #include <windows.h>
+#include <WinBase.h>
 #include <ws2tcpip.h>
 #include <psapi.h>
+#include <shlobj.h>
 #else	/* EVERYONE ELSE */
 #include "mono/io-layer/wapi.h"
 #include "mono/io-layer/uglify.h"
Index: mono/os/gc_wrapper.h
===================================================================
--- mono/os/gc_wrapper.h	(revision 42142)
+++ mono/os/gc_wrapper.h	(working copy)
@@ -5,10 +5,15 @@
 
 #ifdef HAVE_BOEHM_GC
 
-	/* libgc specifies this on the command line,
-	 * so we must define it ourselfs
-	 */
-#	define GC_GCJ_SUPPORT
+#	ifdef _MSC_VER
+#		include <winsock2.h>
+#	else
+		/* libgc specifies this on the command line,
+		 * so we must define it ourselfs
+		*/
+#		define GC_GCJ_SUPPORT
+#	endif
+
 	/*
 	 * Local allocation is only beneficial if we have __thread
 	 * We had to fix a bug with include order in libgc, so only do
Index: mono/monograph/monograph.c
===================================================================
--- mono/monograph/monograph.c	(revision 42142)
+++ mono/monograph/monograph.c	(working copy)
@@ -8,6 +8,7 @@
 #include "mono/metadata/mono-endian.h"
 #include "mono/metadata/appdomain.h" /* mono_init */
 #include "mono/metadata/debug-helpers.h"
+#include "mono/utils/mono-compiler.h"
 
 static FILE *output;
 static int include_namespace = 0;
@@ -1050,12 +1051,14 @@
 		aname = argv [i];
 	if (argc > i + 1)
 		cname = argv [i + 1];
-	if (!aname)
-		aname = "mscorlib";
+	if (aname) {
+		assembly = mono_assembly_open (aname, NULL);
+	} else {
+		assembly = mono_image_get_assembly (mono_get_corlib ());
+	}
 	if (!cname && (graphtype == GRAPH_TYPES))
 		cname = "System.Object";
 
-	assembly = mono_assembly_open (aname, NULL);
 	if (!assembly) {
 		g_print ("cannot open assembly %s\n", aname);
 		exit (1);
Index: mono/mini/mini.h
===================================================================
--- mono/mini/mini.h	(revision 42142)
+++ mono/mini/mini.h	(working copy)
@@ -15,6 +15,7 @@
 #include "mono/metadata/class-internals.h"
 #include "mono/metadata/object-internals.h"
 #include <mono/metadata/profiler-private.h>
+#include <mono/utils/mono-compiler.h>
 
 #include "mini-arch.h"
 #include "regalloc.h"
Index: mono/mini/aot.c
===================================================================
--- mono/mini/aot.c	(revision 42142)
+++ mono/mini/aot.c	(working copy)
@@ -16,6 +16,7 @@
 #ifndef PLATFORM_WIN32
 #include <sys/mman.h>
 #else
+#include <winsock2.h>
 #include <windows.h>
 #endif
 
@@ -36,6 +37,7 @@
 #include <mono/metadata/metadata-internals.h>
 #include <mono/metadata/marshal.h>
 #include <mono/utils/mono-logger.h>
+#include "mono/utils/mono-compiler.h"
 
 #include "mini.h"
 
Index: mono/mini/mini-exceptions.c
===================================================================
--- mono/mini/mini-exceptions.c	(revision 42142)
+++ mono/mini/mini-exceptions.c	(working copy)
@@ -279,11 +279,20 @@
 
 	MonoContext ctx, new_ctx;
 
+#ifdef _MSC_VER
+	unsigned int stackptr, retaddr;
+	__asm mov stackptr, ebp;
+	__asm mov eax, DWORD PTR [ebp + 4];
+	__asm mov retaddr, eax;
+	MONO_CONTEXT_SET_IP (&ctx, retaddr);
+	/* FIXME: NOT WORKING -- THIS IS __builtin_frame_address (0) NOT (1) */
+	MONO_CONTEXT_SET_BP (&ctx, stackptr);
+#else
 	mono_arch_flush_register_windows ();
 
 	MONO_CONTEXT_SET_IP (&ctx, __builtin_return_address (0));
 	MONO_CONTEXT_SET_BP (&ctx, __builtin_frame_address (1));
-
+#endif
 	while (MONO_CONTEXT_GET_BP (&ctx) < jit_tls->end_of_stack) {
 		
 		ji = mono_find_jit_info (domain, jit_tls, &rji, NULL, &ctx, &new_ctx, NULL, &lmf, &native_offset, &managed);
@@ -312,11 +321,18 @@
 	MonoLMF *lmf = jit_tls->lmf;
 	MonoJitInfo *ji, rji;
 	MonoContext ctx, new_ctx;
+	unsigned int stackptr;
 
 	mono_arch_flush_register_windows ();
 
+#ifdef _MSC_VER
+	__asm mov stackptr, ebp;
+#else
+	stackptr = (unsigned int) __builtin_frame_address (0);
+#endif
+
 	MONO_CONTEXT_SET_IP (&ctx, ves_icall_get_frame_info);
-	MONO_CONTEXT_SET_BP (&ctx, __builtin_frame_address (0));
+	MONO_CONTEXT_SET_BP (&ctx, stackptr);
 
 	skip++;
 
@@ -406,7 +422,16 @@
 	MonoFrameSecurityInfo si;
 	MonoContext ctx;
 
+#ifdef _MSC_VER
+	/* seems that MSC doesn't like having __asm in macros */
+	unsigned int stackptr;
+	mono_arch_flush_register_windows ();
+	__asm mov stackptr, ebp;
+	MONO_CONTEXT_SET_IP (&ctx, ves_icall_System_Security_SecurityFrame_GetSecurityFrame);
+	MONO_CONTEXT_SET_BP (&ctx, stackptr);
+#else
 	MONO_INIT_CONTEXT_FROM_FUNC (&ctx, ves_icall_System_Security_SecurityFrame_GetSecurityFrame);
+#endif
 
 	si.skips = skip;
 	si.frame = NULL;
@@ -483,7 +508,16 @@
 	MonoContext ctx;
 	MonoArray *stack;
 
+#ifdef _MSC_VER
+	/* seems that MSC doesn't like having __asm in macros */
+	unsigned int stackptr;
+	mono_arch_flush_register_windows ();
+	__asm mov stackptr, ebp;
+	MONO_CONTEXT_SET_IP (&ctx, ves_icall_System_Security_SecurityFrame_GetSecurityStack);
+	MONO_CONTEXT_SET_BP (&ctx, stackptr);
+#else
 	MONO_INIT_CONTEXT_FROM_FUNC (&ctx, ves_icall_System_Security_SecurityFrame_GetSecurityStack);
+#endif
 
 	ss.skips = skip;
 	ss.stack = NULL;
Index: mono/mini/mini-x86.c
===================================================================
--- mono/mini/mini-x86.c	(revision 42142)
+++ mono/mini/mini-x86.c	(working copy)
@@ -91,7 +91,12 @@
 
 #define FLOAT_PARAM_REGS 0
 
+#if _MSC_VER
+/* MCS requires a value enum value */
+static X86_Reg_No param_regs [] = { X86_NREG };
+#else
 static X86_Reg_No param_regs [] = { };
+#endif
 
 #ifdef PLATFORM_WIN32
 static X86_Reg_No return_regs [] = { X86_EAX, X86_EDX };
@@ -469,6 +474,7 @@
 cpuid (int id, int* p_eax, int* p_ebx, int* p_ecx, int* p_edx)
 {
 	int have_cpuid = 0;
+#ifndef _MSC_VER
 	__asm__  __volatile__ (
 		"pushfl\n"
 		"popl %%eax\n"
@@ -485,7 +491,21 @@
 		:
 		: "%eax", "%edx"
 	);
-
+#else
+	__asm {
+		pushfd
+		pop eax
+		mov edx, eax
+		xor eax, 0x200000
+		push eax
+		popfd
+		pushfd
+		pop eax
+		xor eax, edx
+		and eax, 0x200000
+		mov have_cpuid, eax
+	}
+#endif
 	if (have_cpuid) {
 		/* Have to use the code manager to get around WinXP DEP */
 		MonoCodeManager *codeman = mono_code_manager_new_dynamic ();
@@ -516,14 +536,18 @@
 void
 mono_arch_cpu_init (void)
 {
+	/* spec compliance requires running with double precision */
+#ifndef _MSC_VER
 	guint16 fpcw;
 
-	/* spec compliance requires running with double precision */
 	__asm__  __volatile__ ("fnstcw %0\n": "=m" (fpcw));
 	fpcw &= ~X86_FPCW_PRECC_MASK;
 	fpcw |= X86_FPCW_PREC_DOUBLE;
 	__asm__  __volatile__ ("fldcw %0\n": : "m" (fpcw));
 	__asm__  __volatile__ ("fnstcw %0\n": "=m" (fpcw));
+#else
+	_control87 (_PC_64, MCW_PC);
+#endif
 }
 
 /*
Index: mono/mini/mini-x86.h
===================================================================
--- mono/mini/mini-x86.h	(revision 42142)
+++ mono/mini/mini-x86.h	(working copy)
@@ -107,8 +107,13 @@
 	guint32     eip;
 };
 
+#ifndef _MSC_VER
 typedef struct MonoCompileArch {
 } MonoCompileArch;
+#else
+/* MCS doesn't like empty struct */
+typedef void* MonoCompileArch;
+#endif
 
 #if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
 # define SC_EAX sc_eax
Index: mono/utils/mono-compiler.h
===================================================================
--- mono/utils/mono-compiler.h	(revision 42142)
+++ mono/utils/mono-compiler.h	(working copy)
@@ -31,5 +31,25 @@
 
 #endif
 
+/* Deal with Microsoft C compiler differences */
+#ifdef _MSC_VER
+
+#include <float.h>
+#define isnan(x)	_isnan(x)
+#define trunc(x)	((int)(x))
+#define isinf(x)	(_isnan(x) ? 0 : (_fpclass(x) == _FPCLASS_NINF) ? -1 : (_fpclass(x) == _FPCLASS_PINF) ? 1 : 0)
+
+#define popen		_popen
+#define pclose		_pclose
+
+#include <direct.h>
+#define mkdir(x)	_mkdir(x)
+
+/* GCC specific functions aren't available */
+#define __builtin_return_address(x)	NULL
+
+#endif /* _MSC_VER */
+
+
 #endif /* __UTILS_MONO_COMPILER_H__*/
 
