Index: mono/mono/metadata/ChangeLog
===================================================================
--- mono/mono/metadata/ChangeLog	(revision 65453)
+++ mono/mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2006-09-15  Jonathan Chambers  <joncham@gmail.com>
+
+	* marshal.c: COM Interop fixes. Handle case where method->klass.
+	is interface. Handle BSTR/MonoString when null. Use CDECL as 
+	calling convention on non-windows platforms. This is for
+	compatibility with XPCOM and MainWin COM.
+	
 2006-09-14  Zoltan Varga  <vargaz@gmail.com>
 
 	* marshal.c (emit_marshal_object): Fix marshalling of blittable classes and null.
Index: mono/mono/metadata/marshal.c
===================================================================
--- mono/mono/metadata/marshal.c	(revision 65453)
+++ mono/mono/metadata/marshal.c	(working copy)
@@ -238,8 +238,12 @@
 	// return type is always int32 (HRESULT)
 	res->ret = &mono_defaults.int32_class->byval_arg;
 
-	// com is always stdcall
+	// STDCALL on windows, CDECL everywhere else to work with XPCOM and MainWin COM
+#ifdef PLATFORM_WIN32
 	res->call_convention = MONO_CALL_STDCALL;
+#else
+	res->call_convention = MONO_CALL_C;
+#endif
 
 	return res;
 }
@@ -274,7 +278,7 @@
 	guint32 offset = 7; 
 	guint32 slot = method->slot;
 	GPtrArray *ifaces;
-	MonoClass *ic = method->klass;
+	MonoClass *ic = NULL;
 	int i;
 
 	ifaces = mono_class_get_implemented_interfaces (method->klass);
@@ -291,6 +295,12 @@
 		g_ptr_array_free (ifaces, TRUE);
 	}
 
+	if (!ic)
+		ic = method->klass;
+	
+	g_assert (ic);
+	g_assert (MONO_CLASS_IS_INTERFACE (ic));
+
 	if (!interface_type_attribute)
 		interface_type_attribute = mono_class_from_name (mono_defaults.corlib, "System.Runtime.InteropServices", "InterfaceTypeAttribute");
 	cinfo = mono_custom_attrs_from_class (ic);
@@ -318,7 +328,8 @@
 cominterop_get_method_interface (MonoMethod* method)
 {
 	GPtrArray *ifaces;
-	MonoClass *ic = method->klass;
+	MonoType* t = NULL;
+	MonoClass *ic = NULL;
 	int i;
 	MonoReflectionType* rt = NULL;
 
@@ -335,11 +346,15 @@
 		g_ptr_array_free (ifaces, TRUE);
 	}
 
-	if (ic) {
-		MonoType* t = mono_class_get_type (ic);
-		rt = mono_type_get_object (mono_domain_get(), t);
-	}
+	if (!ic)
+		ic = method->klass;
 
+	g_assert (ic);
+	g_assert (MONO_CLASS_IS_INTERFACE (ic));
+
+	t = mono_class_get_type (ic);
+	rt = mono_type_get_object (mono_domain_get(), t);
+
 	return rt;
 }
 
@@ -822,6 +837,8 @@
 mono_string_to_bstr (MonoString *string_obj)
 {
 #ifdef PLATFORM_WIN32
+	if (!string_obj)
+		return NULL;
 	return SysAllocStringLen (mono_string_chars (string_obj), mono_string_length (string_obj));
 #else
 	g_error ("UnmanagedMarshal.BStr is not implemented.");
@@ -833,6 +850,8 @@
 mono_string_from_bstr (gpointer bstr)
 {
 #ifdef PLATFORM_WIN32
+	if (!bstr)
+		return NULL;
 	MonoDomain *domain = mono_domain_get ();
 	return mono_string_new_utf16 (domain, bstr, SysStringLen (bstr));
 #else
@@ -8783,7 +8802,8 @@
 	return mono_string_to_bstr(ptr);
 }
 
-#ifdef  __i386__
+// STDCALL on windows, CDECL everywhere else to work with XPCOM and MainWin COM
+#ifdef  PLATFORM_WIN32
 #ifdef _MSC_VER
 #define STDCALL __stdcall
 #else
Index: mono/mono/tests/cominterop.cs
===================================================================
--- mono/mono/tests/cominterop.cs	(revision 65453)
+++ mono/mono/tests/cominterop.cs	(working copy)
@@ -15,8 +15,14 @@
 	public static extern int mono_test_marshal_bstr_in([MarshalAs(UnmanagedType.BStr)]string str);
 
 	[DllImport("libtest")]
-	public static extern int mono_test_marshal_bstr_out([MarshalAs(UnmanagedType.BStr)] out string str);
+    public static extern int mono_test_marshal_bstr_out([MarshalAs(UnmanagedType.BStr)] out string str);
 
+    [DllImport("libtest")]
+    public static extern int mono_test_marshal_bstr_in_null([MarshalAs(UnmanagedType.BStr)]string str);
+
+    [DllImport("libtest")]
+    public static extern int mono_test_marshal_bstr_out_null([MarshalAs(UnmanagedType.BStr)] out string str);
+
 	[DllImport("libtest")]
 	public static extern int mono_test_marshal_variant_in_sbyte([MarshalAs(UnmanagedType.Struct)]object obj);
 
@@ -103,7 +109,11 @@
 			if (mono_test_marshal_bstr_in ("mono_test_marshal_bstr_in") != 0)
 				return 1;
 			if (mono_test_marshal_bstr_out (out str) != 0 || str != "mono_test_marshal_bstr_out")
-				return 2;
+                return 2;
+            if (mono_test_marshal_bstr_in_null (null) != 0)
+                return 1;
+            if (mono_test_marshal_bstr_out_null (out str) != 0 || str != null)
+                return 2;
 
 			#endregion // BSTR Tests
 
@@ -111,49 +121,49 @@
 
 			object obj;
 			if (mono_test_marshal_variant_in_sbyte ((sbyte)100) != 0)
-				return 3;
+				return 13;
 			if (mono_test_marshal_variant_in_byte ((byte)100) != 0)
-				return 4;
+				return 14;
 			if (mono_test_marshal_variant_in_short ((short)314) != 0)
-				return 5;
+				return 15;
 			if (mono_test_marshal_variant_in_ushort ((ushort)314) != 0)
-				return 6;
+				return 16;
 			if (mono_test_marshal_variant_in_int ((int)314) != 0)
-				return 7;
+				return 17;
 			if (mono_test_marshal_variant_in_uint ((uint)314) != 0)
-				return 8;
+				return 18;
 			if (mono_test_marshal_variant_in_long ((long)314) != 0)
-				return 9;
+				return 19;
 			if (mono_test_marshal_variant_in_ulong ((ulong)314) != 0)
-				return 10;
+				return 20;
 			if (mono_test_marshal_variant_in_float ((float)3.14) != 0)
-				return 11;
+				return 21;
 			if (mono_test_marshal_variant_in_double ((double)3.14) != 0)
-				return 12;
+				return 22;
 			if (mono_test_marshal_variant_in_bstr ("PI") != 0)
-				return 13;
+				return 23;
 			if (mono_test_marshal_variant_out_sbyte (out obj) != 0 || (sbyte)obj != 100)
-				return 14;
+				return 24;
 			if (mono_test_marshal_variant_out_byte (out obj) != 0 || (byte)obj != 100)
-				return 15;
+				return 25;
 			if (mono_test_marshal_variant_out_short (out obj) != 0 || (short)obj != 314)
-				return 16;
+				return 26;
 			if (mono_test_marshal_variant_out_ushort (out obj) != 0 || (ushort)obj != 314)
-				return 17;
+				return 27;
 			if (mono_test_marshal_variant_out_int (out obj) != 0 || (int)obj != 314)
-				return 18;
+				return 28;
 			if (mono_test_marshal_variant_out_uint (out obj) != 0 || (uint)obj != 314)
-				return 19;
+				return 29;
 			if (mono_test_marshal_variant_out_long (out obj) != 0 || (long)obj != 314)
-				return 20;
+				return 30;
 			if (mono_test_marshal_variant_out_ulong (out obj) != 0 || (ulong)obj != 314)
-				return 21;
+				return 31;
 			if (mono_test_marshal_variant_out_float (out obj) != 0 || ((float)obj - 3.14) / 3.14 > .001)
-				return 22;
+				return 32;
 			if (mono_test_marshal_variant_out_double (out obj) != 0 || ((double)obj - 3.14) / 3.14 > .001)
-				return 23;
+				return 33;
 			if (mono_test_marshal_variant_out_bstr (out obj) != 0 || (string)obj != "PI")
-				return 24;
+				return 34;
 
 			#endregion // VARIANT Tests
 
@@ -161,86 +171,86 @@
 
 			IntPtr pUnk;
 			if (mono_test_marshal_com_object_create (out pUnk) != 0)
-				return 25;
+				return 65;
 
 			if (mono_test_marshal_com_object_ref_count (pUnk) != 1)
-				return 26;
+				return 46;
 
 			if (Marshal.AddRef (pUnk) != 2)
-				return 27;
+				return 47;
 
 			if (mono_test_marshal_com_object_ref_count (pUnk) != 2)
-				return 28;
+				return 48;
 
 			if (Marshal.Release (pUnk) != 1)
-				return 29;
+				return 49;
 
 			if (mono_test_marshal_com_object_ref_count (pUnk) != 1)
-				return 30;
+				return 50;
 
 			object com_obj = Marshal.GetObjectForIUnknown (pUnk);
 
 			if (com_obj == null)
-				return 31;
+				return 51;
 
 			IMath imath = com_obj as IMath;
 
 			if (imath == null)
-				return 32;
+				return 52;
 
 			if (imath.Add (20, 10) != 30)
-				return 33;
+				return 53;
 
 			if (imath.Subtract (20, 10) != 10)
-				return 34;
+				return 54;
 
 			IMath same1, same2;
 			imath.Same (out same1);
 			imath.Same (out same2);
 			if (same1 != same2)
-				return 35;
+				return 55;
 
 			if (!same1.Equals (same2))
-				return 36;
+				return 56;
 
 			IMath diff1, diff2;
 			imath.Different (out diff1);
 			imath.Different (out diff2);
 			if (diff1 == diff2)
-				return 37;
+				return 57;
 
 			if (diff1.Equals (diff2))
-				return 38;
+				return 58;
 
 			// same1 & same2 share a RCW
 			if (Marshal.ReleaseComObject (same1) != 1)
-				return 39;
+				return 59;
 
 			if (Marshal.ReleaseComObject (same2) != 0)
-				return 40;
+				return 60;
 
 
 			if (Marshal.ReleaseComObject (diff1) != 0 ||
 				Marshal.ReleaseComObject (diff2) != 0)
-				return 41;
+				return 61;
 
 			IntPtr pUnk2 = Marshal.GetIUnknownForObject (imath);
 			if (pUnk2 == IntPtr.Zero)
-				return 50;
+				return 70;
 
 			if (pUnk != pUnk2)
-				return 51;
+				return 71;
 
 			IntPtr pDisp = Marshal.GetIDispatchForObject (imath);
 			if (pDisp == IntPtr.Zero)
-				return 52;
+				return 72;
 
 			if (pUnk != pDisp)
-				return 53;
+				return 73;
 
 
 			//if (mono_test_marshal_com_object_destroy (pUnk) != 0)
-			//    return 31;
+			//    return 71;
 			#endregion // Marshal COM Interop Tests
 		}
 
Index: mono/mono/tests/ChangeLog
===================================================================
--- mono/mono/tests/ChangeLog	(revision 65453)
+++ mono/mono/tests/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2006-09-15  Jonathan Chambers  <joncham@gmail.com>
+
+	* cominterop.cs: Added COM Interop tests for null BSTR checks.
+	* libtest.c: Added COM Interop tests for null BSTR checks.
+
 2006-09-14  Zoltan Varga  <vargaz@gmail.com>
 
 	* pinvoke2.cs libtest.c: Add test for marshalling of blittable classes and null.
Index: mono/mono/tests/libtest.c
===================================================================
--- mono/mono/tests/libtest.c	(revision 65453)
+++ mono/mono/tests/libtest.c	(working copy)
@@ -1893,6 +1893,21 @@
 }
 
 STDCALL int
+mono_test_marshal_bstr_in_null(BSTR bstr)
+{
+	if (!bstr)
+		return 0;
+	return 1;
+}
+
+STDCALL int
+mono_test_marshal_bstr_out_null(BSTR* bstr)
+{
+	*bstr = NULL;
+	return 0;
+}
+
+STDCALL int
 mono_test_marshal_variant_in_sbyte(VARIANT variant)
 {
 	if (variant.vt == VT_I1 && variant.cVal == 100)