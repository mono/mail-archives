? t
Index: inssel.brg
===================================================================
RCS file: /cvs/public/mono/mono/mini/inssel.brg,v
retrieving revision 1.36
diff -u -r1.36 inssel.brg
--- inssel.brg	26 Mar 2004 15:24:16 -0000	1.36
+++ inssel.brg	1 Apr 2004 21:29:17 -0000
@@ -1719,33 +1719,22 @@
 }
 
 reg: OP_STRLEN (reg) {	
-	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
-				   state->left->reg1, G_STRUCT_OFFSET (MonoString, length));
+	g_assert_not_reached ();
 }
 
 reg: OP_GETTYPE (reg) {	
-	int vt_reg = mono_regstate_next_int (s->rs);
-	MONO_EMIT_NEW_LOAD_MEMBASE (s, vt_reg, state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
-	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOAD_MEMBASE, state->reg1, vt_reg, G_STRUCT_OFFSET (MonoVTable, type));
+	g_assert_not_reached ();
 }
 
 #
 # array support
 #
 reg: CEE_LDLEN (reg) {	
-	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
-				   state->left->reg1, G_STRUCT_OFFSET (MonoArray, max_length));
+	g_assert_not_reached ();
 }
 
 reg: OP_ARRAY_RANK (reg) {	
-	int vtable_reg = mono_regstate_next_int (s->rs);
-	int class_reg = mono_regstate_next_int (s->rs);
-	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, vtable_reg, 
-				       state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
-	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, class_reg, 
-				       vtable_reg, G_STRUCT_OFFSET (MonoVTable, klass));
-	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, state->reg1, 
-				       class_reg, G_STRUCT_OFFSET (MonoClass, rank));
+	g_assert_not_reached ();
 }
 
 reg: OP_CHECK_ARRAY_TYPE (reg) {
Index: mini.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini.c,v
retrieving revision 1.210
diff -u -r1.210 mini.c
--- mini.c	31 Mar 2004 20:45:53 -0000	1.210
+++ mini.c	1 Apr 2004 21:29:19 -0000
@@ -618,6 +618,27 @@
 		(dest)->inst_right = (el2);	\
 	} while (0)
 
+#define NEW_LOAD_MEMBASE(cfg,dest,source,offset,op) do { \
+		MonoInst* load_source; \
+		if (offset != 0) { \
+			MonoInst* offset_inst; \
+			NEW_ICONST (cfg, offset_inst, offset); \
+			MONO_INST_NEW (cfg, load_source, CEE_ADD); \
+			load_source->cil_code = source->cil_code; \
+			load_source->inst_left = source; \
+			load_source->inst_right = offset_inst; \
+			load_source->type = STACK_MP; \
+		} else { \
+			load_source = source; \
+		} \
+		MONO_INST_NEW (cfg, dest, op); \
+		dest->type = ldind_type [op - CEE_LDIND_I1]; \
+		dest->cil_code = source->cil_code; \
+		dest->inst_left = load_source; \
+		dest->flags |= source->flags; \
+	} while (0)
+
+
 #if 0
 static gint
 compare_bblock (gconstpointer a, gconstpointer b)
@@ -6337,10 +6358,12 @@
 	static MonoJitICallInfo *newarr_specific_info = NULL;
 	MonoJitICallInfo *info;
 	int i;
+	MonoCompile *cfg = data;
+
+decompose_again:
 
 	switch (tree->opcode) {
 	case CEE_NEWARR: {
-		MonoCompile *cfg = data;
 		MonoInst *iargs [3];
 
 		if (!newarr_info) {
@@ -6372,6 +6395,42 @@
 		for (i = 0; i < info->sig->param_count; ++i)
 			dec_foreach (iargs [i], cfg);
 		break;
+	}
+	
+	case OP_GETTYPE: {
+		MonoInst* load_vtable;
+		MonoInst* load_type;
+		NEW_LOAD_MEMBASE (cfg, load_vtable, tree->inst_left, G_STRUCT_OFFSET (MonoObject, vtable), CEE_LDIND_I);
+		NEW_LOAD_MEMBASE (cfg, load_type, load_vtable, G_STRUCT_OFFSET (MonoVTable, type), CEE_LDIND_REF);	
+		*tree = *load_type;
+		goto decompose_again;
+	}
+	
+	case OP_STRLEN: {
+		MonoInst* load_length;
+		NEW_LOAD_MEMBASE (cfg, load_length, tree->inst_left, G_STRUCT_OFFSET (MonoString, length), CEE_LDIND_I4);
+		*tree = *load_length;
+		goto decompose_again;
+	}
+	
+	case CEE_LDLEN: {
+		MonoInst* load_length;
+		NEW_LOAD_MEMBASE (cfg, load_length, tree->inst_left, G_STRUCT_OFFSET (MonoArray, max_length), CEE_LDIND_I4);
+		*tree = *load_length;
+		goto decompose_again;
+	}
+	
+	case OP_ARRAY_RANK: {
+		MonoInst* load_vtable;
+		MonoInst* load_klass;
+		MonoInst* load_rank;
+		
+		NEW_LOAD_MEMBASE (cfg, load_vtable, tree->inst_left, G_STRUCT_OFFSET (MonoObject, vtable), CEE_LDIND_I);
+		NEW_LOAD_MEMBASE (cfg, load_klass, load_vtable, G_STRUCT_OFFSET (MonoVTable, klass), CEE_LDIND_I);
+		NEW_LOAD_MEMBASE (cfg, load_rank, load_klass, G_STRUCT_OFFSET (MonoClass, rank), CEE_LDIND_I4);
+		
+		*tree = *load_rank;
+		goto decompose_again;
 	}
 
 	default:
