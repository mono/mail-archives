Index: ChangeLog
===================================================================
RCS file: /mono/mcs/class/System/System.Text.RegularExpressions/ChangeLog,v
retrieving revision 1.18
diff -u -r1.18 ChangeLog
--- ChangeLog	20 Nov 2003 21:14:28 -0000	1.18
+++ ChangeLog	21 Nov 2003 23:13:45 -0000
@@ -1,3 +1,9 @@
+2003-11-21  Juraj Skripsky <js@hotfeet.ch>
+
+	* quicksearch.cs: Create and use hashtable only for "long" search
+	strings. (Search): Use simple scan for a single-character search strings.
+	(GetChar): Simplify case sensitivity handling.
+
 2003-11-20  Juraj Skripsky <js@hotfeet.ch>
 
 	* quicksearch.cs: Use a hashtable instead of an array for the
Index: notes.txt
===================================================================
RCS file: /mono/mcs/class/System/System.Text.RegularExpressions/notes.txt,v
retrieving revision 1.3
diff -u -r1.3 notes.txt
--- notes.txt	5 Feb 2002 20:48:52 -0000	1.3
+++ notes.txt	21 Nov 2003 23:13:45 -0000
@@ -20,12 +20,6 @@
 
 * Octal/backreference parsing needs a big fix. The rules are ridiculously complex.
 
-* Add a check in QuickSearch for single character substrings. This is likely to
-  be a common case. There's no need to go through a shift table. Also, have a
-  look at just computing a relevant subset of the shift table and using an
-  (offset, size) pair to help test inclusion. Characters not in the table get
-  the default len + 1 shift.
-
 * Improve the perl test suite. Run under MS runtime to generate checksums for
   each trial. Checksums should incorporate: all captures (index, length) for all
   groups; names of explicit capturing groups, and the numbers they map to. Any
Index: quicksearch.cs
===================================================================
RCS file: /mono/mcs/class/System/System.Text.RegularExpressions/quicksearch.cs,v
retrieving revision 1.2
diff -u -r1.2 quicksearch.cs
--- quicksearch.cs	20 Nov 2003 21:14:28 -0000	1.2
+++ quicksearch.cs	21 Nov 2003 23:13:45 -0000
@@ -3,25 +3,32 @@
 // namespace:	System.Text.RegularExpressions
 // file:	quicksearch.cs
 //
-// author:	Dan Lewis (dlewis@gmx.co.uk)
-// 		(c) 2002
+// Authors:	Dan Lewis (dlewis@gmx.co.uk)
+//		Juraj Skripsky (juraj@hotfeet.ch)
+//
+// (c) 2002 Dan Lewis
+// (c) 2003 Juraj Skripsky
+//
 
 using System;
 using System.Collections;
 
 namespace System.Text.RegularExpressions {
-
-	// TODO use simple test for single character strings
-
 	class QuickSearch {
-		// simplified boyer-moore for fast substring matching
+		// simplified boyer-moore for fast substring matching
+		// (for short strings, we use simple scans)
 	
 		public QuickSearch (string str, bool ignore) {
 			this.str = str;
 			this.len = str.Length;
-			this.ignore = ignore;
-		
-			Setup ();
+			this.ignore = ignore;
+
+			if (ignore)
+				str = str.ToLower ();
+
+			// create the shift table only for "long" search strings
+			if(len > THRESHOLD)
+				SetupShiftTable ();
 		}
 		
 		public string String {
@@ -36,41 +43,34 @@
 			get { return ignore; }
 		}
 
-		public int Search (string text, int start, int end) {
-			if (end > text.Length - len)
-				end = text.Length - len;
-		
+		public int Search (string text, int start, int end) {
 			int ptr = start;
-			if (!ignore) {
-				while (ptr <= end) {
-					int i = len - 1;
-					while (str[i] == text[ptr + i]) {
-						if (-- i < 0)
-							return ptr;
-					}
-
-					if (ptr < end)
-						ptr += GetShiftDistance (text[ptr + len]);
-					else
-						break;
-				}
-			}
-			else {
-				// ignore case: same as above, but we convert text
-				// to lower case before doing the string compare
-			
-				while (ptr <= end) {
-					int i = len - 1;
-					while (str[i] == Char.ToLower (text[ptr + i])) {
-						if (-- i < 0)
-							return ptr;
-					}
-
-					if (ptr < end)
-						ptr += GetShiftDistance (text[ptr + len]);
-					else
-						break;
+
+			// use simple scan for a single-character search string
+			if (len == 1) {
+				while (ptr <= end) {
+					if(str[0] == GetChar(text[ptr]))
+						return ptr;
+					else
+						ptr++;
+				}
+				return -1;
+			}
+
+			if (end > text.Length - len)
+				end = text.Length - len;
+
+			while (ptr <= end) {
+				int i = len - 1;
+				while (str[i] == GetChar(text[ptr + i])) {
+					if (-- i < 0)
+						return ptr;
 				}
+
+				if (ptr < end)
+					ptr += GetShiftDistance (text[ptr + len]);
+				else
+					break;
 			}
 
 			return -1;
@@ -78,30 +78,32 @@
 
 		// private
 
-		private void Setup () {
-			if (ignore)
-				str = str.ToLower ();
-
+		private void SetupShiftTable () {
 			shift = new Hashtable ();
 			for (int i = 0; i < len; ++ i) {
 				char c = str[i];
-
-				shift[c] = len - i;
-				if (ignore)
-					shift[Char.ToUpper (c)] = len - i;
+				shift[GetChar(c)] = len - i;
 			}
 		}
 	    
-		int GetShiftDistance (char c){
-			object s = shift[c];
+		private int GetShiftDistance (char c) {
+			if(shift == null)
+				return 1;
+
+			object s = shift[c];
 			return (s != null ? (int)s : len + 1);
+		}
+
+		private char GetChar(char c) {
+			return (!ignore ? c : Char.ToLower(c));
 		}
 		
 		private string str;
 		private int len;
 		private bool ignore;
 
-		Hashtable shift;
+		private Hashtable shift;
+		private readonly static int THRESHOLD = 5;
 	}
 
 }
