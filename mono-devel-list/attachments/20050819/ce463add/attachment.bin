Index: AssemblyName.cs
===================================================================
--- AssemblyName.cs	(revisi√≥n: 48583)
+++ AssemblyName.cs	(copia de trabajo)
@@ -37,6 +37,8 @@
 using System.Text;
 using System.Runtime.InteropServices;
 using System.Runtime.CompilerServices;
+using System.IO;
+using System.Collections.Generic;
 
 using Mono.Security;
 
@@ -73,7 +75,6 @@
 		int processor_architecture;
 #endif
         #endregion
-		
 		public AssemblyName ()
 		{
 			// defaults
@@ -81,11 +82,102 @@
 		}
 
 #if NET_2_0
+		const string exceptionMessage = "The assembly name is invalid.";
+		
 		public AssemblyName (string assemblyName)
 		{
-			name = assemblyName;
+			string [] parts;
+
+			if (assemblyName == null)
+				throw new ArgumentNullException ("assemblyName");
+			if (assemblyName.Length < 1)
+				throw new ArgumentException ("assemblyName cannot have zero length", "assemblyName");
+			
+			parts = assemblyName.Split (',');
+			name = parts [0].Trim ();
+			if (name.Length < 1)
+				throw new FileLoadException (exceptionMessage);
+
+			IComparer<string> comparer = StringComparer.OrdinalIgnoreCase;
+			for (int i = 1; i < parts.Length; i++) {
+				if (parts [i].IndexOf ('=') < 0)
+					throw new FileLoadException (exceptionMessage);
+
+				string [] values = parts [i].Split ('=');
+				values [0] = values [0].Trim ();
+				values [1] = values [1].Trim ();
+				if (values [0].Length < 1 || values [1].Length < 1)
+					throw new FileLoadException (exceptionMessage);
+
+				if (comparer.Compare (values [0], "Version") == 0) {
+					if (version != null)
+						throw new FileLoadException (exceptionMessage);
+					try {
+						version = new Version (values [1]);
+					} catch (ArgumentException) {
+						throw new FileLoadException (exceptionMessage);
+					} catch (FormatException) {
+						throw new FileLoadException (exceptionMessage);
+					}
+				} else if (comparer.Compare (values [0], "Culture") == 0) {
+					if (cultureinfo != null)
+						throw new FileLoadException (exceptionMessage);
+					if (comparer.Compare (values [1], "neutral") == 0)
+						values [1] = "";
+					cultureinfo = new CultureInfo (values [1]);
+				} else if (comparer.Compare (values [0], "PublicKeyToken") == 0) {
+					if (keyToken != null)
+						throw new FileLoadException (exceptionMessage);
+					ParsePublicKeyToken (values [1]);
+				} else if (comparer.Compare (values [0], "PublicKey") == 0) {
+					if (publicKey != null)
+						throw new FileLoadException (exceptionMessage);
+					ParsePublicKey (values [1]);
+				} else
+					throw new FileLoadException (exceptionMessage);
+			}
+			
 		}
 
+		void ParsePublicKeyToken (string kToken)
+		{
+			if (kToken.Length != 16)
+				throw new FileLoadException (exceptionMessage);
+
+			keyToken = new byte [8];
+			for (int i = 0, j = 0; i < 8; i++) {
+				keyToken [i] = (byte) (GetCharNumericValue (kToken [j++]) << 4);
+				keyToken [i] |= (byte) GetCharNumericValue (kToken [j++]);
+			}
+		}
+
+		void ParsePublicKey (string key)
+		{
+			if (key.Length != 320)
+				throw new FileLoadException (exceptionMessage);
+			
+			publicKey = new byte [160];
+			for (int i = 0, j = 0; i < 160; i++) {
+				publicKey [i] = (byte) (GetCharNumericValue (key [j++]) << 4);
+				publicKey [i] |= (byte) GetCharNumericValue (key [j++]);
+			}
+			flags = AssemblyNameFlags.PublicKey;
+		}
+
+		int GetCharNumericValue (char c)
+		{
+			if (c >= (char)0x30 && c <= (char)0x3B)
+				return c - 0x30; // 0-9
+			if (c >= (char)0x41 && c <= (char)0x46)
+				return c - 0x37; // A-F
+			if (c >= (char)0x61 && c <= (char)0x66)
+				return c - 0x57; // a-f
+
+			throw new FileLoadException (exceptionMessage);
+		}
+#endif
+		
+#if NET_2_0
 		[MonoTODO]
 		public ProcessorArchitecture ProcessorArchitecture {
 			get {
