Index: AssemblyName.cs
===================================================================
--- AssemblyName.cs	(revisi√≥n: 48528)
+++ AssemblyName.cs	(copia de trabajo)
@@ -37,6 +37,7 @@
 using System.Text;
 using System.Runtime.InteropServices;
 using System.Runtime.CompilerServices;
+using System.IO;
 
 using Mono.Security;
 
@@ -73,6 +74,7 @@
 		int processor_architecture;
 #endif
         #endregion
+		static readonly char [] delimiter = {','};
 		
 		public AssemblyName ()
 		{
@@ -80,12 +82,84 @@
 			versioncompat = AssemblyVersionCompatibility.SameMachine;
 		}
 
-#if NET_2_0
+#if NET_2_0 || BOOTSTRAP_NET_2_0
 		public AssemblyName (string assemblyName)
 		{
-			name = assemblyName;
+			string [] parts;
+
+			if (assemblyName == null)
+				throw new ArgumentNullException ("assemblyName");
+			if (assemblyName == "")
+				throw new ArgumentException ("assemblyName cannot have zero length", "assemblyName");
+			
+			// Remove white spaces, to mimic .Net behavior
+			assemblyName = assemblyName.Replace (" ", "");
+			parts = assemblyName.Split (delimiter);
+			if (parts [0] == "")
+				throw new FileLoadException ("The assembly name is invalid.");
+
+			name = parts [0];
+			for (int i = 0; i < parts.Length; i++) {
+				try {
+					if (String.Compare (parts [i], 0, "Version=", 0, 8, true, CultureInfo.InvariantCulture) == 0)
+						version = new Version (parts [i].Substring (8, parts [i].Length - 8));
+					else if (String.Compare (parts [i], 0, "Culture=", 0, 8, true, CultureInfo.InvariantCulture) == 0) {
+						string culture = parts [i].Substring (8, parts [i].Length - 8);
+						if (String.Compare (culture, "neutral", true, CultureInfo.InvariantCulture) == 0)
+							culture = "";
+						cultureinfo = new CultureInfo (culture);
+					}
+					else if (String.Compare (parts [i], 0, "PublicKeyToken=", 0, 15, true, CultureInfo.InvariantCulture) == 0)
+						ParseKeyToken (parts [i].Substring (15, parts [i].Length - 15));
+					else if (String.Compare (parts [i], 0, "PublicKey=", 0, 10, true, CultureInfo.InvariantCulture) == 0)
+						ParseKey (parts [i].Substring (10, parts [i].Length - 10));
+				} catch {
+					throw new FileLoadException ("The assembly name is invalid.");
+				}
+			}
+			
 		}
 
+		void ParseKeyToken (string kToken)
+		{
+			if (kToken.Length != 16)
+				throw new Exception ();
+
+			byte [] tmp = new byte [8];
+			for (int i = 0, j = 0; i < 8; i++) {
+				tmp [i] = (byte) (GetCharNumericValue (kToken [j++]) << 4);
+				tmp [i] |= (byte) GetCharNumericValue (kToken [j++]);
+			}
+
+			keyToken = tmp;
+		}
+
+		void ParseKey (string key)
+		{
+			if (key.Length != 320)
+				throw new Exception ();
+			
+			byte [] tmp = new byte [160];
+			for (int i = 0, j = 0; i < 160; i++) {
+				tmp [i] = (byte) (GetCharNumericValue (key [j++]) << 4);
+				tmp [i] |= (byte) GetCharNumericValue (key [j++]);
+			}
+			publicKey = tmp;
+			flags = AssemblyNameFlags.PublicKey;
+		}
+
+		int GetCharNumericValue (char c)
+		{
+			if (c >= (char)0x30 && c <= (char)0x3B)
+				return c - 0x30; // 0-9
+			if (c >= (char)0x61 && c <= (char)0x66)
+				return c - 0x57; // a-f
+
+			throw new Exception ();
+		}
+#endif
+		
+#if NET_2_0
 		[MonoTODO]
 		public ProcessorArchitecture ProcessorArchitecture {
 			get {
