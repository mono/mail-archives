Index: Test/System.Reflection/ChangeLog
===================================================================
--- Test/System.Reflection/ChangeLog	(revision 128487)
+++ Test/System.Reflection/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2009-03-03  Matthew Metnetsky  <matthew@cowarthill.com>
+
+	* BinderTests.cs: added tests for TargetParameterCountException
+	* BinderTests.cs: added tests for BindingFlags.ExactBinding
+
 2009-02-21  Jb Evain  <jbevain@novell.com>
 
 	* BinderTests.cs: add test for bug #471257, where Type.InvokeMember
Index: Test/System.Reflection/BinderTests.cs
===================================================================
--- Test/System.Reflection/BinderTests.cs	(revision 128487)
+++ Test/System.Reflection/BinderTests.cs	(working copy)
@@ -530,6 +530,11 @@
 			public void Bar ()
 			{
 			}
+
+			public int Add(int x, int y)
+			{
+				return x + y;	
+			}
 		}
 
 		class Foo : BaseFoo {
@@ -556,5 +561,76 @@
 
 			Assert.IsTrue (foo.Barred);
 		}
-    }
+
+		class Int32Binder : AssertingBinder
+		{
+			public override object ChangeType(Object value, Type type, CultureInfo ci)
+			{
+				if (value.GetType() == type) {
+					return value;
+				} else if (type.IsPrimitive) {
+					if (type == typeof(Int32))
+						return Convert.ToInt32(value);
+
+					throw new ArgumentException("missing support for primitive: " + type);
+				}
+
+				throw new ArgumentException("Could not ChangeType to " + type.FullName);
+			}
+		}
+
+		[Test]
+		[ExpectedException(typeof (TargetParameterCountException))]
+		public void TestTargetParameterCountExceptionA ()
+		{
+			MethodInfo method = typeof (Foo).GetMethod ("Add");
+			method.Invoke((new Foo ()), 0, null, null, null);
+		}
+
+		[Test]
+		[ExpectedException(typeof (TargetParameterCountException))]
+		public void TestTargetParameterCountExceptionB ()
+		{
+			MethodInfo method = typeof (Foo).GetMethod ("Add");
+			method.Invoke(new Foo (), 0, null, new object [] {1}, null);
+		}
+
+		[Test]
+		public void TestBindingFlagsA ()
+		{
+			MethodInfo method = typeof (Foo).GetMethod ("Add");
+			method.Invoke((new Foo ()), 0, null, new object [] {1, 2}, null);
+		}
+
+		[Test]
+		[ExpectedException(typeof (ArgumentException))]
+		public void TestBindingFlagsB ()
+		{
+			MethodInfo method = typeof (Foo).GetMethod ("Add");
+			method.Invoke((new Foo ()), 0, null, new object [] {1, "2"}, null);
+		}
+
+		[Test]
+		public void TestBindingFlagsExactBindingA ()
+		{
+			MethodInfo method = typeof (Foo).GetMethod ("Add");
+			method.Invoke((new Foo ()), BindingFlags.ExactBinding, null, new object [] {1, 2}, null);
+		}
+
+		[Test]
+		[ExpectedException(typeof (ArgumentException))]
+		public void TestBindingFlagsExactBindingB ()
+		{
+			MethodInfo method = typeof (Foo).GetMethod ("Add");
+			method.Invoke((new Foo ()), BindingFlags.ExactBinding, new Int32Binder (), new object [] {1, "2"}, null);
+		}
+
+		[Test]
+		public void TestBindingFlagsExactBindingC ()
+		{
+			MethodInfo method = typeof (Foo).GetMethod ("Add");
+			method.Invoke((new Foo ()), 0, new Int32Binder (), new object [] {1, "2"}, null);
+		}
+
+	}
 }
Index: System.Reflection/ChangeLog
===================================================================
--- System.Reflection/ChangeLog	(revision 128487)
+++ System.Reflection/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2009-03-03  Matthew Metnetsky  <matthew@cowarthill.com>
+
+	* MonoMethod.cs: within Invoke only change types if BindingFlags.ExactBinding isn't set
+
+	* MonoMethod.cs: within Invoke ensure arg types match ParameterInfo types before
+	calling InvokeInternal
+
 2008-03-02  Rodrigo Kumpera  <rkumpera@novell.com>
 
 	* EventInfo.cs: Apply similar trick to the one in MonoProperty to speed up
Index: System.Reflection/MonoMethod.cs
===================================================================
--- System.Reflection/MonoMethod.cs	(revision 128487)
+++ System.Reflection/MonoMethod.cs	(working copy)
@@ -126,15 +126,25 @@
 		 */
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
 		internal extern Object InternalInvoke (Object obj, Object[] parameters, out Exception exc);
-		
+
 		public override Object Invoke (Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) 
 		{
 			if (binder == null)
 				binder = Binder.DefaultBinder;
 			ParameterInfo[] pinfo = GetParameters ();
-			if (!Binder.ConvertArgs (binder, parameters, pinfo, culture))
-				throw new ArgumentException ("parameters");
 
+			if ((parameters == null && pinfo.Length != 0) || (parameters != null && parameters.Length != pinfo.Length))
+				throw new TargetParameterCountException ("parameters do not match signature");
+			
+			if ((invokeAttr & BindingFlags.ExactBinding) == 0) {
+				if (!Binder.ConvertArgs (binder, parameters, pinfo, culture))
+					throw new ArgumentException ("failed to convert parameters");
+			} else {
+				for (int i = 0; i < pinfo.Length; i++)
+					if (parameters[i].GetType() != pinfo[i].ParameterType)
+						throw new ArgumentException ("parameters do not match signature");
+			}
+
 #if !NET_2_1
 			if (SecurityManager.SecurityEnabled) {
 				// sadly Attributes doesn't tell us which kind of security action this is so
@@ -417,10 +427,21 @@
 		{
 			if (binder == null)
 				binder = Binder.DefaultBinder;
+
 			ParameterInfo[] pinfo = GetParameters ();
-			if (!Binder.ConvertArgs (binder, parameters, pinfo, culture))
-				throw new ArgumentException ("parameters");
 
+			if ((parameters == null && pinfo.Length != 0) || (parameters != null && parameters.Length != pinfo.Length))
+				throw new TargetParameterCountException ("parameters do not match signature");
+			
+			if ((invokeAttr & BindingFlags.ExactBinding) == 0) {
+				if (!Binder.ConvertArgs (binder, parameters, pinfo, culture))
+					throw new ArgumentException ("failed to convert parameters");
+			} else {
+				for (int i = 0; i < pinfo.Length; i++)
+					if (parameters[i].GetType() != pinfo[i].ParameterType)
+						throw new ArgumentException ("parameters do not match signature");
+			}
+
 			if (SecurityManager.SecurityEnabled) {
 				// sadly Attributes doesn't tell us which kind of security action this is so
 				// we must do it the hard way - and it also means that we can skip calling

