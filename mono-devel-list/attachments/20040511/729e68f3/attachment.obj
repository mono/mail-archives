? icall.diff
? rand.diff
Index: rand.c
===================================================================
RCS file: /cvs/public/mono/mono/metadata/rand.c,v
retrieving revision 1.12
diff -u -r1.12 rand.c
--- rand.c	6 May 2004 02:18:47 -0000	1.12
+++ rand.c	11 May 2004 17:52:01 -0000
@@ -1,12 +1,13 @@
 /*
  * rand.c: System.Security.Cryptography.RNGCryptoServiceProvider support
  *
- * Author:
+ * Authors:
  *      Mark Crichton (crichton@gimp.org)
  *      Patrik Torstensson (p@rxc.se)
+ *	Sebastien Pouliot (sebastien@ximian.com)
  *
  * (C) 2001 Ximian, Inc.
- *
+ * (C) 2004 Novell (http://www.novell.com)
  */
 
 #include <config.h>
@@ -93,41 +94,50 @@
 
 #if defined (PLATFORM_WIN32)
 
-#include <WinCrypt.h>
-
-static int s_providerInitialized = 0;
-static HCRYPTPROV s_provider;
-
-static HCRYPTPROV GetProvider()
-{
-    if (s_providerInitialized == 1)
-        return s_provider;
-
-    if (!CryptAcquireContext (&s_provider, NULL, NULL, PROV_RSA_FULL, 0))  
-    {
-        if (GetLastError() != NTE_BAD_KEYSET)
-            mono_raise_exception (mono_get_exception_execution_engine ("Failed to acquire crypt context"));
-
-		// Generate a new keyset if needed
-        if (!CryptAcquireContext (&s_provider, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
-            mono_raise_exception (mono_get_exception_execution_engine ("Failed to acquire crypt context (new keyset)"));
-    }
-    
-    s_providerInitialized =  1;
-
-    return s_provider;
-}
+#include <wincrypt.h>
+
+#ifndef PROV_INTEL_SEC
+#define PROV_INTEL_SEC		22
+#endif
+#ifndef CRYPT_VERIFY_CONTEXT
+#define CRYPT_VERIFY_CONTEXT	0xF0000000
+#endif
+
+static HCRYPTPROV s_provider = 0;
 
-void ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_InternalGetBytes(MonoObject *self, MonoArray *arry)
+static HCRYPTPROV GetProvider ()
 {
-    guint32 len;
-    guchar *buf;
+	if (s_provider == 0) {
+		/* There is no need to create a container for just random data,
+		   so we can use CRYPT_VERIFY_CONTEXT (one call) see: 
+		   http://blogs.msdn.com/dangriff/archive/2003/11/19/51709.aspx */
+
+		/* We first try to use the Intel PIII RNG if drivers are present 
+		   http://developer.intel.com/design/chipsets/rng/RNG-CAPI.pdf */
+		if (!CryptAcquireContext (&s_provider, NULL, NULL, PROV_INTEL_SEC, CRYPT_VERIFY_CONTEXT)) {
+			/* not a PIII or no drivers available, use default RSA CSP */
+			if (!CryptAcquireContext (&s_provider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFY_CONTEXT)) {
+				mono_raise_exception (mono_get_exception_execution_engine (
+					"Failed to acquire cryptographic context."));
+			}
+		}
+	}
+	return s_provider;
+}
 
-    len = mono_array_length (arry);
-    buf = mono_array_addr (arry, guchar, 0);
+void ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_InternalGetBytes (MonoObject *self, MonoArray *arry)
+{
+	guint32 len = mono_array_length (arry);
+	guchar *buf = mono_array_addr (arry, guchar, 0);
 
-    if (0 == CryptGenRandom (GetProvider(), len, buf))
-       mono_raise_exception (mono_get_exception_execution_engine ("Failed to generate random bytes from CryptoAPI"));
+	if (!CryptGenRandom (GetProvider (), len, buf)) {
+		/* we may have lost our context with CryptoAPI, but all hope isn't lost yet! */
+		s_provider = 0; /* RESET */
+		if (!CryptGenRandom (GetProvider (), len, buf)) {
+			mono_raise_exception (mono_get_exception_execution_engine (
+				"CryptoAPI failed to generate random bytes."));
+		}
+	} 
 }
 
 #else
@@ -176,7 +186,7 @@
 
     if (err < 0) {
         g_warning("Entropy error! Error in read.");
-        mono_raise_exception (mono_get_exception_execution_engine ("Failed to read a random byte from /dev/urandom or /dev/random device"));
+        mono_raise_exception (mono_get_exception_execution_engine ("Failed to read a random byte from /dev/urandom or /dev/random device"));
     }
 
     close(file);
