Index: ChangeLog
===================================================================
RCS file: /cvs/public/libgdiplus/ChangeLog,v
retrieving revision 1.1.1.1
diff -u -w -b -u -r1.1.1.1 ChangeLog
--- ChangeLog	31 Jan 2004 06:21:09 -0000	1.1.1.1
+++ ChangeLog	4 Apr 2004 10:03:21 -0000
@@ -1,3 +1,8 @@
+2004-04-04  Vladimir Vukicevic  <vladimir@pobox.com>
+
+	* configure.in: Added checks for libtiff and libjpeg.  Cribbed
+	from gtk.
+
 2004-01-31  Miguel de Icaza  <miguel@ximian.com>
 
 	* Initial release, split from the Mono's MCS package.
Index: src/ChangeLog
===================================================================
RCS file: /cvs/public/libgdiplus/src/ChangeLog,v
retrieving revision 1.72
diff -u -w -b -u -r1.72 ChangeLog
--- src/ChangeLog	4 Apr 2004 08:06:25 -0000	1.72
+++ src/ChangeLog	4 Apr 2004 10:03:22 -0000
@@ -1,0 +1,12 @@
+2004-04-04  Vladimir Vukicevic  <vladimir@pobox.com>
+
+	* src/image.c, src/gdip.h: Added GdipDrawImage/DrawImageRect
+
+	* src/jpegcodec.c, src/tiffcodec.c: Implemented loading jpeg and
+	tiff images.  Need to test these out on windows, to see exactly
+	what formats stuff gets retruned in, but I think we should be ok
+	for the most common cases.  No file saving yet.
+	
+	* src/bmpcodec.c, src/gifcodec.c, src/pngcodec.c:
+	Remove calls to bogus (and undefined) gdip_image_new()
+
Index: configure.in
===================================================================
RCS file: /cvs/public/libgdiplus/configure.in,v
retrieving revision 1.6
diff -u -w -b -u -r1.6 configure.in
--- configure.in	19 Mar 2004 00:04:47 -0000	1.6
+++ configure.in	4 Apr 2004 10:03:21 -0000
@@ -22,12 +22,71 @@
 	AC_MSG_ERROR("Did not find Cairo 0.1.17");
 fi
 GDIPLUS_LIBS="`pkg-config --libs cairo mono glib-2.0` `freetype-config --libs`"
-AC_SUBST(GDIPLUS_LIBS)
 GDIPLUS_CFLAGS="`pkg-config --cflags cairo mono glib-2.0` `freetype-config --cflags`"
+
+AC_ARG_WITH(libjpeg,
+	[AC_HELP_STRING([--without-libjpeg], [disable JPEG file IO])])
+AC_ARG_WITH(libtiff,
+	[AC_HELP_STRING([--without-libtiff], [disable TIFF file IO])])
+
+dnl Test for libtiff
+  if test x$with_libtiff != xno && test -z "$LIBTIFF"; then
+    AC_CHECK_LIB(tiff, TIFFReadScanline,
+      [AC_CHECK_HEADER(tiffio.h,
+        TIFF='tiff'; LIBTIFF='-ltiff',
+        AC_MSG_WARN(*** TIFF loader will not be built (TIFF header files not found) ***))],
+      [AC_CHECK_LIB(tiff, TIFFWriteScanline,
+        [AC_CHECK_HEADER(tiffio.h,
+          TIFF='tiff'; LIBTIFF='-ltiff -ljpeg -lz',
+          AC_MSG_WARN(*** TIFF loader will not be built (TIFF header files not found) ***))],
+        [AC_CHECK_LIB(tiff34, TIFFFlushData,
+          [AC_CHECK_HEADER(tiffio.h,
+            TIFF='tiff'; LIBTIFF='-ltiff34 -ljpeg -lz',
+            AC_MSG_WARN(*** TIFF loader will not be built (TIFF header files not found) ***))],
+        AC_MSG_WARN(*** TIFF plug-in will not be built (TIFF library not found) ***), -ljpeg -lz -lm)], -ljpeg -lz -lm)], -lm)
+  fi
+
+if test x$TIFF != x; then
+  GDIPLUS_LIBS="$GDIPLUS_LIBS $LIBTIFF"
+  AC_DEFINE(HAVE_LIBTIFF, 1, Define if tiff support is available)
+fi
+
+dnl Test for libjpeg
+  if test x$with_libjpeg != xno && test -z "$LIBJPEG"; then
+    AC_CHECK_LIB(jpeg, jpeg_destroy_decompress,
+      jpeg_ok=yes,
+      jpeg_ok=no
+      AC_MSG_WARN(*** JPEG loader will not be built (JPEG library not found) ***))
+    if test "$jpeg_ok" = yes; then
+      AC_MSG_CHECKING([for jpeglib.h])
+      AC_TRY_CPP(
+[#include <stdio.h>
+#undef PACKAGE
+#undef VERSION
+#undef HAVE_STDLIB_H
+#include <jpeglib.h>],
+        jpeg_ok=yes,
+        jpeg_ok=no)
+      AC_MSG_RESULT($jpeg_ok)
+      if test "$jpeg_ok" = yes; then
+        JPEG='jpeg'; LIBJPEG='-ljpeg'
+      else
+        AC_MSG_WARN(*** JPEG loader will not be built (JPEG header file not found) ***)
+      fi
+    fi
+  fi
+
+if test x$JPEG != x; then
+  GDIPLUS_LIBS="$GDIPLUS_LIBS $LIBJPEG"
+  AC_DEFINE(HAVE_LIBJPEG, 1, Define if jpeg support is available)
+fi
+
+AC_SUBST(GDIPLUS_LIBS)
 AC_SUBST(GDIPLUS_CFLAGS)
+
 AC_OUTPUT([
 Makefile
 libgdiplus.pc
 2004-04-04  Duncan Mak  <duncan@ximian.com>
 
 	* graphics-path.c (append_arc): Added a new boolean argument. to
Index: src/bmpcodec.c
===================================================================
RCS file: /cvs/public/libgdiplus/src/bmpcodec.c,v
retrieving revision 1.1
diff -u -w -b -u -r1.1 bmpcodec.c
--- src/bmpcodec.c	20 Mar 2004 22:29:32 -0000	1.1
+++ src/bmpcodec.c	4 Apr 2004 10:03:22 -0000
@@ -13,7 +13,11 @@
 GpStatus 
 gdip_load_png_bmp_from_file (FILE *fp, GpImage *image)
 {
-	image = (GpImage *) gdip_image_new ();
-	image->type = imageBitmap;
+    return NotImplemented;
+}
+
+GpStatus 
+gdip_load_bmp_image_from_file (FILE *fp, GpImage *image)
+{
 	return NotImplemented;
 }
Index: src/gdip.h
===================================================================
RCS file: /cvs/public/libgdiplus/src/gdip.h,v
retrieving revision 1.32
diff -u -w -b -u -r1.32 gdip.h
--- src/gdip.h	2 Apr 2004 19:13:52 -0000	1.32
+++ src/gdip.h	4 Apr 2004 10:03:22 -0000
@@ -549,6 +549,10 @@
 GpStatus GdipDrawBeziers (GpGraphics *graphics, GpPen *pen, GpPointF *points, int count);
 GpStatus GdipDrawBeziersI (GpGraphics *graphics, GpPen *pen, GpPoint *points, int count);
 GpStatus GdipDrawEllipse (GpGraphics *graphics, GpPen *pen, float x, float y, float width, float height);
+GpStatus GdipDrawImage (GpGraphics *graphics, GpImage *image, int x, int y);
+GpStatus GdipDrawImageI (GpGraphics *graphics, GpImage *image, int x, int y);
+GpStatus GdipDrawImageRect (GpGraphics *graphics, GpImage *image, int x, int y, int width, int height);
+GpStatus GdipDrawImageRectI (GpGraphics *graphics, GpImage *image, int x, int y, int width, int height);
 GpStatus GdipDrawLine (GpGraphics *graphics, GpPen *pen, float x1, float y1, float x2, float y2);
 GpStatus GdipDrawLineI (GpGraphics *graphics, GpPen *pen, int x1, int y1, int x2, int y2);
 GpStatus GdipDrawLines (GpGraphics *graphics, GpPen *pen, GpPointF *points, int count);
Index: src/gifcodec.c
===================================================================
RCS file: /cvs/public/libgdiplus/src/gifcodec.c,v
retrieving revision 1.1
diff -u -w -b -u -r1.1 gifcodec.c
--- src/gifcodec.c	20 Mar 2004 22:29:32 -0000	1.1
+++ src/gifcodec.c	4 Apr 2004 10:03:22 -0000
@@ -13,7 +13,5 @@
 GpStatus 
 gdip_load_gif_image_from_file (FILE *fp, GpImage *image)
 {
-	image = (GpImage *) gdip_image_new ();
-	image->type = imageBitmap;
 	return NotImplemented;
 }
Index: src/image.c
===================================================================
RCS file: /cvs/public/libgdiplus/src/image.c,v
retrieving revision 1.10
diff -u -w -b -u -r1.10 image.c
--- src/image.c	31 Mar 2004 15:36:10 -0000	1.10
+++ src/image.c	4 Apr 2004 10:03:22 -0000
@@ -125,10 +125,21 @@
 }
 
 GpStatus 
+GdipDrawImage (GpGraphics *graphics, GpImage *image, int x, int y)
+{
+    return GdipDrawImageRectI (graphics, image, x, y, image->width, image->height);
+}
+
+GpStatus 
 GdipDrawImageI (GpGraphics *graphics, GpImage *image, int x, int y)
 {
-	printf("GdipDrawImageI. %p (type %d), %p, (%d,%d)\n", graphics, graphics->type, image, x, y);
-	return NotImplemented;
+    return GdipDrawImageRectI (graphics, image, x, y, image->width, image->height);
+}
+
+GpStatus
+GdipDrawImageRect (GpGraphics *graphics, GpImage *image, int x, int y, int width, int height)
+{
+    return GdipDrawImageRectI (graphics, image, x, y, width, height);
 }
 
 GpStatus 
@@ -176,10 +187,17 @@
 	ImageFormat format;
 	unsigned char *file_name;
 
+        GError *err = NULL;
+
 	if (!image || !file)
 		return InvalidParameter;
  
-	file_name = (unsigned char *) g_utf16_to_utf8 ((const gunichar2 *)file, -1, NULL, NULL, NULL);
+	file_name = (unsigned char *) g_utf16_to_utf8 ((const gunichar2 *)file, -1, NULL, NULL, &err);
+        if (file_name == NULL || err != NULL) {
+            *image = NULL;
+            return InvalidParameter;
+        }
+
 	/*printf ("image.c, file name is %s \n", file_name);*/
 	if ((fp = fopen(file_name, "rb")) == NULL) 
 		return FileNotFound;
@@ -197,7 +215,7 @@
 			}
 			break;
 		case TIFF:
-			status = gdip_load_tiff_image_from_file (fp, result);
+			status = gdip_load_tiff_image_from_file (fp, &result);
 			if (status != Ok)
 			{	
 				fclose(fp);
@@ -221,7 +239,7 @@
 			}
 			break;
 		case JPEG:
-			status = gdip_load_jpeg_image_from_file (fp, result);
+			status = gdip_load_jpeg_image_from_file (fp, &result);
 			if (status != Ok)
 			{	
 				fclose(fp);
Index: src/jpegcodec.c
===================================================================
RCS file: /cvs/public/libgdiplus/src/jpegcodec.c,v
retrieving revision 1.1
diff -u -w -b -u -r1.1 jpegcodec.c
--- src/jpegcodec.c	20 Mar 2004 22:29:32 -0000	1.1
+++ src/jpegcodec.c	4 Apr 2004 10:03:22 -0000
@@ -1,19 +1,301 @@
-/*
+/* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*-
+ *
  * jpegcodec.c : Contains function definitions for encoding decoding jpeg images
  *
  * Authors:
  *  	Sanjay Gupta (gsanjay@novell.com)
+ *      Vladimir Vukicevic (vladimir@pobox.com)
  *
  * Copyright (C) Novell, Inc. 2003-2004.
  */
 
+#include <config.h>
+
 #include <stdio.h>
 #include "jpegcodec.h"
 
+#ifdef HAVE_LIBJPEG
+
+#include <setjmp.h>
+#include <jpeglib.h>
+
+#ifndef HAVE_SIGSETJMP
+#define sigjmp_buf jmp_buf
+#define sigsetjmp(jb, x) setjmp(jb)
+#define siglongjmp longjmp
+#endif
+
+#define JPEG_READ_BUFFER_SIZE	65536
+
+struct gdip_jpeg_source_mgr {
+    struct jpeg_source_mgr parent;
+
+    FILE *infp;
+    JOCTET *buf;
+};
+typedef struct gdip_jpeg_source_mgr *gdip_jpeg_source_mgr_ptr;
+
+struct gdip_jpeg_error_mgr {
+    struct jpeg_error_mgr parent;
+    sigjmp_buf setjmp_buffer;
+    GError **error;
+};
+typedef struct gdip_jpeg_error_mgr *gdip_jpeg_error_mgr_ptr;
+
+static void
+_gdip_jpeg_error_exit (j_common_ptr cinfo)
+{
+    gdip_jpeg_error_mgr_ptr err = (gdip_jpeg_error_mgr_ptr) cinfo->err;
+    char buffer[JMSG_LENGTH_MAX];
+
+    (* cinfo->err->format_message) (cinfo, buffer);
+
+    /* There is some very bizzare stuff happening with error
+     * reporting.  These are supposed to be fatal errors,
+     * but libjpeg goes through a bunch of these calls and then
+     * -finishes uncompressing the image-.  I have no idea
+     * what's going on here.
+     * -- FIXME
+     */
+#if 0
+    printf ("jpeg error: %d %s\n", err->parent.msg_code, buffer);
+    siglongjmp (err->setjmp_buffer, 1);
+#endif
+}
+
+static void
+_gdip_jpeg_output_message (j_common_ptr cinfo)
+{
+    /* shh. */
+}
+
+static void
+_gdip_source_stdio_init (j_decompress_ptr cinfo)
+{
+    /* nothing */
+}
+
+static bool
+_gdip_source_stdio_fill_input_buffer (j_decompress_ptr cinfo)
+{
+    gdip_jpeg_source_mgr_ptr src = (gdip_jpeg_source_mgr_ptr) cinfo->src;
+    size_t nb;
+
+    nb = fread (src->buf, 1, JPEG_READ_BUFFER_SIZE, src->infp);
+
+    if (nb <= 0) {
+        /* this is a hack learned from gdk-pixbuf */
+        /* insert fake EOI marker, to try to salvage image
+         * in case of malformed/incomplete input
+         */
+        src->buf[0] = (JOCTET) 0xFF;
+        src->buf[1] = (JOCTET) JPEG_EOI;
+        nb = 2;
+    }
+
+    src->parent.next_input_byte = src->buf;
+    src->parent.bytes_in_buffer = nb;
+
+    return TRUE;
+}
+
+static void
+_gdip_source_stdio_skip_input_data (j_decompress_ptr cinfo, long skipbytes)
+{
+    gdip_jpeg_source_mgr_ptr src = (gdip_jpeg_source_mgr_ptr) cinfo->src;
+
+    if (skipbytes > 0) {
+        if (skipbytes > (long) src->parent.bytes_in_buffer) {
+            skipbytes -= (long) src->parent.bytes_in_buffer;
+            fseek (src->infp, skipbytes, SEEK_CUR);
+
+            (void) _gdip_source_stdio_fill_input_buffer (cinfo);
+        } else {
+            src->parent.next_input_byte += (size_t) skipbytes;
+            src->parent.bytes_in_buffer -= (size_t) skipbytes;
+        }
+    }
+}
+
+static void
+_gdip_source_stdio_term (j_decompress_ptr cinfo)
+{
+    /* nothing */
+}
+
+GpStatus 
+gdip_load_jpeg_image_from_file (FILE *fp, GpImage **image)
+{
+    GpBitmap *img = NULL;
+    struct jpeg_decompress_struct cinfo;
+    struct gdip_jpeg_error_mgr jerr;
+    gdip_jpeg_source_mgr_ptr src = NULL;
+
+    guchar *destbuf = NULL, *destptr = NULL;
+    guchar *lines[4] = {NULL, NULL, NULL, NULL};
+
+    int stride;
+
+    img = gdip_bitmap_new ();
+
+    cinfo.err = jpeg_std_error ((struct jpeg_error_mgr *) &jerr);
+    jerr.parent.error_exit = _gdip_jpeg_error_exit;
+    jerr.parent.output_message = _gdip_jpeg_output_message;
+
+    if (sigsetjmp (jerr.setjmp_buffer, 1)) {
+        /* Error occured during decompression */
+        jpeg_destroy_decompress (&cinfo);
+
+        if (destbuf != NULL)
+            g_free (destbuf);
+
+        gdip_bitmap_dispose (img);
+        *image = NULL;
+        return GenericError;
+    }
+
+    jpeg_create_decompress (&cinfo);
+
+    cinfo.src = (struct jpeg_source_mgr *)
+        (*cinfo.mem->alloc_small) ((j_common_ptr) &cinfo, JPOOL_PERMANENT, sizeof (struct gdip_jpeg_source_mgr));
+    src = (gdip_jpeg_source_mgr_ptr) cinfo.src;
+    src->buf = (JOCTET *)
+        (*cinfo.mem->alloc_small) ((j_common_ptr) &cinfo, JPOOL_PERMANENT, JPEG_READ_BUFFER_SIZE * sizeof(JOCTET));
+    src->parent.init_source = _gdip_source_stdio_init;
+    src->parent.fill_input_buffer = _gdip_source_stdio_fill_input_buffer;
+    src->parent.skip_input_data = _gdip_source_stdio_skip_input_data;
+    src->parent.resync_to_restart = jpeg_resync_to_restart;
+    src->parent.bytes_in_buffer = 0;
+    src->parent.next_input_byte = NULL;
+
+    src->infp = fp;
+    
+    jpeg_read_header (&cinfo, TRUE);
+
+    cinfo.do_fancy_upsampling = FALSE;
+    cinfo.do_block_smoothing = FALSE;
+    jpeg_start_decompress (&cinfo);
+
+    img->image.type = imageBitmap;
+    img->image.graphics = 0;
+    img->image.width = cinfo.output_width;
+    img->image.height = cinfo.output_height;
+
+    if (cinfo.out_color_space != JCS_GRAYSCALE &&
+        cinfo.out_color_space != JCS_RGB)
+    {
+        g_warning ("Unsupported JPEG color space: %d", cinfo.out_color_space);
+        jpeg_destroy_decompress (&cinfo);
+        gdip_bitmap_dispose (img);
+        *image = NULL;
+        return InvalidParameter;
+    }
+
+    if (cinfo.out_color_components == 1) {
+        img->image.pixFormat = Alpha;
+        img->cairo_format = CAIRO_FORMAT_A8;
+        img->data.Stride = cinfo.out_color_components * cinfo.output_width;
+        img->data.PixelFormat = img->image.pixFormat;
+    } else if (cinfo.out_color_components == 3) {
+        /* We need to expand the data out to 32bpp for cairo */
+        img->image.pixFormat = Format32bppArgb;
+        img->cairo_format = CAIRO_FORMAT_ARGB32;
+        img->data.Stride = 4 * cinfo.output_width;
+        img->data.PixelFormat = img->image.pixFormat;
+    } else if (cinfo.out_color_components == 4) {
+        img->image.pixFormat = Format32bppArgb;
+        img->cairo_format = CAIRO_FORMAT_ARGB32;
+        img->data.Stride = cinfo.out_color_components * cinfo.output_width;
+        img->data.PixelFormat = img->image.pixFormat;
+    } else {
+        g_warning ("Unsupported JPEG out_color_components: %d", cinfo.out_color_components);
+        jpeg_destroy_decompress (&cinfo);
+        gdip_bitmap_dispose (img);
+        *image = NULL;
+        return InvalidParameter;
+    }
+
+    img->data.Width = img->image.width;
+    img->data.Height = img->image.height;
+
+    stride = img->data.Stride;
+
+    destbuf = GdipAlloc (stride * cinfo.output_height);
+    destptr = destbuf;
+
+    img->data.Scan0 = destbuf;
+    img->data.Reserved = GBD_OWN_SCAN0;
+
+    jpeg_start_decompress (&cinfo);
+
+    while (cinfo.output_scanline < cinfo.output_height) {
+        int i;
+        for (i = 0; i < cinfo.rec_outbuf_height; i++) {
+            lines[i] = destptr;
+            destptr += stride;
+        }
+
+        jpeg_read_scanlines (&cinfo, lines, cinfo.rec_outbuf_height);
+
+        /* if we have RGB data, we need to expand this out to ARGB */
+        if (cinfo.out_color_components == 3) {
+            for (i = 0; i < cinfo.rec_outbuf_height; i++) {
+                int j;
+                guchar *inptr, *outptr;
+                JOCTET r, g, b;
+
+                inptr = lines[i] + (img->image.width) * 3 - 1;
+                outptr = lines[i] + stride - 1;
+                for (j = 0; j < img->image.width; j++) {
+                    /* Note the swapping of R and B, to get ARGB from what
+                     * looks like BGR data.
+                     * We really need to do some tests to see what this stuff
+                     * looks like inside windows.
+                     */
+                    r = *inptr--;
+                    g = *inptr--;
+                    b = *inptr--;
+                    *outptr-- = 255;
+                    *outptr-- = b;
+                    *outptr-- = g;
+                    *outptr-- = r;
+                }
+            }
+        }
+    }
+
+    img->image.surface = cairo_surface_create_for_image (destbuf, img->cairo_format,
+                                                   img->image.width, img->image.height,
+                                                   stride);
+    img->image.horizontalResolution = gdip_get_display_dpi ();
+    img->image.verticalResolution = gdip_get_display_dpi ();
+    img->image.propItems = NULL;
+    img->image.palette = NULL;
+
+    *image = (GpImage *) img;
+    return Ok;
+}
+
 GpStatus 
-gdip_load_jpeg_image_from_file (FILE *fp, GpImage *image)
+gdip_save_jpeg_image_to_file (FILE *fp, GpImage *image)
 {
-	image = (GpImage *) gdip_image_new ();
-	image->type = imageBitmap;
 	return NotImplemented;
 }
+
+#else
+
+/* No libjpeg */
+GpStatus
+gdip_load_jpeg_image_from_file (FILE *fp, GpImage **image)
+{
+    *image = NULL;
+    return NotImplemented;
+}
+
+GpStatus 
+gdip_save_jpeg_image_to_file (FILE *fp, GpImage *image)
+{
+    return NotImplemented;
+}
+
+#endif
Index: src/jpegcodec.h
===================================================================
RCS file: /cvs/public/libgdiplus/src/jpegcodec.h,v
retrieving revision 1.1
diff -u -w -b -u -r1.1 jpegcodec.h
--- src/jpegcodec.h	20 Mar 2004 22:29:32 -0000	1.1
+++ src/jpegcodec.h	4 Apr 2004 10:03:22 -0000
@@ -3,6 +3,7 @@
  *
  * Authors:
  *  	Sanjay Gupta (gsanjay@novell.com)
+ *      Vladimir Vukicevic (vladimir@pobox.com)
  *
  * Copyright (C) Novell, Inc. 2003-2004.
  */
@@ -12,7 +13,7 @@
 #include "gdip.h"
 
 GpStatus 
-gdip_load_jpeg_image_from_file (FILE *fp, GpImage *image);
+gdip_load_jpeg_image_from_file (FILE *fp, GpImage **image);
 
 GpStatus 
 gdip_save_jpeg_image_to_file (FILE *fp, GpImage *image);
Index: src/pngcodec.c
===================================================================
RCS file: /cvs/public/libgdiplus/src/pngcodec.c,v
retrieving revision 1.4
diff -u -w -b -u -r1.4 pngcodec.c
--- src/pngcodec.c	31 Mar 2004 13:39:05 -0000	1.4
+++ src/pngcodec.c	4 Apr 2004 10:03:22 -0000
@@ -54,7 +54,7 @@
 	PNGHeader header;
 	GpStatus status = Ok;
 	
-	image = (GpImage *) gdip_image_new ();
+/*	image = (GpImage *) gdip_image_new (); */
 	if (image == NULL)
 		return OutOfMemory;
 
Index: src/tiffcodec.c
===================================================================
RCS file: /cvs/public/libgdiplus/src/tiffcodec.c,v
retrieving revision 1.1
diff -u -w -b -u -r1.1 tiffcodec.c
--- src/tiffcodec.c	20 Mar 2004 22:29:32 -0000	1.1
+++ src/tiffcodec.c	4 Apr 2004 10:03:22 -0000
@@ -1,8 +1,10 @@
-/*
+/* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*-
+ *
  * tiffcodec.c : Contains function definitions for encoding decoding tiff images
  *
  * Authors:
  *  	Sanjay Gupta (gsanjay@novell.com)
+ *	Vladimir Vukicevic (vladimir@pobox.com)
  *
  * Copyright (C) Novell, Inc. 2003-2004.
  */
@@ -10,10 +12,97 @@
 #include <stdio.h>
 #include "tiffcodec.h"
 
+#ifdef HAVE_LIBTIFF
+
+/* Thankfully, libtiff sucks far less than libjpeg */
+#include <tiffio.h>
+
 GpStatus 
-gdip_load_tiff_image_from_file (FILE *fp, GpImage *image)
+gdip_load_tiff_image_from_file (FILE *fp, GpImage **image)
+{
+    GpBitmap *img = NULL;
+    TIFF *tif = NULL;
+    guint32 *raster = NULL;
+
+    tif = TIFFFdOpen(fileno (fp), "lose.tif", "r");
+    if (tif) {
+        TIFFRGBAImage tifimg;
+        char emsg[1024];
+
+        if (TIFFRGBAImageBegin(&tifimg, tif, 0, emsg)) {
+            size_t npixels;
+
+            img = gdip_bitmap_new ();
+            img->image.type = imageBitmap;
+            img->image.graphics = 0;
+            img->image.width = tifimg.width;
+            img->image.height = tifimg.height;
+            /* libtiff expands stuff out to ARGB32 for us if we use this interface */
+            img->image.pixFormat = Format32bppArgb;
+            img->cairo_format = CAIRO_FORMAT_ARGB32;
+            img->data.Stride = tifimg.width * 4;
+            img->data.PixelFormat = img->image.pixFormat;
+            img->data.Width = img->image.width;
+            img->data.Height = img->image.height;
+
+            npixels = tifimg.width * tifimg.height;
+            /* Note that we don't use _TIFFmalloc */
+            raster = (guint32*) GdipAlloc (npixels * sizeof (guint32));
+            if (raster != NULL) {
+                if (TIFFRGBAImageGet(&tifimg, raster, tifimg.width, tifimg.height)) { 
+                    img->data.Scan0 = raster;
+                    img->data.Reserved = GBD_OWN_SCAN0;
+                }
+            } else {
+                goto error;
+            }
+
+            TIFFRGBAImageEnd(&tifimg);
+        } else {
+            goto error;
+        }
+
+        TIFFClose(tif);
+    } else {
+        goto error;
+    }
+
+    *image = img;
+    return Ok;
+
+  error:
+
+    if (raster)
+        GdipFree (raster);
+    if (img)
+        gdip_bitmap_dispose (img);
+    if (tif)
+        TIFFClose(tif);
+    *image = NULL;
+    return InvalidParameter;
+}
+
+GpStatus 
+gdip_save_tiff_image_to_file (FILE *fp, GpImage *image)
+{
+    return NotImplemented;
+}
+
+#else
+
+/* no libtiff */
+
+GpStatus 
+gdip_load_tiff_image_from_file (FILE *fp, GpImage **image)
+{
+    *image = NULL;
+    return NotImplemented;
+}
+
+GpStatus 
+gdip_save_tiff_image_to_file (FILE *fp, GpImage *image)
 {
-	image = (GpImage *) gdip_image_new ();
-	image->type = imageBitmap;
 	return NotImplemented;
 }
+
+#endif
Index: src/tiffcodec.h
===================================================================
RCS file: /cvs/public/libgdiplus/src/tiffcodec.h,v
retrieving revision 1.1
diff -u -w -b -u -r1.1 tiffcodec.h
--- src/tiffcodec.h	20 Mar 2004 22:29:32 -0000	1.1
+++ src/tiffcodec.h	4 Apr 2004 10:03:22 -0000
@@ -3,6 +3,7 @@
  *
  * Authors:
  *  	Sanjay Gupta (gsanjay@novell.com)
+ *      Vladimir Vukicevic (vladimir@pobox.com)
  *
  * Copyright (C) Novell, Inc. 2003-2004.
  */
@@ -12,7 +13,7 @@
 #include "gdip.h"
 
 GpStatus 
-gdip_load_tiff_image_from_file (FILE *fp, GpImage *image);
+gdip_load_tiff_image_from_file (FILE *fp, GpImage **image);
 
 GpStatus 
 gdip_save_tiff_image_to_file (FILE *fp, GpImage *image);
