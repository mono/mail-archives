Index: configure.in
===================================================================
--- configure.in	(revision 69965)
+++ configure.in	(working copy)
@@ -1623,7 +1623,7 @@
 		JIT_SUPPORTED=yes
 		jit_wanted=true
 		arch_target=alpha;
-		CFLAGS="$CFLAGS -mieee"
+		CFLAGS="$CFLAGS -mieee -O0"
 		case $host_os in
 		  linux*)
 			LIBC="libc.so.6.1"
@@ -1797,7 +1797,7 @@
 fi
 
 mono_debugger_supported=no
-if test "x$TARGET" = "xAMD64" -o "x$TARGET" = "xX86"; then
+if test "x$TARGET" = "xAMD64" -o "x$TARGET" = "xX86" -o "x$TARGET" = "xALPHA"; then
 	if test x$use_included_gc = xyes; then
 		case "$host" in
 		*-*-*linux*)
Index: mono/arch/alpha/alpha-codegen.h
===================================================================
--- mono/arch/alpha/alpha-codegen.h	(revision 69965)
+++ mono/arch/alpha/alpha-codegen.h	(working copy)
@@ -562,7 +562,8 @@
 #define alpha_cpysn(ins,  Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x17, 0x021, Rsrc1, Rsrc2, Rdest )
 #define alpha_cpyse(ins,  Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x17, 0x022, Rsrc1, Rsrc2, Rdest )
 
-#define	alpha_trapb(ins)	alpha_encode_op(ins, 0x18, 0, 0, 0, 0);
+#define	alpha_trapb(ins)	alpha_encode_mem_fc( ins, 0x18, 0x0000, 0, 0, 0 )
+#define	alpha_mb(ins)		alpha_encode_mem_fc( ins, 0x18, 0x4000, 0, 0, 0 )
 
 #endif
 
Index: mono/mini/mini-alpha.h
===================================================================
--- mono/mini/mini-alpha.h	(revision 69965)
+++ mono/mini/mini-alpha.h	(working copy)
@@ -64,6 +64,9 @@
   guint64     eip;          // RA ? or caller PC
   guint64     rsp;          // SP ? caller SP
   guint64     rgp;          // GP
+  guint64     r14;
+  guint64     r13;
+  guint64     r12;
 };
 
 #define MONO_ARCH_FRAME_ALIGNMENT 8
Index: mono/mini/mini-alpha.c
===================================================================
--- mono/mini/mini-alpha.c	(revision 69965)
+++ mono/mini/mini-alpha.c	(working copy)
@@ -1554,7 +1554,7 @@
 	       {
 		 CFG_DEBUG(3) g_print("ALPHA: Saved aggregate arg reg %d at offset: %0lx\n",
 				      ainfo->reg + j, inst->inst_offset + (8*j));
-		 alpha_stq(code, ainfo->reg+j, inst->inst_basereg,
+		 alpha_stq(code, (ainfo->reg+j), inst->inst_basereg,
 			   (inst->inst_offset + (8*j)));
 		 offset += 8;
 	       }
@@ -1675,9 +1675,10 @@
 guint32
 mono_arch_regalloc_cost (MonoCompile *cfg, MonoMethodVar *vmv)
 {
+  MonoInst *ins = cfg->varinfo [vmv->idx];
+
    /* FIXME: */
   CFG_DEBUG(2) ALPHA_DEBUG("mono_arch_regalloc_cost");
-  MonoInst *ins = cfg->varinfo [vmv->idx];
 
   if (cfg->method->save_lmf)
     /* The register is already saved */
@@ -1784,11 +1785,11 @@
 mono_arch_emit_epilog (MonoCompile *cfg)
 {
   MonoMethod *method = cfg->method;
-  int quad, offset, i;
+  int offset, i;
   unsigned int *code;
   int max_epilog_size = 128;
   int stack_size = cfg->arch.stack_size;
-  CallInfo *cinfo;
+  //  CallInfo *cinfo;
   gint32 lmf_offset = cfg->arch.lmf_offset;
   
   CFG_DEBUG(2) ALPHA_DEBUG("mono_arch_emit_epilog");
@@ -2365,17 +2366,17 @@
            // Shift 32 bit unsigned value right
            CFG_DEBUG(4) g_print("ALPHA_CHECK: [int_shr_un] dreg=%d, sreg1=%d, sreg2=%d\n",
                   ins->dreg, ins->sreg1, ins->sreg2);
-	   alpha_zap_(code, ins->sreg1, 0xF0, ins->dreg);
-           alpha_srl(code, ins->dreg, ins->sreg2, ins->dreg);
+	   alpha_zap_(code, ins->sreg1, 0xF0, alpha_at /*ins->dreg*/);
+           alpha_srl(code, alpha_at /*ins->dreg*/, ins->sreg2, ins->dreg);
            break;
 
          case OP_ISHR_UN_IMM:
            // Shift 32 bit unassigned value rigth by constant
            g_assert(alpha_is_imm(ins->inst_imm));
            CFG_DEBUG(4) g_print("ALPHA_CHECK: [int_shr_un_imm] dreg=%d, sreg1=%d, const=%ld\n",
-                  ins->dreg, ins->sreg1, ins->inst_imm);
-	   alpha_zap_(code, ins->sreg1, 0xF0, ins->dreg);
-           alpha_srl_(code, ins->dreg, ins->inst_imm, ins->dreg);
+				ins->dreg, ins->sreg1, ins->inst_imm);
+	   alpha_zap_(code, ins->sreg1, 0xF0, alpha_at /*ins->dreg*/);
+           alpha_srl_(code, alpha_at /*ins->dreg*/, ins->inst_imm, ins->dreg);
            break;
 
          case OP_LSHR_UN_IMM:
@@ -2872,7 +2873,7 @@
 	   // Valid only for storing 0
 	   // storei1_membase_reg will do the rest
 	   
-	   CFG_DEBUG(4) g_printf("ALPHA_CHECK: [storei1_membase_imm(0)] const=%0lx, destbasereg=%d, offset=%0lx\n",
+	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [storei1_membase_imm(0)] const=%0lx, destbasereg=%d, offset=%0lx\n",
 		  ins->inst_imm, ins->inst_destbasereg, ins->inst_offset);
 	   g_assert(ins->inst_imm == 0);
 
@@ -2912,7 +2913,7 @@
 	   // Now work only for storing 0
            // For now storei2_membase_reg will do the work
 	   
-	   CFG_DEBUG(4) g_printf("ALPHA_CHECK: [storei2_membase_imm(0)] const=%0lx, destbasereg=%d, offset=%0lx\n",
+	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [storei2_membase_imm(0)] const=%0lx, destbasereg=%d, offset=%0lx\n",
 		  ins->inst_imm, ins->inst_destbasereg, ins->inst_offset);
 	   
 	   g_assert(ins->inst_imm == 0);
@@ -3772,7 +3773,7 @@
 	     // of by call_filter. There should be difference. For now just
 	     // handle - call_handler
 
-	     CFG_DEBUG(4) g_print("ALPHA_CHECK: [start_handler] basereg=%d, offset=%0x\n",
+	     CFG_DEBUG(4) g_print("ALPHA_CHECK: [start_handler] basereg=%d, offset=%0lx\n",
 		ins->inst_left->inst_basereg, ins->inst_left->inst_offset);
 
 	     alpha_stq(code, alpha_ra, ins->inst_left->inst_basereg, 
@@ -3783,7 +3784,7 @@
 	 case CEE_ENDFINALLY:
 	   {
              // Keep in sync with start_handler
-             CFG_DEBUG(4) g_print("ALPHA_CHECK: [endfinally] basereg=%d, offset=%0x\n",
+             CFG_DEBUG(4) g_print("ALPHA_CHECK: [endfinally] basereg=%d, offset=%0lx\n",
                 ins->inst_left->inst_basereg, ins->inst_left->inst_offset);
 
              alpha_ldq(code, alpha_ra, ins->inst_left->inst_basereg,
@@ -3796,7 +3797,7 @@
 	 case OP_ENDFILTER:
 	   {
 	     // Keep in sync with start_handler
-	     CFG_DEBUG(4) g_print("ALPHA_CHECK: [endfilter] sreg1=%d, basereg=%d, offset=%0x\n",
+	     CFG_DEBUG(4) g_print("ALPHA_CHECK: [endfilter] sreg1=%d, basereg=%d, offset=%0lx\n",
 		ins->sreg1, ins->inst_left->inst_basereg, ins->inst_left->inst_offset);
 
 	     alpha_ldq(code, alpha_ra, ins->inst_left->inst_basereg,
@@ -3832,7 +3833,7 @@
 	   break;
 
 	 case CEE_THROW:
-	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [throw] sreg1=%0lx\n",
+	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [throw] sreg1=%0x\n",
 				ins->sreg1);
 	   alpha_mov1(code, ins->sreg1, alpha_a0);
 	   code = emit_call (cfg, code, MONO_PATCH_INFO_INTERNAL_METHOD,
@@ -3840,7 +3841,7 @@
 	   break;
 
          case OP_RETHROW:
-           CFG_DEBUG(4) g_print("ALPHA_CHECK: [rethrow] sreg1=%0lx\n",
+           CFG_DEBUG(4) g_print("ALPHA_CHECK: [rethrow] sreg1=%0x\n",
                                 ins->sreg1);
            alpha_mov1(code, ins->sreg1, alpha_a0);
            code = emit_call (cfg, code, MONO_PATCH_INFO_INTERNAL_METHOD,
@@ -3849,14 +3850,15 @@
 
 	 case CEE_JMP:
 	   {
-	     CFG_DEBUG(4) g_print("ALPHA_CHECK: [jmp] %p\n", ins->inst_p0);
 	     /*
-	      * Note: this 'frame destruction' logic is useful for tail calls, too.
-	      * Keep in sync with the code in emit_epilog.
+	      * Note: this 'frame destruction' logic is useful for tail calls,
+	      too. Keep in sync with the code in emit_epilog.
 	      */
-	     int pos = 0, i, offset;
+	     int offset;
 	     AlphaGotData ge_data;
 
+	     CFG_DEBUG(4) g_print("ALPHA_CHECK: [jmp] %p\n", ins->inst_p0);
+
 	     /* FIXME: no tracing support... */
 	     if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
 	       code = mono_arch_instrument_epilog (cfg,
@@ -3887,6 +3889,11 @@
 	   mono_add_patch_info (cfg, offset,
 				(MonoJumpInfoType)ins->inst_i1, ins->inst_p0);
 	   break;
+
+	 case OP_MEMORY_BARRIER:
+	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [mb]\n");
+	   alpha_mb(code);
+	   break;
 	   
 	 default:
 	   g_warning ("unknown opcode %s in %s()\n",
@@ -4074,7 +4081,7 @@
 
 	case MONO_PATCH_INFO_GOT_OFFSET:
 	  {
-	    unsigned int *ip2 = ip;
+	    unsigned int *ip2 = (unsigned int *)ip;
 	    unsigned int inst = *ip2;
 	    unsigned int off = patch_info->data.offset & 0xFFFFFFFF;
 
@@ -4089,7 +4096,7 @@
 	case MONO_PATCH_INFO_CLASS_INIT: 
 	  {		  
 	    /* Might already been changed to a nop */
-	    unsigned int* ip2 = ip;
+	    unsigned int* ip2 = (unsigned int *)ip;
 	   unsigned long t_addr = (unsigned long)target;
  
 	    if (*ip2 != (t_addr & 0xFFFFFFFF) ||
@@ -5867,14 +5874,15 @@
 
   // Check for (call_membase):
   // -4: mov     v0,a0        - load this ???
-  // -3: ldq     v0,0(v0)     - load vtable
+  // -3: ldq     v0,0(v0)     - load vtable 
   // -2: ldq     t12,64(v0)   - load method (object->vtable->vtable[method->slot])
-  if ((pc[start_index-1] & 0xFFFFFFFF) == 0xA4000000 &&
+  if ((pc[start_index-1] & 0xFC00FFFF) == 0xA4000000 &&
       (pc[start_index] & 0xFFFF0000) == 0xA7600000
       )
     {
       disp = pc[start_index] & 0xFFFF;
-      reg = 0; // For now
+      reg = (pc[start_index-1] >> AXP_REG1_SHIFT) & AXP_REG_MASK;
+      //reg = 0; // For now
 
       ALPHA_PRINT g_debug("ALPHA_CHECK: [mono_arch_get_vcall_slot_addr callvirt] call_membase");
 
@@ -5886,7 +5894,7 @@
   // -4: ldq     v0,0(v0)
   // -3: ldq     v0,-n(v0)
   // -2: ldq     t12,0(v0)
-  if ((pc[start_index-2] & 0xFFFFFFFF) == 0xA4000000 &&
+  if ((pc[start_index-2] & 0xFC00FFFF) == 0xA4000000 &&
       (pc[start_index-1] & 0xFFFF0000) == 0xA4000000 &&
       (pc[start_index] & 0xFFFF0000) == 0xA7600000
       )
Index: mono/mini/Makefile.am
===================================================================
--- mono/mini/Makefile.am	(revision 69965)
+++ mono/mini/Makefile.am	(working copy)
@@ -243,8 +243,12 @@
 if AMD64
 mono_debugger_arch_sources = mdb-debug-info64.s
 else
+if ALPHA
+mono_debugger_arch_sources = mdb-debug-info64.s
+else
 mono_debugger_arch_sources = mdb-debug-info32.s
 endif
+endif
 mono_debugger_sources = debug-debugger.c debug-debugger.h $(mono_debugger_arch_sources)
 else
 mono_debugger_sources =
@@ -335,7 +339,7 @@
 
 if ALPHA
 arch_sources = \
-	$(alpha_sources)
+	$(alpha_sources) $(mono_debugger_sources)
 
 arch_BURGSRC = $(srcdir)/inssel-long.brg $(srcdir)/inssel-alpha.brg
 arch_built = cpu-alpha.h
Index: mono/mini/inssel-alpha.brg
===================================================================
--- mono/mini/inssel-alpha.brg	(revision 69965)
+++ mono/mini/inssel-alpha.brg	(working copy)
@@ -337,6 +337,9 @@
 #        mono_bblock_add_inst (s->cbb, tree);
 #}
 
+#stmt: CEE_BEQ (OP_LCOMPARE(reg, OP_I8CONST)) {
+#	printf("Found match for CEE_BEQ (OP_LCOMPARE(reg, OP_I8CONST))\n");
+#}
 
 stmt: CEE_BLT_UN (OP_COMPARE (freg, freg)) {
         MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
@@ -383,7 +386,8 @@
                 state->left->left->reg1, state->left->right->reg1);
         MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
 
-        tree->opcode = OP_FCEQ;
+        tree->dreg = state->reg1;
+	tree->opcode = OP_FCEQ;
         mono_bblock_add_inst (s->cbb, tree);
 }
 
@@ -392,6 +396,7 @@
                 state->left->left->reg1, state->left->right->reg1);
         MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
 
+	tree->dreg = state->reg1;
         tree->opcode = OP_FCLT;
         mono_bblock_add_inst (s->cbb, tree);
 }
@@ -403,6 +408,7 @@
                 state->left->left->reg1, state->left->right->reg1);
         MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
 
+	tree->dreg = state->reg1;
         tree->opcode = OP_FCLT_UN;
         mono_bblock_add_inst (s->cbb, tree);
 }
@@ -416,6 +422,7 @@
         MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
 
 //        tree->opcode = OP_FCGT;
+	tree->dreg = state->reg1;
 	tree->opcode = OP_FCLT;
         mono_bblock_add_inst (s->cbb, tree);
 }
@@ -428,6 +435,7 @@
                 state->left->right->reg1, state->left->left->reg1);
         MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
 
+	tree->dreg = state->reg1;
         tree->opcode = OP_FCLT_UN;
         mono_bblock_add_inst (s->cbb, tree);
 }
Index: mono/mini/tramp-alpha.c
===================================================================
--- mono/mini/tramp-alpha.c	(revision 69965)
+++ mono/mini/tramp-alpha.c	(working copy)
@@ -508,6 +508,21 @@
 
   ALPHA_DEBUG("mono_arch_nullify_class_init_trampoline");
 
+  // pcode[-2] ldq     t12,n(gp)
+  // pcode[-1] jsr     ra,(t12),0x20003efcb40
+  if ((pcode[-2] & 0xFFFF0000) == 0xa77d0000 &&
+       pcode[-1] == 0x6b5b4000)
+  {
+      // Put "unop" into call inst
+      pcode--;
+      alpha_nop(pcode);
+      alpha_nop(pcode);
+      alpha_nop(pcode);
+
+      mono_arch_flush_icache ((code-4), 3*4);
+  }
+  else
+      g_assert_not_reached ();
 }
 
 /*
@@ -535,9 +550,9 @@
   // -2 - mov     v0,t12
   // -1 - jsr     ra,(t12),0x200041476e4
   //  0 - ldah    gp,0(ra)
-  if (((pcode[-4] & 0xFF000000) == 0xA4000000) &&
-      ((pcode[-3] & 0xFF000000) == 0xA4000000) &&
-      ((pcode[-2] & 0xFF00FF00) == 0x47000400) &&
+  if (((pcode[-4] & 0xFC000000) == 0xA4000000) &&
+      ((pcode[-3] & 0xFC000000) == 0xA4000000) &&
+      ((pcode[-2] & 0xFC000FE0) == 0x44000400) &&
       ((pcode[-1] & 0xFFFF0000) == 0x6B5B0000))
     {
       fp_disp = (pcode[-4] & 0xFFFF);
@@ -547,7 +562,6 @@
       obj = *pobj;
       reg = 0;
     }
-  else
     // The non-optimized call signature for now is
     // -5 - ldq     v0,24(fp)
     // -4 - mov     v0,v0
@@ -555,22 +569,40 @@
     // -2 - mov     v0,t12
     // -1 - jsr     ra,(t12),0x200041476e4
     //  0 - ldah    gp,0(ra)
-    if (((pcode[-5] & 0xFF000000) == 0xA4000000) &&
-	((pcode[-4] & 0xFF00FF00) == 0x47000400) &&
-	((pcode[-3] & 0xFF000000) == 0xA4000000) &&
-	((pcode[-2] & 0xFF00FF00) == 0x47000400) &&
-	((pcode[-1] & 0xFFFF0000) == 0x6B5B0000))
-      {
-	fp_disp = (pcode[-5] & 0xFFFF);
-	obj_disp = (pcode[-3] & 0xFFFF);
+  else if (((pcode[-5] & 0xFC000000) == 0xA4000000) &&
+	   ((pcode[-4] & 0xFC000FE0) == 0x44000400) &&
+	   ((pcode[-3] & 0xFC000000) == 0xA4000000) &&
+	   ((pcode[-2] & 0xFC000FE0) == 0x44000400) &&
+	   ((pcode[-1] & 0xFFFF0000) == 0x6B5B0000))
+    {
+      fp_disp = (pcode[-5] & 0xFFFF);
+      obj_disp = (pcode[-3] & 0xFFFF);
 
-	pobj = regs[15] + fp_disp;
-	obj = *pobj;
-	reg = 0;
-      }
-    else
-      g_assert_not_reached ();
+      pobj = regs[15] + fp_disp;
+      obj = *pobj;
+      reg = 0;
+    }
+      // Code with linears optimization
+      // -4 - mov     reg,v0
+      // -3 - ldq     v0,40(v0)
+      // -2 - mov     v0,t12
+      // -1 - jsr     ra,(t12)
+      //  0 - ldah    gp,0(ra)
+  else if (((pcode[-4] & 0xFC000FE0) == 0x44000400) &&
+	   ((pcode[-3] & 0xFC000000) == 0xA4000000) &&
+	   ((pcode[-2] & 0xFC000FE0) == 0x44000400) &&
+	   ((pcode[-1] & 0xFFFF0000) == 0x6B5B0000))
+    {
+      fp_disp = (pcode[-4] >> AXP_REG2_SHIFT) & AXP_REG_MASK;
+      obj_disp = (pcode[-3] & 0xFFFF);
 
+      obj = regs[fp_disp];
+      //obj = *pobj;
+      reg = 0;
+    }
+  else
+    g_assert_not_reached ();
+
   *((gpointer*)(obj + obj_disp)) = addr;
 }
 
