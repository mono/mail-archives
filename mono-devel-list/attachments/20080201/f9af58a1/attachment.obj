Index: System.Data.Common/Key.cs
===================================================================
--- System.Data.Common/Key.cs	(revision 62794)
+++ System.Data.Common/Key.cs	(working copy)
@@ -34,7 +34,7 @@
 
 namespace System.Data.Common
 {
-	internal class Key
+	public class Key
 	{
 		#region Fields
 
Index: System.Data.Common/Index.cs
===================================================================
--- System.Data.Common/Index.cs	(revision 62794)
+++ System.Data.Common/Index.cs	(working copy)
@@ -42,130 +42,74 @@
 	internal class Index
 	{
 		#region Fields
-
-		int[] _array;
-		int _size;
 		Key _key;
 		int _refCount = 0;
-		IndexDuplicatesState _hasDuplicates;
 
 		#endregion // Fields
 
 		#region Constructors
 
-		internal Index(Key key)
+		internal Index (Key key)
 		{
 			_key = key;
-			Reset();
+			_container = new RBTree (Key);
+			RebuildIndex ();
 		}
 
 		#endregion // Constructors
 
 		#region Properties
 
-		internal Key Key 
-		{
-			get {
-				return _key;
+		RBTree _container;
+		internal RBTree Container {
+			get { 
+				if (_container == null)
+					Reset ();
+				return _container; 
 			}
 		}
 
-		internal int Size
-		{
-			get {
-				EnsureArray();
-				return _size;
-			}
+		internal int Size {
+			get { return Container.Count; }
 		}
 
-		internal int RefCount
-		{
-			get {
-				return _refCount;
-			}
+		internal bool HasDuplicates {
+			get { return Container.HasDuplicates; }
 		}
 
-		internal int IndexToRecord(int index){
-			return index < 0 ? index : Array[index];
+		internal int[] Duplicates {
+			get { return Container.Duplicates; }
 		}
 
-		private int[] Array
-		{
-			get {
-				EnsureArray();
-				return _array;
-			}
+		internal Key Key {
+			get { return _key; }
 		}
 
-		internal bool HasDuplicates
-		{
-			get {
-				if (_array == null || _hasDuplicates == IndexDuplicatesState.Unknown) {
-					EnsureArray();
-					if (_hasDuplicates == IndexDuplicatesState.Unknown) {
-						// check for duplicates
-						_hasDuplicates = IndexDuplicatesState.False;
-						for(int i = 0; i < Size - 1; i++) {
-							if (Key.CompareRecords(Array[i],Array[i+1]) == 0) {
-								_hasDuplicates = IndexDuplicatesState.True;
-								break;
-							}
-						}
-					}
-				}
-				return (_hasDuplicates == IndexDuplicatesState.True);
-			}
+		internal int RefCount {
+			get { return _refCount; }
 		}
 
+
 		#endregion // Properties
 
 		#region Methods
-
-		internal int[] Duplicates {
-			get {
-				if (!HasDuplicates)
-					return null;
-
-				ArrayList dups = new ArrayList();
-
-				bool inRange = false;
-				for(int i = 0; i < Size - 1; i++) {
-					if (Key.CompareRecords(Array[i],Array[i+1]) == 0){
-						if (!inRange) {
-							dups.Add(Array[i]);
-							inRange = true;
-						}
-
-						dups.Add(Array[i+1]);
-					}
-					else
-						inRange = false;
-				}
-
-				return (int[])dups.ToArray(typeof(int));
-			}
-		}
-
-		private void EnsureArray()
+		internal DataRow[] GetAllRows ()
 		{
-			if (_array == null) {
-				RebuildIndex();
-			}
-		}
+			DataRow[] dataRows = Key.Table.NewRowArray (Size);
+			int [] records = Container.GetSortedList ();
 
-		internal int[] GetAll()
-		{
-			return Array;
+			for (int i = 0; i < dataRows.Length; i++)
+				dataRows[i] = Key.Table.RecordCache [records [i]];
+			return dataRows;
 		}
 
-		internal DataRow[] GetAllRows ()
+		internal DataRow[] GetDistinctRows () 
 		{
-			DataRow[] list = new DataRow [Size];
-			for (int i=0; i < Size; ++i)
-				list [i] = Key.Table.RecordCache [Array [i]];
-			return list;
+			throw new NotImplementedException ();
+			//FIXME : use the new implementation to get the 
+			//distinct rows.
 		}
-
+/*
 		internal DataRow[] GetDistinctRows () 
 		{
 			ArrayList list = new ArrayList ();
@@ -179,543 +123,169 @@
 			}
 			return (DataRow[])list.ToArray (typeof (DataRow));
 		}
+*/
 
 		internal void Reset()
 		{
-			_array = null;
-			RebuildIndex();
+			_container = new RBTree (Key);
+			RebuildIndex ();
 		}
 
-		private void RebuildIndex()
+		internal void RebuildIndex ()
 		{
-			// consider better capacity approximation
-			_array = new int[Key.Table.RecordCache.CurrentCapacity];
-			_size = 0;
-			foreach(DataRow row in Key.Table.Rows) {
-				int record = Key.GetRecord(row);
-				if (record != -1) {
-					_array[_size++] = record;
-				}
+			if (_container == null)
+				_container = new RBTree (Key);
+			int record = -1;
+			foreach (DataRow row in Key.Table.Rows) {
+				record = Key.GetRecord (row);
+				if (record != -1)
+					_container.Add (record);
 			}
-			_hasDuplicates = IndexDuplicatesState.False;
-			// Note : MergeSort may update hasDuplicates to True
-			Sort();
 		}
 
-		private void Sort()
+		internal int Find (object key)
 		{
-			//QuickSort(Array,0,Size-1);
-			MergeSort(Array,Size);
+			return Find (new object[] {key});
 		}
-		
-		/*
-		 * Returns record number of the record equal to the key values supplied 
-		 * in the meaning of index key, or -1 if no equal record found.
-		 */
-		internal int Find(object[] keys)
+
+		internal int Find (int record)
 		{
-			int index = FindIndex(keys);
-			return IndexToRecord(index);
+			return NodeToRecord (Container.Find (record));
 		}
+	
+		int NodeToRecord (RBNode node)
+		{
+			return node.Record;
+		}
 
-		/*
-		 * Returns record index (location) of the record equal to the key values supplied 
-		 * in the meaning of index key, or -1 if no equal record found.
-		 */
-		internal int FindIndex(object[] keys)
+		int[] NodesToRecords (RBNode[] nodes)
 		{
-			if (keys == null || keys.Length != Key.Columns.Length) {
+			int[] records = new int [nodes.Length];
+			for (int i=0; i<records.Length; ++i)
+				records [i] = NodeToRecord (nodes [i]);
+			return records;
+		}
+
+
+		internal int Find (object[] keys)
+		{
+			if (keys == null || keys.Length != Key.Columns.Length)
 				throw new ArgumentException("Expecting " + Key.Columns.Length + " value(s) for the key being indexed, " +
-					"but received " + ((keys == null) ? 0 : keys.Length) + " value(s).");
-			}
+						"but received " + ((keys == null) ? 0 : keys.Length) + " value(s).");
 
-			int tmp = Key.Table.RecordCache.NewRecord();
+			int tmp = Key.Table.RecordCache.NewRecord ();
 			try {
-				// init key values for temporal record
-				for(int i = 0; i < Key.Columns.Length; i++) {
+				for(int i = 0; i < Key.Columns.Length; i++)
 					Key.Columns[i].DataContainer[tmp] = keys[i];
-				}
-				return FindIndex(tmp);
-			}
-//			catch(FormatException) {
-//				return -1;
-//			}
-//			catch(InvalidCastException) {
-//				return -1;
-//			}
-			finally {
+				return NodeToRecord (Container.Find (tmp));
+				
+			} finally {
 				Key.Table.RecordCache.DisposeRecord(tmp);
 			}
 		}
 
-		/*
-		 * Returns record number of the record equal to the record supplied 
-		 * in the meaning of index key, or -1 if no equal record found.
-		 */
-		internal int Find(int record)
+		internal int FindIndex (object[] keys)
 		{
-			int index = FindIndex(record);
-			return IndexToRecord(index);
+			if (keys == null || keys.Length != Key.Columns.Length)
+				throw new ArgumentException("Expecting " + Key.Columns.Length + " value(s) for the key being indexed, " +
+						"but received " + ((keys == null) ? 0 : keys.Length) + " value(s).");
+
+			int tmp = Key.Table.RecordCache.NewRecord ();
+			try {
+				for(int i = 0; i < Key.Columns.Length; i++)
+					Key.Columns[i].DataContainer[tmp] = keys[i];
+				return Container.FindIndex (tmp);
+			} finally {
+				Key.Table.RecordCache.DisposeRecord(tmp);
+			}
 		}
 
-		/*
-		 * Returns array of record numbers of the records equal equal to the key values supplied 
-		 * in the meaning of index key, or -1 if no equal record found.
-		 */
-		internal int[] FindAll(object[] keys)
+		internal int[] FindAll (int record)
 		{
-			int[] indexes = FindAllIndexes(keys);
-			IndexesToRecords(indexes);
-			return indexes;
+			return NodesToRecords (Container.FindAll (record));
 		}
 
-		/*
-		 * Returns array of indexes of the records inside the index equal equal to the key values supplied 
-		 * in the meaning of index key, or -1 if no equal record found.
-		 */
-		internal int[] FindAllIndexes(object[] keys)
+		internal int[] FindAll (object key)
 		{
-			if (keys == null || keys.Length != Key.Columns.Length) {
+			return FindAll (new object[] {key});
+		}
+		
+		internal int[] FindAll (object[] keys)
+		{
+			if (keys == null || keys.Length != Key.Columns.Length)
 				throw new ArgumentException("Expecting " + Key.Columns.Length + " value(s) for the key being indexed," +
 					"but received " + ((keys == null) ? 0 : keys.Length) + " value(s).");
-			}
 
 			int tmp = Key.Table.RecordCache.NewRecord();
 			try {
-				// init key values for temporal record
-				for(int i = 0; i < Key.Columns.Length; i++) {
+				for(int i = 0; i < Key.Columns.Length; i++)
 					Key.Columns[i].DataContainer[tmp] = keys[i];
-				}
-				return FindAllIndexes(tmp);
-			}
-			catch(FormatException) {
+				return NodesToRecords (Container.FindAll (tmp));
+			} catch(FormatException) {
 				return new int[0];
-			}
-			catch(InvalidCastException) {
+			} catch(InvalidCastException) {
 				return new int[0];
-			}
-			finally {
+			} finally {
 				Key.Table.RecordCache.DisposeRecord(tmp);
 			}
 		}
 
-		/*
-		 * Returns array of record numbers of the records equal to the record supplied 
-		 * in the meaning of index key, or empty list if no equal records found.
-		 */
-		internal int[] FindAll(int record)
+		internal int[] FindAllIndexes (object[] keys)
 		{
-			int[] indexes = FindAllIndexes(record);
-            IndexesToRecords(indexes);
-			return indexes;
-		}
+			if (keys == null || keys.Length != Key.Columns.Length)
+				throw new ArgumentException("Expecting " + Key.Columns.Length + " value(s) for the key being indexed," +
+					"but received " + ((keys == null) ? 0 : keys.Length) + " value(s).");
 
-		/*
-		 * Returns array of indexes of the records inside the index that equal to the record supplied 
-		 * in the meaning of index key, or empty list if no equal records found.
-		 */
-		internal int[] FindAllIndexes(int record)
-		{
-			int index = FindIndex(record);
-
-			if (index == -1) {
+			int tmp = Key.Table.RecordCache.NewRecord();
+			try {
+				for(int i = 0; i < Key.Columns.Length; i++)
+					Key.Columns[i].DataContainer[tmp] = keys[i];
+				return Container.FindAllIndexes (tmp);
+			} catch(FormatException) {
 				return new int[0];
+			} catch(InvalidCastException) {
+				return new int[0];
+			} finally {
+				Key.Table.RecordCache.DisposeRecord(tmp);
 			}
-
-			int startIndex = index++;
-			int endIndex = index;
-			
-			for(;startIndex >= 0 && Key.CompareRecords(Array[startIndex],record) == 0;startIndex--);
-			for(;endIndex < Size && Key.CompareRecords(Array[endIndex],record) == 0;endIndex++);
-			
-			int length = endIndex - startIndex - 1;
-			int[] indexes = new int[length];
-			
-			for(int i = 0; i < length; i++) {
-				indexes[i] = ++startIndex;
-			}
-			
-			return indexes;
 		}
 
-		/*
-		 * Returns index inside the array where record number of the record equal to the record supplied 
-		 * in the meaning of index key is sored, or -1 if no equal record found.
-		 */
-		private int FindIndex(int record)
+		internal void Delete (DataRow row)
 		{
-			if (Size == 0) {
-				return -1;
-			}
-			return BinarySearch(Array,0,Size - 1,record);
-		}
-
-		/*
-		 * Finds exact location of the record specified
-		 */ 
-		private int FindIndexExact(int record)
-		{
-			for (int i = 0, size = Size; i < size; i++)
-				if (Array[i] == record)
-					return i;
-
-			return -1;
-		}
-
-		/*
-		 * Returns array of records from the indexes (locations) inside the index
-		 */
-		private void IndexesToRecords(int[] indexes)
-		{
-			for(int i = 0; i < indexes.Length; i++) {
-				indexes[i] = Array[indexes[i]];
-			}
-		}
-
-		internal void Delete(DataRow row)
-		{
 			int oldRecord = Key.GetRecord(row);
-
-			Delete(oldRecord);
+			Container.Delete (oldRecord);
 		}
 
-		internal void Delete(int oldRecord)
+		internal void Update (DataRow row, int oldRecord, DataRowVersion oldVersion, DataRowState oldState)
 		{
-			if (oldRecord == -1)
-				return;
-
-			int index = FindIndexExact(oldRecord);
-			if (index != -1) {
-				if ((_hasDuplicates == IndexDuplicatesState.True)) {
-					int c1 = 1;
-					int c2 = 1;
-
-					if (index > 0) {
-						c1 = Key.CompareRecords(Array[index - 1],oldRecord);
-					}
-					if (index < Size - 1) {
-						c2 = Key.CompareRecords(Array[index + 1],oldRecord);
-					}
-
-					if (c1 == 0 ^ c2 == 0) {
-						_hasDuplicates = IndexDuplicatesState.Unknown;
-					}
-				}
-				Remove(index);
-			}
-		}
-
-		private void Remove(int index)
-		{
-			if (Size > 1) {
-				System.Array.Copy(Array,index+1,Array,index,Size - index - 1);
-			}
-			_size--;
-		}
-
-
-		internal void Update(DataRow row,int oldRecord, DataRowVersion oldVersion, DataRowState oldState)
-		{			
+			int newRecord = Key.GetRecord (row);	
 			bool contains = Key.ContainsVersion (oldState, oldVersion);
-			int newRecord = Key.GetRecord(row);	
-			// the record did not appeared in the index before update
-			if (oldRecord == -1 || Size == 0 || !contains) {
-				if (newRecord >= 0) {
-					if (FindIndexExact(newRecord) < 0)
-						Add(row,newRecord);
-				}
-				return;
-			}
-			
-			// the record will not appeare in the index after update
-			if (newRecord < 0 || !Key.CanContain (newRecord)) {
-				Delete (oldRecord);
-				return;
-			}
 
-			int oldIdx = FindIndexExact(oldRecord);
-
-			if( oldIdx == -1 ) {
-				Add(row,newRecord);
-				return;
-			}
-				
-			int newIdx = -1;
-			int compare = Key.CompareRecords(Array[oldIdx],newRecord);
-			int start,end;
-
-			int c1 = 1;
-			int c2 = 1;
-
-			if (compare == 0) {
-				if (Array[oldIdx] == newRecord) {
-					// we deal with the same record that didn't change
-					// in the context of current index.
-					// so , do nothing.
-					return;
-				}
-			}
-			else {
-				if ((_hasDuplicates == IndexDuplicatesState.True)) {
-					if (oldIdx > 0) {
-						c1 = Key.CompareRecords(Array[oldIdx - 1],newRecord);
-					}
-					if (oldIdx < Size - 1) {
-						c2 = Key.CompareRecords(Array[oldIdx + 1],newRecord);
-					}
-
-					if ((c1 == 0 ^ c2 == 0) && compare != 0) {
-						_hasDuplicates = IndexDuplicatesState.Unknown;
-					}
-				}
-			}
-			
-			if ((oldIdx == 0 && compare > 0) || (oldIdx == (Size - 1) && compare < 0) || (compare == 0)) {
-				// no need to switch cells
-				newIdx = oldIdx;
-			}
-			else {
-				if (compare < 0) {
-					// search after the old place
-					start = oldIdx + 1;
-					end = Size - 1;
-				}
-				else {
-					// search before the old palce
-					start = 0;
-					end = oldIdx - 1;
-				}
-
-				newIdx = LazyBinarySearch(Array,start,end,newRecord);					
-
-				if (oldIdx < newIdx) {
-					System.Array.Copy(Array,oldIdx + 1,Array,oldIdx,newIdx - oldIdx);
-					if (Key.CompareRecords (Array [newIdx], newRecord) > 0)
-						--newIdx;
-				}
-				else if (oldIdx > newIdx){
-					System.Array.Copy(Array,newIdx,Array,newIdx + 1,oldIdx - newIdx);
-					if (Key.CompareRecords (Array [newIdx], newRecord) < 0)
-						++newIdx;
-				}
-			}			
-			Array[newIdx] = newRecord;
-
-			if (compare != 0) {
-				if (!(_hasDuplicates == IndexDuplicatesState.True)) {
-					if (newIdx > 0) {
-						c1 = Key.CompareRecords(Array[newIdx - 1],newRecord);
-					}
-					if (newIdx < Size - 1) {
-						c2 = Key.CompareRecords(Array[newIdx + 1],newRecord);
-					}
-
-					if (c1 == 0 || c2 == 0) {
-						_hasDuplicates = IndexDuplicatesState.True;
-					}
-				}
-			}
+			Container.Delete (oldRecord);
+			Container.Add (newRecord);
 		}
 
-		internal void Add(DataRow row) {
-			Add(row, Key.GetRecord(row));
-		}
-
-		private void Add(DataRow row,int newRecord)
+		internal void Add (DataRow row) 
 		{
-			int newIdx;
-
-			if (newRecord < 0 || !Key.CanContain (newRecord))
-				return;
-
-			if (Size == 0) {
-				newIdx = 0;
-			}
-			else {
-				newIdx = LazyBinarySearch(Array,0,Size - 1,newRecord);
-				// if newl value is greater - insert afer old value
-				// else - insert before old value
-				if (Key.CompareRecords(Array[newIdx],newRecord) < 0) {
-					newIdx++;
-				}
-			}
-					
-			Insert(newIdx,newRecord);
-
-			int c1 = 1;
-			int c2 = 1;
-			if (!(_hasDuplicates == IndexDuplicatesState.True)) {
-				if (newIdx > 0) {
-					c1 = Key.CompareRecords(Array[newIdx - 1],newRecord);
-				}
-				if (newIdx < Size - 1) {
-					c2 = Key.CompareRecords(Array[newIdx + 1],newRecord);
-				}
-
-				if (c1 == 0 || c2 == 0) {
-					_hasDuplicates = IndexDuplicatesState.True;
-				}
-			}
+			Container.Add (Key.GetRecord(row));
 		}
 
-		private void Insert(int index,int r)
+		internal void AddRef ()
 		{
-			if (Array.Length == Size) {
-				int[] tmp = (Size == 0) ? new int[16] : new int[Size << 1];
-				System.Array.Copy(Array,0,tmp,0,index);
-				tmp[index] = r;
-				System.Array.Copy(Array,index,tmp,index + 1,Size - index);
-				_array = tmp;
-			}
-			else {
-				System.Array.Copy(Array,index,Array,index + 1,Size - index);
-				Array[index] = r;
-			}
-			_size++;
-		}
-
-		private void MergeSort(int[] to, int length)
-        {
-            int[] from = new int[length];
-            System.Array.Copy(to, 0, from, 0, from.Length);
-
-            MergeSort(from, to, 0, from.Length);
-        }
-
-        private void MergeSort(int[] from, int[] to,int p, int r)
-        {
-            int q = (p + r) >> 1;
-	        if (q == p) {
-                return;
-            }        
-
-            MergeSort(to, from, p, q);
-            MergeSort(to, from, q, r);
-
-            // merge
-            for (int middle = q, current = p;;) {
-				int res = Key.CompareRecords(from[p],from[q]);
-                if (res > 0) {
-                    to[current++] = from[q++];
-
-                    if (q == r) {
-                        while( p < middle) {
-                                to[current++] = from[p++];
-						}
-                        break;
-                    }
-                }
-                else {
-
-					if (res == 0) {
-						_hasDuplicates = IndexDuplicatesState.True;
-					}
-
-                    to[current++] = from[p++];
-
-                    if (p == middle) {
-                        while( q < r) {
-                                to[current++] = from[q++];
-						}
-                        break;
-                    }
-                }
-            }
-		}
-
-		private void QuickSort(int[] a,int p,int r)
-		{
-			if (p < r) {
-				int q = Partition(a,p,r);
-				QuickSort(a,p,q);
-				QuickSort(a,q+1,r);
-			}
-		}
-
-		private int Partition(int[] a,int p,int r)
-		{
-			int x = a[p];
-			int i = p - 1;
-			int j = r + 1;
-
-			while(true) {
-				// decrement upper limit while values are greater then border value
-				do {
-					j--;
-				}
-				while(Key.CompareRecords(a[j],x) > 0);	//while(a[j] > x);
-
-				do {
-					i++;
-				}
-				while(Key.CompareRecords(a[i],x) < 0);	//while(a[i] < x);
-				
-				if (i<j) {
-					int tmp = a[j];
-					a[j] = a[i];
-					a[i] = tmp;
-				}
-				else {
-					return j;
-				}
-			}
-		}
-
-		private int BinarySearch(int[] a, int p, int r,int b)
-		{
-			int i = LazyBinarySearch(a,p,r,b);
-
-			return (Key.CompareRecords(a[i],b) == 0) ? i : -1;
-		}
-
-		// Lazy binary search only returns the cell number the search finished in,
-		// but does not checks that the correct value was actually found
-		private int LazyBinarySearch(int[] a, int p, int r,int b)
-		{
-			if ( p == r ) {
-				return p;
-			}
-
-			int q = (p+r) >> 1;
-
-			int compare = Key.CompareRecords(a[q],b);
-			if (compare < 0) { // if (a[q] < b) {
-				return LazyBinarySearch(a,q+1,r,b);
-			}
-			else if (compare > 0) { // a[q] > b
-				return LazyBinarySearch(a,p,q,b);
-			}	
-			else { // a[q] == b
-				return q;
-			}
-		}
-
-		internal void AddRef()
-		{
 			_refCount++;
 		}
 
-		internal void RemoveRef()
+		internal void RemoveRef ()
 		{
 			_refCount--;
 		}
 
-		/*
-		// Prints indexes. For debugging.
 		internal void Print ()
-                {
-                        for (int i=0; i < Size; i++) {
-                                Console.Write ("Index {0} record {1}: ", i, Array [i]);
-                                for (int j=0; j < Key.Table.Columns.Count; j++) {
-                                        DataColumn col = Key.Table.Columns [j];
-                                        if (Array [i] >= 0)
-                                                Console.Write ("{0,15} ", col [Array [i]]);
-                                }
-                                Console.WriteLine ();
-                        }
-                }
-		*/
-		
+		{
+			Console.WriteLine ( "################################");
+			Container.Print (Container.Root);
+			Console.WriteLine ( "################################");
+		}
 		#endregion // Methods
 	}
 }
Index: System.Data.dll.sources
===================================================================
--- System.Data.dll.sources	(revision 62794)
+++ System.Data.dll.sources	(working copy)
@@ -167,6 +167,8 @@
 System.Data.Common/GroupByBehavior.cs
 System.Data.Common/IdentifierCase.cs
 System.Data.Common/Index.cs
+System.Data.Common/RBTree.cs
+System.Data.Common/RBNode.cs
 System.Data.Common/Key.cs
 System.Data.Common/PermissionHelper.cs
 System.Data.Common/RecordCache.cs
Index: System.Data/DataView.cs
===================================================================
--- System.Data/DataView.cs	(revision 62794)
+++ System.Data/DataView.cs	(working copy)
@@ -216,7 +216,7 @@
 		// the compiler creates a DefaultMemeberAttribute from
 		// this IndexerNameAttribute
 		[System.Runtime.CompilerServices.IndexerName("Item")]
-		public DataRowView this[int recordIndex] {
+		public DataRowView this [int recordIndex] {
 			[MonoTODO]
 			get {
 				if (recordIndex > rowCache.Length)
@@ -896,10 +896,10 @@
 				Index.Reset();
 			}
 
-			int[] records = Index.GetAll();
+			DataRow[] records = Index.GetAllRows ();
 
 			if (records != null) {
-				InitDataRowViewArray(records,Index.Size);
+				InitDataRowViewArray (records, Index.Size);
 			}
 			else {
 				rowCache = new DataRowView[0];
@@ -931,6 +931,24 @@
 			}
 		}
 
+		private void InitDataRowViewArray(DataRow[] records,int size) 
+		{
+			if (_lastAdded != null) {
+				rowCache = new DataRowView[size + 1];	
+			}
+			else {
+				rowCache = new DataRowView[size];			
+			}
+
+			for (int r = 0; r < size; r++) {
+				rowCache[r] = new DataRowView (this, records[r],r);
+			}
+
+			if(_lastAdded != null) {
+				rowCache[size] = new DataRowView(this,_lastAdded,size);
+			}
+		}
+
 		[MonoTODO]
 		PropertyDescriptorCollection ITypedList.GetItemProperties (PropertyDescriptor[] listAccessors) 
 		{
@@ -1253,13 +1271,14 @@
 			return new RelatedDataView(relation.ChildColumns,keyValues);
 		}
 
-		private int GetRecord(int index) {
+		private int GetRecord(int index) 
+		{
 			if (index < 0 || index >= Count)
 				throw new IndexOutOfRangeException(String.Format("There is no row at position {0}.", index));
 
 			return(index == Index.Size) ?
 				_lastAdded.IndexFromVersion(DataRowVersion.Default) :
-				Index.IndexToRecord(index);
+				Index.Key.GetRecord (rowCache [index].Row);
 		}
 
 		internal DataRowVersion GetRowVersion(int index) {
Index: System.Data/ForeignKeyConstraint.cs
===================================================================
--- System.Data/ForeignKeyConstraint.cs	(revision 62794)
+++ System.Data/ForeignKeyConstraint.cs	(working copy)
@@ -444,7 +444,7 @@
 			_validateColumns(_parentColumns, _childColumns);
 			
 			//we must have a unique constraint on the parent
-			_ensureUniqueConstraintExists(collection, _parentColumns);
+			_ensureUniqueConstraintExists (collection, _parentColumns);
 			
 			if ( (Table.DataSet != null && Table.DataSet.EnforceConstraints)
 			     || (Table.DataSet == null && Table.EnforceConstraints)) {
Index: System.Data/DataRow.cs
===================================================================
--- System.Data/DataRow.cs	(revision 62794)
+++ System.Data/DataRow.cs	(working copy)
@@ -708,6 +708,7 @@
 				CheckChildRows(DataRowAction.Delete);
 				break;
 			}
+
 			if (Current >= 0) {
 				int current = Current;
 				DataRowState oldState = RowState;
@@ -883,9 +884,8 @@
 				//FIXME : ideally  indexes shouldnt be maintained during dataload.But this needs to
 				//be implemented at multiple places.For now, just maintain the index.
 				//if (!Table._duringDataLoad) {
-					foreach(Index index in Table.Indexes) {
-						index.Update(this,oldRecord, DataRowVersion.Current, oldState);
-					}
+					foreach(Index index in Table.Indexes)
+						index.Update(this, oldRecord, DataRowVersion.Current, oldState);
 				//}
 
 				try {
@@ -1207,16 +1207,16 @@
 			int numColumn = parentColumns.Length;
 
 			int curIndex = IndexFromVersion(version);
-					int tmpRecord = relation.ParentTable.RecordCache.NewRecord();
-						for (int i = 0; i < numColumn; i++) {
-							// according to MSDN: the DataType value for both columns must be identical.
-							parentColumns[i].DataContainer.CopyValue(childColumns[i].DataContainer, curIndex, tmpRecord);
-						}
+			int tmpRecord = relation.ParentTable.RecordCache.NewRecord();
+			for (int i = 0; i < numColumn; i++) {
+				// according to MSDN: the DataType value for both columns must be identical.
+				parentColumns[i].DataContainer.CopyValue(childColumns[i].DataContainer, curIndex, tmpRecord);
+			}
 
 			try {
 				Index index = relation.ParentTable.FindIndex(parentColumns);
 				if (index != null) { // get the parent rows from the index
-					int[] parentRecords = index.FindAll(tmpRecord);
+					int[] parentRecords = index.FindAll (tmpRecord);
 					for (int i = 0; i < parentRecords.Length; i++) {
 						rows.Add (parentColumns[i].Table.RecordCache[parentRecords[i]]);
 					}
Index: System.Data/DataTable.cs
===================================================================
--- System.Data/DataTable.cs	(revision 62794)
+++ System.Data/DataTable.cs	(working copy)
@@ -687,8 +687,8 @@
 			bool rowsExist = false;
 			Index indx = this.FindIndex(columns);
 
-			if (indx != null) { // lookup for a row in index			
-				rowsExist = (indx.Find(index) != -1);
+			if (indx != null) { // lookup for a row in index
+				rowsExist = (indx.Find (index) != -1);
 			} 
 			else { 
 				// we have to perform full-table scan
@@ -1586,10 +1586,12 @@
 
 			Index index = GetIndex(columns, sorts, recordStates, filter, false);
 
+			DataRow[] dataRows = index.GetAllRows (); //NewRowArray(index.Size);
+			/*
 			int[] records = index.GetAll();
-			DataRow[] dataRows = NewRowArray(index.Size);
 			for (int i = 0; i < dataRows.Length; i++)
 				dataRows[i] = RecordCache[records[i]];
+				*/
 
 			return dataRows;
 		}
@@ -2067,5 +2069,11 @@
 		internal void ResetPropertyDescriptorsCache() {
 			_propertyDescriptorsCache = null;
 		}
+
+		public void PrintIndex ()
+		{
+			foreach (Index indx in Indexes)
+				indx.Print ();
+		}
 	}
 }