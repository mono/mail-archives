Index: class.c
===================================================================
RCS file: /cvs/public/mono/mono/metadata/class.c,v
retrieving revision 1.245
diff -u -p -r1.245 class.c
--- class.c	10 Mar 2004 00:50:12 -0000	1.245
+++ class.c	14 Mar 2004 22:43:33 -0000
@@ -36,8 +36,10 @@
 MonoStats mono_stats;
 
 gboolean mono_print_vtable = FALSE;
+gboolean mono_print_class_layout = FALSE;
 
 static MonoClass * mono_class_create_from_typedef (MonoImage *image, guint32 type_token);
+static void print_class_layout (MonoClass* klass);
 
 void (*mono_debugger_class_init_func) (MonoClass *klass) = NULL;
 
@@ -477,53 +479,50 @@ class_compute_field_layout (MonoClass *c
 
 	mono_class_layout_fields (class);
 }
-
+/*
+ * The smallest integer n such that n >= value && n % align == 0
+ */
+#define ALIGN(value, align) (((value) + ((align) - 1)) & ~((align) - 1))
 void
 mono_class_layout_fields (MonoClass *class)
 {
 	int i;
 	const int top = class->field.count;
 	guint32 layout = class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK;
-	guint32 pass, passes, real_size;
-	gboolean gc_aware_layout = FALSE;
+	guint32 pass, real_size;
 	MonoClassField *field;
+	MonoClassField *static_field_with_0_offset = NULL;
 
 	/*
-	 * Enable GC aware auto layout: in this mode, reference
-	 * fields are grouped together inside objects, increasing collector 
-	 * performance.
-	 * Requires that all classes whose layout is known to native code be annotated
-	 * with [StructLayout (LayoutKind.Sequential)]
+	 * Corlib is missing [StructLayout (LayoutKind.Sequential)] on many
+	 * fields that are accessed from native code. If we place the attribute
+	 * on all such classes, we could remove this check. This would increase perf
+	 * because we would be better able to lay out other corlib classes.
 	 */
-	 /* corlib is missing [StructLayout] directives in many places */
-	if (layout == TYPE_ATTRIBUTE_AUTO_LAYOUT) {
-		if (class->image != mono_defaults.corlib)
-			gc_aware_layout = TRUE;
-	}
+	if (layout == TYPE_ATTRIBUTE_AUTO_LAYOUT && class->image == mono_defaults.corlib)
+		layout = TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT;
 
 	/*
 	 * Compute field layout and total size (not considering static fields)
 	 */
-
 	switch (layout) {
 	case TYPE_ATTRIBUTE_AUTO_LAYOUT:
-	case TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT:
 
-		if (gc_aware_layout)
-			passes = 2;
-		else
-			passes = 1;
-
-		if (layout != TYPE_ATTRIBUTE_AUTO_LAYOUT)
-			passes = 1;
-
-		if (class->parent)
-			real_size = class->parent->instance_size;
-		else
-			real_size = sizeof (MonoObject);
+		/* AUTO LAYOUT
+		 * One of the benefits of a managed world is that we can control
+		 * the layout of objects to a greater extent than even a compiler.
+		 * 
+		 * We take advantage of this ability in two ways:
+		 *      * Reference objects are grouped, giving better GC performance
+		 *      * Other members are grouped as so to be packed in the smallest
+		 *        space possible, given alignment requirements.
+		 */
+	
+		real_size = class->parent ? class->parent->instance_size : sizeof (MonoObject);
 
-		for (pass = 0; pass < passes; ++pass) {
-			for (i = 0; i < top; i++){
+		/* 5 passes: one for references, one each for objects of align {1, 2, 4, 8} */
+		for (pass = 0; pass < 5; ++pass) {
+			for (i = 0; i < top; i++) {
 				int size, align;
 				field = &class->fields [i];
 
@@ -531,48 +530,77 @@ mono_class_layout_fields (MonoClass *cla
 					continue;
 				if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
 					continue;
-
-				if (gc_aware_layout) {
-					/* 
-					 * We process fields with reference type in the first pass,
-					 * and fields with non-reference type in the second pass.
-					 * We use IS_POINTER instead of IS_REFERENCE because in
-					 * some internal structures, we store GC_MALLOCed memory
-					 * in IntPtr fields...
-					 */
-					if (MONO_TYPE_IS_POINTER (field->type)) {
-						if (pass == 1)
-							continue;
-					} else {
-						if (pass == 0)
-							continue;
-					}
-				}
-
+				
+				/* already done
+				 * Note that a field cant have an offset of 0, because
+				 * that is part of the object header. So this is safe
+				 */
+				if (field->offset)
+					continue;
+				
 				if ((top == 1) && (class->instance_size == sizeof (MonoObject)) &&
 					(strcmp (field->name, "$PRIVATE$") == 0)) {
 					/* This field is a hack inserted by MCS to empty structures */
 					continue;
 				}
 
+				/* 
+				 * We process fields with reference type in the first pass,
+				 * and fields with non-reference type in the second pass.
+				 * We use IS_POINTER instead of IS_REFERENCE because in
+				 * some internal structures, we store GC_MALLOCed memory
+				 * in IntPtr fields...
+				 */
+				if (pass == 0 && !MONO_TYPE_IS_POINTER (field->type))
+					continue;
+
 				size = mono_type_size (field->type, &align);
-			
-				/* FIXME (LAMESPEC): should we also change the min alignment according to pack? */
-				align = class->packing_size ? MIN (class->packing_size, align): align;
+				
+				/* on pass 1, we do objects with alignment >= 8, on 2 >= 4, etc */
+				if (pass > 0 && align < (1 << (4 - pass)))
+					continue;
+				
 				class->min_align = MAX (align, class->min_align);
-				field->offset = real_size;
-				field->offset += align - 1;
-				field->offset &= ~(align - 1);
+				field->offset = ALIGN (real_size, align);
 				real_size = field->offset + size;
 			}
 
-			class->instance_size = MAX (real_size, class->instance_size);
-       
-			if (class->instance_size & (class->min_align - 1)) {
-				class->instance_size += class->min_align - 1;
-				class->instance_size &= ~(class->min_align - 1);
+		}
+
+		class->instance_size = ALIGN (MAX (real_size, class->instance_size), class->min_align);
+		
+		break;
+	
+	case TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT:
+		
+		real_size = class->parent ? class->parent->instance_size : sizeof (MonoObject);
+		
+		for (i = 0; i < top; i++) {
+			int size, align;
+			field = &class->fields [i];
+
+			if (mono_field_is_deleted (field))
+				continue;
+			if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
+				continue;
+
+			if ((top == 1) && (class->instance_size == sizeof (MonoObject)) &&
+				(strcmp (field->name, "$PRIVATE$") == 0)) {
+				/* This field is a hack inserted by MCS to empty structures */
+				continue;
 			}
+
+			size = mono_type_size (field->type, &align);
+		
+			/* FIXME (LAMESPEC): should we also change the min alignment according to pack? */
+			align = class->packing_size ? MIN (class->packing_size, align): align;
+			class->min_align = MAX (align, class->min_align);
+			field->offset = ALIGN (real_size, align);
+			real_size = field->offset + size;
 		}
+
+		class->instance_size = ALIGN (MAX (real_size, class->instance_size), class->min_align);
+
 		break;
 	case TYPE_ATTRIBUTE_EXPLICIT_LAYOUT:
 		real_size = 0;
@@ -614,21 +642,111 @@ mono_class_layout_fields (MonoClass *cla
 	/*
 	 * Compute static field layout and size
 	 */
-	for (i = 0; i < top; i++){
-		int size, align;
-		field = &class->fields [i];
+	
+	/* 4 passes: one each for objects of align {1, 2, 4, 8} */
+	for (pass = 0; pass < 4; ++pass) {
+		for (i = 0; i < top; i++){
+			int size, align;
+			field = &class->fields [i];
+				
+			if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
+				continue;
+			if (field->type->attrs & FIELD_ATTRIBUTE_LITERAL)
+				continue;
+			if (mono_field_is_deleted (field))
+				continue;
 			
-		if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
-			continue;
-		if (mono_field_is_deleted (field))
+			/* already done */
+			if (field->offset)
+				continue;
+			
+			size = mono_type_size (field->type, &align);
+			/* on pass 1, we do objects with alignment >= 8, on 2 >= 4, etc */
+			if (align < (1 << (3 - pass)))
+				continue;
+			field->offset = ALIGN (class->class_size, align);
+			class->class_size = field->offset + size;
+			if (!field->offset) {
+				/*
+				 * This is a total hack ;-). In Auto Layout, we know there is
+				 * no field at offset 0, because that is the object header. However
+				 * here, there will always be a field at offset 0 (the first one).
+				 * in order to be able to do if (field->offset) continue, we need
+				 * to fake having an offset.
+				 */
+				static_field_with_0_offset = field;
+				field->offset = 0xdeadbeef;
+			}
+		}
+	}
+	
+	if (static_field_with_0_offset)
+		static_field_with_0_offset->offset = 0;
+	
+	if (mono_print_class_layout)
+		print_class_layout (class);
+}
+
+static int cmp_field (MonoClassField* a, MonoClassField* b)
+{
+	return a->offset - b->offset;
+}
+
+static void print_class_layout (MonoClass *klass)
+{
+	const char* fmtstring = "    %3d - %3d %s (%s)\n";
+	const int top = klass->field.count;
+	int i;
+	MonoClassField* field;
+	MonoClassField* fields;
+	
+	printf ("Layout for %s.%s\n", klass->name_space, klass->name);
+	
+	printf (" Instance:\n");
+	
+	if (klass->parent)
+		printf (fmtstring, 0, klass->parent->instance_size, "<parent>", klass->parent->name);
+	else
+		printf (fmtstring, 0, sizeof (MonoObject), "<object header>", "Object");
+	
+	fields = g_memdup (klass->fields, top * sizeof (MonoClassField));
+	qsort (fields, top, sizeof (MonoClassField), cmp_field);
+	
+	for (i = 0; i < top; i++) {
+		char* nm;
+		int size, dummy;
+		field = &fields [i];
+		
+		if (mono_field_is_deleted (field) || (field->type->attrs & FIELD_ATTRIBUTE_STATIC))
 			continue;
+		
+		size = mono_type_size (field->type, &dummy);
+		nm = mono_type_get_name (field->type);
+		printf (fmtstring, field->offset, field->offset + size, field->name, nm);
+		g_free (nm);
+	}
+	
+	if (klass->class_size) {
+		printf (" Static:\n");
+		for (i = 0; i < top; i++) {
+			char* nm;
+			int size, align;
+			field = &fields [i];
 			
-		size = mono_type_size (field->type, &align);
-		field->offset = class->class_size;
-		field->offset += align - 1;
-		field->offset &= ~(align - 1);
-		class->class_size = field->offset + size;
+			if (mono_field_is_deleted (field) || !(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
+				continue;
+			if (field->type->attrs & FIELD_ATTRIBUTE_LITERAL)
+				continue;
+			
+			size = mono_type_size (field->type, &align);
+			nm = mono_type_get_name (field->type);
+			printf (fmtstring, field->offset, field->offset + size, field->name, nm);
+			g_free (nm);
+		}
 	}
+	printf ("\n");
+	
+	g_free (fields);
 }
 
 static void
Index: class.h
===================================================================
RCS file: /cvs/public/mono/mono/metadata/class.h,v
retrieving revision 1.126
diff -u -p -r1.126 class.h
--- class.h	10 Mar 2004 22:14:22 -0000	1.126
+++ class.h	14 Mar 2004 22:43:33 -0000
@@ -10,13 +10,9 @@
 #define MONO_DEFAULT_SUPERTABLE_SIZE 6
 
 extern gboolean mono_print_vtable;
+extern gboolean mono_print_class_layout;
 typedef struct MonoVTable MonoVTable;
 
-typedef struct {
-	MonoTypeEnum type;
-	gpointer value;
-} MonoConstant;
-
 /*
  * MonoClassField is just a runtime representation of the metadata for
  * field, it doesn't contain the data directly.  Static fields are
@@ -44,8 +40,10 @@ typedef struct {
 	const char      *name;
 
 	/*
-	 * Pointer to the data (from the RVA address, valid only for
-	 * fields with the has rva flag).
+	 * If the field is constant, pointer to the metadata constant
+	 * value.
+	 * If the field has an RVA flag, pointer to the data.
+	 * Else, invalid.
 	 */
 	const char      *data;
 
@@ -53,10 +51,9 @@ typedef struct {
 	MonoClass       *parent;
 
 	/*
-	 * If the field is constant, pointer to the metadata where the
-	 * constant value can be loaded. Initialized lazily during vtable creation.
+	 * If the field is constant, the type of the field.
 	 */
-	MonoConstant    *def_value;
+	MonoTypeEnum     def_type;
 } MonoClassField;
 
 /* a field is ignored if it's named "_Deleted" and it has the specialname and rtspecialname flags set */
Index: icall.c
===================================================================
RCS file: /cvs/public/mono/mono/metadata/icall.c,v
retrieving revision 1.431
diff -u -p -r1.431 icall.c
--- icall.c	11 Mar 2004 18:01:25 -0000	1.431
+++ icall.c	14 Mar 2004 22:43:35 -0000
@@ -2319,15 +2319,15 @@ ves_icall_get_enum_info (MonoReflectionT
 		if (mono_field_is_deleted (field))
 			continue;
 		mono_array_set (info->names, gpointer, j, mono_string_new (domain, field->name));
-		if (!field->def_value) {
-			field->def_value = g_new0 (MonoConstant, 1);
+
+		if (!field->data) {
 			crow = mono_metadata_get_constant_index (enumc->image, MONO_TOKEN_FIELD_DEF | (i+enumc->field.first+1), crow + 1);
-			field->def_value->type = mono_metadata_decode_row_col (&enumc->image->tables [MONO_TABLE_CONSTANT], crow-1, MONO_CONSTANT_TYPE);
+			field->def_type = mono_metadata_decode_row_col (&enumc->image->tables [MONO_TABLE_CONSTANT], crow-1, MONO_CONSTANT_TYPE);
 			crow = mono_metadata_decode_row_col (&enumc->image->tables [MONO_TABLE_CONSTANT], crow-1, MONO_CONSTANT_VALUE);
-			field->def_value->value = (gpointer)mono_metadata_blob_heap (enumc->image, crow);
+			field->data = (gpointer)mono_metadata_blob_heap (enumc->image, crow);
 		}
 
-		p = field->def_value->value;
+		p = field->data;
 		len = mono_metadata_decode_blob_size (p, &p);
 		switch (enumc->enum_basetype->type) {
 		case MONO_TYPE_U1:
Index: object.c
===================================================================
RCS file: /cvs/public/mono/mono/metadata/object.c,v
retrieving revision 1.203
diff -u -p -r1.203 object.c
--- object.c	5 Mar 2004 03:46:04 -0000	1.203
+++ object.c	14 Mar 2004 22:43:35 -0000
@@ -38,6 +38,9 @@
 #define CREATION_SPEEDUP 1
 #endif
 
+static void
+get_default_field_value (MonoDomain* domain, MonoClassField *field, void *value);
+
 void
 mono_runtime_object_init (MonoObject *this)
 {
@@ -368,9 +371,8 @@ mono_class_vtable (MonoDomain *domain, M
 {
 	MonoVTable *vt = NULL;
 	MonoClassField *field;
-	const char *p;
 	char *t;
-	int i, len;
+	int i;
 	guint32 vtable_size;
 	guint32 cindex;
 	guint32 constant_cols [MONO_CONSTANT_SIZE];
@@ -452,9 +454,12 @@ mono_class_vtable (MonoDomain *domain, M
 				continue;
 			}
 		}
+		
 		if ((field->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {
 			MonoClass *fklass = mono_class_from_mono_type (field->type);
 			t = (char*)vt->data + field->offset;
+			g_assert (!(field->type->attrs & FIELD_ATTRIBUTE_HAS_DEFAULT));
+			
 			if (fklass->valuetype) {
 				memcpy (t, field->data, mono_class_value_size (fklass, NULL));
 			} else {
@@ -466,78 +471,20 @@ mono_class_vtable (MonoDomain *domain, M
 		}
 		if (!(field->type->attrs & FIELD_ATTRIBUTE_HAS_DEFAULT))
 			continue;
-
-		if (!field->def_value) {
+		
+		if (!field->data) {
 			cindex = mono_metadata_get_constant_index (class->image, MONO_TOKEN_FIELD_DEF | (i + 1), cindex + 1);
 			g_assert (cindex);
+			g_assert (!(field->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA));
 
 			mono_metadata_decode_row (&class->image->tables [MONO_TABLE_CONSTANT], cindex - 1, constant_cols, MONO_CONSTANT_SIZE);
-			field->def_value = g_new0 (MonoConstant, 1);
-			field->def_value->type = constant_cols [MONO_CONSTANT_TYPE];
-			field->def_value->value = (gpointer)mono_metadata_blob_heap (class->image, constant_cols [MONO_CONSTANT_VALUE]);
+			field->def_type = constant_cols [MONO_CONSTANT_TYPE];
+			field->data = (gpointer)mono_metadata_blob_heap (class->image, constant_cols [MONO_CONSTANT_VALUE]);
 		}
+		
+		if (!(field->type->attrs & FIELD_ATTRIBUTE_LITERAL))
+			get_default_field_value (domain, field, (char*)vt->data + field->offset);
 
-		p = field->def_value->value;
-		len = mono_metadata_decode_blob_size (p, &p);
-		t = (char*)vt->data + field->offset;
-		/* should we check that the type matches? */
-		switch (field->def_value->type) {
-		case MONO_TYPE_BOOLEAN:
-		case MONO_TYPE_U1:
-		case MONO_TYPE_I1:
-			*t = *p;
-			break;
-		case MONO_TYPE_CHAR:
-		case MONO_TYPE_U2:
-		case MONO_TYPE_I2: {
-			guint16 *val = (guint16*)t;
-			*val = read16 (p);
-			break;
-		}
-		case MONO_TYPE_U4:
-		case MONO_TYPE_I4: {
-			guint32 *val = (guint32*)t;
-			*val = read32 (p);
-			break;
-		}
-		case MONO_TYPE_U8:
-		case MONO_TYPE_I8: {
-			guint64 *val = (guint64*)t;
-			*val = read64 (p);
-			break;
-		}
-		case MONO_TYPE_R4: {
-			float *val = (float*)t;
-			readr4 (p, val);
-			break;
-		}
-		case MONO_TYPE_R8: {
-			double *val = (double*)t;
-			readr8 (p, val);
-			break;
-		}
-		case MONO_TYPE_STRING: {
-			gpointer *val = (gpointer*)t;
-#if G_BYTE_ORDER != G_LITTLE_ENDIAN
-			gunichar2 *copy = g_malloc (len);
-			int j;
-			for (j = 0; j < len/2; j++) {
-				copy [j] = read16 (p);
-				p += 2;
-			}
-			*val = mono_string_new_utf16 (domain, copy, len/2);
-			g_free (copy);
-#else
-			*val = mono_string_new_utf16 (domain, (const guint16*)p, len/2);
-#endif
-			break;
-		}
-		case MONO_TYPE_CLASS:
-			/* nothing to do, we malloc0 the data and the value can be 0 only */
-			break;
-		default:
-			g_warning ("type 0x%02x should not be in constant table", field->def_value->type);
-		}
 	}
 
 	vt->max_interface_id = class->max_interface_id;
@@ -953,6 +900,8 @@ mono_field_static_set_value (MonoVTable 
 	void *dest;
 
 	g_return_if_fail (field->type->attrs & FIELD_ATTRIBUTE_STATIC);
+	/* you cant set a constant! */
+	g_return_if_fail (!(field->type->attrs & FIELD_ATTRIBUTE_LITERAL));
 
 	dest = (char*)vt->data + field->offset;
 	set_value (field->type, dest, value, FALSE);
@@ -1039,6 +988,49 @@ mono_field_get_value_object (MonoDomain 
 	return o;
 }
 
+static void
+get_default_field_value (MonoDomain* domain, MonoClassField *field, void *value)
+{
+	const char *p = field->data;
+	g_return_if_fail (field->type->attrs & FIELD_ATTRIBUTE_HAS_DEFAULT);
+		
+	mono_metadata_decode_blob_size (p, &p);
+
+	switch (field->def_type) {
+	case MONO_TYPE_BOOLEAN:
+	case MONO_TYPE_U1:
+	case MONO_TYPE_I1:
+		*(guint8 *) value = *p;
+		break;
+	case MONO_TYPE_CHAR:
+	case MONO_TYPE_U2:
+	case MONO_TYPE_I2:
+		*(guint16*) value = read16 (p);
+		break;
+	case MONO_TYPE_U4:
+	case MONO_TYPE_I4:
+		*(guint32*) value = read32 (p);
+		break;
+	case MONO_TYPE_U8:
+	case MONO_TYPE_I8:
+		*(guint64*) value = read64 (p);
+		break;
+	case MONO_TYPE_R4:
+		readr4 (p, (float*) value);
+		break;
+	case MONO_TYPE_R8:
+		readr8 (p, (double*) value);
+		break;
+	case MONO_TYPE_STRING:
+		*(gpointer*) value = mono_ldstr_metdata_sig (domain, field->data);
+		break;
+	case MONO_TYPE_CLASS:
+		*(gpointer*) value = NULL;
+		break;
+	default:
+		g_warning ("type 0x%02x should not be in constant table", field->def_type);
+	}
+}
 
 void
 mono_field_static_get_value (MonoVTable *vt, MonoClassField *field, void *value)
@@ -1047,6 +1039,11 @@ mono_field_static_get_value (MonoVTable 
 
 	g_return_if_fail (field->type->attrs & FIELD_ATTRIBUTE_STATIC);
 
+	if (field->type->attrs & FIELD_ATTRIBUTE_LITERAL) {
+		get_default_field_value (vt->domain, field, value);
+		return;
+	}
+	
 	src = (char*)vt->data + field->offset;
 	set_value (field->type, value, src, TRUE);
 }
@@ -2231,16 +2228,27 @@ mono_string_intern (MonoString *str)
 MonoString*
 mono_ldstr (MonoDomain *domain, MonoImage *image, guint32 idx)
 {
-	const char *str, *sig;
-	MonoString *o;
-	size_t len2;
-
 	MONO_ARCH_SAVE_REGS;
 
 	if (image->dynamic)
 		return mono_lookup_dynamic_token (image, MONO_TOKEN_STRING | idx);
 	else
-		sig = str = mono_metadata_user_string (image, idx);
+		return mono_ldstr_metdata_sig (domain, mono_metadata_user_string (image, idx));
+}
+
+/*
+ * mono_ldstr_metdata_sig
+ * @domain: the domain for the string
+ * @sig: the signature of a metadata string
+ *
+ * returns a MonoString for a string stored in the metadata
+ */
+MonoString*
+mono_ldstr_metdata_sig (MonoDomain *domain, const char* sig)
+{
+	const char *str = sig;
+	MonoString *o;
+	size_t len2;
 
 	mono_domain_lock (domain);
 	if ((o = mono_g_hash_table_lookup (domain->ldstr_table, sig))) {
Index: object.h
===================================================================
RCS file: /cvs/public/mono/mono/metadata/object.h,v
retrieving revision 1.112
diff -u -p -r1.112 object.h
--- object.h	5 Mar 2004 03:46:04 -0000	1.112
+++ object.h	14 Mar 2004 22:43:35 -0000
@@ -416,6 +416,9 @@ MonoString*
 mono_ldstr                  (MonoDomain *domain, MonoImage *image, guint32 str_index);
 
 MonoString*
+mono_ldstr_metdata_sig      (MonoDomain *domain, const char* sig);
+
+MonoString*
 mono_string_is_interned     (MonoString *str);
 
 MonoString*
Index: reflection.c
===================================================================
RCS file: /cvs/public/mono/mono/metadata/reflection.c,v
retrieving revision 1.297
diff -u -p -r1.297 reflection.c
--- reflection.c	11 Mar 2004 00:45:03 -0000	1.297
+++ reflection.c	14 Mar 2004 22:43:36 -0000
@@ -6788,14 +6788,13 @@ fieldbuilder_to_mono_class_field (MonoCl
 	if (fb->def_value) {
 		MonoDynamicImage *assembly = (MonoDynamicImage*)klass->image;
 		field->type->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;
-		field->def_value = g_new0 (MonoConstant, 1);
-		idx = encode_constant (assembly, fb->def_value, &field->def_value->type);
+		idx = encode_constant (assembly, fb->def_value, &field->def_type);
 		/* Copy the data from the blob since it might get realloc-ed */
 		p = assembly->blob.data + idx;
 		len = mono_metadata_decode_blob_size (p, &p2);
 		len += p2 - p;
-		field->def_value->value = g_malloc (len);
-		memcpy (field->def_value->value, p, len);
+		field->data = g_malloc (len);
+		memcpy (field->data, p, len);
 	}
 
 	return field;
@@ -7243,14 +7242,13 @@ typebuilder_setup_fields (MonoClass *kla
 		if (fb->def_value) {
 			MonoDynamicImage *assembly = (MonoDynamicImage*)klass->image;
 			field->type->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;
-			field->def_value = g_new0 (MonoConstant, 1);
-			idx = encode_constant (assembly, fb->def_value, &field->def_value->type);
+			idx = encode_constant (assembly, fb->def_value, &field->def_type);
 			/* Copy the data from the blob since it might get realloc-ed */
 			p = assembly->blob.data + idx;
 			len = mono_metadata_decode_blob_size (p, &p2);
 			len += p2 - p;
-			field->def_value->value = g_malloc (len);
-			memcpy (field->def_value->value, p, len);
+			field->data = g_malloc (len);
+			memcpy (field->data, p, len);
 		}
 	}
 	mono_class_layout_fields (klass);
