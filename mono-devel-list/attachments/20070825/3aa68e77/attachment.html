<tt>
<br>
Thanks&nbsp;to&nbsp;help&nbsp;on&nbsp;this&nbsp;list&nbsp;I&amp;#39;ve&nbsp;come&nbsp;a&nbsp;long&nbsp;way&nbsp;in&nbsp;embedding&nbsp;mono&nbsp;into<br>
my&nbsp;C++&nbsp;application.&nbsp;During&nbsp;the&nbsp;transition&nbsp;of&nbsp;a&nbsp;very&nbsp;large<br>
application&nbsp;(25+&nbsp;yrs&nbsp;of&nbsp;C,&nbsp;Fortran,&nbsp;&amp;amp;&nbsp;C++)&nbsp;towards&nbsp;managed&nbsp;code,&nbsp;we<br>
will&nbsp;be&nbsp;adding&nbsp;new&nbsp;code&nbsp;in&nbsp;.NET&nbsp;languages,&nbsp;but&nbsp;needing&nbsp;to&nbsp;access&nbsp;these<br>
objects&nbsp;from&nbsp;C++&nbsp;fairly&nbsp;intimately.&nbsp;Therefore&nbsp;I&amp;#39;m&nbsp;looking&nbsp;at&nbsp;writing<br>
wrappers&nbsp;which&nbsp;expose&nbsp;CLR&nbsp;classes&nbsp;as&nbsp;C++&nbsp;classes&nbsp;--&nbsp;without&nbsp;resorting<br>
to&nbsp;(XP)COM&nbsp;or&nbsp;CORBA.&nbsp;I&nbsp;figure&nbsp;most&nbsp;of&nbsp;these&nbsp;can&nbsp;be&nbsp;auto-generated.&nbsp;I&nbsp;believe&nbsp;it<br>
will&nbsp;make&nbsp;sense&nbsp;to&nbsp;emit&nbsp;mono-embedding&nbsp;wrappers&nbsp;for&nbsp;Linux&nbsp;and&nbsp;Managed<br>
C++&nbsp;wrappers&nbsp;for&nbsp;Windows.&nbsp;If&nbsp;anyone&nbsp;else&nbsp;is&nbsp;interested&nbsp;(or&nbsp;has&nbsp;already<br>
undertaken!)&nbsp;such&nbsp;an&nbsp;effort,&nbsp;let&nbsp;me&nbsp;know.&nbsp;However&nbsp;I&amp;#39;m&nbsp;still&nbsp;looking&nbsp;at&nbsp;some&nbsp;marshalling&nbsp;issues.&lt;br&gt;<br>
<br>
&lt;br&gt;<br>
<br>
If&nbsp;I&nbsp;call&nbsp;.NET&nbsp;functions&nbsp;exclusively&nbsp;via&nbsp;the&nbsp;embedding&nbsp;reflection&nbsp;API,<br>
e.g.&nbsp;mono_runtime_invoke,&nbsp;and&nbsp;carefully&nbsp;call&nbsp;g_free&nbsp;on&nbsp;returned<br>
copies&nbsp;of&nbsp;things&nbsp;like&nbsp;strings,&nbsp;everything&nbsp;works&nbsp;fine,&nbsp;including&nbsp;managed&nbsp;exceptions.&nbsp;It&nbsp;seems<br>
that&amp;nbsp;&nbsp;by&nbsp;caching&nbsp;the&nbsp;reflected&nbsp;objects,&nbsp;e.g.&nbsp;MonoMethod*,&nbsp;performance<br>
is&nbsp;good.&lt;br&gt;<br>
<br>
&lt;br&gt;<br>
<br>
However&nbsp;I&nbsp;am&nbsp;having&nbsp;problems&nbsp;with&nbsp;delegates&nbsp;invoked&nbsp;across&nbsp;the&nbsp;barrier.<br>
They&nbsp;execute&nbsp;properly,&nbsp;but&nbsp;appear&nbsp;to&nbsp;leak&nbsp;memory,&nbsp;and&nbsp;I&nbsp;am&nbsp;not&nbsp;sure&nbsp;how<br>
to&nbsp;catch&nbsp;exceptions&nbsp;they&nbsp;might&nbsp;throw.&nbsp;For&nbsp;the&nbsp;majority&nbsp;of&nbsp;our&nbsp;interop,<br>
we&nbsp;can&nbsp;avoid&nbsp;attempting&nbsp;this&nbsp;scenario,&nbsp;but&nbsp;we&amp;#39;d&nbsp;like&nbsp;to&nbsp;investigate&nbsp;it<br>
so&nbsp;that&nbsp;we&nbsp;can&nbsp;provide&nbsp;managed&nbsp;callbacks&nbsp;for&nbsp;unmanaged&nbsp;code&nbsp;to&nbsp;call.&lt;br&gt;<br>
<br>
&lt;br&gt;<br>
<br>
In&nbsp;our&nbsp;C++,&nbsp;we&nbsp;define&nbsp;(using&nbsp;MSVC&nbsp;syntax&nbsp;for&nbsp;this&nbsp;prototype)&lt;br&gt;<br>
<br>
&lt;blockquote&gt;//&nbsp;function:&nbsp;string-&amp;gt;string&lt;br&gt;<br>
typedef&nbsp;char*&nbsp;(__stdcall&nbsp;*&nbsp;action_string)(char*);&lt;br&gt;&lt;br&gt;<br>
//&nbsp;managed&nbsp;code&nbsp;will&nbsp;stash&nbsp;a&nbsp;delegate&nbsp;here&nbsp;for&nbsp;use&nbsp;by&nbsp;unmanaged&nbsp;code&lt;br&gt;<br>
action_string&nbsp;_f_string;&lt;br&gt;<br>
extern&nbsp;&amp;quot;C&amp;quot;&nbsp;_declspec(dllexport)&nbsp;void&nbsp;__stdcall<br>
init_string(action_string&nbsp;f)&lt;br&gt;<br>
{&amp;nbsp;&nbsp;_f_string&nbsp;=f&nbsp;;&nbsp;}&lt;br&gt;<br>
&nbsp;&nbsp;&lt;br&gt;<br>
//&nbsp;the&nbsp;unmanged&nbsp;code&nbsp;actually&nbsp;calls&nbsp;this&nbsp;code,&nbsp;e.g.&nbsp;do_string(&amp;quot;hello&amp;quot;)&lt;br&gt;<br>
extern&nbsp;&amp;quot;C&amp;quot;&nbsp;_declspec(dllexport)&nbsp;char*&nbsp;__stdcall&nbsp;do_string(char*&nbsp;s);&lt;br&gt;<br>
&nbsp;&nbsp;{&amp;nbsp;&nbsp;return&nbsp;_f_string(s);&nbsp;}&lt;br&gt;<br>
&lt;/blockquote&gt;<br>
then&nbsp;in&nbsp;C#&nbsp;we&nbsp;write&lt;br&gt;<br>
&lt;blockquote&gt;//&nbsp;function:&nbsp;string-&amp;gt;string,&nbsp;equivalent&nbsp;to&nbsp;action_string&nbsp;above&lt;br&gt;<br>
public&nbsp;delegate&nbsp;string&nbsp;ActionString(string&nbsp;_);&lt;br&gt;<br>
&nbsp;&nbsp;&lt;br&gt;<br>
//&nbsp;the&nbsp;managed&nbsp;code&nbsp;we&amp;#39;ll&nbsp;be&nbsp;calling&nbsp;from&nbsp;unmanaged&nbsp;code&lt;br&gt;<br>
public&nbsp;static&nbsp;string&nbsp;Echo(string&nbsp;s)&nbsp;{&nbsp;return&nbsp;s+s;&nbsp;}&lt;br&gt;<br>
&nbsp;&nbsp;&lt;br&gt;<br>
//&nbsp;and&nbsp;the&nbsp;bootstrapper&lt;br&gt;<br>
[DllImport(&amp;quot;libhost&amp;quot;)]&nbsp;public&nbsp;static&nbsp;extern&nbsp;void&nbsp;init_string(ActionString&nbsp;s);&lt;br&gt;<br>
public&nbsp;static&nbsp;void&nbsp;Boot&nbsp;{&nbsp;init_string(Echo);&nbsp;}&lt;br&gt;<br>
&lt;/blockquote&gt;<br>
and&nbsp;again&nbsp;in&nbsp;C++,&nbsp;we&nbsp;can&nbsp;actually&nbsp;call&nbsp;the&nbsp;managed&nbsp;code&nbsp;like&nbsp;so&lt;br&gt;<br>
&lt;blockquote&gt;//&nbsp;find_method&nbsp;is&nbsp;just&nbsp;a&nbsp;shortcut&nbsp;using&nbsp;debug-helpers&lt;br&gt;<br>
MonoMethod&nbsp;*bootMethod&nbsp;=&nbsp;find_method(&amp;quot;Hello.World:Boot&amp;quot;,&nbsp;image);&lt;br&gt;<br>
&amp;nbsp;mono_runtime_invoke(bootMethod,&nbsp;NULL,&nbsp;NULL,&nbsp;NULL);&lt;br&gt;<br>
//&nbsp;now&nbsp;we&nbsp;have&nbsp;a&nbsp;function&nbsp;pointer&nbsp;we&nbsp;can&nbsp;call&lt;br&gt;<br>
char&nbsp;*result&nbsp;=&nbsp;do_string(&amp;quot;hello&amp;quot;);&lt;br&gt;<br>
g_free(result);&lt;br&gt;<br>
&lt;/blockquote&gt;<br>
Everything&nbsp;works.&nbsp;However,&nbsp;there&nbsp;appears&nbsp;to&nbsp;be&nbsp;a&nbsp;memory&nbsp;leak.&nbsp;I&nbsp;am&nbsp;not<br>
sure&nbsp;whether&nbsp;it&nbsp;is&nbsp;the&nbsp;input&nbsp;that&nbsp;is&nbsp;leaking&nbsp;(i.e.&nbsp;a&nbsp;copy&nbsp;of&amp;nbsp;<br>
char*&amp;quot;hello&amp;quot;&nbsp;turned&nbsp;into&nbsp;utf16&amp;quot;hello&amp;quot;),&nbsp;or&nbsp;if&nbsp;I&nbsp;am&nbsp;improperly&nbsp;freeing<br>
the&nbsp;output&nbsp;(which&nbsp;I&nbsp;must&nbsp;assume&nbsp;is&nbsp;a&nbsp;copied&nbsp;string)&nbsp;or&nbsp;something&nbsp;else<br>
in&nbsp;the&nbsp;internals.&nbsp;What&nbsp;is&nbsp;encouraging&nbsp;is&nbsp;that&nbsp;all&nbsp;the&nbsp;marshalling&nbsp;is<br>
correct,&nbsp;just&nbsp;leaky.&nbsp;Also,&nbsp;if&nbsp;the&nbsp;managed&nbsp;code&nbsp;throws&nbsp;an&nbsp;exception,&nbsp;the<br>
program&nbsp;prints&nbsp;an&nbsp;error&nbsp;message&nbsp;(&amp;quot;uncaught&nbsp;exception&amp;quot;)&nbsp;and&nbsp;hangs.&nbsp;I&nbsp;am<br>
not&nbsp;sure&nbsp;what&nbsp;I&nbsp;would&nbsp;have&nbsp;expected&nbsp;on&nbsp;the&nbsp;C++&nbsp;side,&nbsp;perhaps&nbsp;a&nbsp;C++<br>
exception,&nbsp;perhaps&nbsp;silence.&lt;br&gt;<br>
&lt;br&gt;<br>
&gt;From&nbsp;the&nbsp;fact&nbsp;that&nbsp;the&nbsp;function&nbsp;pointers&nbsp;work&nbsp;at&nbsp;all,&nbsp;I&nbsp;can&nbsp;tell&nbsp;a&nbsp;lot<br>
of&nbsp;thought&nbsp;has&nbsp;already&nbsp;gone&nbsp;into&nbsp;this&nbsp;PInvoke&nbsp;stuff.&nbsp;What&nbsp;am&nbsp;I&nbsp;missing<br>
on&nbsp;the&nbsp;garbage&nbsp;collection&nbsp;side?&nbsp;(And&nbsp;as&nbsp;soon&nbsp;as&nbsp;the&nbsp;strings&nbsp;work,&nbsp;I<br>
need&nbsp;to&nbsp;worry&nbsp;about&nbsp;making&nbsp;sure&nbsp;that&nbsp;managed&nbsp;delegate&nbsp;doesn&amp;#39;t&nbsp;move&nbsp;or<br>
get&nbsp;garbage&nbsp;collected!)&lt;br&gt;<br>
&lt;br&gt;<br>
Thanks&lt;br&gt;<br>
&lt;br&gt;<br>
Sebastian<br>

</tt>
