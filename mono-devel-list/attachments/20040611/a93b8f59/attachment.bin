? EnumBuilder.old.cs
? ebuilder.diff
Index: EnumBuilder.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Reflection.Emit/EnumBuilder.cs,v
retrieving revision 1.16
diff -u -r1.16 EnumBuilder.cs
--- EnumBuilder.cs	11 Jun 2004 02:03:15 -0000	1.16
+++ EnumBuilder.cs	11 Jun 2004 08:01:14 -0000
@@ -40,6 +40,30 @@
 namespace System.Reflection.Emit {
 	public sealed class EnumBuilder : Type {
 		CustomAttributeBuilder[] cattrs;
+		TypeBuilder enumBuilder;
+		Type underlyingType;
+		private static BindingFlags fieldBindingFlags;
+		private static FieldAttributes fieldAttributes;
+		private static Type int8, int16, int32, int64, uint8, uint16, uint32, uint64, enumType;
+
+		static EnumBuilder ()
+		{
+			int8 = typeof (System.SByte);
+			int16 = typeof (System.Int16);
+			int32 = typeof (System.Int32);
+			int64 = typeof (System.Int64);
+			uint8 = typeof (System.Byte);
+			uint16 = typeof (System.UInt16);
+			uint32 = typeof (System.UInt32);
+			uint64 = typeof (System.UInt64);
+			enumType = typeof (System.Enum);
+
+			fieldBindingFlags |= BindingFlags.Public | BindingFlags.NonPublic |
+				BindingFlags.Static | BindingFlags.Instance;
+			
+			fieldAttributes |= FieldAttributes.Public |
+				FieldAttributes.Static | FieldAttributes.Literal;
+                }
 
 		public override Assembly Assembly {
 			get { return null; }
@@ -91,16 +115,48 @@
 
 		internal EnumBuilder (ModuleBuilder mb, string name, TypeAttributes visibility, Type underlyingType)
 		{
+			if (name == null)
+				throw new ArgumentNullException ("name");
+			if (mb.GetType (name) != null)
+				throw new ArgumentException ("Type with the same name already defined", "name");	
+			if (underlyingType != int8 &&
+					underlyingType != int16 &&
+					underlyingType != int32 &&
+					underlyingType != int64 &&
+					underlyingType != uint8 &&
+					underlyingType != uint16 &&
+					underlyingType != uint32 &&
+					underlyingType != uint64)
+				throw new ArgumentException ("The underlying type is not valid for an enum", "underlyingType");
+
+			this.underlyingType = underlyingType;
+			visibility |= TypeAttributes.Sealed | TypeAttributes.Class;
+			enumBuilder = mb.DefineType (name, visibility, enumType);
+
+			enumBuilder.DefineField ("value__", underlyingType, 
+					FieldAttributes.Public | FieldAttributes.SpecialName |
+					FieldAttributes.RTSpecialName);
+		       
 		}
 
 		public Type CreateType ()
 		{
-			return null;
+			return enumBuilder.CreateType ();
 		}
 
 		public FieldBuilder DefineLiteral (string literalName, object literalValue)
 		{
-			return null;
+			if (literalValue.GetType () != underlyingType)
+				throw new ArgumentException ("Value type is different from previous declared type for this enum",
+						"literalValue");
+
+			if (enumBuilder.GetField (literalName, fieldBindingFlags) != null)
+				throw new ArgumentException ("Literal name already defined", "literalName");
+
+			FieldBuilder field = enumBuilder.DefineField (literalName, enumBuilder, fieldAttributes);
+			field.SetConstant (literalValue);
+			
+			return field;
 		}
 		protected override TypeAttributes GetAttributeFlagsImpl ()
 		{
